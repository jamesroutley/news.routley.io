<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bou.ke/blog/chromium-bug/">Original</a>
    <h1>Finding a Bug in Chromium</h1>
    
    <div id="readability-page-1" class="page"><div>
<div>
  
  <p>This week I’ve submitted <a href="https://issues.chromium.org/issues/415223370" target="_blank">a report</a> for a bug I found in Chromium, the first time I’ve done so. I wanted to show how I found the bug and to spread … to hopefully speed up the resolution of it.</p>

<p>At <a href="https://www.monumental.co" target="_blank">Monumental</a> we’ve building robots to automate construction, starting with masonry. At our company full-stack really means <em>full</em>-stack, it reaches from the hardware and electronics all the way to the front-end that designs the walls and controls the robots.</p>

<p><img src="https://bou.ke/images/atrium.png" alt="" loading="lazy"/></p><p>Our frontend is an Electron app called Atrium that we develop using a mix of TypeScript and Rust WASM code. We use Rust because it allows us to have a shared codebase between our frontend and backend—the ‘backend’ being the code that runs on the robots in this case. To use Rust from TypeScript we use <a href="https://rustwasm.github.io/wasm-bindgen/" target="_blank">wasm-bindgen</a>, which represents Rust objects as wrapped JS classes, essentially a pointer to some memory with generated methods.</p>

<p>To ensure Rust memory is released when the JS pointer to it is no longer referenced, wasm-bindgen uses the <a href="https://rustwasm.github.io/wasm-bindgen/reference/weak-references.html" target="_blank">Weak References</a> support in modern JS engines to register cleanup callbacks in a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry" target="_blank">FinalizationRegistry</a>. This allows you to register a function (a finalizer) that is called after an object is garbage collected.</p>

<p><img src="https://bou.ke/images/wasm-memory.png" alt="" loading="lazy"/></p><p>The problem we have is that sometimes our WASM memory starts rising and never falling again. Strangely it only happens sometimes and seemingly without any relation to the current page or what the operator was doing at the time. Looking closely at the metrics I realized the first crucial thing: once this runaway memory leak started happening, it would keep happening for a specific window, <strong>across reloads</strong>. The only way to resolve it would be to close the window and open a new one.</p>

<p><img src="https://bou.ke/images/wasm-allocations.png" alt="" loading="lazy"/></p><p>I kept adding more metrics around our WASM usage until I pinpointed the exact thing that was happening: at some point the JS engine would just stop calling finalizers. And this behavior persists across reloads.</p>

<h2 id="creating-a-reproduction">Creating a reproduction</h2>

<p>At this point I was quite sure I’d found a browser bug, because the behavior seemed to happen randomly and because of the persistence across reloads. Now I had to create a reproduction, which was a bit daunting because we have a complicated app using many browser features like workers, SharedArrayBuffers, who knows what underlying interaction causes this issue. And I had to reproduce it outside of the context of our Electron app, because it wouldn’t get accepted by Chromium otherwise. After some fiddling I managed to create a minimal reproduction, all you have to do is insert a lot of objects into a FinalizationRegistry and reload the tab a couple of times and then it mysteriously starts happening. This is the whole reproduction:</p>

<pre><code>let liveObjects = 0
let createdObjects = 0
let collectedObjects = 0

const registry = new FinalizationRegistry(() =&gt; {
    liveObjects--
    collectedObjects++
})

class TrackableObject {
    constructor(id) {
        this.id = id
        this.data = new Uint8Array(5_000)
    }
}

function createObject() {
    for (let i = 0; i &lt; 20_000; i++) {
        registry.register(new TrackableObject(i))
        createdObjects++
        liveObjects++
    }
}

setInterval(createObject, 1_000 / 60)

setTimeout(() =&gt; {
    if (collectedObjects &gt; 0) {
        window.location.reload()
    }
}, 3000)
</code></pre>

<p>After a couple of reloads (you can speed up the process by refreshing a couple times yourself) the <code>collectedObjects</code> value gets stuck at 0 and the runaway memory leak has manifested itself. You can try it <a href="https://bou.ke/blog/chromium-bug/repro.html">here</a>, it works in Chrome Canary as of May 2nd 2025 (version 138.0.7156.0).</p>

<h2 id="resolution">Resolution</h2>

<p>Usually when there’s a bug in open-source software I’d take a stab at resolving it myself, but Chromium is one of the most complicated pieces of software that’s our there, with over 30 million lines of code. This bug also smells a lot like a race condition, which are also hard to fix. So I’m just gonna hope <a href="https://issues.chromium.org/issues/415223370" target="_blank">submitting the bug to the bug tracker</a> will get it fixed in the not too distant future!</p>

<p>Does pushing the limits of what browser engines until they break excite you? <a href="https://www.monumental.co/jobs" target="_blank">Come work with me!</a></p>

  <p><span>May 2025</span></p>
</div>
</div></div>
  </body>
</html>
