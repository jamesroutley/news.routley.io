<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://biriukov.dev/docs/fd-pipe-session-terminal/0-sre-should-know-about-gnu-linux-shell-related-internals-file-descriptors-pipes-terminals-user-sessions-process-groups-and-daemons/">Original</a>
    <h1>GNU/Linux shell related internals</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><p>Despite the era of containers, virtualization, and the rising number of UI of all kinds, SREs often spend a significant part of their time in GNU/Linux shells. It could be debugging, testing, developing, or preparing the new infrastructure. It may be the good old <code>bash</code>, the more recent and fancy <code>zsh</code>, or even <code>fish</code> or <code>tcsh</code> with their interesting and unique features.</p><img alt="Learn Linux Internals" src="https://biriukov.dev/docs/fd-pipe-session-terminal/images/meme.jpg"/><p>But it is common nowadays how little people know about the internals of their shells, terminals, and relations between processes. All are taken primarily for granted without really thinking about such aspects.</p><p>Have you ever thought about how a shell pipe works, how pressing the <code>CTRL+C</code> combination delivers the interrupt signal to the currently running shell processes, or how <code>vim</code> rewrites the content of the console when you change the size of your terminal window?</p><p>I want to show you some indeed neat parts of pipes, file descriptors, shells, terminals, processes, jobs, and signals in this series of posts. We’ll touch on how all of them interact with each other to build a responsible, simple, and reliable environment. And all of this, of course, will be shown in the context of the Linux kernel, its internals, and various debugging tools and approaches.</p><p>We are going to play with file descriptors, pipes, different tools such as <code>nohup</code> and <code>pv</code>, experiment with background and foreground processes, understand how <code>tmux</code> gives us the ability to continue where we stopped, why and how the <code>CTRL+C</code> interrupts the currently running pipeline of commands and much much more. Also, we will use <code>strace</code> to trace syscalls, read the Linux kernel source code, and use <code>bpftrace</code> to get under the hood of arbitrary kernel functions.</p><h2 id="prepare-environment">Prepare environment
<a href="#prepare-environment">#</a></h2><p>During the series, I’ll mix <code>python</code> and <code>golang</code> for my examples. Also, we’ll need a file for our experiments. I use <code>/var/tmp/file1.db</code>. You can easily generate it using the following command:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ dd <span>if</span><span>=</span>/dev/random of<span>=</span>/var/tmp/file1.db count<span>=</span><span>100</span> bs<span>=</span>1M
</span></span></code></pre></div><h2 id="dive">Dive
<a href="#dive">#</a></h2><p>With all that said, let’s learn, experiment, and have fun.</p><a href="https://biriukov.dev/docs/fd-pipe-session-terminal/1-file-descriptor-and-open-file-description/">Read next chapter →</a></article></div></div></div>
  </body>
</html>
