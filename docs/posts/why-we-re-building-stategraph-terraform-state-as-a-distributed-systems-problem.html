<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stategraph.dev/blog/why-stategraph/">Original</a>
    <h1>Why We&#39;re Building Stategraph: Terraform State as a Distributed Systems Problem</h1>
    
    <div id="readability-page-1" class="page"><article>
        

        

        <section aria-labelledby="tldr-h">
            <strong id="tldr-h">TL;DR</strong>
            <div role="region" aria-label="Terminal output: TL;DR">
                
                <div>
                    <p><span>$</span> cat why-stategraph.tldr</p>
                    <p>• Terraform state shows distributed coordination issues but uses file primitives.</p>
                    <p>• File blob (100% read/lock) vs. change cone (~3%).</p>
                    <p>• Stategraph → graph state, ACID transactions, subgraph isolation.</p>
                </div>
            </div>
        </section>

        <p>The Terraform ecosystem has spent a decade working around a fundamental architectural mismatch: we&#39;re using filesystem semantics to solve a distributed systems problem. The result is predictable and painful.</p>

        <p>When we started building infrastructure automation at scale, we discovered that Terraform&#39;s state management exhibits all the classic symptoms of impedance mismatch between data representation and access patterns. Teams implement increasingly elaborate workarounds: state file splitting, wrapper orchestration, external locking mechanisms. These aren&#39;t solutions; they&#39;re evidence that we&#39;re solving the wrong problem.</p>

        <p>Stategraph addresses this by treating state for what it actually is: a directed acyclic graph of resources with partial update semantics, not a monolithic document.</p>

        <div>
            <h2>The Pathology of File-Based State</h2>

            <p>Terraform state, at its core, is a coordination problem. Multiple actors (engineers, CI systems, drift detection) need to read and modify overlapping subsets of infrastructure state concurrently. This is a well-studied problem in distributed systems, with established solutions around fine-grained locking, multi-version concurrency control, and transaction isolation.</p>

            <p>Instead, Terraform implements the simplest possible solution: a global mutex on a JSON file.</p>

            <div>
                <h4>Observation</h4>
                <p>The probability of lock contention in a shared state file increases super-linearly with both team size and resource count. At 100 resources and 5 engineers, you&#39;re coordinating 500 potential interaction points through a single mutex.</p>
            </div>

            <p>Consider the actual data access patterns in a typical Terraform operation:</p>

            <div role="img" aria-label="Comparison of file-based state with global lock versus graph state with precise operations">
                <div role="group" aria-labelledby="current-model">
                    <h4 id="current-model">Current Model</h4>
                    <p>
                        tfstate.json (2.3MB)
                    </p>
                    <p>
                        Read: 100%</p>
                </div>
                <div role="group" aria-labelledby="actual-need">
                    <h4 id="actual-need">Actual Requirement</h4>
                    <div>
                        <p>VPC</p>
                        <p>Subnet</p>
                        <p>RDS</p>
                        <p>ALB</p>
                        <p>ASG</p>
                        <p>SG</p>
                    </div>
                    <p>
                        Read: 3%</p>
                </div>
            </div>

            <p>This mismatch between granularity of operation and granularity of locking is the root cause of every Terraform scaling problem. It violates the fundamental principle of isolation in concurrent systems: non-overlapping operations should not block each other.</p>

            <p>The standard response, splitting state files, doesn&#39;t solve the problem. It redistributes it. Now you have N coordination problems instead of one, plus the additional complexity of managing cross-state dependencies. You&#39;ve traded false contention for distributed transaction coordination, which is arguably worse.</p>
        </div>

        <div>
            <h2>State as a Graph: The Natural Representation</h2>

            <p>Infrastructure state is inherently a directed graph. Resources have dependencies, which form edges. Changes propagate along these edges. Terraform already knows this: the internal representation is a graph, and the planner performs graph traversal. But at the storage layer, we flatten this rich structure into a blob.</p>

            <p>This is akin to storing a B-tree in a CSV file. You can do it, but you&#39;re destroying the very properties that make the data structure useful.</p>

            <div role="region" aria-label="Stategraph query demo">
                
                <div>
                    <p><span>stategraph&gt;</span> -- Find resource subgraph for planned change</p>
                    <p>WITH RECURSIVE affected AS (</p>
                    <p>    SELECT id, type, name FROM resources</p>
                    <p>    WHERE name = &#39;prod-api-cluster&#39;</p>
                    <p>    UNION</p>
                    <p>    SELECT r.id, r.type, r.name FROM resources r</p>
                    <p>    JOIN dependencies d ON r.id = d.dependent_id</p>
                    <p>    JOIN affected a ON d.resource_id = a.id</p>
                    <p>) SELECT * FROM affected;</p>
                    <p>→ 12 resources in change scope <span>(0.003s)</span></p>
                    <p>→ Compared to: 2,847 resources in full state <span>(1.2s)</span></p>
                </div>
            </div>

            <p>When state is properly normalized into a graph database, several properties emerge naturally:</p>

            <p><strong>Subgraph isolation:</strong> Operations on disjoint subgraphs are inherently parallelizable. If Team A is modifying RDS instances and Team B is updating CloudFront distributions, there&#39;s no shared state to coordinate.</p>

            <p><strong>Precise locking:</strong> We can implement row-level locking on resources and edge-level locking on dependencies. Lock acquisition follows the dependency graph, preventing deadlocks through consistent ordering.</p>

            <p><strong>Incremental refresh:</strong> Given a change set, we can compute the minimal refresh set by traversing the dependency graph. Most changes affect a small cone of resources, not the entire state space.</p>
        </div>

        <div>
            <h2>Concurrency Control Through Proper Abstractions</h2>

            <p>The distributed systems community solved these problems decades ago. Multi-version concurrency control (MVCC) allows readers to proceed without blocking writers. Write-ahead logging provides durability without sacrificing performance. Transaction isolation levels let operators choose their consistency guarantees.</p>

            <p>Stategraph implements these patterns at the Terraform state layer:</p>

            <div>
                <h4>Traditional: Global Lock</h4>
                
                <p><span>$ terraform apply</span> Acquiring <strong>global lock</strong>… <span>waiting</span></p>
                <h4>Stategraph: Subgraph Isolation</h4>
                
                <p><span>$ stategraph apply</span> Locking subgraph <strong>(3 resources)</strong>… <span>ready</span></p>
            </div>

            <p>Each operation acquires locks only on its subgraph. The lock manager uses the dependency graph to ensure consistent ordering, preventing deadlocks. Readers use MVCC to access consistent snapshots without blocking writers.</p>

            <div>
                <h4>Implementation Detail</h4>
                <p>Lock acquisition follows a strict partial order derived from the resource dependency graph. Resources are locked in topological order, with ties broken by resource ID. This guarantees deadlock freedom without requiring global coordination.</p>
            </div>

            <p>The result is dramatic improvement in concurrent throughput:</p>

            <div>
                <div>
                    <h5>Transaction A</h5>
                    <p>Lock: RDS:prod-db</p>
                    <p>Lock: SG:prod-db-sg</p>
                    <p>Apply changes</p>
                </div>
                <div>
                    <h5>Transaction B</h5>
                    <p>Lock: CF:cdn-dist</p>
                    <p>Lock: S3:static-assets</p>
                    <p>Apply changes</p>
                </div>
                <div>
                    <h5>Transaction C</h5>
                    <p>Lock: ASG:workers</p>
                    <p>Lock: LC:worker-config</p>
                    <p>Apply changes</p>
                </div>
            </div>

            <p>Three teams, three transactions, zero contention. This isn&#39;t possible with file-based state, regardless of how you split it.</p>
        </div>

        <div>
            <h2>The Refresh Problem</h2>

            <p>Terraform refresh is O(n) in the number of resources, regardless of change scope. Change one security group rule and you still walk the entire state. That&#39;s an algorithmic bottleneck, not just an implementation detail.</p>

            <div role="img" aria-label="Comparison of refresh scope: file-based vs graph-based">
                <div role="group" aria-labelledby="refresh-before">
                    <h4 id="refresh-before">File-Based State</h4>
                    
                    <p>
                        Changing 1 resource</p>
                </div>
                <p>
                    →
                </p>
                <div role="group" aria-labelledby="refresh-after">
                    <h4 id="refresh-after">Graph State</h4>
                    
                    <p>
                        Changing 1 resource</p>
                </div>
            </div>

            <p>With a graph representation, refresh work can be scoped to the affected subgraph instead of the entire state. Most changes touch only a small fraction of resources, not everything.</p>
        </div>

        <div>
            <h2>Why We Built This</h2>

            <p>At Terrateam, we&#39;ve watched hundreds of teams struggle with the same fundamental problems. They start with a single state file, hit scaling limits, split their state, discover coordination complexity, build orchestration layers, and eventually resign themselves to living with the pain.</p>

            <p>This is a solvable problem. The computer science is well-understood. The implementation is straightforward once you acknowledge that state management is a distributed systems problem, not a file storage problem.</p>

            <p>Stategraph isn&#39;t revolutionary. It&#39;s the application of established distributed systems principles to a problem that&#39;s been mischaracterized since its inception. We&#39;re not inventing new algorithms; we&#39;re applying the right ones.</p>

            <div>
                <h4>Design Principle</h4>
                <p>The storage layer should match the access patterns. Terraform state exhibits graph traversal patterns, partial update patterns, and concurrent access patterns. The storage layer should be a graph database with ACID transactions and fine-grained locking. Anything else is impedance mismatch.</p>
            </div>

            <p>The infrastructure industry has accepted file-based state as an immutable constraint for too long. It&#39;s not. It&#39;s a choice, and it&#39;s the wrong one for systems at scale.</p>
        </div>

        <div>
            <h2>Technical Implementation</h2>

            <p>Stategraph is implemented as a PostgreSQL schema with a backend that speaks the Terraform/OpenTofu remote backend protocol. We chose PostgreSQL for its robust MVCC, proven scalability, and operational familiarity. The schema normalizes state into three primary relations:</p>

            <p><strong>resources:</strong> one row per resource, with type, provider, and attribute columns.</p>

            <p>The backend extends Terraform&#39;s protocol with graph-aware operations. Lock acquisition and state queries operate directly on the database representation of the graph, enabling precision and concurrency that file-based backends can&#39;t provide.</p>

            <p>This isn&#39;t a wrapper or an orchestrator. It&#39;s a replacement for the storage layer that preserves Terraform&#39;s execution model while fixing its coordination problems.</p>
        </div>

        <div>
            <h2>Adoption Path</h2>

            <p>Stategraph reads existing tfstate files and constructs the graph representation automatically. No changes to Terraform configurations are required. The backend protocol is unchanged. From Terraform&#39;s perspective, Stategraph is just another backend, like S3 or GCS.</p>

            <p>But from an operational perspective, everything changes. Lock contention disappears. Refresh times drop by orders of magnitude. Teams stop blocking each other. State becomes queryable, auditable, and comprehensible.</p>

            <p>We&#39;re not asking teams to rewrite their infrastructure. We&#39;re asking them to store it properly.</p>

            <blockquote>
                The question isn&#39;t whether Terraform state should be a graph. It already is. The question is whether we&#39;ll continue pretending it&#39;s a file.
            </blockquote>
        </div>

        <div>
            <h3>Technical Preview</h3>
            <p>Stategraph is in active development. We&#39;re working with design partners to validate the approach at scale.</p>
            <p><a href="https://stategraph.dev/#signup">Get Updates</a></p>
        </div>
    </article></div>
  </body>
</html>
