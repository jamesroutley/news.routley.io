<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hazure.neocities.org/articles/4j0k">Original</a>
    <h1>A minimal timing and synchronization model</h1>
    
    <div id="readability-page-1" class="page"><div>  <p>After having spent some time <a href="https://hazure.neocities.org/articles/2h03.html">surveying issues related to
    managing the flow of time in programming</a>, we are ready to propose a
    minimal timing and synchronization model of our own, built on a very small
    number of constructs and primitives, but intended to be expressive enough
    to represent a wide variety of patterns while being simple enough to be
    relatively easy to implement and extend in a variety of different
    environments. Our model is based on <a href="https://hazure.neocities.org/articles/2n08.html">logical time</a>,
    instantaneous computations, and cooperative scheduling of lightweight
    threads, or fibers. This presentation will be very abstract but it will be
    followed shortly by the concrete description of <a href="#">practical
    browser-based implementation</a>; it is a also snapshot of the current state
    of the model, which is still under development.</p> <p><strong>I. Time and computations.</strong> We chose to represent time as a
    discrete set of instants <em>t</em>. An instant can be <em>definite</em>, <em>indefinite</em>, or <em>unresolved</em> (this terminology is borrowed from <a href="https://hazure.neocities.org/articles/2g04.html">SMIL</a>). Resolved (definite or indefinite) values should form
    a <a href="https://en.wikipedia.org/wiki/Total_order">total order</a> and
    have an additive and a multiplicative operation, so we chose to use
    non-negative real numbers for definite values, <a href="https://en.wikipedia.org/wiki/Extended_real_number_line">extended with +∞</a> for indefinite instants. Unresolved values are just unique values distinct
    from resolved values.</p> <p>A <em>duration</em> is a value <em>d</em> defined as the difference between
    two instants. Durations are also definite, indefinite, or unresolved. When
    resolved, durations are never negative, that is, durations are only defined
    between a later instant and an earlier instant. When the later instant is
    indefinite, then the duration is indefinite; when the later instant is
    unresolved, then the duration is also unresolved.</p> <p>Following the synchronous model of the <a href="https://hazure.neocities.org/articles/2i02.html">ChucK</a> and <a href="https://hazure.neocities.org/articles/2i03.html">Esterel</a> programming languages, we loosely define a <em>computation</em> as an operation, or sequence of operations, that can be
    perceived as running uninterrupted within an instant. This can be as simple
    as a single CPU instruction like adding or branching, or calling an
    arbitrarily complex function, itself calling itself or other functions, in
    a high-level programming language. Whatever the actual complexity of the
    computation, its duration is always zero; it may produce effects during
    execution, and result in a value or an error. An ordered sequence of
    computations <em>C</em> can be associated with an instant: every computation <em>c</em> ∈ <em>C</em> is executed at the associated time <em>t</em>.</p> <p>By ordering computations within an instant, it is possible to order <em>all</em> computations that happen at a definite time: first by instant,
    then by order within the sequence of computations. Computations associated
    with an indefinite or unresolved time are never executed, but an unresolved
    value may eventually be resolved as the effect of another computation; if
    the resolved value is an instant that is already associated with a sequence
    of computations, the computations at the the previously unresolved time are
    appended at the end of the sequence, maintaining the ordering of
    computations.</p> <p><strong>II. Synchronizing computations.</strong> Based on these concepts of
    time and computations, we can now define <em>synchronization mechanisms</em> to manage the ordering and timing of computations. A <em>fiber</em> is an
    ordered sequence of zero or more <em>instructions</em>, where an instruction
    is either a computation or one of three synchronization primitives (Delay,
    Spawn, Join). A fiber can be <em>scheduled</em> to begin in a given
    instant; after a fiber begins, its instructions are <em>executed</em> in
    order, and the fiber ends when its last instruction does.</p> <p><em>Delay</em> allows a fiber to suspend execution (<em>i.e.</em>, wait) for a
    given duration before executing its next instruction. Waiting for an
    indefinite or unresolved duration means that execution is suspended
    indefinitely. An unresolved duration may eventually become resolved and
    a delay duration may change during execution.</p> <p><em>Spawn</em> allows a fiber to create a new <em>child</em> fiber
    scheduled to begin in the same instant. Fibers are organized in trees: a
    fiber may spawn multiple children, and may have a single parent (the fiber
    that they were spawned from). While the child fiber begins in the same
    instant that it was spawned, spawning itself is an instantaneous
    computation with no duration, so the parent fiber keeps executing, possibly
    spawning other fibers, before the child fibers actually begin. Child fibers
    that were spawned in a given instant <em>t</em> do begin as soon as the
    parent fiber is suspended or ends, in the order in which they were
    spawned.</p> <p><em>Join</em> is the counterpart to Spawn and allows a fiber to wait
    until all of its children have ended. If no child fiber was previously
    spawned, then joining is instantaneous and the fiber resumes execution
    immediately. Otherwise, the parent fiber is suspended for an unresolved
    duration. When a fiber ends, it gets removed from the list of children of
    its parent (if any). If there is a parent and it is joining, the parent is
    notified and given the opportunity to execute a computation immediately
    (<em>i.e.</em>, in the same instant, and before any other computation scheduled in
    that instant) to handle the effect of that child joining. When the last
    child has ended, the join ends and the parent fiber, which has no children
    anymore, resumes execution immediately.</p> <p>Fibers provide the basis for sequential execution of computations.
    Delay allows for asynchronous execution. Spawn and Join are the building
    blocks for concurrent execution: they often go together, as a fiber
    can spawn multiple children to execute subtasks concurrently then join to
    wait for all subtasks to finish before resuming; but it is possible to
    spawn a child fiber and <em>not</em> join, so that both fibers keep running
    independently.</p> <figure>
            <img src="https://hazure.neocities.org/images/cartoon-cyclops.png" alt="A cyclops is trying out
    pairs of glasses handed to him from a shop assistant."/>
            <figcaption>Hmmm... I don’t
    know... there’s something not quite right with these too...</figcaption>
        </figure> <p>Error handling is another kind of synchronization mechanism. A fiber
    executes its instructions one after the other <em>as long as no error
    occurs</em>.  If a computation ends in error, then the fiber resumes execution
    but is <em>failing</em>, and every subsequent instruction is treated as a <a href="https://en.wikipedia.org/wiki/NOP_(code)">no-op</a> computation, with
    no effect and no duration. This results in a failing fiber ending as soon
    as an error occurs; the parent fiber is then notified, and if it is
    joining, may decide how to handle the error from the child fiber (<em>e.g.</em>, by
    failing itself, ignoring the error, initiating a fallback, &amp;c.) The reason
    why we still go through the motions of executing the instructions of a
    failing fiber instead of simply ending right there and then is that it is
    possible to <em>protect</em> instructions from failure: a protected
    instruction will still execute even if its fiber is failing, providing an
    opportunity for error handling and recovery. Note that protection is not
    an instruction or computation, but a <em>property</em> of an instruction.</p> <p>Errors happen during computations, but it is also possible that a fiber
    may <em>fail</em> another suspended fiber, as we will see below. In that
    case, the failing fiber resumes execution immediately, <em>unless</em> the
    instruction that caused the fiber to be suspended in the first place (a
    Delay or a Join) was protected. If that instruction was a Join and was not
    protected, the child fibers fail as well, so that the parent eventually
    resumes execution. This behaviour can be used for <em>cancelling</em> other
    fibers, usually children, by using a special <em>Cancel</em> error (an error
    that can be distinguished from all other possible erros).</p> <p>For example, a <em>timeout</em> can be implemented by spawning two
    fibers. The first fiber can execute any series of instructions. The second
    fiber only has one Delay with a definite duration. The parent fiber then
    joins, and as soon as one child fiber ends, cancels the other one by making
    it fail with a Cancel error. If the first fiber ends before the timeout
    delay expires, then the timeout is cancelled and execution continues
    normally: the task completed before the timeout expired. If on the other
    hand the delay ends first, then the task was still in progress and is
    cancelled, and execution can resume with an error or a default value.</p> <p>Because cancelling is just failing a fiber, using protected
    instructions judiciously leads to different patterns. In the previous
    timeout scenario, protecting the Delay in the second fiber means that
    whatever task is undertaken by the first fiber, execution will always take
    the same amount of time: if a result is provided before the timeout
    expires, then cancelling the other fiber has no effect and the join will
    only end when that fiber ends, but if the timeout expires before the task
    is complete, then the first fiber will be cancelled. Either way, the
    resulting duration is always that of the delay. Another use of protection
    is to give a fiber a chance to end gracefully even in the case of errors,
    including cancellation; if the task in the timeout scenario requires some
    cleaning up at the end (such as freeing resources), the last instructions
    can be protected to make sure that they are always executed, whether or not
    execution ends succesfully.</p> <figure><div> <canvas></canvas> </div> <figcaption>This article may be a little dry, so here is a  5-second
        racing microgame adapted from <a href="https://github.com/stcucufa/epistrophy/blob/f6f51d49413988d7c681abc43829f0e7ad7bcfe2/examples/cars/cars.js">an example of using the browser implementation of the model</a>. Click
        the game window to (re)start the game, then use the up and down arrow
        keys to move your car.</figcaption></figure> <p><strong>III. Scheduling computations.</strong> We have described all but one
    of the components of our model: instants, computations, delays, fibers,
    spawning and joining, and error handling. The last piece of the puzzle is
    the <em>scheduler</em>, which bridges the gap between fibers and instants,
    ensuring that computations from the different fibers are executed at the
    right time and in the right order; but also translates the logical time of
    the model into the actual time experienced by the user of the program,
    acting as the interface between the idealized environment of the model and
    the real world in which programs actually run. It also provides specific
    computations for fibers to affect other fibers, like failing a fiber
    (<em>e.g.</em>, for cancellation) or changing the duration of a delay (resolving
    an unresolved duration, extending or shortening a resolved duration).</p> <p>Our model is an example of cooperative multithreading (which is one
    reason why the term <em>fiber</em> was chosen in opposition to <em>thread</em>,
    which is generally associated with a preemptive model). Scheduling is
    relatively straightforward: once a fiber is scheduled to begin at a given
    instant, start executing the computations on that fiber until it explictly <em>yields</em>, which happens when encountering a Delay or a Join, or it
    ends. The scheduler simply needs to keep a queue of fibers ordered by the
    time at which they are scheduled to begin or resume; when the first instant
    happens, the fiber at the head of the queue is removed and it starts
    executing. If the fiber yields, it is put back in the queue at a new
    instant (following a delay with a definite duration), or stored in a pool
    of fibers suspended indefinitely; the scheduler can then move to the next
    fiber in the queue.</p> <p>Actually running a program using this model requires chosing a <em>timescale</em> for durations; for instance, if our application has a graphical
    user interface, we may want to think of durations at the millisecond scale.
    A Delay of 500 would then translate to half a second of physical time; a
    fiber scheduled at <em>t</em> = 7777 would begin executing 7.777s after the
    main fiber began. Note that the timescale does not need to fixed from one
    execution to the next, or even through one execution. We will discuss <a href="#">time manipulation</a> more thoroughly in a forthcoming article,
    but one aspect that we can already mention is that the scheduler is not
    clock: it may be <em>driven</em> by a running clock, but that clock may be
    paused and resumed; and the clock could be bypassed altogether in favor of
    of feeding time values to the scheduler at an arbitrary rate.</p> <p>This model is designed to be as small as possible in order to keep
    complexity in check, while still making it possible for interesting
    emergent behaviours to emerge; this was achieved by removing any feature
    that can be realized using the existing primitives. For example, we can
    think of asynchronous function calls as a sequence of three instructions: a
    computation that initiate the call, returning a future (or promise, or some
    similar value) synchronously; a Delay with an unresolved duration; and a
    computation that handles the eventual value or error. The scheduler manages
    the actual asynchronous function call and resolves the duration of the
    delay when it completes. DOM events in a browser environment can be
    implemented in a very similar fashion (setting up the listener and resuming
    when an event notification is received). These features may need to be
    provided by a practical implementation, but using the model ensures that
    they fit consistently with the actual primitives.</p> <p>Another example of a feature that may seem fundamental but can also be
    completely defined in terms of the primitives of the model is <em>repetition</em>. We can define a new Repeat instruction as a pair of Spawn
    and Join: first, we spawn a new fiber for the body of the loop; then join.
    Recall that a parent fiber may execute a computation when a child fiber
    ends; here, that computation consists of spawning the child fiber one more
    time. Spawning the fiber again prevents the join from ending, since it
    still has a child fiber, and the same fiber will repeat over and over
    again.</p> <p>Interestingly, our model makes it easy to limit the <em>duration</em> of
    a loop (<em>e.g.</em>, by using a timeout as discussed above), but not the number
    of iterations! This can be addressed by modifying Repeat to keep track of
    the number of times the child fiber was spawned, and evaluate a predicate
    (<em>i.e.</em>, any computation resulting in a boolean value) before spawning, and
    only spawn if the predicate is true. If the fiber is not spawned, then the
    Join ends immediately as there is no child fiber, and the loop ends. Adding
    this test before even the first iteration means that we can also use Repeat
    to conditionally spawn any fiber, keeping with our minimalisitic mindset.
    ⚄⚃</p> </div></div>
  </body>
</html>
