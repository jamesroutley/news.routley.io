<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cohost.org/tef/post/1764930-how-not-to-write-a">Original</a>
    <h1>How not to write a pipeline</h1>
    
    <div id="readability-page-1" class="page"><div data-post-body="true" data-testid="post-body"><div><p>let me boldly assert that there are two types of programmer (at least as far as this post is concerned):<!-- --></p>
<!-- --><ol>
<!-- --><li>a programmer who builds something out of message queues and calls it a pipeline<!-- --></li>
<!-- --><li>a programmer who has had to maintain and operate a type-1 made pipeline<!-- --></li>
<!-- --></ol>
<!-- --><p>although both types of programmer are kept awake by thoughts of code at night, only one of them is on the pager rota. every programmer gets to fuck around, but only a handful are blessed/cursed with finding out.<!-- --></p>
<!-- --><p>this essay is for programmers of the second variety. i&#39;m not sure what anyone else will get, but hopefully the people who have already suffered will receive validation, and maybe a few lucky people will pick up some useful framing and vocabulary to fight the good fight later.<!-- --></p><hr/>
<!-- -->
<!-- --><p>you are:<!-- --></p>
<!-- --><ul>
<!-- --><li>☐ A long time industry expert, with twelve acronyms on your business card.<!-- --></li>
<!-- --><li>☐ Someone with a kanban, can-do attitude. Party planning your way to success!<!-- --></li>
<!-- --><li>☑ A well rounded burnout who got hired through word of mouth.<!-- --></li>
<!-- --></ul>
<!-- --><p>you are<!-- --></p>
<!-- --><ul>
<!-- --><li>☐ in a small engineering team, building out features for a website<!-- --></li>
<!-- --><li>☑ employee number four and the ceo keeps writing code on weekends<!-- --></li>
<!-- --><li>☐ in a large enterprise company with an hour and a half long daily standup<!-- --></li>
<!-- --></ul>
<!-- --><p>you are<!-- --></p>
<!-- --><ul>
<!-- --><li>☐ in charge of building out backend systems<!-- --></li>
<!-- --><li>☐ all working in the same repo<!-- --></li>
<!-- --><li>☑ accidentally in ops, after fixing one too many builds<!-- --></li>
<!-- --></ul>
<!-- -->
<!-- --><p>it&#39;s 3pm, it&#39;s friday, and your coworker drops a link in the company chat. it&#39;s a 2000 line change request, and they&#39;re desperate for a +1. despite the length, the code is relatively straight forwards. a lot of it is just yaml.<!-- --></p>
<!-- --><p>there&#39;s a thumbnail generator that&#39;s starting to take too long. originally it just cropped and resized things down, but for some ungodly reason, there&#39;s video support and transcoding now. requests to the website are timing out because this process is taking too long to complete.<!-- --></p>
<!-- --><p>your coworker, bored as hell, desperate to get on with real work, volunteers as tribute to fix the bug. now the code calls &#34;StartThumbNailer(user, file)&#34;, a message gets put in a queue, and another process elsewhere calls &#34;user, file := queue.ThumbNextNail()&#34;. problem solved.<!-- --></p>
<!-- --><p>alas, it isn&#39;t icarus&#39; fate to know his future.<!-- --></p>
<!-- -->
<!-- --><p>you open a dm, it&#39;s best to avoid an audience. people get touchy about their code.<!-- --></p>
<!-- --><blockquote>
<!-- --><p>&#34;This is great work, it&#39;s good to prototype these things out&#34;<!-- --></p>
<!-- --></blockquote>
<!-- --><p>Remember: Don&#39;t be a dick about it. Don&#39;t squeal and wail, not matter how much you want to.   People really don&#39;t like being told &#34;You can&#39;t do it that way. You do not understand why.&#34; It&#39;s a bad look all round, even if it&#39;s true.<!-- --></p>
<!-- --><p>Establish common ground, reframe problem, work towards common goals. Then you can be a dick about it, later. Remember: It&#39;s only a little bit less of a dick to be Socratic about it, and ask questions you already know the answer to, so try and be nice where you can.<!-- --></p>
<!-- --><blockquote>
<!-- --><p>&#34;I don&#39;t see a lot of error handling.&#34;<!-- --></p>
<!-- --></blockquote>
<!-- --><p>There&#39;s never <!-- --><em>any<!-- --></em> error handling. The message broker is always running, the queue always exists, and the workers never make a mistake, either. That&#39;s how prototypes look, sure, but that&#39;s how pipelines will look, years later.<!-- --></p>
<!-- --><p>The only thing that changes as pipelines age is the number of graphs on the ops dashboard.<!-- --></p>
<!-- --><blockquote>
<!-- --><p>&#34;It will be good to work out precisely which things we can leave out of a first implementation. We don&#39;t want to lose future feature dev time to operations.&#34;<!-- --></p>
<!-- --></blockquote>
<!-- --><p>You&#39;re not trying to &#34;shut it down&#34;, you&#39;re working out the minimum level of work needed to ship it. You&#39;re justifying why with a business case.<!-- --></p>
<!-- --><blockquote>
<!-- --><p>&#34;What happens when message delivery fails? Maybe there&#39;s a network blip, maybe someone tripped over the cable at the data centre?&#34;<!-- --></p>
<!-- --></blockquote>
<!-- --><p>It&#39;s important not to blame the broker, and focus more on &#34;networks are bad and haunted.&#34; People will just tell you the broker saves messages to disk, so they&#39;re even harder to lose, ignoring the actual problem at hand.<!-- --></p>
<!-- --><blockquote>
<!-- --><p>&#34;If the send fails, we can just log it instead of doing nothing, and I guess we can restart those thumbnail jobs by hand.&#34;<!-- --></p>
<!-- --></blockquote>
<!-- --><p>Again, it&#39;s time to move on. A log message is fine enough for a first prototype, so don&#39;t get hung up on it. A lack of error handling isn&#39;t the important point. The important point is &#34;how much manual work is it going to be to fix things after they go wrong?&#34;<!-- --></p>
<!-- --><blockquote>
<!-- --><p>&#34;If something else went wrong, Is there a way to tell which users are missing thumbnails? Or would we have to add logging elsewhere?&#34;<!-- --></p>
<!-- --></blockquote>
<!-- --><p>The answer&#39;s usually something like &#34;a timestamp in the database&#34; or something, and another klaxon starts ringing. Resist the urge to explain why timestamps are a bad choice for now, you can revisit it later.<!-- --></p>
<!-- --><p>The important bit is that &#34;there&#39;s some state, in a database&#34;, and for now it only has two states &#34;needs doing, and has been done&#34;. It&#39;ll end up with seven or eight states later on, and that&#39;s when you&#39;ll have &#34;the timestamp talk&#34;<!-- --></p>
<!-- --><blockquote>
<!-- --><p>&#34;I think the important question is: Can write some .NeedsThumbnail() or .HasThumbnail() function, and then resend those messages? We can worry about the implementation details at the end.&#34;<!-- --></p>
<!-- --></blockquote>
<!-- --><p>That&#39;s right. &#34;At the end&#34;. Now your coworker should realise it&#39;s time for a long haul discussion about the system. Don&#39;t miss your chance to recap things.<!-- --></p>
<!-- --><ul>
<!-- --><li>you recognise that there&#39;s limits to error handling in a prototype<!-- --></li>
<!-- --><li>you&#39;re worried about the manual work required to fix errors<!-- --></li>
<!-- --><li>with a bit more of a plan, things can move forward<!-- --></li>
<!-- --><li>working out manual steps required for recovery &amp; seeing if there&#39;s low hanging fruit<!-- --></li>
<!-- --></ul>
<!-- --><p>you open a shared document. it&#39;s called &#34;background work: operations guide&#34;, and drop a link in the change request.<!-- --></p>
<!-- --><blockquote>
<!-- --><ol>
<!-- --><li>
<!-- --><p>lost message<!-- --></p>
<!-- --></li>
<!-- --></ol>
<!-- --><ul>
<!-- --><li>problem: the service might fail to send a message for a variety of reasons<!-- --></li>
<!-- --><li>solution: we can discover this through logs and alarms<!-- --></li>
<!-- --><li>solution: we can store some state in the database, so it&#39;s easy to tell the &#34;needs thumbnails&#34; from &#34;has thumbnails&#34;<!-- --></li>
<!-- --><li>resolution: we can write scripts to restart lost jobs, or do it manually<!-- --></li>
<!-- --></ul>
<!-- --></blockquote>
<!-- --><p>with some aplomb, you write up a series of headings underneath.<!-- --></p>
<!-- --><blockquote>
<!-- --><ol start="2">
<!-- --><li>duplicate messages<!-- --></li>
<!-- --><li>failed thumbnailer<!-- --></li>
<!-- --><li>head of line<!-- --></li>
<!-- --><li>statistics / monitoring / debugging<!-- --></li>
<!-- --></ol>
<!-- --></blockquote>
<!-- --><p>your coworker is not impressed, but hasn&#39;t lost hope yet. maybe they&#39;ll ship it by the end of the week. meanwhile, there&#39;s a bit of a shit-eating-grin on your face.<!-- --></p>
<!-- --><p>error handling sometimes means running the same thing twice. duplicate handling means avoiding just that.  the statistics part is yet another &#34;tricking them into using the database&#34; section, broken down into smaller bite sized chunks.<!-- --></p>
<!-- --><p>it is time to make your coworker eat their vegetables.<!-- --></p>
<!-- -->
<!-- --><p>the original code didn&#39;t really have any deduplication. the worker assumes it&#39;s the only one running for that user&#39;s thumbnails.<!-- --></p>
<!-- --><p>duplication is a always a problem because the recovery steps for &#34;lost messages&#34; involve resending potentially lost messages. for example:<!-- --></p>
<!-- --><ul>
<!-- --><li>workers stop running overnight<!-- --></li>
<!-- --><li>message queue builds up<!-- --></li>
<!-- --><li>workers restart in morning<!-- --></li>
<!-- --><li>user notices thumbnail is missing, gets manually added to queue by hand<!-- --></li>
<!-- --><li>now there&#39;s two messages in the queue.<!-- --></li>
<!-- --></ul>
<!-- --><p>it isn&#39;t the worst thing in the world if two processes get run at once, but no-one&#39;s really sure if it will cause problems, writing to the same files at the same time.<!-- --></p>
<!-- --><p>again, the point of raising this isn&#39;t &#34;this has to be fixed&#34; but &#34;we need to understand how it can fail, and how much time will we waste fixing it.&#34;<!-- --></p>
<!-- --><p>sometimes the answer is &#34;make the process idempotent&#34;, but usually the answer is &#34;locks&#34;, shortly followed by &#34;leases&#34;. you&#39;ll need to timeout locks eventually, if a worker crashes midway through thumbnailing.<!-- --></p>
<!-- --><p>&#34;well, fuck it, we&#39;ll use redis. put a worker_id, timestamp in a hash, and if that timestamp is old, or missing, i can write my own one in.&#34;<!-- --></p>
<!-- --><p>it&#39;s not perfect by any means, but it will reduce the operations headache. you update the file and move on.<!-- --></p>
<!-- --><p>sometimes the queue has a magical transactional mode, where you can hold onto a message until you&#39;ve finished processing it, and after a timeout it&#39;ll be available for other workers.<!-- --></p>
<!-- --><p>it&#39;s almost the same thing you&#39;re doing with redis, but there&#39;s still a little more work to do:<!-- --></p>
<!-- -->
<!-- --><blockquote>
<!-- --><p>&#34;if a worker takes a message, asks for a lease, and then crashes, how do we retry work?<!-- --><!-- --></p>
<!-- --></blockquote>
<!-- --><p>The usual answer to &#34;How do we fix it&#34; is &#34;Something puts the message back in the queue.&#34; Your coworker points out that we can fix it in the same way as before. Putting some timestamps in the database. Writing an automated script that restarts old jobs.<!-- --></p>
<!-- --><p>You nod once more, it&#39;s still not the right time to argue about timestamps.<!-- --></p>
<!-- --><blockquote>
<!-- --><p>&#34;Let&#39;s call it a message pump. Since it pumps messages into the queue. Also, we should probably keep track of the last error message, and the number of attempts when we do it.&#34;<!-- --></p>
<!-- --></blockquote>
<!-- --><p>It&#39;s ok, it&#39;s only adding one JSONB column. One we&#39;ll make use of later. Heh heh heh.<!-- --></p>
<!-- --><blockquote>
<!-- --><p>&#34;There&#39;s still one problem left, but I&#39;m not sure it applies.&#34;<!-- --></p>
<!-- --></blockquote>
<!-- -->
<!-- --><p>thankfully your coworker was sensible, and suggested using the same automated script as before. if they&#39;d chosen the fancy transactional queue, there&#39;d be a little surprise for them in store: head of line blocking<!-- --></p>
<!-- --><p>everyone who has worked with queues usually has a story like this, give or take some details:<!-- --></p>
<!-- --><ol>
<!-- --><li>for error handling, we used a transactional queue: if a process failed, it returned to the queue.<!-- --></li>
<!-- --><li>one job kept killing all the workers during a period of high load. the worker would crash, and the bad job went back to the top of the list. two people had a screaming match over zoom<!-- --></li>
<!-- --><li>instead of limiting retries, or a time-to-live on the job message, retries are put in a new &#34;error queue&#34;, with their own workers<!-- --></li>
<!-- --><li>the error queue ends up full of duplicate messages, and all progress on retries is blocked.<!-- --></li>
<!-- --></ol>
<!-- --><p>you write &#34;head of line blocking: not in scope&#34; and move on. It&#39;s at this point you pray for a lightbulb above your coworkers head. Handling lost messages, handling broken thumbnailer runs, ensuring two jobs don&#39;t overlap, these are all interlinked. It&#39;s far too easy to write error handling that causes more errors.<!-- --></p>
<!-- --><p>with the error handling wrapped up, it&#39;s time to move on to the last section. unfortunately for your coworker, this is where the magic happens.<!-- --></p>
<!-- --><p>It&#39;s finally time to talk about timestamps.<!-- --></p>
<!-- -->
<!-- --><p>now you can start asking questions like &#34;How do we tell if a job has been enqueued or not? how do we tell if a job is being worked on?&#34; before moving onto &#34;Actually, how many states can a process be in?&#34;<!-- --></p>
<!-- --><p>with the queue, it&#39;s not possible to find out what things are running, if anything has crashed, and instead all you have is a graph that has three settings:<!-- --></p>
<!-- --><ul>
<!-- --><li>Queue&#39;s empty. Fine. Or maybe it&#39;s broken and no work is happening.<!-- --></li>
<!-- --><li>Burst of work, but line is going down. Actually fine.<!-- --></li>
<!-- --><li>Line is going up. Something is not working, and whatever it is, the problem is only getting worse.<!-- --></li>
<!-- --></ul>
<!-- --><p>Meanwhile, the message broker queue thing as it stands only tracks two things:<!-- --></p>
<!-- --><ul>
<!-- --><li>If it&#39;s in the queue, this job will be assigned to a worker next.<!-- --></li>
<!-- --><li>If it&#39;s not in the queue, this job will not be assigned to a worker.<!-- --></li>
<!-- --></ul>
<!-- --><p>In other words:<!-- --></p>
<!-- --><ul>
<!-- --><li>We can&#39;t really tell if things are working reliably, outside of a few cases<!-- --></li>
<!-- --><li>The only thing we know for sure is &#34;this work is about to be done&#34;<!-- --></li>
<!-- --></ul>
<!-- --><p>Your coworker points out that the timestamp thing from earlier would help, and it does. Now you can track two more things:<!-- --></p>
<!-- --><ul>
<!-- --><li>When did I last send a message<!-- --></li>
<!-- --><li>When did a job last complete.<!-- --></li>
<!-- --></ul>
<!-- --><p>Notice how neither of those two states really tell you anything about what&#39;s going on for a particular thumbnail job. You can kinda infer &#34;this should be run&#34; if the last send message is older than the job last completing. You can kinda infer &#34;this ran, but i don&#39;t know if it succeeded or not&#34; if the last send message is earlier than the job completeing.<!-- --></p>
<!-- --><p>That&#39;s not a lot to infer. The underlying problem here is that a process can be in way more than two or three states, especially now error handling has come into the mix, and a handful of timestamps won&#39;t fix it.<!-- --></p>
<!-- --><p>To be clear: This is the time to yell about timestamps.<!-- --></p>
<!-- --><p>Yell about having one field called <!-- --><code>state<!-- --></code> is way easier than <!-- --><code>started_at<!-- --></code> <!-- --><code>last_active_at<!-- --></code> <!-- --><code>completed_at<!-- --></code> <!-- --><code>last_error_at<!-- --></code>, and a nasty series of comparisons. A field with three booleans and a truth table isn&#39;t any better, either.<!-- --></p>
<!-- --><p>After sketching things out with your coworker, you decide that a job can be in several different states:<!-- --></p>
<!-- --><ul>
<!-- --><li>initialised: an id or record exists but there&#39;s no data inside<!-- --></li>
<!-- --><li>created: everything needed to start the job is available.<!-- --></li>
<!-- --><li>enqueued: in the process of being assigned to a worker<!-- --></li>
<!-- --><li>active: a worker is doing the job<!-- --></li>
<!-- --><li>failed: a worker encountered a known error, and can be restarted<!-- --></li>
<!-- --><li>panic: a worker encountered an unknown error<!-- --></li>
<!-- --><li>timeout: a worker failed to complete the job<!-- --></li>
<!-- --><li>skipped: no work actually needed<!-- --></li>
<!-- --></ul>
<!-- --><blockquote>
<!-- --><p>&#34;We&#39;ll probably combine some of them together, but it&#39;s good practice to split things up as much as possible.&#34;<!-- --></p>
<!-- --></blockquote>
<!-- -->
<!-- --><p>Now you&#39;ve committed to tracking state in the database, it&#39;s time to clean up the proposal.<!-- --></p>
<!-- --><ul>
<!-- --><li>we&#39;ll have a table of thumbnail jobs in the database<!-- --></li>
<!-- --><li>each one has a state field, a free text field, and a jsonb column for error handling and other details<!-- --></li>
<!-- --></ul>
<!-- --><blockquote>
<!-- --><p>&#34;We could have a table of thumbnail changes in the database,  that gets a new record every time the state changes. It might be more work now, but it&#39;s probably easier to have one DB migration than two.&#34;<!-- --></p>
<!-- --></blockquote>
<!-- --><ul>
<!-- --><li>workers read from a queue to find new work, and use a redis lock to exclude others<!-- --></li>
<!-- --><li>there&#39;s a message pump that reads from the database and writes to the queue<!-- --></li>
<!-- --><li>we don&#39;t need to persist any messages in the queue<!-- --></li>
<!-- --></ul>
<!-- --><p>It all feels a little overkill, but it really does make a big difference. Unlike before, there&#39;s handling in place for all sorts of errors. It&#39;s easy to recover from a crashed queue, you just empty it and restart the workers. Plus one quite lovely feature: the message pump can check the queue length, and alert if things stop going down. There&#39;s no need to configure an alerting system.<!-- --></p>
<!-- --><p>It&#39;s not a lot of code to write. The redis lock code (in lua) is somewhere on stack overflow. The database migration is a pain in the ass to deploy, but it&#39;s not difficult to write. Your coworker even adds in the second table, and starts collecting statistical data in the jsonb field to show off.<!-- --></p>
<!-- -->
<!-- --><p>it&#39;s a good point to sigh and take a break. you&#39;ve successfully got a coworker to build a reliable, robust system. one that has automated ways to handle failures, one that doesn&#39;t require human intervention on the regular, and one that doesn&#39;t remind you of all the awful systems you&#39;ve suffered so far.<!-- --></p>
<!-- --><p>it&#39;s a good moment to take a step back and ask &#34;how come it worked out this time&#34;<!-- --></p>
<!-- --><ul>
<!-- --><li>your coworker actually believes you when you share your experience<!-- --></li>
<!-- --><li>you aren&#39;t forcing people to reinvent your exact solution<!-- --></li>
<!-- --><li>not every issue is fixed, despite being identified<!-- --></li>
<!-- --><li>it wasn&#39;t about someone being right, or someone being wrong, it was about lowering operational costs<!-- --></li>
<!-- --></ul>
<!-- --><p>sure enough, sometimes it doesn&#39;t work out<!-- --></p>
<!-- --><ul>
<!-- --><li>your coworker doesn&#39;t care about the operational cost<!-- --></li>
<!-- --><li>no-one&#39;s getting a bonus for taking time to ship things carefully<!-- --></li>
<!-- --><li>the right thing will only matter at scale, and by that time, who knows what we&#39;ll be needing<!-- --></li>
<!-- --></ul>
<!-- --><p>sometimes it&#39;s a little bit like solving a race condition. no-one believes it can be fixed, and when people ask for help, they just want to move the problem elsewhere. turns out &#34;have you tried explicitly ordering the operations on the shared mutable state&#34; is not a popular answer, despite being correct. people hate eating their vegetables.<!-- --></p>
<!-- --><p>even so, you do win the argument eventually.<!-- --></p>
<!-- --><p>the queue keeps exploding, duplicate messages keep breaking everything. the error handling caused a denial of service. things tend to steer towards &#34;tracking the state of a job&#34;.<!-- --></p>
<!-- --><p>the broker grows from &#34;a new central point of failure that always needs more disks&#34; into &#34;a lightweight service discovery and work assignment service&#34;, and instead of &#34;just fire and regret a message&#34; you have &#34;the queue buffers the results of a more expensive database query.&#34;<!-- --></p>
<!-- --><p>in fact, we could get rid of the queue entirely, and just use a load balancer<!-- --></p>
<!-- --><ul>
<!-- --><li>workers connect to a load balancer instead of a broker<!-- --></li>
<!-- --><li>scheduler sends http request for each item of work until told to slow down<!-- --></li>
<!-- --><li>jobs complete in the background and update the database<!-- --></li>
<!-- --></ul>
<!-- --><p>we could even get rid of the load balancer, too:<!-- --></p>
<!-- --><ul>
<!-- --><li>workers connect to the scheduler, and ask for the next job to perform<!-- --></li>
<!-- --><li>scheduler hands out jobs one by one as workers scale up or finish tasks<!-- --></li>
<!-- --><li>like before, scheduler amortises the expensive database query<!-- --></li>
<!-- --><li>but now? you don&#39;t need a lock server<!-- --></li>
<!-- --></ul>
<!-- --><p>in some ways, you&#39;ve just moved the queue and locking data structures inside the scheduler, they haven&#39;t really gone away. it does, however, let us do a variety of nice things:<!-- --></p>
<!-- --><ul>
<!-- --><li>like before, the scheduler can be killed and restarted, as all state is kept in the database<!-- --></li>
<!-- --><li>scheduler can even spin up more workers as and when required by the load<!-- --></li>
<!-- --><li>scheduler can offer api for starting jobs, listing jobs, getting status, or watching for changes<!-- --></li>
<!-- --><li>workers can even report back to the scheduler instead of to the database directly, which lets scheduler check worker is trying to update an active job.<!-- --></li>
<!-- --></ul>
<!-- --><p>the best part? the system doesn&#39;t really look much like a pipeline.<!-- --></p>
<!-- --><p>now the message pump, the lock, the queue, the worker registration, and the worker assignment, and the recovery processes are all happening in the same place, it feels quite different from slapping messages into a queue and hoping for the best.<!-- --></p>
<!-- --><p>it might feel like more work than wrapping shit together in redis, but in some ways there&#39;s less complexity going around. as far as the worker is concerned, there&#39;s no lock manager, there&#39;s no queue, there&#39;s no database, just a scheduler api for getting a job and another for progress updates.<!-- --></p>
<!-- --><p>it&#39;s almost important enough to recap<!-- --></p>
<!-- --><ul>
<!-- --><li>keep all the process state in a database table<!-- --></li>
<!-- --><li>use a text field for state, there&#39;s a lot of them<!-- --></li>
<!-- --><li>use another table if you want to track changes<!-- --></li>
<!-- --><li>scheduler amortises expensive database queries<!-- --></li>
<!-- --><li>scheduler keeps track of which worker is active on what<!-- --></li>
<!-- --><li>workers poll scheduler to be assigned work<!-- --></li>
<!-- --><li>workers update scheduler, not database, with progress updates / heartbeat messages<!-- --></li>
<!-- --><li>scheduler orders work to be done by most overdue<!-- --></li>
<!-- --></ul>
<!-- --><p>[that last one is how you handle restarting errored jobs or missing jobs]<!-- --></p>
<!-- --><p>intermission almost over, and we&#39;re nearly halfway to the (non) goal.<!-- --></p>
<!-- -->
<!-- --><p>even if you don&#39;t go full tilt and implement the all-in-one scheduler, it might feel like the battle is won. with just a message pump, you&#39;re handling all sorts of errors automatically, and it didn&#39;t take two sprints to write.<!-- --></p>
<!-- --><p>there&#39;s just one problem: someone has suggested splitting up the thumbnailer into seperate processes. that same someone suggests tying the parts back together with a message broker. the pipeline is back, and the same problems are back too.<!-- --></p>
<!-- --><p>not just head of line blocking, but the whole &#34;have you tried reading the logs&#34; school of state management.<!-- --></p>
<!-- --><p>it&#39;s at this point that you start to ask &#34;why does everyone keep doing it this way?&#34; and it doesn&#39;t take too long to realise that the answer is unix. when people think about batch processing, they think about being at the command line, and chaining up steps together in a unix pipeline<!-- --></p>
<!-- --><p>and much like a pipeline, you end up writing something different to make things robust.<!-- --></p>
<!-- --><p>at some point, the unix pipeline fails, and you&#39;re faced with re-running the entire thing again, or repeating that time honoured unix tradition of breaking up the pipeline a series of <!-- --><code>Makefile<!-- --></code> steps, using temporary files for each program&#39;s input and output.<!-- --></p>
<!-- --><p>pipelines aren&#39;t really designed for reliability, and in some ways, they&#39;re not really designed for task level parallelism either: it&#39;s a lot easier to run a 1000 calls to <!-- --><code>process(item)<!-- --></code> than it is to run one worker pool for each step in <!-- --><code>process<!-- --></code> and wire them up together with queues.<!-- --></p>
<!-- --><p>anyway, back to the problem at hand: someone has had the bright idea of connecting things up with a message broker. this time, it&#39;s a new coworker, and the argument&#39;s a bit different. sure enough, there&#39;s the same old story about service discover, or &#34;free error handling for a problem created by using a broker&#34; stuff you heard the last time, but now there&#39;s &#34;can scale up and down each worker queue to adjust for load&#34; too<!-- --></p>
<!-- --><p>i&#39;ve already elaborated at length about why &#34;don&#39;t join things together with queues&#34; elsewhere, and this post is already quite lengthy in the &#34;don&#39;t use a queue to store background work&#34; department, so let&#39;s cut to the meat of it.<!-- --></p>
<!-- --><blockquote>
<!-- --><p>&#34;There&#39;s no real end-to-end management of the task state, unless you have a database. &#34;<!-- --></p>
<!-- --></blockquote>
<!-- --><p>The state tracking needs to be back, or messages will fall into the void. The message pump needs to be back, or work won&#39;t get restarted after failure. We can add new pipeline-like steps to our improved system, without having to implement the all-in-one scheduler.<!-- --></p>
<!-- --><blockquote>
<!-- --><p>&#34;We can add new logic to the message pump, and new states to the database table.&#34;<!-- --></p>
<!-- --></blockquote>
<!-- --><p>Fine. Keep your queues and your worker pool, but you tell the database when you&#39;re done with your step, and the message pump will send off a new task. It&#39;s still a little janky, each worker has to know the name of the worker after it to glue everything together, but it&#39;ll work fine enough.<!-- --></p>
<!-- --><p>The important part is to not be woken up at night because the queue&#39;s exploded. Using a message pump keeps that queue length bounded.<!-- --></p>
<!-- --><p>That&#39;s the real problem with queues: There&#39;s never any flow control, or a way for a queue to tell clients to slow down. There&#39;s always persistence, so you can&#39;t drop messages on the floor. There&#39;s never bounds on the size of a queue, either. A queue is a machine for turning rpc calls into full disks.<!-- --></p>
<!-- --><p>Look, to keep a distributed system running, you need to build a system that aims towards an equilibrium state, slowing things down when other parts can&#39;t keep up. A message broker does the exact opposite, allowing parts to get wildly out of sync until you run out of disk space to keep up appearances.<!-- --></p>
<!-- --><p>Once you have backpressure or load shedding atop of a queue, you can&#39;t just fire a message away and hope for the best. You need to implement flow control, or error handling. You have to stop pretending the queue is a magic wand.<!-- --></p>
<!-- --><p>It&#39;s fine to glue things together with queues. You&#39;ve just got to avoid persistence, and demand backpressure or load shedding, and you won&#39;t end up in the same mess over and over and over again. That&#39;s the important bit. That and &#34;if you run things, you need to keep track of their states&#34;<!-- --></p>
<!-- --><p>Anyway, back to the coworker.<!-- --></p>
<!-- --><blockquote>
<!-- --><p>&#34;That&#39;s not the only route we can go. Your way is to have six worker pools, one for each part of the thumbnail task, shared across every task. Could we have one worker pool, for the whole thumbnail task, and just run the different steps inside the same worker?&#34;<!-- --></p>
<!-- --></blockquote>
<!-- --><p>It&#39;s not much of a change from before. Now the worker updates the database, then runs the next step, then updates the database, and runs the next step, until it runs out of steps. Like before, it&#39;s way, way easier to run <!-- --><code>task()<!-- --></code> 1,000 times, than it is to run six different pools and queues between them, but not every pipeline can benefit from task-level-parallelism.<!-- --></p>
<!-- --><blockquote>
<!-- --><p>&#34;... but if we have to do stuff like aggregation, we might have to do something different&#34;<!-- --></p>
<!-- --></blockquote>
<!-- --><p>let&#39;s stop thinking about the janky-ass setup we have so far. remember the all in one scheduler earlier? for task level parallelism, it&#39;s pretty straight forwards, we just run all the thumbnail components in one worker, and use the same setup from before:<!-- --></p>
<!-- --><ul>
<!-- --><li>we have one big worker pool<!-- --></li>
<!-- --><li>each worker asks for a task, and which state it&#39;s in<!-- --></li>
<!-- --><li>the worker runs that one part of the code, and reports the output<!-- --></li>
<!-- --><li>the scheduler decides if that worker runs the next step<!-- --></li>
<!-- --><li>in other words: the scheduler can decide how to parition the work at runtime<!-- --></li>
<!-- --></ul>
<!-- --><p>that&#39;s a kinda nice thing to have, but it doesn&#39;t clear up running things with task-level parallelism. in this case, the thumbnailer can run one step in parallel for each of the output files it generates.<!-- --></p>
<!-- --><p>your coworker, now fully baptised in the church of state tracking, decides to step in. they&#39;re saying stuff like &#34;it&#39;s not a background job system, it&#39;s a series of persistent state machines executed in parallel across a shared worker pool&#34;, so you know they&#39;ve got this.<!-- --></p>
<!-- --><blockquote>
<!-- --><p>&#34;We just run another task, right? There&#39;s one table for thumbnail tasks, right, one per top level thumbnail job. Let&#39;s add a second table for subtasks, and a given task can have lots of<!-- --><!-- --></p>
<!-- --></blockquote>
<!-- --><p>In the all in one scheduler, it looks something like this<!-- --></p>
<!-- --><ul>
<!-- --><li>The worker tells the scheduler to start a number of subtasks<!-- --></li>
<!-- --><li>As the worker asks the scheduler to create a subtask, the scheduler can choose to assign it immediately<!-- --></li>
<!-- --><li>The original worker polls the scheduler to find out when that subtask completes<!-- --></li>
<!-- --><li>The original worker moves onto other work.<!-- --></li>
<!-- --><li>If there&#39;s an error, the worker restarts the subtask<!-- --></li>
<!-- --></ul>
<!-- --><p>Applying it to the redis-and-message-pump prototype, we get:<!-- --></p>
<!-- --><ul>
<!-- --><li>There&#39;s a redis server providing a lock and a queue<!-- --></li>
<!-- --><li>The database has a table for the thumbnail task and another table for subtasks<!-- --></li>
<!-- --><li>There&#39;s a message pump, which scans both tables and tops up the message queue with jobs<!-- --></li>
<!-- --><li>Workers pull out a task or a subtask from the queue, and run it<!-- --></li>
<!-- --><li>The top level tasks end up just starting other subtasks and waiting for most of the time.<!-- --></li>
<!-- --></ul>
<!-- --><p>Congratulations: You are the proud author of a not-pipeline. Sure enough, there&#39;s task level parallelism, and there&#39;s even inter-task level parallelism too. There&#39;s duplicate handling, end-to-end error handling with state tracking, and it&#39;s easy to ask questions like &#34;What process is running?&#34; and &#34;What error did this thing return with.&#34; Throw on a web interface, and you can probably move a lot of the support burden to another team.<!-- --></p>
<!-- --><p>It might still smell like a pipeline, but there&#39;s those all important differences.<!-- --></p>
<!-- --><ul>
<!-- --><li>The queue isn&#39;t persistent. You can restart the broker at any time, or drop all messages to go back to a known state.<!-- --></li>
<!-- --><li>There&#39;s backpressure.  The message pump can hold off on writing messages if the queue gets too big.<!-- --></li>
<!-- --><li>There&#39;s end-to-end error handling, it doesn&#39;t matter if an individual part fails.<!-- --></li>
<!-- --><li>There&#39;s even process supervision. The top level task watches over the smaller ones. Errors in subprocesses can be handled and managed, too.<!-- --></li>
<!-- --><li>There&#39;s task level parallelism. One broken process in one thumbnail doesn&#39;t affect other thumbnail tasks.<!-- --></li>
<!-- --><li>There&#39;s inter-task level parallelism. One broken substep doesn&#39;t impeded other substeps from running to completetion.<!-- --></li>
<!-- --><li>The system is always in recovery. Instead of assuming things work, it constantly looks out for overdue tasks, trying to push things back into equilibrium,<!-- --></li>
<!-- --><li>It&#39;s even pretty easy to adapt. Adding new states doesn&#39;t require migrations, and the JSONB column gets used to smuggle variables into subtasks. Nice.<!-- --></li>
<!-- --></ul>
<!-- --><p>Most importantly? This system is the winner of the &#34;least likely to wake you up at night&#34; award, handed out by a select set of judges. Not bad for &#34;a lock and and a queue in redis to amortise an expensive postgres query&#34;<!-- --></p>
<!-- --><p>Not that anyone else notices. The problem with building robust systems is that it&#39;s a thankless task that everyone eventually takes for granted. Give it a few months, the new hires will be exclaiming &#34;Couldn&#39;t we just use a message broker. It&#39;s so much easier than this mess of queue and redis and database.&#34;<!-- --></p>
<!-- --><p>I blame unix, personally.<!-- --></p>
<!-- -->
<!-- --><p>your coworker has been nerd sniped. they went off and finished the all-in-one scheduler for fun. it turned out to be a little less code than the redis duct tape sandwich in production. they&#39;ve made some changes<!-- --></p>
<!-- --><p>there&#39;s a <!-- --><code>process<!-- --></code> table and a &#39;procedure&#39; table, some of the other names have changed too. they renamed the scheduler to &#34;operator&#34;. it&#39;s a kubernetes term for a daemon that watches a database and runs set actions, very similarly to how an operator works. in some ways, your coworker has written a toolkit for writing a scheduler in.<!-- --></p>
<!-- --><p>they&#39;ve also started going on about &#34;microsoft orleans&#34; and &#34;entity component systems&#34; and &#34;the blackboard pattern.&#34; you even heard &#34;tuplespace&#34; once. they&#39;re all &#34;here&#39;s a database that tracks state, persists objects, and here&#39;s a series of workers that collaborative update this database to achieve tasks in a distributed or parallel or concurrent style&#34; looking things, and your coworker really, really wants to keep talking about turning the rather fancy state machines they can build.<!-- --></p>
<!-- --><p>well, at least it&#39;s not a pipeline. you hate pipelines, remember?<!-- --></p>
<!-- -->
<!-- --><p>you might wonder and ask me &#34;is this software something you want to write&#34;, and the answer is &#34;i have already written this software ten times over, in slightly different forms, all in different jobs&#34;<!-- --></p>
<!-- --><p>in one job, we had a web api for all the little tasks associated with a background process, and we&#39;d even coded a few buttons in. i suggested to coworker that it might be easier to just return a list of actions each thingy could do, over hardcoding each and every one.  we even started doing things like returning human facing values in api. a &#34;state_en&#34; along with a &#34;state&#34; with things like &#34;Process is running for N hours&#34; inside.<!-- --></p>
<!-- --><p>in another job, the big database of state got copied around from place to place. we ended up using version numbers instead of timestamps. yep, that&#39;s right, there&#39;s still more timestamp content. the problem with timestamps is that you can&#39;t tell if you&#39;ve missed a version, there&#39;s no easy way to handle clock skew, and you don&#39;t really know how many times a thing has changed, either. a version number handles all these things, but you&#39;ll still need a timestamp to know when a version changed, and you won&#39;t care so much about clock skew, then.<!-- --></p>
<!-- --><p>i even got to write my own rpc toolkit one of the times. as much as i lament having to rebuild the same internal product in each and every job, i&#39;m not sure i&#39;d have learned so much about distributed systems without it. that, and i&#39;d probably be out of a job if people could actually build batch processing systems as easily as they build websites.<!-- --></p>
<!-- --><p>thankfully, this post will change nothing<!-- --></p></div></div></div>
  </body>
</html>
