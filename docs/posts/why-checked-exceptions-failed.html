<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://borretti.me/article/why-checked-exceptions-failed">Original</a>
    <h1>Why checked exceptions failed</h1>
    
    <div id="readability-page-1" class="page"><article>
    <p>Java has this feature called checked exceptions, which lets you <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.6">annotate</a>
a method with the set of exceptions it may throw, like so:</p>

<div><div><pre><code><span>private</span> <span>void</span> <span>foo</span><span>()</span> <span>throws</span> <span>FooException</span><span>,</span> <span>BarException</span> <span>{</span>
  <span>// ...</span>
<span>}</span>
</code></pre></div></div>

<p>Methods that call <code>foo()</code> must either explicitly catch <code>FooException</code> and
<code>BarException</code>, or otherwise annotate themselves with the set of exceptions they
don’t handle and which propagate up from them.</p>

<p>Nobody uses this. Why? Because the rest of the language is missing.</p>

<p>The central concepts of most programming languages are values and types. All of
the machinery of the language is, in one way or another, about transforming
values into other values, or transforming types into other types. We can do a
lot of things with values and types.</p>

<p>Functions and methods have a <em>signature</em>: the types of the parameters, and the
return type. Java added extra information to method signatures, orthogonal to
the types: the set of exceptions the method can throw. But the rest of the
machinery is missing.</p>

<p>Say I have an interface with a method <code>foo</code>:</p>

<div><div><pre><code><span>public</span> <span>interface</span> <span>ExampleInterface</span> <span>{</span>
    <span>void</span> <span>foo</span><span>();</span>
<span>}</span>
</code></pre></div></div>

<p>How does this interact with checked exceptions? Can I write this?</p>

<div><div><pre><code><span>public</span> <span>class</span> <span>ExampleClass</span> <span>implements</span> <span>ExampleInterface</span> <span>{</span>
    <span>public</span> <span>void</span> <span>foo</span><span>()</span> <span>throws</span> <span>IOException</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>IOException</span><span>(</span><span>&#34;Oh no!&#34;</span><span>);</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>Obviously not:</p>

<div><div><pre><code>error: foo() in ExampleClass cannot implement foo() in ExampleInterface
    public void foo() throws IOException {
                ^
overridden method does not throw IOException
</code></pre></div></div>

<p>Because the code that uses the interface, rather than the class, has no way of
seeing this.</p>

<p>Can I specify that implementations of <code>foo</code> can throw no, some, or all
exceptions? What would it even mean to write something like <code>throws *</code>?
Analogously, if I have a function that takes a method as an argument, like a
callback, how do I specify what set of exceptions in can throw? Can I have
generic “exception set parameters”?</p>

<p>It starts with a very simple and laudable goal: let’s add extra information to
the type signature, orthogonal to the types, so we can track exceptions,
computational effects, maybe even things like stack usage or whether the
function is recursive. And before long you’re overwhelmed with subtyping
relationships between effects, lattice theory, covariance and contravariance of
effects.</p>

<p>Concretely, checked exceptions in Java failed because Java lacks “throwingness
polymorphism”, if you will.</p>

<p>Functional error handling, using <code>Option</code> and <code>Result</code> types, is rapidly
becoming the standard operating procedure in essentially every language, because
it relies on nothing but <em>values</em> and <em>types</em>. They are more of the same, and so
they fit right into the existing language machinery.</p>

<p>More broadly: in programming languages, <em>everything impinges on everything
else</em>. Which is why you can’t bolt a type system or an ownership system on a
language after the fact. At least, not without massive holes you will cope about
and deny exist.</p>

<p>Was Java wrong to add checked exceptions? No. They took a risk and it didn’t pay
off. The design flaws in programming languages are not necessarily evident until
you write tens of thousands, or hundreds of thousands, or millions of lines of
code. They can only be evaluated in the large.</p>

  </article></div>
  </body>
</html>
