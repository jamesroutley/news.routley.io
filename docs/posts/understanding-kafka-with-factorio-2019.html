<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ruurtjan.medium.com/understanding-kafka-with-factorio-74e8fc9bf181">Original</a>
    
    <div id="readability-page-1" class="page"><div><div><section><div><div><div><div><div><div><p><a rel="noopener follow" href="https://ruurtjan.medium.com/?source=post_page-----74e8fc9bf181-----------------------------------"><img alt="Ruurtjan Pul" src="https://miro.medium.com/fit/c/56/56/1*uLt7KmAcmllD88BlXmYfnQ.jpeg" width="28" height="28"/></a></p></div></div></div></div><p id="4d72"><em>Thanks to </em><a href="https://medium.com/u/ac5a5df4d1a6?source=post_page-----74e8fc9bf181-----------------------------------" target="_blank" rel="noopener"><em>Tom de Ruijter,</em></a><em> </em><a href="https://medium.com/u/9fdf9ae0d8fd?source=post_page-----74e8fc9bf181-----------------------------------" target="_blank" rel="noopener"><em>Steven Reitsma</em></a><em> and </em><a href="https://twitter.com/laurenskoppenol" target="_blank" rel="noopener ugc nofollow"><em>Laurens Koppenol</em></a><em> for proof reading this post.</em></p><p id="a0ee">While playing <a href="https://www.factorio.com/" target="_blank" rel="noopener ugc nofollow">Factorio</a> the other day, I was struck by the many similarities with <a href="https://kafka.apache.org/" target="_blank" rel="noopener ugc nofollow">Apache Kafka</a>. If you aren’t familiar with them: Factorio is an open-world RTS where you build and optimize supply chains in order to launch a satellite and restore communications with your home planet, and Kafka is a distributed streaming platform, which handles asynchronous communication in a durable way.</p><p id="7dd5">I wonder how far we can<span id="rmm"><span id="rmm"> </span></span>take the analogy between Factorio and Kafka before it starts to break down. Let’s start from scratch, explore the core Kafka concepts through Factorio visualizations, and have some fun along the way.</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/0*4pqsIxKItolPfHRT.jpg" width="700" height="259" role="presentation"/></p></div><figcaption>If you don’t have a lot of time to spare, don’t download Factorio.</figcaption></figure><h2 id="e1ae">Why bother with async messaging?</h2><p id="8292">Let’s say we have three microservices. One for mining iron ore, one for smelting iron ore into iron plates, and one for producing iron gear wheels from these plates. We can chain these services with synchronous HTTP calls. Whenever our mining drill has new iron ore, it does a POST call on the smelting furnace, which in turn POSTs to the factory.</p><figure><div><div><div><p><img alt="" src="https://miro.medium.com/freeze/max/60/1*VxPctzCiJHYH0H_UWAE6Mw.gif?q=20" width="700" height="248" role="presentation"/></p><p><img alt="" width="700" height="248" role="presentation"/></p></div></div></div><figcaption>From left to right: mining, smelting and producing — tightly coupled via synchronous communication</figcaption></figure><p id="c2d1">This setup served us well, until there was a power outage in the factory. The furnace’s HTTP calls failed, causing the mining drill’s calls to fail as well. We can implement <a href="https://martinfowler.com/bliki/CircuitBreaker.html" target="_blank" rel="noopener ugc nofollow">circuit breakers</a> and retries to prevent cascading failures and message loss, but at some point we’ll have to stop trying, or we’ll run out of memory.</p><figure><div><div><div><p><img alt="" src="https://miro.medium.com/freeze/max/60/1*ybhZGVD1oWfxT_QfFIeGCA.gif?q=20" width="700" height="250" role="presentation"/></p><p><img alt="" width="700" height="250" role="presentation"/></p></div></div></div><figcaption>Power outage at the factory</figcaption></figure><p id="b3c9">If only there was a way to decouple these microservices... This is, of course, where Kafka comes in. With Kafka, you can store streams of records in a fault-tolerant and durable way. In Kafka terminology, these streams are called <em>topics</em>.</p><figure><div role="button" tabindex="0"><div><div><div><p><img alt="" src="https://miro.medium.com/freeze/max/60/1*XUZUg7DlOZy5fItePjYgPg.gif?q=20" width="700" height="184" role="presentation"/></p><p><img alt="" width="700" height="184" role="presentation"/></p></div></div></div></div><figcaption>Microservices decoupled by asynchronous messaging</figcaption></figure><p id="1cf3">With asynchronous topics between services, messages, or <em>records</em>, are buffered during peak loads, and when there is an outage. These buffers obviously have limited capacity, so let’s talk about scalability.</p><p id="4521">We can increase storage capacity and throughput by adding Kafka servers to the cluster. Another way is to increase disk size (for storage), or CPU and network speed (for throughput). Which of these options give you the best value for money is use-case specific, but buying <em>bigger </em>servers — unlike buying <em>more</em> servers — is subject to <a href="https://en.wikipedia.org/wiki/Diminishing_returns" target="_blank" rel="noopener ugc nofollow">the law of diminishing returns</a>. Kafka’s capacity scales linearly with each node added, so that’s usually the way to go.</p><figure><div><div><div><p><img alt="" src="https://miro.medium.com/freeze/max/60/1*pVoHlF2FfMoHw0WOuUoZmg.gif?q=20" width="700" height="248" role="presentation"/></p><p><img alt="" width="700" height="248" role="presentation"/></p></div></div></div><figcaption>Vertical scaling — a bigger, exponentially more expensive server</figcaption></figure><figure><div><div><div><p><img alt="" src="https://miro.medium.com/freeze/max/60/1*kZe05DbF2yYm43INu07Ecw.gif?q=20" width="700" height="248" role="presentation"/></p><p><img alt="" width="700" height="248" role="presentation"/></p></div></div></div><figcaption>Horizontal scaling — distribute the load over more servers</figcaption></figure><p id="cba8">To divide a topic between multiple servers, we need a way to split a topic into smaller substreams. These substreams are called <em>partitions.</em> Whenever a service <em>produces</em> a new record, this service gets to decide which partition the record should land on.</p><figure><div><div><div><p><img alt="" src="https://miro.medium.com/freeze/max/36/1*Qe4n06aC_PxpbS6s9MoiMw.gif?q=20" width="275" height="456" role="presentation"/></p><p><img alt="" width="275" height="456" role="presentation"/></p></div></div></div><figcaption>A wagon producing records, a partitioner that puts messages on the right partition, and a topic with four partitions.</figcaption></figure><p id="07ee">The <a href="https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/internals/DefaultPartitioner.java#L69" target="_blank" rel="noopener ugc nofollow">default <em>partitioner</em></a><em> </em>hashes the message key and modulos that over the number of partitions:</p><figure><div></div></figure><p id="44f4">That way messages with the same key always end up on the same partition.</p><p id="8c62">Note that messages are only guaranteed to be ordered within the context of a producer and partition. Records from multiple producers, or from a single producer on multiple partitions, can interleave.</p></div></div></section><section><div><div><p id="2577">Now that we know how messages are put onto topics, let’s see how they are <em>consumed</em>. When you start listening to a topic, by default the records from all partitions are routed to you. It’s common though, to have multiple instances of a microservice running at the same time to achieve higher throughput or availability. If they all start listening to the topic, each record gets processed by each instance, which is usually not what you want.</p><figure><p><img alt="" src="https://miro.medium.com/max/812/1*MhgvvDO8qLfWqYbXXZ_SSg.gif" width="406" height="420" role="presentation"/></p><figcaption>All microservice instances consume all messages</figcaption></figure><p id="cd25"><em>Consumer groups </em>allow you to evenly divide the partitions among multiple consumers. When a microservice instance joins the consumer group, Kafka will reassign some of the partitions to it. Likewise, when an instance crashes, or leaves the group for another reason, its partitions will be assigned to other instances. Kafka makes sure the partitions are always evenly divided among the consumers in each group.</p><figure><div><div><div><p><img alt="" src="https://miro.medium.com/freeze/max/60/1*tEf0Y1nrA6jI4D7YrTSViQ.gif?q=20" width="406" height="333" role="presentation"/></p><p><img alt="" width="406" height="333" role="presentation"/></p></div></div></div><figcaption>A single consumer group with three consumers</figcaption></figure><p id="0525">If there’s a topic where the number of records per partition are skewed, you might be in trouble. An instance might not be able to keep up, because it was assigned the partition with many records, while other instances are idle. It’s up to you to make sure that there are no partitions that have vastly more records than others.</p><figure><div><div><div><p><img alt="" src="https://miro.medium.com/freeze/max/60/1*SIBbXFlCnSxahp8xofNjqA.gif?q=20" width="406" height="333" role="presentation"/></p><p><img alt="" width="406" height="333" role="presentation"/></p></div></div></div><figcaption>Messages are piling up on a hot partition</figcaption></figure><p id="6201">Each consumer keeps track of which records it has processed. Since records are processed in order, a simple <em>offset </em>is enough. Every once in a while (5 seconds by default), a consumer will <em>commit</em> its offset to Kafka<em>.</em></p><p id="f018">When a consumer leaves its group, its partitions are given to other consumer in the group. The new consumers will be able to start requesting records starting at the offset where the previous consumer stopped.</p><p id="e71a">It is possible that a record was processed, but not yet committed. You’ll either have to start at the committed offset, or start processing new messages and skip everything that’s not yet processed. This is why Kafka can only guarantee that messages are delivered at least once, or at most once.</p></div></div></section><section><div><div><p id="e033">The analogy no longer really makes sense when we start duplicating data. With Kafka, we can process a single record multiple times. Multiple consumer groups can consume the same records. Topics can be stored with a <em>replication factor </em>of three for reliability. Topics can have a <em>retention period</em> after which records are deleted. All this is possible because data, unlike iron, can be duplicated easily.</p><p id="5d27">This is a good place to end this post. We’ve covered all the major concepts of Kafka and you should have a general understanding of how Kafka works. Let’s wrap up with a short recap.</p><h2 id="d898">What we learned</h2><p id="f248">Kafka is a distributed streaming platform that stores records in a durable way through replicating records across multiple servers. Topics consist of partitions, that store records in order. Partitioners decide which records belong on which partitions. Consumer groups are optional, and help distribute partitions among consumers for scalability. Offsets are committed as checkpoints for when consumers crash.</p><p id="89e2">And that, in a nutshell, is how Kafka works.</p><h2 id="f525">About the author</h2><p id="8bee"><a href="https://medium.com/u/ee6f5293f7?source=post_page-----74e8fc9bf181-----------------------------------" target="_blank" rel="noopener">Ruurtjan Pul</a> (<a href="https://twitter.com/Ruurtjan" target="_blank" rel="noopener ugc nofollow">Twitter: @ruurtjan</a>) is a data engineer at <a href="https://bigdatarepublic.nl" target="_blank" rel="noopener ugc nofollow"><strong>BigData Republic</strong></a>, a data science consultancy company in the Netherlands. We hire the best of the best in BigData Science and BigData Engineering. If you are interested in using Kafka and other data engineering tools on practical use cases, feel free to contact us at <a href="mailto:info@bigdatarepublic.nl" target="_blank" rel="noopener ugc nofollow"><strong>info@bigdatarepublic.nl</strong></a>.</p><figure><div><div><div><p><img alt="" src="https://miro.medium.com/max/60/1*Z59mqTSdHgyxj-hP63WiTg.png?q=20" width="414" height="156" role="presentation"/></p><p><img alt="" width="414" height="156" role="presentation"/></p></div></div></div></figure><h2 id="0cff">Learn more</h2></div></div></section></div></div></div>
  </body>
</html>
