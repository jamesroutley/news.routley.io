<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/ziglang/zig/pull/24329">Original</a>
    <h1>Zig breaking change â€“ initial Writergate</h1>
    
    <div id="readability-page-1" class="page"><div>
        <div>
  
  <task-lists disabled="" sortable="">
    <div>
      <p dir="auto"><a href="https://github.com/ziglang/zig/pull/10055" data-hovercard-type="pull_request" data-hovercard-url="/ziglang/zig/pull/10055/hovercard">Previous Scandal</a></p>
<h2 dir="auto">Summary</h2>
<p dir="auto">Deprecates all existing std.io readers and writers in favor of the newly provided <code>std.io.Reader</code> and <code>std.io.Writer</code> which are <em>non-generic</em> and have the buffer above the vtable - in other words the buffer is <strong>in the interface, not the implementation</strong>. This means that although Reader and Writer are no longer generic, they are still transparent to optimization; all of the interface functions have a concrete hot path operating on the buffer, and only make vtable calls when the buffer is full.</p>
<p dir="auto">I have a lot more changes to upstream but it was taking too long to finish them so I decided to do it more piecemeal. Therefore, I opened this tiny baby PR to get things started.</p>
<p dir="auto">These changes are extremely breaking. I am sorry for that, but I have carefully examined the situation and acquired confidence that this is the direction that Zig needs to go. I hope you will strap in your seatbelt and come along for the ride; it will be worth it.</p>
<p dir="auto">The breakage in this first PR mainly has to do with formatted printing.</p>
<h2 dir="auto">Upgrade Guide</h2>
<p dir="auto">Turn on <code>-freference-trace</code> to help you find all the format string breakage.</p>
<ul dir="auto">
<li>std.fs.File.reader -&gt; std.fs.File.deprecatedReader</li>
<li>std.fs.File.writer -&gt; std.fs.File.deprecatedWriter</li>
<li>std.fmt.format -&gt; std.fmt.deprecatedFormat</li>
<li>std.fmt.fmtSliceEscapeLower -&gt; std.ascii.hexEscape</li>
<li>std.fmt.fmtSliceEscapeUpper -&gt; std.ascii.hexEscape</li>
<li>std.fmt.fmtSliceHexLower -&gt; {x}</li>
<li>std.fmt.fmtSliceHexUpper -&gt; {X}</li>
<li>std.fmt.fmtIntSizeDec -&gt; {B}</li>
<li>std.fmt.fmtIntSizeBin -&gt; {Bi}</li>
<li>std.fmt.fmtDuration -&gt; {D}</li>
<li>std.fmt.fmtDurationSigned -&gt; {D}</li>
<li>{} -&gt; {f} when there is a format method. This prevents footguns when adding or deleting format methods.</li>
<li>format method signature
<ul dir="auto">
<li>anytype -&gt; *std.io.Writer</li>
<li>inferred error set -&gt; error{WriteFailed}</li>
<li>FormatOptions -&gt; (deleted)</li>
</ul>
</li>
<li>std.fmt.Formatter
<ul dir="auto">
<li>now takes context type explicitly</li>
<li>no fmt string</li>
</ul>
</li>
</ul>
<p dir="auto">These are deprecated but not deleted yet:</p>
<ul dir="auto">
<li>std.io.GenericReader -&gt; std.io.Reader</li>
<li>std.io.GenericWriter -&gt; std.io.Writer</li>
<li>std.io.AnyReader -&gt; std.io.Reader</li>
<li>std.io.AnyWriter -&gt; std.io.Writer</li>
</ul>
<p dir="auto">If you have an old stream and you need a new one, you can use <code>adaptToNewApi()</code> like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="fn foo(old_writer: anytype) !void {
    var adapter = old_writer.adaptToNewApi();
    const w = &amp;adapter.new_interface;
    try w.print(&#34;{s}&#34;, .{&#34;example&#34;});
    // ...
}"><pre><span>fn</span> <span>foo</span>(<span>old_writer</span>: <span>anytype</span>) <span>!</span><span>void</span> {
    <span>var</span> <span>adapter</span> <span>=</span> <span>old_writer</span>.<span>adaptToNewApi</span>();
    <span>const</span> <span>w</span> <span>=</span> <span>&amp;</span><span>adapter</span>.<span>new_interface</span>;
    <span>try</span> <span>w</span>.<span>print</span>(<span>&#34;{s}&#34;</span>, .{<span>&#34;example&#34;</span>});
    <span>// ...</span>
}</pre></div>
<h2 dir="auto">New API</h2>
<h3 dir="auto">Formatted Printing</h3>
<ul dir="auto">
<li>{t} is shorthand for <code>@tagName()</code> and <code>@errorName()</code></li>
<li>{b64}: output string as standard base64</li>
</ul>
<h3 dir="auto"><code>std.io.Writer</code> and <code>std.io.Reader</code></h3>
<p dir="auto">These have a bunch of handy new APIs that are more convenient, perform better, and are not generic. For instance look at how reading until a delimiter works now.</p>
<p dir="auto">These streams also feature some unique concepts compared with other languages&#39; stream implementations:</p>
<ul dir="auto">
<li>The concept of <strong>discarding</strong> when reading: allows efficiently ignoring data. For instance a decompression stream, when asked to discard a large amount of data, can skip decompression of entire frames.</li>
<li>The concept of <strong>splatting</strong> when writing: this allows a logical &#34;memset&#34; operation to pass through I/O pipelines without actually doing any memory copying, turning an O(M*N) operation into O(M) operation, where M is the number of streams in the pipeline and N is the number of repeated bytes. In some cases it can be even more efficient, such as when splatting a zero value that ends up being written to a file; this can be lowered as a seek forward.</li>
<li>Sending a file when writing: this allows an I/O pipeline to do direct fd-to-fd copying when the operating system supports it.</li>
<li>The stream user provides the buffer, but the stream implementation decides the minimum buffer size. This effectively moves state from the stream implementation into the user&#39;s buffer</li>
</ul>
<h3 dir="auto"><code>std.fs.File.Reader</code></h3>
<p dir="auto">Memoizes key information about a file handle such as:</p>
<ul dir="auto">
<li>The size from calling stat, or the error that occurred therein.</li>
<li>The current seek position.</li>
<li>The error that occurred when trying to seek.</li>
<li>Whether reading should be done positionally or streaming.</li>
<li>Whether reading should be done via fd-to-fd syscalls (e.g. <code>sendfile</code>)</li>
</ul>
<p dir="auto">Fulfills the <code>std.io.Reader</code> interface.</p>
<p dir="auto">This API turned out to be super handy in practice. Having a concrete type to pass around that memoizes file size is really nice.</p>
<h3 dir="auto"><code>std.fs.File.Writer</code></h3>
<p dir="auto">Same idea but for writing.</p>
<h2 dir="auto">What&#39;s NOT Included in this Branch</h2>
<p dir="auto">This is part of a series of changes leading up to &#34;I/O as an Interface&#34; and Async/Await Resurrection. However, this branch does not do any of that. It also does not do any of these things:</p>
<ul dir="auto">
<li>Rework tls</li>
<li>Rework http</li>
<li>Rework json</li>
<li>Rework zon</li>
<li>Rework zstd</li>
<li>Rework flate</li>
<li>Rework zip</li>
<li>Rework package fetching</li>
<li>Delete fifo.LinearFifo</li>
<li>Delete the deprecated APIs mentioned above</li>
</ul>
<p dir="auto">I have done all the above in a separate branch and plan to upstream them one at a time in follow-up PRs, eliminating dependencies on the old streaming APIs like a game of pick-up-sticks.</p>
<h2 dir="auto">Merge Checklist:</h2>
<ul>
<li> fix failing behavior tests</li>
<li> fix failing std lib tests</li>
<li> solve the TODOs in std.io.Writer</li>
<li> finish implementing std.fs.File.Writer which doesn&#39;t handle positional mode. this is probably breaking caching which now relies on the manifest being written positionally to save from having to seek.</li>
<li> figure out what to do about count: usize vs count: u64
<ul dir="auto">
<li>I&#39;d rather not have this field but I don&#39;t see how to get rid of it</li>
</ul>
</li>
</ul>
    </div>
  </task-lists>
  
</div>

      </div></div>
  </body>
</html>
