<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://szymonkaliski.com/writing/2023-10-02-building-a-diy-pen-plotter/">Original</a>
    <h1>Building a DIY Pen Plotter</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>This article documents my learnings from designing and building a <a href="https://szymonkaliski.com/projects/diy-pen-plotter">DIY Pen Plotter</a> during the summer of 2023.
My ultimate goal is to build my own CNC machine, and a pen-plotter seemed like a good stepping stone towards this project — this is an important context for how I designed this machine, as if I only wanted a pen-plotter, a lot of things could be simplified.</p>
<div><div data-is-processed="true"><figure><span>
      <span></span>
  <img alt="Fusion 360 design" title="Fusion 360 design" src="https://szymonkaliski.com/static/deb3ff6c502b64dd2168d7c891a1a8a0/87339/design.png" srcset="/static/deb3ff6c502b64dd2168d7c891a1a8a0/4d463/design.png 360w, /static/deb3ff6c502b64dd2168d7c891a1a8a0/eefce/design.png 720w, /static/deb3ff6c502b64dd2168d7c891a1a8a0/87339/design.png 1440w, /static/deb3ff6c502b64dd2168d7c891a1a8a0/88b03/design.png 1920w" sizes="(max-width: 1440px) 100vw, 1440px" loading="lazy"/>
    </span></figure></div></div>
<p>My hope is that this collection of notes will be useful to you if you ever embark on a similar project:</p>
<ul>
<li><a href="#designing">Designing</a></li>
<li><a href="#materials">Materials</a></li>
<li><a href="#electronics">Electronics</a></li>
<li><a href="#grbl"><code>GRBL</code></a></li>
<li><a href="#g-code"><code>G-Code</code></a></li>
</ul>

<p>Up to this point, all my designs for 3D-printed objects were either made in code (using my own tools, of course: <a href="https://szymonkaliski.com/projects/modeler">Modeler</a> and <a href="https://szymonkaliski.com/projects/hiccup-sdf">hiccup-sdf</a>) or using <a href="https://solvespace.com/index.pl">SolveSpace</a>.</p>
<p>The code-based approach is great for parametric designs or art projects (like <a href="https://szymonkaliski.com/projects/fabfungus">FabFungus</a>), while SolveSpace is awesome for quick sketches.
In this project I had to figure out how to combine multiple parts together, and there was just no way around trying a serious tool — I went with <a href="https://www.autodesk.com/products/fusion-360/">Fusion 360</a> just because I had heard about it previously.</p>
<p>You can easily find a ton of &#34;get started with&#34; tutorials for Fusion 360 on YouTube — I can&#39;t point to one that was the most helpful.
I just watched a couple of them and started playing around with the tool (which is free for personal use).</p>
<p>When designing 3D-printed parts to connect real-life objects, you&#39;ll want to reference these objects in CAD.
You can model them yourself, but usually it&#39;s possible to find them in the <a href="https://grabcad.com/library">GrabCAD Library</a>.
For Fusion 360 you want <code>.stp</code> files, which you can add to your project.
<a href="https://www.autodesk.com/products/fusion-360/blog/import-step-file-into-fusion-360/">Here&#39;s a tutorial from Autodesk</a>.</p>
<p>3D-printed objects tend to shrink after they are printed.
Nothing in reality fits as perfectly as what you design in CAD.
If you make an exact 20mm by 20mm hole for an aluminum profile, there&#39;s a big chance that it just won&#39;t fit after the print.
What I did, was print a couple of draft versions of the part with various sizing adjustments to test what fits exactly right, and then used that throughout the design.
For example, in my setup, this meant printing 3.2mm instead of 3mm holes for M3 screws, 8.4mm instead of 8mm for the rotating trapezoidal screw, etc.</p>
<p>For Fusion 360 itself, I recommend adjusting two settings:</p>
<ul>
<li><a href="https://www.autodesk.com/support/technical/article/caas/sfdcarticles/sfdcarticles/How-to-improve-trackpad-modelling-for-Fusion-360.html">Turning on native trackpad support</a> for a better trackpad experience.</li>
<li><a href="https://www.autodesk.com/support/technical/article/caas/sfdcarticles/sfdcarticles/How-to-optimize-settings-in-Fusion-360-for-performance.html#:~:text=Disable%C2%A0all%20the%20effects%20in%20the%20Display%20Settings">Disabling graphic effects</a> for much better performance.</li>
</ul>
<p>As for the design itself, I wouldn&#39;t recommend going for wheels for the Y-axis, as you can see in the picture above.
It&#39;s very hard to get the tolerances just right, and my Z-axis is very wobbly.
This is fine for a pen-plotter, but a no-go for CNC.
I&#39;m planning on redesigning this to use two linear rods with linear bearings, which should create a much more rigid structure than the one I have for the Z-axis.</p>

<p>The way most DIY 3D-printers, pen-plotters, and CNC&#39;s are built is by combining widely available prefabricates with 3D-printed objects.</p>
<p>I designed the body of my pen-plotter using:</p>
<ul>
<li>20x20mm aluminum extrusions (often called just <code>2020</code>)</li>
<li>10mm linear rods and matching 10mm linear bearings (<code>LM10UU</code>)</li>
<li>8mm ACME lead screws with matching lead screw nuts</li>
<li><code>NEMA17</code>-clones for motors</li>
<li>aluminum couplings for connecting the motors with the lead screws</li>
</ul>
<p>Another option for transforming the motor&#39;s rotation into linear motion is by using belts, but I decided that the lead screws would be better for the CNC, as intuitively, it feels like more force can be transferred this way.
Also, I don&#39;t have to worry about tightening the belts.</p>
<p>For getting these parts, 3D-printer shops are your best bet.
Motors can get quite expensive, and I just went with the cheapest ones I could find.
The aluminum extrusions, rods and lead screws you can get cut to size (or cut on your own if you have the proper tools), but I managed to just find ones that fit my build (and sometimes I designed around what I could find).</p>
<p>For connecting the extrusions to 3D-printed parts, I used the standard approach of adding T-nuts in the profiles, leaving holes in the design where the T-nut should be, and screwing them together.
If you&#39;ve ever assembled a 3D-printer, you know what I&#39;m talking about, if not, just search YouTube for T-nuts, I guess.</p>
<div>
  <div data-is-processed="true"><figure><span>
      <span></span>
  <img alt="linear bearing sandwich" title="linear bearing sandwich" src="https://szymonkaliski.com/static/3cdf3461c56ad08759ecb8ac8bd24153/87339/linear-bearing-sandwich.png" srcset="/static/3cdf3461c56ad08759ecb8ac8bd24153/4d463/linear-bearing-sandwich.png 360w, /static/3cdf3461c56ad08759ecb8ac8bd24153/eefce/linear-bearing-sandwich.png 720w, /static/3cdf3461c56ad08759ecb8ac8bd24153/87339/linear-bearing-sandwich.png 1440w, /static/3cdf3461c56ad08759ecb8ac8bd24153/0d4f8/linear-bearing-sandwich.png 1600w" sizes="(max-width: 1440px) 100vw, 1440px" loading="lazy"/>
    </span></figure></div>
</div>
<p>The linear bearings are sandwiched between two 3D-printed parts that I screw together.
This was the part of the design that I had to do the most trial-and-error to fit perfectly.</p>

<p>To move the motors, you&#39;ll need a couple of electronic parts.
I went with what seems to be a standard setup:</p>
<ul>
<li>Arduino CNC Shield</li>
<li>four <code>A4988</code> motor drivers</li>
<li>cheap Arduino UNO clone I had in my drawer</li>
<li>a power supply — I had a 3A 12V one in my drawer too, and it seems to do just fine</li>
<li>end-stops — anything that you&#39;ll find in your electronic store of choice should be just fine, I went with the cheapest mechanical ones I could find (two per axis, so six in total)</li>
</ul>
<p>You&#39;ll want to set up <code>VRef</code> for your motor drivers — again, there are a ton of tutorials about that on YouTube.
This is mainly so the motors don&#39;t overheat.</p>
<p>End-stops are a safety feature, so the machine gets a &#34;hard stop&#34; when it physically hits a certain limit (instead of destroying itself).
They can be &#34;normally opened&#34; (NO) or &#34;normally closed&#34; (NC).
I went with &#34;normally closed&#34;, as they are safer — if a wire connection breaks for whatever reason, the result will be the same as if the end-stop was triggered.
With &#34;normally opened&#34; ones, we don&#39;t get that safety.</p>
<p>Properly wiring two &#34;normally closed&#34; end-stops per axis wasn&#39;t immediately obvious to me, especially going through the CNC Shield.
What seems to work is wiring them in sequence, connecting one end to the axis end-stop pin and the other to the ground, like so:</p>
<div><div data-is-processed="true"><figure><span>
      <span></span>
  <img alt="End-stop wiring diagram" title="End-stop wiring diagram" src="https://szymonkaliski.com/static/5688a02e518b9e18e2b597ab817b8f4c/87339/end-stop-diagram.png" srcset="/static/5688a02e518b9e18e2b597ab817b8f4c/4d463/end-stop-diagram.png 360w, /static/5688a02e518b9e18e2b597ab817b8f4c/eefce/end-stop-diagram.png 720w, /static/5688a02e518b9e18e2b597ab817b8f4c/87339/end-stop-diagram.png 1440w, /static/5688a02e518b9e18e2b597ab817b8f4c/88b03/end-stop-diagram.png 1920w" sizes="(max-width: 1440px) 100vw, 1440px" loading="lazy"/>
    </span></figure></div></div>
<p>To debug the motors and end-switches wiring with the CNC Shield, it&#39;s best to use simple ad-hoc Arduino code instead of going for a full GRBL install, as it introduces another layer of indirection and makes it harder to pinpoint where the issue might be coming from.</p>
<p>Below is the code I used to see if I could move one motor.
To test different motors, adjust the <code>dirPin</code> and <code>stepPin</code> which you can find by looking for the CNC Shield pinout.</p>
<pre><code><span>#<span>define</span> dirPin 5</span>
<span>#<span>define</span> stepPin 2</span>
<span>#<span>define</span> enablePin 8</span>


<span>#<span>define</span> stepsPerRevolution 200</span>
<span>#<span>define</span> microsPulseWidth 250</span>
<span>#<span>define</span> microsBetweenSteps 1000</span>

<span><span>void</span> <span>setup</span><span>()</span> </span>{
  <span>pinMode</span>(stepPin, <span>OUTPUT</span>);
  <span>pinMode</span>(dirPin, <span>OUTPUT</span>);
  <span>pinMode</span>(enablePin, <span>OUTPUT</span>);
  <span>digitalWrite</span>(enablePin, <span>LOW</span>);
}

<span><span>void</span> <span>stepMotor</span><span>()</span> </span>{
  <span>digitalWrite</span>(stepPin, <span>HIGH</span>);
  <span>delayMicroseconds</span>(microsPulseWidth);
  <span>digitalWrite</span>(stepPin, <span>LOW</span>);
  <span>delayMicroseconds</span>(microsBetweenSteps);
}

<span><span>void</span> <span>loop</span><span>()</span> </span>{
  
  <span>digitalWrite</span>(dirPin, <span>HIGH</span>);
  <span>for</span> (<span>int</span> i = <span>0</span>; i &lt; <span>5</span> * stepsPerRevolution; i++) {
    stepMotor();
  }

  <span>delay</span>(<span>1000</span>);

  
  <span>digitalWrite</span>(dirPin, <span>LOW</span>);
  <span>for</span> (<span>int</span> i = <span>0</span>; i &lt; <span>5</span> * stepsPerRevolution; i++) {
    stepMotor();
  }

  <span>delay</span>(<span>1000</span>);
}</code></pre>
<p>And here&#39;s what I used to debug the end-stops:</p>
<pre><code><span>#<span>define</span> xLimitPin 9</span>
<span>#<span>define</span> yLimitPin 10</span>
<span>#<span>define</span> zLimitPin 11</span>

<span><span>void</span> <span>setup</span><span>()</span> </span>{
  <span>Serial</span>.<span>begin</span>(<span>115200</span>);
  <span>pinMode</span>(xLimitPin, <span>INPUT_PULLUP</span>);
  <span>pinMode</span>(yLimitPin, <span>INPUT_PULLUP</span>);
  <span>pinMode</span>(zLimitPin, <span>INPUT_PULLUP</span>);
}

<span><span>void</span> <span>loop</span><span>()</span> </span>{
  <span>Serial</span>.<span>print</span>(<span>&#34;x = &#34;</span>);
  <span>Serial</span>.<span>print</span>(<span>digitalRead</span>(xLimitPin));
  <span>Serial</span>.<span>print</span>(<span>&#34;y = &#34;</span>);
  <span>Serial</span>.<span>print</span>(<span>digitalRead</span>(yLimitPin));
  <span>Serial</span>.<span>print</span>(<span>&#34;z = &#34;</span>);
  <span>Serial</span>.<span>println</span>(<span>digitalRead</span>(zLimitPin));

  <span>delay</span>(<span>200</span>);
}</code></pre>

<p>Once all the axes move and the end-stops are wired properly, it&#39;s time to start controlling the machine with G-code, the standard for 3D-printers and CNC machines.</p>
<p>Luckily, there&#39;s an open-source G-code interpreter for Arduino UNO and the CNC Shield called <a href="https://github.com/gnea/grbl"><code>grbl</code></a>.
The installation is pretty straight-forward, and described <a href="https://github.com/gnea/grbl/wiki/Compiling-Grbl">here</a> — you basically add <code>grbl</code> as an Arduino library and then upload the only sketch that it provides: <code>GrblUpload</code>.</p>
<p>There&#39;s one adjustment I had to make in <code>config.h</code>, the configuration for the controller — I commented out <code>#define VARIABLE_SPINDLE</code> which conflicts with Z-axis end-stops.</p>
<p>Once <code>grbl</code> is running on the Arduino, the real fun starts — configuring all of its settings.
You can do this directly through the Arduino serial console, but I decided to switch to a GUI, so it&#39;s easier to test and control the machine.
I went with <a href="https://cnc.js.org"><code>cncjs</code></a>, after testing a couple of other apps that didn&#39;t seem to work correctly for whatever reason.</p>
<p>For the configuration, there&#39;s a lengthy documentation on the <a href="https://github.com/gnea/grbl/wiki/Grbl-v1.1-Configuration"><code>grbl</code> wiki</a>; here are the things that I did:</p>
<ul>
<li>calculated steps per mm for the motor movement, as described <a href="https://github.com/gnea/grbl/wiki/Grbl-v1.1-Configuration#100-101-and-102--xyz-stepsmm">here</a></li>
<li>adjusted maximum rate for the motor&#39;s, as described <a href="https://github.com/gnea/grbl/wiki/Grbl-v1.1-Configuration#110-111-and-112--xyz-max-rate-mmmin">here</a></li>
<li><a href="https://github.com/gnea/grbl/wiki/Grbl-v1.1-Configuration#3--direction-port-invert-mask">inverted</a> some of the motors axes to move in a predictable way</li>
<li>
<!-- -->enabled end-stops:<!-- -->
<ul data-isnt-top-level="true">
<li>they had to be <a href="https://github.com/gnea/grbl/wiki/Grbl-v1.1-Configuration#5----limit-pins-invert-boolean">inverted</a> since they are &#34;normally closed&#34;</li>
<li>they had to be <a href="https://github.com/gnea/grbl/wiki/Grbl-v1.1-Configuration#21---hard-limits-boolean">enabled</a></li>
<li>and with this, the homing cycle (automatic corner finding) can be <a href="https://github.com/gnea/grbl/wiki/Grbl-v1.1-Configuration#22---homing-cycle-boolean">enabled</a> too</li>
</ul>
</li>
<li>finally, I homed the machine (using the button in the GUI), and stepped it manually to the other end-stop to figure out the <a href="https://github.com/gnea/grbl/wiki/Grbl-v1.1-Configuration#130-131-132--xyz-max-travel-mm">soft limits</a> (which also have to be <a href="https://github.com/gnea/grbl/wiki/Grbl-v1.1-Configuration#20---soft-limits-boolean">enabled</a>)</li>
</ul>

<p>To plot anything, the machine needs G-code describing the sequence of motor moves.
There are many ways of generating it, the one I went with was <a href="https://github.com/abey79/vpype"><code>vpype</code></a> and <a href="https://github.com/plottertools/vpype-gcode"><code>vpype-gcode</code></a> — a powerful command-line tool for everything SVG and plotters.</p>
<p>Since this is a completely custom pen-plotter, I had to create my own configuration for <code>vpype-gcode</code>, which looks like this:</p>
<pre><code><span>[gwrite.plotter]</span>

<span>document_start</span> = <span>&#39;&#39;&#39;
$H       ; find home first
G21      ; mm units
G17      ; xy plane
G91      ; relative coords
&#39;&#39;&#39;</span>
<span>document_end</span> = <span>&#39;&#39;&#39;
M2       ; program end
&#39;&#39;&#39;</span>

<span>segment_first</span> = <span>&#39;&#39;&#39;
G00 X{dx:.4f} Y{dy:.4f}
G00 Z-20 ; pen down
&#39;&#39;&#39;</span>
<span>segment</span> = <span>&#39;&#39;&#39;
G00 X{dx:.4f} Y{dy:.4f}
&#39;&#39;&#39;</span>
<span>segment_last</span> = <span>&#39;&#39;&#39;
G00 X{dx:.4f} Y{dy:.4f}
G00 Z20  ; pen up
&#39;&#39;&#39;</span>

<span>unit</span> = <span>&#34;mm&#34;</span>
<span>vertical_flip</span> = <span>true</span></code></pre>
<p>To plot an SVG file I first call:</p>
<pre><code>vpype --config vpype-config.toml <span>read</span> image.svg gwrite -p plotter image.gcode</code></pre>
<p>And then I load the <code>image.gcode</code> file into <code>cncjs</code>, and hit &#34;run&#34;.</p>

<p><a href="https://mattferraro.dev/posts/cnc-router">Anatomy of a CNC Router</a> covers materials and software in way more detail than I did here.
<a href="https://wiki.printnc.info/en/home">PrintNC</a> is the recommended route if you want a DIY project, but not one made completely from scratch.</p></div></div></div>
  </body>
</html>
