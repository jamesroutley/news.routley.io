<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://veryth.ink/blog/simple-notifications/">Original</a>
    <h1>Simple Remote System Notifications</h1>
    
    <div id="readability-page-1" class="page"><section><p>How I configured a server to notify my personal computer and smart-phone when I have new mail.</p><span id="continue-reading"></span><hr/><p>A friend of mine dropped off a NAS/home-lab of his with me to look after and host while he is abroad. We got around to getting it configured and networked yesterday, after which he made me a user account. I started idly poking around a bit to see what I could do on this system when I remembered the often ignored (by me) <code>mail</code> system. Out of curiosity, I began to learn how to use it, and of course, I sent some obligatory test messages to my friend&#39;s user to bother him whenever he ssh&#39;d in next.</p><p>Now, I didn&#39;t expect to receive a lot of mail on this system, but it got me wondering about how I could alert myself to new messages (or other events) without having to remember to login and check frequently.</p><p>There are a number of ways to be alerted or notified of something. For instance, one can trigger an email sent to themselves, or perhaps by placing a VOIP call, or they could even start a signal fire. But I wanted something that would work on any of my devices, and simple to configure without fiddling with any system configuration on the server itself - perhaps as easy as sending a request to another server, even?</p><p>Before I begin detailing how I went about solving this, I want to make it clear that I purposefully did not look into whether or not there was existing software out there that solves this specific problem. I just wanted to craft my own simple solution, albeit still relying heavily on the efforts of others.</p><h2 id="ntfy">ntfy</h2><p>I remembered having heard of a simple, self-hostable, open-source service called <a href="https://ntfy.sh"><em>ntfy</em></a> that seemed to be a good match for what I was looking for.</p><p><em>ntfy</em> (pronounced &#34;notify&#34;) is a very simple, but flexible service that allows users to generate a <strong>topic</strong>, subscribe other devices with a <em>ntfy</em> client to that <strong>topic</strong>, and send <code>POST</code> or <code>PUT</code> requests to that <strong>topic</strong> to create a new notification! Here&#39;s an example:</p><pre data-lang="txt"><code data-lang="txt"><span>curl -d &#34;Hello, World!&#34; ntfy.sh/test-topic-plz-ignore
</span></code></pre><p>Any client that had subscribed to <code>test-topic-plz-ignore</code> at the time of sending would receive a notification with the contents of the <code>--data</code> flag. There are <a href="https://docs.ntfy.sh/publish/">loads of other features</a> that let one further control the notification&#39;s appearance, meta-data, etc. But this is all I needed to begin.</p><h2 id="bit-of-bash">Bit of bash</h2><p>So, to test that this worked for me, I quickly wrote the following bash script.</p><pre data-lang="sh"><code data-lang="sh"><span>#!/usr/bin/env bash
</span><span>
</span><span>USER</span><span>=</span><span>&#34;</span><span>[REDACTED]</span><span>&#34;
</span><span>MAIL_FILE</span><span>=</span><span>&#34;</span><span>/var/mail/</span><span>$</span><span>USER</span><span>&#34;
</span><span>NOTIFY_SERVER</span><span>=</span><span>&#34;</span><span>https://ntfy.sh</span><span>&#34;
</span><span>TOPIC</span><span>=</span><span>&#34;</span><span>[REDACTED]</span><span>&#34;
</span><span>REQUEST_URL</span><span>=</span><span>&#34;</span><span>$</span><span>NOTIFY_SERVER</span><span>/</span><span>$</span><span>TOPIC</span><span>&#34;
</span><span>
</span><span>if [ </span><span>-s </span><span>&#34;</span><span>$</span><span>MAIL_FILE</span><span>&#34; </span><span>]; then
</span><span>    </span><span>MSG_COUNT</span><span>=</span><span>&#34;</span><span>$</span><span>(</span><span>grep </span><span>&#39;</span><span>Message-Id</span><span>&#39; </span><span>$</span><span>MAIL_FILE -c</span><span>)</span><span>&#34;
</span><span>    </span><span>curl</span><span> -d </span><span>&#34;</span><span>You have </span><span>$</span><span>MSG_COUNT</span><span> new message(s)</span><span>&#34; </span><span>$</span><span>REQUEST_URL
</span><span>fi
</span></code></pre><p>This may be a simple script, but I&#39;ll break it down anyway:</p><ol start="9"><li>Uses <code>test</code>&#39;s <code>-s</code> flag to check if the mail file has any contents</li><li>Uses <code>grep</code>&#39;s <code>-c</code> flag to return the number of occurrences of &#39;Message-Id&#39; (indicating unique messages)</li><li>Finally, we make the request containing the notification body with <code>curl</code>!</li></ol><p>And after running this script on a mail file I had locally, I could verify it worked! It was now time to figure out scheduling.</p><h2 id="some-systemd">Some systemd</h2><p>When I was exploring the server&#39;s system earlier, I had noticed the presence of <code>systemd</code> so, in an effort to familiarize myself with the utility more, I decided to use it for my scheduling needs - although, a simple cronjob would certainly have sufficed.</p><p>First, I defined the service file in my remote user&#39;s home directory.</p><p><code>~/.config/systemd/user/check-mail.service</code></p><pre data-lang="ini"><code data-lang="ini"><span>[Unit]
</span><span>Description</span><span>=</span><span>&#34;notify if there&#39;s new mail&#34;
</span><span>
</span><span>[Service]
</span><span>Type</span><span>=</span><span>oneshot
</span><span>ExecStart</span><span>=%h/.</span><span>local</span><span>/</span><span>bin</span><span>/</span><span>check</span><span>-</span><span>mail</span><span>.</span><span>sh
</span></code></pre><p>Then, I defined a timer file which specifies a service to run at defined intervals.</p><p><code>~/.config/systemd/user/check-mail.timer</code></p><pre data-lang="ini"><code data-lang="ini"><span>[Unit]
</span><span>Description</span><span>=</span><span>&#34;timer for check-mail.service&#34;
</span><span>
</span><span>[Timer]
</span><span>OnBootSec</span><span>=</span><span>5min
</span><span>OnUnitActiveSec</span><span>=</span><span>15min
</span><span>Unit</span><span>=</span><span>check</span><span>-</span><span>mail</span><span>.</span><span>service
</span><span>
</span><span>[Install]
</span><span>WantedBy</span><span>=</span><span>default</span><span>.</span><span>target
</span></code></pre><p>I then reloaded the systemd user daemon with <code>systemd --user daemon-reload</code>, and immediately enabled the timer with <code>systemd --user enable --now check-mail.timer</code>. After waiting several minutes (and amending some incorrectly defined paths ðŸ¤«), I confirmed that this indeed worked!</p><h2 id="improvements">Improvements</h2><p>I&#39;m currently satisfied with the above, but of course, I&#39;ve already identified several ways this could be improved.</p><p>It would be preferred to only trigger a notification when there are new and previously un-notified messages that remain unread. Right now, this script will spam me with notifications every 15-minutes until I handle them all - not ideal. I could probably fix this easily by hashing the mail file and storing the value between runs, comparing hashes on the next run and triggering a new notification if they don&#39;t match. This also comes with the benefit of being able to tighten-up the interval a bit to get more immediate notifications, if I preferred.</p><p>Hard-coding variables in my script is perfectly acceptable for my own use, but if I were to ever consider releasing this for others to use I would want to add basic command-line arguments, environment variable support, perhaps even configuration file support.</p><p>Additionally, before releasing, I&#39;d want to do research into how other mail systems populate unread mail to ensure that this solution functions for common environments and systems.</p><p>Thanks for reading this short post!</p><p>I want to take a moment to give a quick shout-out to <a href="https://blog.heckel.io/about/">Philipp C. Heckel</a>, the creator of <a href="https://ntfy.sh">ntfy.sh</a>, for publishing and maintaining his easy-to-use, well-documented, and open-source software! This would have taken much more effort to solve without his work being available to use freely. This post was not sponsored by him in any way, I&#39;m just grateful for his efforts. :)</p><p>If you enjoyed reading this, and/or want to share how you&#39;ve solved a similar problem, please consider sharing via one of the methods listed <a href="https://veryth.ink/about">here</a>. Notice anything incorrect about this or any other post? Please let me know!</p><p>Until next time.</p><p>- crenfrow</p></section></div>
  </body>
</html>
