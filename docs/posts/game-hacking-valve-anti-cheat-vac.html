<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://codeneverdies.github.io/posts/gh-2/">Original</a>
    <h1>Game Hacking – Valve Anti-Cheat (VAC)</h1>
    
    <div id="readability-page-1" class="page"><div id="content"><hr/><blockquote><h2 id="intro">Intro</h2></blockquote><p>In 2002 Valve created an Anti-Cheat solution called “Valve Anti-Cheat” aka <strong>VAC</strong>.
The first game they implemented VAC into was Counter-Strike. When <strong>VAC</strong> was introduced it only operated in
User Mode (Still does) meaning it runs entirely in user space <sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> and has no kernel component.</p><p>Below is a list of games that use <strong>VAC</strong>.. <sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup></p><pre><code>Call of Duty: Modern Warfare 2
Call of Duty: Modern Warfare 3
Counter-Strike (video game)
Counter-Strike: Condition Zero
Counter-Strike: Source
Counter-Strike 2
Day of Defeat
Day of Defeat: Source
Deathmatch Classic
Half-Life 2: Deathmatch
Half-Life Deathmatch: Source
Ricochet
Team Fortress
Team Fortress Classic
</code></pre><p>A longer list can be found here <sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>.</p><hr/><blockquote><h2 id="vac-cident">VAC-cident?</h2></blockquote><p>So.. if you don’t know <strong>VAC</strong> has been around for quite a while, at the time of writing it’ll be 23 years.
Over the time they’ve made some mistakes but who doesn’t? (Taken from wikipedia) <sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup> <sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup></p><pre><code>- In July 2010, [snip] Approximately 12,000 owners of Call of Duty: Modern Warfare 2 were 
banned when Steam updated a DLL file on disk after it had been loaded into memory by the 
game, causing a false positive detection. These bans were revoked and those affected received 
a free copy of Left 4 Dead 2 or an extra copy to send as a gift. 

- In October 2023, certain users of AMD graphics cards were banned from Counter-Strike 2 
after AMD added support for their &#34;Anti-Lag+&#34; feature via a driver update, which the game 
flagged as a cheat due to it detouring certain DLL functions. AMD subsequently withdrew the 
driver update and Valve pledged to unban any affected users.
</code></pre><p>This post isn’t created to bash Valve they clean up after their mistakes and listen to their community,
gotta love devs when they do that. I also commend them because getting <strong>VAC</strong> banned isn’t such a slap
on the wrist. Getting <strong>VAC</strong> banned has some stipulations such as:</p><ul><li>Having the <strong>VAC</strong> ban show on your Steam profile</li><li>Being banned from all <strong>“GoldSrc”</strong> games</li><li>Being banned from all <strong>“Source engine”</strong> games (The Counter-Strike serise)</li><li>Not being able to <strong>refund</strong> the game you’re <strong>VAC</strong> banned on</li></ul><p>Knowing what’ll happen if you get <strong>VAC</strong> banned is important to know because regardless if
you’re cheating or not false bans are no good. People in the community took it upon themselves
to reverse engineer the Anti-Cheat and understand what it does (some did it just to cheat).</p><hr/><blockquote><h2 id="vac-what">VAC what?</h2></blockquote><p>The previous section brings us to a term you may have heard before, the infamous <strong>“VAC Bypass”</strong>.
Searching online for information about bypassing <strong>VAC</strong> brings many blogs and repos that all seem to do/talk about something
similar and that’s “Dumping the <strong>VAC</strong> modules”. Let me explain, <strong>VAC</strong> is <strong>NOT</strong> just one executable on the system it streams it’s
Anti-Cheat modules (DLLs) from a server, once a module is recieved by some routine in <strong>steamservice.dll</strong> inside <strong>steamservice.exe</strong>
(or <strong>steam.exe</strong> if <strong>ran as admin</strong>) it will be loaded using one of the two methods below. <sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup> <sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup> <sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup> <sup id="fnref:9"><a href="#fn:9" role="doc-noteref">9</a></sup> <sup id="fnref:10"><a href="#fn:10" role="doc-noteref">10</a></sup> <sup id="fnref:11"><a href="#fn:11" role="doc-noteref">11</a></sup> <sup id="fnref:12"><a href="#fn:12" role="doc-noteref">12</a></sup> <sup id="fnref:13"><a href="#fn:13" role="doc-noteref">13</a></sup></p><ul><li><strong>Reflectively load</strong> the DLL into memory</li><li>Use the WinAPI function <strong>LoadLibrary</strong></li></ul><p>By default the Anti-Cheat modules are reflectively loaded into memory. The goal is to force <strong>LoadLibrary</strong> into being used,
then someone can hook that function and dump the modules (DLLs) to disk, allowing someone to analyse the dumped DLLs and understand
what they’re doing to detect cheating.</p><hr/><blockquote><h2 id="dumping-vac-modules-in-the-big-25">Dumping VAC Modules in the big ‘25</h2></blockquote><p>To kick start the journey on dumping the <strong>VAC</strong> modules load <strong>steamservice.dll</strong> into <strong>Binary Ninja</strong>. Once the binary is fully analyzed
go to “Triage Summary”</p><blockquote><p><img src="https://codeneverdies.github.io/svg/loading.min.svg" data-src="/VAC-1.png" data-srcset="/VAC-1.png, /VAC-1.png 1.5x, /VAC-1.png 2x" data-sizes="auto" alt="/VAC-1.png" title="VAC-1"/></p></blockquote><p>It is <strong>VERY</strong> important to take note that this is a 32-bit process, so all pointers will be 32-bits in size you’ll see why this is important later.</p><p>Next we’ll search for calls to <strong>LoadLibrary*</strong> I’ll save the reader some time and tell you that we should be looking
for calls to <strong>LoadLibraryW</strong> it will be called in a very important function that we can use to back track.</p><blockquote><p><img src="https://codeneverdies.github.io/svg/loading.min.svg" data-src="/VAC-2.png" data-srcset="/VAC-2.png, /VAC-2.png 1.5x, /VAC-2.png 2x" data-sizes="auto" alt="/VAC-2.png" title="VAC-2"/></p></blockquote><p>Following the reference takes us to an interesting function <strong>sub_10086f80</strong></p><blockquote><p><img src="https://codeneverdies.github.io/svg/loading.min.svg" data-src="/VAC-3.png" data-srcset="/VAC-3.png, /VAC-3.png 1.5x, /VAC-3.png 2x" data-sizes="auto" alt="/VAC-3.png" title="VAC-3"/></p></blockquote><p>Judging by the return value <strong>HMODULE</strong> and the calls to LoadLibrary* it’s safe to say this function’s job is to load
some kind of module and return a handle to it. Following references to where this function is called leads us to another interesting
function <strong>sub_10086c40</strong>.</p><blockquote><p><img src="https://codeneverdies.github.io/svg/loading.min.svg" data-src="/VAC-4.png" data-srcset="/VAC-4.png, /VAC-4.png 1.5x, /VAC-4.png 2x" data-sizes="auto" alt="/VAC-4.png" title="VAC-4"/></p></blockquote><p>The beginning of the <strong>sub_10086c40</strong> function didn’t look too important (at the time) but we should remember that this function also returns a handle to a module.
I looked at the references and it shows that this function is called once in the function <strong>sub_10059040</strong>.</p><blockquote><p><img src="https://codeneverdies.github.io/svg/loading.min.svg" data-src="/VAC-17.png" data-srcset="/VAC-17.png, /VAC-17.png 1.5x, /VAC-17.png 2x" data-sizes="auto" alt="/VAC-17.png" title="VAC-17"/></p></blockquote><p>We can see <strong>sub_10086c40</strong> being called if we trace back the <strong>first</strong> argument passed to that function,
we’ll see that it was used by another function <strong>sub_100859d0</strong>. If that function call is successful
execution carries on, so it’s safe to say it’s important. Let’s take a look at this function.</p><blockquote><p><img src="https://codeneverdies.github.io/svg/loading.min.svg" data-src="/VAC-18.png" data-srcset="/VAC-18.png, /VAC-18.png 1.5x, /VAC-18.png 2x" data-sizes="auto" alt="/VAC-18.png" title="VAC-5"/></p></blockquote><p>This function makes two WinAPI calls</p><ul><li><p><strong>GetTempPathW</strong>
: Retrieves the path of the directory designated for temporary files.</p></li><li><p><strong>GetTempFileNameW</strong>
: Creates a name for a temporary file. If a unique file name is generated, an empty file is created and the handle to it is released; otherwise, only a file name is generated.</p></li></ul><p>The combination of these calls tells us that we need to be looking for any <code>.TMP</code> files being accessed, the names are usually in this format <code>&lt;uuuu&gt;.TMP</code>.</p><p>Now there’s a path to a DLL floating in memory how does it get used? Look no more.</p><blockquote><p><img src="https://codeneverdies.github.io/svg/loading.min.svg" data-src="/VAC-5.png" data-srcset="/VAC-5.png, /VAC-5.png 1.5x, /VAC-5.png 2x" data-sizes="auto" alt="/VAC-5.png" title="VAC-5"/></p></blockquote><pre tabindex="0"><code>100591f7   HMODULE eax_13 = sub_10086c40(edi_1, 0)
100591ff   *(esi + 4) = eax_13
100591ff   
10059204   if (eax_13 != 0)
10059215       int32_t eax_14 = sub_10086c20(eax_13, &#34;_runfunc@20&#34;)
1005921d       *(esi + 0xc) = eax_14
</code></pre><p>The path <code>edi_1</code> is used by <strong>sub_10086c40</strong>, this function is used to get a handle to a module <code>eax_13</code> then it’s passing that handle to <strong>sub_10086c20</strong>.
<strong>sub_10086c20</strong> takes two arguments we know the first is a handle to a module the second is from what we can see here a string <code>_runfunc@20</code>, the return value
<code>int32_t</code> looks a little weird but this is a 32-bit process remember ;) so this could be a pointer to something dont ya think? Here’s the function prototype</p><pre tabindex="0"><code>int32_t sub_10086c20(HMODULE arg1, PSTR arg2)
</code></pre><p>Place your bets on it being a GetProcAddress wrapper.. Drum roll please… It is…</p><blockquote><p><img src="https://codeneverdies.github.io/svg/loading.min.svg" data-src="/VAC-6.png" data-srcset="/VAC-6.png, /VAC-6.png 1.5x, /VAC-6.png 2x" data-sizes="auto" alt="/VAC-6.png" title="VAC-6"/></p></blockquote><p>So with this bit of information we know <strong>steamservice.dll</strong> recieves the <strong>VAC</strong> modules, it’s using a function <strong>sub_10086c40</strong> which calls
<strong>sub_10086f80</strong> to load the Anti-Cheat module and return a handle, then that handle is passed to <strong>sub_10086c20</strong> to get the address
of a function named <code>_runfunc@20</code>. By default as said earlier the modules are reflectively loaded so this isn’t the regular control flow of
<strong>steamservice.dll</strong>, this can be confirmed if you scroll up a bit in <strong>sub_10059040</strong> you’ll see a flag being checked.</p><blockquote><p><img src="https://codeneverdies.github.io/svg/loading.min.svg" data-src="/VAC-7.png" data-srcset="/VAC-7.png, /VAC-7.png 1.5x, /VAC-7.png 2x" data-sizes="auto" alt="/VAC-7.png" title="VAC-7"/></p></blockquote><p><strong>steamservice.dll</strong> will most likely take this path unless we can do something about it</p><blockquote><p><img src="https://codeneverdies.github.io/svg/loading.min.svg" data-src="/VAC-8.png" data-srcset="/VAC-8.png, /VAC-8.png 1.5x, /VAC-8.png 2x" data-sizes="auto" alt="/VAC-8.png" title="VAC-8"/></p></blockquote><p>Let’s look at it in assembly</p><blockquote><p><img src="https://codeneverdies.github.io/svg/loading.min.svg" data-src="/VAC-9.png" data-srcset="/VAC-9.png, /VAC-9.png 1.5x, /VAC-9.png 2x" data-sizes="auto" alt="/VAC-9.png" title="VAC-9"/></p></blockquote><p>Take a look at <code>je 0x10059127</code> ( <code>0x74 0x47</code> )</p><p><code>0x74</code> is the jump if equal instruction and <code>0x47</code> is how many bytes forward to jump (71) in hex</p><p>What we wan’t to do is change the first instruction at <strong>steamservice.dll</strong> + 0x590DE (0x100590de)</p><ul><li>to <code>jne 0x10059127</code> ( <code>0x75 0x47</code> )</li></ul><p>we’re changing the first byte of this instruction to be <code>0x75</code> which is jump if <strong>NOT</strong>
zero/equal. (Inverting)</p><blockquote><p><img src="https://codeneverdies.github.io/svg/loading.min.svg" data-src="/VAC-10.png" data-srcset="/VAC-10.png, /VAC-10.png 1.5x, /VAC-10.png 2x" data-sizes="auto" alt="/VAC-10.png" title="VAC-10"/></p></blockquote><p>Now that we have a potential way of dumping the <strong>VAC</strong> modules let’s test it! first we start steam and launch <strong>x32dbg</strong> as
admin we should remember the offset to our instructions <strong>steamservice.dll</strong> + 0x590DE.</p><blockquote><p><img src="https://codeneverdies.github.io/svg/loading.min.svg" data-src="/VAC-11.png" data-srcset="/VAC-11.png, /VAC-11.png 1.5x, /VAC-11.png 2x" data-sizes="auto" alt="/VAC-11.png" title="VAC-11"/></p></blockquote><p>Once <strong>x32dbg</strong> is loaded attach to <strong>steamservice.dll</strong></p><blockquote><p><img src="https://codeneverdies.github.io/svg/loading.min.svg" data-src="/VAC-12.png" data-srcset="/VAC-12.png, /VAC-12.png 1.5x, /VAC-12.png 2x" data-sizes="auto" alt="/VAC-12.png" title="VAC-12"/></p></blockquote><p>Press <code>CTRL+G</code> and enter <code>steamservice.dll + 0x590DE</code></p><blockquote><p><img src="https://codeneverdies.github.io/svg/loading.min.svg" data-src="/VAC-13.png" data-srcset="/VAC-13.png, /VAC-13.png 1.5x, /VAC-13.png 2x" data-sizes="auto" alt="/VAC-13.png" title="VAC-13"/></p></blockquote><p>Now we’re where we need to patch</p><blockquote><p><img src="https://codeneverdies.github.io/svg/loading.min.svg" data-src="/VAC-14.png" data-srcset="/VAC-14.png, /VAC-14.png 1.5x, /VAC-14.png 2x" data-sizes="auto" alt="/VAC-14.png" title="VAC-14"/></p></blockquote><p>Right click on that instruction and click “Assemble” then enter <code>jnz 0x10059127</code> and hit ok</p><blockquote><p><img src="https://codeneverdies.github.io/svg/loading.min.svg" data-src="/VAC-15.png" data-srcset="/VAC-15.png, /VAC-15.png 1.5x, /VAC-15.png 2x" data-sizes="auto" alt="/VAC-15.png" title="VAC-15"/></p></blockquote><p>It should be changed</p><blockquote><p><img src="https://codeneverdies.github.io/svg/loading.min.svg" data-src="/VAC-16.png" data-srcset="/VAC-16.png, /VAC-16.png 1.5x, /VAC-16.png 2x" data-sizes="auto" alt="/VAC-16.png" title="VAC-16"/></p></blockquote><p>The next step is to open <strong>Procmon</strong> play a game that uses <strong>VAC</strong> (I chose CSGO) and wait for
<strong>steamservice.exe</strong> to access some <code>.TMP</code> files.</p><p>Here are the <strong>Procmon</strong> filters</p><blockquote><p><img src="https://codeneverdies.github.io/svg/loading.min.svg" data-src="/VAC-19.png" data-srcset="/VAC-19.png, /VAC-19.png 1.5x, /VAC-19.png 2x" data-sizes="auto" alt="/VAC-19.png" title="VAC-19"/></p></blockquote><p>While loading the game we see our first TMP file <code>C:\Windows\Temp\D54A.tmp</code></p><blockquote><p><img src="https://codeneverdies.github.io/svg/loading.min.svg" data-src="/VAC-20.png" data-srcset="/VAC-20.png, /VAC-20.png 1.5x, /VAC-20.png 2x" data-sizes="auto" alt="/VAC-20.png" title="VAC-20"/></p></blockquote><p>Let’s join a public match and see if there are others</p><blockquote><p><img src="https://codeneverdies.github.io/svg/loading.min.svg" data-src="/VAC-21.png" data-srcset="/VAC-21.png, /VAC-21.png 1.5x, /VAC-21.png 2x" data-sizes="auto" alt="/VAC-21.png" title="VAC-21"/></p></blockquote><p>And some more..</p><blockquote><p><img src="https://codeneverdies.github.io/svg/loading.min.svg" data-src="/VAC-22.png" data-srcset="/VAC-22.png, /VAC-22.png 1.5x, /VAC-22.png 2x" data-sizes="auto" alt="/VAC-22.png" title="VAC-22"/></p></blockquote><p>We can also look at these files in the temp directory..</p><blockquote><p><img src="https://codeneverdies.github.io/svg/loading.min.svg" data-src="/VAC-23.png" data-srcset="/VAC-23.png, /VAC-23.png 1.5x, /VAC-23.png 2x" data-sizes="auto" alt="/VAC-23.png" title="VAC-23"/></p></blockquote><p>I copied all of these files to a new directory and loaded <code>D54A.tmp</code> into <strong>PE-bear</strong></p><blockquote><p><img src="https://codeneverdies.github.io/svg/loading.min.svg" data-src="/VAC-24.png" data-srcset="/VAC-24.png, /VAC-24.png 1.5x, /VAC-24.png 2x" data-sizes="auto" alt="/VAC-24.png" title="VAC-24"/></p></blockquote><p>We see something familiar <code>_runfunc@20</code> this is the function that was found using <strong>sub_10086c20</strong>.</p><hr/><blockquote><h2 id="to-be-continued">To be continued</h2></blockquote><p>In the next post we will be doing analysis on these Anti-Cheat Modules to get a better understanding of what’s going on.
I hope you enjoyed this post and most importantly learned a thing or two. Stay tuned!</p><hr/><blockquote><h2 id="references">References</h2></blockquote></div></div>
  </body>
</html>
