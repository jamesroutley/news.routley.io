<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://szhu.github.io/lunar-lander-autopilot/">Original</a>
    <h1>Show HN: I built an autopilot for the lunar lander game</h1>
    
    <div id="readability-page-1" class="page"><div id="post_body_1950159">
    
      <div><p>My time at RC this batch has largely been exploring functional languages. With Haskell, it’s fascinating to see how lazy evaluation introduces a different paradigm. With Idris, it’s intriguing to see types as first class citizens.</p><p>We had a group viewing of the <a href="https://www.youtube.com/watch?v=832JF1o7Ck8">talk</a> on Verse by Simon Peyton-Jones yesterday. I didn&#39;t quite follow where the gaps in existing languages for what Epic Games is trying to do resulted in the the choices they made - functional logic language, declarative, lenient evaluation, static types, effect system. The main thing I came away with was confirmation that I should look into Prolog.</p><p>More generally, what I haven’t been able to put into words is how a language &#39;looks&#39;. I remember trying out Ruby (likely for Rails) but the syntax didn&#39;t quite feel as &#39;natural&#39; to me. Python felt more concise, and the ‘one way to do things’ philosophy translated naturally when I was picking up Go. Haskell looks even less familiar, perhaps here the different paradigm element keeps it separate vs comparing against imperative languages.</p><p>Learning compilers helped me think of languages as more similar to each other than different (especially now with Haskell at one end of the spectrum). Chelsea Troy summed up the Ruby vs Python difference in this <a href="https://chelseatroy.com/2021/01/31/why-learn-python/">post</a>.</p><blockquote>
<p>Ruby values expressiveness over interpretability: the artful Rubyist can construct code that reads more or less like an English sentence. Indeed, that was the intent of that language’s design. When this happens, it’s gorgeous to see. However, the inexperienced (or malevolent) Rubyist can construct code that works fine, but is utterly unintelligible.</p>
<p>Python values interpretability over expressiveness: the authors strive for there to be only one way to write something.</p>
</blockquote><p>To clarify, I&#39;m not saying it&#39;s a good or bad, just different. I’ll be sure to bring this up at coffee chats to get a better perspective.</p></div>
    
  </div></div>
  </body>
</html>
