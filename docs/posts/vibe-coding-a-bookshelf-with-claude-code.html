<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://balajmarius.com/writings/vibe-coding-a-bookshelf-with-claude-code/">Original</a>
    <h1>Show HN: Vibe coding a bookshelf with Claude Code</h1>
    
    <div id="readability-page-1" class="page"><article><p>I own more books than I can read. Not in a charming, aspirational way, but in
the practical sense that at some point I stopped knowing what I owned.
Somewhere around 500 books, memory stopped being a reliable catalog.</p>
<p>For years, I told myself I would fix this. Nothing elaborate, nothing worthy
of a startup idea. A spreadsheet would have been enough. I never did it, not
because it was hard, but because it was tedious.</p>
<figure><img src="https://balajmarius.com/images/vibe-coding-a-bookshelf-with-claude-code/part-of-my-personal-library.jpg" alt="Part of my personal library"/><figcaption>Part of my personal library</figcaption></figure>
<p>The gap between intention and execution was small, but it was enough to keep the
project permanently parked in the someday pile.</p>
<p>By the end of 2025, I had been working with AI agents long enough that this
kind of project finally felt possible. Not because they made things more
impressive, but because they removed the part I always stalled on. Execution.</p>
<p>The bookshelf project is where I clearly understood what my role becomes once
execution stops being the bottleneck.</p>
<h2>The problem</h2>
<p>I tried the obvious tools first. <a href="https://apps.apple.com/us/app/isbn-scan-book-info-ratings/id6463488866">ISBN scanner apps</a> failed on Romanian
editions, and <a href="https://goodreads.com/">Goodreads</a> could not identify obscure publishers or antiquarian
finds. Anything even slightly nonstandard came back incomplete or wrong.
Partial data felt worse than no data at all, so every attempt ended the same
way: a few entries filled in, followed by abandonment.</p>
<p>What I needed was not a better app, but a way to tolerate imperfection without
the whole system falling apart.</p>
<h2>The data</h2>
<p>Every project starts with bad data, and this one started with worse data. One
afternoon, I photographed every book I own: spines, covers, duplicates, and
the occasional blurry thumb. <strong>Four hundred and seventy photos in total</strong>. Once
the images were on my laptop, I opened Claude.</p>
<figure><img src="https://balajmarius.com/images/vibe-coding-a-bookshelf-with-claude-code/470-shots-one-afternoon.jpg" alt="470 shots, one afternoon"/><figcaption>470 shots, one afternoon</figcaption></figure>
<p>The first steps were mechanical. Renaming files. Converting <code>HEIC</code> to <code>JPG</code>. Then
I asked for something real: a script that sends each image to OpenAI&#39;s vision
API, extracts author, title, and publisher, normalizes names, resizes images
to avoid wasting tokens, and writes everything to a <code>JSON</code> file.</p>
<p>Claude wrote the script and ran it. It worked. Not perfectly, but well enough
to matter.</p>
<pre><code>{
  &#34;id&#34;: &#34;ZfEPBCMZDaCKm6k0NVJ8F&#34;,
  &#34;title&#34;: &#34;Simulacre È™i simulare&#34;,
  &#34;author&#34;: &#34;Jean Baudrillard&#34;,
  &#34;publisher&#34;: &#34;Colectia Panopticon&#34;,
  &#34;source&#34;: &#34;dataset/83.jpg&#34;,
},
</code></pre>
<p>Roughly 90 percent of the books came back correct. The failures were
predictable: poor lighting, damaged covers, unreadable spines. One novel was
confidently identified as a 1987 Soviet agricultural manual.</p>
<p>I fixed the rest by hand. That decision was not technical, it was judgment.
Ninety percent accuracy was enough. Chasing the remaining ten percent would
have meant days of edge cases for very little additional value. That was the
first moment where my role became clear.</p>
<p>Later, when I received a few books for Christmas, we added a second script that
runs the same pipeline for new additions. <em>Photo in, metadata and images out</em>.</p>
<h2>The covers</h2>
<p>With metadata sorted, covers were still missing. My photos showed spines, not
artwork, and I wanted a clean visual representation. Claude suggested using
<a href="https://openlibrary.org/">Open Library</a>&#39;s API to fetch covers, which mostly worked. Half the covers were
low quality or incorrect, and Romanian editions barely existed in the
database.</p>
<p>We iterated. Claude wrote a second pass, another model call that scored cover
quality and flagged bad matches. For flagged books, it fell back to Google
Images via <a href="https://serpapi.com/">SerpAPI</a>. That handled most cases. A few remained: antiquarian finds
and obscure Soviet boxing manuals that no database was ever going to have
clean assets for.</p>
<p>I opened Photoshop and fixed ten covers by hand. For a collection of 460
books, ten manual edits felt like a win.</p>
<h2>The shelf</h2>
<p>Once the data and covers were in place, the UI came next. The obvious solution
was a grid of covers. It was correct, and it was lifeless. I kept looking at
my physical bookshelf instead. What makes it interesting is not the covers,
but the spines. Different widths, uneven pressure, colors blending into a
single texture.</p>
<figure><img src="https://balajmarius.com/images/vibe-coding-a-bookshelf-with-claude-code/the-shelf-version-zero.jpg" alt="The shelf, version zero"/><figcaption>The shelf, version zero</figcaption></figure>
<p>That was the thing I wanted to recreate.</p>
<p>Claude did not invent that idea. It executed it. It wrote a script to extract
dominant colors from each cover using color quantization, then computed
contrasting text colors for readability. The result was better, but still
wrong. Every book had the same width, and real books are not like that.</p>
<p><a href="https://openlibrary.org/">Open Library</a> had page counts. We mapped page count to spine width and added
slight variation to break the uniformity. At that point, it finally looked
like a bookshelf.</p>
<pre><code>{
  &#34;id&#34;: &#34;ZfEPBCMZDaCKm6k0NVJ8F&#34;,
  &#34;title&#34;: &#34;Simulacre si simulare&#34;,
  &#34;author&#34;: &#34;Jean Baudrillard&#34;,
  &#34;backgroundColor&#34;: &#34;#f0f0ff&#34;,
  &#34;color&#34;: &#34;#1f1f2e&#34;,
  &#34;paddingLeft&#34;: 13,
  &#34;paddingRight&#34;: 13,
  &#34;height&#34;: 384,
  &#34;cover&#34;: &#34;/images/bookshelf/simulacre-si-simulare@2x.webp&#34;,
  &#34;source&#34;: &#34;dataset/83.jpg&#34;
},
</code></pre>
<h2>The animation</h2>
<p>Visually, the shelf worked, but it felt static. A real shelf responds to
touch. When you run your finger along the spines, they tilt slightly. I asked
Claude for an animation, and it came back with a scroll based tilt using
<a href="https://motion.dev/">Framer Motion</a>.</p>
<p>It was close, but wrong. The movement snapped instead of flowing. I did not
know why, I just knew it felt off. That was enough.</p>
<figure><video src="/images/vibe-coding-a-bookshelf-with-claude-code/scroll-animation.webm" autoplay="" loop="" muted="" playsinline=""></video><figcaption>Scroll-based tilt animation</figcaption></figure>
<p>Claude explained the issue immediately. We were updating React state on every
scroll event, causing unnecessary re renders. The fix was to use motion values
and springs that animate outside React&#39;s render cycle. Two minutes later, it
was fixed. I spent the next few minutes scrolling back and forth, just
watching it move. This was the moment my caution dropped, not because the tool
was always right, but because the cost of trying ideas had collapsed.</p>
<h2>Killing good code</h2>
<p>That confidence had a downside. I started asking for things I did not need.
Infinite scroll seemed sensible. Why render 460 books at once? Claude
implemented it, and technically it worked. Memory stayed flat, and the DOM
updated correctly.</p>
<p>But scrolling broke. The container height desynced, the last books were
unreachable, and every attempted fix introduced new jank. The feature worked,
but the experience did not. So we removed it. Not because it was broken, but
because it was unnecessary. Four hundred and sixty books is not a scale
problem. Knowing when to delete working code is not something an AI can decide
for you.</p>
<h2>The stack view</h2>
<p>The shelf looked great on desktop, but on mobile, horizontal scrolling felt
cramped. I wanted an alternative layout: books lying flat, stacked vertically,
readable without tilting your head. I pointed Claude at the shelf
implementation and asked for a stack view.</p>
<figure><img src="https://balajmarius.com/images/vibe-coding-a-bookshelf-with-claude-code/stack-ui-on-mobile.jpg" alt="Stack UI on mobile"/><figcaption>Stack UI on mobile</figcaption></figure>
<p>It read the code, inferred the patterns, and reused them: animation timing,
color extraction, scroll based opacity, the same data shape. It built the new
component and wired up a toggle between layouts. It worked without
explanation. That surprised me more than anything else.</p>
<h2>What I actually did</h2>
<p>Claude wrote all the code. So what did I do?</p>
<ul>
<li>I decided that 90 percent accuracy was enough.</li>
<li>I fixed the ten covers no API could find.</li>
<li>I rejected a grid because I wanted spines.</li>
<li>I deleted infinite scroll because I did not need it.</li>
<li>I kept scrolling the animation until it felt right.</li>
</ul>
<p>Claude handled implementation. I handled taste.</p>
<p>After years of false starts, my bookshelf finally exists. Four hundred and
sixty books, cataloged and displayed at <a href="https://balajmarius.com/bookshelf">bookshelf</a>. I almost
dismissed Claude Code as hype. Now, the times when I wrote everything by hand
feel distant, almost strange.</p>
<p>Execution keeps getting cheaper. Taste still does not.</p></article></div>
  </body>
</html>
