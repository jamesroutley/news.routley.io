<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://notgull.net/announcing-dozer/">Original</a>
    <h1>Writing a Rust compiler in C</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>To bootstrap Rust, no cost is too great.</p>

<p>Perceptive Rustaceans may have noticed my activity has gone down as of late.
There are a handful of different reasons for this. I’ve been the subject of a
truly apocalyptic series of life events, including the death of a relative that
rattled me to my core. I’ve had more responsibilities at work, leaving me with
less time and energy to contribute. Maybe I’ve also lost a little bit of the
college-kid enthusiasm that brought me to open source in the first place.</p>

<p>There’s another reason, too. I’ve been cooking up a project that’s been taking
up most of my time. It’s certainly the largest project I’ve created in the open
source world, and if I complete it, it will certainly be my crowning
achievement.</p>

<p>I am writing a Rust compiler in pure C. No C++. No <a href="https://en.wikipedia.org/wiki/Flex_(lexical_analyser_generator)"><code>flex</code></a> or <a href="https://en.wikipedia.org/wiki/Yacc"><code>yacc</code></a>. Not even a
<a href="https://en.wikipedia.org/wiki/Make_(software)"><code>Makefile</code></a>. Nothing but pure C.</p>

<p>It’s called <a href="https://codeberg.org/notgull/dozer">Dozer</a>.</p>

<h2 id="wait-why">Wait, Why?</h2>

<p>To understand why I’ve followed this path of madness, you first need to
understand bootstrapping and why it is important.</p>

<p>Let’s say that you’ve written some code in Rust. In order to run this code, you
need to <em>compile</em> it. A <em>compiler</em> is a program that parses your code, validates
its correctness, and then transforms it into machine code that the CPU can
understand.</p>

<blockquote>
  <p><img src="https://notgull.net/images/ddog.jpg" alt="Dependency Dog" width="100"/>
<strong>Dependency Dog:</strong> Yes, it’s significantly more complicated than that. Except when it’s less complicated than that. Compilers are tricky to even describe.</p>
</blockquote>

<p>For Rust, your main compiler is <a href="https://github.com/rust-lang/rust">rustc</a>. If you don’t know, this is the
underlying program that <code>cargo</code> calls when you run <code>cargo build</code>. It’s fantastic
software, and frankly a gem of the open source community. Its code quality is up
there with the Linux kernel and the Quake III source code.</p>

<p>However, <a href="https://github.com/rust-lang/rust">rustc</a> itself is a program. So it needs a compiler to compile it from
its source code to machine code. Say, what language <em>is</em> <a href="https://github.com/rust-lang/rust">rustc</a> written in?</p>

<p><img src="https://notgull.net/images/rustc-in-rust.png" alt="rustc is 97.3 percent rust"/></p>

<p>Ah, <a href="https://github.com/rust-lang/rust">rustc</a> is a Rust program. Written in Rust, for the purpose of compiling
Rust code. But, think about this for a second. If <a href="https://github.com/rust-lang/rust">rustc</a> is written in Rust,
and <a href="https://github.com/rust-lang/rust">rustc</a> is needed to compile Rust code, that means you need to use <a href="https://github.com/rust-lang/rust">rustc</a>
to compile <a href="https://github.com/rust-lang/rust">rustc</a>. Which is fine for us users, since we can just download
<a href="https://github.com/rust-lang/rust">rustc</a> from the internet and use it.</p>

<p>But, who compiled the first <a href="https://github.com/rust-lang/rust">rustc</a>? There had to be a chicken before the egg,
right? Where does it start?</p>

<p>…</p>

<p>Actually, that’s fairly simple. Every new version of <a href="https://github.com/rust-lang/rust">rustc</a> was compiled with
the previous version of <a href="https://github.com/rust-lang/rust">rustc</a>. So <a href="https://github.com/rust-lang/rust">rustc</a> version 1.80.0 was compiled with
<a href="https://github.com/rust-lang/rust">rustc</a> version 1.79.0. Which was, in turn, compiled with <a href="https://github.com/rust-lang/rust">rustc</a> version
1.78.0. And so on and so forth, all the way back to <a href="https://github.com/rust-lang/rust/tree/ef75860a0a72f79f97216f8aaa5b388d98da6480">version 0.7</a>
if the compiler. At that point, the compiler was written in <a href="https://en.wikipedia.org/wiki/OCaml">OCaml</a>. So all you
needed was an OCaml compiler to get a fully functioning <a href="https://github.com/rust-lang/rust">rustc</a> program.</p>

<p>There, problem solved! We’ve figured out how to create <a href="https://github.com/rust-lang/rust">rustc</a> from first
principles! All is well, let’s go back to business.</p>

<p>Just one more thing. We still need a version of the <a href="https://en.wikipedia.org/wiki/OCaml">OCaml</a> compiler for all of
this to work. So what language is the <a href="https://en.wikipedia.org/wiki/OCaml">OCaml</a> compiler written in?</p>

<p><img src="https://notgull.net/images/ocaml-in-ocaml.png" alt="OCaml is 84 percent OCaml"/></p>

<p><em>faceplant</em></p>

<p>Okay, okay, no worries! There is a <a href="https://github.com/Ekdohibs/camlboot">project</a>
that can successfully compile the <a href="https://en.wikipedia.org/wiki/OCaml">OCaml</a> compiler using <a href="https://en.wikipedia.org/wiki/GNU_Guile">Guile</a>, which is one of the many
variants of <a href="https://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a>, which is one of many variants of <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a>. Not to mention,
<a href="https://en.wikipedia.org/wiki/GNU_Guile">Guile</a>’s interpreter is written in C.</p>

<p>So this brings us, as all eventually things do, to the C programming language. We just
compile it using <a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">GCC</a>, and everything works out. So we just need to compile
<a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">GCC</a>, which is written using… C++?!</p>

<p>Okay, that’s a little unfair. <a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">GCC</a> was written in C until version 5, and it’s
not like there’s a shortage of C compilers written in C out there. For instance,
consider <a href="https://en.wikipedia.org/wiki/Tiny_C_Compiler">TinyCC</a>, which is written in C and handles not only compiling, but
assembly and linking too.</p>

<p>…but that still doesn’t answer our question. What was the first C compiler
written in? Assembly? Then what was the first assembler written in?</p>

<h2 id="the-descent-principle">The Descent Principle</h2>

<p>This is where we introduce the <a href="https://bootstrappable.org/">Bootstrappable Builds</a>
project. To me, this is one of the most fascinating projects in the open source
community. It’s basically code alchemy.</p>

<p>Their <a href="https://github.com/fosslinux/live-bootstrap">Linux bootstrap process</a>
starts with a 512-byte binary seed. This seed contains what’s possibly the
simplest compiler you can imagine: it takes hexadecimal digits and outputs the
corresponding raw bytes. As an example, here part of the “source code” that’s
compiled with this compiler.</p>

<div><div><pre><code>31 C0           # xor ax, ax
8E D8           # mov ds, ax
8E C0           # mov es, ax
8E D0           # mov ss, ax
BC 00 77        # mov sp, 0x7700
FC              # cld ; clear direction flag
88 16 15 7C     # mov [boot_drive], dl
</code></pre></div></div>

<p>Note that everything after the pound sign is a comment, and all whitespace is
stripped. Frankly, I’m not even sure this can be called a programming language.
Still, it is <em>technically</em> analyzable, dissectable source code.</p>

<p>From here, this compiler compiles a very simple operating system, a barebones
shell, and a slightly more advanced compiler. That compiler compiles a slightly
more advanced compiler. A few steps later, you have something that roughly
<em>looks</em> like assembly code.</p>

<div><div><pre><code>DEFINE cmp_ebx,edx 39D3
DEFINE je 0F84
DEFINE sub_ebx, 81EB

:loop_options
    cmp_ebx,edx                         # Check if we are done
    je %loop_options_done               # We are done
    sub_ebx, %2                         # --options
</code></pre></div></div>

<p>Man, it’s weird to think of <em>assembly code</em> as being higher-level than anything
else, right?</p>

<p>This is enough to get them to a very basic subset of C. Then they compile a
slightly more advanced C compiler written in this subset. A few steps later they
can compile <a href="https://en.wikipedia.org/wiki/Tiny_C_Compiler">TinyCC</a>. From there they can bootstrap <a href="https://en.wikipedia.org/wiki/Yacc"><code>yacc</code></a>, basic coreutils,
Bash, autotools, and eventually <a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">GCC</a> and Linux.</p>

<p>I’m not doing this justice, it’s a fascinating process. Every step is listed
<a href="https://github.com/fosslinux/live-bootstrap/blob/master/parts.rst">here</a>.</p>

<p>Anyhow, you’ve essentially gone from “a binary blob small enough to be manually
analyzed” to Linux, GCC, and basically everything else. But let’s start again
from <a href="https://en.wikipedia.org/wiki/Tiny_C_Compiler">TinyCC</a>.</p>

<p>Right now, Rust shows up very late into this process. They use <a href="https://github.com/thepowersgang/mrustc">mrustc</a>, an
alternative Rust implementation written in C++ that can compile <a href="https://github.com/rust-lang/rust">rustc</a> version
1.56. From here, they then compile up to modern Rust code.</p>

<p>The main issue here is that, by the time C++ is introduced into the bootstrap
chain, the bootstrap is basically over. So if you wanted to use Rust at any
point before C++ is introduced, you’re out of luck.</p>

<p>So, for me, it would be <em>really nice</em> if there was a Rust compiler that could be
bootstrapped from C. Specifically, a Rust compiler that can be bootstrapped from
<a href="https://en.wikipedia.org/wiki/Tiny_C_Compiler">TinyCC</a>, while assuming that there are no tools on the system yet that could be
potentially useful.</p>

<p>That’s <a href="https://codeberg.org/notgull/dozer">Dozer</a>.</p>

<h2 id="the-plan">The Plan</h2>

<p>I’ve been working on <a href="https://codeberg.org/notgull/dozer">Dozer</a> for the past two months, putting my anemic free
time to work on writing in a language that I kind of hate.</p>

<blockquote>
  <p><img src="https://notgull.net/images/ddog.jpg" alt="Dependency Dog" width="100"/>
<strong>Dependency Dog:</strong> That’s a little unfair. C has some elegant qualities to it. Reality truly is what you make of it. It’s just that I would not let this code anywhere near production.</p>
</blockquote>

<p>It’s written with no extensions, and so far both <a href="https://en.wikipedia.org/wiki/Tiny_C_Compiler">TinyCC</a> and <a href="https://sr.ht/~mcf/cproc/">cproc</a> are able
to compile it with no issues. I’m using <a href="https://c9x.me/compile/">QBE</a> as a backend. Other than that, I
assume no tools exist on the system. Just a C compiler, some very basic shell
implementation, and nothing else.</p>

<p>I won’t get into the raw <em>experience</em> of writing a compiler in this blogpost.
But so far, I have the lexer done, as well as a sizable part of the parser.
Macro/module expansion is something I’m putting off as long as possible,
typechecking only supports <code>i32</code>, and codegen is a little bit rough. But it’s a
start.</p>

<p>I can successfully compile this code:</p>

<div><div><pre><code><span>fn</span> <span>rust_main</span><span>()</span> <span>-&gt;</span> <span>i32</span> <span>{</span>
    <span>(</span><span>2</span> <span>-</span> <span>1</span><span>)</span> <span>*</span> <span>6</span> <span>+</span> <span>3</span>
<span>}</span>
</code></pre></div></div>

<p>So, where to from here? Here’s my plan.</p>

<ul>
  <li>Slowly advance <a href="https://codeberg.org/notgull/dozer">Dozer</a> until it can compile some basic <code>libc</code>-using samples,
then <code>libcore</code>, then <a href="https://github.com/rust-lang/rust">rustc</a>.
    <ul>
      <li>For the record, I’m planning on compiling <a href="https://github.com/rust-lang/rust">rustc</a>’s <a href="https://github.com/rust-lang/rustc_codegen_cranelift">Cranelift</a>
backend, which is written entirely in Rust. Since we’re assuming we don’t
have C++ yet, we can’t compile LLVM.</li>
    </ul>
  </li>
  <li>Create a <code>cargo</code> equivalent that can use <a href="https://codeberg.org/notgull/dozer">Dozer</a> to compile Rust packages.</li>
  <li>Find out which sources in <a href="https://github.com/rust-lang/rust">rustc</a> are automaticaly generated and then strip
them out. By the Bootstrappable project’s rules, automatically generated code
is not allowed.</li>
  <li>Create a process that can be used to compile <a href="https://github.com/rust-lang/rust">rustc</a> and then <code>cargo</code>, then
use our compiled versions of <a href="https://github.com/rust-lang/rust">rustc</a>/<code>cargo</code> to re-compile canonical versions
of <a href="https://github.com/rust-lang/rust">rustc</a>/<code>cargo</code>.</li>
</ul>

<p>This will definitely be the hardest project I’ve ever undertaken. Part of me
doubts that I will be able to finish it. But you know what? It’s better to have
tried and lost than to never have tried at all.</p>

<p>Stay tuned for more <a href="https://codeberg.org/notgull/dozer">Dozer</a> updates, as well as an explanation of the
architecture I have planned.</p>


  </div></div>
  </body>
</html>
