<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lukeplant.me.uk/blog/posts/pythons-disappointing-superpowers/">Original</a>
    <h1>Python&#39;s “disappointing” superpowers</h1>
    
    <div id="readability-page-1" class="page"><div id="contentinner">
  <article itemscope="" itemtype="http://schema.org/BlogPosting"><header>
      
      
    </header><section itemprop="articleBody"><div>
        <p>In Hillel Wayne’s post <a href="https://buttondown.email/hillelwayne/archive/i-am-disappointed-by-dynamic-typing/">“I am disappointed by dynamic typing”</a>, he expresses his sense that the Python ecosystem doesn’t really make the most of the possibilities that Python provides as a dynamically typed language. This is an important subject, since every Python program pays a very substantial set of costs for Python’s highly dynamic nature, such as poor run-time performance, and maintainability issues. Are we we getting anything out of this tradeoff?</p>
<p>I think Hillel makes some fair points, and this post is intended as a response rather than a rebuttal. Recently there has been a significant influence of static type systems which I think might be harmful. The static type system we have in the form of mypy/pyright (which is partly codified in <a href="https://peps.python.org/pep-0484/">PEP 484</a> and following) seems to be much too heavily inspired by what is possible to map to other languages, rather than the features that Python provides.</p>
<p>(As a simple example to support that claim, consider the fact that Python has had support for keyword arguments since as long as I can remember, and for keyword-only arguments since Python 3.0. But  <code>typing.Callable</code> has zero support for them, meaning they can’t be typed in a higher-order context. This is bad, since they are a key part of Python’s excellent reputation for readability, and <a href="https://lukeplant.me.uk/blog/posts/keyword-only-arguments-in-python/">we want more keyword-only arguments, not fewer</a>. I can give more examples, but that will have to wait for another blog post).</p>
<p>I’m worried that a de-facto move away from dynamic stuff in the Python ecosystem, possibly motivated by those who use Python only because they have to, and just want to make it more like the C# or Java they are comfortable with, could leave us with the very worst of all worlds.</p>
<p>However, I also think they are plenty of counter-examples to Hillel’s claim, and that’s what this post will explore.</p>
<p>Hillel was specifically thinking about, in his own words:</p>
<ul>
<li><p>“runtime program manipulation”</p></li>
<li><p>“programs that take programs and output other programs”</p></li>
<li><p>“thinking of the whole runtime environment in the same way, where everything is a runtime construct”</p></li>
</ul>
<p>…and he gave some examples that included things like:</p>
<ul>
<li><p>run-time type modification</p></li>
<li><p>introspection/manipulation of the stack</p></li>
<li><p>passing very differently typed objects through normal code to collect information about it.</p></li>
</ul>
<p>I’m going to give lots of examples of this kind of thing in Python, and they will all be <strong>real world</strong> examples. This means that either I have used them myself to solve real problems, or I’m aware that other people are using them in significant numbers.</p>
<p>Before I get going, there are some things to point out.</p>
<p>First, I don’t have the exact examples Hillel is looking for — but that’s because the kind of problems I’ve needed to solve have not been exactly the same as his. My examples are all necessarily limited in scope: since Python allows unrestricted side-effects in any function, including IO and being able to modify other code, there are obviously limits into how well these techniques can work across large amounts of code.</p>
<p>I do think, however, that my examples are in the same general region, and some of them very close. On both sides we’ve got to avoid semantic hair-splitting — you can argue that every time you use the <code>class</code> keyword in Python you are doing “run-time type creation”, rather than “compile-time type creation”, because that’s how Python’s classes work. But that’s not what Hillel meant.</p>
<p>Second, many of these more magical techniques involve what is called monkey patching. People are often confused about the difference between monkey patching and “dynamic meta-programming”, so I’ve prepared a handy flow chart for you:</p>
<p><img alt="Flow chart: Is this code I found a hacky monkey patch, or cool dynamic meta-programming?  Question: who wrote it? If “Me” - it’s “Dynamic meta-programming”, if “someone else”, it’s “hacky monkey patch”" src="https://lukeplant.me.uk/blogmedia/monkey_patch_or_dynamic_meta_programming.png"/></p><p>There are, however, many instances of advanced, dynamic techniques that never get to the point of the chart above, and that’s because you never know about them. What you know is that the code does something useful, and it does so reliably enough that you don’t need to know what techniques contributed to it. And this is, I think, the biggest problem in what Hillel is asking for. The best examples of these techniques will be reliable enough that they don’t draw attention to themselves, and you immediately take them for granted.</p>
<p>Which is also to say that you cannot discount something I mention below just because it is so widely used that you, too, have taken it for granted — that would effectively be saying that the only examples that count are the ones that have proved to be so wild and wacky that everyone has decided they are a bad idea.</p>
<p>Third, you might also discount these examples as  “just using features the language provides”, rather than “hyper programming” or something exotic. On the one hand, it would be true, but also unfair in the context of this debate. The most obvious example is <code>eval</code>. This is clearly a very powerful technique not available to many statically typed languages, and exactly the kind that Hillel is looking for — you are literally creating more of your program as your program is running. On the other hand, it’s nothing more than a builtin function.</p>
<p>Finally, a number of these examples don’t involve “production” code i.e. the code is typically run only on developer machines or in CI. These still count, however — just like many of Hillel’s examples are in the area of testing. The reasons they still count are 1) developers are humans too, and solving their problems is still important and 2) the techniques used by developers on their own machines are useful in creating high quality code for running on other people’s machines, where we don’t want to incur the performance or robustness penalties of the techniques used.</p>
<p>So, here are my examples. The majority are not my own code, but I’ve also taken the opportunity to do some fairly obvious bragging about cool things I’ve done in Python.</p>
<nav id="examples" role="doc-toc"><p>Examples</p>
<ul>
<li><p><a href="#gooey" id="toc-entry-1">Gooey</a></p></li>
<li><p><a href="#werkzeugs-interactive-debugger" id="toc-entry-2">Werkzeug’s interactive debugger</a></p></li>
<li><p><a href="#hybrid-attributes-in-sqlalchemy" id="toc-entry-3">Hybrid attributes in SQLAlchemy</a></p></li>
<li><p><a href="#pony-orm" id="toc-entry-4">Pony ORM</a></p></li>
<li>
<p><a href="#django" id="toc-entry-5">Django</a></p>
<ul>
<li><p><a href="#foreignkey" id="toc-entry-6">ForeignKey</a></p></li>
<li><p><a href="#relatedmanager" id="toc-entry-7">RelatedManager</a></p></li>
<li><p><a href="#manytomany-models" id="toc-entry-8">ManyToMany models</a></p></li>
<li><p><a href="#consequences" id="toc-entry-9">Consequences</a></p></li>
<li><p><a href="#baserow" id="toc-entry-10">Baserow</a></p></li>
<li><p><a href="#cciw-data-retention-policy" id="toc-entry-11">CCiW data retention policy</a></p></li>
</ul>
</li>
<li><p><a href="#query-tracing" id="toc-entry-12">Query tracing</a></p></li>
<li><p><a href="#time-machine-and-pyfakefs" id="toc-entry-13">time-machine and pyfakefs</a></p></li>
<li><p><a href="#environment-detection" id="toc-entry-14">Environment detection</a></p></li>
<li>
<p><a href="#fluent-compiler" id="toc-entry-15">fluent-compiler</a></p>
<ul>
<li><p><a href="#compile-to-python" id="toc-entry-16">Compile-to-Python</a></p></li>
<li><p><a href="#dynamic-test-methods" id="toc-entry-17">Dynamic test methods</a></p></li>
<li><p><a href="#morph-into" id="toc-entry-18"><code>morph_into</code></a></p></li>
</ul>
</li>
<li>
<p><a href="#pytest" id="toc-entry-19">Pytest</a></p>
<ul>
<li><p><a href="#assert-rewriting" id="toc-entry-20">Assert rewriting</a></p></li>
<li><p><a href="#automatic-dependency-injection-of-fixtures" id="toc-entry-21">Automatic dependency injection of fixtures</a></p></li>
</ul>
</li>
<li><p><a href="#others" id="toc-entry-22">Others</a></p></li>
<li><p><a href="#conclusion" id="toc-entry-23">Conclusion</a></p></li>
<li><p><a href="#links" id="toc-entry-24">Links</a></p></li>
</ul></nav><section id="gooey"><h2><a href="#toc-entry-1" role="doc-backlink">Gooey</a></h2>
<p><a href="https://github.com/chriskiehl/Gooey">Gooey</a> is a library that will re-interpret <a href="https://docs.python.org/3/library/argparse.html">argparse</a> entry points as if they were specifying a GUI. In other words, you do “import gooey”, add a decorator and it transforms your CLI program into a GUI program. Apparently it does this by <a href="https://github.com/chriskiehl/Gooey#how-does-it-work">re-parsing your entry point module</a>, for reasons I don’t know and don’t need to know. I do know that it works for programs I’ve tried it with, when I wanted to make something that I was using as a CLI, but also needed to usable by other family members. A pretty cool tool that solves real problems.</p>
</section><section id="werkzeugs-interactive-debugger"><h2><a href="#toc-entry-2" role="doc-backlink">Werkzeug’s interactive debugger</a></h2>
<p>Werkzeug provide a <a href="https://werkzeug.palletsprojects.com/en/2.2.x/debug/">debugger middleware</a> which works with any WSGI-compliant Python web framework (which is most of them) with the following extremely useful behaviour:</p>
<ul>
<li><p>Crashing errors are automatically intercepted and an error page is shown with a stack trace instead of a generic 500 error.</p></li>
<li><p>For any and every frame of the stack trace, you can, right from your web browser, start a Python REPL at that frame — i.e. you can effectively continue execution of the crashed program at any point in the stack, or from multiple points simultaneously.</p></li>
</ul>
<p>This is extremely useful, to say the least.</p>
<img alt="Screenshot of Werkzeug debugger in action" src="https://lukeplant.me.uk/blogmedia/werkzeug_debugger_example.png"/><p>(For Django users - you can use this most easily using <a href="https://django-extensions.readthedocs.io/en/latest/">django-extensions</a>)</p>
</section><section id="hybrid-attributes-in-sqlalchemy"><h2><a href="#toc-entry-3" role="doc-backlink">Hybrid attributes in SQLAlchemy</a></h2>
<p>I’m sure there are <strong>many</strong> examples of advanced dynamic techniques in SQLAlchemy, and I’m not the best qualified to talk about them, but here is a cool one I came across that helps explain the kind of thing you can do in Python.</p>
<p>Suppose you have an ORM object with some attributes that come straight from the database, along with some calculated properties. In the example below we’ve got a model representing an account that might have payments against it:</p>
<div><pre><a id="rest_code_e02934ddcf304788835b1d82b3c1d712-1" name="rest_code_e02934ddcf304788835b1d82b3c1d712-1" href="#rest_code_e02934ddcf304788835b1d82b3c1d712-1"></a><span>class</span> <span>Account</span><span>(</span><span>Base</span><span>):</span>
<a id="rest_code_e02934ddcf304788835b1d82b3c1d712-2" name="rest_code_e02934ddcf304788835b1d82b3c1d712-2" href="#rest_code_e02934ddcf304788835b1d82b3c1d712-2"></a>    <span># DB columns:</span>
<a id="rest_code_e02934ddcf304788835b1d82b3c1d712-3" name="rest_code_e02934ddcf304788835b1d82b3c1d712-3" href="#rest_code_e02934ddcf304788835b1d82b3c1d712-3"></a>    <span>amount_paid</span><span>:</span> <span>Mapped</span><span>[</span><span>Decimal</span><span>]</span>
<a id="rest_code_e02934ddcf304788835b1d82b3c1d712-4" name="rest_code_e02934ddcf304788835b1d82b3c1d712-4" href="#rest_code_e02934ddcf304788835b1d82b3c1d712-4"></a>    <span>total_purchased</span><span>:</span> <span>Mapped</span><span>[</span><span>Decimal</span><span>]</span>
<a id="rest_code_e02934ddcf304788835b1d82b3c1d712-5" name="rest_code_e02934ddcf304788835b1d82b3c1d712-5" href="#rest_code_e02934ddcf304788835b1d82b3c1d712-5"></a>
<a id="rest_code_e02934ddcf304788835b1d82b3c1d712-6" name="rest_code_e02934ddcf304788835b1d82b3c1d712-6" href="#rest_code_e02934ddcf304788835b1d82b3c1d712-6"></a>    <span># Calculated properties:</span>
<a id="rest_code_e02934ddcf304788835b1d82b3c1d712-7" name="rest_code_e02934ddcf304788835b1d82b3c1d712-7" href="#rest_code_e02934ddcf304788835b1d82b3c1d712-7"></a>    <span>@property</span>
<a id="rest_code_e02934ddcf304788835b1d82b3c1d712-8" name="rest_code_e02934ddcf304788835b1d82b3c1d712-8" href="#rest_code_e02934ddcf304788835b1d82b3c1d712-8"></a>    <span>def</span> <span>balance_due</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>Decimal</span><span>:</span>
<a id="rest_code_e02934ddcf304788835b1d82b3c1d712-9" name="rest_code_e02934ddcf304788835b1d82b3c1d712-9" href="#rest_code_e02934ddcf304788835b1d82b3c1d712-9"></a>        <span>return</span> <span>self</span><span>.</span><span>total_purchased</span> <span>-</span> <span>self</span><span>.</span><span>amount_paid</span>
<a id="rest_code_e02934ddcf304788835b1d82b3c1d712-10" name="rest_code_e02934ddcf304788835b1d82b3c1d712-10" href="#rest_code_e02934ddcf304788835b1d82b3c1d712-10"></a>
<a id="rest_code_e02934ddcf304788835b1d82b3c1d712-11" name="rest_code_e02934ddcf304788835b1d82b3c1d712-11" href="#rest_code_e02934ddcf304788835b1d82b3c1d712-11"></a>    <span>@property</span>
<a id="rest_code_e02934ddcf304788835b1d82b3c1d712-12" name="rest_code_e02934ddcf304788835b1d82b3c1d712-12" href="#rest_code_e02934ddcf304788835b1d82b3c1d712-12"></a>    <span>def</span> <span>has_payment_outstanding</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>bool</span><span>:</span>
<a id="rest_code_e02934ddcf304788835b1d82b3c1d712-13" name="rest_code_e02934ddcf304788835b1d82b3c1d712-13" href="#rest_code_e02934ddcf304788835b1d82b3c1d712-13"></a>        <span>return</span> <span>self</span><span>.</span><span>balance_due</span> <span>&gt;</span> <span>0</span>
</pre></div>
<p>Very often you find yourself in a situation like this:</p>
<ul>
<li><p>Sometimes you have already loaded an object from the DB, and want to know a calculated value like “does this account have an outstanding payment?”. This shouldn’t execute any more database queries, since you’ve already loaded everything you need to answer that question.</p></li>
<li><p>But sometimes, you want to re-use this logic to do something like “get me all the accounts that have outstanding payments”, and it is vital for efficiency that we do the filtering in the database as a SQL <code>WHERE</code> clause, rather than loading all the records into a Python process and filtering there.</p></li>
</ul>
<p>How could we do this in SQLAlchemy <strong>without duplicating the logic</strong> regarding <code>balance_due</code> and <code>has_outstanding_payment</code>?</p>
<p>The answer is <a href="https://docs.sqlalchemy.org/en/20/orm/extensions/hybrid.html">hybrid attributes</a>:</p>
<ul>
<li><p><code>from sqlalchemy.ext.hybrid import hybrid_property</code></p></li>
<li><p>replace <code>property</code> with <code>hybrid_property</code> on the two properties.</p></li>
</ul>
<p><strong>That is all</strong>. Then you can do:</p>
<div><pre><a id="rest_code_5d28b7a34bb640a09e0aa0258ddcb11f-1" name="rest_code_5d28b7a34bb640a09e0aa0258ddcb11f-1" href="#rest_code_5d28b7a34bb640a09e0aa0258ddcb11f-1"></a><span>select</span><span>(</span><span>Account</span><span>)</span><span>.</span><span>where</span><span>(</span><span>Account</span><span>.</span><span>has_payment_outstanding</span> <span>==</span> <span>True</span><span>)</span>
</pre></div>
<p>This will generate a SQL query that looks like this:</p>
<div><pre><a id="rest_code_51b81a2809d24358ab265a50f8db983c-1" name="rest_code_51b81a2809d24358ab265a50f8db983c-1" href="#rest_code_51b81a2809d24358ab265a50f8db983c-1"></a><span>SELECT</span><span> </span><span>account</span><span>.</span><span>id</span><span>,</span><span> </span><span>account</span><span>.</span><span>amount_paid</span><span>,</span><span> </span><span>account</span><span>.</span><span>total_purchased</span><span></span>
<a id="rest_code_51b81a2809d24358ab265a50f8db983c-2" name="rest_code_51b81a2809d24358ab265a50f8db983c-2" href="#rest_code_51b81a2809d24358ab265a50f8db983c-2"></a><span>FROM</span><span> </span><span>account</span><span></span>
<a id="rest_code_51b81a2809d24358ab265a50f8db983c-3" name="rest_code_51b81a2809d24358ab265a50f8db983c-3" href="#rest_code_51b81a2809d24358ab265a50f8db983c-3"></a><span>WHERE</span><span> </span><span>(</span><span>account</span><span>.</span><span>total_purchased</span><span> </span><span>-</span><span> </span><span>account</span><span>.</span><span>amount_paid</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>)</span><span> </span><span>=</span><span> </span><span>1</span><span></span>
</pre></div>
<p>What’s going on here? If you have a normal model instance <code>an_account</code>, retrieved from a database query, and you do <code>an_account.has_payment_outstanding</code>, then in the <code>has_payment_outstanding</code> function body above, everything is normal: <code>self</code> is bound to <code>an_account</code>, attributes like <code>total_purchased</code> will be <code>Decimal</code> objects that have been loaded from the database.</p>
<p>However, if you use <code>Account.has_payment_outstanding</code>, the <code>self</code> variable gets bound to a different type of object (the <code>Account</code> class or some proxy), and so things like <code>self.total_purchased</code> instead resolve to objects representing columns/fields. These classes have appropriate “dunder” methods defined, (<code>__add__</code>, <code>__gt__</code> etc) so that operations done on them, such as maths and comparisons, instead of returning values immediately, return new expression objects that track what operations were done. These can then be compiled to SQL later on. So we can execute the filtering as a WHERE clause in the DB.</p>
<p>The point here is: we are passing both “normal” and “instrumented” types through the same code in order to completely change our execution strategy. This allows us to effectively compile our Python code into SQL on the fly. This is essentially identical to Hillel’s example of passing instrumented objects (“Replacer” class) through normal code to extract certain information about what operations were done.</p>
<p>This is a very neat feature in SQLAlchemy that I’m rather jealous of as a Django user. If you want the same efficiency in Django, you have to define the instance properties and the database filtering separately, and usually physically not next to each other in the code. The closest we have is <a href="https://docs.djangoproject.com/en/4.1/ref/models/expressions/#query-expressions">Query expressions</a> but they don’t work quite the same.</p>
</section><section id="pony-orm"><h2><a href="#toc-entry-4" role="doc-backlink">Pony ORM</a></h2>
<p>This ORM has a way of writing SQL select queries that appears even more magical. Using an example from <a href="https://ponyorm.org/">their home page</a>, you write code like this:</p>
<div><pre><a id="rest_code_f73feccf70844907a806fd7ec5d93f9a-1" name="rest_code_f73feccf70844907a806fd7ec5d93f9a-1" href="#rest_code_f73feccf70844907a806fd7ec5d93f9a-1"></a><span>select</span><span>(</span><span>c</span> <span>for</span> <span>c</span> <span>in</span> <span>Customer</span> <span>if</span> <span>sum</span><span>(</span><span>c</span><span>.</span><span>orders</span><span>.</span><span>price</span><span>)</span> <span>&gt;</span> <span>1000</span><span>)</span>
</pre></div>
<p>The result of this is a SQL query that looks like this:</p>
<div><pre><a id="rest_code_93cb0a872bc84ebb864e4795b598bd1e-1" name="rest_code_93cb0a872bc84ebb864e4795b598bd1e-1" href="#rest_code_93cb0a872bc84ebb864e4795b598bd1e-1"></a><span>SELECT</span><span> </span><span>&#34;c&#34;</span><span>.</span><span>&#34;id&#34;</span><span></span>
<a id="rest_code_93cb0a872bc84ebb864e4795b598bd1e-2" name="rest_code_93cb0a872bc84ebb864e4795b598bd1e-2" href="#rest_code_93cb0a872bc84ebb864e4795b598bd1e-2"></a><span>FROM</span><span> </span><span>&#34;customer&#34;</span><span> </span><span>&#34;c&#34;</span><span></span>
<a id="rest_code_93cb0a872bc84ebb864e4795b598bd1e-3" name="rest_code_93cb0a872bc84ebb864e4795b598bd1e-3" href="#rest_code_93cb0a872bc84ebb864e4795b598bd1e-3"></a><span>  </span><span>LEFT</span><span> </span><span>JOIN</span><span> </span><span>&#34;order&#34;</span><span> </span><span>&#34;order-1&#34;</span><span></span>
<a id="rest_code_93cb0a872bc84ebb864e4795b598bd1e-4" name="rest_code_93cb0a872bc84ebb864e4795b598bd1e-4" href="#rest_code_93cb0a872bc84ebb864e4795b598bd1e-4"></a><span>    </span><span>ON</span><span> </span><span>&#34;c&#34;</span><span>.</span><span>&#34;id&#34;</span><span> </span><span>=</span><span> </span><span>&#34;order-1&#34;</span><span>.</span><span>&#34;customer&#34;</span><span></span>
<a id="rest_code_93cb0a872bc84ebb864e4795b598bd1e-5" name="rest_code_93cb0a872bc84ebb864e4795b598bd1e-5" href="#rest_code_93cb0a872bc84ebb864e4795b598bd1e-5"></a><span>GROUP</span><span> </span><span>BY</span><span> </span><span>&#34;c&#34;</span><span>.</span><span>&#34;id&#34;</span><span></span>
<a id="rest_code_93cb0a872bc84ebb864e4795b598bd1e-6" name="rest_code_93cb0a872bc84ebb864e4795b598bd1e-6" href="#rest_code_93cb0a872bc84ebb864e4795b598bd1e-6"></a><span>HAVING</span><span> </span><span>coalesce</span><span>(</span><span>SUM</span><span>(</span><span>&#34;order-1&#34;</span><span>.</span><span>&#34;total_price&#34;</span><span>),</span><span> </span><span>0</span><span>)</span><span> </span><span>&gt;</span><span> </span><span>1000</span><span></span>
</pre></div>
<p>A normal understanding of generator expressions suggests that the <code>select</code> function is consuming a generator. But that couldn’t explain the behaviour here. Instead, it actually <a href="https://github.com/ponyorm/pony/blob/27593ffc74184bc334dd301a86fc5f40fdd3ad87/pony/orm/core.py#L5542">introspects the frame object of the calling code</a>, then <a href="https://github.com/ponyorm/pony/blob/27593ffc74184bc334dd301a86fc5f40fdd3ad87/pony/orm/decompiling.py#L22">decompiles the byte code of the generator expression object it finds</a>, and builds a <a href="https://github.com/ponyorm/pony/blob/27593ffc74184bc334dd301a86fc5f40fdd3ad87/pony/orm/core.py#L5669">Query</a> based on the <a href="https://docs.python.org/3/library/ast.html">AST</a> objects.</p>
<p>PonyORM doesn’t advertise all that, of course. It advertises a “beautiful” syntax for writing ORM code, because that’s what matters.</p>
</section><section id="django"><h2><a href="#toc-entry-5" role="doc-backlink">Django</a></h2>
<p>This is the web framework I know well, as I used to contribute significantly, and I’ll pick just a few important examples from the ORM, and then from the broader ecosystem.</p>
<section id="foreignkey"><h3><a href="#toc-entry-6" role="doc-backlink">ForeignKey</a></h3>
<p>Suppose, to pick one example of many, you are writing <a href="https://github.com/django-otp/django-otp/">django-otp</a>, a third party library that provides a <a href="https://en.wikipedia.org/wiki/One-time_password">One Time Password</a> implementation for <a href="https://en.wikipedia.org/wiki/Multi-factor_authentication">2FA requirements</a>. You want to create a table of TOTP devices that are linked to user accounts, and so you have something like this:</p>
<div><pre><a id="rest_code_e2b74c8dcc1f4150b22dd3f7425b3b26-1" name="rest_code_e2b74c8dcc1f4150b22dd3f7425b3b26-1" href="#rest_code_e2b74c8dcc1f4150b22dd3f7425b3b26-1"></a><span>class</span> <span>TOTPDevice</span><span>(</span><span>models</span><span>.</span><span>Model</span><span>):</span>
<a id="rest_code_e2b74c8dcc1f4150b22dd3f7425b3b26-2" name="rest_code_e2b74c8dcc1f4150b22dd3f7425b3b26-2" href="#rest_code_e2b74c8dcc1f4150b22dd3f7425b3b26-2"></a>    <span>user</span> <span>=</span> <span>models</span><span>.</span><span>ForeignKey</span><span>(</span><span>&#39;auth.User&#39;</span><span>,</span> <span>related_name</span><span>=</span><span>&#39;totp_devices&#39;</span><span>)</span>
</pre></div>
<p>Later on, you have code that starts with a <code>User</code> object and retrieves their TOTP devices, and it looks something like this:</p>
<div><pre><a id="rest_code_8d056b3288cd408e86d86e134b6bbe21-1" name="rest_code_8d056b3288cd408e86d86e134b6bbe21-1" href="#rest_code_8d056b3288cd408e86d86e134b6bbe21-1"></a><span>devices</span> <span>=</span> <span>user</span><span>.</span><span>totp_devices</span><span>.</span><span>all</span><span>()</span>
</pre></div>
<p>This is interesting, because my <code>user</code> variable is an instance of a <code>User</code> model that was provided by core Django, which has no knowledge of the third party project that provides the <code>TOTPDevice</code> model.</p>
<p>In fact it goes further: I may not be using Django’s <code>User</code> at all, but my own custom <code>User</code> class, and the <code>TOTPDevice</code> can easily support that too just by doing this:</p>
<div><pre><a id="rest_code_bc4b056b5c374ddc9861f299a8a1f326-1" name="rest_code_bc4b056b5c374ddc9861f299a8a1f326-1" href="#rest_code_bc4b056b5c374ddc9861f299a8a1f326-1"></a><span>user</span> <span>=</span> <span>models</span><span>.</span><span>ForeignKey</span><span>(</span><span>getattr</span><span>(</span><span>settings</span><span>,</span> <span>&#34;AUTH_USER_MODEL&#34;</span><span>,</span> <span>&#34;auth.User&#34;</span><span>))</span>
</pre></div>
<p>This means that my <code>User</code> model has no knowledge of the <code>TOTPDevice</code> class, nor the other way around, yet instances of these classes both get wired up to refer to each other.</p>
<p>What is actually going on to enable this?</p>
<p>When you import Django and call <code>setup()</code>, it imports all the apps in your
project. When it comes to the <code>TOTPDevice</code> class, it sees the <code>&#34;auth.User&#34;</code>
reference and finds the class it refers to. It then <strong>modifies that
class</strong>, adding a <code>totp_devices</code> <a href="https://docs.python.org/3/glossary.html#term-descriptor">descriptor</a> object to the class attributes.</p>
<p>This is <strong>run-time type modification</strong>.</p>
<p>The result is that when you do <code>user.totp_devices</code>, you get a <code>Manager</code> instance that does queries against the <code>TOTPDevice</code> table. It is a specific kind of manager, known as a <code>RelatedManager</code>, with the special property that it automatically does the correct <code>filter()</code> calls to limit returned values to those related to the model instance, among other things.</p>
</section><section id="manytomany-models"><h3><a href="#toc-entry-8" role="doc-backlink">ManyToMany models</a></h3>
<p>One common need in database applications is to have <a href="https://en.wikipedia.org/wiki/Many-to-many_(data_model)">many-to-many relationships</a> between two models. Typically this can be modelled with a separate table that has foreign keys to the two related tables.</p>
<p>To make this easy, Django provides a <code>ManyToManyField</code>. For simple cases, it’s
tedious to have to create a model for the intermediate table yourself, so of
course Django just <a href="https://github.com/django/django/blob/d54717118360e8679aa2bd0c5a1625f3e84712ba/django/db/models/fields/related.py#L1279">creates it for you</a>
if you don’t provide your own, using <a href="https://docs.python.org/3/library/functions.html#type">type() with 3 arguments</a>. This is again <strong>run-time type creation</strong>.</p>
</section><section id="consequences"><h3><a href="#toc-entry-9" role="doc-backlink">Consequences</a></h3>
<p>These examples of run-time type modification or creation are perhaps not the most extreme or mind-bending. But they are something even better: useful. It’s these features, and things like them, that enable an ecosystem of third party Django libraries that can integrate with your own code without any problems.</p>
<p>Python also always gives us enough flexibility to have a good backwards compatibility story — so that, for example, the swappable User model was introduced with an absolute minimum of fuss for both projects and pluggable Django apps.</p>
<p>I’m interested in functional programming, Haskell in particular — this blog even ran on Haskell for a time — so I always take interest in developments in the Haskell web framework world. I see lots of cool things, but it always seems that the ecosystems around Haskell web frameworks are at least 10 years behind Django. One key issue is that in contrast to Django or other Python frameworks, Haskell web frameworks almost always have some kind of code generation layer. This can be made to work well for the purposes envisaged by the framework authors, but it never seems to enable the ecosystem of external packages that highly dynamic typing supports.</p>
<p>Please note that I’m not claiming here that Python is better than Haskell or anything so grand. I’m simply claiming that Python does enable very useful things to be built, and those things are made possible and easy <strong>because of Python’s design, rather than despite it</strong>.</p>
<p>I think this is important to say. Python has become massively more popular than it was when I first started to use it, and there are increasing numbers of people who use it only because of network effects, and don’t understand why it got so popular in the first place. These people can sometimes assume that it’s fundamentally a poorly designed language that we are just lumped with — today’s PHP — whose best trajectory is to make it more like Java or C# or Rust etc. I think that would be a big mistake.</p>
</section><section id="baserow"><h3><a href="#toc-entry-10" role="doc-backlink">Baserow</a></h3>
<p>One project that takes Python’s run-time type creation further is <a href="https://baserow.io/">Baserow</a>. In their case, their customers create database applications, and the metadata for those tables is stored in … tables. They like Django and want to use it as much as possible. But they also want their customers’ actual data tables to be normal RDBMS tables, and therefore benefit from all the typical RDBMS features to make their tables fast and compact etc. (I’ve seen and worked on systems that took the opposite approach, where customer schema was relegated to second class storage — essentially a key-value table — and the performance was predictably awful).</p>
<p>And they want plug-in authors to be able to use Django too! Some people are just greedy! They <a href="https://baserow.io/blog/how-baserow-lets-users-generate-django-models">have a nice article describing how they achieved all this</a>: in short, they use <code>type()</code> for run-time type creation and then leverage everything Django gives them.</p>
<p>This has the interesting effect that the metadata tables, along with their own business tables, live <strong>at the same level</strong> as their customers’ tables which are described by those metadata tables. This “meta and non-meta living at the same level” is a neat illustration of what Python’s type system gives you:</p>
<p>When you first discover the mind-bending relationships around <code>type(type) == type</code>, you might think of an infinitely-recursive relationship. But actually, an infinite relationship has been flattened to being just 3 layers deep — instance, class, metaclass. The last layer just recurses onto itself. The infinity has been tamed, and brought into the same structures that you can already deal with, and without changing language or switching to code generation techniques. This is one reason why many examples of the “hyper-programming” that Hillel talks about can just be dismissed as normal programming — but they are simply hyper-programming that you are now taking for granted.</p>
</section><section id="cciw-data-retention-policy"><h3><a href="#toc-entry-11" role="doc-backlink">CCiW data retention policy</a></h3>
<p><a href="https://www.cciw.co.uk/">CCiW</a> is a small charity I’ve been involved with for a long time. When I came to implement its <a href="https://gdpr-info.eu/">GDPR</a> and data retention policies, I found another example of how useful it is having access to Django’s meta-layer (generic framework code) on the same level as my normal data layer (business specific classes and tables), in ways that often aren’t the case for statically typed languages that resort to code-generation techniques for some of these things.</p>
<p>I wanted to have a data retention policy that was both human readable and machine readable, so that:</p>
<ul>
<li><p>We don’t have keep two separate documents in sync.</p></li>
<li><p>the CCiW committee and other interested parties would be able to read the  policy that actually gets applied, rather than merely what the policy was supposed to be.</p></li>
<li><p>I could have machine level checking of the exhaustiveness of the policy.</p></li>
</ul>
<p>My solution was to split the data retention policy into two parts:</p>
<ul>
<li><p>a heavily commented, human-and-machine readable <a href="https://github.com/cciw-uk/cciw.co.uk/blob/master/config/data_retention.yaml">Literate YAML file</a> with a <a href="https://www.cciw.co.uk/data-retention-policy/">nicely formatted version</a>, that I can genuinely claim <strong>is</strong> our data retention policy, and that it is automatically applied,</p></li>
<li><p>and a <a href="https://github.com/cciw-uk/cciw.co.uk/blob/master/cciw/data_retention/applying.py">Python implementation</a> that reads this file and applies it, along with some additional logic.</p></li>
</ul>
<p>A key part of the neatness of this solution is that the generic, higher level code (which reads in a YAML file, and therefore has to treat field names and table names as strings), and the business/domain specific logic can sit right next to each other. The end result is something that’s both efficient and elegant, with great separation of concerns, and virtually self-maintaining — it complains at me automatically if I fail to update it when adding new fields or tables.</p>
<p>In terms of performance, the daily application for the data retention policy for the entire database requires, at the moment, just 5 UPDATE and 3 DELETE queries, run once a day. This is made possible by:</p>
<ul>
<li><p>using the power of an ORM,</p></li>
<li><p>using generic code to build up <code>**kwargs</code> to <a href="https://github.com/cciw-uk/cciw.co.uk/blob/37e6d69064c9a5d1372809fa2d723a0e203d21c3/cciw/data_retention/applying.py#L86">pass</a> to <a href="https://docs.djangoproject.com/en/4.1/ref/models/querysets/#django.db.models.query.QuerySet.update">QuerySet.update()</a>,</p></li>
<li><p>seamlessly integrating these two with <a href="https://github.com/cciw-uk/cciw.co.uk/blob/37e6d69064c9a5d1372809fa2d723a0e203d21c3/cciw/data_retention/applying.py#L229">business specific logic</a>.</p></li>
</ul>
<p><a href="https://gist.github.com/spookylukey/eeafa220b61e479694e2acf44902b6e1">Here is one of the queries the ORM generates</a>, which is complex enough that I wouldn’t attempt to write this by hand, but it correctly applies business logic like not erasing any data of people who still owe us money, and combines all the erasure that needs to be done into a single query.</p>
</section></section><section id="query-tracing"><h2><a href="#toc-entry-12" role="doc-backlink">Query tracing</a></h2>
<p>A common need in database web applications is development tools that monitor what database queries your code is generating and where they are coming from in the code. In Python this is made very easy thanks to <a href="https://docs.python.org/3/library/sys.html?highlight=_getframe#sys._getframe">sys._getframe</a> which gives you frame objects of the currently running program.</p>
<p>For Django, the go-to tool that uses this is <a href="https://github.com/jazzband/django-debug-toolbar">django-debug-toolbar</a>, which does an excellent job of pinpointing where queries are coming from.</p>
<p>There have been times when it has failed me, however. In particular, when you are working with generic code, such as the Django admin or <a href="https://www.django-rest-framework.org/">Django REST framework</a>, in which the fields and properties that will be fetched may be defined as strings in declarative code, a stack trace alone is not enough to work out what is triggering the queries. For example, you might have an admin class defined like this:</p>
<div><pre><a id="rest_code_792c241dc84a4c8980e4ff4f090f6b0d-1" name="rest_code_792c241dc84a4c8980e4ff4f090f6b0d-1" href="#rest_code_792c241dc84a4c8980e4ff4f090f6b0d-1"></a><span>class</span> <span>MyModelAdmin</span><span>(</span><span>admin</span><span>.</span><span>ModelAdmin</span><span>):</span>
<a id="rest_code_792c241dc84a4c8980e4ff4f090f6b0d-2" name="rest_code_792c241dc84a4c8980e4ff4f090f6b0d-2" href="#rest_code_792c241dc84a4c8980e4ff4f090f6b0d-2"></a>    <span>list_display</span> <span>=</span> <span>[</span><span>&#34;field1&#34;</span><span>,</span> <span>&#34;field2&#34;</span><span>,</span> <span>&#34;field3&#34;</span><span>,</span> <span>...</span><span>]</span>
</pre></div>
<p>And the stack trace points you to <a href="https://github.com/django/django/blob/4470c2405c8dbb529501f9d78753e2aa4e9653a2/django/contrib/admin/templatetags/admin_list.py#L212">this code</a>:</p>
<div><pre><a id="rest_code_8d34de0a6e0148b1ae38f28a18039a4e-1" name="rest_code_8d34de0a6e0148b1ae38f28a18039a4e-1" href="#rest_code_8d34de0a6e0148b1ae38f28a18039a4e-1"></a><span>for</span> <span>field_index</span><span>,</span> <span>field_name</span> <span>in</span> <span>enumerate</span><span>(</span><span>cl</span><span>.</span><span>list_display</span><span>):</span>
<a id="rest_code_8d34de0a6e0148b1ae38f28a18039a4e-2" name="rest_code_8d34de0a6e0148b1ae38f28a18039a4e-2" href="#rest_code_8d34de0a6e0148b1ae38f28a18039a4e-2"></a>    <span>f</span><span>,</span> <span>attr</span><span>,</span> <span>value</span> <span>=</span> <span>lookup_field</span><span>(</span><span>field_name</span><span>,</span> <span>result</span><span>,</span> <span>cl</span><span>.</span><span>model_admin</span><span>)</span>
</pre></div>
<p>It’s correct, but not helpful. I need to know what the value of the local variable <code>field_name</code> is in that loop to work out what is actually causing these queries.</p>
<p>In addition, in one case I was actually working with DRF endpoints, not the HTML endpoints the debug toolbar is designed for.</p>
<p>So, I wrote <a href="https://gist.github.com/spookylukey/cafeadfbe776ace223e5520bb0a93652#file-db_debug-py-L313">my own utilities</a> that, in addition to extracting the stack, would also include certain local variables for specified functions/methods. I then needed to add some aggregation functionality and pretty-printing for the SQL queries too. Also, I wrote a version of <a href="https://docs.djangoproject.com/en/4.1/topics/testing/tools/#django.test.TransactionTestCase.assertNumQueries">assertNumQueries</a> that used this better reporting.</p>
<p>This was highly effective, and enabled me and members of my team to tackle these DRF endpoints that had got entirely out of hand, often taking them from 10,000+ database queries (!) to 10 or 20.</p>
<p>This is relatively advanced stuff, but not actually all that hard, and it’s within reach of many developers. It doesn’t require learning a whole new language or deep black magic. You can call <code>sys._getframe</code> interactively from a REPL and find out what it does. The biggest hurdle is actually making the mental leap that says “I need to build this, and with Python, I probably can”.</p>
</section><section id="time-machine-and-pyfakefs"><h2><a href="#toc-entry-13" role="doc-backlink">time-machine and pyfakefs</a></h2>
<p>As an example of “entire program transformation”, <a href="https://github.com/adamchainz/time-machine">time-machine</a> is an extremely useful library that mocks out date/time functions across your entire program, and <a href="https://github.com/pytest-dev/pyfakefs">pyfakefs</a> is one that does the same thing for file-system calls.</p>
<p>These contrast with libraries like <a href="https://docs.python.org/3/library/unittest.mock.html">unittest.mock</a> do that do monkey patching on a more limited, module-by-module basis.</p>
<p>This technique is primarily useful in automated test suites, but it has a profound impact on the rest of your code base. In other languages, if you want to mock out “all date/time access” or “all filesystem access”, you may end up with a lot of tedious and noisy code to pass these dependencies through layers of code, or complex automatic dependency injection frameworks to avoid that. In Python, those things are rarely necessary, precisely because of things like time-machine and pyfakefs — that is, because your entire program can be manipulated at run-time. Your code base then has the massive benefit of a direct and simple style.</p>
</section><section id="environment-detection"><h2><a href="#toc-entry-14" role="doc-backlink">Environment detection</a></h2>
<p>My current employer is <a href="https://datapane.com/">Datapane</a> who make tools for data apps. Many of our customers use <a href="https://jupyter.org/">Jupyter</a> or similar environments. To make things work really smoothly, our library codes detects the environment it is running in and responds, and in some cases interacts with this environment (courtesy of <a href="https://datacrayon.com/">Shahin</a>, our Jupyter guy). This is an application of Python’s great support for introspection of the running program. There are a bunch of ways you can do this kind of thing:</p>
<ul>
<li><p>checking the system environment in <code>os.environ</code></p></li>
<li><p>checking the contents of <code>sys.modules</code></p></li>
<li><p>using <code>sys._getframe</code> to examine how you are being called.</p></li>
<li><p>attempting to use <a href="https://ipython.readthedocs.io/en/stable/api/generated/IPython.core.getipython.html#IPython.core.getipython.get_ipython">get_ipython</a> and seeing if it works etc.</p></li>
</ul>
<p>This is an example of the “whole runtime environment” being dynamic and introspectable, and Jupyter Notebook and its huge ecosystem make great use of this.</p>
<p>With some of the bigger features we’re working on at the moment at Datapane, we’re needing more advanced ways of adjusting to the running environment. Of course, as long it works, none of the implementation matters to our customers, so we don’t advertise any of that. Our marketing tagline for this is “Jupyter notebook to a shareable data app in 10 seconds”, not “we’re in your Python process, looking at your sys.modules”.</p>
<p>After doing a grep through my <code><span>site-packages</span></code>, I found that doing <code>sys._getframe</code> for different kinds of environment detection is relatively common — often used for things like “raise a deprecation warning, but not if we are being called from these specific callees, like our own code”. Here’s just one more example:</p>
<p><a href="https://boltons.readthedocs.io/">boltons</a> provides a <a href="https://boltons.readthedocs.io/en/latest/typeutils.html?highlight=sentinel#boltons.typeutils.make_sentinel">make_sentinel</a> function. The docs state that if you want “pickleability”, the sentinel must be stored in a module-level constant. But the implementation goes further and <a href="https://boltons.readthedocs.io/en/latest/_modules/boltons/typeutils.html#make_sentinel">checks</a> you are doing that using a <code>sys._getframe</code> trick. This is just a simple usability enhancement in which code checks that it is being used correctly, made possible by Python’s deep introspection support, but this kind of thing adds up. You will find many similar things in small amounts scattered across different libraries.</p>
</section><section id="fluent-compiler"><h2><a href="#toc-entry-15" role="doc-backlink">fluent-compiler</a></h2>
<p><a href="https://projectfluent.org/">Fluent</a> is a localisation system by Mozilla. I wrote and contributed the initial version of the official <a href="https://github.com/projectfluent/python-fluent">fluent.runtime</a> Python implementation, which is an interpreter for the Fluent language, and I also wrote a second implementation, <a href="https://github.com/django-ftl/fluent-compiler">fluent-compiler</a>.</p>
<p>Of all the libraries I’ve written, this was the one I enjoyed most, and it’s also the least popular it seems — not surprising, since GNU gettext provides a great 90% solution, which is enough for just about everyone, apart from Mozilla and, for some reason I can’t quite remember, me. However, I do know that Mozilla are actually using my second implementation in some of their web projects, via <a href="https://github.com/django-ftl/django-ftl">django-ftl</a>, and I’m using it, and it has a few GitHub stars, so that counts as real world!</p>
<p>Here are some of the Hillel-worthy Python techniques I used:</p>
<section id="compile-to-python"><h3><a href="#toc-entry-16" role="doc-backlink">Compile-to-Python</a></h3>
<p>In fluent-compiler, the implementation strategy I took was to compile the parsed Fluent AST to Python code, and <code>exec</code> it. I actually use Python AST nodes rather than strings, for various security reasons, but this is basically the same as doing <code>eval</code>, and that same technique is used by various other projects like <a href="https://jinja.palletsprojects.com/">Jinja</a> and <a href="https://www.makotemplates.org/">Mako</a>.</p>
<p>If anything qualifies as “programs that create programs on the fly”, then using <a href="https://docs.python.org/3/library/functions.html#exec">exec</a>, <a href="https://docs.python.org/3/library/functions.html#eval">eval</a> or <a href="https://docs.python.org/3/library/functions.html#compile">compile</a> must do so! The main advantage of this technique here is speed. It works particularly well with Fluent, because with a bit of static analysis, we can often completely eliminate the overhead that would otherwise be caused by its more advanced features, like <a href="https://projectfluent.org/fluent/guide/terms.html">terms and parameterized terms</a>, so that at run-time they cost us nothing.</p>
<p>This works even better when combined with PyPy. For the simple and common cases, under CPython 3.11 my benchmarks show a solution using fluent-compiler is about 15% faster than GNU gettext, while under PyPy it’s more than twice as fast.  You should take these numbers with a pinch of salt, but I am confident that the result is not slow, despite having far more advanced capabilities than GNU gettext, which is not necessarily true for my first implementation.</p>
<p>Additionally, there are some neat tricks you can do when implementing a compiler using the same language that you are compiling to, like <a href="https://github.com/django-ftl/fluent-compiler/blob/6b262af7ce7c5608516aa24aff868ff66f95e0af/src/fluent_compiler/compiler.py#L1366">evaluating some things ahead of time that you know are constants</a>.</p>
</section><section id="dynamic-test-methods"><h3><a href="#toc-entry-17" role="doc-backlink">Dynamic test methods</a></h3>
<p>While developing the second implementation, I used the first implementation as a reference. I didn’t want to duplicate every test, or really do anything manually to every test, I just wanted a large sub-set of the test suite to automatically test both implementations. I also wanted failures to clearly indicate which implementation had failed, i.e. I wanted them to run as separate test cases, because the reference implementation could potentially be at fault in some corner cases.</p>
<p>As I was using unittest, my solution was this: I <a href="https://github.com/django-ftl/fluent-compiler/blob/d1481d61e0bc1a28a228a4b6d5258350d436e765/fluent.runtime/tests/__init__.py#L12">added a class decorator</a> that modified the test classes by removing every method that started with <code>test_</code>, replacing it with two methods, one for each implementation.</p>
<p>This provided almost exactly the same functionality as one of Hillel’s wished-for examples:</p>
<blockquote>
<p>Add an output assertion to an optimized function in dev/testing, checking that on all invocations it matches the result of an unoptimized function</p>
</blockquote>
<p>I just used a slightly different technique that better suited my needs, but also made great use of run-time program manipulation.</p>
</section><section id="morph-into"><h3><a href="#toc-entry-18" role="doc-backlink"><code>morph_into</code></a></h3>
<p>As part of the Fluent-to-Python compilation process, I have a tree of AST objects that I want to simplify. Simplifications include things like replacing a “string join” operation that has just one string, with that single string — so we need completely different types of objects. Even in a language that has mutation this can be a bit of a pain, because we’ve got to update the parent object and tell it to replace this child with a different child, and there are many different types of parent object with very different shapes. So my solution was <code>morph_into</code>:</p>
<div><pre><a id="rest_code_c9c67dbce04a4259b7a9210b780071e7-1" name="rest_code_c9c67dbce04a4259b7a9210b780071e7-1" href="#rest_code_c9c67dbce04a4259b7a9210b780071e7-1"></a><span>def</span> <span>morph_into</span><span>(</span><span>item</span><span>,</span> <span>new_item</span><span>):</span>
<a id="rest_code_c9c67dbce04a4259b7a9210b780071e7-2" name="rest_code_c9c67dbce04a4259b7a9210b780071e7-2" href="#rest_code_c9c67dbce04a4259b7a9210b780071e7-2"></a>    <span>&#34;&#34;&#34;</span>
<a id="rest_code_c9c67dbce04a4259b7a9210b780071e7-3" name="rest_code_c9c67dbce04a4259b7a9210b780071e7-3" href="#rest_code_c9c67dbce04a4259b7a9210b780071e7-3"></a><span>    Change `item` into `new_item` without changing its identity</span>
<a id="rest_code_c9c67dbce04a4259b7a9210b780071e7-4" name="rest_code_c9c67dbce04a4259b7a9210b780071e7-4" href="#rest_code_c9c67dbce04a4259b7a9210b780071e7-4"></a><span>    &#34;&#34;&#34;</span>
<a id="rest_code_c9c67dbce04a4259b7a9210b780071e7-5" name="rest_code_c9c67dbce04a4259b7a9210b780071e7-5" href="#rest_code_c9c67dbce04a4259b7a9210b780071e7-5"></a>    <span>item</span><span>.</span><span>__class__</span> <span>=</span> <span>new_item</span><span>.</span><span>__class__</span>
<a id="rest_code_c9c67dbce04a4259b7a9210b780071e7-6" name="rest_code_c9c67dbce04a4259b7a9210b780071e7-6" href="#rest_code_c9c67dbce04a4259b7a9210b780071e7-6"></a>    <span>item</span><span>.</span><span>__dict__</span> <span>=</span> <span>new_item</span><span>.</span><span>__dict__</span>
</pre></div>
<p>With this solution, we leave the identity of the object the same, so none of the pointers to it need to be updated. But its type and all associated data is changed into something else, so that, other than <a href="https://docs.python.org/3/library/functions.html#id">id()</a>, the behaviour of <code>item</code> will now be indistinguishable from <code>new_item</code>. Not many languages allow you to do this!</p>
<p>I spent quite a lot of time wondering if I should be ashamed or proud of this code. But it turned out there was nothing to be ashamed of — it saved me writing a bunch of code and has had really no downsides.</p>
<p>Now, this technique won’t work for some things, like builtin primitives, so it can’t be completely generalised. But it doesn’t need that in order to be useful — all the objects I want to do this on are my own custom AST classes that share an interface, so it works and is “type safe” in its own way.</p>
<p>I’m far from the first person to discover this kind of trick when implementing compilers. In <a href="https://thume.ca/2019/04/29/comparing-compilers-in-rust-haskell-c-and-python/">this comparison of several groups of people working on a compiler project</a>, one of the most impressive results came from a single-person team who chose Python. She used way less code, and implemented way more features than the other groups, who all had multiple people on their teams and were using C++/Rust/Haskell etc. Fancy metaprogramming and dynamic typing were a big part of the difference, and by the sounds of it she used exactly the same kinds of things I used:</p>
<blockquote>
<p>Another example of the power of metaprogramming and dynamic typing is that we have a 400 line file called <code>visit.rs</code> that is mostly repetitive boilerplate code implementing a visitor on a bunch of AST structures. In Python this could be a short ~10 line function that recursively introspects on the fields of the AST node and visits them (using the <code>__dict__</code> attribute).</p>
</blockquote>
<p>Again, I’m not claiming “dynamic typing is better than static typing” — <a href="https://lukeplant.me.uk/blog/posts/you-cant-compare-language-features-only-languages/">I don’t think it’s even meaningful to do that comparison</a>. I’m claiming that highly dynamic meta-programming tricks are indeed a significant part of real Python code, and really do make a big difference.</p>
</section></section><section id="pytest"><h2><a href="#toc-entry-19" role="doc-backlink">Pytest</a></h2>
<p>Pytest does quite a few dynamic tricks.  Hillel wishes that pytests functionality was more easily usable elsewhere, such as from a REPL. I’ve no doubt this is a legitimate complaint — as it happens, my own use cases involve <a href="https://lukeplant.me.uk/blog/posts/repl-python-programming-and-debugging-with-ipython/">sticking a REPL in my test</a>, rather than sticking a pytest in my REPL. However, you can’t claim that pytest isn’t a valid example, or isn’t making use of Python’s dynamism — it does, and it provides a lot of useful functionality as a result, including:</p>
<section id="assert-rewriting"><h3><a href="#toc-entry-20" role="doc-backlink">Assert rewriting</a></h3>
<p>The most obvious is perhaps their <a href="https://docs.pytest.org/en/6.2.x/assert.html">assert rewriting</a>, which relies on modifying the AST of test modules to inject sub-expression information for when asserts fail. It makes test assertions often much more immediately useful.</p>
</section><section id="automatic-dependency-injection-of-fixtures"><h3><a href="#toc-entry-21" role="doc-backlink">Automatic dependency injection of fixtures</a></h3>
<p>Pytest provides one of the few cases of automatic dependency injection in Python where I’ve thought it was a good idea. It also makes use of Python’s dynamism to make this dependency injection extremely low ceremony. All you need to do is add a parameter to your test function, giving the parameter the name of the <a href="https://docs.pytest.org/en/6.2.x/fixture.html">fixture</a> you want, and pytest will find that fixture in its registry and pass it to your function.</p>
</section></section><section id="others"><h2><a href="#toc-entry-22" role="doc-backlink">Others</a></h2>
<p>This post is way too long already, and I’ve done very little actual searching for this stuff — almost all my examples are things that I’ve heard about in the past or done myself, so there must be far more than these in the real world out there. Here are a bunch more I thought of but didn’t have time to expand on:</p>
<ul>
<li><p>PyTorch <a href="https://pytorch.org/tutorials/beginner/basics/autogradqs_tutorial.html">automatic differentiation</a> which uses instrumented objects (similar to the SQLAlchemy example I presume), plus <a href="https://github.com/pytorch/pytorch/blob/master/tools/autograd/derivatives.yaml">some kind of pattern matching on function calls</a> that I haven’t had time to investigate.</p></li>
<li><p><a href="https://vcrpy.readthedocs.io/en/latest/index.html">VCR.py</a>: monkey patch all HTTP functions and record interactions, so that the second time we run a test we can use canned responses and avoid the network.</p></li>
<li><p>CCiW email tests: <a href="https://github.com/cciw-uk/cciw.co.uk/blob/37e6d69064c9a5d1372809fa2d723a0e203d21c3/cciw/utils/tests/base.py#L55">monkey patch Django’s Atomic decorator and mail sending functions</a> to ensure we are using “queued email” appropriately inside transactions.</p></li>
<li><p>Lots of tricks in <a href="https://github.com/radiac/django-tagulous">django-tagulous</a> to improve usability for developers.</p></li>
<li><p><a href="https://numba.pydata.org/">numba</a>: JIT compile and run your Python code on a GPU with a single decorator.</p></li>
<li><p><a href="https://drf-spectacular.readthedocs.io/en/latest/readme.html">drf-spectacular</a>: iterate over all endpoints in a DRF project, introspecting serializers and calling methods with dummy request objects where necessary, to produce an OpenAPI schema.</p></li>
<li><p>In the stdlib, <a href="https://docs.python.org/3/library/functools.html#functools.total_ordering">@total_ordering</a> will look at your class and add missing rich comparison methods.</p></li>
<li><p>depending on an environment flag, <a href="https://github.com/learnscripture/learnscripture.net/blob/3063de7bd364ccf6105b39485830e75b19f902d9/learnscripture/tests/base.py#L232">automatically wrap all UI test cases in a decorator that takes a screenshot if the test fails</a>.</p></li>
</ul></section><section id="conclusion"><h2><a href="#toc-entry-23" role="doc-backlink">Conclusion</a></h2>
<p>Why don’t we talk about these much? I think a large part of the answer is that the Python community cares about solving problems, and not about how clever your code is. Clever code, in fact, is looked down on, which is the right attitude — cleverness for the sake of it is always bad. Problem solving is good though. So libraries and projects that do these things don’t tend to brag about their clever techniques, but the problem that they solve.</p>
<p>Also, many libraries that use these things wrap them up so that you don’t have to know what’s going on — It Just Works. As a newbie, everything about computers is magical and you have to just accept that that’s how they work. Then you take it for granted, and just get on with using it.</p>
<p>On the other hand, for the implementer, once you understand the magic, it stops being magic, it’s just a feature that the language has.</p>
<p>Either way, pretty soon none of these things count as “hyper programming” any more — in one sense, they are just normal Python programming, and that’s the whole point: <strong>Python gives you super powers which are not super powers, they are normal powers</strong>. Everyone gets to use them, and you don’t need to learn a different language to do so.</p>
<p>Perhaps we do need to talk about them more, though. At the very least, I hope my examples have sparked some ideas about the kinds of things that are possible in Python.</p>
<p>Happy hacking!</p>
</section><section id="links"><h2><a href="#toc-entry-24" role="doc-backlink">Links</a></h2>
<ul>
<li><p><a href="https://lobste.rs/s/9w7ylg/python_s_disappointing_superpowers">Discussion of this post on Lobsters</a></p></li>
<li><p><a href="https://twitter.com/spookylukey/status/1620851142849863680">Discussion of this post on Twitter</a></p></li>
<li><p><a href="https://news.ycombinator.com/item?id=34611969">Discussion of this post on Hacker News</a></p></li>
</ul></section>
</div>
    </section></article>



</div></div>
  </body>
</html>
