<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://blog.pkh.me/p/33-deconstructing-be%CC%81zier-curves.html">Original</a>
    <h1>Deconstructing Bézier Curves</h1>
    
    <div id="readability-page-1" class="page"><article><p>Graphists, animators, game programmers, font designers, and other graphics
professionals and enthusiasts are often working with Bézier curves. They&#39;re
popular, extensively documented, and used pretty much everywhere. That being
said, I find them being explained almost exclusively in 2 or 3 dimensions,
which can be a source of confusion in various situations. I&#39;ll try to
deconstruct them a bit further in this article. At the end or the post, we&#39;ll
conclude with a concrete example where this deconstruction is helpful.</p>
<h2>A Bézier curve in pop culture</h2>
<p>Most people are first confronted with Bézier curves through an UI that may look
like this:</p>
<p><img src="http://blog.pkh.me/img/bezier/b3-labels.png" alt="centerimg"/></p>
<p>In this case the curve is composed of 4 user controllable points, meaning it&#39;s
a Cubic Bézier.</p>
<p><code>C₀</code>, <code>C₁</code>, <code>C₂</code> and <code>C₃</code> are respectively the start, controls and end 2D point
coordinates. Evaluating this formula for all the <code>t</code> values within <code>[0;1]</code> will
give all the points of the curve. Simple enough.</p>
<p>Now this is obvious but the important take here is that this formula applies
<strong>to each dimension</strong>. Since we are working in 2D here, it is evaluated on both
the x and y-axis. As a result, a more explicit writing of the formula would be:</p>
<p><img src="http://blog.pkh.me/img/bezier/bezier-0.png" alt="centerimg"/></p>
<p><strong>Note</strong>: if we were working with Bézier in 3D space, the <code>C</code> vectors would be
in 3D as well.</p>
<p>Intuitively, you may start to see in the mathematical form how each point
contributes to the curve, but it involves some tricky mental gymnastic (at
least for me). So before diving into the multidimensional aspect, we will
simplify the problem by looking into lower degrees.</p>
<h2>Lower degrees</h2>
<p>As implied by its name, the <strong>Cubic</strong> curve <code>B₃(t)</code> is of the 3rd degree. The
2nd most popular curve is the <strong>Quadratic</strong> curve <code>B₂(t)</code> where instead of 2
control points, we only have one (<code>Q₁</code>, in the middle):</p>
<p><img src="http://blog.pkh.me/img/bezier/b2-labels.png" alt="centerimg"/></p>
<p>Can we go lower? Well, there is a &#34;1st degree Bézier curve&#34; but you won&#39;t hear
that term very often, because after removing the remaining control point:</p>
<p><img src="http://blog.pkh.me/img/bezier/b1-labels.png" alt="centerimg"/></p>
<p>The &#34;curve&#34; is now a simple line between the 2 points. Still, the concept of
interpolation between the points is consistent/symmetric with the cubic and the
quadratic.</p>
<p>Do you recognize the formula (see title of the figure)? Yes, this is <a href="http://blog.pkh.me/p/29-the-most-useful-math-formulas.html">mix(),
one of the most useful math formula</a>!
The contribution of each factor should make sense this time: <code>t</code> varies within
<code>[0;1]</code>, at <code>t=0</code> we have 100% of <code>L₀</code> (the starting point), at <code>t=1</code> we have
100% of <code>L₁</code>, in the middle at <code>t=½</code> we have 50% of each, etc. All intermediate
values of <code>t</code> define a straight line between these 2 points. We have a simple
linear interpolation.</p>
<p>The presence of this function in the 1st degree is not just a coincidence:
<strong>the <code>mix</code> function is actually the corner stone of all the Bézier curves</strong>.
Indeed, we can build up the Bézier formulas using exclusively nested <code>mix()</code>:</p>
<ul>
<li><code>B₁(l₀,l₁,t) = mix(l₀,l₁,t)</code></li>
<li><code>B₂(q₀,q₁,q₂,t) = B₁(mix(q₀,q₁,t), mix(q₁,q₂,t), t)</code></li>
<li><code>B₃(c₀,c₁,c₂,c₃,t) = B₂(mix(c₀,c₁,t), mix(c₁,c₂,t), mix(c₂,c₃,t))</code></li>
</ul>
<p>This way of formulating the curves is basically <a href="https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm">De Casteljau&#39;s
algorithm</a>. You have no idea how much I love accidentally finding
yet again a relationship with my favourite mathematical function.</p>
<p>But back to our &#34;Bézier 1st degree&#34;, remember that we are still in 2D:</p>
<p><img src="http://blog.pkh.me/img/bezier/bezier-1.png" alt="centerimg"/></p>
<p>This multi-dimensional graphic representation can be problematic because it is
<strong>exclusively spatial</strong>: if one is interested in the <code>t</code> parameter, it has to
be extrapolated visually from a twisted curve using mind bending powers, which
is not always practical.</p>
<h2>Mono-dimensional</h2>
<p>In order to represent <code>t</code>, we have to split each spatial dimension and draw
them according to <code>t</code> (defined within <code>[0;1]</code>).</p>
<p>Let&#39;s work this out with the following cubic curve (start point is
bottom-left):</p>
<p><img src="http://blog.pkh.me/img/bezier/cubic-2d.png" alt="centerimg"/></p>
<p>If we study this curve, we can see that the <code>x</code> is slightly decreasing, then
increasing for most of the curve, then slightly decreasing again. In
comparison, the <code>y</code> seems to be increasing, decreasing, then increasing again,
probably more strongly than with <code>x</code>. But can you tell for sure what their
respective curves actually look like precisely? I for sure can&#39;t, but my
computer can:</p>
<p><img src="http://blog.pkh.me/img/bezier/cubic-1d.png" alt="centerimg"/></p>
<p>Just to be extra clear: the formula is unchanged, we&#39;re simply tracing the x
and y dimensions separately according to <code>t</code> instead of plotting the curve in a
xy plane. Note that this means <strong><code>C₀</code>, <code>C₁</code>, <code>C₂</code> and <code>C₂</code> can now only change
vertically</strong>: they are respectively placed at <code>t=0</code>, <code>t=⅓</code>, <code>t=⅔</code> and <code>t=1</code>.
The vertical axis corresponds to their value on their respective plane.</p>
<p>Similarly, with a quadratic we would have <code>Q₀</code> at <code>t=0</code>, <code>Q₁</code> at <code>t=½</code> and <code>Q₂</code>
at <code>t=1</code>.</p>
<p>So what&#39;s so great about this representation? Well, first of all the curves are
not going backward anymore, they can be understood by following a left-to-right
reading everyone is familiar with: there is no shenanigan involved in the
interpretation anymore. Also, we are now going to be able to work them out in
algebraic form.</p>
<h2>Polynomial form</h2>
<p>So far we&#39;ve looked at the curve under their Bézier form, but they can also be
expressed in their polynomial form:</p>
<pre><code>B₁(t) = (1-t)·L₀ + t·L₁
      = (-L₀+L₁)·t + L₀
      = a₁t + b₁
</code></pre>
<pre><code>B₂(t) = (1-t)²·Q₀ + 2(1-t)t·Q₁ + t²·Q₂
      = (Q₀-2Q₁+Q₂)·t² + (-2Q₀+2Q₁)·t + Q₀
      = a₂t² + b₂t + c₂
</code></pre>
<pre><code>B₃(t) = (1-t)³·C₀ + 3(1-t)²t·C₁ + 3(1-t)t²·C₂ + t³·C₃
      = (-C₀+3C₁-3C₂+C₃)·t³ + (3C₀-6C₁+3C₂)·t² + (-3C₀+3C₁)·t + C₀
      = a₃t³ + b₃t² + c₃t + d₃
</code></pre>
<p>This algebraic form is great because we can now plug the formula into a
polynomial root finding algorithm in order to identify the roots. Let&#39;s study a
concrete use case of this.</p>
<h2>Concrete use case: intersecting ray</h2>
<p>A fundamental problem of text rendering is figuring out whether a given pixel
<code>P</code> lands inside or outside the character shape (which is composed of a chain
of Bézier curves). The most common algorithms (<a href="https://en.wikipedia.org/wiki/Nonzero-rule">non-zero rule</a> or
<a href="https://en.wikipedia.org/wiki/Even-odd_rule">even-odd rule</a>) involve a <em>ray</em> going from the pixel position into an
arbitrary direction toward infinity (usually horizontal for simplicity). If we
can identify every intersection of this ray with each curve of the shape, we
can deduce if our pixel point <code>P=(Px,Py)</code> is inside or outside.</p>
<p>We will simplify the problem to the crossing of just one curve, using the one
from previous section. It would look like this with an arbitrary point <code>P</code>:</p>
<p><img src="http://blog.pkh.me/img/bezier/cubic-2d-ray.png" alt="centerimg"/></p>
<p>We&#39;re looking for the intersection coordinates, but how can we do that in 2D
space? Well, with an horizontal ray, we would have to know when the
y-coordinate of the curve is the same as the y-coordinate of <code>P</code>, so we first
have to solve <code>By(t) = Py</code>, or <code>By(t)-Py=0</code>, where <code>By(t)</code> is the <code>y</code> component
of the given Bézier curve <code>B(t)</code>.</p>
<p>This is a schoolbook <a href="https://en.wikipedia.org/wiki/Root-finding_algorithms">root finding</a> problem, because given that
<code>B(t)</code> is of the third degree, we end up solving the equation: <code>a₃t³ + b₃t² + c₃t + d₃ - Py = 0</code> (the <code>d₃ - Py</code> part is constant, so it acts as the last
coefficient of the polynomial). This gives us the <code>t</code> values (or roots), that
is where the ray crosses our <code>y</code> component.</p>
<p>Since this is a 3rd degree polynomial (highest power is 3), we will have <em>at
most</em> 3 points were the ray crosses the curve. In our case, we do actually get
the maximum number of roots:</p>
<p><img src="http://blog.pkh.me/img/bezier/cubic-1d-y-ray.png" alt="centerimg"/></p>
<p>Now that we have the <code>t</code> values on our curve (remember that <code>t</code> values are
common for both x and y axis), we can simply evaluate the <code>x</code> component of the
<code>B(t)</code> to obtain the <code>x</code> coordinate.</p>
<p><img src="http://blog.pkh.me/img/bezier/cubic-1d-x-ray.png" alt="centerimg"/></p>
<p>Using <code>Px</code>, we can filter which roots we want to keep. In this case,
<code>Px=-0.75</code>, so we&#39;re going to keep all the intersections (all the roots
x-coordinates are located above this value).</p>
<p>We could do exactly the same operation by solving <code>Bx(t)-Px=0</code> and evaluating
<code>By(t)</code> on the roots we found: this would give us the intersections with a
vertical ray instead of an horizontal one.</p>
<p>I&#39;m voluntarily omitting a lot of technical details here, such as the root
finding algorithm and floating point inaccuracies challenges: the point is to
illustrate how the 1D deconstruction is essential in understanding and
manipulating Bézier curves.</p>
<h2>Bonus</h2>
<p>During the writing of this article, I made a small <code>matplotlib</code> demo which got
quite popular on Twitter, so I&#39;m sharing it again:</p>
<p>
    <video src="/misc/bezier.webm" controls="controls" width="800">Animated Bézier curves</video>
</p>
<p>The script used to generate this video:</p>
<pre><code>import matplotlib.pyplot as plt
import numpy as np
from matplotlib.animation import FuncAnimation

def mix(a, b, x): return (1 - x) * a + b * x
def linear(a, b, x): return (x - a) / (b - a)
def remap(a, b, c, d, x): return mix(c, d, linear(a, b, x))

def bezier1(p0, p1, t): return mix(p0, p1, t)
def bezier2(p0, p1, p2, t): return bezier1(mix(p0, p1, t), mix(p1, p2, t), t)
def bezier3(p0, p1, p2, p3, t): return bezier2(mix(p0, p1, t), mix(p1, p2, t), mix(p2, p3, t), t)

def _main():
    pad = 0.05
    bmin, bmax = -1, 1
    x_color, y_color, xy_color = &#34;#ff4444&#34;, &#34;#44ff44&#34;, &#34;#ffdd00&#34;

    np.random.seed(0)
    r0, r1 = np.random.uniform(-1, 1, (2, 4))
    r2, r3 = np.random.uniform(0, 2 * np.pi, (2, 4))

    cfg = {
        &#34;axes.facecolor&#34;: &#34;333333&#34;,
        &#34;figure.facecolor&#34;: &#34;111111&#34;,
        &#34;font.family&#34;: &#34;monospace&#34;,
        &#34;font.size&#34;: 9,
        &#34;grid.color&#34;: &#34;666666&#34;,
    }
    plt.style.use(&#34;dark_background&#34;)
    with plt.rc_context(cfg):
        fig = plt.figure(figsize=[8, 4.5])
        gs = fig.add_gridspec(nrows=2, ncols=3)

        ax_x = fig.add_subplot(gs[0, 0])
        ax_x.grid(True)
        for i in range(4):
            ax_x.axvline(x=i / 3, linestyle=&#34;--&#34;, alpha=0.5)
        ax_x.axhline(y=0, alpha=0.5)
        ax_x.set_xlabel(&#34;t&#34;)
        ax_x.set_ylabel(&#34;x&#34;, rotation=0, color=x_color)
        ax_x.set_xlim(0 - pad, 1 + pad)
        ax_x.set_ylim(bmin - pad, bmax + pad)
        (x_plt,) = ax_x.plot([], [], &#34;-&#34;, color=x_color)
        (x_plt_c0,) = ax_x.plot([], [], &#34;o:&#34;, color=x_color)
        (x_plt_c1,) = ax_x.plot([], [], &#34;o:&#34;, color=x_color)

        ax_y = fig.add_subplot(gs[1, 0])
        ax_y.grid(True)
        for i in range(4):
            ax_y.axvline(x=i / 3, linestyle=&#34;--&#34;, alpha=0.5)
        ax_y.axhline(y=0, alpha=0.5)
        ax_y.set_xlabel(&#34;t&#34;)
        ax_y.set_ylabel(&#34;y&#34;, rotation=0, color=y_color)
        ax_y.set_xlim(0 - pad, 1 + pad)
        ax_y.set_ylim(bmin - pad, bmax + pad)
        (y_plt,) = ax_y.plot([], [], &#34;-&#34;, color=y_color)
        (y_plt_c0,) = ax_y.plot([], [], &#34;o:&#34;, color=y_color)
        (y_plt_c1,) = ax_y.plot([], [], &#34;o:&#34;, color=y_color)

        ax_xy = fig.add_subplot(gs[0:2, 1:3])
        ax_xy.grid(True)
        ax_xy.axvline(x=0, alpha=0.8)
        ax_xy.axhline(y=0, alpha=0.8)
        ax_xy.set_aspect(&#34;equal&#34;, &#34;box&#34;)
        ax_xy.set_xlabel(&#34;x&#34;, color=x_color)
        ax_xy.set_ylabel(&#34;y&#34;, rotation=0, color=y_color)
        ax_xy.set_xlim(bmin - pad, bmax + pad)
        ax_xy.set_ylim(bmin - pad, bmax + pad)
        (xy_plt,) = ax_xy.plot([], [], &#34;-&#34;, color=xy_color)
        (xy_plt_c0,) = ax_xy.plot([], [], &#34;o:&#34;, color=xy_color)
        (xy_plt_c1,) = ax_xy.plot([], [], &#34;o:&#34;, color=xy_color)

        fig.tight_layout()

        def update(frame):
            px = remap(-1, 1, bmin, bmax, np.sin(r0 * frame + r2))
            py = remap(-1, 1, bmin, bmax, np.sin(r1 * frame + r3))
            t = np.linspace(0, 1)
            x = bezier3(px[0], px[1], px[2], px[3], t)
            y = bezier3(py[0], py[1], py[2], py[3], t)

            x_plt.set_data(t, x)
            x_plt_c0.set_data((0, 1 / 3), (px[0], px[1]))
            x_plt_c1.set_data((2 / 3, 1), (px[2], px[3]))

            y_plt.set_data(t, y)
            y_plt_c0.set_data((0, 1 / 3), (py[0], py[1]))
            y_plt_c1.set_data((2 / 3, 1), (py[2], py[3]))

            xy_plt.set_data(x, y)
            xy_plt_c0.set_data((px[0], px[1]), (py[0], py[1]))
            xy_plt_c1.set_data((px[2], px[3]), (py[2], py[3]))

        duration, fps, speed = 15, 60, 3
        frames = np.linspace(0, duration * speed, duration * fps)
        anim = FuncAnimation(fig, update, frames=frames)
        anim.save(&#34;/tmp/bezier.webm&#34;, fps=fps, codec=&#34;vp9&#34;, extra_args=[&#34;-preset&#34;, &#34;veryslow&#34;, &#34;-tune-content&#34;, &#34;screen&#34;])


if __name__ == &#34;__main__&#34;:
    _main()
</code></pre>
</article></div>
  </body>
</html>
