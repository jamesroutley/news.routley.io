<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://xvw.lol/en/articles/why-ocaml.html">Original</a>
    <h1>OCaml as my primary language</h1>
    
    <div id="readability-page-1" class="page"><article><p>In this <em>opinion piece</em>, I will try to briefly share my encounter with
the language and list its advantages — organized into several sections
covering <em>the language itself</em>, its ecosystem, and its community. I
will also attempt to <em>debunk</em> some popular myths (or misconceptions)
found on the Internet. For the sake of transparency, it is important
to note that, at the time of writing, my <a href="https://tarides.com">professional
work</a> <strong>involves working for and on the OCaml
ecosystem</strong>. However, readers who have followed me for several years
can attest that I was promoting the language long before I was paid to
work on the OCaml ecosystem, <em>sometimes rather immoderately</em>.</p>
<h2 id="foreword"><a aria-hidden="true" href="#foreword"></a>Foreword</h2>
<p>First, this article will explain why I <strong>personally</strong> believe that
OCaml is a relevant choice in many contexts. My goal is not
specifically to convince you—although that would be a very welcome
<em>side effect</em> — and it’s quite likely that many of the arguments I
present will also apply to other languages!</p>
<p>Also, very often, when I suggest OCaml to people who want to explore
new languages or try out solutions written in OCaml, I’m kindly told
that <em>I’m always promoting OCaml</em>. It’s amusing to notice that when
the suggestions involve languages adopted <em>by default</em>, like
JavaScript, or more recent ones like
<a href="https://www.rust-lang.org/">Rust</a> or <a href="https://go.dev/">Go</a>, they tend
to trigger fewer reactions. This is probably because people
<em>implicitly</em> assume that proposing a <em>lesser-known</em> language leans
toward irrationality and personal preference. From my point of view,
<strong>suggesting OCaml is, in many cases where fine-grained memory control
is not needed, just as relevant as suggesting Rust</strong> (and probably
more so).</p>
<p>To wrap up this preface, many people first encountered OCaml (or <a href="https://caml.inria.fr/caml-light/release.fr.html">Caml
Light</a>) during their
undergraduate studies or in preparatory classes, often using it in
contexts far removed from industry. As for me, I started getting
interested in OCaml much earlier, thanks to the <a href="http://sdz.tdct.org/">Site du
Zéro</a>, where a small community of functional
programming enthusiasts promoted less <em>mainstream</em> languages like
<a href="https://ocaml.org">OCaml</a>, <a href="https://www.erlang.org/">Erlang</a>, and
<a href="https://www.haskell.org/">Haskell</a>. My interaction with OCaml at
university was <strong>just a bonus</strong>.</p>
<h3 id="other-resources"><a aria-hidden="true" href="#other-resources"></a>Other resources</h3>
<p>I’m not the first to document the reasons for choosing OCaml. There
are many other resources that, in my opinion, are also worth checking
out, and they show that OCaml users are generally very satisfied — so
much so that they’re motivated to share <em>how and why</em> we chose the
language as our main technology:</p>
<ul>
<li>
<p><a href="https://dev.realworldocaml.org/prologue.html#why-ocaml">&#34;<strong>Why
OCaml?</strong>&#34;</a>,
the prologue of the book <a href="https://dev.realworldocaml.org/toc.html">Real World
OCaml</a>, which presents
factual advantages of using OCaml (and whose introduction includes a
timeline). While the book is excellent in many respects, I’ve gotten
into the habit of not recommending it because I find its usage
approach quite biased, suggesting libraries by default that aren’t
necessarily widely accepted in the community.</p>
</li>
<li>
<p><a href="https://cs3110.github.io/textbook/chapters/intro/intro.html">&#34;<strong>Better Programming Through
OCaml</strong>&#34;</a>,
the prologue of the book (accompanied by videos) <a href="https://cs3110.github.io/textbook/cover.html">OCaml Programming:
Correct + Efficient +
Beautiful</a>, which
mainly explains how learning OCaml can improve a developer’s skills
in other, more popular technologies. The book is fairly recent, and
it’s the one I <strong>now recommend as the go-to resource</strong> for getting
started with OCaml.</p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=v1CmGbOGb2I"><strong>Talk: &#34;Why
OCaml?&#34;</strong></a>, a
presentation by <a href="https://twitter.com/yminsky">Yaron Minsky</a>, CTO of
<a href="https://blog.janestreet.com/">Jane Street</a>—an industrial user of
OCaml and one of the global leaders in finance. Yaron is also one of
the authors of <em>Real World OCaml</em> and the originator of the widely
quoted phrase in the statically typed programming languages world,
&#34;<em>Make illegal states unrepresentable</em>&#34;. The talk offers plenty of
insights into Jane Street’s motivations for choosing OCaml.</p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=TxuLrsQZprE">&#34;<strong>OCaml for Fun &amp; Profit: An Experience
Report</strong>&#34;</a>, presented
by <a href="https://lambdafoo.com/">Tim McGilchrist</a> at <a href="https://yowcon.com/melbourne-2023">Yow
2023</a>. After a rich introduction
to the language, it covers some very concrete use cases of OCaml in
production — <em>with fun and profit</em>.</p>
</li>
<li>
<p><a href="https://roscidus.com/blog/blog/categories/0install/">&#34;<strong>Replacing Python for
0Install</strong>&#34;</a> by
<a href="https://roscidus.com/blog/">Thomas Leonard</a>. This series of
articles is, in my view, <strong>incredibly interesting</strong>. The author of
<a href="https://0install.net/">0Install</a>, a decentralized, cross-platform
software installation system (a slightly older alternative to
<a href="https://nixos.org/">Nix</a>), was looking for a language other than
<a href="https://www.python.org/">Python</a> for a new version’s implementation
(the reasons for replacing Python are also <a href="https://roscidus.com/blog/blog/2013/06/09/choosing-a-python-replacement-for-0install/#why-replace-python">documented
here</a>)
and carried out a thorough, methodical comparison of several
candidates: <a href="https://www.cs.bu.edu/~hwxi/atslangweb/">ATS</a>,
<a href="https://learn.microsoft.com/en-us/dotnet/csharp/">C#</a>,
<a href="https://www.haskell.org/">Haskell</a>, <a href="https://go.dev">Go</a>,
<a href="https://www.rust-lang.org/">Rust</a>, and <a href="https://ocaml.org">OCaml</a>,
alongside Python. Years later, I’m still impressed by the rigor and
nuance of this series, which I <strong>highly recommend</strong>.</p>
</li>
</ul>
<p>There are probably other resources and testimonials, notably on the
<a href="https://ocaml.org/">official website</a>, which features both
<a href="https://ocaml.org/industrial-users">industrial</a> and
<a href="https://ocaml.org/academic-users">academic</a> case studies. There are
also articles expressing the frustration OCaml can cause. I’m aware
that OCaml is not perfect—nor do I believe any technology is
perfect. I’ll likely refer to some of these articles (implicitly or
explicitly) in the section on <em>myths</em> and in the conclusion, where
I’ll try to explain in which contexts I don’t find OCaml to be a
relevant choice.</p>
<h2 id="ocaml-as-a-language"><a aria-hidden="true" href="#ocaml-as-a-language"></a>OCaml as a language</h2>
<p>Before diving into the <strong>features</strong> offered by the language, I’d like
to start with a point that I believe is essential. OCaml is a
programming language that originated from
<a href="https://ocaml.org/about#history">research</a> and is used by <a href="https://ocaml.org/industrial-users">industrial
users</a>. This duality is important
because it provides the language with two key advantages:</p>
<ul>
<li>
<p>Guidance on <em>desirable</em> features as interesting language concepts,
supported by advanced research. For example, to my knowledge, OCaml
is the first <em>mainstream</em> language to offer native support for
<a href="https://v2.ocaml.org/manual/effects.html">user-defined effects</a>,
which is the result of cutting-edge research, illustrated by
numerous
<a href="https://arxiv.org/search/cs?searchtype=author&amp;query=Sivaramakrishnan,+K">publications</a>.</p>
</li>
<li>
<p>Guidance on <em>desirable</em> features as tools for industrialization,
also backed by research and motivated by practical use cases. For
instance, recently, <a href="https://blog.janestreet.com/">Jane Street</a>, a
major industrial OCaml user, proposed the integration of <em>affine
sessions</em>, enabling <a href="https://blog.janestreet.com/search/?query=oxidizing">linear resource
management</a>
(somewhat <em>Rust-like</em>).</p>
</li>
</ul>
<p>This intertwining of industrial and academic motivations allows OCaml
to offer a collection of solid, useful, and well-defined features. In
other words, OCaml is a <strong>living</strong> language, and since I’ve been using
it, I’ve witnessed many developments and additions that I consider
highly desirable and that <em>debunk</em> a common assertion against OCaml:
<strong>the language is only useful for theory or for implementing
<a href="https://coq.inria.fr/">Coq/Rocq</a></strong>.</p>
<p>Although this was historically true, the motivations provided by
industrial users justify the label &#34;<em>An industrial-strength functional
programming language with an emphasis on expressiveness and safety</em>.&#34;
The opening keynote of the <a href="https://ocaml.org/conferences/ocaml-workshop-2021">OCaml Workshop
2021</a> by <a href="https://xavierleroy.org/">Xavier
Leroy</a>, titled &#34;<a href="https://watch.ocaml.org/w/tU8wR9EcAcyFHHVcX4GS46"><em>25 Years Of
OCaml</em></a>,&#34; presents
an exhaustive timeline of OCaml’s continuous design, showing the
various phases of evolution the language has undergone.</p>
<p>In broad terms, OCaml is a programming language from the <a href="https://en.wikipedia.org/wiki/ML_%28programming_language%29">ML
family</a>,
<strong>high-level</strong> (here, meaning it features <a href="https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29">garbage
collection</a>),
<strong>statically typed</strong> (types are checked at compile time with no
implicit conversions), with <strong><a href="https://en.wikipedia.org/wiki/Type_inference">type
inference</a></strong> (also
called <em>type synthesis</em>), allowing the compiler to deduce the type of
an expression in most cases. This enables programming in both
<a href="https://en.wikipedia.org/wiki/Functional_programming"><strong>functional</strong></a>
and
<a href="https://en.wikipedia.org/wiki/Imperative_programming"><strong>imperative</strong></a>
styles.</p>
<p>OCaml also provides an <strong>object-oriented programming model</strong> and a
very rich <strong>module system</strong>. The language has two compilation schemes:
<code>ocamlc</code>, which compiles to a <em>bytecode</em> executable by a <strong>virtual
machine</strong> (portable and efficient), and <code>ocamlopt</code>, which compiles to
<strong>native machine code</strong> (runnable on a wide <a href="https://github.com/ocaml/ocaml?tab=readme-ov-file#overview">variety of
architectures</a>).</p>
<p>Moreover, OCaml allows <strong>conversion of its bytecode to JavaScript</strong>
using
<a href="https://ocsigen.org/js_of_ocaml/latest/manual/overview">Js_of_ocaml</a>,
enabling <em>very fast</em> interoperability within the OCaml ecosystem
(which I use <em>extensively</em> on this website). The <a href="https://github.com/ocaml-wasm/wasm_of_ocaml">same approach is
used to produce
WebAssembly</a>. For deeper
interoperability with the JavaScript ecosystem,
<a href="https://melange.re/">Melange</a> takes a somewhat different approach
than Js_of_ocaml to generate robust JavaScript.</p>
<p>OCaml is a <strong>highly versatile</strong> language, and I will now try to
present the features and strengths that make it — <em>for me</em> — an ideal
tool for building both personal and professional projects, starting
with a brief detour into static typing.</p>
<h3 id="on-static-type-checking"><a aria-hidden="true" href="#on-static-type-checking"></a>On static type checking</h3>
<p>When I was preparing, with <a href="https://twitter.com/bibear">Bruno</a>, the
episode of <a href="https://www.ifttd.io/liste-des-episodes">If This Then Dev</a>
dedicated to OCaml — which, in the end, was
<a href="https://www.ifttd.io/episodes/le-langage-de-tous-les-langages">recorded</a>
with <a href="https://github.com/d-plaindoux">Didier</a> — he asked me a question
that I found surprising:</p>
<blockquote>
<p>“Is it really worth bothering with types when working on a <em>personal
project</em> quickly?  Even though I can perfectly see the value for
<em>production</em> code, for a <em>personal project</em> it seems like a waste of
time to me.”</p>
</blockquote>
<p>I think there are two main angles to answer this. The first, and most
obvious, is that, <strong>in principle, I don’t see why a personal project
should be any less disciplined than a professional one</strong>. When I write
software <em>for myself</em>, I could indeed get away with ignoring the
<em>corner cases</em> of my implementation. Sure, that’s possible. But that’s
probably not what I actually want to do. So, if a language and its
compiler let me set up safety nets that force me to account for all
the cases in my software, <em>I take them</em> — just like writing <em>unit
tests</em> <strong>makes development easier</strong>, and I don’t see them as a
constraint.</p>
<p>But beyond considerations of hygiene in a personal project, I think
the negative reputation of static type checking usually stems from a
bad experience. Indeed, in languages like C or Java, types are
<strong>mostly a constraint</strong> that can be easily circumvented. In languages
that place a strong emphasis on typing — like
<a href="https://ocaml.org">OCaml</a>, <a href="https://www.haskell.org">Haskell</a>,
<a href="https://fsharp.org">F#</a>, <a href="https://www.scala-lang.org/">Scala</a>, or
<a href="https://www.rust-lang.org">Rust</a> — <strong>types act as safeguards</strong>. More
importantly, in my view, <strong>types also serve as a tool for expressive
<em>design</em></strong>. Using them provides safety while also offering an
incredibly rich, versatile, and concise way to describe data.</p>
<p>From my experience, even though it’s common to move from a
<em>poorly-typed</em> (sorry, the temptation is too strong) to a <em>dynamically
typed</em> language — I, for instance, happily transitioned from Java to
Ruby — moving from a language with a rich type system, like OCaml or
Haskell, makes switching to a <em>dynamically typed</em> language much
harder. At present, <strong>I don’t know anyone who has seriously used
languages like OCaml or Haskell and was happy to return to languages
with less sophisticated type systems</strong> (though an interesting project
can sometimes justify such a technological regression).</p>
<p>This is <strong>not just a personal observation</strong>; static type checking is
central to the broader debate about the evolution of programming
languages. Historical languages evolve (or attempt to evolve) to
integrate more type checking. For instance,
<a href="https://www.erlang.org/">Erlang</a>, as early as the 1980s (before its
compiler source was released), experimented with <a href="https://homepages.inf.ed.ac.uk/wadler/papers/erlang/erlang.pdf">integrating a type
system</a>. Java,
version by version, enhances features aimed at improving static type
verification, such as incorporating <a href="https://openjdk.org/jeps/409">sealed
families</a>.</p>
<p>Many languages are experimenting with type systems: <a href="https://www.ruby-lang.org/en/news/2020/12/25/ruby-3-0-0-released/">Ruby with
RBS</a>,
<a href="https://crystal-lang.org/">Crystal</a> (a statically typed language
heavily inspired by Ruby), <a href="https://mypy-lang.org/">Python with Mypy</a>,
<a href="https://www.irif.fr/_media/users/gduboc/elixir-types.pdf">Elixir</a>
(which revisits Erlang’s past experiments, offering a viable gradual
typing approach), and, of course,
<a href="https://www.typescriptlang.org/">TypeScript</a>, which has become
<strong>widely adopted</strong> in the JavaScript community.</p>
<p>While all these initiatives are encouraging and clearly move in the
right direction, for now, they primarily <strong>add safeguards</strong> but do not
yet serve as expressive <strong>design tools</strong>.</p>
<p>When it comes to increasingly rich type systems, <strong>the White House</strong>
recently published a
<a href="https://bidenwhitehouse.archives.gov/oncd/briefing-room/2024/02/26/press-release-technical-report/">report</a>
emphasizing the importance of <em>memory safety</em> in software design and…
<em>endorsing</em> the use of the <a href="https://www.rust-lang.org">Rust</a> language
(historically <a href="https://users.rust-lang.org/t/understanding-how-the-rust-compiler-is-built/87237/7">written in
OCaml</a>
before becoming <em>self-hosted</em>) over C++, clearly showing that even
official bodies (often considered outdated) highlight the value of
rich type systems. Moreover, the <a href="https://tarides.com/blog/2024-03-07-a-time-for-change-our-response-to-the-white-house-cybersecurity-press-release/">response from
Tarides</a>,
the company I work for at the time of writing this article, also
presents compelling arguments in favor of using OCaml for building
critical systems.</p>
<p>In conclusion, static type checking is really valuable and highly
recommended, and it’s worth exploring languages with sophisticated
type systems (like OCaml) and, why not, going even further by
increasingly delving into formal methods.</p>
<h3 id="features-of-the-language"><a aria-hidden="true" href="#features-of-the-language"></a>Features of the <em>language</em></h3>
<p>Even though it’s very tempting to create a massive OCaml tutorial, the
goal of this section is to present what makes <strong>OCaml</strong>, <strong>for me</strong>, a
<strong>highly relevant</strong> choice for both learning and production. The
advantages will therefore be presented (and <em>defended</em>), but <strong>this is
not a tutorial</strong>.</p>
<h4 id="a-multi-paradigm-language"><a aria-hidden="true" href="#a-multi-paradigm-language"></a>A <em>multi-paradigm</em> language</h4>
<p>Nowadays, talking about <strong>multi-paradigm</strong> languages might seem
unnecessary, since a large majority of programming languages <em>favored
by industry</em> are already multi-paradigm. However, OCaml is a
<strong>functional programming</strong> language that also supports <strong>imperative
programming</strong>, <strong>modular programming</strong>, <strong>object-oriented
programming</strong>, and, since version <code>5.0.0</code>, <strong>multi-core programming</strong>.</p>
<p>Just as <a href="https://www.haskell.org/">Haskell</a> is widely recognized in
the functional programming world, it’s often assumed that adding
imperative mechanisms to a language is a bad idea — especially if one
is convinced of the benefits of the functional style. From my
perspective, there are several perfectly legitimate reasons to use
imperative programming when the language allows it:</p>
<ul>
<li>
<p><strong>Readability of an implementation.</strong> Sometimes, avoiding mutability
requires adding extra plumbing (for example, a <a href="https://wiki.haskell.org/State_Monad">State
Monad</a>), which can make
reading and understanding a program more cumbersome.</p>
</li>
<li>
<p><strong>Performance.</strong> Adding such plumbing can introduce overhead, making
the execution of implementations more costly.</p>
</li>
<li>
<p><strong>Ease of use.</strong> A few years ago, <a href="https://twitter.com/rtguillon">Arthur
Guillon</a> ceremoniously told me that
&#34;<em>OCaml is a lambda calculus that trivially allows effects</em>,&#34; which
makes it very effective for tasks like debugging, where printing
messages to standard output is simple. While I acknowledge that this
is probably not the <em>best way</em> to implement logging, it undeniably
provides a comfortable user experience and enables rapid
prototyping.</p>
</li>
</ul>
<p>In general, OCaml&#39;s dual nature — both imperative and functional —
allows you to leverage the advantages of both paradigms in different
situations and, of course, to combine them. For example, hidding a
module&#39;s imperative nature behind a functional API.</p>
<h5 id="syntax-à-la-ml"><a aria-hidden="true" href="#syntax-à-la-ml"></a>Syntax <em>à la ML</em></h5>
<p>Although syntax is often considered a minor detail, languages in the
<a href="https://en.wikipedia.org/wiki/ML_%28programming_language%29">ML
family</a>
have a concise, expressive, and readable syntax. Even though <em>this
family of syntax</em> can be confusing when coming from more conventional,
C-inspired syntax, one gets used to it fairly quickly and can soon
realize that it is very consistent and relatively
unambiguous. However, if OCaml’s syntax is problematic for you, don’t
hesitate to look into <a href="https://reasonml.github.io/">ReasonML</a>, an
alternative syntax that uses braces.</p>

<p>OCaml is a language that originates from French research, as shown by
the <a href="https://caml.inria.fr/about/history.en.html">history of Caml</a>,
primarily designed to implement the proof assistant
<a href="https://coq.inria.fr/">Coq/Rocq</a>. This origin — and the initial
motivations, implementing Coq while also serving as a programming
language taught in preparatory classes—creates a certain duality:</p>
<ul>
<li>
<p>The core features were not initially designed with industry in
mind. However, this assertion is no longer true, primarily because
OCaml <strong>has</strong> become a language used in industrial contexts. While
in the language’s genesis, there were more tools for building a
language itself (facilitating the teaching of compiler mechanisms)
than tools for building &#34;enterprise&#34; applications, projects from the
community motivated by industrial use have enriched the language and
its ecosystem, making it a versatile tool suitable for industry. For
example, creating a <em>binding</em> with the
<a href="https://en.wikipedia.org/wiki/Tk_%28software%29">Tk</a> library led to
the integration in the language of <a href="https://ocaml.org/manual/lablexamples.html">named
arguments</a>, <a href="https://ocaml.org/manual/lablexamples.html#s%3Aoptional-arguments">optional
arguments</a>,
and <a href="https://ocaml.org/manual/polyvariant.html">polymorphic
variants</a>.</p>
</li>
<li>
<p>The set of paradigms and language features are <strong>carefully thought
out and well-theorized</strong>. Generally, the integration of a feature
(or collection of features) results from meticulous research, based
on solid theoretical foundations and reviewed by numerous experts in
the field (often
<a href="https://www.inria.fr/fr/avec-xavier-leroy-linformatique-confirme-sa-presence-au-college-de-france">recognized</a>
by the scientific community). This rigor can sometimes slow the
introduction of new features but generally ensures their proper
functioning and theoretical stability.</p>
</li>
</ul>
<p>This theoretical rigor, stemming from OCaml’s undeniable closeness to
the research world, means that its various aspects are well
documented, illustrated by <a href="https://arxiv.org/search/?query=ocaml&amp;searchtype=all&amp;source=header">a large number of
publications</a>,
and exhibit <strong>predictable behavior</strong>. From my point of view, this
makes OCaml a very wise choice for understanding these different
features <em>in depth</em>. For example, I believe OCaml has allowed me to
<strong>much better understand</strong> certain traits or paradigms of programming
languages.</p>
<p>Moreover, a great example of how meticulous and rigorous research can
support the integration of a language feature is OCaml’s
implementation of an <a href="https://ocaml.org/manual/objectexamples.html">object
model</a>. Indeed, the
thesis of <a href="https://www.irif.fr/~vouillon/">Jérôme Vouillon</a>, <em><a href="https://www.irif.fr/~vouillon/publi/these.ps.gz">Design
and Implementation of an Extension of the ML Language with
Objects</a></em>, proposes
an innovative object model that integrates very well with type
inference by <a href="https://caml.inria.fr/pub/docs/oreilly-book/html/book-ora144.html">separating the notions of inheritance and
subtyping</a>
— inheritance being a <strong>syntactic notion</strong> and subtyping a <strong>semantic
notion</strong> — using <a href="https://en.wikipedia.org/wiki/Row_polymorphism">row
polymorphism</a> to
describe <a href="https://en.wikipedia.org/wiki/Structural_type_system">structural subtyping
relationships</a>,
as opposed to <a href="https://en.wikipedia.org/wiki/Nominal_type_system">nominal
subtyping</a>, used by
Java, C#, and most popular OOP languages. OCaml’s object model fully
adheres to the <a href="https://en.wikipedia.org/wiki/SOLID">SOLID principles</a>
without any <a href="https://spring.io/projects/spring-boot">additional
ceremony</a>.</p>
<h4 id="algebraic-types"><a aria-hidden="true" href="#algebraic-types"></a>Algebraic types</h4>
<p>I’ve been quite expansive about the reasons why I value a language
with static type checking. However, in my experience, for a statically
typed language to be truly usable, the presence of <a href="https://cs3110.github.io/textbook/chapters/data/algebraic_data_types.html">algebraic
types</a>
is necessary:</p>
<ul>
<li>
<p><strong>Product types</strong>: These allow grouping values of heterogeneous
types (thus creating a <strong>conjunction</strong> of heterogeneous types). They
are generally present in all <em>mainstream</em> languages (for example,
<em>objects</em>, which introduce additional concepts, or tuples and
records).</p>
</li>
<li>
<p><strong>Sum types</strong>: These allow constructing a <strong>disjunction</strong> of
heterogeneous value types, with different <em>cases</em> indexed by
constructors. While some <em>special cases</em> of sums exist in mainstream
languages—like <em>booleans</em> (which are a disjunction of two cases:
<code>true</code> and <code>false</code>, i.e., two parameterless constructors) — support
for full sum types is often cumbersome in popular languages. For
example, Kotlin and Java (and <em>de facto</em> C#) use a construct
associated with inheritance relations called
<a href="https://docs.oracle.com/en/java/javase/17/language/sealed-classes-and-interfaces.html">sealing</a>. The
integration of <a href="https://docs.scala-lang.org/scala3/reference/enums/adts.html">dedicated sum type
syntax</a>
also took some time in Scala, which, prior to recent versions,
relied on sealed families, making the expression of sums verbose
and, in my view, harder to reason about.</p>
</li>
<li>
<p><strong>Exponential types</strong>: These allow describing functions that express
types for higher-order functions (functions that can be passed as
arguments or returned as results).</p>
</li>
</ul>
<p>Coupled with <a href="https://ocaml.org/manual/5.2/patterns.html">pattern
matching</a> and <a href="https://en.wikipedia.org/wiki/Parametric_polymorphism">parametric
polymorphism</a>
(or <em>generics</em>), an algebraic type system is an incredibly expressive
tool for describing data structures, the state machine of a program,
or modeling a <a href="https://pragprog.com/titles/swdddf/domain-modeling-made-functional/">business
domain</a>
with an appropriate cardinality. Even in the 21st century, where
products and exponentials are common, when I use <em>very popular</em>
languages, I am often frustrated by the lack of sum types, which
forces me to use verbose encodings (increasing the domain’s
cardinality). This is particularly noticeable when working with
<a href="https://go.dev/">Go</a> and
<a href="https://www.typescriptlang.org/">TypeScript</a>.</p>
<p>The appeal of this triad is, in fact, probably one of the reasons
(combined with a very ergonomic ecosystem and toolchain) behind the
success of <a href="https://www.rust-lang.org/">Rust</a>. In short, if you intend
to build a new programming language with static type checking,
<em>please</em>, do not hesitate to include algebraic types!</p>
<p>Finally, there are aspects of OCaml&#39;s type system that I haven’t
covered, but which probably deserve dedicated articles. For example,
<a href="https://ocaml.org/manual/gadts-tutorial.html">generalized algebraic data types
(GADTs)</a>, which allow
expressing even more invariants.</p>
<h4 id="modular-programming-and-module-language"><a aria-hidden="true" href="#modular-programming-and-module-language"></a>Modular programming and module language</h4>
<p>OCaml, through its ancestor <a href="https://caml.inria.fr/pub/docs/manual-caml-light/">Caml
Light</a>, was among
the first languages to offer a module system, similar to <a href="https://smlfamily.github.io/">Standard
ML</a>, providing <strong>encapsulation and
abstraction</strong> while supporting <strong>separate compilation</strong>, in the style
of <a href="https://en.wikipedia.org/wiki/Modula-2">Modula-2</a>. OCaml’s module
system is a <strong>fundamental aspect</strong> of the language, although its
complexity can be intimidating. Indeed, in OCaml, it is possible to
clearly distinguish the interface (the <em>signature</em>) from the
implementation (the <em>structure</em>), thus facilitating encapsulation and
documentation, while also allowing <strong>function application within the
module language</strong>.</p>
<p>I find it particularly difficult to address the topic of modules
briefly (it’s a subject I’ve wanted to explore on my blog for
<em>years</em>). However, here is a list of advantages I see in OCaml’s
<em>highly modular</em> approach:</p>
<ul>
<li>
<p><strong>Separate compilation</strong>: A key feature that allows efficient
compilation of large programs by identifying junction points to
optimize parallel and incremental compilation. This approach is
leveraged by <a href="https://dune.build/">dune</a>, the recommended build
system for OCaml.</p>
</li>
<li>
<p><strong>Systematic separation of implementation and interface</strong>: Offers
several significant advantages, including encapsulation and placing
documentation in the interface. In my programming workflow, I find
this very convenient because I can implement my <em>structure</em> (the
module’s implementation) while <em>being guided by type inference</em> and
specify its API in the <em>signature</em> (the module’s interface),
deciding on the display order and providing clear documentation that
doesn’t pollute the implementation space. Additionally,
encapsulation allows me to freely define intermediate types inside
the structure, for example, to represent a program’s state machine,
<a href="https://en.wikipedia.org/wiki/Leaky_abstraction">without letting it
escape</a>.</p>
</li>
<li>
<p><strong>A powerful tool for describing data structures</strong>: By abstracting
types (hiding their implementation) and combining this with
encapsulation, it is possible to describe data structures that
<strong>maintain invariants</strong>. This is why it is common to have a
structure/signature pair for each data structure, hiding
implementation details through abstraction and encapsulation.</p>
</li>
<li>
<p><strong>Reusability and sharing</strong>: Just as it is possible to describe
types in the value language (as seen with algebraic types), it is
also possible to describe types in the module language, called
<strong>translucent signatures</strong>, which allow defining the type of a
signature without associating it with a structure. These signatures
are structurally typed, and coupled with
<a href="https://ocaml.org/docs/functors">functors</a> (functions in the module
language), it is possible to <em>share behavior</em> between modules.</p>
</li>
<li>
<p><strong>Advanced forms of polymorphism</strong>: Including <a href="https://okmij.org/ftp/ML/higher-kind-poly.html">Higher Kinded
Polymorphism</a>,
available in the module language. In broad terms, you can describe
&#34;<em>generics parameterized by generics</em>&#34;. This limitation in languages
like F# or Java often motivates the use of <a href="https://github.com/yallop/higher?tab=readme-ov-file#implementations-in-other-languages">heavy
encodings</a>
to work around the lack.</p>
</li>
</ul>
<p>The theory behind module languages in ML-family languages is a vast
subject, <a href="https://dl.acm.org/doi/10.1145/3649818">still evolving</a>, and
very difficult to summarize in a single paragraph. However, the
introduction of <a href="https://people.mpi-sws.org/~dreyer/thesis/main.pdf">Derek Dreyer’s
thesis</a>,
<em>Understanding and Evolving the ML Module System</em>, provides an
excellent explanation of the purpose and use of modules, illustrated
with many examples. I hope to take the time in the coming weeks or
months to write more extensively about the module language than I have
<a href="http://tinylogger.com/en/articles/modules-import.html">already attempted</a>, because it could
be very educational and, in my view, the topic is extremely
interesting!</p>
<h4 id="dependency-injection-and-inversion"><a aria-hidden="true" href="#dependency-injection-and-inversion"></a>Dependency injection and inversion</h4>
<p>Briefly touching on object-oriented programming in OCaml, I mentioned
that OCaml allows, through its language features, a straightforward
way to meet the prerequisites for writing <strong>SOLID</strong> code. The final
point I’d like to emphasize is the ease of dependency inversion,
achievable through <strong>language-provided features</strong>. In broad terms, the
principle of dependency inversion involves describing dependency
lattices using <strong>abstractions</strong> rather than <strong>implementations</strong>. This
way, dependencies can be <em>injected afterward</em> — making context
changes, for example in unit testing, trivially implementable.</p>
<p>OCaml provides (<em>at least</em>) two tools that facilitate this inversion,
each useful in different contexts. We will draw inspiration from the
very popular teletype example to show how to invert dependencies:</p>
<pre><code><span>let</span><span> </span><span>program</span><span> </span><span>()</span><span> </span><span>=</span><span>
</span><span>  </span><span>let</span><span> </span><span>()</span><span> </span><span>=</span><span> </span><span>print_endline</span><span> </span><span>&#34;</span><span>Hello World</span><span>&#34;</span><span> </span><span>in</span><span>
</span><span>  </span><span>let</span><span> </span><span>()</span><span> </span><span>=</span><span> </span><span>print_endline</span><span> </span><span>&#34;</span><span>What is your name?</span><span>&#34;</span><span> </span><span>in</span><span>
</span><span>  </span><span>let</span><span> </span><span>name</span><span> </span><span>=</span><span> </span><span>read_line</span><span> </span><span>()</span><span> </span><span>in</span><span>
</span><span>  </span><span>print_endline</span><span> </span><span>(</span><span>&#34;</span><span>Hello </span><span>&#34;</span><span> </span><span>^</span><span> </span><span>name</span><span>)</span><span>
</span></code></pre>
<p>Even if it might not seem obvious, this program depends on <strong>concrete
implementations</strong> — namely, interactions with standard input and
output.</p>
<h5 id="through-modules"><a aria-hidden="true" href="#through-modules"></a>Through modules</h5>
<p>The most straightforward approach is to use modules, either as
<a href="https://ocaml.org/manual/firstclassmodules.html">first-class values</a>
or by construction, using
<a href="https://ocaml.org/docs/functors">functors</a>. The duality between
signatures and structures makes dependency inversion obvious. For
example, to revisit our example, here’s how, using <a href="https://ocaml.org/manual/firstclassmodules.html"><em>first-class
modules</em></a>, it becomes
<strong>very easy</strong> to depend on an abstract set of interactions. We start
by describing the abstract representation of possible interactions:</p>
<pre><code><span>module</span><span> </span><span>type</span><span> </span><span>IO</span><span> </span><span>=</span><span> </span><span>sig</span><span>
</span><span>  </span><span>val</span><span> </span><span>print_endline</span><span> : string -&gt; unit
</span><span>  </span><span>val</span><span> </span><span>read_line</span><span> : unit -&gt; string
</span><span>end</span><span>
</span></code></pre>
<p>We can now expect our <code>program</code> function to take a module of type <code>IO</code>
as an argument (we’ll call this <em>a handler</em>) and use the functions
exported by the module, which in our example is named <code>Handler</code>:</p>
<pre><code><span>let</span><span> </span><span>program</span><span> </span><span>(</span><span>module</span><span> </span><span>Handler</span><span>:</span><span> </span><span>IO</span><span>)</span><span> </span><span>=</span><span>
</span><span>  </span><span>let</span><span> </span><span>()</span><span> </span><span>=</span><span> </span><span>Handler</span><span>.</span><span>print_endline</span><span> </span><span>&#34;</span><span>Hello World</span><span>&#34;</span><span> </span><span>in</span><span>
</span><span>  </span><span>let</span><span> </span><span>()</span><span> </span><span>=</span><span> </span><span>Handler</span><span>.</span><span>print_endline</span><span> </span><span>&#34;</span><span>What is your name?</span><span>&#34;</span><span> </span><span>in</span><span>
</span><span>  </span><span>let</span><span> </span><span>name</span><span> </span><span>=</span><span> </span><span>Handler</span><span>.</span><span>read_line</span><span> </span><span>()</span><span> </span><span>in</span><span>
</span><span>  </span><span>Handler</span><span>.</span><span>print_endline</span><span> </span><span>(</span><span>&#34;</span><span>Hello </span><span>&#34;</span><span> </span><span>^</span><span> </span><span>name</span><span>)</span><span>
</span></code></pre>
<p>For example, in the context of unit testing, it’s possible to provide
an implementation that logs all the operations called (and <em>mocks</em> the
<code>read_line</code> call to fix the returned result). This makes expressing
unit tests that <em>verify business logic</em> very easy to implement.</p>
<p>Passing a concrete implementation as an argument to our function
amounts to <strong>interpreting the program</strong>.</p>
<h5 id="through-user-defined-effects"><a aria-hidden="true" href="#through-user-defined-effects"></a>Through <em>user-defined effects</em></h5>
<p>OCaml version 5 arrived with a host of new features. However, the
biggest advancement is the complete redesign of the OCaml <strong>runtime</strong>
to support multi-core execution. There are several ways to describe
concurrent algorithms — for example, using
<a href="https://en.wikipedia.org/wiki/Actor_model">actors</a> or
<a href="https://go101.org/article/channel.html">channels</a>. OCaml has chosen
to rely on
<a href="https://github.com/ocaml-multicore/ocaml-effects-tutorial">effects</a>,
which simplify the management of the program&#39;s <em>control flow</em>.  In
fact, OCaml allows users to define their own effects, logically called
<a href="https://ocaml.org/manual/effects.html">user-defined effects</a>. While
they are a powerful tool for describing concurrent programs, they also
make it easier to inject dependencies when you want to maintain
control, <em>at the handler level</em>, over the execution flow of a program.</p>
<blockquote>
<p>Note: In my example, I am using an experimental syntax, <a href="https://github.com/ocaml/ocaml/pull/12309">just
merged</a> into the OCaml
main branch, which will likely be available in version <code>5.3.0</code> of
the language.</p>
</blockquote>
<p>As with our previous improvement, we first need to describe the set of
operations that can be performed. We use the <code>effect</code> construct:</p>
<pre><code><span>effect</span><span> </span><span>Print_endline</span><span> </span><span>:</span><span> </span><span>string</span><span> </span><span>-&gt;</span><span> </span><span>unit</span><span>
</span><span>effect</span><span> </span><span>Read_line</span><span> </span><span>:</span><span> </span><span>unit</span><span> </span><span>-&gt;</span><span> </span><span>string</span><span>
</span></code></pre>
<p>Next, we can write our program in a direct style, by <em>producing
effects</em>:</p>
<pre><code><span>let</span><span> </span><span>program</span><span> </span><span>()</span><span> </span><span>=</span><span>
</span><span>  </span><span>let</span><span> </span><span>()</span><span> </span><span>=</span><span> </span><span>Effect</span><span>.</span><span>perform</span><span> </span><span>(</span><span>Print_endline</span><span> </span><span>&#34;</span><span>Hello World</span><span>&#34;</span><span>)</span><span> </span><span>in</span><span>
</span><span>  </span><span>let</span><span> </span><span>()</span><span> </span><span>=</span><span> </span><span>Effect</span><span>.</span><span>perform</span><span> </span><span>(</span><span>Print_endline</span><span> </span><span>&#34;</span><span>What is your name?</span><span>&#34;</span><span>)</span><span> </span><span>in</span><span>
</span><span>  </span><span>let</span><span> </span><span>name</span><span> </span><span>=</span><span> </span><span>Effect</span><span>.</span><span>perform</span><span> </span><span>(</span><span>Read_line</span><span> </span><span>()</span><span>)</span><span> </span><span>in</span><span>
</span><span>  </span><span>Effect</span><span>.</span><span>perform</span><span> </span><span>(</span><span>Print_endline</span><span> </span><span>(</span><span>&#34;</span><span>Hello </span><span>&#34;</span><span> </span><span>^</span><span> </span><span>name</span><span>)</span><span>)</span><span>
</span></code></pre>
<p>It is then possible to <strong>interpret our program afterward</strong>, using a
construction similar to pattern matching, to give a specific meaning
to each effect.</p>
<p>Currently, it should be noted that <strong>effect propagation is not tracked
by the type system</strong>. However, this is an experimental feature, which
is used extensively in the <a href="https://github.com/xhtmlboi/yocaml">new version of
YOCaml</a>. I am aware that resources
are being devoted to developing an <strong>efficient type system to track
effect propagation</strong>!</p>
<p>In general, when I don’t care about controlling the program’s flow, or
I don’t need to add effects <em>after the fact</em>, I use modules. But in
the case of YOCaml, the new effect system was leveraged to <a href="https://github.com/xhtmlboi/yocaml/commit/d78bb21077272ae86f7b6b3017509596de0a5a27">introduce
effects dedicated to unit
testing</a>,
allowing, for example, the <em>mocking of time passing</em>.</p>
<p>Once again, it’s really difficult not to go on at length about
<em>user-defined effects</em>, which are a brand-new and very exciting
feature of the language. I’ll conclude by simply sharing two articles
written by <a href="https://github.com/art-w">Arthur Wendling</a> that explain
the use of effects in a very pedagogical way, along with a
comprehensive bibliography on the literature related to effect
abstraction in functional programming:</p>
<ul>
<li><a href="https://hackmd.io/@yF_ntUhmRvKUt15g7m1uGw/Bk-5NXh15">Scopes and effect
handlers</a></li>
<li><a href="https://hackmd.io/@yF_ntUhmRvKUt15g7m1uGw/BJBZ7TMeq">Roguelike with effect
handlers</a></li>
<li><a href="https://github.com/yallop/effects-bibliography">Effect bibliography</a></li>
</ul>
<p>It’s worth noting that this inversion/injection could also be done
using <em>records</em> or <em>objects</em>. However, my experience with OCaml
suggests that approaches using modules or effects (when you want to
manipulate the program’s control flow) are often more straightforward
and easier to reason about.</p>
<h3 id="regarding-the-future"><a aria-hidden="true" href="#regarding-the-future"></a>Regarding the future</h3>
<p>OCaml is a <em>constantly evolving</em> language that changes with each
version. In the section on dependency inversion, I briefly mentioned
the recent inclusion of effects in the language to describe a
<em>multi-core runtime</em>, reflecting the ongoing evolution of OCaml over
the years. One can also note the integration of <a href="https://ocaml.org/manual/bindingops.html">binding
operators</a>, which make the
use of the triad
<a href="https://en.wikipedia.org/wiki/Functor_%28functional_programming%29">Functors</a>,
<a href="https://en.wikipedia.org/wiki/Applicative_functor">Applicative
Functors</a>, and
<a href="https://en.wikipedia.org/wiki/Monad_%28functional_programming%29">Monads</a>
more convenient — similar to <a href="https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/computation-expressions">computation
expressions</a>
in F#.</p>
<p>Currently, many very exciting projects are underway to further improve
the language:</p>
<ul>
<li>
<p>A deep work on the expression of effects, with a newly added syntax,
and a collection of research on the separation between <a href="https://github.com/ocaml/ocaml/pull/12736">operations
and effects</a> and, of
course, on the <a href="https://arxiv.org/abs/2407.11816">propagation of effects in the type
system</a>.</p>
</li>
<li>
<p><a href="https://opensource.janestreet.com/">Jane Street</a> proposed <a href="https://antonlorenzen.de/mode-inference.pdf">a
non-intrusive resource management
model</a>, inspired by
Rust, introducing <em>modalities</em> and <em>a bit of linearity</em>.</p>
</li>
<li>
<p>A genuine <a href="https://clement.blaudeau.net/assets/pdf/blaudeau_ocaml_modules.pdf">foundational
work</a>
has been initiated on the module language, making the implementation
of <a href="https://www.cl.cam.ac.uk/~jdy22/papers/modular-implicits.pdf">Modular
Implicits</a>
more smoothly achievable.</p>
</li>
</ul>
<p>We can also note the development of a <a href="https://xnning.github.io/papers/icfp23.pdf">hygienic macro
system</a>, the gradual
integration of a <a href="https://okmij.org/ftp/ML/MetaOCaml.html">staged metaprogramming
system</a>, and the
implementation of an <a href="https://ocamlpro.com/blog/tag/flambda2/"><em>optimization
back-end</em></a>, reflecting
OCaml’s strong activity in the innovation sector and making its
development in the coming years very motivating and exciting!</p>
<h3 id="weaknesses"><a aria-hidden="true" href="#weaknesses"></a>Weaknesses</h3>
<p>Even though I’m convinced that OCaml is an <strong>excellent language</strong>,
claiming it is perfect would probably be <em>disingenuous</em> — after all,
<em>nothing is perfect</em>. Here are, in my opinion, a few points that cast
a shadow on OCaml as a language:</p>
<ul>
<li>
<p><strong>Lack of <a href="https://en.wikipedia.org/wiki/Ad_hoc_polymorphism">ad-hoc
polymorphism</a>.</strong>
Although it is possible to work around it, for example using local
module openings, the absence of <em>ad-hoc polymorphism</em> (via <a href="https://en.wikibooks.org/wiki/Haskell/Classes_and_types">type
classes</a> —
as in Haskell, or
<a href="https://doc.rust-lang.org/book/ch10-02-traits.html">traits</a>/<a href="https://docs.scala-lang.org/tour/implicit-parameters.html">implicit
objects</a>
— as in Rust and Scala, or <a href="https://coq.inria.fr/doc/v8.18/refman/language/extensions/canonical.html">canonical
structures</a>
— as in Coq) can sometimes make certain situations tricky. Even
though I tend to prefer explicit relationships, over the years I’ve
found several cases where this absence can be problematic:</p>
<ul>
<li>
<p>The inability to describe type parameter constraints on
polymorphic functions, leading to polymorphic equality and
comparison functions in the standard library, which has caused
<a href="https://blog.janestreet.com/the-perils-of-polymorphic-compare/">much
debate</a>
and, for example, required specialized versions of arithmetic
operators for different numeric representations (<code>int</code>, <code>int64</code>,
<code>float</code>).</p>
</li>
<li>
<p>Risk of combinatorial explosion when describing many relationships
between modules. This is why the
<a href="https://github.com/xvw/preface">Preface</a> library proposes a
somewhat <a href="https://github.com/xvw/preface/blob/master/guides/option_instantiation.md">complex modular
decomposition</a>.</p>
</li>
</ul>
<p>However, even though the arrival of <a href="https://www.cl.cam.ac.uk/~jdy22/papers/modular-implicits.pdf">implicit
modules</a>
is probably not in the short-term roadmap, recent work on the module
language, as discussed in the “future of OCaml” section, is
promising.</p>
</li>
<li>
<p><strong>Cumbersome interaction between the module language and the value
language.</strong>  The module language is <strong>a different language</strong> with
its own type system. Whether this counts as a weakness is debatable,
but this distinction can be intimidating. It comes from the fact
that OCaml’s module system was a pioneer in module theory and
predates more recent innovations (e.g.,
<a href="https://people.mpi-sws.org/~rossberg/1ml/1ml-extended.pdf">1ML</a>).
In practice, besides being <em>complex to grasp</em>, certain parts of the
language are hard to specify correctly, for example <a href="https://www.ocaml.org/manual/5.2/recursivemodules.html#s%3Arecursive-modules">recursive
modules</a>.</p>
</li>
<li>
<p><strong>A language comfortable for functional programming, but impure.</strong>
While I consider impurity <strong>a feature</strong>, importing idioms from
purely functional languages (e.g., Haskell) can cause difficulties
related to type inference, such as the <a href="https://en.wikipedia.org/wiki/Value_restriction"><em>value
restriction</em></a>.
Even though OCaml has
<a href="https://caml.inria.fr/pub/papers/garrigue-value_restriction-fiwflp04.pdf">relaxed</a>
this restriction, its implications on polymorphic function inference
can still be intimidating — for very good reasons.</p>
</li>
</ul>
<ul>
<li><strong>Syntax.</strong> Personally, I really like OCaml’s syntax and believe
syntax should rarely be a major issue, but some choices can be
confusing. For instance, type parameters prefix the type name: a
list of <code>a</code> is written <code>&#39;a list</code>. Many of these choices aim to
<em>reduce syntactic ambiguity</em>, and you get used to them
quickly. However, coming from another language, some of these
conventions may seem surprising.</li>
</ul>
<p>I think these weaknesses are generally debatable (because they are
often justified), but I completely understand that they can be
unsettling. However, I believe they are not enough to make OCaml
unusable and <strong>should not be a major barrier to getting started with
OCaml</strong>! The benefit of having an <em>improvable</em> language is that it
constantly offers a range of potential improvements, motivating work
that can also benefit other languages. And, to be entirely honest,
being aware of these <em>rough edges</em>, I’ve more often found myself
frustrated by the absence of language features <strong>that exist in OCaml</strong>
in other languages, rather than complaining about these rough edges
while writing OCaml itself. For these rough edges, there are usually
workarounds (sometimes only partially satisfying, I admit) that allow
one to work calmly and effectively.</p>
<h3 id="to-conclude-on-language"><a aria-hidden="true" href="#to-conclude-on-language"></a>To conclude on language</h3>
<p>I have, in very broad strokes, outlined <strong>reasons</strong> why, in my
opinion, learning OCaml is a <strong>very relevant</strong> choice. This language
allows one to <em>fundamentally understand</em> certain <em>very</em> popular
programming idioms (often poorly defined). Moreover, some aspects of
the language perfectly serve industrial purposes, making good
practices sometimes trivial to express! Much of this appeal can be
experimented with in other languages, but OCaml&#39;s <em>strongly
multi-paradigm</em> nature allows one to centralize this learning in a
single language. To my knowledge, in the jungle of <em>partially popular</em>
languages, only Scala seems to cover as many topics, although, from my
point of view, its object model is, essentially for interoperability
with other JVM languages, far less interesting.</p>
<p>Since the goal of this article is not to be a tutorial, I deliberately
skimmed over certain concepts,
<a href="https://ocaml.org/docs/modules">modules</a> and
<a href="https://ocaml.org/manual/ffects.html">effects</a>. I hardly mentioned
<a href="https://ocaml.org/docs/objects">objects</a>, <a href="https://ocaml.org/manual/polyvariant.html">polymorphic
variants</a>, or <a href="https://ocaml.org/manual/gadts-tutorial.html">generalized
algebraic types</a>. If
these topics interest you, I encourage you to read in detail the
excellent <a href="https://caml.inria.fr/pub/docs/u3-ocaml/index.html">Using, Understanding, and Unraveling The OCaml
Language</a> by
<a href="http://cristal.inria.fr/~remy/">Didier Rémy</a>, along with the books I
presented in the introduction, which is a goldmine for anyone wishing
to deepen their knowledge of OCaml.</p>
<p>In conclusion, OCaml offers a diverse and rich set of language-level
tools for learning programming, building industrial-grade programs
that follow standards, as well as implementing <a href="https://github.com/art-w/deque">complex data
structures</a> and <a href="https://github.com/xvw/preface">category-theory-based
abstractions</a> such as a functional
core, imperative traits, a rich and expressive inferred type system
(allowing the expression of algebraic types and facilitating clear
domain modeling), a module system for abstraction, reusability, and
defining compilation units, an object model, the ability to express
effects that can be propagated and interpreted <em>a posteriori</em>, and
other advanced features. Even just to <em>grasp advanced programming
concepts</em>, OCaml is an <strong>excellent candidate</strong> — which is why OCaml
has been an obvious inspiration for many more recent languages, <a href="https://doc.rust-lang.org/reference/influences.html">with
Rust being a notable
example</a>.</p>
<h2 id="ocaml-as-an-ecosystem"><a aria-hidden="true" href="#ocaml-as-an-ecosystem"></a>OCaml as an ecosystem</h2>
<p>Having an expressive language is very beneficial for <em>building things</em>
(the phrasing is deliberately naive). However, in different contexts,
both professional and personal, this is not enough:</p>
<ul>
<li>
<p>In a professional context, it is obvious that if I want my team and
I to be productive, it is probably not very relevant to have to
build a whole tool stack before being able to start addressing the
problem we are tasked with.</p>
</li>
<li>
<p>In a personal context, even though one could <em>argue</em> that building
your technology stack is <strong>very educational</strong>, it changes the set of
skills you actually want to <em>develop</em>. If, to build a small web
application to get started with OCaml as a web language, I have to
build my entire HTTP stack, it is very likely that OCaml is not the
right choice. Rest assured, however, that OCaml has <a href="https://ocaml.org/docs/is-ocaml-web-yet">a rich tooling
ecosystem</a> for building web
applications!</p>
</li>
</ul>
<p>That’s why the features offered by the language are not a sufficient
metric to describe its viability for building and maintaining
projects. The ecosystem is also a very important factor. It is for
these reasons that <a href="https://dotnet.microsoft.com/en-us/">.NET</a> and the
<a href="https://en.wikipedia.org/wiki/Java_virtual_machine">JVM</a>, through
relatively less expressive (but improving) languages like Java and C#,
are also so popular. To assess the relevance of an ecosystem, I think
it is important to consider several criteria:</p>
<ul>
<li>
<p>The relevance of the <em>runtime</em> (or compilation targets) for the
project. It’s likely that I wouldn’t recommend OCaml for embedding
in a tiny, exotic <em>hardware</em> — though, knowing nothing about
low-level programming (because it’s not my field at all), I could be
wrong.</p>
</li>
<li>
<p>Its <strong>platform</strong>. Is its entire <em>toolchain</em> complete and ergonomic?
From my point of view, this includes a package manager, a <em>build
system</em>, good <em>editor support</em> (agnostic as possible), a solid
documentation generator, and a collection of additional tools, such
as a <em>formatter</em> (and many others).</p>
</li>
<li>
<p>The relevance of the <strong>available libraries</strong> (and their level of
maintenance and discoverability, which generally implies having a
package manager) with particular consideration for their
ergonomics. For example, if I don’t have any cryptography
primitives, I probably wouldn’t choose this technology to build a
<em>blockchain</em>. There is a whole class of problems that are <strong>very
difficult</strong> to <em>solve in isolation</em> or in a professional context.</p>
</li>
</ul>
<p>In this section, we will try to overview these different points to see
if the OCaml ecosystem lives up to the language. I want to clarify
that <strong>I am somewhat biased</strong> because I have been convinced of OCaml’s
relevance since 2012, back when the ecosystem was <strong>drastically
poorer</strong>. At that time, I tried to build projects by patching the
gaps, which probably created a <a href="https://en.wikipedia.org/wiki/Survivorship_bias">survivorship
bias</a>. Nowadays,
thanks in part to industrial users, the OCaml ecosystem is much richer
and more extensive, making it much easier to defend, although when
some gaps still exist, the bad faith <em>of the old user</em> can resurface.</p>
<h3 id="compilation-runtimes-and-additional-targets"><a aria-hidden="true" href="#compilation-runtimes-and-additional-targets"></a>Compilation, <em>runtimes</em>, and additional targets</h3>
<p>Since its inception, OCaml has had two compilation targets:</p>
<ul>
<li>
<p>Native compilation, which produces highly efficient executables
compiled for a specific architecture (and supports a <a href="https://github.com/ocaml/ocaml?tab=readme-ov-file#overview">large number
of
architectures</a>). Moreover,
whereas Windows was historically largely neglected, <a href="https://tarides.com/blog/2024-05-22-launching-the-first-class-windows-project/">a special
effort</a>
has been made to support it (also note the <a href="https://github.com/diskuv/dkml-installer-ocaml">DkMl
project</a>, an
independent initiative).</p>
</li>
<li>
<p>Compilation to <em>bytecode</em> (for a virtual machine), producing
portable executables.</p>
</li>
</ul>
<p>The presence of a virtual machine enabled the development of the
venerable
<a href="http://ocsigen.org/js_of_ocaml/latest/manual/overview">Js_of_OCaml</a>,
which allows <a href="https://www.irif.fr/~vouillon/publi/js_of_ocaml.pdf">transforming OCaml bytecode into
JavaScript</a>,
making OCaml perfectly viable for developing applications in the
browser as well as in the <a href="https://nodejs.org/en">Node</a> runtime, and
it is extensively used for this website. Using a similar approach,
<a href="https://webassembly.org/">WebAssembly</a> support was made possible very
recently through the
<a href="https://github.com/ocaml-wasm/wasm_of_ocaml">Wasm_of_OCaml</a>
project. Supporting compilation to <em>WASM</em> for a language with a
<a href="https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29">garbage
collector</a>
was a <em>serious challenge</em>, but with the recent specification of
interaction between <em>WASM</em> and <a href="https://github.com/WebAssembly/gc"><em>garbage
collectors</em></a>, <strong>OCaml now has
perfectly decent WebAssembly compilation</strong> (and many ambitious web
projects, like <a href="https://ocsigen.org">Ocsigen</a>, are beginning to
support <em>WASM</em> natively).</p>
<p>Moreover, the <a href="https://melange.re">Melange</a> project (historically
<a href="https://discuss.ocaml.org/t/a-short-history-of-rescript-bucklescript/7222">BuckleScript</a>)
offers a way to <em>transpile</em> — mapping the OCaml <em>AST</em> to the
JavaScript <em>AST</em> — as an alternative for producing JavaScript. If I
were to compare
<a href="http://ocsigen.org/js_of_ocaml/latest/manual/overview">Js_of_OCaml</a>
and <a href="https://melange.re">Melange</a>, beyond the different underlying
methods used to produce JavaScript (compiling to <em>bytecode</em> and then
transforming that <em>bytecode</em> into JavaScript versus syntactic
transformation from OCaml to JavaScript), I would say that
<strong>Js_of_OCaml</strong> integrates better with the OCaml ecosystem and is
therefore likely <strong>intended for OCaml developers</strong> who want to make
their projects accessible from a browser — indeed, interaction with
the existing JavaScript ecosystem can be more cumbersome. <strong>Melange</strong>
fits better with the JavaScript ecosystem (<code>npm</code> and co) and is
therefore likely <strong>intended for JavaScript developers</strong> seeking to
bring more safety to their JS projects (or an existing codebase).</p>
<p>Nowadays, it is common to find <em>multi-backend</em> languages like
<a href="https://www.idris-lang.org/">Idris</a> or
<a href="https://nim-lang.org/">Nim</a>. However, <em>at the time</em>, I was very
impressed that OCaml could, <em>from the moment I started using it</em>, also
compile to JavaScript. Back then, the only language I knew that
offered multiple compilation targets was <a href="https://haxe.org/">Haxe</a>,
which were so different (incidentally, Haxe is <a href="https://github.com/HaxeFoundation/haxe">written in
OCaml</a>).</p>
<p>Indeed, in 2024, producing JavaScript has become standard, but the
<a href="https://www.irif.fr/~balat/publications/2006mlworkshop-balat-ocsigen.pdf">first traces of Js_of_OCaml date back to
2006</a>,
making OCaml a pioneer in the field!</p>
<h4 id="a-quick-detour-via-mirageos"><a aria-hidden="true" href="#a-quick-detour-via-mirageos"></a>A quick detour via MirageOS</h4>
<p>In the <em>lattice formed by the different OCaml execution and
compilation contexts</em>, having libraries that work well in <em>the
majority of contexts</em> is a challenging task. Fortunately, the
<a href="https://mirage.io/">MirageOS</a> project — a set of libraries designed
to build an <strong>operating system dedicated to running only a single
application</strong> via virtualization (a
<a href="https://en.wikipedia.org/wiki/Unikernel"><em>unikernel</em></a>) — introduced a
true discipline for producing multi-context libraries.</p>
<p>In the <em>near future</em>, I would like to spend more time writing about
Mirage, a fascinating project that we are trying to integrate into our
projects, for example in <a href="https://github.com/xhtmlboi/yocaml">YOCaml</a>,
our static site generator. Moreover, in addition to providing a sound
approach to distributing <em>intelligently compartmentalized</em> libraries,
Mirage offers a solid foundation of libraries for building OCaml
projects, which I will discuss more <em>extensively</em> in the section
dedicated to libraries.</p>
<h3 id="the-ocaml-platform"><a aria-hidden="true" href="#the-ocaml-platform"></a>The OCaml platform</h3>
<p>The <a href="https://ocaml.org/platform">OCaml platform</a> is a set of tools,
maintained within an explicit lifecycle (<code>active</code>, <code>incubating</code>,
<code>maintained</code>, and <code>deprecated</code>), designed to support the compiler with
a coherent toolchain for OCaml code production. It includes many tools
serving different purposes; however, in this section, I will focus
only on certain aspects of the platform, leaving you free to consult
its <a href="https://ocaml.org/platform">page</a> and
<a href="https://ocaml.org/tools/platform-roadmap">roadmap</a> for more detailed
information. In this section, we will look at, <em>in broad strokes</em>, 4
main specific points:</p>
<ul>
<li>The package manager</li>
<li>The build system (<em>build-system</em>)</li>
<li>Editor support (including code formatting)</li>
<li>The documentation generator</li>
</ul>
<p>When using OCaml for some time, this is probably the most exciting
part of the article, because, in my opinion, it is the one that has
benefited the most from progress. And the
<a href="https://ocaml.org/tools/platform-roadmap">roadmap</a> is, in my view,
promising!</p>
<h4 id="opam-the-package-manager"><a aria-hidden="true" href="#opam-the-package-manager"></a>OPAM, the package manager</h4>
<p>Even though <em>language-specific package managers</em> have become very
popular (if not essential) in reducing adoption friction for a
language, at the time OCaml was designed, they were rare. Indeed,
apart from <a href="https://en.wikipedia.org/wiki/CTAN">CTAN</a>, for
distributing <a href="https://en.wikipedia.org/wiki/TeX">TeX</a> packages,
<a href="https://en.wikipedia.org/wiki/CPAN">CPAN</a>, inspired by CTAN, for
distributing <a href="https://www.perl.org/">Perl</a> packages, and
<a href="https://en.wikipedia.org/wiki/PEAR">PEAR</a> for
<a href="https://www.php.net/">PHP</a>, it would take until
<a href="https://en.wikipedia.org/wiki/RubyGems">Gems</a> for development
technologies to consider adopting a package manager as axiomatic for a
programming language.</p>
<p><a href="https://opam.ocaml.org">OPAM</a>, for <strong>O</strong>Caml <strong>Pa</strong>ckage <strong>M</strong>anager,
is a
<a href="https://raw.githubusercontent.com/ocaml/opam/30598a59c98554057ce2beda80f0d31474b94150/specs/roadmap.pdf">proposal</a>
from 2012 (the <a href="https://opam.ocaml.org/about.html">official site <em>About</em>
page</a> presents a small
timeline). In addition to installing packages, OPAM allows you to
install different versions of OCaml and create <em>potentially sandboxed
environments</em>, called
<a href="https://ocaml.org/docs/opam-switch-introduction">switches</a>. You can
use the public resource repository, <a href="https://github.com/ocaml/opam-repository">hosted on
GitHub</a>, but it is also
perfectly possible to create your own package index.</p>
<blockquote>
<p>Having already published several packages on OPAM, I must admit that
the <a href="https://check.ci.ocaml.org/">CI</a> for package addition
validation is incredibly efficient and user-friendly (each error
provides a Dockerfile to reproduce the issue locally), and that the
team of people who moderate and manage package additions/changes are
extraordinarily responsive and kind.</p>
</blockquote>
<p>Even though, in the light of modern standards, one could point out several criticisms of OPAM, for example:</p>
<ul>
<li>terminology that can be cumbersome to grasp (<em>switch</em>, <em>invariant</em>,
etc.)</li>
<li>duplication of all packages and compilers across multiple <em>switches</em>
(this is a known issue for which <a href="https://www.youtube.com/watch?v=5JDSUCx-tPw">work has already been
done</a>)</li>
<li>and probably some ergonomic issues (notably the interaction with
<code>dune</code> could be smoother, for which <a href="https://discuss.ocaml.org/t/ann-dune-developer-preview-updates/15160">work is also currently
underway</a>)</li>
<li>some complications when managing packages in development,
referencing them from a source repository rather than from OPAM</li>
</ul>
<p>I must admit that coming from an era when OPAM did not exist, I have
learned to live with some of these minor pitfalls, and on a daily
basis, I have little reason to complain about the tool, which has
never really let me down in my everyday use. However, if you have
encountered usage issues, I encourage you to discuss them on <a href="https://ocaml.org/community">one of
the communication spaces</a> so that the
development team can take your feedback into account and guide you.</p>
<p>There is also <a href="https://esy.sh/">esy</a> as an alternative package
manager, which draws inspiration from <a href="https://nixos.org/">Nix</a> to
build a reusable <em>store</em>, in the same way it is possible to use Nix
with OCaml. However, being somewhat conventional, I am not really
familiar with these practices, and being satisfied with my <em>workflow</em>
with OPAM, I have, unfortunately, never taken the time to seriously
experiment with <strong>esy</strong>.</p>
<h4 id="dune-the-build-system"><a aria-hidden="true" href="#dune-the-build-system"></a>Dune, the <em>build-system</em></h4>
<p>As with package management, historically, OCaml had <strong>several</strong>
<em>build-systems</em>: the venerable
<a href="https://github.com/ocaml/ocamlbuild">ocamlbuild</a>,
<a href="https://github.com/ocaml/oasis">oasis</a>,
<a href="https://github.com/OCamlPro/ocp-build">ocp-build</a>,
<a href="https://ocaml.org/p/jenga/latest">Jenga</a>, and other variations around
<a href="https://www.gnu.org/software/make/">Make</a>. However, since 2018, the
community has strongly adopted <a href="https://dune.build/">Dune</a>, a
<em>build-system</em> initially developed at
<a href="https://www.janestreet.com/">Janestreet</a>.</p>
<p>In many aspects, Dune can be intimidating. Indeed, its
<a href="https://dune.readthedocs.io/en/stable/">documentation</a> is <strong>very
dense</strong> — but it has greatly improved in terms of structure over the
past few months. And, while many tools choose rule description
languages like <a href="https://en.wikipedia.org/wiki/YAML">YAML</a>,
<a href="https://en.wikipedia.org/wiki/TOML">TOML</a>, or even
<a href="https://en.wikipedia.org/wiki/JSON">JSON</a>, Dune has opted for
<a href="https://en.wikipedia.org/wiki/S-expression">S-expressions</a>. It is
also regrettable that Dune, <em>by default</em>, treats <a href="https://ocaml.org/manual/5.2/comp.html#s%3Acomp-warnings">all
warnings</a> as
fatal.</p>
<p>Before explaining some of its choices (such as <strong>S-expressions</strong>), it
is very important to highlight the points that have made Dune a
standard:</p>
<ul>
<li>Dune is <strong>very fast</strong> and offers a <strong>highly efficient</strong> execution
model</li>
<li>it builds the necessary artifacts for configuration <em>automatically</em></li>
<li>it generates some redundant files (such as OPAM description files)</li>
<li>it trivializes the
<a href="https://en.wikipedia.org/wiki/S-expression"><em>vendoring</em></a> of
libraries</li>
<li>it allows invoking <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">read–eval–print
loops</a>
correctly provisioned by the context</li>
<li>one becomes familiar very quickly with <strong>S-expressions</strong>, which
allow rules to be described schematically and rapidly</li>
<li>it is relatively agnostic and can execute arbitrary tasks (similar
to <code>make</code>)</li>
<li>it is constantly evolving and improving from version to version</li>
<li>paired with <a href="https://github.com/tarides/dune-release">dune-release</a>,
it makes publishing packages on OPAM incredibly simple</li>
</ul>
<p>Perhaps I’m biased, but in my opinion, Dune is one of the most generic
and pleasant <em>build-systems</em> I’ve ever used — even if, at first
glance, it can seem intimidating and some choices may be hard to
justify.</p>
<h5 id="on-the-choice-of-s-expressions"><a aria-hidden="true" href="#on-the-choice-of-s-expressions"></a>On the choice of S-expressions</h5>
<p>At first glance, using a <em>Lisp-like</em> syntax to describe binaries,
libraries, and projects may seem surprising. However, this decision
has several advantages:</p>
<ul>
<li>The AST of <strong>S-expressions</strong> being <strong>drastically simple</strong>, parsing
is very straightforward and can be made highly efficient, which does
not penalize compilation speed.</li>
<li>The language has <em>termination</em>, making it easier to inspect in case
of errors (anyone who has tried to handle errors in large YAML files
will have faced this kind of problem).</li>
<li>The language is very easy to learn and to describe.</li>
<li>It allows describing <strong>real programs</strong>, making Dune relatively
generic and enabling additional tasks.</li>
</ul>
<p>So, from my point of view, the choice of <strong>S-expressions</strong> is
relevant: it allows describing complex, readable programs without
being too verbose, does not significantly slow down compilation, and
enables very concise descriptions of highly complex build rules. And
to be completely honest, you get used to it very quickly!</p>
<h5 id="contribution-to-the-state-of-the-art-selective-applicative-functor"><a aria-hidden="true" href="#contribution-to-the-state-of-the-art-selective-applicative-functor"></a>Contribution to the state of the art: Selective Applicative Functor</h5>
<p>In addition to being a very pleasant <em>build-system</em>, Dune has
contributed to the state of the art in research by highlighting a new
construction <em>inspired by category theory</em>. Indeed, in 2018, <a href="https://blogs.ncl.ac.uk/andreymokhov/about/">Andrey
Mokhov</a>, <a href="https://ndmitchell.com/">Neil
Mitchell</a> and <a href="https://simon.peytonjones.org/">Simon Peyton
Jones</a> proposed, in the excellent
paper <a href="https://dl.acm.org/doi/10.1145/3236774">&#34;<em>Build Systems à la
Carte</em>&#34;</a>, a collection of
abstractions to re-implement — modularly — various
<em>build-systems</em>. However, for reasons related to <strong>static dependency
analysis</strong>, these models were not compatible with Dune. After several
investigations and experiments, a new construction, similar to an
<a href="https://hackage.haskell.org/package/base-4.20.0.1/docs/Control-Applicative.html">Applicative</a>,
a <a href="https://dl.acm.org/doi/10.1145/3341694">Selective Applicative
Functor</a>, capturing Dune&#39;s
prerequisites was proposed. This information may seem anecdotal, but,
in my view, it reinforces the value (and importance) of being at <strong>the
intersection of research and industry</strong>.</p>
<h5 id="alternatives"><a aria-hidden="true" href="#alternatives"></a>Alternatives</h5>
<p>Although widely adopted by the community, OCaml offers alternative
systems (sometimes using Dune <em>under the hood</em>), for example,
<a href="https://obazl.github.io/docs_obazl/">Obazl</a> which provides OCaml
rules for <a href="https://bazel.build/">Bazel</a>,
<a href="https://github.com/rizo/onix">Onix</a> which allows building projects
with <a href="https://nixos.org">Nix</a>, <a href="https://buck2.build/">Buck2</a> which is
an ambitious and generic project competing with Bazel, and
<a href="https://github.com/OCamlPro/drom">Drom</a> which offers an experience
similar to <a href="https://doc.rust-lang.org/stable/cargo/">Cargo</a>, unifying
package management and project building.</p>
<h4 id="lsp-and-merlin-for-editors"><a aria-hidden="true" href="#lsp-and-merlin-for-editors"></a>LSP and Merlin for editors</h4>
<p>In the previous sections, we saw how much OCaml has progressed in
areas necessary for industrialization. On the other hand, in terms of
editor support, OCaml has had excellent support for
<a href="https://www.vim.org/">Vim</a> and
<a href="https://www.gnu.org/software/emacs/">Emacs</a> for over 10 years through
the <a href="https://github.com/ocaml/merlin">Merlin</a> project, which provides
editor services enabling <strong>completion</strong>, <strong>diagnostics</strong>, <strong>code
navigation</strong> features, tools related to <strong>value deconstruction</strong>,
<strong>value construction</strong>, management (and navigation) of <strong>typed
holes</strong>, <strong>polarity-based search</strong>, precise information (with
verbosity control) on <strong>value types</strong>, <em><strong>jump-to-definition</strong></em>, etc.</p>
<p>In my opinion, IDE support via Merlin has been excellent in OCaml for
a very long time. Coupled with
<a href="https://github.com/OCamlPro/ocp-indent">ocp-indent</a>, which calculates
the cursor position after an action in the editor, and
<a href="https://github.com/ocaml-ppx/ocamlformat">OCamlformat</a>, which allows
on-the-fly (configurable) formatting of OCaml files, writing code in
Emacs or Vim is an absolute joy!</p>
<h5 id="the-advent-of-vscode-lsp-as-standard"><a aria-hidden="true" href="#the-advent-of-vscode-lsp-as-standard"></a>The advent of VSCode, LSP as standard</h5>
<p>In 2015, <a href="https://en.wikipedia.org/wiki/Visual_Studio_Code">Visual Studio
Code</a> arrived,
introducing the <a href="https://en.wikipedia.org/wiki/Language_Server_Protocol">Language Server
Protocol</a>,
which abstracts how editors interact with a language through a server,
following a uniform protocol. OCaml has a <a href="https://github.com/ocaml/ocaml-lsp">very good LSP
server</a> that itself relies on
well-established libraries in the OCaml ecosystem, notably
Merlin. Since LSP has become <em>relatively standard</em> in the editor world
(Vim, Emacs, and, in fact, almost all free editors I know can interact
with an LSP server), the plan is to deprecate the Merlin server,
moving entirely to LSP, making Merlin a low-level library that
provides tooling used by LSP. This is one of the projects the <code>Editor</code>
team at <a href="https://tarides.com">Tarides</a> (which I’m part of) is working
on: making <code>ocaml-lsp</code> feature-compatible with Merlin’s historic
server to reduce maintenance for alternative clients (Emacs and Vim),
only worrying about OCaml-specific requests and actions (which,
logically, are not part of the protocol).</p>
<p>Currently, the <a href="https://marketplace.visualstudio.com/items?itemName=ocamllabs.ocaml-platform">OCaml platform for Visual Studio
Code</a>
and <a href="https://github.com/tarides/ocaml-eglot">OCaml-eglot</a> are the two
canonical implementations (which extend the LSP protocol for OCaml),
respectively for VSCode and Emacs. We are currently considering the
implementation of a NeoVim plugin.</p>
<p>A bit like with Dune, in my opinion, the tooling state is excellent,
and the roadmap is motivating! However, since this is <strong>my work</strong>, I’m
probably biased.</p>
<h4 id="odoc-the-documentation-generator"><a aria-hidden="true" href="#odoc-the-documentation-generator"></a>Odoc, the documentation generator</h4>
<p>OCaml is distributed with a documentation generator, the venerable
<a href="https://ocaml.org/manual/5.2/ocamldoc.html">OCamldoc</a>; however, it is
no longer recommended by/for the community. Indeed, the tool being
promoted is <a href="https://ocaml.github.io/odoc/">Odoc</a>, a new tool that
exists outside the compiler and offers several very interesting
features:</p>
<ul>
<li>a <em>rich markup</em> language, supporting cross-references</li>
<li>the ability to write &#34;manual&#34; pages, ephemeral, while still
benefiting from cross-references</li>
<li>very good integration with Dune</li>
<li>a type-based search bar (implemented via
<a href="https://doc.sherlocode.com/">Sherlodoc</a>)</li>
<li>inclusion of source code (written in the documentation or documented
modules)</li>
<li>implementation of <em>drivers</em> allowing the generation of large sets of
documentation (used to implement <a href="https://ocaml.org/packages">the documentation of all packages
on OPAM</a>)</li>
<li>support for <a href="https://en.wikipedia.org/wiki/Doctest"><em>doctest</em></a> via
<a href="https://github.com/realworldocaml/mdx">mdx</a></li>
</ul>
<p>Even though the <em>look&#39;n feel</em> of documentation generated by Odoc is,
in my view, <strong>far superior</strong> to that produced by OCamldoc, there is
still (once again, in my view) a bit of work needed on the UI for the
tool to be truly <strong>perfect</strong>!</p>
<p>I clearly have a certain fondness for the documentation of the
<a href="https://elixir-lang.org/">Elixir</a> language,
<a href="https://hexdocs.pm/">HexDoc</a> (in terms of <em>design</em> and features), and
personally, I would like OCaml to move toward that example. However,
it must be acknowledged that the documentation generated by Odoc is
superior to that of many other languages. Moreover, due to the highly
modular nature of the language, a good documentation generator that
effectively supports <em>cross-references</em> is quite an achievement!</p>
<h3 id="available-libraries"><a aria-hidden="true" href="#available-libraries"></a>Available libraries</h3>
<p>We have seen that the language is <em>cool</em>, and that it has tooling
which, although still evolving, is effective and pleasant to
use. Could its lack of popularity be due to a too limited set of
libraries? To be completely honest, <strong>I don’t know</strong>. What I do know
is that whenever I have had to write OCaml projects, both professional
and personal, I have often found everything I needed in the <a href="https://ocaml.org/packages">package
list</a>. I think the reasons why OCaml is
mature enough for many typical projects can be summarized in several
points:</p>
<ul>
<li>Companies like <a href="https://www.lexifi.com/">Lexifi</a> and
<a href="https://www.janestreet.com/">Janestreet</a> have strongly contributed
to the ecosystem by releasing many libraries necessary for their
daily use.</li>
<li>Ambitious research projects, such as, in the case of the Web,
<a href="https://ocsigen.org/home/intro.html">Ocsigen</a>, used industrially in
the <a href="https://www.besport.com">BeSport</a> project, have generated a
collection of useful libraries.</li>
<li>As mentioned earlier, <a href="https://mirage.io">MirageOS</a>, with its
<a href="https://blog.container-solutions.com/all-about-unikernels-part-1-what-they-are"><em>Clean
Slate</em></a>
approach, naturally produced many robust libraries.</li>
<li>Like in popular languages such as JavaScript or Rust, motivated
contributors have provided excellent libraries.</li>
<li>The language is old and has been used industrially for a long time.</li>
</ul>
<p>For my part, I have sometimes <em>re-created</em> libraries for the
<strong>pleasure of reinventing the wheel</strong>, but also, at times, to offer an
alternative interface. Moreover, OCaml allows interfacing with, among
other languages, C, enabling the creation of <em>bindings</em> for a large
number of libraries and tools. However, if there is a library that you
find <em>objectively</em> missing, I encourage you to join <a href="https://ocaml.org/community">the
community</a>.</p>
<p>It is important to note that my use of OCaml has focused primarily on
three areas:</p>
<ul>
<li><strong>Web development</strong> (heavily driven by Mirage, Ocsigen, and
independent projects like <a href="https://aantron.github.io/dream/">Dream</a>,
<a href="https://github.com/xhtmlboi/yocaml">YOCaml</a>, and many
<a href="https://ocaml.org/packages/search?q=web">others</a>)</li>
<li><strong>Blockchain development</strong> and, by extension, the use of
cryptography libraries, provided once again by Mirage, as well as by
the <a href="https://github.com/hacl-star/hacl-star">HACL*</a> project, a
formally verified library written in <a href="https://fstar-lang.org/">F*</a>
and extracted to OCaml</li>
<li><strong>Development of <a href="https://github.com/ocaml/merlin">Merlin</a></strong> and
<a href="https://github.com/ocaml/ocaml-lsp">OCaml-LSP</a></li>
</ul>
<p>All these areas still require good testing tooling, and OCaml offers
several complementary libraries to implement robust test
suites. Indeed, within the OCaml ecosystem, you can find tools to
write <a href="https://github.com/realworldocaml/mdx">doctests</a>, classic <a href="https://github.com/mirage/alcotest">unit
tests</a>, <a href="https://github.com/c-cube/qcheck">property-based
tests</a>,
<a href="https://github.com/stedolan/crowbar">fuzzing</a>, as well as <a href="https://dune.readthedocs.io/en/stable/tests.html#inline-expectation-tests">output
observation
tests</a>,
<a href="https://dune.readthedocs.io/en/stable/tests.html#inline-tests">inline
tests</a>
(which allow testing, among other things, private components), and
<a href="https://dune.readthedocs.io/en/latest/reference/cram.html">cram
tests</a>.</p>
<p>I continue to find everything I need among the available packages, and
I’m still very impressed to see the number of packages and
alternatives grow <em>year after year</em>. Of course, there are some gaps,
but they have not invalidated my choice of OCaml.</p>
<h4 id="side-note-on-the-standard-library"><a aria-hidden="true" href="#side-note-on-the-standard-library"></a>Side note on the standard library</h4>
<p>A recurring criticism of OCaml is the <em>modesty</em> of its standard
library. Historically, it was designed only to implement the language
itself, so it didn’t include certain features useful for end
users. This situation has led to the emergence of alternative standard
libraries, the most popular of which are:</p>
<ul>
<li><a href="https://github.com/ocaml-batteries-team/batteries-included">Batteries</a>,
an alternative to the standard library that is somewhat
<em>dated</em>. Historically, it was a <em>fork</em> of
<a href="https://github.com/ygrek/ocaml-extlib">Extlib</a>.</li>
<li><a href="https://opensource.janestreet.com/base/">Base</a>, an alternative
developed by <a href="https://janestreet.com">Janestreet</a>, used <em>quite
extensively</em> in the book <a href="https://dev.realworldocaml.org/">Real World
OCaml</a>. The library enforces strong
conventions, such as <em>labeling</em> higher-order functions (typically
with the name <code>f</code>).</li>
<li><a href="https://opensource.janestreet.com/core/">Core</a> is an extension of
Base.</li>
<li><a href="https://github.com/c-cube/ocaml-containers">Containers</a> is an
extension of the standard library (in the sense that <code>open Containers</code> at the beginning of a module does not break code written
with the standard library).</li>
</ul>
<p>In addition to these alternative standard libraries, there are
specialized libraries that address general problems, such as
<a href="https://github.com/dbuenzli/bos">Bos</a>, which provides tools to
interact with an operating system, and
<a href="https://github.com/xvw/preface">Preface</a> — <em>shameless plug</em> — which
allows you to <em>realize abstractions from category theory</em>.</p>
<p>The stance of the maintainers on the standard library has evolved over
the years, and it is now possible to consider extending it. However,
additions to the standard library are often subject to debate, and
adding new modules can sometimes take a long time. Personally, I would
have preferred that the standard library <strong>continue to serve only the
development of the language</strong> and that a library under the OCaml
community umbrella be published. This separation allows the releases
of the language and its standard library to be desynchronized and also
likely simplifies compatibility between the library and the language.</p>
<h3 id="ecosystem-conclusion"><a aria-hidden="true" href="#ecosystem-conclusion"></a>Ecosystem Conclusion</h3>
<p>Unfortunately, I don’t have the opportunity to cover all the tools of
the platform, nor the fundamental building blocks that make OCaml
enjoyable to use for personal projects as well as for industrial
projects (for example, the various existing
<a href="https://github.com/hackwaly/ocamlearlybird">debuggers</a>). However, I
hope I’ve been able to give an overview of some tools that form a
solid foundation for using OCaml.</p>
<p>In my use of the language, I’ve sometimes had to build my own library;
however, it’s not an exercise I regret. I think, unfortunately, that
if one decides never to use a language just because 100% of the
necessary libraries aren’t available, it feels—perhaps awkwardly—to me
like <strong>leveling down</strong>, trapping us behind languages backed by
<em>wealthy companies</em>, like Java or C#, and <strong>that’s a bit sad</strong>.</p>

<p>Even though I’ve used many different programming languages, I think
OCaml is the only one with which I’ve had strong community
interaction. So, I’m not fully aware of how things work in other
communities, which makes my feedback <em>somewhat irrelevant</em>. But from
my experience, I find that the OCaml community, besides being very
productive, is:</p>
<ul>
<li>
<p><strong>Very accessible</strong>: Like many other languages, OCaml has a <a href="https://ocaml.org/community">strong
online presence</a>. On these platforms,
you can find highly experienced contributors to the language and its
ecosystem and benefit from expert (or sometimes less technical)
advice. I’d like to give a special mention to <a href="http://gasche.info">Gabriel
Scherer</a> and <a href="https://perso.quaesituri.org/florian.angeletti">Florian
Angeletti</a>, whose
answers are always thoughtful and interesting.</p>
</li>
<li>
<p><strong>Very kind</strong>: I often need to ask for help, and I’ve always
received clear and precise answers, whether in private or in public.</p>
</li>
<li>
<p><strong>Very brilliant</strong>: OCaml is the product of work by <em>brilliant
researchers</em>, and having the chance to interact with them is
incredible (and potentially a bit intimidating). Being able to ask
questions directly to people behind some of the major discoveries in
language design is a fantastic opportunity.</p>
</li>
</ul>
<p>To conclude on the community aspect, even though I’m not fully aware
of how other communities interact, I find it a pleasure to be part of
the OCaml developer community. It’s a welcoming space, conducive to
sharing and learning.</p>
<h2 id="some-myths-about-ocaml"><a aria-hidden="true" href="#some-myths-about-ocaml"></a>Some myths about OCaml</h2>
<p>I’m finally reaching the most fun part of this overly long article: I
get to <strong>debunk</strong> some persistent myths about OCaml. I still can’t
promise complete objectivity, but know that my intentions are good. On
the internet, you often see various criticisms or remarks about OCaml,
and I often find it tiresome to respond. However, what better way than
an article meant to share my enthusiasm for the language to take the
time to address some of these critiques and try to provide a response?</p>
<p>I’ve selected a few, but it’s likely that in the future I’ll write
somewhat longer articles—similar to the members of <a href="https://www.heyplzlookat.me/articles/critique-de-la-raison-pure.gmi">HeyPlzLookAtMe
(fr)</a>
— about articles I find unfair.</p>
<h3 id="ocaml-and-f"><a aria-hidden="true" href="#ocaml-and-f"></a>OCaml and F#</h3>
<p><a href="https://fsharp.org/">F#</a> is a programming language <a href="https://fsharp.org/history/hopl-final/hopl-fsharp.pdf">historically very
inspired</a> by
OCaml that runs on the <a href="https://dotnet.microsoft.com">.NET</a> platform
(and, de facto, integrates very well with C#). I find the language —
which I have professionally used at
<a href="https://derniercri.io/">DernierCri</a> and
<a href="https://www.d-edge.com">D-Edge</a> — very pleasant. Historically, since
.NET was exclusively for Windows environments, OCaml didn’t suffer
much by comparison. However, since the arrival of <a href="https://github.com/dotnet/core">.NET
Core</a>, a cross-platform implementation
of .NET, I increasingly see statements on the internet like:</p>
<blockquote>
<p>&#34;Why continue using OCaml when you can have the same language, F#,
with the entire .NET ecosystem, more features, and a syntax that’s
more pleasant to use?&#34;</p>
</blockquote>
<p>First, I do think that having the .NET (Core) ecosystem is a huge
advantage. Regarding the syntax, I’m more reserved. Indeed, I find
that indentation-based syntax sometimes makes moving code around more
cumbersome, and even though there are criticisms of OCaml’s syntax, I
must admit it hasn’t let me down. The last point seems a bit more
insidious. Indeed, F# has been equipped with features not present in
OCaml, for example:</p>
<ul>
<li><a href="https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/computation-expressions">Computation
expressions</a>
(which are syntactically a more general form than <a href="https://ocaml.org/manual/5.2/bindingops.html">binding
operators</a>)</li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/computation-expressions">Type
providers</a>
(which can, unfortunately, sometimes cause issues with .NET Core in
certain name/path resolution cases)</li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/active-patterns">Active
patterns</a></li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/generics/statically-resolved-type-parameters">Statically resolved type
parameters</a></li>
<li>The ability to assign methods to sums and products, which makes
sense for interoperability reasons but significantly breaks type
inference</li>
<li>And probably other features that I don’t know well (or are linked to
interoperability with the .NET platform, notably
<a href="https://learn.microsoft.com/fr-fr/dotnet/fsharp/language-reference/attributes">reflection</a>)</li>
</ul>
<p>These evolutions arrived gradually in the language. It would be naive
to think that OCaml hasn’t evolved as well. Indeed, although
historically the two languages seemed very similar, from the very
beginning of F#’s proposal, certain features were missing:</p>
<ul>
<li>
<p>The absence of a <strong>module language</strong>. Indeed, the <code>module</code> keyword
exists in F#, but it is only used to describe static classes (and it
integrates rather awkwardly with namespaces).</p>
</li>
<li>
<p>A <strong>drastically different object model</strong> (for interoperability with
C#, of course).</p>
</li>
</ul>
<p>These two reasons alone would be enough to consider OCaml and F# as
<em>cousin</em> languages but <strong>very different</strong>, and in my opinion, strongly
justify preferring one over the other. In my case, OCaml over F# makes
the introductory sentence of this section moot. However, like F#,
OCaml has also evolved, and in addition to these two fundamental
differences, OCaml offers many features that are absent in F#:</p>
<ul>
<li><strong>Local and generalized <code>open</code>s</strong>: In OCaml, you can open a module
locally within a scope, whereas in F# you can only open a module at
the <em>top-level</em>, which can be quite frustrating in some cases.</li>
<li><strong>Row polymorphism</strong>: OCaml supports row polymorphism on products
(via objects) and sums (via <a href="https://ocaml.org/manual/5.2/polyvariant.html">polymorphic
variants</a>).</li>
<li><strong>Generalized Algebraic Data Types (GADTs)</strong>: One of the most missed
features (after the module system) for expressing precise type
constraints.</li>
<li><strong>User-defined effects</strong>: OCaml allows defining custom effect
handlers, which can simplify complex control flow and concurrency
patterns.</li>
<li><strong>Open sums</strong>: Extensible variants allow for sum types that can be
extended, though similar behavior can sometimes be simulated using
objects and inheritance.</li>
</ul>
<p>To conclude, even though F# is a really nice language and using it
brings many advantages (notably the .NET platform), it is <strong>not just a
better version of OCaml</strong>. The two languages are very different, and
from my point of view, OCaml has a more sophisticated type system,
which makes me prefer it over F#. In my opinion, saying that F# is
just a prettier OCaml is as reasonable as saying that
<a href="https://kotlinlang.org/">Kotlin</a> is nothing more than
<a href="https://www.scala-lang.org/">Scala</a> with a lighter syntax.</p>
<h3 id="doubled-operators-for-floats"><a aria-hidden="true" href="#doubled-operators-for-floats"></a>Doubled operators for floats</h3>
<p>The standard library contains the following arithmetic operators on
integers:</p>
<pre><code><span>val</span><span> </span><span>(</span><span> </span><span>+</span><span> </span><span>)</span><span> </span><span>:</span><span> </span><span>int</span><span> </span><span>-&gt;</span><span> </span><span>int</span><span> </span><span>-&gt;</span><span> </span><span>int</span><span>
</span><span>val</span><span> </span><span>(</span><span> </span><span>-</span><span> </span><span>)</span><span> </span><span>:</span><span> </span><span>int</span><span> </span><span>-&gt;</span><span> </span><span>int</span><span> </span><span>-&gt;</span><span> </span><span>int</span><span>
</span><span>val</span><span> </span><span>(</span><span> </span><span>*</span><span> </span><span>)</span><span> </span><span>:</span><span> </span><span>int</span><span> </span><span>-&gt;</span><span> </span><span>int</span><span> </span><span>-&gt;</span><span> </span><span>int</span><span>
</span></code></pre>
<p>But also arithmetic operators for floating point numbers:</p>
<pre><code><span>val</span><span> </span><span>(</span><span> </span><span>+.</span><span> </span><span>)</span><span> </span><span>:</span><span> </span><span>float</span><span> </span><span>-&gt;</span><span> </span><span>float</span><span> </span><span>-&gt;</span><span> </span><span>float</span><span>
</span><span>val</span><span> </span><span>(</span><span> </span><span>-.</span><span> </span><span>)</span><span> </span><span>:</span><span> </span><span>float</span><span> </span><span>-&gt;</span><span> </span><span>float</span><span> </span><span>-&gt;</span><span> </span><span>float</span><span>
</span><span>val</span><span> </span><span>(</span><span> </span><span>*.</span><span> </span><span>)</span><span> </span><span>:</span><span> </span><span>float</span><span> </span><span>-&gt;</span><span> </span><span>float</span><span> </span><span>-&gt;</span><span> </span><span>float</span><span>
</span></code></pre>
<p>At first glance, this may seem confusing. However, it makes perfect
sense. If we wanted to have generic operators, we would need <a href="https://en.wikipedia.org/wiki/Ad_hoc_polymorphism">ad-hoc
polymorphism</a>, like
in Haskell, for example, where arithmetic operators reside in the
<code>Num</code> type class:</p>
<pre><code><span>class</span><span>  </span><span>Num</span><span> </span><span>a</span><span>  </span><span>where</span><span>
</span><span>  (+), (-), (*) :: a -&gt; a -&gt; a
</span><span>  </span></code></pre>
<p>Without some form of ad-hoc polymorphism (via classes, traits, or
implicits) to describe a constraint on our operators, e.g., <code>op :: Num a =&gt; a -&gt; a -&gt; a</code>, what can we do? A suggestion I’ve often seen online
is to use <em>the same trick</em> as with the <code>=</code> operator, whose type is
<code>val (=) : &#39;a -&gt; &#39;a -&gt; bool</code>. That doesn’t work, because while
we can hope that <em>everything is comparable</em> (at worst, we can return
<code>false</code>), how can we generalize something like addition?</p>
<p>Support for arithmetic operators is a tricky problem, which is
actually the original motivation behind <a href="https://en.wikipedia.org/wiki/Type_class">type
classes</a> (and the reason for
<a href="https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/generics/statically-resolved-type-parameters">statically resolved type
parameters</a>
in F#). From my perspective, <em>while waiting for <a href="https://www.cl.cam.ac.uk/~jdy22/papers/modular-implicits.pdf">modular
implicits</a></em>,
duplicating operators to work with integers and floats seems like a
<em>reasonable</em> approach. And if, for some strange reason, suffixing
operators with dots when using floats gives you hives, you can avoid
it using local opens by providing, for example, this module:</p>
<pre><code><span>module</span><span> </span><span>Arithmetic</span><span> </span><span>(</span><span>P</span><span> </span><span>:</span><span> </span><span>sig</span><span>
</span><span>  </span><span>type</span><span> </span><span>t</span><span>
</span><span>
</span><span>  </span><span>val</span><span> </span><span>add</span><span> : t -&gt; t -&gt; t
</span><span>  </span><span>val</span><span> </span><span>sub</span><span> : t -&gt; t -&gt; t
</span><span>  </span><span>val</span><span> </span><span>mul</span><span> : t -&gt; t -&gt; t
</span><span>  </span><span>val</span><span> </span><span>div</span><span> : t -&gt; t -&gt; t
</span><span>end</span><span>)</span><span> </span><span>=</span><span>
</span><span>struct</span><span>
</span><span>  </span><span>let</span><span> </span><span>(</span><span> </span><span>+</span><span> </span><span>)</span><span>,</span><span> </span><span>(</span><span> </span><span>-</span><span> </span><span>)</span><span>,</span><span> </span><span>(</span><span> </span><span>*</span><span> </span><span>)</span><span>,</span><span> </span><span>(</span><span> </span><span>/</span><span> </span><span>)</span><span> </span><span>=</span><span> </span><span>P</span><span>.</span><span>(</span><span>add</span><span>,</span><span> </span><span>sub</span><span>,</span><span> </span><span>mul</span><span>,</span><span> </span><span>div</span><span>)</span><span>
</span><span>end</span><span>
</span></code></pre>
<p>Which allows extending the <code>Int</code> and <code>Float</code> modules (which already
provide the functions <code>add</code>, <code>sub</code>, <code>mul</code>, and <code>div</code>) by giving them
arithmetic operators:</p>
<pre><code><span>module</span><span> </span><span>Int</span><span> </span><span>=</span><span> </span><span>struct</span><span>
</span><span>  </span><span>include</span><span> </span><span>Int</span><span>
</span><span>  </span><span>include</span><span> </span><span>Arithmetic</span><span> </span><span>(</span><span>Int</span><span>)</span><span>
</span><span>end</span><span>
</span></code></pre>
<p>In broad terms, we create an <code>Int</code> module, include the previous <code>Int</code>
module so that our new <code>Int</code> module retains the entire API of the
original <code>Int</code> module, and then we define (and include) our arithmetic
operators. We can now repeat the same process with <code>Float</code>:</p>
<pre><code><span>module</span><span> </span><span>Float</span><span> </span><span>=</span><span> </span><span>struct</span><span>
</span><span>  </span><span>include</span><span> </span><span>Float</span><span>
</span><span>  </span><span>include</span><span> </span><span>Arithmetic</span><span> </span><span>(</span><span>Float</span><span>)</span><span>
</span><span>end</span><span>
</span></code></pre>
<p>And now we can use a local <code>open</code> so that we don’t have to suffix our
operators with dots:</p>
<pre><code><span>let</span><span> </span><span>x</span><span> </span><span>=</span><span> </span><span>Int</span><span>.</span><span>(</span><span>1</span><span> </span><span>+</span><span> </span><span>2</span><span> </span><span>+</span><span> </span><span>3</span><span> </span><span>+</span><span> </span><span>(</span><span>4</span><span> </span><span>*</span><span> </span><span>6</span><span> </span><span>/</span><span> </span><span>7</span><span>)</span><span>)</span><span>
</span><span>let</span><span> </span><span>y</span><span> </span><span>=</span><span> </span><span>Float</span><span>.</span><span>(</span><span>1.3</span><span> </span><span>+</span><span> </span><span>2.5</span><span> </span><span>+</span><span> </span><span>3.1</span><span> </span><span>+</span><span> </span><span>(</span><span>4.6</span><span> </span><span>*</span><span> </span><span>6.8</span><span> </span><span>/</span><span> </span><span>7.9</span><span>)</span><span>)</span><span>
</span></code></pre>
<p>From my point of view, even if this can be confusing for those coming
from languages where this isn’t an issue, it’s a minor problem. The
lack of operator overloading seems like a rather weak argument for not
giving a language a chance — <em>but that’s just my humble opinion</em>.</p>
<h3 id="on-the-separation-between-ml-and-mli"><a aria-hidden="true" href="#on-the-separation-between-ml-and-mli"></a>On the separation between <code>ml</code> and <code>mli</code></h3>
<p>Another point that generates a lot of discussion (even
<a href="https://discuss.ocaml.org/t/has-there-been-a-syntax-proposed-for-combining-mli-into-ml/15163">recently</a>)
concerns the <strong>separation between <code>ml</code> and <code>mli</code> files</strong>. Personally,
I find it great. Even if it can introduce a bit of repetition, it
allows me to focus on the API via module encapsulation in the <code>mli</code>
file while also adding documentation. I can organize the functions I
expose in any order I like, and naturally, I can abstract the types I
share as much as possible. Moreover, when I look at an implementation,
the <code>ml</code> code is rarely cluttered with documentation, making it easy
to navigate the different elements of the module. On top of that, it
enables separate compilation and prevents recompiling modules that
depend on other modules whose implementation alone was changed during
development (this is Dune’s default behavior in the <code>dev</code> profile).</p>
<p>However, tastes vary, and when exposing complex types or module types,
this repetition can be annoying. Fortunately, there is a <em>trick</em>,
presented in 2020 by <a href="https://www.craigfe.io">Craig Ferguson</a>, that
helps mitigate this repetition: <a href="https://www.craigfe.io/posts/the-intf-trick">The <code>_intf_</code>
trick</a>.</p>
<p>Additionally, there are small tricks based on the ability to pass
arbitrary module expressions to the <code>open</code> and <code>include</code> primitives,
which sometimes allow you to do without <code>mli</code>. I had already mentioned
this in the article <a href="http://tinylogger.com/en/articles/modules-import.html">OCaml, modules and import
schemes</a>.</p>
<h4 id="encapsulation-without-mli"><a aria-hidden="true" href="#encapsulation-without-mli"></a>Encapsulation without <code>mli</code></h4>
<p>You can simply use <code>open struct (* private code *) end</code> to avoid
exporting parts of your code without needing interfaces. For example:</p>
<pre><code><span>open</span><span> </span><span>struct</span><span>
</span><span>  </span><span>
</span><span>  </span><span>let</span><span> </span><span>f</span><span> </span><span>x</span><span> </span><span>=</span><span> </span><span>x</span><span>
</span><span>  </span><span>let</span><span> </span><span>g</span><span> </span><span>=</span><span> </span><span>_some_private_stuff</span><span>
</span><span>end</span><span>
</span><span>
</span><span>
</span><span>let</span><span> </span><span>a</span><span> </span><span>=</span><span> </span><span>f</span><span> </span><span>10</span><span>
</span><span>let</span><span> </span><span>b</span><span> </span><span>=</span><span> </span><span>g</span><span> </span><span>+</span><span> </span><span>11</span><span>
</span></code></pre>
<h4 id="expressing-the-interface-from-ml"><a aria-hidden="true" href="#expressing-the-interface-from-ml"></a>Expressing the interface from <code>ml</code></h4>
<p>Another similar technique is to use <code>include (struct ... end : sig (* public API *) end)</code> to describe both the structure and the interface
in the same file. For example:</p>
<pre><code><span>include</span><span> </span><span>(</span><span>struct</span><span>
</span><span>  </span><span>type</span><span> </span><span>t</span><span> </span><span>=</span><span> </span><span>int</span><span>
</span><span>  </span><span>let</span><span> </span><span>f</span><span> </span><span>x</span><span> </span><span>=</span><span> </span><span>x</span><span>
</span><span>  </span><span>let</span><span> </span><span>g</span><span> </span><span>=</span><span> </span><span>_some_private_stuff</span><span>
</span><span>end</span><span> </span><span>:</span><span> </span><span>sig</span><span>
</span><span>  </span><span>type</span><span> </span><span>t</span><span>
</span><span>  </span><span>val</span><span> </span><span>f</span><span> : int -&gt; t
</span><span>end</span><span>)</span><span>
</span></code></pre>
<p>This way, the signature and the structure live in the same file, while
still allowing precise control over encapsulation. Another approach
would be to put the signature in a dedicated <code>module type</code>, like this:</p>
<pre><code><span>module</span><span> </span><span>type</span><span> </span><span>S</span><span> </span><span>=</span><span> </span><span>sig</span><span>
</span><span>  </span><span>type</span><span> </span><span>t</span><span>
</span><span>  </span><span>val</span><span> </span><span>f</span><span> : int -&gt; t
</span><span>end</span><span>
</span><span>
</span><span>include</span><span> </span><span>(</span><span>struct</span><span>
</span><span>  </span><span>type</span><span> </span><span>t</span><span> </span><span>=</span><span> </span><span>int</span><span>
</span><span>  </span><span>let</span><span> </span><span>f</span><span> </span><span>x</span><span> </span><span>=</span><span> </span><span>x</span><span>
</span><span>  </span><span>let</span><span> </span><span>g</span><span> </span><span>=</span><span> </span><span>_some_private_stuff</span><span>
</span><span>end</span><span> </span><span>:</span><span> </span><span>S</span><span>)</span><span>
</span></code></pre>
<p>This is very similar to the first approach, except that the module
also exposes the module type <code>S</code>. A useful side effect of this <em>leak</em>
is that you can easily reference the module&#39;s signature using
<code>My_mod.S</code> instead of having to write <code>module type of My_mod</code>.</p>
<h4 id="to-conclude-on-separation"><a aria-hidden="true" href="#to-conclude-on-separation"></a>To conclude on separation</h4>
<p>I find this separation <strong>very desirable</strong>. However, since OCaml’s
module system is highly expressive, it is possible — through some
clever encoding — to work around this separation. From my point of
view, these approaches mainly serve to demonstrate this
<em>expressiveness</em>, because the downside of merging everything in one
file is the loss of separate compilation, which I consider <em>quite
unfortunate</em>.</p>
<h2 id="conclusion"><a aria-hidden="true" href="#conclusion"></a>Conclusion</h2>
<p>I think I have <em>briefly</em> covered the points I wanted to discuss. From
my perspective, <strong>OCaml is an amazing language</strong>! It offers an
excellent balance between safety and expressiveness, thanks in
particular to its advanced type system, a rich module language,
objects, support for <em>row polymorphism</em> via objects and polymorphic
variants, and user-defined effects! Its intersection of research and
industry makes it, in my view, a language evolving in the right
direction, carefully integrating new features to stay modern without
suffering the pitfalls of too-rapid or untested adoption.</p>
<p>Even though for several years OCaml’s tooling might have seemed a bit…
<em>dusty</em>, recently, thanks in part to commercial support from certain
companies, the tooling has been drastically modernized and continues
to improve, as shown by <a href="https://ocaml.org/tools/platform-roadmap">the platform
roadmap</a>. Additionally, the
growing ecosystem of libraries makes it possible to use OCaml in a
wide range of contexts, notably thanks to its different compilation
targets (for example, the browser via
<a href="https://github.com/ocsigen/js_of_ocaml">js_of_ocaml</a> and
<a href="https://github.com/ocaml-wasm/wasm_of_ocaml">wasm_of_ocaml</a>).</p>
<p>By combining an expressive language with a versatile ecosystem and a
supportive, responsive community, OCaml becomes a very compelling
choice for both personal and professional projects. Clearly, migrating
an entire codebase to OCaml is probably not a pragmatic move, but if
you have small personal projects in mind and are curious and
entertained by programming languages, <strong>I seriously encourage you to
consider OCaml</strong>!</p>
<p>I hope I’ve managed to convey my enthusiasm for this language (and its
ecosystem). If you’d like to discuss it, find projects, or explore
contribution opportunities, I’d be happy to talk with you — or you can
reach out to the community through <a href="https://discuss.ocaml.org/">the
forum</a>, which is active, responsive, and
welcoming!</p>
</article></div>
  </body>
</html>
