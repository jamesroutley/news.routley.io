<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.jacobvosmaer.nl/0020-1-billion-row-challenge/">Original</a>
    <h1>Taking on the One Billion Row Challenge in C</h1>
    
    <div id="readability-page-1" class="page"><div><p><i><a href="https://blog.jacobvosmaer.nl/">Jacob Vosmaer&#39;s blog</a></i></p>

<p>2024-02-06</p>

<p>I will share below what I have done and learned by taking on the <a href="https://github.com/gunnarmorling/1brc">One Billion Row Challenge</a> in C.</p>

<h2>Am I allowed to do this challenge?</h2>

<p>Earlier this year I read the announcement of the <a href="https://www.morling.dev/blog/one-billion-row-challenge/">One Billion Row Challenge</a>. The challenge was to parse and summarize 1 billion rows of CSV as fast as possible... in Java.</p>

<p>I remember reading the blog post and thinking &#34;this sounds like something I would enjoy&#34; until I hit the requirement to do it in Java. Not because I have something against Java, but because I have virtually no experience in that language so the challenge would become &#34;using Java&#34; rather than &#34;process data quickly&#34;.</p>

<p>I decided it wasn&#39;t for me and I moved on. Then several weeks later I found out that many people did the challenge for themselves in whatever language they felt like, and I felt stupid for not realizing I could have done the same. When I was done feeling stupid I started doing the challenge for myself after all, in C.</p>

<p>A big lesson here is that I need to be more critical  when I tell myself I cannot do something or that something is not for me.</p>

<h2>Generating the inputs</h2>

<p>The official <a href="https://github.com/gunnarmorling/1brc">repository</a> for the challenge contains Java code that can generate random data to test your solution on. There is no download link for the test data, you have to generate it yourself.</p>

<p>I tried generating the data on my local machine but I kept running into Java compiler errors that I did not understand. I decided it would be more <i>fun</i> to implement <a href="https://github.com/jacobvosmaer/1brc/blob/6681871a36eccb0209390dfa224cc20f8a9aa3ff/gendata.c">my own test data generator</a> than to fix the compiler errors.</p>

<p>The test data purports to be a series of temperature readings from weather stations. The challenge repository contains a 45 thousand line CSV file of (weather station, mean temperature) pairs. The test generator selects up to 10,000 rows from the weather station CSV and then generates N random readings for those weather stations. The temperature values are generated by the Java <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Random.html#nextGaussian--"><code>nextGaussian</code></a> standard library  function.</p>

<p>The C standard library has no nextGaussian function. The Java documentation however helpfully explains that the underlying algorithm is the <a href="https://en.wikipedia.org/wiki/Marsaglia_polar_method">Marsaglia polar method</a>. The Wikipedia page for that algorithm has C++ example code that I copy-pasted and modified to become C and fit in my program.</p>

<p>This data generator program may be the first time I got to use the trick of a growable array that starts as a null pointer and then grows as needed  by calling <code>realloc</code>. I have seen this trick plenty of times but it was good to actually use it so that it becomes part of my vocabulary.</p>

<details><summary>The <code>realloc</code> trick</summary>

<pre><code>
struct city *cities = 0;
int ncities = 0, maxcities = 0;

while(fgets(buf, sizeof(buf), stdin)) {
  if (ncities == maxcities) {
    maxcities = maxcities ? 2 * maxcities : 1;
    assert(cities = realloc(cities, maxcities * sizeof(*cities)));
  }

  /* Parse buf and store at cities[ncities++] */
}
</code></pre>

</details>

<p>The end result is a 100-line C program that only uses the standard library (and <code>getpid()</code> from <code>unistd.h</code> to seed the random number generator). All this had nothing to do with the challenge proper, but it was fun for me and very satisfying. Generating the test data should not be hard and my generator is now very easy to compile and use (no dependencies).</p>

<h2>Exploratory solutions</h2>

<p>If this had been a &#34;real&#34; question I wanted to answer for myself (&#34;what is the average of these numbers?&#34;) the first tool I would have reached for is Awk. My <a href="https://github.com/jacobvosmaer/1brc/blob/14a9fe176e448000cac9e4cf2be0398a3c29310f/awk/awk-sort">Awk solution</a> is short and took very little time to write. The flip side is that it needs 17 minutes to process 1B rows. The best Java solutions in the official contest run under 2 seconds. Still, if you add up the time to run the Awk code once and the time to write the code it&#39;s a clear winner.</p>

<details><summary>Core of my Awk solution</summary>

<pre><code>
awk -F&#39;;&#39; &#39;
  {
    if(!num[$1] || $2&gt;max[$1]) max[$1]=$2
    if(!num[$1] || $2&lt;min[$1]) min[$1]=$2
    total[$1]+=$2
    num[$1]++
  }
  END {
    for(x in total) printf(&#34;%s=%.1f/%.1f/%.1f\n&#34;, x, min[x], total[x]/num[x], max[x])
  }
&#39;
</code></pre>

</details>

<p>All statements of the form &#34;program X runs in Y seconds&#34; are of course unscientific measurements on my laptop. It is the relative differences that matter.</p>

<p>After Awk I tried Go. I am an experienced Go programmer so I can write a solution without having to fight the language. Go has a useful standard library and it&#39;s usually fast. In my <a href="https://github.com/jacobvosmaer/1brc/blob/14a9fe176e448000cac9e4cf2be0398a3c29310f/go/singlethr.go">Go solution</a> I mostly took a naive approach except for the use of <a href="https://pkg.go.dev/bufio#Reader.ReadSlice">bufio.Reader.ReadSlice</a> in an attempt to avoid spurious allocations. I still saw some garbage collector activity when I took a CPU profile so I am not sure my attempt worked.</p>

<p>Still, the Go version processes 1B rows in about 1:50 minutes and it did not take me long to write. This also &#34;matches&#34; the baseline number quoted by the original challenge. I put &#34;matches&#34; in quotes because that was 2 minutes on a different computer so it&#39;s not really comparable.. :)</p>

<h2>My first C hash map!</h2>

<p>I am used to working with languages that have a built-in <a href="https://en.wikipedia.org/wiki/Hash_table">hash map</a> data structure. Hash maps are incredibly useful. C, however, does not have hash maps built in. You have to bring or write your own.</p>

<p>In my journey of learning C, I have been able to avoid using hash maps until now. In my embedded projects I use relatively small data structures that work perfectly well as arrays with linear search. For example, a MIDI keyboard has at most 128 keys. If I want to track which keys are pressed down I need a data structure with only 128 elements. And because keys are usually pressed by fingers, the total number of pressed keys is at most 10 in practice. My MIDI instruments also do not have to handle one billion key presses as fast as possible.</p>

<p>But here, with looking up one of 10,000 records one billion times, a hash map is worthwhile. I chose to use open addressing as <a href="https://nullprogram.com/blog/2022/08/08/">suggested by Chris Wellons</a>.</p>

<p>Writing a general use hash map implementation is a lot of work, but when you are solving a specific program you only have to implement the bits you need. For example, my implementation  can only find or insert elements. I never delete elements so I don&#39;t have to implement that.</p>

<details><summary>Open addressing hash map</summary>

<pre><code>
#define EXP 16
struct city {
  char *name;
  double total, min, max;
  int num;
} cities[1 &lt;&lt; 14], *cityindex[1 &lt;&lt; EXP];
/* The size of cities is 1 &lt;&lt; 14 = 16384 which is well over
    the maximum 10000 records we need to be able to handle.
    The index is 4x bigger which gives us a hash map load
    factor of 4. */

int ncities;

/* From https://nullprogram.com/blog/2022/08/08/ */
int ht_lookup(uint64_t hash, int exp, int idx) {
  uint32_t mask = ((uint32_t)1 &lt;&lt; exp) - 1;
  uint32_t step = (hash &gt;&gt; (64 - exp)) | 1;
  return (idx + step) &amp; mask;
}

/* upsert returns the existing record  in cities for name, or
    it creates one and returns that. */
struct city *upsert(char *name) {
  uint64_t h = hash(name);
  int i = h;

  while (1) {
    i = ht_lookup(h, EXP, i);

    if (!cityindex[i]) {
      assert(ncities &lt; nelem(cities));
      cityindex[i] = cities + ncities++;
      assert(cityindex[i]-&gt;name = strdup(name));
      return cityindex[i];
    } else if (!strcmp(name, cityindex[i]-&gt;name)) {
      return cityindex[i];
    }
  }
}
</code></pre>

</details>

<p>I also don&#39;t need bring in a general purpose hash function that can resist adversarial inputs such as <a href="https://en.wikipedia.org/wiki/SipHash">SipHash</a>. The hash function only has to be &#34;good enough&#34; and I can compensate for lack of uniformity (i.e. increased chance of collissions) by increasing the load factor of my hash map.</p>

<p>My first <a href="https://github.com/jacobvosmaer/1brc/blob/14a9fe176e448000cac9e4cf2be0398a3c29310f/c/c2.c">C solution with a hash map</a> runs in close to the same time as my naive Go implementation: 2 minutes.
Apart from achieving this performance, this felt like a big win because now I feel like I can use hashmaps in C. </p>

<h2>Faster number parsing</h2>

<p>Some quick profiling on Linux with <code>perf record</code> showed that my program was spending a lot of time in <a href="https://en.cppreference.com/w/c/io/fscanf"><code>sscanf</code></a>. I was using <code>sscanf</code> to parse floating point numbers from the input. Because the input is actually fixed precision fixed point (the exponent is always 0 and there is always exactly one decimal after the <code>.</code>) you can also treat them as integers and divide by <code>10.0</code> before printing them. This reduced the running time to 1:06.</p>

<details><summary>Optimistic number parsing</summary>

<pre><code>
int64_t temp = 0, sign = 1;

/* p points to the next character we&#39;re parsing */
if (*p == &#39;-&#39;) {
  sign = -1;
  p++;
}
for (; *p &amp;&amp; *p != &#39;\n&#39;; p++)
  if (*p != &#39;.&#39;)
    temp = 10 * temp + (*p - &#39;0&#39;);
temp *= sign;
</code></pre>

</details>

<h2>My first mmap</h2>

<p>I did not look at other people&#39;s solutions in detail but I did notice that <a href="https://www.man7.org/linux/man-pages/man2/mmap.2.html"><code>mmap</code></a> (memory-mapped IO) and multi-threading seemed to be worth using. I chose to try mmap first.</p>

<p>My <a href="https://github.com/jacobvosmaer/1brc/blob/14a9fe176e448000cac9e4cf2be0398a3c29310f/c/c4.c">first attempt</a> made the program slower: 1:14 minutes. But after <a href="https://github.com/jacobvosmaer/1brc/blob/14a9fe176e448000cac9e4cf2be0398a3c29310f/c/c5.c">adapting</a> the design some more to better take advantage of the input data being there in memory, that went down to 1:04.</p>

<p>This does not seem like a big improvement. On small scale benchmarks (10M rows instead of 1B), the improvement was bigger: from 655ms to 388ms. It would be interesting to understand the discrepancy between the 10M row run times and the 1B row times. I don&#39;t have an answer right now. After writing this I tried using <code>madvise</code> with MADV_SEQUENTIAL but that did not change anything for the better.</p>

<p>I guess my lesson here is that <code>mmap</code> is at least convenient, and that micro-benchmarks (processing 10M rows instead of 1B rows) can be misleading?</p>

<h2>Multi-threading</h2>

<p>The final thing I wanted to try for now was multi-threading. To facilitate this I refactored the code that <a href="https://github.com/jacobvosmaer/1brc/blob/14a9fe176e448000cac9e4cf2be0398a3c29310f/c/c7.c#L123-L131">updates the statistics</a> to work both with a <a href="https://github.com/jacobvosmaer/1brc/blob/14a9fe176e448000cac9e4cf2be0398a3c29310f/c/c7.c#L155">single row</a> as well as with <a href="https://github.com/jacobvosmaer/1brc/blob/14a9fe176e448000cac9e4cf2be0398a3c29310f/c/c7.c#L197">aggregated data</a> for the current weather station.</p>

<p>This now runs in 0:14 minutes, which is 8 times faster than my first C-with-hash-map implementation. Woohoo!</p>

<h2>Benefits of doing this work while at Recurse</h2>

<p>I did the work I described above by myself. I could also have done it while not at Recurse. But what was nice here was that I was able  to show my work to other participants and get interesting questions, reactions and suggestions. I am very grateful for this.</p>

<h2>Conclusion and next steps</h2>

<p>Even though I did not get to participate in the original challenge, this has been a great opportunity for me to grow as a C programmer and it gave me another thing over which I could connect with my fellow Recurse participants.</p>

<p>To get an even faster solution, I may try to implement some sort of <a href="https://simdjson.org/publications/">SIMD</a> approach to make the parsing faster.. </p>
<p>Tags:
<a href="https://blog.jacobvosmaer.nl/recurse.html">recurse</a>
</p><details><summary>Edit history</summary><table>
<tbody><tr><td>2024-02-06</td><td></td><td>0020: update gendata link after bug fix</td></tr>
<tr><td>2024-02-06</td><td></td><td>0020: publish</td></tr>
<tr><td>2024-02-06</td><td></td><td>0020: improvements after proofreading</td></tr>
<tr><td>2024-02-06</td><td></td><td>Add 0020 1brc</td></tr>
</tbody></table></details><p><a href="https://blog.jacobvosmaer.nl/">Back</a></p>
</div></div>
  </body>
</html>
