<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mikeinnes.github.io/2017/08/24/cudanative.html">Original</a>
    <h1>Generic GPU Kernels</h1>
    
    <div id="readability-page-1" class="page"><div>

  <p>Julia has a library called <a href="https://github.com/JuliaGPU/CUDAnative.jl">CUDAnative</a>, which hacks the compiler to run your code on GPUs.</p>

<div><div><pre><code><span>using</span> <span>CuArrays</span><span>,</span> <span>CUDAnative</span>

<span>xs</span><span>,</span> <span>ys</span><span>,</span> <span>zs</span> <span>=</span> <span>CuArray</span><span>(</span><span>rand</span><span>(</span><span>1024</span><span>)),</span> <span>CuArray</span><span>(</span><span>rand</span><span>(</span><span>1024</span><span>)),</span> <span>CuArray</span><span>(</span><span>zeros</span><span>(</span><span>1024</span><span>))</span>

<span>function</span><span> kernel_vadd</span><span>(</span><span>out</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>)</span>
  <span>i</span> <span>=</span> <span>(</span><span>blockIdx</span><span>()</span><span>.</span><span>x</span><span>-</span><span>1</span><span>)</span> <span>*</span> <span>blockDim</span><span>()</span><span>.</span><span>x</span> <span>+</span> <span>threadIdx</span><span>()</span><span>.</span><span>x</span>
  <span>out</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>a</span><span>[</span><span>i</span><span>]</span> <span>+</span> <span>b</span><span>[</span><span>i</span><span>]</span>
  <span>return</span>
<span>end</span>

<span>@cuda</span> <span>(</span><span>1</span><span>,</span> <span>length</span><span>(</span><span>xs</span><span>))</span> <span>kernel_vadd</span><span>(</span><span>zs</span><span>,</span> <span>xs</span><span>,</span> <span>ys</span><span>)</span>

<span>@assert</span> <span>zs</span> <span>==</span> <span>xs</span> <span>+</span> <span>ys</span>
</code></pre></div></div>

<p>Is this better than writing CUDA C? At first, it’s easy to mistake this for simple syntactic convenience, but I’m convinced that it brings something fundamentally new to the table. Julia’s powerful array abstractions turn out to be a great fit for GPU programming, and it should be of interest to GPGPU hackers regardless of whether they use the language already.</p>

<h2 id="a-new-dimension">A New Dimension</h2>

<p>For numerics experts, one of Julia’s killer features is its powerful N-dimensional array support. This extends not just to high-level “vectorised” operations like broadcasting arithmetic, but also to the inner loops in the lowest-level kernels. For example, take a CPU kernel that adds two 2D arrays:</p>

<div><div><pre><code><span>function</span><span> add!</span><span>(</span><span>out</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>)</span>
  <span>for</span> <span>i</span> <span>=</span> <span>1</span><span>:</span><span>size</span><span>(</span><span>a</span><span>,</span> <span>1</span><span>)</span>
    <span>for</span> <span>j</span> <span>=</span> <span>1</span><span>:</span><span>size</span><span>(</span><span>a</span><span>,</span> <span>2</span><span>)</span>
      <span>out</span><span>[</span><span>i</span><span>,</span><span>j</span><span>]</span> <span>=</span> <span>a</span><span>[</span><span>i</span><span>,</span><span>j</span><span>]</span> <span>+</span> <span>b</span><span>[</span><span>i</span><span>,</span><span>j</span><span>]</span>
    <span>end</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>This kernel is fast, but hard to generalise across different numbers of dimensions. The change needed to support 3D arrays, for example, is small and mechanical (add an extra inner loop), but we can’t write it using normal functions.</p>

<p>Julia’s code generation enables an elegant, if slightly arcane, solution:</p>

<div><div><pre><code><span>using</span> <span>Base</span><span>.</span><span>Cartesian</span>

<span>@generated</span> <span>function</span><span> add!</span><span>(</span><span>out</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>)</span>
  <span>N</span> <span>=</span> <span>ndims</span><span>(</span><span>out</span><span>)</span>
  <span>quote</span>
    <span>@nloops</span> <span>$</span><span>N</span> <span>i</span> <span>out</span> <span>begin</span>
      <span>@nref</span><span>(</span><span>$</span><span>N</span><span>,</span> <span>out</span><span>,</span> <span>i</span><span>)</span> <span>=</span> <span>@nref</span><span>(</span><span>$</span><span>N</span><span>,</span> <span>a</span><span>,</span> <span>i</span><span>)</span> <span>+</span> <span>@nref</span><span>(</span><span>$</span><span>N</span><span>,</span> <span>b</span><span>,</span> <span>i</span><span>)</span>
    <span>end</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>The <code>@generated</code> annotation allows us to hook into Julia’s code specialisation; when the function receives matrices as input, our custom code generation will create and run a twice-nested loop. This will behave the same as our <code>add!</code> function above, but for arrays of any dimension. If you remove <code>@generated</code> you can see the internals.</p>

<div><div><pre><code><span>julia</span><span>&gt;</span> <span>using</span> <span>MacroTools</span>
<span>julia</span><span>&gt;</span> <span>add!</span><span>(</span><span>zs</span><span>,</span> <span>xs</span><span>,</span> <span>ys</span><span>)</span> <span>|&gt;</span> <span>macroexpand</span> <span>|&gt;</span> <span>MacroTools</span><span>.</span><span>prettify</span>
<span>quote</span>
    <span>for</span> <span>i_2</span> <span>=</span> <span>indices</span><span>(</span><span>out</span><span>,</span> <span>2</span><span>)</span>
        <span>nothing</span>
        <span>for</span> <span>i_1</span> <span>=</span> <span>indices</span><span>(</span><span>out</span><span>,</span> <span>1</span><span>)</span>
            <span>nothing</span>
            <span>out</span><span>[</span><span>i_1</span><span>,</span> <span>i_2</span><span>]</span> <span>=</span> <span>a</span><span>[</span><span>i_1</span><span>,</span> <span>i_2</span><span>]</span> <span>+</span> <span>b</span><span>[</span><span>i_1</span><span>,</span> <span>i_2</span><span>]</span>
            <span>nothing</span>
        <span>end</span>
        <span>nothing</span>
    <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>If you try it with, say, a seven dimensional input, you’ll be glad you didn’t have to write the code yourself.</p>

<div><div><pre><code><span>for</span> <span>i_7</span> <span>=</span> <span>indices</span><span>(</span><span>out</span><span>,</span> <span>7</span><span>)</span>
  <span>for</span> <span>i_6</span> <span>=</span> <span>indices</span><span>(</span><span>out</span><span>,</span> <span>6</span><span>)</span>
    <span>for</span> <span>i_5</span> <span>=</span> <span>indices</span><span>(</span><span>out</span><span>,</span> <span>5</span><span>)</span>
      <span>for</span> <span>i_4</span> <span>=</span> <span>indices</span><span>(</span><span>out</span><span>,</span> <span>4</span><span>)</span>
        <span>for</span> <span>i_3</span> <span>=</span> <span>indices</span><span>(</span><span>out</span><span>,</span> <span>3</span><span>)</span>
          <span>for</span> <span>i_2</span> <span>=</span> <span>indices</span><span>(</span><span>out</span><span>,</span> <span>2</span><span>)</span>
            <span>for</span> <span>i_1</span> <span>=</span> <span>indices</span><span>(</span><span>out</span><span>,</span> <span>1</span><span>)</span>
              <span>out</span><span>[</span><span>i_1</span><span>,</span> <span>i_2</span><span>,</span> <span>i_3</span><span>,</span> <span>i_4</span><span>,</span> <span>i_5</span><span>,</span> <span>i_6</span><span>,</span> <span>i_7</span><span>]</span> <span>=</span> <span>a</span><span>[</span><span>i_1</span><span>,</span> <span>i_2</span><span>,</span> <span>i_3</span><span>,</span> <span>i_4</span><span>,</span> <span>i_5</span><span>,</span> <span>i_6</span><span>,</span> <span>i_7</span><span>]</span> <span>+</span> <span>b</span><span>[</span><span>i_1</span><span>,</span> <span>i_2</span><span>,</span> <span>i_3</span><span>,</span> <span>i_4</span><span>,</span> <span>i_5</span><span>,</span> <span>i_6</span><span>,</span> <span>i_7</span><span>]</span>
<span># Some output omitted</span>
</code></pre></div></div>

<p><code>Base.Cartesian</code> is a powerful framework and has many more elegant tools, but that illustrates the core point.</p>

<p>Here’s a bonus. Addition clearly makes sense over any number of input arrays. The same tools we used for generic dimensionality can be used to generalise the number of inputs, too:</p>

<div><div><pre><code><span>@generated</span> <span>function</span><span> addn!</span><span>(</span><span>out</span><span>,</span> <span>xs</span><span>::</span><span>Vararg</span><span>{</span><span>Any</span><span>,</span><span>N</span><span>})</span> <span>where</span> <span>N</span>
  <span>quote</span>
    <span>for</span> <span>i</span> <span>=</span> <span>1</span><span>:</span><span>length</span><span>(</span><span>out</span><span>)</span>
      <span>out</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>@ncall</span> <span>$</span><span>N</span> <span>(</span><span>+</span><span>)</span> <span>j</span> <span>-&gt;</span> <span>xs</span><span>[</span><span>j</span><span>][</span><span>i</span><span>]</span>
    <span>end</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>Again, remove the <code>@generated</code> to see what’s happening:</p>

<div><div><pre><code><span>julia</span><span>&gt;</span> <span>addn!</span><span>(</span><span>zs</span><span>,</span> <span>xs</span><span>,</span> <span>xs</span><span>,</span> <span>ys</span><span>,</span> <span>ys</span><span>)</span> <span>|&gt;</span> <span>macroexpand</span> <span>|&gt;</span> <span>MacroTools</span><span>.</span><span>prettify</span>
<span>quote</span>
  <span>for</span> <span>i</span> <span>=</span> <span>1</span><span>:</span><span>length</span><span>(</span><span>out</span><span>)</span>
    <span>out</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>(</span><span>xs</span><span>[</span><span>1</span><span>])[</span><span>i</span><span>]</span> <span>+</span> <span>(</span><span>xs</span><span>[</span><span>2</span><span>])[</span><span>i</span><span>]</span> <span>+</span> <span>(</span><span>xs</span><span>[</span><span>3</span><span>])[</span><span>i</span><span>]</span> <span>+</span> <span>(</span><span>xs</span><span>[</span><span>4</span><span>])[</span><span>i</span><span>]</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>If we put this together we can make an N-dimensional, N-argument version of <code>kernel_vadd</code> on the GPU (where <code>@cuindex</code> hides the messy ND indexing):</p>

<div><div><pre><code><span>@generated</span> <span>function</span><span> kernel_vadd</span><span>(</span><span>out</span><span>,</span> <span>xs</span><span>::</span><span>NTuple</span><span>{</span><span>N</span><span>})</span> <span>where</span> <span>N</span>
  <span>quote</span>
    <span>I</span> <span>=</span> <span>@cuindex</span><span>(</span><span>out</span><span>)</span>
    <span>out</span><span>[</span><span>I</span><span>...</span><span>]</span> <span>=</span> <span>@ncall</span> <span>$</span><span>N</span> <span>(</span><span>+</span><span>)</span> <span>j</span> <span>-&gt;</span> <span>xs</span><span>[</span><span>j</span><span>][</span><span>I</span><span>...</span><span>]</span>
    <span>return</span>
  <span>end</span>
<span>end</span>

<span>@cuda</span> <span>(</span><span>1</span><span>,</span> <span>length</span><span>(</span><span>xs</span><span>))</span> <span>kernel_vadd</span><span>(</span><span>zs</span><span>,</span> <span>(</span><span>xs</span><span>,</span> <span>ys</span><span>))</span>
</code></pre></div></div>

<p>This short kernel can now add any number of arrays of any dimension; is it still just “CUDA with Julia syntax”, or is it something more?</p>

<h2 id="functions-for-nothing">Functions for Nothing</h2>

<p>Julia has more tricks up its sleeve. It automatically specialises higher-order functions, which means that if we write:</p>

<div><div><pre><code><span>function</span><span> kernel_zip2</span><span>(</span><span>f</span><span>,</span> <span>out</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>)</span>
  <span>i</span> <span>=</span> <span>(</span><span>blockIdx</span><span>()</span><span>.</span><span>x</span><span>-</span><span>1</span><span>)</span> <span>*</span> <span>blockDim</span><span>()</span><span>.</span><span>x</span> <span>+</span> <span>threadIdx</span><span>()</span><span>.</span><span>x</span>
  <span>out</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>f</span><span>(</span><span>a</span><span>[</span><span>i</span><span>],</span> <span>b</span><span>[</span><span>i</span><span>])</span>
  <span>return</span>
<span>end</span>

<span>@cuda</span> <span>(</span><span>1</span><span>,</span> <span>length</span><span>(</span><span>xs</span><span>))</span> <span>kernel_zip2</span><span>(</span><span>+</span><span>,</span> <span>zs</span><span>,</span> <span>xs</span><span>,</span> <span>ys</span><span>)</span>
</code></pre></div></div>

<p>It behaves and performs <em>exactly</em> like <code>kernel_vadd</code>; but we can use any binary function without extra code. For example, we can now subtract two arrays:</p>

<div><div><pre><code><span>@cuda</span> <span>(</span><span>1</span><span>,</span> <span>length</span><span>(</span><span>xs</span><span>))</span> <span>kernel_zip2</span><span>(</span><span>-</span><span>,</span> <span>zs</span><span>,</span> <span>xs</span><span>,</span> <span>ys</span><span>)</span>
</code></pre></div></div>

<p>Combining this with the above, we have all the tools we need to write a generic <code>broadcast</code> kernel (if you’re unfamiliar with array broadcasting, think of it as a slightly more general <code>map</code>). This is implemented in the <a href="https://github.com/FluxML/CuArrays.jl">CuArrays</a> package loaded earlier, so you can immediately write:</p>

<div><div><pre><code><span>julia</span><span>&gt;</span> <span>σ</span><span>(</span><span>x</span><span>)</span> <span>=</span> <span>1</span> <span>/</span> <span>(</span><span>1</span> <span>+</span> <span>exp</span><span>(</span><span>-</span><span>x</span><span>))</span>

<span>julia</span><span>&gt;</span> <span>σ</span><span>.</span><span>(</span><span>xs</span><span>)</span>
<span>1024</span><span>-</span><span>element</span> <span>CuArray</span><span>{</span><span>Float64</span><span>,</span><span>1</span><span>}</span><span>:</span>
 <span>0.547526</span>
 <span>0.6911</span>  
 <span>⋮</span>       
</code></pre></div></div>

<p>(Which, if we generalise <code>kernel_vadd</code> in the ways outlined above, is just an “add” using the <code>σ</code> function and a single input.)</p>

<p>There’s no hint of it in our code, but Julia will compile a custom GPU kernel to run this high-level expression. Julia will also fuse multiple broadcasts together, so if we write an expression like</p>



<p>This creates a single kernel call, with no memory allocation or temporary arrays required. Pretty cool – and well out of the reach any other system I know of.</p>

<h2 id="-derivatives-for-free">&amp; Derivatives for Free</h2>

<p>If you look at the original <code>kernel_vadd</code> above, you’ll notice that there are no types mentioned. Julia is duck typed, even on the GPU, and this kernel will work for anything that supports the right operations.</p>

<p>For example, the inputs don’t <em>have</em> to be <code>CuArray</code>s, as long as they look like arrays and can be transferred to the GPU. If we add a range of numbers to a <code>CuArray</code> like so:</p>

<div><div><pre><code><span>@cuda</span> <span>(</span><span>1</span><span>,</span> <span>length</span><span>(</span><span>xs</span><span>))</span> <span>kernel_vadd</span><span>(</span><span>xs</span><span>,</span> <span>xs</span><span>,</span> <span>1</span><span>:</span><span>1024</span><span>)</span>
</code></pre></div></div>

<p>The range <code>1:1024</code> is never actually allocated in memory; the elements <code>[1, 2, ..., 1024]</code> are computed on-the-fly as needed on the GPU. The element type of the array is also generic, and only needs to support <code>+</code>; so <code>Int + Float64</code> works, as above, but we can also use user-defined number types.</p>

<p>A powerful example is the dual number. A dual number is really a pair of numbers, like a complex number; it’s a value that carries around its own derivative.</p>

<div><div><pre><code><span>julia</span><span>&gt;</span> <span>using</span> <span>ForwardDiff</span>
<span>julia</span><span>&gt;</span> <span>f</span><span>(</span><span>x</span><span>)</span> <span>=</span> <span>x</span><span>^</span><span>2</span> <span>+</span> <span>2</span><span>x</span> <span>+</span> <span>3</span>

<span>julia</span><span>&gt;</span> <span>x</span> <span>=</span> <span>ForwardDiff</span><span>.</span><span>Dual</span><span>(</span><span>5</span><span>,</span> <span>1</span><span>)</span>
<span>Dual</span><span>{</span><span>Void</span><span>}(</span><span>5</span><span>,</span><span>1</span><span>)</span>

<span>julia</span><span>&gt;</span> <span>f</span><span>(</span><span>x</span><span>)</span>
<span>Dual</span><span>{</span><span>Void</span><span>}(</span><span>38</span><span>,</span><span>12</span><span>)</span>
</code></pre></div></div>

<p>The final <code>Dual</code> carries the value that we expect from <code>f</code> (<code>5^2 + 2*x + 3 == 38</code>), but <em>also</em> the derivative (<code>2x + 2 == 12</code>).</p>

<p>Dual numbers have an amazingly high power:simplicity ratio and are <em>really</em> fast, but are completely impractical in most languages. Julia makes it simple, and moreover, a vector of dual numbers will transparently do the derivative computation on the GPU.</p>

<div><div><pre><code><span>julia</span><span>&gt;</span> <span>xs</span> <span>=</span> <span>CuArray</span><span>(</span><span>ForwardDiff</span><span>.</span><span>Dual</span><span>.</span><span>(</span><span>1</span><span>:</span><span>1024</span><span>,</span> <span>1</span><span>))</span>

<span>julia</span><span>&gt;</span> <span>f</span><span>.</span><span>(</span><span>xs</span><span>)</span>
<span>1024</span><span>-</span><span>element</span> <span>CuArray</span><span>{</span><span>ForwardDiff</span><span>.</span><span>Dual</span><span>{</span><span>Void</span><span>,</span><span>Int64</span><span>,</span><span>1</span><span>},</span><span>1</span><span>}</span><span>:</span>
          <span>Dual</span><span>{</span><span>Void</span><span>}(</span><span>6</span><span>,</span><span>4</span><span>)</span>
         <span>Dual</span><span>{</span><span>Void</span><span>}(</span><span>11</span><span>,</span><span>6</span><span>)</span>
         <span>Dual</span><span>{</span><span>Void</span><span>}(</span><span>18</span><span>,</span><span>8</span><span>)</span>
                        <span>⋮</span>

<span>julia</span><span>&gt;</span> <span>σ</span><span>.</span><span>(</span><span>xs</span><span>)</span>
<span>1024</span><span>-</span><span>element</span> <span>CuArray</span><span>{</span><span>ForwardDiff</span><span>.</span><span>Dual</span><span>{</span><span>Void</span><span>,</span><span>Float64</span><span>,</span><span>1</span><span>},</span><span>1</span><span>}</span><span>:</span>
 <span>Dual</span><span>{</span><span>Void</span><span>}(</span><span>0.731059</span><span>,</span><span>0.196612</span><span>)</span>   
 <span>Dual</span><span>{</span><span>Void</span><span>}(</span><span>0.880797</span><span>,</span><span>0.104994</span><span>)</span>   
 <span>Dual</span><span>{</span><span>Void</span><span>}(</span><span>0.952574</span><span>,</span><span>0.0451767</span><span>)</span>  
            <span>⋮</span>                    
</code></pre></div></div>

<p>Not only is there no overhead compared to hand-writing the necessary cuda kernel for this; there’s no overhead at all! In my benchmarks, taking a derivative using dual numbers is <em>just as fast as computing only the value</em> with raw floats. Pretty impressive.</p>

<p>In machine learning frameworks, it’s common to need a “layer” for each possible activation function: <code>sigmoid</code>, <code>relu</code>, <code>tanh</code> etc. Having this trick in our toolkit means that backpropagation through <em>any</em> scalar function will work for free.</p>

<p>Overall, GPU kernels in Julia are amazingly generic, across types, dimensions and arity. Want to broadcast an integer range, a dual-number matrix, and a 6D array of floats? Go ahead, and a single, extremely fast GPU kernel will give you the result.</p>

<div><div><pre><code><span>xs</span> <span>=</span> <span>CuArray</span><span>(</span><span>ForwardDiff</span><span>.</span><span>Dual</span><span>.</span><span>(</span><span>randn</span><span>(</span><span>100</span><span>,</span><span>100</span><span>),</span> <span>1</span><span>))</span>
<span>ys</span> <span>=</span> <span>CuArray</span><span>(</span><span>randn</span><span>(</span><span>1</span><span>,</span> <span>100</span><span>,</span> <span>5</span><span>,</span> <span>5</span><span>,</span> <span>5</span><span>))</span>
<span>(</span><span>1</span><span>:</span><span>100</span><span>)</span> <span>.*</span> <span>xs</span> <span>./</span> <span>ys</span>
<span>100</span><span>×100×5×5×5</span> <span>Array</span><span>{</span><span>ForwardDiff</span><span>.</span><span>Dual</span><span>{</span><span>Void</span><span>,</span><span>Float64</span><span>,</span><span>1</span><span>},</span><span>5</span><span>}</span><span>:</span>
<span>[</span><span>:</span><span>,</span> <span>:</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>]</span> <span>=</span>
   <span>Dual</span><span>{</span><span>Void</span><span>}(</span><span>0.0127874</span><span>,</span><span>-</span><span>0.427122</span><span>)</span>  <span>…</span>   <span>Dual</span><span>{</span><span>Void</span><span>}(</span><span>-</span><span>0.908558</span><span>,</span><span>-</span><span>0.891798</span><span>)</span>
   <span>Dual</span><span>{</span><span>Void</span><span>}(</span><span>0.97554</span><span>,</span><span>-</span><span>2.56273</span><span>)</span>     <span>…</span>   <span>Dual</span><span>{</span><span>Void</span><span>}(</span><span>-</span><span>8.22101</span><span>,</span><span>-</span><span>5.35079</span><span>)</span>  
  <span>Dual</span><span>{</span><span>Void</span><span>}(</span><span>-</span><span>7.13571</span><span>,</span><span>-</span><span>4.27122</span><span>)</span>          <span>Dual</span><span>{</span><span>Void</span><span>}(</span><span>2.14025</span><span>,</span><span>-</span><span>8.91798</span><span>)</span>  
              <span>⋮</span>                     <span>⋱</span>                             
</code></pre></div></div>

<p>The full broadcasting machinery in CuArrays is <a href="https://github.com/FluxML/CuArrays.jl/blob/9a2eafa19966cf5613308bbcda1db0e1c3e95358/src/broadcast.jl#L4-L64"><em>60 lines long</em></a>. While not completely trivial, this is an incredible amount of functionality to get from this much code. CuArrays itself is under 400 source lines, while providing almost all general array operations (indexing, concatenation, permutedims etc) in a similarly generic way.</p>

<p>Julia’s ability to spit out specialised code is unprecedented, and I’m excited to see where this leads in future. For example, it would be relatively easy to build a Theano-like framework in Julia, and create specialised kernels for larger computations. Either way, I think we’ll be hearing more about Julia and GPUs as time goes on.</p>

<p><em>Full credit for the work behind this to <a href="https://github.com/maleadt">Tim Besard</a> and <a href="https://github.com/jrevels">Jarrett Revels</a>, respective authors of the amazing <a href="https://github.com/JuliaGPU/CUDAnative.jl">CUDAnative</a> and <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff</a>.</em></p>


</div></div>
  </body>
</html>
