<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.franzoni.eu/password-requirements-myths-madness/">Original</a>
    <h1>Password Requirements: Myths and Madness</h1>
    
    <div id="readability-page-1" class="page"><div>
            <!--kg-card-begin: markdown--><p>More than 11 years have passed since the venerable <a href="https://xkcd.com/936/">XKCD Password Strength strip</a>:</p>
<p><img src="https://imgs.xkcd.com/comics/password_strength.png"/></p><p>And yet this still happens nowadays on a variety of websites. Maybe it&#39;s even more frequent than 10 years ago:</p>
<p><img src="https://www.franzoni.eu/content/images/2022/12/Single_Sign_On-1.jpg" alt="Single_Sign_On-1" loading="lazy"/></p>
<p>The hilarious part for this website is that the embedded strength checker properly recognizes a good password; but then an additional policy is bolted on, just in case users were too happy. In this case, whitespace is not accepted, and only some non-alphanumeric chars are considered special.</p>
<p>I tried taking a look at those idiosyncratic password requirements, and for most policies I couldn&#39;t find a direct relation to some recommendation or compliance. So, here I&#39;m trying to dig in what the underlying reasons are for this folly.</p>
<h3 id="pleaseuseamixofuppercaseandlowercaselettersdigitsspecialcharsinyourpassword">Please use a mix of uppercase and lowercase letters, digits, special chars in your password</h3>
<p>Usual explanation: for security reasons you must choose a strong password!</p>
<p>My verdict: <strong>Misunderstanding</strong></p>
<p>The usual explanation is correct, but does not imply that a password should contain a lot of strange, hard-to-type and hard-to-remember characters. That&#39;s exact what xkcd passwords are about: a longer password with plain ascii lowercase letters can have the same <strong><a href="https://en.wikipedia.org/wiki/Entropy_(information_theory)">entropy</a></strong> as a shorter password from a larger charset.</p>
<p>If you host a web application: Enforce a password&#39;s <strong>strength</strong>, not strange user-hostile policies. There&#39;re libraries for that (e.g. <a href="https://github.com/dropbox/zxcvbn">https://github.com/dropbox/zxcvbn</a>) that work both in backend and frontend.</p>
<h3 id="youcannotusewhitespaceaccentedlettershyphensinyourpassword">You cannot use whitespace, accented letters, hyphens, [...] in your password</h3>
<p>Usual explanation: Very often there&#39;s no explanation for this, or it&#39;s something like &#34;your password contains unsafe characters&#34;.</p>
<p>My verdict: <strong>No real motivation beyond, possibly, incompetence</strong></p>
<p>This is a terrible one. You waste a lot of time at generating a &#34;strong password&#34; that complies with a website&#39;s policy, and then you discover that you could not use &#34;-&#34; in it. Or just whitespace for XKCD-style passwords.</p>
<p><strong>There&#39;s no technical reason for restricting any character from appearing in any password.</strong> The usual approach for handling a password is:</p>
<ul>
<li>take the password as a string, as the user typed it.</li>
<li>encode with a specific, well-defined encoding (e.g. utf-8)</li>
<li>add a salt (probably your favourite library will require it in its input) and use a password-derivation algorithm (pbkdf2, Argon2, whatever) to get an &#34;hashed&#34; password and save that salt+hash in your storage of choice.</li>
</ul>
<p>What I suspect is that improper escaping and/or encoding techniques are being used in a website imposing that restriction. It&#39;s a red flag.</p>
<p>Caveats:</p>
<p>If you host a web application: make sure you&#39;re correctly processing the string coming from the user, rather than adding arbitrary requirements that force the users back-and-forth from a password manager to your application.</p>
<h3 id="youcannotenterapasswordwithfewerthanxchars">You cannot enter a password with fewer than X chars</h3>
<p>Usual explanation: security! I want your password to be veeeery strong!</p>
<p>My verdict: Could be better</p>
<p>This is connected with password strength. A short password is easy to bruteforce. But, a website should aim at password strength, not at password length. If I use four unicode code points outside the <a href="https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane">BMP</a>, my password is probably very safe already. By the way, if X is 8 or something like that, it probably won&#39;t hurt, as most complexity indicators won&#39;t yield a good estimate for shorter passwords.</p>
<p>Caveats:</p>
<p>If you host a web application: clearly state the minimum length which is required for a password.</p>
<p>EDIT:</p>
<h3 id="youcannotenterapasswordwithmorethanxchars">You cannot enter a password with more than X chars</h3>
<p>Usual explanation: whew. It&#39;s too large we cannot handle it.</p>
<p>My verdict: <strong>Largely unmotivated</strong> unless X is quite large.</p>
<p>Once hashed, passwords take up the same amount of space. Restricting the maximum number of chars to a low number makes no sense and then forces people to use strange chars to get complexity right.</p>
<p>This is especially troublesome when the browser field is short, you can&#39;t see the password that you&#39;re pasting because it&#39;s masked, and you finally set a password that&#39;s not the one you expect. Then, when trying to login, the &#34;enter your password&#34; field isn&#39;t got the same limitations, and you cannot login because you&#39;re using the wrong (too-long) password.</p>
<p>Caveats:</p>
<p>EDIT:</p>
<p>If you host a web application: please allow long passwords at least 64 chars long; even 256 should pose no DoS risk whatsoever. Also, make sure that the HTML field itself is larger than the allowed password size, so you can tell the user &#34;password too long&#34; if they&#39;re pasting into it.</p>
<h3 id="youcannotpasteintothisfield">You cannot paste into this field</h3>
<p>Usual explanation: Security! I want you to actually write this and know what you&#39;re writing and write it twice in two boxes! Don&#39;t copy-paste from somewhere else!</p>
<p>My verdict: <strong>Largely unmotivated right now, and dangerous</strong>.</p>
<p>Somebody thinks that disallowing paste is a good idea so people actually need to write a password twice and they can&#39;t make typos. But this prevents using password managers, which are a Good Idea. This is a very old thing that some people thought being a good idea in the past, but I think it&#39;s not considered ideal since.... 2005?</p>
<p>If you host a web application: please allow pasting into password fields.</p>
<h3 id="youcannotshoworcopythisfield">You cannot show or copy this field</h3>
<p>Usual explanation: security! your password is For Your Hands Only. We cannot even trust your eyes.</p>
<p>My verdict: <s>Security through obscurity</s> bad idea.</p>
<p>Don&#39;t do this. While setting a password, there <strong>must</strong> be an icon to show it and make sure I&#39;m not doing mistakes. It won&#39;t be saved in plaintext anywhere else! This is <strong>especially true</strong> if you&#39;re not allowing pasting a password. Then there&#39;s no way to make sure I&#39;ve written what I wanted to write! The default masking of the password is just designed to prevent shoulder surfing.</p>
<p>If you host a web application: please allow showing what I entered when setting or entering a password anyway. Otherwise I can keep doing mistakes!</p>
<p>EDIT:</p>
<h3 id="yourpasswordhasexpired">Your password has expired</h3>
<p>Usual explanation: used to be widespread, and even required and recommended by widespread operating systems and applications.</p>
<p>My verdict: <strong>Old idea</strong></p>
<p>This once happened to be recommended, because a leak of password hashes was considered possible, and the password was in plaintext or was using weak hashes, and reuse was frequent. Nowadays, it&#39;s not recommended any more: unless there has been a known leak, if the password is properly salted and hashed, has a reasonable complexity, and hasn&#39;t been reused, there&#39;s no need fo rotation</p>
<h3 id="toomanyfailuresyouraccountislocked">Too many failures - your account is locked.</h3>
<p>Usual explanation: we don&#39;t want your account to be bruteforced</p>
<p>My verdict: <strong>Bad idea</strong> especially if &#34;too many&#34; is low, like 3 or 5, and my password is complex.</p>
<p>The idea is that you &#34;protect&#34; a user preventing their account being bruteforced. But the CIA triad includes Availablity, and you&#39;re basically opening a giant door for a DoS this way; just know somebody&#39;s username and you can lock their account. Who knows what it takes to unlock it.</p>
<p>Account locking <em>could</em> be used in 2FA contexts (requires the other factor to provoke a DoS - that&#39;s why in some cases you enter a wrong password and you&#39;re still asked for your second factor, and only at the end you fail the authentication if either was wrong), but it&#39;s still usually pointless to lock an account after a few attempts - they&#39;re too few to guess a password.</p>
<p>Caveats:</p>
<p>If you host a web application: consider using <em>temporary</em> locking with exponential, kind-of-stochastic backoff (like 10s wait the first time before being able to enter the password again, 22s the second...) after 10-20 attempts instead. If you can, it&#39;s probably useful to limit this measure to specific IPs that are attempting the bruteforce (but can be hard if it&#39;s a distributed attack).</p>
<h2 id="finalthoughts">Final thoughts</h2>
<p>I really hope that passwordless login will make some steps forward in the next years (e.g. <a href="https://passkeys.dev/">https://passkeys.dev/</a>, <a href="https://www.yubico.com/authentication-standards/fido2/">https://www.yubico.com/authentication-standards/fido2/</a>). In the meantime, I&#39;d love a &#34;password complexity api&#34; so that my browser (or password manager) can already generate the right password for a website.</p>
<h2 id="references">References</h2>
<p><a href="https://www.auditboard.com/blog/nist-password-guidelines/">https://www.auditboard.com/blog/nist-password-guidelines/</a></p>
<!--kg-card-end: markdown-->

        
	
        </div></div>
  </body>
</html>
