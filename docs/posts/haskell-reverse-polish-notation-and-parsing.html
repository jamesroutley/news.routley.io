<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mattwills.bearblog.dev/haskell-postfix/">Original</a>
    <h1>Haskell, Reverse Polish Notation, and Parsing</h1>
    
    <div id="readability-page-1" class="page"><div>
    

    
        
    

    
        

        <p>
            <i>
                <time datetime="2025-06-26T01:48Z">
                    26 Jun, 2025
                </time>
            </i>
        </p>
    

    <p>My Journey into Haskell: Building a Reverse Polish Notation Calculator
Introduction: A Side Quest</p>
<p>In my attempt to get my first paycheck, aka get a job, I have led myself down a fascinating rabbit hole into functional programming, mathematical notation, and parsing theory. This is the story of how I discovered Haskell, tackled reverse Polish notation, and learned about monadic parsing along the way.</p>
<p>My journey began when my friend Jackson Slipock encouraged me to explore functional programming. After a quick Google search, I landed on Haskell as my first functional language. Around the same time, during a networking call about job opportunities, someone mentioned reverse Polish notation. The idea struck me: why not build a reverse Polish notation calculator in Haskell?</p>
<p>What could have been a simple weekend project became weeks of deep learning. This blog chronicles that journey, drawing heavily from Graham Hutton&#39;s excellent book Programming in Haskell, which I highly recommend. What you&#39;re reading is my attempt to learn something deeply, implement it myself, and then teach it to others.</p>
<p>From Imperative to Functional: A Mental Shift</p>
<p>Coming from a background in Python and C—languages I&#39;m comfortable with after a couple years of experience—Haskell represented a fundamental shift in thinking. Both Python and C are imperative languages that share similar concepts: loops, mutable data, global state, and variables that can be modified. The transition between them never required a major mental adjustment.</p>
<p>Functional programming throws all of that out the window.</p>
<p>In Haskell, functions are mathematical abstractions. Given the same input, a function will always produce the same output. There are no global variables, and data is immutable once created. Instead of writing a series of statements that accomplish a task, functional programming encourages building expressions that naturally compose together.</p>
<p>This is why Haskell has no loops. Instead, it pushes you to think recursively, building solutions through expressions that elegantly combine to produce results.</p>
<p>Why Choose Functional Programming?</p>
<p>The benefits became clear as I progressed: functional code tends to be more concise, easier to understand, and less prone to bugs. Haskell excels at representing complex ideas in just a few lines of code, and it makes translating mathematical concepts into working programs remarkably straightforward. As someone who majored in math and genuinely enjoys it, this felt incredibly satisfying.</p>
<p>These concepts might seem abstract at first—I certainly struggled with them initially. But they become clearer with practice, and keeping them in mind helps when encountering Haskell code for the first time. My first real &#34;aha!&#34; moment came when implementing merge sort, but before we get there, let&#39;s explore some things that were new to me as a first time functional programmer.</p>
<p>Recursive Types: Building Natural Numbers from Scratch</p>
<p>Let me start with a classic example that illustrates Haskell&#39;s elegance. Here&#39;s how you can define natural numbers (0, 1, 2, 3, 4...) recursively:</p>
<div><pre><span></span><span>data</span><span> </span><span>Nat</span><span> </span><span>=</span><span> </span><span>Zero</span><span> </span><span>|</span><span> </span><span>Succ</span><span> </span><span>Nat</span>
</pre></div>
<p>That&#39;s it. This simple line captures the mathematical definition of natural numbers: zero is the base case, and every other natural number is the successor of another natural number. To convert this abstract representation into something the computer can work with:</p>
<div><pre><span></span><span>eval</span><span> </span><span>::</span><span> </span><span>Nat</span><span> </span><span>-&gt;</span><span> </span><span>Int</span>
<span>eval</span><span> </span><span>Zero</span><span> </span><span>=</span><span> </span><span>0</span>
<span>eval</span><span> </span><span>(</span><span>Succ</span><span> </span><span>m</span><span>)</span><span> </span><span>=</span><span> </span><span>1</span><span> </span><span>+</span><span> </span><span>eval</span><span> </span><span>m</span>
</pre></div>
<p>So 0 becomes Zero, 1 becomes Succ Zero, 2 becomes Succ (Succ Zero), and so on. This direct translation from mathematical definition to code is something you simply can&#39;t achieve as elegantly in languages like Python or C.</p>
<p>Lambda Functions:</p>
<p>I want to implement merge sort but to get there we must get through some basics in Haskell. The first topic are lambda functions which are anonymous functions that take arguments and perform operations</p>
<div><pre><span></span><span>-- \arg1 arg2 -&gt; do something with the arguments</span>
<span>\</span><span>x</span><span> </span><span>y</span><span> </span><span>-&gt;</span><span> </span><span>x</span><span> </span><span>+</span><span> </span><span>y</span><span>  </span><span>-- adds two arguments</span>
<span>\</span><span>x</span><span> </span><span>-&gt;</span><span> </span><span>x</span><span>        </span><span>-- identity function</span>
</pre></div>
<p>Curried Functions</p>
<p>One of Haskell&#39;s most important concepts is currying, which becomes essential when working with functions like map. Since functions in Haskell are mathematical abstractions, passing multiple arguments requires a clever approach.</p>
<p>Instead of passing tuples (which becomes cumbersome), Haskell uses curried functions:</p>
<div><pre><span></span><span>add</span><span> </span><span>::</span><span> </span><span>Int</span><span> </span><span>-&gt;</span><span> </span><span>Int</span><span> </span><span>-&gt;</span><span> </span><span>Int</span>
<span>add</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>=</span><span> </span><span>x</span><span> </span><span>+</span><span> </span><span>y</span>
</pre></div>
<p>This function appears to take two integers and return their sum, but it&#39;s actually more sophisticated. We can rewrite it to reveal what&#39;s really happening:</p>
<div><pre><span></span><span>add</span><span> </span><span>::</span><span> </span><span>Int</span><span> </span><span>-&gt;</span><span> </span><span>(</span><span>Int</span><span> </span><span>-&gt;</span><span> </span><span>Int</span><span>)</span>
<span>add</span><span> </span><span>x</span><span> </span><span>=</span><span> </span><span>\</span><span>y</span><span> </span><span>-&gt;</span><span> </span><span>x</span><span> </span><span>+</span><span> </span><span>y</span>
</pre></div>
<p>The add function takes one argument and returns a new function. When you call add 5, you get a function that adds 5 to whatever you pass it. Then add 5 7 applies that &#34;add 5&#34; function to 7, resulting in 12. We can go a step deeper and using lambdas, we can write</p>
<div><pre><span></span><span>add</span><span> </span><span>::</span><span> </span><span>Int</span><span> </span><span>-&gt;</span><span> </span><span>Int</span><span> </span><span>-&gt;</span><span> </span><span>Int</span>
<span>add</span><span> </span><span>=</span><span> </span><span>\</span><span>x</span><span> </span><span>-&gt;</span><span> </span><span>(</span><span>\</span><span>y</span><span> </span><span>-&gt;</span><span> </span><span>x</span><span> </span><span>+</span><span> </span><span>y</span><span>)</span>
</pre></div>
<p>This clearly shows that curried functions are functions that return other functions allowing us to have functions that take multiple arguments while still following the rules of functional programming.</p>
<p>The Beauty of Merge Sort in Haskell</p>
<p>This demonstrates several key Haskell concepts: recursion with lists (working toward a base case by processing the head and recursively handling the tail), and pattern matching (different behavior for empty versus non-empty lists).</p>
<p>Let&#39;s consider the map function (a curried function)  which applies a function to each element in a list recursively.</p>
<div><pre><span></span><span>map</span><span> </span><span>::</span><span> </span><span>(</span><span>a</span><span> </span><span>-&gt;</span><span> </span><span>b</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>[</span><span>a</span><span>]</span><span> </span><span>-&gt;</span><span> </span><span>[</span><span>b</span><span>]</span>
<span>map</span><span> </span><span>_</span><span> </span><span>[]</span><span> </span><span>=</span><span> </span><span>[]</span>
<span>map</span><span> </span><span>f</span><span> </span><span>(</span><span>x</span><span>:</span><span>xs</span><span>)</span><span> </span><span>=</span><span> </span><span>f</span><span> </span><span>x</span><span> </span><span>:</span><span> </span><span>map</span><span> </span><span>f</span><span> </span><span>xs</span>
</pre></div>
<p>This is a typical way to iterate over lists in Haskell. You have a base case of the empty list were you return some value then the recursive case where you use pattern matching to get the first element of the list at the top of the list. These tools will be used in merge sort.</p>
<p>Once I grasped these fundamentals, implementing merge sort revealed Haskell&#39;s true elegance:</p>
<div><pre><span></span><span>halve</span><span> </span><span>::</span><span> </span><span>[</span><span>a</span><span>]</span><span> </span><span>-&gt;</span><span> </span><span>([</span><span>a</span><span>],</span><span> </span><span>[</span><span>a</span><span>])</span>
<span>halve</span><span> </span><span>xs</span><span> </span><span>=</span><span> </span><span>(</span><span>take</span><span> </span><span>(</span><span>length</span><span> </span><span>xs</span><span> </span><span>`</span><span>div</span><span>`</span><span> </span><span>2</span><span>)</span><span> </span><span>xs</span><span>,</span><span> </span><span>drop</span><span> </span><span>(</span><span>length</span><span> </span><span>xs</span><span> </span><span>`</span><span>div</span><span>`</span><span> </span><span>2</span><span>)</span><span> </span><span>xs</span><span>)</span>

<span>merge</span><span> </span><span>::</span><span> </span><span>Ord</span><span> </span><span>a</span><span> </span><span>=&gt;</span><span> </span><span>[</span><span>a</span><span>]</span><span> </span><span>-&gt;</span><span> </span><span>[</span><span>a</span><span>]</span><span> </span><span>-&gt;</span><span> </span><span>[</span><span>a</span><span>]</span>
<span>merge</span><span> </span><span>[]</span><span> </span><span>ys</span><span> </span><span>=</span><span> </span><span>ys</span>
<span>merge</span><span> </span><span>xs</span><span> </span><span>[]</span><span> </span><span>=</span><span> </span><span>xs</span>
<span>merge</span><span> </span><span>(</span><span>x</span><span>:</span><span>xs</span><span>)</span><span> </span><span>(</span><span>y</span><span>:</span><span>ys</span><span>)</span>
<span>  </span><span>|</span><span> </span><span>x</span><span> </span><span>&lt;</span><span> </span><span>y</span><span>     </span><span>=</span><span> </span><span>x</span><span> </span><span>:</span><span> </span><span>merge</span><span> </span><span>xs</span><span> </span><span>(</span><span>y</span><span>:</span><span>ys</span><span>)</span>
<span>  </span><span>|</span><span> </span><span>otherwise</span><span> </span><span>=</span><span> </span><span>y</span><span> </span><span>:</span><span> </span><span>merge</span><span> </span><span>(</span><span>x</span><span>:</span><span>xs</span><span>)</span><span> </span><span>ys</span>

<span>msort</span><span> </span><span>::</span><span> </span><span>Ord</span><span> </span><span>a</span><span> </span><span>=&gt;</span><span> </span><span>[</span><span>a</span><span>]</span><span> </span><span>-&gt;</span><span> </span><span>[</span><span>a</span><span>]</span>
<span>msort</span><span> </span><span>[]</span><span> </span><span>=</span><span> </span><span>[]</span>
<span>msort</span><span> </span><span>xs</span><span> </span><span>=</span><span> </span><span>merge</span><span> </span><span>(</span><span>msort</span><span> </span><span>left</span><span>)</span><span> </span><span>(</span><span>msort</span><span> </span><span>right</span><span>)</span>
<span>  </span><span>where</span><span> </span><span>(</span><span>left</span><span>,</span><span> </span><span>right</span><span>)</span><span> </span><span>=</span><span> </span><span>halve</span><span> </span><span>xs</span>
</pre></div>
<p>The msort function captures the exact algorithm described in textbooks. There&#39;s no index tracking, no confusing logic—just clean, recursive structure that mirrors the mathematical definition perfectly. This is when it hit me that Haskell and the rules of functional programming lead to easy,  clean,  concise code.</p>
<p>Understanding Reverse Polish Notation</p>
<p>Now let&#39;s dive into reverse Polish notation (RPN), also called postfix notation. This system eliminates the need for parentheses in mathematical expressions.</p>
<p>In standard notation:</p>
<ul>
<li>2 + 3 * 4 equals 14 (due to order of operations)</li>
<li>(2 + 3) * 4 equals 20</li>
</ul>
<p>In reverse Polish notation:</p>
<ul>
<li>2 3 4 * + equals 14</li>
<li>2 3 + 4 * equals 20</li>
</ul>
<p>RPN is fascinating because it maps perfectly onto a stack-based evaluation model. The rule is simple: when you encounter a number, push it onto the stack; when you encounter an operator, pop two numbers, apply the operation, and push the result back. Continue until one item remains.</p>
<p>This made RPN popular in early calculators and trading systems where speed mattered. For computers, it&#39;s compelling because evaluation requires only one simple rule, with no need to track precedence or parentheses.</p>
<p>My First RPN Evaluator (And Its Limitations)</p>
<p>Postfix expression evaluation seemed like an easy thing to implement in Haskell and I was hopeful that I would be able to bang this out. My initial implementation worked but had limitations:</p>
<div><pre><span></span><span>evalRpn</span><span> </span><span>::</span><span> </span><span>String</span><span> </span><span>-&gt;</span><span> </span><span>Stack</span><span> </span><span>Int</span><span> </span><span>-&gt;</span><span> </span><span>Stack</span><span> </span><span>Int</span>
<span>evalRpn</span><span> </span><span>[]</span><span> </span><span>stack</span><span> </span><span>=</span><span> </span><span>stack</span>
<span>evalRpn</span><span> </span><span>(</span><span>x</span><span>:</span><span>xs</span><span>)</span><span> </span><span>stack</span>
<span>  </span><span>|</span><span> </span><span>isDigit</span><span> </span><span>x</span><span> </span><span>=</span><span> </span><span>evalRpn</span><span> </span><span>xs</span><span> </span><span>((</span><span>digitToInt</span><span> </span><span>x</span><span>)</span><span> </span><span>:</span><span> </span><span>stack</span><span>)</span>
<span>  </span><span>|</span><span> </span><span>otherwise</span><span> </span><span>=</span><span> </span><span>evalRpn</span><span> </span><span>xs</span><span> </span><span>((</span><span>applyOp</span><span> </span><span>x</span><span> </span><span>(</span><span>pop2</span><span> </span><span>stack</span><span>))</span><span> </span><span>:</span><span> </span><span>drop</span><span> </span><span>2</span><span> </span><span>stack</span><span>)</span>
</pre></div>
<p>This handled single-digit numbers but failed on inputs like 12 35 + because it couldn&#39;t parse multi-digit numbers. I knew I could do better and decided to build a proper parser.</p>
<p>Learning from an Expert</p>
<p>At this point, I knew my RPN implementation wasn&#39;t optimal. So I took a chance and emailed Graham Hutton, author of Programming in Haskell. To my amazement, this seasoned professional took time to help a complete novice. Here&#39;s his elegant solution:</p>
<div><pre><span></span><span>import</span><span> </span><span>Data.Char</span>

<span>type</span><span> </span><span>Expr</span><span> </span><span>=</span><span> </span><span>[</span><span>Symb</span><span>]</span>
<span>data</span><span> </span><span>Symb</span><span> </span><span>=</span><span> </span><span>Num</span><span> </span><span>Int</span><span> </span><span>|</span><span> </span><span>Add</span><span> </span><span>|</span><span> </span><span>Mul</span>
<span>  </span><span>deriving</span><span> </span><span>Show</span>

<span>parse</span><span> </span><span>::</span><span> </span><span>String</span><span> </span><span>-&gt;</span><span> </span><span>Expr</span>
<span>parse</span><span> </span><span>=</span><span> </span><span>map</span><span> </span><span>p</span>

<span>p</span><span> </span><span>::</span><span> </span><span>Char</span><span> </span><span>-&gt;</span><span> </span><span>Symb</span>
<span>p</span><span> </span><span>&#39;+&#39;</span><span> </span><span>=</span><span> </span><span>Add</span>
<span>p</span><span> </span><span>&#39;*&#39;</span><span> </span><span>=</span><span> </span><span>Mul</span>
<span>p</span><span> </span><span>n</span><span> </span><span>|</span><span> </span><span>isDigit</span><span> </span><span>n</span><span> </span><span>=</span><span> </span><span>Num</span><span> </span><span>(</span><span>digitToInt</span><span> </span><span>n</span><span>)</span>

<span>eval</span><span> </span><span>::</span><span> </span><span>Expr</span><span> </span><span>-&gt;</span><span> </span><span>[</span><span>Int</span><span>]</span><span> </span><span>-&gt;</span><span> </span><span>[</span><span>Int</span><span>]</span>
<span>eval</span><span> </span><span>[]</span><span> </span><span>s</span><span> </span><span>=</span><span> </span><span>s</span>
<span>eval</span><span> </span><span>(</span><span>Add</span><span> </span><span>:</span><span> </span><span>e</span><span>)</span><span> </span><span>(</span><span>n</span><span>:</span><span>m</span><span>:</span><span>s</span><span>)</span><span> </span><span>=</span><span> </span><span>eval</span><span> </span><span>e</span><span> </span><span>(</span><span>m</span><span>+</span><span>n</span><span> </span><span>:</span><span> </span><span>s</span><span>)</span>
<span>eval</span><span> </span><span>(</span><span>Mul</span><span> </span><span>:</span><span> </span><span>e</span><span>)</span><span> </span><span>(</span><span>n</span><span>:</span><span>m</span><span>:</span><span>s</span><span>)</span><span> </span><span>=</span><span> </span><span>eval</span><span> </span><span>e</span><span> </span><span>(</span><span>m</span><span>*</span><span>n</span><span> </span><span>:</span><span> </span><span>s</span><span>)</span>
<span>eval</span><span> </span><span>(</span><span>Num</span><span> </span><span>n</span><span> </span><span>:</span><span> </span><span>e</span><span>)</span><span> </span><span>s</span><span> </span><span>=</span><span> </span><span>eval</span><span> </span><span>e</span><span> </span><span>(</span><span>n</span><span> </span><span>:</span><span> </span><span>s</span><span>)</span>
</pre></div>
<p>This solution is beautifully compact and works perfectly for expressions like 23+ or 23* (assuming no spaces and single-digit numbers). His use of a new data type was clean and the way I probably should have been thinking about this question the whole time. This was clearly superior to my previous implementation however, it doesn&#39;t handle spacing or multi-digit numbers. I wanted to extend this while preserving its clean structure.</p>
<p>Discovering Monads Through a Simple Example</p>
<p>To improve this solution, I needed introduce some parsing. My brother has talked about top-down recursive parsers so I decided to look into creating a parse trees in Haskell. I did not end up making any parse trees but this sent me on the jounery to make a parsers in Haskell. In order make a parser I first needed to understand monads—one of Haskell&#39;s most powerful  (and confusing) concepts. Monads allow computations to carry additional context, such as the possibility of failure, input/output operations, or parsing state.</p>
<p>Let me illustrate with a simple example: adding two numbers, but failing if their sum exceeds 10:</p>
<div><pre><span></span><span>addLess10</span><span> </span><span>::</span><span> </span><span>Int</span><span> </span><span>-&gt;</span><span> </span><span>Int</span><span> </span><span>-&gt;</span><span> </span><span>Maybe</span><span> </span><span>Int</span>
<span>addLess10</span><span> </span><span>x</span><span> </span><span>y</span>
<span>  </span><span>|</span><span> </span><span>x</span><span> </span><span>+</span><span> </span><span>y</span><span> </span><span>&lt;=</span><span> </span><span>10</span><span> </span><span>=</span><span> </span><span>Just</span><span> </span><span>(</span><span>x</span><span> </span><span>+</span><span> </span><span>y</span><span>)</span><span>  </span>
<span>  </span><span>|</span><span> </span><span>otherwise</span><span>   </span><span>=</span><span> </span><span>Nothing</span>
</pre></div>
<p>The Maybe type can be either Just a (success with value a) or Nothing (failure). Now, suppose I want to sum a list using this rule, failing if any intermediate sum exceeds 10:</p>
<div><pre><span></span><span>addList</span><span> </span><span>::</span><span> </span><span>[</span><span>Int</span><span>]</span><span> </span><span>-&gt;</span><span> </span><span>Maybe</span><span> </span><span>Int</span>
<span>addList</span><span> </span><span>[]</span><span>       </span><span>=</span><span> </span><span>Nothing</span>
<span>addList</span><span> </span><span>[</span><span>x</span><span>]</span><span>      </span><span>=</span><span> </span><span>Just</span><span> </span><span>x</span>
<span>addList</span><span> </span><span>(</span><span>x</span><span>:</span><span>y</span><span>:</span><span>xs</span><span>)</span><span> </span><span>=</span><span> </span><span>addLess10</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>&gt;&gt;=</span><span> </span><span>\</span><span>res</span><span> </span><span>-&gt;</span><span> </span><span>addList</span><span> </span><span>(</span><span>res</span><span> </span><span>:</span><span> </span><span>xs</span><span>)</span>
</pre></div>
<p>The key is the bind operator &gt;&gt;=, which chains computations together. If any step returns Nothing, the entire computation fails. Here&#39;s how the Maybe monad instance makes this work:</p>
<div><pre><span></span><span>instance</span><span> </span><span>Monad</span><span> </span><span>Maybe</span><span> </span><span>where</span>
<span>  </span><span>return</span><span> </span><span>x</span><span> </span><span>=</span><span> </span><span>Just</span><span> </span><span>x</span>
<span>  </span><span>Nothing</span><span> </span><span>&gt;&gt;=</span><span> </span><span>_</span><span> </span><span>=</span><span> </span><span>Nothing</span>
<span>  </span><span>Just</span><span> </span><span>x</span><span>  </span><span>&gt;&gt;=</span><span> </span><span>f</span><span> </span><span>=</span><span> </span><span>f</span><span> </span><span>x</span>
</pre></div>
<p>If we encounter Nothing, the bind operator short-circuits. If we get Just x, it applies the function to x. This automatic error handling is what makes monads powerful.</p>
<p>The same logic becomes cleaner with do notation:</p>
<div><pre><span></span><span>addList</span><span> </span><span>::</span><span> </span><span>[</span><span>Int</span><span>]</span><span> </span><span>-&gt;</span><span> </span><span>Maybe</span><span> </span><span>Int</span>
<span>addList</span><span> </span><span>[]</span><span>       </span><span>=</span><span> </span><span>Nothing</span>
<span>addList</span><span> </span><span>[</span><span>x</span><span>]</span><span>      </span><span>=</span><span> </span><span>Just</span><span> </span><span>x</span>
<span>addList</span><span> </span><span>(</span><span>x</span><span>:</span><span>y</span><span>:</span><span>xs</span><span>)</span><span> </span><span>=</span><span> </span><span>do</span>
<span>  </span><span>res</span><span> </span><span>&lt;-</span><span> </span><span>addLess10</span><span> </span><span>x</span><span> </span><span>y</span>
<span>  </span><span>addList</span><span> </span><span>(</span><span>res</span><span> </span><span>:</span><span> </span><span>xs</span><span>)</span>
</pre></div>
<p>The do notation is just syntactic but it clearly gives us the ability to chain multiple statements together and build larger monadic types. This will serve us well when we start to do parsing.</p>
<p>The Foundation: Parser Type Definition</p>
<p>The true power of monads becomes apparent when building parsers. We can create small, primitive parsers and compose them into larger, more sophisticated ones. For example, we might create a parser that consumes exactly x spaces, or one that reads multi-digit numbers. The key is starting with a solid foundation.</p>
<p>First, we need to define what a parser actually is. The parsing type below and the all the primitives come from Programming in Haskell, here&#39;s our base type:</p>
<div><pre><span></span><span>newtype</span><span> </span><span>Parser</span><span> </span><span>a</span><span> </span><span>=</span><span> </span><span>P</span><span> </span><span>(</span><span>String</span><span> </span><span>-&gt;</span><span> </span><span>[(</span><span>a</span><span>,</span><span> </span><span>String</span><span>)])</span>

<span>parse</span><span> </span><span>::</span><span> </span><span>Parser</span><span> </span><span>a</span><span> </span><span>-&gt;</span><span> </span><span>String</span><span> </span><span>-&gt;</span><span> </span><span>[(</span><span>a</span><span>,</span><span> </span><span>String</span><span>)]</span>
<span>parse</span><span> </span><span>(</span><span>P</span><span> </span><span>p</span><span>)</span><span> </span><span>inp</span><span> </span><span>=</span><span> </span><span>p</span><span> </span><span>inp</span>
</pre></div>
<p>Let&#39;s break this down: A Parser a is essentially a wrapper around a function that takes a String and returns a list of tuples. Each tuple contains a result of type a and the remaining unparsed String. If the list is empty, parsing fails. If the list contains results, parsing succeeds.</p>
<p>We write the parse function as an easy way to unwrap our parser and apply it to actual input.</p>
<p>Our First Parser: Reading Single Characters</p>
<p>Now we can build our first concrete parser:</p>
<div><pre><span></span><span>item</span><span> </span><span>::</span><span> </span><span>Parser</span><span> </span><span>Char</span>
<span>item</span><span> </span><span>=</span><span> </span><span>P</span><span> </span><span>(</span><span>\</span><span>inp</span><span> </span><span>-&gt;</span><span> </span><span>case</span><span> </span><span>inp</span><span> </span><span>of</span><span> </span>
<span>    </span><span>[]</span><span> </span><span>-&gt;</span><span> </span><span>[]</span>
<span>    </span><span>(</span><span>x</span><span>:</span><span>xs</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>[(</span><span>x</span><span>,</span><span> </span><span>xs</span><span>)])</span>
</pre></div>
<p>This parser reads exactly one character from the input. If we call parse item &#34;thing&#34;, we get [(&#39;t&#39;, &#34;hing&#34;)]—the first character and the rest of the string. We simply pop off the first element of the string.</p>
<p>The Parser Monad: Enabling Composition</p>
<p>Here’s where things get really confusing but where the magic happens. To chain parsers together effectively, we need to define how the Parser type works as a monad:</p>
<div><pre><span></span><span>instance</span><span> </span><span>Monad</span><span> </span><span>Parser</span><span> </span><span>where</span>
<span>   </span><span>-- (&gt;&gt;=) :: Parser a -&gt; (a -&gt; Parser b) -&gt; Parser b</span>
<span>   </span><span>p</span><span> </span><span>&gt;&gt;=</span><span> </span><span>f</span><span> </span><span>=</span><span> </span><span>P</span><span> </span><span>(</span><span>\</span><span>inp</span><span> </span><span>-&gt;</span><span> </span><span>case</span><span> </span><span>parse</span><span> </span><span>p</span><span> </span><span>inp</span><span> </span><span>of</span>
<span>                           </span><span>[]</span><span> </span><span>-&gt;</span><span> </span><span>[]</span>
<span>                           </span><span>[(</span><span>v</span><span>,</span><span> </span><span>out</span><span>)]</span><span> </span><span>-&gt;</span><span> </span><span>parse</span><span> </span><span>(</span><span>f</span><span> </span><span>v</span><span>)</span><span> </span><span>out</span><span>)</span>
</pre></div>
<p>The bind operator (&gt;&gt;=) is confusing at first, but understanding its type signature helps. It takes:</p>
<ol>
<li>A parser that produces values of type a</li>
<li>A function that takes an a and returns a parser producing b</li>
<li>Returns a new parser that produces b</li>
</ol>
<p>Here&#39;s what happens step by step:</p>
<ol>
<li>Run the first parser p on the input</li>
<li>If it fails (returns []), the whole computation fails</li>
<li>If it succeeds, extract the value v and remaining input out</li>
<li>Apply function f to v to get a new parser</li>
<li>Run that new parser on the remaining input out
This allows us to sequence parsing operations while automatically handling the threading of remaining input through each step.</li>
</ol>
<p>Practical Example: Conditional Character Parsing</p>
<p>With our monad instance, we can now write much cleaner parser code:</p>
<div><pre><span></span><span>sat</span><span> </span><span>::</span><span> </span><span>(</span><span>Char</span><span> </span><span>-&gt;</span><span> </span><span>Bool</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Parser</span><span> </span><span>Char</span>
<span>sat</span><span> </span><span>f</span><span> </span><span>=</span><span> </span><span>do</span>
<span>    </span><span>x</span><span> </span><span>&lt;-</span><span> </span><span>item</span>
<span>    </span><span>if</span><span> </span><span>f</span><span> </span><span>x</span><span> </span><span>then</span><span> </span><span>return</span><span> </span><span>x</span><span> </span><span>else</span><span> </span><span>empty</span>
</pre></div>
<p>This parser reads a character and only succeeds if that character satisfies the predicate f. Notice how clean this is:</p>
<ul>
<li>x &lt;- item extracts the character that item parsed</li>
<li>We can work directly with x without worrying about tuples or remaining input</li>
<li>The monad handles all the bookkeeping automatically</li>
</ul>
<p>Without monads, we&#39;d have to manually manage the parsing state, check for failures, and thread the remaining input through each operation. The monadic interface abstracts away this complexity, letting us focus on the parsing logic itself.</p>
<p>The Power of Composition</p>
<p>This foundation enables us to build increasingly sophisticated parsers by combining simpler ones. Want to parse digits? Spaces? Multi-digit numbers? Each becomes a matter of composing our basic building blocks using the monadic interface.</p>
<p>The beauty is that each parser remains focused on its specific task, while the monad instance handles the complex orchestration of sequencing, error handling, and state management. This is why monadic parsing is so powerful—it gives us both expressiveness and composability without sacrificing clarity.</p>
<p>As we&#39;ll see, this approach scales beautifully from simple character-level parsing all the way up to complete expression parsers, all built from the same fundamental building blocks.</p>
<p>Building a Robust Parser with Monadic Parsing</p>
<p>Using monadic parsing techniques, I built a more flexible parser that handles spaces and multi-digit numbers while maintaining the elegance of Hutton&#39;s design:</p>
<div><pre><span></span><span>type</span><span> </span><span>Expr</span><span> </span><span>=</span><span> </span><span>[</span><span>Symb</span><span>]</span>
<span>data</span><span> </span><span>Symb</span><span> </span><span>=</span><span> </span><span>Num</span><span> </span><span>Int</span><span> </span><span>|</span><span> </span><span>Add</span><span> </span><span>|</span><span> </span><span>Mul</span>
<span>  </span><span>deriving</span><span> </span><span>Show</span>

<span>symb</span><span> </span><span>::</span><span> </span><span>Parser</span><span> </span><span>Symb</span>
<span>symb</span><span> </span><span>=</span><span> </span><span>do</span>
<span>  </span><span>n</span><span> </span><span>&lt;-</span><span> </span><span>token</span><span> </span><span>natural</span>
<span>  </span><span>return</span><span> </span><span>(</span><span>Num</span><span> </span><span>n</span><span>)</span>
<span>  </span><span>&lt;|&gt;</span><span> </span><span>do</span>
<span>    </span><span>symbol</span><span> </span><span>&#34;+&#34;</span>
<span>    </span><span>return</span><span> </span><span>Add</span>
<span>  </span><span>&lt;|&gt;</span><span> </span><span>do</span>
<span>    </span><span>symbol</span><span> </span><span>&#34;*&#34;</span>
<span>    </span><span>return</span><span> </span><span>Mul</span>

<span>p</span><span> </span><span>::</span><span> </span><span>Parser</span><span> </span><span>Expr</span>
<span>p</span><span> </span><span>=</span><span> </span><span>some</span><span> </span><span>symb</span>

<span>eval</span><span> </span><span>::</span><span> </span><span>Expr</span><span> </span><span>-&gt;</span><span> </span><span>[</span><span>Int</span><span>]</span><span> </span><span>-&gt;</span><span> </span><span>[</span><span>Int</span><span>]</span>
<span>eval</span><span> </span><span>[]</span><span> </span><span>s</span><span> </span><span>=</span><span> </span><span>s</span>
<span>eval</span><span> </span><span>(</span><span>Add</span><span> </span><span>:</span><span> </span><span>e</span><span>)</span><span> </span><span>(</span><span>n</span><span>:</span><span>m</span><span>:</span><span>s</span><span>)</span><span> </span><span>=</span><span> </span><span>eval</span><span> </span><span>e</span><span> </span><span>(</span><span>m</span><span>+</span><span>n</span><span> </span><span>:</span><span> </span><span>s</span><span>)</span>
<span>eval</span><span> </span><span>(</span><span>Mul</span><span> </span><span>:</span><span> </span><span>e</span><span>)</span><span> </span><span>(</span><span>n</span><span>:</span><span>m</span><span>:</span><span>s</span><span>)</span><span> </span><span>=</span><span> </span><span>eval</span><span> </span><span>e</span><span> </span><span>(</span><span>m</span><span>*</span><span>n</span><span> </span><span>:</span><span> </span><span>s</span><span>)</span>
<span>eval</span><span> </span><span>(</span><span>Num</span><span> </span><span>n</span><span> </span><span>:</span><span> </span><span>e</span><span>)</span><span> </span><span>s</span><span> </span><span>=</span><span> </span><span>eval</span><span> </span><span>e</span><span> </span><span>(</span><span>n</span><span> </span><span>:</span><span> </span><span>s</span><span>)</span>
</pre></div>
<p>This implementation keeps Hutton&#39;s clear evaluation logic while using monadic parsing to handle complex input. The symb parser reads natural numbers or operators, converting them into symbolic expressions. The eval function interprets the postfix expression using a stack, just as before.</p>
<p>What I love about this solution is its natural behavior: it reads the longest valid expression it can process. If the input has sufficient structure, it evaluates successfully; otherwise, it fails gracefully. The code cleanly separates parsing from evaluation and handles complexity without becoming messy.</p>
<p>Reflections on the Journey</p>
<p>This final version represents several weeks of learning, struggling, and ultimately succeeding. I learned Haskell from scratch, grappled with monads and parsing, and created something genuinely useful. Most importantly, I learned from a world-class teacher who was generous enough to guide a beginner.</p>
<p>My biggest takeaway is this: Haskell is a beautiful and expressive language that rewards the investment of time and effort. The concepts you learn become part of how you think about programming, even in other languages. Having excellent resources like Programming in Haskell and access to knowledgeable mentors makes an enormous difference.</p>
<p>For future projects, I&#39;ll remember to lean on authoritative sources and structured learning. Sometimes you don&#39;t know what you don&#39;t know, and sometimes all it takes to get unstuck is sending one thoughtful email.
Thanks for following my journey. I hope it encourages you to take your own side quests, learn deeply, and share what you discover along the way.</p>


    

    
        

        
            


        
    


  </div></div>
  </body>
</html>
