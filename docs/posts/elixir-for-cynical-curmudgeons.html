<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wiki.alopex.li/ElixirForCynicalCurmudgeons">Original</a>
    <h1>Elixir for cynical curmudgeons</h1>
    
    <div id="readability-page-1" class="page"><div id="wikipage"><div id="TOC">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#elixir">Elixir</a></li>
<li><a href="#the-sales-pitch">The sales pitch</a></li>
<li><a href="#i-hate-sales-pitches">I hate sales pitches</a></li>
<li><a href="#the-epiphany">The epiphany</a></li>
<li><a href="#maniacal-laughter"><em>maniacal laughter</em></a></li>
</ul>
</div>


<p>This is an attempt to wrap my head around using the Phoenix web
framework for a small project. However, it got too long so I broke it
into two parts. This is part 1 and just talks about the Elixir language,
part 2 is <a href="https://blog.plover.com/Unix/PhoenixForCynicalCurmudgeons" title="Go to wiki page">PhoenixForCynicalCurmudgeons</a> but that is
still WIP. However, I realized that I have a number of <em>attitude
issues</em> that make Phoenix hard to start getting into, so I’m going
to attempt to write about it in a way that makes sense to me.</p>
<p>My issues are:</p>
<ul>
<li>I don’t actually know Erlang too well in practice</li>
<li>I don’t actually know web programming too well in practice</li>
<li>I don’t actually like web programming much</li>
<li>I’ve spent the last 10 years being the go-to person to fix every
random technical thing that could screw up, and am thus something of a
pessimist and a control freak</li>
<li>The world is burning down around us and none of us can do anything
about it</li>
</ul>
<p>So, if you share some of these issues, maybe this doc will be useful
to you. This will not teach you Elixir or Phoenix, but it may help you
figure out how to <em>think</em> about them. This is a supplement to the
<a href="https://elixir-lang.org/getting-started/introduction.html">official
docs</a>, not a replacement, so it won’t try to cover the things that
those docs explain well.</p>
<p>Disclaimer: As far as I know this is correct, but there’s probably
details I’m missing or misinterpreting. Don’t take this as gospel. I am
not an expert, I am merely a determined idiot.</p>
<p>Last updated in August 2023. It uses Elixir 1.14, Erlang/OTP 25 and
Phoenix 1.7.7.</p>

<p>Really what I want to get a handle on is the web framework Phoenix.
But Phoenix is written in the Elixir programming language, so to tackle
Phoenix, we must tackle Elixir.</p>

<p>I’m not going to spend too long singing the praises of The Erlang/OTP
Platform, I assume if you’re here then you already know enough to be
interested. Long story short, it gives you multiprocessing via
communicating independent processes, makes almost all state immutable so
these independent processes can <em>only</em> talk with each other via
messages, and gives you bunches of tools for handling the failure and
restarting of processes, as well as inspecting and changing code at
runtime. It runs on a VM called BEAM, because for various reasons the
conventional Unix process model can’t actually give the same level of
robustness and introspection that you can get with a sandboxed virtual
machine. Erlang itself is a wild programming language made in the late
80’s that started with Prolog with a sprinkling of Lisp here and there
and turned it into a language like nothing else on this earth. Elixir is
a much newer and more comfy-looking programming language that started in
2012 and also compiles to the BEAM VM, offering good compatibility with
Erlang code.</p>
<p>I love Erlang but have never really used it <a href="https://erlang-in-anger.com/">In Anger</a>; the biggest thing I’ve
written with it is a card game. I have dipped in and out of it many
times over the years, but most of the time I just don’t have a lot of
use cases where it’s obviously the best choice over something else. It
has always seemed like the ideal tool for non-trivial web applications,
but I never really had a need to write that. But I recently had an idea
I want to try to write for an actual web service that’s not a static
generated site or a tiny mono-purpose API, so I figured I’d take a good
stab at using Erlang or Elixir for it.</p>
<p>Elixir at first blush looks like they just took Erlang and re-skinned
it to look like Ruby. However, Elixir offers some modest but meaningful
functional upgrades over Erlang:</p>
<ul>
<li>Nested modules. Erlang has a flat module namespace, you can make a
module named <code>foo</code> but you can’t put a module named
<code>bar</code> into it and get <code>foo/bar</code> or
<code>foo.bar</code>. This is Fine but not ideal, you generally end up
faking the nesting and making a module named <code>foo_bar</code>
anyway. Erlang doesn’t care, but it also doesn’t help you.</li>
<li>Better strings. Erlang strings are by default a linked list of
characters, which probably made a lot more sense for a telecoms
infrastructure language in the late 1980’s than it does for a web
language in the 2020’s. This still actually works half decently because
a lot of I/O can be done with lists of substrings rather than
creating/modifying existing strings, but it’s still not ideal. But
Erlang also has bit-strings which are immutable arrays of arbitrary
bytes, and you can stuff ASCII or UTF-8 data into those and use them as
strings too. In Elixir the defaults are flipped: strings are immutable
arrays by default, and if you need to talk to Erlang code that expects
the linked-list type of string you can create them. It still keeps the
scatter-list-y I/O model though, so constructing a new string out of a
bunch of pieces with a format function or such won’t allocate a new
buffer and copy the strings into it, it will just produce a list of
packed string fragments. Elixir strings also assume UTF-8 by default;
Erlang bit-strings assume no particular encoding.</li>
<li>Nicer structure syntax. Erlang is sort of weird ’cause for the
longest time structs were not first-class objects, they were just tuples
with macros for creating and accessing them. Erlang is a very dynamic
language that tends to say that abstraction is done by functions and
interfaces, and if you need to rummage around in the guts of your data
structures then you should. However, its creators really didn’t want to
add hashtables everywhere as a general-purpose structure the way that
Python and Ruby do, so they just sat and mulled on the problem. They did
eventually add real structures/records, which are much nicer wrappers
around tuples, but they’re still a little tacked-on. Elixir’s maps are
basically the same as Erlang’s structures (records, whatever), but more
convenient.</li>
<li>Bigger stdlib. Erlang’s stdlib is pretty nice, Elixir’s adds to it.
’Nuff said.</li>
<li>Better macros. Erlang has actually fairly powerful macros but they
are, frankly, a cleaned up C preprocessor. You can define constants,
include files, do some basic ifdef stuff, shit like that. You
<em>can</em> get significantly fancier, but it’s pretty clear that
you’re usually not intended to; the reference docs barely tell you
anything about it.</li>
</ul>

<p>However, there’s also a bunch of cognitive bumps for me to overcome
when trying to learn Elixir:</p>
<ul>
<li>All the syntactic sugar. Elixir looks like Ruby, which is quite
loosey-goosey and malleable, and Elixir is even more malleable. There’s
a <em>lot</em> of bits in the first half of the tutorial that say “you
can also write it like this…” and gives you some uncertain thing with
less punctuation involved At first glance, it <em>feels</em> like it
tries excessively hard to make things pretty rather than good, and the
way Phoenix writes code makes that worse. It’s easy to feel like it’s
all just sugar rather than content.</li>
<li>Bigger language, period. Erlang is very appealingly simple; there’s
a small number of constructs that then fit together pretty well.
Sometimes it’s a little clunky, but if you look at some Erlang code then
there’s not much fanciness outside of how message and processes
interact; it generally just does what it says it does. Elixir has a lot
more going on at many different levels; why do we need that?</li>
<li>Big complicated project structure. You <em>can</em> make an Elixir
project that’s just a single script or a directory with a small
collection of files, but the docs prefer to plunge you into its build
tool <code>mix</code>, designing an OTP application, how
<code>GenServer</code> works, etc. It’s all significantly more
complicated to pick up and get going with <code>mix</code> than with
<code>cargo</code>, <code>zig</code> or other tools I’m more familiar
with. Some of it like OTP and <code>GenServer</code> are already
familiar from Erlang, but in that case what does Elixir add over just
using Erlang again?</li>
<li>Tries fairly hard to look hip. The presentation for both Elixir and
Phoenix is quite shiny, it has lots of very friendly introductions that
tell you how great it is, all the <em>features</em> it has, and how it’s
totally worth all this extra complexity to get into it and do everything
with its awesome new paradigm. This makes me automatically distrust it.
It’s honestly not <em>that</em> bad, and in my more forgiving moments I
have a hard time looking at the Elixir website and docs and
realistically saying that I could do better, but I still end up feeling
like there’s still a certain amount of hype to machete your way through
before you get to the content. See the “cynical curmudgeon” part; the
harder something tries to convince me of <em>anything</em>, the more I
expect it to suck. If someone just takes Erlang, slaps on a friendly
Ruby-ish syntax and a few modest upgrades and touts it as the Next Big
Thing, do I <em>really</em> trust anything they have to say?</li>
</ul>
<p>So I’ve looked at Elixir before but this has kinda tended to turn me
off, even with Elixir’s benefits. I can <em>get</em> all those benefits
in Erlang, it just takes a little more work. Why should I bother
learning a new language with ten million special syntax frills, all
sorts of domain-specific tooling, a new stdlib, etc? There’s nothing
fundamentally wrong with that stuff, but most of the time it’s really
not my jam. I much prefer starting off with a small, simple system and
then incrementally adding bits in a controlled fashion…
<em>especially</em> when I want to make a reliable, robust, complex
system with an unfamiliar tool in an unfamiliar problem domain. If I’m
going to use something big and complicated then it needs to make it
<strong>worth</strong> it – Rust crosses this threshold for me, for
example, because it does things other languages literally cannot.
Meanwhile, Elixir starts off feeling like it wants to hold your hand a
lot. Erlang is a pretty small, conservative language where, despite its
1980’s warts, you write what you mean and that’s what you get. In
contrast, it’s easy to get the impression that Elixir is trying to be
Magical and thus actually just hiding all the real work. Yes, this is
kinda bitchy, but I’m not here to rant. I’ve looked at Elixir reasonably
seriously several times before, and every time it left a bad taste in my
mouth and I went “whatever, I’ll just use Erlang instead”. So in writing
this I wanted to look at <em>why</em> I felt that way.</p>
<p>This is the root of my curmudgeoniness: Magic is never worth it. 99%
of the time, Magic breaks. And when it does, and someone inevitably asks
me to help fix it, I do it by getting out the machete and chopping out
all the happy shiny convenient shit until you can see what is actually
going on. And when you dig through the Magic and try to figure out what
the hell is actually going on, most of the time it’s either stupid and
broken by design, or it’s not very magical at all and you’re just like
“why didn’t you just say this in the first place?” This has happened to
me again and again in all sorts of places; here’s a list of real
examples from work I’ve run into in the last couple years alone:</p>
<ul>
<li>A distributed service does Magical Autodiscovery to find other nodes
on the network without needing a central index? It just scans for UDP
ports that are willing to talk to it, starting with a Well-Known Port
Number and trying each in sequence until it thinks it’s found
everything.</li>
<li>A proprietary monitoring GUI for that service which Magically lets
you inspect it remotely? It just uses an existing open-source program
that collects that information and ships it to you over websocket.</li>
<li>A website Magically presents a live-updating display without needing
a Full Front-End Javascript Framework? It’s just an <code>iframe</code>
that is refreshed every five seconds.</li>
<li>A communication protocol you want to implement that provides a set
of RPC messages you need to receive and respond to and it all Magically
clicks together? Nope, turns out there’s a lot of undocumented
assumptions about what messages are sent when and in what order, and you
have to poke at the client and massage your server’s output until you
manage to figure out what it actually expects.</li>
</ul>
<p>Over and over again, it turns out that <strong>there is no such thing
as Magic</strong>, and anyone who says otherwise is skimming over
details that will bite you in the ass later on. This is <em>fine</em>
for many purposes, because 90% of programs are small hacks and one-off
tools and so “later” very seldom actually happens. But in those cases,
why are you using a big, complicated language like Elixir in the first
place, especially when there’s already the more minimal Erlang sitting
right there waiting to be picked up?</p>
<p>It’s a pretty tough sell.</p>

<p>But I still felt like Elixir deserved a good hard go, so I shrugged
off my prejudice and started digging. I read the tutorials for Elixir
and Phoenix, trusted that the people who were sensible enough to build a
web system atop Erlang are sensible enough to know what they’re doing,
and tried to put the pieces together. When gradually, bit by bit, I
realized what was going on and everything made much more sense. Here’s
the trick about Elixir: Elixir is actually a Lisp.</p>
<p><strong>Elixir is actually a Lisp.</strong></p>
<p>It doesn’t have the parenthesis, but it does have most of the things
things that make Common Lisp very flexible, very powerful, very dynamic,
and very metaprogramming-heavy. I don’t actually <em>enjoy</em> Common
Lisp itself very much ’cause it <a href="https://wiki.alopex.li/CommonLispThoughts">comes with a lot of
baggage</a> and doesn’t have most of the things that have been developed
since 2000 or so to make programming less painful, but Elixir
<em>does</em>. Elixir also has all of Erlang’s goodness still present:
true immutability, pervasive pattern matching, extensive symbolic
programming, optional/gradual typing, etc. It doesn’t do this alone of
course; as I said, Erlang has a fair dollop of Lisp in its genetics
already. BEAM is already probably 75% of a Lisp runtime in terms of how
easy it is to introspect, modify, dig into and poke around with, but
Erlang doesn’t do a whole lot to take advantage of that directly until
you start actually getting deep into the guts of the runtime libraries,
which is not the easiest thing to do. Elixir on the other hand takes
advantage of all that introspective power right from the start and runs
with it, and runs with it <em>hard</em>. It’s relatively hard to find
Erlang programs and stuff written about Erlang that really takes you
through all the various tools and how to put them together into
something awesome; there’s a very solid handful of books and docs and
such, but apart from that people don’t seem to <em>talk</em> about
Erlang very much, or if they do it’s the same “Intro to OTP” content
every single time. Meanwhile the Phoenix web framework appears to be a
pretty good and honestly quite interesting example of how to write
Elixir programs and libraries in the large, so you can dig into
something Real and Complex and see how it can all be put together.</p>
<p>I bitched about all of Elixir’s syntactic sugar and how much
special-case nonsense it appears to do. For example, here’s a basic
hello world in Elixir:</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span>defmodule</span> <span>Hello</span> <span>do</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>  <span>def</span> greet() <span>do</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>    <span>IO</span><span>.</span>puts(<span>&#34;Hello world!&#34;</span>)</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>  <span>end</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span>end</span></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span>Hello</span><span>.</span>greet()</span></code></pre></div>
<p>So far so good. <code>defmodule</code> defines a module, and it
consists of function/method definitions starting with
<code>def ... do ... end</code>, nothing particularly surprising. Now,
here’s a snippet from the default Phoenix project template for my wiki
test project, Otter:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span>defmodule</span> <span>OtterWeb</span><span>.</span><span>Router</span> <span>do</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>  <span>use</span> <span>OtterWeb</span>, <span>:router</span></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>  pipeline <span>:browser</span> <span>do</span></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>    plug <span>:accepts</span>, [<span>&#34;html&#34;</span>]</span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>    plug <span>:fetch_session</span></span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a>    plug <span>:fetch_live_flash</span></span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a>    plug <span>:put_root_layout</span>, <span>html:</span> {<span>OtterWeb</span><span>.</span><span>Layouts</span>, <span>:root</span>}</span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a>    plug <span>:protect_from_forgery</span></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a>    plug <span>:put_secure_browser_headers</span></span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a>  <span>end</span></span>
<span id="cb2-12"><a href="#cb2-12" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" tabindex="-1"></a>  pipeline <span>:api</span> <span>do</span></span>
<span id="cb2-14"><a href="#cb2-14" tabindex="-1"></a>    plug <span>:accepts</span>, [<span>&#34;json&#34;</span>]</span>
<span id="cb2-15"><a href="#cb2-15" tabindex="-1"></a>  <span>end</span></span>
<span id="cb2-16"><a href="#cb2-16" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" tabindex="-1"></a>  scope <span>&#34;/&#34;</span>, <span>OtterWeb</span> <span>do</span></span>
<span id="cb2-18"><a href="#cb2-18" tabindex="-1"></a>    pipe_through <span>:browser</span></span>
<span id="cb2-19"><a href="#cb2-19" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" tabindex="-1"></a>    get <span>&#34;/&#34;</span>, <span>PageController</span>, <span>:home</span></span>
<span id="cb2-21"><a href="#cb2-21" tabindex="-1"></a>  <span>end</span></span>
<span id="cb2-22"><a href="#cb2-22" tabindex="-1"></a></span>
<span id="cb2-23"><a href="#cb2-23" tabindex="-1"></a>  scope <span>&#34;/api&#34;</span>, <span>OtterWeb</span> <span>do</span></span>
<span id="cb2-24"><a href="#cb2-24" tabindex="-1"></a>    pipe_through <span>:api</span></span>
<span id="cb2-25"><a href="#cb2-25" tabindex="-1"></a>  <span>end</span></span>
<span id="cb2-26"><a href="#cb2-26" tabindex="-1"></a></span>
<span id="cb2-27"><a href="#cb2-27" tabindex="-1"></a>  <span>if</span> <span>Application</span><span>.</span>compile_env(<span>:otter</span>, <span>:dev_routes</span>) <span>do</span></span>
<span id="cb2-28"><a href="#cb2-28" tabindex="-1"></a>    <span>import</span> <span>Phoenix</span><span>.</span><span>LiveDashboard</span><span>.</span><span>Router</span></span>
<span id="cb2-29"><a href="#cb2-29" tabindex="-1"></a></span>
<span id="cb2-30"><a href="#cb2-30" tabindex="-1"></a>    scope <span>&#34;/dev&#34;</span> <span>do</span></span>
<span id="cb2-31"><a href="#cb2-31" tabindex="-1"></a>      pipe_through <span>:browser</span></span>
<span id="cb2-32"><a href="#cb2-32" tabindex="-1"></a></span>
<span id="cb2-33"><a href="#cb2-33" tabindex="-1"></a>      live_dashboard <span>&#34;/dashboard&#34;</span>, <span>metrics:</span> <span>OtterWeb</span><span>.</span><span>Telemetry</span></span>
<span id="cb2-34"><a href="#cb2-34" tabindex="-1"></a>      forward <span>&#34;/mailbox&#34;</span>, <span>Plug</span><span>.</span><span>Swoosh</span><span>.</span><span>MailboxPreview</span></span>
<span id="cb2-35"><a href="#cb2-35" tabindex="-1"></a>    <span>end</span></span>
<span id="cb2-36"><a href="#cb2-36" tabindex="-1"></a>  <span>end</span></span>
<span id="cb2-37"><a href="#cb2-37" tabindex="-1"></a><span>end</span></span></code></pre></div>
<p>What the hell is going on here? <code>use</code> is fairly normal,
it’s just a module import that calls a callback to initialize stuff in
that module. (It isn’t, but that’s what you think at first.) But this
module has <code>scope</code> blocks and <code>pipeline</code> blocks,
they’re right under the top-level <code>defmodule</code>, they contain a
bunch of weird <code>plug</code> or <code>pipe_through</code>
statements… this isn’t Elixir, it’s some weird special-purpose
domain-specific language that Elixir just… happens to have built into it
somehow? Why does Elixir let a library write all this special custom
syntax? Is this just part of the language somehow because Phoenix is its
flagship software? Hang on, there’s an <code>if</code> expression at the
end of the module that looks like it’s run at compile time… can you even
<em>do</em> that? The language tutorial never heckin’ does that!</p>
<p>Buckle up, we’re in for a <em>trip</em>. ’Cause here’s the trick:
Elixir actually has only <em>one</em> syntax for calling a function or a
macro: <code>foo(arg1, arg2, arg3)</code>. That’s all. Every function or
macro call will turn into that format, and that’s the format the
documentation will show you too. So let’s see how the various layers of
syntactic sugar work with that basis…</p>
<p>First, because Elixir likes Ruby (and for pretty good reasons), you
can generally ditch the parens around a function call and just write it
as <code>foo arg1, arg2, arg3</code>. Ok, fine, that’s fairly
sensible.</p>
<p>Now if you have a function that takes a variable number of keyword
arguments, you just make the last function arg an assoc list, a list of
key-value pairs where the key is an atom. (Resist the curmudgeonly urge
to get all “hashtables and arrays are better” here, these linked lists
are generally short with good memory locality, it’s Fine.) So if you
want a function with a variable numbers of params you can define it as
<code>foo(arg1, params)</code> and call it as
<code>foo arg1, [{:arg2, something}, {:arg3, something_else}]</code>.
(<code>:foo</code> is what Lisp calls a symbol, Erlang/Elixir calls an
atom, and most of the rest of the world calls an interned string. They
are immutable, uniquely identified by name and only by name, and compile
down to integers.)</p>
<p>Since assoc lists are pretty common, there’s a piece of syntactic
sugar for them that looks more dictionary-like:
<code>[key1: val1, key2: val2]</code> is equivalent to
<code>[{:key1, val1}, {:key2, val2}]</code>. Moving the colon makes my
brain fritz a little bit but the result looks nice. So you can call a
function and give it an assoc list as an argument just with
<code>foo arg1, [arg2: something, arg3: something_else]</code>.</p>
<p>That’s nice, but really as long as our assoc list is the last thing
being passed to the function we don’t need the outer brackets of the
list either, so sure, just make it so you can call
<code>foo arg1, arg2: something, arg3: something_else</code>.</p>
<p>Are you yet thinking “oh no… they <em>wouldn’t</em>”? I have news for
you: <strong>oh yes they would</strong>.</p>
<p>This only works in some places and I still haven’t figured out quite
all the rules, but <code>do</code>, followed by a newline, followed by
<code>end</code>, is in fact sugar for an assoc list. So if you
write:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>foo thing <span>do</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>  <span>10</span></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a><span>end</span></span></code></pre></div>
<p>then it is equivalent to actually calling
<code>foo thing, do: 10</code>. Or rather,
<code>foo(thing, [{:do, 10}])</code>. And what do you know, if
<code>foo</code> is not a function but a macro, then the syntax is
exactly the same but the contents of the assoc list it gets passed is
not the evaluated expression between the <code>do</code> and
<code>end</code>, it’s a syntax tree. Made, naturally, of lists and
tuples and atoms.</p>
<p>So going back to our weird Phoenix module with all the new block
types? All those blocks that are written in the format of
<code>magical_keyword value do ... end</code>? All macros.
<code>scope</code> is a macro. <code>pipeline</code> is a macro. So
<code>defmodule</code> can contain any kind of macro call? …wait, that
means…</p>
<p><code>if</code> is a macro.</p>
<p><code>def</code> is a macro.</p>
<p><code>defmodule</code> is a macro.</p>
<p>It’s all macros. It’s ALL MACROS! ALL THE WAY DOWN! AAAAAAAAAA
AHAHAHAHAHHAHAAAA!</p>

<p>This is not done naively though, oh no! Elixir takes <em>other</em>
things from Lisp-y origins as well. Wonderful things!</p>
<p>For example, a string is written <code>&#34;foo&#34;</code>. Sensible enough.
Making an old-style Erlang list-y string is <code>~c&#34;foo&#34;</code>, sure.
Making a regex is <code>~r/foo/</code>, ok, so the <code>~</code> is
general syntax for “string-ish thing”, the way that <code>\x</code> in a
string in most languages is general syntax for “some special character”.
Not quite! Elixir calls it a “sigil”, but you can define your own sigils
just by writing a function that takes a string and does something with
it and returns some data, and <a href="https://elixir-lang.org/getting-started/sigils.html#custom-sigils">bam,
it works</a>.</p>
<p>Common Lisp calls these “reader macros”. They’re <a href="https://lisper.in/reader-macros">rather a pain in the ass</a>
though, Elixir’s version is a much nicer shortcut for most of the things
that you would actually want to use them for.</p>
<p>So the Elixir creators haven’t just stolen macros and homoiconic
syntax from Lisp, they’ve rummaged deeper into “what made Lisp awesome”
and pulled out other bits too. And also stolen liberally from other
languages! There’s an equivalent to Rust’s <code>dbg!()</code> macro
that prints an expression’s code and its result, then goes further and
optionally breaks into the interactive debugger, <code>pry</code>, which
appears more juiced up than Erlang’s debugger. They’ve stolen
<code>|&gt;</code> expression-pipeline syntax from the Haskell/ML world.
They’ve taken a lot of the interactive documentation functions that make
Python so easy to poke around in from the REPL. You know, all the
<em>good</em> shit.</p>
<p>Also note that while we have like 4 layers of syntactic sugar between
<code>foo([{:do, 3}])</code> and <code>foo do 3 end</code>, they are
truly <em>layers</em>. Each one fits neatly inside the previous one with
no overlapping edge cases or hazardous interactions. They’re not
separate features that you have to jig-saw together in some intricate
manner where everything explodes if you overlook something. It’s always
just a function/macro call that takes an assoc list as its last
parameter. (There actually is one sharp edge,
<code>do\n ...\n end</code> vs <code>do: ...\n</code>, but don’t harsh
my groove.)</p>
<p>Oh, then there’s <code>use</code>. You know how I said
“<code>use</code> is fairly normal, it’s just a module import that calls
a callback to initialize stuff”, and then noted that the truth was more
complicated and moved on? The truth is <em>way</em> more interesting:
<code>use Thing, option: something</code> imports the module
<code>Thing</code> like <code>require</code> does, then calls
<code>Thing.__using__(option: something)</code>. The <em>trick</em> is
that the <code>__using__()</code> function usually isn’t called for its
side effects, though that might happen occasionally. In fact, if you
read the docs more carefully it never says that <code>__using__()</code>
is a function at all, just “a callback”. Quite often,
<code>__using__()</code> is in fact a macro. A macro that will
<em>generate and return some code</em>, which is then <em>spliced into
your module</em> where you wrote the <code>use</code> statement. So you
can write a <code>Thing.__using__()</code> macro such that
<code>use Thing</code> actually expands into
<code>require Thing1; require Thing2; def some_cool_method() ...; use SomeOtherThing</code>.
<code>use</code> doesn’t import a module’s definitions into your
module’s namespace, it gives that module permission to
<strong>generate</strong> arbitrary code in your module’s namespace. So
be very aware when reading or writing Elixir code: whenever you see
<code>use</code> invoked, it’s actually some kind of turbo-macro that is
probably defining a bunch of exciting new things for you!</p>
<p>There’s probably more, but I haven’t found it yet. I’m having too
much fun to dig for many more details. Because, I’ll say it, Elixir is a
<em>better</em> Lisp than Common Lisp or Scheme. Writing either of those
comes with a lot of problems you have to solve to get started compared
to, say, Clojure or Fennel: libs, package manager, FFI, build system,
how to distribute applications, etc. No Lisp I know of has had the kind
of robustness and multiprocessing power that BEAM can give you (unless
it was <a href="https://lfe.io/">already written for BEAM</a> ).
Erlang’s pattern-matching is top-tier, and Elixir inherits all of that.
Erlang has a bunch of libs and tools for monitoring and poking around
inside a running application, and Elixir uses them and adds more. And so
on.</p>
<p>And that’s the thing about Elixir’s version of magic: none of it is
actually hidden. They don’t try to pretend it’s magic, they tell you
exactly how it works in the first half of the tutorial! It just, you
know, takes a bit of work to actually <em>absorb</em> what they’re
telling you and figure out how it all interacts. Most of the structures
that form the guts of the runtime are made out of lists and tuples and
atoms, which feels weird to a Rust person who is used to structs and
types which are not interchangeable and never public unless you know for
sure they’re supposed to be. Erlang and Elixir are just like, go ahead,
poke around, make changes, break shit! Because unlike Common Lisp with
its state baked in manually to an image, everything can be automatically
restored to a clean slate when you tell it to starting from a
declarative project specification. Elixir hides nothing behind “magic”.
It <em>wants</em> you to poke around in its magical bits. Yeah you’ll
break shit, here, have the tools you need to make sure that shit doesn’t
break in production. Just use them!</p>
<p>It’s been a long time since a programming language made me this
happy.</p><div id="categoryList"><ul><li><a href="https://blog.plover.com/_category/computer">computer</a></li><li><a href="https://blog.plover.com/_category/programming">programming</a></li><li><a href="https://blog.plover.com/_category/writing">writing</a></li></ul></div></div></div>
  </body>
</html>
