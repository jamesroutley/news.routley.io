<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://signia.tldraw.dev/docs/what-are-signals">Original</a>
    <h1>What Are Signals?</h1>
    
    <div id="readability-page-1" class="page"><div><p>Let&#39;s start with an extremely broad definition:</p><p><strong>A signal</strong> is a value that changes over time and whose change events can trigger side effects.</p><p><strong>A signals library</strong>, or framework, provides a cohesive set of tools for managing these changing values and their side effects in an automated way that ensures consistency.
This allows developers to spend less time thinking about how updates are propagated through a system and more time focusing on what those updates should be.
It also prevents whole classes of easy-to-introduce-but-hard-to-find bugs that can occur due to accidental mismanagement of derived state or side effects.</p><hr/><p>There are many well-known software patterns matching this description, but that we wouldn&#39;t normally call &#39;signals&#39;. For example, using the above definition you could argue that <a href="https://reactjs.org/" target="_blank" rel="noopener noreferrer">React</a> is a signals library specifically for UI view trees.</p><p>This might seem like a trivial comparison to draw, but it&#39;s a useful one to explore because <strong>signals are pure uncut reactive values</strong>, and frameworks like React incorporate the same fundamental concepts into more involved APIs.</p><p>To illustrate, let&#39;s break signals down to understand their component parts.</p><h2 id="breaking-signals-down">Breaking signals down<a href="#breaking-signals-down" aria-label="Direct link to Breaking signals down" title="Direct link to Breaking signals down">​</a></h2><p>Signals libraries or frameworks are typically based on three primitives:</p><ul><li><p>Root values</p><p>A root value is any state value that is updated directly, normally in response to external events, e.g. user input.</p><div><p><span><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</p><p>In a modern idiomatic React app, <code>useState</code> or <code>useReducer</code> are for managing root values.</p></div><p>A common good practice is to make sure you don&#39;t store the same piece of information in multiple root values, so that each &#39;fact&#39; in your system has a single source of truth. Otherwise, you risk getting into a situation where the values are out of sync.</p></li><li><p>Derived values</p><p>A derived value is any state value that is computed exclusively by looking at other state values.</p><div><p><span><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</p><p>In a React component, the rendered tree is a derived value. Any intermediate data you compute during a component&#39;s render function is also derived, e.g. a filtered list of todo items in a todo app.</p></div><p>A key component of signals is that derived values are <em>automatically</em> recomputed when their dependencies change. This is a huge win over manually managing derived values, which is error-prone and can lead to subtle hard-to-find bugs.</p></li><li><p>Side effects</p><p>A side effect is any process which runs in response to a state change event.</p><div><p><span><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</p><p>In React, updating the DOM is a side effect which is managed by React itself. It also provides <code>useEffect</code> for executing custom side effects in response to changing values.</p></div></li></ul><p>Let&#39;s look at a simple Todo list React app to see how these primitives map to code.</p><div><div><pre tabindex="0"><code><span><span>function</span><span> </span><span>TodoApp</span><span>(</span><span>)</span><span> </span><span>{</span><span></span><br/></span><span><span>    </span><span>const</span><span> </span><span>[</span><span>todos</span><span>,</span><span> setTodos</span><span>]</span><span> </span><span>=</span><span> </span><span>useState</span><span>&lt;</span><span>Todo</span><span>[</span><span>]</span><span>&gt;</span><span>(</span><span>[</span><span>{</span><span> text</span><span>:</span><span> </span><span>&#39;buy milk&#39;</span><span>,</span><span> completed</span><span>:</span><span> </span><span>false</span><span> </span><span>}</span><span>]</span><span>)</span><span></span><br/></span><span><span>    </span><span>const</span><span> </span><span>[</span><span>showCompleted</span><span>,</span><span> setShowCompleted</span><span>]</span><span> </span><span>=</span><span> </span><span>useState</span><span>(</span><span>false</span><span>)</span><span></span><br/></span><span><span></span><br/></span><span><span>    </span><span>const</span><span> filteredTodos </span><span>=</span><span> </span><span>useMemo</span><span>(</span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>        </span><span>return</span><span> todos</span><span>.</span><span>filter</span><span>(</span><span>(</span><span>todo</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>!</span><span>todo</span><span>.</span><span>completed </span><span>||</span><span> showCompleted</span><span>)</span><span></span><br/></span><span><span>    </span><span>}</span><span>,</span><span> </span><span>[</span><span>todos</span><span>,</span><span> showCompleted</span><span>]</span><span>)</span><span></span><br/></span><span><span></span><br/></span><span><span>    </span><span>return</span><span> </span><span>(</span><span></span><br/></span><span><span>        </span><span>&lt;</span><span>&gt;</span><span></span><br/></span><span><span>            </span><span>{</span><span>/* ... */</span><span>}</span><span></span><br/></span><span><span>            </span><span>&lt;</span><span>TodoList todos</span><span>=</span><span>{</span><span>filteredTodos</span><span>}</span><span> </span><span>/</span><span>&gt;</span><span></span><br/></span><span><span>        </span><span>&lt;</span><span>/</span><span>&gt;</span><span></span><br/></span><span><span>    </span><span>)</span><span></span><br/></span><span><span></span><span>}</span><br/></span></code></pre></div></div><p><img src="https://blog.plover.com/img/what-are-signals-0-light.png" alt="How signals work"/><img src="https://blog.plover.com/img/what-are-signals-0-dark.png" alt="How signals work"/></p><h2 id="the-signals-design-space">The Signals Design Space<a href="#the-signals-design-space" aria-label="Direct link to The Signals Design Space" title="Direct link to The Signals Design Space">​</a></h2><p>On top of this foundation there exists a wide spectrum of features and design decisions that each signals implementation may approach differently. Here&#39;s just a few:</p><h3 id="how-do-you-access-the-value-of-a-signal">How do you access the value of a signal?<a href="#how-do-you-access-the-value-of-a-signal" aria-label="Direct link to How do you access the value of a signal?" title="Direct link to How do you access the value of a signal?">​</a></h3><ul><li>Are the signals explicitly wrapped?</li><li>Does a compiler do the unwrapping on your behalf?</li><li>If not, is it <code>get(wrapper)</code> or <code>wrapper.value</code> or <code>wrapper.get()</code> or <code>wrapper()</code>?</li></ul><div><p><span><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</p><p>In idiomatic React code this is complicated. Values are unwrapped and can be tricky to read depending on where they are defined, e.g. folks frequently accidentally read stale values.</p></div><h3 id="how-does-data-flow">How does data flow?<a href="#how-does-data-flow" aria-label="Direct link to How does data flow?" title="Direct link to How does data flow?">​</a></h3><p>There are two main approaches to propagating root state changes: <strong>push</strong> and <strong>pull</strong>.</p><p>Generally speaking <strong>pull</strong> is simpler to work with because derived values are computed on-demand, i.e. <em>lazily</em>. This can avoid unnecessary recomputation of derived values. However, in some situations <strong>push</strong> can be more performant because it has lower overhead.</p><h4 id="push">Push<a href="#push" aria-label="Direct link to Push" title="Direct link to Push">​</a></h4><p>When you change a root value, any derived values that read from it are immediately updated, and so on, from left to right.</p><p><img src="https://blog.plover.com/img/what-are-signals-push-light.png" alt="Push signals"/><img src="https://blog.plover.com/img/what-are-signals-push-dark.png" alt="Push signals"/></p><ol><li>The <code>todos</code> value is updated.</li><li>The <code>filteredTodos</code> value is updated.</li><li>The <code>&lt;TodoList /&gt;</code> value is updated.</li><li>The side effect is triggered.</li></ol><h4 id="pull">Pull<a href="#pull" aria-label="Direct link to Pull" title="Direct link to Pull">​</a></h4><p>When you change a root value, any side effects that might need to execute are notified. Upstream derived values are only recomputed
if they are read from.</p><p><img src="https://blog.plover.com/img/what-are-signals-pull-light.png" alt="Push signals"/><img src="https://blog.plover.com/img/what-are-signals-pull-dark.png" alt="Push signals"/></p><ol><li>The <code>todos</code> value is updated.</li><li>The side effect is &#39;maybe&#39; triggered, and reads the <code>&lt;TodoList&gt;</code> value to see if it changed</li><li>The <code>&lt;TodoList&gt;</code> value is &#39;maybe&#39; recomputed, and reads the <code>Active todos</code> value to see if it changed</li><li>The <code>filteredTodos</code> value is recomputed because it&#39;s root dependency changed</li><li>The <code>&lt;TodoList&gt;</code> value is recomputed because the <code>Active todos</code> value changed</li><li>The side effect is triggered</li></ol><div><p><span><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</p><p>React is a mixture of push and pull. Derived values are updated in &#39;push&#39; mode during a render, but renders are evaluated in a larger &#39;pull&#39; context. </p></div><h3 id="how-are-derived-values-created-and-cached">How are derived values created and cached?<a href="#how-are-derived-values-created-and-cached" aria-label="Direct link to How are derived values created and cached?" title="Direct link to How are derived values created and cached?">​</a></h3><p>Since derived values are computed by looking at other state values, there must be some way of knowing <em>which</em> other state values are used so that the derived values can be recomputed automatically.</p><p>Some signals implementation use explicit dependency declaration. Indeed, React&#39;s <code>useMemo</code> is a way of managing derived values with explicit dependency declaration.</p><div><div><pre tabindex="0"><code><span><span>const</span><span> fullName </span><span>=</span><span> </span><span>useMemo</span><span>(</span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>    </span><span>return</span><span> </span><span>`</span><span>${</span><span>firstName</span><span>}</span><span> </span><span>${</span><span>lastName</span><span>}</span><span>`</span><span></span><br/></span><span><span></span><span>}</span><span>,</span><span> </span><span>[</span><span>firstName</span><span>,</span><span> lastName</span><span>]</span><span>)</span><br/></span></code></pre></div></div><p>Other signals implementations use automatic dependency capturing, either supported by a compiler or, more commonly, by using wrapped values.
This is a less-restrictive approach because it means you don&#39;t need direct access to the dependency values, and you don&#39;t need to worry about keeping the dependency list up to date.</p><p>This is how the same thing would look using <code>signia</code></p><div><div><pre tabindex="0"><code><span><span>const</span><span> fullName </span><span>=</span><span> </span><span>computed</span><span>(</span><span>&#39;fullName&#39;</span><span>,</span><span> </span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>    </span><span>return</span><span> </span><span>`</span><span>${</span><span>firstName</span><span>.</span><span>value</span><span>}</span><span> </span><span>${</span><span>lastName</span><span>.</span><span>value</span><span>}</span><span>`</span><span></span><br/></span><span><span></span><span>}</span><span>)</span><br/></span></code></pre></div></div><p>In both cases, the results of the computation are cached so that they are only recomputed when one of the dependencies changes.</p><h3 id="other-variables">Other variables<a href="#other-variables" aria-label="Direct link to Other variables" title="Direct link to Other variables">​</a></h3><ul><li>What kinds of side effects can be triggered?<ul><li>Only UI updates, or any old side effect?</li></ul></li><li>Are the signals standalone, bolted on to a framework, or integrated into a framework from the ground up?</li><li>Can the signal dependency graphs form a tree, a directed acyclic graph, or a directed cyclic graph?<ul><li>Do they support bi-directionality (e.g. lenses)?</li></ul></li><li>Do the signals support &#39;batching&#39;, i.e. transactions?<ul><li>If so, can changes be rolled back when a transaction aborts?</li></ul></li></ul><h2 id="okay-but-what-do-people-actually-mean-by-the-term-signals">Okay but what do people actually mean by the term &#39;signals&#39;?<a href="#okay-but-what-do-people-actually-mean-by-the-term-signals" aria-label="Direct link to Okay but what do people actually mean by the term &#39;signals&#39;?" title="Direct link to Okay but what do people actually mean by the term &#39;signals&#39;?">​</a></h2><p>The term &#39;signals&#39; is typically, but not always, talking about reactive values with:</p><ul><li>explicit wrappers</li><li>automatic dependency capturing</li><li>directed acyclic graphs</li><li>bolted on to a framework</li></ul><p>Here are some examples of libraries or frameworks that implement signals:</p><ul><li><a href="https://www.solidjs.com/tutorial/introduction_signals" target="_blank" rel="noopener noreferrer">SolidJS</a></li><li><a href="https://preactjs.com/guide/v10/signals/" target="_blank" rel="noopener noreferrer">Preact</a></li><li><a href="https://jotai.pmnd.rs/" target="_blank" rel="noopener noreferrer">jotai</a></li><li><a href="https://mobx.js.org/README.html" target="_blank" rel="noopener noreferrer">MobX</a></li><li><a href="https://recoiljs.org/" target="_blank" rel="noopener noreferrer">Recoil</a></li></ul><h2 id="conclusion">Conclusion<a href="#conclusion" aria-label="Direct link to Conclusion" title="Direct link to Conclusion">​</a></h2><ul><li>Signals are just a way to model and use reactive data, and they do it in a very pure, stripped-down way.</li><li>There are a million implementation details that give flavor to a particular signals library. Some big differences, some small differences, but the core concepts are shared.</li></ul></div></div>
  </body>
</html>
