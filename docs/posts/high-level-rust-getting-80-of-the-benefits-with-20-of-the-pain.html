<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hamy.xyz/blog/2026-01_high-level-rust">Original</a>
    <h1>High-Level Rust: Getting 80% of the Benefits with 20% of the Pain</h1>
    
    <div id="readability-page-1" class="page"><p>DISCLOSURE: If you buy through affiliate links, I may earn a small commission. <a href="https://www.vim.org/blog/disclosures">(disclosures)</a></p><div><p>I&#39;ve been <a href="https://hamy.xyz/blog/2026-01_missing-programming-language">searching for the perfect programming language</a> for years and my conclusion thus far is that it&#39;s missing.</p>
<p><img src="https://cdn.hamy.xyz/labs/posts/2026/2026-01_the-missing-programming-language/2026-01_the-missing-programming-language_table.png" alt="Programming Language Scores"/></p>
<p>There is no programming language that has it all:</p>
<ul>
<li>Expressive types</li>
<li>Good Community</li>
<li>Good ecosystem</li>
<li>Good perf</li>
<li>Good devx</li>
</ul>
<p>Several get close, but they&#39;re all missing something.</p>
<p>For the past couple years, my languages of choice have been F#, TypeScript, and C#. They are all solid languages but I always felt like I was settling in some dimension.</p>
<ul>
<li><strong>F#</strong> - Has great types and bones but I think the syntax is too minimal to be readable, the ecosystem is tiny with many abandoned packages or you build wrappers to interop with C#, and AIs aren&#39;t very good at idiomatic F# because there&#39;s so little training data and is overshadowed by OO C#.</li>
</ul>
<ul>
<li><strong>TypeScript</strong> - Is ubiquitious with the biggest ecosystem in the world but the types are lies and the ecosystem is constantly undergoing largescale thrash</li>
<li><strong>C#</strong> - Is a solid OO language but it&#39;s full of boilerplate and has yet to get native unions and exhaustive pattern matching (maybe this year?).</li>
</ul>
<p><em>Related: <a href="https://hamy.xyz/blog/2025-06_7-reasons-fsharp-sucks">7 Reasons F# Sucks</a></em></p>
<p>So I found myself bouncing back and forth year after year and bending each language further towards what I wanted:</p>
<ul>
<li><a href="https://hamy.xyz/blog/2023-10-i-formatted-fsharp-wrong">Writing some verbose F#</a></li>
<li><a href="https://hamy.xyz/blog/2025-07_typescript-result-types">Adding results to TypeScript</a></li>
<li>Using <a href="https://hamy.xyz/blog/2025-07_csharp-records">immutable records</a> and  Results in C#</li>
</ul>
<p>They all got closer but just weren&#39;t quite there.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/ncHPgvhnm7k?si=Nh9Ls4cuQRcJwd5d" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<h2 id="rust-is-perfect-except-for-the-productivity">Rust is perfect, except for the productivity</h2>
<p>I&#39;ve known about Rust for a long time but have only seriously considered it a few times and never really built anything with it - largely because I didn&#39;t think the learning curve was worth the gains. After all I&#39;m not a systems-level programmer, so why use a systems-level language?</p>
<p>But it&#39;s popular at <a href="https://hamy.xyz/blog/2026-01_recurse-center-statement">Recurse Center</a> where I&#39;ve spent the last several weeks building stuff and someone mentioned that Rust was a good language even if you just chose it for the types. That was interesting to me because I often do choose the language for its types (its one of the biggest differentiators) and then hope that there&#39;s an ecosystem to support it.</p>
<p>So I went and researched / reported on <a href="https://hamy.xyz/blog/2026-01_missing-programming-language">the missing language</a> and sure enough Rust is a strong contender - except for its devx.</p>
<p>But I got to thinking - <a href="https://hamy.xyz/blog/2025-12_software-engineers-ai">with AI so good at writing standard code</a>, is this learning curve now much lower? Can we move about as fast with Rust as we would another language? And if we could do that, what would we gain?</p>
<h2 id="the-pros-and-cons-of-rust">The Pros and Cons of Rust</h2>
<p>The pros and cons of Rust basically shake out to:</p>
<p><strong>Pros:</strong></p>
<ul>
<li><strong>Fast</strong> - Approaching C which is about as fast as you can get in a readable language</li>
<li><strong>Great types</strong> - truly expressive (see: <a href="https://hamy.xyz/blog/2026-01_missing-programming-language#my-definition-of-expressive-types">my definition of expressive types</a>)</li>
<li><strong>Runs ~anywhere</strong> - Is so low level it can plug into most things</li>
<li><strong>Large and growing ecosystem</strong> - ~10th in size w ~15% of devs using it and growing at ~30% per year according to <a href="https://survey.stackoverflow.co/2025/technology">Stack Overflow Dev survey 2025</a></li>
<li><strong>Super stable</strong> - Goes to great lengths to have solid crates that don&#39;t break over time (though the lang has had its share of thrash like with async runtimes)</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li><strong>Learning curve</strong> - ownership, borrowing, lifetimes, async runtimes and gotchas</li>
<li><strong>Lower velocity</strong> - vs high level languages</li>
</ul>
<p>So the pros are really really good. In fact, if you could remove the cons Rust looks a lot like the type of language I&#39;ve been searching for.</p>
<p><img src="https://cdn.hamy.xyz/labs/posts/2026/2026-02_high-level-rust/2026-02_high-level-rust_thumbnail.png" alt="High Level Rust"/></p>
<h2 id="high-level-rust">High Level Rust</h2>
<p>So I had this idea - what if you could just write Rust as a high-level language? If you can just get that devx to approach that of C#, F#, TS then you get basically all upside.</p>
<p>So I started doing research and reading the Rust book and building little prototypes.</p>
<p>What I came up with was an approach that gets us ~80% of benefits of Rust for only ~20% of the pain. And in most cases the only drawbacks are a 10-20% hit on perf which isn&#39;t that bad when we consider how fast Rust is out of the box and how it compares to other languages we&#39;d build in the same way.</p>
<p>The approach is:</p>
<ul>
<li><strong>Type-first domain modeling</strong> - Use enums and structs to model your domain. Make invalid states unrepresentable.</li>
<li><strong>Functionalish logic</strong> - This means immutable by default, pure functions, ImPureIm sandwiches, generous cloning instead of mutations. Rust&#39;s type system already pushes you towards this so we&#39;re working with the system but if you also allow yourself to take the perf hit on clones you can avoid most painful borrow checker / lifetime / async edge cases. Note: there be dragons in cloning perf since this is not a Garbage Collected language, you likely need to use <code>Arc</code> on non primitives and structs and immutable collection crates to keep clone cost down.</li>
<li><strong>Domain Driven Design</strong> - Domains encapsulated behind services. Use traits as interfaces to help with DI, testing. Create these services at the app root and use <code>Arc&lt;dyn TRAIT&gt;</code> to allow for shared references.</li>
</ul>
<p>We do lose some perf from this approach but it&#39;s in the ballpark of 10-30% depending on how frequently you&#39;re doing these clones. If you do have a hot path / perf critical area, you can typically optimize those away by switching them over to mutations.</p>
<p>I&#39;ll note that this approach adds in some extra mental overhead in terms of remembering to use immutable structures / primitives / Arc everywhere you can to allow for less expensive clones. That&#39;s a real cost you don&#39;t typically pay in GC languages (other than limit data / clones in frequency / size) and not something Rust&#39;s type system is currently helping with (both expensive and cheap clones are just <code>.clone()</code>). And expensive clones are <em>very</em> bad in Rust because they&#39;re all deep clones so some inefficient ones in hot paths can easily tank your perf down below that of other compiled languages like F# / C#. (I see there are some <a href="https://smallcultfollowing.com/babysteps/blog/2025/11/10/just-call-clone/"><code>alias</code> proposals</a> to help with this and I&#39;m putting together <a href="https://github.com/SIRHAMY/light-clone">a package</a> to allow the type system to point these out to prevent myself from repeatedly making this mistake).</p>
<p>So this approach works for most general high level computing tasks but is not universally effective.</p>
<h2 id="when-high-level-rust-makes-sense">When High Level Rust Makes Sense</h2>
<p>I think this is a good fit when you care more about logic than performance. But if performance is a concern / you have logic in a hot path then mutations likely makes more sense as it&#39;s <em>much</em> faster.</p>
<p><strong>Good fit:</strong></p>
<ul>
<li>Web APIs, CRUD services</li>
<li>Business logic heavy applications</li>
<li>Projects where correctness &gt; raw performance</li>
<li>Teams coming from <a href="https://hamy.xyz/blog/2024-12_5-years-fsharp-in-production">functional languages</a></li>
</ul>
<p><strong>Not a fit:</strong></p>
<ul>
<li>Hot paths, game engines, OS kernels</li>
<li>Complex concurrent systems with shared mutable state</li>
<li>When you need every bit of performance</li>
<li>When you have time to learn / use &#34;proper&#34; Rust - I&#39;m sure experienced Rustaceans will see this proposal as overly restrictive and ineffective for leveraging the language for what it&#39;s capable of</li>
</ul>
<h2 id="next">Next</h2>
<p>Rust really feels like an excellent language on paper but it has some scary edge cases that make it hard to onboard onto. I think this approach can help soften those edges and make it an excellent high level language that happens to be able to produce near-metal performance if and when you need it.</p>
<p>But we&#39;ll see - I just started this journey a few weeks ago and am actively exploring this approach through demo web services, games, and CLIs so maybe my view will change.</p>
<p>I&#39;m actively working on <a href="https://github.com/SIRHAMY/light-clone">LightClone</a> - the package to enforce cheap clones. If you&#39;re interested in this / want to see it happen please star it on GitHub and shoot me any feedback you might have. This would let me know it&#39;s smth people want, is worth investing in, and help me make it more generally useful!</p>
<p>If you liked this post you might also like:</p>
<ul>
<li><a href="https://hamy.xyz/blog/2026-01_missing-programming-language">The Missing Programming Language - Why There&#39;s No S-Tier Language (Yet)</a></li>
<li><a href="https://hamy.xyz/blog/2026-01_how-i-think-about-vibe-engineering">How I think about writing quality code fast with AI</a></li>
<li><a href="https://hamy.xyz/blog/2026-01_ai-engineering-best-practices">5 AI Coding Best Practices from a Google AI Director (That Actually Work)</a></li>
</ul>
</div></div>
  </body>
</html>
