<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.cs.mcgill.ca/~cs573/winter2001/AttLinux_syntax.htm">Original</a>
    <h1>AT&amp;T Syntax versus Intel Syntax</h1>
    
    <div id="readability-page-1" class="page">



<p>In order to maintain compatibility with the output of <code>gcc</code>,
<code>gas</code> supports AT&amp;T System V/386 assembler syntax.
This is quite different from Intel syntax. We mention these
differences because almost all 80386 documents used only Intel
syntax. Notable differences between the two syntaxes are: </p>

<ul>
    <li>AT&amp;T immediate operands are preceded by <samp>`$&#39;</samp>;
        Intel immediate operands are undelimited (Intel <samp>`push
        4&#39;</samp> is AT&amp;T <samp>`pushl $4&#39;</samp>). AT&amp;T
        register operands are preceded by <samp>`%&#39;</samp>; Intel
        register operands are undelimited. AT&amp;T absolute (as
        opposed to PC relative) jump/call operands are prefixed
        by <samp>`*&#39;</samp>; they are undelimited in Intel syntax.
    </li>
    <li>AT&amp;T and Intel syntax use the opposite order for
        source and destination operands. Intel <samp>`add eax, 4&#39;</samp>
        is <samp>`addl $4, %eax&#39;</samp>. The <samp>`source, dest&#39;</samp>
        convention is maintained for compatibility with previous
        Unix assemblers. </li>
    <li>In AT&amp;T syntax the size of memory operands is
        determined from the last character of the opcode name.
        Opcode suffixes of <samp>`b&#39;</samp>, <samp>`w&#39;</samp>,
        and <samp>`l&#39;</samp> specify byte (8-bit), word (16-bit),
        and long (32-bit) memory references. Intel syntax
        accomplishes this by prefixes memory operands (<em>not</em>
        the opcodes themselves) with <samp>`byte ptr&#39;</samp>, <samp>`word
        ptr&#39;</samp>, and <samp>`dword ptr&#39;</samp>. Thus, Intel <samp>`mov
        al, byte ptr </samp><samp><var>foo</var></samp><samp>&#39;</samp>
        is <samp>`movb </samp><samp><var>foo</var></samp><samp>,
        %al&#39;</samp> in AT&amp;T syntax. </li>
    <li>Immediate form long jumps and calls are <samp>`lcall/ljmp
        $</samp><samp><var>section</var></samp><samp>, $</samp><samp><var>offset</var></samp><samp>&#39;</samp>
        in AT&amp;T syntax; the Intel syntax is <samp>`call/jmp
        far </samp><samp><var>section</var></samp><samp>:</samp><samp><var>offset</var></samp><samp>&#39;</samp>.
        Also, the far return instruction is <samp>`lret $</samp><samp><var>stack-adjust</var></samp><samp>&#39;</samp>
        in AT&amp;T syntax; Intel syntax is <samp>`ret far </samp><samp><var>stack-adjust</var></samp><samp>&#39;</samp>.
    </li>
    <li>The AT&amp;T assembler does not provide support for
        multiple section programs. Unix style systems expect all
        programs to be single sections. </li>
</ul>

<h2>Opcode Naming</h2>

<p>Opcode names are suffixed with one character modifiers which
specify the size of operands. The letters <samp>`b&#39;</samp>, <samp>`w&#39;</samp>,
and <samp>`l&#39;</samp> specify byte, word, and long operands. If no
suffix is specified by an instruction and it contains no memory
operands then <code>gas</code> tries to fill in the missing
suffix based on the destination register operand (the last one by
convention). Thus, <samp>`mov %ax, %bx&#39;</samp> is equivalent to <samp>`movw
%ax, %bx&#39;</samp>; also, <samp>`mov $1, %bx&#39;</samp> is equivalent
to <samp>`movw $1, %bx&#39;</samp>. Note that this is incompatible
with the AT&amp;T Unix assembler which assumes that a missing
opcode suffix implies long operand size. (This incompatibility
does not affect compiler output since compilers always explicitly
specify the opcode suffix.) </p>

<p>Almost all opcodes have the same names in AT&amp;T and Intel
format. There are a few exceptions. The sign extend and zero
extend instructions need two sizes to specify them. They need a
size to sign/zero extend <em>from</em> and a size to zero extend <em>to</em>.
This is accomplished by using two opcode suffixes in AT&amp;T
syntax. Base names for sign extend and zero extend are <samp>`movs...&#39;</samp>
and <samp>`movz...&#39;</samp> in AT&amp;T syntax (<samp>`movsx&#39;</samp>
and <samp>`movzx&#39;</samp> in Intel syntax). The opcode suffixes
are tacked on to this base name, the <em>from</em> suffix before
the <em>to</em> suffix. Thus, <samp>`movsbl %al, %edx&#39;</samp> is
AT&amp;T syntax for &#34;move sign extend <em>from</em> %al <em>to</em>
%edx.&#34; Possible suffixes, thus, are <samp>`bl&#39;</samp> (from
byte to long), <samp>`bw&#39;</samp> (from byte to word), and <samp>`wl&#39;</samp>
(from word to long). </p>

<p>The Intel-syntax conversion instructions </p>

<ul>
    <li><samp>`cbw&#39;</samp> -- sign-extend byte in <samp>`%al&#39;</samp>
        to word in <samp>`%ax&#39;</samp>, </li>
    <li><samp>`cwde&#39;</samp> -- sign-extend word in <samp>`%ax&#39;</samp>
        to long in <samp>`%eax&#39;</samp>, </li>
    <li><samp>`cwd&#39;</samp> -- sign-extend word in <samp>`%ax&#39;</samp>
        to long in <samp>`%dx:%ax&#39;</samp>, </li>
    <li><samp>`cdq&#39;</samp> -- sign-extend dword in <samp>`%eax&#39;</samp>
        to quad in <samp>`%edx:%eax&#39;</samp>, </li>
</ul>

<p>are called <samp>`cbtw&#39;</samp>, <samp>`cwtl&#39;</samp>, <samp>`cwtd&#39;</samp>,
and <samp>`cltd&#39;</samp> in AT&amp;T naming. <code>gas</code>
accepts either naming for these instructions. Far call/jump
instructions are <samp>`lcall&#39;</samp> and <samp>`ljmp&#39;</samp> in
AT&amp;T syntax, but are <samp>`call far&#39;</samp> and <samp>`jump
far&#39;</samp> in Intel convention. </p>

<h2>Register Naming</h2>

<p>Register operands are always prefixes with <samp>`%&#39;</samp>.
The 80386 registers consist of </p>

<ul>
    <li>the 8 32-bit registers <samp>`%eax&#39;</samp> (the
        accumulator), <samp>`%ebx&#39;</samp>, <samp>`%ecx&#39;</samp>, <samp>`%edx&#39;</samp>,
        <samp>`%edi&#39;</samp>, <samp>`%esi&#39;</samp>, <samp>`%ebp&#39;</samp>
        (the frame pointer), and <samp>`%esp&#39;</samp> (the stack
        pointer). </li>
    <li>the 8 16-bit low-ends of these: <samp>`%ax&#39;</samp>, <samp>`%bx&#39;</samp>,
        <samp>`%cx&#39;</samp>, <samp>`%dx&#39;</samp>, <samp>`%di&#39;</samp>,
        <samp>`%si&#39;</samp>, <samp>`%bp&#39;</samp>, and <samp>`%sp&#39;</samp>.
    </li>
    <li>the 8 8-bit registers: <samp>`%ah&#39;</samp>, <samp>`%al&#39;</samp>,
        <samp>`%bh&#39;</samp>, <samp>`%bl&#39;</samp>, <samp>`%ch&#39;</samp>,
        <samp>`%cl&#39;</samp>, <samp>`%dh&#39;</samp>, and <samp>`%dl&#39;</samp>
        (These are the high-bytes and low-bytes of <samp>`%ax&#39;</samp>,
        <samp>`%bx&#39;</samp>, <samp>`%cx&#39;</samp>, and <samp>`%dx&#39;</samp>)
    </li>
    <li>the 6 section registers <samp>`%cs&#39;</samp> (code section),
        <samp>`%ds&#39;</samp> (data section), <samp>`%ss&#39;</samp> (stack
        section), <samp>`%es&#39;</samp>, <samp>`%fs&#39;</samp>, and <samp>`%gs&#39;</samp>.
    </li>
    <li>the 3 processor control registers <samp>`%cr0&#39;</samp>, <samp>`%cr2&#39;</samp>,
        and <samp>`%cr3&#39;</samp>. </li>
    <li>the 6 debug registers <samp>`%db0&#39;</samp>, <samp>`%db1&#39;</samp>,
        <samp>`%db2&#39;</samp>, <samp>`%db3&#39;</samp>, <samp>`%db6&#39;</samp>,
        and <samp>`%db7&#39;</samp>. </li>
    <li>the 2 test registers <samp>`%tr6&#39;</samp> and <samp>`%tr7&#39;</samp>.
    </li>
    <li>the 8 floating point register stack <samp>`%st&#39;</samp> or
        equivalently <samp>`%st(0)&#39;</samp>, <samp>`%st(1)&#39;</samp>,
        <samp>`%st(2)&#39;</samp>, <samp>`%st(3)&#39;</samp>, <samp>`%st(4)&#39;</samp>,
        <samp>`%st(5)&#39;</samp>, <samp>`%st(6)&#39;</samp>, and <samp>`%st(7)&#39;</samp>.
    </li>
</ul>

<h2>Opcode Prefixes</h2>

<p>Opcode prefixes are used to modify the following opcode. They
are used to repeat string instructions, to provide section
overrides, to perform bus lock operations, and to give operand
and address size (16-bit operands are specified in an instruction
by prefixing what would normally be 32-bit operands with a &#34;operand
size&#34; opcode prefix). Opcode prefixes are usually given as
single-line instructions with no operands, and must directly
precede the instruction they act upon. For example, the <samp>`scas&#39;</samp>
(scan string) instruction is repeated with: </p>

<pre>        repne
        scas
</pre>

<pre>Here is a list of opcode prefixes: </pre>

<ul>
    <li>Section override prefixes <samp>`cs&#39;</samp>, <samp>`ds&#39;</samp>,
        <samp>`ss&#39;</samp>, <samp>`es&#39;</samp>, <samp>`fs&#39;</samp>, <samp>`gs&#39;</samp>.
        These are automatically added by specifying using the <var>section</var>:<var>memory-operand</var>
        form for memory references. </li>
    <li>Operand/Address size prefixes <samp>`data16&#39;</samp> and <samp>`addr16&#39;</samp>
        change 32-bit operands/addresses into 16-bit operands/addresses.
        Note that 16-bit addressing modes (i.e. 8086 and 80286
        addressing modes) are not supported (yet). </li>
    <li>The bus lock prefix <samp>`lock&#39;</samp> inhibits
        interrupts during execution of the instruction it
        precedes. (This is only valid with certain instructions;
        see a 80386 manual for details). </li>
    <li>The wait for coprocessor prefix <samp>`wait&#39;</samp> waits
        for the coprocessor to complete the current instruction.
        This should never be needed for the 80386/80387
        combination. </li>
    <li>The <samp>`rep&#39;</samp>, <samp>`repe&#39;</samp>, and <samp>`repne&#39;</samp>
        prefixes are added to string instructions to make them
        repeat <samp>`%ecx&#39;</samp> times. </li>
</ul>

<h2>Memory References</h2>

<p>An Intel syntax indirect memory reference of the form </p>

<pre><em><strong><var>section</var></strong></em><em><strong>:[</strong></em><em><strong><var>base</var></strong></em><em><strong> + </strong></em><em><strong><var>index</var></strong></em><em><strong>*</strong></em><em><strong><var>scale</var></strong></em><em><strong> + </strong></em><em><strong><var>disp</var></strong></em><em><strong>]</strong></em>
</pre>

<pre>is translated into the AT&amp;T syntax </pre>

<pre><em><strong><var>section</var></strong></em><em><strong>:</strong></em><em><strong><var>disp</var></strong></em><em><strong>(</strong></em><em><strong><var>base</var></strong></em><em><strong>, </strong></em><em><strong><var>index</var></strong></em><em><strong>,</strong></em><em><strong><var>scale</var></strong></em><em><strong>)</strong></em>
</pre>

<p>where <var>base</var> and <var>index</var> are the optional 32-bit
base and index registers, <var>disp</var> is the optional
displacement, and <var>scale</var>, taking the values 1, 2, 4,
and 8, multiplies <var>index</var> to calculate the address of
the operand. If no <var>scale</var> is specified, <var>scale</var>
is taken to be 1. <var>section</var> specifies the optional
section register for the memory operand, and may override the
default section register (see a 80386 manual for section register
defaults). Note that section overrides in AT&amp;T syntax <em>must</em>
have be preceded by a <samp>`%&#39;</samp>. If you specify a section
override which coincides with the default section register, <code>gas</code>
does <em>not</em> output any section register override prefixes
to assemble the given instruction. Thus, section overrides can be
specified to emphasize which section register is used for a given
memory operand. </p>

<p>Here are some examples of Intel and AT&amp;T style memory
references: </p>

<dl compact="">
    <dt>AT&amp;T: <samp>`-4(%ebp)&#39;</samp>, Intel: <samp>`[ebp - 4]&#39;</samp>
    </dt>
    <dd><var>base</var> is <samp>`%ebp&#39;</samp>; <var>disp</var>
        is <samp>`-4&#39;</samp>. <var>section</var> is missing, and
        the default section is used (<samp>`%ss&#39;</samp> for
        addressing with <samp>`%ebp&#39;</samp> as the base register).
        <var>index</var>, <var>scale</var> are both missing. </dd>
    <dt>AT&amp;T: <samp>`foo(,%eax,4)&#39;</samp>, Intel: <samp>`[foo
        + eax*4]&#39;</samp> </dt>
    <dd><var>index</var> is <samp>`%eax&#39;</samp> (scaled by a <var>scale</var>
        4); <var>disp</var> is <samp>`foo&#39;</samp>. All other
        fields are missing. The section register here defaults to
        <samp>`%ds&#39;</samp>. </dd>
    <dt>AT&amp;T: <samp>`foo(,1)&#39;</samp>; Intel <samp>`[foo]&#39;</samp>
    </dt>
    <dd>This uses the value pointed to by <samp>`foo&#39;</samp> as a
        memory operand. Note that <var>base</var> and <var>index</var>
        are both missing, but there is only <em>one</em> <samp>`,&#39;</samp>.
        This is a syntactic exception. </dd>
    <dt>AT&amp;T: <samp>`%gs:foo&#39;</samp>; Intel <samp>`gs:foo&#39;</samp>
    </dt>
    <dd>This selects the contents of the variable <samp>`foo&#39;</samp>
        with section register <var>section</var> being <samp>`%gs&#39;</samp>.
    </dd>
</dl>

<p>Absolute (as opposed to PC relative) call and jump operands
must be prefixed with <samp>`*&#39;</samp>. If no <samp>`*&#39;</samp> is
specified, <code>gas</code> always chooses PC relative addressing
for jump/call labels. </p>

<p>Any instruction that has a memory operand <em>must</em>
specify its size (byte, word, or long) with an opcode suffix (<samp>`b&#39;</samp>,
<samp>`w&#39;</samp>, or <samp>`l&#39;</samp>, respectively). </p>

<h2>Handling of Jump Instructions</h2>

<p>Jump instructions are always optimized to use the smallest
possible displacements. This is accomplished by using byte (8-bit)
displacement jumps whenever the target is sufficiently close. If
a byte displacement is insufficient a long (32-bit) displacement
is used. We do not support word (16-bit) displacement jumps (i.e.
prefixing the jump instruction with the <samp>`addr16&#39;</samp>
opcode prefix), since the 80386 insists upon masking <samp>`%eip&#39;</samp>
to 16 bits after the word displacement is added. </p>

<p>Note that the <samp>`jcxz&#39;</samp>, <samp>`jecxz&#39;</samp>, <samp>`loop&#39;</samp>,
<samp>`loopz&#39;</samp>, <samp>`loope&#39;</samp>, <samp>`loopnz&#39;</samp>
and <samp>`loopne&#39;</samp> instructions only come in byte
displacements, so that if you use these instructions (<code>gcc</code>
does not use them) you may get an error message (and incorrect
code). The AT&amp;T 80386 assembler tries to get around this
problem by expanding <samp>`jcxz foo&#39;</samp> to </p>

<pre>         jcxz cx_zero
         jmp cx_nonzero
cx_zero: jmp foo
cx_nonzero:
</pre>

<h2>Floating Point</h2>

<p>All 80387 floating point types except packed BCD are supported.
(BCD support may be added without much difficulty). These data
types are 16-, 32-, and 64- bit integers, and single (32-bit),
double (64-bit), and extended (80-bit) precision floating point.
Each supported type has an opcode suffix and a constructor
associated with it. Opcode suffixes specify operand&#39;s data types.
Constructors build these data types into memory. </p>

<ul>
    <li>Floating point constructors are <samp>`.float&#39;</samp> or <samp>`.single&#39;</samp>,
        <samp>`.double&#39;</samp>, and <samp>`.tfloat&#39;</samp> for 32-,
        64-, and 80-bit formats. These correspond to opcode
        suffixes <samp>`s&#39;</samp>, <samp>`l&#39;</samp>, and <samp>`t&#39;</samp>.
        <samp>`t&#39;</samp> stands for temporary real, and that the
        80387 only supports this format via the <samp>`fldt&#39;</samp>
        (load temporary real to stack top) and <samp>`fstpt&#39;</samp>
        (store temporary real and pop stack) instructions. </li>
    <li>Integer constructors are <samp>`.word&#39;</samp>, <samp>`.long&#39;</samp>
        or <samp>`.int&#39;</samp>, and <samp>`.quad&#39;</samp> for the
        16-, 32-, and 64-bit integer formats. The corresponding
        opcode suffixes are <samp>`s&#39;</samp> (single), <samp>`l&#39;</samp>
        (long), and <samp>`q&#39;</samp> (quad). As with the
        temporary real format the 64-bit <samp>`q&#39;</samp> format
        is only present in the <samp>`fildq&#39;</samp> (load quad
        integer to stack top) and <samp>`fistpq&#39;</samp> (store
        quad integer and pop stack) instructions. </li>
</ul>

<p>Register to register operations do not require opcode suffixes,
so that <samp>`fst %st, %st(1)&#39;</samp> is equivalent to <samp>`fstl
%st, %st(1)&#39;</samp>. </p>

<p>Since the 80387 automatically synchronizes with the 80386 <samp>`fwait&#39;</samp>
instructions are almost never needed (this is not the case for
the 80286/80287 and 8086/8087 combinations). Therefore, <code>gas</code>
suppresses the <samp>`fwait&#39;</samp> instruction whenever it is
implicitly selected by one of the <samp>`fn...&#39;</samp>
instructions. For example, <samp>`fsave&#39;</samp> and <samp>`fnsave&#39;</samp>
are treated identically. In general, all the <samp>`fn...&#39;</samp>
instructions are made equivalent to <samp>`f...&#39;</samp>
instructions. If <samp>`fwait&#39;</samp> is desired it must be
explicitly coded. </p>

<h2>Writing 16-bit Code</h2>

<p>While GAS normally writes only &#34;pure&#34; 32-bit i386
code, it has limited support for writing code to run in real mode
or in 16-bit protected mode code segments. To do this, insert a <samp>`.code16&#39;</samp>
directive before the assembly language instructions to be run in
16-bit mode. You can switch GAS back to writing normal 32-bit
code with the <samp>`.code32&#39;</samp> directive. </p>

<p>GAS understands exactly the same assembly language syntax in
16-bit mode as in 32-bit mode. The function of any given
instruction is exactly the same regardless of mode, as long as
the resulting object code is executed in the mode for which GAS
wrote it. So, for example, the <samp>`ret&#39;</samp> mnemonic
produces a 32-bit return instruction regardless of whether it is
to be run in 16-bit or 32-bit mode. (If GAS is in 16-bit mode, it
will add an operand size prefix to the instruction to force it to
be a 32-bit return.) </p>

<p>This means, for one thing, that you can use GNU CC to write
code to be run in real mode or 16-bit protected mode. Just insert
the statement <samp>`asm(&#34;.code16&#34;);&#39;</samp> at the
beginning of your C source file, and while GNU CC will still be
generating 32-bit code, GAS will automatically add all the
necessary size prefixes to make that code run in 16-bit mode. Of
course, since GNU CC only writes small-model code (it doesn&#39;t
know how to attach segment selectors to pointers like native x86
compilers do), any 16-bit code you write with GNU CC will
essentially be limited to a 64K address space. Also, there will
be a code size and performance penalty due to all the extra
address and operand size prefixes GAS has to add to the
instructions. </p>

<p>Note that placing GAS in 16-bit mode does not mean that the
resulting code will necessarily run on a 16-bit pre-80386
processor. To write code that runs on such a processor, you would
have to refrain from using <em>any</em> 32-bit constructs which
require GAS to output address or operand size prefixes. At the
moment this would be rather difficult, because GAS currently
supports <em>only</em> 32-bit addressing modes: when writing 16-bit
code, it <em>always</em> outputs address size prefixes for any
instruction that uses a non-register addressing mode. So you can
write code that runs on 16-bit processors, but only if that code
never references memory. </p>

<h2>Notes</h2>

<p>There is some trickery concerning the <samp>`mul&#39;</samp> and <samp>`imul&#39;</samp>
instructions that deserves mention. The 16-, 32-, and 64-bit
expanding multiplies (base opcode <samp>`0xf6&#39;</samp>; extension
4 for <samp>`mul&#39;</samp> and 5 for <samp>`imul&#39;</samp>) can be
output only in the one operand form. Thus, <samp>`imul %ebx, %eax&#39;</samp>
does <em>not</em> select the expanding multiply; the expanding
multiply would clobber the <samp>`%edx&#39;</samp> register, and this
would confuse <code>gcc</code> output. Use <samp>`imul %ebx&#39;</samp>
to get the 64-bit product in <samp>`%edx:%eax&#39;</samp>. </p>

<p>We have added a two operand form of <samp>`imul&#39;</samp> when
the first operand is an immediate mode expression and the second
operand is a register. This is just a shorthand, so that,
multiplying <samp>`%eax&#39;</samp> by 69, for example, can be done
with <samp>`imul $69, %eax&#39;</samp> rather than <samp>`imul $69, %eax,
%eax&#39;</samp>. </p>


</div>
  </body>
</html>
