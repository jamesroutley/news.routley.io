<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://elijer.github.io/garden/devnotes/Regex-Baby-Steps">Original</a>
    <h1>Regex Baby Steps</h1>
    
    <div id="readability-page-1" class="page"><div id="quartz-body"><div><article><p>“Okay I’m gonna do it. I’m just gonna learn regex, get it out of the way, and be that much closer to becoming a 10x developer” - Me, at least a couple times.</p>
<p>And I did it. I did the deep dive, practiced, tried to learn it front to back.</p>
<p>Do I remember what I learned from those times? Am I still asking rhetorical questions? No and yes, respectively.</p>
<p>Where do we go from here? Well I don’t know about you but I’m going to lower my expectations and lean into a type of learning that’s a bit more iterative. But this isn’t an online cooking recipe, let’s get to the good stuff.</p>

<p><code>\d</code> matches each digit.
<code>[1-9]</code> does too.</p>
<p>Given <code>123</code>, the regex expression <code>/\d/</code> returns three matches: <code>[1][2][3]</code></p>
<p>Adding <code>+</code> matches one or more of the previous pattern:
<code>/\d+/</code> or <code>/[1-9]+/</code>.</p>
<p>Given <code>123</code> again, we’re returned one match <code>[123]</code>
Give this <code>123abc345</code>, it returns 2 matches  <code>[123]abc[345]</code></p>

























<div><table><thead><tr><th>expression</th><th>explanation</th></tr></thead><tbody><tr><td><code>/\d/</code></td><td>match all digits in a string</td></tr><tr><td><code>/[1-9]/</code></td><td>same deal, more explicit</td></tr><tr><td><code>/\d+/</code></td><td>match all contiguous groups of digits (but not subgroups)</td></tr><tr><td><code>/[1-9]+/</code></td><td>&#34;&#34;</td></tr></tbody></table></div>
<p>Now we can add in the <code>^</code> and <code>$</code> operators, beginning and end. These say, these matches must be in relation to the beginning and/or end.</p>

























<div><table><thead><tr><th>expression</th><th>explanation</th></tr></thead><tbody><tr><td><code>/^\d/</code></td><td>Match a single digit at the beginning of a string</td></tr><tr><td><code>/\d$/</code></td><td>Match a single digit at the end of a string</td></tr><tr><td><code>/^\d$/</code></td><td>Match a string consisting <em>only</em> of a single digit</td></tr><tr><td><code>/^\d+$/</code></td><td>Match a string consisting <em>only</em> of a contiguous group of digits.</td></tr></tbody></table></div>
<p>How do we use this stuff in <code>JS</code> or <code>TS</code>?
Make sure a string is <em>only</em> comprised of digits in javascript with <code>/^[1-9]$/.test(str)</code>.</p>
<p>The <code>.test()</code> method returns true if <em>at least one</em> match is found.</p>
<p>You can also get all matches found with a weirdly different syntax:
<code>str.match(/\d/g)</code>
The <code>g</code> is for global, and tells JS we want to return more than just the first match.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>&#39;123&#39;</span><span>.</span><span>match</span><span>(</span><span>/</span><span>\d</span><span>/</span><span>g</span><span>)</span></span>
<span data-line=""><span>// &gt; [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]</span></span></code></pre></figure>
<p>If we want the indices of each match, we can get more info with <code>matchAll</code>:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>&#39;123&#39;</span><span>.</span><span>matchAll</span><span>(</span><span>/</span><span>\d</span><span>/</span><span>g</span><span>)</span></span></code></pre></figure>
<p>But since this returns an iterator we need to convert it into an array first:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>Array.</span><span>from</span><span>(</span><span>&#39;123&#39;</span><span>.</span><span>matchAll</span><span>(</span><span>/</span><span>\d</span><span>/</span><span>g</span><span>))</span></span>
<span data-line=""><span>//or</span></span>
<span data-line=""><span>[</span><span>...</span><span>&#39;123&#39;</span><span>.</span><span>matchAll</span><span>(</span><span>/</span><span>\d</span><span>/</span><span>g</span><span>)]</span></span></code></pre></figure>
<p>This will create an array of <em>objects</em> with some weird properties</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>    const</span><span> symbols</span><span> =</span><span> Array.</span><span>from</span><span>(data.</span><span>matchAll</span><span>(</span><span>/</span><span>[</span><span>^</span><span>0-9.]</span><span>/</span><span>g</span><span>))</span></span>
<span data-line=""><span>    const</span><span> symbolIndexes</span><span> =</span><span> new</span><span> Set</span><span>(symbols.</span><span>map</span><span>(</span><span>d</span><span>=&gt;</span><span>d.index))</span></span></code></pre></figure>

<p>So now we can tack on the <code>.replace()</code> method and this should make sense:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>str.</span><span>replace</span><span>(</span><span>/</span><span>[</span><span>^</span><span>a-zA-Z]</span><span>/</span><span>g</span><span>, </span><span>&#39;&#39;</span><span>);</span></span></code></pre></figure>
<p>But wait…why is the carrot <code>^</code> inside the brackets.</p>
<p>AHHHHHHHHHHHHHHHHHHHHHH</p>
<p>Good question. Turns out that if the carrot is the first character in the square brackets, it’s saying “everything <em>but</em> the pattern in these brackets”. So super different from what it means when it’s outside of them.</p>
<p><em>It inverts the pattern.</em></p>
<p>Random note:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>const</span><span> str</span><span> =</span><span> s.</span><span>replace</span><span>(</span><span>/</span><span>[\w]</span><span>+</span><span>/</span><span>g</span><span>, </span><span>&#39;&#39;</span><span>).</span><span>toLowerCase</span><span>()</span></span></code></pre></figure>
<p><code>\w</code> corresponds to all characters <code>[a-zA-Z0-9]</code></p>

<p>This is probably what we want.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>data </span><span>=</span><span> data.</span><span>replace</span><span>(</span><span>/</span><span>\s</span><span>+</span><span>/</span><span>g</span><span>, </span><span>&#39;&#39;</span><span>)</span></span></code></pre></figure>

<ul>
<li><code>g</code> (global) - find all matches rather than stopping at first</li>
<li><code>i</code> (case insensitive) - ignore case when matching</li>
<li><code>m</code> (multiline) - treat beginning and end characters (^ and $) as working over multiple lines</li>
<li><code>s</code> (dotall) - matches any character, including newlines</li>
<li><code>u</code> (unicode) - treat pattern as unicode sequence</li>
<li><code>y</code> (sticky) - matches only from the last index indicated</li>
</ul>

<p>Surprise, capitals do the same as <code>^</code> and invert the class.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>// Character Classes</span></span>
<span data-line=""><span>\w  </span><span>// Word character: [a-zA-Z0-9_]</span></span>
<span data-line=""><span>\</span><span>W</span><span>  // NOT a word character: [^a-zA-Z0-9_]</span></span>
<span data-line=""><span>\d  </span><span>// Digit: [0-9]</span></span>
<span data-line=""><span>\</span><span>D</span><span>  // NOT a digit: [^0-9]</span></span>
<span data-line=""><span>\s  </span><span>// Whitespace: [ \t\n\r\f\v]</span></span>
<span data-line=""><span>\</span><span>S</span><span>  // NOT whitespace: [^ \t\n\r\f\v]</span></span></code></pre></figure>

<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>// The ones I already know:</span></span>
<span data-line=""><span>^</span><span>     // Start of string/line</span></span>
<span data-line=""><span>$     </span><span>// End of string/line</span></span>
<span data-line=""> </span>
<span data-line=""><span>// Word boundary:</span></span>
<span data-line=""><span>\b    </span><span>// Word boundary</span></span>
<span data-line=""><span>\</span><span>B</span><span>    // NOT a word boundary</span></span></code></pre></figure>
<p>Word boundary examples</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>// Matches positions where a word character is next to a non-word character</span></span>
<span data-line=""><span>&#34;Hi there&#34;</span><span>.</span><span>match</span><span>(</span><span>/</span><span>\b</span><span>Hi</span><span>\b</span><span>/</span><span>)    </span><span>// ✓ Matches &#39;Hi&#39; as whole word</span></span>
<span data-line=""><span>&#34;High&#34;</span><span>.</span><span>match</span><span>(</span><span>/</span><span>\b</span><span>Hi</span><span>\b</span><span>/</span><span>)        </span><span>// ✗ Doesn&#39;t match hi as part of word</span></span>
<span data-line=""> </span>
<span data-line=""><span>// \B - Not a Word Boundary</span></span>
<span data-line=""><span>// Matches positions where \b WOULDN&#39;T match</span></span>
<span data-line=""><span>&#34;High&#34;</span><span>.</span><span>match</span><span>(</span><span>/</span><span>\B</span><span>Hi</span><span>/</span><span>)          </span><span>// Does NOT match &#34;Hi&#34; at start</span></span>
<span data-line=""><span>&#34;High&#34;</span><span>.</span><span>match</span><span>(</span><span>/</span><span>\B</span><span>gh</span><span>\B</span><span>/</span><span>)        </span><span>// Matches &#34;gh&#34; in middle of &#34;High&#34;</span></span></code></pre></figure>
<p>Okay sweet! Not a regex expert. But it doesn’t look foreign anymore and I can understand basic operations. I’ll keep adding to this, carefully - not to disrupt the fragile space I’ve reserved for regex in my brain - as I learn more.</p></article><hr/></div></div></div>
  </body>
</html>
