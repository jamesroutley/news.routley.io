<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.computerenhance.com/p/the-problem-with-risc-v-v-mask-bits">Original</a>
    <h1>The Problem with RISC-V V Mask Bits</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><div class=""><div><div dir="auto"><div><figure><a target="_blank" rel="nofollow" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F1397d99d-63f1-45dd-88d8-91d77014ad90_5616x3744.jpeg"><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F1397d99d-63f1-45dd-88d8-91d77014ad90_5616x3744.jpeg 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F1397d99d-63f1-45dd-88d8-91d77014ad90_5616x3744.jpeg 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F1397d99d-63f1-45dd-88d8-91d77014ad90_5616x3744.jpeg 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F1397d99d-63f1-45dd-88d8-91d77014ad90_5616x3744.jpeg 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F1397d99d-63f1-45dd-88d8-91d77014ad90_5616x3744.jpeg" width="1456" height="971" data-attrs="{&#34;src&#34;:&#34;https://bucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com/public/images/1397d99d-63f1-45dd-88d8-91d77014ad90_5616x3744.jpeg&#34;,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:971,&#34;width&#34;:1456,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:6560199,&#34;alt&#34;:&#34;A series of stuffed animals in rows.&#34;,&#34;title&#34;:null,&#34;type&#34;:&#34;image/jpeg&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:false}" alt="A series of stuffed animals in rows." title="A series of stuffed animals in rows." srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F1397d99d-63f1-45dd-88d8-91d77014ad90_5616x3744.jpeg 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F1397d99d-63f1-45dd-88d8-91d77014ad90_5616x3744.jpeg 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F1397d99d-63f1-45dd-88d8-91d77014ad90_5616x3744.jpeg 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F1397d99d-63f1-45dd-88d8-91d77014ad90_5616x3744.jpeg 1456w" sizes="100vw"/></picture></a></figure></div><p><em><span>I filed the concern described in this article </span><a href="https://github.com/riscv/riscv-v-spec/issues/811" rel="">on the RISC-V V github</a><span> if you would like to follow along</span></em><span>. </span><em>I also passed on the concern personally to a RISC-V V community liaison, and I will post a follow-up article in the future with any responses I receive.</em></p><p><a href="https://en.wikipedia.org/wiki/RISC-V" rel="">RISC-V</a><span> is an instruction set architecture designed to compete with </span><a href="https://en.wikipedia.org/wiki/ARM_architecture_family" rel="">ARM</a><span>. Like ARM, the base instruction set for RISC-V does not include any </span><a href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_data" rel="">SIMD</a><span> instructions. Instead, both ISAs have “extensions” which define these instructions for chips which need them.</span></p><p><span>In ARM’s case, there are extensions for packed (</span><a href="https://developer.arm.com/documentation/102474/0100/Fundamentals-of-Armv8-Neon-technology?lang=en" rel="">NEON</a><span>) and vector (</span><a href="https://developer.arm.com/documentation/102476/0100/SVE-architecture-fundamentals" rel="">SVE</a><span>) SIMD instructions. For RISC-V, although there was consideration of a “</span><a href="https://github.com/riscv/riscv-p-spec" rel="">P</a><span>” extension for packed SIMD, the main extension gaining traction is the vector extension, RISC-V “</span><a href="https://github.com/riscv/riscv-v-spec" rel="">V</a><span>”.</span></p><p><span>The RISC-V V design is relatively uncontroversial, but one aspect stands out as a problem for high-performance chips: the mask bits for </span><a href="https://en.wikipedia.org/wiki/Predication_(computer_architecture)" rel="">predicated instructions</a><span> are required to be visible as the low-order bits of the v0 vector register. For reasons I&#39;ll explain in detail later, this means high-performance chips have no option other than to create complex schemes for dealing with the dual-use of this register.</span></p><p><span>This unusual choice is unlike other common instruction sets that provide predicated vector instructions. ARM SVE, </span><a href="https://en.wikipedia.org/wiki/AVX-512" rel="">AVX-512</a><span>, and early supercomputers like the </span><a href="https://en.wikipedia.org/wiki/Cray-1" rel="">CRAY-1</a><span> all use dedicated mask registers, avoiding this problem. Even packed instruction sets like </span><a href="https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions" rel="">SSE</a><span> and </span><a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions" rel="">AVX2</a><span>, which lack dedicated mask registers, avoid this problem by defining the mask bits as the high bit of each lane, so they are already “in the right place” when they are used.</span></p><p>Although this may seem like a small issue, once code is written for an ISA, it becomes a permanent burden on the ISA to support forevermore. Problems like this which require workarounds in high-performance parts of the chip should be avoided. They not only create bloat in current designs, but that bloat must remain in all future designs that support the ISA.</p><p>Even though future RISC-V extensions might make this unusual choice obsolete - for example, if a future extension adds real mask registers - RISC-V chips will still be forced to include legacy workarounds just in case they encounter code using the old mask paradigm. Once it&#39;s in the ISA, it never really goes away, as experience with x86/64 has amply shown.</p><p>That’s about all there is to say. If you already know a lot about vector instruction sets, you now know the gravamen: using the low bits of v0 as both actual vector lanes and as the mask bits for all vector lanes forces high-performance chips to include unnecessary cruft, now and for as long as the RISC-V V ISA remains relevant (assuming it ever becomes relevant in the first place!)</p><h2>Is there an alternative?</h2><p>It certainly seems like there is: just have a single dedicated mask register, like the CRAY-1. If the mask was always a separate register that could not be targeted by normal vector instructions, then RISC-V V chips could be designed knowing that they never had to use the value of v0 in two ways at once - problem solved.</p><p><span>One objection to this solution might have been, “because we didn’t want to add a bunch of mask-specific instructions”. A reasonable answer, to be sure, but not one that applies to RISC-V. It </span><em>already has </em><span>a bunch of mask-specific instructions! The spec includes no less than </span><em>eight</em><span> custom instructions just for working with masks: vmand, vmnand, vmandn, vmxor, vmor, vmnor, vmorn, vmxnor.</span></p><p><span>If you’re already going to add custom instructions </span><em>as if</em><span> you have mask registers, it is hard to see why the very little additional work necessary to have at least one dedicated mask register would be sufficient reason to introduce the burdensome and unusual dual-use v0 scheme present in RISC-V V.</span></p><h2>So why did they do it this way?</h2><p>I honestly don’t know, and that’s why I’m writing the article. To me, this design looks like a bit of a special-case hack, perhaps intended to make it easier to implement RISC-V V slowly on small or low-performance chips, or something like that.</p><p><span>If I’m right about that, I think it’s a bad precedent to put that in the ISA proper. Vector instructions are </span><em>specifically for performance</em><span>. The whole point of having SIMD is to build fast chips. So the RISC-V V extension seems a poor place to make a tradeoff that penalizes high-performance designs.</span></p><p><span>Furthermore, the design seems very </span><em>un-RISC</em><span>. The thing that makes RISC attractive - to the extent that it is attractive - is </span><em>simplicity</em><span>. There’s not supposed to be a lot of “sometimes the registers work one way, sometimes they work another way” kinds of stuff going on, because that makes it more complicated to design a chip. While there’s no hard-and-fast rule about what can be in a RISC chip and what can’t, it certainly seems against the spirit of it.</span></p><h2>Can it be changed?</h2><p>The RISC-V V spec recently hit v1.0, and it is now frozen “for public comment”. I am hopeful that means that public comments, like this one, might lead to a spec revision before a significant amount of effort is expended supporting the “v0 as both vector and mask” design.</p><p><span>While the relative scarcity of hardware implementing RISC-V V makes it hard to have much practical experience with it, it otherwise seems like a reasonable spec, at least on paper. Yes, it probably needs multiple mask registers eventually, but figuring out some way to add multiple mask registers at a later date is fine, and requires no weird hardware workarounds. There’s no need to worry about that </span><em>now</em><span>.</span></p><p><span>Having the mask bits stored in the low part of v0, on the other hand, </span><em>is</em><span> something that needs to be worried about now, because that duality will have to be mimicked by all future RISC-V V chips forever if they actually want to be compatible with code written now.</span></p><p><span>So, I think it’s an issue worth pressing. And this is me pressing it. </span><a href="https://github.com/riscv/riscv-v-spec/issues/811" rel="">Press, PRESS</a><span>!!!</span></p><h2>Appendixeseseses</h2><p>If you don&#39;t know a lot about vector instruction sets, and would like more explanation, here is a tiny primer on the parts of vector processing relevant to this article:</p><h2>What are &#34;vector instructions&#34;, and why do they exist?</h2><p>High-performance CPU and GPU chips try to do large amounts of computations as quickly as possible. While the circuitry for the calculation itself costs some amount of chip real estate, each instruction also has other fixed costs that have nothing to do with the computation itself.</p><p>Take as an example a floating point multiply instruction. We can think of the instruction as requiring two different types of &#34;work&#34;. </p><p>The first type of work is just the circuitry to literally compute the multiplication. There is no way to &#34;save&#34; on this work by doing more multiplies - if you wanted to multiply more numbers together at the same time, you would have to add more exact copies of this circuitry.</p><p><span>The second type of work is </span><em>everything else</em><span>. This is all the bookkeeping and routing that must be done to know what to do: decoding the instruction from the instruction stream, determining that it&#39;s a multiply, finding the source data and figuring out if it&#39;s ready, scheduling it to be executed on the multiply circuitry, retrieving the results once it&#39;s done, etc.</span></p><p><span>SIMD instructions - short for “single instruction, multiple data” - are a way to </span><em>amortize</em><span> the second type work. Instead of the multiply instruction taking one float and multiplying it by one other float, you define the multiply to take </span><em>many</em><span> floats and multiply them by </span><em>many</em><span> other floats. This is essentially equivalent to taking many multiply instructions with independent inputs and combining them into a single instruction.</span></p><p>Because high-performance computation almost always involves performing similar operations on large amounts of data, SIMD instructions have proven to be a popular way to reduce instruction overhead. All modern consumer CPUs and GPUs use SIMD processing for their core math operations: x64 has SSE, AVX, and AVX-512; ARM has NEON and SVE; and nVidia/AMD/Intel GPUs all have their own internal SIMD instruction sets.</p><p><span>But why did I say “vector instructions”, instead of “SIMD instructions”, in the title of this section? Well, technically RISC-V V is a particular </span><em>type</em><span> of SIMD instruction set called a </span><em>vector</em><span> instruction set.</span></p><p><span>There are two common kinds of instruction sets that leverage SIMD: &#34;Packed&#34; instruction sets, like AVX2 and NEON, use fixed-length registers, so instructions are defined to operate on a specific number of items. When code is written (or compiled) for the ISA, the stride of loops is </span><em>fixed at compile time</em><span>. If a loop is compiled for the 4-wide version of the instruction set, then it will always run 4-wide, </span><em>even if it is later run on a CPU that is 8-wide</em><span>. Code must be rewritten (or re-compiled) to target a new version of the ISA each time the width is expanded if you want to take advantage of the newer, wider CPUs.</span></p><p><span>&#34;Vector&#34; instruction sets like ARM SVE and RISC-V V, by contrast, do not specify the exact number of items in the ISA. They instead provide instructions you can use when writing loops to </span><em>adjust</em><span> the stride of the loop based on how many items </span><em>that particular CPU</em><span> can handle at a time. So the same instruction sequence, on the same ISA, will run at different widths on different CPUs. Running on an 4-wide CPU and a 8-wide CPU, the exact same loop code will run 4-wide and 8-wide, respectively.</span></p><p>Although packed vs. vector is an important architectural difference to consider in general, it can be safely ignored with respect to the mask bit problem described in this article. The same problem would exist in either design.</p><h2>What are &#34;mask bits&#34; and &#34;predicated instructions&#34;?</h2><p>An obvious problem arises as soon as you have instructions operating on multiple pieces of data at the same time: some operations need to be applied only to a subset of the data.</p><p>As a simple example, suppose you wanted to add 5 to any input that was greater than 0. In a scalar loop, you are accustomed to using a branch to jump around the addition if the input value isn&#39;t greater than 0. This works because there is only one value per iteration of the loop, so there&#39;s only one answer to the question &#34;is the input greater than 0?&#34;</p><p>However, when you are operating on many values at the same time, you are no longer guaranteed a single answer. Perhaps some of the inputs are greater than 0, but some are not. What do you do?</p><p><span>The solution to this problem in SIMD instruction sets is to make comparison instructions produce a full bit pattern - called a </span><em>mask</em><span> - rather than a single-bit answer used in a branch. Each bit in the mask holds the result of the comparison for one of the inputs. Using the mask, each instruction that performs an operation on multiple inputs - such as our &#34;add 5&#34; - can use the corresponding bit to know whether to perform the operation or not on each of the inputs individually.</span></p><p>This can be done in one of three ways: </p><ol><li><p>using additional &#34;and&#34;, &#34;andnot&#34;, and &#34;or&#34; instructions to merge results together based on the bit pattern,</p></li><li><p>using a single special-purpose “select” instruction that does the merge in a single instruction, or</p></li><li><p><span>intrinsically, by SIMD hardware that supports </span><em>predicated</em><span> instructions. </span></p></li></ol><p>Predicated instructions read the mask bits as part of the instruction, and leave unaffected those lanes untouched where the mask is zero. This obviates the need to manually merge results.</p><p>RISC-V V has predicated instruction support in the ISA. Every vector instruction that performs an operation has two versions: one that operates on the entire set of inputs, and one that uses a mask.</p><h2>Where and how are RISC-V mask bits stored?</h2><p><span>Unlike ARM SVE and AVX-512, RISC-V V lacks support for mask </span><em>registers</em><span>. It does not define an additional set of registers for holding these mask values. And, unlike the CRAY-1, it also doesn’t define a </span><em>single</em><span> additional vector mask register, either.</span></p><p>Instead, the RISC-V V spec defines mask bits as always coming from the first vector register, v0. Any time an instruction uses a mask, it will use v0 as the source of the mask. This doesn&#39;t mean you can&#39;t have multiple masks, but it does mean that you must always move your masks into v0 before issuing masked instructions.</p><p>Although this may seem like a significant drawback, it&#39;s actually not that alarming, at least not to me. While it&#39;s true that you must insert various &#34;move mask to v0&#34; instructions that wouldn&#39;t otherwise be there, it&#39;s important to remember that these will not really be actual computation instructions. Moves from one vector register to another will always be simple register renames handled by the front end of any high-performance chip, and I would consider it highly unlikely that you would change masks so frequently as to overburden the front end.</p><p>Thus, although not having mask registers does pose a problem for register pressure (since your masks are now taking up registers you’d otherwise have for your actual values, etc.), that problem is one that would be completely alleviated by a future mask register spec. There is no obvious, large backwards-compatibility cost to the chip design for this interim solution existing, so I probably wouldn&#39;t take the time to write a whole article like this if that were the only issue.</p><h2>What is the problem with the RISC-V mask bits?</h2><p><span>The problem isn&#39;t the lack of mask registers, or the limitation that it has to be v0. Instead, the problem is </span><em>where</em><span> the bits are defined to be stored in v0.</span></p><p>If you imagine how a physical CPU or GPU has to be constructed in order to do large multi-input operations - such as multiplying 64 floats at a time, a not-unreasonable number for something like a GPU - there are hard constraints on where the bits of the inputs come from. You can imagine these inputs as being in &#34;lanes&#34; that are arranged across the chip such that the inputs to each lane are stored near the lane. Getting a 64-float multiply to run quickly means you can’t shuttle all 64 floats from some central location all the way to each of the 64 multiply units. Such an operation would be more like an L1 cache fetch, as opposed to direct use of a register.</p><p>So for example, when you think of a single vector register, rather than thinking of it as one big blob containing something like 64 floats, you instead have to think of it as 64 separate floats, each stored near its respective lane, such that when it is used as the input to a multiply, the floats are each close to the lane multiplier they actually need to use. In other words, it&#39;s more like 64 sets of single-float registers feeding 64 single-float multipliers than it is a big 64-float register stored in one place and a big 64-float multiplier in another.</p><p><span>When you use dedicated mask registers, the chip designer is free to spread those mask bits across all the lanes to ensure that the storage for the mask register keeps each bit close to the lane where it will be used as a predicate - just like they do with the vector registers themselves. However, the RISC-V V spec makes an unreasonable demand on the organization of the mask register bits: it specifically says that the bits of v0 that will be used for masking are the </span><em>lowest n bits</em><span> of the entire register.</span></p><p>This means, for example, if you had the 64-float registers hypothesized above, you would store the corresponding 64-bit mask in just the first two (low-order) float lanes of v0 (and the other 62 lanes are all empty). The 32-bits of the first lane would be the mask bits for the first 32 lanes, and the 32-bits of the second lane would be the mask bits for the second 32 lanes.</p><p>This puts the chip designer in a bind: if an instruction calls for v0 to be used as a vector input, then the low-order bits of v0 would want to be stored near the low lanes. But if an instruction calls for v0 to be used as the mask, suddenly those same bits want to spread across all the lanes! The ISA basically wants the designer to have the same bit in two different places at once.</p><p><span>And, although I’m not knowledgeable enough about chip design to know what the best work-around is here, that’s </span><em>basically</em><span> what they’re going to have to do. I’d imagine most high-performance designs will resort to some kind of shadowing where they try to keep the bits stored </span><em>as if</em><span> they were a mask register when they come out of mask instructions, </span><em>as if</em><span> they were a vector register when they come out of vector instructions, and then have some hacks in there to work around cases where the instruction stream does something unexpected and the bits aren’t in the right place.</span></p></div></div></div></article></div></div></div>
  </body>
</html>
