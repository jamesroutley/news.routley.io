<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://subzero.cloud/blog/serverfree-architecture/">Original</a>
    <h1>Is offline-first not enough? Do we need &#34;serverfree&#34;?</h1>
    
    <div id="readability-page-1" class="page"><div><h2>What if Serverless Meant No Backend Servers?</h2><p>By now, everyone knows that serverless doesn&#39;t actually mean without servers; it just means using someone else&#39;s servers. But what if it really meant no servers at all? What if you could run your code entirely without any servers? You might be thinking, &#34;That&#39;s just desktop applications,&#34; but that&#39;s not what I&#39;m referring to. What if we could run a traditional web app, composed of frontend code, that talks to an express-like server and saves data in a database, all without any servers? No backend servers, no containers, no virtual machines, nothing. Just code, a browser (well, and a place to serve our static files from, which technically is a server).</p><p>I&#39;ll call this the ServerFreeâ„¢ architecture.</p><h3 id="tldr">TL;DR </h3><p>This article demonstrates how to build a web application that is packaged to run in the browser, including the database.<!-- --> <!-- -->The frontend code is build as usual, the backend is packaged and runs in a web worker and for the database we use <a href="https://sqlite.org/wasm/doc/trunk/index.md">SQLite compiled to WebAssembly</a>.</p><p>The code for the demo app is available on <a href="https://github.com/subzerocloud/my-way-track">github</a>.</p><p>A live version is running on <a href="https://my-way-track.vercel.app/">https://my-way-track.vercel.app/</a>.</p><p>The article is split into a few sections. The first few cover the building of our application with a classic architecture using subZero libraries, the last section covers the conversion to a ServerFree architecture.</p><ul><li><a href="#first-attempt">First attempt with a classic architecture (the easy part)</a><ul><li><a href="#database-schema">The database schema</a></li><li><a href="#better-layout">Better Layout</a></li><li><a href="#custom-components">Custom components for Opportunities</a></li><li><a href="#dashboard">The Dashboard</a></li></ul></li><li><a href="#mvp-v1">MVP V1 (small detour with Turso DB)</a></li><li><a href="#serverfree">Converting to ServerFree architecture (the fun part)</a><ul><li><a href="#sqlite-wasm">SQLite compiled to WebAssembly</a></li><li><a href="#web-worker">The Web Worker</a></li><li><a href="#service-worker">The Service Worker</a></li><li><a href="#main-thread">The Main Thread</a></li></ul></li></ul><h3 id="idea">The Idea  </h3><p>One morning, as I was contemplating ways to procrastinate on doing marketing for SubZero without feeling guilty, an idea struck me. &#34;I know, I&#39;ll engage in some content marketing... but what do I need for that? Oh, a cool demo project!&#34; And just like that, I found a way to spend a month <s>doing content marketing</s> writing code.</p><p>Lately, it seems like most developer-focused content leans more towards spam than substance. You see titles like &#34;Build &lt;thing&gt; in 5 minutes&#34; or &#34;Create a &lt;fang&gt; clone in 1 hour (with our SaaS),&#34; but once you scratch the surface, they often turn out to be another trivial todo/blog/chat app that nobody really uses.</p><p>I wanted to create something different, something genuinely useful. While seeking inspiration on Hacker News, I stumbled upon <a href="https://news.ycombinator.com/item?id=37792507">Show HN: A job application tracker with company reviews, recruiter autoresponder</a>. It looked like a useful tool, one that could be built reasonably fast using the SubZero stack.</p><p>However, looking through comments, one thing caught my eye: A lot of people commented on the privacy aspect of the app.<!-- --> <!-- -->This is where the things derailed a bit from a one day demo project to a &#34;down the rabbit hole of web workers, incompatibilities, missing documentations and other fun stuff&#34; project.</p><p>And that, boys and girls, is how one inadvertently invents a new architecture instead of sticking to marketing like a sane person.</p><h3 id="first-attempt">First attempt with a classic architecture (the easy part) </h3><h4 id="database-schema">The database schema </h4><p>So i fired the subzero cli and after a quick <code>npx @subzerocloud/scaffold@latest new</code>, changing the <a href="https://github.com/subzerocloud/my-way-track/commit/6084a8d1ccaccd6373f6c33a48429612a019a0a4">database schema</a> and configuring permissions, i had a reasonably functioning app. This took a hole 10 minutes, I know this is like ages compared to other tools accomplish things in &#34;literally seconds&#34; but what can I say...</p><figure><img src="https://subzero.cloud/blog/serverfree-architecture/default-dashboard.png" alt=""/><figcaption></figcaption></figure><figure><img src="https://subzero.cloud/blog/serverfree-architecture/default-opportunities.png" alt=""/><figcaption></figcaption></figure><p>While this already has some powerful functionality (full CRUD and filtering, just by introspecting the database schema), I want to build something that is closer to a product than a demo. So, let&#39;s do some UI customization. You&#39;ll see that the backend functionality is so powerful that we never have to touch the backend code (<code>server.ts</code>, which is like 200 LOC).</p><h4 id="better-layout">Better Layout </h4><p>The first thing we&#39;ll change is the layout. There&#39;s a lot of wasted space on the left side, so let&#39;s move the sidebar to the top.</p><p>Here is the commit that accomplishes this: <a href="https://github.com/subzerocloud/my-way-track/commit/adf1b8cf4ee24d4154aeb451d0e128781ee6d45f">Change Layout</a>.</p><figure><img src="https://subzero.cloud/blog/serverfree-architecture/layout-dashboard.png" alt=""/><figcaption></figcaption></figure><figure><img src="https://subzero.cloud/blog/serverfree-architecture/layout-opportunities.png" alt=""/><figcaption></figcaption></figure><h4 id="custom-components">Custom Components for Opportunities </h4><p>Next, we&#39;ll turn our attention to the &#34;Opportunities&#34; page, since this is where the main functionality of the app is provided. We&#39;ll add custom Show, Create, Edit, and List components for the Opportunities. The list page will also contain a custom filter component.</p><p>Here is the commit that accomplishes this: <a href="https://github.com/subzerocloud/my-way-track/commit/4d1c01a50132ea7f44a8d5b4553c4215b229b2b1">Custom Opportunities Components</a>.</p><figure><img src="https://subzero.cloud/blog/serverfree-architecture/custom-list.png" alt=""/><figcaption></figcaption></figure><figure><img src="https://subzero.cloud/blog/serverfree-architecture/custom-edit.png" alt=""/><figcaption></figcaption></figure><figure><img src="https://subzero.cloud/blog/serverfree-architecture/custom-show.png" alt=""/><figcaption></figcaption></figure><p>A few notes on the changes above:</p><ul><li><p>Notice that <code>App.tsx</code> received almost no changes; we essentially instructed it to &#34;use these custom components when rendering pages for this model.&#34;</p></li><li><p>For Create and Edit, we used the same <code>OpportunityForm</code> component, which is devoid of &#34;logic.&#34; It only defines the components to be used for each field.</p></li><li><p>The Show page features the <code>OpportunityShow</code> component, which also requires no complex logic. Simple HTML with some Tailwind classes gets the job done.</p></li><li><p>On the List page, we have some very light formatting logic for a few fields. The key component here is the <code>OpportunityFilter</code>. While it primarily consists of declarative JSX code and lacks intricate business logic, the filtering capabilities it enables are remarkably powerful and flexible. This showcases the thoughtful design of <a href="https://marmelab.com/react-admin/">React Admin</a>. By defining our <code>Datagrid</code> and <code>Filter</code> components, the library orchestrates the interactions between lists, filters, and the backend API, eliminating the need for explicit logic like &#34;when I click this button, call this API and update the list with the results.&#34;</p></li><li><p>Lastly, I want to highlight that we&#39;ve implemented complex flows, especially for filtering, without needing to add any custom backend endpoints to handle the complexity.</p></li></ul><p>If you&#39;ve looked at the <a href="https://github.com/subzerocloud/my-way-track/commit/dddd42e52f7eac47d9ee191dbd034dd7a990ba19">commit</a> following the one mentioned earlier, you might have noticed a small change in <code>server.ts</code>. At first glance, you might think, &#34;Aha, they did have to change the backend code.&#34; However, this particular case highlights the flexibility of SubZero rather than its limitations. Let me explain.</p><p>In our database schema, we used a column named <code>stage_ids</code> to hold the IDs of completed stages for each opportunity. In the filtering component, we aimed to provide a way to display opportunities that completed a specific stage. The SubZero REST API, which follows the PostgREST specs, has a filtering operator called <code>cs</code>. This operator, corresponding to PostgreSQL&#39;s <code>@&gt;</code> operator, checks if a value is contained in an array. Our database, however, uses SQLite, which doesn&#39;t natively support this operator. Many people overlook SQLite, thinking it lacks certain features they need. But SQLite is highly extensible, allowing the addition of custom functions. We added a custom function to SQLite that implements the <code>@&gt;</code> operator (the <code>cs</code> function). Now, we can effectively use this in our filtering. Neat, right?</p><h4 id="dashboard">The Dashboard </h4><p>At this stage, we have a fully functional app, but the Dashboard displays only some generic information about the number of tables and columns in our schema. Let&#39;s enhance it to show more relevant data, such as &#34;Open Opportunities,&#34; &#34;Average Progress / Application,&#34; and &#34;Average Days Since Application.&#34;</p><p>Here is the commit that accomplishes this: <a href="https://github.com/subzerocloud/my-way-track/commit/7192e514a77c12df0f5b67f3c6a878688fb48fd7">Custom Dashboard</a>.</p><figure><img src="https://subzero.cloud/blog/serverfree-architecture/custom-dashboard.png" alt=""/><figcaption></figcaption></figure><p>While you might expect some complex rendering logic for those visually appealing panels and charts, you&#39;ll be pleasantly surprised to find that the code is quite simple, thanks to <a href="https://www.tremor.so/">Tremor</a>. All you need is the data to display, and here, the power of the SubZero REST API shines through. Once again, we did not need to write any custom backend code to achieve this.</p><p>Take a look at these beauties in <code>Dashboard.tsx</code>:</p><pre><code><span></span>
<span>client</span>
<span>    </span><span>.</span><span>from</span><span>(</span><span>&#39;opportunities&#39;</span><span>)</span><span></span>
<span>    </span><span>.</span><span>select</span><span>(</span><span>`</span><span></span>
<span>        week:$strftime(&#39;%Y-%W&#39;, created_at),</span>
<span>        total:$count(id)</span>
<span>    </span><span>`</span><span>)</span><span></span>
<span>    </span><span></span>
<span>    </span><span>.</span><span>groupby</span><span>(</span><span>&#39;week&#39;</span><span>)</span><span></span>
<span>    </span><span>.</span><span>then</span><span>(</span><span>(</span><span>{</span><span> data </span><span>}</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>        </span><span>setPerWeekApplications</span><span>(</span><span>data</span><span>)</span><span>;</span><span></span>
<span>    </span><span>}</span><span>)</span><span>;</span><span></span>
<!-- -->
<span></span><span></span>
<span>client</span>
<span>    </span><span>.</span><span>from</span><span>(</span><span>&#39;opportunities&#39;</span><span>)</span><span></span>
<span>    </span><span>.</span><span>select</span><span>(</span><span>`</span><span></span>
<span>        $avg($sub($unixepoch(updated_at),$unixepoch(created_at)))</span>
<span>    </span><span>`</span><span>)</span><span></span>
<span>    </span><span>.</span><span>is</span><span>(</span><span>&#39;close_reason&#39;</span><span>,</span><span> </span><span>&#39;null&#39;</span><span>)</span><span></span>
<span>    </span><span>.</span><span>single</span><span>(</span><span>)</span><span></span>
<span>    </span><span>.</span><span>then</span><span>(</span><span>(</span><span>{</span><span> data </span><span>}</span><span>:</span><span>PostgrestSingleResponse</span><span>&lt;</span><span>any</span><span>&gt;</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>        </span><span>setAvgDaysOpen</span><span>(</span><span>Math</span><span>.</span><span>round</span><span>(</span><span>data</span><span>.</span><span>avg </span><span>/</span><span> </span><span>86400</span><span>)</span><span>)</span><span>;</span><span></span>
<span>    </span><span>}</span><span>)</span><span>;</span>
</code></pre><h3 id="mvp-v1">MVP V1 (Small Detour with Turso DB) </h3><p>At this point, we have a nice-looking, fully functional app, complete with a backend server, a database, and a frontend. It would be a shame not to explore how we can package this classic architecture into a single deployable unit for production. So, let&#39;s do that.</p><h4 id="docker-image">The docker image </h4><p>Deploying this to production is a matter of building the image:</p><pre><code><span>docker build -t my-way-track .</span>
</code></pre><p>seeding the database:</p><pre><code><span>(cd db &amp;&amp; sqlite3 production.db &lt; init.sql)</span>
</code></pre><p>and running the container:</p><pre><code><span>docker run --rm \</span>
<span>-p 3000:3000 \</span>
<span>-e JWT_SECRET=&#34;&lt;LONG_JWT_SECRET_GOES_HERE&gt;&#34; \</span>
<span>-v &#34;$(pwd)/db/production.db:/app/app.db&#34; \</span>
<span>my-way-track</span>
</code></pre><p>Now, the application can be accessed at http://localhost:3000, but logging in isn&#39;t possible because the test user, which was being created by the SubZero development tooling, is no longer there. Therefore, we need to create a user.</p><p>First, we&#39;ll need an <code>env.production</code> file to store some configuration settings for the SubZero CLI, enabling it to connect to the production instance of the app.</p><p>Save the following in <code>env.production</code>:</p><pre><code><span>API_EXTERNAL_URL=http://localhost:3000/auth</span>
<span>GOTRUE_JWT_SECRET=&lt;LONG_JWT_SECRET_GOES_HERE&gt;</span>
</code></pre><p>Now we can use the cli to create the user:</p><pre><code><span>CONFIG_PATH=.env.production npx auth-cli users create</span>
</code></pre><p>Check the user was created:</p><pre><code><span>CONFIG_PATH=.env.production npx auth-cli users list</span>
</code></pre><h4 id="turso-db">Meet Turso DB </h4><p>We now have the Docker image and can deploy it anywhere we want, but there&#39;s still one aspect that&#39;s not ideal: the database. The SQLite database file needs to live outside the container to persist data between container restarts. While services running our container might offer vendor-specific ways to persist files, this isn&#39;t ideal. Wouldn&#39;t it be nice if we could access SQLite with a connection string, similar to PostgreSQL or MySQL? Thanks to <a href="https://turso.tech/">Turso DB</a>, this is now possible. With this service/technology, we&#39;ve solved our SQLite database persistence and backup issues in one stroke.</p><p>The SubZero library has built-in support for Turso DB, so all we need to do is replace the better-sqlite3 client with the Turso DB client, and we&#39;re set. Check out the <a href="https://github.com/subzerocloud/my-way-track/commit/1ed38e9e724f91f135d9df404ad090bd1e9dedd3">commit</a> that implements this change.</p><p>Sign up for a free account at <a href="https://turso.tech/">https://turso.tech/</a> and create a database. Use <a href="https://docs.turso.tech/quickstart">this walkthrough</a> to set up the Turso CLI and create a database.</p><p>Once the database is created (in the commands below, we&#39;ve named the database <code>mywaytrack</code>), seed it like this:</p><pre><code><span>turso db shell mywaytrack &lt; db/include/schema.sql</span>
</code></pre><p>Get the connection string for the database:</p><pre><code><span>turso db show mywaytrack</span>
</code></pre><p>Get the token for the database:</p><pre><code><span>turso db tokens create mywaytrack</span>
</code></pre><p>Rebuild the docker image:</p><pre><code><span>docker build -t my-way-track .</span>
</code></pre><p>Run the container:</p><pre><code><span>docker run --rm \</span>
<span>-p 3000:3000 \</span>
<span>-e JWT_SECRET=&#34;&lt;LONG_JWT_SECRET_HERE&gt;&#34; \</span>
<span>-e DB_URI=&#34;&lt;turso_connection_string_here&gt;&#34; \</span>
<span>-e TURSO_TOKEN=&#34;&lt;TURSO_ACCESS_TOKEN_HERE&gt;&#34; \</span>
<span>my-way-track</span>
</code></pre><p>Create the user:</p><pre><code><span>CONFIG_PATH=.env.production npx auth-cli users create</span>
</code></pre><p>Now we have a way of deploying and restarting our app without losing the data in our SQLite database.</p><h3 id="serverfree">Converting to ServerFree Architecture (The Fun Part) </h3><p>Here&#39;s how all the components fit together and what we are aiming to achieve:</p><figure><img src="https://subzero.cloud/blog/serverfree-architecture/diagram.png" alt=""/><figcaption></figcaption></figure><p>Below, I&#39;ll go through each component, explaining how it works, the reasoning behind it, and the challenges I faced.</p><p>Most of the changes were implemented in this <a href="https://github.com/subzerocloud/my-way-track/commit/d0f97e70a9879f05edd8c79fb1ed433c17e491f7">commit</a>.</p><h4 id="sqlite-wasm">SQLite Compiled to WebAssembly </h4><p>If, like me, you spend a lot of time on HackerNews, you&#39;ve probably heard about the <a href="https://sqlite.org/wasm/doc/trunk/index.md">version of SQLite</a> compiled to WebAssembly. Though I&#39;ve never seen it used in a real-world application, it&#39;s a core component of our ServerFree architecture. After all, everyone needs a database, right?</p><p>For storage, it offers options like localStorage and sessionStorage, which aren&#39;t very useful for our case â€” too small and volatile for my taste. However, it also supports using the Origin-Private FileSystem (OPFS). This is a relatively new development in the browser world, yet it&#39;s already supported by all major browsers.</p><p>There is a small catch, though, when using OPFS with SQLite: the code interacting with the database must run in a Web Worker. Additionally, when the worker script is fetched from the server, you need to set these headers:</p><pre><code><span>Cross-Origin-Embedder-Policy: require-corp</span>
<span>Cross-Origin-Opener-Policy: same-origin</span>
</code></pre><h4 id="web-worker">The Web Worker </h4><p>We need to run our backend code in a web worker, primarily because we&#39;re using SQLite with OPFS. Fortunately, this requirement works in our favor, as it allows the backend code to run on a separate thread, preventing the UI thread from being blocked.</p><p>To make our code compatible with a WebWorker environment, we mostly needed to eliminate dependencies on NodeJS-specific APIs and replace them with browser-compatible ones.</p><p>The server code was using Express, primarily for routing and the HTTP server â€“ functions that rely on NodeJS-specific APIs. To address this, I replaced Express with <a href="https://github.com/kwhitley/itty-router">itty-router</a>. Itty-router provides similar routing/middleware functionality but is browser-compatible.</p><p>I kept <a href="https://github.com/subzerocloud/my-way-track/blob/main/src/server.ts">src/server.ts</a> worker-agnostic, only exporting the <code>router</code> and <code>init</code> function. From there, the worker just needs to call</p><pre><code><span>await</span><span> router</span><span>.</span><span>handle</span><span>(</span><span>request</span><span>,</span><span> response</span><span>,</span><span> </span><span>function</span><span> </span><span>(</span><span>e</span><span>)</span><span> </span><span>{</span><span> </span><span>throw</span><span> e</span><span>;</span><span> </span><span>}</span><span>)</span><span>;</span>
</code></pre><p>This approach keeps things nicely separated, allowing you to essentially copy and paste the worker code into your own project, along with your custom server logic.</p><h4 id="service-worker">The Service Worker </h4><p>The Service Worker is a lesser-known browser feature, and it was new to me before this project. Introduced in 2015, Service Workers essentially act as a proxy between the browser and the network. They can intercept requests and respond with cached data, enabling developers to build offline-first applications. However, they differ significantly from Web Workers, particularly in their lifecycle, and they&#39;re not intended for running application code (as the browser can terminate them at any time, causing loss of state). For a deeper dive into the stages of a Service Worker, check out <a href="https://web.dev/articles/service-worker-lifecycle">this article</a>.</p><p>Our interest lies in their ability to intercept requests made by the UI to the backend, allowing us to handle them in the worker. Initially, I tried running the entire backend in the Service Worker (not yet aware that the browser could terminate it anytime). However, I encountered a limitation: a specific OPFS capability was not available in the Service Worker environment. This meant I could not use SQLite from the Service Worker.</p><p>In the diagram above, you see a direct arrow between the Service Worker and the Web Worker. However, enabling direct communication between them was challenging due to the unpredictable start/stop nature of the Service Worker. The MessageChannel setup between them was lost randomly. Ultimately, a more reliable solution was to use the main thread as a proxy between the Service Worker and the Web Worker.</p><h4 id="main-thread">The Main Thread </h4><p>In the main thread (UI), I eliminated the code related to authentication. If you think about it, in this context, you authenticate when you log in to your computer. Although you are navigating to a web page, you are actually interacting with files on your computer, which is no different than interacting with a document or an Excel file.</p><h3 id="conclusion">Conclusion </h3><p>I believe this architecture holds a lot of potential, and I&#39;m eager to see what people will create with it. There are many use cases where this architecture is particularly advantageous, especially when customer data is distinct and there&#39;s no need to share it between users.</p><p>Here are some key benefits of this architecture:</p><ul><li><p><strong>No Backend Servers</strong>: This is the most apparent benefit. You can provide a service at the cost of hosting a static website, eliminating concerns about scaling.</p></li><li><p><strong>Privacy</strong>: Data is stored on the user&#39;s computer and never reaches your servers. This means less worry about complying with GDPR, CCPA, etc. One minor drawback is that the user needs to use the same computer/browser, but this can be addressed by providing a way to <a href="https://sqlite.org/wasm/doc/trunk/api-worker1.md#method-export">export/import</a> the database.</p></li><li><p><strong>Security</strong>: For sensitive data, such as medical records or financial information, you don&#39;t need to worry (as much) about encryption, data leaks, etc.</p></li><li><p><strong>Offload Work from the Backend</strong>: With tools like <a href="https://electric-sql.com/">Electric</a>, you can sync part of the database to the client and route some requests/queries to be handled by the browser, which would otherwise burden the backend server. This can be achieved without major changes to your frontend code.</p></li></ul></div></div>
  </body>
</html>
