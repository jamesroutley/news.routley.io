<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://endler.dev/2017/yes/">Original</a>
    <h1>A little story about the `yes` Unix command</h1>
    
    <div id="readability-page-1" class="page"><div><article><p>Published on 10th of October, 2017 Â· Updated on 29th of April, 2021</p><p>What&#39;s the simplest Unix command you know?</p><p>Among the series of simple Unix commands, there&#39;s also <code>yes</code>. If you execute it without arguments, you get an infinite stream of y&#39;s, separated by a newline:</p><pre><code><span>y
</span><span>y
</span><span>y
</span><span>y
</span><span>(...you get the idea)
</span></code></pre><p>What seems to be pointless in the beginning turns out to be pretty helpful :</p><pre><code><span>yes | sh boring_installation.sh
</span></code></pre><p>Ever installed a program, which required you to type &#34;y&#34; and hit enter to keep going? <code>yes</code> to the rescue! It will carefully fulfill its duty, so you can keep watching <a href="https://www.youtube.com/watch?v=yhBExhldRXQ">Pootie Tang</a>.</p><h2 id="writing-yes"><a href="#writing-yes"> <svg viewBox="0 0 24 24" height="22" width="22" xmlns="http://www.w3.org/2000/svg"> <path d="M0 0h24v24H0z" fill="none"></path> <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path> </svg> </a>Writing yes</h2><p>Here&#39;s a basic version in... uhm... BASIC.</p><pre><code><span>10 PRINT &#34;y&#34;
</span><span>20 GOTO 10
</span></code></pre><p>And here&#39;s the same thing in Python:</p><pre data-lang="python"><code data-lang="python"><span>while </span><span>True</span><span>:
</span><span>    </span><span>print</span><span>(</span><span>&#34;y&#34;</span><span>)
</span></code></pre><p>Simple, eh? Not so quick!</p><pre><code><span>python yes.py | pv -r &gt; /dev/null
</span><span>[4.17MiB/s]
</span></code></pre><p>Compare that with the built-in version on my Mac:</p><pre><code><span>yes | pv -r &gt; /dev/null
</span><span>[34.2MiB/s]
</span></code></pre><p>So I tried to write a quicker version in Rust. Here&#39;s my first attempt:</p><pre data-lang="rust"><code data-lang="rust"><span>use </span><span>std</span><span>::</span><span>env</span><span>;
</span><span>
</span><span>fn </span><span>main</span><span>() {
</span><span>  </span><span>let</span><span> expletive </span><span>= </span><span>env</span><span>::</span><span>args()</span><span>.</span><span>nth</span><span>(</span><span>1</span><span>)</span><span>.</span><span>unwrap_or</span><span>(</span><span>&#34;y&#34;</span><span>.</span><span>into</span><span>())</span><span>;
</span><span>  </span><span>loop </span><span>{
</span><span>    </span><span>println!</span><span>(</span><span>&#34;</span><span>{}</span><span>&#34;</span><span>,</span><span> expletive)</span><span>;
</span><span>  }
</span><span>}
</span></code></pre><p>Some explanations:</p><ul><li>The string we want to print in a loop is the first command line parameter and is named <em>expletive</em>. I learned this word from the <code>yes</code> manpage.</li><li>I use <code>unwrap_or</code> to get the <em>expletive</em> from the parameters. In case the parameter is not set, we use &#34;y&#34; as a default.</li><li>The default parameter gets converted from a string slice (<code>&amp;str</code>) into an <em>owned</em> string on the heap (<code>String</code>) using <code>into()</code>.</li></ul><p>Let&#39;s test it.</p><pre><code><span>cargo run --release | pv -r &gt; /dev/null
</span><span>   Compiling yes v0.1.0
</span><span>    Finished release [optimized] target(s) in 1.0 secs
</span><span>     Running `target/release/yes`
</span><span>[2.35MiB/s]
</span></code></pre><p>Whoops, that doesn&#39;t look any better. It&#39;s even slower than the Python version! That caught my attention, so I looked around for the source code of a C implementation.</p><p>Here&#39;s the <a href="https://github.com/dspinellis/unix-history-repo/blob/4c37048d6dd7b8f65481c8c86ef8cede2e782bb3/usr/src/cmd/yes.c">very first version of the program</a>, released with Version 7 Unix and famously authored by Ken Thompson on <nobr>Jan 10, 1979</nobr>:</p><pre data-lang="c"><code data-lang="c"><span>main</span><span>(argc</span><span>,</span><span> argv)
</span><span>char </span><span>**</span><span>argv</span><span>;
</span><span>{
</span><span>  </span><span>for </span><span>(</span><span>;;</span><span>)
</span><span>    </span><span>printf</span><span>(</span><span>&#34;</span><span>%s</span><span>\n</span><span>&#34;</span><span>,</span><span> argc</span><span>&gt;</span><span>1</span><span>?</span><span> argv[</span><span>1</span><span>]</span><span>: </span><span>&#34;y&#34;</span><span>)</span><span>;
</span><span>}
</span></code></pre><p>No magic here.</p><p>Compare that to the <a href="https://github.com/coreutils/coreutils/blame/master/src/yes.c">128-line-version from the GNU coreutils, which is mirrored on Github</a>. After 25 years, <em>it is still under active development!</em> The last code change happened around a <a href="https://github.com/coreutils/coreutils/commit/4cdb1703aff044de44d27e0558714542197f6dad">year ago</a>. That&#39;s quite fast:</p><pre><code><span># brew install coreutils
</span><span>gyes | pv -r &gt; /dev/null
</span><span>[854MiB/s]
</span></code></pre><p>The important part is at the end:</p><pre data-lang="c"><code data-lang="c"><span>/* Repeatedly output the buffer until there is a write error; then fail.  */
</span><span>while </span><span>(</span><span>full_write </span><span>(STDOUT_FILENO</span><span>,</span><span> buf</span><span>,</span><span> bufused) </span><span>==</span><span> bufused)
</span><span>  </span><span>continue</span><span>;
</span></code></pre><p>Aha! So they simply use a buffer to make write operations faster. The buffer size is defined by a constant named <code>BUFSIZ</code>, which gets chosen on each system so as to make I/O efficient (see <a href="https://www.gnu.org/software/libc/manual/html_node/Controlling-Buffering.html">here</a>). On my system, that was defined as 1024 bytes. I actually had better performance with 8192 bytes.</p><p>I&#39;ve extended my Rust program:</p><pre data-lang="rust"><code data-lang="rust"><span>use </span><span>std</span><span>::</span><span>env</span><span>;
</span><span>use </span><span>std</span><span>::</span><span>io</span><span>::</span><span>{</span><span>self</span><span>,</span><span> BufWriter</span><span>,</span><span> Write}</span><span>;
</span><span>
</span><span>const </span><span>BUFSIZE</span><span>: </span><span>usize </span><span>= </span><span>8192</span><span>;
</span><span>
</span><span>fn </span><span>main</span><span>() {
</span><span>    </span><span>let</span><span> expletive </span><span>= </span><span>env</span><span>::</span><span>args()</span><span>.</span><span>nth</span><span>(</span><span>1</span><span>)</span><span>.</span><span>unwrap_or</span><span>(</span><span>&#34;y&#34;</span><span>.</span><span>into</span><span>())</span><span>;
</span><span>    </span><span>let mut</span><span> writer </span><span>= </span><span>BufWriter</span><span>::</span><span>with_capacity(</span><span>BUFSIZE</span><span>, </span><span>io</span><span>::</span><span>stdout())</span><span>;
</span><span>    </span><span>loop </span><span>{
</span><span>        </span><span>writeln!</span><span>(writer, </span><span>&#34;</span><span>{}</span><span>&#34;</span><span>,</span><span> expletive)</span><span>.</span><span>unwrap</span><span>()</span><span>;
</span><span>    }
</span><span>}
</span></code></pre><p>The important part is, that the buffer size is a multiple of four, to ensure <a href="https://stackoverflow.com/a/381368/270334">memory alignment</a>.</p><p>Running that gave me 51.3MiB/s. Faster than the version, which comes with my system, but still way slower than the results from <a href="https://www.reddit.com/r/unix/comments/6gxduc/how_is_gnu_yes_so_fast/">this Reddit post</a> that I found, where the author talks about 10.2GiB/s.</p><h2 id="update"><a href="#update"> <svg viewBox="0 0 24 24" height="22" width="22" xmlns="http://www.w3.org/2000/svg"> <path d="M0 0h24v24H0z" fill="none"></path> <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path> </svg> </a>Update</h2><p>Once again, the Rust community did not disappoint.</p><pre data-lang="rust"><code data-lang="rust"><span>use </span><span>std</span><span>::</span><span>env</span><span>;
</span><span>use </span><span>std</span><span>::</span><span>io</span><span>::</span><span>{</span><span>self</span><span>,</span><span> Write}</span><span>;
</span><span>use </span><span>std</span><span>::</span><span>process</span><span>;
</span><span>use </span><span>std</span><span>::</span><span>borrow</span><span>::</span><span>Cow</span><span>;
</span><span>
</span><span>use </span><span>std</span><span>::</span><span>ffi</span><span>::</span><span>OsString</span><span>;
</span><span>pub const </span><span>BUFFER_CAPACITY</span><span>: </span><span>usize </span><span>= </span><span>64 </span><span>* </span><span>1024</span><span>;
</span><span>
</span><span>pub fn </span><span>to_bytes</span><span>(</span><span>os_str</span><span>:</span><span> OsString) </span><span>-&gt; </span><span>Vec</span><span>&lt;</span><span>u8</span><span>&gt; {
</span><span>  </span><span>use </span><span>std</span><span>::</span><span>os</span><span>::</span><span>unix</span><span>::</span><span>ffi</span><span>::</span><span>OsStringExt</span><span>;
</span><span>  os_str</span><span>.</span><span>into_vec</span><span>()
</span><span>}
</span><span>
</span><span>fn </span><span>fill_up_buffer</span><span>&lt;</span><span>&#39;a</span><span>&gt;(</span><span>buffer</span><span>: </span><span>&amp;</span><span>&#39;a mut</span><span> [</span><span>u8</span><span>], </span><span>output</span><span>: </span><span>&amp;</span><span>&#39;a</span><span> [</span><span>u8</span><span>]) </span><span>-&gt; </span><span>&amp;</span><span>&#39;a </span><span>[</span><span>u8</span><span>] {
</span><span>  </span><span>if</span><span> output</span><span>.</span><span>len</span><span>() </span><span>&gt;</span><span> buffer</span><span>.</span><span>len</span><span>() </span><span>/ </span><span>2 </span><span>{
</span><span>    </span><span>return</span><span> output</span><span>;
</span><span>  }
</span><span>
</span><span>  </span><span>let mut</span><span> buffer_size </span><span>=</span><span> output</span><span>.</span><span>len</span><span>()</span><span>;
</span><span>  buffer[</span><span>..</span><span>buffer_size]</span><span>.</span><span>clone_from_slice</span><span>(output)</span><span>;
</span><span>
</span><span>  </span><span>while</span><span> buffer_size </span><span>&lt;</span><span> buffer</span><span>.</span><span>len</span><span>() </span><span>/ </span><span>2 </span><span>{
</span><span>    </span><span>let </span><span>(left</span><span>,</span><span> right) </span><span>=</span><span> buffer</span><span>.</span><span>split_at_mut</span><span>(buffer_size)</span><span>;
</span><span>    right[</span><span>..</span><span>buffer_size]</span><span>.</span><span>clone_from_slice</span><span>(left)</span><span>;
</span><span>    buffer_size </span><span>*= </span><span>2</span><span>;
</span><span>  }
</span><span>
</span><span>  </span><span>&amp;</span><span>buffer[</span><span>..</span><span>buffer_size]
</span><span>}
</span><span>
</span><span>fn </span><span>write</span><span>(</span><span>output</span><span>: </span><span>&amp;</span><span>[</span><span>u8</span><span>]) {
</span><span>  </span><span>let</span><span> stdout </span><span>= </span><span>io</span><span>::</span><span>stdout()</span><span>;
</span><span>  </span><span>let mut</span><span> locked </span><span>=</span><span> stdout</span><span>.</span><span>lock</span><span>()</span><span>;
</span><span>  </span><span>let mut</span><span> buffer </span><span>= </span><span>[</span><span>0</span><span>u8</span><span>; </span><span>BUFFER_CAPACITY</span><span>]</span><span>;
</span><span>
</span><span>  </span><span>let</span><span> filled </span><span>= </span><span>fill_up_buffer</span><span>(</span><span>&amp;</span><span>mut</span><span> buffer</span><span>,</span><span> output)</span><span>;
</span><span>  </span><span>while</span><span> locked</span><span>.</span><span>write_all</span><span>(filled)</span><span>.</span><span>is_ok</span><span>() {}
</span><span>}
</span><span>
</span><span>fn </span><span>main</span><span>() {
</span><span>  </span><span>write</span><span>(</span><span>&amp;</span><span>env</span><span>::</span><span>args_os()</span><span>.</span><span>nth</span><span>(</span><span>1</span><span>)</span><span>.</span><span>map</span><span>(to_bytes)</span><span>.</span><span>map_or</span><span>(
</span><span>    Cow</span><span>::</span><span>Borrowed(
</span><span>      </span><span>&amp;</span><span>b</span><span>&#34;y</span><span>\n</span><span>&#34;</span><span>[</span><span>..</span><span>]</span><span>,
</span><span>    )</span><span>,
</span><span>    |</span><span>mut </span><span>arg</span><span>| {
</span><span>      arg</span><span>.</span><span>push</span><span>(</span><span>b</span><span>&#39;</span><span>\n</span><span>&#39;</span><span>)</span><span>;
</span><span>      Cow</span><span>::</span><span>Owned(arg)
</span><span>    }</span><span>,
</span><span>  ))</span><span>;
</span><span>  process</span><span>::</span><span>exit(</span><span>1</span><span>)</span><span>;
</span><span>}
</span></code></pre><p>Now that&#39;s a whole different ballgame!</p><ul><li>We prepare a filled string buffer, which will be reused for each loop.</li><li><a href="https://doc.rust-lang.org/std/io/struct.Stdout.html#method.lock">Stdout is protected by a lock</a>. So, instead of constantly acquiring and releasing it, we keep it all the time.</li><li>We use a the platform-native <a href="https://doc.rust-lang.org/std/ffi/struct.OsString.html"><code>std::ffi::OsString</code></a> and <a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>std::borrow::Cow</code></a> to avoid unnecessary allocations.</li></ul><p>The only thing that I could contribute was <a href="https://github.com/cgati/yes/pull/3/files">removing an unnecessary <code>mut</code></a>. ðŸ˜…</p><h2 id="lessons-learned"><a href="#lessons-learned"> <svg viewBox="0 0 24 24" height="22" width="22" xmlns="http://www.w3.org/2000/svg"> <path d="M0 0h24v24H0z" fill="none"></path> <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path> </svg> </a>Lessons learned</h2><p>The trivial program <code>yes</code> turns out not to be so trivial after all. It uses output buffering and memory alignment to improve performance. Re-implementing Unix tools is fun and makes me appreciate the nifty tricks, which make our computers fast.</p><ul><li>ðŸ’¬ Comments on <a href="https://www.reddit.com/r/rust/comments/75fll1/a_little_story_about_the_yes_unix_command/">Reddit</a>, <a href="https://news.ycombinator.com/item?id=15454352">Hacker News</a>.</li><li>ðŸ“– Translated into <a href="https://postd.cc/a-little-story-about-the-yes-unix-command/">Japanese</a>.</li></ul><div><p>Thanks for reading! I mostly write about Rust and my (open-source) projects. If you would like to receive future posts automatically, you can subscribe via <a href="https://endler.dev/rss.xml">RSS</a> or email:</p></div><p><a aria-label="Submit blog post to Hacker News" href="https://news.ycombinator.com/submitlink?u=https://endler.dev/2017/yes/&amp;t=A Little Story About the `yes` Unix Command"> <svg viewBox="0 0 16 16" aria-hidden="true" clip-rule="evenodd" fill-rule="evenodd" height="16" stroke-linejoin="round" stroke-miterlimit="1.41" version="1.1" width="16" xmlns="http://www.w3.org/2000/svg"><g transform="matrix(.0593 0 0 .0593 -8.6 -3.86)" stroke-width="1.05"><path d="m145 65h270v270h-270z" fill="#fb651e"></path><path d="m271 218-46.3-86.8h21.2l27.3 54.9c0.42 0.979 0.909 1.99 1.47 3.04 0.559 1.05 1.05 2.13 1.47 3.25 0.281 0.42 0.489 0.804 0.63 1.15 0.14 0.349 0.279 0.663 0.42 0.943 0.698 1.4 1.33 2.76 1.89 4.09 0.559 1.33 1.05 2.55 1.47 3.67 1.12-2.38 2.34-4.93 3.67-7.65 1.33-2.73 2.69-5.56 4.09-8.49l27.7-54.9h19.7l-46.8 87.9v56h-17.8z" fill="#fff" fill-rule="nonzero"></path></g> </svg> <span>Submit to HN</span> </a> <a aria-label="Sponsor Matthias on Github" href="https://github.com/sponsors/mre/"> <svg viewBox="0 0 16 16" aria-hidden="true" height="16" version="1.1" width="16"> <path d="M4.25 2.5c-1.336 0-2.75 1.164-2.75 3 0 2.15 1.58 4.144 3.365 5.682A20.565 20.565 0 008 13.393a20.561 20.561 0 003.135-2.211C12.92 9.644 14.5 7.65 14.5 5.5c0-1.836-1.414-3-2.75-3-1.373 0-2.609.986-3.029 2.456a.75.75 0 01-1.442 0C6.859 3.486 5.623 2.5 4.25 2.5zM8 14.25l-.345.666-.002-.001-.006-.003-.018-.01a7.643 7.643 0 01-.31-.17 22.075 22.075 0 01-3.434-2.414C2.045 10.731 0 8.35 0 5.5 0 2.836 2.086 1 4.25 1 5.797 1 7.153 1.802 8 3.02 8.847 1.802 10.203 1 11.75 1 13.914 1 16 2.836 16 5.5c0 2.85-2.045 5.231-3.885 6.818a22.08 22.08 0 01-3.744 2.584l-.018.01-.006.003h-.002L8 14.25zm0 0l.345.666a.752.752 0 01-.69 0L8 14.25z" fill-rule="evenodd"></path> </svg> <span>Sponsor me on Github</span> </a> <a aria-label="Amazon wishlist" href="https://www.amazon.de/hz/wishlist/ls/361PJ2MNLWL16?ref_=wl_share"> <svg viewBox="0 0 16 16" height="16"><defs></defs><path d="M4.068 2.493c-1.058.005-2.138.354-3.237 1.03v9.231c1.099-.676 2.179-1.025 3.237-1.03 1.058-.006 2.096.33 3.111 1.03v-9.23c-1.015-.7-2.053-1.037-3.111-1.031zm7.864 0c-1.058-.006-2.096.33-3.111 1.03v9.231c1.015-.7 2.053-1.036 3.111-1.03 1.058.005 2.138.354 3.237 1.03v-9.23c-1.099-.677-2.179-1.026-3.237-1.031z" fill="none" stroke="#999" stroke-width="1.668"></path></svg> <span>My Amazon wish list</span> </a></p></article></div></div>
  </body>
</html>
