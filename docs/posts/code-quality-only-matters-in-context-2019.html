<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.adamtornhill.com/articles/code-quality-in-context/why-i-write-dirty-code.html">Original</a>
    <h1>Code quality only matters in context (2019)</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
      
      <h3>
        by Adam Tornhill, October 2019
      </h3>
      <p>
        I used to obsess about code quality earlier in my career. My experience indicates that I&#39;m in good company here; a lot of us developers spend so much time growing our programming skills, and that kind of drive comes from intrinsic motivation. We care about what we do, and we want to do it well.
      </p>
      <p>
        However, over the past decade I have noticed a change in how I approach code quality. I still consider code quality important, but only in context. In this article I want to share the heuristics I use to decide when high-quality code is called for, and when we can let it slip. It&#39;s all about using data to guide when and where to invest in higher code quality, and how it can be a long-term saving to compromise it. Let&#39;s start by uncovering the motivation for investing in code quality.
      </p>
      <h2>Code quality only matters in context</h2>
      <p>
      Code quality is a broad and ill-defined concept. To me, code quality is all about understandability. The reason being that code is read exceedingly more often than it&#39;s modified. In fact, most of our development time is spent trying to understand existing code just so that we know how to change it. We developers don&#39;t really write code. Our primary task is to read code, and the easier our code is to reason about, the cheaper it is to modify.
      </p>
      <p>
      Now, let&#39;s pretend for a moment that we know that a particular piece of code will never ever be modified again. Would that change how you write that code? It should, at least in a world where business factors like time to market matter. So what would we do differently in this hypothetical scenario? Well, code comments would be the first thing to go -- the machine doesn&#39;t care about them anyway, and since the code won&#39;t ever be touched again, comments don&#39;t serve any real need. The same goes for design principles like loose coupling, high cohesion, and DRY -- none of those matter unless we have to revisit the code again. 
      </p>
      <p>
      Of course, quick and dirty code is all fun and games until we need to revisit it, understand it, and modify it. That&#39;s where the costs come. These delayed costs may be much higher than what it would have required to design the code properly in the first place, simply because we need to re-learn a part of the solution domain that is no longer fresh in our head. Since we cannot know up front if our code will be modified again or not, we learn to err on the safe side; better to make <em>all</em> code as clean as possible. That way we avoid unpleasant future surprises.
      </p>
      <p>
      With that reservation, I will claim that doing a quick and dirty solution is almost always a faster <em>short-term</em> solution (before you burn the heretic, please note that I emphasized <em>short-term</em>). But could it also be a viable long-term saving? Can we trade quality for speed in the long run as well? It turns out that we can in certain situations.
      </p>
      <p>
      When I reason about code, I&#39;m not only looking at the code. I have just as much interest in understanding its temporal characteristics and trends, which is data we can mine from version-control history. The key concept I use for code quality decisions is <em>hotspots</em>.
      </p>
      <p>
      A hotspot is code with high development activity and frequent churn. It&#39;s code that&#39;s worked on often, and hence code that has to be read and understood frequently, potentially by multiple authors. Here&#39;s an example from React.js, and a <a href="https://codescene.io/projects/5539/jobs/15495/results/code/hotspots/system-map">link to the interactive hotspot map</a>:
      </p>
      <p>
        <img src="https://www.adamtornhill.com/articles/code-quality-in-context/react-hotspots.png" width="800" alt="Hotspots visualize the development activity of each piece of code"/>
      </p>
      <p>
      The interesting thing with hotspots is that they make up a relatively minor part of the code, often just 1-3% of the total code size. However, that small portion of the code tends to attract an unproportional amount of development activity. This becomes apparent if we plot the change frequency of each file in a codebase:
      </p>
      <p>
        <img src="https://www.adamtornhill.com/articles/code-quality-in-context/hotspots-distribution.png" width="800" alt="The distribution of development activity across files in three separate codebases."/>
      </p>
      <p>
      As you see in the preceding figure, most of your code is likely to be in the long tail. That means it&#39;s code that&#39;s rarely if ever touched. The  hotspots, on the other hand, just make up a small part of the code but attract most of the development work.
      </p>
      <p>
      This implies that any code quality issues or technical debt in the hotspots, however minor, are likely to be expensive. Really expensive. Since the code is worked on so often, the additional costs in understanding the code and in making sure it doesn&#39;t break, multiply quickly. This is where code quality matters the most.
      </p>
      <p>
      I have used hotspot analyses in my daily work for the past 10 years. It&#39;s been a real game changer that I&#39;m taking full advantage of. Here&#39;s how: occasionally, I need to expand or tweak a feature that&#39;s been stable for a long time, so I find myself operating in the long tail of change frequencies. To me, that&#39;s an opportunity to make the bet that the code will continue to remain stable. You see, code frequently turn into hotspots because it implements a particularly volatile area of the domain where requirements are evolving. Stable code usually represent stable parts of the domain too. That allows me to take short cuts.
      </p>
      <p>
      For example, when working on code in the long tail I might realize that my new code is similar to some existing responsibility. So I copy-paste the original and tweak the copy to do what I want. Or I decide to add one more parameter to a function instead of looking for a concept to encapsulate. Or maybe I decide to squeeze in an extra if-statement in already tricky code. Yes, there&#39;s truly no limit to the sins I commit. But I only compromise quality in the long tail, and I only do it if I estimate that it will save me time.
      </p>
      <p>
      On the other hand, once I work in hotspots, I&#39;m well aware that the code will be worked on again; the best prediction of future activity is the code&#39;s history. So I take care in designing the code, and I often start by refactoring the existing solution to get a better starting point. Not only will this make life simpler for my colleagues; my future self is going to love me as well.
      </p>
      <h3>Take calculated risks</h3>
      <p>
      Before you walk into your manager&#39;s office to claim that <q>this crazy Swedish programmer claims that we can write crappy code and benefit from it</q>, I think it&#39;s only fair to point out that I do have some rules to control the risk. It has become sort of an informal process and safety-net that guides me in my day job.
      </p>
      <p>
      First of all, I know exactly how healthy my code is. I know the code health of each module in the codebase where I work thanks to <a href="https://codescene.com/">CodeScene</a>. CodeScene&#39;s Code Health metric was heavily researched and designed precisely for estimating how hard code would be for a human to understand. The code health metric doesn&#39;t care about the subjective stuff, like coding style or if a public constructor should lack a comment, but instead aims to catch the properties of code that really matter for maintainability.
      </p>
      <p>
      Knowing the health of your code -- at any time -- is key. Once you have that knowledge, you can start to use technical debt in its original sense. That is, you can take on technical debt strategically. And if you balance the amount of debt you take on based on the hotspot criteria, then it might even become an interest free loan. There might be a free lunch after all, it just requires data.
      </p>
      <p>
      When using the code health metric, I also tend to emphasize trends over absolute values. I use this to put a quality bar on any code that I touch. Should some code slide down and decline in health, then that might be a sign I&#39;ve gone too far and need to pay down the accumulated debt. To make it actionable, I run these checks in a CI/CD pipeline (you can read more on how this works on <a href="https://codescene.com/blog/codescene-ci-cd-quality-gates/">my other blog</a>).
      </p>
      <p>
        <img src="https://www.adamtornhill.com/articles/code-quality-in-context/code-health-quality-gate.png" width="800" alt="Use code health as a quality gate."/>
      </p>
      <p>
      Finally, I tend to write a test for most new code. When operating in the long tail, I might not put the full effort into making the code easily testable, but I do like to leave a test as a safety-net for my future self.
      </p>
      <h3>The perils of improving existing code</h3>
      <p>
      So far I&#39;ve talked about the economics of knowing when -- and when not -- to invest in code quality. But there&#39;s a different perspective too, and it&#39;s an argument about correctness. You see, clean code that doesn&#39;t work is rarely rewarded. And this is where it gets interesting. It turns out that there&#39;s a correlation between old, stable code and correctness.
      </p>
      <p>
      I covered this in <a href="https://pragprog.com/titles/atevol/software-design-x-rays/">Software Design X-Rays</a> under the title <q>Your Best Bug Fix Is Time</q>. In that section, I reference research that compares modules of different age. That is, the time since their last modification. That research finds that a module which is a year older than a similar module has roughly one-third fewer defects.
      </p>
      <p>
        <img src="https://www.adamtornhill.com/articles/code-quality-in-context/best-bug-fix-is-time.png" width="800" alt="Your best bug fix is time."/>
      </p>
      <p>
      Code stabilizes for different reasons. One might be that it&#39;s dead code, which means it can be safely deleted (always a win). Or it might become stable because it just works and does its job. Sure,the code may still be hard to understand, but what is there is likely to have been debugged into functionality. It&#39;s been battle tested and it just works. Using hotspots, you can ensure it stays that way.
      </p>
      <p>
      This correctness perspective is the main reason why I would like to put the Boy Scout Rule into context too; should we really be boy scouting code in the long tail? Code that we haven&#39;t worked on in a long time, and code that we might not touch again in the foreseeable future. I would at least balance the trade-offs between stabilizing code and refactoring it, and I tend to value stability higher. But again, it&#39;s a contextual discussion that cannot -- and shouldn&#39;t -- be taken as a general rule applicable to all code. All code isn&#39;t equal.
      </p>
      <h2>Code quality as a lever</h2>
      <p>
      I rarely use <q>clean code</q> as a term, simply because it suggests an absolute that I don&#39;t think exist, and the opposite -- dirty code -- is by definition unattractive. That said, I do appreciate much of the work by the clean code movement, I follow it closely, and I learn from it. I do think that the movement has pushed our industry in a good direction.
      </p>
      <p>
      My point is simply that <q>good</q> is contextual. And following a principle to the extreme means a diminishing return; we spend time polishing code with little pay off, and that&#39;s time we could have been spent on activities that actually benefit our business. By making contextual decisions, guided by data from how our code evolves, we can optimize our efforts and view code quality as a design option that we might or might not need in specific situations. It all depends.
      </p>
      <h3>About Adam Tornhill</h3>
    <p>
      Adam Tornhill is a programmer who combines degrees in engineering and psychology. He&#39;s the founder of Empear where he designs the <a href="https://codescene.com/">CodeScene tool</a> for software analysis. He&#39;s also the author of <a href="https://pragprog.com/titles/atevol/software-design-x-rays/">Software Design X-Rays: Fix Technical Debt with Behavioral Code Analysis</a>, the best selling <a href="https://pragprog.com/titles/atcrime/your-code-as-a-crime-scene/">Your Code as a Crime Scene</a>, <a href="https://leanpub.com/lispweb">Lisp for the Web</a>, <a href="https://leanpub.com/patternsinc">Patterns in C</a> and a public speaker. Adam&#39;s other interests include modern history, music, and martial arts.
    </p>
    
  
</div></div>
  </body>
</html>
