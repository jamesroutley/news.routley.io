<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://miccah.io/posts/go-interfaces.html">Original</a>
    <h1>What are Go interfaces?</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>I was talking to my coworker about interfaces when the question arose about why
a concrete slice has to manually be converted into an interface slice. I’ll
demonstrate this as a simple example.</p>

<div><div><pre><code><span>ints</span> <span>:=</span> <span>[]</span><span>int</span><span>{</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>7</span><span>}</span>

<span>var</span> <span>anys</span> <span>[]</span><span>any</span> <span>=</span> <span>ints</span> <span>// Error!</span>
<span>// cannot use ints (variable of type []int) as type []any in variable declaration</span>
</code></pre></div></div>

<p>This is perhaps surprising because semantically every <code>int</code> is an <code>any</code>, so why
doesn’t it work? I told my coworker it was because elements in a slice must all
have the same size, and interfaces are wide pointers. It was a good enough
explanation at the time, but it got me wondering.. are interfaces really wide
pointers? How are they actually represented at runtime?</p>

<h2 id="iface-and-eface">iface and eface</h2>

<p>Well fortunately for us, Go is <a href="https://github.com/golang/go">open source</a>! Poking around we can find a few
promising struct definitions: <a href="https://github.com/golang/go/blob/169203f3ee022abf66647abc99fd483fd10f9a54/src/runtime/runtime2.go#L202-L210">iface and eface</a>.</p>

<div><div><pre><code><span>type</span> <span>iface</span> <span>struct</span> <span>{</span>
	<span>tab</span>  <span>*</span><span>itab</span>
	<span>data</span> <span>unsafe</span><span>.</span><span>Pointer</span>
<span>}</span>

<span>type</span> <span>eface</span> <span>struct</span> <span>{</span>
	<span>_type</span> <span>*</span><span>_type</span>
	<span>data</span>  <span>unsafe</span><span>.</span><span>Pointer</span>
<span>}</span>
</code></pre></div></div>

<p>We can see here that both <code>iface</code> and <code>eface</code> are, indeed, double wide
pointers. The first pointer contains some sort of information about the type
and the second is a pointer to the actual data.</p>

<p>If these are the actual runtime types, we should be able to write a program to
inspect them. Let’s start by copying <code>eface</code> and its child structs.</p>

<h2 id="inspecting-eface">Inspecting eface</h2>

<div><div><pre><code><span>package</span> <span>main</span>

<span>import</span> <span>(</span>
	<span>&#34;fmt&#34;</span>
	<span>&#34;unsafe&#34;</span>
<span>)</span>

<span>func</span> <span>main</span><span>()</span> <span>{</span>
	<span>var</span> <span>a</span> <span>any</span> <span>=</span> <span>int64</span><span>(</span><span>0x41414141</span><span>)</span>
	<span>e</span> <span>:=</span> <span>*</span><span>(</span><span>*</span><span>eface</span><span>)(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>&amp;</span><span>a</span><span>))</span>

	<span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;%+v</span><span>\n</span><span>&#34;</span><span>,</span> <span>e</span><span>)</span>
	<span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;%+v</span><span>\n</span><span>&#34;</span><span>,</span> <span>e</span><span>.</span><span>_type</span><span>)</span>
	<span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;0x%x</span><span>\n</span><span>&#34;</span><span>,</span> <span>*</span><span>(</span><span>*</span><span>int64</span><span>)(</span><span>e</span><span>.</span><span>data</span><span>))</span>
<span>}</span>

<span>type</span> <span>eface</span> <span>struct</span> <span>{</span>
	<span>_type</span> <span>*</span><span>_type</span>
	<span>data</span>  <span>unsafe</span><span>.</span><span>Pointer</span>
<span>}</span>

<span>type</span> <span>_type</span> <span>struct</span> <span>{</span>
	<span>size</span>       <span>uintptr</span>
	<span>ptrdata</span>    <span>uintptr</span> <span>// size of memory prefix holding all pointers</span>
	<span>hash</span>       <span>uint32</span>
	<span>tflag</span>      <span>uint8</span>
	<span>align</span>      <span>uint8</span>
	<span>fieldAlign</span> <span>uint8</span>
	<span>kind</span>       <span>uint8</span>
	<span>// function for comparing objects of this type</span>
	<span>// (ptr to object A, ptr to object B) -&gt; ==?</span>
	<span>equal</span> <span>func</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>,</span> <span>unsafe</span><span>.</span><span>Pointer</span><span>)</span> <span>bool</span>
	<span>// gcdata stores the GC type data for the garbage collector.</span>
	<span>// If the KindGCProg bit is set in kind, gcdata is a GC program.</span>
	<span>// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span>
	<span>gcdata</span> <span>*</span><span>byte</span>
	<span>// The original types for these two were `nameOff` and `typeOff` which are</span>
	<span>// just int32. They represent an offset into.. something? for these values.</span>
	<span>str</span>       <span>int32</span>
	<span>ptrToThis</span> <span>int32</span>
<span>}</span>
</code></pre></div></div>

<p>Running this on my machine I get:</p>

<div><div><pre><code>{_type:0x489c00 data:0x4b9048}
&amp;{size:8 ptrdata:0 hash:2580995395 tflag:15 align:8 fieldAlign:8 kind:6 equal:0x402fa0 gcdata:0x4b8f7d str:2320 ptrToThis:17664}
0x41414141
</code></pre></div></div>

<p>Here we can see all of the information looks reasonably accurate. The size and
align is 8 bytes, the pointer types look like addresses, and of course the data
matches. <code>eface</code> appears to only be for the <code>any</code> type, or as it was previously
known, the <em>empty</em> interface <code>interface{}</code>. Empty interfaces, unlike other
interfaces, don’t have any methods associated with them.</p>

<h2 id="inspecting-iface">Inspecting iface</h2>

<p>Now let’s take a look at <code>iface</code>.</p>

<div><div><pre><code><span>package</span> <span>main</span>

<span>import</span> <span>(</span>
	<span>&#34;fmt&#34;</span>
	<span>&#34;unsafe&#34;</span>
<span>)</span>

<span>type</span> <span>I</span> <span>interface</span> <span>{</span>
	<span>I1</span><span>()</span>
	<span>I2</span><span>()</span>
<span>}</span>
<span>type</span> <span>S</span> <span>struct</span> <span>{</span>
	<span>foo</span> <span>int32</span>
	<span>bar</span> <span>string</span>
<span>}</span>

<span>func</span> <span>(</span><span>s</span> <span>S</span><span>)</span> <span>I1</span><span>()</span> <span>{</span> <span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;I1&#34;</span><span>)</span> <span>}</span>
<span>func</span> <span>(</span><span>s</span> <span>S</span><span>)</span> <span>I2</span><span>()</span> <span>{</span> <span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;I2&#34;</span><span>)</span> <span>}</span>

<span>func</span> <span>main</span><span>()</span> <span>{</span>
	<span>var</span> <span>s</span> <span>I</span> <span>=</span> <span>S</span><span>{</span><span>0x41414141</span><span>,</span> <span>&#34;BBBB&#34;</span><span>}</span>

	<span>i</span> <span>:=</span> <span>*</span><span>(</span><span>*</span><span>iface</span><span>)(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>&amp;</span><span>s</span><span>))</span>
	<span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;%+v</span><span>\n</span><span>&#34;</span><span>,</span> <span>i</span><span>)</span>
	<span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;%+v</span><span>\n</span><span>&#34;</span><span>,</span> <span>i</span><span>.</span><span>tab</span><span>)</span>
	<span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;%+v</span><span>\n</span><span>&#34;</span><span>,</span> <span>*</span><span>(</span><span>*</span><span>S</span><span>)(</span><span>i</span><span>.</span><span>data</span><span>))</span>
	<span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;struct addr:    %+v</span><span>\n</span><span>&#34;</span><span>,</span> <span>s</span><span>.</span><span>I1</span><span>)</span>
	<span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;fun table:      %+v</span><span>\n</span><span>&#34;</span><span>,</span> <span>(</span><span>*</span><span>func</span><span>())(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>&amp;</span><span>i</span><span>.</span><span>tab</span><span>.</span><span>fun</span><span>[</span><span>0</span><span>])))</span>
<span>}</span>

<span>type</span> <span>iface</span> <span>struct</span> <span>{</span>
	<span>tab</span>  <span>*</span><span>itab</span>
	<span>data</span> <span>unsafe</span><span>.</span><span>Pointer</span>
<span>}</span>

<span>type</span> <span>itab</span> <span>struct</span> <span>{</span>
	<span>inter</span> <span>*</span><span>interfacetype</span>
	<span>_type</span> <span>*</span><span>_type</span>
	<span>hash</span>  <span>uint32</span> <span>// copy of _type.hash. Used for type switches.</span>
	<span>_</span>     <span>[</span><span>4</span><span>]</span><span>byte</span>
	<span>fun</span>   <span>[</span><span>1</span><span>]</span><span>uintptr</span> <span>// variable sized. fun[0]==0 means _type does not implement inter.</span>
<span>}</span>

<span>type</span> <span>interfacetype</span> <span>struct</span> <span>{</span>
	<span>typ</span>     <span>_type</span>
	<span>pkgpath</span> <span>*</span><span>byte</span>
	<span>mhdr</span>    <span>[]</span><span>imethod</span>
<span>}</span>

<span>type</span> <span>imethod</span> <span>struct</span> <span>{</span>
	<span>// The original types for these two were `nameOff` and `typeOff` which are</span>
	<span>// just int32. They represent an offset into.. something? for these values.</span>
	<span>name</span> <span>int32</span>
	<span>ityp</span> <span>int32</span>
<span>}</span>

<span>type</span> <span>_type</span> <span>struct</span> <span>{</span>
	<span>/* Removed for brevity */</span>
<span>}</span>
</code></pre></div></div>

<p>Again, running this on my machine we get:</p>

<div><div><pre><code>{tab:0x4b9e28 data:0xc000010030}
&amp;{inter:0x48e060 _type:0x492140 hash:837923000 _:[0 0 0 0] fun:[4729568]}
{foo:1094795585 bar:BBBB}
struct addr:    0x482be0
fun table:      0x4b9e40
</code></pre></div></div>

<p>And again, most of this data looks reasonable. One thing I couldn’t figure out
though, is how to get the function address from the <code>fun</code> table. I printed them
out above and they are clearly different, off by about <code>0x37260</code> bytes. If
anyone knows how this is done, please let me know!</p>

<h2 id="conclusion">Conclusion</h2>

<p>So overall, interfaces <em>are</em> wide pointers with a special case for the empty
interface. One pointer always points to the actual data, and the other points
to type information, of which there’s a table of function pointers to call the
methods of the interface. There’s certainly more to explore here, but that’s a
good enough mental model for now.</p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
