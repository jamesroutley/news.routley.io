<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://smallcultfollowing.com/babysteps/blog/2022/06/15/what-it-feels-like-when-rust-saves-your-bacon/">Original</a>
    <h1>What it feels like when Rust saves your bacon</h1>
    
    <div id="readability-page-1" class="page"><section>
      <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>You‚Äôve probably heard that the Rust type checker can be a great ‚Äúco-pilot‚Äù, helping you to avoid subtle bugs that would have been a royal pain in the !@#!$! to debug. This is truly awesome! But what you may not realize is how it feels <em>in the moment</em> when this happens. The answer typically is: <strong>really, really frustrating!</strong> Usually, you are trying to get some code to compile and you find you just can‚Äôt do it.</p>

<p>As you come to learn Rust better, and especially to gain a bit of a deeper understanding of what is happening when your code runs, you can start to see when you are getting a type-check error because you have a typo versus because you are trying to do something fundamentally flawed.</p>

<p>A couple of days back, I had a moment where the compiler caught a really subtle bug that would‚Äôve been horrible had it been allowd to compile. I thought it would be fun to narrate a bit how it played out, and also take the moment to explain a bit more about temporaries in Rust (a common source of confusion, in my observations).</p>

<h2 id="code-available-in-this-repository">Code available in this repository</h2>

<p>All the code for this blog post is available in a <a href="https://github.com/nikomatsakis/2022-06-15-blogpost/">github repository</a>.</p>

<h2 id="setting-the-scene-lowering-the-ast">Setting the scene: lowering the AST</h2>

<p>In the compiler, we first represent Rust programs using an <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/ast/index.html">Abstract Syntax Tree (AST)</a>. I‚Äôve prepared a <a href="https://github.com/nikomatsakis/2022-06-15-blogpost/blob/f280f91e9be03d37f273acf13502ef7dc1015db8/examples/a.rs">standalone example</a> that shows roughly how the code looks today (of course the real thing is a lot more complex). The AST in particular is found in the <a href="https://github.com/nikomatsakis/2022-06-15-blogpost/blob/f280f91e9be03d37f273acf13502ef7dc1015db8/examples/a.rs#L4">ast module</a> containing various data structures that map closely to Rust syntax. So for example we have a <code>Ty</code> type that represents Rust types:</p>

<div><div><pre><code><span>pub</span> <span>enum</span> <span>Ty</span> <span>{</span>
    <span>ImplTrait</span><span>(</span><span>TraitRef</span><span>),</span>
    <span>NamedType</span><span>(</span><span>String</span><span>,</span> <span>Vec</span><span>&lt;</span><span>Ty</span><span>&gt;</span><span>),</span>
    <span>// ...</span>
<span>}</span>

<span>pub</span> <span>struct</span> <span>Lifetime</span> <span>{</span>
    <span>// ...</span>
<span>}</span>
</code></pre></div></div>

<p>The <code>impl Trait</code> notation references a <a href="https://github.com/nikomatsakis/2022-06-15-blogpost/blob/f280f91e9be03d37f273acf13502ef7dc1015db8/examples/a.rs#L12-L15"><code>TraitRef</code></a>, which stores the <code>Trait</code> part of things:</p>

<div><div><pre><code><span>pub</span> <span>struct</span> <span>TraitRef</span> <span>{</span>
    <span>pub</span> <span>trait_name</span><span>:</span> <span>String</span><span>,</span>
    <span>pub</span> <span>parameters</span><span>:</span> <span>Parameters</span><span>,</span>
<span>}</span>

<span>pub</span> <span>enum</span> <span>Parameters</span> <span>{</span>
    <span>AngleBracket</span><span>(</span><span>Vec</span><span>&lt;</span><span>Parameter</span><span>&gt;</span><span>),</span>
    <span>Parenthesized</span><span>(</span><span>Vec</span><span>&lt;</span><span>Ty</span><span>&gt;</span><span>),</span>
<span>}</span>

<span>pub</span> <span>enum</span> <span>Parameter</span> <span>{</span>
    <span>Ty</span><span>(</span><span>Ty</span><span>),</span>
    <span>Lifetime</span><span>(</span><span>Lifetime</span><span>),</span>
<span>}</span>
</code></pre></div></div>

<p>Note that the parameters of the trait come in two varieties, angle-bracket (e.g., <code>impl PartialEq&lt;T&gt;</code> or <code>impl MyTrait&lt;&#39;a, U&gt;</code>) and parenthesized (e.g., <code>impl FnOnce(String, u32)</code>). These two are slightly different ‚Äì parenthesized parameters, for example, only accept types, whereas angle-bracket accept types or lifetimes.</p>

<p>After parsing, this AST gets translated to something called <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/hir/index.html">High-level Intermediate Representation (HIR)</a> through a process called <em>lowering</em>. The snippet doesn‚Äôt include the HIR, but it includes a number of methods like <a href="https://github.com/nikomatsakis/2022-06-15-blogpost/blob/8232a6ee30e92faa2117dd23ee28d5c145509d92/examples/a.rs#L98-L116"><code>lower_ty</code></a> that take as input an AST type and produce the HIR type:</p>

<div><div><pre><code><span>impl</span> <span>Context</span> <span>{</span>
    <span>fn</span> <span>lower_ty</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> <span>ty</span><span>:</span> <span>&amp;</span><span>ast</span><span>::</span><span>Ty</span><span>)</span> <span>-&gt;</span> <span>hir</span><span>::</span><span>Ty</span> <span>{</span>
        <span>match</span> <span>ty</span> <span>{</span>
            <span>// ... lots of stuff here</span>
            <span>// A type like `impl Trait`</span>
            <span>ast</span><span>::</span><span>Ty</span><span>::</span><span>ImplTrait</span><span>(</span><span>trait_ref</span><span>)</span> <span>=&gt;</span> <span>{</span>
                <span>do_something_with</span><span>(</span><span>trait_ref</span><span>);</span>
            <span>}</span>

            <span>// A type like `Vec&lt;T&gt;`, where `Vec` is the name and</span>
            <span>// `[T]` are the `parameters`</span>
            <span>ast</span><span>::</span><span>Ty</span><span>::</span><span>NamedType</span><span>(</span><span>name</span><span>,</span> <span>parameters</span><span>)</span> <span>=&gt;</span> <span>{</span>
                <span>for</span> <span>parameter</span> <span>in</span> <span>parameters</span> <span>{</span>
                    <span>self</span><span>.lower_ty</span><span>(</span><span>parameter</span><span>);</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>// ...</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>Each method is defined on this <code>Context</code> type that carries some common state, and the methods tend to call one another. For example, <a href="https://github.com/nikomatsakis/2022-06-15-blogpost/blob/f280f91e9be03d37f273acf13502ef7dc1015db8/examples/a.rs#L57-L65"><code>lower_signature</code></a> invokes <a href="https://github.com/nikomatsakis/2022-06-15-blogpost/blob/8232a6ee30e92faa2117dd23ee28d5c145509d92/examples/a.rs#L98-L116"><code>lower_ty</code></a> on all of the input (argument) types and on the output (return) type:</p>

<div><div><pre><code><span>impl</span> <span>Context</span> <span>{</span>
    <span>fn</span> <span>lower_signature</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> <span>sig</span><span>:</span> <span>&amp;</span><span>ast</span><span>::</span><span>Signature</span><span>)</span> <span>-&gt;</span> <span>hir</span><span>::</span><span>Signature</span> <span>{</span>
        <span>for</span> <span>input</span> <span>in</span> <span>&amp;</span><span>sig</span><span>.inputs</span> <span>{</span>
            <span>self</span><span>.lower_ty</span><span>(</span><span>input</span><span>);</span>
        <span>}</span>

        <span>self</span><span>.lower_ty</span><span>(</span><span>&amp;</span><span>sig</span><span>.output</span><span>);</span>

        <span>...</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<h2 id="our-story-begins">Our story begins</h2>

<p><a href="https://github.com/spastorino/">Santiago Pastorino</a> is working on a refactoring to make it easier to support returning <code>impl Trait</code> values from trait functions. As part of that, he needs to collect all the <code>impl Trait</code> types that appear in the function arguments. The challenge is that these types can appear anywhere, and not just at the top level. In other words, you might have <code>fn foo(x: impl Debug)</code>, but you might also have <code>fn foo(x: Box&lt;(impl Debug, impl Debug)&gt;)</code>. Therefore, we decided it would make sense to add a vector to <code>Context</code> and have <code>lower_ty</code> collect the <code>impl Trait</code> types into it. That way, we can find the complete set.</p>

<p>To do this, we started by adding the vector into this <code>Context</code>. We‚Äôll store the <code>TraitRef</code> from each <code>impl Trait</code> type:</p>

<div><div><pre><code><span>struct</span> <span>Context</span><span>&lt;</span><span>&#39;ast</span><span>&gt;</span> <span>{</span>
    <span>saved_impl_trait_types</span><span>:</span> <span>Vec</span><span>&lt;&amp;</span><span>&#39;ast</span> <span>ast</span><span>::</span><span>TraitRef</span><span>&gt;</span><span>,</span>
    <span>// ...</span>
<span>}</span>
</code></pre></div></div>

<p>To do this, we had to add a new lifetime parameter, <code>&#39;ast</code>, which is meant to represent the lifetime of the AST structure itself. In other words, <code>saved_impl_trait_types</code> stores references into the AST. Of course, once we did this, the compiler got upset and we had to go modify the <code>impl</code> block that references <code>Context</code>:</p>

<div><div><pre><code><span>impl</span><span>&lt;</span><span>&#39;ast</span><span>&gt;</span> <span>Context</span><span>&lt;</span><span>&#39;ast</span><span>&gt;</span> <span>{</span>
    <span>...</span>
<span>}</span>
</code></pre></div></div>

<p>Now we can modify the <code>lower_ty</code> to push the trait ref into the vector:</p>

<div><div><pre><code><span>impl</span><span>&lt;</span><span>&#39;ast</span><span>&gt;</span> <span>Context</span><span>&lt;</span><span>&#39;ast</span><span>&gt;</span> <span>{</span>
    <span>fn</span> <span>lower_ty</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> <span>ty</span><span>:</span> <span>&amp;</span><span>ast</span><span>::</span><span>Ty</span><span>)</span> <span>{</span>
        <span>match</span> <span>ty</span> <span>{</span>
            <span>...</span>
            
            <span>ast</span><span>::</span><span>Ty</span><span>::</span><span>ImplTrait</span><span>(</span><span>...</span><span>)</span> <span>=&gt;</span> <span>{</span>
                <span>// üëá push the types into the vector üëá</span>
                <span>self</span><span>.saved_impl_trait_types</span><span>.push</span><span>(</span><span>ty</span><span>);</span>
                <span>do_something</span><span>();</span>
            <span>}</span>

            <span>ast</span><span>::</span><span>Ty</span><span>::</span><span>NamedType</span><span>(</span><span>name</span><span>,</span> <span>parameters</span><span>)</span> <span>=&gt;</span> <span>{</span>
                <span>...</span> <span>// just like before</span>
            <span>}</span>
            
            <span>...</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>At this point, the compiler gives us an error:</p>

<div><div><pre><code>error[E0621]: explicit lifetime required in the type of `ty`
   --&gt; examples/b.rs:125:42
    |
119 |     fn lower_ty(&amp;mut self, ty: &amp;ast::Ty) -&gt; hir::Ty {
    |                                -------- help: add explicit lifetime `&#39;ast` to the type of `ty`: `&amp;&#39;ast ast::Ty`
...
125 |                 self.impl_trait_tys.push(trait_ref);
    |                                          ^^^^^^^^^ lifetime `&#39;ast` required
</code></pre></div></div>

<p>Pretty nice error, actually! It‚Äôs pointing out that we are pushing into this vector which needs references into ‚Äúthe AST‚Äù, but we haven‚Äôt declared in our signature that the <code>ast::Ty</code> must actually from ‚Äúthe AST‚Äù. OK, let‚Äôs fix this:</p>

<div><div><pre><code><span>impl</span><span>&lt;</span><span>&#39;ast</span><span>&gt;</span> <span>Context</span><span>&lt;</span><span>&#39;ast</span><span>&gt;</span> <span>{</span>
    <span>fn</span> <span>lower_ty</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> <span>ty</span><span>:</span> <span>&amp;</span><span>&#39;ast</span> <span>ast</span><span>::</span><span>Ty</span><span>)</span> <span>{</span>
        <span>// had to add &#39;ast here üëÜ, just like the error message said</span>
        <span>...</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<h2 id="propagating-lifetimes-everywhere">Propagating lifetimes everywhere</h2>

<p>Of course, now we start getting errors in the functions that <em>call</em> <code>lower_ty</code>. For example, <code>lower_signature</code> says:</p>

<div><div><pre><code>error[E0621]: explicit lifetime required in the type of `sig`
  --&gt; examples/b.rs:71:18
   |
65 |     fn lower_signature(&amp;mut self, sig: &amp;ast::Signature) -&gt; hir::Signature {
   |                                        --------------- help: add explicit lifetime `&#39;ast` to the type of `sig`: `&amp;&#39;ast ast::Signature`
...
71 |             self.lower_ty(input);
   |                  ^^^^^^^^ lifetime `&#39;ast` required
</code></pre></div></div>

<p>The fix is the same. We tell the compiler that the <code>ast::Signature</code> is part of ‚Äúthe AST‚Äù, and that implies that the <code>ast::Ty</code> values owned by the <code>ast::Signature</code> are also part of ‚Äúthe AST‚Äù:</p>

<div><div><pre><code><span>impl</span><span>&lt;</span><span>&#39;ast</span><span>&gt;</span> <span>Context</span><span>&lt;</span><span>&#39;ast</span><span>&gt;</span> <span>{</span>
    <span>fn</span> <span>lower_signature</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> <span>sig</span><span>:</span> <span>&amp;</span><span>&#39;ast</span> <span>ast</span><span>::</span><span>Signature</span><span>)</span> <span>-&gt;</span> <span>hir</span><span>::</span><span>Signature</span> <span>{</span>
        <span>//        had to add &#39;ast here üëÜ, just like the error message said</span>
        <span>...</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>Great. This continues for a bit. But then‚Ä¶ we hit this error:</p>

<div><div><pre><code>error[E0597]: `parameters` does not live long enough
  --&gt; examples/b.rs:92:53
   |
58 | impl&lt;&#39;ast&gt; Context&lt;&#39;ast&gt; {
   |      ---- lifetime `&#39;ast` defined here
...
92 |                 self.lower_angle_bracket_parameters(&amp;parameters);
   |                 ------------------------------------^^^^^^^^^^^-
   |                 |                                   |
   |                 |                                   borrowed value does not live long enough
   |                 argument requires that `parameters` is borrowed for `&#39;ast`
93 |             }
   |             - `parameters` dropped here while still borrowed
</code></pre></div></div>

<p>What‚Äôs this about?</p>

<h2 id="uh-oh">Uh oh‚Ä¶</h2>

<p>Jumping to that line, we see this function <a href="https://github.com/nikomatsakis/2022-06-15-blogpost/blob/f280f91e9be03d37f273acf13502ef7dc1015db8/examples/b.rs#L85-L97"><code>lower_trait_ref</code></a>:</p>

<div><div><pre><code><span>impl</span> <span>Context</span><span>&lt;</span><span>&#39;ast</span><span>&gt;</span> <span>{</span>
    <span>// ...</span>
    <span>fn</span> <span>lower_trait_ref</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> <span>trait_ref</span><span>:</span> <span>&amp;</span><span>&#39;ast</span> <span>ast</span><span>::</span><span>TraitRef</span><span>)</span> <span>-&gt;</span> <span>hir</span><span>::</span><span>TraitRef</span> <span>{</span>
        <span>match</span> <span>&amp;</span><span>trait_ref</span><span>.parameters</span> <span>{</span>
            <span>ast</span><span>::</span><span>Parameters</span><span>::</span><span>AngleBracket</span><span>(</span><span>parameters</span><span>)</span> <span>=&gt;</span> <span>{</span>
                <span>self</span><span>.lower_angle_bracket_parameters</span><span>(</span><span>&amp;</span><span>parameters</span><span>);</span>
            <span>}</span>
            <span>ast</span><span>::</span><span>Parameters</span><span>::</span><span>Parenthesized</span><span>(</span><span>types</span><span>)</span> <span>=&gt;</span> <span>{</span>
                <span>let</span> <span>parameters</span><span>:</span> <span>Vec</span><span>&lt;</span><span>_</span><span>&gt;</span> <span>=</span> <span>types</span><span>.iter</span><span>()</span><span>.cloned</span><span>()</span><span>.map</span><span>(</span><span>ast</span><span>::</span><span>Parameter</span><span>::</span><span>Ty</span><span>)</span><span>.collect</span><span>();</span>
                <span>self</span><span>.lower_angle_bracket_parameters</span><span>(</span><span>&amp;</span><span>parameters</span><span>);</span> <span>// üëà error is on this line</span>
                
            <span>}</span>
        <span>}</span>

        <span>hir</span><span>::</span><span>TraitRef</span>
    <span>}</span>
    <span>// ...</span>
<span>}</span>
</code></pre></div></div>

<p>So what‚Äôs this about? Well, the <em>purpose</em> of this code is a bit clever. As we saw before, Rust has two syntaxes for trait-refs, you can use parentheses like <code>FnOnce(u32)</code>, in which case you only have types, or you can use angle brackets like <code>Foo&lt;&#39;a, u32&gt;</code>, in which case you could have either lifetimes <em>or</em> types. So this code is normalizing to the angle-bracket notation, which is more general, and then using the same lowering helper function.</p>

<h2 id="wait-right-there-that-was-the-moment">Wait! Right there! That was the moment!</h2>

<p>What?</p>

<h2 id="that-was-the-moment-that-rust-saved-you-a-world-of-pain">That was the moment that Rust saved you a world of pain!</h2>

<p>It was? It just kind of seemed like an annoying, and I will say, kind of confusing compilation error. What the heck is going on? The problem here is that <code>parameters</code> is a local variable. It is going to be freed as soon as <code>lower_trait_ref</code> returns. But it could happen that <code>lower_trait_ref</code> calls <code>lower_ty</code> which takes a reference to the type and stores it into the <code>saved_impl_trait_types</code> vector. Then, later, some code would try to use that reference, and access freed memory. That would sometimes work, but often not ‚Äì and if you forgot to test with parenthesized trait refs, the code would work fine for ever, so you‚Äôd never even notice.</p>

<h2 id="how-to-fix-it">How to fix it</h2>

<p>Maybe you‚Äôre wondering: great, Rust saved me a world of pain, but how do I fix it? Do I just have to copy the <code>lower_angle_bracket_parameters</code> and have two copies? ‚ÄòCause that‚Äôs kind of unfortunate.</p>

<p>Well, there are a variety of ways you <em>might</em> fix it. One of them is to use an <em>arena</em>, like the <a href="https://crates.io/crates/typed-arena"><code>typed-arena</code></a> crate. An arena is a memory pool. Instead of storing the temporary <code>Vec&lt;Parameter&gt;</code> vector on the stack, we‚Äôll put it in an arena, and that way it will live for the entire time that we are lowering things. <a href="https://github.com/nikomatsakis/2022-06-15-blogpost/blob/f280f91e9be03d37f273acf13502ef7dc1015db8/examples/c.rs">Example C</a> in the repo takes this approach. It starts by adding the <code>arena</code> field to the <a href="https://github.com/nikomatsakis/2022-06-15-blogpost/blob/f280f91e9be03d37f273acf13502ef7dc1015db8/examples/c.rs#L54-L60"><code>Context</code></a>:</p>

<div><div><pre><code><span>struct</span> <span>Context</span><span>&lt;</span><span>&#39;ast</span><span>&gt;</span> <span>{</span>
    <span>impl_trait_tys</span><span>:</span> <span>Vec</span><span>&lt;&amp;</span><span>&#39;ast</span> <span>ast</span><span>::</span><span>TraitRef</span><span>&gt;</span><span>,</span>

    <span>// Holds temporary AST nodes that we create during lowering;</span>
    <span>// this can be dropped once lowering is complete.</span>
    <span>arena</span><span>:</span> <span>&amp;</span><span>&#39;ast</span> <span>typed_arena</span><span>::</span><span>Arena</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>ast</span><span>::</span><span>Parameter</span><span>&gt;&gt;</span><span>,</span>
<span>}</span>
</code></pre></div></div>

<p>This actually makes a subtle change to the meaning of <code>&#39;ast</code>. It used to be that the only things with <code>&#39;ast</code> lifetime were ‚Äúthe AST‚Äù itself, so having that lifetime implied being a part of the AST. But now that same lifetime is being used to tag the arena, too, so if we hae <code>&amp;&#39;ast Foo</code> it means the data comes is owned by <em>either</em> the arena or the AST itself.</p>

<p><strong>Side note:</strong> despite the name lifetimes, which I now rather regret, more and more I tend to think of <em>lifetimes</em> like <code>&#39;ast</code> in terms of ‚Äúwho owns the data‚Äù, which you can see in my description in the previous paragraph. You could instead think of <code>&#39;ast</code> as a span of time (a ‚Äúlifetime‚Äù), in which case it refers to the time that the <code>Context</code> type is valid, really, which must be a subset of the time that the arena is valid and the time that the AST itself is valid, since <code>Context</code> stores references to data owned by both of those.</p>

<p>Now we can rewrite <code>lower_trait_ref</code>  to call <code>self.arena.alloc()</code>:</p>

<div><div><pre><code><span>impl</span> <span>Context</span><span>&lt;</span><span>&#39;ast</span><span>&gt;</span> <span>{</span>
    <span>fn</span> <span>lower_trait_ref</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> <span>trait_ref</span><span>:</span> <span>&amp;</span><span>&#39;ast</span> <span>ast</span><span>::</span><span>TraitRef</span><span>)</span> <span>-&gt;</span> <span>hir</span><span>::</span><span>TraitRef</span> <span>{</span>
        <span>match</span> <span>&amp;</span><span>trait_ref</span><span>.parameters</span> <span>{</span>
            <span>// ...</span>
            <span>ast</span><span>::</span><span>Parameters</span><span>::</span><span>Parenthesized</span><span>(</span><span>types</span><span>)</span> <span>=&gt;</span> <span>{</span>
                <span>let</span> <span>parameters</span><span>:</span> <span>Vec</span><span>&lt;</span><span>_</span><span>&gt;</span> <span>=</span> <span>types</span><span>.iter</span><span>()</span><span>.cloned</span><span>()</span><span>.map</span><span>(</span><span>ast</span><span>::</span><span>Parameter</span><span>::</span><span>Ty</span><span>)</span><span>.collect</span><span>();</span>
                <span>let</span> <span>parameters</span> <span>=</span> <span>self</span><span>.arena</span><span>.alloc</span><span>(</span><span>parameters</span><span>);</span> <span>// üëà added this line!</span>
                <span>self</span><span>.lower_angle_bracket_parameters</span><span>(</span><span>parameters</span><span>);</span>
            <span>}</span>
        <span>}</span>
        <span>// ...</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>Now the <code>parameters</code> variable is not stored on the stack but allocated in the arena; the arena has <code>&#39;ast</code> lifetime, so that‚Äôs fine, and everything works!</p>

<h2 id="calling-the-lowering-code-and-creating-the-context">Calling the lowering code and creating the context</h2>

<p>Now that we added, the arena, creating the context will look a bit different. It‚Äôll look something like:</p>

<div><div><pre><code><span>let</span> <span>arena</span> <span>=</span> <span>TypedArena</span><span>::</span><span>new</span><span>();</span>
<span>let</span> <span>context</span> <span>=</span> <span>Context</span><span>::</span><span>new</span><span>(</span><span>&amp;</span><span>arena</span><span>);</span>
<span>let</span> <span>hir_signature</span> <span>=</span> <span>context</span><span>.lower_signature</span><span>(</span><span>&amp;</span><span>signature</span><span>);</span>
</code></pre></div></div>

<p>The nice thing about this is that, once we are done with lowering, the <code>context</code> will be dropped and all those temporary nodes will be freed.</p>

<h2 id="another-way-to-fix-it">Another way to fix it</h2>

<p>The other obvious option is to avoid lifetimes altogether and just ‚Äúclone all the things‚Äù. Given that the AST is immutable once constructed, you can just clone them into the vector:</p>

<div><div><pre><code><span>struct</span> <span>Context</span> <span>{</span>
    <span>impl_trait_tys</span><span>:</span> <span>Vec</span><span>&lt;</span><span>ast</span><span>::</span><span>TraitRef</span><span>&gt;</span><span>,</span> <span>// just clone it!</span>
<span>}</span>
</code></pre></div></div>

<p>If that clone is too expensive (possible), then use <code>Rc&lt;ast::TraitRef&gt;</code> or <code>Arc&lt;ast::TraitRef&gt;</code> (this will require deep-ish changes to the AST to put all the things into <code>Rc</code> or <code>Arc</code> that might need to be individually referenced). At this point you‚Äôve got a feeling a lot like garbage collection (if less ergonomic).</p>

<h2 id="yet-another-way">Yet another way</h2>

<p>The way I tend to write compilers these days is to use the ‚Äúindices as pointers‚Äù. In this approach, all the data in the AST is stored in vectors, and references between things use indices, kind of like <a href="http://smallcultfollowing.com/babysteps/blog/2015/04/06/modeling-graphs-in-rust-using-vector-indices/">I described here</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Compilation errors are pretty frustrating, but they may also be a sign that the compiler is protecting us from ourselves. In this case, when we embarked on this refactoring, I was totally sure it was going to work fine, because I didn‚Äôt realize we ever created ‚Äútemporary AST‚Äù nodes, so I assumed that all the data was owned by the original AST. In a language like C or C++, it would have been <em>very</em> easy to have a bug here, and it would have been a horrible pain to find. With Rust, that‚Äôs not a problem.</p>

<p>Of course, not everything is great. For me, doing these kinds of lifetime transformations is old-hat. But for many people it‚Äôs pretty non-obvious how to start when the compiler is giving you error messages. When people come to me for help, the first thing I try to do is to suss out: what are the ownership relationships, and where do we expect these references to be coming form? There‚Äôs also various heuristics that I use to decide: do we need a new lifetime parameter? Can we re-use an existing one? I‚Äôll try to write up more stories like this to clarify that side of things. Honestly, my main point here was that I was just so grateful that Rust prevented us from spending hours and hours debugging a subtle crash!</p>

<p>Looking forward a bit, I see a lot of potential to improve things about our notation and terminology. I think we should be able to make cases like this one much slicker, hopefully without requiring named lifetime parameters and so forth, or as many edits. But I admit I don‚Äôt yet know how to do it! :) My plan for now is to keep an eye out for the tricks I am using and the kinds of analysis I am doing in my head and write out blog posts like this one to capture those narratives. I encourage those of you who know Rust well (or who don‚Äôt!) to do the same.</p>

<h2 id="appendix-why-not-have-context-own-the-typedarena">Appendix: why not have <code>Context</code> <em>own</em> the <code>TypedArena</code>?</h2>

<p>You may have noticed that using the arena had a kind of annoying consequence: people who called <code>Context::new</code> now had to create and supply an area:</p>

<div><div><pre><code><span>let</span> <span>arena</span> <span>=</span> <span>TypedArena</span><span>::</span><span>new</span><span>();</span>
<span>let</span> <span>context</span> <span>=</span> <span>Context</span><span>::</span><span>new</span><span>(</span><span>&amp;</span><span>arena</span><span>);</span>
<span>let</span> <span>hir_signature</span> <span>=</span> <span>context</span><span>.lower_signature</span><span>(</span><span>&amp;</span><span>signature</span><span>);</span>
</code></pre></div></div>

<p>This is because <code>Context&lt;&#39;ast&gt;</code> stores a <code>&amp;&#39;ast TypedArena&lt;_&gt;</code>, and so the caller must create the arena. If we modified <code>Context</code> to <em>own</em> the arena, then the API could be better. So why didn‚Äôt I do that? To see why, check out <a href="https://github.com/nikomatsakis/2022-06-15-blogpost/blob/f280f91e9be03d37f273acf13502ef7dc1015db8/examples/c.rs">example D</a> (which doesn‚Äôt build). In that example, the <code>Context</code> looks like‚Ä¶</p>

<div><div><pre><code><span>struct</span> <span>Context</span><span>&lt;</span><span>&#39;ast</span><span>&gt;</span> <span>{</span>
    <span>impl_trait_tys</span><span>:</span> <span>Vec</span><span>&lt;&amp;</span><span>&#39;ast</span> <span>ast</span><span>::</span><span>TraitRef</span><span>&gt;</span><span>,</span>

    <span>// Holds temporary AST nodes that we create during lowering;</span>
    <span>// this can be dropped once lowering is complete.</span>
    <span>arena</span><span>:</span> <span>typed_arena</span><span>::</span><span>Arena</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>ast</span><span>::</span><span>Parameter</span><span>&gt;&gt;</span><span>,</span>
<span>}</span>
</code></pre></div></div>

<p>You then have to change the signatures of each function to take an <code>&amp;&#39;ast mut self</code>:</p>

<div><div><pre><code><span>impl</span> <span>Context</span><span>&lt;</span><span>&#39;ast</span><span>&gt;</span> <span>{</span>
    <span>fn</span> <span>lower_signature</span><span>(</span><span>&amp;</span><span>&#39;ast</span> <span>mut</span> <span>self</span><span>,</span> <span>sig</span><span>:</span> <span>&amp;</span><span>&#39;ast</span> <span>ast</span><span>::</span><span>Signature</span><span>)</span> <span>-&gt;</span> <span>hir</span><span>::</span><span>Signature</span> <span>{</span><span>...</span><span>}</span>
<span>}</span>
</code></pre></div></div>

<p>This is saying: the <code>&#39;ast</code> parameter might refer to data owned by self, or maybe by sig. Seems sensible, but if you try to build <a href="https://github.com/nikomatsakis/2022-06-15-blogpost/blob/f280f91e9be03d37f273acf13502ef7dc1015db8/examples/c.rs">Example D</a>, though, you get lots of errors. Here is one of the most interesting to me:</p>

<div><div><pre><code>error[E0502]: cannot borrow `*self` as mutable because it is also borrowed as immutable
  --&gt; examples/d.rs:98:17
   |
62 | impl&lt;&#39;ast&gt; Context&lt;&#39;ast&gt; {
   |      ---- lifetime `&#39;ast` defined here
...
97 |                 let parameters = self.arena.alloc(parameters);
   |                                  ----------------------------
   |                                  |
   |                                  immutable borrow occurs here
   |                                  argument requires that `self.arena` is borrowed for `&#39;ast`
98 |                 self.lower_angle_bracket_parameters(parameters);
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here
</code></pre></div></div>

<p>What is this all about? This is actually pretty subtle! This is saying that <code>parameters</code> was allocated from <code>self.arena</code>. That means that <code>parameters</code> will be valid <strong>as long as <code>self.arena</code> is valid</strong>.</p>

<p>But <code>self</code> is an <code>&amp;mut Context</code>, which means it can mutate any of the fields of the <code>Context</code>. When we call <code>self.lower_angle_bracket_parameters()</code>, it‚Äôs entirely possible that <code>lower_angle_bracket_parameters</code> could mutate the arena:</p>

<div><div><pre><code><span>fn</span> <span>lower_angle_bracket_parameters</span><span>(</span><span>&amp;</span><span>&#39;ast</span> <span>mut</span> <span>self</span><span>,</span> <span>parameters</span><span>:</span> <span>&amp;</span><span>&#39;ast</span> <span>[</span><span>ast</span><span>::</span><span>Parameter</span><span>])</span> <span>{</span>
    <span>self</span><span>.arena</span> <span>=</span> <span>TypedArena</span><span>::</span><span>new</span><span>();</span> <span>// what if we did this?</span>
    <span>// ...</span>
<span>}</span>
</code></pre></div></div>

<p>Of course, the code doesn‚Äôt do that now, but what if it did? The answer is that the parameters would be freed, because the arena that owns them is freed, and so we‚Äôd have dead code. D‚Äôoh!</p>

<p>All things considered, I‚Äôd like to make it possible for <code>Context</code> to own the arena, but right now it‚Äôs pretty challenging. This is a good example of code patterns we could enable, but it‚Äôll require language extensions.</p>

  </div>

  

  <!-- NDM: added this -->
  
  
  
  

</article>

    </section></div>
  </body>
</html>
