<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wadetregaskis.com/swift-sucks-at-web-serving-or-does-it/">Original</a>
    <h1>Swift sucks at web serving or does it?</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="text">
			

<p>A few weeks ago, Axel Roest published <a href="https://tech.phlux.us/Juice-Sucking-Servers/" data-wpel-link="external" target="_blank" rel="external noopener">a simple web server comparison</a>, that turned out to not be doing what it was thought to be doing. Figuring that out was a very interesting discussion that warrants a retrospective, to look at which parts were particularly helpful and which not so much.</p>



<p>Tangentially, I want to highlight that Axel‚Äôs comparison is notable because he is interested in <em>efficiency</em>, not mere brute performance. The two are usually correlated but not always the same. He correctly noted that electricity is a major <em>and increasingly large</em> part of server costs (see <a href="https://wadetregaskis.com/the-cost-of-electrical-power-in-servers/" data-wpel-link="internal">my prior post</a> for why it‚Äôs even worse than you likely realise). That said, while he did take RAM and power measurements, his benchmark and analysis didn‚Äôt go into detail about energy efficiency.</p>







<p>Alex wanted to see how a very simple web server performed in:</p>



<ul>
<li><a href="https://www.php.net/manual/en/install.fpm.php" data-wpel-link="external" target="_blank" rel="external noopener">FPM</a> w/ <a href="https://www.nginx.com" data-wpel-link="external" target="_blank" rel="external noopener">NGINX</a> (PHP).</li>



<li><a href="https://helidon.io" data-wpel-link="external" target="_blank" rel="external noopener">Helidon</a> (Kotlin).</li>



<li><a href="https://nodejs.org/en" data-wpel-link="external" target="_blank" rel="external noopener">Node.js</a> (JavaScript).</li>



<li><a href="https://vapor.codes" data-wpel-link="external" target="_blank" rel="external noopener">Vapor</a> (Swift).</li>
</ul>



<p>He was particularly interested in throughput &amp; latency vs RAM &amp; power usage. All are important metrics in their own right, but are most useful in light of each other.</p>



<p>He chose to use <a href="https://en.wikipedia.org/wiki/Fibonacci_sequence" data-wpel-link="external" target="_blank" rel="external noopener">Fibonacci sequence</a> calculation as the load. Choosing a load for any web server benchmark is always highly contentious, and not the focus of this post. Whether you think Fibonacci‚Äôs a good choice or not, read on to see why really it didn‚Äôt matter.</p>



<div><p>‚òùÔ∏è People get hung up on how well benchmarks represent the so-called real world, but I think that‚Äôs often fruitless to argue about and also beside the point. What matters is whether the benchmark is <em>useful</em>. e.g. does it <em>inform</em> and <em>elucidate</em>?</p></div>



<p>He did use <em>very</em> old hardware, though ‚Äì an Intel Core i3-550 from over a decade ago. Fortunately it didn‚Äôt turn out to materially impact the relative results nor behaviours of the benchmark, but it‚Äôs usually unwise to add unnecessary [potential] variables to your setup, like unusual hardware.</p>



<p>In my own debugging and profiling, I used my also very old 10-core iMac Pro. It‚Äôs at least a Xeon? üòÖ</p>











<p>In words:</p>



<ul>
<li>Helidon (Kotlin) had the highest throughput and lowest latency at low (and arguably more reasonable) loads, but used by far the most RAM, and the most power. Consequently it handled the most load before requests started failing (timing out).</li>



<li>Node.js (JavaScript) was qualitatively very similar to Helidon (Kotlin) but less in all metrics ‚Äì less throughput, less peak load capacity, but also less RAM and very slightly less power used.</li>



<li>FPM + NGINX (PHP) followed the pattern.</li>



<li>Vapor (Swift) did not ‚Äì it had higher throughput than PHP yet requests started failing much sooner as load increased. It used the least RAM and least power, though, and kept on trucking irrespective of the load.</li>
</ul>



<p>Many people would have left it at that ‚Äì obviously the results make sense for the first three (‚Äúeveryone knows‚Äù that Kotlin‚Äôs faster than JavaScript that‚Äôs faster than PHP) and Vapor / Swift apparently just isn‚Äôt fast and has weird reliability behaviours. QED, right?</p>



<div><p>‚ö†Ô∏è Going in with a specific hypothesis can be helpful, but hypotheses can also end up being just biases.  Be careful not to blindly accept apparent confirmation of the hypothesis.  Similarly, beware subconscious hypotheses like ‚ÄúKotlin is faster than JavaScript‚Äù.</p></div>



<p>To his credit, Axel wasn‚Äôt so sure ‚Äì he felt that the results he was seeing were suspicious, and <a href="https://forums.swift.org/t/standard-vapor-website-drops-1-5-of-requests-even-at-concurrency-of-100/71583" data-wpel-link="external" target="_blank" rel="external noopener">he sought help from the Swift Forums</a> in explaining or correcting them.</p>



<div><div>
<p>‚úÖ Question your results. <em>Understand</em> them. It improves the quality, correctness, and usefulness of your work. <em>Why</em> something behaves the way it does is often more interesting and important than merely how it behaves.</p>



<p>On most platforms it‚Äôs pretty easy to at least do a time profile, and most often that‚Äôs all you need to understand what‚Äôs going on. On Apple platforms you can use <a href="https://www.avanderlee.com/debugging/xcode-instruments-time-profiler/" data-wpel-link="external" target="_blank" rel="external noopener">Instruments</a>, on Windows &amp; Linux tools like <a href="https://www.intel.com/content/www/us/en/docs/vtune-profiler/user-guide/2024-1/basic-hotspots-analysis.html" data-wpel-link="external" target="_blank" rel="external noopener">VTune</a>, among <a href="https://en.wikipedia.org/wiki/List_of_performance_analysis_tools" data-wpel-link="external" target="_blank" rel="external noopener">many other options</a>.</p>



<p>If need be, ask others for help, like Axel did.</p>
</div></div>



<p>While Axel did <em>suspect</em> something was wrong ‚Äì noting the oddly small but persistent failure rate ‚Äì he missed the most obvious <em>proof</em> of wrongness ‚Äì logically impossible results. Doing 80,000 continuous concurrent streams of requests with ~98% of those requests completing within the two second time limit means the server must have a throughput of at least 39,000 requests per second. Yet the benchmark tool reported a mere ~8,000 requests per second.</p>



<p>Sadly, though <a href="https://forums.swift.org/t/standard-vapor-website-drops-1-5-of-requests-even-at-concurrency-of-100/71583/2" data-wpel-link="external" target="_blank" rel="external noopener">I pointed this out as the very first response to the thread</a>, it seemed to be overlooked by everyone (even myself!), even though it clearly fingered the benchmark tool itself as the problem (which is only partially correct, as we‚Äôll see later, but in any case was the exact right place to start looking).</p>







<h2><span id="Domain_experts_weigh_in">Domain experts weigh in</span></h2>



<p>The Swift Forum post immediately attracted relevant people: folks that work on Vapor and NIO, and folks that have experience using them. However, ironically this didn‚Äôt initially help ‚Äì they tended to assume the problem was in Vapor (or its networking library, <a href="https://github.com/apple/swift-nio" data-wpel-link="external" target="_blank" rel="external noopener">SwiftNIO</a>) or how Vapor was being configured. It turned out none of this was really true ‚Äì there <em>was</em> <a href="https://forums.swift.org/t/standard-vapor-website-drops-1-5-of-requests-even-at-concurrency-of-100/71583/49" data-wpel-link="external" target="_blank" rel="external noopener">a small optimisation made to Vapor</a> as a result of all this, which did marginally improve performance (in specific circumstances), but ultimately Vapor &amp; NIO were not the problem, nor was the benchmark‚Äôs configuration and use of them.</p>



<div><div>
<p>‚ö†Ô∏è It can be all too easy to assume elaborate reasons when you know a lot about something.  Don‚Äôt jump to conclusions. Check the most basic and foundational things <em>first</em>.</p>



<p>I say this with humility and I guess technically hypocrisy, because even as professional performance engineer (in the past) I‚Äôve repeatedly made this mistake myself. We‚Äôre all particularly susceptible to this mistake.</p>
</div></div>



<p>There were some assertions that the results <em>were</em> plausible and just how Vapor performs, and that the ‚Äúproblem‚Äù was the choice of Vapor rather than some other web server framework (e.g. <a href="https://github.com/hummingbird-project/hummingbird" data-wpel-link="external" target="_blank" rel="external noopener">Hummingbird</a>).</p>



<div><p>‚ö†Ô∏è It‚Äôs not <em>wrong</em> to be interested in additional data, but be careful not to get distracted. Using Vapor was not in any way wrong or unhelpful ‚Äì it is the most well-known and probably well-used web server framework in Swift. It might well be that other frameworks are better in some respects, but that‚Äôs a <em>different</em> comparison than what Axel performed.</p></div>



<p>Others similarly asserted that the results were plausible because Swift uses <a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/automaticreferencecounting/" data-wpel-link="external" target="_blank" rel="external noopener">reference-counting</a> for memory management whereas PHP, JavaScript, and Kotlin use garbage collection. It was presented as ‚Äúcommon knowledge‚Äù that garbage collection has inherent benefits for some programs, like web servers, because it makes memory allocation super cheap.</p>



<div><div>
<p>‚ö†Ô∏è While it can be useful to speculate a little, in a brainstorming sense, don‚Äôt presume.  A <em>lot</em> of mistakes have been made over the years because of this, like that ‚Äúlinked lists are faster than arrays‚Äù or ‚Äúbinary search is faster than linear search‚Äù, etc.</p>



<p>Remember that intuition is in large part presumptions and generalisations. That doesn‚Äôt make intuition useless, but always remember that it‚Äôs far from foolproof.  Use it to generate hypotheses, not conclusions.</p>
</div></div>



<h2><span id="Examining_the_load">Examining the load</span></h2>



<p>Even though it was clear that something was wrong with the actual measurements, a lot of the early discussion revolved around the load used (Fibonacci sequence calculation), particularly regarding whether it was:</p>



<h3><span id="The_8220right8221_load">The ‚Äúright‚Äù load</span></h3>



<p>A few folks asserted that the CPU-heavy nature of calculating Fibonacci numbers isn‚Äôt representative of web servers generally. Multiple people noted that ‚Äì in the Swift implementation, at least ‚Äì the majority of the CPU time was spent doing the Fibonacci calculation. Some felt this was therefore not a useful benchmark of Vapor itself.</p>



<p>A lot of this boiled down to <a href="https://en.wikipedia.org/wiki/No_true_Scotsman" data-wpel-link="external" target="_blank" rel="external noopener">the ‚Äúno true Scotsman‚Äù problem</a>, which is very common in benchmarking, with a bit of perfect world logical fallacy peppered in, trying to identify the One True Representative Benchmark. See the earlier point about fixating on such matters rather than whether the benchmark is <em>useful</em>.</p>



<div><div>
<p>‚ö†Ô∏è While it‚Äôs not necessarily wrong or unwise to evaluate how well a benchmark represents real world usage (whether generally or against specific cases), it‚Äôs an exercise that suffers from diminishing returns pretty quickly. It‚Äôs usually best to not quibble too much or too long, as long as the benchmark is in the ballpark.</p>



<p>You can always develop &amp; present your own benchmark(s), if you feel there are better or additional ways to go about it. Best of all, the existence of <em>both</em> the original benchmark and your benchmark(s) will be more useful than either alone, since you can compare and contrast them.</p>
</div></div>



<h3><span id="A_8220fair8221_load">A ‚Äúfair‚Äù load</span></h3>



<p>Accusations were made pretty quickly that the benchmark is ‚Äúunfair‚Äù to Swift because Swift doesn‚Äôt ‚Äì it was asserted ‚Äì have a properly-optimised ‚Äú<a href="https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic" data-wpel-link="external" target="_blank" rel="external noopener">BigInt</a>‚Äù implementation, unlike all the other languages tested.</p>



<p>No real evidence was given for this.  Even if it were true, it doesn‚Äôt invalidate the benchmark ‚Äì in fact, it just makes the benchmark <em>more</em> successful because it‚Äôs then highlighted an area where Swift is lacking.</p>



<p>The BigInt library that Axel used, <a href="https://github.com/attaswift/BigInt" data-wpel-link="external" target="_blank" rel="external noopener">attaswift/BigInt</a>, is by far the most popular available for Swift, as judged by things like GitHub stars, forks, &amp; contributor counts, ranking in web &amp; GitHub searches, etc. There are <a href="https://swiftpackageindex.com/search?query=bigint" data-wpel-link="external" target="_blank" rel="external noopener">quite a few others</a>, though.</p>



<div><div>
<p>‚òùÔ∏è There are multiple ways to approach a benchmark, all equally valid because they‚Äôre all useful. Axel chose to use popular packages, in <em>all</em> the languages he tested. That‚Äôs definitely fair. It‚Äôs also useful because it represents what the typical developer will do when building real web servers.</p>



<p>It‚Äôs often also interesting and useful to search out the <em>best</em> packages (whatever that may mean in context, such as fastest). That could represent what a more heavily optimised implementation might do. It <em>might</em> also better represent what is theoretical possible (<em>if</em> optimal packages exist already). Those are interesting things to explore too, just not what Axel happened to be doing.</p>



<p>You can see also more of my thoughts on Axel‚Äôs choice here, <a href="https://forums.swift.org/t/standard-vapor-website-drops-1-5-of-requests-even-at-concurrency-of-100/71583/39" data-wpel-link="external" target="_blank" rel="external noopener">in the Swift Forums thread</a>.</p>
</div></div>



<p>It wasn‚Äôt until <a href="https://forums.swift.org/t/standard-vapor-website-drops-1-5-of-requests-even-at-concurrency-of-100/71583/46" data-wpel-link="external" target="_blank" rel="external noopener">actual evidence was presented</a>, that the discussion made progress.</p>



<div><div>
<p>‚ö†Ô∏è While it‚Äôs true that without the initial blind assertions, actual data might never have been gathered, it would have been more effective and efficient to have just gathered the data at the start.</p>



<p>Data is better than supposition.</p>
</div></div>



<p>It was shown that in fact the BigInt implementation in question <em>was</em> significantly slower than it could be, because JavaScript‚Äôs implementation of addition was much faster. <a href="https://forums.swift.org/t/standard-vapor-website-drops-1-5-of-requests-even-at-concurrency-of-100/71583/62" data-wpel-link="external" target="_blank" rel="external noopener">Some additional simple tests</a> showed even wider performance gaps regarding the other key operation: rendering to strings. It was <em>that</em> data that turned out to be critical ‚Äì <a href="https://github.com/apple/swift-foundation/pull/262" data-wpel-link="external" target="_blank" rel="external noopener">I myself happened to have implemented BigInt string rendering for Apple‚Äôs new Foundation</a>, <em>and</em> then <a href="https://github.com/apple/swift-foundation/pull/306" data-wpel-link="external" target="_blank" rel="external noopener">saw it dramatically optimised by</a> <a href="https://github.com/oscbyspro" data-wpel-link="external" target="_blank" rel="external noopener">Oscar Bystr√∂m Ericsson</a>, whom has his own BigInt package for Swift, <a href="https://github.com/oscbyspro/Numberick" data-wpel-link="external" target="_blank" rel="external noopener">Numberick</a>. So I had a pretty darn good idea of where I might find a faster package‚Ä¶ üòÜ</p>



<p>You can read more about that specific bit of serendipity <a href="https://forums.swift.org/t/standard-vapor-website-drops-1-5-of-requests-even-at-concurrency-of-100/71583/64" data-wpel-link="external" target="_blank" rel="external noopener">in the Swift Forums thread</a>.</p>



<p>It was trivial to do the package switch, and it quickly improved Vapor/Swift‚Äôs showing in the benchmark manyfold ‚Äì in combination with some other simple and reasonable tweaks, it was <em>five times faster</em>!</p>



<div><div>
<p>‚úÖ Axel‚Äôs benchmark taught a lot of people that <a href="https://github.com/oscbyspro/Numberick" data-wpel-link="external" target="_blank" rel="external noopener">Numberick</a> is much more performant than <a href="https://github.com/attaswift/BigInt" data-wpel-link="external" target="_blank" rel="external noopener">BigInt</a>, at least in some important operations (addition and string rendering). Granted that knowledge is a little bit niche in its utility, but it‚Äôs still a good outcome.</p>



<p>It also demonstrated that modifying in place can be faster than creating a copy, <em>even if</em> it means having to do a swap. i.e.:</p>







<p>‚Ä¶instead of:</p>



<div data-code-block-pro-font-family=""><pre tabindex="0"><code><span><span>let</span><span> c = a + b</span></span>
<span><span>a = b</span></span>
<span><span>b = c</span></span></code></pre></div>



<p>That‚Äôs a tidbit I had picked up through varied experiences, and <a href="https://wadetregaskis.com/swift-tip-the-swap-function/" data-wpel-link="internal">wrote about previously</a>. The <code><a href="https://developer.apple.com/documentation/swift/swap(_:_:)" data-wpel-link="external" target="_blank" rel="external noopener">swap</a></code> function in Swift is under-appreciated and under-utilised. This knowledge may seem esoteric but you‚Äôd be amazed how often it applies (a <em>lot</em> of programming is about combining data, after all).</p>
</div></div>



<p>Axel posted <a href="https://tech.phlux.us/Juice-Sucking-Servers-Part-Deux/" data-wpel-link="external" target="_blank" rel="external noopener">a follow-up with additional data</a> (with the aforementioned changes and optimisations). That showed Swift now beating out the other three frameworks / languages, with the highest throughput and lowest latency (and still the lowest RAM and power usage).</p>


<div>
<figure><img loading="lazy" decoding="async" width="800" height="513" src="https://wadetregaskis.com/wp-content/uploads/2024/05/Web-server-comparison-throughput-after-fixes.webp" alt="" srcset="https://wadetregaskis.com/wp-content/uploads/2024/05/Web-server-comparison-throughput-after-fixes.webp 800w, https://wadetregaskis.com/wp-content/uploads/2024/05/Web-server-comparison-throughput-after-fixes-256x164.webp 256w, https://wadetregaskis.com/wp-content/uploads/2024/05/Web-server-comparison-throughput-after-fixes-768x492.webp 768w, https://wadetregaskis.com/wp-content/uploads/2024/05/Web-server-comparison-throughput-after-fixes-256x164@2x.webp 512w" sizes="(max-width: 800px) 100vw, 800px"/><figcaption>From Axel‚Äôs follow-up post. X axis is the number of concurrent requests.</figcaption></figure></div>


<p>So, all done, right? Turns out, Vapor/Swift wins, yeah?</p>



<p>Well, maybe.</p>



<h3 id="do-these-improvements-apply-to-the-other-cases-too"><span id="Do_these_improvements_apply_to_the_other_cases_too">Do these improvements apply to the other cases too?</span></h3>



<p>That is yet to be examined. Because only Swift seemed to be producing odd results, Axel only put the benchmark to the Swift community for deeper analysis. It‚Äôs quite possible that doing the same with the other web frameworks &amp; languages would similarly reveal potential improvements.</p>



<p>Still, the results are useful as they stand. Some simple and very plausible ‚Äì even for a Swift beginner ‚Äì optimisations made a big difference, though of course the biggest difference was simply using a different 3rd party package. There are a lot of useful lessons in that, both in the specifics as already covered and as general best practices.</p>



<div><div>
<p>‚òùÔ∏è Benchmarks are rarely ‚Äúdone‚Äù, their results rarely ‚Äúfinal‚Äù. At least if you permit optimisations or other changes. How do you <em>know</em> there‚Äôs not something still ‚Äúunfair‚Äù about one of the cases?</p>



<p>Again, this speaks to the potential futility of trying to make ‚Äúfair‚Äù benchmarks, and reiterates the practical benefit of simply trying to learn instead.</p>
</div></div>



<h2><span id="but_why_is_the_success_rate_still_weird">‚Ä¶but‚Ä¶ why is the success rate still weird?</span></h2>



<p>Despite the improved performance, a fundamental problem remained: <em>the numbers still didn‚Äôt make sense</em>.</p>


<div>
<figure><img loading="lazy" decoding="async" width="800" height="512" src="https://wadetregaskis.com/wp-content/uploads/2024/05/Web-server-comparison-success-rate-after-fixes.png" alt="" srcset="https://wadetregaskis.com/wp-content/uploads/2024/05/Web-server-comparison-success-rate-after-fixes.png 800w, https://wadetregaskis.com/wp-content/uploads/2024/05/Web-server-comparison-success-rate-after-fixes-256x164.png 256w, https://wadetregaskis.com/wp-content/uploads/2024/05/Web-server-comparison-success-rate-after-fixes-768x492.png 768w, https://wadetregaskis.com/wp-content/uploads/2024/05/Web-server-comparison-success-rate-after-fixes-256x164@2x.png 512w" sizes="(max-width: 800px) 100vw, 800px"/><figcaption>From Axel‚Äôs follow-up post. X axis is the number of concurrent requests.</figcaption></figure></div>


<p>The success rates are <em>slightly</em> different but not materially ‚Äì as concurrent requests go up, the throughput plateaus very quickly, yet success rate remains about the same. It‚Äôs exactly the same problem as at the outset ‚Äì these results cannot possibly be correct.</p>



<p>Despite all the community‚Äôs efforts, we hadn‚Äôt actually figured out the real problem. We‚Äôd merely made Swift <em>look</em> better, without actually providing confidence in the accuracy of the results.</p>



<p>In fairness to myself, I was well aware that we weren‚Äôt done, I was just struggling to understand what was really going on, <a href="https://forums.swift.org/t/standard-vapor-website-drops-1-5-of-requests-even-at-concurrency-of-100/71583/74" data-wpel-link="external" target="_blank" rel="external noopener">as I noted here</a>.</p>



<h2><span id="Examining_the_benchmark_tool">Examining the benchmark tool</span></h2>



<p>While there‚Äôd been some tangential questions about <code><a href="https://github.com/wg/wrk" data-wpel-link="external" target="_blank" rel="external noopener">wrk</a></code>, the benchmarking tool Axel used, it had largely been ignored thus far.</p>



<p>Ironically (as you‚Äôll soon see) Axel chose <code>wrk</code> specifically because <a href="https://tech.phlux.us/Juice-Sucking-Servers/#benchmarking-software" data-wpel-link="external" target="_blank" rel="external noopener">he didn‚Äôt like the behaviour he saw</a> with <a href="https://httpd.apache.org/docs/2.4/programs/ab.html" data-wpel-link="external" target="_blank" rel="external noopener">ApacheBench</a>. Mostly its lack of HTTP/1.1 connection reuse (a subjective but valid methodology choice on Axel‚Äôs part) but also because it sounds like he saw some inexplicable results from it too. In hindsight, that might have been a clue that something more pervasive was wrong.</p>



<p>In retrospect there were a few tangential comments in the Swift Forums thread that were on the right track, e.g.:</p>



<blockquote>
<p>‚Ä¶when a new connection comes in, the server needs to make a decision: It can</p>



<ul>
<li>Either accept the new connection immediately, slowing the existing connections down a little (because now there are more connections to service with the same resources as before)</li>



<li>Or it can prioritise the existing connections and slow the connection acceptance (increasing the latency of the first request in the new connection which now has to wait).</li>
</ul>
<cite><a href="https://forums.swift.org/u/johannesweiss/summary" data-wpel-link="external" target="_blank" rel="external noopener">Johannes Weiss</a>, <a href="https://forums.swift.org/t/standard-vapor-website-drops-1-5-of-requests-even-at-concurrency-of-100/71583/77" data-wpel-link="external" target="_blank" rel="external noopener">Swift Forums post</a></cite></blockquote>



<p>As a little spoiler, it seems apparent that the other three web frameworks all accept incoming connections virtually immediately with priority over any existing connections &amp; request handling (even though they don‚Äôt necessarily attempt to <em>serve</em> all those connections‚Äô requests simultaneously). Vapor does not.</p>



<p>Suspicions did [correctly] develop around the opening of the connections themselves, which triggered testing with longer timeouts in a somewhat blind attempt to cover-up the ‚Äúspurious‚Äù first moments of the test.</p>



<div><p>‚ùå Trying to essentially just hide inconvenient results is unlikely to help. It may even be successful, which is the worst possible outcome because it‚Äôs basically just burying a time-bomb into the benchmark, <em>and</em> forgoing any real understanding &amp; potential knowledge to be gained from properly investigating the problem.</p></div>



<h3><span id="Characterising_the_failure_modes">Characterising the failure mode(s)</span></h3>



<p>Though admittedly I wasn‚Äôt <em>fully</em> conscious of what I was doing at the time, the next breakthrough came from simply <a href="https://forums.swift.org/t/standard-vapor-website-drops-1-5-of-requests-even-at-concurrency-of-100/71583/85" data-wpel-link="external" target="_blank" rel="external noopener">gathering more data and analysing it <em>qualitatively</em></a>. This helped in two key ways:</p>



<ul>
<li>It better defined and pinned down the circumstances in which things appear to go wrong with the benchmark itself.</li>
</ul>



<div><p>‚úÖ When it doubt, try to better define the problem. Eliminate variables. Refine quantitative estimates. Make your life easier by eliminating things that don‚Äôt matter.</p></div>



<ul>
<li>It provided hints and potential insight into the nature of the problem.</li>
</ul>



<div><p>‚úÖ There are <em>many</em> ways to approach a data set, in terms of analysis methods. It‚Äôs a good idea to always keep that in mind, and to try different analysis mindsets whenever you seem stuck (and also to further validate conclusions).</p></div>



<p>Interestingly although ultimately only tangentially, this modality finding prompted quite a few ‚Äúme too!‚Äù responses from other folks, about a variety of use-cases involving Vapor <em>or</em> NIO.  I took that as affirmation that I was onto something real, but in retrospect that should have been an even better clue:  the fact that some people had seen this issue <em>without</em> Vapor involved ‚Äì the only common denominator was NIO.  Even though it turns out NIO itself wasn‚Äôt doing any wrong, it was on the right path to answers.  <a href="https://forums.swift.org/t/standard-vapor-website-drops-1-5-of-requests-even-at-concurrency-of-100/71583/87" data-wpel-link="external" target="_blank" rel="external noopener">This was <em>specifically</em> pointed out to everyone</a>, even.</p>



<div><p>‚òùÔ∏è Sometimes, it just comes down to needing to listen better.</p></div>



<h3><span id="Overlooked_clues">Overlooked clues</span></h3>



<p>At this point there were a bunch of discussions about <a href="https://forums.swift.org/t/standard-vapor-website-drops-1-5-of-requests-even-at-concurrency-of-100/71583/89" data-wpel-link="external" target="_blank" rel="external noopener">benchmark tool configuration</a>, <a href="https://forums.swift.org/t/standard-vapor-website-drops-1-5-of-requests-even-at-concurrency-of-100/71583/91" data-wpel-link="external" target="_blank" rel="external noopener">hardware arrangement</a>, <a href="https://forums.swift.org/t/standard-vapor-website-drops-1-5-of-requests-even-at-concurrency-of-100/71583/102" data-wpel-link="external" target="_blank" rel="external noopener">whether TLS should be used</a>, etc.  I‚Äôm going to skim over it, because there‚Äôs not much to ultimately say about it ‚Äì it turned out to not be on the right track in this case, or purely tangential, but it was entirely reasonable to investigate &amp; discuss those aspects.  Such is debug life.</p>


<div>
<figure><img loading="lazy" decoding="async" width="600" height="600" src="https://wadetregaskis.com/wp-content/uploads/2024/05/Debug-Life-t-shirt.avif" alt="" srcset="https://wadetregaskis.com/wp-content/uploads/2024/05/Debug-Life-t-shirt.avif 600w, https://wadetregaskis.com/wp-content/uploads/2024/05/Debug-Life-t-shirt-256x256.avif 256w, https://wadetregaskis.com/wp-content/uploads/2024/05/Debug-Life-t-shirt-256x256@2x.avif 512w" sizes="(max-width: 600px) 100vw, 600px"/><figcaption>I couldn‚Äôt find evidence that anyone‚Äôs gotten the tattoo yet, but you can at least <a href="https://www.redbubble.com/i/t-shirt/Debug-Life-White-Typographic-Design-for-Thug-Programmers-by-ramiro/17317023.FB110" data-wpel-link="external" target="_blank" rel="external noopener">get the wardrobe</a>.</figcaption></figure></div>


<p>What‚Äôs interesting is that yet another key clue was mentioned in the Swift Forums thread, yet was overlooked because it was attributed incorrectly and the mechanics miscategorised:</p>



<blockquote>
<p>Don‚Äôt test with more than 128 connections. You will get read errors. This is due to the file descriptor limit applied to each process on macOS. As¬†<a href="https://forums.swift.org/u/johannesweiss" data-wpel-link="external" target="_blank" rel="external noopener">@johannesweiss</a>¬†mentioned earlier the default for this is 256. You can change this but it involves disabling the System Integrity Protection.</p>
<cite><a href="https://forums.swift.org/u/adam-fowler/summary" data-wpel-link="external" target="_blank" rel="external noopener">Adam Fowler</a>, <a href="https://forums.swift.org/t/standard-vapor-website-drops-1-5-of-requests-even-at-concurrency-of-100/71583/99" data-wpel-link="external" target="_blank" rel="external noopener">Swift Forums thread</a></cite></blockquote>



<p>The 128 connections &amp; read errors parts were spot on, in hindsight.  But the rest was incorrect (it‚Äôs not about the file descriptor ulimit) and in particular the incorrect statement about having to disable SIP perhaps further distracted readers (corrections were posted in reply, which perhaps steered the thread away from what actually mattered).</p>



<p>I‚Äôm not sure what precisely the lesson is here‚Ä¶ if Adam had better understood the behaviour he‚Äôd seen previously (re. 128 connections being the apparent limit) he might have been able to immediately point out one of the key problems.  But who can say why he didn‚Äôt quite understand that limit correctly, or whether he should have.  This sort of thing happens, and <em>maybe</em> it suggests a failure to properly diagnose problems previously, but mostly I‚Äôd just point out that the discrepancy here ‚Äì between 128 and 256 ‚Äì <em>should</em> have been noticed, and had it been questioned it would have accelerated progress towards the root cause.</p>



<p>Speaking just for myself, I think I (erroneously) dismissed Adam‚Äôs comment because I already knew that the default file descriptor limit is <em>not</em> actually 256 (it‚Äôs 2,560 on macOS, mostly) and so I assumed the <em>whole</em> comment was wrong and irrelevant.</p>



<div><p>‚ö†Ô∏è Partly wrong is not the same as completely wrong (let-alone useless).</p></div>



<p>Another clue was put forth, yet again essentially by accident (without understanding its significance, at the time):</p>



<blockquote>
<p>Yes, the reason I used¬†<code>wrk</code>, is that it uses pipelining. That‚Äôs why ab (apachebench) had such terrible performance: it opened a new socket for each request. And then it overloaded the system by throwing</p>



<ul>
<li><code>socket: Too many open files</code></li>



<li><code>apr_socket_recv: Connection reset by peer¬†</code></li>
</ul>



<p>errors.</p>



<p>I raised the¬†<code>ulimit -n</code>¬†to 10240, but still¬†<code>apr_socket_recv: Connection reset by peer (104)</code>¬†occurred occasionally.</p>
<cite><a href="https://forums.swift.org/u/axello/summary" data-wpel-link="external" target="_blank" rel="external noopener">Axel Roest</a>, <a href="https://forums.swift.org/t/standard-vapor-website-drops-1-5-of-requests-even-at-concurrency-of-100/71583/122" data-wpel-link="external" target="_blank" rel="external noopener">Swift Forums thread</a></cite></blockquote>



<p>This hinted very directly at the second major problem, but it seems nobody in the forum thread realised it.  I think there was still a pre-occupation with the file descriptor ulimit.</p>



<p>A little logic applied at the time of Axel‚Äôs comment <em>should</em> have revealed its mistaken presumption: that opening new TCP connections for each HTTP request will inevitably cause connection failures.  Sure, it will if you give it enough concurrent connection attempts, but real-world web servers operate at <em>huge</em> loads that are basically one HTTP request per connection, without any significant reliability problems.  In hindsight, it‚Äôs clear that Axel‚Äôs dismissal of this behaviour as in any way normal was a mistake ‚Äì as was everyone else in the thread going along with that dismissal.</p>



<div><p>‚ö†Ô∏è If a tool isn‚Äôt working the way you expect, maybe that‚Äôs telling you something important.  Just switching tools until you find one which doesn‚Äôt exhibit the problem doesn‚Äôt necessarily mean it‚Äôs not still a problem.</p></div>



<h3><span id="A_misunderstood_workaround">A misunderstood workaround</span></h3>



<p>In parallel to all of the above discussion in the Swift Forums thread, I‚Äôd been diving into <code>wrk</code> to see what it was really doing.  I discovered <em>a way</em> to eliminate the errors: by opening all the TCP connections in advance in a way that <em>happened</em> to limit how many were attempted concurrently by <code>wrk</code> thread count which <em>happened</em> to be low enough in my use of <code>wrk</code> to not hit the magic 128 limit (more on that later).  As you can see in <a href="https://forums.swift.org/t/standard-vapor-website-drops-1-5-of-requests-even-at-concurrency-of-100/71583/123" data-wpel-link="external" target="_blank" rel="external noopener">my forum post on this</a>, I initially misunderstood how <code>wrk</code> functioned and misattributed the root cause as bugs / bad design in <code>wrk</code>.</p>



<p>In my defence, <code>wrk</code> isn‚Äôt written very well, eschewing such outrageous and bourgeois software engineering practices as, you know, actually checking for errors.  So it wasn‚Äôt unreasonable to believe it was ultimately just broken, given plenty of evidence that it was at least partly broken (which it was &amp; is), but it was ultimately a mistake to let that cloud my judgement of each individual behaviour.</p>



<p>Then again, if I hadn‚Äôt been so appalled by the bad code in <code>wrk</code>, and taken it upon myself to rewrite key parts of it, I might not have stumbled onto the above ‚Äúfix‚Äù and therefore also not found the true cause, later.</p>



<div><p>‚úÖ Improving error handling &amp; reporting is practically always a good idea.  And when debugging a problem it can be helpful even if it doesn‚Äôt feel guided ‚Äì the whole point of absent or incorrect error reporting is that you don‚Äôt know what you‚Äôre missing, so you may well reveal an important clue ‚Äúby accident‚Äù.</p></div>



<h3><span id="It8217s_never_the_compiler_or_the_kernel_except_when_it_is">It‚Äôs never the compiler or the kernel‚Ä¶ except when it is</span></h3>



<p>At the time I did think I‚Äôd actually <em>fixed</em> <code>wrk</code>; I didn‚Äôt realise I‚Äôd merely found an imperfect workaround.  I‚Äôd solved the connection errors (not really)!  But, I was still curious about one thing ‚Äì something pretty much everyone had kinda ignored this whole time:</p>



<blockquote>
<p>Though those lingering few read/write errors still bother me. I might look into them later.</p>
<cite>Me, <a href="https://forums.swift.org/t/standard-vapor-website-drops-1-5-of-requests-even-at-concurrency-of-100/71583/123" data-wpel-link="external" target="_blank" rel="external noopener">Swift Forums thread</a></cite></blockquote>







<p>Tracing those reported errors to their cause was quite a challenge.  The only known way to reproduce the errors was to use a very high number of concurrent TCP connections (several thousand), which made it hard to follow any <em>single</em> connection through its lifecycle using any low-brow methods (printf debugging etc).  <a href="https://forums.swift.org/t/standard-vapor-website-drops-1-5-of-requests-even-at-concurrency-of-100/71583/129" data-wpel-link="external" target="_blank" rel="external noopener">I eventually managed</a> using System Trace<sup data-fn="65590619-a219-4fb0-87ea-fd2c98990365"><a href="#65590619-a219-4fb0-87ea-fd2c98990365" id="65590619-a219-4fb0-87ea-fd2c98990365-link">1</a></sup> (lamenting, the entire time I used Instruments, that it would have been <a href="https://leopard-adc.pepas.com/documentation/DeveloperTools/Conceptual/SharkUserGuide/SystemTracing/SystemTracing.html" data-wpel-link="external" target="_blank" rel="external noopener">so much easier in Shark</a>).</p>



<p>Unfortunately, what I was seeing ‚Äì while in fact correct ‚Äì did not make sense to me, so I was hesitant to take it on face value.</p>



<p>The lack of any error reporting on the server side, because Vapor lacks it completely, was also both a known problem at the time and also a problem in hindsight.  Had Vapor/NIO actually reported the errors they were encountering, it would have partially validated what I was seeing in the system traces ‚Äì in fact, it would probably have saved me from having to capture &amp; analyse system traces.</p>



<div><p>‚ùå Ignoring errors is always a bad idea.  I mean, duh, right?  But apparently it has to be reiterated.</p></div>



<p>Alas I don‚Äôt actually remember now precisely what led me to the final answers and root causes.  I know it involved many hours of experimenting, exploring hypotheses, and in generally fiddling with everything I could think of.</p>



<p>Somehow or other, I did finally cotton on to a key configuration parameter:  <code>kern.ipc.somaxconn</code>.</p>



<p>That controls how many connection requests can be pending (not formally accepted by the server) at one time.  It defaults to 128 on macOS.  Remember that number, 128?</p>



<p>Once I had figured out that <code>kern.ipc.somaxconn</code> directly controlled the problematic behaviour, the rest followed pretty naturally and quickly ‚Äì I realised that what I saw in the system traces was in fact accurate, and that in turn revealed that the macOS kernel contains multiple surprisingly blatant and serious bugs (or at the very least dubious design choices, and lying documentation) regarding TCP sockets in non-blocking mode.  I wrote that up in some detail in the second half of <a href="https://forums.swift.org/t/standard-vapor-website-drops-1-5-of-requests-even-at-concurrency-of-100/71583/132" data-wpel-link="external" target="_blank" rel="external noopener">this Swift Forums post</a>.</p>



<p>As a sidenote, that darn magic number that everyone kept ignoring ‚Äì 128 ‚Äì cropped up yet again, in <a href="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man2/listen.2.html" data-wpel-link="external" target="_blank" rel="external noopener">the <code>listen</code> man page</a>, though by the time I saw it there it was merely a confirmation of what I‚Äôd already discovered, than a helpful clue.  Still, perhaps there‚Äôs a lesson there:  read the man page. üòÜ</p>



<div><p>‚ùå When documenting known bugs and limitations, explain them fully.  Don‚Äôt just say e.g. ‚Äúmore than 128 doesn‚Äôt work‚Äù, say <em>why</em>.</p></div>



<h2><span id="Conclusion">Conclusion</span></h2>



<p>All told, the major problems identified by the benchmark were (and not all of these were mentioned above, but you can find all the details in <a href="https://forums.swift.org/t/standard-vapor-website-drops-1-5-of-requests-even-at-concurrency-of-100/71583" data-wpel-link="external" target="_blank" rel="external noopener">the Swift Forums thread</a>):</p>



<ul>
<li>The particular 3rd party library used for BigInt support in Swift, <a href="https://github.com/attaswift/BigInt" data-wpel-link="external" target="_blank" rel="external noopener">attaswift/BigInt</a>, performs quite poorly.</li>



<li>Vapor would accept too few connections per cycle of its event loop (promptly fixed, in <a href="https://github.com/vapor/vapor/releases/tag/4.96.0" data-wpel-link="external" target="_blank" rel="external noopener">4.96.0</a>).</li>



<li>The benchmark tool used, <code><a href="https://github.com/wg/wrk" data-wpel-link="external" target="_blank" rel="external noopener">wrk</a></code>, has numerous bugs:
<ul>
<li>It doesn‚Äôt always use the configured number of concurrent connections.</li>



<li>It doesn‚Äôt measure latency correctly.</li>



<li>It doesn‚Äôt report errors correctly (in the sense both that it miscategorises them, e.g. connect vs read/write, and that it doesn‚Äôt provide enough detail to understand what they are, such as by including the errno).</li>
</ul>
</li>



<li>The macOS kernel (and seemingly Linux kernel likewise) has multiple bugs:
<ul>
<li>Connection errors are reported incorrectly (as <code>ECONNRESET</code> or <code>EBADF</code>, instead of <code>ECONNREFUSED</code>).</li>



<li>kqueue (kevents) behaves as if all connections are always accepted, even when they are not.  Put another way, you cannot actually tell if a connection was successful when using non-blocking sockets on macOS.</li>
</ul>
</li>



<li>Key network configuration on macOS &amp; Linux is way too restrictive:
<ul>
<li>Maximum file descriptors per process is only 2,560 generally on macOS, and even less (256) in GUI apps.  It may vary on Linux, but on Axel‚Äôs particular server it was 1,024.</li>



<li>Maximum number of unaccepted connection requests (the <code>kern.ipc.somaxconn</code> sysctl on macOS, <code>/proc/sys/net/core/somaxconn</code> on Linux) is only 128 on macOS.  It may vary on Linux.</li>
</ul>
</li>
</ul>



<p>It <em>appears</em> that the kernel bugs apply to Linux as well (although it‚Äôs not known if kqueue was in use there, as <code>wrk</code> also supports <code>epoll</code> and <code>select</code>), as the behaviour seems to be the same there, but I didn‚Äôt test that myself and it‚Äôs not completely clear from Axel‚Äôs posts.  Also, Axel has not yet done a follow-up with the final fixes &amp; workarounds, to confirm that they do fully fix the benchmark‚Äôs results.</p>



<p>And that‚Äôs just the <em>problems</em> ‚Äì there was a whole host of interesting lessons taken away from all this (only a fraction of which were highlighted in this post ‚Äì many more can be found in Axel‚Äôs posts and the Swift Forums thread).</p>



<p>Nominally the end result is also a benchmark that shows Vapor (Swift) out-performing other popular web frameworks in other languages.  <em>Hugely</em> out-performing them, if you factor in not just throughput &amp; latency but RAM &amp; power usage.  But, to reiterate <a href="#do-these-improvements-apply-to-the-other-cases-too">what I pointed out earlier</a>, take that with a grain of salt.</p>



<p>So, for a benchmark that many initially decried as unrealistic or plain poorly conceived, it turned out to be pretty darn useful, I think.  And if that doesn‚Äôt make it a successful benchmark, I don‚Äôt know what does.</p>


		</div></div>
  </body>
</html>
