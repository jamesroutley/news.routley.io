<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.bbc.com/news/magazine-22751415">Original</a>
    <h1>Why Finnish babies sleep in cardboard boxes (2013)</h1>
    
    <div id="readability-page-1" class="page"><article><p>Somehow I am organizing a conference called <a href="https://www.hytradboi.com/">Have you tried rubbing a database on it?</a></p><p>This isn&#39;t what I planned to do this year. How did this happen?</p><h2 id="inception">Inception</h2><p>The answer is that I drank too much coffee before breakfast and ended up on twitter, where I saw someone joking that the solution to thinking that everything is a compiler problem is to learn about databases - now you have two problems.</p><p>Which hits a little too close to home. But while we&#39;re thinking about it...</p><p>Are these actually two separate problems?</p><p>Fundamentally, every computer system is about storing, moving and transforming data. The line between operating system, database and programming language is somewhat arbitrary - a product of specific problems, available hardware and historical accident.</p><p>But today the problems and the hardware have changed dramatically, and as a result we&#39;re starting to see people experimenting with redrawing the lines.</p><p>Here are some of the changes:</p><ul><li><strong><a href="https://aiimpacts.org/trends-in-dram-price-per-gigabyte/">Cheaper ram</a>, <a href="https://itnext.io/modern-storage-is-plenty-fast-it-is-the-apis-that-are-bad-6a68319fbc1a">faster storage hardware and better IO apis</a></strong>. It used to make sense to think of the database as the thing that works with data on the slow block-addressable persistent memory and the programming language as the thing that works with data on the fast byte-addressable volatile memory. Those two different kinds of hardware require very different techniques. But over the last decade that distinction has narrowed, <a href="https://15721.courses.cs.cmu.edu/spring2020/slides/02-inmemory.pdf">in-memory databases</a> have crossed over to the other side, and with <a href="https://www.tomshardware.com/news/intel-optane-dimm-pricing-performance,39007.html">byte-addressable non-volatile memory</a> finally starting to be commercially available the tradeoffs are going to change radically.</li><li>While storage speeds increased, <strong>memory latency and cpu speed stagnated</strong>. Taking full advantage of today&#39;s hardware requires being aware of data locality, prefetching, pipelining, branch prediction etc, not to mention taking advantage of increasing core counts. This requires writing code in a style that is very foreign to most programmers and for which most programming languages don&#39;t offer much assistance. Which is why eg a SQL query in a modern analytics database will often outperform a hand-written C++ program.</li><li><strong>Distributed systems have become much more prevalent</strong>, in large part due to everything moving to the web. On the server side we have to deal with horizontal scaling already, and possibly the <a href="https://engineering.purdue.edu/WukLab/disaggregate.html">disaggregation of the server</a> in the future. On the client side most people now have multiple devices, each of which is moving towards more hetoregenous hardware (eg <a href="https://en.wikipedia.org/wiki/ARM_big.LITTLE">arm&#39;s big.little</a>). We now spend much more time describing the movement of data between systems than in the past, and we&#39;ve discovered that expecting programmers to be able to reason about consistency by hand is a losing battle (see eg <a href="https://jepsen.io/">jepsen breaking everything</a>, google&#39;s heavy investment in <a href="https://static.googleusercontent.com/media/research.google.com/en//archive/spanner-osdi2012.pdf">spanner</a> for global consistency).</li><li><strong>The table stakes have risen</strong> for both for user-facing applications and dev-facing apis - real-time updates, collaborative editing, sync across devices and with cloud servers, interop between different services etc. In particular the complexity of both distributed webapps and complex GUIs makes change management appealing (eg <a href="https://reactjs.org/docs/hooks-intro.html">react hooks</a>, <a href="https://docs.mongodb.com/realm/sdk/node/fundamentals/live-queries/">realm&#39;s live objects</a>).</li><li><strong>The increasing ops burden</strong> on the server side means people are open to radical changes eg <a href="https://aws.amazon.com/lambda/">&#39;serverless&#39; computing</a>.</li><li><strong>The growing value of big data analysis</strong> and the fragmentation of it&#39;s ecosystem results in needing to be able to easily share data between many different languages and across many machines (eg via <a href="https://arrow.apache.org/">arrow</a>).</li></ul><p>Here are some of the directions people are exploring to deal with these changes:</p><ul><li><strong>Pushing runtime state and logic into the database</strong> eg facebook messenger <a href="https://engineering.fb.com/2020/03/02/data-infrastructure/messenger/">moved much of their coordination and caching logic</a> into sqlite, our machinery <a href="https://ourmachinery.com/post/the-story-behind-the-truth-designing-a-data-model/">stores their entire runtime state</a> in a custom in-memory database, fossil <a href="https://www.fossil-scm.org/home/doc/trunk/www/theory1.wiki##h2">writes large parts of its logic in SQL</a>, unity encourages <a href="https://docs.unity3d.com/Packages/com.unity.entities@0.17/manual/index.html">storing all runtime state in their entity component system</a>.</li><li><strong>Abandoning global control flow</strong> in favor of scheduling systems which understand dataflow and dependencies eg streaming systems like <a href="https://flink.apache.org/">flink</a> or <a href="https://www.confluent.io/stream-processing/">kafka streams</a>, incremental systems like <a href="https://reactjs.org/">react</a>, <a href="https://github.com/salsa-rs/salsa">salsa</a> or <a href="https://nixos.org/">nix</a>, parallel execution systems like the <a href="https://docs.unity3d.com/Manual/JobSystem.html">unity job system</a>, event-triggered systems like <a href="https://aws.amazon.com/lambda/">aws lambda functions</a> or <a href="https://www.airtable.com/product/automations">airtable automations</a>.</li><li><strong>Moving data-intensive code into specialized systems</strong> eg vectorized libraries like <a href="https://numpy.org/">numpy</a> or <a href="https://github.com/dremio/gandiva">gandiva</a>, specialized compilers like <a href="https://docs.unity3d.com/Packages/com.unity.burst@0.2/manual/index.html">unity&#39;s burst</a>, <a href="https://cs.stanford.edu/%7Ematei/papers/2017/cidr_weld.pdf">weld</a> or <a href="https://futhark-lang.org/">futhark</a>.</li><li><strong>Taking advantage of uniform data models</strong> to provide generic solutions to hard problems eg <a href="https://github.com/automerge/automerge">automerge</a> provides offline collaboration, <a href="http://www.ultorg.com/">ultorg</a> turns databases into crud apps, the <a href="https://ourmachinery.com/docs/writing-tools-faster/index.html">our machinery database</a> provides undo, online collaboration and automatically generated editor UI, <a href="https://matrix.org/">matrix</a> piggybacks all their other functionality on top of their generic message sync protocol.</li><li><strong>Unbundling the monolithic database server</strong> into separate tools eg <a href="https://martin.kleppmann.com/2015/11/05/database-inside-out-at-oredev.html">turning the database inside out</a>, <a href="https://www.youtube.com/watch?v=YhF8YR0OEFk">turning the database into a toolkit</a>.</li></ul><p>I don&#39;t know what the future is going to look like, but a rewarding avenue of experiment is to take the tools and techniques developed in the database world and recombine them in new ways and on new problems - redrawing the lines between operating system, database and programming language.</p><p>But those lines are still encoded in the structure of our fields. Database people go to database conferences. Programming language people go to programming language conferences. Game engine developers are not going to either of those conferences.</p><p>What if we tried to get all these people in the same room?</p><h2 id="format">Format</h2><p>Well, &#39;room&#39;. This isn&#39;t exactly the best year for international travel. So it will have to be online.</p><p>And at first that felt like a problem, because I usually go to conferences to meet people and only later watch the recorded talks at 2x speed, because most people talk too slowly and rehearse too little. A conference where I just watch the talks at regular speed and then don&#39;t get to talk to anyone doesn&#39;t sound that appealing.</p><p>Passive lectures aren&#39;t an effective way to convey information anyway. So I prefer the model used by eg <a href="https://bangbangcon.com/">!!con</a> - all talks are ten minutes long, and they&#39;re treated as a starting point to get people talking rather than as a complete lecture.</p><p>You can pack a lot of ideas into a heavily edited, well rehearsed 10 minute recording (I&#39;ve been using <a href="https://vimeo.com/641790697">medc</a> as my favorite example). And we can show a lot of those 10 minute recordings in one day and still reserve half the time for discussion over text and video chat.</p><h2 id="funding">Funding</h2><p>Many tech conferences end up being a series of hour-long ads from software vendors. Which is fine. Sometimes people need to buy software. But that means that it&#39;s all about the immediate future - things that you can already sell. It doesn&#39;t leave much room for people doing things out on the fringes. So I wanted to run a conference that wouldn&#39;t accept talks that are just &#39;doing boring task X with expensive SaaS Y&#39;.</p><p>But then how do I get sponsors to pay for the conference?</p><p>This year I &#39;went&#39; to <a href="https://www.handmade-seattle.com/">handmade</a>. It had no ads and no sponsors - supported entirely by ticket sales. How did they do it? They just... didn&#39;t spend loads of money.</p><p>And handmade was a hybrid event. They had to book a location, hire staff to sign people in etc. Plus they live-streamed and live-captioned everything. That&#39;s expensive and difficult.</p><p><a href="https://archive.fosdem.org/2021/">Fosdem</a> this year was online-only. They estimate the hardware costs for 30k attendees at <a href="https://news.ycombinator.com/item?id=26144249">a few thousand dollars</a>.</p><p>If I cut out the live-streaming too and do entirely pre-recorded talks, what costs am I even left with? Video hosting. Captioning. Text and video chat. Maybe hiring moderators, if there are a lot of attendees. That&#39;s it.</p><p>So I expect the costs to be low enough that I can go out on a wing and set the ticket price to pay-what-you-want.</p><p>(There&#39;s also labour. A lot of labour. But that&#39;s <a href="https://github.com/sponsors/jamii">already been paid for</a>.)</p><h2 id="talks">Talks</h2><p>I thought that the hard part would be finding speakers, but a week after publishing the site <a href="https://www.hytradboi.com/#speakers">the lineup is already pretty exciting</a>. Turns out you can just email strangers and ask them to give a talk at your just-recently-invented conference and they&#39;ll agree. (Track record so far - 8 yes, 3 maybe, 1 no reply).</p><p>There is also a <a href="https://docs.google.com/forms/d/e/1FAIpQLSdVtuKHEVZN052mQy7DJVX6P9bl26mfvxwiwvTnHJY7ToD_7w/viewform">form to propose a talk</a>. There have already been a few solid proposals, some of which for projects that I never would have heard of otherwise.</p><p>One of the nice things about being an purely online conference is there isn&#39;t a capacity limit. So rather than thinking about accepting or rejecting talks, I&#39;m thinking about it as a curation problem. I&#39;ll add the talks that I think people will be most excited about to the main schedule, but I&#39;ll also intersperse it with choose-your-own-adventure blocks where attendees can individually choose which of the remaining talks to watch. And all of the talks will be available publicly after the event.</p><h2 id="you">You</h2><p>If this sounds like something you&#39;d enjoy you can sign up here to be notified when tickets are available:</p><p>Or you can submit a talk proposal here:</p><p><a href="https://forms.gle/xuc1yX1sZYJSy48f7" id="submit">Propose a talk</a></p></article></div>
  </body>
</html>
