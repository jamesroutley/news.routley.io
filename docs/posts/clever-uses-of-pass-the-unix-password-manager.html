<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://vitalyparnas.com/guides/pass/">Original</a>
    <h1>Clever uses of pass, the Unix password manager</h1>
    
    <div id="readability-page-1" class="page"><div id="entry-content">
<p>Pass (<a href="https://www.passwordstore.org/">main site</a>, <a href="https://wiki.archlinux.org/index.php/Pass">Arch wiki</a>) is a command-line Unix password manager that utilizes GPG for all underlying encryption. However, beyond passwords, we can utilize it in a number of clever ways.</p>

<h3>Contents</h3>

<ul>
<li><a href="#general">General usage</a>

<ul>
<li><a href="#insert">Insert new passwords</a></li>
<li><a href="#generate">Generate new passwords</a></li>
<li><a href="#access">Access an existing password</a></li>
<li><a href="#edit">Edit an existing password</a></li>
<li><a href="#ops">Copy, move, delete</a></li>
</ul></li>
<li><a href="#files">File encryption and multi-line password files</a></li>
<li><a href="#other">Other sensitive data encryption</a>

<ul>
<li><a href="#apis">HTTP APIs</a></li>
<li><a href="#s3cmd">s3cmd</a></li>
<li><a href="#config_files">isync/mbsync and mstmp</a></li>
</ul></li>
</ul>

<h3>General usage <a name="general"></a></h3>

<p>More of a prereq than a tip, install <code>bash-completion</code> or whatever shell completion that pertains to you. Pass usage becomes vastly easier once all command-line arguments and password-store hierarchy conveniently expand as you type.</p>

<p>First, all proceeding operations impact your password store directory, this either <code>$HOME/.pass</code> or <code>$PASSWORD_STORE_DIR</code>. </p>

<p>Initialize the main password store. This merely creates the respective folder with a <code>.gpg-id</code> file containing your desired gpg key identifier.</p>

<pre><code>pass init &lt;gpg id&gt;
</code></pre>

<h4>Insert new passwords <a name="insert"></a></h4>

<pre><code>pass insert ebay
pass insert email/user1
pass insert email/user2
</code></pre>

<p>Each prompts you to enter and reenter the desired password. The first creates <code>ebay.gpg</code> within your password store directory, the latter two <code>user1.gpg</code> and <code>user2.gpg</code> within the <code>email</code> sub-folder. (Optional: append the <code>-e</code> flag to echo the entered text to your terminal in exchange for only one entry prompt.)</p>

<p>The flexibility of any directory hierarchy is extremely helpful for password organization and command-line auto-completion. Furthermore, pass creates all missing sub-folders to any level of depth.</p>

<h4>Generate new passwords <a name="generate"></a></h4>

<pre><code>pass generate -c &lt;acct_critical&gt; 20
pass generate -c -n &lt;acct_non_critical&gt; 10
</code></pre>

<p>The first creates a more secure, alpha-numeric and symbolic 20-character password. The second creates an alpha-numeric only password (<code>-n</code> = no symbols) of 10 characters. Both copy the password to the system clipboard (<code>-c</code>) rather than echo it to the terminal.</p>

<h4>Access an existing password <a name="access"></a></h4>

<pre><code>pass acct_non_critical
pass -c email/user1
</code></pre>

<p>The first echoes the password to the terminal in plain glory. The second copies the password to the system clipboard for the default 45 seconds, this handier and far more secure.</p>

<p>Again, auto-completion is wonderful when entering these commands.</p>

<h4>Edit an existing password <a name="edit"></a></h4>

<p>This opens up the password for editing within your configured text <code>$EDITOR</code>.</p>

<pre><code>pass edit &lt;name&gt;
</code></pre>

<h4>Copy, move, delete <a name="ops"></a></h4>

<pre><code>pass cp email/user1 email/user3
pass mv user4 email/user4
pass rm old_account
pass rm -r email
</code></pre>

<p>The first effectively copies user1.gpg to user3.gpg, both to have the same password. The second moves user4.gpg to email/user4.gpg. The third deletes old_account.gpg. The fourth recursively clears the entire email subfolder of passwords.</p>

<p>All of these operations you can also execute using the plain unix <code>cp/mv/rm</code> on the respective files in the password store directory. There’s no other metadata to consider. The mechanism is quiet simple and transparent!</p>

<h3>File encryption and multi-line password files <a name="files"></a></h3>

<p>pass supports multi-line passwords, manually entered via <code>pass insert -m &lt;name&gt;</code> or edited/appended via <code>pass edit &lt;name&gt;</code>. With <code>edit</code> you can even expand an initially single-line password file.</p>

<p>Following traditional usage, a multi-line password might resemble the following:</p>

<pre><code>EFxlP.pAFmB$xmH7|_h4
username
email
street address
</code></pre>

<p>The default copy command <code>pass -c</code> only copies the first line of such a multi-line password file, in this case the very password. </p>

<p>However, <code>pass edit</code> or <code>pass [show]</code> enables you to edit/see the entire blob. </p>

<p>Additionally, <code>pass -c[num]</code> copies the indicated line.</p>

<p>We can thus store any amount of data in a ‘password’ file, including entire documents. </p>

<p>Here we pipe a file <code>secret_answers.txt</code> for encrypted storage within the password file <code>sensitive/secret_answers</code>:</p>

<pre><code>pass insert -m sensitive/secret_answers &lt; secret_answers.txt
# Or
cat secret_answers.txt | pass insert -m sensitive/secret_answers
</code></pre>

<p>Better yet, to recursively encrypt an entire directory <code>sensitive_dir</code> within the folder <code>sensitive</code> of your password store, folder structure maintained:</p>

<pre><code>for file in $(find sensitive_dir -type f); do 
    pass insert -m &#34;sensitive/$file&#34; &lt; &#34;$file&#34; &gt; /dev/null 
done
</code></pre>

<p>You could also achieve the above via direct <code>gpg</code> manipulation outside your password store. However, pass greatly abstracts the viewing and especially the editing of such encrypted data with the simplicity of the <code>pass edit</code> command.</p>

<p>One might suggest an encrypted container or filesystem solutions. This is ultimately a matter of taste. For my part, I’ve never cared much for their relative complexity of implementation, configuration and management. </p>

<p>The amount of <em>frequently read/written</em> files that I consider encryption-worthy (beyond whatever security inherent to their storage medium), tends to number relatively small. I’d rather deal with the ad-hoc encryption of individual files, and pass makes this seamless.</p>

<h3>Other sensitive data encryption <a name="other"></a></h3>

<p>I don’t like sensitive bits to be plain text viewable, be it strictly for my own eyes. This includes not only passwords but possibly compromising API keys or other access codes.</p>

<p>These often appear within command line arguments or configuration files. Here I present a few use to circumvent the issue with pass.</p>

<h4>HTTP APIs <a name="apis"></a></h4>

<p>Cloud providers often feature HTTP based APIs requiring a key. With <code>curl</code>, we might access the API as such:</p>

<pre><code>curl -H &#34;API-Key: &lt;sensitive&gt;&#34; ...
</code></pre>

<p>I’d rather the plain key not appear, per the incorporation of this shell call to pass:</p>

<pre><code>curl -H &#34;API-Key: $(pass provider/api_key)&#34; ...
</code></pre>

<h4>s3cmd <a name="s3cmd"></a></h4>

<p>s3cmd enables CLI access to the Amazon S3 object storage. The <code>$HOME/.s3cfg</code> config annoyingly echoes the access/secret keys in plain text form:</p>

<pre><code>access_key = &lt;sensitive&gt;
secret_key = &lt;sensitive&gt;
</code></pre>

<p>Instead, we can set them to blank strings (necessary for proper functioning)</p>

<pre><code>access_key = &#39;&#39;
secret_key = &#39;&#39;
</code></pre>

<p>and setup the following alias to pass the keys on the command line, encrypted in our password store:</p>

<pre><code>alias s3cmd=&#34;s3cmd --access_key=&#34;&#39;$(pass aws/access)&#39;&#34; \
    --secret_key=&#34;&#39;$(pass aws/secret)&#39;
</code></pre>

<p>Note above the single quotes around the invocation of <code>$(pass ...)</code>. This is necessary to postpone the command evaluation until execution, rather than the resulting keys appear directly in your rendered alias.</p>

<h4>isync/mbsync and mstmp <a name="config_files"></a></h4>

<p>mbsync locally syncs your Imap email mailbox. I personally don’t wish to be prompted for the account password on each synchronization.</p>

<p>The solution either requires storing the plain text password in the <code>Pass</code> directive of the <code>.mbsyncrc</code> config file, or the alternative password evaluator directive as follows:</p>

<pre><code>PassCmd &#34;pass email/user1&#34;
</code></pre>

<p>The identical situation presents itself in the case of msmtp, the email sending framework. To store a password in the config, we could either opt for the plain text <code>password &lt;plain text&gt;</code>, or </p>

<pre><code>passwordeval &#34;pass email/user1&#34;
</code></pre>

<p>Once again, pass to the rescue.</p>
<p><b>Questions, comments</b>? <a href="https://vitalyparnas.com/connect/">Connect</a>.</p>
</div></div>
  </body>
</html>
