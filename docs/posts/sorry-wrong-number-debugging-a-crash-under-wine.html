<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.jchw.io/wrong-number/">Original</a>
    <h1>Sorry, Wrong Number: Debugging a Crash Under Wine</h1>
    
    <div id="readability-page-1" class="page"><div id="site-main">
    <article>

        <header>


            


            <div>
                <section>
                    <ul>
                        <li>
                            <a href="https://blog.jchw.io/author/john/"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><path d="M3.513 18.998C4.749 15.504 8.082 13 12 13s7.251 2.504 8.487 5.998C18.47 21.442 15.417 23 12 23s-6.47-1.558-8.487-4.002zM12 12c2.21 0 4-2.79 4-5s-1.79-4-4-4-4 1.79-4 4 1.79 5 4 5z" fill="#FFF"></path></g></svg>
</a>
                        </li>
                    </ul>
                    <div>
                        
                        <p><time datetime="2022-04-12">Apr 12, 2022</time>
                            <span><span>•</span> 14 min read</span>
                        </p>
                    </div>
                </section>
            </div>

            <figure>
                <img srcset="https://images.unsplash.com/photo-1610278614135-739ed9ef1ef4?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDI0M3x8d2luZXxlbnwwfHx8fDE2NDk3MzgzOTE&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000 300w,
                            https://images.unsplash.com/photo-1610278614135-739ed9ef1ef4?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDI0M3x8d2luZXxlbnwwfHx8fDE2NDk3MzgzOTE&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000 600w,
                            https://images.unsplash.com/photo-1610278614135-739ed9ef1ef4?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDI0M3x8d2luZXxlbnwwfHx8fDE2NDk3MzgzOTE&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000 1000w,
                            https://images.unsplash.com/photo-1610278614135-739ed9ef1ef4?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDI0M3x8d2luZXxlbnwwfHx8fDE2NDk3MzgzOTE&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000 2000w" sizes="(min-width: 1400px) 1400px, 92vw" src="https://images.unsplash.com/photo-1610278614135-739ed9ef1ef4?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDI0M3x8d2luZXxlbnwwfHx8fDE2NDk3MzgzOTE&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" alt="Sorry, Wrong Number: Debugging a Crash under Wine"/>
                    <figcaption>Photo by <a href="https://unsplash.com/@jefspeetjens?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit">Jos Speetjens</a> / <a href="https://unsplash.com/?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit">Unsplash</a></figcaption>
            </figure>
        </header>

        <section>
            <p>On December 3rd, 2021, a friend of mine needed help: their program was crashing on <a href="https://winehq.org">Wine</a>, and they wanted to know how to fix it.</p><p>(And I&#39;m only getting around to publishing this <em>now</em>, several months later. I&#39;m a bit disorganized...)</p><p>Normally, the answer to this question is not very complicated, because a lot of stuff works just fine in Wine provided the environment is setup correctly, and some stuff simply doesn&#39;t work. Usually problems fall into one of those two categories; however, in this case, there really wasn&#39;t any obvious reason (at least to me) why it shouldn&#39;t work.</p><p>The program in question is compiled with MSys2&#39;s MinGW-w64 package, using GCC 10.3. It contains a few other libraries <em>also</em> compiled with the same toolchain, as DLLs, including <code>libpng</code> and <code>zlib</code>, which I am about to become very familiar with.</p><p>Some debugging had already been done, and they knew which call the application was failing in: a call to <code>png_read_info</code>. I ran it under Wine using the <code>WINE_DEBUG=+all</code> option and generated a gigantic log file of mostly useless information. After a bit of correlation, I found the last API call before the crash: an <code>msvcrt._read</code>, returning successfully... and then we crash.</p><p>After a bit of misdirection, I realized a crucial detail that I had been glancing over for a bit: the access violation was an <em>execute</em>, <em>not</em> a read or write. That means that RIP is landing in the middle of a page that is not executable. Hmmm. Stack corruption, somehow?</p><p>Something interesting about Wine is that you can run it under Valgrind, which, with a few flags, does <em>actually </em>work correctly. But upon doing this, I discovered nothing particularly interesting, certainly nothing that would suggest stack corruption, so I moved on.</p><p>At this point I decided to break out rr, a special debugger that can record and replay program execution. Honestly, it&#39;s a bit overkill here, but it does make it easier to analyze crashes, and this seemed like a good excuse to pull it out. There <em>is</em> a bit of trickiness with using rr on top of Wine, but it works more or less just fine; it&#39;s just a bit of a pain to get the replay working. I never quite figured out how to get debug symbols to map correctly with this Wine-under-GDB setup going on, so I had to manually explore the address space to figure out what I was looking at.</p><p>After much ado, the program crashes into... nowhere. It crashes at <code>0x2&#39;fe8f&#39;2910</code>. Nothing is mapped here. Hmm.</p><p>Using the magic of rr, I can replay to some point directly before the crash and then step into it. A few hundred <code>stepi</code>s later, and I found the culprit: <code>e8 20 45 7e 96</code>, at the address <code>0x3&#39;6810&#39;e3eb</code>. AKA, <code>CALL 0x2fe8f2910</code> . In other words: there is an explicit <code>CALL</code> to nowhere.</p><p>At this point, I threw <code>libpng</code> in a disassembler, and found the instruction at <code>0x36810e3eb</code>. The instruction?</p><figure><img src="https://blog.jchw.io/content/images/2021/12/image.png" alt="A screenshot showing a CALL instruction, CALL near ptr crc32 (E8 78 9E 03 00)" loading="lazy" width="1044" height="371" srcset="https://blog.jchw.io/content/images/size/w600/2021/12/image.png 600w, https://blog.jchw.io/content/images/size/w1000/2021/12/image.png 1000w, https://blog.jchw.io/content/images/2021/12/image.png 1044w" sizes="(min-width: 720px) 720px"/><figcaption>A call to... crc32?</figcaption></figure><p>Bizarre. That <code>CALL</code> has a completely different address. It is <code>e8 78 9e 03 00</code>, not <code>e8 20 45 7e 96</code> which is non-sense and points backwards to before the entire module.</p><p>So who&#39;s modifying the CALL? Is it the program? Is it libpng? Is it Wine?</p><figure><img src="https://blog.jchw.io/content/images/2021/12/image-2.png" alt="A screenshot of Fred Jones from Scooby Doo imminently unmasking a perpetrator." loading="lazy" width="541" height="402"/></figure><p>One thing we <em>do</em> know about the <code>.text</code> segment is that it&#39;s read-only. Of course, you should at least <em>verify</em> this in your disassembler, but I did, and indeed, it&#39;s read-only. That means that in order to modify the segment, someone would need to deliberately mark it writable. On UNIX-like platforms, you would use a syscall like <code>mprotect</code>, whereas Windows provides <code>VirtualProtect</code> in <code>kernel32</code>. Thankfully, there&#39;s really no way that libpng would link to <code>VirtualPro</code>-</p><figure><img src="https://blog.jchw.io/content/images/2021/12/image-5.png" alt="A screenshot of the IDA imports panel, showing VirtualProtect and VirtualQuery being imported from KERNEL32 by the libpng DLL." loading="lazy" width="937" height="62" srcset="https://blog.jchw.io/content/images/size/w600/2021/12/image-5.png 600w, https://blog.jchw.io/content/images/2021/12/image-5.png 937w" sizes="(min-width: 720px) 720px"/><figcaption>Goddammit.</figcaption></figure><p>...what exactly is libpng doing calling this?</p><figure><img src="https://blog.jchw.io/content/images/2021/12/image-7.png" alt="A call graph showing VirtualProtect being called by sub_36812E420, which is called by sub_36812E590, which is called by sub_3680F1200 (which is, effectively, the DLL&#39;s entrypoint.)" loading="lazy" width="1441" height="558" srcset="https://blog.jchw.io/content/images/size/w600/2021/12/image-7.png 600w, https://blog.jchw.io/content/images/size/w1000/2021/12/image-7.png 1000w, https://blog.jchw.io/content/images/2021/12/image-7.png 1441w" sizes="(min-width: 720px) 720px"/></figure><p>Apparently, it reaches back to <code>sub_3680F1200</code>, which is just the entry point of the DLL–there&#39;s a stub over at the &#34;true&#34; entry point, but IDA does not count the <code>jmp</code> in the call graph, so you can&#39;t see it here.</p><p>In order to try to identify what this code was, I used the tried and true strategy of looking for interesting strings, and quickly found a few, but the most interesting was this one: <code>&#34;Unknown pseudo relocation bit size %d&#34;</code> – hrm, what&#39;s a pseudo relocation?</p><p>I&#39;ve mostly glossed over many of the lower level details in this post, but I think this one merits some more attention.</p><h2 id="whats-a-normal-relocation">What&#39;s a <em>normal</em> relocation?</h2><p>Before answering what a <em>pseudo</em> relocation is, I&#39;d like to discuss <em>regular</em> relocations. When a linker links a program module, it has to pick some arbitrary &#34;base address&#34; to use for <em>position-dependent</em> code and data. What does that mean? Let&#39;s say you have a global, statically-initialized variable that is a pointer to another global variable. This is allowed. The pointer written into the executable file during compilation (specifically linking) is the address that <em>would</em> be correct if the program module was loaded into its <em>preferred base address</em>. Much code and data is position-independent, and thus does not need relocations, but any place where an absolute offset into the address space must be written, such as static pointers, relocations will be needed.</p><p>However, being loaded at your preferred base address is somewhat rare these days. For one thing, almost all executable loaders <em>have </em>to support relocating the module to a different base address, because otherwise, it&#39;d be impossible to simultaneously load two modules whose preferred base addresses lead to an overlap, and these cannot be coordinated ahead of time in most cases. In addition, modern AMD64 machines have plenty of address space, so for security reasons, a mitigation called ASLR is almost always used, which essentially just randomizes the base address of program modules even if they are not initially overlapping. (This is a <em>bit </em>of an <a href="https://devblogs.microsoft.com/oldnewthing/20160413-00/?p=93301">oversimplification</a>.)</p><p>If we move (that is, change the location of) the program module in memory, the addresses that the linker had to write based off of the preferred base address don&#39;t line up, as the module is now at a <em>different </em>address, and all offsets are now shifted by some value. In order to adjust this pointer, the linker stores a relocation entry in the binary during compilation for each instance of position-dependent code or data, such as our pointer. At runtime, the executable loader or runtime linker will read each relocation entry and adjust it based on the type of relocation and the offset; adding the offset between the preferred base and the actual base directly to the value present at the address. As long as there is no inadvertent position-dependent code not accounted for by relocations, everything will work perfectly fine.</p><p>Modern Windows uses the Portable Executable format. The PE format contains ~9 or so different kinds of relocation entries, some of which vary depending on CPU architecture. The main reason this is necessary is to handle different relocations that modify CPU instructions, where the address may be encoded into the CPU instruction in different ways that the relocation needs to be aware of. PE handles, for example, special cases for the MIPS, ARM (32-bit), and RISC-V instruction sets. (UEFI uses the PE binary format for its binaries, so in order for RISC-V to be able to support UEFI, the PE binary format needed to add support for RISC-V, too. Fun fact!)</p><h2 id="microsoft-windows-vs-everything-else">Microsoft Windows vs. Everything Else</h2><p>The thing is, though, in many other operating systems, especially UNIX-likes, relocations and symbols are different. Whereas Windows binaries have explicit Imports and Exports, and a vector of pointers called the IAT (Import Address Table,) ELF binaries have a single unified symbol table. And when it comes to relocations, ELF has a lot more types of relocations than PE.</p><p>Why does this matter? The answer has everything to do with linkage.</p><p>When you compile some C code, and it references a symbol which is not defined in that translation unit, it is treated as an <em>external symbol</em>. Later, during linking, when the linker resolves that symbol, it can place the address of the symbol where needed, and thus, the symbol is resolved.</p><p>This becomes a problem when linking to other libraries and modules; the address of the symbol is not actually known until runtime, when those libraries and modules are loaded in. Because of that, you need to generate different code; code that resolves the address at runtime, then uses that address. At least on Windows, it would not be typical to generate code like this for any external symbol; it would be slow and wasteful.</p><p>Thankfully, there is a workaround for function calls: the linker can generate a <em>thunk</em>; a small routine that forwards the call through the IAT, then that thunk can be used as the address to write in for the CALL instruction.</p><p>But what if you reference a <em>data</em> symbol from another library or module? Or, if you try to get the address of a function symbol from another library or module? That&#39;s a problem. You need to generate the aforementioned code which resolves the address first, and the compiler, not knowing that this is the case, will generate the wrong code, and the linker will not be able to deal with it.</p><p>With ELF, you actually <em>can</em> do this, using symbol-relative relocations. With PE, you are S.O.L. (Simply Out of Luck.) Or at least, you would <em>normally </em>be.</p><h2 id="what-a-pseudo-relocation-is">What a <em>pseudo-relocation </em>is.</h2><p>Of course, it <em>is</em> possible to link to data symbols on Windows. This is what all of that <code>__declspec(dllimport)</code> business is for: you can specify it on declarations of external symbols, and that way the compiler can generate code which is appropriate for linking to an external symbol in another library.</p><p>So what&#39;s the problem?</p><p>Well, a lot of code written for UNIX-likes doesn&#39;t mark their symbols with <code>__declspec(dllimport)</code>, given that it is a Windows-only feature. MinGW wants to support compiling these programs, and in order to support that, it has invented the concept of <em>pseudo-relocations</em>. (Or perhaps Cygwin has invented this concept; I&#39;m not sure.) A pseudo-relocation is a &#34;fake&#34; relocation handled at runtime, by the library itself, after the real relocations are done. It does this by, at the entrypoint, walking through a list of pseudo-relocations and adjusting the pointers with some offset relative to an IAT entry. These pseudo-relocations import symbol-relative imports, just like ELF systems.</p><p>In other words... Pseudo-relocations are a MinGW feature that implements a special kind of &#34;relocation&#34; where a pointer in code or data is replaced with an address <em>relative to an imported symbol</em>. </p><p>(Truth be told, it&#39;s unclear why MinGW has decided that a call to <code>crc32</code> needs a pseudo-relocation, but it seems like it can happen when you pass flags to prevent thunks from being generated, and the wrong definitions to zlib to prevent it from using the proper attributes on its symbols.)</p><p>Hopefully, you have at least as good an understanding as I do about <em>why</em> pseudo-relocations exist, and what problem they&#39;re meant to solve... but a problem remains:</p><p>Why does this code, which works under Windows, break under Wine? If you are particularly keen, you may already have an idea what&#39;s going on, but just to make sure we&#39;re going to dive into exactly what&#39;s happening.</p><p>In order to get more insight into what&#39;s going on, we can debug the pseudo-relocation implementation. I don&#39;t have debug symbols for it, but that&#39;s not a big deal, since the pseudo-relocation code compiles down to relatively succinct and understandable machine code.</p><p>Wine provides a GDB server, so you can connect a number of different debuggers. However, I hit a crucial limitation with winedbg right away: it seems to execute the loader before we have a chance to insert breakpoints, which means the libpng entrypoint has already ran before we get the chance to break on it. This leaves us with a couple of different options:</p><ul><li>We could fudge the <code>was_init</code> variable. It&#39;s a global that the pseudo-reloc code uses to determine if it has run already; the DLL entrypoint runs for new threads, so we could just break on that, then adjust <code>was_init</code> so that it runs again anyways. This probably works in this case, but it&#39;s not very versatile.</li><li>We can forgo winedbg and simply run Wine itself under GDB.</li></ul><h2 id="wine-under-gdb">Wine under GDB</h2><p>When I used rr earlier, I was basically already doing this. However, rr is pretty overkill for this problem, and actually introduces some complexity of its own, so it&#39;s probably easier to just forgo it for now.</p><p>I&#39;m on NixOS, where the WINE binary on the <code>$PATH</code> is actually a shell script. We&#39;ll tell GDB to execute bash first.</p><pre><code> gdb --args bash wine Game.exe</code></pre><p>This won&#39;t work just yet; we need to adjust the behaviors on fork and exec; then we can go.</p><pre><code>(gdb) set follow-fork-mode child
(gdb) set follow-exec-mode new
(gdb) catch fork
Catchpoint 1 (fork)
(gdb) catch exec
Catchpoint 2 (exec)
(gdb) run</code></pre><p>We can <code>continue</code> a couple of times until we&#39;re finally in our target binary, then flip <code>follow-fork-mode</code> back to <code>parent</code> and <code>follow-exec-mode</code> back to <code>same</code>. I want to set a breakpoint at the point at which the <code>was_init</code> variable is flagged. Because WINE doesn&#39;t implement ASLR, our libraries end up at their preferred base addresses, so lacking symbols in GDB, I can just enter the raw addresses as determined by digging around in IDA:</p><pre><code>(gdb) break *0x36812E5C8
Breakpoint 3 at 0x36812e5c8</code></pre><p>GDB doesn&#39;t give us a whole lot of feedback. Something useful you can do is have GDB print the disassembly at the instruction pointer for you:</p><pre><code>(gdb) display/i $pc
1: x/i $pc
=&gt; 0x36812e5c8: movl   $0x1,0x14b0e(%rip)        # 0x3681430e0
(gdb) </code></pre><p>Now, as we step through, we can see what instruction we are on.</p><p>In this case, the <code>+0x14b0e</code> address is <code>was_init</code>. This instruction may look strange since <a href="https://github.com/Alexpux/mingw-w64/blob/d90b8bb82e9b3ece71b8e505fa9b3d75747d8046/mingw-w64-crt/crt/pseudo-reloc.c#L473">pseudo-reloc has <code>++was_init</code> rather than <code>was_init = 1</code></a>, but I think we can assume that the compiler has optimized it to assume <code>was_init</code> is zero due to the conditional beforehand. Neat.</p><p>This could get pretty boring if we tried to understand and explain each instruction. I&#39;ve already analyzed the function and found the relocations, so I should be able to set a conditional breakpoint that gets me into the exact spot I want to be.</p><figure><img src="https://blog.jchw.io/content/images/2021/12/image-12.png" alt="IDA Pro screenshot showing a number of runtime_pseudo_reloc_item_v2 structures, highlighting the one that covers the offset of interest for us." loading="lazy" width="1025" height="535" srcset="https://blog.jchw.io/content/images/size/w600/2021/12/image-12.png 600w, https://blog.jchw.io/content/images/size/w1000/2021/12/image-12.png 1000w, https://blog.jchw.io/content/images/2021/12/image-12.png 1025w" sizes="(min-width: 720px) 720px"/></figure><p>IDA Pro annoyingly shows the same address for all relocations because it&#39;s marked as an array. That&#39;s OK – we just need to calculate it out, and make a quick breakpoint:</p><pre><code>(gdb) break *0x36812E69D if $rbx == 0x36813DF4C
Breakpoint 5 at 0x36812e69d</code></pre><p>And now we can continue. Once we&#39;re there, we can step around:</p><pre><code>(gdb) stepi
0x000000036812e69f in ?? ()
1: x/i $pc
=&gt; 0x36812e69f: mov    0x4(%rbx),%esi
(gdb)
0x000000036812e6a2 in ?? ()
1: x/i $pc
=&gt; 0x36812e6a2: movzbl 0x8(%rbx),%edx
(gdb)
0x000000036812e6a6 in ?? ()
1: x/i $pc
=&gt; 0x36812e6a6: add    %r13,%rax
(gdb)
0x000000036812e6a9 in ?? ()
1: x/i $pc
=&gt; 0x36812e6a9: add    %r13,%rsi
(gdb)
0x000000036812e6ac in ?? ()
1: x/i $pc
=&gt; 0x36812e6ac: mov    (%rax),%r15
(gdb)
0x000000036812e6af in ?? ()
1: x/i $pc
=&gt; 0x36812e6af: cmp    $0x20,%edx
(gdb)
0x000000036812e6b2 in ?? ()
1: x/i $pc
=&gt; 0x36812e6b2: je     0x36812e7a8
(gdb)</code></pre><p>This is just a switch statement compiled into a conditional tree. As luck would have it, all of our relocations are 32-bit (<em>...</em>), so this first conditional hits immediately.</p><pre><code>(gdb)
0x000000036812e7a8 in ?? ()
1: x/i $pc
=&gt; 0x36812e7a8: mov    (%rsi),%edx
(gdb)
0x000000036812e7aa in ?? ()
1: x/i $pc
=&gt; 0x36812e7aa: mov    %rdx,%rcx
(gdb) nexti
0x000000036812e7ad in ?? ()
1: x/i $pc
=&gt; 0x36812e7ad: or     %r14,%rdx
(gdb)
0x000000036812e7b0 in ?? ()
1: x/i $pc
=&gt; 0x36812e7b0: test   %ecx,%ecx
(gdb)
0x000000036812e7b2 in ?? ()
1: x/i $pc
=&gt; 0x36812e7b2: cmovns %rcx,%rdx
(gdb)
0x000000036812e7b6 in ?? ()
1: x/i $pc
=&gt; 0x36812e7b6: mov    %rsi,%rcx
(gdb)
0x000000036812e7b9 in ?? ()
1: x/i $pc
=&gt; 0x36812e7b9: sub    %rax,%rdx
(gdb)
0x000000036812e7bc in ?? ()
1: x/i $pc
=&gt; 0x36812e7bc: add    %rdx,%r15
(gdb)
0x000000036812e7bf in ?? ()
1: x/i $pc
=&gt; 0x36812e7bf: call   0x36812e420
(gdb)
0x000000036812e7c4 in ?? ()
1: x/i $pc
=&gt; 0x36812e7c4: mov    %r15d,(%rsi)
(gdb)
0x000000036812e7c7 in ?? ()
1: x/i $pc
=&gt; 0x36812e7c7: jmp    0x36812e694
(gdb)</code></pre><p>This code right here is the culprit. It just wrote <code>%r15d</code> to the memory at the address pointed to by <code>%rsi</code>. What are those values?</p><pre><code>(gdb) i r r15d
r15d           0x967e4520          -1770109664
(gdb) i r rsi
rsi            0x36810e3ec         14630839276</code></pre><p>We have, without a doubt, located the culprit. It&#39;s writing the exact same sequence of incorrect bytes we saw earlier. What the heck is wrong with it? Why isn&#39;t it getting the correct address for crc32? Why is it <code>0x1&#39;0000&#39;0000</code> too far forward?</p><p>If you haven&#39;t figured it out yet, this should do it:</p><pre><code># At this point, %rax points to where the IAT entry is,
# and %r15 points to the actual value in it.
rax            0x368148268         14631076456
r15            0x1fe8f2910         8565762320

# Read the value at the target into %edx.
# This is a pointer into the IAT.
mov    (%rsi),%edx

rsi            0x36810e3ec         14630839276
*rsi           0x39e78             237176
edx            0x20 -&gt; 0x39e78     32 -&gt; 237176

# Copy %rdx into %rcx.
mov    %rdx,%rcx
rdx            0x39e78             237176
rcx            0x0 -&gt; 0x39e78      0 -&gt; 237176

# Perform sign extension on %rdx copy.
or     %r14,%rdx
r14            0xffffffff00000000  -4294967296
rdx            0x39e78 -&gt; 0xffffffff00039e78  237176 -&gt; -4294730120

# Test %ecx for flags.
test   %ecx,%ecx
eflags         0x286               [ PF SF IF ]
ecx            0x39e78             237176

# This undoes the sign extension if the sign bit is not set.
cmovns %rcx,%rdx
eflags         0x206               [ PF IF ]
rcx            0x39e78             237176
rdx            0xffffffff00039e78 -&gt; 0x39e78  -4294730120 -&gt; 237176

# At this point we&#39;ve undone the sign extension.

# Move relative offset of IAT into rcx, for mark_section_writable.
mov    %rsi,%rcx
rsi            0x36810e3ec         14630839276
rcx            0x39e78 -&gt; 0x36810e3ec  237176 -&gt; 14630839276

# %rax is the absolute address of the IAT entry. Subtract it from %rdx.
sub    %rax,%rdx
rax            0x368148268         14631076456
rdx            0x39e78 -&gt; 0xfffffffc97ef1c10  237176 -&gt; -14630839280

# Add %rdx to %r15.
add    %rdx,%r15
rdx            0xfffffffc97ef1c10  -14630839280
r15            0x1fe8f2910 -&gt; 0xfffffffe967e4520  8565762320 -&gt; -6065076960

# Call mark_section_writable
call   0x36812e420

# Write the pseudo-relocation back.
mov    %r15d,(%rsi)
rsi            0x36810e3ec         14630839276
*rsi           0x39e78 -&gt; 0x967e4520  237176 -&gt; -1770109664
r15d           0x967e4520          -1770109664
</code></pre><p>Did you catch it? The distance between the instruction is greater than what can be stored in a 32-bit value. The E8 CALL instruction can only jump between [-2<sup>31</sup>,2<sup>31</sup>) bytes away from the RIP as of execution because it can only store a 32-bit signed offset. Unfortunately, the pseudo reloc code simply failed silently back when I was debugging this, but I believe it has been fixed and now outputs an error when this occurs, so it shouldn&#39;t be so puzzling to future generations.</p><h2 id="one-last-thing">One last thing...</h2><p>There is one more weird thing though. This program <em>works</em> on Windows, reliably. Obviously, it isn&#39;t loading libraries at their preferred base addresses, or it would crash. So why is this happening?</p><p>Well, simple: Wine doesn&#39;t support ASLR, and the libraries, at their preferred addresses, wind up too far away for the pseudo-relocations.</p><p>However, the fact that it works seemingly reliably on Windows is very interesting. Maybe an interesting exploration would be to see exactly why Windows ASLR seems to consistently choose addresses that are unproblematic. Perhaps it&#39;s because the first time after bootup that these particular modules load is in quick succession?</p><p>Regardless, now knowing how the problem can be fixed, it&#39;s hard to be motivated to dig <em>too </em>much deeper. It might be nice if Wine could have similar ASLR behavior to Windows, so that these problems are less likely to crop up only on Wine, but these problems could also occur on Windows with ASLR disabled, so it&#39;s probably not that important.</p><p>Overall, I had fun debugging this issue. I&#39;m also really happy with how far Wine has come, and I do not think it is a coincidence that the issue we hit was not reasonably Wine&#39;s fault. I am, however, a bit sad that I didn&#39;t get an opportunity to track down and fix a nasty Wine bug, but all the more happy that the reason for this is because it simply didn&#39;t exist.</p><p>Maybe next time. :)</p>
        </section>


    </article>
</div></div>
  </body>
</html>
