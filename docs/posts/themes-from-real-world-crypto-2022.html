<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.trailofbits.com/2022/05/03/themes-from-real-world-crypto-2022/">Original</a>
    <h1>Themes from Real World Crypto 2022</h1>
    
    <div id="readability-page-1" class="page"><article id="post-102141">
	<!-- .entry-header -->

	<div>
		<p><strong><em>By William Woodruff</em></strong></p>
<p>Last week, over 500 cryptographers from around the world gathered in Amsterdam for Real World Crypto 2022, meeting in person for the first time in over two years.</p>
<p>As in <a href="https://blog.trailofbits.com/2020/01/23/themes-from-real-world-crypto-2020/" rel="noopener" target="_blank">previous years</a>, we dispatched a handful of our researchers and engineers to attend the conference, listen to talks, and <s>schmooze</s> observe the themes currently dominating the nexus between cryptographic research and practical (real world!) engineering.</p>
<p>Here are the major themes we gleaned from Real World Crypto 2022:</p>
<ol>
<li><strong>Trusted hardware isn’t so trustworthy</strong>: Implementers of trusted hardware (whether trusted execution environments (TEEs), HSMs, or secure enclaves) continue to make engineering mistakes that fundamentally violate the integrity promises made by the hardware.</li>
<li><strong>Security tooling is still too difficult to use</strong>: Or “you can lead a horse to water, but you can’t make it run <code>./configure &amp;&amp; make &amp;&amp; make install</code>.”</li>
<li><strong>Side channels everywhere</strong>: When God closes a door, he opens a side channel.</li>
<li><strong>LANGSEC in cryptographic contexts</strong>: Figuring out which protocol you’re speaking is the third hard problem in computer science.</li>
</ol>
<p>Let’s get to it!</p>
<h2>Trusted hardware isn’t so trustworthy</h2>
<p>Fundamental non-cryptographic vulnerabilities in trusted hardware are nothing new. Years of vulnerabilities have led to Intel’s decision to <a href="https://www.bleepingcomputer.com/news/security/new-intel-chips-wont-play-blu-ray-disks-due-to-sgx-deprecation/" rel="noopener" target="_blank">remove SGX</a> from its next generation of consumer CPUs, and <a href="https://www.cve.org/CVERecord?id=CVE-2017-15361" rel="noopener" target="_blank">ROCA</a> affected <a href="https://www.theregister.com/2017/10/16/roca_crypto_vuln_infineon_chips/" rel="noopener" target="_blank">one in four TPMs</a> back in 2017.</p>
<p>What <em>is</em> new is the prevalence of trusted hardware in <em>consumer-facing</em> roles. Ordinary users are increasingly (and unwittingly!) interacting with secure enclaves and TEEs via password managers and 2FA schemes like <a href="https://www.w3.org/TR/webauthn-2/" rel="noopener" target="_blank">WebAuthn</a> on their mobile phones and computers. This has fundamentally broadened the risk associated with vulnerabilities in trusted hardware: breaks in trusted hardware now pose a <em>direct</em> risk to individual users.</p>
<p>That’s where our first highlight from RWC 2022 comes in: <strong>“Trust Dies in Darkness: Shedding Light on Samsung’s TrustZone Cryptographic Design”</strong> (<a href="https://iacr.org/submit/files/slides/2022/rwc/rwc2022/58/slides.pdf" rel="noopener" target="_blank">slides</a>, <a href="https://youtu.be/9Citd5IT9hU?t=24" rel="noopener" target="_blank">video</a>, <a href="https://eprint.iacr.org/2022/208.pdf" rel="noopener" target="_blank">paper</a>). In this session, the presenters describe two critical weaknesses in <a href="https://developer.samsung.com/teegris/overview.html" rel="noopener" target="_blank">TEEGRIS</a>, Samsung’s implementation of a <a href="https://www.arm.com/technologies/trustzone-for-cortex-m" rel="noopener" target="_blank">TrustZone</a> OS: an <strong>IV reuse attack</strong> that allows an attacker to extract hardware-protected keys, and a <strong>downgrade attack</strong> that renders even the latest <em>and patched</em> flagship Samsung devices vulnerable to the first attack. We’ll take a look at both.</p>
<h3>IV reuse in TEEGRIS</h3>
<p>TEEGRIS is an entirely separate OS, running in isolation and in parallel with the “normal” host OS (Android). To communicate with the host, TEEGRIS provides a trusted application (TA) that runs within the TEE but exposes resources to the normal host via <a href="https://source.android.com/security/keystore/implementer-ref" rel="noopener" target="_blank">Keymaster</a>, a command-and-response protocol standardized by Google.</p>
<p>Keymaster includes the concept of “blobs”: encryption keys that have themselves been encrypted (“wrapped”) with the TEE’s key material and stored on the host OS. Because the wrapped keys are stored on the host, their security ultimately depends on the security of the TEE’s correct application of encryption during key wrapping.</p>
<p>So how does the TEEGRIS Keymaster wrap keys? With AES-GCM!</p>
<p>As you’ll recall, there are (normally) three parameters for a block cipher (AES) combined with a mode of operation (GCM):</p>
<ul>
<li>The <em>secret key</em>, used to initialize the block cipher</li>
<li>The <em>initialization vector (IV)</em>, used to perturb the ciphertext and prevent our friend <a href="https://words.filippo.io/the-ecb-penguin/" rel="noopener" target="_blank">the ECB penguin</a></li>
<li>The <em>plaintext</em> itself, which we intend to encrypt (in this case, another encryption key)</li>
</ul>
<p>The security of AES-GCM depends on the assumption that an IV is never reused for the same secret key. Therefore, an attacker that can force the secret key and IV to be used across multiple “sessions” (in this case, key wrappings) can violate the security of AES-GCM. The presenters discovered mistakes in Samsung’s Keymaster implementation that violate two security assumptions: that the key derivation function (KDF) can’t be manipulated to produce the same key multiple times, and that the attacker can’t control the IV. Here’s how:</p>
<ul>
<li>On the Galaxy S8 and S9, the KDF used to generate the secret key used only <strong>attacker-controlled inputs</strong>. In other words, an attacker can force all encrypted blobs for a given Android application to use the <strong>exact same AES key</strong>. In this context, this is acceptable <em>as long as</em> an attacker cannot force IV reuse, <em>except</em>…</li>
<li>…the Android application <em>can</em> set an IV when generating or importing a key! Samsung’s Keymaster implementation on the Galaxy S9 trusts the IV passed in by the host, allowing an attacker to use the same IV multiple times.</li>
</ul>
<p>At this point, the properties of the stream cipher itself give the attacker everything they need to recover an encryption key from another blob: the XOR of the malicious blob, the malicious key, and the target (victim) blob that yields the plaintext of the target, which is the unwrapped encryption key!</p>
<p>Ultimately, the presenters determined that this <em>particular</em> attack worked only on the Galaxy S9: the S8’s Keymaster TA generates secret keys from attacker-controlled inputs but doesn’t use an attacker-provided IV, preventing IV reuse.</p>
<p>The talk’s presenters reported this bug in March of 2021, and it was assigned <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-25444" rel="noopener" target="_blank">CVE-2021-25444</a>.</p>
<h3>Downgrade attacks</h3>
<p>As part of their analysis of Samsung’s TrustZone implementation, the presenters discovered that the Keymaster TA on Galaxy S10, S20, and S21 devices used a newer blob format (“v20-s10”) by default. This new format changes the data used to seed the KDF: instead of being entirely attacker controlled, random bytes (derived from the TEE itself) are mixed in, preventing key reuse.</p>
<p>But not so fast: the TEE on the S10, S20, and S21 uses the “v20-s10” format by default but allows the application to specify a different blob version to use instead. The version without any randomized salt (“v15”) is one of the valid options, so we’re right back where we started with predictable key generation.</p>
<p>The talk’s presenters reported this bug in July of 2021, and it was assigned <a href="https://nvd.nist.gov/vuln/detail/CVE-2021-25490" rel="noopener" target="_blank">CVE-2021-25490</a>.</p>
<h3>Takeaways</h3>
<p>TEEs are not special: they’re subject to the same cryptographic engineering requirements as everything else. Hardware guarantees are only as good as the software running on top of them, which should (1) use modern ciphers with misuse-resistant modes of operation, (2) minimize potential attacker influence over key and key derivation material, and (3) eliminate the attacker’s ability to downgrade formats and protocols that <em>should</em> be completely opaque to the host OS.</p>
<h2>Security tooling is still too difficult to use</h2>
<p>We at Trail of Bits are big fans of automated security tooling: it’s why we write and open-source tools like <a href="https://github.com/trailofbits/dylint" rel="noopener" target="_blank"><code>dylint</code></a>, <a href="https://github.com/trailofbits/pip-audit" rel="noopener" target="_blank"><code>pip-audit</code></a>, <a href="https://github.com/trailofbits/siderophile" rel="noopener" target="_blank"><code>siderophile</code></a>, and <a href="https://github.com/crytic/echidna" rel="noopener" target="_blank">Echidna</a>.</p>
<p>That’s why we were saddened by the survey results in <strong>“‘They’re not that hard to mitigate’: What Cryptographic Library Developers Think About Timing Attacks”</strong> (<a href="https://iacr.org/submit/files/slides/2022/rwc/rwc2022/47/slides.pdf" rel="noopener" target="_blank">slides</a>, <a href="https://youtu.be/cX-o9rM2DgM?t=1795" rel="noopener" target="_blank">video</a>, <a href="https://eprint.iacr.org/2021/1650.pdf" rel="noopener" target="_blank">paper</a>): of 44 cryptographers surveyed across 27 major open-source cryptography projects, only 17 had actually used automated tools to find timing vulnerabilities, even though 100% of the participants surveyed were aware of timing vulnerabilities and their potential severity. The following are some of the reasons participants cited for choosing not to use automated tooling:</p>
<ul>
<li><strong>Skepticism about risk</strong>: Many participants expressed doubt that they needed additional tooling to help mitigate timing attacks or that there were practical real-world attacks that justified the effort required for mitigation.</li>
<li><strong>Difficulty of installation or use</strong>: Many of the tools surveyed had convoluted installation, compilation, and usage instructions. Open-source maintainers expressed frustration when trying to make projects with outdated dependencies work on modern systems, particularly in contexts in which they’d be most useful (automated testing in CI/CD).</li>
<li><strong>Maintenance status</strong>: Many of the tools surveyed are source artifacts from academic works and are either unmaintained or very loosely maintained. Others had no easily discoverable source artifacts, had binary releases only, or were commercially or otherwise restrictively licensed.</li>
<li><strong>Invasiveness</strong>: Many of the tools introduce additional requirements on the programs they analyze, such as particular build structures (or program representations, such as C/C++ or certain binary formats only) and special DSLs for indicating secret and public values. This makes many tools inapplicable to newer projects written in languages like Python, Rust, and Go.</li>
<li><strong>Overhead</strong>: Many of the tools involve significant learning curves that would take up too much of a developer’s already limited time. Many also require a significant amount of time to use, even after mastering them, in terms of manually reviewing and eliminating false positives and negatives, tuning the tools to increase the true positive rate, and so forth.</li>
</ul>
<p>Perhaps unintuitively, <em>awareness</em> of tools did not correlate with their use: the majority of developers surveyed (33/44) were aware of one or more tools, but only half of that number actually <em>chose</em> to use them.</p>
<h3>Takeaways</h3>
<p>In the presenters’ words, there is a clear “leaky pipeline” from awareness of timing vulnerabilities (nearly universal), to tool awareness (the majority of developers), to actual tool use (a small minority of developers). Stopping those leaks will require tools to become:</p>
<ul>
<li><strong>Easier to install and use</strong>: This will reduce the cognitive overhead necessary between selecting a tool and actually being able to apply it.</li>
<li><strong>Readily available</strong>: Tools must be discoverable without requiring intense familiarity with active cryptographic research; tools should be downloadable from well-known sources (such as public Git hosts).</li>
</ul>
<p>Additionally, the presenters identified <strong>compilers</strong> themselves as an important new frontier: the compiler is always present, is already familiar to developers, and is the ideal place to introduce more advanced techniques like secret typing. We at Trail of Bits happen to agree!</p>
<h2>Side channels everywhere</h2>
<p>The great thing about side-channel vulnerabilities is their incredible pervasiveness: there’s a seemingly never-ending reservoir of increasingly creative techniques for extracting information from a target machine.</p>
<p>Side channels are typically described along two dimensions: <strong>passive-active</strong> (i.e., does the attacker need to interact with the target, and to what extent?) and <strong>local-remote</strong> (i.e., does the attacker need to be in the physical vicinity of the target?). <strong>Remote</strong>, <strong>passive</strong> side channels are thus the “best of both worlds” from an attacker’s perspective: they’re entirely covert and require no physical presence, making them (in principle) undetectable by the victim.</p>
<p>We <em>loved</em> the side channel described in <strong>“Lend Me Your Ear: Passive Remote Physical Side Channels on PCs”</strong> (<a href="https://youtu.be/cX-o9rM2DgM?t=3102" rel="noopener" target="_blank">video</a>, <a href="https://www.usenix.org/system/files/sec22summer_genkin.pdf" rel="noopener" target="_blank">paper</a>). To summarize:</p>
<ul>
<li>The presenters observed that, on laptops, the onboard microphone is physically wired to the audio interface (and, thus, to the CPU). Digital logic controls the intentional flow of data, but it’s all just wires and, therefore, unintentional noise underneath.</li>
<li>In effect, this means that the onboard microphone might act as an EM probe for the CPU itself!</li>
<li>We share our audio over the internet to potentially untrusted parties: company meetings, conferences, VoIP with friends and family, voice chat for video games, and so on…</li>
<li>…so can we extract anything of interest from that data?</li>
</ul>
<p>The presenters offered three case studies:</p>
<ul>
<li><strong>Website identification</strong>: A victim is browsing a website while talking over VoIP, and the attacker (who is on the call with the victim) would like to know <em>which</em> site the victim is currently on.
<ul>
<li><strong>Result</strong>: Using a convolutional neural network with a 14-way classifier (for 14 popular news websites), the presenters were able to achieve 96% accuracy.</li>
</ul>
</li>
<li><em>Cryptographic key recovery</em>: A victim is performing ECDSA signatures on her local machine while talking over VoIP, and the attacker would like to exfiltrate the secret key being used for signing.
<ul>
<li><strong>Result</strong>: The presenters were able to use the same side-channel weakness as <a href="https://eprint.iacr.org/2020/728.pdf" rel="noopener" target="_blank">Minerva</a> but without local instrumentation. Even with post-processing noise, they demonstrated key extraction after roughly 20,000 signing operations.</li>
</ul>
</li>
<li><strong>CS:GO wallhacks</strong>: A victim is playing an online first-person shooter while talking with other players over VoIP, and the attacker would like to know where the victim is physically located on the game map.
<ul>
<li><strong>Result</strong>: Distinct “zebra patterns” were visually identifiable in the spectrogram when the victim was hidden behind an opaque in-game object, such as a car. The presenters observed that this circumvented standard “anticheat” mitigations, as no client code was manipulated to reveal the victim’s in-game location.</li>
</ul>
</li>
</ul>
<h3>Takeaways</h3>
<p>Side channels are the gift that keeps on giving: they’re difficult to anticipate and to mitigate, and they compromise cryptographic schemes that are <strong>completely sound</strong> in the abstract.</p>
<p>The presenters correctly note that this particular attack upends a traditional assumption about physical side channels: that they cannot be exploited remotely and, thus, can be excluded from threat models in which the attacker is purely remote.</p>
<h2>LANGSEC in cryptographic contexts</h2>
<p><a href="http://langsec.org/" rel="noopener" target="_blank">LANGSEC</a> is the “language-theoretic approach to security”: it attributes many (most?) exploitable software bugs to the <em>ad hoc interpretation</em> of potentially untrusted inputs and proposes that we parse untrusted inputs by comparing them against a <em>formal language</em> derived solely from valid or expected inputs.</p>
<p>This approach is <em>extremely</em> relevant to the kinds of bugs that regularly rear their heads in applied cryptography:</p>
<ul>
<li>Complex schemes (like PKCS#1 v1.5) with complex underlying formats (like DER) continue to produce exploitable bugs: <a href="https://mailarchive.ietf.org/arch/msg/openpgp/5rnE9ZRN1AokBVj3VqblGlP63QE/" rel="noopener" target="_blank">Bleichenbacher’s 2006 attack</a> <a href="https://github.com/FiloSottile/BERserk" rel="noopener" target="_blank">keeps</a> <a href="https://i.blackhat.com/USA-19/Wednesday/us-19-Chau-A-Decade-After-Bleichenbacher-06-RSA-Signature-Forgery-Still-Works-wp.pdf" rel="noopener" target="_blank">showing up</a> year after year.</li>
<li>Complex protocols (like TLS) and upgrade/downgrade behavior also produce exploitable bugs: <a href="https://www.openssl.org/~bodo/ssl-poodle.pdf" rel="noopener" target="_blank">POODLE</a> downgrades to SSL 3.0, and <a href="https://dl.acm.org/doi/pdf/10.1145/3386367.3431310" rel="noopener" target="_blank">implementation errors can allow for TLS 1.3 downgrades</a>.</li>
</ul>
<p>We saw not one, but <em>two</em> LANGSEC-adjacent talks at RWC this year!</p>
<h3>Application layer protocol confusion</h3>
<p>The presenters of <strong>“ALPACA: Application Layer Protocol Confusion—Analyzing and Mitigating Cracks in TLS Authentication”</strong> (<a href="https://iacr.org/submit/files/slides/2022/rwc/rwc2022/46/slides.pdf" rel="noopener" target="_blank">slides</a>, <a href="https://youtu.be/Htms5rNy7B8?t=1245" rel="noopener" target="_blank">video</a>, <a href="https://www.usenix.org/system/files/sec21-brinkmann.pdf" rel="noopener" target="_blank">paper</a>) started with their observation of a design decision in TLS: because TLS is fundamentally application and protocol independent, it has no <em>direct</em> notion of how the two endpoints should be communicating. In other words, TLS cares only about establishing an encrypted channel between two machines, not (necessarily) <em>which</em> machines or <em>which</em> services on those machines are actually communicating.</p>
<p>In their use on the web, TLS certificates are normally bound to domains, preventing an attacker from redirecting traffic intended for <code>safe.com</code> to <code>malicious.biz</code>. But this isn’t always sufficient:</p>
<ul>
<li>Wildcard certificates are common: an attacker who controls <code>malicious.example.com</code> might be able to redirect traffic from <code>safe.example.com</code> if that traffic were encrypted with a certificate permitting <code>*.example.com</code>.</li>
<li>Certificates can claim many hosts, including hosts that have been obtained or compromised by a malicious attacker: the certificate for <code>safe.example.com</code> might also permit <code>safe.example.net</code>, which an attacker might control.</li>
<li>Finally, and perhaps most interestingly, certificates <strong>do not</strong> specify which <em>service</em> and/or <em>port</em> they expect to authenticate with, creating an opportunity for an attacker to <strong>redirect traffic to a different service on the same host</strong>.</li>
</ul>
<p>To make this easier for the attacker, hosts frequently run multiple services with protocols that roughly resemble HTTP. The presenters evaluated four of them (FTP, SMTP, IMAP, and POP3) against three different attack techniques:</p>
<ul>
<li><strong>Reflection</strong>: A MiTM attacker redirects a cross-origin HTTPS request to a different service on the same host, causing that service to “reflect” a trusted response back to the victim.</li>
<li><strong>Download</strong>: An attacker stores malicious data on a service running the same host and tricks a subsequent HTTPS request into downloading and presenting that data, similarly to a stored XSS attack.</li>
<li><strong>Upload</strong>: An attacker compromises a service running on the same host and redirects a subsequent HTTPS request to the service, causing sensitive contents (such as cookie headers) to be uploaded to the service for later retrieval.</li>
</ul>
<p>Next, the presenters evaluated popular web browsers and application servers for FTP, SMTP, IMAP, and POP3 and determined that:</p>
<ul>
<li><strong>All browsers</strong> were vulnerable to at least two attack techniques (FTP upload + FTP download) against one or more FTP server packages.</li>
<li><strong>Internet Explorer and Microsoft Edge</strong> were <em>particularly</em> vulnerable: all exploit methods worked with one or more server packages.</li>
</ul>
<p>This is all <s>terrible great</s>, but how many <em>actual</em> servers are vulnerable? As it turns out, quite a few: of <strong>2 million</strong> unique hosts running a TLS-enabled application server (like FTP or SMTP), over <strong>1.4 million</strong> (or 69%) were <em>also</em> running HTTPS, making them potentially vulnerable to a general cross-protocol attack. The presenters further narrowed this down to hosts with application servers that were known to be exploitable (such as old versions of ProFTPD) and identified over <strong>114,000</strong> HTTPS hosts that could be attacked.</p>
<p>So what can we do about it? The presenters have some ideas:</p>
<ul>
<li>At the application server level, there are some reasonable countermeasures we could apply: protocols like FTP should be more strict about what they accept (e.g., refusing to accept requests that look like HTTP) and should be more aggressive about terminating requests that don’t resemble valid FTP sessions.</li>
<li>At the certificate level, organizations should be wary of wildcard and multi-domain certificates and should avoid shared hosts for TLS-enabled applications.</li>
<li>Finally, at the protocol level, TLS extensions like <a href="https://tools.ietf.org/html/rfc7301" rel="noopener" target="_blank">ALPN</a> allow clients to specify the application-level protocol they expect to communicate with, potentially allowing the target application server (like SMTP) to reject the redirected connection. This requires application servers not to ignore ALPN, which they frequently do.</li>
</ul>
<h4>Takeaways</h4>
<ul>
<li>Despite being known and well understood for years, cross-protocol attacks are still possible today! Even worse, trivial scans reveal hundreds of thousands of exploitable application servers running on shared HTTPS, making the bar for exploitation very low.</li>
<li>This space is not fully explored: application protocols like SMTP and FTP are obvious targets because of their similarity to HTTP, but newer protocols are also showing up in internet services such as VPN protocols and DTLS.</li>
</ul>
<h3>“Secure in isolation, vulnerable when composed”: ElGamal in OpenPGP</h3>
<p>The presenters of <strong>“On the (in)security of ElGamal in OpenPGP”</strong> (<a href="https://iacr.org/submit/files/slides/2022/rwc/rwc2022/76/slides.pdf" rel="noopener" target="_blank">slides</a>, <a href="https://youtu.be/9Citd5IT9hU?t=1023" rel="noopener" target="_blank">video</a>, <a href="https://eprint.iacr.org/2021/923.pdf" rel="noopener" target="_blank">paper</a>) covered another LANGSEC-adjacent problem: standards or protocols that are <strong>secure in isolation</strong> but <strong>insecure when interoperating</strong>.</p>
<p>The presenters considered <a href="https://en.wikipedia.org/wiki/ElGamal_encryption" rel="noopener" target="_blank">ElGamal</a> in implementations of OpenPGP (<a href="https://datatracker.ietf.org/doc/html/rfc4880" rel="noopener" target="_blank">RFC 4880</a>) due to its (ahem) <em>unique</em> status among asymmetric schemes required by OpenPGP:</p>
<ul>
<li>Unlike RSA (PKCS#1) and ECDH (<a href="https://datatracker.ietf.org/doc/html/rfc6637" rel="noopener" target="_blank">RFC 6637</a>), ElGamal has no formal or official specification!</li>
<li>The two “official” references for ElGamal are the <a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=1057074" rel="noopener" target="_blank">original paper itself</a> and the 1997 edition of the <em>Handbook of Applied Cryptography</em>, which <strong>disagree</strong> on parameter selection techniques! The OpenPGP RFC cites both; the presenters concluded that the RFC intends for the original paper to be authoritative.</li>
</ul>
<p>(By the way, did you know that this is <em>still</em> a common problem for cryptographic protocols, including zero-knowledge, MPC, and threshold schemes? If that sounds scary (it is) and like something you’d like to avoid (it is), you should check out <a href="https://www.zkdocs.com/" rel="noopener" target="_blank">ZKDocs</a>! We’ve done the hard work of understanding best practices for protocol and scheme design in the zero-knowledge ecosystem so that you don’t have to.)</p>
<p>The presenters evaluated three implementations of PGP that support ElGamal key generation (<a href="https://gnupg.org/" rel="noopener" target="_blank">GnuPG</a>, <a href="https://botan.randombit.net/" rel="noopener" target="_blank">Botan</a>, and <a href="https://www.cryptopp.com/wiki/Linux" rel="noopener" target="_blank"><code>libcrypto++</code></a>) and found that <strong>none obey RFC 4880</strong> with regard to parameter selection: all three use different approaches to prime generation.</p>
<p>But that’s merely the beginning: many OpenPGP implementations are proprietary or subject to long-term changes, making it difficult to evaluate real-world deviation from the standard just from open-source codebases. To get a sense for the real world, the presenters surveyed over 800,000 real-world ElGamal keys and found that:</p>
<ul>
<li>The majority of keys appear to be generated using a “safe primes” technique.</li>
<li>A large minority appear to be using <a href="http://citeseerx.ist.psu.edu/viewdoc/download?rep=rep1&amp;type=pdf&amp;doi=10.1.1.44.5296" rel="noopener" target="_blank">Lim-Lee primes</a>.</li>
<li>A much smaller minority appear to be using Schnorr or similar primes.</li>
<li>Just 5% appear to be using “quasi-safe” primes, likely indicating an intent to be compliant with RFC 4880’s prime generation requirements.</li>
</ul>
<p>Each of these prime generation techniques is (probably) <strong>secure in isolation…but not when composed</strong>: each of Go, GnuPG, and <code>libcrypto++</code>’s implementations of encryption against an ElGamal public key were vulnerable to side-channel attacks enabling plaintext recovery because of the unexpected prime generation techniques used for ElGamal keys in the wild.</p>
<p>The bottom line: of the roughly 800,000 keys surveyed, approximately 2,000 were vulnerable to practical plaintext recovery because of the “short exponent” optimization used to generate them. To verify the feasibility of their attack, the presenters successfully recovered an encrypted message’s plaintext after about 2.5 hours of side-channel analysis of GPG performing encryptions.</p>
<h4>Takeaways</h4>
<ul>
<li>ElGamal is an old, well-understood cryptosystem, one whose parameters and security properties are straightforward <em>on paper</em> (<a href="https://blog.trailofbits.com/2019/07/08/fuck-rsa/" rel="noopener" target="_blank">much like RSA</a>) but is subject to significant ambiguity and diversity in real-world implementations. Standards matter for security, and ElGamal needs a real one!</li>
<li>Cryptosystem security is pernicious: it’s not enough to be aware of potential side channels via your own inputs; signing and encryption schemes must <em>also</em> be resistant to poorly (or even just unusually) generated keys, certificates, etc.</li>
</ul>
<h2>Honorable mentions</h2>
<p>There were a <em>lot</em> of really great talks at this year’s RWC—too many to highlight in a single blog post. Some others that we really liked include:</p>
<ul>
<li><strong>“Zero-Knowledge Middleboxes”</strong> (<a href="https://datatracker.ietf.org/meeting/112/materials/slides-112-tls-zero-knowledge-proofs-meet-tls-01" rel="noopener" target="_blank">slides</a>, <a href="https://youtu.be/zwIl8pqiZeA?t=1244" rel="noopener" target="_blank">video</a>, <a href="https://eprint.iacr.org/2021/1022.pdf" rel="noopener" target="_blank">paper</a>): Companies currently rely on TLS <a href="https://en.wikipedia.org/wiki/Middlebox" rel="noopener" target="_blank">middleboxes</a> (and other network management techniques, like DNS filtering) to enforce corporate data and security policies. Middleboxes are powerful tools, ones that are subject to privacy abuses (and subsequent user circumvention by savvy users, undermining their efficacy). This talk offers an interesting (albeit still experimental) solution: use a middlebox to verify a zero-knowledge proof of <em>policy compliance</em>, without actually decrypting (and, therefore, compromising) any TLS sessions! The key result of this solution is compliance with a DNS policy without compromising a user’s DNS-over-TLS session, with an overhead of approximately five milliseconds per verification (corresponding to one DNS lookup).</li>
<li><strong>“Commit Acts of Steganography Before It’s Too Late”</strong> (<a href="https://cs-people.bu.edu/kaptchuk/talks/RWC22.pdf" rel="noopener" target="_blank">slides</a>, <a href="https://youtu.be/6Gb0xO8csVU?t=54" rel="noopener" target="_blank">video</a>): <a href="https://en.wikipedia.org/wiki/Steganography" rel="noopener" target="_blank">Steganography</a> is the ugly duckling of the cryptographic/cryptanalytic world, with research on steganography and steganalysis having largely dried up. Kaptchuk argues that this decline in interest is unwarranted and that steganography will play an important role in <em>deniable</em> communication with and within repressive states. To this end, the talk proposes <a href="https://meteorfrom.space/" rel="noopener" target="_blank">Meteor</a>, a cryptographically secure steganographic scheme that uses a <em>generative language model</em> to hide messages within plausible-looking human-language sentences.</li>
</ul>
<p>See you in 2023!</p>
			</div><!-- .entry-content -->

	
</article></div>
  </body>
</html>
