<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.righto.com/2023/04/reverse-engineering-8086-divide-microcode.html">Original</a>
    <h1>Reverse-engineering the division microcode in the Intel 8086 processor</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-5693917346966509204" itemprop="description articleBody">



<p>While programmers today take division for granted, most microprocessors in the 1970s could only add and subtract — division required a slow and tedious loop implemented in assembly code.
One of the nice features of the Intel 8086 processor (1978) was
that it provided machine instructions for integer multiplication and division.
Internally, the 8086 still performed a loop, but the loop was implemented in microcode: faster and transparent to
the programmer.
Even so, division was a slow operation, about 50 times slower than addition.</p>
<p>I recently examined <a href="https://www.righto.com/2023/03/8086-multiplication-microcode.html">multiplication in the 8086</a>, and
now it&#39;s time to look at the division microcode.<span id="fnref:microcode"><a href="#fn:microcode">1</a></span>
(There&#39;s a lot of overlap with the multiplication post so apologies for any deja vu.)
The die photo below shows the chip under a microscope.
I&#39;ve labeled the key functional blocks; the ones that are important to this post are darker.
At the left, the ALU (Arithmetic/Logic Unit) performs the arithmetic operations at the heart of division: subtraction and shifts.
Division also uses a few special hardware features: the X register, the F1 flag, and a loop counter.
The microcode ROM at the lower right controls the process.</p>
<p><a href="https://static.righto.com/images/8086-div/die-labeled.jpg"><img alt="The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip with the metal and polysilicon removed, revealing the silicon underneath. Click on this image (or any other) for a larger version." height="592" src="https://static.righto.com/images/8086-div/die-labeled-w600.jpg" title="The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip with the metal and polysilicon removed, revealing the silicon underneath. Click on this image (or any other) for a larger version." width="600"/></a></p><p>The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip with the metal and polysilicon removed, revealing the silicon underneath. Click on this image (or any other) for a larger version.</p>
<h2>Microcode</h2>
<p>Like most instructions, the division routines in the 8086 are implemented in microcode.
Most people think of machine instructions as the basic steps that a computer performs.
However, many processors have another layer of software underneath: microcode.
With microcode, instead of building the CPU&#39;s control circuitry from complex logic gates, the control logic is largely replaced with code.
To execute a machine instruction, the computer internally executes several simpler micro-instructions, specified by the microcode.
This is especially useful for a machine instruction such as division, which performs many steps in a loop.</p>
<!--
The 8086 uses a hybrid approach: although it uses microcode, much of the instruction functionality is implemented with gate logic.
This approach removed duplication from the microcode and kept the microcode small enough for 1978 technology.
In a sense, the microcode is parameterized.
For instance, the microcode can specify a generic Arithmetic/Logic Unit (ALU) operation and a generic register.
The gate logic examines the instruction to determine which specific operation to perform and the appropriate register.
-->

<p>Each micro-instruction in the 8086 is encoded into 21 bits as shown below.
Every micro-instruction moves data from a source register to a destination register, each specified with 5 bits.
The meaning of the remaining bits depends on the type field and can be anything from an ALU operation to a memory read or write to
a change of microcode control flow.
Thus, an 8086 micro-instruction typically does two things in parallel: the move and the action.
For more about 8086 microcode, see my <a href="https://www.righto.com/2022/11/how-8086-processors-microcode-engine.html">microcode blog post</a>.</p>
<p><a href="https://static.righto.com/images/8086-div/microcode-format.jpg"><img alt="The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?" height="203" src="https://static.righto.com/images/8086-div/microcode-format-w700.jpg" title="The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?" width="700"/></a></p>
<p>A few details of the ALU (Arithmetic/Logic Unit) operations are necessary to understand the division microcode.
The ALU has three temporary registers that are invisible to the programmer: tmpA, tmpB, and tmpC.
An ALU operation takes its first argument from the specified temporary register, while the second argument always comes from tmpB.
An ALU operation requires two micro-instructions.
The first micro-instruction specifies the ALU operation and source register, configuring the ALU. For instance, <code>ADD tmpA</code> to add tmpA to the default tmpB.
In the next micro-instruction (or a later one), the ALU result can be accessed through a register called <code>Σ</code> (Sigma) and moved to another register.</p>
<p>The carry flag plays a key role in division.
The carry flag is one of the programmer-visible status flags that is set by arithmetic operations, but it is also used
by the microcode.
For unsigned addition, the carry flag is set if there is a carry out of the word (or byte).
For subtraction, the carry flag indicates a borrow, and is set if the subtraction requires a borrow.
Since a borrow results if you subtract a larger number from a smaller number, the carry flag also indicates
the &#34;less than&#34; condition.
The carry flag (and other status flags) are only updated if micro-instruction contains the <code>F</code> bit.</p>
<p>The <code>RCL</code> (Rotate through Carry, Left) micro-instruction is heavily used in the division microcode.<span id="fnref:rcl"><a href="#fn:rcl">2</a></span>
This operation shifts the bits in a 16-bit word, similar to the <code>&lt;&lt;</code> bit-shift operation in high-level languages, but with an additional feature.
Instead of discarding the bit on the end, that bit is moved into the carry flag. Meanwhile, the bit formerly in the carry flag moves into the word.
You can think of this as rotating the bits while treating the carry flag as a 17th bit of the word.
(The <code>RCL</code> operation can also act on a byte.)</p>
<p><a href="https://static.righto.com/images/8086-div/lrcy.jpg"><img alt="The rotate through carry left micro-instruction." height="51" src="https://static.righto.com/images/8086-div/lrcy-w300.jpg" title="The rotate through carry left micro-instruction." width="300"/></a></p><p>The rotate through carry left micro-instruction.</p>
<p>These shifts perform an important part of the division process since shifting can be viewed as multiplying or dividing by two.
<code>RCL</code> also provides a convenient way to move the most-significant bit to the carry flag, where it can be tested for a conditional jump.
(This is important because the top bit is used as the sign bit.)
Another important property is that performing <code>RCL</code> on a lower word and then <code>RCL</code> on an upper word will perform a 32-bit shift, since
the high bit of the lower word will be moved into the low bit of the upper word via the carry bit.
Finally, the shift moves the quotient bit from the carry into the register.</p>
<h2>Binary division</h2>
<p>The division process in the 8086 is similar to grade-school long division, except in binary instead of decimal.
The diagram below shows the process: dividing 67 (the dividend) by 9 (the divisor) yields the quotient 7 at the top and the remainder 4 at the bottom.
Long division is easier in binary than decimal because you don&#39;t need to guess the right quotient digit.
Instead, at each step you either subtract the divisor (appropriately shifted)
or subtract nothing.
Note that although the divisor is 4 bits in this example, the subtractions use 5-bit values.
The need for an &#34;extra&#34; bit in division will be important in the discussion below; 16-bit division needs a 17-bit value.</p>

<table>

<tbody><tr><td colspan="8"> </td><td>0</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>
<tr><td colspan="4"> </td><td>-</td><td>0</td><td>0</td><td>0</td><td>0</td>
</tr><tr><td colspan="5"> </td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td colspan="5"> </td><td>-</td><td>1</td><td>0</td><td>0</td><td>1</td>
</tr><tr><td colspan="6"> </td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td colspan="6"> </td><td>-</td><td>1</td><td>0</td><td>0</td><td>1</td>
</tr><tr><td colspan="7"> </td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td></tr>
<tr><td colspan="7"> </td><td>-</td><td>1</td><td>0</td><td>0</td><td>1</td>
</tr><tr><td colspan="8"> </td><td>0</td><td>1</td><td>0</td><td>0</td></tr>
</tbody></table>

<p>Instead of shifting the divisor to the right each step, the 8086&#39;s algorithm shifts the quotient and the current dividend
to the left each step.
This trick reduces the register space required.
Dividing a 32-bit number (the dividend) by a 16-bit number yields a 16-bit result, so it seems like you&#39;d need four 16-bit registers in
total.
The trick is that after each step, the 32-bit dividend gets one bit smaller, while the result gets one bit larger.
Thus, the dividend and the result can be packed together into 32 bits. At the end, what&#39;s left of the dividend is
the 16-bit remainder. The table below illustrates this process for a sample dividend (blue) and quotient (green).<span id="fnref:table"><a href="#fn:table">3</a></span>
At the end, the 16-bit blue value is the remainder.</p>


<table>

<tbody><tr><th colspan="16">dividend</th><th colspan="16">quotient</th></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>
</tbody></table>
<h2>The division microcode</h2>
<p>The 8086 has four division instructions to handle signed and unsigned division of byte and word operands.
I&#39;ll start by describing the microcode for the unsigned word division instruction <code>DIV</code>, which divides a 32-bit dividend by a 16-bit divisor.
The dividend is supplied in the AX and DX registers while the divisor is specified by the source operand.
The 16-bit quotient is returned in AX and the 16-bit remainder in DX.
For a divide-by-zero, or if the quotient is larger than 16 bits, a type 0 &#34;divide error&#34; interrupt is generated.</p>
<h3><code>CORD</code>: The core division routine</h3>
<p>The <code>CORD</code> microcode subroutine below implements the long-division algorithm for all division instructions; I think <code>CORD</code> stands for Core Divide.
At entry, the arguments are in the ALU temporary registers:
tmpA/tmpC hold the 32-bit dividend, while tmpB holds the 16-bit divisor.
(I&#39;ll explain the configuration for byte division later.)
Each cycle of the loop shifts the values and then potentially subtracts the divisor.
One bit is appended to the quotient to indicate whether the
divisor was subtracted or not.
At the end of the loop, whatever is left of the dividend is the remainder.</p>
<p>Each micro-instruction specifies a register move on the left, and an action on the right.
The moves transfer words between the visible registers and the ALU&#39;s temporary registers, while the actions are mostly ALU operations or control flow.
As is usually the case with microcode, the details are tricky.
The first three lines below check if the division will overflow or divide by zero.
The code compares tmpA and tmpB by subtracting tmpB, discarding the result, but setting the status flags (<code>F</code>).
If the upper word of the divisor is greater or equal to the dividend, the division will overflow, so execution jumps to <code>INT0</code> to generate
a divide-by-zero interrupt.<span id="fnref:interrupts"><a href="#fn:interrupts">4</a></span> (This handles both the case where the dividend is &#34;too large&#34; and the divide-by-0 case.)
The number of loops in the division algorithm is controlled by a special-purpose loop counter.
The <code>MAXC</code> micro-instruction initializes the counter to 7 or 15, for a byte or word divide instruction respectively.</p>
<pre>   move        action
             SUBT tmpA   <span><b>CORD:</b> set up compare</span>
Σ → no dest  MAXC F       <span>compare, set up counter, update flags</span>
             JMP NCY INT0 <span>generate interrupt if overflow</span>
             RCL tmpC    <span><b>3:</b> main loop: left shift tmpA/tmpC</span>
Σ → tmpC     RCL tmpA     <span></span>
Σ → tmpA     SUBT tmpA    <span>set up compare/subtract</span>
             JMPS CY 13   <span>jump if top bit of tmpA was set</span>
Σ → no dest  F            <span>compare, update flags</span>
             JMPS NCY 14  <span>jump for subtract</span>
             JMPS NCZ 3   <span>test counter, loop back to 3</span>
             RCL tmpC    <span><b>10:</b> done:</span>
Σ → tmpC                  <span>shift last bit into tmpC</span>
Σ → no dest  RTN          <span>done: get top bit, return</span>

             RCY         <span><b>13:</b> reset carry</span>
Σ → tmpA     JMPS NCZ 3  <span><b>14:</b> subtract, loop</span>
             JMPS 10     <span>done, goto 10</span>
</pre>

<p>The main loop starts at <em>3</em>.
The tmpC and tmpA registers are shifted left. This has two important side effects. First, the old carry bit (which holds the latest
quotient bit) is shifted into the bottom of tmpC. Second, the top bit of tmpA is shifted into the carry bit;
this provides the necessary &#34;extra&#34; bit for the subtraction below.
Specifically, if the carry (the &#34;extra&#34; tmpA bit) is set, tmpB can be subtracted, which is accomplished by jumping to <em>13</em>.
Otherwise, the code compares tmpA and tmpB by
subtracting tmpB, discarding the result, and updating the flags (<code>F</code>).
If there was no borrow/carry (tmpA ≥ tmpB), execution jumps to <em>14</em> to subtract.
Otherwise, the internal loop counter is decremented and control flow goes back to the top of the loop if not done
(<code>NCZ</code>, Not Counter Zero).
If the loop is done, tmpC is rotated left to pick up the last quotient bit from the carry flag.
Then a second rotate of tmpC is performed but the result is discarded; this puts the top bit of tmpC into the carry flag for
use later in <code>POSTIDIV</code>. Finally, the subroutine returns.</p>
<p>The subtraction path is <em>13</em> and <em>14</em>, which subtract tmpB from tmpA by storing the result (Σ) in tmpA.
This path resets the carry flag for use as the quotient bit.
As in the other path, the loop counter is decremented and tested (<code>NCZ</code>) and execution either continues back at <em>3</em>
or finishes at <em>10</em>.</p>
<p>One complication is that the carry bit is the opposite of the desired quotient bit. 
Specifically, if tmpA &lt; tmpB, the comparison generates a borrow so the carry flag is set to 1.
In this case, the desired quotient bit is 0 and no subtraction takes place.
But if tmpA ≥ tmpB, the comparison does not generate a borrow (so the carry flag is set to 0), the code subtracts tmpB,
and the desired quotient bit is 1.
Thus, tmpC ends up holding the <em>complement</em> of the desired result; this is fixed later.</p>
<p>The microcode is carefully designed to pack the divide loop into a small number of micro-instructions.
It uses the registers and the carry flag in tricky ways, using the carry flag to hold the top bit of tmpA,
the comparison result, and the generated quotient bit.
This makes the code impressively dense but tricky to understand.</p>
<h3>The top-level division microcode</h3>
<p>Now I&#39;ll pop up a level and take a look at the top-level microcode (below) that implements the <code>DIV</code> and <code>IDIV</code> machine instructions.
The first three instructions load tmpA, tmpC, and tmpB from the specified registers.
(The <code>M</code> register refers to the source specified in the instruction, either a register or a memory location.)
Next, the <code>X0</code> condition tests bit 3 of the instruction, which in this case distinguishes <code>DIV</code> from <code>IDIV</code>.
For signed division (<code>IDIV</code>), the microcode calls <code>PREIDIV</code>, which I&#39;ll discuss below.
Next, the <code>CORD</code> micro-subroutine discussed above is called to perform the division.</p>
<pre>DX → tmpA                      <span><b>iDIV rmw:</b> load tmpA, tmpC, tmpB </span>
AX → tmpC    RCL tmpA           <span>set up RCL left shift operation</span>
M → tmpB     CALL X0 PREIDIV    <span>set up integer division if IDIV</span>
             CALL CORD          <span>call CORD to perform division </span>
             COM1 tmpC          <span>set up to complement the quotient </span>
DX → tmpB    CALL X0 POSTIDIV   <span>get original dividend, handle IDIV</span>
Σ → AX       NXT                <span>store updated quotient</span>
tmpA → DX    RNI                <span>store remainder, run next instruction</span>
</pre>

<p>As discussed above, the quotient in tmpC needs to be 1&#39;s-complemented, which is done with <code>COM1</code>.
For <code>IDIV</code>, the micro-subroutine <code>POSTIDIV</code> sets the signs of the results appropriately.
The results are stored in the <code>AX</code> and <code>DX</code> registers.
The <code>NXT</code> micro-operation indicates the next micro-instruction is the last one, directing the microcode engine to
start the next
machine instruction. Finally, <code>RNI</code> directs the microcode engine to run the next machine instruction.</p>
<h2>8-bit division</h2>
<p>The 8086 has separate opcodes for 8-bit division.
The 8086 supports many instructions with byte and word versions, using 8-bit or 16-bit arguments respectively.
In most cases, the byte and word instructions use the same microcode, with the ALU and register hardware using bytes or words based on the instruction.
In the case of division,
the shift micro-operations act on tmpA and tmpC as 8-bit registers rather than 16-bit registers.
Moreover, the <code>MAXC</code> micro-operation initializes the internal counter to 7 rather than 15.
Thus, the same <code>CORD</code> microcode is used for word and byte division, but the number of loops and the specific
operations are changed by the hardware.</p>
<p>The diagram below shows the tmpA and tmpC registers during each step of dividing 0x2345 by 0x34.
Note that the registers are treated as 8-bit registers.
The divisor (blue) steadily shrinks with the quotient (green) taking its place.
At the end, the remainder is 0x41 (blue) and the quotient is 0xad, complement of the green value.</p>
<table>
<tbody><tr><th colspan="16">tmpA</th><th colspan="16">tmpC</th></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>
</tbody></table>

<p>Although the <code>CORD</code> routine is shared for byte and word division, the top-level microcode is different.
In particular, the byte and word division instructions use different registers, requiring microcode changes.
The microcode below is the top-level code for byte division. It is almost the same as the microcode above, except it
uses the top and bottom bytes of the accumulator (<code>AH</code> and <code>AL</code>) rather than the <code>AX</code> and <code>DX</code> registers.</p>
<pre>AH → tmpA                     <span><b>iDIV rmb:</b> get arguments</span>
AL → tmpC    RCL tmpA          <span>set up RCL left shift operation</span>
M → tmpB     CALL X0 PREIDIV   <span>handle signed division if IDIV</span>
             CALL CORD         <span>call CORD to perform division</span>
             COM1 tmpC         <span>complement the quotient</span>
AH → tmpB    CALL X0 POSTIDIV  <span>handle signed division if IDIV</span>
Σ → AL       NXT               <span>store quotient</span>
tmpA → AH    RNI               <span>store remainder, run next instruction</span>
</pre>

<h2>Signed division</h2>
<p>The 8086 (like most computers) represents signed numbers using a format called two&#39;s complement.
While a regular byte holds a number from 0 to 255, a signed byte holds a number from -128 to 127.
A negative number is formed by flipping all the bits (known as the one&#39;s complement) and then adding 1, yielding the two&#39;s complement value.
For instance, +5 is <code>0x05</code> while -5 is <code>0xfb</code>.
(Note that the top bit of a number is set for a negative number; this is the sign bit.)
The nice thing about two&#39;s complement numbers is that the same addition and subtraction operations work on both signed and unsigned values.
Unfortunately, this is not the case for signed multiplication and division.</p>
<p>The 8086 has separate <code>IDIV</code> (Integer Divide) instructions to perform signed division.
The 8086 performs signed division by converting the arguments to positive values, performing unsigned division, and then
negating the results if necessary.
As shown earlier, signed and unsigned division both use the same top-level microcode and the microcode conditionally calls some subroutines for
signed division.
These additional subroutines cause a significant performance penalty, making signed division over 20 cycles slower than unsigned division.
I will discuss those micro-subroutines below.</p>
<h3><code>PREIDIV</code></h3>
<p>The first subroutine for signed division is <code>PREIDIV</code>, performing preliminary operations for integer division.
It converts the two arguments, stored in tmpA/tmpC and tmpB, to positive values.
It keeps track of the signs using an internal flag called <code>F1</code>, toggling this flag for each negative argument.
This conveniently handles the rule that two negatives make a positive since complementing the <code>F1</code> flag twice will clear it.
The point of this is that the main division code (<code>CORD</code>) only needs to handle unsigned division.</p>
<p>The microcode below implements <code>PREIDIV</code>.
First it tests if tmpA is negative, but
the 8086 does not have a microcode condition to directly test the sign of a value.
Instead, the microcode determines if a value is negative by shifting the value left, which moves the top (sign) bit into the carry flag.
The conditional jump (<code>NCY</code>) then tests if the carry is clear, jumping if the value is non-negative.
If tmpA is negative, execution falls through to negate the first argument.
This is tricky because the argument is split between the tmpA and tmpC registers.
The two&#39;s complement operation (<code>NEG</code>) is applied to the low word, while either 2&#39;s complement or one&#39;s complement (<code>COM1</code>) is applied to
the upper word, depending on the carry for mathematical reasons.<span id="fnref:neg"><a href="#fn:neg">5</a></span>
The <code>F1</code> flag is complemented to keep track of the sign.
(The multiplication process reuses most of this code, starting at the <code>NEGATE</code> entry point.)</p>
<pre>Σ → no dest             <span><b>PREIDIV:</b> shift tmpA left</span>
             JMPS NCY 7  <span>jump if non-negative</span>
             NEG tmpC   <span><b>NEGATE:</b> negate tmpC</span>
Σ → tmpC     COM1 tmpA F <span>maybe complement tmpA</span>
             JMPS CY 6  
             NEG tmpA    <span>negate tmpA if there&#39;s no carry</span>
Σ → tmpA     CF1        <span><b>6:</b> toggle F1 (sign)</span>

             RCL tmpB  <span><b>7:</b> test sign of tmpB</span>
Σ → no dest  NEG tmpB    <span>maybe negate tmpB</span>
             JMPS NCY 11 <span>skip if tmpB positive</span>
Σ → tmpB     CF1 RTN     <span>else negate tmpB, toggle F1 (sign)</span>
             RTN        <span><b>11:</b> return</span>
</pre>

<p>The next part of the code, starting at <em>7</em>, negates tmpB (the divisor) if it is negative. Since the divisor is a single
word, this code is simpler.
As before, the <code>F1</code> flag is toggled if tmpB is negative.
At the end, both arguments (tmpA/tmpC and tmpB) are positive, and <code>F1</code> indicates the sign of the result.</p>
<h3><code>POSTIDIV</code></h3>
<p>After computing the result, the <code>POSTIDIV</code> routine is called for signed division.
The routine first checks for a signed overflow and raises a divide-by-zero interrupt if so.
Next, the routine negates the quotient and remainder if necessary.<span id="fnref:signs"><a href="#fn:signs">6</a></span></p>
<p>In more detail, the <code>CORD</code> routine left the top bit of tmpC (the complemented quotient) in the carry flag.
Now, that bit is tested. If the carry bit is 0 (<code>NCY</code>), then the top bit of the quotient is 1 so the quotient is too big to fit in a signed value.<span id="fnref:overflow"><a href="#fn:overflow">7</a></span>
In this case, the <code>INT0</code> routine is executed to trigger a type 0 interrupt, indicating a divide overflow.
(This is a rather roundabout way of testing the quotient, relying on a carry bit that was set in a previous subroutine.)</p>
<pre>             JMP NCY INT0 <span><b>POSTIDIV:</b> if overflow, trigger interrupt</span>
             RCL tmpB      <span>set up rotate of tmpB</span>
Σ → no dest  NEG tmpA      <span>get sign of tmpB, set up negate of tmpA</span>
             JMPS NCY 5    <span>skip if tmpB non-negative</span>
Σ → tmpA                   <span>otherwise negate tmpA (remainder)</span>
             INC tmpC     <span><b>5:</b> set up increment</span>
             JMPS F1 8     <span>test sign flag, skip if set</span>
             COM1 tmpC     <span>otherwise set up complement</span>
             CCOF RTN     <span><b>8:</b> clear carry and overflow flags, return</span>
</pre>

<p>Next, tmpB (the divisor) is rotated to see if it is negative.
(The caller loaded tmpB with the original divisor, replacing the dividend that was in tmpB previously.)
If the divisor is negative, tmpA (the remainder) is negated.
This implements the 8086 rule that the sign of the remainder matches the sign of the divisor.</p>
<p>The quotient handling is a bit tricky. Recall that tmpC holds the complemented quotient.
the <code>F1</code> flag is set if the result should be negative. In that case, the complemented quotient needs to be incremented
by 1 (<code>INC</code>) to convert from 1&#39;s complement to 2&#39;s complement.
On the other hand, if the quotient should be positive, 1&#39;s-complementing tmpC (<code>COM1</code>) will yield the desired positive
quotient.
In either case, the ALU is configured in <code>POSTIDIV</code>, but the result will be stored back in the main routine.</p>
<p>Finally, the <code>CCOF</code> micro-operation clears the carry and overflow flags.
Curiously, the 8086 documentation declares that the status flags are undefined following <code>IDIV</code>, but the microcode
explicitly clears the carry and overflow flags.
I assume that the flags were cleared in analogy with <code>MUL</code>, but then Intel decided that this wasn&#39;t useful so they
didn&#39;t document it. (Documenting this feature would obligate them to provide the same functionality in later x86 chips.)</p>
<h2>The hardware for division</h2>
<p>For the most part, the 8086 uses the regular ALU addition and shifts for the division algorithm. Some special hardware
features provide assistance.
In this section, I&#39;ll look at this hardware.</p>
<h3>Loop counter</h3>
<p>The 8086 has a 4-bit loop counter for multiplication and division. This counter starts at 7 for byte division and 15 for word division,
based on the low bit of the opcode.
This loop counter allows the microcode to decrement the counter, test for the end, and perform a conditional branch in one micro-operation.
The counter is implemented with four flip-flops, along with logic to compute the value after decrementing by one.
The <code>MAXC</code> (Maximum Count) micro-instruction sets the counter to 7 or 15 for byte or word operations respectively.
The <code>NCZ</code> (Not Counter Zero) micro-instruction has two actions. First, it performs a conditional jump if the counter is nonzero.
Second, it decrements the counter.</p>
<h3>The F1 flag</h3>
<p>Signed multiplication and division use an internal flag called <code>F1</code><span id="fnref:f1"><a href="#fn:f1">8</a></span> to keep track of the sign.
The <code>F1</code> flag is toggled by microcode through the <code>CF1</code> (Complement F1) micro-instruction.
The <code>F1</code> flag is implemented with a flip-flop, along with a multiplexer to select the value. It is cleared when a new instruction starts,
set by a <code>REP</code> prefix, and toggled by the <code>CF1</code> micro-instruction.
The diagram below shows how the F1 latch and the loop counter appear on the die. In this image, the metal layer has been removed, showing the
silicon and the polysilicon wiring underneath.</p>
<p><a href="https://static.righto.com/images/8086-div/counter.jpg"><img alt="The counter and F1 latch as they appear on the die. The latch for the REP state is also here." height="308" src="https://static.righto.com/images/8086-div/counter-w600.jpg" title="The counter and F1 latch as they appear on the die. The latch for the REP state is also here." width="600"/></a></p><p>The counter and F1 latch as they appear on the die. The latch for the REP state is also here.</p>
<h3>X register</h3>
<p>The division microcode uses an internal register called the <code>X</code> register to distinguish between the <code>DIV</code> and <code>IDIV</code> instructions.
The <code>X</code> register is a 3-bit register that holds the ALU opcode, indicated by bits 5–3 of the instruction.<span id="fnref:x-reg"><a href="#fn:x-reg">9</a></span>
Since the instruction is held in the Instruction Register, you might wonder why a separate register is required.
The motivation is that some opcodes specify the type of ALU operation in the second byte of the instruction, the ModR/M byte, bits 5–3.<span id="fnref:opcode"><a href="#fn:opcode">10</a></span>
Since the ALU operation is sometimes specified in the first byte and sometimes in the second byte, the <code>X</code> register was added to handle
both these cases.</p>
<p>For the most part, the <code>X</code> register indicates which of the eight standard ALU operations is selected (<code>ADD</code>, <code>OR</code>, <code>ADC</code>, <code>SBB</code>, <code>AND</code>, <code>SUB</code>, <code>XOR</code>, <code>CMP</code>). 
However, a few instructions use bit 0 of the <code>X</code> register to distinguish between other pairs of instructions.
For instance, it distinguishes between <code>MUL</code> and <code>IMUL</code>, <code>DIV</code> and <code>IDIV</code>, <code>CMPS</code> and <code>SCAS</code>, <code>MOVS</code> and <code>LODS</code>, or <code>AAA</code> and <code>AAS</code>.
While these instruction pairs may appear to have arbitrary opcodes, they have been carefully assigned
so the microcode can distinguish them.</p>
<p>The implementation of the <code>X</code> register is straightforward, consisting of three flip-flops to hold the three bits of the instruction.
The flip-flops are loaded from the prefetch queue bus during First Clock and during Second Clock for appropriate instructions, as the
instruction bytes travel over the bus.
Testing bit 0 of the <code>X</code> register with the <code>X0</code> condition is supported by the microcode condition evaluation circuitry, so it can be used for conditional jumps in the microcode.</p>
<h2>Algorithmic and historical context</h2>
<p>As you can see from the microcode, division is a complicated and relatively slow process.
On the 8086, division takes up to 184 clock cycles to perform all the microcode steps.
(In comparison, two registers can be added in 3 clock cycles.)
Multiplication and division both loop over the bits, performing repeated addition or subtraction respectively.
But division requires a decision (subtract or not?) at each step, making it even slower, about half the speed of multiplication.<span id="fnref:history"><a href="#fn:history">11</a></span></p>
<p>Various algorithms have been developed to speed up division.
Rather than performing long division one bit at a time, you can do long division in, say, base 4, producing two quotient
bits in each step.
As with decimal long division, the tricky part is figuring out what digit to select. The <a href="https://en.wikipedia.org/wiki/Division_algorithm#SRT_division">SRT algorithm</a> (1957) uses a small
lookup table to estimate the quotient digit from a few bits of the divisor and dividend.
The clever part is that the selected digit doesn&#39;t need to be exactly right at each step; the algorithm will self-correct
after a wrong &#34;guess&#34;.
The Pentium processor (1993) famously had a <a href="https://math.mit.edu/~edelman/homepage/papers/pentiumbug.pdf">floating point division bug</a>
due to a few missing values in the SRT table. This bug cost Intel $475 million to replace the faulty processors.</p>
<p>Intel&#39;s x86 processors steadily improved divide performance. The 80286 (1982) performed a word divide in 22 clocks, about
6 times as fast as the 8086.
In the <a href="https://www.cubawiki.com.ar/images/b/b3/Orga2_paper_penyn.pdf">Penryn</a> architecture (2007), Intel upgraded from
Radix-4 to Radix-16 division.
Rather than having separate integer and floating-point hardware, integer divides were handled through the floating point divider.
Although modern Intel processors have greatly improved multiplication and division compared to the 8086, division is still a relatively slow operation.
While a Tiger Lake (2020) processor can perform an integer multiplication every clock cycle (with a latency of 3 cycles),
division is much slower and can only be done once every 6-10 clock cycles (<a href="https://agner.org/optimize/">details</a>).</p>
<p>I&#39;ve written numerous <a href="https://www.righto.com/search/label/8086">posts on the 8086</a> so far and
plan to continue reverse-engineering the 8086 die so
follow me on Twitter <a href="https://twitter.com/kenshirriff">@kenshirriff</a> or <a href="https://www.righto.com/feeds/posts/default">RSS</a> for updates.
I&#39;ve also started experimenting with Mastodon recently as <a href="https://oldbytes.space/@kenshirriff">@<span data-cfemail="f59e909b869d9c87879c9393b59a9991978c819086db8685949690">[email protected]</span></a>.</p>
<h2>Notes and references</h2>


</div></div>
  </body>
</html>
