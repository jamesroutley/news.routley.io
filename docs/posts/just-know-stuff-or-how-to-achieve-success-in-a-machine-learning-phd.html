<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kidger.site/thoughts/just-know-stuff/">Original</a>
    <h1>Just know stuff. (Or, how to achieve success in a machine learning PhD)</h1>
    
    <div id="readability-page-1" class="page"><div><section class="page"><article><header><em><a href="https://kidger.site/thoughts/">&lt; Back to &#34;Thoughts&#34;</a></em> | <em>Posted on January 26, 2023</em></header><h2 id="introduction">Introduction</h2><p>So I recently completed my PhD in Mathematics from the University of Oxford. (Hurrah! It was so much fun.)</p><p>In 2-and-a-bit years I wrote 12 papers, received 4139 GitHub stars, got 3271 Twitter followers, authored 1 textbook – doing double-duty as my thesis – and got the coveted big-tech job-offer.</p><div><p><span></span>On Neural Differential Equations</p><p>If you’re interested in a textbook on Neural Differential Equations with a smattering of scientific computing, then <a href="https://arxiv.org/abs/2202.02435">my thesis is available online.</a></p></div><p>Quite a few folks seem to have looked at this, and messaged me – mostly on <a href="https://twitter.com/PatrickKidger">Twitter</a> or <a href="https://fosstodon.org/@PatrickKidger">Mastodon</a> – asking for advice on <strong>how to achieve success in a machine learning PhD?</strong></p><p>Each time my answer is: <strong>Just Know Stuff.</strong></p><p>Now, I don’t think “Just Know Stuff” is a terribly controversial opinion – undergraduate classes are largely based around imparting knowledge; the first year of a new PhD’s life is usually spent reading up on the literature – but from the number of questions I get it would seem that this is something worth restating.</p><p>Know your field inside-out. Know as much about adjacent fields (in math, statistics, …) as you can. Don’t just know how to program; know how to do software development. Know the mathematical underpinnings your work is built upon. And so on and so on. Indeed: <a href="https://kidger.site/thoughts/how-to-handle-a-hands-off-supervisor">possessing a technical depth of knowledge is how you come up with new ideas and learn to recognise bad ones</a>.</p><p>This does beg the follow-up question: <strong>what is worth knowing? What is worth learning?</strong></p><p>And the answer to <em>that</em> is what I started repeating to all of you folks messaging me. But then that started taking up way too much time, mostly because I write way too much. So now I’m writing this post instead – this way I’ll only have to write way too much only once!</p><p>The following is a highly personal list of the things I found to be useful during my PhD, and which I think are of a broad enough appeal that they probably represent a reasonable core of knowledge for those just starting an ML PhD. The following is by no mean exhaustive, and you should certainly expect to add a lot of domain-specific stuff on top of this. But perhaps the following is a useful starting point.</p><p><em>This list is targeted towards early-stage PhD or pre-PhD students. If you’re late-stage and reading through this thinking “yeah, of course I know this stuff”, then well… that’s the point!</em></p><h2 id="machine-learning">Machine learning</h2><ul><li>Know both forward- and reverse-mode autodifferentiation. (Nice reference: Appendix A of my thesis. ;) )<ul><li>Write some custom gradient operations in both PyTorch and JAX.</li><li>Look up “optimal Jacobian accumulation” on the autodifferentiation page on Wikipedia.</li><li>Optional: learn how JAX derives reverse-mode autoderivatives by combining partial evaluation, forward-mode-autodifferentiation, and transposition.</li><li>Optional: why is the computation of a divergence computationally expensive using autodifferentiation? Learn Hutchinson’s trace estimator. (Why is that efficient?) Learn the <a href="https://ram900.hosting.nyu.edu/hutchplusplus/">Hutch++ trace estimator</a>. (Which is surprisingly poorly known.)</li></ul></li><li>What is meant by Strassen’s algorithm? Learn how matrix multiplies are actually done in practice. Learn Winograd convolutions.</li><li>Write your own implementation of a convolutional layer. Write your own implementation of multihead attention.</li><li>Know the universal approximation theorem. (I recommend Leshno et al. 1993 or Pinkus 1999 as references. <em>Not</em> the much-more-frequently cited references to older results by Cybenko or Hornik, who give much weaker results.)<ul><li>Optional: if you’re really keen then look up the modern line of work on <a href="https://arxiv.org/abs/1905.08539">alternate universal approximation theorems</a>.</li></ul></li><li>Learn the basics of graph neural networks. (E.g. what is oversmoothing?) How do these generalise CNNs?</li><li>Learn modern Transformer architectures. Look up recent papers <a href="https://github.com/lucidrains">(or implementations)</a> to see some of the more common architectural tricks. Build a toy implementation.</li><li>Learn U-Nets. Build a toy implementation.</li><li>Know how residual networks are discretised ordinary differential equations.</li><li>know how Gated Recurrent Units (GRUs) are also discretised differential equations.</li><li>Know how stochastic gradient descent is also a discretised differential equation too! (Yes, including the “stochastic”: that’s a Monte-Carlo discretisation of an expectation.) These are <a href="https://francisbach.com/gradient-flows/">gradient flows</a>.</li><li>Know what is meant by the manifold hypothesis.</li><li>Learn the basics of policy gradients. Implement PPO to solve cart-pole. (<a href="https://spinningup.openai.com/en/latest/">Spinning up</a> is a great resource.)</li><li>Learn KL divergence, Wasserstein distance, MMD distance.</li><li>Learn normalising flows, VAEs, WGANs, score-based diffusion models. <a href="https://docs.kidger.site/equinox/examples/score_based_diffusion/">Implement a basic score-based diffusion from scratch.</a></li><li>Try the basics of distributed training of a model. (Over multiple GPUs; multiple computers.) Start with <code>jax.pmap</code>.</li><li>Know how to do hyperparameter optimisation via Bayesian optimisation. My favourite library for this is <a href="https://ax.dev">Ax</a>.<ul><li>Optional: try doing this in a distributed fashion, with a main thread sending hyperparameter jobs to different machines, and receiving results back. (The “Service API” for Ax is the appropriate tool here.)</li></ul></li><li>Learn the formulae for Adadelta, Adam, etc. What were the innovations for each optimiser? (Momentum, second moments, …) What are some of the newer ones that are now being used (Adabelief, RAdam, NAdamW, … etc. etc. – this is a flavour-of-the-month kind of field.)</li><li>Learn why we use first-order optimisation techniques (SGD and friends), rather than anything else. (Why not Gauss–Newton? Why not Newton–Raphson? Why not Levenberg–Marquardt?) On that note, let’s move on to…</li></ul><h2 id="elementary-scientific-computing">(Elementary) scientific computing</h2><ul><li>…start by learning all of those algorithms I just mentioned as well (they’re all nonlinear solvers).</li><li>Learn QR decompositions, LU decompositions, SVD decompositions, Cholesky decompositions.<ul><li>Solve linear systems via each of the above decompositions. (Recognise that this is better than inverting a matrix.) Learn the varying computational costs and stabilities of the different ways of doing this. (SVD -&gt; Cholesky-&gt; QR -&gt; LU.)</li><li>Reduce linear least squares to linear solves via the normal equations. Know that this squares the condition number. Recognise that this is the textbook approach to fitting a linear model.</li></ul></li><li>Learn what is meant by the <a href="https://en.m.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse">Moore–Penrose pseudoinverse</a> of a matrix.</li><li>Learn the basics of numerical differential equation solvers:<ul><li>Euler’s method</li><li>Heun’s method</li><li>Optional: Implicit Euler method. Know that it works provided <code>hL &lt; 1</code>, where <code>h</code> is the step size and <code>L</code> is the Lipschitz constant of the vector field. (Know the contraction mapping theorem.)</li><li>Optional: other diffeq solvers, e.g. explicit Runge–Kutta methods. <a href="https://docs.kidger.site/diffrax/usage/how-to-choose-a-solver/">This is a nice summary of when to use each.</a></li></ul></li><li>Know Monte-Carlo sampling. Know Quasi Monte-Carlo sampling. Know the convergence rates for both.</li><li>Learn what is meant by quadrature.</li><li>Learn Chebyshev polynomials.</li><li>Know the quirks of floating-point arithmetic: non-associativity, catastrophic cancellation, the impossibility of representing some integers, that you should not compare floats via equality, the meaning of numerical stability.<ul><li>This is the reason <code>expm1</code> and <code>logsumexp</code> exist as standalone functions.</li></ul></li><li>Optional: learn wavelets.</li><li>Optional: sparsity.<ul><li>The different kinds of sparse format (CSC, COO, …);</li><li>Sparse linear solvers (e.g. iterative/Krylov methods);</li><li>Linear preconditioners.</li></ul></li></ul><p>There’s (a lot) more scientific computing out there, but I’m writing for an ML audience here. The above is perhaps a minimum worth being conversant on.</p><h2 id="software-development">Software development.</h2><p><em>(Those of you deriving PAC-Bayes bounds, you might be able to skip this section. Unless you want an industry job post-PhD, that is.)</em></p><p>Academic software is almost always a poorly-maintained kludge of leaky abstractions, awful formatting, and bugs that don’t cripple things only because some other bug stops them from doing so.</p><p><em>This is a systemic professional failing.</em> As an (applied) ML researcher, the overwhelming majority of your time will be spent in front of a screen, staring at code. And yet most of you (yes, you) would not pass muster as a junior developer.</p><p>So, how to improve? First of all, never accept the kludge.</p><ul><li>You’ve messed up your Git repo? Figure out the commands to fix it… don’t just delete it and clone from the remote. (<a href="https://xkcd.com/1597">https://xkcd.com/1597</a>)</li><li>You’ve written messy code? Assuming you’re using Python: learn PEP8, pre-commit, Black, flake8, isort. (Or <a href="https://github.com/charliermarsh/ruff">ruff</a> if you’re ahead-of-the-curve.)<ul><li>Feel free to steal the configs from <a href="https://github.com/patrick-kidger/equinox">one of my repositories</a>.</li></ul></li><li>Your code is too slow? Learn a more performant language (C++, Rust, Triton) and write things there.</li><li>Focus on writing clean code, based around orthogonal abstractions. When the code starts getting messy – and it will – be willing to refactor your code into something more legible. Avoid both spaghetti code and ravioli code.</li></ul><p>And returning to the overall theme:</p><ul><li>Learn Python to an advanced enough level that you know what descriptors, weak references, and metaclasses are.<ul><li>Learn what closures are.</li></ul></li><li>Learn how to build your own Python package and push it to PyPI.</li><li>Learn both PyTorch and JAX.<ul><li>When the documentation is inadequate, look at their source code.</li><li>Optional: <a href="https://jax.readthedocs.io/en/latest/autodidax.html">reimplement JAX core transforms from scratch</a>.</li></ul></li><li>Learn some object oriented design patterns. At least as far as dependency inversion and factories.</li><li>Learn some C/C++.<ul><li>Pass-by-reference vs pass-by-copy. Pointers.</li><li>Write some bindings for using these from Python. (In ML, this is easiest using PyTorch+LibTorch+pybind11.)</li><li>Optional: learn some OpenMP.</li></ul></li><li>Learn some Julia. Understand why multiple dispatch is so cool, and how this helps build numerical programs. Write some macros and learn what is meant by homoiconicity.</li><li>Learn some Haskell. Learn functional programming. Learn some type theory. (Learn the difference between a sum type and a union type.) Learn what is meant by monads. Learn what is meant by referential transparency.<ul><li>Optional: look up Koka and learn what is meant by algebraic effects.</li><li>Optional: look up Idris or Liquid Haskell and learn what is meant by dependent types.</li></ul></li><li>Learn some Common Lisp or Scheme. Understand why its code is the same as its abstract syntax tree (AST). Write some macros and <em>really</em> understand homoiconicity.</li><li>What is meant by generic programming? What is meant by variadic generics? When are these helpful? (<a href="https://github.com/google/jaxtyping">Cough cough</a>.)</li><li>Learn big-O notation for computational complexity. Learn how a hash map is implemented. Look up how a Python dict is implemented. Look up the exponential memory allocation trick for continually appending to e.g. a Python list.</li><li>Know dynamic programming. (The classic example here is the Fibonacci numbers.) Learn to recognise when a problem can be solved this way. Recognise the equivalence between dynamic programming and caching (a la Python’s <code>functools.lru_cache</code>).</li><li>Have a read of programming blogs. (Personally, this is how I procrastinate from more serious work.)</li><li>Learn how to collaborate on code! Typically via GitHub-style pull-request workflows. We’re not going to hire you without evidence we can work with you.</li><li>Know how to write tests. Integrate them into a CI/CD system e.g. GitHub Actions. (Once again, feel free to <a href="https://github.com/patrick-kidger/diffrax/tree/main/.github/workflows/">steal from one of my repos</a>.)</li></ul><p>There’s loads more I could add here: learn some compiler theory (tail call optimisation, peephole optimisation, …). Learn distributed computing. Learn different database systems. Learn a bit about how a CPU works (L1/L2/L3 caches, CPU cycles, vectorisation, branch prediction, some basic assembly, etc.). Learn other programming languages (Nim, Zig, Dex, …) Learn when to use a few mildly nontrivial data structures (heaps, btrees, ropes, …)</p><p>You don’t need to become a serious software developer. (i.e. knowing all of the above list and substantially more.) Just don’t write code that makes my eyes bleed.</p><p>In nearly every respect I’d actually recommend against the university-taught courses for much of the above list. YMMV, but these are usually pretty poor. (Perhaps because they’re taught by academics… who, as already discussed, don’t usually know what they’re doing here. E.g. C++ courses that taught the <code>new</code> and <code>delete</code> operators as good practice…) Try the internet instead.</p><p>I recommend reading programming forums, YouTube videos from programming conferences, and programming blogs.</p><h2 id="mathematics">Mathematics</h2><ul><li>Some basics.<ul><li>Convex functions (recognise that this is a way to bound a nonlinear function by an easier-to-understand linear function).</li><li>Lipschitz functions (these have already appeared several times above: in WGANs, the implicit Euler method, the contraction mapping theorem).</li><li>The meaning of injectivity, surjectivity, bijectivity.</li></ul></li><li>Please, please: learn some probability via measure theory. You’ll start reading machine learning papers wondering how people ever express themselves precisely without it. The entire field seems to be predicated around writing things like $x \sim p_\theta(x|z=q_\phi(x))$ as if that’s somehow meaningful notation.</li><li>Likewise, learn integration through measure theory. At least as far as Fubini’s theorem, the Leibniz Integral Rule, and what is meant by absolute continuity of measures.<ul><li>Optional: If you’re keen then go as far as Radon–Nikodym derivatives. (Which appears in the definition of the KL divergence, for example.)</li><li>Optional: the meaning of almost-everywhere. Recognise that ReLU is almost-everywhere differentiable.</li><li>Optional: Alexandrov’s Theorem.</li></ul></li><li>Topology is a great topic to learn the basics of, as this underpins nearly all of modern mathematics: open sets, closed sets, compactness, continuous functions, etc.<ul><li>Optional: there’s some very enjoyable “counterexamples in topology” books out there, that will melt your brain into a variety of interesting shapes.</li></ul></li><li>Analysis. A topic close to my heart, as this was my primary field of study at university.<ul><li>Real analysis, at least the basics: epsilon-delta, the definition of differentiation, that continuous functions on a compact set attain their bounds, etc.</li><li>Functional analysis, once again at least the basics: at least as far as the Weierstraß Approximation Theorem.</li><li>Ordinary differential equations; at least as far as linearisation around equilibria. (Probably the engineers have some good not-too-dense reference texts for these.)</li><li>Fourier series.</li><li>Div, grad, curl and all that.</li></ul></li><li>Optional: any number of slightly more specialised, but still very widely applicable, fields. For example:<ul><li>Differential geometry</li><li>Optimal transport.</li><li>Stochastic calculus, if you do anything to do with time series. (Or score-based diffusion models.)</li><li>Statistical physics.</li><li>Perturbation theory. Much of machine learning is morphing into a branch of applied mathematics. And as my old fluid dynamics lecturer commented, you can’t be a card-carrying applied mathematician without knowing perturbation theory.</li></ul></li></ul><h2 id="statistics">Statistics</h2><p>Actually, I’m going to admit to something here: my statistics is nowhere near as strong as I’d like it to be. I think there’s probably a lot that should be added to the following list.</p><ul><li>All the usual introductory stuff: log-likelihoods, BLUE, cross-validation, confidence intervals, random forests, XGBoost etc. etc.<ul><li>Regularisation: Tikhonov/ridge/L2 regularisation, sparsity/L1 regularisation, weight decay. The equivalence between regularised maximum likelihood and maximum a-posteriori.</li></ul></li><li>Variance minimisation:<ul><li>Antithetic sampling;</li><li>Importance sampling (<em>cough</em> Radon–Nikodym derivatives again <em>cough</em>);</li><li>Quasi Monte-Carlo (again);</li><li>Control variates.</li></ul></li><li>Linear-time biased Monte-Carlo approximations to MMDs. Quadratic-time unbiased Monte-Carlo approximations to MMDs.<ul><li>It may have gone out of fashion, but the basics of kernel theory.</li></ul></li><li>Markov Chain Monte-Carlo. Hamiltonian Monte-Carlo.<ul><li>Relatedly, Gaussian “soap bubbles” in high dimensions, and “typical sets” in MCMC. Anything to build high-dimensional intuition is great. <a href="https://stanislavfort.github.io/blog/sphere-spilling-out/">This</a> is a fun example. Can you figure out what’s wrong with the final picture?</li></ul></li></ul><h2 id="thats-a-lot-of-stuff">That’s a lot of stuff</h2><p>That’s quite a long list.</p><p>Don’t expect to cover all of that in a few months; this is something that should happen over the next few years. To be precise, the above is more-or-less what I think deserves to be known by most people by the end of their PhD. You should naturally expect to also know your own subfield, whatever that is, inside-out.</p><p>This list is noticeably biased towards the things I happen to be more involved in, which I guess is unsurprising.</p><p>(For example I haven’t mentioned Vapnik–Chervonenkis dimensions or Gaussian processes anywhere. Some may disagree with me but I think it’s possible to get by without knowing VC dimensions these days. And I have a personal bias against Gaussian processes.)</p><p>So, season to taste. Probably a few of you are reading this wondering how it could have slipped my mind to add your favourite X, Y or Z to that list! (Object detection, scaling laws for large models, subquadratic attention mechanisms, symbolic regression, …)</p><p>It’s worth noting that “by the end of their PhD” is kind of an arbitrary deadline. One never really stops learning. I certainly look back what I’ve written a couple of years ago, and see noticeable improvements I would make if I were to do it again. And looking forward, I have a list of things I intend to learn more about. (Currently: algebraic effects, deeper knowledge of Rust, and microbiology.)</p><h2 id="interesting-parts-of-the-internet-to-hang-out-in">Interesting parts of the internet to hang out in.</h2><p>When it comes to Just Knowing Stuff, it’s great to get a sense of the general Zeitgeist in the ML community, and also the rest of the tech community at large. These are a few of my favourite spots:</p><ul><li>Twitter;</li><li>Mastodon;</li><li>Hacker News;</li><li>/r/machinelearning</li><li>YouTube, in particular the recorded talks from programming conferences;</li><li>Programming/software blogs;</li><li>Forums for software you use regularly<ul><li>including the GitHub “issues” and “discussions” tabs</li></ul></li></ul><h2 id="conclusion">Conclusion</h2><p>Those of you who already have research experience, and who are reading this: what would be your personal Just Know Stuff list? Do you think mine is fair?</p><p>Write your own list and/or let me know on <a href="https://twitter.com/PatrickKidger">Twitter</a> or <a href="https://fosstodon.org/@PatrickKidger">Mastodon</a>.</p></article></section></div></div>
  </body>
</html>
