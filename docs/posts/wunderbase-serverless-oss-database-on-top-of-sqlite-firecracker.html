<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wundergraph.com/blog/wunderbase_serverless_graphql_database_on_top_of_sqlite_firecracker_and_prisma">Original</a>
    <h1>Show HN: WunderBase â€“ Serverless OSS database on top of SQLite, Firecracker</h1>
    
    <div id="readability-page-1" class="page"><div><article><p>Today we&#39;re happy to announce the open source release of WunderBase,<!-- --> <!-- -->a Serverless Database with a GraphQL API on top of SQLite, Firecracker/Fly machines, and Prisma.<!-- --> <!-- -->It&#39;s embarrassingly simple, but powerful, as the codebase is less than 400 lines of Go.<!-- --></p><p>WunderBase is built on top of Fly machines, which is a REST API that allows you to run virtual machines in seconds.<!-- --> <!-- -->What&#39;s special about machines is that they can sleep when an application exits with a zero exit code.<!-- --></p><p>When you send a request to WunderBase, the virtual machine wakes up in about 300-500ms and executes the request.<!-- --> <!-- -->Ten seconds (configurable) after the last request was processed, we send the machine to sleep again.<!-- --> <!-- -->This means that you really only pay for storage and the CPU time you really use,<!-- --> <!-- -->hence the name &#34;Serverless Database&#34;.<!-- --></p><p>If you&#39;d like to jump right into the code and try WunderBase out for yourself, you can find the <!-- --><a target="_blank" rel="noreferrer" href="https://github.com/wundergraph/wunderbase">source code on GitHub<!-- --> <!-- --><span><svg viewBox="0 0 256 256" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M59.1666 78.8334C56.5587 78.8334 54.0575 79.8694 52.2134 81.7135C50.3693 83.5576 49.3333 86.0587 49.3333 88.6667V196.833C49.3333 199.441 50.3693 201.942 52.2134 203.787C54.0575 205.631 56.5587 206.667 59.1666 206.667H167.333C169.941 206.667 172.442 205.631 174.287 203.787C176.131 201.942 177.167 199.441 177.167 196.833V137.833C177.167 132.403 181.569 128 187 128C192.431 128 196.833 132.403 196.833 137.833V196.833C196.833 204.657 193.725 212.161 188.193 217.693C182.661 223.225 175.157 226.333 167.333 226.333H59.1666C51.3427 226.333 43.8393 223.225 38.307 217.693C32.7747 212.161 29.6666 204.657 29.6666 196.833V88.6667C29.6666 80.8428 32.7747 73.3394 38.307 67.807C43.8393 62.2747 51.3427 59.1667 59.1666 59.1667H118.167C123.597 59.1667 128 63.5692 128 69C128 74.4308 123.597 78.8334 118.167 78.8334H59.1666Z"></path><path d="M147.667 39.5C147.667 34.0692 152.069 29.6667 157.5 29.6667H216.5C221.931 29.6667 226.333 34.0692 226.333 39.5V98.5C226.333 103.931 221.931 108.333 216.5 108.333C211.069 108.333 206.667 103.931 206.667 98.5V49.3334H157.5C152.069 49.3334 147.667 44.9308 147.667 39.5Z"></path><path d="M223.453 32.5468C227.293 36.387 227.293 42.6131 223.453 46.4532L115.287 154.62C111.446 158.46 105.22 158.46 101.38 154.62C97.54 150.78 97.54 144.554 101.38 140.713L209.547 32.5468C213.387 28.7066 219.613 28.7066 223.453 32.5468Z"></path></svg></span></a>.<!-- --></p><a href="#see-wunderbase-in-action"><h2>See WunderBase in action<!-- --></h2></a><p>If you&#39;re less of a reader, you can also watch the video below to see WunderBase in action.</p><a href="#why-we&#39;ve-built-wunderbase"><h2>Why we&#39;ve built WunderBase<!-- --></h2></a><p>We&#39;re in the works of building WunderGraph Cloud, applying the principles of Vercel to Backend/API development.<!-- --> <!-- -->We take the most important backend primitives like Authentication &amp; Authorization, Database, Queue, PubSub, Key-Value Store, Cache, etc.<!-- --> <!-- -->and make them available as a single, unified SDK.<!-- --></p><p>Git push and 30 seconds later, you&#39;ve got a fully functional Serverless backend without touching any infrastructure.<!-- --> <!-- -->Make some code changes, open a PR, and get a preview environment with your changes.<!-- --></p><p>For this to work, we need a fast and inexpensive way to create and destroy databases.<!-- --> <!-- -->But as you&#39;ll see, there are many other use cases for WunderBase than just preview environments.<!-- --></p><a href="#how-does-wunderbase-work"><h2>How does WunderBase work?<!-- --></h2></a><p>Here&#39;s an overview of how WunderBase works:</p><div><p><span><span></span><img alt="WunderBase" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive"/></span></p></div><ol><li>You deploy WunderBase to a Fly machine with a volume attached</li><li>The Fly machine boots up and starts WunderBase</li><li>We use the the <!-- --><code>prisma.schema</code> file to migrate the database using the Prisma Migration Engine<!-- --></li><li>Once the migration is done, we create a lock file to prevent future migrations if the <!-- --><code>prisma.schema</code> file didn&#39;t change<!-- --></li><li>Finally, we start the Prisma Query Engine to serve the GraphQL API</li><li>Ten seconds (configurable) after the last request was processed, we exit WunderBase with a zero exit code to indicate to fly that this Machine should go to sleep</li></ol><p>Request flow:</p><ol><li>You send a request to WunderBase</li><li>The Fly machine wakes up in about 300-500ms</li><li>The fly proxy forwards the request to WunderBase</li><li>WunderBase sanitizes the request and proxies it to the Prisma Query Engine</li><li>The Prisma Query Engine executes the request and returns the result</li><li>WunderBase sends the result back to the client</li><li>Again, after ten seconds of inactivity, we shut down the Machine</li></ol><a href="#rethinking-serverless-with-fly-machines"><h2>Rethinking Serverless with Fly machines<!-- --></h2></a><p>When using AWS Lambda, you have to follow certain rules to make your application compatible with the environment.<!-- --> <!-- -->E.g. when you&#39;re using Golang, you have to export a <!-- --><code>Handler</code> function that takes a <!-- --><code>context.Context</code> and the name of the event.<!-- --> <!-- -->Also, you don&#39;t really have much control over the environment your application runs in.<!-- --> <!-- -->At some point, the Lambda runtime will shut down your application.<!-- --></p><p>With Fly machines, we can operate at a much lower level.<!-- --> <!-- -->We create a Docker container that listens on a specific port.<!-- --> <!-- -->We tell fly to run this container and send all requests to this port.<!-- --> <!-- -->If we think the Machine should sleep, we exit the container with a zero exit code.<!-- --> <!-- -->Fly will keep our volume around and start the container again when we send a request.<!-- --></p><p>A lot of applications are written in a Serverful single-tenant way would usually be quite expensive to run as a multi-tenant service.<!-- --> <!-- -->With Fly machines, we can run these applications in a very cost-efficient way.<!-- --> <!-- -->However, there&#39;s a catch. We have to optimize the application for fast startup and shutdown.<!-- --> <!-- -->I know that fly is working on allowing machines to &#34;sleep&#34; and &#34;resume&#34;, just like closing and re-opening a laptop.<!-- --> <!-- -->This would allow us to run applications that are not optimized for fast startup and shutdown.<!-- --> <!-- -->In the meantime, we&#39;ve built WunderBase in a way to optimize for fast startup and shutdown times.<!-- --></p><a href="#optimizations-to-reduce-cold-start-and-shutdown-times"><h2>Optimizations to reduce cold start and shutdown times<!-- --></h2></a><p>When a request is waiting to be served, we need to make sure that the Machine starts up as fast as possible.<!-- --> <!-- -->At the same time, we always want to keep the database schema in sync with the <!-- --><code>prisma.schema</code> file.<!-- --> <!-- -->If we ran a migration every time the Machine starts up, we would have to wait for the migration to finish before we can serve the request.<!-- --> <!-- -->That&#39;s not ideal, so we&#39;ve optimized this path.<!-- --></p><p>When the Machine starts up, we hash the <!-- --><code>prisma.schema</code> file and check if there&#39;s a lock file with the same hash.<!-- --> <!-- -->If there&#39;s a lock file, we compare the content of the lock file with the hash of the <!-- --><code>prisma.schema</code> file.<!-- --> <!-- -->If they are the same, we know that the migration for this schema has already been executed.<!-- --> <!-- -->If there&#39;s no lock file, we run a migration and create a lock file with the hash of the <!-- --><code>prisma.schema</code> file.<!-- --></p><p>We store the lock file in the volume, so it&#39;s available even if the Machine was sleeping.</p><p>Next, we needed to make sure that the Prisma Query Engine shuts down properly.<!-- --> <!-- -->We start the Prisma Query Engine as a separate process.<!-- --> <!-- -->Before we kill the main process, we send a <!-- --><code>SIGTERM</code> signal to the Prisma Query Engine.<!-- --> <!-- -->If we would immediately kill the main process, the sub-process would keep the Machine from shutting down for a few more seconds.<!-- --> <!-- -->Instead, we&#39;re using a <!-- --><code>sync.WaitGroup</code> to wait for the Prisma Query Engine to shut down before we exit the main process.<!-- --> <!-- -->This way, we&#39;ve reduced the shutdown time from 5-10 seconds to 1-2 seconds.<!-- --></p><p>If we didn&#39;t do this, you&#39;d have to wait up to 10 seconds when sending a request to WunderBase while it&#39;s shutting down.</p><a href="#how-does-wunderbase-compare-to-other-serverless-databases-like-dynamodb,-cockroachdb,-mongodb,-faunadb,-planetscale-or-neon"><h2>How does WunderBase compare to other Serverless Databases like DynamoDB, CockroachDB, MongoDB, FaunaDB, Planetscale or Neon?<!-- --></h2></a><p>We can have long debates about what Serverless really is or if the term actually makes sense.<!-- --> <!-- -->After all, there are still servers involved.<!-- --> <!-- -->To me, Serverless means that you don&#39;t have to worry about the infrastructure<!-- --> <!-- -->and that you only pay for what you really use.<!-- --></p><p>For a long time, Serverless was mostly about functions.<!-- --> <!-- -->You write a function, deploy it, and you&#39;re done.<!-- --> <!-- -->Someone else takes care of the infrastructure and you only pay per request.<!-- --></p><p>Then came a new wave of Serverless offerings that give you a &#34;Serverless Database&#34;.<!-- --> <!-- -->You write a schema, deploy it, and you&#39;re done.<!-- --> <!-- -->But are these really Serverless?<!-- --></p><p>From a user perspective, yes.<!-- --> <!-- -->From a technical perspective, no.<!-- --> <!-- -->Most databases still are &#34;Serverful&#34; in the sense that the database server is always running.<!-- --></p><p>Some solutions, like Neon, try to solve this problem by separating the compute and storage layer.<!-- --> <!-- -->Others, like CockroachDB or Mongo put a proxy in front of the database so that you can &#34;imitate&#34; a Serverless Database.<!-- --></p><p>In contrast, the storage layer of WunderBase is always &#34;sleeping&#34;, because it&#39;s just a file.<!-- --> <!-- -->SQLite is probably the only real Serverless database because it&#39;s just a file.<!-- --> <!-- -->The Serverful part of WunderBase is the proxy that runs the Prisma Query Engine and translates between GraphQL and SQL.<!-- --> <!-- -->But as we&#39;ve discussed earlier, we can send this proxy to sleep and wake it up again when we need it.<!-- --></p><p>Another important aspect of WunderBase is that it&#39;s actually quite simple and very transparent what&#39;s going on.<!-- --> <!-- -->We&#39;ve got a proxy that translates between GraphQL and SQL,<!-- --> <!-- -->and we have a SQLite database / file on a volume.<!-- --></p><p>I&#39;ve told one of my Co-Founders that I&#39;m a bit embarrassed to release WunderBase because it&#39;s so simple and just a few hundred lines of code.<!-- --> <!-- -->He answered that it&#39;s not embarrassing at all, because it&#39;s actually quite impressive that we&#39;ve managed to build something that&#39;s so simple and yet so powerful.<!-- --> <!-- -->And he&#39;s right! Sometimes you combine the right ingredients in the right way and achieve something that took others years to build.<!-- --> <!-- -->It took me just a few hours to build WunderBase. The most time-consuming part was to write proper tests and this blog post.<!-- --></p><a href="#what-are-the-use-cases-for-wunderbase"><h2>What are the use cases for WunderBase?<!-- --></h2></a><p>You might be thinking that WunderBase is just a toy project.<!-- --> <!-- -->We&#39;re definitely not going to compete with the big players in the Serverless Database space.<!-- --> <!-- -->Instead, we&#39;re looking at serving use cases that others are unable to serve.<!-- --></p><p>I&#39;ll give you a few examples:</p><ul><li>It takes seconds to create a new WunderBase instance. You can use it for a quick prototype or to test something out.</li><li>For each branch you deploy, you can have a separate WunderBase instance that&#39;s isolated from the main branch/database.</li><li>A lot of applications don&#39;t ever store more than a few gigabytes of data and have very little traffic. WunderBase is perfect for these use cases.</li></ul><p>One use case that excites me the most is that you can &#34;shard&#34; at the database layer.<!-- --> <!-- -->What this means is that you can have a single database model that&#39;s shared across multiple databases.<!-- --> <!-- -->You can have one database per user, tenant, or any other key and route traffic to the correct database based on the user&#39;s (tenant&#39;s) ID.<!-- --> <!-- -->If you have a customer with a lot of data, you can easily put them on a separate database.<!-- --> <!-- -->If each customer has their own database, you can do point in time recovery for each customer individually.<!-- --></p><p>Another interesting use case is OLAP.<!-- --> <!-- -->Let&#39;s say we&#39;d like to analyze terabytes of data in seconds.<!-- --> <!-- -->We can shard the data across multiple databases and run a query on each database in parallel.<!-- --> <!-- -->We can then aggregate the results and return them to the user.<!-- --> <!-- -->While we&#39;re not serving any requests, we can shut down the databases.<!-- --> <!-- -->This way, we&#39;re only really paying for the storage and compute that we&#39;re using.<!-- --> <!-- -->This could be an Open Source alternative to BigQuery.<!-- --></p><a href="#how-fast-is-wunderbase"><h2>How fast is WunderBase?<!-- --></h2></a><p>I&#39;ve done some benchmarking and was able to achieve 2k write requests per second and 10k read requests per second.<!-- --> <!-- -->There&#39;s a benchmark script in the WunderBase repository that you can use to run your own benchmarks.<!-- --> <!-- -->Make sure to set the rate limit environment variables properly to not get rate-limited.<!-- --> <!-- -->During my testing I&#39;ve realized that 2k/10k is the maximum that I can achieve before getting Timeout errors,<!-- --> <!-- -->so I&#39;ve added some rate limiting to the proxy to keep everything stable.<!-- --></p><a href="#how-can-you-scale-wunderbase"><h2>How can you scale WunderBase?<!-- --></h2></a><p>There are multiple ways to scale WunderBase.<!-- --> <!-- -->We can add read replicas to scale reads.<!-- --> <!-- -->There&#39;s tooling to replicate SQLite databases, both locally or even remotely.<!-- --> <!-- -->So we could have a master database and read replicas in different regions.<!-- --></p><p>Another way to scale WunderBase is to have multiple master databases.<!-- --> <!-- -->With this approach, we can scale writes based on a key like the user ID or tenant ID.<!-- --></p><p>If you&#39;ve got users all over the world, you can combine both approaches to optimize for latency.</p><a href="#can-you-easily-migrate-from-wunderbase-to-a-different-database"><h2>Can you easily migrate from WunderBase to a different database?<!-- --></h2></a><p>Another question you might ask is if you&#39;re able to migrate from SQLite to e.g. PostgreSQL or MySQL.<!-- --> <!-- -->The answer is yes and it&#39;s actually quite easy.<!-- --> <!-- -->As we&#39;re using Prisma, we can just change the <!-- --><code>provider</code> in the <!-- --><code>datasource</code> block in the <!-- --><code>prisma.schema</code> file.<!-- --> <!-- -->If we&#39;re using the same Schema, Prisma will give us the same GraphQL API, even if we&#39;re using a different database.<!-- --></p><p>So it&#39;s possible to switch from SQLite to MySQL, PostgreSQL, SQLServer or even Planetscale.</p><a href="#how-can-you-backup-wunderbase"><h2>How can you backup WunderBase?<!-- --></h2></a><p>Backups can be implemented e.g. by leveraging LiteStream,<!-- --> <!-- -->a tool that streams the changes from a SQLite database to S3.<!-- --></p><a href="#caveats"><h2>Caveats<!-- --></h2></a><p>There&#39;s one caveat that you should be aware of.<!-- --> <!-- -->The GraphQL API that WunderBase (Prisma Query Engine) exposes is not intended to be publicly exposed.<!-- --> <!-- -->You should always put a <!-- --><a target="_blank" rel="noreferrer" href="https://github.com/wundergraph/wundergraph">GraphQL API Gateway like WunderGraph<!-- --> <!-- --><span><svg viewBox="0 0 256 256" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M59.1666 78.8334C56.5587 78.8334 54.0575 79.8694 52.2134 81.7135C50.3693 83.5576 49.3333 86.0587 49.3333 88.6667V196.833C49.3333 199.441 50.3693 201.942 52.2134 203.787C54.0575 205.631 56.5587 206.667 59.1666 206.667H167.333C169.941 206.667 172.442 205.631 174.287 203.787C176.131 201.942 177.167 199.441 177.167 196.833V137.833C177.167 132.403 181.569 128 187 128C192.431 128 196.833 132.403 196.833 137.833V196.833C196.833 204.657 193.725 212.161 188.193 217.693C182.661 223.225 175.157 226.333 167.333 226.333H59.1666C51.3427 226.333 43.8393 223.225 38.307 217.693C32.7747 212.161 29.6666 204.657 29.6666 196.833V88.6667C29.6666 80.8428 32.7747 73.3394 38.307 67.807C43.8393 62.2747 51.3427 59.1667 59.1666 59.1667H118.167C123.597 59.1667 128 63.5692 128 69C128 74.4308 123.597 78.8334 118.167 78.8334H59.1666Z"></path><path d="M147.667 39.5C147.667 34.0692 152.069 29.6667 157.5 29.6667H216.5C221.931 29.6667 226.333 34.0692 226.333 39.5V98.5C226.333 103.931 221.931 108.333 216.5 108.333C211.069 108.333 206.667 103.931 206.667 98.5V49.3334H157.5C152.069 49.3334 147.667 44.9308 147.667 39.5Z"></path><path d="M223.453 32.5468C227.293 36.387 227.293 42.6131 223.453 46.4532L115.287 154.62C111.446 158.46 105.22 158.46 101.38 154.62C97.54 150.78 97.54 144.554 101.38 140.713L209.547 32.5468C213.387 28.7066 219.613 28.7066 223.453 32.5468Z"></path></svg></span></a> in front of it.<!-- --> <!-- -->It&#39;s perfectly fine to use GraphQL as the ORM layer, but this API is not intended to be consumed by clients in the browser directly.<!-- --></p><p>Additionally, Prisma Query Engine is only exposing a subset of GraphQL,<!-- --> <!-- -->e.g. you cannot use variable definitions.<!-- --> <!-- -->We&#39;ve done some extra steps in WunderGraph to make it compatible with GraphQL,<!-- --> <!-- -->like writing a &#34;variable definition inliner&#34; to automatically inline variable definitions and make the GraphQL Operation compatible with the Prisma Engine.<!-- --> <!-- -->I&#39;ll follow up with a blog post about this topic as it was actually quite interesting to reverse engineer the Prisma Query Engine and make all of this work together.<!-- --></p><a href="#thank-you-prisma!"><h2>Thank you Prisma!<!-- --></h2></a><p>All of this wouldn&#39;t have been possible without the amazing work that the Prisma team has done.<!-- --> <!-- -->Besides the 400 lines of glue code that I&#39;ve written, the rest is just Prisma.<!-- --></p><p>I also know that this is not the intended use case of Prisma.<!-- --> <!-- -->Nikolas Burk keeps reminding me that Prisma is an ORM and the GraphQL layer of the Prisma Query Engine is an internal detail.<!-- --> <!-- -->Prisma generates a client library on top of this Engine which uses GraphQL internally.<!-- --></p><p>I personally think that it&#39;s much more powerful to expose the GraphQL API directly.<!-- --> <!-- -->This way, I&#39;m able to <!-- --><a target="_blank" rel="noreferrer" href="https://docs.wundergraph.com/docs/features/cross-api-joins-to-compose-apis">join<!-- --> <!-- --><span><svg viewBox="0 0 256 256" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M59.1666 78.8334C56.5587 78.8334 54.0575 79.8694 52.2134 81.7135C50.3693 83.5576 49.3333 86.0587 49.3333 88.6667V196.833C49.3333 199.441 50.3693 201.942 52.2134 203.787C54.0575 205.631 56.5587 206.667 59.1666 206.667H167.333C169.941 206.667 172.442 205.631 174.287 203.787C176.131 201.942 177.167 199.441 177.167 196.833V137.833C177.167 132.403 181.569 128 187 128C192.431 128 196.833 132.403 196.833 137.833V196.833C196.833 204.657 193.725 212.161 188.193 217.693C182.661 223.225 175.157 226.333 167.333 226.333H59.1666C51.3427 226.333 43.8393 223.225 38.307 217.693C32.7747 212.161 29.6666 204.657 29.6666 196.833V88.6667C29.6666 80.8428 32.7747 73.3394 38.307 67.807C43.8393 62.2747 51.3427 59.1667 59.1666 59.1667H118.167C123.597 59.1667 128 63.5692 128 69C128 74.4308 123.597 78.8334 118.167 78.8334H59.1666Z"></path><path d="M147.667 39.5C147.667 34.0692 152.069 29.6667 157.5 29.6667H216.5C221.931 29.6667 226.333 34.0692 226.333 39.5V98.5C226.333 103.931 221.931 108.333 216.5 108.333C211.069 108.333 206.667 103.931 206.667 98.5V49.3334H157.5C152.069 49.3334 147.667 44.9308 147.667 39.5Z"></path><path d="M223.453 32.5468C227.293 36.387 227.293 42.6131 223.453 46.4532L115.287 154.62C111.446 158.46 105.22 158.46 101.38 154.62C97.54 150.78 97.54 144.554 101.38 140.713L209.547 32.5468C213.387 28.7066 219.613 28.7066 223.453 32.5468Z"></path></svg></span></a> multiple APIs together easily<!-- --> <!-- -->and talk to all my services with a single language.<!-- --></p><p>So, thank you and sorry for abusing your product! Open Source is awesome! =)</p><a href="#the-future-of-firecracker-based-applications"><h2>The future of Firecracker-based Applications<!-- --></h2></a><p>I&#39;m very excited about the future of Firecracker-based applications.<!-- --> <!-- -->I&#39;m pretty sure that this paradigm will allow us to build or re-build a lot of applications in a more efficient way,<!-- --> <!-- -->like Serverless Databases, Serverless Caches, Serverless Queues, Serverless Search Engines, etc.<!-- --></p><a href="#what&#39;s-next"><h2>What&#39;s next?<!-- --></h2></a><p>Our goal for WunderGraph is to create a TypeScript Framework that allows you to build Serverless Applications in a very simple way.<!-- --> <!-- -->From databases to file storage, queues, pub/sub, key-value, and caching.<!-- --> <!-- -->We want to provide a unified SDK that allows you to focus on the code, not on the infrastructure.<!-- --></p><p>Today, we&#39;re starting with a Database, but there&#39;s alot more to come.</p><div><div><p>WunderGraph Cloud Early Access</p><p>Be amongst the first to try WunderGraph Cloud &amp; WunderBase for free.<!-- --> <!-- -->With WunderGraph Cloud, you&#39;ll be able to git push your application and get a fully functional Serverless API alongside your Database in seconds.<!-- --></p></div></div><p>Make sure to follow us on twitter or linkedin to stay up to date on our progress.</p><a href="#what-would-you-build-with-wunderbase"><h2>What would you build with WunderBase?<!-- --></h2></a><p>Finally, I&#39;d love to hear what you&#39;d build with WunderBase.<!-- --> <!-- -->I&#39;ve got a few ideas (see above),<!-- --> <!-- -->but I&#39;m sure that there are many more use cases that I haven&#39;t thought of yet.<!-- --></p><p>In case you&#39;ve missed it above, here&#39;s the link to the <!-- --><a target="_blank" rel="noreferrer" href="https://github.com/wundergraph/wunderbase">source code of WunderBase on GitHub<!-- --> <!-- --><span><svg viewBox="0 0 256 256" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M59.1666 78.8334C56.5587 78.8334 54.0575 79.8694 52.2134 81.7135C50.3693 83.5576 49.3333 86.0587 49.3333 88.6667V196.833C49.3333 199.441 50.3693 201.942 52.2134 203.787C54.0575 205.631 56.5587 206.667 59.1666 206.667H167.333C169.941 206.667 172.442 205.631 174.287 203.787C176.131 201.942 177.167 199.441 177.167 196.833V137.833C177.167 132.403 181.569 128 187 128C192.431 128 196.833 132.403 196.833 137.833V196.833C196.833 204.657 193.725 212.161 188.193 217.693C182.661 223.225 175.157 226.333 167.333 226.333H59.1666C51.3427 226.333 43.8393 223.225 38.307 217.693C32.7747 212.161 29.6666 204.657 29.6666 196.833V88.6667C29.6666 80.8428 32.7747 73.3394 38.307 67.807C43.8393 62.2747 51.3427 59.1667 59.1666 59.1667H118.167C123.597 59.1667 128 63.5692 128 69C128 74.4308 123.597 78.8334 118.167 78.8334H59.1666Z"></path><path d="M147.667 39.5C147.667 34.0692 152.069 29.6667 157.5 29.6667H216.5C221.931 29.6667 226.333 34.0692 226.333 39.5V98.5C226.333 103.931 221.931 108.333 216.5 108.333C211.069 108.333 206.667 103.931 206.667 98.5V49.3334H157.5C152.069 49.3334 147.667 44.9308 147.667 39.5Z"></path><path d="M223.453 32.5468C227.293 36.387 227.293 42.6131 223.453 46.4532L115.287 154.62C111.446 158.46 105.22 158.46 101.38 154.62C97.54 150.78 97.54 144.554 101.38 140.713L209.547 32.5468C213.387 28.7066 219.613 28.7066 223.453 32.5468Z"></path></svg></span></a>.<!-- --> <!-- -->Give it a star if you like the project and go tinkering with it. =)<!-- --></p></article></div></div>
  </body>
</html>
