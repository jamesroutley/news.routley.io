<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tweedegolf.nl/en/blog/79/sorting-with-simd">Original</a>
    <h1>Sorting with SIMD</h1>
    
    <div id="readability-page-1" class="page"><p><strong><p>Google recently published a <a href="https://opensource.googleblog.com/2022/06/Vectorized%20and%20performance%20portable%20Quicksort.html">blog article</a> and paper introducing their SIMD-accelerated sorting algorithm.</p><p>SIMD stands for single instruction, multiple data. A single instruction is used to apply the same operation to multiple pieces of data. The prototypical example is addition, where one instruction can do e.g. 4 32-bit additions. A single SIMD addition should be roughly 4 times faster than performing 4 individual additions.</p><p>This kind of instruction-level parallelism has many applications in areas with a lot of number crunching, e.g. machine learning, physics simulations, and game engines. But how can this be used for sorting? Sorting does not involve arithmetic, and the whole idea of sorting is that each element moves to its unique correct place in the output. In other words, we don&#39;t want to perform the same work for each element, so at first sight it&#39;s hard to see where SIMD can help.</p><p>To understand the basic concepts, I played around with the ideas from the paper <a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.1009.7773&amp;rep=rep1&amp;type=pdf">Fast Quicksort Implementation Using AVX Instructions</a> by Shay Gueron and Vlad Krasnov. They provide an implementation in (surprisingly readable) assembly <a href="https://github.com/vkrasnov/avx_qsort/blob/master/qsort_AVX2_HSW_256bit_int.s">on their github</a>. Let&#39;s see how we can make SIMD sort.</p></strong></p><div><h2 id="rust-avx-simd-basics">rust AVX simd basics</h2><p>Because we are just exploring the idea (rather than writing a production-quality implementation), we&#39;ll be using the somewhat outdated AVX family of simd instructions in this post. These are available on intel/amd processors made in the last decade, and operate on 128-bit simd values.</p><p>The following creates a 128-bit simd value consisting of four 32-bit values, each being the i32 value <code>42</code>:</p><pre><code>#[cfg(target_arch = &#34;x86_64&#34;)]
use std::arch::x86_64::*;

let same : __m128i = _mm_set1_epi32(42i32);</code></pre><p>The weird functions starting with <code>_mm</code> wrap instructions and are called intrinsics. There are intrinsics for going from standard rust types to simd types:</p><pre><code>let values1 = [ 1i32, 2, 3, 4 ];
let simd_value = _mm_load_ps(unsafe { values.as_ptr().cast() });</code></pre><p>... and back:</p><pre><code>let mut values2= [ 0i32, 0, 0, 0 ];
_mm_storeu_ps(unsafe { values2.as_mut_ptr().cast() }, simd_value);
assert_eq!(values1, values2);</code></pre><h3 id="simd-compare">SIMD Compare</h3><p>Given some simd values, we can use simd instructions to do work. For instance here we perform four greater-than comparisons in one instruction with the <code>_mm_cmpgt_epi32</code> intrinsic:</p><p><img alt="Sorting with SIMD" src="https://bytes.zone/images/sorting1.png"/></p><p>in code:</p><pre><code>let values1 = [ 1i32, 8, 5, 4 ];
let simd_value1 = _mm_load_ps(unsafe { values1.as_ptr().cast() });
let values2 = [ 1i32, 2, 6, 8 ];
let simd_value2 = _mm_load_ps(unsafe { values2.as_ptr().cast() });

let greater_than = _mm_cmpgt_epi32(current, pivot);

let mut result= [ 0i32 ; 4 ];
_mm_storeu_ps(unsafe { result.as_mut_ptr().cast() }, greater_than);
assert_eq!(result, [ 0x0, 0xFFFFFFFF, 0x0, 0xFFFFFFFF ]);</code></pre><p><code>false</code> is encoded as the integer <code>0</code> (<code>0x0</code> in hex), while <code>true</code> is represented as the 32-bit where each bit is a one (<code>0xFFFFFFFF</code> in hex).</p><h2 id="quicksort">Quicksort</h2><p>The quicksort algorithm is a recursive sort that picks an element from the input list, the pivot, and then partitions the list into those elements smaller, and those bigger than the pivot.</p><p>The algorithm then recurses on the list of smaller and bigger elements, picking a new pivot, and eventually bottoming out in a list of either 0 or 1 elements.</p><p>Quicksort normally uses constant space - the sorting happens in-place - but for this paper a linear amount of additional space is needed to temporarily store the list of elements bigger than the pivot. I also use an explicit stack rather than recursion to make sure we can handle very large inputs.</p><pre><code>pub fn sort(input: &amp;mut [i32]) {
    let mut scratchpad = vec![0; input.len()];

    sort_help(input, &amp;mut scratchpad)
}

fn sort_help(initial: &amp;mut [i32], scratchpad: &amp;mut [i32]) {
    let mut stack = vec![0..initial.len()];

    while let Some(range) = stack.pop() {
        let (start, end) = (range.start, range.end);
        let input = &amp;mut initial[start..end];

        if input.len() &lt;= 1 {
            continue;
        }

        // returns the number of elements less than or equal to the pivot
        let n = partition(input, scratchpad);

        if n == input.len() {
            // all elements smaller than or equal to the pivot 
            // i.e. the pivot is in the correct position in the array
            stack.push(start..end - 1);
        } else {
            stack.push(start..start + n);
            stack.push(start + n..end);
        }
    }
}</code></pre><h2 id="permute">Permute</h2><p>The core of the <a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.1009.7773&amp;rep=rep1&amp;type=pdf">Fast Quicksort Implementation Using AVX Instructions</a> paper is to use the permute instruction to implement the <code>partition</code> function. With some thought, this instruction can move all elements greater than or smaller than the pivot to one side of a SIMD value.</p><p>For our case, the instruction in question is not exposed as a convenient intrinsic. So instead, we have to reach for some inline assembly. It is always fun to use a new language feature. You should probably not use inline assembly in production code, but here we&#39;re just using it for experimentation.</p><pre><code>#[target_feature(enable = &#34;avx&#34;)]
unsafe fn vperilps(mut current: __m128, mask: (i32, i32, i32, i32)) -&gt; __m128 {
    let mask = _mm_set_epi32(mask.3, mask.2, mask.1, mask.0);

    std::arch::asm!(
        &#34;vpermilps {a:y}, {a:y}, {m:y}&#34;,
        a = inout(ymm_reg) current,
        m = in(ymm_reg) mask,

    );

    current
}

unsafe fn permute(x: (i32, i32, i32, i32), mask: (i32, i32, i32, i32)) -&gt; __m128 {
    let y = _mm_set_epi32(x.3, x.2, x.1, x.0);
    vperilps(y, mask)
}</code></pre><p>The instruction inputs are two 128-bit values: the input vector and a lookup table. The output is defined as</p><pre><code>output[0] = input[mask[0];
output[1] = input[mask[1];
output[2] = input[mask[2];
output[3] = input[mask[3];</code></pre><p>so for each position in the output, we index into the lookup table. That gives an index into the input, whose value we put in the output. Because simd values are conceptually binary numbers, they &#34;start&#34; from the right.</p><pre><code>permute((64, 32, 16, 8), (3,2,1,0)) == _mm_set_epi32(64, 32, 16, 8)
permute((64, 32, 16, 8), (0,1,2,3)) == _mm_set_epi32(8, 16, 32, 64)</code></pre><p>The trick is now to determine which elements are greater than the pivot, and pick the right mask that puts these values on the right. If our input is <code>_mm_set_epi32(5, 40, 20, 10)</code> and the pivot is 15, then the values at 40 and 20 should move to the right: 20 moves to the right-most position, and 40 moves just to the left of that. The two remaining positions don&#39;t matter, but it is convenient to use zero as the value in the mask. Thus we end up with:</p><p><img alt="Sorting with SIMD" src="https://bytes.zone/images/sorting2.png"/></p><pre><code>permute((5, 40, 20, 10), (0, 0, 2, 1)) == _mm_set_epi32(10, 10, 40, 20)</code></pre><p>we then write this output to the array with the greater values, and increment by the number of values that are greater, roughly</p><pre><code>let greater = permute((5, 40, 20, 10), (0, 0, 2, 1));
_mm_storeu_ps(scratchpad.as_ptr().add(top) as *mut _, greater);
top += 2;</code></pre><p>But that moves the problem: how do we figure out what mask to use?</p><h2 id="finding-the-lookup-table">Finding the lookup table</h2><p>The core idea here is to precompute what to do in all scenarios: we&#39;re creating a lookup table.
Let&#39;s look at some examples. Say the output of the comparison is</p><pre><code>0010</code></pre><p>Only the element at index 1 is bigger than the pivot (index 0 is the right-most bit). Therefore we want the element at index 1 of the input to move to index 0 of the output. Hence we put the value 1 at index 0 of the mask:</p><pre><code>(0, 0, 0, 1)</code></pre><p>If instead the comparison says</p><pre><code>0100</code></pre><p>that means that we want the element at index 2 of the input to move to index 0 of the output:</p><pre><code>(0, 0, 0, 2)</code></pre><p>and if there are multiple, we want to preserve the order</p><pre><code>0110</code></pre><p>That means that we want the element at index 2 of the input to move to index 0 of the output:</p><pre><code>(0, 0, 2, 1)</code></pre><p>This (ugly, unoptimized) snippet generates the whole table:</p><pre><code>// gives all the indices of the 1 bits in the input number
fn iter_ones(mut int: usize) -&gt; impl Iterator&lt;Item = usize&gt; {
    let mut i = 0;

    std::iter::from_fn(move || loop {
        if int == 0 {
            return None;
        }

        let current = i;
        let is_one = int &amp; 1 &gt; 0;

        i += 1;
        int &gt;&gt;= 1;

        if is_one {
            return Some(current);
        }
    })
}

fn generate_table() {
    for i in 0..16 {
        let mut row = [0, 0, 0, 0];

        for (r, o) in row.iter_mut().zip(iter_ones(i)) {
            *r = o;
        }

        println!(&#34;{:?}&#34;, row);
    }
}</code></pre><h2 id="performance">Performance</h2><p>So, is it faster? Not really. It&#39;s competitive with the rust standard library on my machine, but much slower on some other CPUs I tested it on. That is a little disappointing.</p><p>There are many reasons for this: the pivot is picked in a naive way, quicksort is not the best choice when lists are small. With some thought it is also possible to remove the second buffer, and have the program run using constant space.</p><p>There are also wider SIMD values, and newer instruction sets. The more recent AVX512 has special instructions which remove the need for a big lookup table.</p><h2 id="conclusion">Conclusion</h2><p>We have explored a non-intuitive use of SIMD instructions: speeding up quicksort. The solution uses simd intrinsics, some inline assembly, and the construction of a small lookup table. At least to me, this sort of trickery is extremely satisfying.</p><p>The google implementation is much more robust, but based on the same idea. They report being able to sort 1GB/s on a single CPU core. An extremely impressive result.</p><p>I&#39;m very interested in using SIMD outside of number crunching. The <a href="https://arxiv.org/pdf/1902.08318.pdf">simdjson</a> paper is a great example of how SIMD can be used in parsing. SIMD can easily be used for searching, and with these ideas, we can also improve sorting. If you have examples of simd in non-intuitive ways, let me know!</p></div></div>
  </body>
</html>
