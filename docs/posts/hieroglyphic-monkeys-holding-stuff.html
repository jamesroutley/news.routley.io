<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.plover.com/lang/egyptian-monkeys.html">Original</a>
    <h1>Hieroglyphic monkeys holding stuff</h1>
    
    <div id="readability-page-1" class="page"><div><details open=""><summary>Table of Contents</summary></details>
<p>Building a native GUI for a cross-platform application is a decades old
problem. Nowadays, most people just <em>don&#39;t</em> and fallback to using a non-native
experience such as Electron instead.</p>
<p>One approach to building a native GUI for a cross-platform application is to
write all of the business logic in a cross-platform language (C, Rust, Zig,
etc.) and then write the platform-specific GUI code.
This is the approach I take with my
<a target="_blank" rel="noopener noreferrer" href="https://twitter.com/mitchellh/status/1662217955424493570">my terminal emulator</a>
and it works really well. As of the current date writing this post, 93% of my repository is
business logic in Zig and C, and 4% is macOS-specific GUI code in Swift.</p>
<p>As a result, my terminal emulator is truly native: you get native Mac windows,
Mac GUI components (buttons, text fields), etc. It looks and feels great. But
its also still cross-platform: I support Linux (using GTK) while sharing ~90%
of all code. In this post, I&#39;ll share details about how this setup works and
why I approached GUI programming this way.</p>
<p>I&#39;ll be using Zig as the example shared-logic language, but this general
pattern should apply to any systems language that can compile to a C-compatible
library, such as Rust.</p>
<div><p>This post will not teach you to Zig or SwiftUI programming. However, you
also don&#39;t need to be familiar with either. As long as you understand that
Zig is a programming language and SwiftUI is a native GUI toolkit, then
my explanations in this post are going to be more generally applicable.</p></div>
<hr/>

<p>The high level idea:</p>
<ol>
<li>
<p>Write your business logic in any language that supports exporting a
C-compatible library. This is just about any systems language
(Rust, Zig, C, C++, etc.). You could use a higher level language
(JavaScript, Ruby, Python) but the architecture changes since you need
a runtime.</p>
</li>
<li>
<p>Compile your cross-platform logic into a static library that exposes
the C ABI as the primary interface (acts like a &#34;typical&#34; system library).</p>
</li>
<li>
<p>Write your GUI logic in whatever native language and toolkit is recommended
for your platform, such as SwiftUI in XCode.</p>
</li>
<li>
<p><a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Linker_(computing)">Link</a> the GUI to your
cross-platform library. ðŸŽ‰</p>
</li>
</ol>
<hr/>

<p>Zig makes it easy to export a C API. By prepending <code>export</code> to a function,
the function uses the C calling convention and is available for other programs
to call via standard linking. Here is the real exported function for initializing
the global state for my terminal:</p>
<div><pre><code><span><span>export</span> <span>fn</span> <span>ghostty_init</span><span>(</span><span>)</span> <span><span>c_int</span></span> <span>{</span>
</span><span>    main<span>.</span>state<span>.</span><span>init</span><span>(</span><span>)</span><span>;</span>
</span><span>    <span>return</span> <span>0</span><span>;</span>
</span><span><span>}</span>
</span></code></pre></div>
<div><p>The signature of an exported function (or more specifically: functions
using the C calling convention) is limited to parameters and return values
that are supported by C. This means you can not use comptime parameters,
generics, error sets, arbitrary bit width integers, etc. This restriction
<em>only applies to the signature</em>. You can use all of those features inside
the function body.</p></div>
<p>From there, you can write your own header file and it quacks just like any
other library written in C. Note, you actually <em>must</em> write a header file,
because this is how Swift is going to know what the API is for your library.</p>
<div><pre><code><span><span><span>#</span> <span>ghostty</span><span><span>.</span>h</span></span>
</span><span>
</span><span><span>int</span> <span>ghostty_init</span><span>(</span><span>void</span><span>)</span><span>;</span>
</span></code></pre></div>
<p>Finally, to build a static library, we can use the native Zig build tooling.
The <code>build.zig</code> ends up looking something like this. The result is that
you should see a file named <code>something.a</code> in your <code>zig-out</code> directory.</p>
<div><pre><code><span><span>const</span> lib <span>=</span> b<span>.</span><span>addStaticLibrary</span><span>(</span><span>.</span><span>{</span>
</span><span>    <span>.</span>name <span>=</span> <span>&#34;ghostty&#34;</span><span>,</span>
</span><span>    <span>.</span>root_source_file <span>=</span> <span>.</span><span>{</span> <span>.</span>path <span>=</span> <span>&#34;src/main_c.zig&#34;</span> <span>}</span><span>,</span>
</span><span>    <span>.</span>target <span>=</span> <span>.</span><span>{</span>
</span><span>        <span>.</span>cpu_arch <span>=</span> <span>.</span>aarch64<span>,</span>
</span><span>        <span>.</span>os_tag <span>=</span> <span>.</span>macos<span>,</span>
</span><span>        <span>.</span>os_version_min <span>=</span> target<span>.</span>os_version_min<span>,</span>
</span><span>    <span>}</span><span>,</span>
</span><span>    <span>.</span>optimize <span>=</span> optimize<span>,</span>
</span><span><span>}</span><span>)</span><span>;</span>
</span><span>lib<span>.</span>bundle_compiler_rt <span>=</span> <span>true</span><span>;</span>
</span><span>lib<span>.</span><span>linkLibC</span><span>(</span><span>)</span><span>;</span>
</span><span>b<span>.</span>default_step<span>.</span><span>dependOn</span><span>(</span><span>&amp;</span>lib<span>.</span>step<span>)</span><span>;</span>
</span></code></pre></div>
<hr/>

<p>Static libraries do not also embed their static dependencies. For example,
if your Zig code linked to <a target="_blank" rel="noopener noreferrer" href="https://curl.se/">libcurl</a>, then any user of your
static library would still need to provide a static version of libcurl as well.</p>
<div><p><strong>Note: this is only required if you have non-Zig library dependencies.</strong>
If you&#39;re compiling all your code and dependencies into a single unit,
then this step is not necessary.</p></div>
<p>Since we&#39;re only building our static libraries to integrate with our GUI
and not as general purpose static libraries, let&#39;s go ahead and package
up all our dependencies as well. To do that, we have to use
<a target="_blank" rel="noopener noreferrer" href="https://www.unix.com/man-page/osx/1/LIBTOOL/"><code>libtool(1)</code></a>.</p>
<p>The <code>build.zig</code> code looks like this:</p>
<div><pre><code><span><span>var</span> lib_list <span>=</span> <span>...</span><span>;</span>
</span><span><span>try</span> lib_list<span>.</span><span>append</span><span>(</span><span>.</span><span>{</span> <span>.</span>generated <span>=</span> <span>&amp;</span>lib<span>.</span>output_path_source <span>}</span><span>)</span><span>;</span>
</span><span><span>const</span> libtool <span>=</span> LibtoolStep<span>.</span><span>create</span><span>(</span>b<span>,</span> <span>.</span><span>{</span>
</span><span>    <span>.</span>name <span>=</span> <span>&#34;ghostty&#34;</span><span>,</span>
</span><span>    <span>.</span>out_name <span>=</span> <span>&#34;libghostty-aarch64-bundle.a&#34;</span><span>,</span>
</span><span>    <span>.</span>sources <span>=</span> lib_list<span>.</span>items<span>,</span>
</span><span><span>}</span><span>)</span><span>;</span>
</span><span>libtool<span>.</span>step<span>.</span><span>dependOn</span><span>(</span><span>&amp;</span>lib<span>.</span>step<span>)</span><span>;</span>
</span><span>b<span>.</span>default_step<span>.</span><span>dependOn</span><span>(</span>libtool<span>.</span>step<span>)</span><span>;</span>
</span></code></pre></div>
<p>The <code>LibtoolStep</code> is a custom step I wrote and the
<a target="_blank" rel="noopener noreferrer" href="https://gist.github.com/mitchellh/0ee168fb34915e96159b558b89c9a74b#file-libtoolstep-zig">source can be found here</a>.
LibtoolStep requires a list of all the dependencies, which we build up in
<code>lib_list</code> (including adding our own library we just wrote). The result of
the libtool run is a &#34;bundled&#34; library which contains our library and
all of its dependencies.</p>
<hr/>

<p>macOS is still in the midst of its transition from Intel to Apple Silicon,
so we must build a library that works with both the <code>x86_64</code> and <code>aarch64</code>
architectures. Mac supports what they call &#34;Universal Binaries&#34; which
work on both systems by just copying the final machine code for both architectures
into one file.</p>
<p>To build a universal binary, we have to build the static library for each
specific architecture, then use the <a target="_blank" rel="noopener noreferrer" href="https://ss64.com/osx/lipo.html"><code>lipo</code> tool</a>
to merge them together.</p>
<p>In <code>build.zig</code>, that looks like this:</p>
<div><pre><code><span><span>const</span> static_lib_universal <span>=</span> LipoStep<span>.</span><span>create</span><span>(</span>b<span>,</span> <span>.</span><span>{</span>
</span><span>    <span>.</span>name <span>=</span> <span>&#34;ghostty&#34;</span><span>,</span>
</span><span>    <span>.</span>out_name <span>=</span> <span>&#34;libghostty.a&#34;</span><span>,</span>
</span><span>    <span>.</span>input_a <span>=</span> static_lib_aarch64<span>.</span>output<span>,</span>
</span><span>    <span>.</span>input_b <span>=</span> static_lib_x86_64<span>.</span>output<span>,</span>
</span><span><span>}</span><span>)</span><span>;</span>
</span><span>static_lib_universal<span>.</span>step<span>.</span><span>dependOn</span><span>(</span>static_lib_aarch64<span>.</span>step<span>)</span><span>;</span>
</span><span>static_lib_universal<span>.</span>step<span>.</span><span>dependOn</span><span>(</span>static_lib_x86_64<span>.</span>step<span>)</span><span>;</span>
</span></code></pre></div>
<p>The <code>LipoStep</code> is a custom step I wrote to call <code>lipo</code> and the
<a target="_blank" rel="noopener noreferrer" href="https://gist.github.com/mitchellh/0ee168fb34915e96159b558b89c9a74b#file-lipostep-zig">source can be found here</a>.
The <code>static_lib_aarch64</code> and <code>static_lib_x86_64</code> are the results of the
<code>addStaticLibrary</code> or <code>libtool</code> calls in the previous sections. The final result
is a universal library!</p>
<hr/>

<p>Finally, we need to build an <a target="_blank" rel="noopener noreferrer" href="https://developer.apple.com/documentation/xcode/creating-a-multi-platform-binary-framework-bundle"><code>xcframework</code> file</a>.
An <code>xcframework</code> is a single bundle that contains the library, headers,
and other associated files that XCode can use a single unit to easily
integrate libraries.</p>
<p>I&#39;m not going to explain xcframework files in detail. This blog post should
give you enough information for you to accurately Google search and find the
answers you need. This was the hardest part for me: just figuring out <em>what</em>
I needed to know. I&#39;m hoping this blog post gets you there!</p>
<p>I wrote a custom step for this too, <a target="_blank" rel="noopener noreferrer" href="https://gist.github.com/mitchellh/0ee168fb34915e96159b558b89c9a74b#file-xcframeworkstep-zig">called <code>XCFrameworkStep</code></a>.
In <code>build.zig</code> it looks like this:</p>
<div><pre><code><span><span>// The xcframework wraps our ghostty library so that we can link</span>
</span><span><span>// it to the final app built with Swift.</span>
</span><span><span>const</span> xcframework <span>=</span> XCFrameworkStep<span>.</span><span>create</span><span>(</span>b<span>,</span> <span>.</span><span>{</span>
</span><span>    <span>.</span>name <span>=</span> <span>&#34;GhosttyKit&#34;</span><span>,</span>
</span><span>    <span>.</span>out_path <span>=</span> <span>&#34;macos/GhosttyKit.xcframework&#34;</span><span>,</span>
</span><span>    <span>.</span>library <span>=</span> static_lib_universal<span>.</span>output<span>,</span>
</span><span>    <span>.</span>headers <span>=</span> <span>.</span><span>{</span> <span>.</span>path <span>=</span> <span>&#34;include&#34;</span> <span>}</span><span>,</span>
</span><span><span>}</span><span>)</span><span>;</span>
</span><span>xcframework<span>.</span>step<span>.</span><span>dependOn</span><span>(</span>static_lib_universal<span>.</span>step<span>)</span><span>;</span>
</span><span>b<span>.</span>default_step<span>.</span><span>dependOn</span><span>(</span>xcframework<span>.</span>step<span>)</span><span>;</span>
</span></code></pre></div>
<p>This step takes our final library output along with a path to our
headers directory (that has the <code>ghostty.h</code> file) and builds our
xcframework.</p>
<p><strong>IMPORTANT: You need a modulemap.</strong> You need to create a <code>module.modulemap</code>
file in your <code>include</code> directory. This is used by XCode with the xcframework
file to properly build your library. Put the <code>module.modulemap</code> file alongside
your C header:</p>
<div><pre><code><span><span>// This makes Ghostty available to the XCode build for the macOS app.</span>
</span><span><span>// We append &#34;Kit&#34; to it not to be cute, but because targets have to have</span>
</span><span><span>// unique names and we use Ghostty for other things.</span>
</span><span>module GhosttyKit <span>{</span>
</span><span>    umbrella header <span>&#34;ghostty.h&#34;</span>
</span><span>    export <span>*</span>
</span><span><span>}</span>
</span></code></pre></div>
<hr/>

<p>Our library is finally ready to be used by XCode. This step is thankfully
very easy: just drag and drop the built xcframework file into the &#34;Frameworks&#34;
section of your XCode project and select &#34;Do Not Embed&#34; as the embedding
option. That&#39;s it, your Swift code can now import it:</p>
<div><pre><code><span><span>import</span> <span>SwiftUI</span>
</span><span><span>import</span> <span>GhosttyKit</span>
</span><span>
</span><span><span>@main</span>
</span><span><span>struct</span> <span>GhosttyApp</span><span>:</span> <span>App</span> <span>{</span>
</span><span>    <span>var</span> body<span>:</span> <span>some</span> <span>Scene</span> <span>{</span> <span>...</span> <span>}</span>
</span><span><span>}</span>
</span></code></pre></div>
<p>The <code>import</code> name must match the name in your modulemap (previous section).
After you import, autocomplete will have all of your functions and types
from your header file, and they&#39;ll be automatically converted to Swift types
(the types they use for bridging to C).</p>
<p>At this point, you&#39;ll probably run into some challenges around C numeric types,
C booleans, C pointers, etc. and interoperating with Swift. But these are
all very Google-able problems.</p>
<hr/>

<p>I admit, there are a lot of concepts to get to the promised land with this
idea: exporting a C API, building a static lib, libtooling dependencies,
lipoing for universal binaries, generating an xcframework, writing a
C header and modulemap file, then importing it into your XCode project.</p>
<p>But, each of these steps isn&#39;t doing anything cutting edge or esoteric.
All of the steps are tried and true -- usually decades-old -- operations
and tools for working with system libraries. They&#39;re unlikely to to be
brittle going forward.</p>
<p>For my terminal application, I&#39;ve used this technique for a little over a year
including over one major macOS update so far, and nothing broke at all.
Going forward, I don&#39;t expect things to break, either.</p>
<p>And I think the payoff is worth it: you can get a truly native GUI
experience while keeping almost all of your application logic cross-platform.
To repeat from the introduction: for my application 94% of my code is
in Zig and is used cross-platform, and only 4% is platform-specific GUI
code for macOS. Admittedly, a terminal emulator doesn&#39;t have <em>that</em> much
GUI interactions, but that implements native tabs, splits, preference pane,
etc.</p>
<p>I know that this blog post doesn&#39;t have a turnkey, copy-and-paste solution
to integrating Zig with SwiftUI, but I hope it gives you the knowledge basis
necessary to follow this pattern.</p>
<hr/>

<p>One approach on macOS is to go lower level and try to use Objective-C
directly to interact with the system libraries such as AppKit or Foundation.
Objective-C has a native C API so most programming languages can interact
with it directly. I took this approach first, but I don&#39;t think its practically viable.</p>
<p>The major issue is that it is painfully clear that the future of Apple
device programming is Swift. While some core libraries are available in
ObjC, a majority of modern integrations <em>require</em> Swift to some extent
(or jumping through some absolutely-not-worth-it hoops to make something work).</p>
<p>A lot of this comes down to convenience: the <em>convenient</em> GUI integrations are
in Swift nowadays (such as SwiftUI). But sometimes, it comes down to actual
functionality. For example, if you want to integrate with the
<a target="_blank" rel="noopener noreferrer" href="https://support.apple.com/guide/iphone/view-activities-in-the-dynamic-island-iph28f50d10d/ios">iPhone Dynamic Island</a>,
you have to export a SwiftUI view as far as I know. I&#39;m sure there is some
cursed way to use pure UIKit but... you&#39;d be really fighting what Apple
<em>wants</em> you to do.</p></div></div>
  </body>
</html>
