<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.twitter.com/engineering/en_us/topics/open-source/2023/twitter-recommendation-algorithm">Original</a>
    <h1>The Twitter Algorithm</h1>
    
    <div id="readability-page-1" class="page"><div><p>Twitter aims to deliver you the best of what’s happening in the world right now. This requires a recommendation algorithm to distill the roughly 500 million Tweets posted daily down to a handful of top Tweets that ultimately show up on your device’s <b>For You</b> timeline. This blog is an introduction to how the algorithm selects Tweets for your timeline.</p> 
<p>Our recommendation system is composed of many interconnected services and jobs, which we will detail in this post. While there are many areas of the app where Tweets are recommended—Search, Explore, Ads—this post will focus on the home timeline’s For You feed.</p> 
<h2>How do we choose Tweets?</h2> 
<p>The foundation of Twitter’s recommendations is a set of core models and features that extract latent information from Tweet, user, and engagement data. These models aim to answer important questions about the Twitter network, such as, <i>“What is the probability you will interact with another user in the future?”</i> or, <i>“What are the communities on Twitter and what are trending Tweets within them?”</i> Answering these questions accurately enables Twitter to deliver more relevant recommendations.</p> 
<p>The recommendation pipeline is made up of three main stages that consume these features: </p> 
<ol> 
 <li>Fetch the best Tweets from different recommendation sources in a process called <b>candidate sourcing</b>.</li> 
 <li><b>Rank</b> each Tweet using a machine learning model.</li> 
 <li>Apply<b> heuristics and filters</b>, such as filtering out Tweets from users you’ve blocked, NSFW content, and Tweets you’ve already seen.</li> 
</ol> 
<p>The service that is responsible for constructing and serving the For You timeline is called Home Mixer. Home Mixer is built on Product Mixer, our custom Scala framework that facilitates building feeds of content. This service acts as the software backbone that connects different candidate sources, scoring functions, heuristics, and filters.</p> 
<p>This diagram below illustrates the major components used to construct a timeline:</p>

<p>This Tweet is unavailable</p>
<div>
  

<div>
  
  
  <div>
    <div>
      <div>
        <header>
          
        </header>
        <p>
          This Tweet is unavailable.
        </p>
      </div>
    </div>
  </div>
</div>

</div>
</div><div><p>Let’s explore the key parts of this system, roughly in the order they’d be called during a single timeline request, starting with retrieving candidates from <b>Candidate Sources</b>.</p> 
<h2>Candidate Sources</h2> 
<p>Twitter has several Candidate Sources that we use to retrieve recent and relevant Tweets for a user. For each request, we attempt to extract the best 1500 Tweets from a pool of hundreds of millions through these sources. We find candidates from people you follow (<b>In-Network</b>) and from people you don’t follow (<b>Out-of-Network</b>). Today, the For You timeline consists of 50% In-Network Tweets and 50% Out-of-Network Tweets on average, though this may vary from user to user.</p> 
<h3>In-Network Source</h3> 
<p>The In-Network source is the largest candidate source and aims to deliver the most relevant, recent Tweets from users you follow. It efficiently ranks Tweets of those you follow based on their relevance using a logistic regression model. The top Tweets are then sent to the next stage.</p> 
<p>The most important component in ranking In-Network Tweets is <a href="https://www.ueo-workshop.com/wp-content/uploads/2014/04/sig-alternate.pdf">Real Graph</a>. Real Graph is a model which predicts the likelihood of engagement between two users. The higher the Real Graph score between you and the author of the Tweet, the more of their tweets we&#39;ll include.</p> 
<p>The In-Network source has been the subject of recent work at Twitter. We recently stopped using Fanout Service, a 12-year old service that was previously used to provide In-Network Tweets from a cache of Tweets for each user. We’re also in the process of redesigning the logistic regression ranking model which was last updated and trained several years ago!</p> 
<h3>Out-of-Network Sources</h3> 
<p>Finding relevant Tweets outside of a user’s network is a trickier problem: <i>How can we tell if a certain Tweet will be relevant to you if you don’t follow the author?</i> Twitter takes two approaches to addressing this.</p> 
<h4>Social Graph</h4> 
<p>Our first approach is to estimate what you would find relevant by analyzing the engagements of people you follow or those with similar interests.</p> 
<p>We traverse the graph of engagements and follows to answer the following questions:</p> 
<ul> 
 <li><i>What Tweets did the people I follow recently engage with?</i></li> 
 <li><i>Who likes similar Tweets to me, and what else have they recently liked?</i></li> 
</ul> 
<p>We generate candidate Tweets based on the answers to these questions and rank the resulting Tweets using a logistic regression model. Graph traversals of this type are essential to our Out-of-Network recommendations; we developed <a href="https://www.vldb.org/pvldb/vol9/p1281-sharma.pdf">GraphJet</a>, a graph processing engine that maintains a real-time interaction graph between users and Tweets, to execute these traversals. While such heuristics for searching the Twitter engagement and follow network have proven useful (these currently serve about 15% of Home Timeline Tweets), embedding space approaches have become the larger source of Out-of-Network Tweets.</p> 
<h4>Embedding Spaces</h4> 
<p>Embedding space approaches aim to answer a more general question about content similarity: <i>What Tweets and Users are similar to my interests?</i></p> 
<p>Embeddings work by generating numerical representations of users’ interests and Tweets’ content. We can then calculate the similarity between any two users, Tweets or user-Tweet pairs in this embedding space. Provided we generate accurate embeddings, we can use this similarity as a stand-in for relevance.</p> 
<p>One of Twitter’s most useful embedding spaces is <a href="https://dl.acm.org/doi/10.1145/3394486.3403370">SimClusters</a>. SimClusters discover communities anchored by a cluster of influential users using a <a href="https://github.com/twitter/sbf">custom matrix factorization algorithm</a>. There are 145k communities, which are updated every three weeks. Users and Tweets are represented in the space of communities, and can belong to multiple communities. Communities range in size from a few thousand users for individual friend groups, to hundreds of millions of users for news or pop culture. These are some of the biggest communities:</p>

<p>This Tweet is unavailable</p>
<div>
  

<div>
  
  
  <div>
    <div>
      <div>
        <header>
          
        </header>
        <p>
          This Tweet is unavailable.
        </p>
      </div>
    </div>
  </div>
</div>

</div>
</div><div><p>We can embed Tweets into these communities by looking at the current popularity of a Tweet in each community. The more that users from a community like a Tweet, the more that Tweet will be associated with that community.</p> 
<h2>Ranking</h2> 
<p>The goal of the For You timeline is to serve you relevant Tweets. At this point in the pipeline, we have ~1500 candidates that may be relevant. Scoring directly predicts the relevance of each candidate Tweet and is the primary signal for ranking Tweets on your timeline. At this stage, all candidates are treated equally, without regard for what candidate source it originated from.</p> 
<p>Ranking is achieved with a ~48M parameter neural network that is continuously trained on Tweet interactions to optimize for positive engagement (e.g. Likes, Retweets, and Replies). This ranking mechanism takes into account thousands of features and outputs ten labels to give each Tweet a score, where each label represents the probability of an engagement. We rank the Tweets from these scores. </p> 
<h2>Heuristics, Filters, and Product Features</h2> 
<p>After the Ranking stage, we apply heuristics and filters to implement various product features. These features work together to create a balanced and diverse feed. Some examples include:</p> 
<ul> 
 <li><b>Visibility Filtering</b>: Filter out Tweets based on their content and your preferences. For instance, remove Tweets from accounts you block or mute.  </li> 
 <li><b>Author Diversity</b>: Avoid too many consecutive Tweets from a single author.</li> 
 <li><b>Content Balance</b>: Ensure we are delivering a fair balance of In-Network and Out-of-Network Tweets.</li> 
 <li><b>Feedback-based Fatigue</b>: Lower the score of certain Tweets if the viewer has provided negative feedback around it.</li> 
 <li><b>Social Proof</b>: Exclude Out-of-Network Tweets without a second degree connection to the Tweet as a quality safeguard. In other words, ensure someone you follow engaged with the Tweet or follows the Tweet’s author.</li> 
 <li><b>Conversations</b>: Provide more context to a Reply by threading it together with the original Tweet.</li> 
 <li><b>Edited Tweets</b>: Determine if the Tweets currently on a device are stale, and send instructions to replace them with the edited versions.</li> 
</ul> 
<h2>Mixing and Serving</h2> 
<p>At this point, Home Mixer has a set of Tweets ready to send to your device. As the last step in the process, the system blends together Tweets with other non-Tweet content like Ads, Follow Recommendations, and Onboarding prompts, which are returned to your device to display. </p> 
<p>The pipeline above runs approximately 5 billion times per day and completes in under 1.5 seconds on average. A single pipeline execution requires 220 seconds of CPU time, nearly 150x the latency you perceive on the app.</p>

<p>This Tweet is unavailable</p>
<div>
  

<div>
  
  
  <div>
    <div>
      <div>
        <header>
          
        </header>
        <p>
          This Tweet is unavailable.
        </p>
      </div>
    </div>
  </div>
</div>

</div>
</div><div><p>The goal of our open source endeavor is to provide full transparency to you, our users, about how our systems work. We’ve released the code powering our recommendations that you can view <a href="https://github.com/twitter/the-algorithm">here</a> (and <a href="https://github.com/twitter/the-algorithm-ml">here</a>) to understand our algorithm in greater detail, and we are also working on several features to provide you greater transparency within our app. Some of the new developments we have planned include: </p> 
<ul> 
 <li>A better Twitter analytics platform for creators with more information on reach and engagement</li> 
 <li>Greater transparency into any safety labels applied to your Tweets or accounts</li> 
 <li>Greater visibility into why Tweets appear on your timeline</li> 
</ul> 
<h2>What’s Next?</h2> 
<p>Twitter is the center of conversations around the world. Every day, we serve over 150 billion Tweets to people’s devices. Ensuring that we’re delivering the best content possible to our users is both a challenging and an exciting problem. We’re working on new opportunities to expand our recommendation systems—new real-time features, embeddings, and user representations—and we have one of the most interesting datasets and user bases in the world to do it with. We are building the town square of the future. If this interests you, please consider <a href="mailto:careers@twitter.com">joining us</a>.</p> 
<p><i>Written by the Twitter Team.</i></p>

<p>This Tweet is unavailable</p>
<div>
  

<div>
  
  
  <div>
    <div>
      <div>
        <header>
          
        </header>
        <p>
          This Tweet is unavailable.
        </p>
      </div>
    </div>
  </div>
</div>

</div>
</div></div>
  </body>
</html>
