<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://josephmate.github.io/2025-02-26-3200p-cpu-util/">Original</a>
    <h1>3,200% CPU Utilization</h1>
    
    <div id="readability-page-1" class="page"><div>
  <div>
    <div>

      

      

      <article role="main">
        <p>A while back my machine was so messed up that I could barely ssh onto it.
3,200% CPU utilization - all 32 cores on the host were fully utilized!
<a href="https://josephmate.github.io/2021-10-03-my-bug-used-up-100cpu-or-did-it/">Compare that to my last bug where it only used 1 core, 100%</a></p>

<p>Fortunately, it was using Java 17 runtime which had thread dumps with CPU time!
Sorting by CPU time brought a bunch of threads that looked similar to this:</p>

<div><div><pre><code>&#34;Thread-0&#34; #22 [14700] prio=5 os_prio=0 cpu=10359.38ms elapsed=11.49s tid=0x000001cdc35aaf60 nid=14700 runnable  [0x00000047cfffe000]
   java.lang.Thread.State: RUNNABLE
	at java.util.TreeMap.put(java.base@17.0.1/TreeMap.java:826)
	at java.util.TreeMap.put(java.base@17.0.1/TreeMap.java:534)
	at BusinessLogic.someFunction(BusinessLogic.java:29)
    ...
</code></pre></div></div>

<p>I make a quick conclusion about this and thought to look at BusinessLogic:29 based
on the stack trace and it looked like this:</p>

<div><div><pre><code><span>public</span> <span>void</span> <span>someFunction</span><span>(</span><span>SomeType</span> <span>relatedObject</span><span>,</span> <span>List</span><span>&lt;</span><span>SomeOtherType</span><span>&gt;</span> <span>unrelatedObjects</span><span>)</span> <span>{</span>
  <span>...</span>
  <span>for</span> <span>(</span><span>SomeOtherType</span> <span>unrelatedObject</span> <span>:</span> <span>unrelatedObjects</span><span>)</span> <span>{</span>
    <span>treeMap</span><span>.</span><span>put</span><span>(</span><span>relatedObject</span><span>.</span><span>a</span><span>(),</span> <span>relatedObject</span><span>.</span><span>b</span><span>());</span> <span>// line 29</span>
  <span>}</span>
  <span>...</span>
<span>}</span>
</code></pre></div></div>

<p>That code is odd.
Notice we’re iterating over <code>unrelatedObject</code>, but the body of the loop only used <code>relatedObject</code>.
The code can be reduced to simply:</p>
<div><div><pre><code><span>public</span> <span>void</span> <span>someFunction</span><span>(</span><span>SomeType</span> <span>relatedObject</span><span>,</span> <span>List</span><span>&lt;</span><span>SomeOtherType</span><span>&gt;</span> <span>unrelatedObjects</span><span>)</span> <span>{</span>
  <span>...</span>
  <span>treeMap</span><span>.</span><span>put</span><span>(</span><span>relatedObject</span><span>.</span><span>a</span><span>(),</span> <span>relatedObject</span><span>.</span><span>b</span><span>());</span>
  <span>...</span>
  <span>// unrelatedObjects is used later on in the function so the parameter cannot be removed</span>
<span>}</span>
</code></pre></div></div>

<p>There must have been some refactoring in the area and unrelatedObject wasn’t used anymore. 
I prepared my unit test and ran the test before and after the fix.
I tried <code>treeMap</code> and <code>unrelatedObjects</code> with 1,000,000 entries, well exceeding what the application ever saw and was not able to reproduce the problem.
Assuming unrelatedObjects is size N and treeMap is size M, the complexity is O(N lg(M)).
So it makes sense that I was unable to reproduce the problem.
<a href="https://josephmate.github.io/PowersOf2/">You wouldn’t really see one minute of execution time until 100 million to 1 billion entries.</a>.</p>

<p>It must be something else.
I was certain treeMap and unrelatedObjects never exceed 1,000 entries.
It’s not even close enough to cause an issue with an O(N lg(M)) algorithm.</p>

<p>I wasn’t very familiar with the class so I started to look around,
focusing on <code>treeMap</code> and <code>unrelatedObjects</code> to see if my assumption that they
never exceed 1,000 holds. Could they be in the millions or even billions?</p>

<p>Then I noticed the definition of the TreeMap as :</p>
<div><div><pre><code><span>// The field wasn&#39;t actually named treeMap.</span>
<span>private</span> <span>final</span> <span>Map</span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>&gt;</span> <span>treeMap</span> <span>=</span> <span>new</span> <span>TreeMap</span><span>&lt;&gt;();</span>
</code></pre></div></div>

<p>That’s scary.
There were multiple threads accessing the TreeMap, and it was unguarded.
At this point, I had an aha moment.
Could an unguarded TreeMap cause 3,200% utilization?</p>



<p>I put together a simple experiment to try to reproduce the problem.
I created a bunch of threads randomly updating a shared TreeMap.</p>
<div><div><pre><code><span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>numThreads</span><span>;</span> <span>i</span><span>++)</span> <span>{</span>
    <span>threads</span><span>.</span><span>add</span><span>(</span><span>new</span> <span>Thread</span><span>(()</span> <span>-&gt;</span> <span>{</span>
        <span>Random</span> <span>random</span> <span>=</span> <span>new</span> <span>Random</span><span>();</span>
        <span>for</span><span>(</span><span>int</span> <span>j</span> <span>=</span> <span>0</span><span>;</span> <span>j</span> <span>&lt;</span> <span>numUpdates</span><span>;</span> <span>j</span><span>++)</span> <span>{</span>
            <span>try</span> <span>{</span>
                <span>treeMap</span><span>.</span><span>put</span><span>(</span><span>random</span><span>.</span><span>nextInt</span><span>(</span><span>1000</span><span>),</span> <span>random</span><span>.</span><span>nextInt</span><span>(</span><span>1000</span><span>));</span>
            <span>}</span> <span>catch</span> <span>(</span><span>NullPointerException</span> <span>e</span><span>)</span> <span>{</span>
                <span>// let it keep going so we can reproduce the issue.</span>
            <span>}</span>
        <span>}</span>
    <span>}));</span>
<span>}</span>
</code></pre></div></div>

<p>That try catch was key.
If no try catch, I wasn’t able to reproduce the problem.
Some threads would crash with the above output:</p>
<div><div><pre><code>Exception in thread &#34;Thread-0&#34; java.lang.NullPointerException: Cannot read field &#34;right&#34; because &#34;l&#34; is null
        at java.base/java.util.TreeMap.rotateRight(TreeMap.java:2562)
        at java.base/java.util.TreeMap.fixAfterInsertion(TreeMap.java:2594)
        at java.base/java.util.TreeMap.addEntry(TreeMap.java:770)
        at java.base/java.util.TreeMap.put(TreeMap.java:828)
        at java.base/java.util.TreeMap.put(TreeMap.java:534)
        at SimpleRepro.lambda$main$0(SimpleRepro.java:28)
        at java.base/java.lang.Thread.run(Thread.java:833)
</code></pre></div></div>
<p>but the program would still halt.</p>

<p>Probably only languages that allow you to catch NPEs will encounter this issue.
Other languages will just crash.
After a few runs, I saw 500% cpu utilization.
That’s crazy!
I always thought of race conditions as corrupting the data or deadlocking.
I never though it could cause performance issues.
But it makes sense, you could corrupt the data in a way that creates an infinite loop.</p>

<p>You can check out the java experiment from my GitHub java-by-experiments repo
<a href="https://github.com/josephmate/java-by-experiments/blob/main/tree_map_corruption/java/src/main/java/SimpleRepro.java">SimpleRepro.java</a></p>

<p>To make extra sure, I created another experiment that uses reflection
against the TreeMap to dump the nodes and their colours.
(In Java, a TreeMap is implemented using a Red-Black tree.)
The cycle in the TreeMap is highlighted in blue.
<img src="https://owentrueblood.com/assets/2023-08-20_cpu_util_3200/red_black_tree_cycle.gv.svg" alt="example cycle generated from TreeMap experiment"/></p>

<p>So if you’re searching or putting something not already in the map,
it could get stuck in that infinite loop.</p>

<p>To reproduce the above graph you need to use reflection to access the root, 
and the left and right fields of the <code>TreeMap.Entry</code>.
You recursively traverse the <code>TreeMap.Entry</code>s starting from root, keeping
track of the Entries you visited.
If you visit an entry you already visited, you know you’ve hit a loop.
Print all the nodes from visited to show the cycle.</p>
<div><div><pre><code><span>private</span> <span>final</span> <span>TreeMap</span><span>&lt;</span><span>Integer</span><span>,</span><span>Integer</span><span>&gt;</span> <span>treeMap</span><span>;</span>
<span>private</span> <span>static</span> <span>final</span> <span>Field</span> <span>treeMapRootField</span><span>;</span>
<span>private</span> <span>static</span> <span>final</span> <span>Field</span> <span>treeMapEntryLeft</span><span>;</span>
<span>private</span> <span>static</span> <span>final</span> <span>Field</span> <span>treeMapEntryRight</span><span>;</span>
<span>private</span> <span>static</span> <span>final</span> <span>Field</span> <span>treeMapEntryKey</span><span>;</span>
<span>private</span> <span>static</span> <span>final</span> <span>Field</span> <span>treeMapEntryColor</span><span>;</span>

<span>...</span>

<span>public</span> <span>void</span> <span>print</span><span>()</span> <span>throws</span> <span>Exception</span> <span>{</span>
    <span>print</span><span>(</span><span>treeMapRootField</span><span>.</span><span>get</span><span>(</span><span>treeMap</span><span>),</span> <span>&#34;&#34;</span><span>,</span> <span>new</span> <span>IdentityHashMap</span><span>&lt;&gt;());</span>
<span>}</span>

<span>private</span> <span>void</span> <span>print</span><span>(</span>
    <span>Object</span> <span>treeMapEntry</span><span>,</span> <span>String</span> <span>tabs</span><span>,</span> <span>IdentityHashMap</span><span>&lt;</span><span>Object</span><span>,</span> <span>Object</span><span>&gt;</span> <span>visited</span>
<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
    <span>if</span> <span>(</span><span>treeMapEntry</span> <span>!=</span> <span>null</span> <span>&amp;&amp;</span> <span>!</span><span>visited</span><span>.</span><span>containsKey</span><span>(</span><span>treeMapEntry</span><span>))</span> <span>{</span>
        <span>// in order traversal</span>
        <span>visited</span><span>.</span><span>put</span><span>(</span><span>treeMapEntry</span><span>,</span> <span>treeMapEntry</span><span>);</span>
        <span>print</span><span>(</span><span>treeMapEntryLeft</span><span>.</span><span>get</span><span>(</span><span>treeMapEntry</span><span>),</span> <span>tabs</span> <span>+</span> <span>&#34;  &#34;</span><span>,</span> <span>visited</span><span>);</span>
        <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>tabs</span> <span>+</span> <span>treeMapEntryKey</span><span>.</span><span>get</span><span>(</span><span>treeMapEntry</span><span>)</span> <span>+</span> <span>&#34;:&#34;</span>
            <span>+</span> <span>(</span><span>treeMapEntryColor</span><span>.</span><span>getBoolean</span><span>(</span><span>treeMapEntry</span><span>)</span> <span>?</span> <span>&#34;BLACK&#34;</span> <span>:</span> <span>&#34;RED&#34;</span><span>));</span>
        <span>print</span><span>(</span><span>treeMapEntryRight</span><span>.</span><span>get</span><span>(</span><span>treeMapEntry</span><span>),</span> <span>tabs</span> <span>+</span> <span>&#34;  &#34;</span><span>,</span> <span>visited</span><span>);</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>treeMapEntry</span> <span>!=</span> <span>null</span> <span>&amp;&amp;</span> <span>visited</span><span>.</span><span>containsKey</span><span>(</span><span>treeMapEntry</span><span>))</span> <span>{</span>
        <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>tabs</span> <span>+</span> <span>treeMapEntryKey</span><span>.</span><span>get</span><span>(</span><span>treeMapEntry</span><span>)</span>  <span>+</span> <span>&#34;:&#34;</span>
            <span>+</span> <span>(</span><span>treeMapEntryColor</span><span>.</span><span>getBoolean</span><span>(</span><span>treeMapEntry</span><span>)</span> <span>?</span> <span>&#34;BLACK&#34;</span> <span>:</span> <span>&#34;RED&#34;</span><span>)</span>
            <span>+</span> <span>&#34; CYCLE&#34;</span>
        <span>);</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>Working code is available in my java-by-experiments GitHub project
<a href="https://github.com/josephmate/java-by-experiments/blob/main/tree_map_corruption/java/src/main/java/ExploringTreeMap.java">ExploringTreeMap.java</a>
and
<a href="https://github.com/josephmate/java-by-experiments/blob/main/tree_map_corruption/java/src/main/java/TreeMapExplorer.java">TreeMapExplorer.java</a></p>



<p>I’m not the first person to write about this issue.
While preparing this article I found:</p>

<ul>
  <li>Ivo Anjo wrote: <a href="https://ivoanjo.me/blog/2018/07/21/writing-to-a-java-treemap-concurrently-can-lead-to-an-infinite-loop-during-reads/">writing to a java treemap concurrently can lead to an infinite loop during reads</a></li>
  <li>Red Hat has a troubleshooting article: <a href="https://access.redhat.com/solutions/58008">High CPU due to multiple Java threads accessing TreeMap simultaneously</a>
    <ul>
      <li>Originally reported as far back as June 20 2011 based on <a href="https://web.archive.org/web/20190715204100/https://access.redhat.com/solutions/58008">web archive</a></li>
    </ul>
  </li>
  <li>There is even a Stack Overflow question about it: <a href="https://stackoverflow.com/questions/56234865/java-process-consumes-more-than-100-cpu">Java Process consumes more than 100% CPU</a></li>
</ul>

<p>However, this article provides a few new perspectives not previously discussed:</p>

<ol>
  <li>Practical code that that reproduces the issue.</li>
  <li>Proposing that only a particular class of languages can encounter this issue
and exploring that hypothesis</li>
  <li>A survey of languages to see if all can reproduce the issue</li>
  <li>A new approach to fixing TreeMap and red black tree to prevent this issue</li>
</ol>

<p>If any of these interest you, please keep reading.</p>



<p>Some might claim that my experimental code is unrealistic.
Who ignores NPEs?
There are two practical ways: uncaught exceptions in executors and services backed by a thread pool.</p>

<h2 id="uncaught-exceptions-in-executor">Uncaught Exceptions in Executor</h2>

<p>We could reproduce this problem in conjunction with another common mistake that suppresses uncaught exceptions.</p>

<p>The below code also reproduces the issue, but with a thread pool.</p>
<div><div><pre><code><span>final</span> <span>ExecutorService</span> <span>pool</span> <span>=</span> <span>Executors</span><span>.</span><span>newFixedThreadPool</span><span>(</span><span>numThreads</span><span>);</span>
<span>final</span> <span>TreeMap</span><span>&lt;</span><span>Integer</span><span>,</span><span>Integer</span><span>&gt;</span> <span>treeMap</span> <span>=</span> <span>new</span> <span>TreeMap</span><span>&lt;&gt;();</span>

<span>Random</span> <span>random</span> <span>=</span> <span>new</span> <span>Random</span><span>();</span>
<span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>numThreads</span><span>*</span><span>numUpdatesPerThread</span><span>;</span> <span>i</span><span>++)</span> <span>{</span>
    <span>pool</span><span>.</span><span>submit</span><span>(</span> <span>()</span> <span>-&gt;</span> <span>{</span>
        <span>treeMap</span><span>.</span><span>put</span><span>(</span><span>random</span><span>.</span><span>nextInt</span><span>(</span><span>10000</span><span>),</span> <span>random</span><span>.</span><span>nextInt</span><span>(</span><span>10000</span><span>));</span>
    <span>});</span>
<span>}</span>

<span>pool</span><span>.</span><span>shutdown</span><span>();</span>
<span>pool</span><span>.</span><span>awaitTermination</span><span>(</span><span>1</span><span>,</span> <span>TimeUnit</span><span>.</span><span>DAYS</span><span>);</span>
</code></pre></div></div>
<p>snippet from <a href="https://github.com/josephmate/java-by-experiments/tree/main/tree_map_corruption/java/src/main/java/ExecutorUncaughtRepro.java">ExecutorUncaughtRepro.java</a></p>

<p>When you run it, you’ll see it hang.
Take a thread dump and see the same symptoms:</p>
<div><div><pre><code>&#34;pool-1-thread-1&#34; #22 [15356] prio=5 os_prio=0 cpu=17734.38ms elapsed=21.39s tid=0x0000023c45dd3e90 nid=15356 runnable  [0x000000780b4fe000]
   java.lang.Thread.State: RUNNABLE
	at java.util.TreeMap.put(java.base@19.0.1/TreeMap.java:826)
	at java.util.TreeMap.put(java.base@19.0.1/TreeMap.java:534)
	at ExecutorUncaughtRepro.lambda$main$0(ExecutorUncaughtRepro.java:33)
	at ExecutorUncaughtRepro$$Lambda$14/0x00000008010031f0.run(Unknown Source)
	at java.util.concurrent.Executors$RunnableAdapter.call(java.base@19.0.1/Executors.java:577)
	at java.util.concurrent.FutureTask.run(java.base@19.0.1/FutureTask.java:317)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@19.0.1/ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@19.0.1/ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(java.base@19.0.1/Thread.java:1589)

</code></pre></div></div>
<p>It’s stuck on the TreeMap and really high CPU utilization.</p>

<p>However, when looking at standard out there is nothing!
The thread pool swallowed all the NPEs not giving any indication of problem. 
Unfortunately, this was the case in my situation.</p>

<p>When managing your own thread pools, you need to make sure you:</p>
<ol>
  <li>Register an uncaught exception handler on the thread through a thread factory</li>
  <li>Operate on the futures it return. If you do <code>future.get()</code> you will get an <code>ExectionException</code> wrapping the NPE!</li>
</ol>

<h2 id="again-with-grpc">Again with gRPC</h2>

<p>Another way is to have some sort of service back by a thread pool like a gRPC service.
Here I recreate a realistic scenario in gRPC that reproduces the problem.
The service is powered by an unguarded TreeMap.</p>

<div><div><pre><code><span>@Override</span>
<span>public</span> <span>void</span> <span>addReceipt</span><span>(</span>
    <span>ReceiptProcessorServiceOuterClass</span><span>.</span><span>AddReceiptRequest</span> <span>req</span><span>,</span>
    <span>StreamObserver</span><span>&lt;</span><span>ReceiptProcessorServiceOuterClass</span><span>.</span><span>AddReceiptResponse</span><span>&gt;</span> <span>responseObserver</span>
<span>)</span> <span>{</span>
    <span>int</span> <span>timestamp</span> <span>=</span> <span>req</span><span>.</span><span>getTimestamp</span><span>();</span>
    <span>int</span> <span>totalPrice</span> <span>=</span> <span>req</span><span>.</span><span>getTotalPrice</span><span>();</span>
    <span>receipts</span><span>.</span><span>put</span><span>(</span><span>timestamp</span><span>,</span> <span>totalPrice</span><span>);</span>
    <span>ReceiptProcessorServiceOuterClass</span><span>.</span><span>AddReceiptResponse</span> <span>response</span> <span>=</span> <span>ReceiptProcessorServiceOuterClass</span><span>.</span><span>AddReceiptResponse</span><span>.</span><span>newBuilder</span><span>().</span><span>build</span><span>();</span>
    <span>responseObserver</span><span>.</span><span>onNext</span><span>(</span><span>response</span><span>);</span>
    <span>responseObserver</span><span>.</span><span>onCompleted</span><span>();</span>
<span>}</span>
</code></pre></div></div>
<p>snippet from <a href="https://github.com/josephmate/java-by-experiments/blob/main/tree_map_corruption/java/src/main/java/GrpcRepro.java">GrpcRepro.java</a></p>

<p>Dumping the threads gives us:</p>
<div><div><pre><code>&#34;grpc-default-executor-23&#34; #54 [8796] daemon prio=5 os_prio=0 cpu=18671.88ms elapsed=175.50s tid=0x00000168b6c707c0 nid=8796 runnable  [0x000000059fbfe000]
   java.lang.Thread.State: RUNNABLE
	at java.util.TreeMap.put(java.base@19.0.1/TreeMap.java:826)
	at java.util.TreeMap.put(java.base@19.0.1/TreeMap.java:534)
	at ReceiptProcessorServiceImpl.addReceipt(GrpcRepro.java:59)
	at ReceiptProcessorServiceGrpc$MethodHandlers.invoke(ReceiptProcessorServiceGrpc.java:185)
	at io.grpc.stub.ServerCalls$UnaryServerCallHandler$UnaryServerCallListener.onHalfClose(ServerCalls.java:182)
	at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.halfClosed(ServerCallImpl.java:346)
	at io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1HalfClosed.runInContext(ServerImpl.java:860)
	at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37)
	at io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:133)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@19.0.1/ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@19.0.1/ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(java.base@19.0.1/Thread.java:1589)
</code></pre></div></div>
<p>showing that TreeMap.put() got stuck on an infinite loop.</p>



<p>My suspicion is that two threads independently rotate the tree 
in opposite directions, resulting in a cycle.
Or maybe, two overlaping rotations interleave their writes in a way that produces the
cycle.
However, I do not have proof of an interleaving between threads that shows this.</p>

<p>I also suspect that the NPE is necessary.
The problem will not reproduce without hitting an NPE as I saw with my Java experiments.</p>



<p>I explore this idea that only languages with NPEs can exhibit this problem by
trying to reproduce this problem in as many languages as I’ve programmed in
before.
If this claim is true, I expect it to only reproduce in
Java, Kotlin, C#, Ruby, Typescript, and Python.
I expect to not be able to reproduce the problem in Go, C++, Rust, and Elixir.</p>

<table>
  <thead>
    <tr>
      <th>Language</th>
      <th>Affected</th>
      <th>Explanation</th>
      <th>Code</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Java</td>
      <td>yes</td>
      <td>this whole article is based on this</td>
      <td><a href="https://github.com/josephmate/java-by-experiments/tree/main/tree_map_corruption/java/">source</a></td>
    </tr>
    <tr>
      <td>C#</td>
      <td>yes</td>
      <td><a href="https://stackoverflow.com/questions/14909853/is-sorteddictionary-a-red-black-tree">SortedDictionary</a> used red black tree</td>
      <td><a href="https://github.com/josephmate/java-by-experiments/tree/main/tree_map_corruption/csharp/">source</a></td>
    </tr>
    <tr>
      <td>Ruby</td>
      <td>no</td>
      <td>Used red black tree from <a href="http://kanwei.github.io/algorithms/classes/Containers/RubyRBTreeMap.html">kanwei/algorithms</a> but was unable to reproduce the issue. I believe it might not be able to reproduce the problem due to the Global Interpreter Lock (GIL), and how it limits when threads can context switch preventing interleavings of threads that cause an infinite loop.</td>
      <td><a href="https://github.com/josephmate/java-by-experiments/tree/main/tree_map_corruption/ruby/">source</a></td>
    </tr>
    <tr>
      <td>C++</td>
      <td>yes</td>
      <td><a href="https://stackoverflow.com/questions/18414579/what-data-structure-is-inside-stdmap-in-c">used red-black tree</a>. I was expecting it to always segfault first preventing it from hitting the issue.</td>
      <td><a href="https://github.com/josephmate/java-by-experiments/tree/main/tree_map_corruption/cpp/">source</a></td>
    </tr>
    <tr>
      <td>Go</td>
      <td>yes</td>
      <td><a href="https://github.com/emirpasic/gods#redblacktree">has popular datastructures library</a>. Similar to C++, I was expecting it only segfault and not reproduce the infinite loop. I was wrong.</td>
      <td><a href="https://github.com/josephmate/java-by-experiments/tree/main/tree_map_corruption/golang/">source</a></td>
    </tr>
    <tr>
      <td>Rust</td>
      <td>no</td>
      <td>compiler prevented me. I don’t know enough about writing unsafe code to reproduce the problem</td>
      <td><a href="https://github.com/josephmate/java-by-experiments/tree/main/tree_map_corruption/rust/">source</a></td>
    </tr>
    <tr>
      <td>Kotlin</td>
      <td>yes</td>
      <td>uses java’s TreeMap, same issue expected</td>
      <td> </td>
    </tr>
    <tr>
      <td>PHP</td>
      <td>no</td>
      <td>not in standard library and did not find any popular libraries with red black tree</td>
      <td> </td>
    </tr>
    <tr>
      <td>JavaScript</td>
      <td>no</td>
      <td><a href="https://stackoverflow.com/questions/40028377/is-it-possible-to-achieve-multithreading-in-nodejs">multithreading model cannot share references</a></td>
      <td> </td>
    </tr>
    <tr>
      <td>Typescript</td>
      <td>no</td>
      <td>same argument as JavaScript</td>
      <td> </td>
    </tr>
    <tr>
      <td>Python</td>
      <td>no</td>
      <td>no red-black tree in standard library and popular libraries like <a href="https://grantjenks.com/docs/sortedcontainers/implementation.html">Sorted Containers do not use red black tree</a>. despite no red black tree, if I had run the experiment, I would expect to not to be able to reproduce for the same reason as ruby: the GIL.</td>
      <td> </td>
    </tr>
    <tr>
      <td>Elixir</td>
      <td>no</td>
      <td>Although there are many third party implementations of the red black trees in Elixir (and Erlang), the programming model makes it impossible: data structures are immutable and interactions between threads are limited to message passing.</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>From the table, the most interesting one is C++ because I was not expecting to be able to reproduce the problem due to my hypothesis from the last section.
As a result, I include the details from the experiment here. Similarly, go as unexpected, but trim the article, I left it out. You can see <a href="https://github.com/josephmate/java-by-experiments/tree/main/tree_map_corruption/golang/">Go here</a>.</p>

<p>The code is essentially the same as the Java one, only using C++ standard libraries.
I also added extra printing since I was so shocked that the problem reproduced,
I just wanted to make extra sure.</p>
<div><div><pre><code><span>// Equivalent of TreeMap in C++ is std::map</span>
<span>// Uses same red black tree data structure</span>
<span>std</span><span>::</span><span>map</span><span>&lt;</span><span>int</span><span>,</span> <span>int</span><span>&gt;</span> <span>sortedMap</span><span>;</span>

<span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>numThreads</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
    <span>threads</span><span>.</span><span>emplace_back</span><span>([</span><span>&amp;</span><span>]()</span> <span>{</span>
        <span>// copy so that we don&#39;t use the latest value of i (5)</span>
        <span>int</span> <span>threadId</span> <span>=</span> <span>threadIdGenerator</span><span>.</span><span>fetch_add</span><span>(</span><span>1</span><span>);</span>
        <span>std</span><span>::</span><span>random_device</span> <span>rd</span><span>;</span>
        <span>std</span><span>::</span><span>mt19937</span> <span>gen</span><span>(</span><span>rd</span><span>());</span>
        <span>std</span><span>::</span><span>uniform_int_distribution</span><span>&lt;&gt;</span> <span>dis</span><span>(</span><span>0</span><span>,</span> <span>999</span><span>);</span>
                    
        <span>int</span> <span>progressThreshold</span> <span>=</span> <span>numUpdates</span> <span>/</span> <span>progressRatio</span><span>;</span>
        <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;Thread &#34;</span> <span>&lt;&lt;</span> <span>threadId</span> <span>&lt;&lt;</span> <span>&#34; started.&#34;</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> <span>j</span> <span>=</span> <span>0</span><span>;</span> <span>j</span> <span>&lt;</span> <span>numUpdates</span><span>;</span> <span>j</span><span>++</span><span>)</span> <span>{</span>
            <span>try</span> <span>{</span>
                <span>int</span> <span>key</span> <span>=</span> <span>dis</span><span>(</span><span>gen</span><span>);</span>
                <span>int</span> <span>value</span> <span>=</span> <span>dis</span><span>(</span><span>gen</span><span>);</span>

                <span>sortedMap</span><span>[</span><span>key</span><span>]</span> <span>=</span> <span>value</span><span>;</span>
            <span>}</span> <span>catch</span> <span>(</span><span>const</span> <span>std</span><span>::</span><span>exception</span><span>&amp;</span> <span>e</span><span>)</span> <span>{</span>
                <span>std</span><span>::</span><span>cerr</span> <span>&lt;&lt;</span> <span>&#34;Caught exception on thread &#34;</span> <span>&lt;&lt;</span> <span>threadId</span> <span>&lt;&lt;</span> <span>&#34;:&#34;</span> <span>&lt;&lt;</span> <span>e</span><span>.</span><span>what</span><span>()</span> <span>&lt;&lt;</span> <span>std</span><span>::</span><span>endl</span><span>;</span>
            <span>}</span>

            <span>if</span> <span>((</span><span>j</span> <span>+</span> <span>1</span><span>)</span> <span>%</span> <span>progressThreshold</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
                    <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;Thread &#34;</span> <span>&lt;&lt;</span> <span>threadId</span> <span>&lt;&lt;</span> <span>&#34;: &#34;</span> 
                            <span>&lt;&lt;</span> <span>((</span><span>j</span> <span>+</span> <span>1</span><span>)</span> <span>*</span> <span>100</span> <span>/</span> <span>numUpdates</span><span>)</span> <span>&lt;&lt;</span> <span>&#34;% complete (&#34;</span> 
                            <span>&lt;&lt;</span> <span>(</span><span>j</span> <span>+</span> <span>1</span><span>)</span> <span>&lt;&lt;</span> <span>&#34;/&#34;</span> <span>&lt;&lt;</span> <span>numUpdates</span> <span>&lt;&lt;</span> <span>&#34; updates)</span><span>\n</span><span>&#34;</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;Thread &#34;</span> <span>&lt;&lt;</span> <span>threadId</span> <span>&lt;&lt;</span> <span>&#34; completed.&#34;</span><span>;</span>
    <span>});</span>
<span>}</span>
</code></pre></div></div>

<p>Occasionally, the program segfaults and crashes like before.
This is what I was expecting the worst failure to look like.</p>
<div><div><pre><code>./SimpleRepro
zsh: segmentation fault  ./SimpleRepro
</code></pre></div></div>

<p>However, very rarely the output would look like below, indicating the threads got
stuck.
After waiting 10 minutes, the threads never completed.
I did not expect this to happen because I thought it requires a thrown and
swallowed exception. That is not happening here.</p>
<div><div><pre><code>./SimpleRepro
Thread 0 started.Thread Thread 0: 10% complete (Thread 10/10012Thread  started.3
started.Thread 4 started.Thread 4: 10% complete (10/100 updates)
 updates)
Thread 0: 20% complete (20/100 updates)
Thread 0: 30% complete (30/100 updates)
Thread 0: 40% complete (40/100 updates)
Thread 1: 10% complete (10/100 updates)
 started.Thread 2: 10% complete (10/100 updates)
Thread 1: 20% complete (20/100 updates)
&lt;nothing output for 5 minutes&gt;
</code></pre></div></div>

<p>From the tool <code>top</code> we can see that the problem reproduced because of the high cpu
utilization.</p>
<div><div><pre><code>top
PID    COMMAND      %CPU  TIME     ...
59815  SimpleRepro  170.8 08:49.61 ...
</code></pre></div></div>

<p>This shows my claim is false.
I was able to reproduce the problem in Go and C++.
Although they sometimes segfaulted, there were times when they got stuck in the
infinite loop.
In a language like C++, when you reference a null pointer it always segfaults,
so there must be an interleaving of the threads that does not hit a null!
I have no idea why.
I was expecting them to crash given how often I saw NPEs in the Java experiment.</p>

<p>With this knowledge, I went back to my SimpeRepro java experiment and stopped catching the NPE.
After re-running it 12 times, I was still able to reproduce the problem despite not catching the NPE:</p>
<div><div><pre><code>&#34;Thread-4&#34; #17 prio=5 os_prio=31 cpu=18597.02ms elapsed=23.79s tid=0x00007f81051ac200 nid=0x6a03 runnable  [0x000070000bcb5000]
   java.lang.Thread.State: RUNNABLE
        at java.util.TreeMap.put(java.base@17.0.3/TreeMap.java:826)
        at java.util.TreeMap.put(java.base@17.0.3/TreeMap.java:534)
        at SimpleRepro.lambda$main$0(SimpleRepro.java:28)
        at SimpleRepro$$Lambda$1/0x0000000800c00a08.run(Unknown Source)
        at java.lang.Thread.run(java.base@17.0.3/Thread.java:833)
</code></pre></div></div>

<p>The other thing that surprised me was languages like Ruby, despite letting you
catch NPEs did not let you reproduce the problem. The Global Interpreter Lock (GIL)
somehow prevented all execution interleavings that would reproduce the problem.</p>



<p>The easiest way to fix this was to wrap the TreeMap with <code>Collections.synchronizedMap</code> or switch to <code>ConcurrentHashMap</code> and sort on demand.
However, those fixes are boring and did not prevent us from making that mistake and taking down our host.</p>



<p>What if you could safely make the mistake, but not have a cycle?</p>

<p>I modified the red-black tree to record the nodes it has already visited.
The only requires an additional O(lg(n)) memory since it’s limited by the height of the tree.
The height of a red-black tree is guaranteed to be O(lg(n)).
If we encounter a node that we already visited, we throw a <code>ConcurrentModificationException</code>.
This will not prevent the data corruption,
but will prevent 100% cpu utilization from the infinite loop if someone makes that mistake again in the future.
This would require standard libraries to adopt this technique though which I
don’t think is likely to happen given the extra memory needed.</p>

<div><div><pre><code><span>diff --git a/tree_map_corruption/java/src/main/java/ProtectedTreeMap.java b/tree_map_corruption/java/src/main/java/ProtectedTreeMap.java
index 53c15bb..2713d5a 100644
</span><span>--- a/tree_map_corruption/java/src/main/java/ProtectedTreeMap.java
</span><span>+++ b/tree_map_corruption/java/src/main/java/ProtectedTreeMap.java
</span><span>@@ -345,7 +345,9 @@</span> public class ProtectedTreeMap&lt;K,V&gt;
         @SuppressWarnings(&#34;unchecked&#34;)
             Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;
         Entry&lt;K,V&gt; p = root;
<span>+        IdentityHashMap&lt;Entry&lt;?,?&gt;, Boolean&gt; visited = new IdentityHashMap&lt;&gt;();
</span>         while (p != null) {
<span>+            visited.put(p, true);
</span>             int cmp = k.compareTo(p.key);
             if (cmp &lt; 0)
                 p = p.left;
<span>@@ -353,6 +355,10 @@</span> public class ProtectedTreeMap&lt;K,V&gt;
                 p = p.right;
             else
                 return p;
<span>+
+            if (visited.containsKey(p)) {
+                throw new ConcurrentModificationException(&#34;TreeMap corrupted. Loop detected&#34;);
+            }
</span>         }
         return null;
     }
<span>@@ -779,6 +785,7 @@</span> public class ProtectedTreeMap&lt;K,V&gt;
     }
 
     private V put(K key, V value, boolean replaceOld) {
<span>+        IdentityHashMap&lt;Entry&lt;?,?&gt;, Boolean&gt; visited = new IdentityHashMap&lt;&gt;();
</span>         Entry&lt;K,V&gt; t = root;
         if (t == null) {
             addEntryToEmptyMap(key, value);
<span>@@ -790,6 +797,7 @@</span> public class ProtectedTreeMap&lt;K,V&gt;
         Comparator&lt;? super K&gt; cpr = comparator;
         if (cpr != null) {
             do {
<span>+                visited.put(t, true);
</span>                 parent = t;
                 cmp = cpr.compare(key, t.key);
                 if (cmp &lt; 0)
<span>@@ -803,12 +811,17 @@</span> public class ProtectedTreeMap&lt;K,V&gt;
                     }
                     return oldValue;
                 }
<span>+
+                if (visited.containsKey(t)) {
+                    throw new ConcurrentModificationException(&#34;TreeMap corrupted. Loop detected&#34;);
+                }
</span>             } while (t != null);
         } else {
             Objects.requireNonNull(key);
             @SuppressWarnings(&#34;unchecked&#34;)
             Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;
             do {
<span>+                                                               visited.put(t, true);
</span>                 parent = t;
                 cmp = k.compareTo(t.key);
                 if (cmp &lt; 0)
<span>@@ -822,6 +835,10 @@</span> public class ProtectedTreeMap&lt;K,V&gt;
                     }
                     return oldValue;
                 }
<span>+
+                if (visited.containsKey(t)) {
+                    throw new ConcurrentModificationException(&#34;TreeMap corrupted. Loop detected&#34;);
+                }
</span>             } while (t != null);
         }
         addEntry(key, value, parent, cmp &lt; 0);
</code></pre></div></div>
<p>diff from my <a href="https://github.com/josephmate/java-by-experiments/blob/main/tree_map_corruption/java/src/main/java/ProtectedTreeMap.java">ProtectedTreeMap.java</a></p>

<p>In the above code, you can see that I modified both the get and put methods to
maintain the set of visited nodes and throw a <code>ConcurrentModificationException</code>
when an already visited node is in the set.</p>



<p>Mistakes happen so it’s important that multiple layers are in place to detect the issue.
Imaging a slice of Swiss cheese, each slice taken from a different block of cheese.
Stacking enough of those slices would result in nothing being able to pass through.</p>

<h2 id="alerts-on-npes">Alerts on NPEs</h2>

<p>We lacked an alarm on any instance of an NPE.
We only had error rate alarms.
This NPE only occurs once per API handler worker thread before which was not enough to trigger our error rate alarms.
On top of that, none of the NPEs were logged because we had an unhandled exception in our Executor.</p>

<h2 id="alerts-on-utilization-anomalies">Alerts on utilization anomalies</h2>

<p>We monitor the cpu utilization and use a naive threshold based approach to alarming.
When the cpu utilization exceeds that threshold, we fire an alarm because it indicates abnormal behaviour.
This is how we discovered the issue.</p>

<h2 id="uncaught-exceptions-on-executors">Uncaught exceptions on Executors</h2>

<p>If you add your work to an executor you must ensure you have an uncaught exception handler.</p>
<div><div><pre><code><span>AtomicInteger</span> <span>threadNumber</span> <span>=</span> <span>new</span> <span>AtomicInteger</span><span>(</span><span>1</span><span>);</span>
<span>ThreadFactory</span> <span>customThreadFactory</span> <span>=</span> <span>new</span> <span>ThreadFactory</span><span>()</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>Thread</span> <span>newThread</span><span>(</span><span>Runnable</span> <span>r</span><span>)</span> <span>{</span>
        <span>Thread</span> <span>thread</span> <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>r</span><span>);</span>
        <span>thread</span><span>.</span><span>setName</span><span>(</span><span>&#34;my-thread-pool-&#34;</span> <span>+</span> <span>threadNumber</span><span>.</span><span>getAndIncrement</span><span>());</span>
        <span>thread</span><span>.</span><span>setUncaughtExceptionHandler</span><span>(</span>
          <span>(</span><span>dyingThread</span><span>,</span> <span>throwable</span><span>)</span> <span>-&gt;</span> <span>{</span>
            <span>logger</span><span>.</span><span>error</span><span>(</span><span>&#34;uncaught exception!&#34;</span><span>,</span> <span>throwable</span><span>);</span>
          <span>}</span>
        <span>);</span>
        <span>return</span> <span>thread</span><span>;</span>
    <span>}</span>
<span>};</span>

<span>ExecutorService</span> <span>executor</span> <span>=</span> <span>Executors</span><span>.</span><span>newFixedThreadPool</span><span>(</span><span>2</span><span>,</span> <span>customThreadFactory</span><span>);</span>
</code></pre></div></div>

<p>This code is kind of ugly so you’re better off using</p>

<p><a href="https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/concurrent/BasicThreadFactory.html">Apache Common’s BasicThreadFactory</a>:</p>
<div><div><pre><code><span>new</span> <span>BasicThreadFactory</span><span>.</span><span>Builder</span><span>()</span>
  <span>.</span><span>namingPattern</span><span>(</span><span>&#34;my-thread-pool-%d&#34;</span><span>)</span>
  <span>.</span><span>uncaughtExceptionHandler</span><span>(</span>
    <span>(</span><span>dyingThread</span><span>,</span> <span>throwable</span><span>)</span> <span>-&gt;</span> <span>{</span>
      <span>logger</span><span>.</span><span>error</span><span>(</span><span>&#34;uncaught exception!&#34;</span><span>,</span> <span>throwable</span><span>);</span>
    <span>}</span>
  <span>)</span>
  <span>.</span><span>build</span><span>();</span>
</code></pre></div></div>
<p>or <a href="https://guava.dev/releases/19.0/api/docs/com/google/common/util/concurrent/ThreadFactoryBuilder.html">guava’s ThreadFactoryBuilder</a>:</p>
<div><div><pre><code><span>new</span> <span>ThreadFactoryBuilder</span><span>()</span>
  <span>.</span><span>setNameFormat</span><span>(</span><span>&#34;my-thread-pool-%d&#34;</span><span>)</span>
  <span>.</span><span>setUncaughtExceptionHandler</span><span>(</span>
    <span>(</span><span>dyingThread</span><span>,</span> <span>throwable</span><span>)</span> <span>-&gt;</span> <span>{</span>
      <span>logger</span><span>.</span><span>error</span><span>(</span><span>&#34;uncaught exception!&#34;</span><span>,</span> <span>throwable</span><span>);</span>
    <span>}</span>
  <span>)</span>
  <span>.</span><span>build</span><span>()</span>
</code></pre></div></div>

<p>Without a handler, the exception will be swallowed and none of your log monitoring will be able to detect the issue.</p>

<h2 id="code-reviews">Code reviews</h2>

<p>Sometimes, a detail oriented developer will notice the combination of threads
and TreeMap, or even suggest to not use a TreeMap if ordered elements are not
needed. Unfortunately, that didn’t happen in this case.</p>

<h2 id="static-code-analysis">Static code analysis</h2>

<p>Static code analysis tools like SpotBugs (used to be called FindBugs), JLint, and Chord can detect these kinds of issues at build time. See the paper <a href="https://www.sqrlab.ca/papers/SCAM2010.pdf">How Good is Static Analysis at Finding Concurrency Bugs?</a>.
Unfortunately, we didn’t start using them until after the bug.</p>

<h2 id="tests">Tests</h2>

<p>Ensure your tests handle the multithreaded case!
In my case, we did not have multithreaded tests for that part of the code.</p>



<p>Mistakes happen.
Watch out, unprotected concurrent modification data corruption can present itself as infinite loops!
Despite making multiple mistakes, that hid the problem at multiple layers but not all.
As long as you adopt a layered approach, you will be able to respond quickly or
prevent it entirely.</p>


      </article>

      

      

      
        <!-- Check if any share-links are active -->








      

      
      
  
  
  

  


  

  



    </div>
  </div>
</div></div>
  </body>
</html>
