<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gordonc.bearblog.dev/dry-most-over-rated-programming-principle/">Original</a>
    <h1>Why DRY is the most over-rated programming principle</h1>
    
    <div id="readability-page-1" class="page"><div>
<div><p>I figured I&#39;d kick off my new blog with the most click baity thing I could think of. I suspect any developer reading this is aware of the DRY principle because it is just so ubiquitous. If not though, you just need to know that it stands for &#34;Don&#39;t Repeat Yourself&#34; and is generally invoked when advising people to not copy and paste snippets of code all over the place and instead consolidate logic into a central place.</p>
<p>DRY was the first programming principle I encountered and probably the only one I was aware of for the first year that I was a developer.  It&#39;s also probably one of the simplest principles to understand. If you see two things in your code that are the same, maybe they should just be one thing. Hard to argue with that. But, I think that DRY is just like every other principle out there - it has its place, but it&#39;s best taken in moderation.  And I think that, due to its ubiquity and simplicity, we tend to take DRY too far, far too often.</p>
<p>So without further ado, let&#39;s dive into my three criticisms of DRY.</p>
<h2 id="1-dry-is-misused-to-eliminate-coincidental-repetition">1. DRY is misused to eliminate coincidental repetition</h2>
<p>Sometimes things happen to be the same, but it&#39;s just a coincidence.  For instance, consider some python code that requests a pizza from a fictional API.</p>
<div><pre><span></span><span>def</span><span> </span><span>make_hawaiian_pizza</span><span>():</span><span></span>
<span>    </span><span>payload</span><span> </span><span>=</span><span> </span><span>{</span><span></span>
<span>        </span><span>crust</span><span>:</span><span> </span><span>&#34;thin&#34;</span><span>,</span><span></span>
<span>        </span><span>sauce</span><span>:</span><span> </span><span>&#34;tomato&#34;</span><span>,</span><span></span>
<span>        </span><span>cheese</span><span>:</span><span> </span><span>&#34;regular&#34;</span><span>,</span><span></span>
<span>        </span><span>toppings</span><span>:</span><span> </span><span>[</span><span>&#34;ham&#34;</span><span>,</span><span> </span><span>&#34;pineapple&#34;</span><span>]</span><span></span>
<span>    </span><span>}</span><span></span>
<span>    </span><span>requests</span><span>.</span><span>post</span><span>(</span><span>PIZZA_URL</span><span>,</span><span> </span><span>payload</span><span>)</span><span></span>

<span>def</span><span> </span><span>make_pepperoni_pizza</span><span>():</span><span></span>
<span>    </span><span>payload</span><span> </span><span>=</span><span> </span><span>{</span><span></span>
<span>        </span><span>crust</span><span>:</span><span> </span><span>&#34;thin&#34;</span><span>,</span><span></span>
<span>        </span><span>sauce</span><span>:</span><span> </span><span>&#34;tomato&#34;</span><span>,</span><span></span>
<span>        </span><span>cheese</span><span>:</span><span> </span><span>&#34;regular&#34;</span><span>,</span><span></span>
<span>        </span><span>toppings</span><span>:</span><span> </span><span>[</span><span>&#34;pepperoni&#34;</span><span>]</span><span></span>
<span>    </span><span>}</span><span></span>
<span>    </span><span>requests</span><span>.</span><span>post</span><span>(</span><span>PIZZA_URL</span><span>,</span><span> </span><span>payload</span><span>)</span><span></span>
</pre></div>

<p>Quite a lot of repetition going on in these payloads.  Really the only difference between the pizzas is the toppings. One would be very tempted to &#34;DRY it up&#34; and make the following refactor:</p>
<div><pre><span></span><span>def</span><span> </span><span>make_pizza</span><span>(</span><span>toppings</span><span>):</span><span></span>
<span>    </span><span>payload</span><span> </span><span>=</span><span> </span><span>{</span><span></span>
<span>        </span><span>crust</span><span>:</span><span> </span><span>&#34;thin&#34;</span><span>,</span><span></span>
<span>        </span><span>sauce</span><span>:</span><span> </span><span>&#34;tomato&#34;</span><span>,</span><span></span>
<span>        </span><span>cheese</span><span>:</span><span> </span><span>&#34;regular&#34;</span><span>,</span><span></span>
<span>        </span><span>toppings</span><span>:</span><span> </span><span>toppings</span><span></span>
<span>    </span><span>}</span><span></span>
<span>     </span><span>requests</span><span>.</span><span>post</span><span>(</span><span>PIZZA_URL</span><span>,</span><span> </span><span>payload</span><span>)</span><span></span>

<span>def</span><span> </span><span>make_pepperoni_pizza</span><span>():</span><span></span>
<span>    </span><span>make_pizza</span><span>([</span><span>&#34;pepperoni&#34;</span><span>])</span><span></span>

<span>def</span><span> </span><span>make_hawaiian_pizza</span><span>():</span><span></span>
<span>    </span><span>make_pizza</span><span>([</span><span>&#34;ham&#34;</span><span>,</span><span> </span><span>&#34;pineapple&#34;</span><span>])</span><span></span>
</pre></div>

<p>The problem is that these two pizzas just happen to have the same crust, sauce and cheese. Had we started out with two pizza types that have different crust/sauce/cheese, we never would have made this refactor.  Instead of our code being architected around the concept of how pizzas are made in the abstract, its architecture is tightly coupled to the specific needs of these two pizzas that we happened to be dealing with.  The chance that we will be putting this code back the way it was is extremely high.</p>
<h2 id="2-dry-creates-a-presumption-of-reusability">2. DRY creates a presumption of reusability</h2>
<p>Imagine we are at a company with a large codebase where multiple product areas want to integrate ordering pizza. Rather than every product writing their own <code>make_pizza()</code> function, why not stick it in a <code>common</code> library that any product can import and call?</p>
<p>So we go down this path and we end up with 5 products each calling <code>make_pizza()</code> with different arrays of arguments for the various types of pizzas they want.</p>
<p>Now along comes some cutting edge product team and they really want to start making pizzas that are half Hawaiian, half pepperoni.  The developers on this team are all about DRY and know that there is a great shared pizza function so they go to use it. The only problem is, it can&#39;t take split pizza orders. Some modifications will have to be made.</p>
<div><pre><span></span><span># cool_product/pizza.py</span><span></span>
<span>left_toppings</span><span> </span><span>=</span><span> </span><span>[</span><span>&#34;beef&#34;</span><span>]</span><span></span>
<span>right_toppings</span><span> </span><span>=</span><span> </span><span>[]</span><span> </span>
<span>make_pizza</span><span>([</span><span>left_toppings</span><span>,</span><span> </span><span>right_toppings</span><span>])</span><span>  </span><span># this will be a very funny pizza </span><span></span>

<span># common/make_pizza.py</span><span></span>
<span>def</span><span> </span><span>make_pizza</span><span>(</span><span>*</span><span>args</span><span>):</span><span></span>
<span>    </span><span>payload</span><span> </span><span>=</span><span> </span><span>{</span><span></span>
<span>        </span><span>crust</span><span>:</span><span> </span><span>&#34;original&#34;</span><span>,</span><span></span>
<span>        </span><span>sauce</span><span>:</span><span> </span><span>&#34;tomato&#34;</span><span>,</span><span></span>
<span>        </span><span>cheese</span><span>:</span><span> </span><span>&#34;regular&#34;</span><span>,</span><span></span>
<span>    </span><span>}</span><span></span>
<span>    </span><span>if</span><span> </span><span>len</span><span>(</span><span>args</span><span>)</span><span> </span><span>==</span><span> </span><span>2</span><span>:</span><span></span>
<span>        </span><span>payload</span><span>[</span><span>&#34;toppings_left&#34;</span><span>]</span><span> </span><span>=</span><span> </span><span>args</span><span>[</span><span>0</span><span>]</span><span></span>
<span>        </span><span>payload</span><span>[</span><span>&#34;toppings_right&#34;</span><span>]</span><span> </span><span>=</span><span> </span><span>args</span><span>[</span><span>1</span><span>]</span><span></span>
<span>    </span><span>else</span><span>:</span><span></span>
<span>        </span><span>payload</span><span>[</span><span>&#34;toppings_left&#34;</span><span>]</span><span> </span><span>=</span><span> </span><span>args</span><span>[</span><span>0</span><span>]</span><span></span>
<span>        </span><span>payload</span><span>[</span><span>&#34;toppings_right&#34;</span><span>]</span><span> </span><span>=</span><span> </span><span>args</span><span>[</span><span>0</span><span>]</span><span></span>

<span>    </span><span>return</span><span> </span><span>requests</span><span>.</span><span>post</span><span>(</span><span>PIZZA_URL</span><span>,</span><span> </span><span>payload</span><span>)</span><span></span>
</pre></div>

<p>This works, and it doesn&#39;t require changing every existing usage of the API. Hopefully though, you can agree that it is not goodâ„¢. Having the meaning of the first argument change because you passed an optional second argument is very odd. There are many other ways of doing this refactor but I would assert that any change that doesn&#39;t modify the existing calls of <code>make_pizza</code> or make a totally separate function for split topping pizzas (not DRY) will be some level of bad.</p>
<p>You might think that legit reasonable developers but would not actually do something like this and would instead go back to the existing invocations and modify them to get a nice solution, but I&#39;ve seen this happen all over the place. Overzealous use of DRY puts us into a mindset where we are always looking to reuse code, even when it is so obviously taking us down a bad path.  We end up with a presumption of reusability when really we should have a presumption of repetition.</p>
<h2 id="3-dry-is-a-gateway-drug-to-unnecessary-complexity">3. DRY is a gateway drug to unnecessary complexity</h2>
<p>If you are a 10x developer you probably at this point have a long list of potential solutions for the problems I&#39;ve highlighted.  You might say that I am making my examples deliberately obtuse to win my points and that there are actually ways I could fix these problems.</p>
<p>To solve my sauce issue, maybe I could use an OOP style and have a PizzaOrderer class that can be subclassed for each pizza type, allowing each type to override sensible sauce/crust defaults.  Or maybe I could use a class to represent a Pizza and have methods like <code>add_toppping()</code>/<code>add_topping_left()</code>/<code>add_topping_right()</code> so consumers can add toppings quickly if making a whole pizza but also opt into granularity for split pizzas. There are many other tricks that you could suggest.</p>
<p>All these ideas are great.  But remember that the fundamental goal here, is to send a POST request with a single JSON object.  That is a very, very simple thing to do. Now we are talking about all kinds of fancy programming stuff to try to solve problems that only exist because we don&#39;t want to repeat the same 6 line snippet in a handful of different places because DRY tells us that&#39;s bad.</p>
<p>What&#39;s happening, is our adherence to DRY is leading us down a garden path to building an unnecessarily complex application that could be written very simply. I think this also occurs far too often. Copying and pasting a few lines of code takes almost zero thought and no time. Find and replace are very good at finding repeating things later if we start to care.  As soon as we start the thought process of thinking how to avoid a copy paste and refactor instead, we are losing the complexity battle.</p>
<h2 id="so-what">So what?</h2>
<p>Well, obviously I&#39;m not saying we should throw DRY completely out the window. I&#39;m not sure it would actually be possible to write code that &#34;never doesn&#39;t repeat itself&#34;.  But I do think we should tone down knee jerk reactions to PRs that contain several repetitions of a block of code.  There are at least a few cases where that might be the exact right thing to do.</p>
<p>I hope you enjoyed the post and please hit me up on <a href="https://twitter.com/gordon_cassie">Twitter</a> to discuss!</p>
</div>
</div></div>
  </body>
</html>
