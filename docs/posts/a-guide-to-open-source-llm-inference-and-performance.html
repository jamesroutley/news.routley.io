<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.baseten.co/blog/llm-transformer-inference-guide/">Original</a>
    <h1>A guide to open-source LLM inference and performance</h1>
    
    <div id="readability-page-1" class="page"><div><h3>TL;DR</h3><p>We want to use the full power of our GPU during LLM inference. To do that, we need to know if our inference is compute bound or memory bound so that we can make optimizations in the right area. Calculating the operations per byte possible on a given GPU and comparing it to the arithmetic intensity of our model’s attention layers reveals where the bottleneck is: compute or memory. We can use this information to pick the appropriate GPU for model inference and, if our use case allows, use techniques like batching to better utilize our GPU resources.</p></div><div><div><p>Many layers of abstraction sit between an ML model API and a bare-metal GPU. Developing strong mental models for these abstractions helps you control costs and improve performance during inference so that you get the most bang for your buck by fully exploiting the potential of your GPUs.</p><p>This guide will help you understand the math behind profiling transformer inference. As a concrete example, we’ll look at running Llama 2 on an A10 GPU throughout the guide. We’ll cover:</p><ul><li><p>Reading key GPU specs to discover your hardware’s capabilities</p></li><li><p>Calculating the operations-to-byte (ops:byte) ratio of your GPU</p></li><li><p>Calculating the arithmetic intensity of your LLM</p></li><li><p>Comparing ops:byte to arithmetic intensity to discover if inference is compute bound or memory bound</p></li><li><p>Practical strategies for optimizing memory-bound and compute-bound inference</p></li></ul><p>Plus, we’ll check our work with real-world benchmarks of the model. You’ll come away from this guide with an understanding of the main bottlenecks for model serving and how to mitigate them.</p><h2><a id="112923-reading-gpu-specs"></a> <!-- -->Reading GPU specs</h2><p>One common workload is running a seven billion parameter LLM like <a target="_blank" href="https://app.baseten.co/explore/llama_2_7b_chat">Llama 2</a> or <a target="_blank" href="https://app.baseten.co/explore/mistral_7b_instruct">Mistral</a>. Serving and LLM in production requires a GPU, but which one should we pick?</p><p>Suppose we pick an <a target="_blank" href="https://www.nvidia.com/content/dam/en-zz/Solutions/Data-Center/a10/pdf/a10-datasheet.pdf">A10</a>, a good middle ground between the lean <a target="_blank" href="https://www.nvidia.com/content/dam/en-zz/Solutions/Data-Center/tesla-t4/t4-tensor-core-datasheet-951643.pdf">T4</a> and the powerful (but pricey) <a target="_blank" href="https://www.nvidia.com/content/dam/en-zz/Solutions/Data-Center/a100/pdf/nvidia-a100-datasheet-us-nvidia-1758950-r4-web.pdf">A100</a>. Here are the A10’s key specs.</p><h3><a id="112926-a10-key-specs"></a> <!-- -->A10 key specs</h3><div><table><thead><tr><th>Column A</th><th>Column B</th></tr></thead><tbody><tr><td>FP32</td><td>31.2 TF</td></tr><tr><td>TF32 Tensor Core</td><td>62.5 TF | 125 TF*</td></tr><tr><td>BFLOAT16 Tensor Core</td><td>125 TF | 250 TF*</td></tr><tr><td>FP16 Tensor Core</td><td>125 TF | 250 TF*</td></tr><tr><td>INT8 Tensor Core</td><td>250 TOPS | 500 TOPS*</td></tr><tr><td>INT4 Tensor Core</td><td>500 TOPS | 1000 TOPS*</td></tr><tr><td>GPU Memory</td><td>24 GB GDDR6</td></tr><tr><td>GPU Memory Bandwidth</td><td>600 GB/s</td></tr><tr><td>Max TDP Power</td><td>150W</td></tr></tbody></table></div><p>There are three numbers we care about here when it comes to inference:</p><ul><li><p><strong>FP16 Tensor Core</strong>: This is our <strong>compute bandwidth</strong>. We have <strong>125 TFLOPS (teraflops, or a trillion float point operations per second)</strong> of available compute for models in half-precision (also known as <strong>FP16)</strong>. Half-precision is a binary number format that occupies 16 bits per number, as opposed to full-precision, which refers to a binary format that utilizes 32 bits per number. For many ML applications, using half-precision is a practical choice as it requires less memory without losing accuracy. In this blog post, we ignore datasheet values associated with sparsity (denoted by an asterisk). </p></li><li><p><strong>GPU Memory</strong>: We can quickly estimate the size of a model in gigabytes by multiplying the number of parameters (in billions) by 2. This approach is based on a simple formula: with each parameter using 16 bits (or 2 bytes) of memory in half-precision, the memory usage in GB is approximately twice the number of parameters. Therefore, a 7B parameter model, for instance, will take up approximately <strong>14 GB of memory. </strong>Why does this matter? Well, with our <strong>A10&#39;s 24 GB of VRAM</strong>, we can comfortably run a 7B parameter model and still have about 10 GB of memory remaining as a buffer. This spare memory plays an important role in model execution, something we will elaborate on later.</p></li><li><p><strong>GPU Memory Bandwidth</strong>: We can move <strong>600 GB/s</strong> from GPU memory (also known as HBM or high bandwidth memory) to our on-chip processing units (also known as SRAM or shared memory).</p></li></ul><h2><a id="3500569-calculating-the-operations-per-byte-opsbyte-ratio"></a> <!-- -->Calculating the operations per byte (ops:byte) ratio</h2><p>Using these numbers, we can calculate the <a target="_blank" href="https://docs.nvidia.com/deeplearning/performance/dl-performance-gpu-background/index.html#understand-perf">ops:byte ratio of our hardware</a>. This tells us how many floating point operations per second (FLOPS) we can complete for every byte of memory we access.</p><p>Given the numbers from the spec sheet, we calculate the ops:byte ratio for the A10:</p><div><pre><code><span>ops_to_byte_A10
</span>    = compute_bw / memory_bw 
<!-- -->    = 125 TF / 600 GB/S  
<!-- -->    = 208.3 ops / byte</code></pre></div><p>This means to take full advantage of our compute resources, we have to complete 208.3 floating point operations for every byte of memory access.</p><ul><li><p>If we find ourselves only able to complete fewer than 208.3 operations per byte, our system performance is <strong>memory bound</strong>. This essentially means that the speed and efficiency of our system are constrained by the rate at which we can transfer data or the input-output operations that it can handle.</p></li><li><p>If we want to do more than 208.3 floating point operations per byte, our system is instead <strong>compute bound</strong>. In this state, our effectiveness and performance are restrained not by the memory, but rather the number of compute units that our chip possesses.</p></li></ul><p>It’s essential to know if we are compute bound or memory bound so we know where to focus optimization efforts.</p><h2><a id="3500576-calculating-arithmetic-intensity"></a> <!-- -->Calculating arithmetic intensity</h2><p>To determine whether we’re memory bound or compute bound, we need to calculate the <strong>arithmetic intensity</strong> of our 7 billion parameter LLM, then compare it to the ops:byte ratio we just calculated for our GPU. Arithmetic intensity is the number of compute operations an algorithm takes divided by the number of byte accesses it requires and is a hardware-agnostic measurement.</p><p>The most computationally expensive parts of our 7B parameter LLM are the <strong>attention layers</strong>, which ensure next token predictions are weighted based on the relevance of previous tokens. Because attention layers are the most computationally demanding part of the inference, we’ll calculate our arithmetic intensity there.</p><p>Understanding attention layers requires getting just a bit more specific with how the model works under the hood. When sampling from a transformer, there are two phases:</p><ol><li><p><strong>Prefill</strong>: In the first phase, the model ingests your prompt tokens in parallel, populating the key-value (KV) cache. The KV cache can be thought of as the state for your model, nestled within the attention operation. During the prefill, no tokens are being generated.</p></li><li><p><strong>Autoregressive sampling: </strong>In the second phase, we leverage our current state (stored in the KV cache) to sample and decode the next token. We pay a small price in storage in order to not recalculate the cache for every single new token. Without the KV cache, every successive token would take longer to sample because we would have to pass all previously seen tokens through the model.</p></li></ol><h3><a id="3500602-breaking-down-the-attention-equation"></a> <!-- -->Breaking down the attention equation</h3><p>Below is the equation for attention in LLM inference. We’ll go through this equation step by step to determine what requires memory movement and what requires compute operations, which we can then compare to find the arithmetic intensity that we’re looking for.</p><div><p>✕</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAwIiBoZWlnaHQ9IjI1MCI+PC9zdmc+" aria-hidden="true" alt=""/><img aria-hidden="true" alt="" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgFCgoFBQwFBQUFBREJCgUMFxMZGBYTFhUaHysjGh0oHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLBQUFEAUFEC8cFhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIAAYAGAMBIgACEQEDEQH/xAAVAAEBAAAAAAAAAAAAAAAAAAAAB//EABQQAQAAAAAAAAAAAAAAAAAAAAD/xAAVAQEBAAAAAAAAAAAAAAAAAAACAP/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/AK+AJACT/9k="/></p></div><p>The authors of <a target="_blank" href="https://arxiv.org/pdf/2205.14135.pdf">the FlashAttention paper</a> have a great implementation for the standard attention algorithm. This framing will make it easier for us to calculate memory and compute in the algorithm.</p><div><p>✕</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAwIiBoZWlnaHQ9IjIwOCI+PC9zdmc+" aria-hidden="true" alt=""/><img aria-hidden="true" alt="" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgFCgoFBQwFBQUFBREJCgUMFxMZGBYTFhUaHysjGh0oHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLBQUFEAUFEC8cFhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIAAUAGAMBIgACEQEDEQH/xAAVAAEBAAAAAAAAAAAAAAAAAAAAB//EABQQAQAAAAAAAAAAAAAAAAAAAAD/xAAVAQEBAAAAAAAAAAAAAAAAAAACAP/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/AK+AJACT/9k="/></p></div><p>Eagle-eyed readers might notice this algorithm drops the scaling by <code>sqrt(d_k)</code>. It’s a minor factor that we can safely ignore.</p><p>All three steps follow the same pattern: load values from memory, perform a computation, and store the results of that computation to memory. In the algorithm:</p><ul><li><p><code>N</code> is the sequence length of the LLM, which sets the context window.</p><ul><li><p>For Llama 2 7B, <code>N = 4096</code>.</p></li></ul></li><li><p><code>d</code> is the dimension of a single attention head.</p><ul><li><p>For Llama 2 7B, <code>d = 128</code>.</p></li></ul></li><li><p><code>Q</code>, <code>K</code>, and <code>V</code> are all matrices used to compute attention.</p><ul><li><p>Their dimensions are <code>N</code> by <code>d</code>, or in our case <code>4096x128</code>.</p></li></ul></li><li><p><code>S</code> and <code>P</code> are both matrices calculated during the equation.</p><ul><li><p>Their dimensions are <code>N</code> by <code>N</code>, or in our case <code>4096x4096</code>.</p></li></ul></li><li><p><code>O</code> is the output matrix with the results of the attention calculation.</p><ul><li><p><code>O</code> is an <code>N</code> by d matrix, or in our case <code>4096x128</code>.</p></li></ul></li><li><p><strong>HBM</strong> is high bandwidth memory.</p><ul><li><p>From the data sheet, we know that we have 24 GB of HBM on the A10 operating at 600 GB/s.</p></li></ul></li></ul><p>With these figures in mind, let’s break down the standard attention algorithm for each line in the implementation, which we’ll then sum to find the total compute and memory costs of running the algorithm.</p><div><table><thead><tr><th>Line in algorithm</th><th>Load from memory</th><th>Compute</th><th>Store to memory</th></tr></thead><tbody><tr><td>Line 1:</td><td>size_fp16 * (size_Q + size_K)</td><td>cost_dot_product_QK * size_S</td><td>size_fp16 * size_S</td></tr><tr><td></td><td>= 2 * 2 * (N * d)</td><td>= (2 * d) * (N * N)</td><td>= 2 * (N * N)</td></tr><tr><td>Line 2:</td><td>size_fp16 * size_S</td><td>cost_softmax * size_P</td><td>size_fp16 * size_P</td></tr><tr><td></td><td>= 2 * (N * N)</td><td>= 3 * (N * N)</td><td>= 2 * (N * N)</td></tr><tr><td>Line 3:</td><td>size_fp16 * (size_P + size_V)</td><td>cost_dot_product_PV * size_O</td><td>size_fp16 * size_O</td></tr><tr><td></td><td>= 2 * ((N*N) + (N * d))</td><td>= (2 * N) * (N * d)</td><td>= 2 * (N * d)</td></tr></tbody></table></div><p>We calculate total memory movement by summing the first and third columns (the loads from and stores to memory).</p><div><pre><code><span>total_memory_movement_in_bytes:
</span>    = (2 * 2 * (N * d)) + (2 * (N * N)) + (2 * ((N*N) + (N * d))) + (2 * (N * N)) + (2 * (N * N)) + (2 * (N * d))
<!-- -->    = 8N^2 + 8Nd bytes</code></pre></div><p>And calculate total compute by summing the second column (the compute on the loaded data).</p><div><pre><code><span>total</span><span>_compute_</span><span>in</span><span>_floating_</span><span>point</span><span>_ops: 
</span><span>    = ((2 * d) * (N * N)) + (3 * (N * N)) + ((2 * N) * (N * d))
</span><span>    = 4(N^2)d + 3N^2 ops</span></code></pre></div><p>The arithmetic intensity can be calculated as follows.</p><div><pre><code><span>arithmetic_intensity_llama 
</span>    ~= total compute / total memory movement
<!-- -->    = 4d(N^2) + 3N^2 ops / 8N^2 + 8Nd bytes
<!-- -->    = 62 ops/byte for Llama 2 7B</code></pre></div><h2><a id="3500639-discovering-our-inference-bottleneck"></a> <!-- -->Discovering our inference bottleneck</h2><p>Our arithmetic intensity for Llama 2 7B is 62 operations per byte, which is way less than our A10’s ops:byte ratio of 208.3.</p><p>Thus, during the autoregressive phase, our model is <strong>memory bound</strong>. In other words, in the time it takes us to move a single byte from memory to compute, we could have completed many, many more calculations than just on that byte.</p><p>This is a problem. We’re paying good money to keep our GPUs up, but are not using the compute that’s available to us.</p><h2><a id="3500664-batching-memory-bound-processes-on-a-gpu"></a> <!-- -->Batching memory-bound processes on a GPU</h2><p>One solution is to leverage the extra on-chip memory to run forward passes through our model in <strong>batches.</strong> In other words, we can wait a couple hundred milliseconds to rack up a few requests and run them all in a single pass instead of greedily processing requests as they arrive. This enables us to reuse parts of the model that we’ve already loaded into the GPU’s SRAM.</p><p>Batching increases the model’s arithmetic intensity by doing more computation for the same number of loads and stores from memory, which in turn reduces the degree to which the model is memory bound.</p><p>How big can we make our batches? Recall that we have 10 GB of memory left on our A10 after loading in our 7B parameter model:</p><p>Now, the question is how many sequences can we fit in that spare GPU memory at once?</p><p>To calculate this figure, we’ll need to return to the KV cache. Recall that during the prefill step in the attention layer, we populate the KV cache based on the prompt, or input sequence.</p><p>The KV cache contains the matrices K and V that we used during attention calculation. We need some of the values from earlier and a couple of new ones to calculate the size of the KV cache:</p><ul><li><p><code>d</code>, which can be notated as <code>d_head</code>, is the dimension of a single attention head.</p><ul><li><p>For Llama 2 7B, <code>d = 128</code>.</p></li></ul></li><li><p><code>n_heads</code> is the number of attention heads.</p><ul><li><p>For Llama 2 7B, <code>n_heads = 32</code>.</p></li></ul></li><li><p><code>n_layers</code> is the number of times the attention block shows up.</p><ul><li><p>For Llama 2 7B, <code>n_layers = 32</code>.</p></li></ul></li><li><p><code>d_model</code> is the dimension of the model. <code>d_model = d_head * n_heads</code>.</p><ul><li><p>For Llama 2 7B, <code>d_model = 4096</code>.</p></li></ul></li></ul><p>It’s worth noting that d_model being the same as N (the context window length) is coincidental. As <a target="_blank" href="https://arxiv.org/pdf/2302.13971.pdf">the Llama paper</a> shows, other sizes of Llama 2 have a larger <code>d_model</code> (see the “dimension” column).</p><div><p>✕</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAwIiBoZWlnaHQ9IjMzOCI+PC9zdmc+" aria-hidden="true" alt=""/><img aria-hidden="true" alt="" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgFCgoFBQwFBQUFBREJCgUMFxMZGBYTFhUaHysjGh0oHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLBQUFEAUFEC8cFhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIAAcAGAMBIgACEQEDEQH/xAAVAAEBAAAAAAAAAAAAAAAAAAAAB//EABQQAQAAAAAAAAAAAAAAAAAAAAD/xAAVAQEBAAAAAAAAAAAAAAAAAAACAP/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/AK4AJACT/9k="/></p></div><p>At half precision (FP16), each floating point number takes 2 bytes to store. There are 2 matrices, and to calculate the KV cache size, we multiple both by <code>n_layers</code> and <code>d_model</code>, yielding the following equation:</p><div><pre><code><span>kv_cache_size
</span>    = (2 * 2 * n_layers * d_model) bytes/token
<!-- -->    = (4 * 32 * 4096) bytes/token
<!-- -->    = 524288 bytes/token
<!-- -->    ~ 0.00052 GB/token</code></pre></div><p>Given that the KV cache requires 524288 bytes per token, how large can the KV cache be in terms of tokens?</p><div><pre><code><span>kv_cache_tokens
</span>    = 10 GB / 0.00052 GB/token
<!-- -->    = 19,230 tokens</code></pre></div><p>Our KV cache can comfortably accommodate 19,230 tokens. Thus, for Llama 2&#39;s standard sequence length of 4096 tokens, our system has the bandwidth to handle a batch of 4 sequences concurrently.</p><p>In summary, to make the most of the compute capacity that we’re paying for, we want to batch 4 requests at a time during inference to fill our KV cache. This will increase our throughput.</p><p>If you are using LLMs to process a large queue of documents asynchronously, batching is a great idea. You will process the queue much faster than if you were to process each element individually, and can schedule the inference calls so that they fill up batches quickly, minimizing the impact on latency.</p><h2><a id="3500724-evaluating-gpus-for-llm-inference"></a> <!-- -->Evaluating GPUs for LLM inference</h2><p>In some cases, batching may not make sense. For example, if you’re building a user-facing chatbot, your product is much more sensitive to latency, so you can’t wait for a batch to fill before running inference. What should we do in this case?</p><p>One option is to recognize that we won’t be able to fully utilize our GPU’s on-chip memory, and downsize. For example, we can move to a T4 GPU, which has 16 GB of VRAM. This can still hold our 7B parameter model, but there’s much less leftover capacity — only 2 GB — for batching and KV caching. </p><p>However, a <a href="https://www.baseten.co/blog/comparing-nvidia-gpus-for-ai-t4-vs-a10/">T4 GPU is usually slower than an A10</a>. And an <a href="https://www.baseten.co/blog/nvidia-a10-vs-a100-gpus-for-llm-and-stable-diffusion-inference/">A100, while more powerful, is also more expensive</a>. We can quantify this difference by calculating some simple lower bounds on inference times.</p><h3><a id="3500728-generating-a-single-token-on-each-gpu"></a> <!-- -->Generating a single token on each GPU</h3><p>Recall that during the autoregressive part of generation, we are memory bandwidth bound if our batch size is 1. Let’s quickly calculate how long it takes to generate a single token using the following equation:</p><div><pre><code><span>time/token = total number of bytes moved (the model weights) / accelerator memory bandwidth</span></code></pre></div><ul><li><p>On an T4: <code>(2 * 7B) bytes / (300 GB/s)</code> = 46 ms/token</p></li><li><p>On an A10: <code>(2 * 7B) bytes / (600 GB/s) </code>= 23 ms/token</p></li><li><p>On an A100 SXM 80 GB: <code>(2 * 7B) bytes / (2039 GB/s)</code> = 6 ms/token</p></li></ul><p>These estimates show that an A10 is twice as fast as a T4, and an A100 is nearly four times faster than an A10 (and thus eight times faster than a T4).</p><p>These numbers are only an approximation, because they assume there is zero communication within the GPU during inference, zero overhead on each forward pass, and perfect parallelization during computation.</p><h3><a id="3500755-prefilling-with-batched-prompt-tokens-on-each-gpu"></a> <!-- -->Prefilling with batched prompt tokens on each GPU</h3><p>We can also compute the time it takes for the prefill section assuming that we batch all of the prompt tokens into a single forward pass. Let’s assume that the prompt has 350 tokens, for simplicity, and that the limiting bottleneck is compute, and not memory.</p><div><pre><code><span>Prefill time = number of tokens * ( number of parameters / accelerator compute bandwidth)</span></code></pre></div><ul><li><p>On a T4: <code>350 * (2 * 7B) FLOP / 65 TFLOP/s</code> = 75 ms</p></li><li><p>On an A10: <code>350 * (2 * 7B) FLOP / 125 TFLOP/s</code> = 39 ms</p></li><li><p>On an A100 SXM 80 GB: <code>350 * (2 * 7B) FLOP / 312 TFLOP/s</code> = 16 ms</p></li></ul><h3><a id="3500759-estimating-total-generation-time-on-each-gpu"></a> <!-- -->Estimating total generation time on each GPU</h3><p>Assuming we allow for 150 completion tokens (and we suppress any stop tokens), our total generation time will be as follows.</p><div><pre><code><span>Total generation time = prefill time + number of tokens * time/token</span></code></pre></div><ul><li><p>On a T4 = <code>75 ms + 150 tokens * 46 ms/token</code> = 6.98 s</p></li><li><p>On an A10 = <code>39 ms + 150 tokens * 23 ms/token</code> = 3.49 s</p></li><li><p>On an A100 SXM 80 GB: <code>16 ms + 150  tokens * 6 ms/token</code> = 0.92s</p></li></ul><p>Factoring in GPU prices, we can look at an approximate tradeoff between speed and cost for inference. The specifics will vary slightly depending on the number of tokens used in the calculation.</p><div><table><thead><tr><th>GPU</th><th>Inference time</th><th>List price</th><th>Speedup vs T4</th><th>Cost vs T4</th></tr></thead><tbody><tr><td>T4</td><td>6.98 seconds</td><td>$0.01052/min</td><td>n/a</td><td>n/a</td></tr><tr><td>A10</td><td>3.49 seconds</td><td>$0.02012/min</td><td>~ 2x</td><td>~ 2x</td></tr><tr><td>A100</td><td>0.92 seconds</td><td>$0.10240/min</td><td>~ 7.5x</td><td>~ 10x</td></tr></tbody></table></div><h2><a id="3500786-benchmarks-for-llama-2-7b-chat-on-nvidia-gpus"></a> <!-- -->Benchmarks for Llama 2 7B Chat on NVIDIA GPUs</h2><p>In Physics class, many homework problems take place in a frictionless vacuum. The estimates we’ve been making have taken place in a similarly theoretical circumstance. Let’s compare them to real world figures.</p><p>The numbers we have calculated are underestimates of inference time because they don’t account for factors like GPU communication costs, network delays, and imperfect utilization. In the real world, these factors can make inference take up to twice as long.</p><p>The practical benchmark uses <a target="_blank" href="https://app.baseten.co/explore/llama_2_7b_chat">Llama 2 7B Chat</a> on Baseten and measures the end-to-end latency on applicable GPUs without any optimizations apart from using <a target="_blank" href="https://github.com/turboderp/exllamav2">ExLlama V2</a>.</p><p>We use a standardized prompt that has an exact input length of 350 tokens according to the <a target="_blank" href="https://belladoreai.github.io/llama-tokenizer-js/example-demo/build/">Llama 2 tokenizer</a>. The prompt is shared below. The text to summarize is pulled from <a target="_blank" href="https://paulgraham.com/greatwork.html">How to Do Great Work by Paul Graham</a>.</p><div><pre><code><span>Write a concise summary of the following:
</span>
<!-- -->&#34;The first step is to decide what to work on…[excerpt continues long enough to make the prompt exactly 350 tokens]&#34;
<!-- -->
<!-- -->CONCISE SUMMARY:</code></pre></div><p>We also allowed a maximum of 150 output tokens, with no stop token, which guaranteed that every query would spend 500 tokens in total. Therefore, we can use calculations from above to predict how long these queries will take. </p><p>The predictions are shown in dark green, while the measured generation times are shown in a lighter shade. The expected calculations are in the right ballpark, but always fall short because they make generous assumptions when it comes to the parallelization of work and ignore communication delays within the GPU.</p><div><p>✕</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMTE5IiBoZWlnaHQ9Ijc4MCI+PC9zdmc+" aria-hidden="true" alt=""/><img aria-hidden="true" alt="" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgOBgoICAgLEQoVDhgQDg0NFxgWFhEYIx8lJBYfGx0gHyslGh0oKSEXJDUlKC0vMjI2GSU4PTcwPCsxMi8BCgsLDg0OHBAQHDsoIik7OzIvOzs7NTs7Ozs7OzsvMi8vNS8vLy8vOy87LzsvNjs1Mi81Ly8vLy8vLy8vNS8vNf/AABEIABEAGAMBIgACEQEDEQH/xAAZAAACAwEAAAAAAAAAAAAAAAAABAUGBwH/xAAmEAAABQIEBwEAAAAAAAAAAAAAAQIDEQQFBiI1cRIUITFCYYET/8QAFwEBAAMAAAAAAAAAAAAAAAAAAQACA//EABsRAAICAwEAAAAAAAAAAAAAAAABAgMxMkEh/9oADAMBAAIRAxEAPwDY836eoCyneCpcMzKI7Bepcr+bMmk5Y6Cr1ZXty4uJSSogVbMLrJRwSFiuTruJqlszywYBA4Oo7q3it5T6T4YOZAImMLG16jSfL4EkaivYAAjbwTt2uVOw4AAI4GrU/9k="/></p><p>Comparison of generation time and predicted time across instance types</p></div><h2><a id="3500816-optimizing-llm-model-inference-with-transformer-math"></a> <!-- -->Optimizing LLM model inference with transformer math</h2><p>We want to make the most of compute capacity during LLM inference, but we can’t do that when we’re memory bound. Calculating the operations per byte possible on a given GPU and comparing it to the arithmetic intensity of our model’s attention layers lets us understand if we’re memory bound or compute bound.</p><p>When memory bound, batching lets us make the most of our compute capacity, though batching isn’t possible for many latency-sensitive use cases. When we start with a strong latency requirement, we can use similar calculations to estimate which GPUs can meet our needs.</p><p>As useful as these theoretical calculations are, it’s alway essential to check them against real-world benchmarks to account for factors like communication costs and network delays.</p><p>Looking under the hood of LLM inference is fascinating, and there’s always further to dig. Here are some great resources for learning more:</p><ul><li><p><a target="_blank" href="https://kipp.ly/transformer-inference-arithmetic/">Transformer inference arithmetic on kipp.ly</a></p></li><li><p><a target="_blank" href="https://cursor.sh/blog/llama-inference">Why GPT-3.5 is (mostly) cheaper than Llama 2 on cursor.sh</a></p></li><li><p><a target="_blank" href="https://horace.io/brrr_intro.html">Making Deep Learning Go Brrrr From First Principles on horace.io</a></p></li><li><p><a target="_blank" href="https://docs.nvidia.com/deeplearning/performance/dl-performance-gpu-background/index.html">GPU Performance Background User&#39;s Guide by NVIDIA</a></p></li></ul></div></div></div>
  </body>
</html>
