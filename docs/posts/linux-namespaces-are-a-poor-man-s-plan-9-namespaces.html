<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://yotam.net/posts/linux-namespaces-are-a-poor-mans-plan9-namespaces/">Original</a>
    <h1>Linux Namespaces Are a Poor Man&#39;s Plan 9 Namespaces</h1>
    
    <div id="readability-page-1" class="page"><article>
		<header>
			
			<time datetime="2022-11-05T10:15:12+0300">Nov 5, 2022 10:15</time>
		</header>
		<section id="post-content">
			<p>Plan 9 is the failed<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> successor to Unix. It was developed by the same group,
Bell Labs, with all of the experience they had gather in the twenty years since
Unix was first written. Many features that are common today in many Unix
systems, and some non Unix systems, came originally from Plan 9. For example,
the <code>/proc</code> file system was first implemented in UNIX 8th Edition, which was the
predecessor to Plan 9<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>. Another example, which I will talk about in this
post, is the use of process namespaces.</p>
<p>Plan 9 had two major ideas, that everything else was built on. The first was the
idea that everything is a file. You might think that in Unix everything was
already a file, but it was only partially true. In Plan 9 they took this idea to
the extreme. Everything including the input and output of the system, process
management and network connections were all accessed through the file system
instead of the usual syscalls. The second major idea is, you guessed it, per
process namespace.</p>
<p>These two major ideas are the key to what makes Plan 9 namespaces so great.
Instead of having a different namespace API for each resource, like we have in
Linux, we had a unified concept of filesystem namespaces. It already means that
the namespace API is a lot simpler than its Linux counterpart, but it also means
that we have a namespace for almost anything. A popular example is the
<a href="https://swtch.com/drawterm/">drawterm</a> terminal, which connects to a remote machine, and binds the client
display and input devices into the process namespace. That makes for an elegant
remote desktop solution that doesn’t require a custom protocol<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>.</p>
<p>The drawterm program also shows another awesome property of Plan 9, which is a
side effect of the two major ideas. Plan 9 was made after the concept of
computer networks was more common, and so it supports networking natively. Plan
9 has its own network filesystem protocol called 9p, which is used to create the
filesystem view of the process. You don’t care if each resource is local or not,
you access it the same way through the filesystem. A nice example of it, is that
if you want to create a proxy in Plan 9, you just need to mount the remote /net
directory of the proxy server into the local /net for the desired process.</p>
<p>I’m not aware of a Docker counterpart in Plan 9 but I think it’s obvious how one
would implement such a thing easily. Some APIs are missing, like cgroups, and
the operating system is sadly stuck in the 90s, but I think Plan 9 can be a
great inspiration in simplification. Sadly, we can’t just bring Plan 9
namespaces into Linux or any other Unix-like os. Only a system designed from the
start properly, with such coherence, can achieve something so simple yet so
powerful and intergate with the whole system.</p>


		</section>
	</article></div>
  </body>
</html>
