<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.miguelgrinberg.com/post/building-a-toy-programming-language-in-python">Original</a>
    <h1>A toy programming language in 137 lines of Python code</h1>
    
    <div id="readability-page-1" class="page"><div><p>I thought it would be fun to go outside of my comfort zone of web development topics and write about something completely different and new, something I have never written about before. So today, I&#39;m going to show you how to implement a programming language!</p>
<p>The project will parse and execute programs written in a simple language I called <code>my</code> (I know it&#39;s a lame name, but hey, it is &#34;my&#34; language). The implementation is going to be in Python, without any external dependencies. The <code>my</code> language is simple enough to make this project reasonably short, but also complex enough to make it interesting. If you are only interested in the complete code, you can find it in <a href="https://github.com/miguelgrinberg/mylang">this GitHub repository</a>. If you want to learn, then read on!</p>
<p>In this first installment of this series, I&#39;ll show you how to build a very basic programming language that implements a print statement. Then in the <a href="https://blog.miguelgrinberg.com/post/building-a-toy-programming-language-in-python-part-2">second part</a> I&#39;ll extend the language to support variables and mathematical expressions. The end goal is a programming language implementation that can execute programs such as this one:</p>
<pre><code>a = 3
b = 4 + a * 2
print b + 1
</code></pre>
<p>Once you learn the techniques involved in bringing <code>my</code> to life, you will be able to extend the language in any way you like and make it yours too. Sounds interesting? Let&#39;s get started!</p>
<h2>The Components of a Programming Language</h2>
<p>It is not the point of this article to bore you with a discussion of compiler theory, but at the same time I feel it is important to begin with a basic idea of the project structure. It is certainly possible to start coding away and figure things out intuitively as you go, but given that this is a topic that has been well studied it does not make sense to ignore all the research and knowledge that is available.</p>
<p>So, in very general terms, a programming language implementation is composed of the following phases:</p>
<ul>
<li>Lexical analysis, where the program&#39;s source code is read and divided up into individual units called <em>tokens</em>.</li>
<li>Syntax analysis, where the sequence of tokens provided by the lexical analyzer (or <em>lexer</em>) is checked against the grammar of the language. The module that performs this task is called the <em>parser</em>.</li>
<li>Code generation, where an intermediate code is generated as a lower-level representation of the sequence of tokens parsed from the source file. The module that performs this task is sometimes called the <em>compiler</em>, though this term is often used to refer to this and the previous two phases combined.</li>
<li>Execution, where the intermediate code produced by the compiler is read and executed. The module that performs this task is called the <em>interpreter</em>.</li>
</ul>
<p>Some languages have a more complex structure, which for example includes one or more code optimization phases after the compiler phase, leading to more efficient code. Others have simplifications, such as having a single phase that merges code generation and execution together, which means that code is executed on the fly as it is parsed.</p>
<p>Regardless of the exact structure of a language implementation, the important point to remember is that using a well defined structure based on the above phases will help keep the complexity of the project under control.</p>
<h2>The &#34;My&#34; Programming Language, Version 0.1</h2>
<p>If you are familiar with my tutorials, you know that I like to build projects in small steps. For that reason, the first version of the <code>my</code> language is going to be extremely simple, with just a <code>print</code> statement that prints numbers. Here is an example program written in the first version of <code>my</code>:</p>
<pre><code>print 1
print 52
</code></pre>
<p>The <code>print</code> keyword is a reserved word of the language. Numbers in this language are integers. When this program is executed, the expected output should be:</p>
<pre><code>1
52
</code></pre>
<p>The documentation that describes the syntax of a language is called the language <em>grammar</em>. This is very important to have, as it serves as a reference when implementing the language. The grammar for this first version of the <code>my</code> language is:</p>
<pre><code>&lt;program&gt; = &lt;statement&gt; [ &lt;statement&gt; ... ]
&lt;statement&gt; = &lt;print_statement&gt; &#34;\n&#34;
&lt;print_statement&gt; = &#34;print&#34; &lt;expression&gt;
&lt;expression&gt; = number
</code></pre>
<p>To make sense of this notation you can start from top to bottom. The first rule says that a program in this language is defined  as a statement optionally followed by more statements.</p>
<p>In the second rule, a statement is defined as a print statement, followed by an end of line. The third rule states that a print statement must have the literal word &#34;print&#34; followed by an expression. The fourth and final rule defines an expression as a number. Remember that this is a first attempt, expressions will later be expanded.</p>
<p>The <code>&#34;\n&#34;</code>, <code>&#34;print&#34;</code> and <code>number</code> elements used in this grammar are terminal symbols, or <em>tokens</em>. These do not require grammar rules because they are tokens directly produced by the lexer. The remaining symbols, which are shown enclosed in <code>&lt;</code> and <code>&gt;</code>, are defined in terms of other symbols or tokens.</p>
<h2>The Lexer</h2>
<p>The function of the lexical analyzer (or lexer) is to read the source code of the language and produce a sequence of tokens. In this section I&#39;ll show you how to build a lexer for the <code>my</code> language.</p>
<p>Consider once again the example <code>my</code> program:</p>
<pre><code>print 1
print 52
</code></pre>
<p>With this input, the lexer should produce the following list of tokens:</p>
<ul>
<li><code>&#34;print&#34;</code></li>
<li><code>&#34;number&#34;</code>, 1</li>
<li><code>&#34;\n&#34;</code></li>
<li><code>&#34;print&#34;</code></li>
<li><code>&#34;number&#34;</code>, 52</li>
<li><code>&#34;\n&#34;</code></li>
</ul>
<p>The <code>My</code> class shown below accepts the source code of a <code>my</code> program as a string, and in accordance with the grammar I shared above. Its <code>tokens()</code> method returns an iterator that produces tokens from this code.</p>
<pre><code>class My:
    def __init__(self, code):
        self.code = code
        self.line_nr = 0

    def raise_error(self, message):
        raise ValueError(f&#39;{self.line_nr}: {message}&#39;)

    def tokens(self):
        for line in self.code.strip().split(&#39;\n&#39;):
            self.line_nr += 1
            for token in line.strip().split(&#39; &#39;):
                if token == &#39;print&#39;:
                    yield (token,)
                elif token.isnumeric():
                    yield (&#39;number&#39;, int(token))
                else:
                    self.raise_error(f&#39;Syntax Error: Invalid token {token}&#39;)
            yield (&#39;\n&#39;,)
</code></pre>
<p>Copy the above code to a file named <em>my.py</em>. Before I explain some the interesting details in this implementation, let&#39;s give this lexer a try. Try the following in a Python prompt:</p>
<pre><code>&gt;&gt;&gt; from my import My
&gt;&gt;&gt; p = My(&#39;&#39;&#39;print 1
... print 52
... &#39;&#39;&#39;)
&gt;&gt;&gt; list(p.tokens())
[(&#39;print&#39;,), (&#39;number&#39;, 1), (&#39;\n&#39;,), (&#39;print&#39;,), (&#39;number&#39;, 52), (&#39;\n&#39;,)]
</code></pre>
<p>This is pretty cool, right? Each token is returned as a tuple. For the <code>&#34;print&#34;</code> and <code>&#34;\n&#34;</code> tokens, the tuples have a single element with the token itself. For the <code>number</code> token, a second element is added with the actual value of the number.</p>
<p>The <code>tokens()</code> method is built as a <a href="https://docs.python.org/3/glossary.html#term-generator">generator</a>, a special kind of Python function that returns an iterator. The elements returned by the iterator are produced with the <code>yield</code> keyword, inside the body of the function. You can see that the method splits the source code into lines and iterates over them, then for each line it splits on the spaces. Inside this double for-loop, each part is checked to see if it matches the <code>&#34;print&#34;</code> or <code>number</code> tokens. The <code>&#34;\n&#34;</code> token is treated as a special case because it is only valid at the end of the line, so it is added automatically after each outer loop iteration.</p>
<p>What happens when a token does not match the <code>&#34;print&#34;</code> or <code>number</code> tokens defined in the language grammar? That is an error, so for that case the <code>raise_error()</code> method is called. This method raises a <code>ValueError</code> exception with an the error message, which would be the equivalent to having a syntax error reported in a Python script. Here is another console example where an error is raised due to an invalid token:</p>
<pre><code>&gt;&gt;&gt; p = My(&#39;&#39;&#39;print 1
... print &#34;foo&#34;
... &#39;&#39;&#39;)
&gt;&gt;&gt; list(p.tokens())
Traceback (most recent call last):
...
ValueError: 2: Syntax Error: Invalid token &#34;foo&#34;
</code></pre>
<p>Notice the <code>2:</code> in the error message. This is the line number of the error! The <code>line_nr</code> attribute of the <code>My</code> class counts the line as they are being analyzed, and this makes it possible to report a line number when an error occurs. A more sophisticated lexer could also keep track of column numbers and accurately show the position of the error within the line as well.</p>
<p>Because the <code>tokens()</code> method returns an iterable, it can be printed by transforming it to a list, as I did in the Python prompt examples shown above. Another way to use this method that is more practical for a language parser is to use it along with the <code>next()</code> function from Python. Here is how that works, still in the Python console:</p>
<pre><code>&gt;&gt;&gt; p = My(&#39;&#39;&#39;print 1
... print 52
... &#39;&#39;&#39;)
&gt;&gt;&gt; token_feed = p.tokens()
&gt;&gt;&gt; next(token_feed)
(&#39;print&#39;,)
&gt;&gt;&gt; next(token_feed)
(&#39;number&#39;, 1)
&gt;&gt;&gt; next(token_feed)
(&#39;\n&#39;,)
&gt;&gt;&gt; next(token_feed)
(&#39;print&#39;,)
&gt;&gt;&gt; next(token_feed)
(&#39;number&#39;, 52)
&gt;&gt;&gt; next(token_feed)
(&#39;\n&#39;,)
&gt;&gt;&gt; next(token_feed)
Traceback (most recent call last):
  File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;
StopIteration
</code></pre>
<p>Here the <code>token_feed</code> variable is assigned the iterator returned by the <code>tokens()</code> method. Then each time the <code>next()</code> function is called with this iterator as an argument, another token is returned. When all the tokens have been returned, the <code>StopIteration</code> exception is raised. This is going to be the basis of how the parser will communicate with the lexer to ask for tokens. The <code>next_token()</code> method of the <code>My</code> class, shown below, will be used for this task:</p>
<pre><code>class My:
    def __init__(self, code):
        self.code = code
        self.line_nr = 0
        self.token_feed = self.tokens()

    # ...

    def next_token(self):
        try:
            token = next(self.token_feed)
        except StopIteration:
            token = None
        return token
</code></pre>
<p>In the constructor, the <code>token_feed</code> attribute is initialized with the token iterator. The <code>next_token()</code> method then returns tokens from this iterator one by one. When the end of the token stream is reached, the method catches the <code>StopIteration</code> exception and returns <code>None</code> instead, which the parser will interpret as having reached the end of the code.</p>
<p>To evaluate if the token stream matches a certain rule, it is often useful for the parser to &#34;look ahead&#34; for the next token, before it is certain if the rule under consideration is a match or not. The <code>next_token()</code> method shown above returns the next token, but at the same time it consumes it, meaning that once a token has been returned it has to be used or else it is lost. What would be most useful is if the parser could change its mind with regards to a token and return it to the stream, so that then another rule in the parser can get it when it calls <code>next_token()</code>.</p>
<p>The idea of being able to take the next token and optionally returning it to the stream is implemented below in the <code>return_token()</code> method:</p>
<pre><code>class My:
    def __init__(self, code):
        self.code = code
        self.line_nr = 0
        self.token_feed = self.tokens()
        self.returned_token = None

    # ...

    def next_token(self):
        if self.returned_token:
            token = self.returned_token
            self.returned_token = None
        else:
            try:
                token = next(self.token_feed)
            except StopIteration:
                token = None
        return token

    def return_token(self, token):
        if self.returned_token is not None:
            raise RuntimeError(&#39;Cannot return more than one token at a time&#39;)
        self.returned_token = token
</code></pre>
<p>In this version of the <code>My</code> class, a <code>returned_token</code> attribute is initialized to <code>None</code>. If a token provided by <code>next_token()</code> cannot be used, the parser can give it back with a call to <code>return_token()</code>, so that the same token is returned the next time <code>next_token()</code> is called. This creates a complication, because there is no easy way to return an item to an iterator. My implementation puts the returned token in the new <code>returned_token</code> attribute. The <code>next_time()</code> implementation is now expanded to return this token instead of the next one from the iterator. With this little trick the parser can retrieve a token, do some work with it and then change its mind and return it. One side effect of this implementation is that it is only possible to return one token, so a <code>RuntimeError</code> is raised if two tokens are returned in a row.</p>
<p>Save the above changes to the <em>my.py</em> file, and then start a new Python session to play with the new token methods:</p>
<pre><code>&gt;&gt;&gt; from my import My
&gt;&gt;&gt; p = My(&#39;&#39;&#39;print 1
... print 52
... &#39;&#39;&#39;)
&gt;&gt;&gt; p.next_token()
(&#39;print&#39;,)
&gt;&gt;&gt; p.next_token()
(&#39;number&#39;, 1)
&gt;&gt;&gt; p.return_token((&#39;number&#39;, 1))
&gt;&gt;&gt; p.next_token()
(&#39;number&#39;, 1)
&gt;&gt;&gt; p.next_token()
(&#39;\n&#39;,)
</code></pre>
<p>Hopefully this example clarifies how the parser is going to manage the token stream.</p>
<h2>The Parser</h2>
<p>The task of the parser is to match the sequence of tokens to the language grammar. For each rule in the grammar, there is going to be a method that determines if the token stream matches the rule or not.</p>
<p>Here is the first rule in the language grammar:</p>
<pre><code>&lt;program&gt; = &lt;statement&gt; [ &lt;statement&gt; ... ]
</code></pre>
<p>As a naming convention, I&#39;m going to use the rule names in the parsing methods. The rule is named <code>&lt;program&gt;</code>, so I&#39;m going to call the method that parses it <code>parse_program()</code>. Another convention is that all the methods that parse rules will return <code>True</code> if they were able to match the rule to the incoming tokens, or <code>False</code> if not. A return of <code>False</code> would tell the caller that this rule isn&#39;t present in the stream.</p>
<p>The <code>&lt;program&gt;</code> rule is a high-level rule that is defined in terms of other rules, and while this may appear to complicate things, in fact it is all the contrary, because any references to other rules are addressed by calling the methods of the other rules.</p>
<p>I think the best way to understand what I mean here is to look at the definition of the <code>parse_program()</code> method:</p>
<pre><code>class My:
    # ...

    def parse_program(self):
        if not self.parse_statement():
            self.raise_error(&#39;Expected: statement&#39;)
        token = self.next_token()
        while token is not None:
            self.return_token(token)
            if not self.parse_statement():
               self.raise_error(&#39;Expected: statement&#39;)
            token = self.next_token()
        return True
</code></pre>
<p>The <code>&lt;program&gt;</code> rule says that the very first thing to look for is something that matches the <code>&lt;statement&gt;</code> rule. This is implemented by calling a <code>parse_statement()</code> method (which does not exist yet). Like all the methods that implement the parsing of a rule, the return value of the call indicates if the parsing was successful or not. When parsing the <code>&lt;program&gt;</code> rule, a failure to parse a first statement indicates that the program is incorrect, as there are no alternative rules that can be considered instead. For that reason, if the initial statement cannot be parsed, that is considered an error that halts the parsing.</p>
<p>After the first statement, a <code>&lt;program&gt;</code> rule allows one or more optional statements, until the end of the program is reached. This means that after parsing the first statement, the parser for <code>&lt;program&gt;</code> needs to consider one of two possible paths, both valid:</p>
<ol>
<li>There is another statement in the token stream</li>
<li>There are no more tokens, meaning that the end of the program was reached</li>
</ol>
<p>To decide which of the two paths is the one that matches the input stream of tokens, the next token is obtained. If this token is not <code>None</code>, that means that there are more statements in the program. In that case, the token is returned to the stream and another call to <code>parse_statement()</code> is made to parse the next statement. Returning the token to the stream is important, because this token needs to be available to the <code>parse_statement()</code> method.</p>
<p>When the end of the program is reached, the next token is going to be <code>None</code>, and this will cause the while-loop to exit. At this point the program has been completely parsed!</p>
<p>But of course, the parser is still incomplete, as there are three more rules that need to be implemented. Let&#39;s look at the second rule:</p>
<pre><code>&lt;statement&gt; = &lt;print_statement&gt; &#34;\n&#34;
</code></pre>
<p>Here is the <code>parse_statement()</code> method that implements this rule:</p>
<pre><code>class My:
    # ...

    def parse_statement(self):
        if not self.parse_print_statement():
            self.raise_error(&#39;Expected: print statement&#39;)
        token = self.next_token()
        if token[0] != &#39;\n&#39;:
            self.raise_error(&#39;Expected: end of line&#39;)
        return True
</code></pre>
<p>This actually makes sense, right? A statement is composed of a print statement followed by an end-of-line token. If either of them aren&#39;t present, then errors are reported. To check for the <code>&lt;print_statement&gt;</code> rule, a call to the <code>parse_print_statement()</code> is made. The check for the end-of-line token does not require any method calls because it can be done with a simple comparison.</p>
<p>There are two rules left to implement:</p>
<pre><code>&lt;print_statement&gt; = &#34;print&#34; &lt;expression&gt;
&lt;expression&gt; = number
</code></pre>
<p>Here are the corresponding parsing methods:</p>
<pre><code>class My:
    # ...

    def parse_print_statement(self):
        token = self.next_token()
        if token[0] != &#39;print&#39;:
            self.return_token(token)
            return False
        if not self.parse_expression():
            self.raise_error(&#39;Expected: expression&#39;)
        return True

    def parse_expression(self):
        token = self.next_token()
        if token[0] != &#39;number&#39;:
            self.return_token(token)
            return False
        return True
</code></pre>
<p>A difference in these two parsing methods is that when they don&#39;t recognize the first token they put the token back on the stream and then return <code>False</code>, whereas the previous two rules raised errors. When a rule returns <code>False</code>, it is giving the parent rule the option to attempt to call other rules before giving up with an error. This is a sensible thing to do in lower level rules, because they do not have the context to know if there are other alternatives that the parent rule can explore.</p>
<p>It may sound hard to believe, but this is all there is to the parser module of the <code>my</code> language. To tie the collection of rules together, let&#39;s add a <code>run()</code> method that runs the program through the parser:</p>
<pre><code>class My:
    # ...

    def run(self):
        try:
            return self.parse_program()
        except ValueError as exc:
            print(str(exc))
            return False
</code></pre>
<p>This method catches the <code>ValueError</code> exception that is raised for various error conditions when the <code>raise_error()</code> method is invoked. When an error occurs, the error message is printed, and then the <code>run()</code> method returns <code>False</code>, to indicate that the program failed.</p>
<p>You can try parsing some simple programs in the Python prompt:</p>
<pre><code>&gt;&gt;&gt; from my import My
&gt;&gt;&gt; p = My(&#39;&#39;&#39;print 1
... print 52
... &#39;&#39;&#39;)
&gt;&gt;&gt; p.run()
True
</code></pre>
<p>This returns a simple <code>True</code>, but that means a lot. It means that all the tokens found in this program were found to comply with the rules of the grammar of the language. Let&#39;s try some invalid programs to see how the output changes:</p>
<pre><code>&gt;&gt;&gt; p = My(&#39;&#39;&#39;print 1
... print
... &#39;&#39;&#39;)
&gt;&gt;&gt; p.run()
2: Expected: expression
False
</code></pre>
<p>In this example, I have omitted the argument to <code>print</code> in line 2. The error reports this mistake, and the top-level <code>run()</code> method returns <code>False</code>, to indicate that the program did not parse.</p>
<p>Let&#39;s try another one:</p>
<pre><code>&gt;&gt;&gt; p = My(&#39;&#39;&#39;print 1 2
... &#39;&#39;&#39;)
&gt;&gt;&gt; p.run()
1: Expected: end of line
False
</code></pre>
<p>For this second error, I added an extra number at the end of the print statement in line 1, and the parser indicates that an end-of-line was expected there. Fantastic!</p>
<h2>The Interpreter</h2>
<p>The parser for the first version of the language is now complete, so now it is time to evaluate the options for the remaining work:</p>
<ul>
<li>One option is to define a set of low-level coding instructions and then add code generation of these instructions to the parsing methods. Then separately from that, build an interpreter the runs these instructions.</li>
<li>A second option is to directly implement the code execution logic within the parsing methods, without generating intermediate instructions.</li>
</ul>
<p>To keep things simple, I&#39;m going to go with the second option, which is a good option for smaller languages.</p>
<p>In terms of implementing the program execution for this language, the secret technique that makes it possible is the <a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">stack</a>. A stack is a primitive data structure that supports two main operations, <em>push</em> and <em>pop</em>, to add and remove elements respectively. The interesting aspect is that elements are removed in reverse order to how they were added, which is the same as saying that the last element in is the first element out (LIFO). The stack is at the core of pretty much all execution environments for programming languages.</p>
<p>Here is a very simple execution stack implementation for the <code>my</code> language:</p>
<pre><code>class My:
    def __init__(self, code):
        self.code = code
        self.line_nr = 0
        self.token_feed = self.tokens()
        self.returned_token = None
        self.stack = []

    # ...

    def stack_push(self, arg):
        self.stack.append(arg)

    def stack_pop(self):
        return self.stack.pop()
</code></pre>
<p>How is the stack used? It&#39;s simple. Rules such as <code>&lt;expression&gt;</code>, which have a resulting value after they are parsed, push this result to the stack. Rules such as <code>&lt;print_statement&gt;</code>, which consume a value, pop a value from the stack. Let&#39;s implement the stack in these two rules:</p>
<pre><code>class My:
    # ...

    def parse_print_statement(self):
        token = self.next_token()
        if token != (&#39;print&#39;,):
            self.return_token(token)
            return False
        if not self.parse_expression():
            self.raise_error(&#39;Expected expression&#39;)

        value = self.stack_pop()
        print(value)
        return True

    def parse_expression(self):
        token = self.next_token()
        if token[0] != &#39;number&#39;:
            self.return_token(token)
            return False

        self.stack_push(token[1])
        return True

    # ...
</code></pre>
<p>After a successful parse of the <code>&lt;expression&gt;</code> rule, and before returning <code>True</code>, the value associated with the expression is pushed to the stack. For the simplistic expressions in the current version of the language, the number to push is given as the second value in the <code>number</code> token tuple.</p>
<p>The <code>&lt;print_statement&gt;</code> rule, which needs a value to print, pops a value from the stack and prints it. This is all it takes to execute the print statement!</p>
<p>In case you are wondering, the LIFO property of the stack prevents values from different statements from ever getting mixed up. Even with complicated mathematical expressions, the stack is able to maintain the running state of the application, with every expression being consumed by the proper owner.</p>
<h2>Running Programs Stored on Files</h2>
<p>The <code>my</code> language is somewhat useless as it can only print numbers, but it is a very good base to continue building from. Before I end this first part, it would be convenient to make the <code>my</code> language work with programs stored in files on disk. This can be implemented at the bottom of <em>my.py</em>:</p>
<pre><code>import sys

class My:
    # ...

if __name__ == &#39;__main__&#39;:
    with open(sys.argv[1], &#39;rt&#39;) as f:
        code = f.read()
    program = My(code)
    program.run()
</code></pre>
<p>Now you can create silly programs that print numbers, store them in a file and execute them. For example, write the following program in a file called <em>test.my</em>:</p>
<pre><code>print 1
print 52
</code></pre>
<p>Then run the program as follows:</p>
<pre><code>$ python my.py test.my
1
52
</code></pre>
<p>Very cool!</p>
<p>In the <a href="https://blog.miguelgrinberg.com/post/building-a-toy-programming-language-in-python-part-2">second part</a> of this tutorial, I&#39;ll show you how to extend the <code>my</code> language to support variables and mathematical expressions.</p></div></div>
  </body>
</html>
