<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thunderseethe.dev/posts/bet-on-cbpv/">Original</a>
    <h1>I&#39;m Betting on Call-by-Push-Value</h1>
    
    <div id="readability-page-1" class="page"><div><p>You come upon a function argument at a fork in the road.
If it takes the left road, it‚Äôll evaluate itself and then be passed to its function.
If it takes the right road, it‚Äôll pass itself to the function to be evaluated somewhere down the road (ü•Åüêç).
Let‚Äôs bet on which road will be faster.</p><p>We might suspect this is a rather boring bet.
All we have to do is look down each road and see which one is shorter.
Fortunately for our wager (and to the dismay of theorists everywhere), this is not the case.
We can always construct a situation where evaluating either eagerly or lazily is better.</p><p>Our gamble touches on an age-old question in programming language semantics, to <a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_value" target="_blank" rel="noopener" data-goatcounter-click="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_value" data-goatcounter-title="call-by-value" data-goatcounter-referrer="I&#39;m betting on Call-by-Push-Value">call-by-value</a>
(CBV) or to <a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_need" target="_blank" rel="noopener" data-goatcounter-click="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_need" data-goatcounter-title="call-by-name/call-by-need" data-goatcounter-referrer="I&#39;m betting on Call-by-Push-Value">call-by-name/call-by-need</a>
(CBN).
They are both evaluation strategies that determine the order in which expressions are evaluated.
CBV always evaluates a function argument before passing it to a function (aka eager evaluation).
CBN waits to evaluate function arguments until they are used in the function body (aka lazy evaluation).</p><p>Languages pick one and use it for all their function applications.
Rust, Java, JavaScript, Python, and C/C++ use CBV as their evaluation strategy.
Haskell and‚Ä¶uh‚Ä¶ Haskell use CBN for their evaluation strategy.
Alas, whichever call you make, the grass is always greener on the other side.
Our CBV languages introduce little spurts of lazy evaluation (closures, iterators, etc.).
Our CBN language(s) introduce eager evaluation; Haskell extended its language to make data types eager by default.</p><p>Given both CBV and CBN languages end up wanting both eager and lazy evaluation, why are we forced to pick one and forgo the other entirely?
It turns out we‚Äôre not, we just didn‚Äôt know that yet when we designed all those languages. ‚Ä¶<em>Whoops</em>.</p><p>Before we can talk about why CBPV is cool, we have to talk about what it is.
The big idea of CBPV is to support both CBV and CBN with one set of semantics.
It accomplishes this by distinguishing between values and computations.
The paper provides a nice slogan to capture the intuition: ‚Äúa computation does, a value is‚Äù.</p><p>Great, but what does that actually mean?
Let‚Äôs look at a traditional lambda calculus, to provide contrast for our CBPV lambda calculus:</p><div><pre tabindex="0"><code data-lang="hs"><span><span><span>data</span> <span>Type</span> 
</span></span><span><span>    <span>|</span> <span>Int</span>
</span></span><span><span>    <span>|</span> <span>Fun</span> <span>Type</span> <span>Type</span>
</span></span><span><span>
</span></span><span><span><span>data</span> <span>Term</span>
</span></span><span><span>    <span>=</span> <span>Var</span> <span>Text</span>
</span></span><span><span>    <span>|</span> <span>Int</span> <span>Int</span>
</span></span><span><span>    <span>|</span> <span>Fun</span> <span>Text</span> <span>Term</span>
</span></span><span><span>    <span>|</span> <span>App</span> <span>Term</span> <span>Term</span>
</span></span></code></pre></div><p>Depending on how we execute our <code>App</code> term, this can be either CBV or CBN (but not both).
If we evaluate our argument and apply it to our function, that‚Äôs CBV.
If we apply our argument to our function unevaluated, that‚Äôs CBN.</p><p>However, we have to pick one: either CBV or CBN.
This is due to our values being all mixed up with our computations under one term.
CBN wants <code>App</code> to take a computation, but CBV wants <code>App</code> to take a value.
Because the two are indistinguishable we‚Äôre forced to pick one.
Our CBPV lambda calculus fixes this by sundering value and computation in two:</p><div><pre tabindex="0"><code data-lang="hs"><span><span><span>-- Type of values</span>
</span></span><span><span><span>data</span> <span>ValType</span> 
</span></span><span><span>    <span>=</span> <span>Int</span>
</span></span><span><span>    <span>|</span> <span>Thunk</span> <span>CompType</span>
</span></span><span><span>
</span></span><span><span><span>-- Type of computations</span>
</span></span><span><span><span>data</span> <span>CompType</span> 
</span></span><span><span>    <span>=</span> <span>Fun</span> <span>ValType</span> <span>CompType</span> <span>-- !!</span>
</span></span><span><span>    <span>|</span> <span>Return</span> <span>ValType</span>
</span></span><span><span>
</span></span><span><span><span>-- A value term</span>
</span></span><span><span><span>data</span> <span>Value</span>
</span></span><span><span>    <span>=</span> <span>Int</span> <span>Int</span>
</span></span><span><span>    <span>|</span> <span>Var</span> <span>Text</span>
</span></span><span><span>    <span>|</span> <span>Thunk</span> <span>Comp</span>
</span></span><span><span>
</span></span><span><span><span>-- A computation term</span>
</span></span><span><span><span>data</span> <span>Comp</span>
</span></span><span><span>    <span>=</span> <span>Fun</span> <span>Text</span> <span>Comp</span>
</span></span><span><span>    <span>|</span> <span>App</span> <span>Comp</span> <span>Value</span>
</span></span><span><span>    <span>|</span> <span>Return</span> <span>Value</span>
</span></span></code></pre></div><p>With that CPBV has cut the Gordian Knot, cementing its place as ruler of all Applications.
And we love that for them, but wow, it took a lot more stuff to do it (we doubled our line count).
It‚Äôs now exceedingly clear what‚Äôs a value and what‚Äôs a computation.
One surprising thing is that variables are a value.
What if our variable is bound to a computation?
CBPV has decreed: ‚Äúwe don‚Äôt have to worry about it‚Äù (although to be frank I‚Äôm a little worried about it).</p><p>If we look at our new <code>App</code> node, it can also only apply a value.
What a relief, that means we can still pass variables to functions.
But CBN has us pass around unevaluated arguments, the whole point is that they‚Äôre computations we haven‚Äôt evaluated to a value yet.
How are we going to do that if all our variables are values and all our function arguments are values?
The answer lies in a new <code>Value</code> node: <code>Thunk</code>.</p><p>A <code>Thunk</code> turns a computation into a value.
When we want to apply a computation to a function, we first have to turn it into a value using <code>Thunk</code>.
This detail is what makes CPBV so useful.
Being forced to be explicit about packaging our computations into values increases our ability to reason about work.</p><p>We can see another example of this in our new <code>Comp</code> node: <code>Fun</code>.
<code>Fun</code> can only return a <code>Comp</code>.
We can nest <code>Fun</code> nodes (since they are computations) to create multi argument functions.
But what if we want to return a function from a function?</p><p>For that we make use of our final new node <code>Return</code>.
<code>Return</code> is the compliment of <code>Thunk</code>.
It turns a <code>Value</code> into a <code>Computation</code>.
Using <code>Return</code> we can create a function that returns a function like so:</p><div><pre tabindex="0"><code data-lang="hs"><span><span>(<span>Fun</span> <span>&#34;x&#34;</span> (<span>Return</span> (<span>Thunk</span> (<span>Fun</span> <span>&#34;y&#34;</span> (<span>Return</span> (<span>Var</span> <span>&#34;x&#34;</span>))))))
</span></span></code></pre></div><p>This might seem like pageantry, and for a surface language humans write I‚Äôd have to agree.
But in a compiler IR, this distinction allows us to generate much more efficient code.</p><p>Now that we know what CBPV <em>is</em>, we can finally talk about why CBPV <em>is‚Ä¶the future</em>.
We know one big advantage is being explicit about where we turn computations into values (and back).
To help put that in perspective, look at this monstrosity from <a href="https://www.cambridge.org/core/journals/journal-of-functional-programming/article/making-a-fast-curry-pushenter-vs-evalapply-for-higherorder-languages/02447DB613E94DC35ACDCB24DB39F085" target="_blank" rel="noopener" data-goatcounter-click="https://www.cambridge.org/core/journals/journal-of-functional-programming/article/making-a-fast-curry-pushenter-vs-evalapply-for-higherorder-languages/02447DB613E94DC35ACDCB24DB39F085" data-goatcounter-title="Making a fast curry" data-goatcounter-referrer="I&#39;m betting on Call-by-Push-Value">Making a fast curry</a>
required to apply arguments to a function at runtime:</p><p><img src="https://thunderseethe.dev/img/stgApplyNP.png" alt="Code snippet showing function application in making of a fast curry"/></p><p>Not only do we have to look up the arity of the function, we have to look up whether we‚Äôre calling a function or a closure.
Even worse this all has to be done at runtime.
All these headaches go away with CBPV.
If we see a:</p><div><pre tabindex="0"><code data-lang="hs"><span><span>(<span>Fun</span> <span>&#34;x&#34;</span> (<span>Fun</span> <span>&#34;y&#34;</span> (<span>Return</span> (<span>Var</span> <span>&#34;x&#34;</span>))))
</span></span></code></pre></div><p>we know we have to apply two arguments. If instead we see:</p><div><pre tabindex="0"><code data-lang="hs"><span><span>(<span>Fun</span> <span>&#34;x&#34;</span> (<span>Return</span> (<span>Thunk</span> (<span>Fun</span> <span>&#34;y&#34;</span> (<span>Return</span> (<span>Var</span> <span>&#34;x&#34;</span>))))))
</span></span></code></pre></div><p>we can only apply 1 argument, and then we have a value we have to handle before we can do anymore.
It‚Äôs not even a valid term to apply two arguments to this term</p><p>Being explicit about values and computations isn‚Äôt solely a helpful optimization.
It opens the door to do new things we couldn‚Äôt before.
This is what actually led me to write this article.
I kept seeing otherwise unrelated papers employ CBPV to make their work possible.
Let‚Äôs look at those papers to see the different things CPBV can do:</p><ul><li><a href="https://dl.acm.org/doi/10.5555/645894.671755" target="_blank" rel="noopener" data-goatcounter-click="https://dl.acm.org/doi/10.5555/645894.671755" data-goatcounter-title="Algebraic Effects" data-goatcounter-referrer="I&#39;m betting on Call-by-Push-Value">Algebraic Effects</a>
(This one is actually covered in Levy‚Äôs paper)</li><li><a href="https://www.cl.cam.ac.uk/~nk480/implicit-polarized-f.pdf" target="_blank" rel="noopener" data-goatcounter-click="https://www.cl.cam.ac.uk/~nk480/implicit-polarized-f.pdf" data-goatcounter-title="Implicit Polarized F: Local Type Inference for Impredicativity" data-goatcounter-referrer="I&#39;m betting on Call-by-Push-Value">Implicit Polarized F: Local Type Inference for Impredicativity</a></li><li><a href="https://www.microsoft.com/en-us/research/uploads/prod/2020/03/kacc.pdf" target="_blank" rel="noopener" data-goatcounter-click="https://www.microsoft.com/en-us/research/uploads/prod/2020/03/kacc.pdf" data-goatcounter-title="Kinds Are Calling Conventions" data-goatcounter-referrer="I&#39;m betting on Call-by-Push-Value">Kinds Are Calling Conventions</a></li></ul><p>Algebraic effects are concerned with tracking side effects in types.
An issue you encounter immediately upon trying to do this is: where can effects happen?
Functions can do effects sure, that‚Äôs easy.
What about records, can they do effects?
Well that seems kind of silly, records are values, so let‚Äôs say no.
But what if the record contains a function that does an effect, what then?</p><p>CBPV deftly dispatches these quandaries.
Effects can appear on any computation type, and only on computation types.
Functions return a computation, so they can do effects.
But our records are values, so they can only store other values, not effects.</p><p>If we want to put a function in a record we first have to turn it into a <code>Thunk</code>.
So then our record can‚Äôt do effects.
If we want to perform our record‚Äôs function‚Äôs effects, we first have to turn it back into a computation with <code>Return</code>.
CBPV makes it explicit and clear where (and where not) effects can occur in a program.</p><p>This one has a daunting name, but it‚Äôs really cool.
It‚Äôs talking about type inference (a subject <a href="https://thunderseethe.dev/posts/type-inference/">we‚Äôre well versed in</a>
).
A timeworn tradeoff for type infer-ers is generic types.
If you allow a generic type to be inferred to be another generic type, your type inference is undecidable.
This puts us in a bind though.
A lot of cool types happen to involve these nested generics (called Rank-2, Rank-N, or Impredicative types), and if we can‚Äôt infer them we‚Äôre forced to write them down by hand.
Truly, a fate worse than death, so the types go sorely under-utilized.</p><p>This paper makes a dent in that problem by allowing us to infer these types, sometimes.
Sometimes may seem underwhelming, but you have to consider it‚Äôs infinitely better than never.
It does this with, you guessed it, CBPV.
As we‚Äôve seen, Call by push value makes it explicit when a function is saturated vs when it returns a closure.</p><p>This turns out to be vital information to have during type inference.
Saturated function calls have all their arguments, and these arguments can provide enough information to infer our function type.
Even when our function type includes nested generics.
That‚Äôs quite exciting!
All of a sudden our code requires fewer annotations because we made a smarter choice in language semantics.</p><p>Kinds Are Calling Conventions is a fascinating paper.
It employs kinds to solve issues that have plagued excessively generic languages since the first beta redux:</p><ul><li>Representation - is my type boxed or unboxed</li><li>Levity - is a generic argument evaluated lazily or eagerly</li><li>Arity - how many arguments does a generic function take before doing real work</li></ul><p>To solve these issues, types are given more sophisticated kinds.
Instead of type <code>Int</code> having kind <code>TYPE</code>, it would have kind <code>TYPE Ptr</code>.
Similarly, we ascribe the type <code>Int -&gt; Int -&gt; Int</code> the kind <code>TYPE Call[Int, Int]</code>.
Denoting that it is a function of arity 2 with its kind.
This is where CBPV enters the story.</p><p>To be able to provide the arity in a type‚Äôs kind, we first have to know a function‚Äôs arity.
This can be tricky in CBV or CBN languages that freely interchange functions and closures.
Thankfully, CBPV makes it abundantly clear what the arity of any function is, based purely on its type.</p><p>Kinds Are Calling conventions utilizes this to great effect to emit efficient calling code for higher order functions.
The paper also makes use of the fact that CBPV admits both eager and lazy evaluation to track how an argument is evaluated in the kind.
All in service of generating more efficient machine code.
Who could‚Äôve guessed such a theoretical approach would serve such pragmatic goals.</p><p>If I had a nickel for every time CBPV shows up in the wild, I‚Äôd have 3 nickels.
That‚Äôs not a lot, but it‚Äôs weird that it happened 3 times.
Personally, I believe this is because CBPV hits upon a kernel of truth in the universe.
Being explicit about what‚Äôs a computation and what‚Äôs a value allows us to reason about more properties of our programs.</p><p>Not only does it let us optimize our programs better, but it lets us do new kinds of polymorphism and decide fancier types in finite time.
Given how recent CBPV is in terms of research, I think we‚Äôre just seeing start of things you can do with CBPV, and we‚Äôll continue to discover more things moving forward.
I‚Äôm doing my part.
You better believe <a href="https://thunderseethe.dev/series/making-a-language/">my language</a>
will be built atop call-by-push-value.</p></div></div>
  </body>
</html>
