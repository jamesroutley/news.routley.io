<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.gtk.org/2024/01/28/new-renderers-for-gtk/">Original</a>
    <h1>New Renderers for GTK</h1>
    
    <div id="readability-page-1" class="page"><article id="post-9754">
	<!-- .entry-header -->

	
	
	<div>
		<p>Recently, GTK gained not one, but two new renderers: one for GL and one for Vulkan.</p>
<p>Since naming is hard, we reused existing names and called them “ngl” and “vulkan”. They are built from the same <a href="https://gitlab.gnome.org/GNOME/gtk/-/tree/main/gsk/gpu">sources</a>, therefore we also call them “unified” renderers.</p>
<p>But what is exciting about them?</p>
<h3>A single source</h3>
<p>As mentioned already, the two renderers are built from the same source. It is modeled to follow Vulkan apis, with some abstractions to cover the differences between Vulkan and GL (more specifically, GL 3.3+ and GLES 3.0+). This lets us share much of the infrastructure for walking the scene graph, maintaining transforms and other state, caching textures and glyphs, and will make it easier to keep both renderers up-to-date and on-par.</p>
<p>Could this unified approach be extended further, to cover a Metal-based renderer on macOS or a DirectX-based one on Windows? Possibly. The advantage of the Vulkan/GL combination is that they share basically the same shader language (GLSL, with some variations). That isn’t the case for Metal or DirectX. For those platforms, we either need to duplicate the shaders or use a translation tool like <a href="https://github.com/KhronosGroup/SPIRV-Cross">SPIRV-Cross</a>.</p>
<p>If that is the kind of thing that excites you, help is welcome.</p>
<h3>Implementation details</h3>
<p>The old GL renderer uses simple shaders for each rendernode type and frequently resorts to offscreen rendering for more complex content. The unified renderers have (more capable) per-node shaders too, but instead of relying on offscreens, they will also use a complex shader that interprets data from a buffer. In game programming, this approach is known as a <a href="https://dolphin-emu.org/blog/2017/07/30/ubershaders/">ubershader</a>.</p>
<p>The unified renderer implementation is less optimized than the old GL renderer, and has been written with a focus on correctness and maintainability. As a consequence, it can handle much more varied rendernode trees correctly.</p>
<p>Here is an harmless-looking example:</p>
<pre>repeat {
  bounds: 0 0 50 50;
  child: border {
    outline: 0 0 4.3 4.3;
    widths: 1.3;
  }
}</pre>
<figure id="attachment_9883" aria-describedby="caption-attachment-9883"><a href="https://blog.gtk.org/files/2024/01/difficult.png"><img decoding="async" src="https://blog.gtk.org/files/2024/01/difficult.png" alt="" width="120" height="50"/></a><figcaption id="caption-attachment-9883">gl (left) ngl (right)</figcaption></figure>
<figure id="attachment_9886" aria-describedby="caption-attachment-9886"><a href="https://blog.gtk.org/files/2024/01/difficult-zoom.png"><img decoding="async" src="https://blog.gtk.org/files/2024/01/difficult-zoom-300x125.png" alt="" width="300" height="125" srcset="https://blog.gtk.org/files/2024/01/difficult-zoom-300x125.png 300w, https://blog.gtk.org/files/2024/01/difficult-zoom.png 600w" sizes="(max-width: 300px) 85vw, 300px"/></a><figcaption id="caption-attachment-9886">A close-up view</figcaption></figure>
<h3>New capabilities</h3>
<p>We wouldn’t have done all this work, if there wasn’t some tangible benefit. Of course, there’s new features and capabilities. Lets look at some:</p>
<p><em>Antialiasing. </em>A big problem with the old GL renderer is that it will just lose fine details. If something is small enough to fall between the boundaries of a single line of pixels, it will simply disappear. In particular this can affect  underlines, such as mnemonics. The unified renderers handle such cases better, by doing antialiasing. This helps not just for preserving fine detail, but also prevents jagged outlines of primitives.</p>
<figure id="attachment_9805" aria-describedby="caption-attachment-9805"><a href="https://blog.gtk.org/files/2024/01/aa.png"><img decoding="async" src="https://blog.gtk.org/files/2024/01/aa-300x150.png" alt="" width="300" height="150" srcset="https://blog.gtk.org/files/2024/01/aa-300x150.png 300w, https://blog.gtk.org/files/2024/01/aa-1024x512.png 1024w, https://blog.gtk.org/files/2024/01/aa-768x384.png 768w, https://blog.gtk.org/files/2024/01/aa-1200x600.png 1200w, https://blog.gtk.org/files/2024/01/aa.png 1280w" sizes="(max-width: 300px) 85vw, 300px"/></a><figcaption id="caption-attachment-9805">Close-up view of GL vs NGL</figcaption></figure>
<p><em>Fractional scaling. </em>Antialiasing is also the basis that lets us handle fractional scales properly. If your  1200 × 800 window is set to be scaled to 125 %, with the unified renderers, we will use a framebuffer of size 1500 × 1000 for it, instead of letting the compositor downscale a 2400 × 1600 image. Much less pixels, and a sharper image.</p>
<p><em>Arbitrary gradients. </em>The old GL renderer handles linear, radial and conic gradients with up to 6 color stops. The unified renders allow an <em>unlimited</em> number of color stops. The new renderers also apply antialiasing to gradients, so sharp edges will have smooth lines.</p>
<figure id="attachment_9895" aria-describedby="caption-attachment-9895"><a href="https://blog.gtk.org/files/2024/01/lg1.png"><img loading="lazy" decoding="async" src="https://blog.gtk.org/files/2024/01/lg1.png" alt="" width="301" height="47"/></a><figcaption id="caption-attachment-9895">A linear gradient with 64 color stops</figcaption></figure>
<p><em>Dmabufs. </em>As a brief detour from the new renderers, we worked on dmabuf support and graphics offloading <a href="https://blog.gtk.org/2023/11/15/introducing-graphics-offload/">last fall</a>. The new renderers support this and extend it to create dmabufs when asked to produce a texture via the <a href="https://docs.gtk.org/gsk4/method.Renderer.render_texture.html">render_texture</a> api (currently, just the Vulkan renderer).</p>
<h3>Any sharp edges?</h3>
<p>As is often the case, with new capabilities comes the potential for new gotchas. Here are some things to be aware of, as an app developer:</p>
<p><em>No more glshader nodes.</em> Yes, they made for some fancy demos for 4.0, but they are very much tied to the old GL renderer, since they make assumptions about the GLSL api exposed by that renderer. Therefore, the new renderers don’t support them.</p>
<p>You have been warned in the docs:</p>
<blockquote><p>If there is a problem, this function returns FALSE and reports an error. You should use this function before relying on the shader for rendering and use a fallback with a simpler shader or without shaders if it fails.</p></blockquote>
<p>Thankfully, many uses of the glshader node are no longer necessary, since GTK has gained new features since 4.0, such as mask nodes and support for straight-alpha textures.</p>
<p><em>Fractional positions.</em> The old GL renderer is rounding things, so you could get away with handing it fractional positions. The new renderers will place things where you tell it. This can sometimes have unintended <a href="https://gitlab.gnome.org/GNOME/gtk/-/issues/6361">consequences</a>, so should be on the lookout and make sure that your positions are where they should be.</p>
<p>In particular, look out for out for cairo-style drawing where you place lines at half-pixel positions so they fill out one row of pixels precisely.</p>
<p><em>Driver problems. </em>The new renderers are using graphics drivers in new and different ways, so there is potential for triggering problems on that side.</p>
<p>Please file problems you see against GTK even if they look like driver issues, since it is useful for us to get an overview how well (or badly) the new code works with the variety of drivers and hardware out there.</p>
<h3>But is it faster?</h3>
<p>No, the new renderers are not faster (yet).</p>
<p>The old GL renderer is heavily optimized for speed. It also uses much simpler shaders, and does not do the math that is needed for features such as antialiasing. We want to make the new renderers faster eventually, but the new features and correctness make them very exciting, even before we reach that goal. All of the GPU-based renderers are more than fast enough to render todays GTK apps at 60 or 144 fps.</p>
<p>That being said, the Vulkan renderer comes close to matching and surpassing the old GL renderer in some unscientific benchmarks. The new GL renderer is slower for some reason that we have not tracked down yet.</p>
<h3>New defaults</h3>
<p>In the just-released 4.13.6 snapshot, we have made the ngl renderer the new default. This is a trial balloon — the renderers need wider testing with different apps too verify that they are ready for production. If significant problems appear, we can revert back to the gl renderer for 4.14.</p>
<p>We decided not make the Vulkan renderer the default yet, since it is behind the GL renderers in a few application integration aspects: the webkit GTK4 port works with GL, not with Vulkan, and GtkGLArea and GtkMediaStream currently both produce GL textures that the Vulkan renderer can’t directly import. All of these issues will hopefully be addressed in the not-too-distant future, and then we will revisit the default renderer decision.</p>
<p>If you are using GTK on very old hardware, you may be better off with the old GL renderer, since it makes fewer demands on the GPU. You can override the renderer selection using the GSK_RENDERER environment variable:</p>
<pre>GSK_RENDERER=gl</pre>
<h3>Future plans and possibilities</h3>
<p>The new renderers are a good foundation to implement things that we’ve wanted to have for a long time, such as</p>
<ul>
<li>Proper color handling (including HDR)</li>
<li>Path rendering on the GPU</li>
<li>Possibly including glyph rendering</li>
<li>Off-the-main-thread rendering</li>
<li>Performance (on old and less powerful devices)</li>
</ul>
<p>Some of these will be a focus of our work in the near and medium-term future.</p>
<h3>Summary</h3>
<p>The new renderers have some exciting features, with more to come.</p>
<p>Please try them out, and let us know what works and what doesn’t work for you.</p>
	</div><!-- .entry-content -->

	<!-- .entry-footer -->
</article></div>
  </body>
</html>
