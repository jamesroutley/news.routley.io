<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://maskray.me/blog/2024-06-30-integrated-assembler-improvements-in-llvm-19">Original</a>
    <h1>Integrated assembler improvements in LLVM 19</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
      
        <p>Within the LLVM project, MC is a library responsible for handling
assembly, disassembly, and object file formats. [Intro to the LLVM MC
Project], which was written back in 2010, remains a good source to
understand the high-level structures.</p>
<p>In the latest release cycle, substantial effort has been dedicated to
refining MC&#39;s internal representation for improved performance and
readability. These changes have <a href="#summary">decreased compile
time significantly</a>. This blog post will delve into the details,
providing insights into the specific changes.</p>
<h2 id="mcassembler-and-mcasmlayout"><code>MCAssembler</code> and
<code>MCAsmLayout</code></h2>
<p><code>MCAssembler</code> manages assembler states (including
sections, symbols) and implements layout and object file writing after
parsing. <code>MCAsmLayout</code>, tightly coupled with
<code>MCAssembler</code>, was in charge of symbol and fragment offsets
during <code>MCAssembler::Finish</code>. Many <code>MCAssembler</code>
and <code>MCExpr</code> member functions have a
<code>const MCAsmLayout &amp;</code> parameter, contributing to slight
overhead.</p>
<p>I have <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/commit/67957a45ee1ec42ae1671cdbfa0d73127346cc95">started
to merge</a> <code>MCAsmLayout</code> into <code>MCAssembler</code> and
simplify fragment management.</p>
<h2 id="fragments">Fragments</h2>
<p>Fragments, representing sequences of non-relaxable instructions,
relaxable instruction, alignment directives, and other elements.
<code>MCDataFragment</code> and <code>MCRelaxableFragment</code>, whose
sizes are crucial for memory consumption, have undergone several
optimizations:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/pull/94913">MCInst:
decrease inline element count to 6</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/pull/95293">[MC]
Reduce size of MCDataFragment by 8 bytes</a> by <span data-cites="aengelke">@aengelke</span></li>
<li><a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/pull/95341">[MC] Move
MCFragment::Atom to MCSectionMachO::Atoms</a></li>
</ul>
<p>The fragment management system has also been streamlined by
transitioning from a doubly-linked list (<code>llvm::iplist</code>) to a
<a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/pull/95077">singly-linked
list</a>, eliminating unnecessary overhead. A few prerequisite commits
removed backward iterator requirements.</p>
<p>Furthermore, I <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/commit/e48c4011ca80385573f1b92793c75dc98abb228f">introduced
the &#34;current fragment&#34; concept</a> (<code>MCSteamer::CurFrag</code>)
allowing for faster appending of new fragments.</p>
<h2 id="symbols">Symbols</h2>
<p><span data-cites="aengelke">@aengelke</span> made
two noticeable performance improvements:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/pull/95021">[MC] Don&#39;t
evaluate name of unnamed symbols</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/pull/95464">[MC]
Eliminate two symbol-related hash maps</a></li>
</ul>
<p>In <code>MCObjectStreamer</code>, newly defined labels were put into
a &#34;pending label&#34; list and initially assigned to a
<code>MCDummyFragment</code> associated with the current section. The
symbols will be reassigned to a new fragment when the next instruction
or directive is parsed. This pending label system, while necessary for
aligned bundling, introduced complexity and potential for subtle
bugs.</p>
<p>To streamline this, I <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/commit/75006466296ed4b0f845cbbec4bf77c21de43b40">revamped
the implementation</a> by directly adjusting offsets of existing
fragments, eliminating over 100 lines of code and reducing the potential
for errors.</p>
<p>Details: In 2014, <a target="_blank" rel="noopener" href="https://reviews.llvm.org/D5915">[MC]
Attach labels to existing fragments instead of using a separate
fragment</a> introduced <code>flushPendingLabels</code> aligned bundling
assembler extension for Native Client. <a target="_blank" rel="noopener" href="https://reviews.llvm.org/D71368">[MC] Match labels to existing
fragments even when switching sections.</a>, built on top of
<code>flushPendingLabels</code>, added further complication. Worse, a
lot of directive handling code have to add
<code>flushPendingLabels</code> and a missing
<code>flushPendingLabels</code> could lead to subtle bugs related to
incorrect symbol values.</p>
<p>For the following code, aligned bundling requires that
<code>.Ltmp</code> is defined at <code>addl</code>. </p><figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>$ clang var.c -S -o - -fPIC -m32</span></pre></td></tr></tbody></table></figure>
<p>( <code>MCAsmStreamer</code> doesn&#39;t call
<code>flushPendingLabels</code> in its handlers. This is the reason that
we cannot change <code>MCAsmStreamer::getAssemblerPtr</code> to use a
<code>MCAssembler</code> and change
<code>AsmParser::parseExpression</code>. )</p>
<h2 id="sections">Sections</h2>
<p>Section handling was also refined. MCStreamer maintains a a section
stack for features like
<code>.push_section</code>/<code>.pop_section</code>/<code>.previous</code>
directives. Many functions relied on the section stack for loading the
current section, which introduced overhead due to the additional
indirection and nullable return values.</p>
<p>By leveraging the &#34;current fragment&#34; concept, the need for the
section stack was eliminated in most cases, simplifying the codebase and
improving efficiency.</p>
<p>I have eliminated nullable <code>getCurrentSectionOnly</code> uses
and <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/commit/626eef5ecf92e98cbfccfa6134e0a760e7592813">changed
<code>getCurrentSectionOnly</code> to leverage the &#34;current fragment&#34;
concept</a>. This change also <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/commit/4ae23bcca144b542f16d45acc8f270e156e2fa4e">revealed
an interesting quirk</a> in NVPTX assembly related to DWARF
sections.</p>
<h2 id="section-symbols">Section symbols</h2>
<p>Many section creation functions (<code>MCContext::get*Section</code>)
had a <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/commit/6b9998b3ebd4f21ba726e65e5fe2636e4eeed598"><code>const char *BeginSymName</code>
parameter</a> to support the section symbol concept. This led to issues
when we want to treat the section name as a symbol. In 2017, the
parameter was <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/commit/13a79bbfe583e1d8cc85d241b580907260065eb8">removed
for ELF</a>, streamlining section symbol handling.</p>
<p>I changed the way MC handles section symbols for <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/pull/96459">COFF</a> and
removed the unused parameters for WebAssembly. The work planned for
XCOFF is outlined in <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/issues/96810">https://github.com/llvm/llvm-project/issues/96810</a>.</p>
<h2 id="expression-evaluation">Expression evaluation</h2>
<p>Expression evaluation in <code>MCAssembler::layout</code> previously
employed a complex lazy evaluation algorithm, which aimed to minize the
number of fragment relaxation. It proved difficult to understand and
resulted in <a target="_blank" rel="noopener" href="https://reviews.llvm.org/D79570">complex recursion
detection</a>.</p>
<p>To address this, I removed lazy evaluation in favor of <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/commit/9d0754ada5dbbc0c009bcc2f7824488419cc5530">eager
fragment relaxation</a>. This simplification improved the reliability of
the layout process, eliminating the need for intricate workarounds like
the <code>MCFragment::IsBeingLaidOut</code> flag introduced earlier.</p>
<p>Note: the benefit of lazy evaluation largely diminished when <a target="_blank" rel="noopener" href="https://reviews.llvm.org/D76114">https://reviews.llvm.org/D76114</a> invalidated all sections
to fix the correctness issue for the following assembly:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>.section .text1,&#34;ax&#34;</span></pre></td></tr></tbody></table></figure>
<p>In addition, I removed <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/commit/3a90c27385e9a8b50e40a307822906a1303c310b">an
overload of isSymbolRefDifferenceFullyResolvedImpl</a>, enabling
constant folding for variable differences in Mach-O.</p>
<h2 id="target-specific-features-misplaced-in-the-generic-implementation">Target-specific
features misplaced in the generic implementation</h2>
<p>I have made efforts to relocate target-specific functionalities to
their respective target implementations:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/pull/96835">[MC,X86]
emitInstruction: remove virtual function calls due to Intel JCC
Erratum</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/pull/97008">[MC,X86]
De-virtualize emitPrefix</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/commit/41a08e764aeec92703285754b5e8acd85283b1a6">[MC]
Move Mach-O specific getAtom and isSectionAtomizableBySymbols to Mach-O
files</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/commit/fec1b6f9d3cf5347b67ffb2078c995eb496acf47">[MC]
Move ELFWriter::createMemtagRelocs to
AArch64TargetELFStreamer::finish</a></li>
</ul>
<h2 id="crel">CREL</h2>
<p>The integrated assembler will support compact relocations for ELF <a target="_blank" rel="noopener" href="https://discourse.llvm.org/t/rfc-crel-a-compact-relocation-format-for-elf/77600">https://discourse.llvm.org/t/rfc-crel-a-compact-relocation-format-for-elf/77600</a></p>
<h2 id="summary">Summary</h2>
<p>LLVM 19 introduces significant enhancements to the integrated
assembler, resulting in notable performance gains, reduced memory usage,
and a more streamlined codebase. These optimizations pave the way for
future improvements.</p>
<p>I compiled the preprocessed SQLite Amalgamation (from <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-test-suite">llvm-test-suite</a>)
using a Release build of clang:</p>
<table>
<thead>
<tr>
<th>build</th>
<th>2024-05-14</th>
<th>2024-06-30</th>
</tr>
</thead>
<tbody>
<tr>
<td>-O0</td>
<td>0.5304</td>
<td>0.4942</td>
</tr>
<tr>
<td>-O0 -g</td>
<td>0.8818</td>
<td>0.8026</td>
</tr>
<tr>
<td>-O2</td>
<td>6.249</td>
<td>6.087</td>
</tr>
<tr>
<td>-O2 -g</td>
<td>7.931</td>
<td>7.659</td>
</tr>
</tbody>
</table>
<p><code>clang -c -w sqlite3.i</code></p>
<p>The AsmPrinter pass, which couples the assembler, dominates the
<code>-O0</code> compile time. I have modified the
<code>-ftime-report</code> mechanism to decrease the per-instruction
overhead. The decrease in compile time matches the decrease in the spent
in AsmPrinter. Coupled with a recent observation that BOLT, which
heavily utilizes MC, is ~8% faster, it&#39;s clear that MC modifications
have yielded substantial improvements.</p>
<h2 id="roadmap">Roadmap</h2>
<h3 id="symbol-redefinition">Symbol redefinition</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/commit/ae7ac010594f693fdf7b3ab879e196428d961e75">llvm-mc:
Diagnose misuse (mix) of defined symbols and labels.</a> added
redefinition error. This was refined many times. I hope to fix this in
the future.</p>
<h3 id="addressing-mach-o-weakness">Addressing Mach-O weakness</h3>
<p>The Mach-O assembler lacks the robustness of its ELF counterpart.
Notably, certain aspects of the Mach-O implementation, such as the
conditions for constant folding in
<code>MachObjectWriter::isSymbolRefDifferenceFullyResolvedImpl</code>
(different for x86-64 and AArch64), warrant revisiting.</p>
<p>Additionally, the Mach-O has a hack to <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/issues/19577">maintain
compatibility with Apple cctools assembler</a>, when the relocation
addend is non-zero.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>.data</span></pre></td></tr></tbody></table></figure>
<p>This leads to another workaround in
<code>MCFragment.cpp:getSymbolOffsetImpl</code> (<a target="_blank" rel="noopener" href="https://reviews.llvm.org/D109109">[MC] Recursively calculate
symbol offset</a>), which is to support the following assembly:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>l_a:</span></pre></td></tr></tbody></table></figure>

      
    </div></div>
  </body>
</html>
