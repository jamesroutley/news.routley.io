<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/Articles/1034603/">Original</a>
    <h1>Tracking trust with Rust in the kernel</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>
The Linux kernel has to handle many different sources of data that should not
be trusted: user space, network connections, and removable storage, to name a
few. The kernel has to remain secure even if one of these sends garbled (or
malicious) data. Benno Lossin has been working on an API for kernel Rust code
that makes it harder to accidentally make decisions based on data from user space. That work
is now on its
<a href="https://lwn.net/ml/all/20250814124424.516191-1-lossin@kernel.org/">
fourth revision</a>, and Lossin has asked kernel developers to experiment with
it and see where problems remain, making this a good time to look at the proposed API.
</p>

<p>
The core approach, as with so many things in Rust, centers on the type system.
Lossin&#39;s patch set introduces a new type, <tt>Untrusted</tt>, that marks data as
originating from an untrusted source, and therefore requiring special caution.
Trying to access a value wrapped by <tt>Untrusted</tt> is forbidden by Rust.
The type is a &#34;transparent&#34; structure, meaning that it will be laid out in
memory exactly like the type that it wraps. An <tt>Untrusted&lt;u8&gt;</tt> is a
single byte, for example. The type therefore has no run-time overhead, so it can
be used as a kind of marker in the type system for data that has come from user
space without being validated. That makes it impossible to pass into functions
that expect normal kernel data by accident.
</p>

<!-- middle-ad -->

<p>
The bulk of Lossin&#39;s patch set is documentation for <tt>Untrusted</tt>, and some
utility functions to manipulate untrusted values. There is also special support
for
<a href="https://lwn.net/Articles/1026694/">
common data structures</a>, specifically
<a href="https://doc.rust-lang.org/stable/std/primitive.slice.html">
slices</a> (arrays with a run-time-known length) and
<a href="https://rust.docs.kernel.org/kernel/alloc/kvec/struct.Vec.html">
vectors</a> (growable arrays on the heap) of untrusted values. When dealing with an existing buffer that should be
filled with untrusted data, the documentation recommends writing the interface
like this:
</p>

<pre>    pub fn read_from_userspace(buf: &amp;mut [Untrusted&lt;u8&gt;])
</pre>

<p>
That function takes a mutable reference to a slice of untrusted bytes, and will
fill it with user-space data. That data can later be copied back to user
space without having to unwrap it. Trying to actually use the value of an
untrusted object within the kernel, however, will cause a compiler error.
Lossin
recommends that form of API because
converting an <tt>&amp;mut Untrusted&lt;[u8]&gt;</tt> (a mutable reference to an
untrusted slice of bytes) into an <tt>&amp;mut
[Untrusted&lt;u8&gt;]</tt> (a mutable reference to a slice of individually
untrusted bytes) can be done automatically — conversions are inserted where
needed by the compiler due to the
<a href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html">
<tt>DerefMut</tt></a> implementation for <tt>Untrusted</tt> — but converting
things the other way around requires an explicit function call. If Rust
developers get in the habit of writing APIs involving <tt>Untrusted</tt> in this
way, they&#39;ll be less of a hassle to use.
</p>

<p>
Sometimes, the kernel does need to read user-space data, not merely copy it
around. The
<a href="https://lwn.net/ml/all/20250814124424.516191-4-lossin@kernel.org/">
third patch</a> of the set contains functions to help with that. It introduces a
new trait called <tt>Validate</tt> that encapsulates the logic for validating
user-space data before use. For a custom type <tt>T</tt>, an implementation of
<tt>Validate&lt;S&gt;</tt> contains the logic needed to turn an
<tt>Untrusted&lt;S&gt;</tt> into a plain <tt>T</tt>. Lossin isn&#39;t totally happy
with that API, though, and wants to find time to improve it.
</p>

<p>
Greg Kroah-Hartman, who has been
<a href="https://lwn.net/ml/all/2024091313-uplifting-hardcopy-395f%40gregkh/">
enthusiastic</a> about the idea of marking input
from user space in the past,
<a href="https://lwn.net/ml/all/2025081416-sufferer-economist-3f00@gregkh/">
asked</a> for Lossin to add an example of a driver
using <tt>Untrusted</tt>.
</p>

<blockquote>
ioctl() is the callback that is taking untrusted data from userspace.
That&#39;s one place we have had more kernel buffer overflows then I can
count and ALWAYS needs to be properly verified before anything can be
done with the data there.
</blockquote>

<p>
Lossin hasn&#39;t written a complete example driver, but did
<a href="https://lwn.net/ml/all/DC2TOYQG9QEI.2TZ4GFFZGF05W@kernel.org/">
share</a> a rough sketch of what using
the new API to implement a driver
<a href="https://www.man7.org/linux/man-pages/man2/ioctl.2.html">
<tt>ioctl()</tt></a> function might look like.
<tt>ioctl()</tt> is a tricky interface because it takes two parameters:
<tt>cmd</tt>, which specifies which command to run, and <tt>arg</tt>, the
meaning of which depends on <tt>cmd</tt>. How <tt>arg</tt> should
be validated depends, therefore, on which command user space has sent. Lossin suggested
representing this in Rust with an enumeration:
</p>

<pre>    enum MyIoctlArgs {
        WriteFoo(UserPtr&lt;Foo&gt;),
        VerifyBar(UserPtr&lt;Bar&gt;),
        // ...
    }
</pre>

<p>
With some suitable tweaks to the Rust driver API, the generic
<a href="https://rust.docs.kernel.org/kernel/miscdevice/trait.MiscDevice.html#method.ioctl">
<tt>MiscDevice::ioctl()</tt></a> function could take a structure that bundles
<tt>cmd</tt> and <tt>arg</tt> together:
</p>

<pre>    pub struct IoctlArgs {
        pub cmd: u32,
        pub arg: usize,
    }

    fn ioctl(
        _device: &lt;Self::Ptr as ForeignOwnable&gt;::Borrowed&lt;&#39;_&gt;,
        _file: &amp;File,
        _args: Untrusted&lt;IoctlArgs&gt;,
    ) -&gt; Result&lt;isize&gt;
</pre>

<p>
The <tt>Untrusted&lt;IoctlArgs&gt;</tt> could then be validated into a normal
<tt>MyIoctlArgs</tt> value. This would not prevent the programmer from botching
the validation logic, of course, but it would force the conversion to happen in
one specific place, and enforce that it is called. Hopefully, that makes it
easier to spot missing checks.
</p>

<p>
Kroah-Hartman
<a href="https://lwn.net/ml/all/2025081505-facial-cyclic-af25@gregkh/">
raised</a> the problem of bugs where the kernel &#34;validates&#34; a particular
piece of data while it is still accessible to user space, and only then copies
it with
<a href="https://docs.kernel.org/kernel-hacking/hacking.html#copy-to-user-copy-from-user-get-user-put-user">
<tt>copy_from_user()</tt></a>.
He wondered how this interface could protect
against that. The <tt>UserPtr</tt> types in <tt>MyIoctlArgs</tt>
in his example help there, Lossin
<a href="https://lwn.net/ml/all/2025081505-facial-cyclic-af25@gregkh/">
explained</a>. These represent pointers to user-space memory; when combined with a
length, they can become a <tt>UserSlice</tt>.
The
<a href="https://rust.docs.kernel.org/kernel/uaccess/struct.UserSlice.html#method.read_all">
<tt>UserSlice::read_all()</tt></a> method being the Rust equivalent of
<tt>copy_from_user()</tt>. Right now, <tt>read_all()</tt> just reads bytes
directly, but if his patch set is accepted, he would want to change it to mark
the read bytes as untrusted:
</p>

<pre>    pub fn read_all&lt;A: Allocator&gt;(
        self,
        buf: &amp;mut Untrusted&lt;Vec&lt;u8, A&gt;&gt;,
        flags: Flags
    ) -&gt; Result
</pre>

<p>
With the types Lossin sketched out, the type system would theoretically
enforce the progression from
<tt>Untrusted&lt;IoctlArgs&gt;</tt>, to <tt>MyIoctlArgs</tt>, to
<tt>UserPtr</tt>, to <tt>Untrusted&lt;Vec&lt;u8&gt;&gt;</tt>, to whatever
user-defined type is appropriate for the argument of <tt>ioctl()</tt>. Since he
did not provide a full, working example, there are still some questions his
response leaves unanswered, but
Kroah-Hartman was
<a href="https://lwn.net/ml/all/2025081746-aspirate-diminish-29cd@gregkh/">
happy</a> with it. At the time of writing no other
comments on the patch set have been made. If the API is adopted in its current
form, it will necessitate pervasive changes to the interfaces for Rust drivers, so the
patch set seems likely to be a topic of discussion at the upcoming
<a href="https://kangrejos.com/">
Kangrejos</a>
conference about the Rust for Linux project in September.
</p></div></div>
  </body>
</html>
