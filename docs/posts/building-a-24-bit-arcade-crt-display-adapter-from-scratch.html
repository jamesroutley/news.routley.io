<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.scd31.com/posts/building-an-arcade-display-adapter">Original</a>
    <h1>Building a 24-bit Arcade CRT Display Adapter, From Scratch</h1>
    
    <div id="readability-page-1" class="page"><div><section><p>In November, my friend and fellow Recurser, <a href="https://www.frankchiarulli.com/">Frank</a>, picked up an arcade machine for the <a href="https://www.recurse.com/">Recurse Center</a>. We call it the RCade. He wanted to leave the original CRT in - which I think is a great choice! - and drove it off of a Raspberry Pi. Eventually we wanted to move to a more powerful computer, but we needed a way to connect it to the display. Off-hand, I mentioned that I could build a CRT display adapter that interfaces with a normal computer over USB. This is that project.</p></section><h2>What the display expects</h2><section><p>The CRT in the RCade has a JAMMA connector, and Frank bought a converter that goes between VGA and JAMMA.</p><p>You might think we could just use an off-the-shelf VGA adapter to drive it at this point, but it&#39;s not that simple. The CRT runs at a weird resolution; We started with 320x240 but eventually wanted to target 336x262, which is super non-standard. Even 320x240 is unattainable by most display adapters, which typically can&#39;t go below 640x480. A custom solution would allow us to output any arbitrary resolution we wanted.</p><p>The other thing is that the Pi, with the <a href="https://github.com/fenlogic/vga666">VGA board</a> we were using, only supports 18-bit colour, and we wanted to improve this. Even on the RCade&#39;s CRT, colour banding was an obvious issue.</p><p>We also wanted to use a laptop, not a desktop, which meant not using a PCI-e card. Instead, a USB interface would be preferable.</p></section><h2>Wait, but what is VGA?</h2><section><p>VGA is a signaling protocol that maps almost exactly 1:1 with what a CRT actually does.</p><p><a href="https://rhodesmill.org/img/rcade/crt-diagram.jpg"><img src="https://rhodesmill.org/thumb/rcade/crt-diagram.jpg"/></a></p><small>Taken from wikimedia.org</small><p>Inside of a CRT, there are 3 electron guns, which correspond to red, green, and blue colour values. Two electromagnets in the neck of the tube are responsible for steering the beam - one steers horizontally and one steers vertically. To draw an image, the beam moves across the screen one horizontal line at a time, and the electron guns are rapidly modulated in order to display the correct colour at each pixel.</p><p>VGA contains analog signals for these R, G, and B electron guns. It also contains an HSYNC and VSYNC signal, which are used so that the driver and the CRT can agree on what pixel is being drawn at a given time. Between the VGA input and the CRT is a very simple circuit which locks onto these HSYNC and VSYNC pulses and synchronizes the sweeping of the beam.</p><p><a href="https://rhodesmill.org/img/rcade/vga-timing.png"><img src="https://rhodesmill.org/thumb/rcade/vga-timing.png"/></a></p><small>Taken from pyroelectro.com</small><p>The HSYNC pulses happen in between horizontal lines, and the VSYNC pulses happen in between frames. There are dead zones around each pulse - referred to as the front and back porch - which give the electron beam time to sweep back across the screen.</p><p>So, all we really need are those R, G, B, HSYNC, and VSYNC signals, running at precise timing, and synced properly relative to each other. Conceptually this is actually pretty simple!</p></section><h2>Attempt 1: Using the RP2040&#39;s PIO</h2><section><p>I like the Raspberry Pi RP2040 a lot. It&#39;s relatively cheap (around $1 USD) and has tons of on-board RAM - 264 KB in fact! It also has what is called Programmable IO, or PIO.</p><p>I&#39;ve never used the PIO before, but the basic idea is that you can write assembly programs where every instruction takes exactly one cycle, and has useful primitives for interacting with GPIO. It&#39;s a fairly limited instruction set, but it allows for bit-banging precise cycle-accurate custom protocols. It&#39;s exactly what I need to modulate a VGA signal.</p><p>The PIO code ended up looking like this:</p><pre><span>  </span><span>// 1. low for 320+16=336 pixels
</span><span>  </span><span>// 2. high for 30 pixels
</span><span>  </span><span>// 3. low for 34 pixels
</span><span>  </span><span>// 4. repeat
</span><span>  </span><span>// runs on sm0
</span><span>  </span><span>// 6 instrs -&gt; can save some with sidesetting
</span><span>  </span><span>let</span><span> hsync = pio::pio_asm!(
</span><span>      &#34;</span><span>.wrap_target</span><span>&#34;,
</span><span>      </span><span>/* begin pixels + front porch */
</span><span>      &#34;</span><span>irq set 0 [2]</span><span>&#34;,    </span><span>// tell vsync we&#39;re doing 1 line
</span><span>      &#34;</span><span>set pins, 1 [31]</span><span>&#34;, </span><span>// go low for 32
</span><span>      &#34;</span><span>set X, 8 [15]</span><span>&#34;,    </span><span>// +16 = 48
</span><span>      &#34;</span><span>a:</span><span>&#34;,
</span><span>      &#34;</span><span>jmp X-- a [31]</span><span>&#34;, </span><span>// each loop 32, * 9 = 288, total = 336
</span><span>      </span><span>/* end front porch, being assert hsync */
</span><span>      &#34;</span><span>set pins, 0 [29]</span><span>&#34;, </span><span>// assert hsync for 30
</span><span>      </span><span>/* end assert hsync, begin back porch */
</span><span>      &#34;</span><span>set pins, 1 [29]</span><span>&#34;, </span><span>// deassert, wait 32 (note there is extra delay after the wrap)
</span><span>      &#34;</span><span>.wrap</span><span>&#34;
</span><span>    );
</span><span>
</span><span>  </span><span>// NOTE - we get irq at *end* of line so we have to time things accordingly
</span><span>  </span><span>// 1. low for 242 lines -&gt; but irq 2 every line for the first 240
</span><span>  </span><span>// 2. high for 3 lines
</span><span>  </span><span>// 3. low for 22 lines
</span><span>  </span><span>// 4. repeat
</span><span>  </span><span>// runs on sm1
</span><span>  </span><span>// 19 instr
</span><span>  </span><span>let</span><span> vsync = pio::pio_asm!(
</span><span>      &#34;</span><span>.side_set 1 opt</span><span>&#34;,
</span><span>      &#34;</span><span>.wrap_target</span><span>&#34;,
</span><span>      &#34;</span><span>set Y, 6</span><span>&#34;,
</span><span>      &#34;</span><span>a_outer:</span><span>&#34;,
</span><span>      &#34;</span><span>set X, 31</span><span>&#34;,
</span><span>      &#34;</span><span>a:</span><span>&#34;,
</span><span>      &#34;</span><span>wait 1 irq 0</span><span>&#34;,
</span><span>      &#34;</span><span>irq set 2</span><span>&#34;,
</span><span>      &#34;</span><span>jmp X-- a</span><span>&#34;, </span><span>// 32 lines per inner loop
</span><span>      &#34;</span><span>jmp Y-- a_outer</span><span>&#34;, </span><span>// 7 outer loops = 224
</span><span>
</span><span>      &#34;</span><span>set X, 15</span><span>&#34;, </span><span>// 16 more lines = 240
</span><span>      &#34;</span><span>z:</span><span>&#34;
</span><span>      &#34;</span><span>wait 1 irq 0</span><span>&#34;,
</span><span>      &#34;</span><span>irq set 2</span><span>&#34;,
</span><span>      &#34;</span><span>jmp X-- z</span><span>&#34;,
</span><span>
</span><span>      &#34;</span><span>wait 1 irq 0</span><span>&#34;, </span><span>// wait for end of last rgb line
</span><span>      &#34;</span><span>wait 1 irq 0</span><span>&#34;, </span><span>// 2 more lines for front porch
</span><span>      &#34;</span><span>wait 1 irq 0</span><span>&#34;,
</span><span>
</span><span>      &#34;</span><span>set X, 2 side 0</span><span>&#34;, </span><span>// assert vsync
</span><span>      &#34;</span><span>b:</span><span>&#34;,
</span><span>      &#34;</span><span>wait 1 irq 0</span><span>&#34;,
</span><span>      &#34;</span><span>jmp X-- b</span><span>&#34;, </span><span>// wait for 3 lines
</span><span>      &#34;</span><span>set X, 20 side 1</span><span>&#34;, </span><span>// deassert vsync
</span><span>      &#34;</span><span>c:</span><span>&#34;,
</span><span>      &#34;</span><span>wait 1 irq 0</span><span>&#34;,
</span><span>      &#34;</span><span>jmp X-- c</span><span>&#34; </span><span>// wait for 21 lines (back porch)
</span><span>      &#34;</span><span>.wrap</span><span>&#34;,
</span><span>  );
</span><span>
</span><span>  </span><span>// 2 cycles per pixel so we run at double speed
</span><span>  </span><span>// 6 instr
</span><span>  </span><span>let</span><span> rgb = pio::pio_asm!(
</span><span>      &#34;</span><span>out X, 32</span><span>&#34;, </span><span>// holds 319, which we have to read from the FIFO
</span><span>      &#34;</span><span>.wrap_target</span><span>&#34;,
</span><span>      &#34;</span><span>mov Y, X</span><span>&#34;,
</span><span>      &#34;</span><span>wait 1 irq 2</span><span>&#34;, </span><span>// wait until start of line
</span><span>      &#34;</span><span>a:</span><span>&#34;,
</span><span>      &#34;</span><span>out pins, 16</span><span>&#34;, </span><span>// write to rgb from dma
</span><span>      &#34;</span><span>jmp Y-- a</span><span>&#34;,
</span><span>      &#34;</span><span>mov pins, NULL</span><span>&#34;, </span><span>// output black
</span><span>      &#34;</span><span>.wrap</span><span>&#34;
</span><span>  );
</span></pre>
<p>The full code lives <a href="https://gitlab.scd31.com/stephen/rp2040-rcade-crt-driver/-/blob/master/src/main.rs">here</a>.</p><p>There are 3 separate PIO programs. <code>hsync</code> is responsible for keeping time and generating HSYNC pulses. At the start of each line, it generates an IRQ event that the other programs use for synchronization. <code>vsync</code> counts these events and generates the VSYNC pulses. Finally, <code>rgb</code> reads pixel data from DMA and outputs to the RGB pins in precise time with the other signals. The <code>out pins, 16</code> signifies that we&#39;re only doing 16-bit colour for now.</p><p>There&#39;s a lot of weirdness in here to get around the constraints of the PIO. For example, between all 3 programs, only a maximum of 31 instructions are allowed. All of the VGA parameters (resolution, porch length, etc.) are hard-coded, and changing these would require at least a small rewrite. It&#39;s pretty brittle in that regard, but for our use-case it&#39;s sufficient as a proof-of-concept.</p><p>Here it is running the actual CRT in the RCade:</p><p><a href="https://rhodesmill.org/img/rcade/pio-crt.jpg"><img src="https://rhodesmill.org/thumb/rcade/pio-crt.jpg"/></a></p><p>I wanted to fill the framebuffer with a repeating pattern, but I messed up my code, hence it looking weird. That&#39;s fine - it was enough to verify my VGA program worked!</p><p>As an aside, every time I popped off the back of the RCade to work on it was terrifying. Not because of the lethal voltages inside, but because Recursers absolutely <i>love</i> the RCade. I often joke that if I were to break it, I would basically be the anti-Frank!</p><p>Now that I had something that could take a framebuffer and throw it onto the CRT, it was time to get the image from my computer to the RP2040.</p></section><h2>Let&#39;s write a kernel module!</h2><section><p>My plan was to write a Linux kernel module that would expose itself as a framebuffer, and then send that framebuffer over USB to the RP2040. On the framebuffer side, this involved interfacing with the <a href="https://www.kernel.org/doc/html/v4.11/gpu/drm-internals.html">DRM layer</a>.</p><p>I actually made decent progress here, although I kernel panicked many, many times. I never bothered to set up a proper development environment (oops), so pretty much any bug would require me to reboot my computer. This was super annoying and tedious, although I did learn a lot. I found cursed things in the official documentation, like <a href="https://www.kernel.org/doc/html/v5.5/gpu/drm-kms.html#c.drm_display_mode">interrobangs!</a></p><p><a href="https://rhodesmill.org/img/rcade/interrobangs.png"><img src="https://rhodesmill.org/thumb/rcade/interrobangs.png"/></a></p><small>Linus pls</small><p>I got as far as getting a framebuffer to show up at the correct resolution and refresh rate. Along this journey though, I discovered the <a href="https://github.com/notro/gud/wiki">GUD kernel module</a>, and quickly realized I should use that instead.</p></section><h2>GUD is... pretty good</h2><section><p>Okay so this GUD thing is sick. It&#39;s a USB display adapter protocol - exactly what I need! It was originally designed to send video from a computer to a Pi Zero for use as a secondary display. It consists of an upstreamed (!!!) kernel module that runs on the host, and separate gadget software that runs on the Pi Zero. I decided I would just write my own gadget implementation to run on the RP2040.</p><p>As a protocol, GUD seems decent. It supports compression over the wire, and only sends the deltas of what&#39;s changed in the host&#39;s framebuffer. It&#39;s also pretty robust in terms of allowing the gadget to advertise what features it supports - compression is optional, and there&#39;s flexibility in colour depth and resolution. And again, it&#39;s upstreamed into the kernel, so anyone on modern Linux could use my display adapter with no software tweaks.</p><p>Unfortunately, GUD has almost no documentation. I figured out what I needed to do by reverse engineering the kernel module, which involved recompiling it to add some debugging statements. The protocol is simple enough that is wasn&#39;t too much of a hassle, and it didn&#39;t take long before I had developed a gadget implementation in Rust for the RP2040.</p><p>And with that, we saw our first Linux images on the CRT:</p>
<p>I know, I know, it looks terrible. Several years ago, I had built a board that implements the R/G/B DACs out of resistors, and I reused that for this project. It can only do 12 bits of colour maximum, and for this test I only bothered to wire up ~2 bits per channel, which is basically unusable. But it proves the concept works!</p><p><a href="https://rhodesmill.org/img/rcade/vga-dac.jpg"><img src="https://rhodesmill.org/thumb/rcade/vga-dac.jpg"/></a></p><small>The board I built several years ago. It was originally designed to fit an STM32 development board.</small><p>To be honest, it&#39;s pretty lucky that this board came with me to New York. I&#39;m surprised I didn&#39;t either throw it out or move it to my parent&#39;s place. It was probably in some other box of things I deemed worth keeping around.</p><p><a href="https://rhodesmill.org/img/rcade/rev0-board.jpg"><img src="https://rhodesmill.org/thumb/rcade/rev0-board.jpg"/></a></p><small>The VGA board connected to the RP2040.</small><p>You can see from the above picture that I really connected the bare minimum for a proof-of-concept. I find perfboard soldering to be a bit tedious!</p><p>As an aside, you may notice in the video that the entire screen is shifted to the left. The left side has wrapped around and is now on the right side. On initial boot, it would look fine; over time it would gradually get worse and worse. This is a bug in my implementation - I suspect it&#39;s some kind of buffer underflow that&#39;s happening, such that each time it occurs, the PIO gets progressively more out of sync. But this is just a guess; I didn&#39;t look into it too much.</p><p>The colour depth issue is trivial to fix, but this next one isn&#39;t. The framerate sucks! You can even see it in the video above, where you can watch the new frame scroll down the screen. The RP2040 can only do USB FS (full-speed), which is capable of 11 Mbps. At the 320x240x16 bpp we were originally targeting, every frame is 153.6 kB. At our maximum USB FS speed, that&#39;s less than 10 FPS! Embarrasingly, I had originally done the math with a bandwidth of 11 M<b>B</b>ps, not 11 M<b>b</b>ps, so I was off by a factor of 8. I was hoping to get something at least temporarily usable but had to go back to the drawing board.</p></section><h2>Going on a GUD gadget side quest</h2><section><p>Who even needs microcontrollers anyway? My next idea was to use the normal GUD gadget implementation, running on a Pi Zero, but outputting to VGA over GPIO. Conceptually this is pretty simple, although in practice it was anything but. The canonical GUD gadget software was based on a 2021 version of <a href="https://buildroot.org/">Buildroot</a>, which was too old to output VGA. I tried, and failed, to update the Buildroot version, as well as to backport the VGA overlay. Neither of those really worked, but I didn&#39;t really know what I was doing.</p><p>I also played around with generating a custom NixOS image that had a modern kernel and the GUD gadget kernel module. When that didn&#39;t work I prepared to run a user space GUD gadget implementation on Raspberry Pi OS. But like, isn&#39;t that boring? And then I&#39;ll still be stuck at 18 bit colour! And sometimes a girl just wants to tickle her electrons :3</p></section><h2>Attempt... 2? 3? 1+i? Returning to MCU land</h2><section><p>Okay, so my beloved RP2040 doesn&#39;t support USB HS (high-speed). My beloved RP2350 (the newer version of the same chip) doesn&#39;t either. But some of my beloved STM32s do!</p><p>Initially I was planning to go computer -&gt; USB HS -&gt; STM32 -&gt; SPI bus -&gt; RP2040 -&gt; VGA. But like, that&#39;s complicated, and there are 2 microcontrollers to program, and there is so much to go wrong, and the SPI bus protocol is going to need to be robust against lost/extra bits, and AAAAAAAAAA I don&#39;t wanna!</p><p>But! STM32! I learned through research that some of the nicer ones have an LTDC peripheral, which, among other things, can drive an LCD display. And guess what? Many LCDs take in an R, G, B, HSYNC, and VSYNC signal. That&#39;s right - they pretend they&#39;re a CRT, and they pretend they have a cute little electron gun inside of them, and the STM32 is like &#34;ok I got u&#34; and can just like, do this natively. And I realize that this is what VGA is, but it&#39;s so, so funny to me that the protocol is literally just the manifestation of a physical design that is largely obsolete.</p><p>Okay so at this point I&#39;m like, is this even a real project anymore? I&#39;m just connecting the USB peripheral to the LTDC peripheral. What part of this is supposed to take effort? I had already written the GUD gadget implementation. Wasn&#39;t I basically already done?</p><p>OH BOY.</p><p>Anyway, by now it&#39;s Christmas time and I fly back to Canada to hang out with my family, as you would expect. I had none of my hardware with me, so now felt like a good time to design the actual board.</p><p><a href="https://rhodesmill.org/img/rcade/rev1-top.jpg"><img src="https://rhodesmill.org/thumb/rcade/rev1-top.jpg"/></a>
<a href="https://rhodesmill.org/img/rcade/rev1-bottom.jpg"><img src="https://rhodesmill.org/thumb/rcade/rev1-bottom.jpg"/></a></p><p>By Christmas Eve, this is what I had. Conceptually, it&#39;s a pretty basic board - there&#39;s the USB HS input, the VGA output, 3 8-bit DACs, some RAM for the framebuffer, and supporting components. At the heart of it is the STM32H723, which is a microcontroller that&#39;s advertised as supporting USB HS and LTDC.</p><p>It&#39;s worth talking about the DACs a bit. They have a few requirements. They need to map the 8-bit binary space uniformly to the analog domain. They also need to act as a resistor divider - my I/O is at 3.3V, but VGA expects a maximum of 0.7 volts for R/G/B. And finally, they need to be impedance-matched to the 75 ohms of the VGA cable, to prevent reflections and ringing that show up in the image. I am... pretty doubtful we need this at our resolution, but it doesn&#39;t hurt, and it increases nerd cred (^:</p><p>I encoded all of these requirements into a system of equations, threw it into a SAT solver, and computed all of my resistor values. I checked the output manually and it made sense, so I used these values in my DAC.</p><p>Also worth noting is the length-matched traces between the STM32 and the HyperRAM. Length-matching ensures that all the signals arrive at the same time; if some arrive too early or late it can cause issues. The traces aren&#39;t impedance-matched, but I did a bit of math and determined they were short enough that I didn&#39;t have to worry about it.</p><p>Also, I want to talk about the USB port. I used Mini-USB. Alright look. I know I know, I should have used USB-C. But I don&#39;t like USB-C! It&#39;s a dumb standard. We spent decades teaching non-technical users to plug the square wire into the square hole and the round wire into the round hole. And then we made every hole the same shape!! But they don&#39;t all support the same things!! Not even every <b>cable</b> supports the same things!! I hate it!! And Mini-USB is so cute. It&#39;s not reversible, but who cares? It&#39;s more robust than micro USB, while still being small. And it&#39;s my board, my rules. So yes, I will keep sending pictures of this board to people, and they will keep complaining it doesn&#39;t use USB-C. And I will continue to not care! Mini-USB is CUTE. And by the way, if you read this entire article and <b>this</b> is the section you choose to engage with, then you are boring!!! You will never live up to Mini-USB!!</p><p>Okay okay sorry about that. I am calm now. With all of that out of the way, I placed the order for the boards. I bought 5 of them, 2 of which were partially assembled. I would complete the rest of the assembly myself, but I didn&#39;t want to worry about the more finicky stuff. Between taxes, tariffs, and shipping, it came to a little over a hundred dollars USD.</p></section><h2>Disaster strikes</h2><section><p>About a week later, I was back home in NYC. My boards hadn&#39;t arrived yet, although I did have access to an STM32H723 development board at this point. To prepare for my boards, I started porting my RP2040 firmware to the STM32H723.</p><p>Things were going well until I tried getting USB set up. For some reason, I could only get it working at USB FS speeds. I figured I was just initializing something wrong - maybe a register I was forgetting about, or that wasn&#39;t in the HAL? I did a lot of digging, before finding this hidden in the datasheet (emphasis mine):</p><blockquote><p>The devices embed a USB OTG high-speed (up to 480 Mbit/s) device/host/OTG peripheral
that supports both full-speed and high-speed operations. It integrates the transceivers for
full-speed operation (12 Mbit/s) and a UTMI low-pin interface (ULPI) for high-speed
operation (480 Mbit/s). <b>When using the USB OTG_HS interface in HS mode, an external
PHY device connected to the ULPI is required.</b></p></blockquote><p>My heart sank. Yes, despite this chip very clearly advertising support for USB HS, it can&#39;t actually do that without an external PHY. This is super easy to miss - I actually told other people about the problem, and often they would tell me I was incorrect until I showed it to them in the datasheet. I&#39;ve also found many posts on the ST Community forums from people running into the same thing. So yeah, I need a new board.</p><p>But because boards are expensive, I figure I&#39;ll still use the rev 1 board to validate as much as I can.</p></section><h2>Disaster strikes, again</h2><section><p>Once the boards come, I complete assembly of one, plug it into my computer, and nothing happens. I find out that the 3.3V rail is shorted to ground. This is the same on all of my boards, even the 3 that are disassembled. Some debugging later, it turns out I moved a via in KiCad and didn&#39;t do a re-pour. My ground plane was connected to my power plane.</p><p>I have a full CI/CD pipeline set up for my PCBs, so I was surprised it didn&#39;t catch this. It turns out it has a bit of wiggle-room, and the re-pour was small enough it didn&#39;t get picked up. I now know I need to be disciplined and run DRC locally, ensuring there are literally no differences (and if there are, commit them and push them up to my Git forge).</p><p>Although annoying, and quite embarrassing, this wasn&#39;t a huge deal. I used a drill bit and very carefully drilled out the offending via by hand. It made a bit of a mess - make sure you use breathing protection - but I got a board that worked.</p><p><a href="https://rhodesmill.org/img/rcade/rev1-drilled.jpg"><img src="https://rhodesmill.org/thumb/rcade/rev1-drilled.jpg"/></a></p><small>The drilled-out via. You can see it directly under the text, near the center-bottom of the image.</small><p>At this point I wrote some code that exercised the HyperRAM and VGA. Everything worked great, so I began work on the new board. Here&#39;s what my development setup looked like while I was testing:</p><p><a href="https://rhodesmill.org/img/rcade/rev1-ltdc-testing.jpg"><img src="https://rhodesmill.org/thumb/rcade/rev1-ltdc-testing.jpg"/></a></p><p>Even though the rev 1 board didn&#39;t work out, Frank pointed out that the difference between it and the previous revision was stark:</p><p><a href="https://rhodesmill.org/img/rcade/rev0-rev1.jpg"><img src="https://rhodesmill.org/thumb/rcade/rev0-rev1.jpg"/></a></p><p>Not a bad pace of development!</p></section><h2>Attempt 4 - Rev 2</h2><section><p>I needed an STM32 that supported ULPI (used for talking to the USB PHY), LTDC, and some kind of external RAM. I looked at dozens of chips and found all sorts of blockers. Chips that actually supported both (but they had overlapping pins), chips that were advertised as supporting both (but in actuality, could only do one or the other, depending on the specific model number), and chips that actually could do both, with unconflicting pins, but only in a BGA package. I did not particularly want to deal with that, mainly because the tiny vias and traces would balloon the board cost even more.</p><p>I ended up settling on the STM32H750IBT, a massive, 176 pin, LQFP chip. This thing is larger than some New York apartments, and at over $10 USD, it costs about the same! I have bought entire dev boards for a fraction of this.</p><p>Once I picked out the chip, I basically redesigned the entire board from scratch. Sure, I could reuse the DACs, but I needed completely new RAM (the new chip has no HyperBus), as well as the USB PHY and supporting components. Now that my Christmas vacation was over, it took me a solid week to get everything designed. This isn&#39;t my most complicated board, but it&#39;s certainly my most complex routing:</p><p><a href="https://rhodesmill.org/img/rcade/rev2-routing.png"><img src="https://rhodesmill.org/thumb/rcade/rev2-routing.png"/></a></p><p>I mean, look at those traces. I&#39;m using basically all available space just to get them to be the same length. ST famously has bad pinouts, and because one of the memory controller pins is located on the complete opposite side of the chip, literally all of the rest of the RAM traces had to be lengthened. And the RAM has a 16-bit data bus. I had to route 38 length-matched traces for the memory alone!</p><p>The USB PHY also had a decent number of traces to route, although far less than the RAM. This is probably the part where I&#39;m supposed to say that like, crosstalk is bad and stuff, but we&#39;re just gonna ignore that. I had like no space; leave me alone!</p><p>Here&#39;s what the board looked like:</p><p><a href="https://rhodesmill.org/img/rcade/rev2-top.jpg"><img src="https://rhodesmill.org/thumb/rcade/rev2-top.jpg"/></a>
<a href="https://rhodesmill.org/img/rcade/rev2-bottom.jpg"><img src="https://rhodesmill.org/thumb/rcade/rev2-bottom.jpg"/></a></p><p>And with that, I ordered the board. Waiting for it to arrive just about killed me, but when it finally did, I got to work.</p></section><h2>Board bring-up</h2><section><p>Board bring-up is a magical thing. One-by-one, you enable each part of the board, and you make sure that everything works the way you expect. Given that USB burned me before, I decided to start there.</p><p>Right out of the gate, I was off to a bumpy start. I got the USB technically working, and I even got it to show up on my computer as USB HS (yay!), but it was super, super flaky. Eventually I worked out that its crystal oscillator was unstable. Going back to the datasheet, I realized I missed a 1M ohm resistor, which was meant to be put in parallel with the crystal. I didn&#39;t have one handy, but I know the human body is around that resistance. I put one finger on each terminal of the crystal. It immediately stabilized. I was pretty ecstatic!</p><p>The next day I went to the Recurse Center and stole a 1M ohm resistor to affix to the board. (Faculty, if you&#39;re reading this, I owe you about a tenth of a cent. Sorry!)</p><p>With that over, the rest of the bring-up process was pretty smooth. I got the LTDC running and ported over the rest of the code that implemented the GUD protocol. I had written things pretty naively but, to my surprise, it didn&#39;t need any optimization for high-speed USB. I guess that&#39;s what a microcontroller with a 480 MHz core will get you!</p></section><h2>Running it in the RCade cabinet</h2><section><p>I was already at the Recurse Center at this point, so I popped the back off the RCade, unplugged the VGA from the Pi, and plugged it into my board. It started up immediately - the colours looked great and I got the full 60 Hz framerate. To be honest, I was shocked at how good it looked, and the crowd that had formed was shocked too. I wasn&#39;t really a believer that 24 bit colour would be noticeable, but I was totally wrong. The lack of colour banding was striking.</p><p>Next, I plugged the board into the Pi, and Frank reconfigured it to make my display adapter the primary display. We launched the normal RCade software and played some games. They looked truly amazing; nothing like before. <a href="https://rose.hall.ly/">Rose</a>, one of the main people who developed the software, joked that it looked so good that some of the graphical shortcuts she took were no longer sufficient.</p><p><a href="https://rhodesmill.org/img/rcade/image-before.jpg"><img src="https://rhodesmill.org/thumb/rcade/image-before.jpg"/></a>
<a href="https://rhodesmill.org/img/rcade/image-after.jpg"><img src="https://rhodesmill.org/thumb/rcade/image-after.jpg"/></a></p><p>It&#39;s hard to tell in the pictures but the difference in person was striking. Where it&#39;s most obvious is in the lack of banding around the mountains.</p><p>This felt amazing, but I wasn&#39;t quite ready to leave the board installed. It was fragile - especially with the resistor I bodged on - and it was expensive. I took my board back out and Frank reverted the RCade to how it was before.</p></section><h2>Designing a case</h2><section><p>I&#39;ll be honest. I don&#39;t get that much joy out of 3D modeling. I find it frustrating, tedious, and generally unfulfilling. To get around this, I decided to use <a href="https://github.com/mrWheel/YAPP_Box">YAPP</a> to design the case. YAPP is a parametric box generator written in OpenSCAD. I wrote a few dozen lines of code and ended up with this beauty:</p><p><a href="https://rhodesmill.org/img/rcade/case-top.png"><img src="https://rhodesmill.org/thumb/rcade/case-top.png"/></a>
<a href="https://rhodesmill.org/img/rcade/case-bottom.png"><img src="https://rhodesmill.org/thumb/rcade/case-bottom.png"/></a></p><p>It took barely any time at all and only took 2 physical revisions before I was happy with it. I added the OpenSCAD code to my board repository and CI/CD pipeline. Now, it builds all the files I need to order the boards, as well as the STL files for the case.</p><p><a href="https://rhodesmill.org/img/rcade/case-printing.jpg"><img src="https://rhodesmill.org/thumb/rcade/case-printing.jpg"/></a></p><small>HE&#39;S BEGINNING TO TAKE FORM</small><p>And now, with the board in the case:</p><p><a href="https://rhodesmill.org/img/rcade/physical-case-top.jpg"><img src="https://rhodesmill.org/thumb/rcade/physical-case-top.jpg"/></a>
<a href="https://rhodesmill.org/img/rcade/physical-case-bottom.jpg"><img src="https://rhodesmill.org/thumb/rcade/physical-case-bottom.jpg"/></a></p><p>At this point I was starting to prepare myself to install it in the RCade.</p></section><h2>Disaster strikes, again??</h2><section><p>Everything was done, so I expected I&#39;d just plug it in and be good to go. When I did this, though, nothing happened. After some debugging I realized the USB had completely died on my board. It wasn&#39;t showing up on any computer I connected it to, although the STM32 was still chugging along happily (and outputting to VGA).</p><p>I still haven&#39;t figured out exactly what happened here. I was having a bit of flakiness with the USB already. I vaguely suspect ESD to either the STM32 or the USB PHY, but am not super confident this is the cause. I&#39;m going to keep looking into this. (inb4: wow maybe you shouldn&#39;t have touched the crystal without grounding yourself first!)</p><p>In the meantime, I assembled a second board and got that installed instead. I&#39;m slightly nervous because I don&#39;t have a third board to use if this one also dies, and I don&#39;t want to order any more until I can figure out what&#39;s killing them. That said, it has been a few days now since I installed it, and despite running 24/7, there&#39;s no signs of it dying yet.</p><p><a href="https://rhodesmill.org/img/rcade/in-cabinet.jpg"><img src="https://rhodesmill.org/thumb/rcade/in-cabinet.jpg"/></a></p><p>Here&#39;s the board in its case, installed in the RCade. We&#39;re still running it off the Raspberry Pi for now, but soon we&#39;ll have that switched out with a laptop. I can&#39;t wait!</p></section><h2>Future improvements</h2><section><p>There are all sorts of things I want to change. I want the board to also support audio, with an integrated amp. Perhaps even a tube amp? I just think it would be funny. And being able to read input from the controls would be cool too.</p><p>On the software side, I want double or triple buffering. I actually got them both working, although they didn&#39;t play nice with the deltas that GUD sends over the wire. There are workarounds to this that I haven&#39;t implemented yet. It would also be nice to give GUD the ability to disable these deltas; perhaps that would be a good feature for me to add to the kernel module. Writing some documentation on the GUD protocol could be good too!</p><p>This was a really fun project, and it&#39;s not over yet, but I think all the hard stuff is pretty much done (although - I&#39;ve thought that before!). I really wasn&#39;t expecting this to take as long as it did, but I learned so much, and I&#39;m a stronger engineer for it.</p></section><h2>Source code</h2><section><p>There&#39;s a few repositories of interest:</p><p>The hardware lives <a href="https://gitlab.scd31.com/stephen/stm32-usb-vga-adapter-hardware">here</a>.</p><p>The software lives <a href="https://gitlab.scd31.com/stephen/stm32-usb-vga-rcade-adapter">here</a>.</p><p>If you&#39;re interested, the original software for the RP2040 lives <a href="https://gitlab.scd31.com/stephen/rp2040-rcade-crt-driver">here</a>.</p><p>My very messy DAC equations live <a href="https://gitlab.scd31.com/stephen/vga-dac-formula-sage">here</a>.</p><p>My Nix GUD gadget attempt lives <a href="https://gitlab.scd31.com/stephen/rcade-gud-os">here</a>.</p><p>I also wrote a fair bit of scratch code while learning (such as for my kernel module), but I don&#39;t think any of it was worth putting it in my Git forge.</p></section></div></div>
  </body>
</html>
