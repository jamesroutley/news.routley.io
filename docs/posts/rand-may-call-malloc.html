<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.thingsquare.com/blog/articles/rand-may-call-malloc/">Original</a>
    <h1>rand() may call malloc()</h1>
    
    <div id="readability-page-1" class="page"><section><p>We recently discovered a weird bug deep inside the <a href="https://www.thingsquare.com/blog/articles/release-4.9/" target="_blank">latest version</a> of the <a href="https://www.thingsquare.com/iot-platform/" target="_blank">Thingsquare IoT platform</a> that took us by surprise.</p>
<p>The root cause turned out to be that the <code>rand()</code> function called the <code>malloc()</code> function. We were surprised by this.</p>
<p>And now we want to spread the word, so that everyone knows: <code>rand()</code> may – under certain conditions – call <code>malloc()</code>.</p>
<p>What does this mean to the average person?</p>
<p>To most people, not much.</p>
<p>In fact, not even most software developers will be affected by this.</p>
<p>But it affected us.</p>
<p>What we are talking about here is very low-level. Very bare-metal. Way more bare-metal than most software developers will ever be.</p>
<p>But let’s dive into it.</p>
<div data-options="{direction: &#34;normal&#34;}">

<div>
<div>
<div>
<div>
<figure>
<svg xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 8 8" style="enable-background:new 0 0 8 8;" space="preserve">
<path d="M3,1.3C2,1.7,1.2,2.7,1.2,3.6c0,0.2,0,0.4,0.1,0.5c0.2-0.2,0.5-0.3,0.9-0.3c0.8,0,1.5,0.6,1.5,1.5c0,0.9-0.7,1.5-1.5,1.5
C1.4,6.9,1,6.6,0.7,6.1C0.4,5.6,0.3,4.9,0.3,4.5c0-1.6,0.8-2.9,2.5-3.7L3,1.3z M7.1,1.3c-1,0.4-1.8,1.4-1.8,2.3
c0,0.2,0,0.4,0.1,0.5c0.2-0.2,0.5-0.3,0.9-0.3c0.8,0,1.5,0.6,1.5,1.5c0,0.9-0.7,1.5-1.5,1.5c-0.7,0-1.1-0.3-1.4-0.8
C4.4,5.6,4.4,4.9,4.4,4.5c0-1.6,0.8-2.9,2.5-3.7L7.1,1.3z"></path>
</svg>
</figure>
<blockquote>
The Thingsquare IoT platform runs on devices that have ridiculously small amounts of memory.
</blockquote>
</div>
</div>
</div>
</div>
</div>

<h2 id="memory-allocation-is-a-challenge">Memory allocation is a challenge</h2>
<p>The Thingsquare IoT platform runs on devices that have small amounts of memory.</p>
<p>Very small.</p>
<p>Sometimes as small as 10 kilobytes. And sometimes we can splurge with as much as 32 kilobytes.</p>
<p>For most modern purposes, this is ridiculously small.</p>
<p>We therefore have to be very clever in how we <a href="https://en.wikipedia.org/wiki/Memory_management" target="_blank">manage this memory</a>.</p>
<p>In the Thingsquare system, we have three different types of memory allocation mechanisms:</p>
<ul>
<li><strong>memb</strong>: the memory block allocator. Fixed-size blocks from static pools of blocks.</li>
<li><strong>mmem</strong>: the managed memory allocator. Dynamic-sized blocks, that may be rearranged to avoid fragmentation, from a static chunk of memory.</li>
<li><strong>bmem</strong>: the block memory heap allocator. Dynamic-sized blocks from a static chunk of memory.</li>
</ul>
<p>And, because the system is written in the C programming language, we also use <a href="https://en.wikipedia.org/wiki/Call_stack" target="_blank">stack memory</a>.</p>
<p>All of the above are based on one principle:</p>
<p>Always pre-allocate everything at compile-time.</p>
<p>This means that we know, beforehand, how much memory is being used. If we use too much, we won’t even be able to compile the code. Much less run it.</p>
<p>What we end up with is a memory structure that looks like this:</p>
<div>
<div>
<p>
    The stack starts at the top of the memory and grows downwards. But we have to be careful – more about this below.
</p>
<p>
    The stack is followed by a bunch of memb, mmem, and bmem blocks. As well as other data that the code uses.
</p>
</div>
<p><img data-src="memory-layout.png" alt="Memory layout"/>
</p>
</div>

<p>Because the memory is so tight, there is not much air in that memory layout. In most cases, it is almost 100% used.</p>
<h2 id="malloc-might-kill-you">malloc() might kill you</h2>
<p>Note that there is one memory allocation mechanism that is <strong>not</strong> in the list above: the C language standard <code>malloc()</code>/<code>free()</code> mechanism.</p>
<p>Why?</p>
<p>Because with <code>malloc()</code>/<code>free()</code>, we don’t know beforehand how much memory that will be used.</p>
<p>We may end up with using more than we would expect, at runtime. And then, it might be too late. The device might already be dead.</p>
<p>Our devices are deployed in difficult-to-reach places. They need to be always available. We can’t afford them to run out of memory when we least expect it.</p>
<p>In fact, we go to great lengths to avoid any surprises.</p>
<p>We have a <a href="https://www.thingsquare.com/blog/articles/wireless-mesh-regression-testing/" target="_blank">thorough test setup</a>, which we run on every code change. This involves running the system in a set of network simulators, so that we can know for sure that the system works as expected. And during manufacturing, we do <a href="https://www.thingsquare.com/blog/articles/iot-production-testing/" target="_blank">production testing</a> to make sure that the hardware works.</p>
<p>So we can’t use <code>malloc()/free()</code>. And we don’t.</p>
<h2 id="the-stack-doesn-t-play-nice">The stack doesn’t play nice</h2>
<p>In the memory layout, the stack is a large chunk. How do we know how much to allocate to the stack?</p>
<p>The stack memory is somewhat tricky to allocate, because its maximum size is determined at runtime.</p>
<p>There is no silver bullet: we can’t predict it. So we need to measure it.</p>
<p>The way we do it is straightforward: at boot, we fill the stack memory with a known byte pattern. We then run the system. The system will use the stack. This will overwrite that byte pattern.</p>
<p>After we have run the system for some time, we check how much of that byte pattern is left. That gives us an idea of how much stack the system uses.</p>
<img data-src="stack-size.png" alt="Stack usage"/>

<p>We then allocate a little more stack memory than what we think we need. To be on the safe side.</p>
<p>But we have one trick left: we can keep measuring that byte pattern, even when devices are deployed.</p>
<h2 id="that-bug">That bug</h2>
<p>So all that leads up to that surprising bug that we stumbled across.</p>
<p>We found that some devices, in the field, were using more stack than we had assumed. And that was strange. Because we had made really sure that the stack size was good.</p>
<p>This made the device behave strangely. Unpredictably.</p>
<p>So what was going on?</p>
<p>We took a deeper look at one of the devices, in the lab.</p>
<p>We added more places in the code where we measured the stack usage. To try to hone in on the part of the code that caused the overflow.</p>
<p>And we found it:</p>
<pre><code>rand();</code></pre><p>Huh?</p>
<p>Yes, the standard C library function that produces pseudo-random numbers.</p>
<p>This caused the stack to overflow.</p>
<p>We use <code>rand()</code> in a few places in the code, where we need a quick pseudo-random number that doesn’t have to be cryptographically safe.</p>
<p>It is a simple function that should not use much stack.</p>
<p>So why was it overflowing the stack?</p>
<h2 id="the-culprit-rand-">The culprit: rand()</h2>
<p>The Thingsquare system use the <a href="https://en.wikipedia.org/wiki/Newlib" target="_blank">newlib</a> standard C library. This is open source, so we can look at the code.</p>
<p>This is <a href="https://sourceware.org/git/?p=newlib-cygwin.git;a=blob;f=newlib/libc/stdlib/rand_r.c;h=0670285a0490230336b71e84d1fc5deedbf1037f;hb=HEAD">the code</a> of the <code>rand()</code> function, which <a href="https://en.wikipedia.org/wiki/Lehmer_random_number_generator" target="_blank">looks familiar</a>:</p>
<pre><code>int
rand_r (unsigned int *seed)
{
        long k;
        long s = (long)(*seed);
        if (s == 0)
          s = 0x12345987;
        k = s / 127773;
        s = 16807 * (s - k * 127773) - 2836 * k;
        if (s &lt; 0)
          s += 2147483647;
        (*seed) = (unsigned int)s;
        return (int)(s <span>&amp;</span> RAND_MAX);
}</code></pre><p>Why would this code use so much stack that it blew through its bounds?</p>
<p>There is no large arrays or structs allocated on the stack.</p>
<p>There is no recursion.</p>
<p>But it turns out that the problem is not in this code. It is in the code that calls this code.</p>
<p>The newlib library has a <a href="https://en.wikipedia.org/wiki/Reentrancy_(computing)" target="_blank">reentrancy layer</a> that makes it possible to call functions multiple times, simultaneously.</p>
<p>And this reentrancy code is implemented with C macros. It is difficult to understand from a first glance. This is how <a href="https://sourceware.org/git/?p=newlib-cygwin.git;a=blob;f=newlib/libc/stdlib/rand.c;h=209cb32ffd114239a6a3256248898f88d26fbd9f;hb=HEAD" target="_blank">the actual</a> <code>rand()</code> function looks:</p>
<pre><code>int
rand (void)
{
  struct _reent *reent = _REENT;

  /* This multiplier was obtained from Knuth, D.E., &#34;The Art of
     Computer Programming,&#34; Vol 2, Seminumerical Algorithms, Third
     Edition, Addison-Wesley, 1998, p. 106 (line 26) <span>&amp;</span> p. 108 */
  _REENT_CHECK_RAND48(reent);
  _REENT_RAND_NEXT(reent) =
     _REENT_RAND_NEXT(reent) * __extension__ <span>6364136223846793005LL</span> + 1;
  return (int)((_REENT_RAND_NEXT(reent) &gt;&gt; 32) <span>&amp;</span> RAND_MAX);
}</code></pre><p>Maybe these calls are the problem?</p>
<p>And, yes, as it turns out, they are.</p>
<p>Deep inside that <code>_REENT_CHECK_RAND48()</code> macro, <a href="https://sourceware.org/git/?p=newlib-cygwin.git;a=blob;f=newlib/libc/include/sys/reent.h;h=f8ecf85866a7af11156ce315b03e1d2990e4d670;hb=HEAD" target="_blank">we find</a>:</p>
<pre><code>/* Generic _REENT check macro.  */
#define _REENT_CHECK(var, what, type, size, init) do { \
  struct _reent *_r = (var); \
  if (_r-&gt;what == NULL) { \
    _r-&gt;what = (type)malloc(size); \
    __reent_assert(_r-&gt;what); \
    init; \
  } \
} while (0)</code></pre><p>Oooops – a <code>malloc()</code>! That one killer function that we wanted to avoid.</p>
<p>But is it really used?</p>
<p>Yes, looking at the compiled code, we see that <code>malloc()</code> being called:</p>
<pre><code>0001ff80 &lt;rand&gt;:
   1ff80:       4b16            ldr     r3, [pc, #88]   ; (1ffdc &lt;rand+0x5c&gt;)
   1ff82:       b510            push    {r4, lr}
   1ff84:       681c            ldr     r4, [r3, #0]
   1ff86:       6ba3            ldr     r3, [r4, #56]   ; 0x38
   1ff88:       b9b3            cbnz    r3, 1ffb8 &lt;rand+0x38&gt;
   1ff8a:       2018            movs    r0, #24
   1ff8c:       f7ff fee4       bl      1fd58 &lt;malloc&gt;
   1ff90:       4602            mov     r2, r0
   1ff92:       63a0            str     r0, [r4, #56]   ; 0x38
   1ff94:       b920            cbnz    r0, 1ffa0 &lt;rand+0x20&gt;
   1ff96:       4b12            ldr     r3, [pc, #72]   ; (1ffe0 &lt;rand+0x60&gt;)
   1ff98:       4812            ldr     r0, [pc, #72]   ; (1ffe4 &lt;rand+0x64&gt;)
   1ff9a:       214e            movs    r1, #78 ; 0x4e
   1ff9c:       f000 f952       bl      20244 &lt;__assert_func&gt;
   1ffa0:       4911            ldr     r1, [pc, #68]   ; (1ffe8 &lt;rand+0x68&gt;)
   1ffa2:       4b12            ldr     r3, [pc, #72]   ; (1ffec &lt;rand+0x6c&gt;)
   1ffa4:       e9c0 1300       strd    r1, r3, [r0]
   1ffa8:       4b11            ldr     r3, [pc, #68]   ; (1fff0 &lt;rand+0x70&gt;)
   1ffaa:       6083            str     r3, [r0, #8]
   1ffac:       230b            movs    r3, #11
   1ffae:       8183            strh    r3, [r0, #12]
   1ffb0:       2100            movs    r1, #0
   1ffb2:       2001            movs    r0, #1
   1ffb4:       e9c2 0104       strd    r0, r1, [r2, #16]
   1ffb8:       6ba4            ldr     r4, [r4, #56]   ; 0x38
   1ffba:       4a0e            ldr     r2, [pc, #56]   ; (1fff4 &lt;rand+0x74&gt;)
   1ffbc:       6920            ldr     r0, [r4, #16]
   1ffbe:       6963            ldr     r3, [r4, #20]
   1ffc0:       490d            ldr     r1, [pc, #52]   ; (1fff8 &lt;rand+0x78&gt;)
   1ffc2:       4342            muls    r2, r0
   1ffc4:       fb01 2203       mla     r2, r1, r3, r2
   1ffc8:       fba0 0101       umull   r0, r1, r0, r1
   1ffcc:       1c43            adds    r3, r0, #1
   1ffce:       eb42 0001       adc.w   r0, r2, r1
   1ffd2:       e9c4 3004       strd    r3, r0, [r4, #16]
   1ffd6:       f020 4000       bic.w   r0, r0, #2147483648     ; 0x80000000
   1ffda:       bd10            pop     {r4, pc}
   1ffdc:       20000770        .word   0x20000770
   1ffe0:       00027bfc        .word   0x00027bfc
   1ffe4:       00027c13        .word   0x00027c13
   1ffe8:       abcd330e        .word   0xabcd330e
   1ffec:       e66d1234        .word   0xe66d1234
   1fff0:       0005deec        .word   0x0005deec
   1fff4:       5851f42d        .word   0x5851f42d
   1fff8:       4c957f2d        .word   0x4c957f2d
</code></pre><p>To achieve reentrancy, the newlib code uses <code>malloc()</code> to allocate state for its randomness, so that it can be called multiple times.</p>
<p>Just what we wanted to avoid.</p>
<p>But why does <code>malloc()</code> result in the stack being blown?</p>
<p>Because <code>malloc()</code>, in its default implementation, uses memory between the highest allocated byte, and the stack. In most cases, for large systems, this is fine. Because there is plenty of free memory between the highest allocated byte and the stack.</p>
<p>But not in our case.</p>
<p>We don’t have much free memory. So that call to <code>malloc()</code> will interfere with the stack, immediately.</p>
<p>And fortunately we were able to find this by keeping a check on the stack.</p>
<p><small>But why did this happen now? We have been running this code for years on end with no problems. As it turns out, the reason is that we <a href="https://www.thingsquare.com/blog/articles/release-4.9/" target="_blank">recently upgraded</a> the arm-gcc version. And this version has its newlib built with reentrancy support, which the previous versions did not have.</small></p>
<h2 id="the-solution-">The solution?</h2>
<p>Fortunately, the solution is simple.</p>
<p>We just stop using <code>rand()</code>.</p>
<p>Instead, we provide our own pseudo-random function. For example, the <a href="https://www.pcg-random.org/" target="_blank"><span>PCG</span> random number generator</a>.</p>
<p>Also, we added another regression test that explicitcly checks for occurences of the <code>malloc()</code> code in generated binaries.</p>
</section></div>
  </body>
</html>
