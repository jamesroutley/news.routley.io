<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://datum-b.com/blog/using_advent_of_code_to_learn">Original</a>
    <h1>Using Advent of Code to Learn the Python C API</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p><a href="https://osmapp.org/home">
            <img src="https://osmapp.org/static/dblogo.png" height="50" alt="Made with PowerPoint"/>
        </a></p>
    <p>24 December, 2023</p>
    <p>The yearly <a href="https://adventofcode.com/2023">Advent Of Code</a> challenge is a great way to learn a new programming language. This year, I’m using it to combine some old favorites. Specifically, learning about the <a href="https://docs.python.org/3/c-api/index.html">Python C API</a>. Follow me through this article as I solve an easy puzzle, and then crank up the difficulty by gluing these two languages together.</p>
<p>Python by itself is a slow language; every variable that you create is a Python object, which includes a reference count and other metadata. Fortunately, Python can be extended with C or other low-level languages<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a>, and this is how popular packages like Numpy and Pandas work: they have Python bindings, but the real heavy lifting is done in C. This is one reason why Python is widely used despite its inherent slowness: you can get around the slow parts if you’re clever.</p>
<p>In my job, we have some Python code which is process bound, and which takes a long time to run. One example relies heavily on regular expressions, and another uses a complicated state machine that spawns thousands of Python class instances when it runs. I suspect it would be much faster if these functions were written in a lower-level language, and I’ve floated the idea to my colleagues that this should be done. The problem is, I don’t yet have the experience and knowledge to carry this out, and I don’t have any good on the job learning opportunities to help me along. So AoC is a perfect way to learn the ropes.</p>
<h2 id="puzzle-part-1">Puzzle, Part 1</h2>
<p>The <a href="https://adventofcode.com/2023/day/1">first part of the first day’s puzzle</a> gives a list of strings, and my job is to find the first and last digit in each string to make a two-digit number, and then sum those numbers. I started by implementing a solution in Python, in part because Python is fun (and my “native language” at this point), and because I want to focus on the nuts-and-bolts of the C API rather than figuring out how to solve the puzzle. My <a href="https://github.com/blairfrandeen/2023-AoC/blob/master/day01.py">solution</a> here was pretty straightforward. First I wrote a function to find the first digit in a string, and return it as an integer:</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span>def</span> first_digit(word: <span>str</span>) <span>-&gt;</span> Optional[<span>int</span>]:</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>    <span>for</span> char <span>in</span> word:</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>        <span>if</span> char.isdigit():</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>            <span>return</span> <span>int</span>(char)</span></code></pre></div>
<p>Then I wrote a function that called <code>first_digit</code> twice, first on the original string and then on the reversed string:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span>def</span> cal_value(line: <span>str</span>) <span>-&gt;</span> <span>int</span>:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>    <span>return</span> first_digit(line) <span>*</span> <span>10</span> <span>+</span> first_digit(line[::<span>-</span><span>1</span>])</span></code></pre></div>
<p>And then put it all together:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span>def</span> part_1(puzzle_input: <span>str</span>) <span>-&gt;</span> <span>int</span>:</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>    <span>return</span> <span>sum</span>(<span>map</span>(cal_value, puzzle_input.splitlines()))</span></code></pre></div>
<h2 id="initial-benchmark">Initial Benchmark</h2>
<p>Before optimizing, it’s always important to benchmark your code so that you understand what to optimize. It’s also super helpful in terms of showing concrete results for your work – how slow was it running before, and how much faster were you able to make it go? I did some very high-level benchmarking using the iPython <code>%%timeit</code> magic. Importantly, I didn’t time the file I/O operation; just the puzzle solution itself.</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>In [<span>1</span>]: <span>with</span> <span>open</span>(<span>&#34;inputs/01&#34;</span>, <span>&#34;r&#34;</span>) <span>as</span> d1:</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>   ...:     puzzle_input <span>=</span> d1.read()</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>   ...: </span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>In [<span>2</span>]: <span>from</span> day01 <span>import</span> part_1, part_2</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>In [<span>3</span>]: <span>%%</span>timeit</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>   ...: part_1(puzzle_input)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>   ...: </span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a><span>977</span> µs ± <span>3.82</span> µs per loop (mean ± std. dev. of <span>7</span> runs, <span>1000</span> loops each)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>In [<span>4</span>]: <span>%%</span>timeit</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>   ...: part_2(puzzle_input)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>   ...: </span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a><span>7.29</span> ms ± <span>60.2</span> µs per loop (mean ± std. dev. of <span>7</span> runs, <span>100</span> loops each)</span></code></pre></div>
<p>So there you have it: almost 1 ms for part 1, and over 7 ms for part 2<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a>. How much faster could I get it go? I did some back-of-the-envelope estimation for part 1: The puzzle input is 1,000 lines; maximum line length is 58 characters, and the file size is 24 kB. If I use the same sort of logic I did for part 1, we can assume 60,000 operations to scan all the lines get the digits, and then another 2,000 operations convert the digits to integers, and 3,000 more to add them up; let’s multiply by π and round up (since I don’t know what I’m doing), and say we have 300k instructions to carry out; my PC has a 3 GHz processor, so it should be able to carry out those 300k instructions in about 100 μs, or 10x as fast as I got from Python.</p>
<p>Was this estimate right? I had no idea, but it seemed plausible.</p>
<h2 id="remembering-c">Remembering C</h2>
<p>It’s always humbling to come back to a language I haven’t used in a long time and try to do something. I managed to get it going fairly smoothly by looking at <a href="https://github.com/blairfrandeen/2021-AoC/blob/master/11.c">one of my better solutions from 2021</a> to jog my memory.</p>
<p>My strategy for part 1 was to read the input file byte-by-byte, and continue adding to the result; no need to allocate any memory along the way. I wrote one little helper function, <code>is_digit(char chr)</code> that indicates whether the current character is a digit, and returns it as an integer if it is. The main logic of my code is fairly straightforward:</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>    <span>char</span> current_chr;   <span>// current character we&#39;re reading</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>    <span>int</span> result = <span>0</span>; <span>// final result we&#39;ll return</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    <span>int</span> first_digit = <span>0</span>;  <span>// flag to indicate that we&#39;ve found the first digit in a line</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>    <span>int</span> second_digit;</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>    <span>int</span> current_digit;</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>    </span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>    <span>// read every byte in the file</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>    <span>while</span>((current_chr = fgetc(file_stream)) != EOF) {</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>        <span>if</span>((current_digit = is_digit(current_chr)) &gt; <span>0</span>) {</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>            <span>// if we haven&#39;t yet found the first digit in a line, set the first_digit</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>            <span>// flag to indicate that we have, and add 10 times that digit to the result</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>            <span>if</span> (!first_digit) {</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a>                first_digit = <span>1</span>;</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a>                result += current_digit * <span>10</span>;</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a>            }</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true"></a>            <span>// set the second digit to the current digit regardless; we&#39;ll only add it</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true"></a>            <span>// to the result once we know it&#39;s the last digit in the line. This also</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true"></a>            <span>// covers the case where a line has only one digit, e.g. &#34;se7en&#34; should yield 77.</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true"></a>            second_digit = current_digit;</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true"></a>        }</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true"></a>        <span>// if we&#39;re at the end of a line, add the second digit, and reset the </span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true"></a>        <span>// flag to indicate we haven&#39;t found the first digit</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true"></a>        <span>if</span>(current_chr == <span>&#39;\n&#39;</span>) {</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true"></a>            result += second_digit;</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true"></a>            first_digit = <span>0</span>;</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true"></a>        }</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true"></a>    }</span></code></pre></div>
<p>I wrapped the above function with a <code>clock()</code> timer to measure CPU time, and this part executed in about 150 μs, almost a 10x improvement over the python implementation<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</p>
<h2 id="extending-python">Extending Python</h2>
<p>I started this part of the journey–the truly unknown territory–in the <a href="https://docs.python.org/3/extending/extending.html#">official Python documentation</a>. When going through new territory like this, I find it helpful to try to read and comprehend the material before trying to program anything, in order to understand the big picture of how everything will fit together.</p>
<h3 id="building-the-extension">Building the Extension</h3>
<p>I was glad I did the reading, because the coding took a bit of troubleshooting to get off the ground. My first hang-up is on what should be the first line of an extension:</p>

<p>That gave this error:</p>
<pre><code>$ gcc -Wall -g day01.c &amp;&amp; ./a.out
day01.c:1:10: fatal error: Python.h: No such file or directory
    1 | #include &lt;Python.h&gt;
      |          ^~~~~~~~~~
compilation terminated.</code></pre>
<p>The API documentation has a section on <a href="https://docs.python.org/3/c-api/intro.html#include-files">include files</a>, which is telling me I need to find where these are located on my machine, and then add them to my compiler’s search path. In my case, this path is <code>/usr/include/python3.10</code>.</p>
<p>When I look at <code>gcc --help</code>, it indicates</p>
<pre><code>  -B &lt;directory&gt;           Add &lt;directory&gt; to the compiler&#39;s search paths.</code></pre>
<p>This is misleading, since <code>-B &lt;directory&gt;</code> looks for executables, whereas <code>-I &lt;directory&gt;</code> adds to the list of directories to be searched for header files. So <code>gcc -I /usr/include/python3.10 day01.c</code> got it to compile, albeit with nothing except the new header file included.</p>
<p>However, in my troubleshooting, I found a better solution, which is to use the <code>python3-config</code> utility to pass these flags to the compiler:</p>
<pre><code>gcc `python3-config --cflags` day01.c </code></pre>
<p>If we run <code>python3-config --cflags</code> on its own, we can see all the options which are being passed to the compiler. There are a few of them and I’m not actually sure what all of them mean.</p>
<p>One of the more confusing aspects of this journey was how to actually build and use my extension. What I figured out from the <a href="https://docs.python.org/3/extending/building.html#building">documentation for building C and C++ extensions</a> is that I wanted a <strong>dynamically loadable module</strong>, which means that I need to compile a <code>.so</code> shared library with the name of my module, and put it someplace where the python <code>import</code> machinery will find it. I finally figured out how to do this by reading the man pages for <code>python3-config</code>: It recommends using</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span>gcc</span> <span>$(</span><span>python-config</span> --cflags --ldflags<span>)</span> -shared -fPIC progr.cpp -o progr.so</span></code></pre></div>
<p>To start, I wanted this to “just work on my machine”, so I just put the <code>.so</code> file in my working directory. A later exercise will be going through the <a href="https://setuptools.pypa.io/en/latest/setuptools.html">setuptools documentation</a> to understand how to distribute something like this so it’s <code>pip install</code>able.</p>
<h3 id="a-minimal-extension-module">A minimal extension module</h3>
<p>Before getting into solving the AoC puzzle, I wrote up a miniature module that allows me to import it and call a function. I did this mostly by following the <a href="https://docs.python.org/3/extending/extending.html#back-to-the-example">instructions in the documentation</a>, while stripping out the capability to take in arguments. The results of my efforts:</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span>&gt;&gt;&gt;</span> <span>import</span> aocmodule <span>as</span> aoc</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span>&gt;&gt;&gt;</span> aoc.part1()</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span>42</span></span></code></pre></div>
<p>The C code to make this happen:</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span>#define PY_SSIZE_T_CLEAN</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span>#include </span><span>&lt;Python.h&gt;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a><span>// this is the function that we can call</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a><span>static</span> PyObject *</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a>aoc_part1(PyObject *self, PyObject *args)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>{</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a>    <span>// for now, don&#39;t take any args, and just return</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a>    <span>// everyone&#39;s favorite integer</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a>    <span>return</span> PyLong_FromLong(<span>42</span>);</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a>}</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true"></a><span>// these are the functions available from this module</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true"></a><span>static</span> PyMethodDef aocMethods[] = {</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true"></a>    {<span>&#34;part1&#34;</span>, aoc_part1, METH_VARARGS, <span>&#34;solve part 1&#34;</span>},</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true"></a>    {NULL, NULL, <span>0</span>, NULL} <span>// sentinel</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true"></a>};</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true"></a></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true"></a><span>// this is the module definition</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true"></a><span>static</span> <span>struct</span> PyModuleDef aocmodule = {</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true"></a>    PyModuleDef_HEAD_INIT,</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true"></a>    <span>&#34;aoc&#34;</span>, <span>// module name</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true"></a>    NULL, <span>// documentation, nothing for now</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true"></a>    -<span>1</span>,</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true"></a>    aocMethods</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true"></a>};</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true"></a></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true"></a><span>// this creates a new module and allows it to be imported</span></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true"></a><span>// using `import aocmodule`</span></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true"></a>PyMODINIT_FUNC </span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true"></a>PyInit_aocmodule(<span>void</span>)</span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true"></a>{</span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true"></a>    <span>return</span> PyModule_Create(&amp;aocmodule);</span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true"></a>}</span></code></pre></div>
<p>I compiled this with the recommended flags above. And there you have it, that’s how to compute the answer to the universe with a Python extension written in C. Now back to the puzzle.</p>
<h2 id="putting-it-together">Putting it together</h2>
<p>Now that I had some basis for how to make an extension module, I needed to figure out how to splice together the Python and the C extension. What I wanted is to be able to load the input in Python, and pass that as a string to the C extension. You’ll recall that this isn’t exactly what I did in my pure C implementation, as I instead passed in a file stream. I’m sure there’s a way to do this in Python, but I think I should have <em>some</em> separation of responsibilities between Python and my C extension.</p>
<p>I pasted the logic from my pure C implementation into my extension module, compiled it, and ran it. It worked! As in, it spit out the correct answer – in 2.25 ms. You’ll recall that the time for the pure Python implementation was just under 1 ms, so this was not the result I was hoping for.</p>
<p>I guessed that the problem is that I was taking a rather long (24 kB) Python string, and passing it to my function, which I think under the hood had to call <code>malloc</code> to make an entierly new copy of the string on the heap, and then loop through each position in the string. Here’s the part of my code that did that:</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span>static</span> PyObject *</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>aoc_part1(PyObject *self, PyObject *args)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>{</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>    <span>const</span> <span>char</span> *puzzle_input;</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>    <span>if</span> (!PyArg_ParseTuple(args, <span>&#34;s&#34;</span>, &amp;puzzle_input))</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>        <span>return</span> NULL;</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>    <span>for</span>(<span>size_t</span> i=<span>0</span>; i &lt; strlen(puzzle_input); i++) {</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a>        <span>if</span>((current_digit = is_digit(puzzle_input[i])) &gt; <span>0</span>) { <span>/* ... */</span> }</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a>    }</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a>    <span>/* ... */</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a>}</span></code></pre></div>
<p>This has to be considerably less efficient than just moving a file pointer around. One thing I considered is to just pass either a file handle or a file path to my C function, and let the C extension get the file handle and do its work.</p>
<p>I didn’t like passing a file path for a few reasons. First, it’s a clunky and error-prone interface, and it seems ardous and unneccessary to have end-users have to create a file to run your string-parsing functions. Second, I would have to re-do my previous benchmarking, as I’m intentionally leaving the file I/O out of the benchmark.</p>
<p>On the other hand, allowing the interface to work with a string enabled this beautiful little test:</p>
<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span>import</span> pytest</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span>import</span> day01</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a><span>from</span> aocmodule <span>import</span> part1</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a><span>@pytest.mark.parametrize</span>(</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>    <span>&#34;line, expected&#34;</span>,</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a>    [</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a>        (<span>&#34;abc123&#34;</span>, <span>13</span>),</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a>        (<span>&#34;se7en&#34;</span>, <span>77</span>),</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a>        (<span>&#34;&#34;</span>, <span>0</span>),</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a>    ],</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a>)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true"></a><span>class</span> TestCalVal:</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true"></a>    <span>def</span> test_cal_value(<span>self</span>, line, expected): <span># pure Python solution</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true"></a>        <span>assert</span> day01.cal_value(line) <span>==</span> expected</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true"></a></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true"></a>    <span>def</span> test_cal_ext(<span>self</span>, line, expected): <span># C extension</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true"></a>        <span>assert</span> part1(line) <span>==</span> expected</span></code></pre></div>
<p>Yup, I can test both the pure Python implementation and the C extension simultaneously with the same set of inputs. For a testing nerd like me this is The Good Stuff, so I clearly wanted to keep using a string argument to the extension function.</p>
<h3 id="once-more-with-buffers">Once More, With Buffers</h3>
<p>Digging around in the documentation, I started to find what I need. In the code snippet above, I declare <code>const char *puzzle_input</code> as a string, and I load that string into memory with the <code>PyArg_ParseTuple</code> function. Specifically, the second argument, <code>&#34;s&#34;</code> is the format specifier, and indicates that this should be a string. There are several format specifiers described in the <a href="https://docs.python.org/3/c-api/arg.html#parsing-arguments-and-building-values">Parsing arguments and building values</a> page. I found what I wanted to use instead is <code>&#34;s*&#34;</code>, which takes a python <code>str</code> or bytes like object and populates a <a href="https://docs.python.org/3/c-api/buffer.html#c.Py_buffer"><code>Py_buffer</code></a> struct. This has a <code>*buf</code> pointer to the start of the buffer; if I keep incrementing that pointer, it should be equivalent to my pure C solution.</p>
<p>Reading through the intro of the <a href="https://docs.python.org/3/c-api/buffer.html">Buffer Protocol</a> seemed promising. A <code>Py_buffer</code> would give me access to the underlying memory of the string that I pass to my extension function, without doing any copying.</p>
<p>I put it together with some minor changes to the code, and I got it to compile. Here’s an abbreviated version with what’s changed:</p>
<div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span>static</span> PyObject *</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>aoc_part1(PyObject *self, PyObject *args)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>{</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>    Py_buffer puzzle_input;</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>    <span>if</span> (!PyArg_ParseTuple(args, <span>&#34;s*&#34;</span>, &amp;puzzle_input))</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a>        <span>return</span> NULL;</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true"></a>    <span>// find the character at the start of the buffer</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true"></a>    <span>char</span> *current_chr = (<span>char</span>*)puzzle_input.buf;</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true"></a>    </span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true"></a>    <span>// read every byte in the buffer. The buffer has a len</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true"></a>    <span>// attribute which is convenient here</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true"></a>    <span>for</span>(Py_ssize_t i=<span>0</span>; i &lt; puzzle_input.len; i++) {</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true"></a>        <span>// dereference the pointer to use is_digit and for comparisons</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true"></a>        <span>if</span>((current_digit = is_digit(*current_chr)) &gt; <span>0</span>) { <span>/* ... */</span> }</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true"></a>        <span>if</span>(*current_chr == <span>&#39;\n&#39;</span>) { <span>/* ... */</span> }</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true"></a></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true"></a>        <span>// move to the next byte in the buffer at the end of every loop</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true"></a>        current_chr++;</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true"></a>    }</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true"></a>    result += second_digit; <span>// allow for input without trailing newline</span></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true"></a></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true"></a>    <span>// release the buffer</span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true"></a>    PyBuffer_Release(&amp;puzzle_input);</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true"></a></span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true"></a>    <span>// return a python int</span></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true"></a>    <span>return</span> PyLong_FromLong(result);</span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true"></a>}</span></code></pre></div>
<p>It compiled, and it runs, and the tests passed – but was it faster than before? Was I right about allocating a 24 kB string taking too long?</p>
<div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>In [<span>1</span>]: <span>from</span> aocmodule <span>import</span> part1</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>In [<span>2</span>]: <span>with</span> <span>open</span>(<span>&#34;inputs/01&#34;</span>, <span>&#34;r&#34;</span>) <span>as</span> d1:</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>   ...:     inpt <span>=</span> d1.read()</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>   ...: </span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>In [<span>3</span>]: part1(inpt)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a>Out[<span>3</span>]: <span>54953</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true"></a>In [<span>4</span>]: <span>%%</span>timeit</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true"></a>   ...: part1(inpt)</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true"></a>   ...: </span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true"></a>   ...: </span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true"></a><span>65.8</span> µs ± <span>45.8</span> ns per loop (mean ± std. dev. of <span>7</span> runs, <span>10000</span> loops each)</span></code></pre></div>
<p>There you have it – according to iPython, it’s even faster than the pure C implementation<a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a>, and 15X faster than the pure Python version!</p>
<p>My final benchmarks for part 1 of the puzzle are summarized below:</p>
<table>
<thead>
<tr>
<th>Solution</th>
<th>Benchmark Method</th>
<th>Number of Runs</th>
<th>Mean Runtime (μs)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pure Python</td>
<td><code>%%timeit</code></td>
<td>1000</td>
<td>977</td>
</tr>
<tr>
<td>Pure C</td>
<td><code>clock()</code></td>
<td>1000</td>
<td>150</td>
</tr>
<tr>
<td>Pure C</td>
<td><code>clock()</code></td>
<td>10</td>
<td>500</td>
</tr>
<tr>
<td>Python Extension</td>
<td><code>%%timeit</code></td>
<td>1000</td>
<td>65.8</td>
</tr>
</tbody>
</table>
</div></div>
  </body>
</html>
