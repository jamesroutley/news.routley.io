<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://surfingcomplexity.blog/2024/12/14/quick-takes-on-the-recent-openai-public-incident-write-up/">Original</a>
    <h1>Quick takes on the recent OpenAI public incident write-up</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>OpenAI recently <a href="https://status.openai.com/incidents/ctrsv3lwd797">published a public writeup</a> for an incident they had on December 11, and there are lots of good details in here! Here are some of my off-the-cuff observations:</p>



<h2>Saturation</h2>



<blockquote>
<p>With thousands of nodes performing these operations simultaneously, the Kubernetes API servers became overwhelmed, taking down the Kubernetes control plane in most of our large clusters.</p>
</blockquote>



<p>The term <em>saturation</em> describes the condition where a system has reached the limit of what it can handle. This is sometimes referred to as <em>overload</em> or <em>resource exhaustion</em>. In the OpenAI incident, it was the Kubernetes API servers saturated because they were receiving too much traffic. Once that happened, the API servers no longer functioned properly. As a consequence, their DNS-based service discovery mechanism ultimately failed.</p>



<p>Saturation is an extremely common failure mode in incidents, and here OpenAI provides us with yet another example. You can also read some previous posts about public incident writeups involving saturation: <a href="https://surfingcomplexity.blog/2024/11/28/quick-takes-on-the-latest-cloudflare-public-incident-write-up/">Cloudflare</a>, <a href="https://surfingcomplexity.blog/2024/07/06/quick-takes-on-rogers-network-outage-executive-summary/">Rogers</a>, and <a href="https://surfingcomplexity.blog/2021/02/08/slacks-jan-2021-outage-a-tale-of-saturation/">Slack</a>.</p>



<h2>All tests pass</h2>



<blockquote>
<p>The change was tested in a staging cluster, where no issues were observed. The impact was specific to clusters exceeding a certain size, and our DNS cache on each node delayed visible failures long enough for the rollout to continue.</p>
</blockquote>



<p>One reason why it’s difficult to prevent saturation-related incidents is because all of the software can be <em>functionally</em> correct, in the sense that it passes all of the functional tests  and that the failure mode only rears its ugly head once the system is exposed to conditions that only occur in the production environment. Even canarying with production traffic can’t prevent problems that only occur under full load.</p>



<blockquote>
<p>Our main reliability concern prior to deployment was resource consumption of the new telemetry service. Before deployment, we evaluated resource utilization metrics in all clusters (CPU/memory) to ensure that the deployment wouldn’t disrupt running services. While resource requests were tuned on a per cluster basis, no precautions were taken to assess Kubernetes API server load. This rollout process monitored service health but lacked sufficient cluster health monitoring protocols.</p>
</blockquote>



<p>It’s worth noting that the engineers did validate the change in resource utilization on the clusters  where the new telemetry configuration was deployed. The problem was an interaction: it increased load on the API servers, which brings us to the next point.</p>



<h2>Complex, unexpected interactions</h2>



<blockquote>
<p>This was a confluence of multiple systems and processes failing simultaneously and interacting in unexpected ways.</p>
</blockquote>



<p>When we look at system failures, we often look for problems in individual components. But in complex systems, identifying the <em>complex, unexpected</em> <em>interactions</em> can yield better insights into how failures happens. You don’t just want to look at the boxes, you also want to look at the arrows.</p>



<blockquote>
<p>In short, the root cause was a new telemetry service configuration that unexpectedly generated massive Kubernetes API load across large clusters, overwhelming the control plane and breaking DNS-based service discovery.</p>
</blockquote>



<p>“<em>So, we rolled out the new telemetry service, and, yada yada yada, our services couldn’t call each other anymore</em>.”</p>



<p>In this case, the surprising interaction was between a failure of the kubernetes API and the resulting failure of services running  on top of kubernetes. Normally, if you have services that are running on top of kubernetes and your kubernetes API goes unhealthy, your services should still keep running normally, you just can’t make changes to your current deployment (e.g., deploy new code, change the number of pods). However, in this case, a failure in the kubernetes API (control plane) ultimately led to failures in the behavior of running services (data plane). </p>



<p>The coupling between the two? It was DNS.</p>



<h2>DNS</h2>



<blockquote>
<p>In short, the root cause was a new telemetry service configuration that unexpectedly generated massive Kubernetes API load across large clusters, overwhelming the control plane and breaking DNS-based service discovery.</p>
</blockquote>



<figure><a href="https://surfingcomplexity.blog/wp-content/uploads/2024/12/image-2.png"><img data-attachment-id="5630" data-permalink="https://surfingcomplexity.blog/2024/12/14/quick-takes-on-the-recent-openai-public-incident-write-up/image-369/" data-orig-file="https://surfingcomplexity.blog/wp-content/uploads/2024/12/image-2.png" data-orig-size="550,707" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image" data-image-description="" data-image-caption="" data-medium-file="https://surfingcomplexity.blog/wp-content/uploads/2024/12/image-2.png?w=233" data-large-file="https://surfingcomplexity.blog/wp-content/uploads/2024/12/image-2.png?w=550" width="550" height="707" src="https://surfingcomplexity.blog/wp-content/uploads/2024/12/image-2.png?w=550" alt="" srcset="https://surfingcomplexity.blog/wp-content/uploads/2024/12/image-2.png 550w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/image-2.png?w=117 117w, https://surfingcomplexity.blog/wp-content/uploads/2024/12/image-2.png?w=233 233w" sizes="(max-width: 550px) 100vw, 550px"/></a></figure>



<h2>Impact of a change is spread out over time</h2>



<blockquote>
<p>DNS caching added a delay between making the change and when services started failing.</p>
</blockquote>



<p>One of the things that makes DNS-related incidents difficult to deal with is the nature of DNS caching.</p>



<p>When the effect of a change is spread out over time, this can make it more difficult to diagnose what the breaking change was. This is especially true when the critical service that stopped working (in this case, service discovery) was not the thing that was changed (telemetry service deployment).</p>



<blockquote>
<p>DNS caching made the issue far less visible until the rollouts had begun fleet-wide.</p>
</blockquote>



<p>In this case, the effect was spread out over time because of the nature of DNS caching. But often we intentionally spread out a change over time because we want to reduce the blast radius if the change we are rolling out turns out to be a breaking change. This works well if we detect the problem during the rollout. However, this can also make it harder to detect the problem, because the error signal is smaller (by design!). And if we only detect the problem after the rollout is complete, it can be harder to correlate the change with the effect, because the change was smeared out over time. </p>



<h2>Failure mode makes remediation more difficult</h2>



<blockquote>
<p> In order to make that fix, we needed to access the Kubernetes control plane – which we could not do due to the increased load to the Kubernetes API servers.</p>
</blockquote>



<p>Sometimes the failure mode that breaks systems that production depends upon also breaks systems that operators depend on to do their work. I think <a href="https://mickens.seas.harvard.edu/">James Mickens</a> said it best <a href="https://scholar.harvard.edu/files/mickens/files/thenightwatch.pdf">when he wrote</a>:</p>



<blockquote>
<p>I HAVE NO TOOLS BECAUSE I’VE DESTROYED MY TOOLS WITH MY TOOLS</p>
</blockquote>



<p>Facebook encountered similar problems when they experienced a <a href="https://engineering.fb.com/2021/10/05/networking-traffic/outage-details/">major outage back in 2021</a>:</p>



<blockquote>
<p>And as our engineers worked to figure out what was happening and why, they faced two large obstacles: first, it was not possible to access our data centers through our normal means because their networks were down, and second, the total loss of DNS broke many of the internal tools we’d normally use to investigate and resolve outages like this. </p>
</blockquote>



<p>This type of problem often requires that operators improvise a solution in the moment. The OpenAI engineers pursued multiple strategies to get the system heathy again.</p>



<blockquote>
<p>We identified the issue within minutes and immediately spun up multiple workstreams to explore different ways to bring our clusters back online quickly:</p>



<ol>
<li>Scaling down cluster size: Reduced the aggregate Kubernetes API load.</li>



<li>Blocking network access to Kubernetes admin APIs: Prevented new expensive requests, giving the API servers time to recover.</li>



<li>Scaling up Kubernetes API servers: Increased available resources to handle pending requests, allowing us to apply the fix.</li>
</ol>



<p>By pursuing all three in parallel, we eventually restored enough control to remove the offending service.</p>
</blockquote>



<p>Their interventions were successful, but it’s easy to imagine scenarios where one of these interventions accidentally made things even worse. As Richard Cook noted: <a href="https://www.adaptivecapacitylabs.com/HowComplexSystemsFail.pdf">all practitioner actions are gambles</a>. Incidents always involve uncertainty in the moment, and it’s easy to overlook this when we look back with perfect knowledge of how the events unfolded.</p>



<h2>A change intended to improve reliability</h2>



<blockquote>
<p>As part of a push to improve reliability across the organization, we’ve been working to improve our cluster-wide observability tooling to strengthen visibility into the state of our systems. At 3:12 PM PST, we deployed a new telemetry service to collect detailed Kubernetes control plane metrics.</p>
</blockquote>



<p>This is a great example of <em>unexpected behavior of a subsystem whose primary purpose was to improve reliability</em>. This is another data point for my <a href="https://surfingcomplexity.blog/2017/06/24/a-conjecture-on-why-reliable-systems-fail/">conjecture on why reliable systems fail.</a></p>




	</div></div>
  </body>
</html>
