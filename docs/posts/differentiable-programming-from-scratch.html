<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thenumb.at/Autodiff/">Original</a>
    <h1>Differentiable Programming from Scratch</h1>
    
    <div id="readability-page-1" class="page"><div><main><p><a href="https://en.wikipedia.org/wiki/Differentiable_programming">Differentiable programming</a> has become a hot research topic, and not only due to the popularity of machine learning frameworks like TensorFlow, PyTorch, and JAX. Many fields apart from machine learning are finding differentiable programming to be a useful tool for solving optimization problems. In computer graphics, differentiable <a href="https://www.youtube.com/watch?v=Tou8or1ed6E">rendering</a>, differentiable <a href="https://physicsbaseddeeplearning.org/diffphys.html">physics</a>, and <a href="https://thenumb.at/Neural-Graphics/">neural representations</a> are all gaining popularity.</p><p><em>This article received an honorable mention in 3Blue1Brown’s <a href="https://www.youtube.com/watch?v=cDofhN-RJqg">Summer of Math Exposition 2</a>!</em></p><ul><li><a href="#prerequisites">Prerequisites</a><ul><li><a href="#differentiation">Differentiation</a></li><li><a href="#optimization">Optimization</a></li></ul></li><li><a href="#differentiating-code">Differentiating Code</a><ul><li><a href="#numerical">Numerical</a></li><li><a href="#symbolic">Symbolic</a></li></ul></li><li><a href="#automatic-differentiation">Automatic Differentiation</a><ul><li><a href="#forward-mode">Forward Mode</a></li><li><a href="#backward-mode">Backward Mode</a></li></ul></li><li><a href="#de-blurring-an-image">De-blurring an Image</a></li><li><a href="#further-reading">Further Reading</a></li></ul><h2 id="differentiation">Differentiation</h2><p>It all starts with the definition you learn in calculus class:</p><p>\[
f^{\prime}(x) = \lim_{h\rightarrow 0} \frac{f(x + h) - f(x)}{h}
\]</p><p>In other words, the derivative computes how much $$f(x)$$ changes when $$x$$ is perturbed by an infinitesimal amount. If $$f$$ is a one-dimensional function from $$\mathbb{R} \mapsto \mathbb{R}$$, the derivative $$f^{\prime}(x)$$ returns the slope of the graph of $$f$$ at $$x$$.</p><p><img src="https://thenumb.at/Autodiff/slope.svg"/></p><p>However, there’s another perspective that provides better intuition in higher dimensions. If we think of $$f$$ as a map from points in its domain to points in its range, we can think of $$f^{\prime}(x)$$ as a map from <em>vectors</em> based at $$x$$ to <em>vectors</em> based at $$f(x)$$.</p><h3 id="one-to-one">One-to-One</h3><p>In 1D, this distinction is a bit subtle, as a 1D “vector” is just a single number. Still, evaluating $$f^{\prime}(x)$$ shows us how a vector placed at $$x$$ is scaled when transformed by $$f$$. That’s just the slope of $$f$$ at $$x$$.</p><p><img src="https://thenumb.at/Autodiff/vec1d.svg"/></p><h3 id="many-to-one">Many-to-One</h3><p>If we consider a function $$g(x,y) : \mathbb{R}^2 \mapsto \mathbb{R}$$ (two inputs, one output), this perspective will become clearer. We can differentiate $$g$$ with respect to any particular input, known as a partial derivative:</p><p>\[
g_x(x,y) = \lim_{h\rightarrow0} \frac{g(x+h,y) - g(x,y)}{h}
\]</p><p>The function $$g_x$$ computes the change in $$g$$ given a change in $$x$$. By combining $$g_x$$ with the corresponding $$g_y$$, we produce the <em>gradient</em> of $$g$$:</p><p>\[
\nabla g(x,y) = \begin{bmatrix}g_x(x,y) &amp; g_y(x,y)\end{bmatrix}
\]</p><p>That is, $$\nabla g(x,y)$$ tells us how $$g$$ changes if we change either $$x$$ or $$y$$. If we multiply $$\nabla g(x,y)$$ with a column vector of differences $$\Delta x,\Delta y$$, we’ll get their combined effect on $$g$$:</p><p>\[
\nabla g(x,y) \begin{bmatrix}\Delta x\\\Delta y\end{bmatrix} = \Delta xg_x(x,y) + \Delta yg_y(x,y)
\]</p><p>It’s tempting to think of the gradient as just another vector. However, it’s often useful to think of the gradient as a <em>higher-order function</em>: $$\nabla g$$ is a function that, when evaluated at $$x,y$$, gives us <em>another function</em> that transforms <em>vectors</em> based at $$x,y$$ to <em>vectors</em> based at $$g(x,y)$$.</p><p>It just so happens that the function returned by our gradient is linear, so it can be represented as a matrix multiplication.</p><p><img src="https://thenumb.at/Autodiff/vec2d.svg"/></p><p>The gradient is typically explained as the “direction of steepest ascent.” Why is that? When we evaluate the gradient at a point $$x,y$$ and a vector $$\Delta x, \Delta y$$, the result is a change in the output of $$g$$. If we <em>maximize</em> the change in $$g$$ with respect to the input vector, we’ll get the direction that makes the output increase the fastest.</p><p>Since the gradient function is just a product with $$\begin{bmatrix}g_x(x,y) &amp; g_y(x,y)\end{bmatrix}$$, the direction $$\begin{bmatrix}\Delta x &amp; \Delta y\end{bmatrix}$$ that maximizes the result is easy to find: it’s parallel to $$\begin{bmatrix}g_x(x,y) &amp; g_y(x,y)\end{bmatrix}$$. That means the gradient vector is, in fact, the direction of steepest ascent.</p><p><img src="https://thenumb.at/Autodiff/grad.svg"/></p><h4 id="the-directional-derivative">The Directional Derivative</h4><p>Another important term is the <em>directional derivative</em>, which computes the derivative of a function along an arbitrary direction. It is a generalization of the partial derivative, which evaluates the directional derivative along a coordinate axis.</p><p>\[
D_{\mathbf{v}}f(x)
\]</p><p>Above, we discovered that our “gradient function” could be expressed as a dot product with the gradient vector. That was, actually, the directional derivative:</p><p>\[
D_{\mathbf{v}}f(x) = \nabla f(x) \cdot \mathbf{v}
\]</p><p>Which again illustrates why the gradient vector is the direction of steepest ascent: it is the $$\mathbf{v}$$ that maximizes the directional derivative. Note that in curved spaces, the “steepest ascent” definition of the gradient still holds, but the directional derivative becomes more complicated than a dot product.</p><h3 id="many-to-many">Many-to-Many</h3><p>For completeness, let’s examine how this perspective extends to vector-valued functions of multiple variables. Consider $$h(x,y) : \mathbb{R}^2 \mapsto \mathbb{R}^2$$ (two inputs, two outputs).</p><p>\[
h(x,y) = \begin{bmatrix}h_1(x,y)\\h_2(x,y)\end{bmatrix}
\]</p><p>We can take the gradient of each part of $$h$$:</p><p>\[
\begin{align*}
\nabla h_1(x,y) &amp;= \begin{bmatrix}h_{1_x}(x,y)&amp; h_{1_y}(x,y)\end{bmatrix} \\
\nabla h_2(x,y) &amp;= \begin{bmatrix}h_{2_x}(x,y)&amp; h_{2_y}(x,y)\end{bmatrix}
\end{align*}
\]</p><p>What object would represent $$\nabla h$$? We can build a matrix from the gradients of each component, called the <em>Jacobian</em>:</p><p>\[
\nabla h(x,y) = \begin{bmatrix}h_{1_x}(x,y) &amp; h_{1_y}(x,y)\\ h_{2_x}(x,y) &amp; h_{2_y}(x,y)\end{bmatrix}
\]</p><p>Above, we argued that the gradient (when evaluated at $$x,y$$) gives us a map from input <em>vectors</em> to output <em>vectors</em>. That remains the case here: the Jacobian is a 2x2 matrix, so it transforms 2D $$\Delta x,\Delta y$$ vectors into 2D $$\Delta h_1, \Delta h_2$$ vectors.</p><p><img src="https://thenumb.at/Autodiff/vec2d2d.svg"/></p><p>Adding more dimensions starts to make our functions hard to visualize, but we can always rely on the fact that the derivative tells us how input vectors (i.e. changes in the input) get mapped to output vectors (i.e. changes in the output).</p><h3 id="the-chain-rule">The Chain Rule</h3><p>The last aspect of differentiation we’ll need to understand is how to differentiate function composition.</p><p>\[
h(x) = g(f(x)) \implies h^\prime(x) = g^\prime(f(x))\cdot f^\prime(x)
\]</p><p>We could prove this fact with a bit of analysis, but the relationship is again easier to understand by thinking of the derivative as higher order function. In this perspective, the chain rule itself is just a function composition.</p><p>For example, let’s assume $$h(\mathbf{x}) : \mathbb{R}^2 \mapsto \mathbb{R}$$ is composed of $$f(\mathbf{x}) : \mathbb{R}^2 \mapsto \mathbb{R}^2$$ and $$g(\mathbf{x}) : \mathbb{R}^2 \mapsto \mathbb{R}$$.</p><p>In order to translate a $$\Delta \mathbf{x}$$ vector to a $$\Delta h$$ vector, we can first use $$\nabla f$$ to map $$\Delta \mathbf{x}$$ to $$\Delta \mathbf{f}$$, based at $$f(\mathbf{x})$$. Then we can use $$\nabla g$$ to map $$\Delta \mathbf{f}$$ to $$\Delta g$$, based at $$g(f(\mathbf{x}))$$.</p><p><img src="https://thenumb.at/Autodiff/vec2d2d1d.svg"/></p><p>Because our derivatives/gradients/Jacobians are linear functions, we’ve been representing them as scalars/vectors/matrices, respectively. That means we can easily compose them with the typical linear algebraic multiplication rules. Writing out the above example symbolically:</p><p>\[
\begin{align*} \nabla h(\mathbf{x}) &amp;= \nabla g(f(\mathbf{x}))\cdot \nabla f(\mathbf{x}) \\
&amp;= \begin{bmatrix}g_{x_1}(f(\mathbf{x}))&amp; g_{x_2}(f(\mathbf{x}))\end{bmatrix} \begin{bmatrix}f_{1_{x_1}}(\mathbf{x}) &amp; f_{1_{x_2}}(\mathbf{x})\\ f_{2_{x_1}}(\mathbf{x}) &amp; f_{2_{x_2}}(\mathbf{x})\end{bmatrix} \\
&amp;= \begin{bmatrix}g_{x_1}(f(\mathbf{x}))f_{1_{x_1}}(\mathbf{x}) + g_{x_2}(f(\mathbf{x}))f_{2_{x_1}}(\mathbf{x}) &amp; g_{x_1}(f(\mathbf{x}))f_{1_{x_2}}(\mathbf{x}) + g_{x_2}(f(\mathbf{x}))f_{2_{x_2}}(\mathbf{x})\end{bmatrix}
\end{align*}
\]</p><p>The result is a 2D vector representing a gradient that transforms 2D vectors to 1D vectors. The composed function $$h$$ had two inputs and one output, so that’s correct. We can also notice that each term corresponds to the chain rule applied to a different computational path from a component of $$\mathbf{x}$$ to $$h$$.</p><h2 id="optimization">Optimization</h2><p>We will focus on the application of differentiation to optimization via gradient descent, which is often used in machine learning and computer graphics. An optimization problem always involves computing the following expression:</p><p>\[
\underset{\mathbf{x}}{\arg\!\min} f(\mathbf{x})
\]</p><p>Which simply means “find the $$\mathbf{x}$$ that results in the smallest possible value of $$f$$.” The function $$f$$, typically scalar-valued, is traditionally called an “energy,” or in machine learning, a “loss function.” Extra constraints are often enforced to limit the valid options for $$\mathbf{x}$$, but we will disregard constrained optimization for now.</p><p><img src="https://thenumb.at/Autodiff/argmin.svg"/></p><p>One way to solve an optimization problem is to iteratively follow the gradient of $$f$$ “downhill.” This algorithm is known as gradient descent:</p><ul><li>Pick an initial guess $$\mathbf{\bar{x}}$$.</li><li>Repeat:<ul><li>Compute the gradient $$\nabla f(\mathbf{\bar{x}})$$.</li><li>Step along the gradient: $$\mathbf{\bar{x}} \leftarrow \mathbf{\bar{x}} - \tau\nabla f(\mathbf{\bar{x}})$$.</li></ul></li><li>while $$|\nabla f(\mathbf{\bar{x}})| &gt; \epsilon$$.</li></ul><p>Given some starting point $$\mathbf{x}$$, computing $$\nabla f(\mathbf{x})$$ will give us the direction from $$\mathbf{x}$$ that would increase $$f$$ the fastest. Hence, if we move our point $$\mathbf{x}$$ a small distance $$\tau$$ along the negated gradient, we will decrease the value of $$f$$. The number $$\tau$$ is known as the step size (or in ML, the learning rate). By iterating this process, we will eventually find an $$\mathbf{x}$$ such that $$\nabla f(\mathbf{x}) \simeq 0$$, which is hopefully the minimizer.</p><p><img src="https://thenumb.at/Autodiff/descent.svg"/></p><p>This description of gradient descent makes optimization sound easy, but in reality there is a lot that can go wrong. When gradient descent terminates, the result is only required to be a critical point of $$f$$, i.e. somewhere $$f$$ becomes flat. That means we could wind up at a maximum (unlikely), a saddle point (possible), or a <em>local</em> minimum (likely). At a local minimum, moving $$\mathbf{x}$$ in any direction would increase the value of $$f(\mathbf{x})$$, but $$f(\mathbf{x})$$ is <strong>not</strong> necessarily the minimum value $$f$$ can take on globally.</p><p>Gradient descent can also diverge (i.e. never terminate) if $$\tau$$ is too large. Because the gradient is only a linear approximation of $$f$$, if we step too far along it, we might skip over changes in $$f$$’s behavior—or even end up <em>increasing</em> both $$f$$ and $$\nabla f$$. On the other hand, the smaller we make $$\tau$$, the longer our algorithm takes to converge. Note that we’re assuming $$f$$ has a lower bound and achieves it at a finite $$\mathbf{x}$$ in the first place.</p><p>The algorithm presented here is the most basic form of gradient descent: much research has been dedicated to devising loss functions and descent algorithms that have higher likelihoods of converging to reasonable results. The practice of adding constraints, loss function terms, and update rules is known as <em>regularization</em>. In fact, optimization is a whole field in of itself: if you’d like to learn more, there’s a vast amount of literature to refer to, especially within machine learning. <a href="https://distill.pub/2017/momentum/">This interactive article</a> explaining <em>momentum</em> is a great example.</p><p>Now that we understand differentiation, let’s move on to programming. So far, we’ve only considered mathematical functions, but we can easily translate our perspective to programs. For simplicity, we’ll only consider <em>pure</em> functions, i.e. functions whose output depends solely on its parameters (no state).</p><p>If your program implements a relatively simple mathematical expression, it’s not too difficult to manually write another function that evaluates its derivative. However, what if your program is a deep neural network, or a physics simulation? It’s not feasible to differentiate something like that by hand, so we must turn to algorithms for automatic differentiation.</p><p>There are several techniques for differentiating programs. We will first look at numeric and symbolic differentiation, both of which have been in use as long as computers have existed. However, these approaches are distinct from the algorithm we now know as <em>autodiff</em>, which we will discuss later.</p><h2 id="numerical">Numerical</h2><p>Numerical differentiation is the most straightforward technique: it simply approximates the definition of the derivative.</p><p>\[
f^\prime(x) = \lim_{h\rightarrow 0} \frac{f(x+h)-f(x)}{h} \simeq \frac{f(x+0.001)-f(x)}{0.001}
\]</p><p>By choosing a small $$h$$, all we have to do is evaluate $$f$$ at $$x$$ and $$x+h$$. This technique is also known as differentiation via <em>finite differences</em>.</p><p>Implementing numeric differentiation as a higher order function is quite easy. It doesn’t even require modifying the function to differentiate:</p><pre id="numerical-example">function numerical_diff(f, h) {
    return function (x) {
        return (f(x + h) - f(x)) / h;
    }
}

let df = numerical_diff(f, 0.001);
</pre><p>You can edit the following JavaScript example, where $$f$$ is drawn in blue and numerical_diff($$f$$, 0.001) is drawn in purple. Note that using control flow is not a problem.</p><p>Unfortunately, finite differences have a big problem: they only compute the derivative of $$f$$ in one direction. If our input is very high dimensional, computing the full gradient of $$f$$ becomes computationally infeasible, as we would have to evaluate $$f$$ for each dimension separately.</p><p>That said, if you only need to compute one directional derivative of $$f$$, the full gradient is overkill: instead, compute a finite difference between $$f(\mathbf{x})$$ and $$f(\mathbf{x} + \Delta\mathbf{x})$$, where $$\Delta\mathbf{x}$$ is a small step in your direction of interest.</p><p>Finally, always remember that numerical differentiation is only an approximation: we aren’t computing the actual limit as $$h \rightarrow 0$$. While finite differences are quite easy to implement and can be very useful for validating other results, the technique should usually be superseded by another approach.</p><h2 id="symbolic">Symbolic</h2><p>Symbolic differentiation involves transforming a representation of $$f$$ into a representation of $$f^\prime$$. Unlike numerical differentiation, this requires specifying $$f$$ in a domain-specific language where each syntactic construct has a known differentiation rule.</p><p>However, that limitation isn’t so bad—we can create a compiler that differentiates expressions in our symbolic language for us. This is the technique used in computer algebra packages like Mathematica.</p><p>For example, we could create a simple language of polynomials that is symbolically differentiable using a small set of recursive rules.</p><div><pre tabindex="0"><code data-lang="text"><span><span>d(n)           -&gt; 0
</span></span><span><span>d(x)           -&gt; 1
</span></span><span><span>d(Add(a, b))   -&gt; Add(d(a), d(b))
</span></span><span><span>d(Times(a, b)) -&gt; Add(Times(d(a), b), Times(a, d(b)))
</span></span></code></pre></div><p>Try out the following implementation:</p><p>If we want our differentiable language to support more operations, we can simply add more differentiation rules. For example, to support trig functions:</p><div><pre tabindex="0"><code data-lang="text"><span><span>d(sin a) -&gt; Times(d(a), cos a)
</span></span><span><span>d(cos a) -&gt; Times(d(a), Times(-1, sin a))
</span></span></code></pre></div><p>Unfortunately, there’s a catch: the size of $$f^\prime$$’s representation can become very large. Let’s write another recursive relationship that counts the number of terms in an expression:</p><div><pre tabindex="0"><code data-lang="text"><span><span>Terms(n)           -&gt; 1
</span></span><span><span>Terms(x)           -&gt; 1
</span></span><span><span>Terms(Add(a, b))   -&gt; Terms(a) + Terms(b) + 1
</span></span><span><span>Terms(Times(a, b)) -&gt; Terms(a) + Terms(b) + 1
</span></span></code></pre></div><p>And then prove that <code>Terms(a) &lt;= Terms(d(a))</code>, i.e. differentiating an expression cannot decrease the number of terms:</p><div><pre tabindex="0"><code data-lang="text"><span><span>Base Cases:
</span></span><span><span>Terms(d(n)) -&gt; 1                                        | Definition
</span></span><span><span>Terms(n)    -&gt; 1                                        | Definition
</span></span><span><span>    =&gt; Terms(n) &lt;= Terms(d(n))
</span></span><span><span>Terms(d(x)) -&gt; 1                                        | Definition
</span></span><span><span>Terms(x)    -&gt; 1                                        | Definition
</span></span><span><span>    =&gt; Terms(x) &lt;= Terms(d(x))
</span></span><span><span>
</span></span><span><span>Inductive Case for Add:
</span></span><span><span>Terms(Add(a, b))    -&gt; Terms(a) + Terms(b) + 1          | Definition
</span></span><span><span>Terms(d(Add(a, b))) -&gt; Terms(d(a)) + Terms(d(b)) + 1    | Definition
</span></span><span><span>Terms(a) &lt;= Terms(d(a))                                 | Hypothesis
</span></span><span><span>Terms(b) &lt;= Terms(d(b))                                 | Hypothesis
</span></span><span><span>    =&gt; Terms(Add(a, b)) &lt;= Terms(d(Add(a, b)))
</span></span><span><span>
</span></span><span><span>Inductive Case for Times:
</span></span><span><span>Terms(Times(a, b))    -&gt; Terms(a) + Terms(b) + 1        | Definition
</span></span><span><span>Terms(d(Times(a, b))) -&gt; Terms(a) + Terms(b) + 3 +
</span></span><span><span>                         Terms(d(a)) + Terms(d(b))      | Definition
</span></span><span><span>    =&gt; Terms(Times(a, b)) &lt;= Terms(d(Times(a, b)))
</span></span></code></pre></div><p>This result might be acceptable if the size of <code>df</code> was linear in the size of <code>f</code>, but that’s not the case. Whenever we differentiate a <code>Times</code> expression, the number of terms in the result will at least <em>double</em>. That means the size of <code>df</code> grows <em>exponentially</em> with the number of <code>Times</code> we compose. You can demonstrate this phenomenon by nesting multiple <code>Times</code> in the JavaScript example.</p><p>Hence, symbolic differentiation is usually infeasible at the scales we’re interested in. However, if it works for your use case, it can be quite useful.</p><p>We’re finally ready to discuss the automatic differentiation algorithm actually used in modern differentiable programming: autodiff! There are two flavors of autodiff, each named for the direction in which it computes derivatives.</p><h2 id="forward-mode">Forward Mode</h2><p>Forward mode autodiff improves on our two older techniques by computing exact derivatives without building a potentially exponentially-large representation of $$f^\prime$$. It is based on the mathematical definition of <em>dual numbers</em>.</p><h3 id="dual-numbers">Dual Numbers</h3><p>Dual numbers are a bit like complex numbers: they’re defined by <a href="https://en.wikipedia.org/wiki/Field_extension">adjoining</a> a new quantity $$\epsilon$$ to the reals. But unlike complex numbers where $$i^2 = -1$$, dual numbers use $$\epsilon^2 = 0$$.</p><p>In particular, we can use the $$\epsilon$$ part of a dual number to represent the derivative of the scalar part. If we replace each variable $$x$$ with $$x + x^\prime\epsilon$$, we will find that dual arithmetic naturally expresses how derivatives combine:</p><p>Addition:</p><p>\[
(x + x^\prime\epsilon) + (y + y^\prime\epsilon) = (x + y) + (x^\prime + y^\prime)\epsilon
\]</p><p>Multiplication:</p><p>\[
\begin{align*} (x + x^\prime\epsilon) * (y + y^\prime\epsilon) &amp;= xy + xy^\prime\epsilon + x^\prime y\epsilon + x^\prime y^\prime\epsilon^2 \\
&amp;= xy + (x^\prime y + xy^\prime)\epsilon \end{align*}
\]</p><p>Division:</p><p>\[
\begin{align*} \frac{x + x^\prime\epsilon}{y + y^\prime\epsilon} &amp;= \frac{\frac{x}{y}+\frac{x^\prime}{y}\epsilon}{1+\frac{y^\prime}{y}\epsilon} \\
&amp;= \left(\frac{x}{y}+\frac{x^\prime}{y}\epsilon\right)\left(1-\frac{y^\prime}{y}\epsilon\right) \\
&amp;= \frac{x}{y} + \frac{x^\prime y - xy^\prime}{y^2}\epsilon
\end{align*}
\]</p><p>The chain rule also works: $$f(x + x^\prime\epsilon) = f(x) + f^\prime(x)x^\prime\epsilon$$ for any smooth function $$f$$. To prove this fact, let us first show that the property holds for positive integer exponentiation.</p><p>Base case:
$$(x+x^\prime\epsilon)^1 = x^1 + 1x^0x^\prime\epsilon$$</p><p>Hypothesis:
$$(x+x^\prime\epsilon)^n = x^n + nx^{n-1}x^\prime\epsilon$$</p><p>Induct:</p><div markdown="1"><p>\[
\begin{align*}
(x+x^\prime\epsilon)^{n+1} &amp;= (x^n + nx^{n-1}x^\prime\epsilon)(x+x^\prime\epsilon) \tag{Hypothesis}\\
&amp;= x^{n+1} + x^nx^\prime\epsilon + nx^nx^\prime\epsilon + nx^{n-1}x^{\prime^2}\epsilon^2\\
&amp;= x^{n+1} + (n+1)x^nx^\prime\epsilon
\end{align*}
\]</p></div><div markdown="1"><p>\[
\begin{align*}
(x+x^\prime\epsilon)^{n+1} &amp;= (x^n + nx^{n-1}x^\prime\epsilon)(x+x^\prime\epsilon) \\&amp;\tag{Hypothesis}\\
&amp;= x^{n+1} + x^nx^\prime\epsilon + nx^nx^\prime\epsilon + nx^{n-1}x^{\prime^2}\epsilon^2\\
&amp;= x^{n+1} + (n+1)x^nx^\prime\epsilon
\end{align*}
\]</p></div><p>We can use this result to prove the same property for any smooth function $$f$$. Examining the Taylor expansion of $$f$$ at zero (also known as its <em>Maclaurin series</em>):</p><p>\[
f(x) = \sum_{n=0}^\infty \frac{f^{(n)}(0)x^n}{n!} = f(0) + f^\prime(0)x + \frac{f^{\prime\prime}(0)x^2}{2!} + \frac{f^{\prime\prime\prime}(0)x^3}{3!} + \dots
\]</p><p>By plugging in our dual number…</p><p>\[
\begin{align*} f(x+x^\prime\epsilon) &amp;= f(0) + f^\prime(0)(x+x^\prime\epsilon) + \frac{f^{\prime\prime}(0)(x+x^\prime\epsilon)^2}{2!} + \frac{f^{\prime\prime\prime}(0)(x+x^\prime\epsilon)^3}{3!} + \dots\\
&amp;= f(0) + f^\prime(0)(x+x^\prime\epsilon) + \frac{f^{\prime\prime}(0)(x^2+2xx^\prime\epsilon)}{2!} + \frac{f^{\prime\prime\prime}(0)(x^3+3x^2x^\prime\epsilon)}{3!} + \dots \\
&amp;= f(0) + f^\prime(0)x + \frac{f^{\prime\prime}(0)x^2}{2!} + \frac{f^{\prime\prime\prime}(0)x^3}{3!} + \dots \\
&amp;\phantom{= }+ \left(f^\prime(0) + f^{\prime\prime}(0)x + \frac{f^{\prime\prime\prime}(0)x^2}{2!} + \dots \right)x^\prime\epsilon \\
&amp;= f(x) + f^\prime(x)x^\prime\epsilon
\end{align*}
\]</p><p>…we prove the result! In the last step, we recover the Maclaurin series for both $$f(x)$$ and $$f^\prime(x)$$.</p><h3 id="implementation">Implementation</h3><p>Implementing forward-mode autodiff in code can be very straightforward: we just have to replace our <code>Float</code> type with a <code>DiffFloat</code> that keeps track of both our value and its dual coefficient. If we then implement the relevant math operations for <code>DiffFloat</code>, all we have to do is run the program!</p><p>Unfortunately, JavaScript does not support operator overloading, so we’ll define a <code>DiffFloat</code> to be a two-element array and use functions to implement some basic arithmetic operations:</p><pre id="forward-lib">function Const(n) {
    return [n, 0];
}
function Add(x, y) {
    return [x[0] + y[0], x[1] + y[1]];
}
function Times(x, y) {
    return [x[0] * y[0], x[1] * y[0] + x[0] * y[1]];
}
</pre><p>If we implement our function $$f$$ in terms of these primitives, evaluating $$f([x,1])$$ will return $$[f(x),f^\prime(x)]$$!</p><p>This property extends naturally to higher-dimensional functions, too. If $$f$$ has multiple outputs, their derivatives pop out in the same way. If $$f$$ has inputs other than $$x$$, assigning them constants means the result will be the partial derivative $$f_x$$.</p><h3 id="limitations">Limitations</h3><p>While forward-mode autodiff does compute exact derivatives, it suffers from the same fundamental problem as finite differences: each invocation of $$f$$ can only compute the directional derivative of $$f$$ for a single direction.</p><p>It’s useful to think of a forward mode derivative as computing one <em>column</em> of the gradient matrix. Hence, if $$f$$ has few inputs but many outputs, forward mode can still be quite efficient at recovering the full gradient:</p><p>\[
\begin{align*}
\nabla f &amp;= \begin{bmatrix} f_{1_x}(x,y) &amp; f_{1_y}(x,y) \\ \vdots &amp; \vdots \\ f_{n_x}(x,y) &amp; f_{n_y}(x,y) \end{bmatrix} \\
\hphantom{\nabla f}&amp;\hphantom{xxx}\begin{array}{} \underbrace{\hphantom{xxxxxx}}_{\text{Pass 1}} &amp; \underbrace{\hphantom{xxxxxx}}_{\text{Pass 2}} \end{array}
\end{align*}
\]</p><p>Unfortunately, optimization problems in machine learning and graphics often have the opposite structure: $$f$$ has a huge number of inputs (e.g. the coefficients of a 3D scene or neural network) and a single output. That is, $$\nabla f$$ has many columns and few rows.</p><h2 id="backward-mode">Backward Mode</h2><p>As you might have guessed, backward mode autodiff provides a way to compute a <em>row</em> of the gradient using a single invocation of $$f$$. For optimizing many-to-one functions, this is exactly what we want: the full gradient in one pass.</p><p>In this section, we will use Leibniz’s notation for derivatives, which is:</p><p>\[
f^\prime(x) = \frac{\partial f}{\partial x}
\]</p><p>Leibniz’s notation makes it easier to write down the derivative of an arbitrary variable with respect an arbitrary input. Derivatives also obtain nice algebraic properties, if you squint a bit:</p><p>\[
g(f(x))^\prime = \frac{\partial g}{\partial f}\cdot\frac{\partial f}{\partial x} = \frac{\partial g}{\partial x}
\]</p><h3 id="backpropagation">Backpropagation</h3><p>Similarly to how forward-mode autodiff propagated derivatives from inputs to outputs, backward-mode propagates derivatives from outputs to inputs.</p><p>That sounds easy enough, but the code only runs in one direction. How would we know what the gradient of our input should be before evaluating the rest of the function? We don’t—when evaluating $$f$$, we use each operation to build a <em>computational graph</em> that represents $$f$$. That is, when $$f$$ tells us to perform an operation, we create a new node noting what the operation is and connect it to the nodes representing its inputs. In this way, a pure function can be nicely represented as a directed acyclic graph, or DAG.</p><p>For example, the function $$f(x,y) = x^2 + xy$$ may be represented with the following graph:</p><img src="https://thenumb.at/Autodiff/g1.svg"/><p>When evaluating $$f$$ at a particular input, we write down the intermediate values computed by each node. This step is known as the <em>forward pass</em>, and computes <em>primal</em> values.</p><img src="https://thenumb.at/Autodiff/g2.svg"/><p>Then, we begin the <em>backward pass</em>, where we compute <em>dual</em> values, or derivatives. Our ultimate goal is to compute $$\frac{\partial f}{\partial x}$$ and $$\frac{\partial f}{\partial y}$$. At first, we only know the derivative of $$f$$ with respect to final plus—they’re the same value, so $$\frac{\partial f}{\partial +} = 1$$.</p><img src="https://thenumb.at/Autodiff/g3.svg"/><p>We can see that the output was computed by adding together two incoming values. Increasing either input to the sum would increase the output by an equal amount, so derivatives propagated through this node should be unaffected. That is, if $$+$$ is the output and $$+_1,+_2$$ are the inputs, $$\frac{\partial +}{\partial +_1} = \frac{\partial +}{\partial +_2} = 1$$.</p><p>Now we can use the chain rule to combine our derivatives, getting closer to the desired result: $$\frac{\partial f}{\partial +_1} = \frac{\partial f}{\partial +}\cdot\frac{\partial +}{\partial +_1} = 1$$, $$\frac{\partial f}{\partial +_2} = \frac{\partial f}{\partial +}\cdot\frac{\partial +}{\partial +_2} = 1$$.</p><img src="https://thenumb.at/Autodiff/g4.svg"/><p>When we evaluate a node, we know the derivative of $$f$$ with respect to its output. That means we can propagate the derivative back along the node’s incoming edges, modifying it based on the node’s operation. As long as we evaluate all outputs of a node before the node itself, we only have to check each node once. To assure proper ordering, we may traverse the graph in <a href="https://en.wikipedia.org/wiki/Topological_sorting"><em>reverse topological order</em></a>.</p><p>Once we get to a multiplication node, there’s slightly more to do: the derivative now depends on the <em>primal</em> input values. That is, if $$f(x,y) = xy$$, $$\frac{\partial f}{\partial x} = y$$ and $$\frac{\partial f}{\partial y} = x$$.</p><p>By applying the chain rule, we get $$\frac{\partial f}{\partial *_1} = 1\cdot*_2$$ and $$\frac{\partial f}{\partial *_2} = 1\cdot*_1$$ for both multiplication nodes.</p><img src="https://thenumb.at/Autodiff/g5.svg"/><p>Applying the chain rule one last time, we get $$\frac{\partial f}{\partial y} = 2$$. But $$x$$ has multiple incoming derivatives—how do we combine them? Each incoming edge represents a different way $$x$$ affects $$f$$, so $$x$$’s total contribution is simply their sum. That means $$\frac{\partial f}{\partial x} = 7$$. Let’s check our result:</p><p>\[
\begin{align*}
f_x(x,y) &amp;= 2x + y &amp;&amp;\implies&amp; f_x(2,3) &amp;= 7 \\
f_y(x,y) &amp;= x &amp;&amp;\implies&amp; f_y(2,3) &amp;= 2
\end{align*}
\]</p><p>You’ve probably noticed that traversing the graph built up a derivative term for each path from an input to the output. That’s exactly the behavior that arose when we manually computed the gradient using the chain rule!</p><p>Backpropagation is essentially the chain rule upgraded with dynamic programming. Traversing the graph in reverse topological order means we only have to evaluate each vertex once—and re-use its derivative everywhere else it shows up. Despite having to express $$f$$ as a computational graph and traverse both forward and backward, the whole algorithm has the same time complexity as $$f$$ itself. Space complexity, however, is a separate issue.</p><h3 id="implementation-1">Implementation</h3><p>We can implement backward mode autodiff using a similar approach as forward mode. Instead of making every operation use dual numbers, we can make each step add a node to our computational graph.</p><pre id="backward-lib">function Const(n) {
	return {op: &#39;const&#39;, in: [n], out: undefined, grad: 0};
}
function Add(x, y) {
	return {op: &#39;add&#39;, in: [x, y], out: undefined, grad: 0};
}
function Times(x, y) {
	return {op: &#39;times&#39;, in: [x, y], out: undefined, grad: 0};
}
</pre><p>Note that JavaScript will automatically store references within the <code>in</code> arrays, hence build a DAG instead of a tree. If we implement our function $$f$$ in terms of these primitives, we can evaluate it on an input node to automatically build the graph.</p><pre id="backward-lib-2">let in_node = {op: &#39;const&#39;, in: [/* TBD */], out: undefined, grad: 0};
let out_node = f(in_node);
</pre><p>The forward pass performs a post-order traversal of the graph, translating inputs to outputs for each node. Remember we’re operating on a DAG: we must check whether a node is already resolved, lest we recompute values that could be reused.</p><pre id="backward-lib-3">function forward(node) {
	if (node.out !== undefined) return;
	if (node.op === &#39;const&#39;) {
		node.out = node.in[0];
	} else if (node.op === &#39;add&#39;) {
		forward(node.in[0]);
		forward(node.in[1]);
		node.out = node.in[0].out + node.in[1].out;
	} else if (node.op === &#39;times&#39;) {
		forward(node.in[0]);
		forward(node.in[1]);
		node.out = node.in[0].out * node.in[1].out;
	}
}
</pre><p>The backward pass is conceptually similar, but a naive pre-order traversal would end up tracing out every path in the DAG—every gradient has to be pushed back to the roots. Instead, we’ll first compute a reverse topological ordering of the nodes. This ordering guarantees that when we reach a node, everything “downstream” of it has already been resolved—we’ll never have to return.</p><pre id="backward-lib-4">function backward(out_node) {
	const order = topological_sort(out_node).reverse();
	for (const node of order) {
		if (node.op === &#39;add&#39;) {
			node.in[0].grad += node.grad;
			node.in[1].grad += node.grad;
		} else if (node.op === &#39;times&#39;) {
			node.in[0].grad += node.in[1].out * node.grad;
			node.in[1].grad += node.in[0].out * node.grad;
		}
	}
}
</pre><p>Finally, we can put our functions together to compute $$f(x)$$ and $$f^\prime(x)$$:</p><pre id="backward-lib-5">function evaluate(x, in_node, out_node) {
	in_node.in = [x];
	forward(out_node);

	out_node.grad = 1;
	backward(out_node);

	return [out_node.out, in_node.grad];
}
</pre><p>Just remember to clear all the <code>out</code> and <code>grad</code> fields before evaluating again! Lastly, the working implementation:</p><h3 id="limitations-1">Limitations</h3><p>If $$f$$ is a function of multiple variables, we can simply read the gradients from the corresponding input nodes. That means we’ve computed a whole row of $$\nabla f$$. Of course, if the gradient has many rows and few columns, forward mode would have been more efficient.</p><p>\[
\begin{align*}
\nabla f &amp;= \begin{bmatrix} \vphantom{\Big|} f_{0_a}(a,\dots,n) &amp; \dots &amp; f_{0_n}(a,\dots,n) \\ \vphantom{\Big|} f_{1_a}(a,\dots,n) &amp; \dots &amp; f_{1_n}(a,\dots,n) \end{bmatrix} \begin{matrix} \left.\vphantom{\Big| f_{0_a}(a,\dots,n)}\right\} \text{Pass 1} \\ \left.\vphantom{\Big| f_{0_a}(a,\dots,n)}\right\} \text{Pass 2} \end{matrix}
\end{align*}
\]</p><p>Unfortunately, backwards mode comes with another catch: we had to store the intermediate result of every single computation inside $$f$$! If we’re passing around substantial chunks of data, say, weight matrices for a neural network, storing the intermediate results can require an unacceptable amount of memory and memory bandwidth. If $$f$$ contains loops, it’s especially bad—because every value is immutable, naive loops will create long chains of intermediate values. For this reason, real-world frameworks tend to encapsulate loops in monolithic parallel operations that have analytic derivatives.</p><p>Many engineering hours have gone into reducing space requirements. One problem-agnostic approach is called checkpointing: we can choose not to store intermediate results at some nodes, rather re-computing them on the fly during the backward pass. Checkpointing gives us a natural space-time tradeoff: by strategically choosing which nodes store intermediate results (e.g. ones with expensive operations), we can reduce memory usage without dramatically increasing runtime.</p><p>Even with checkpointing, training the largest neural networks requires far more fast storage than is available to a single computer. By partitioning our computational graph between multiple systems, each one only needs to store values for its local nodes. Unfortunately, this implies edges connecting nodes assigned to different processors must send their values across a network, which is expensive. Hence, communication costs may be minimized by finding min-cost graph cuts.</p><p><img src="https://thenumb.at/Autodiff/partition2.svg"/></p><h3 id="graphs-and-higher-order-autodiff">Graphs and Higher-Order Autodiff</h3><p>Earlier, we could have computed primal values while evaluating $$f$$ itself. Frameworks like PyTorch and TensorFlow take this approach—evaluating $$f$$ both builds the graph (also known as the ’tape’) and evaluates the forward-pass results. The user may call <code>backward</code> at any point, propagating gradients to all inputs that contributed to the result.</p><p>However, the forward-backward approach can limit the system’s potential performance. The forward pass is relatively easy to optimize via parallelizing, vectorizing, and distributing graph traversal. The backward pass, on the other hand, is harder to parallelize, as it requires a topological traversal and coordinated gradient accumulation. Furthermore, the backward pass lacks some mathematical power. While computing a specific derivative is easy, we don’t get back a general <em>representation</em> of $$\nabla f$$. If we wanted the gradient of the gradient (the Hessian), we’re out of luck.</p><p>Thinking about the gradient as a higher-order function reveals a potentially better approach. If we can represent $$f$$ as a computational graph, there’s no reason we can’t also represent $$\nabla f$$ <em>in the same way</em>. In fact, we can simply add nodes to the graph of $$f$$ that compute derivatives with respect to each input. Because the graph already computes primal values, each node in $$f$$ only requires us to add a constant number of nodes in the graph of $$\nabla f$$. That means the result is only a constant factor larger than the input—evaluating it requires exactly the same computations as the forward-backward algorithm.</p><p>For example, given the graph of $$f(x) = x^2 + x$$, we can produce the following:</p><p><img src="https://thenumb.at/Autodiff/graph2.svg"/></p><p>Defining differentiation as a function <em>on computational graphs</em> unifies the forward and backward passes: we get a single graph that computes both $$f$$ and $$\nabla f$$. That means we can compute higher order derivatives by applying the transformation again! Distributed training is easier, too—we don’t have to implicitly synchronize gradient updates across multiple systems. JAX implements this approach, enabling its seamless gradient, JIT compilation, and vectorization transforms. PyTorch also supports higher-order differentiation via including backward operations in the computational graph, and <a href="https://github.com/pytorch/functorch">functorch</a> provides a JAX-like API.</p><p>Let’s use our fledgling differentiable programming framework to solve a real optimization problem: de-blurring an image. We’ll assume our observed image was computed using a simple box filter, i.e., each blurred pixel is the average of the surrounding 3x3 ground-truth pixels. Of course, a blur loses information, so we won’t be able to reconstruct the exact input—but we can get pretty close!</p><p>\[
\text{Blur}(\text{Image})_{xy} = \frac{1}{9} \sum_{i=-1}^1 \sum_{j=-1}^1 \text{Image}_{(x+i)(y+j)}
\]</p><table><tbody><tr><td><canvas id="image-orig"></canvas><p>Ground Truth Image</p></td><td><canvas id="image-blur"></canvas><p>Observed Image</p></td></tr></tbody></table><p>We’ll need to add one more operation to our framework: division. The operation and forward pass are much the same as addition and multiplication, but the backward pass must compute $$\frac{\partial f}{\partial x}$$ and $$\frac{\partial f}{\partial y}$$ for $$f = \frac{x}{y}$$.</p><pre id="image-div">function Divide(x, y) {
	return {op: &#39;divide&#39;, in: [x, y], out: undefined, grad: 0};
}

// Forward...
	if(node.op === &#39;divide&#39;) {
		forward(node.in[0]);
		forward(node.in[1]);
		node.out = node.in[0].out / node.in[1].out;
	}

// Backward...
	if(node.op === &#39;divide&#39;) {
		n.in[0].grad += n.grad / node.in[1].out;
		n.in[1].grad += (-n.grad * node.in[0].out / (node.in[1].out * node.in[1].out));
	}
</pre><p>Before we start programming, we need to express our task as an optimization problem. That entails minimizing a loss function that measures how far away we are from our goal.</p><p>Let’s start by guessing an arbitrary image—for example, a solid grey block. We can then compare the result of blurring our guess with the observed image. The farther our blurred result is from the observation, the larger the loss should be. For simplicity, we will define our loss as the total squared difference between each corresponding pixel.</p><p>\[
\text{Loss}(\text{Blur}(\text{Guess}), \text{Observed}) = \sum_{x=0}^W\sum_{y=0}^H (\text{Blur}(\text{Guess})_{xy} - \text{Observed}_{xy})^2
\]</p><p>Using differentiable programming, we can compute $$\frac{\partial \text{Loss}}{\partial \text{Guess}}$$, i.e. how changes in our proposed image change the resulting loss. That means we can apply gradient descent to the guess, guiding it towards a state that minimizes the loss function. Hopefully, if our blurred guess matches the observed image, our guess will match the ground truth image.</p><p>Let’s implement our loss function in differentiable code. First, create the guess image by initializing the differentiable parameters to solid grey. Each pixel has three components: red, green, and blue.</p><pre id="image-impl-0">let guess_image = new Array(W*H*3);
for (let i = 0; i &lt; W * H * 3; i++) {
	guess_image[i] = Const(127);
}
</pre><p>Second, apply the blur using differentiable operations.</p><pre id="image-impl-1">let blurred_guess_image = new Array(W*H*3);

for (let x = 0; x &lt; W; x++) {
	for (let y = 0; y &lt; H; y++) {

		let [r,g,b] = [Const(0), Const(0), Const(0)];

		// Accumulate pixels for averaging
		for (let i = -1; i &lt; 1; i++) {
			for (let j = -1; j &lt; 1; j++) {

				// Convert 2D pixel coordinate to 1D row-major array index
				const xi = clamp(x + i, 0, W - 1);
				const yj = clamp(y + j, 0, H - 1);
				const idx = (yj * W + xi) * 3;

				r = Add(r, guess_image[idx + 0]);
				g = Add(g, guess_image[idx + 1]);
				b = Add(b, guess_image[idx + 2]);
			}
		}

		// Set result to average
		const idx = (y * W + x) * 3;
		blurred_guess_image[idx + 0] = Divide(r, Const(9));
		blurred_guess_image[idx + 1] = Divide(g, Const(9));
		blurred_guess_image[idx + 2] = Divide(b, Const(9));
	}
}
</pre><p>Finally, compute the loss using differentiable operations.</p><pre id="image-impl-2">let loss = Const(0);

for (let x = 0; x &lt; W; x++) {
	for (let y = 0; y &lt; H; y++) {

		const idx = (y * W + x) * 3;
		let dr = Add(blurred_guess_image[idx + 0], Const(-observed_image[idx + 0]));
		let dg = Add(blurred_guess_image[idx + 1], Const(-observed_image[idx + 1]));
		let db = Add(blurred_guess_image[idx + 2], Const(-observed_image[idx + 2]));

		loss = Add(loss, Times(dr, dr));
		loss = Add(loss, Times(dg, dg));
		loss = Add(loss, Times(db, db));
	}
}
</pre><p>Calling <code>forward(loss)</code> performs the whole computation, storing results in each node’s <code>out</code> field. Calling <code>backward(loss)</code> computes the derivative of loss at every node, storing results in each node’s <code>grad</code> field.</p><p>Let’s write a simple optimization routine that performs gradient descent on the guess image.</p><pre id="image-impl-3">function gradient_descent_step(step_size) {

	// Clear output values and gradients
	reset(loss);

	// Forward pass
	forward(loss);

	// Backward pass
	loss.grad = 1;
	backward(loss);

	// Move parameters along gradient
	for (let i = 0; i &lt; W * H * 3; i++) {
		let p = guess_image[i];
		p.in[0] -= step_size * p.grad;
	}
}
</pre><p>We’d also like to compute <code>error</code>, the squared distance between our guess image and the ground truth. We can’t use error to inform our algorithm—we’re not supposed to know what the ground truth was—but we can use it to measure how well we are reconstructing the image. For the current iteration, we visualize the guess image, the guess image after blurring, and the gradient of loss with respect to each pixel.</p>The slider adjusts the step size. After running several steps, you&#39;ll notice that even though loss goes to zero, error does not: the loss function does not provide enough information to exactly reconstruct the ground truth. We can also see that optimization behavior depends on the step size—small steps require many iterations to converge, and large steps may overshoot the target, oscillating between too-dark and too-bright images.<p>If you’d like to learn more about differentiable programming in ML and graphics, check out the following resources:</p><ul><li><a href="https://jax.readthedocs.io/en/latest/notebooks/quickstart.html">JAX</a>, <a href="https://pytorch.org/tutorials/beginner/basics/intro.html">PyTorch</a>, <a href="https://www.tensorflow.org/tutorials/quickstart/beginner">TensorFlow</a>, <a href="https://github.com/geohot/tinygrad">tinygrad</a>, <a href="https://github.com/patr-schm/TinyAD">TinyAD</a></li><li><a href="https://physicsbaseddeeplearning.org/intro.html">Physics-Based Deep Learning</a>, <a href="https://www.youtube.com/watch?v=Tou8or1ed6E">Differentiable Rendering Intro</a>, <a href="https://rgl.epfl.ch/publications">Differentiable Rendering Papers</a>, <a href="https://neuralfields.cs.brown.edu/">Neural Fields in Visual Computing</a></li><li><a href="https://dlsyscourse.org/">CMU Deep Learning Systems</a></li></ul><p>Written on <time datetime="2022-07-31T00:00:00+00:00">July 31, 2022</time></p></main></div></div>
  </body>
</html>
