<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ariadne.space/2023/04/13/writing-portable-arm64-assembly/">Original</a>
    <h1>Writing Portable ARM64 Assembly</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>An unfortunate side effect of the rising popularity of Apple’s ARM-based
computers is an increase in unportable assembly code which targets the
64-bit ARM ISA.  This is because developers are writing these bits of
assembly code to speed up their programs when run on Apple’s ARM-based
computers, without considering the other 64-bit ARM devices out there,
such as SBCs and servers running Linux or BSD.</p>
<p>The good news is that it is very easy to write assembly which targets
Apple’s computers as well as the other 64-bit ARM devices running
operating systems other than Darwin.  It just requires being aware of
a few differences between the Mach-O and ELF ABIs, as well as knowing
what Apple-specific syntax extensions to avoid.  By following the
guidance in this blog, you will be able to write assembly code which
is portable between Apple’s toolchain, the official ARM assembly
toolchain, and the GNU toolchain.</p>
<h2 id="differences-between-the-elf-and-mach-o-abis">Differences between the ELF and Mach-O ABIs</h2>
<p>Modern UNIX systems, including Linux-based systems largely use the
<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF binary format</a>.  Apple uses <a href="https://en.wikipedia.org/wiki/Mach-O">Mach-O</a> in Darwin
instead for historical reasons.  This is not a requirement for Apple
imposed by their use of Mach, indeed, OSFMK, the kernel that Darwin,
MkLinux and OSF/1 are all based on, supports ELF binaries just fine.
Apple just decided to use the Mach-O format instead.</p>
<p>When it comes to writing assembly (or, really, just linking code
in general) targeting Darwin, the main difference to be aware of is
that all symbols are prefixed with a single underscore.  For example,
if you have a function that would be declared in C like:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>extern</span> <span>void</span> <span>unmask</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>payload</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>mask</span><span>,</span> <span>size_t</span> <span>len</span><span>);</span>
</span></span></code></pre></div><p>On Darwin, the function in your assembly code must be defined as <code>_unmask</code>.</p>
<p>The other major difference is that ELF defines different classes of
data, for example <code>STT_FUNC</code> and <code>STT_OBJECT</code>.  There is no equivalence
in Mach-O, and thus the <code>.type</code> directive that you would use when writing
assembly for ELF targets is not supported.</p>
<h2 id="apple-specific-vector-mnemonics">Apple-specific vector mnemonics</h2>
<p>The other main thing to watch out for is Apple’s custom mnemonics for
NEON.  In order to make writing NEON code less cumbersome, Apple
introduced a set of mnemonics that allow simplification of specifying
NEON instructions.  For example, if you are targeting Apple devices
only, you might write an exclusive-or NEON instruction like so:</p>
<p>This is an Apple-specific extension to the ARM assembly syntax.  The
<a href="https://developer.arm.com/documentation/dui0802/b/A64-SIMD-Vector-Instructions/EOR--vector-">official ARM assembly manual</a> specifies that the memory layout
must be specified for each register:</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>eor</span>     <span>v2.16b</span><span>,</span> <span>v2.16b</span><span>,</span> <span>v0.16b</span>
</span></span></code></pre></div><h2 id="abstracting-the-abi-details-with-some-macros">Abstracting the ABI details with some macros</h2>
<p>The good news is that the ABI details can easily be abstracted with a
few macros.  As for using NEON functions, the answer is simple: stick to
what the ARM manual says to do, rather than using Apple’s mnemonics.</p>
<p>There are two macros that you need.  These can be placed in a header
file somewhere if wanted.</p>
<p>The first macro allows you to deal with the underscore requirement of the
Darwin ABI:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>#ifdef __MACH__
</span></span></span><span><span><span># define PROC_NAME(__proc) _ ## __proc
</span></span></span><span><span><span>#else
</span></span></span><span><span><span># define PROC_NAME(__proc) __proc
</span></span></span><span><span><span>#endif
</span></span></span></code></pre></div><p>The second macro is optional, but it allows you to define the correct
ELF symbol types outside of Apple’s toolchain:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>#ifdef __clang__
</span></span></span><span><span><span># define TYPE(__proc, __typ)
</span></span></span><span><span><span>#else
</span></span></span><span><span><span># define TYPE(__proc, __typ) .type __proc, __typ
</span></span></span><span><span><span>#endif
</span></span></span></code></pre></div><p>Then you just write your assembly as normal, but using these macros:</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>.global</span> <span>PROC_NAME</span><span>(</span><span>unmask</span><span>)</span>
</span></span><span><span><span>.align</span> <span>2</span>
</span></span><span><span><span>TYPE</span><span>(</span><span>unmask</span><span>,</span> <span>@</span><span>function</span><span>)</span>
</span></span><span><span><span>PROC_NAME</span><span>(</span><span>unmask</span><span>):</span>
</span></span><span><span>   <span>...</span>
</span></span></code></pre></div><p>And that’s all there is to it.  As long as you follow these guidelines,
you will have assembly which is portable to any UNIX-like environment on
64-bit ARM.</p>

  </div></div>
  </body>
</html>
