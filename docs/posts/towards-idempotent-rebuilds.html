<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.josefsson.org/2024/07/10/towards-idempotent-rebuilds/">Original</a>
    <h1>Towards Idempotent Rebuilds?</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>After <a href="https://blog.josefsson.org/2023/04/10/trisquel-is-42-reproducible/">rebuilding all added/modified packages in Trisquel</a>, I have been circling around the elephant in the room: 99% of the binary packages in Trisquel comes from Ubuntu, which to a large extent are built from Debian source packages. Is it possible to rebuild the official binary packages identically? Does anyone make an effort to do so? Does anyone care about going through the differences between the official package and a rebuilt version? <a href="https://reproducible-builds.org/">Reproducible-build.org</a>‘s effort to track <a href="https://tests.reproducible-builds.org/debian/rb-pkg/unstable/amd64/diffoscope-results/mpich.html">reproducibility bugs in Debian</a> (and other systems) is amazing. However as far as I know, they do not confirm or deny that their rebuilds match the official packages. In fact, typically their rebuilds do not match the official packages, even when they say the package is reproducible, which had me surprised at first. To understand why that happens, compare the <a href="https://buildinfo.debian.net/0ddf8ee352df8a2f74aa86efaebdf3e032f7320e/coreutils_9.1-1_amd64">buildinfo file for the official coreutils 9.1-1</a> from Debian bookworm with the <a href="https://tests.reproducible-builds.org/debian/rb-pkg/bookworm/amd64/coreutils.html">buildinfo file for reproducible-build.org’s build</a> and you will see that the SHA256 checksum does not match, but still they declare it as a reproducible package. As far as I can tell of the situation, the purpose of their rebuilds are not to say anything about the official binary build, instead the purpose is to offer a QA service to maintainers by performing two builds of a package and declaring success if both builds match.</p>



<p>I have felt that something is lacking, and months have passed and I haven’t found any project that address the problem I am interested in.  During my earlier work I created a project called <a href="https://blog.josefsson.org/2023/04/17/more-on-differential-reproducible-builds-devuan-is-46-reproducible/">debdistreproduce</a> which performs rebuilds of the difference between two distributions in a GitLab pipeline, and display <a href="https://diffoscope.org/">diffoscope</a> output for further analysis.  A couple of days ago I had the idea of rewriting it to perform rebuilds of a single distribution.  A new project <a href="https://gitlab.com/debdistutils/debdistrebuild">debdistrebuild</a> was born and today I’m happy to bless it as <a href="https://gitlab.com/debdistutils/debdistrebuild/-/tree/v1.0">version 1.0</a> and to announces the project!  Debdistrebuild has <strong>rebuilt the top-50 popcon packages from Debian bullseye, bookworm and trixie, on amd64 and arm64, as well as Ubuntu jammy and noble on amd64</strong>, see the <a href="https://gitlab.com/debdistutils/debdistrebuild/-/tree/v1.0#show-me-results">summary status page</a> for links.  This is intended as a proof of concept, to allow people experiment with the concept of doing GitLab-based package rebuilds and analysis.  Compare how <a href="https://guix.gnu.org/">Guix</a> has the <code><a href="https://guix.gnu.org/manual/en/html_node/On-Trusting-Binaries.html">guix challenge</a></code> command.</p>



<p>Or I should say <code>debdistrebuild</code> has <em>attempted</em> to rebuild those distributions.  The number of identically built packages are fairly low, so I didn’t want to waste resources building the rest of the archive until I understand if the differences are due to consequences of my build environment (plain <code>apt-get build-dep</code> followed by <code>dpkg-buildpackage</code> in a fresh container), or due to some real difference.  Summarizing the results, <code><strong>debdistrebuild</strong></code><strong> is able to rebuild 34% of Debian bullseye on amd64, 36% of bookworm on amd64, 32% of bookworm on arm64</strong>.  The results for trixie and Ubuntu are disappointing, below 10%.</p>



<p>So what causes my rebuilds to be different from the official rebuilds? Some are trivial like the classical problem of <a href="https://debdistutils.gitlab.io/-/reproduce/debian-bullseye-amd64/-/jobs/7291684506/artifacts/diffoscope/index.html">varying build paths</a>, resulting in a different <code>NT_GNU_BUILD_ID</code> causing a mismatch.  Some are a bit strange, like a <a href="https://debdistutils.gitlab.io/-/reproduce/debian-bullseye-amd64/-/jobs/7291769934/artifacts/diffoscope/index.html">subtle difference in one of perl’s headers</a> file.  Some are due to <a href="https://debdistutils.gitlab.io/-/reproduce/debian-bullseye-amd64/-/jobs/7291759732/artifacts/diffoscope/index.html">embedded version numbers</a> from a build dependency.  Several of the build logs and diffoscope outputs doesn’t make sense, likely due to bugs in my build scripts, especially for Ubuntu which appears to strip translations and do other build variations that I don’t do.  In general, the classes of reproducibility problems are the expected.  Some are <a href="https://debdistutils.gitlab.io/-/reproduce/debian-bullseye-amd64/-/jobs/7291703958/artifacts/diffoscope/index.html">assembler differences</a> for GnuPG’s gpgv-static, likely triggered by upload of a new version of gcc after the original package was built.  There are at least two ways to resolve that problem: either use the same version of build dependencies that were used to produce the original build, or demand that all packages that are affected by a change in another package are rebuilt centrally until there are no more differences.</p>



<p>The current design of <code>debdistrebuild</code> uses the latest version of a build dependency that is available in the distribution. We call this a “<strong>idempotent rebuild</strong>“. This is usually not how the binary packages were built originally, they are often built against earlier versions of their build dependency. That is the situation for most binary distributions.</p>



<p>Instead of using the latest build dependency version, higher reproducability may be achieved by rebuilding using the same version of the build dependencies that were used during the original build. This requires parsing <a href="https://buildinfo.debian.net/">buildinfo</a> files to find the right version of the build dependency to install. We believe doing so will lead to a higher number of reproducibly built packages. However it begs the question: can we rebuild that earlier version of the build dependency? This circles back to really old versions and <a href="https://bootstrappable.org/">bootstrappable builds</a> eventually.</p>



<p>While rebuilding old versions would be interesting on its own, we believe that is less helpful for trusting the latest version and improving a binary distribution: it is challenging to publish a new version of some old package that would fix a reproducibility bug in another package when used as a build dependency, and then rebuild the later packages with the modified earlier version. Those earlier packages were already published, and are part of history. It may be that ultimately it will no longer be possible to rebuild some package, because proper source code is missing (for packages using build dependencies that were never part of a release); hardware to build a package could be missing; or that the source code is no longer publicly distributable.</p>



<p>I argue that getting to 100% idempotent rebuilds is an interesting goal on its own, and to reach it we need to start measure idempotent rebuild status.</p>



<p>One could conceivable imagine a way to rebuild modified versions of earlier packages, and then rebuild later packages using the modified earlier packages as build dependencies, for the purpose of achieving higher level of reproducible rebuilds of the last version, and to reach for bootstrappability. However, it may be still be that this is insufficient to achieve idempotent rebuilds of the last versions. Idempotent rebuilds are different from a reproducible build (where we try to reproduce the build using the same inputs), and also to bootstrappable builds (in which all binaries are ultimately built from source code). Consider a cycle where package X influence the content of package Y, which in turn influence the content of package X. These cycles may involve several packages, and it is conceivable that a cycle could be circular and infinite. It may be difficult to identify these chains, and even more difficult to break them up, but this effort help identify where to start looking for them. Rebuilding packages using the same build dependency versions as were used during the original build, or rebuilding packages using a bootsrappable build process, both seem orthogonal to the idempotent rebuild problem.</p>



<p>Our notion of rebuildability appears thus to be complementary to <a href="https://reproducible-builds.org/docs/definition/">reproducible-builds.org’s definition</a> and <a href="https://bootstrappable.org/">bootstrappable.org’s definition</a>. Each to their own devices, and Happy Hacking!</p>
			</div></div>
  </body>
</html>
