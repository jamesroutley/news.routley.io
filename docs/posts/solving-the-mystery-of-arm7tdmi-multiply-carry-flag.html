<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bmchtech.github.io/post/multiply/">Original</a>
    <h1>Solving the Mystery of ARM7TDMI Multiply Carry Flag</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>This blog post assumes a base level of knowledge - comfort in the C programming language and bitwise math is recommended. Also, if you ever have any questions, any at all, while reading this blog post, feel free to reach out to me <a href="https://github.com/bmchtech/blog/discussions">here</a>.</p><p>The Gameboy Advance has a pretty neat CPU - the ARM7TDMI. This CPU is quite complicated - it allows the program counter to be used a <em>general purpose register</em>, implying it can be used as the output to any data processing instruction. That’s like allowing a drunk driver to change their tires while going 30 over the speed limit near a school. It’s a unique feature that can lead to very funny instructions. For example, you can use the program
counter as the output to, say, an XOR instruction. Or an AND instruction.</p><p>Or a multiply instruction.</p><p><a name="instructions"></a>Multiplication on the ARM7TDMI has a few neat features. You can multiply two 32-bit operands together to produce a 64-bit result. You can also optionally choose to do a multiply-add and add a third 64-bit operand to the 64-bit result, within the same instruction. Additionally, you can choose to treat the two 32-bit as either signed or unsigned.</p><p>Why are we talking about the multiplication instruction? Well the ARM7TDMI’s multiplication instructions have a pretty interesting side effect. Here the manual says that
after a multiplication instruction executes, the carry flag is set to a “meaningless value”.</p><p><img alt="An image of the ARM7TDMI manual explaining that the carry and overflow flags are UNPREDICTABLE after a multiply instruction." src="https://bmchtech.github.io/manual.png"/></p><p><small>A short description of carry and overflow flags after a multiplication instruction from the ARM7TDMI manual. <sup>[<a href="https://bmchtech.github.io/post/multiply/#cite1">1</a>]</sup></small></p><p>What this means is that software cannot and
should not rely on the value of the carry flag after multiplication executes. It can be set to anything. Any
value. 0, 1, a horse, whatever. This has been a source of memes in the emulator development community for a few years -
people would frequently joke about how the implementation of the carry flag may as well be <code>cpu.flags.c = rand() &amp; 1;</code>. And they had a point - the carry flag seemed to defy all patterns; nobody understood why it
behaves the way it does. But the one thing we did know, was that the carry flag seemed to be
<em>deterministic</em>. That is, under the same set of inputs to a multiply instruction, the flag would be set to the
same value. This was big news, because it meant that understanding the carry flag could give us key
insight into how this CPU performs multiplication.</p><p>And just to get this out of the way, the carry flag’s behavior after multiplication isn’t an important detail to
emulate at all. Software doesn’t rely on it. And if software <em>did</em> rely on it, then screw the developers who wrote that software. But the carry flag is a meme, and it’s a really tough puzzle, and
that was motivation enough for me to give it a go. Little did I know it’d take <em>3 years</em> of on and off work.</p><p>What’s the simplest, most basic multiplication algorithm you can think of to multiply a <span><strong>multiplier</strong></span> with a <span><strong>multiplicand</strong></span>? One really easy way is to
leverage the distributive property of multiplication like so:</p><p>$$
\color{#3a7dc9}123\color{#4A4358} \cdot \color{#DC6A76}4 \color{#4A4358}=
\color{#3a7dc9}{100 \color{#4A4358} \cdot \color{#DC6A76}4} \color{#4A4358} + \color{#3a7dc9}{20 \color{#4A4358} \cdot \color{#DC6A76}4} \color{#4A4358} + \color{#3a7dc9}{3 \color{#4A4358} \cdot \color{#DC6A76}4}
$$</p><p>There’s two steps here - first compute the addends, then sum them. This
is the basic two-step process you’ll find in lots of multiplication algorithms - most of them simply differ in
how they compute the addends, or how they add the addends together. We can generalize this algorithm
to binary pretty easily too:</p><p>$$
\color{#3a7dc9}1101 \color{#4A4358} \cdot \color{#DC6A76}11\color{#4A4358} =
\color{#3a7dc9}{1000 \color{#4A4358} \cdot\color{#DC6A76} 11} \color{#4A4358} + \color{#3a7dc9}{100 \color{#4A4358} \cdot \color{#DC6A76} 11} \color{#4A4358} + \color{#3a7dc9}{0 \color{#4A4358} \cdot\color{#DC6A76} 11} \color{#4A4358} + \color{#3a7dc9}{1 \color{#4A4358} \cdot \color{#DC6A76}11}
$$</p><p>The convenient thing about binary is that it’s all ones and zeros, meaning the addends are only ever <code>0</code>, or
the <span><strong>multiplicand</strong></span> left shifted by some factor. This makes the addends easy to compute, and means that for
an <code>N-bit</code> number, we need to produce <code>N</code> different addends, and add them all up to get the result.
That’s a lot of addends, which is slow. We can do better.</p><p>The main slowness of the Standard Algorithm is that it requires you to add a <em>lot</em> of numbers together.
Modified Booth’s algorithm is an improvement on the Standard Algorithm that cuts the number of addends in two. Let’s start with the standard definition for multiplication, written as a summation. Note that <code>m[i]</code> is defined as the bit at index <code>i</code> of <code>m</code> when <code>0 &lt;= i &lt; n</code>.</p><p>$$
\begin{aligned}
\color{#3a7dc9}{m}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} &amp;= \sum_{i=0}^{n-1} (2^i \cdot \color{#3a7dc9}{m[i]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) \cr
\end{aligned}
$$</p><p>Now we apply the following transformations. Yes I know this looks scary, you could skip to <a href="https://bmchtech.github.io/post/multiply/#finaleq">the final equation</a> if you want.</p><p>$$
\begin{align}
\color{#3a7dc9}{m}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} &amp;= \sum_{i=0}^{n-1} (2^i \cdot \color{#3a7dc9}{m[i]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} )\cr\cr
&amp;\quad\text{Separate the summation into even and odd elements:}\cr \cr
\color{#3a7dc9}{m}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} &amp;= \sum_{i=0}^{\frac{n}{2}-1} (2^{2i} \cdot \color{#3a7dc9}{m[2i]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) + \sum_{i=0}^{\frac{n}{2}-1} (2^{2i + 1} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) \cr
\cr&amp;     \quad\text{                  Split the second summation into two more summations:}\cr \cr
\color{#3a7dc9}{m}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} &amp;= \sum_{i=0}^{\frac{n}{2}-1} (2^{2i} \cdot \color{#3a7dc9}{m[2i]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) + (2 - 1) \cdot \sum_{i=0}^{\frac{n}{2}-1} (2^{2i + 1} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) \cr
\color{#3a7dc9}{m}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} &amp;= \sum_{i=0}^{\frac{n}{2}-1} (2^{2i} \cdot \color{#3a7dc9}{m[2i]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) + 2 \sum_{i=0}^{\frac{n}{2}-1} (2^{2i + 1} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) - \sum_{i=0}^{\frac{n}{2}-1} (2^{2i + 1} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) \cr
\color{#3a7dc9}{m}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} &amp;= \sum_{i=0}^{\frac{n}{2}-1} (2^{2i} \cdot \color{#3a7dc9}{m[2i]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) + \sum_{i=0}^{\frac{n}{2}-1} (2^{2i + 2} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) - \sum_{i=0}^{\frac{n}{2}-1} (2^{2i + 1} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) \cr \cr&amp;     \quad\text{                  Pull out a single element from each summation, one at a time:}\cr \cr
\color{#3a7dc9}{m}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} &amp;= \sum_{i=1}^{\frac{n}{2}-1} (2^{2i} \cdot \color{#3a7dc9}{m[2i]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) + \sum_{i=0}^{\frac{n}{2}-1} (2^{2i + 2} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) - \sum_{i=0}^{\frac{n}{2}-1} (2^{2i + 1} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) + (\color{#3a7dc9}{m[0]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358})\cr
\color{#3a7dc9}{m}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} &amp;= \sum_{i=1}^{\frac{n}{2}-1} (2^{2i} \cdot \color{#3a7dc9}{m[2i]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) + \sum_{i=0}^{\frac{n}{2}-2} (2^{2i + 2} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) - \sum_{i=0}^{\frac{n}{2}-1} (2^{2i + 1} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) + (\color{#3a7dc9}{m[0]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} + 2^{n} \cdot \color{#3a7dc9}{m[n - 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} )\cr
\color{#3a7dc9}{m}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} &amp;= \sum_{i=1}^{\frac{n}{2}-1} (2^{2i} \cdot \color{#3a7dc9}{m[2i]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) + \sum_{i=0}^{\frac{n}{2}-2} (2^{2i + 2} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) - \sum_{i=1}^{\frac{n}{2}-1} (2^{2i + 1} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) + (\color{#3a7dc9}{m[0]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} + 2^{n} \cdot \color{#3a7dc9}{m[n - 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} + 2 \cdot \color{#3a7dc9}{m[1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} )\cr
\cr&amp;     \quad\text{                  Manipulate the range of the second summation to match the ranges of the other two:}\cr \cr
\color{#3a7dc9}{m}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} &amp;= \sum_{i=1}^{\frac{n}{2}-1} (2^{2i} \cdot \color{#3a7dc9}{m[2i]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) + \sum_{i=1}^{\frac{n}{2}-1} (2^{2i} \cdot \color{#3a7dc9}{m[2i - 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) - \sum_{i=1}^{\frac{n}{2}-1} (2^{2i + 1} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) + (\color{#3a7dc9}{m[0]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} + 2^{n} \cdot \color{#3a7dc9}{m[n - 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} + 2 \cdot \color{#3a7dc9}{m[1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} )\cr
\cr&amp;     \quad\text{                  So that we can combine the summations now:}\cr \cr
\color{#3a7dc9}{m}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} &amp;= \sum_{i=1}^{\frac{n}{2}-1} (2^{2i} \cdot \color{#3a7dc9}{m[2i]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} + 2^{2i} \cdot \color{#3a7dc9}{m[2i - 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} - 2^{2i + 1} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) + (\color{#3a7dc9}{m[0]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} + 2^{n} \cdot \color{#3a7dc9}{m[n - 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} + 2 \cdot \color{#3a7dc9}{m[1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} )\cr
\cr&amp;     \quad\text{                  Some tidywork...}\cr \cr
\color{#3a7dc9}{m}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} &amp;= \sum_{i=1}^{\frac{n}{2}-1} (2^{2i} \cdot \color{#3a7dc9}{m[2i]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} + 2^{2i} \cdot \color{#3a7dc9}{m[2i - 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} - 2 \cdot 2^{2i} \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358}) + (\color{#3a7dc9}{m[0]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} + 2^{n} \cdot \color{#3a7dc9}{m[n - 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} + 2 \cdot \color{#3a7dc9}{m[1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} )\cr
\color{#3a7dc9}{m}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} &amp;= \sum_{i=1}^{\frac{n}{2}-1} ((2^{2i} \cdot \color{#DC6A76} \alpha \color{#4A4358} )\cdot(\color{#3a7dc9}{m[2i]}\color{#4A4358} + \color{#3a7dc9}{m[2i - 1]}\color{#4A4358} - 2 \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358} )) + (\color{#3a7dc9}{m[0]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} + 2^{n} \cdot \color{#3a7dc9}{m[n - 1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} + 2 \cdot \color{#3a7dc9}{m[1]}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} )\cr
\end{align}
$$</p><p>Whew. Did you get all of that? Why did we do all this? Well, note this part of the summation:</p><p>$$
\begin{aligned}
(\color{#3a7dc9}{m[2i]}\color{#4A4358} + \color{#3a7dc9}{m[2i - 1]}\color{#4A4358} - 2 \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358})
\end{aligned}
$$</p><p>This is always one of <code>(-2, -1, 0, 1, 2)</code>.</p><p><a name="negation"></a>Multiplication by those five numbers is easy to calculate in hardware (well, negation is tricky - the algorithm implements negation as bitwise inversion, with an additional 1 added at a later stage. More information about this is given later).</p><p>Note also that if we define:</p><p>$$
\color{#3a7dc9}{m[-1]}\color{#4A4358} = 0
$$</p><p>and</p><p>$$
\begin{aligned}
\text{For}&amp;\text{ unsigned multiplication:}\cr\cr
&amp;x \geq n:  \color{#3a7dc9}{m[x]}\color{#4A4358} = 0\cr\cr
\text{For}&amp;\text{ signed multiplication:}\cr\cr
&amp;x \geq n: \color{#3a7dc9}{m[x]}\color{#4A4358} = \color{#3a7dc9}m[n-1]\cr\cr
\end{aligned}
$$</p><p>Then the leftover three terms outside the summation can be absorbed into the summation, by expanding the summations range by one on both boundaries. And so we have:</p><p>$$
\begin{aligned}
\color{#3a7dc9}{m}\color{#4A4358} \cdot \color{#DC6A76} \alpha \color{#4A4358} &amp;= \sum_{i=0}^{\frac{n}{2}} ((2^{2i} \cdot \color{#DC6A76} \alpha \color{#4A4358}) \cdot (\color{#3a7dc9}{m[2i]}\color{#4A4358} + \color{#3a7dc9}{m[2i - 1]}\color{#4A4358} - 2 \cdot \color{#3a7dc9}{m[2i + 1]}\color{#4A4358}))\cr
\end{aligned}
$$</p><p>Before all this mathematical chaos, we used to have <code>n</code> addends. Now we have just over half that many addends. We can model the generation of an addend sans the left shift using the following C code:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>// represents a 3-bit chunk that is used to determine an addend&#39;s value
</span></span></span><span><span><span></span><span>typedef</span> u8 BoothChunk;
</span></span><span><span>
</span></span><span><span><span>struct</span> BoothRecodingOutput {
</span></span><span><span>    u64  recoded_output;
</span></span><span><span>    <span>bool</span> carry;
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>// booth_chunk is a 3-bit number representing bits [2i - 1 .. 2i + 1]
</span></span></span><span><span><span>// of the multiplier
</span></span></span><span><span><span></span><span>struct</span> BoothRecodingOutput <span>booth_recode</span>(u64 input, BoothChunk booth_chunk) {
</span></span><span><span>    <span>switch</span> (booth_chunk) {
</span></span><span><span>        <span>case</span> <span>0</span><span>:</span> <span>return</span> (<span>struct</span> BoothRecodingOutput) {            <span>0</span>, <span>0</span> };
</span></span><span><span>        <span>case</span> <span>1</span><span>:</span> <span>return</span> (<span>struct</span> BoothRecodingOutput) {        input, <span>0</span> };
</span></span><span><span>        <span>case</span> <span>2</span><span>:</span> <span>return</span> (<span>struct</span> BoothRecodingOutput) {        input, <span>0</span> };
</span></span><span><span>        <span>case</span> <span>3</span><span>:</span> <span>return</span> (<span>struct</span> BoothRecodingOutput) {    <span>2</span> <span>*</span> input, <span>0</span> };
</span></span><span><span>        <span>case</span> <span>4</span><span>:</span> <span>return</span> (<span>struct</span> BoothRecodingOutput) { <span>~</span>(<span>2</span> <span>*</span> input), <span>1</span> };
</span></span><span><span>        <span>case</span> <span>5</span><span>:</span> <span>return</span> (<span>struct</span> BoothRecodingOutput) {       <span>~</span>input, <span>1</span> };
</span></span><span><span>        <span>case</span> <span>6</span><span>:</span> <span>return</span> (<span>struct</span> BoothRecodingOutput) {       <span>~</span>input, <span>1</span> };
</span></span><span><span>        <span>case</span> <span>7</span><span>:</span> <span>return</span> (<span>struct</span> BoothRecodingOutput) {            <span>0</span>, <span>0</span> };
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>// Note that case 4 can *not* be implemented as 2 * (~input). The reason why
</span></span></span><span><span><span></span>    <span>// is that the real value of the addend as represented by the struct is
</span></span></span><span><span><span></span>    <span>// recoded_output + carry. Doing the inversion after the multiplication by 2
</span></span></span><span><span><span></span>    <span>// will put a 1 in the LSB of the recoded_output, allowing the carry to be
</span></span></span><span><span><span></span>    <span>// added correctly.
</span></span></span><span><span><span></span>}
</span></span></code></pre></div><p>For the curious, more information about Booth Recoding can be found in this resource. <sup>[<a href="https://bmchtech.github.io/post/multiply/#cite2">2</a>]</sup></p><p>Now that we have the addends, it’s time to actually add them up to produce the result. However, using a
conventional full adder, the ARM7TDMI is only fast enough to add two numbers per cycle. Which means,
you gotta spend 16 cycles to add all 17 addends, which is uselessly slow. The reason full adders are so
slow is because of the carry propagation - bit <code>N</code> of the result can’t be determined till bit <code>N - 1</code> is
determined. Can we eliminate this issue?</p><p>Introducing… <em>drum roll</em>… carry save adders (CSAs)! These are genius - instead of outputting a single <code>N-bit</code> result, CSAs output one <code>N-bit</code> result without carry propagation, and one <code>N-bit</code> list of carries computed from each bit. At first this seems kind of silly - are CSAs really adding two <code>N-bit</code> operands and
producing two <code>N-bit</code> results? What’s the point? The point is that you can actually fit in an extra operand,
and turn three <code>N-bit</code> operands into two <code>N-bit</code> results. <sup>[<a href="https://bmchtech.github.io/post/multiply/#cite3">3</a>]</sup> Like so:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>struct</span> CSAOutput {
</span></span><span><span>    u64 output;
</span></span><span><span>    u64 carry;
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>struct</span> CSAOutput <span>perform_csa</span>(u64 a, u64 b, u64 c) {
</span></span><span><span>    <span>// Bit i in result should be set if there is either 1 set bit in 
</span></span></span><span><span><span></span>    <span>// src1/src2/src3 at index i, or 3 set bits in src1/src2/src3 at
</span></span></span><span><span><span></span>    <span>// index i. Similarly, bit i in carries should be set if there&#39;s
</span></span></span><span><span><span></span>    <span>// 2 or 3 set bits in src1/src2/src3 at index i. See if you can
</span></span></span><span><span><span></span>    <span>// convince yourself why this is correct.
</span></span></span><span><span><span></span>
</span></span><span><span>    u64 output <span>=</span> a <span>^</span> b <span>^</span> c;
</span></span><span><span>    u64 carry  <span>=</span> (a <span>&amp;</span> b) <span>|</span> (b <span>&amp;</span> c) <span>|</span> (c <span>&amp;</span> a);
</span></span><span><span>    <span>return</span> (<span>struct</span> CSAOutput) { output, carry };
</span></span><span><span>}
</span></span></code></pre></div><p>So you can chain a bunch of CSAs to get yourself down to two addends, and then you can shove the two
<code>N-bit</code> results into a regular adder, like so:</p><div><pre tabindex="0"><code data-lang="c"><span><span>u64 <span>add_csa_results</span>(u64 result, u64 carries) {
</span></span><span><span>    <span>// Exercise for the reader: Why do you suppose we multiply
</span></span></span><span><span><span></span>    <span>// carries by 2? Think about how a full adder is implemented,
</span></span></span><span><span><span></span>    <span>// and what the variable &#34;carries&#34; in the perform_csa function
</span></span></span><span><span><span></span>    <span>// above actually represents. The answer is given after this
</span></span></span><span><span><span></span>    <span>// code block.
</span></span></span><span><span><span></span>
</span></span><span><span>    <span>return</span> result <span>+</span> carries <span>*</span> <span>2</span>;
</span></span><span><span>}
</span></span></code></pre></div><p>The reason we multiply <code>carries</code> by two is because, if we think about how a full adder works, the carry out
from bit <code>i</code> is added to bits <code>i + 1</code> of the addends. So, bit <code>i</code> of carries has double the “weight” of bit <code>i</code> of
result. This is a <strong>very</strong> important detail that will come in handy later, so do make sure you understand
this.</p><p>Using CSAs, the ARM7TDMI can sum up the addends together much faster. <sup>[<a href="https://bmchtech.github.io/post/multiply/#cite4">4, p. 94</a>]</sup></p><p>Until now, we’ve mostly treated “generate the addends” and “add the addends” as two separate, entirely
discrete steps of the algorithm. Can we do them at the same time? Turns out, yes! We can generate some number of addends per cycle, and add them together using CSAs in the same cycle. We repeat this process until we’ve added up all our addends, and then we can send the results from the CSA to the ALU to be added together.</p><p>This is what the ARM7TDMI does - it generates four addends per cycle, and compresses
them using four CSAs to generates only two addends.</p><center><p><img alt="An image of the ARM7TDMI manual explaining that the carry and overflow flags are UNPREDICTABLE after a multiply instruction." src="https://bmchtech.github.io/diagram.png"/></p></center><p>Each cycle, we read 8 bits from the <span><strong>multiplier</strong></span>, and with it, we generate 4 addends. We then
feed them into 4 of the 6 inputs of this CSA array, and when we have our 2 results, feed those
2 results back to the very top of the CSA array for the next cycle. On the first cycle of the algorithm, we can initialize those 2 inputs to the
CSA array with <code>0</code>s.</p><p><a name="trick"></a>A clever trick can be done here. The ARM7TDMI <a href="https://bmchtech.github.io/post/multiply/#instructions">supports mutliply accumulates</a>, which perform multiplication and addition in one instruction. We can implement multiply accumulate by initializing one
of those two inputs with the accumulate value, and get multiply accumulate without extra cycles. This trick is what the
ARM7TDMI employs to do multiply accumulate. (This ends up being a moot point, because the CPU is stupid and can only read two register values at a time per cycle. So, using an accumulate causes the CPU to take
an extra cycle <em>anyway</em>). <sup>[<a href="https://bmchtech.github.io/post/multiply/#cite4">4, p.95</a>]</sup></p><p>The ARM7TDMI does something really clever here. In our current model of the algorithm, there are 4
cycles of CSA compression, where each cycle <code>i</code> processes bits <code>8 * i</code> to <code>8 * i + 7</code> of the <span><strong>multiplier</strong></span>. The observation is that if the remaining upper bits of the <span><strong>multiplier</strong></span> are all
zeros, then, we can skip that cycle, since the addends produced will be all zeros, which cannot possibly
affect the values of the partial result + partial carry. We can do the same trick if the remaining upper bits
are all ones (assuming we are performing a signed multiplication), as those also produce addends that
are all zeros. <sup>[<a href="https://bmchtech.github.io/post/multiply/#cite4">4, p.95</a>]</sup></p><p>Here’s a rough diagram, provided by Steve Furber in his book, Arm System-On-Chip Architecture:</p><p><a name="diagram"></a><img alt="An image of the high level overview of the multiplier’s organization, provided by Steve Furber in his book, Arm System-On-Chip Architecture" src="https://bmchtech.github.io/booth.png"/>
<small>An image of the high level overview of the multiplier’s organization, provided by Steve Furber in his book, Arm System-On-Chip Architecture. <sup>[<a href="https://bmchtech.github.io/post/multiply/#cite4">4, p.95</a>]</sup></small></p><p>Partial Sum / Partial Carry contain the results obtained by the CSAs, and are rotated right by 8 on each cycle. Rm is recoded using booth’s algorithm to produce the addends for the CSA array. <sup>[<a href="https://bmchtech.github.io/post/multiply/#cite4">4, p.95</a>]</sup></p><p>Ok, but <a href="https://bmchtech.github.io/post/multiply/#negation">remember when I said</a> that there will be an elegant way to handle booth’s negation of the addends? The way the algorithm gets around this is kind of genius. Remember how the carry output of a CSA has to be left shifted by 1? Well, this left-shift creates a zero in the LSB of the carry output of the CSA, so why don’t we just put the carry in that bit? <sup>[<a href="https://bmchtech.github.io/post/multiply/#cite5">5, p. 12</a>]</sup> Like so:
<a name="perform_csa_array"></a></p><div><pre tabindex="0"><code data-lang="c"><span><span><span>struct</span> CSAOutput <span>perform_csa_array</span>(u64 partial_sum, u64 partial_carry, 
</span></span><span><span>                                   <span>struct</span> RecodedMultiplicands addends) {
</span></span><span><span>    <span>struct</span> CSAOutput csa_output <span>=</span> { partial_sum, partial_carry };
</span></span><span><span>    <span>struct</span> CSAOutput final_csa_output <span>=</span> { <span>0</span>, <span>0</span> };
</span></span><span><span>
</span></span><span><span>    <span>for</span> (<span>int</span> i <span>=</span> <span>0</span>; i <span>&lt;</span> <span>4</span>; i<span>++</span>) {
</span></span><span><span>        csa_output.output <span>&amp;=</span> <span>0x1FFFFFFFFULL</span>;
</span></span><span><span>        csa_output.carry  <span>&amp;=</span> <span>0x1FFFFFFFFULL</span>;
</span></span><span><span>
</span></span><span><span>        <span>struct</span> CSAOutput result <span>=</span> <span>perform_csa</span>(csa_output.output, 
</span></span><span><span>            addends.m[i].recoded_output <span>&amp;</span> <span>0x3FFFFFFFFULL</span>, csa_output.carry);
</span></span><span><span>
</span></span><span><span>        <span>// Inject the carry caused by booth recoding
</span></span></span><span><span><span></span>        result.carry <span>&lt;&lt;=</span> <span>1</span>;
</span></span><span><span>        result.carry <span>|=</span> addends.m[i].carry;
</span></span><span><span>
</span></span><span><span>        <span>// Take the bottom two bits and inject them into the final output.
</span></span></span><span><span><span></span>        <span>// The value of the bottom two bits will not be changed by future
</span></span></span><span><span><span></span>        <span>// addends, because those addends must be at least 4 times as big
</span></span></span><span><span><span></span>        <span>// as the current addend. By directly injecting these two bits, the
</span></span></span><span><span><span></span>        <span>// hardware saves some space on the chip.
</span></span></span><span><span><span></span>        final_csa_output.output <span>|=</span> (result.output <span>&amp;</span> <span>3</span>) <span>&lt;&lt;</span> (<span>2</span> <span>*</span> i);
</span></span><span><span>        final_csa_output.carry  <span>|=</span> (result.carry  <span>&amp;</span> <span>3</span>) <span>&lt;&lt;</span> (<span>2</span> <span>*</span> i);
</span></span><span><span>        
</span></span><span><span>        <span>// The next CSA will only operate on the upper bits - as explained
</span></span></span><span><span><span></span>        <span>// in the previous comment.
</span></span></span><span><span><span></span>        result.output <span>&gt;&gt;=</span> <span>2</span>;
</span></span><span><span>        result.carry  <span>&gt;&gt;=</span> <span>2</span>;
</span></span><span><span>
</span></span><span><span>        csa_output <span>=</span> result;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    final_csa_output.output <span>|=</span> csa_output.output <span>&lt;&lt;</span> <span>8</span>;
</span></span><span><span>    final_csa_output.carry  <span>|=</span> csa_output.carry  <span>&lt;&lt;</span> <span>8</span>;
</span></span><span><span>
</span></span><span><span>    <span>return</span> final_csa_output;
</span></span><span><span>}
</span></span></code></pre></div><p>(Yes, this insanity is indeed done by the actual CPU.)</p><p>Didn’t we just finish the section titled “Putting it all Together”? Why then is the scroll bar still halfway down the page?</p><p>Because I lied to you all. There’s a small, but very meaningful difference between the algorithm I described and
the ARM7TDMI’s algorithm. Let’s consider the following multiplication:</p><p>$$
\color{#3a7dc9}0x000000FF\color{#4A4358} \cdot \color{#DC6A76}0x00000001 \color{#4A4358}
$$</p><p>How many cycles should this take? 1, right? Because the upper 24 bits of the <span><strong>multiplier</strong></span> are zeros, then the
second, third, and fourth cycles of addends will all be zeros… right?
Right?
Well, that’s how long it takes the ARM7TDMI to do it. So what’s the issue? Let’s take a closer look. The first cycle of the algorithm should have the following four chunks:</p><p>$$
\begin{aligned}
&amp;\text{Chunk #1: }\color{#3a7dc9}\text{0b110 (obtained from m[1..-1])}\cr
&amp;\text{Chunk #2: }\color{#3a7dc9}\text{0b111 (obtained from m[3..1])}\cr
&amp;\text{Chunk #3: }\color{#3a7dc9}\text{0b111 (obtained from m[5..3])}\cr
&amp;\text{Chunk #4: }\color{#3a7dc9}\text{0b111 (obtained from m[7..5])}\cr
\end{aligned}
$$</p><p>Turns out, in our current version of the algorithm, the second cycle does have a single non-zero addend:</p><p>$$
\begin{aligned}
&amp;\text{Chunk #1: }\color{#3a7dc9}\text{0b001 (obtained from m[9..7])}\cr
&amp;\text{Chunk #2: }\color{#3a7dc9}\text{0b000 (obtained from m[11..9])}\cr
&amp;\text{Chunk #3: }\color{#3a7dc9}\text{0b000 (obtained from m[13..11])}\cr
&amp;\text{Chunk #4: }\color{#3a7dc9}\text{0b000 (obtained from m[15..13])}\cr
\end{aligned}
$$</p><p>Because the LSB of Chunk #1 of Cycle #2 uses the MSB of Chunk #4 of Cycle #1, our algorithm would be forced to
take 2 cycles of CSAs. And yet, on the ARM7TDMI, this multiplication would terminate early, after only 1 cycle of CSAs. And there doesn’t seem to be a good way around this. And so I sat there thinking of
workarounds.</p><p><strong>Proposed solution #1:</strong> What if the ARM7TDMI actually processes 5 chunks per cycle?</p><p><strong>Rebuttal:</strong> If that were the case, then the algorithm would be able to process 9 bits on the first cycle,
which it cannot do.</p><p><strong>Proposed solution #2:</strong> Ok but what if the ARM7TDMI has some way of processing chunk #1 of cycle
<code>n</code> on cycle <code>n - 1</code>, but only if cycle <code>n - 1</code> is the last cycle of the algorithm?</p><p><strong>Rebuttal:</strong> Sure, maybe this is possible, but it feels like any solution that would allow the algorithm to do this would also
be capable of allowing the CPU to do 5 chunks per cycle.</p><p><strong>Proposed solution #3:</strong> Fine, what if the CPU actually leverages the power of Cthulu and evil warlock
magic to pull this off?</p><p><strong>Rebuttal:</strong> Yeah, that’s assigning too much credit to this god forsaken bundle of wires that somehow
obtained the title of “CPU” (actually, this solution ends up being closest to the right answer)</p><p>I was kind of out of ideas. I was pretty much ready to give up - my current algorithm was nowhere near
explaining the behavior of the CPU carry flag. And so I took a break, only looking at this problem every
once in a while.</p><p>Congrats for getting this far, now comes the tricky stuff. I require anyone who wants to continue reading to
put on <a href="https://www.google.com/url?sa=t&amp;source=web&amp;rct=j&amp;opi=89978449&amp;url=https://www.youtube.com/watch?v=ntgaStqpmjQ&amp;ved=2ahUKEwj03pfgvs2IAxWjJTQIHTp_EToQtwJ6BAgIEAI&amp;usg=AOvVaw1qRD2jAXNcY-9YA6Uhb9Ig" target="_blank">this music</a> in the background, as it most accurately models the trek into insanity we are about to endure.</p><p>So fast forward about a year, I’m out for a walk and I decide to give this problem a thought again. And so I considered something that, at the outset, sounds really, really stupid.</p><p>“What if we left shifted the <span><strong>multiplier</strong></span> by 1 at the beginning of the algorithm?”</p><p>I mean, it’s kind of dumb, right? The entire issue is that the <span><strong>multiplier</strong></span> is <em>too big</em>. Left shifting it would only exacerbate this issue. Congrats, we went from being able to process 7 bits on the first cycle to 6.</p><p>But pay attention to the <strong>first addend</strong> that would be produced. The corresponding <strong>chunk</strong> would either be <code>000</code> or <code>100</code>. Two options, both of which are really easy to compute. This is a behavior that would only exist on the first cycle of the algorithm. Coincidentally, if you refer to <a href="https://bmchtech.github.io/post/multiply/#diagram">the diagram</a> up above, you’ll notice that, in the first cycle of the algorithm, we have an extra input in the CSA array that we initialized to zero. What if, instead, we initialize it to the addend produced by this mythical <strong>chunk</strong>? Allowing us to process one additional bit on the first cycle only? <sup>[<a href="https://bmchtech.github.io/post/multiply/#cite5">5, p. 14</a>]</sup></p><p>It’d solve the issue. It’d get us the extra bit we needed, and make us match the ARM7TDMI’s cycle counts completely.</p><p>But that’s not all. Remember the carry flag from earlier? With this simple change, we go from matching hardware about 50% of the time (no better than randomly guessing) to matching hardware <em><strong>85%</strong></em> of the time. This sudden increase was something no other theory was able to do, and made me really confident that I was on to something. However, this percentage only happens if we set the carry flag to bit <code>30</code> of the partial carry result, which seems super arbitrary. It turns out that bit of the partial carry result had a special meaning I did not realize at the time, and I would only find out that meaning much, much later.</p><p>(Obviously, shifting the <span><strong>multiplier</strong></span> left by 1 means the result is now twice what it should be. This is handled later.)</p><p>We have a few remaining issues with our implementation of <code>perform_csa_array</code>, let’s discuss them one at a time.</p><h2 id="handling-64-bit-accumulates">Handling 64-bit Accumulates<a href="#handling-64-bit-accumulates" arialabel="Anchor">⌗</a></h2><p>First of all, we don’t know how to handle 64-bit accumulates yet. Thankfully, it was around this time where I found two patents <sup>[<a href="https://bmchtech.github.io/post/multiply/#cite5">5</a>], [<a href="https://bmchtech.github.io/post/multiply/#cite6">6</a>] </sup>that ended up being incredibly illuminating.</p><p>We know how to handle 32-bit accumulates - just <a href="https://bmchtech.github.io/post/multiply/#trick">initialize the partial sum with the value of the accumulator</a>. We can use a similar trick for 64-bit ones. First, we can initialize the partial sum with the bottom 33 bits of the 64 bit accumulate. Why 33? I thought the partial sum was 32 bits wide? Well, if we make the width of the partial sum 33 bits, we’d also be able to handle unsigned and signed multiplication by zero / sign extending appropriately. This way, our algorithm itself only needs to be able to perform signed multiplication, and our choice of zero-extension or sign-extension at initialization will handle the rest. More on this in the next section.</p><p>We take the remaining 31 bits of the acc and drip-feed them, 2 bits per CSA, like so:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>// Contains the current high 31 bits of the acc.
</span></span></span><span><span><span>// This is shifted by 2 after each CSA.
</span></span></span><span><span><span></span>u64 acc_shift_register <span>=</span> <span>0</span>;
</span></span><span><span>
</span></span><span><span><span>struct</span> CSAOutput <span>perform_csa_array</span>(u64 partial_sum, u64 partial_carry,
</span></span><span><span>                                   <span>struct</span> RecodedMultiplicands addends) {
</span></span><span><span>    <span>struct</span> CSAOutput csa_output <span>=</span> { partial_sum, partial_carry };
</span></span><span><span>    <span>struct</span> CSAOutput final_csa_output <span>=</span> { <span>0</span>, <span>0</span> };
</span></span><span><span>
</span></span><span><span>    <span>for</span> (<span>int</span> i <span>=</span> <span>0</span>; i <span>&lt;</span> <span>4</span>; i<span>++</span>) {
</span></span><span><span>        <span>// ... omitted
</span></span></span><span><span><span></span>
</span></span><span><span>        <span>// result.output is guaranteed to have bits 31/32 = 0,
</span></span></span><span><span><span></span>        <span>// so we can safely put whatever we want in them.
</span></span></span><span><span><span></span>        result.output <span>|=</span> (acc_shift_register <span>&amp;</span> <span>3</span>) <span>&lt;&lt;</span> <span>31</span>;      
</span></span><span><span>        acc_shift_register <span>&gt;&gt;=</span> <span>2</span>;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    final_csa_output.output <span>|=</span> csa_output.output <span>&lt;&lt;</span> <span>8</span>;
</span></span><span><span>    final_csa_output.carry  <span>|=</span> csa_output.carry  <span>&lt;&lt;</span> <span>8</span>;
</span></span><span><span>
</span></span><span><span>    <span>return</span> final_csa_output;
</span></span><span><span>}
</span></span></code></pre></div><p>You can think of this trick conceptually as us initializing all 64-bits of <code>csa_output.output</code> to the acc, instead of just the bottom 32-bits. <sup>[<a href="https://bmchtech.github.io/post/multiply/#cite5">5 p. 14</a>]</sup></p><h2 id="handling-signed-multiplication">Handling Signed Multiplication<a href="#handling-signed-multiplication" arialabel="Anchor">⌗</a></h2><p>Turns out this algorithm doesn’t support signed multiplication yet either. To implement this, we need to take a closer look at the CSA.</p><p>The CSA in its current form takes in 3 33-bit inputs, and outputs 2 33-bit outputs. One of these inputs, however, is actually supposed to be <em>34</em> bits (ha, lied to you all again). Specifically, <code>addends.m[i].recoded_output</code>. The recoded output is derived from a 32-bit <span><strong>multiplicand</strong></span>, which, when <a href="https://bmchtech.github.io/post/multiply/#finaleq">booth recoded</a>, can be multiplied by at most <code>2</code>, giving it a size of 33 bits. However, because we can support both signed and unsigned multiplies, this value needs to be 34 bits - the extra bit, as mentioned earlier, allows us to choose to either zero-extend or sign-extend the number to handle both signed and unsigned multiplication elegantly.</p><p>Let’s take a look at the other two of the CSA’s addends as well. <code>csa_output.carry</code>, a 33 bit number, also needs to be properly sign extended. However, <code>csa_output.output</code> does <em>not</em> need to be sign extended, since <code>csa_output.output</code> is technically already a 65 bit number that was fully initialized with the acc.</p><p>Let’s summarize the bit widths so far:</p><ul><li><code>csa_output.output</code>: 65</li><li><code>csa_output.carry</code>: 33</li><li><code>addends.m[i].recoded_output</code>: 34</li></ul><p>In order to implement signed multiplication, we need to sign-extend all 3 of these numbers to the full 65 bits. How can we do so? Well, <code>csa_output.output</code> is already 65 bits, so that one is done for us. What about the other two? For now, I will use the following shortened forms for readability:</p><ul><li><code>csa_output.output</code> will be referred to as <code>S</code></li><li><code>csa_output.carry</code> will be referred to as <code>C</code></li><li><code>addends.m[i].recoded_output</code> will be referred to as <code>X</code></li></ul><p>Here’s a helpful visualization of these desired 65-bit numbers, after they’ve been sign extended:</p><table><thead><tr><th>addend</th><th>bits 65-35</th><th>bit 34</th><th>bit 33</th><th>bit 32</th><th>bits 31-0</th></tr></thead><tbody><tr><td><code>csa_output.output</code></td><td>S[65..35]</td><td>S[34]</td><td>S[33]</td><td>S[32]</td><td>S[31..0]</td></tr><tr><td><code>csa_output.carry</code></td><td>C[32], …, C[32]</td><td>C[32]</td><td>C[32]</td><td>C[32]</td><td>C[31..0]</td></tr><tr><td><code>addends.m[i].recoded_output</code></td><td>X[33], …, X[33]</td><td>X[33]</td><td>X[33]</td><td>X[32]</td><td>X[31..0]</td></tr></tbody></table><p>We can do a magic trick here. We can replace the <code>csa_output.carry</code> row with a row of ones, and <code>!C[32]</code>. Convince yourself that this is mathematically okay:</p><table><thead><tr><th>addend</th><th>bits 65-35</th><th>bit 34</th><th>bit 33</th><th>bit 32</th><th>bits 31-0</th></tr></thead><tbody><tr><td><code>csa_output.output</code></td><td>S[65..35]</td><td>S[34]</td><td>S[33]</td><td>S[32]</td><td>S[31..0]</td></tr><tr><td><code>csa_output.carry</code></td><td>0, …, 0</td><td>0</td><td>!C[32]</td><td>C[32]</td><td>C[31..0]</td></tr><tr><td><code>magic trick</code></td><td>1, …, 1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td><code>addends.m[i].recoded_output</code></td><td>X[33], …, X[33]</td><td>X[33]</td><td>X[33]</td><td>X[32]</td><td>X[31..0]</td></tr></tbody></table><p>Let’s do it again, this time to <code>X</code>:</p><table><thead><tr><th>addend</th><th>bits 65-35</th><th>bit 34</th><th>bit 33</th><th>bit 32</th><th>bits 31-0</th></tr></thead><tbody><tr><td><code>csa_output.output</code></td><td>S[65..35]</td><td>S[34]</td><td>S[33]</td><td>S[32]</td><td>S[31..0]</td></tr><tr><td><code>csa_output.carry</code></td><td>0, …, 0</td><td>0</td><td>!C[32]</td><td>C[32]</td><td>C[31..0]</td></tr><tr><td><code>magic trick</code></td><td>1, …, 1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td><code>addends.m[i].recoded_output</code></td><td>0, …, 0</td><td>0</td><td>!X[33]</td><td>X[32]</td><td>X[31..0]</td></tr><tr><td><code>another magic trick</code></td><td>1, …, 1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr></tbody></table><p>Now we add the magic tricks together:</p><table><thead><tr><th>addend</th><th>bits 65-35</th><th>bit 34</th><th>bit 33</th><th>bit 32</th><th>bits 31-0</th></tr></thead><tbody><tr><td><code>csa_output.output</code></td><td>S[65..35]</td><td>S[34]</td><td>S[33]</td><td>S[32]</td><td>S[31..0]</td></tr><tr><td><code>csa_output.carry</code></td><td>0, …, 0</td><td>0</td><td>!C[32]</td><td>C[32]</td><td>C[31..0]</td></tr><tr><td><code>addends.m[i].recoded_output</code></td><td>0, …, 0</td><td>0</td><td>!X[33]</td><td>X[32]</td><td>X[31..0]</td></tr><tr><td><code>combined magic tricks</code></td><td>1, …, 1</td><td>1</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>And we’ve done it - we removed all the repeated instances of <code>C[32]</code> and <code>X[33]</code>, using some mathematical black magic. <sup>[<a href="https://bmchtech.github.io/post/multiply/#cite5">5 pp. 14-17</a>]</sup> This means that all we need to do to handle sign extension is the following two operations:</p><ul><li><code>result.output |= (S[33] + !C[32] + !X[32]) &lt;&lt; 31;</code></li><li><code>result.carry |= (!S[34]) &lt;&lt; 32;</code></li></ul><p>The resulting code:</p><div><pre tabindex="0"><code data-lang="C"><span><span><span>// Contains the current high 31 bits of the acc. 
</span></span></span><span><span><span>// This is shifted by 2 after each CSA.
</span></span></span><span><span><span></span>u64 acc_shift_register <span>=</span> <span>0</span>;
</span></span><span><span>
</span></span><span><span><span>struct</span> CSAOutput <span>perform_csa_array</span>(u64 partial_sum, u64 partial_carry, 
</span></span><span><span>                                   <span>struct</span> RecodedMultiplicands addends[<span>4</span>]) {
</span></span><span><span>    <span>struct</span> CSAOutput csa_output <span>=</span> { partial_sum, partial_carry };
</span></span><span><span>    <span>struct</span> CSAOutput final_csa_output <span>=</span> { <span>0</span>, <span>0</span> };
</span></span><span><span>
</span></span><span><span>    <span>for</span> (<span>int</span> i <span>=</span> <span>0</span>; i <span>&lt;</span> <span>4</span>; i<span>++</span>) {
</span></span><span><span>        csa_output.output <span>&amp;=</span> <span>0x1FFFFFFFFULL</span>;
</span></span><span><span>        csa_output.carry  <span>&amp;=</span> <span>0x1FFFFFFFFULL</span>;
</span></span><span><span>    
</span></span><span><span>        <span>struct</span> CSAOutput result <span>=</span> <span>perform_csa</span>(csa_output.output, 
</span></span><span><span>            addends.m[i].recoded_output <span>&amp;</span> <span>0x1FFFFFFFFULL</span>, csa_output.carry);
</span></span><span><span>
</span></span><span><span>        <span>// Inject the carry caused by booth recoding
</span></span></span><span><span><span></span>        result.carry <span>&lt;&lt;=</span> <span>1</span>;
</span></span><span><span>        result.carry <span>|=</span> addends.m[i].carry;
</span></span><span><span>
</span></span><span><span>        <span>// Take the bottom two bits and inject them into the final output.
</span></span></span><span><span><span></span>        <span>// The value of the bottom two bits will not be changed by future
</span></span></span><span><span><span></span>        <span>// addends, because those addends must be at least 4 times as big
</span></span></span><span><span><span></span>        <span>// as the current addend. By directly injecting these two bits, the
</span></span></span><span><span><span></span>        <span>// hardware saves some space on the chip.
</span></span></span><span><span><span></span>        final_csa_output.output <span>|=</span> (result.output <span>&amp;</span> <span>3</span>) <span>&lt;&lt;</span> (<span>2</span> <span>*</span> i);
</span></span><span><span>        final_csa_output.carry  <span>|=</span> (result.carry  <span>&amp;</span> <span>3</span>) <span>&lt;&lt;</span> (<span>2</span> <span>*</span> i);
</span></span><span><span>        
</span></span><span><span>        <span>// The next CSA will only operate on the upper bits - as explained
</span></span></span><span><span><span></span>        <span>// in the previous comment.
</span></span></span><span><span><span></span>        result.output <span>&gt;&gt;=</span> <span>2</span>;
</span></span><span><span>        result.carry  <span>&gt;&gt;=</span> <span>2</span>;
</span></span><span><span>
</span></span><span><span>        <span>// Perform the magic described in the tables for the sign extension
</span></span></span><span><span><span></span>        <span>// of csa_output.carry and the recoded addend. Remember that bits 0-1
</span></span></span><span><span><span></span>        <span>// of the acc_shift_register is bits 33-34 of S.
</span></span></span><span><span><span></span>        u64 magic <span>=</span> <span>bit</span>(acc_shift_register, <span>0</span>) <span>+</span> 
</span></span><span><span>            <span>!</span><span>bit</span>(csa_output.carry, <span>32</span>) <span>+</span> <span>!</span><span>bit</span>(addends.m[i].recoded_output, <span>33</span>);
</span></span><span><span>        result.output <span>|=</span> magic <span>&lt;&lt;</span> <span>31</span>;
</span></span><span><span>        result.carry <span>|=</span> (u64) <span>!</span><span>bit</span>(acc_shift_register, <span>1</span>) <span>&lt;&lt;</span> <span>32</span>;        
</span></span><span><span>        acc_shift_register <span>&gt;&gt;=</span> <span>2</span>;
</span></span><span><span>
</span></span><span><span>        csa_output <span>=</span> result;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    final_csa_output.output <span>|=</span> csa_output.output <span>&lt;&lt;</span> <span>8</span>;
</span></span><span><span>    final_csa_output.carry  <span>|=</span> csa_output.carry  <span>&lt;&lt;</span> <span>8</span>;
</span></span><span><span>
</span></span><span><span>    <span>return</span> final_csa_output;
</span></span><span><span>}
</span></span></code></pre></div><p>We already touched on early termination briefly, but turns out it gets a bit more complicated. The patents don’t exactly explain how early termination works in much detail, besides some cryptic references to shift types / shift values. But, I gave it my best guess. We know that we have the following condition for early termination:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>bool</span> <span>should_terminate</span>(u64 multiplier, <span>enum</span> MultiplicationFlavor flavor) {
</span></span><span><span>    <span>if</span> (<span>is_signed</span>(flavor)) {
</span></span><span><span>        <span>return</span> multiplier <span>==</span> <span>0x1FFFFFFFF</span> <span>||</span> multiplier <span>==</span> <span>0</span>;
</span></span><span><span>    } <span>else</span> {
</span></span><span><span>        <span>return</span> multiplier <span>==</span> <span>0</span>;
</span></span><span><span>    }
</span></span><span><span>}
</span></span></code></pre></div><p>Note that <span><strong>multiplier</strong></span> is a signed 33-bit number. After every cycle of booth’s algorithm, the bottom eight bits are fed into a result register, since the <em>next</em> cycle of booth’s algorithm cannot change the value of those bottom eight bits. The remaining upper bits become the next input into the next cycle of booth’s algorithm. Something like this:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>// I&#39;m using this over a __uint128_t since the latter isn&#39;t available
</span></span></span><span><span><span>// on a GBA, and I needed this code to compile on a GBA so I can fuzz the 
</span></span></span><span><span><span>// outputs.
</span></span></span><span><span><span></span><span>struct</span> u128 {
</span></span><span><span>    u64 lo;
</span></span><span><span>    u64 hi;
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>// Latches that contain the final results of the algorithm.
</span></span></span><span><span><span></span>u128 partial_sum;
</span></span><span><span>u128 partial_carry;
</span></span><span><span>
</span></span><span><span><span>do</span> {
</span></span><span><span>    csa_output <span>=</span> <span>perform_one_cycle_of_booths_mutliplication</span>(
</span></span><span><span>        csa_output, multiplicand, multiplier);
</span></span><span><span>
</span></span><span><span>    <span>// The bottom 8 bits of this cycle cannot be changed by future
</span></span></span><span><span><span></span>    <span>// addends, since those addends will be at least 256 times as
</span></span></span><span><span><span></span>    <span>// big as this cycle&#39;s addends. So, put them into the result
</span></span></span><span><span><span></span>    <span>// latches now.
</span></span></span><span><span><span></span>    partial_sum.lo   <span>|=</span> csa_output.output <span>&amp;</span> <span>0xFF</span>;
</span></span><span><span>    partial_carry.lo <span>|=</span> csa_output.carry  <span>&amp;</span> <span>0xFF</span>;
</span></span><span><span>
</span></span><span><span>    <span>// Get csa_output ready to be fed back into the CSAs on the next
</span></span></span><span><span><span></span>    <span>// cycle
</span></span></span><span><span><span></span>    csa_output.output <span>&gt;&gt;=</span> <span>8</span>;
</span></span><span><span>    csa_output.carry  <span>&gt;&gt;=</span> <span>8</span>;
</span></span><span><span>
</span></span><span><span>    <span>// ROR == ROtate Right
</span></span></span><span><span><span></span>    partial_sum <span>=</span> <span>u128_ror</span>(partial_sum, <span>8</span>);
</span></span><span><span>    partial_carry <span>=</span> <span>u128_ror</span>(partial_carry, <span>8</span>);
</span></span><span><span>
</span></span><span><span>    <span>// ASR == Arithmetic Shift Right for 33-bit numbers
</span></span></span><span><span><span></span>    multiplier <span>=</span> <span>asr_33</span>(multiplier, <span>8</span>);
</span></span><span><span>} <span>while</span> (<span>!</span><span>should_terminate</span>(multiplier, flavor));
</span></span><span><span>
</span></span><span><span>partial_sum.lo   <span>|=</span> csa_output.output;
</span></span><span><span>partial_carry.lo <span>|=</span> csa_output.carry;
</span></span></code></pre></div><p>Since <code>partial_sum</code> and <code>partial_carry</code> are shift registers that get rotated with each iteration of booths algorithm, we need to rotate them again after the algorithm ends in order to correct them to their proper values. Thankfully, the ARM7TDMI has something called a barrel shifter. The barrel shifter is a nifty piece of hardware that allows the CPU to perform an arbitrary shift/rotate before an ALU operation, all in one cycle. Since we plan to add <code>partial_sum</code> and <code>partial_carry</code> in the ALU, we may as well use the barrel shifter to rotate one of those two operands, with no additional cost. The other operand ends up requiring special hardware to rotate, since the barrel shifter only operates on one value per cycle.</p><p>For long (64-bit) multiplies, two right rotations (known on the CPU as RORs) occur, since the ALU can only add 32-bits at a time and so the ALU / barrel shifter must be used twice.</p><p>Spoiler alert, the value of the carry flag after a multiply instruction comes from the carryout of this barrel shifter.</p><p>So, what rotation values does the ARM7TDMI use? According to one of the patents, for an unsigned multiply, all (1 for 32-bit multiplies or 2 for 64-bit ones) uses of the barrel shifter do this: <sup>[<a href="https://bmchtech.github.io/post/multiply/#cite6">6, p. 9</a>]</sup></p><table><thead><tr><th># Iterations of Booths</th><th>Type</th><th>Rotation</th></tr></thead><tbody><tr><td>1</td><td>ROR</td><td>22</td></tr><tr><td>2</td><td>ROR</td><td>14</td></tr><tr><td>3</td><td>ROR</td><td>6</td></tr><tr><td>4</td><td>ROR</td><td>30</td></tr></tbody></table><p>Signed multiplies differ from unsigned multiplies in their <strong>second</strong> barrel shift. The second one for signed multiplies uses Arithmetic Shift Rights (ASRs) and looks like this: <sup>[<a href="https://bmchtech.github.io/post/multiply/#cite6">6, p. 9</a>]</sup></p><table><thead><tr><th># Iterations of Booths</th><th>Type</th><th>Rotation</th></tr></thead><tbody><tr><td>1</td><td>ASR</td><td>22</td></tr><tr><td>2</td><td>ASR</td><td>14</td></tr><tr><td>3</td><td>ASR</td><td>6</td></tr><tr><td>4</td><td>ROR</td><td>30</td></tr></tbody></table><p>I’m not going to lie, I couldn’t make sense of these rotation values. At all. Maybe they were wrong, since they patents already had a couple major errors at this point. No idea. Turns out it doesn’t <em>really</em> matter for calculating the carry flag of a multiply instruction. Why? Well, observe what happens when the ARM7TDMI does a <code>ROR</code> or <code>ASR</code>:</p><p>Code from fleroviux’s wonderful NanoBoyAdvance. <sup><a href="https://bmchtech.github.io/post/multiply/#cite7">[7]</a></sup></p><div><pre tabindex="0"><code data-lang="C++"><span><span><span>void</span> <span>ROR</span>(u32<span>&amp;</span> operand, u8 amount, <span>int</span><span>&amp;</span> carry, <span>bool</span> immediate) {
</span></span><span><span>  <span>// Note that in booth&#39;s algorithm, the immediate argument will be true, and
</span></span></span><span><span><span></span>  <span>// amount will be non-zero
</span></span></span><span><span><span></span>
</span></span><span><span>  <span>if</span> (amount <span>!=</span> <span>0</span> <span>||</span> <span>!</span>immediate) {
</span></span><span><span>    <span>if</span> (amount <span>==</span> <span>0</span>) <span>return</span>;
</span></span><span><span>    <span>// We end up doing down this codepath
</span></span></span><span><span><span></span>
</span></span><span><span>    amount <span>%=</span> <span>32</span>;
</span></span><span><span>    operand <span>=</span> (operand <span>&gt;&gt;</span> amount) <span>|</span> (operand <span>&lt;&lt;</span> (<span>32</span> <span>-</span> amount));
</span></span><span><span>    carry <span>=</span> operand <span>&gt;&gt;</span> <span>31</span>;
</span></span><span><span>  } <span>else</span> {
</span></span><span><span>    <span>auto</span> lsb <span>=</span> operand <span>&amp;</span> <span>1</span>;
</span></span><span><span>    operand <span>=</span> (operand <span>&gt;&gt;</span> <span>1</span>) <span>|</span> (carry <span>&lt;&lt;</span> <span>31</span>);
</span></span><span><span>    carry <span>=</span> lsb;
</span></span><span><span>  }
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>void</span> <span>ASR</span>(u32<span>&amp;</span> operand, u8 amount, <span>int</span><span>&amp;</span> carry, <span>bool</span> immediate) {
</span></span><span><span>  <span>// Note that in booth&#39;s algorithm, the immediate argument will be true, and
</span></span></span><span><span><span></span>  <span>// amount will be non-zero and less than 32.
</span></span></span><span><span><span></span>
</span></span><span><span>  <span>if</span> (amount <span>==</span> <span>0</span>) {
</span></span><span><span>    <span>// ASR #0 equals to ASR #32
</span></span></span><span><span><span></span>    <span>if</span> (immediate) {
</span></span><span><span>      amount <span>=</span> <span>32</span>;
</span></span><span><span>    } <span>else</span> {
</span></span><span><span>      <span>return</span>;
</span></span><span><span>    }
</span></span><span><span>  }
</span></span><span><span>
</span></span><span><span>  <span>int</span> msb <span>=</span> operand <span>&gt;&gt;</span> <span>31</span>;
</span></span><span><span>
</span></span><span><span>  <span>if</span> (amount <span>&gt;=</span> <span>32</span>) {
</span></span><span><span>    carry <span>=</span> msb;
</span></span><span><span>    operand <span>=</span> <span>0xFFFFFFFF</span> <span>*</span> msb;
</span></span><span><span>    <span>return</span>;
</span></span><span><span>  }
</span></span><span><span>
</span></span><span><span>  <span>// We end up doing down this codepath
</span></span></span><span><span><span></span>  carry <span>=</span> (operand <span>&gt;&gt;</span> (amount <span>-</span> <span>1</span>)) <span>&amp;</span> <span>1</span>;
</span></span><span><span>  operand <span>=</span> (operand <span>&gt;&gt;</span> amount) <span>|</span> ((<span>0xFFFFFFFF</span> <span>*</span> msb) <span>&lt;&lt;</span> (<span>32</span> <span>-</span> amount));
</span></span><span><span>}
</span></span></code></pre></div><p>Note that in both ROR and ASR the carry will always be set to the last bit of the <code>operand</code> to be shifted out. i.e., if I rotate a value by <code>n</code>, then the carry will always be bit <code>n - 1</code> of the <code>operand</code> before rotation, since that was the last bit to be rotated out. Same goes for ASR.</p><p>So, <em>it doesn’t matter</em> if I don’t use the same rotation values as the patents. Since, no matter the rotation value, as long as the output from <em>my</em> barrel shifter is the same as the output from the <em>ARM7TDMI’s</em> barrel shifter, then the last bit to be shifted out must be the same, and therefore the carry flag must <em>also</em> have been the same.</p><p>So, here’s my implementation. I tried to somewhat mimic the table from above at the cost of code readability, but I admittedly didn’t do a very good job. But hey it works, so fuck it.</p><div><pre tabindex="0"><code data-lang="C"><span><span><span>// I&#39;m using this over a __uint128_t since the latter isn&#39;t available
</span></span></span><span><span><span>// on a GBA, and I needed this code to compile on a GBA so I can fuzz the 
</span></span></span><span><span><span>// outputs.
</span></span></span><span><span><span></span><span>struct</span> u128 {
</span></span><span><span>    u64 lo;
</span></span><span><span>    u64 hi;
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>// The final output of multiplication
</span></span></span><span><span><span></span><span>struct</span> MultiplicationOutput {
</span></span><span><span>    u64 output;
</span></span><span><span>    <span>bool</span> carry;
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>// We have ror&#39;d partial_sum and partial_carry by 8 * num_iterations + 1.
</span></span></span><span><span><span>// We now need to ror backwards (rol). I tried my best to mimic the tables, but
</span></span></span><span><span><span>// I&#39;m off by one for whatever reason.
</span></span></span><span><span><span></span><span>int</span> correction_ror;
</span></span><span><span><span>if</span> (num_iterations <span>==</span> <span>1</span>) correction_ror <span>=</span> <span>23</span>;
</span></span><span><span><span>if</span> (num_iterations <span>==</span> <span>2</span>) correction_ror <span>=</span> <span>15</span>;
</span></span><span><span><span>if</span> (num_iterations <span>==</span> <span>3</span>) correction_ror <span>=</span> <span>7</span>;
</span></span><span><span><span>if</span> (num_iterations <span>==</span> <span>4</span>) correction_ror <span>=</span> <span>31</span>;
</span></span><span><span>
</span></span><span><span>partial_sum   <span>=</span> <span>u128_ror</span>(partial_sum, correction_ror);
</span></span><span><span>partial_carry <span>=</span> <span>u128_ror</span>(partial_carry, correction_ror);
</span></span><span><span>
</span></span><span><span><span>int</span> alu_carry_in <span>=</span> <span>bit</span>(multiplier, <span>0</span>);
</span></span><span><span>
</span></span><span><span><span>if</span> (<span>is_long</span>(flavor)) {
</span></span><span><span>    <span>// Did we not early-terminate?
</span></span></span><span><span><span></span>    <span>if</span> (num_iterations <span>==</span> <span>4</span>) {
</span></span><span><span>        <span>struct</span> AdderOutput adder_output_lo <span>=</span> 
</span></span><span><span>            <span>adder</span>(partial_sum.hi, partial_carry.hi, alu_carry_in);
</span></span><span><span>        <span>struct</span> AdderOutput adder_output_hi <span>=</span> 
</span></span><span><span>            <span>adder</span>(partial_sum.hi <span>&gt;&gt;</span> <span>32</span>, partial_carry.hi <span>&gt;&gt;</span> <span>32</span>, 
</span></span><span><span>                  adder_output_lo.carry);
</span></span><span><span>
</span></span><span><span>        <span>return</span> (<span>struct</span> MultiplicationOutput) {
</span></span><span><span>            ((u64) adder_output_hi.output <span>&lt;&lt;</span> <span>32</span>) <span>|</span> adder_output_lo.output,
</span></span><span><span>            (partial_carry.hi <span>&gt;&gt;</span> <span>63</span>) <span>&amp;</span> <span>1</span>
</span></span><span><span>        };
</span></span><span><span>    } <span>else</span> {
</span></span><span><span>        <span>struct</span> AdderOutput adder_output_lo <span>=</span> 
</span></span><span><span>            <span>adder</span>(partial_sum.hi <span>&gt;&gt;</span> <span>32</span>, partial_carry.hi <span>&gt;&gt;</span> <span>32</span>, alu_carry_in);
</span></span><span><span>
</span></span><span><span>        <span>int</span> shift_amount <span>=</span> <span>1</span> <span>+</span> <span>8</span> <span>*</span> num_iterations;
</span></span><span><span>
</span></span><span><span>        <span>// Why this is needed is unknown, but the multiplication doesn&#39;t work
</span></span></span><span><span><span></span>        <span>// without it
</span></span></span><span><span><span></span>        shift_amount<span>++</span>;
</span></span><span><span>
</span></span><span><span>        <span>// Sign extend partial_carry.lo from shift_amount to 64-bits
</span></span></span><span><span><span></span>        partial_carry.lo <span>=</span> <span>sign_extend</span>(partial_carry.lo, shift_amount, <span>64</span>);
</span></span><span><span>        partial_sum.lo <span>|=</span> acc_shift_register <span>&lt;&lt;</span> (shift_amount);
</span></span><span><span>
</span></span><span><span>        <span>struct</span> AdderOutput adder_output_hi <span>=</span> 
</span></span><span><span>            <span>adder</span>(partial_sum.lo, partial_carry.lo, adder_output_lo.carry);
</span></span><span><span>        <span>return</span> (<span>struct</span> MultiplicationOutput) { 
</span></span><span><span>            ((u64) adder_output_hi.output <span>&lt;&lt;</span> <span>32</span>) <span>|</span> adder_output_lo.output,
</span></span><span><span>            (partial_carry.hi <span>&gt;&gt;</span> <span>63</span>) <span>&amp;</span> <span>1</span>
</span></span><span><span>        };
</span></span><span><span>    }
</span></span><span><span>} <span>else</span> {
</span></span><span><span>    <span>// Did we not early-terminate?
</span></span></span><span><span><span></span>    <span>if</span> (num_iterations <span>==</span> <span>4</span>) {
</span></span><span><span>        <span>struct</span> AdderOutput adder_output <span>=</span> 
</span></span><span><span>            <span>adder</span>(partial_sum.hi, partial_carry.hi, alu_carry_in);
</span></span><span><span>        <span>return</span> (<span>struct</span> MultiplicationOutput) { 
</span></span><span><span>            adder_output.output,
</span></span><span><span>            (partial_carry.hi <span>&gt;&gt;</span> <span>31</span>) <span>&amp;</span> <span>1</span>
</span></span><span><span>        };
</span></span><span><span>    } <span>else</span> {
</span></span><span><span>        <span>struct</span> AdderOutput adder_output <span>=</span> 
</span></span><span><span>            <span>adder</span>(partial_sum.hi <span>&gt;&gt;</span> <span>32</span>, partial_carry.hi <span>&gt;&gt;</span> <span>32</span>, alu_carry_in);
</span></span><span><span>        <span>return</span> (<span>struct</span> MultiplicationOutput) { 
</span></span><span><span>            adder_output.output,
</span></span><span><span>            (partial_carry.hi <span>&gt;&gt;</span> <span>63</span>) <span>&amp;</span> <span>1</span>
</span></span><span><span>        };
</span></span><span><span>    }
</span></span><span><span>}
</span></span></code></pre></div><p>Anyway, that’s basically it. What a meme. If you’re interested in the full code, take a look <a href="https://github.com/zaydlang/multiplication-algorithm/tree/master">here</a>.</p><p><a name="cite1"></a>[1] “Advanced RISC Machines ARM ARM 7TDMI Data Sheet,” 1995. Accessed: Oct. 21, 2024. [Online]. Available: <a href="https://www.dwedit.org/files/ARM7TDMI.pdf">https://www.dwedit.org/files/ARM7TDMI.pdf</a></p><p><a name="cite2"></a>[2] “ASIC Design for Signal Processing,” Geoffknagge.com, 2024. <a href="https://www.geoffknagge.com/fyp/booth.shtml">https://www.geoffknagge.com/fyp/booth.shtml</a></p><p><a name="cite3"></a>[3] Wikipedia Contributors, “Carry-save adder,” Wikipedia, Sep. 17, 2024. <a href="https://en.wikipedia.org/wiki/Carry-save_adder">https://en.wikipedia.org/wiki/Carry-save_adder</a></p><p><a name="cite4"></a>[4] Furber, Arm System-On-Chip Architecture, 2/E. Pearson Education India, 2001.</p><p><a name="cite5"></a>[5] D. J. Seal, G. Larri, and D. V. Jaggar, “Data Processing Using Multiply-accumulate Instructions,” Jul. 14, 1994</p><p><a name="cite6"></a>[6] G. Larri, “Data Processing Method And Apparatus Including Iterative Multiplier,” Mar. 11, 1994</p><p><a name="cite7"></a>[7] fleroviux. “NanoBoyAdvance.” GitHub. Available: <a href="https://github.com/nba-emu/NanoBoyAdvance">https://github.com/nba-emu/NanoBoyAdvance</a>.</p></div></div></div>
  </body>
</html>
