<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://platformers.dev/log/2022-03-02-latest-literally-kills-puppies/">Original</a>
    <h1>Just say no to :latest</h1>
    
    <div id="readability-page-1" class="page"><div>
        
        
        <div role="main">

<h3 id="just-say-no-to-latest">Just say no to <code>:latest</code></h3>
<p><em>2022-Mar-02</em> • by David Norton</p>
<p>Don&#39;t specify <code>latest</code> in your Dockerfile! Or anywhere else! Do you want to 
<a href="https://www.youtube.com/watch?v=Xv2VIEY9-A8&amp;ab_channel=SaturdayNightLive">live in a van down by the river</a>?</p>
<pre><code>FROM alpine:latest
</code></pre>
<p>It breaks one of the core requirements of continuous delivery: reproducible, idempotent builds. This can cause problems
at best when trying to build your project, and at worst in a production failure.</p>
<p>Perhaps worse than specifying <code>latest</code> in a Dockerfile, we <em>definitely</em> don&#39;t want to specify <code>latest</code> in a Kubernetes 
Pod manifest. At least if you use the <code>latest</code> in your 
Dockerfile to create a versioned image, you could roll back to your previous versioned image if something happened. </p>
<p>If your <em>deployment manifest</em> specifies a <code>latest</code> image, then it could update any time a new pod needed to roll out, and you would be 
at the mercy of the maintainers to not break compatibility. This could happen on a weekend or the middle of the night, 
when a node goes bad!</p>
<pre><code># BAD:
image: &#34;nginx:latest&#34;

# GOOD:
image: &#34;nginx:1.21.6&#34;
</code></pre>
<p>(This brings up an interesting side point, in that Docker Hub and most other registries allow mutable tags by default. 
So <code>nginx:1.21.6</code> might not be the same image today as it was yesterday. In reality, you probably need a mechanism to 
enforce tag immutability: e.g., your own registry mirror, or referring to images by SHA).</p>
<p><strong>Latest dependencies exist in most ecosystems</strong></p>
<p>You can have unversioned dependencies in your installation script:</p>
<pre><code># BAD:
pip install awscli

# GOOD:
pip install awscli==1.22.60
</code></pre>
<p>Or in your package.json:</p>
<pre><code># BAD if you don&#39;t have a lock file
&#34;dependencies&#34;: {
    &#34;baz&#34;: &#34;&gt;1.0.2&#34;
}
</code></pre>
<p>Or your Terraform provider:</p>
<pre><code># BAD if you don&#39;t have a lock file
terraform {
  required_providers {
    mycloud = {
      source  = &#34;hashicorp/aws&#34;
      version = &#34;&gt;= 1.0&#34;
    }
  }
}
</code></pre>
<p>Or your Terraform module:</p>
<pre><code># BAD:
module &#34;gitlabrunner&#34; {
  source = &#34;npalm/gitlab-runner/aws&#34;
}
# GOOD:
module &#34;gitlabrunner&#34; {
  source  = &#34;npalm/gitlab-runner/aws&#34;
  version = &#34;1.2.3&#34;
}
</code></pre>
<p>There are any other number of ways this can play out. Whenever you pull in external code or binaries, consider how that 
dependency is versioned and how your build process pulls it in.</p>
<p><strong>Lock files</strong></p>
<p>Thankfully, many frameworks provide a mechanism to allow easy updates, with source-controlled versions and hashsums, by
way of <em>lock files</em>. These lock files are intended to be generated with a specific command, and committed to source 
control. They are then used in CI to pull the exact the same dependencies at build time. For example,
<code>terraform init -upgrade</code> will pull in the latest dependencies allowed by the version constraints and update the 
lock file, and later <code>terraform init</code> will pull in those exact same versions.</p>
<p>I think this provides the best of both worlds -- the latest and greatest with more permissive provider version 
constraints, with the predictability of fixed dependency versions.</p>
<p>Take advantage of these wherever you can, but remember two things:</p>
<ol>
<li>Commit the lock files to source control!</li>
<li>If you need to take advantage of a new feature, bug fix, or security fix, update the provider version constraint,
      run <code>terraform init -upgrade</code>, and commit the updated lock file.</li>
<li>Do not update the lock files during CI (e.g. run <code>terraform init</code>, <em>not</em> <code>terraform init -upgrade</code>)</li>
</ol>
<p>Examples of lock files:</p>
<ul>
<li>Terraform: <a href="https://www.terraform.io/language/files/dependency-lock"><code>.terraform.lock.hcl</code></a></li>
<li>Python: <a href="https://pipenv.pypa.io/en/latest/"><code>Pipfile</code> using Pipenv</a></li>
<li>Node/Yarn: <a href="https://classic.yarnpkg.com/lang/en/docs/yarn-lock/"><code>yarn.lock</code></a></li>
<li>Go: <a href="https://go.dev/blog/using-go-modules">hashsummed and versioned by default with <code>go.sum</code> and <code>go.mod</code></a></li>
</ul>
<p><strong>Pulling dependencies at runtime</strong></p>
<p>As much as you can, avoid pulling dependencies at runtime. This may look like an EC2 user-data script that installs 
Docker, or an <code>npm install</code> running at startup on a virtual machine, or others. Bake your 
dependencies into your deployable artifact, and version your artifacts, so that you always have a deployable system
and can track down issues at the right time.</p>
<p>One way to prevent this is with network policies in your compute environment that prevent access to code distribution
mechanisms (or you could even lock down all outbound access except for allowed connections).</p>
<p><strong>Scanning for vulnerabilities</strong></p>
<p>GitHub and GitLab both have features that will scan your repositories and suggest updates based on security 
vulnerability databases. You can also take advantage of other commercial services such as Twistlock, or open source
solutions such as Grype. These can integrate into your build process, and/or be run on a schedule to catch new reports
as they occur.</p>
<p><strong>Updating dependencies</strong></p>
<p>You should update your dependencies, but it should be with a discrete commit to source control so that you can track
the changes, get a versioned artifact, and be able to catch any issues before they become problems in production.</p>
<p><strong>Conclusion</strong></p>
<p>This post was originally titled <code>:latest literally kills puppies</code>. My editor/wife thought that was a little extreme. 
I took her advice, but added this note indicating my personal feelings on the subject - you can draw your own 
conclusions.</p></div>
        
        
    </div><div>
          

<hr/>
<p>
    <small>© 2021-2022 Platformers LLC</small></p>


      </div></div>
  </body>
</html>
