<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.mozilla.org/performance/2022/02/08/rust-api-for-the-firefox-profiler/">Original</a>
    <h1>Rust API for the Firefox Profiler</h1>
    
    <div id="readability-page-1" class="page"><div>
      
  
<article id="post-331">
  

  <div>
    <p>Firefox Profiler is a tool for analyzing the performance of both websites and Firefox itself. You can visit profiler.firefox.com to learn more about and enable it.</p>
<p>Inside the Firefox codebase, we have different profiler APIs to instrument the source code. With these APIs, threads can be registered with the profiler, different parts of the code can be annotated, and even more information (payload) can be included to a specific event inside the codebase, like a render or reflow event.</p>
<p>Inside the mozilla-central codebase, we have various programming languages like C++, JavaScript, Java and Rust. Since the profiler is implemented in C++, we have the most advanced API for that in C++. <a href="https://firefox-source-docs.mozilla.org/tools/profiler/index.html">You can check its documentation out</a>. Also, we’ve already had APIs for <a href="https://firefox-source-docs.mozilla.org/tools/profiler/instrumenting-javascript.html">JavaScript</a>, and <a href="https://mozilla.github.io/geckoview/javadoc/mozilla-central/org/mozilla/geckoview/ProfilerController.html">Java</a> for some time. But we didn’t have any canonical API for the Rust codebases. We had some hacks around bigger Rust projects like Servo or Webrender to register threads and add annotations, but they weren’t shared across different projects. Therefore we had a lot of code duplications in the different parts of the Firefox codebase. Also, it was pretty tiring work if you wanted to instrument your own Rust code with the profiler API because you had to write things from scratch.</p>
<p>To solve this issue, we wanted to work on a new Rust API that every Rust project inside mozilla-central can use without the need of implementing everything from scratch and having to maintain that code. Instead, the Firefox Profiler team would own the API crate and maintain it, so other people wouldn’t need to worry about it and they would simply import the API crate to their projects to use it. And this work has been completed in the last quarter! In this blog post, I will be talking about this API and some of the implementation details. <a href="https://firefox-source-docs.mozilla.org/tools/profiler/instrumenting-rust.html">You can also see the documentation of this API here</a>. So let’s get into the details of this API and how to use it first.</p>
<h2>The new gecko-profiler crate to the rescue!</h2>
<p>For this work, we’ve created a new Rust crate called gecko-profiler inside the mozilla-central repository. This crate includes everything you need about the profiler, and you only need to import it to instrument your source code. It’s pretty simple to add a new crate to your source code. Go to your Cargo.toml file and add the new gecko-profiler dependency like this:</p>
<pre>[dependencies]
gecko-profiler = { path = &#34;../../tools/profiler/rust-api&#34; }
</pre>
<p>After this addition, you need to update the Cargo.lock file by running <code>cargo update -p gkrust-shared</code>. And this is it, now you can start using the functions inside this crate.</p>
<p>To summarize the functionalities inside this crate, you can:</p>
<ol>
<li>Register the threads with the profiler, so the profiler can record these threads and you can see them in the profiler analysis UI.</li>
<li>Add stack frame labels to annotate and add categories to a part of the stack.</li>
<li>Add markers to mark an instant time or a duration of time during the code execution. With markers, you can also add more information as a payload to make it appear in the profiler analysis UI.</li>
</ol>
<p>You can also check the profiler state to see if the profiler is running or not, but that’s something you usually do before adding a marker, so you don’t do unnecessary computations outside of a profiling session, but we’ll get into that later.</p>
<p>Let’s learn a bit more about how to use these functionalities with some examples.</p>
<h2>Registering threads</h2>
<p>Before profiling a thread, it must be registered first. Otherwise, the profiler can’t find and profile it. So if you are adding a new thread to your codebase, it’s a good idea to register it with the profiler too while you are working on it.</p>
<p>We have two functions for registering and unregistering a thread which are <code>gecko_profiler::register_thread</code> and <code>gecko_profiler::unregister_thread</code> respectively. While registering it, it also accepts a <code>&amp;str</code> as the thread name. Here’s an example with a thread:</p>
<pre>let thread_name = &#34;New Thread&#34;;
std::thread::Builder::new()
    .name(thread_name.into())
    .spawn(move || {
        gecko_profiler::register_thread(thread_name);
        // DO SOME WORK
        gecko_profiler::unregister_thread();
    })
    .unwrap();
</pre>
<p>As you can see here, when we are spawning a thread, we are calling the <code>register_thread</code> function with the thread name. And right before exiting a thread, we are calling the <code>unregister_thread</code> function.</p>
<p>It’s good to keep in mind that registering a thread doesn’t mean that you will see that thread immediately in the profile data. You still need to do something, which is adding the name of that thread to the “Threads” filter inside the about:profiling page. That input is a comma-separated list and you can simply add another thread after a comma. After doing this, you will be able to see the thread inside the captured profile data.</p>
<p>Now that we registered the new thread that we are going to profile, let’s see how we can annotate our source code, so you can see more details inside the profiler analysis view.</p>
<h2>Adding Stack Frame Labels</h2>
<p>Stack frame labels are useful for annotating some parts of the call stacks with a category. This category will be shown in the Firefox Profiler analysis view timeline and the bottom panels like “Call Tree” and “Flame Graph”.</p>
<p>For adding stack frame labels, we have <code>gecko_profiler_label!</code> macro. This macro will extend and mark the stack with the given category, starting from that call until the end of the scope. This essentially extends to an RAII object. Here are some examples:</p>
<pre>// Marking the stack as &#34;Layout&#34; category, no subcategory provided.
gecko_profiler_label!(Layout);
// Marking the stack as &#34;JavaScript&#34; category and &#34;Parsing&#34; subcategory.
gecko_profiler_label!(JavaScript, Parsing);
</pre>
<p>We also have a syntactical sugar called gecko_profiler_fn_label. This is a proc-macro that can be put on top of the functions. It will automatically wrap the whole function scope with that category. Its usage is like this:</p>
<pre>#[gecko_profiler_fn_label(DOM)]
fn foo(bar: u32) -&gt; u32 {
bar
}</pre>
<p>There are various categories and subcategories that can be annotated with this functionality. To see the whole list of the categories, please see the <a href="https://searchfox.org/mozilla-central/source/mozglue/baseprofiler/build/profiling_categories.yaml">profiling_categories.yaml</a> file. I also will be talking about this file when digging into implementation details. Now let’s check our last but pretty big functionality, profiler markers.</p>
<h2>Adding markers</h2>
<p>Markers are packets of arbitrary data that are added to a profile by the Firefox code, usually to indicate something important happening at a point in time, or during an interval of time. We can add different types of markers to our code. There are a few functions you can use per marker type like <code>gecko_profiler::add_untyped_marker</code>, <code>gecko_profiler::add_text_marker</code> and <code>gecko_profiler::add_marker</code>. <code>add_untyped_marker</code> is being used for adding a simple marker without any additional information. add_text_marker is being used for adding a marker with only additional “text” information. And lastly, <code>add_marker</code> is being used for adding a marker with different kinds of data and visualization types.</p>
<p>Here’s some examples:</p>
<pre>// Record a simple marker with the category of Graphics, DisplayListBuilding.
gecko_profiler::add_untyped_marker(
    // Name of the marker as a string.
    &#34;Marker Name&#34;,
    // Category with an optional sub-category.
    gecko_profiler_category!(Graphics, DisplayListBuilding),
    // MarkerOptions that keeps options like marker timing and marker stack.
    // It will be a point in type by default.
    Default::default(),
);
// Create a marker with some additional text information.
let info = &#34;info about this marker&#34;;
gecko_profiler::add_text_marker(
    // Name of the marker as a string.
    &#34;Marker Name&#34;,
    // Category with an optional sub-category.
    gecko_profiler_category!(DOM),
    // MarkerOptions that keeps options like marker timing and marker stack.
    MarkerOptions {
        timing: MarkerTiming::instant_now(),
        ..Default::default()
    },
    // Additional information as a string.
    info,
);
</pre>
<p>These examples show you how to add simple markers. To add more interesting markers with different data fields, add_marker function can be used. But since it’s a bit complicated, I won’t explain this in this blog post. <a href="https://firefox-source-docs.mozilla.org/tools/profiler/instrumenting-rust.html#other-typed-markers">You can refer to our Rust API documentation for more details of it.</a></p>
<p>We also have functions like <code>gecko_profiler::is_active</code> and <code>gecko_profiler::can_accept_markers</code>. They are pretty self explanatory. <code>is_active</code> can be used to check if the profiler is active. <code>can_accept_markers</code> can be used to know if the profiler is active and running and can accept markers. This function is especially useful when you want to add a marker but you need to compute some information to add inside the marker payload. You can put the computations inside a <code>can_accept_markers</code> if block so the code will not run when the profiler is not running.</p>
<h2>Some implementation details if you are curious</h2>
<p>We talked about the API itself. And you can always <a href="https://firefox-source-docs.mozilla.org/tools/profiler/instrumenting-rust.html">check the documentation of it here</a>. I also wanted to talk about the implementation details and the challenges we faced when we were implementing this.</p>
<h3>Profiling categories</h3>
<p>I mentioned before that our profiler categories list lives inside the <a href="https://searchfox.org/mozilla-central/rev/bb14d901ac16633801b7f4adaa4fb104e6f072e4/mozglue/baseprofiler/build/profiling_categories.yaml">profiling_categories.yaml</a> file. Before this work, it was hard coded inside a C++ file. But we couldn’t use the same C++ file inside the Rust side. We could use the rust-bindgen to create some bindings for it, but it wasn’t a clean solution, since we had to touch the Rust side every time we changed the categories. So instead, we chose to move the categories to a yaml file and generate both C++ header files and Rust files from that during the build time.</p>
<p>So now, we have a build step like this:</p>
<p><a href="http://ffp4g1ylyit3jdyti1hqcvtb-wpengine.netdna-ssl.com/performance/files/2022/02/profiler-rust-api-profiling-categories.png"><img loading="lazy" src="http://ffp4g1ylyit3jdyti1hqcvtb-wpengine.netdna-ssl.com/performance/files/2022/02/profiler-rust-api-profiling-categories.png" alt="Profiling categories file generation flow. Both Rust and C++ files are being generated from the profiling_categories.yml" width="747" height="358" srcset="https://blog.mozilla.org/performance/files/2022/02/profiler-rust-api-profiling-categories.png 747w, https://blog.mozilla.org/performance/files/2022/02/profiler-rust-api-profiling-categories-300x144.png 300w, https://blog.mozilla.org/performance/files/2022/02/profiler-rust-api-profiling-categories-600x288.png 600w" sizes="(max-width: 747px) 100vw, 747px"/></a></p>
<p>This generation step helped us generate better and more idiomatic Rust enums and also keep the C++ header as-is. Also, in the future, when someone needs to add a category, they won’t have to edit both sides. Only changing the yaml file should be enough. If you are curious about the generated files, please take a look at <a href="https://searchfox.org/mozilla-central/source/__GENERATED__/mozglue/baseprofiler/public/ProfilingCategoryList.h">the C++ header file here</a> and <a href="https://searchfox.org/mozilla-central/source/__GENERATED__/tools/profiler/rust-api/src/gecko_bindings/profiling_categories.rs">the Rust file here</a>.</p>
<h3>Using C++ objects inside Rust</h3>
<p>We are using both rust-bindgen and cbindgen in our crate. rust-bindgen automatically generates the FFI bindings of C++ functions/enums/classes so we can access them inside Rust. cbindgen automatically generates the FFI bindings of Rust functions so we can access them inside C++. I would say that cbindgen usage is <a href="https://searchfox.org/mozilla-central/source/__GENERATED__/tools/profiler/profiler_ffi_generated.h">pretty small with two functions</a>. But we are <a href="https://searchfox.org/mozilla-central/rev/049f3e8d328c4b6bac9bf4b27309541a2e913686/tools/profiler/rust-api/build.rs">using the rust-bindgen extensively</a>. And this caused a bit of a problem during the implementation phase.</p>
<p>The biggest problem was the usage of C++ structs and classes inside the Rust code. For advanced marker API, we had to use some of these classes inside of Rust code like the <code>MarkerSchema</code> class. Ideally, you should never create a C++ class inside the Rust code. You should always leave the lifetime of an object to its language. If it’s a C++ object, let C++ initialize it, and return the pointer to the Rust side so you can use it there. And vice versa. When you are destroying an object, it’s the same. You should give the pointer back to C++, so we can destroy the C++ object on the C++ side. This part was fine. When we needed a <code>MarkerSchema</code> object we were initializing an empty memory in Rust, then, we were calling a C++ FFI function and it was creating and returning the object back to Rust.</p>
<p>Here’s an example of this lifetime:</p>
<p><a href="http://ffp4g1ylyit3jdyti1hqcvtb-wpengine.netdna-ssl.com/performance/files/2022/02/profiler-rust-api-markerschema-lifetime.png"><img loading="lazy" src="http://ffp4g1ylyit3jdyti1hqcvtb-wpengine.netdna-ssl.com/performance/files/2022/02/profiler-rust-api-markerschema-lifetime.png" alt="MarkerSchema object lifetime. All memory allocations are handled by C++ and the pointer is kept in the Rust side." width="1280" height="960" srcset="https://blog.mozilla.org/performance/files/2022/02/profiler-rust-api-markerschema-lifetime.png 1280w, https://blog.mozilla.org/performance/files/2022/02/profiler-rust-api-markerschema-lifetime-300x225.png 300w, https://blog.mozilla.org/performance/files/2022/02/profiler-rust-api-markerschema-lifetime-600x450.png 600w, https://blog.mozilla.org/performance/files/2022/02/profiler-rust-api-markerschema-lifetime-768x576.png 768w, https://blog.mozilla.org/performance/files/2022/02/profiler-rust-api-markerschema-lifetime-1000x750.png 1000w" sizes="(max-width: 1280px) 100vw, 1280px"/></a>Now, things start to get interesting. Because we were creating the memory space on the Rust side, we had to know the size of that C++ object. And this is where rust-bindgen comes into play. It nicely <a href="https://searchfox.org/mozilla-central/search?q=symbol:gecko_profiler%3A%3Agecko_bindings%3A%3Astructs%3A%3Aroot%3A%3Amozilla%3A%3AMarkerSchema&amp;redirect=false">generates a <code>MarkerSchema</code> struct</a> on the Rust side with the same size as the C++ counterpart. With this generated struct you would know that <code>sizeof(RustMarkerSchema) == sizeof(CPPMarkerSchema)</code>. Unfortunately, there is a caveat, rust-bindgen can generate the sizes of simple classes that don’t have complex fields perfectly. But it can’t generate some classes if the field of that object is complex or contains internal pointers. And, of course, the MarkerSchema class contains some <code>std::string</code> and <code>std::vector</code> fields and they both have internal pointers.</p>
<p>So instead of allocating the same size, we were actually allocating a smaller memory on the Rust side and sending that to C++ to construct the class instance. When we were doing it, some extra fields of that class were just being written into some junk memory address and there was no guarantee that it would not be overwritten. Luckily, we found this out with our address sanitizer jobs in the CI. In the end, the solution was simple, but it took multiple days of debugging and analyzing the problem to figure out and find a solution. I must say that <a href="https://rr-project.org/">rr</a> and <a href="https://pernos.co/">Pernosco</a> were super helpful during this process. I could just record a session and replay it multiple times, even I could share that recording with my colleague Gerald Squelart so we could analyze it together. In the end, the fixing code was <a href="https://searchfox.org/mozilla-central/rev/049f3e8d328c4b6bac9bf4b27309541a2e913686/tools/profiler/rust-api/build.rs#88-95">just two lines of rust-bindgen configuration</a>.</p>
<h2>Conclusion</h2>
<p>I feel like there is a lot more to talk about this API for both usage-wise and implementation details-wise, but I don’t want to bore you too much with the details as well. This was definitely an interesting journey and I learned a lot while I was working on it! I would like to also thank two of my colleagues, Gerald Squelart and Emilio Cobos Álvarez. They helped me a lot during the implementation of this API and they helped with reviewing the work. Also, there are a lot more people I asked for their feedback about the API, thank you, everyone!</p>
<p>Please let us know if you have any questions or feedback. You can find us in the <a href="https://matrix.to/#/#profiler:mozilla.org">“Firefox Profiler” room on chat.mozilla.org</a>.</p>
      </div>

  
</article><!-- #post -->
    </div></div>
  </body>
</html>
