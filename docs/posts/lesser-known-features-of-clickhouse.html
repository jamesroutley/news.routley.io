<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pradeepchhetri.xyz/clickhouselesserknownfeatures/">Original</a>
    <h1>Lesser known features of ClickHouse</h1>
    
    <div id="readability-page-1" class="page"><div id="main">

<div>
<p><strong>Publish date: </strong>May 30, 2022
</p></div>

<nav aria-labelledby="toc-heading">
<h2 id="toc-heading">Table of contents</h2>
<ol>
<li>
<a href="#introduction">
Introduction
</a>
</li>
<li>
<a href="#run-clickhouse-queries-without-clickhouse-server">
Run clickhouse queries without clickhouse server
</a>
</li>
<li>
<a href="#run-clickhouse-as-http-server-with-custom-static-and-dynamic-handlers">
Run clickhouse as http server with custom static and dynamic handlers
</a>
</li>
<li>
<a href="#run-user-defined-functions-on-clickhouse">
Run user-defined functions on clickhouse
</a>
</li>
<li>
<a href="#run-clickhouse-queries-on-data-stored-in-other-databases">
Run clickhouse queries on data stored in other databases
</a>
</li>
<li>
<a href="#run-clickhouse-queries-on-data-stored-in-file">
Run clickhouse queries on data stored in file
</a>
</li>
<li>
<a href="#anonymize-any-data-using-clickhouse-obfuscator">
Anonymize any data using clickhouse-obfuscator
</a>
</li>
<li>
<a href="#read-clickhouse-server-runtime-information-like-queries-settings-users-roles-etc">
Read clickhouse server runtime information like queries, settings, users, roles etc
</a>
</li>
<li>
<a href="#show-the-execution-plan-of-a-clickhouse-query">
Show the execution plan of a clickhouse query
</a>
</li>
<li>
<a href="#convert-datetime-string-to-clickhouses-datetime-irrespective-of-its-format">
Convert datetime string to clickhouse’s datetime irrespective of its format
</a>
</li>
<li>
<a href="#create-row-level-policies-for-fine-granular-user-access">
Create row level policies for fine-granular user access
</a>
</li>
<li>
<a href="#automatic-schema-inference-for-json-documents">
Automatic schema inference for JSON documents
</a>
</li>
<li>
<a href="#conclusion">
Conclusion
</a>
</li>
</ol>
</nav>
<h2 id="introduction">Introduction</h2>
<p>ClickHouse can do lot more than a typical database. In this post, we will look at some of the features which are built into ClickHouse which you might not be aware of.</p>
<h2 id="run-clickhouse-queries-without-clickhouse-server">Run clickhouse queries without clickhouse server</h2>
<p><code>clickhouse-local</code> is a tool which comes along with clickhouse package that can be used to access clickhouse features without running a clickhouse server. Here are some examples you can use clickhouse-local for:</p>
<h4 id="data-manipulation">Data Manipulation</h4>
<p>We come data in various formats (JSON, CSV, TSV and XML) and often need to convert one to other since different tools consume specific format only.</p>
<p>Let say you can CSV file like this:</p>
<pre><code>❯ cat us-counties.csv
date,county,state,fips,cases,deaths
2020-01-21,Snohomish,Washington,53061,1,0
2020-01-22,Snohomish,Washington,53061,1,0
2020-01-23,Snohomish,Washington,53061,1,0
2020-01-24,Cook,Illinois,17031,1,0
2020-01-24,Snohomish,Washington,53061,1,0
2020-01-25,Orange,California,06059,1,0
2020-01-25,Cook,Illinois,17031,1,0
2020-01-25,Snohomish,Washington,53061,1,0
2020-01-26,Maricopa,Arizona,04013,1,0
....
</code></pre>
<p>You can convert it into any of the supported <a href="https://clickhouse.com/docs/en/interfaces/formats/">output format</a> using clickhouse-local.</p>
<p>Let try to convert it into JSON format.</p>
<pre><code>❯ clickhouse-local \
     --file=us-counties.csv \
     --input-format=CSVWithNames \
     --table input \
     --structure=&#39;date Date, county String, state String, fips UInt32, cases UInt32, deaths UInt32&#39; \
     --query=&#39;SELECT * from input FORMAT JSONEachRow&#39;
{&#34;date&#34;:&#34;2020-01-21&#34;,&#34;county&#34;:&#34;Snohomish&#34;,&#34;state&#34;:&#34;Washington&#34;,&#34;fips&#34;:53061,&#34;cases&#34;:1,&#34;deaths&#34;:0}
{&#34;date&#34;:&#34;2020-01-22&#34;,&#34;county&#34;:&#34;Snohomish&#34;,&#34;state&#34;:&#34;Washington&#34;,&#34;fips&#34;:53061,&#34;cases&#34;:1,&#34;deaths&#34;:0}
{&#34;date&#34;:&#34;2020-01-23&#34;,&#34;county&#34;:&#34;Snohomish&#34;,&#34;state&#34;:&#34;Washington&#34;,&#34;fips&#34;:53061,&#34;cases&#34;:1,&#34;deaths&#34;:0}
{&#34;date&#34;:&#34;2020-01-24&#34;,&#34;county&#34;:&#34;Cook&#34;,&#34;state&#34;:&#34;Illinois&#34;,&#34;fips&#34;:17031,&#34;cases&#34;:1,&#34;deaths&#34;:0}
{&#34;date&#34;:&#34;2020-01-24&#34;,&#34;county&#34;:&#34;Snohomish&#34;,&#34;state&#34;:&#34;Washington&#34;,&#34;fips&#34;:53061,&#34;cases&#34;:1,&#34;deaths&#34;:0}
{&#34;date&#34;:&#34;2020-01-25&#34;,&#34;county&#34;:&#34;Orange&#34;,&#34;state&#34;:&#34;California&#34;,&#34;fips&#34;:6059,&#34;cases&#34;:1,&#34;deaths&#34;:0}
{&#34;date&#34;:&#34;2020-01-25&#34;,&#34;county&#34;:&#34;Cook&#34;,&#34;state&#34;:&#34;Illinois&#34;,&#34;fips&#34;:17031,&#34;cases&#34;:1,&#34;deaths&#34;:0}
{&#34;date&#34;:&#34;2020-01-25&#34;,&#34;county&#34;:&#34;Snohomish&#34;,&#34;state&#34;:&#34;Washington&#34;,&#34;fips&#34;:53061,&#34;cases&#34;:1,&#34;deaths&#34;:0}
{&#34;date&#34;:&#34;2020-01-26&#34;,&#34;county&#34;:&#34;Maricopa&#34;,&#34;state&#34;:&#34;Arizona&#34;,&#34;fips&#34;:4013,&#34;cases&#34;:1,&#34;deaths&#34;:0}
....
</code></pre>
<h4 id="data-transformation">Data Transformation</h4>
<p>To analyse data we need to transform the data to get some meaningful results from it. SQL is very powerful in doing such transformations.</p>
<pre><code>❯ clickhouse-local \
     --file=us-counties.csv \
     --input-format=CSVWithNames \
     --table input \
     --structure=&#39;date Date, county String, state String, fips UInt32, cases UInt32, deaths UInt32&#39; \
     --query=&#39;SELECT state State, count() Count, bar(count(), 0, 100000, 100) Histogram from input GROUP BY state ORDER BY state FORMAT PrettyCompact&#39;
┌─State────────────────────┬─Count─┬─Histogram─────────────────────────┐
│ Alabama                  │  9700 │ █████████▋                        │
│ Alaska                   │  2878 │ ██▊                               │
│ Arizona                  │  2320 │ ██▎                               │
│ Arkansas                 │ 10696 │ ██████████▋                       │
│ California               │  8797 │ ████████▋                         │
│ Colorado                 │  8862 │ ████████▋                         │
│ ....                     │ ....  │ ....                              │
│ Virginia                 │ 18532 │ ██████████████████▌               │
│ Washington               │  5956 │ █████▊                            │
│ West Virginia            │  7256 │ ███████▎                          │
│ Wisconsin                │ 10133 │ ██████████▏                       │
│ Wyoming                  │  3187 │ ███▏                              │
└──────────────────────────┴───────┴───────────────────────────────────┘
</code></pre>
<p><a href="https://news.ycombinator.com/user?id=zX41ZdbW">HN User</a> pointed out that we don’t even need to pass the <code>--structure</code> flag and clickhouse will automatically infer it for us. Wow!!</p>
<h2 id="run-clickhouse-as-http-server-with-custom-static-and-dynamic-handlers">Run clickhouse as http server with custom static and dynamic handlers</h2>
<p>ClickHouse listens on port 8123 (by default) for HTTP request. One can add custom http handlers to serve random data whether within clickhouse or outside clickhouse via this endpoint.</p>
<p>Adding the following config to clickhouse config.yml will define an http handler /hello</p>
<pre><code>&lt;clickhouse&gt;
    &lt;http_handlers&gt;
        &lt;rule&gt;
            &lt;url&gt;/hello&lt;/url&gt;
            &lt;methods&gt;GET&lt;/methods&gt;
            &lt;handler&gt;
                &lt;type&gt;static&lt;/type&gt;
                &lt;status&gt;200&lt;/status&gt;
                &lt;response_content&gt;Hello from ClickHouse!&lt;/response_content&gt;
            &lt;/handler&gt;
        &lt;/rule&gt;
    &lt;/http_handlers&gt;
&lt;/clickhouse&gt;
</code></pre>
<p>Let’s try by making an HTTP request</p>
<pre><code>❯ curl &#39;localhost:8123/hello&#39;
Hello from ClickHouse!
</code></pre>
<p>Above example is static content but lets try for serving data from a clickhouse table. Adding the following config to clickhouse config.yml will define an http handler /foobar which will read data from <code>foobar</code> table of <code>default</code> database.</p>
<pre><code>&lt;clickhouse&gt;
    &lt;http_handlers&gt;
        &lt;rule&gt;
            &lt;url&gt;/foobar&lt;/url&gt;
            &lt;methods&gt;POST,GET&lt;/methods&gt;
            &lt;handler&gt;
                &lt;type&gt;predefined_query_handler&lt;/type&gt;
                &lt;query&gt;SELECT * FROM default.foobar&lt;/query&gt;
            &lt;/handler&gt;
        &lt;/rule&gt;
    &lt;/http_handlers&gt;
&lt;/clickhouse&gt;
</code></pre>
<p>Now lets create foobar table and insert some data into it.</p>
<pre><code>ch-server :) CREATE TABLE foobar
(
    `name` String
)
ENGINE = MergeTree
ORDER BY name

Ok.

ch-server :) INSERT INTO foobar(name) VALUES (&#39;John&#39;), (&#39;Michael&#39;), (&#39;Ivan&#39;);

Ok.
</code></pre>
<p>Now let’s make an HTTP request to the clickhouse endpoint.</p>
<pre><code>❯ curl &#39;localhost:8123/foobar&#39;
Ivan
John
Michael
</code></pre>
<p>Note the order change, it is due to <code>ORDER BY name</code> when we created the table.</p>
<p>You can read more about this feature in <a href="https://clickhouse.com/docs/en/interfaces/http/#predefined_query_handler">official documention</a></p>
<h2 id="run-user-defined-functions-on-clickhouse">Run user-defined functions on clickhouse</h2>
<p>One can define custom sql expressions or write scripts in their favourite language and clickhouse will happily call it for you.</p>
<pre><code>ch-server :) CREATE FUNCTION plus_one as (a) -&gt; a + 1

Ok.

ch-server :) SELECT plus_one(10);

┌─plus(10, 1)─┐
│          11 │
└─────────────┘
</code></pre>
<p>Adding the follow config in <code>/etc/clickhouse-server/awkplus_function.xml</code> will add user-defined function</p>
<pre><code>&lt;functions&gt;
    &lt;function&gt;
        &lt;type&gt;executable&lt;/type&gt;
        &lt;name&gt;awk_plus&lt;/name&gt;
        &lt;argument&gt;&lt;type&gt;UInt64&lt;/type&gt;&lt;/argument&gt;
        &lt;argument&gt;&lt;type&gt;UInt64&lt;/type&gt;&lt;/argument&gt;
        &lt;return_type&gt;UInt64&lt;/return_type&gt;
        &lt;format&gt;TabSeparated&lt;/format&gt;
        &lt;command&gt;awk &#39;{ print $1 + $2 }&#39;&lt;/command&gt;
        &lt;execute_direct&gt;0&lt;/execute_direct&gt;
    &lt;/function&gt;
&lt;/functions&gt;
</code></pre>
<pre><code>ch-server :) SELECT awk_plus(1,2);

┌─awk_plus(1, 2)─┐
│             3  │
└────────────────┘
</code></pre>
<h2 id="run-clickhouse-queries-on-data-stored-in-other-databases">Run clickhouse queries on data stored in other databases</h2>
<p>ClickHouse can act as a proxy for other databases like SQLite, MySQL and PostgreSQL.</p>
<p>Following example shows ClickHouse connecting to SQLite.</p>
<pre><code>ch-server :) CREATE DATABASE sqlite_data
ENGINE = SQLite(&#39;sqlite3.db&#39;);

ch-server :) SHOW TABLES FROM sqlite_data;

┌─name─┐
│ taxi │
└──────┘

ch-server :) SELECT count(*) FROM sqlite_data.taxi;

┌──count()─┐
│ 14092414 │
└──────────┘
</code></pre>
<p>Following example shows ClickHouse connecting to PostgreSQL.</p>
<pre><code>ch-server :) CREATE DATABASE postgres_data
ENGINE = PostgreSQL(&#39;127.0.0.1:5432&#39;, &#39;postgres&#39;, &#39;postgres&#39;, &#39;changeme&#39;);

ch-server :) SHOW TABLES FROM postgres_data;

┌─name─┐
│ taxi │
└──────┘

ch-server :) SELECT count(*) FROM postgres_data.taxi;

┌──count()─┐
│ 14092414 │
└──────────┘
</code></pre>
<h2 id="run-clickhouse-queries-on-data-stored-in-file">Run clickhouse queries on data stored in file</h2>
<p>ClickHouse can run queries on data stored in file using FILE Table Engine.</p>
<pre><code>ch-server :) CREATE TABLE data_file
(
    `id` UInt32,
    `name` String
)
ENGINE = File(TabSeparated);

Ok.

ch-server :) SELECT *
FROM data_file;

0 rows in set. Elapsed: 0.002 sec.
</code></pre>
<p>Let’s insert some tab-separated content into file.</p>
<pre><code>❯ cd /var/lib/clickhouse/data/default/data_file
❯ echo &#34;1       Rob&#34; &gt;&gt; data.TabSeparated
❯ echo &#34;2       Michael&#34; &gt;&gt; data.TabSeparated
❯ echo &#34;3       John&#34; &gt;&gt; data.TabSeparated
</code></pre>
<p>Now let’s query the clickhouse table.</p>
<pre><code>ch-server :) SELECT *
FROM data_file;

┌─id─┬─name────┐
│  1 │ Rob     │
│  2 │ Michael │
│  3 │ John    │
└────┴─────────┘

3 rows in set. Elapsed: 0.003 sec.
</code></pre>
<p>This is very useful if you want to do some kind of analysis on some file data.</p>
<h2 id="anonymize-any-data-using-clickhouse-obfuscator">Anonymize any data using clickhouse-obfuscator</h2>
<p>ClickHouse can anonymize your data whether stored inside or outside clickhouse using <code>clickhouse-obfuscator</code>.</p>
<pre><code>❯ cat users.csv
1,Rob
2,Michael
3,John

❯ clickhouse-obfuscator \
     --seed &#34;$(head -c16 /dev/urandom | base64)&#34; \
     --input-format CSV \
     --output-format CSV \
     --structure &#39;id UInt32,name String&#39; \
     &lt; users.csv
Training models
Processed 3 rows
Generating data
Processed 3 rows
1,&#34;&#34;
2,&#34;&#34;
3,&#34;&#34;
</code></pre>
<h2 id="read-clickhouse-server-runtime-information-like-queries-settings-users-roles-etc">Read clickhouse server runtime information like queries, settings, users, roles etc</h2>
<p>By default, there is a <code>system</code> database which contains multiple tables containing information about clickhouse-server itself.</p>
<pre><code>ch-server :) SHOW TABLES FROM system;

┌─name───────────────────────────┐
│ aggregate_function_combinators │
│ asynchronous_inserts           │
│ ...........                    │
│ ...........                    │
│ storage_policies               │
│ table_engines                  │
│ table_functions                │
│ tables                         │
│ time_zones                     │
│ trace_log                      │
│ user_directories               │
│ users                          │
│ warnings                       │
└────────────────────────────────┘

76 rows in set. Elapsed: 0.003 sec.

ch-server :) SELECT query
FROM system.query_log;

┌─query────────────────────┐
│ SHOW TABLES FROM system; │
│ SHOW TABLES FROM default;│
└──────────────────────────┘

ch-server :) SELECT name, value
FROM system.settings;

┌─name─────────────────────────────────────────────────────────────────────────┬─value──────────────────┐
│ min_compress_block_size                                                      │ 65536                  │
│ max_compress_block_size                                                      │ 1048576                │
│ max_block_size                                                               │ 65505                  │
│ max_insert_block_size                                                        │ 1048545                │
│ ...............                                                              │ .......                │
│ input_format_mysql_dump_map_column_names                                     │ 1                      │
└──────────────────────────────────────────────────────────────────────────────┴────────────────────────┘
</code></pre>
<h2 id="show-the-execution-plan-of-a-clickhouse-query">Show the execution plan of a clickhouse query</h2>
<p>ClickHouse support <code>EXPLAIN</code> inspired from PostgreSQL.</p>
<pre><code>ch-server :) EXPLAIN AST
SELECT *
FROM data_file;

┌─explain─────────────────────────────────────┐
│ SelectWithUnionQuery (children 1)           │
│  ExpressionList (children 1)                │
│   SelectQuery (children 2)                  │
│    ExpressionList (children 1)              │
│     Asterisk                                │
│    TablesInSelectQuery (children 1)         │
│     TablesInSelectQueryElement (children 1) │
│      TableExpression (children 1)           │
│       TableIdentifier data_file             │
└─────────────────────────────────────────────┘

9 rows in set. Elapsed: 0.001 sec.

ch-server :) EXPLAIN PLAN
SELECT *
FROM data_file;

┌─explain───────────────────────────────────────────────────────────────────┐
│ Expression ((Projection + Before ORDER BY))                               │
│   SettingQuotaAndLimits (Set limits and quota after reading from storage) │
│     ReadFromStorage (File)                                                │
└───────────────────────────────────────────────────────────────────────────┘

3 rows in set. Elapsed: 0.002 sec.
</code></pre>
<h2 id="convert-datetime-string-to-clickhouses-datetime-irrespective-of-its-format">Convert datetime string to clickhouse’s datetime irrespective of its format</h2>
<p>ClickHouse provides a function which does the heavy lifting of identifying the timestamp format.</p>
<pre><code>ch-server :) SELECT parseDateTimeBestEffort(&#39;31-05-2022 11:11:11&#39;) AS result;

┌──────────────result─┐
│ 2022-05-31 11:11:11 │
└─────────────────────┘

1 row in set. Elapsed: 0.002 sec.

ch-server :) SELECT parseDateTimeBestEffort(&#39;31/05/2022 11:11:11&#39;) AS result;

┌──────────────result─┐
│ 2022-05-31 11:11:11 │
└─────────────────────┘

1 row in set. Elapsed: 0.003 sec.

ch-server :) SELECT parseDateTimeBestEffort(&#39;20220531111111&#39;) AS result;

┌──────────────result─┐
│ 2022-05-31 11:11:11 │
└─────────────────────┘
</code></pre>
<p>Not only that, it even understands unix epoch timestamp.</p>
<pre><code>ch-server :) SELECT parseDateTimeBestEffort(&#39;1653995471&#39;) AS result;

┌──────────────result─┐
│ 2022-05-31 11:11:11 │
└─────────────────────┘
</code></pre>
<h2 id="create-row-level-policies-for-fine-granular-user-access">Create row level policies for fine-granular user access</h2>
<p>This feature of ClickHouse is similar to PostgreSQL’s <a href="https://www.postgresql.org/docs/current/ddl-rowsecurity.html">row-level security</a> but only for ClickHouse users with readonly access.</p>
<p>Let’s say you created two users: john and michael and you want to allow john only to read certain lines and likewise for michael.</p>
<pre><code>❯ clickhouser-client --user=default

ch-server :) CREATE USER john;

Ok.

ch-server :) CREATE USER michael;

Ok.

ch-server :) CREATE TABLE users
(
    `id` UInt32,
    `name` String,
    `age` UInt32
)
ENGINE = MergeTree
ORDER BY id;

Ok.

ch-server :) INSERT INTO users VALUES (1, &#39;John&#39;, 20), (2, &#39;Michael&#39;, 18);

Ok.

ch-server :) SELECT *
FROM users;

┌─id─┬─name────┬─age─┐
│  1 │ John    │  20 │
│  2 │ Michael │  18 │
└────┴─────────┴─────┘

ch-server :) GRANT SELECT(id, name, age) ON default.users TO john WITH GRANT OPTION;

Ok.

ch-server :) GRANT SELECT(id, name, age) ON default.users TO michael WITH GRANT OPTION;

Ok.
</code></pre>
<p>Now you can configure row-level policies for both of these users</p>
<pre><code>❯ clickhouser-client --user=default

ch-server :) CREATE ROW POLICY john_users ON default.users FOR SELECT USING name = &#39;John&#39; TO john;

Ok.

ch-server :) CREATE ROW POLICY michael_users ON default.users FOR SELECT USING name = &#39;Michael&#39; TO michael;

Ok.
</code></pre>
<p>This way when each of these users login, they only see the rows which they are allowed to read.</p>
<pre><code>❯ clickhouse-client --user=john

ch-server :) SELECT *
FROM users;

┌─id─┬─name─┬─age─┐
│  1 │ John │  20 │
└────┴──────┴─────┘

❯ clickhouse-client --user=michael

ch-server :) SELECT *
FROM users;

┌─id─┬─name────┬─age─┐
│  2 │ Michael │  18 │
└────┴─────────┴─────┘
</code></pre>
<h2 id="automatic-schema-inference-for-json-documents">Automatic schema inference for JSON documents</h2>
<p>Last but not the least, this is my favourite feature. ClickHouse recently added a new JSON Object datatype. This helps in infering the datatype dynamically and as a clickhouse enduser, we don’t need to worry about the schema. This inference even work with Nested JSON.</p>
<p>We can first run <code>DESCRIBE TABLE</code> to check the schema ClickHouse will infer for us.</p>
<pre><code>ch-server :) DESCRIBE TABLE s3(&#39;https://datasets-documentation.s3.eu-west-3.amazonaws.com/github/github-2022.ndjson.gz&#39;, &#39;JSONEachRow&#39;)
SETTINGS input_format_max_rows_to_read_for_schema_inference = 100

┌─name───────┬─type─────────────────────┬─default_type─┬─default_expression─┬─comment─┬─codec_expression─┬─ttl_expression─┐
│ type       │ Nullable(String)         │              │                    │         │                  │                │
│ actor      │ Object(Nullable(&#39;json&#39;)) │              │                    │         │                  │                │
│ repo       │ Object(Nullable(&#39;json&#39;)) │              │                    │         │                  │                │
│ created_at │ Nullable(String)         │              │                    │         │                  │                │
│ payload    │ Object(Nullable(&#39;json&#39;)) │              │                    │         │                  │                │
└────────────┴──────────────────────────┴──────────────┴────────────────────┴─────────┴──────────────────┴────────────────┘
</code></pre>
<p>Now we can create the table with a single column of type <code>JSON</code></p>
<pre><code>ch-server :) CREATE TABLE github_json
(
    `event` JSON
)
ENGINE = MergeTree
ORDER BY tuple()

Ok.
</code></pre>
<p>And then import the data</p>
<pre><code>ch-server :) INSERT INTO github_json SELECT *
FROM s3(&#39;https://datasets-documentation.s3.eu-west-3.amazonaws.com/github/github-2022.ndjson.gz&#39;, JSONAsObject, &#39;event JSON&#39;)

Ok.

0 rows in set. Elapsed: 25.469 sec. Processed 1.00 million rows, 453.17 MB (39.26 thousand rows/s., 17.79 MB/s.)
</code></pre>
<p>Now clickhouse will add the inferred columns and you can query by the inferred columns.</p>
<pre><code>ch-server :) SELECT
    event.type,
    event.repo,
    event.actor
FROM github_json
LIMIT 1

┌─event.type─┬─event.repo───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┬─event.actor──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│ PushEvent  │ (429298592,&#39;revacprogramming/pps-test1-Lakshmipatil2021&#39;,&#39;https://api.github.com/repos/revacprogramming/pps-test1-Lakshmipatil2021&#39;) │ (&#39;https://avatars.githubusercontent.com/u/93110249?&#39;,&#39;Lakshmipatil2021&#39;,93110249,&#39;Lakshmipatil2021&#39;,&#39;https://api.github.com/users/Lakshmipatil2021&#39;) │
└────────────┴──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┴──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>In conclusion, ClickHouse can act as proxy, http-server and whatever you can think of. This is just a subset of things which ClickHouse can do. If you haven’t tried ClickHouse, I will encourage you to try it. Thank you for reading the blog.</p>
</div></div>
  </body>
</html>
