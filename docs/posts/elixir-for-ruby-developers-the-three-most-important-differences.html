<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://phoenixonrails.com/blog/elixir-for-ruby-developers-the-three-most-important-differences">Original</a>
    <h1>Elixir for Ruby developers: the three most important differences</h1>
    
    <div id="readability-page-1" class="page"><div>
  

  <p><img src="https://phoenixonrails.com/images/blog/red-potion.jpg"/></p><p>
  This article is an extract from <a href="https://phoenixonrails.com/"><i>Phoenix on Rails</i></a>, a comprehensive guide to Elixir, Phoenix and LiveView for developers who already know Ruby on Rails. If you’re a Rails developer who wants to learn Phoenix fast, <a href="https://phoenixonrails.com/">click here to learn more</a>!</p>
<p>
Many developers who learn Elixir come from a background in Ruby. This is hardly surprising: Elixir’s creator, José Valim, was formerly a prominent Ruby developer, and Elixir has been attracting Rubyists since the very beginning!</p>
<p>
But while Elixir’s syntax looks like Ruby at a glance, you’ll quickly realise that these similarities are skin-deep. The two languages are very different in their underlying designs, and Elixir often requires you to structure your code in a way that looks nothing like the equivalent Ruby. Certain aspects of Elixir will feel very unfamiliar to a Rubyist, and will take some getting used to.</p>
<p>
This series will give a brief introduction to Elixir for developers who already know Ruby. But before we get into the details of Elixir’s syntax, it’s worth reviewing some of the higher-level differences between the two languages. In particular, here are the <strong>three most important differences</strong> between Elixir and Ruby:</p>
<ul>
  <li>
Elixir is <strong>functional</strong>. Unlike Ruby, it’s <strong>not object-oriented</strong> and has no concept of “classes” or inheritance.  </li>
  <li>
Everything in Elixir is <strong>immutable</strong>.  </li>
  <li>
Elixir is <strong>compiled</strong> while Ruby is <strong>interpreted</strong>.  </li>
</ul>
<p>
Let’s look at those three points in more detail…</p>
<h2>
Elixir is Functional, not Object-Oriented</h2>
<p>
The most important difference between Elixir and Ruby is that <strong>Elixir is not object-oriented</strong>.</p>
<p>
Elixir has no classes. You don’t initialize “objects” with instance methods. Instead, you write <strong>functions</strong> that are grouped into <strong>modules</strong>. For this reason, Elixir code can be structured very differently to the equivalent Ruby.</p>
<p>
To illustrate: in Ruby, strings like <code>&#34;this&#34;</code> are <strong>instances</strong> of the class <code>String</code>. That class has various <strong>instance methods</strong> like <code>upcase</code>, <code>reverse</code>, or <code>length</code> which you can call on a particular string using <code>.</code>-syntax. Open <code>irb</code> in a terminal and try it:</p>
<pre><code><span>irb&gt; </span><span>name</span><span> </span><span>=</span><span> </span><span>&#34;Pikachu&#34;</span><span>
</span><span>irb&gt; </span><span>name</span><span>.</span><span>upcase</span><span>
</span><span>&#34;PIKACHU&#34;</span><span>
</span><span>irb&gt; </span><span>name</span><span>.</span><span>reverse</span><span>
</span><span>&#34;uhcakiP&#34;</span><span>
</span><span>irb&gt; </span><span>name</span><span>.</span><span>length</span><span>
</span><span>7</span><span>
</span></code></pre>
<p>
In Elixir, <code>String</code> isn’t a class, because Elixir doesn’t have classes. Instead, <code>String</code> is a <strong>module</strong> - a collection of <strong>functions</strong> that apply to a string. So instead of writing <code>name.upcase</code> you write <code>String.upcase(name)</code>.</p>
<p>
<code>upcase</code> isn’t a method on strings (Elixir doesn’t have methods). It’s a function that takes a string as its first argument.</p>
<p>
Follow the <a href="https://elixir-lang.org/install.html">official instructions</a> to install Elixir if you don’t have it already. Then open another terminal window and start <code>iex</code>, the Elixir equivalent of <code>irb</code>. Here’s how the <code>String</code> operations we saw above are performed in Elixir:</p>
<pre><code><span>iex&gt; </span><span>name</span><span> </span><span>=</span><span> </span><span>&#34;Pikachu&#34;</span><span>
</span><span>iex&gt; </span><span>String</span><span>.</span><span>upcase</span><span data-group-id="0754597911-1">(</span><span>name</span><span data-group-id="0754597911-1">)</span><span>
</span><span>&#34;PIKACHU&#34;</span><span>
</span><span>iex&gt; </span><span>String</span><span>.</span><span>reverse</span><span data-group-id="0754597911-2">(</span><span>name</span><span data-group-id="0754597911-2">)</span><span>
</span><span>&#34;uhcakiP&#34;</span><span>
</span><span>iex&gt; </span><span>String</span><span>.</span><span>length</span><span data-group-id="0754597911-3">(</span><span>name</span><span data-group-id="0754597911-3">)</span><span>
</span><span>7</span><span>
</span></code></pre>
<p>
(Note that you exit <code>iex</code> by pressing <code>Ctrl + C</code> twice, whereas to exit <code>irb</code> you press <code>Ctrl + D</code> once.)</p>
<p>
Elixir has modules like <code>Integer</code>, <code>List</code> and <code>Float</code>, each containing functions to apply to their respective types:</p>
<pre><code><span>iex&gt; </span><span>List</span><span>.</span><span>first</span><span data-group-id="3171463542-1">(</span><span data-group-id="3171463542-2">[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span data-group-id="3171463542-2">]</span><span data-group-id="3171463542-1">)</span><span>
</span><span>1</span><span>
</span><span>iex&gt; </span><span>Float</span><span>.</span><span>floor</span><span data-group-id="3171463542-3">(</span><span>3.14</span><span data-group-id="3171463542-3">)</span><span>
</span><span>3.0</span><span>
</span><span>iex&gt; </span><span>Integer</span><span>.</span><span>digits</span><span data-group-id="3171463542-4">(</span><span>90210</span><span data-group-id="3171463542-4">)</span><span>
</span><span data-group-id="3171463542-5">[</span><span>9</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>0</span><span data-group-id="3171463542-5">]</span><span>
</span></code></pre>
<p>
If a function takes more than one argument, normally the <strong>first</strong> argument has the same type as the module. See for example these two ways of testing whether a regex matches a string (regexes in Elixir are written with <code>~r/…/</code>):</p>
<pre><code><span>iex&gt; </span><span>Regex</span><span>.</span><span>match?</span><span data-group-id="7899434140-1">(</span><span>~r/se[0-9]en/</span><span>,</span><span> </span><span>&#34;se7en&#34;</span><span data-group-id="7899434140-1">)</span><span>
</span><span>true</span><span>
</span><span>iex&gt; </span><span>String</span><span>.</span><span>match?</span><span data-group-id="7899434140-2">(</span><span>&#34;se7en&#34;</span><span>,</span><span> </span><span>~r/se[0-9]en/</span><span data-group-id="7899434140-2">)</span><span>
</span><span>true</span><span>
</span></code></pre>
<p>
Both these functions test whether a string matches a regex, returning a boolean. The only difference is the order of the arguments: <code>Regex.match?</code> takes the regex first, <code>String.match?</code> takes the string first. That’s the general rule: the name of the module tells you the type of the first argument.</p>
<p>
To a Ruby developer, the functional style might feel weird at first. You’ll find yourself reaching for instance methods that don’t exist, and being initially unsure how to structure something in Elixir when you know how you’d write it in Ruby. But with time the functional style will start to feel natural, and you’ll see how it leads to clear, elegant and maintainable code.</p>
<h2>
Immutability vs Mutability</h2>
<p>
The next major difference between Elixir and Ruby is that <strong>in Elixir, everything is immutable</strong>.</p>
<p>
In Ruby it’s usually possible to mutate objects, which is just a fancy way of saying “change them”. For example, the following Ruby creates a string then mutates it in-place:</p>
<pre><code><span>str</span><span> </span><span>=</span><span> </span><span>&#34;hello&#34;</span><span>
</span><span>str</span><span>.</span><span>capitalize!</span><span>
</span><span>str</span><span> </span><span>&lt;&lt;</span><span> </span><span>&#34;!&#34;</span><span>
</span><span>puts</span><span> </span><span>str</span><span>
</span><span># Hello!</span><span>
</span></code></pre>
<p>
The variable <code>str</code> still points to the same memory location, but the contents of that memory have mutated from <code>&#34;hello&#34;</code> to <code>&#34;HELLO!&#34;</code>.</p>
<p>
The disadvantage of mutability is that it makes your code unpredictable. When you pass a string to a function, you don’t necessarily know what happens to it. The function could mutate your string without you realising, causing unexpected behavior further down the line.</p>
<p>
Not everything in Ruby is like this. For example, symbols like <code>:foobar</code> are <strong>immutable</strong>. They can’t be changed after they’ve been created. The only way to “capitalize” <code>:foobar</code> is to create an entirely new symbol, <code>:FOOBAR</code>, at a new memory location.</p>
<p>
In Elixir, everything behaves like a Ruby symbol. There’s no equivalent of <code>capitalize!</code> on a Elixir string because Elixir can’t mutate the string in place. You can only use <code>String.capitalize</code> (which we saw above), which returns an entirely new string, leaving the original one unchanged.</p>
<p>
We’ll see in the lessons ahead how Elixir’s immutability makes for predictable, reliable and maintainable code.</p>
<h2>
Compiled vs Interpreted</h2>
<p>
Elixir is a <strong>compiled language</strong>. Elixir files end in <code>.ex</code>, and get compiled to BEAM files with extension <code>.beam</code>. These compiled files are ultimately what gets run when you execute your code.</p>
<p>
Try it yourself by creating a file called <code>math.ex</code>. (Note that Elixir’s <code>IO.puts</code> is the equivalent of Ruby’s <code>puts</code>):</p>
<pre><code><span>defmodule</span><span> </span><span>Math</span><span> </span><span data-group-id="2829696517-1">do</span><span>
  </span><span>def</span><span> </span><span>add</span><span data-group-id="2829696517-2">(</span><span>a</span><span>,</span><span> </span><span>b</span><span data-group-id="2829696517-2">)</span><span> </span><span data-group-id="2829696517-3">do</span><span>
    </span><span>a</span><span> </span><span>+</span><span> </span><span>b</span><span>
  </span><span data-group-id="2829696517-3">end</span><span>
</span><span data-group-id="2829696517-1">end</span><span>

</span><span>result</span><span> </span><span>=</span><span> </span><span>Math</span><span>.</span><span>add</span><span data-group-id="2829696517-4">(</span><span>2</span><span>,</span><span> </span><span>2</span><span data-group-id="2829696517-4">)</span><span>
</span><span>IO</span><span>.</span><span>puts</span><span data-group-id="2829696517-5">(</span><span>result</span><span data-group-id="2829696517-5">)</span><span>
</span></code></pre>
<p>
Compile and run the code with <code>elixirc</code>:</p>
<pre><code>$ elixirc math.ex
4
</code></pre>
<p x-data="{ tooltip: &#39;If you’re familiar with Java: Elixir and Erlang both run on BEAM in the same way that Java, Scala and Kotlin all run on the JVM.&#39; }">
  This created a compiled file called <code>Elixir.Math.beam</code> in the current directory. <code>.beam</code> files are run on <a href="https://www.erlang.org/blog/a-brief-beam-primer/">BEAM</a>, the same virtual machine that&#39;s used to run <b>Erlang</b>, a veteran functional programming language that&#39;s been around since the ’80s<sup x-tooltip="tooltip">[1]</sup>.</p>
<p>
<code>.beam</code> files are binary files that you shouldn’t edit directly. Make sure to exclude them from your version control system.</p>
<p x-data="{ tooltip: &#39;Depending on who you ask, BEAM either stands for “Bogdan’s Erlang Abstract Machine“ or “Björn’s Erlang Abstract Machine“, after Bogdan Hausman (BEAM’s original creator) and Björn Gustavsson (its current maintainer.)&#39; }">
  BEAM<sup x-tooltip="tooltip">[2]</sup>, AKA the Erlang VM, is widely used in telecoms and is renowned for its speed, scalability and fault tolerance - all good qualities for a modern web app!</p>
<p>
Elixir might look like Ruby on the surface, but its underlying design is heavily based on Erlang. In fact it wouldn’t be too far off to describe Elixir as “Erlang with Ruby syntax”.</p>
<p>
If you want you can still run Elixir as an interpreted language. Try creating a one-line file called <code>hello_world.exs</code>. (Note the different ending, <code>.exs</code> instead of <code>.ex</code>. The extra <code>s</code> stands for “script”.)</p>
<pre><code><span>IO</span><span>.</span><span>puts</span><span data-group-id="0376976311-1">(</span><span>&#34;Hello, world!&#34;</span><span data-group-id="0376976311-1">)</span><span>
</span></code></pre>
<p>
Now run it using <code>elixir</code> instead of <code>elixirc</code>:</p>
<pre><code>$ elixir hello_world.exs
Hello, world!
</code></pre>
<p>
Files run with <code>elixir</code> won’t be compiled; they’ll be interpreted on the fly. This might mean they run more slowly, but you won’t have to pay the fixed cost of compilation at the beginning. <code>.exs</code> files are useful for scripting or testing.</p>
<p>
By convention we use the <code>.ex</code> extension for files we intend to compile, and <code>.exs</code> for files we intend to run as interpreted scripts. This isn’t mandatory - you can interpret an <code>.ex</code> file or compile or <code>.exs</code> if you want. But it’s good to stick to convention.</p>
<p>
In practice you’ll rarely need to run the <code>elixir</code> or <code>elixirc</code> commands yourself when working on a Phoenix project. Most of the time you’ll run or compile Elixir code using <code>mix</code>, Elixir’s build tool, as we’ll see throughout the course.</p>
<p>
With that out of the way, we can start talking about syntax. What does Elixir code actually look like? We’ll see in the next extract (coming soon).</p>

</div></div>
  </body>
</html>
