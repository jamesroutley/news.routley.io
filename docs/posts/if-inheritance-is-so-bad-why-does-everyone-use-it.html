<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buttondown.email/hillelwayne/archive/if-inheritance-is-so-bad-why-does-everyone-use-it/">Original</a>
    <h1>If Inheritance is so bad, why does everyone use it?</h1>
    
    <div id="readability-page-1" class="page"><div>
                <date>
                    
                        May 15, 2020
                    </date>
                
                

                

                
                    
                        <h2>Alloy Workshop</h2>
<p>There are still two slots available for the <a href="https://www.eventbrite.com/e/software-modeling-with-alloy-workshop-registration-104254118876" target="_blank">alloy workshop</a>! I&#39;ve been hard at work adding a bunch of teaching innovations to the class, which I <em>wanted to</em> talk about this time, but something more interesting came up.</p>
<h2>If Inheritance is so bad, why does everyone use it?</h2>
<p><a href="https://solovyov.net/blog/2020/inheritance/" target="_blank">This essay</a> says that inheritance is harmful and if possible you should &#34;ban inheritance completely&#34;. You see these arguments a lot, as well as things like &#34;prefer composition to inheritance&#34;. A lot of these arguments argue that in practice inheritance has problems. But they don&#39;t preclude inheritance working in another context, maybe with a better language syntax. And it doesn&#39;t explain why inheritance became so popular in the first place. I want to explore what&#39;s <em>fundamentally</em> challenging about inheritance and why we all use it anyway.</p>
<p>My favorite essay on inheritance is <a href="https://www.sicpers.info/2018/03/why-inheritance-never-made-any-sense/" target="_blank">Why inheritance never made any sense</a>. In it Graham argues that there&#39;s actually three ways that we mean inheritance:</p>
<blockquote>
<ol>
<li>Ontological inheritance is about specialisation: this thing is a specific variety of that thing (a football is a sphere and it has this radius)</li>
<li>Abstract data type inheritance is about substitution: this thing behaves in all the ways that thing does and has this behaviour (this is the Liskov substitution principle)</li>
<li>Implementation inheritance is about code sharing: this thing takes some of the properties of that thing and overrides or augments them in this way.</li>
</ol>
</blockquote>
<p>Since conventional class-based inheritance conflates these three types of inheritance, it doesn&#39;t really satisfy any of them properly. This is what makes it so challenging to use in practice. Things like abstract data types and modules and such only hit one of these kinds at a time, properly separating the concerns and making them easier to use.</p>
<p>So then why do we use inheritance instead of ADTs and modules and stuff? And that&#39;s where we need to look at the history.</p>
<h3>History</h3>
<p>Where did inheritance come from? As with many things in OOP, it comes from SIMULA-67. The creators, Dahl and Nygaard, introduced objects as a generalization of their SIMULA-I&#39;s simulation syntax. That&#39;s important to understand why inheritance works the way it does: it was originally designed for use in simulation software. The <a href="http://simula67.at.ifi.uio.no/Standard-70/Simula-1970-NR-22.pdf" target="_blank">first examples</a> of inheritance are for modeling customer orders and a jobshop simulation!</p>
<p>SIMULA had a big influence on other object languages. Smalltalk credits it for a lot of the design decisions. This meant that inheritance was pretty entrenched by the point that the alternative started appearing. And that&#39;s the key point: inheritance came <em>first</em>. The idea of subtypes, or abstract data types, come from Barbara Liskov&#39;s CLU. That was six years later, <em>in part</em> based on her knowledge of SIMULA. Notably, CLU was a research language, not an industry language. ADTs only entered widespread industry use with Java interfaces, about two decades after CLU.<sup id="fnref:adts"><a href="#fn:adts">1</a></sup> In the intervening thirty years, inheritance was established by C++, Smalltalk, and Object Pascal. </p>
<p>Similarly, modularization was a concept for a while but modules only appeared as a first-class language component with Modula, which came out in 1975. Even <em>today</em> most industry languages don&#39;t have proper modules that encourage code specialization. Most languages with &#34;modules&#34; are really just namespaces.</p>
<p>Time to take off the Fact Hat and put on the Speculation Hat. It seems to me that ADTs and modules were in part influenced by the existence of inheritance. People saw the idea and try to separate out the various concerns. This happens quite often in language design, and in fact any sort of technical development. Often people will introduce a practical innovation that sort of blends together a bunch of abstract concepts <em>without knowing about those concepts beforehand</em>. It&#39;s only once the innovation is used in practice and people get a better &#34;intuition&#34; for it that they start to see the abstract concepts and try to tease them apart. Of course, once something becomes established it&#39;s very hard to get rid of. And because a lot of languages started out using inheritance, it became a common thing. </p>
<p>See also: <em>everything else in software</em>.</p>
<p>It&#39;s also notably the first case where we put a syntactic relationship between two classes. Surprisingly, it still remains one of the only ways to relate two classes. You&#39;ve basically got interfaces, traits/mixins, and inheritance, and that&#39;s <em>it</em>. I suspect this is because most object relationships are domain-based, and while language syntax tries to remain generality-based.</p>
<h3>The better mousetrap</h3>
<p>There is one part of the story we need to talk about though: can we do inheritance in a better way? The key language here is Eiffel, by Bertrand Meyer. Eiffel used to be a rising giant in the OOP world but has mostly faded into irrelevance now. Among other things, almost all of the relationships were inheritance-based. There were no interfaces, no modules, no traits, etc. You&#39;re even expected to use multiple inheritance quite regularly.</p>
<p>This isn&#39;t as bad as it sounds. Eiffel was designed from the start to avoid a lot of the pitfalls that you often see with inheritance. For example it avoided the &#34;diamond problem&#34; with a robust renaming mechanism. It also had a really interesting feature that made its inheritance a lot more powerful: code contracts. You could place preconditions and postconditions on methods that would be checked and every call. If you inherited the class, though, Eiffel could guarantee that you could <em>only</em> weaken preconditions and <em>only</em> strengthen postconditions. This means that you can substitute a child class anywhere the parent class would be accepted and guarantee that all of the invariants were still satisfied. That&#39;s a pretty cool language feature!</p>
<p>Incidentally, Meyer also coined the &#34;open closed principle&#34;, which is the O in SOLID. So his thinking on languages did have at least some effect on our modern development, if somewhat indirect.</p>
<p>Unfortunately, Eiffel also had a minor problem with inheritance. You see, Eiffel is statically typed. The input types of a method&#39;s parameters are effectively preconditions. This means, to be type safe, you should only be able to &#34;weaken the preconditions&#34; on an inherited method&#39;s parameters&#39; types, like say &#34;instead of taking any natural number, this method can now take any integer&#34;. This is equivalent to replacing a type with its supertype, or &#34;contravariance&#34;. But Meyer thought that <a href="https://archive.eiffel.com/doc/manuals/technology/typing/paper/page.html" target="_blank">&#34;wasn&#39;t useful&#34;</a> and made method parameters <em>covariant</em>, replaceable with their <em>subtypes</em>. This makes the type system unsound.</p>
<p>They call this the &#34;CATcall&#34; problem and still haven&#39;t figured out how to fix it.<sup id="fnref:catcall"><a href="#fn:catcall">2</a></sup></p>
<p>So yeah, inheritance has problems. I mean of course there are cases where you can safely use it, and there are cases where it&#39;s the right choice, but it definitely shows signs of being a &#34;first-generation solution&#34;.</p>
<h2>Some thoughts on first-generation solutions</h2>
<p>Probably something bigger here worth exploring but that&#39;s getting further away from &#34;why inheritance&#34;, so I&#39;ll leave that for another newsletter. Cheers!</p>

                    
                

                
                    <p><em>If you&#39;re reading this on the web, you can subscribe <a href="https://buttondown.email/hillelwayne" target="_blank">here</a>. Updates are once a week. My main website is <a href="https://www.hillelwayne.com" target="_blank">here</a>.</em></p>
                

            </div></div>
  </body>
</html>
