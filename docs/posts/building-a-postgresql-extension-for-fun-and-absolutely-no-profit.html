<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.veitheller.de/Building_a_PostgreSQL_extension_for_fun_and_absolutely_no_profit.html">Original</a>
    <h1>Building a PostgreSQL extension for fun and absolutely no profit</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>A few months ago, <a href="https://github.com/hellerve/pg_ddate/">I
built my first PostgreSQL extension, <code>pg_ddate</code></a>. I mostly
wanted to learn how PostgreSQL extensions work, and make a simple but
feature-complete extensions with custom data types, operators, and all
the bells and whistles.</p>
<p>It worked quite well, and was extremely fun, so I decided to write up
a tutorial for all of you who want to do something like this
yourselves!</p>
<p>For the purposes of this blog post, I assume that you’re at least
somewhat comfortable with both C and SQL. We’ll explore why extensions
are fun and necessary, and build a loadable extension together that
defines a new data type and registers it and its operators, as well as a
custom helper function to get a full picture. I also won’t get into what
a Discordian date is, so <a href="https://en.wikipedia.org/wiki/Discordian_calendar">you might need
a quick primer</a>. It is the obviously correct data system.</p>
<p>A quick note on development setup: I use Docker for development
convenience, and the one I came up with <a href="https://github.com/hellerve-project-based-learning/pg_ddate/blob/main/Dockerfile">can
be found in the repo</a>.</p>
<h2 id="what-are-extensions-for-exactly">What are extensions for,
exactly?</h2>
<p><a href="https://www.postgresql.org/docs/current/extend-extensions.html">The
official PostgreSQL documentation on extensions</a> gives a little bit
of a primer on why extensions are useful and sometimes required, but
it’s mostly focused on the technical bits, so I thought I’d briefly
explain what an extension is and why we’d use one..</p>
<p>Extensions are packaged C-and-SQL artifacts that extend PostgreSQL
with functions and data types. While SQL itself is geared toward
defining data structures that fit well into a tabular structure, some
types require different handling. A custom date type like a Discordian
date is a prime example. We want these dates to behave exactly like
normal date types, including printing nicely, and being orderable and
castable to and from regular dates. This is probably achievable in SQL,
but packaging a new C data type is a bit easier, and it allows us to
ship all the algorithms around the data type in a language that is more
geared toward “regular” procedures than SQL.</p>
<p>Other extensions might not even ship custom types and instead be
focused around custom algorithms that are not easily expressible in SQL.
In a nutshell, extensions give us the raw algorithmic power of C
underneath our relational abstraction.</p>
<h2 id="building-an-extension">Building an extension</h2>
<p>Now that we’ve talked a bit about what an extension is and why we
might want one, let’s talk about how to build it. We will start with the
project structure that PostgreSQL imposes on us, and then gradually fill
it all out with code.</p>
<h3 id="making-a-scaffold">Making a scaffold</h3>
<p>Conceptually, we need three files<sup><a href="#1">1</a></sup>: a C
file, a SQL file, and a control file.</p>
<p>The control file just defines a bunch of metadata and can be largely
copy-pasted and forgotten about:</p>
<pre><code>comment = &#39;Discordian date type&#39;
default_version = &#39;1.0&#39;
module_pathname = &#39;$libdir/pg_ddate&#39;
relocatable = true</code></pre>
<p>The C and SQL files are where the magic happens. The SQL layer is
largely responsible for wiring up the types, functions, and operators
that we define. For now, we will only define an empty type inside
it:</p>
<pre><code>\echo Use &#34;CREATE EXTENSION pg_ddate&#34; to load this file. \quit

CREATE TYPE ddate;</code></pre>
<p>The C side defines the meat of the extension. A scaffold for it could
look like this:</p>
<pre><code>// these includes are all defined by postgres
#include &#34;postgres.h&#34;
#include &#34;fmgr.h&#34;
#include &#34;utils/builtins.h&#34;
#include &#34;utils/date.h&#34;
#include &#34;utils/datetime.h&#34;
#include &#34;utils/timestamp.h&#34;
#include &#34;libpq/pqformat.h&#34;

#include &lt;time.h&gt;
#include &lt;math.h&gt;

PG_MODULE_MAGIC;

typedef struct {
    int32 julian_day;
} DDate;</code></pre>
<p>We do not know how to pass things around yet, but we do have all the
pieces in place to get started.</p>
<h3 id="defining-a-type">Defining a type</h3>
<p>To define a full type in our extension, we will need to use <a href="https://www.postgresql.org/docs/current/sql-createtype.html"><code>CREATE TYPE</code></a>.
<code>CREATE TYPE</code> takes a whole range of different inputs, but
for our purposes we mostly need to tell PostgreSQL how to convert the
type to and from text (<code>input</code> and <code>output</code>) and
binary (<code>receive</code> and <code>send</code>), as well as the size
and alignment of our type.</p>
<p>The SQL to do so looks like this:</p>
<pre><code>CREATE OR REPLACE FUNCTION ddate_in(cstring)
RETURNS ddate
AS &#39;MODULE_PATHNAME&#39;
LANGUAGE C IMMUTABLE STRICT;

-- ... do the same for ddate_out, ddate_recv, and ddate_send ...

CREATE TYPE ddate (
    internallength = 4,
    input = ddate_in,
    output = ddate_out,
    receive = ddate_recv,
    send = ddate_send,
    alignment = int4,
    storage = plain
);</code></pre>
<p>This tells PostgreSQL that the length of the type is four bytes, its
alignment and storage type, and wires up the conversion functions.</p>
<p>So, how do these functions look like in C? Let’s start with the
string functions:</p>
<pre><code>PG_FUNCTION_INFO_V1(ddate_in);
Datum ddate_in(PG_FUNCTION_ARGS) {
    char *str = PG_GETARG_CSTRING(0);
    DDate *result;

    result = (DDate *) palloc(sizeof(DDate));

    result-&gt;julian_day = ddate_parse_from_str(str);

    PG_RETURN_POINTER(result);
}

PG_FUNCTION_INFO_V1(ddate_out);
Datum ddate_out(PG_FUNCTION_ARGS) {
    DDate *ddate = (DDate *) PG_GETARG_POINTER(0);
    char *result;

    result = (char *) palloc(128);
    ddate_write_to_str(ddate, result);

    PG_RETURN_CSTRING(result);
}</code></pre>
<p>The main bits that are interesting here is that we register the
function using <code>PG_FUNCTION_INFO_V1</code>, and then adhere to the
signature PostgreSQL expects: we return a <code>Datum</code> and take in
<code>PG_FUNCTION_ARGS</code>. We get to the actual arguments by using
the accessors provided by PostgreSQL (<code>PG_GETARG_CSTRING</code> and
<code>PG_GETARG_POINTER</code> in the above). When we return values, we
wrap those in similar macros. This might look scary at first, but it’s
actually very little ceremony for a foreign function interface, and it
reads pretty clearly!</p>
<p>The binary converters look quite similar:</p>
<pre><code>PG_FUNCTION_INFO_V1(ddate_recv);
Datum ddate_recv(PG_FUNCTION_ARGS) {
    StringInfo buf = (StringInfo) PG_GETARG_POINTER(0);
    DDate *result;

    result = (DDate *) palloc(sizeof(DDate));
    result-&gt;julian_day = pq_getmsgint(buf, sizeof(int32));

    PG_RETURN_POINTER(result);
}

PG_FUNCTION_INFO_V1(ddate_send);
Datum ddate_send(PG_FUNCTION_ARGS) {
    DDate *ddate = (DDate *) PG_GETARG_POINTER(0);
    StringInfoData buf;

    pq_begintypsend(&amp;buf);
    pq_sendint(&amp;buf, ddate-&gt;julian_day, sizeof(int32));

    PG_RETURN_BYTEA_P(pq_endtypsend(&amp;buf));
}</code></pre>
<p>The main difference here is that we need custom functions to actually
send and receive things, but if we squint it’s not too bad. As a note:
these two functions aren’t strictly necessary, but are required if we
want our data type to support the binary protocol.</p>
<p>And just like that we have a fully functional data type!</p>
<h3 id="adding-functions">Adding functions</h3>
<p>Now we’re ready to add functions. We’ll start with a normal one, then
we’ll add custom operators and casts to complete the picture.</p>
<p>Let’s start with <code>ddate_now()</code>, a function we can call in
SQL to get the current discordian date. In SQL, this is a trivial
addition:</p>
<pre><code>CREATE OR REPLACE FUNCTION ddate_now()
RETURNS ddate
AS &#39;MODULE_PATHNAME&#39;
LANGUAGE C STABLE;</code></pre>
<p>We just tell SQL that a function with that name exists, and we are
done!</p>
<p>The C side is not much scarier:</p>
<pre><code>PG_FUNCTION_INFO_V1(ddate_now);
Datum ddate_now(PG_FUNCTION_ARGS) {
    DateADT current_date;
    DDate *result;

    current_date = GetSQLCurrentDate();

    result = (DDate *) palloc(sizeof(DDate));
    result-&gt;julian_day = current_date + POSTGRES_EPOCH_JDATE;

    PG_RETURN_POINTER(result);
}</code></pre>
<p>We utilize the fact that we can already get the current date in
PostgreSQL’s C API, and just get the date from there. A relatively easy
addition, all in all.</p>
<p>Now that we’re practiced extension writes, let’s do some more
interesting things.</p>
<h4 id="customizing-our-operators">Customizing our operators</h4>
<p>Let’s add an equality operator and go from there. In SQL:</p>
<pre><code>CREATE OR REPLACE FUNCTION ddate_eq(ddate, ddate)
RETURNS boolean
AS &#39;MODULE_PATHNAME&#39;
LANGUAGE C IMMUTABLE STRICT;

CREATE OPERATOR = (
    leftarg = ddate,
    rightarg = ddate,
    procedure = ddate_eq,
    commutator = =,
    negator = &lt;&gt;,
    restrict = eqsel,
    join = eqjoinsel,
    hashes,
    merges
);</code></pre>
<p>We only need to register an equality function and we are able to
register our operator. Quite nice!</p>
<p>C is even easier, facilitated by the fact that we’re dealing with
comparable types already:</p>
<pre><code>PG_FUNCTION_INFO_V1(ddate_eq);
Datum ddate_eq(PG_FUNCTION_ARGS) {
    DDate *date1 = (DDate *) PG_GETARG_POINTER(0);
    DDate *date2 = (DDate *) PG_GETARG_POINTER(1);

    PG_RETURN_BOOL(date1-&gt;julian_day == date2-&gt;julian_day);
}</code></pre>
<p>All we need to do is get the date arguments and compare them! This
means that defining operators, while sounding scary, becomes mostly busy
work. We need to do this somewhat boring work for all operators
separately. Once we have that, however, we can even register our type as
an operator class for b-tree:</p>
<pre><code>CREATE OPERATOR CLASS ddate_ops
DEFAULT FOR TYPE ddate USING btree AS
    OPERATOR 1 &lt;,
    OPERATOR 2 &lt;=,
    OPERATOR 3 =,
    OPERATOR 4 &gt;=,
    OPERATOR 5 &gt;,
    FUNCTION 1 ddate_cmp(ddate, ddate);</code></pre>
<p>The most interesting operator is probably <code>~</code>, which
performs regex match. Check it out if this blog post has whet your
appetite (<a href="https://github.com/hellerve-project-based-learning/pg_ddate/blob/4338b04a3a6fd23ecb0902ab5fbc001c75221122/pg_ddate.c#L310-L327">C</a>,
<a href="https://github.com/hellerve-project-based-learning/pg_ddate/blob/4338b04a3a6fd23ecb0902ab5fbc001c75221122/pg_ddate--1.0.sql#L159-L170">SQL</a>).</p>
<h4 id="adding-casts">Adding casts</h4>
<p>Finally, we define some casts from dates to discordian dates. Let’s
start with C this time, since it contains all things you know
already:</p>
<pre><code>PG_FUNCTION_INFO_V1(date_to_ddate);
Datum date_to_ddate(PG_FUNCTION_ARGS) {
    DateADT date = PG_GETARG_DATEADT(0);
    DDate *result;

    result = (DDate *) palloc(sizeof(DDate));
    result-&gt;julian_day = date + POSTGRES_EPOCH_JDATE;

    PG_RETURN_POINTER(result);
}

PG_FUNCTION_INFO_V1(ddate_to_date);
Datum ddate_to_date(PG_FUNCTION_ARGS) {
    DDate *ddate = (DDate *) PG_GETARG_POINTER(0);
    DateADT result;

    result = ddate-&gt;julian_day - POSTGRES_EPOCH_JDATE;

    PG_RETURN_DATEADT(result);
}</code></pre>
<p>At this point, all of this should be familiar to you. The functions
follow the usual structure, the only new additions are
<code>PG_*_DATEADT</code>, which get and return date types,
respectively.</p>
<p>On the SQL side, the addition is also quite simple:</p>
<pre><code>CREATE CAST (date AS ddate) WITH FUNCTION date_to_ddate(date) AS IMPLICIT;
CREATE CAST (ddate AS date) WITH FUNCTION ddate_to_date(ddate) AS IMPLICIT;</code></pre>
<p>We tell PostgreSQL how to cast dates to ddates and vice versa, and we
allow for implicit casts, type safety be damned.</p>
<p>And that’s it! You’ve just built a full data type for PostgreSQL,
including all manner of quite advanced functionality such as b-tree
indexing, casts, and operators!</p>
<h2 id="fin">Fin</h2>
<p>I hope this post made it clear to you just how delightful I find the
PostgreSQL extension API. It is one of the least intrusive APIs that
doesn’t get in the way while being powerful and straddling the gap
between the higher and lower levels of the database effortlessly.
Honestly, I was quite in awe.</p>
<p>The truth of the matter, however, is that most of us will never or
very rarely need to write PostgreSQL extensions, so we won’t get to play
with the API. Truth be told: most of the time it’s probably a bad idea.
I hope this blog post comes in handy for you in the rare cases where it
isn’t.</p>

<p><span id="1">1.</span> In reality, we also need a Makefile that uses
<a href="https://www.postgresql.org/docs/current/extend-pgxs.html">PGXS</a>,
but I will omit that for the purposes of this post, since building the
extension is a minor concern. If you are truly interested, check <a href="https://github.com/hellerve-project-based-learning/pg_ddate/blob/main/Makefile">the
Makefile in the repository</a>.</p>

      
    </div></div>
  </body>
</html>
