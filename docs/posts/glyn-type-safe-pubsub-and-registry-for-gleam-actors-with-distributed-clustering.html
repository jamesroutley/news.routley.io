<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/mbuhot/glyn">Original</a>
    <h1>Glyn: Type-safe PubSub and Registry for Gleam actors with distributed clustering</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><a href="https://hex.pm/packages/glyn" rel="nofollow"><img src="https://camo.githubusercontent.com/bf8e9fc802eda12f522310d5f9871290d28426d1b2646bfc9a398e7bf91007d3/68747470733a2f2f696d672e736869656c64732e696f2f686578706d2f762f676c796e" alt="Package Version" data-canonical-src="https://img.shields.io/hexpm/v/glyn"/></a>
<a href="https://hexdocs.pm/glyn/" rel="nofollow"><img src="https://camo.githubusercontent.com/4bb6f0346c92c97533ee101eb333cf8ab3c7c7285aa966aed1ba529e055f398b/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6865782d646f63732d666661666633" alt="Hex Docs" data-canonical-src="https://img.shields.io/badge/hex-docs-ffaff3"/></a></p>
<p dir="auto"><strong>Type-safe PubSub and Registry for Gleam actors with distributed clustering support.</strong></p>
<p dir="auto">Built on the Erlang <a href="https://github.com/ostinelli/syn">syn</a> library.</p>
<p dir="auto">Glyn provides two complementary systems for actor communication:</p>
<ul dir="auto">
<li><strong>PubSub</strong>: Broadcast events to multiple subscribers</li>
<li><strong>Registry</strong>: Direct command routing to named processes</li>
</ul>
<p dir="auto">Both systems integrate seamlessly with Gleam&#39;s actor model using selector composition patterns.</p>


<div dir="auto"><h2 tabindex="-1" dir="auto">Creating Message Types and Decoders</h2><a id="user-content-creating-message-types-and-decoders" aria-label="Permalink: Creating Message Types and Decoders" href="#creating-message-types-and-decoders"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">First, define your message types and corresponding decoder functions.
Explicit decoders are required to ensure messages sent between nodes in a cluster are handled with type safety.
Note the Glyn does not JSON encode messages, they are sent directly as erlang terms and should be decoded from tuples.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// my_app/orders.gleam
import gleam/dynamic.{type Dynamic}
import gleam/dynamic/decode
import gleam/erlang/process.{type Subject}

// Define your message types
pub type Event {
  OrderCreated(id: String, amount: Int)
  OrderShipped(id: String, tracking: String)
  SystemAlert(message: String)
}

pub type Command {
  ProcessOrder(id: String, reply_with: Subject(Bool))
  GetStatus(reply_with: Subject(String))
  Shutdown
}

// Helper function to match specific atoms
fn expect_atom(expected: String) -&gt; decode.Decoder(atom.Atom) {
  use value &lt;- decode.then(atom.decoder())
  case atom.to_string(value) == expected {
    True -&gt; decode.success(value)
    False -&gt; decode.failure(value, &#34;Expected atom: &#34; &lt;&gt; expected)
  }
}

// Unsafe cast for Subject decoding - use with caution
@external(erlang, &#34;gleam_stdlib&#34;, &#34;identity&#34;)
fn unsafe_cast_subject(value: Dynamic) -&gt; Subject(a)

// Create decoder functions
pub fn event_decoder() -&gt; decode.Decoder(Event) {
  decode.one_of(
    {
      use _ &lt;- decode.field(0, expect_atom(&#34;order_created&#34;))
      use id &lt;- decode.field(1, decode.string)
      use amount &lt;- decode.field(2, decode.int)
      decode.success(OrderCreated(id, amount))
    },
    or: [
      {
        use _ &lt;- decode.field(0, expect_atom(&#34;order_shipped&#34;))
        use id &lt;- decode.field(1, decode.string)
        use tracking &lt;- decode.field(2, decode.string)
        decode.success(OrderShipped(id, tracking))
      },
      {
        use _ &lt;- decode.field(0, expect_atom(&#34;system_alert&#34;))
        use message &lt;- decode.field(1, decode.string)
        decode.success(SystemAlert(message))
      },
    ]
  )
}

pub fn command_decoder() -&gt; decode.Decoder(Command) {
  decode.one_of(
    // Shutdown is a simple variant - encoded as bare atom
    decode.map(expect_atom(&#34;shutdown&#34;), fn(_) { Shutdown }),
    or: [
      // ProcessOrder has data - encoded as tuple
      {
        use _ &lt;- decode.field(0, expect_atom(&#34;process_order&#34;))
        use id &lt;- decode.field(1, decode.string)
        use reply_with &lt;- decode.field(2, decode.dynamic)
        decode.success(ProcessOrder(id, unsafe_cast_subject(reply_with)))
      },
      // GetStatus has data - encoded as tuple
      {
        use _ &lt;- decode.field(0, expect_atom(&#34;get_status&#34;))
        use reply_with &lt;- decode.field(1, decode.dynamic)
        decode.success(GetStatus(unsafe_cast_subject(reply_with)))
      },
    ]
  )
}"><pre><span>// my_app/orders.gleam</span>
<span>import</span> <span>gleam/dynamic</span><span>.</span><span>{</span><span>type</span> <span>Dynamic</span><span>}</span>
<span>import</span> <span>gleam/dynamic/decode</span>
<span>import</span> <span>gleam/erlang/process</span><span>.</span><span>{</span><span>type</span> <span>Subject</span><span>}</span>

<span>// Define your message types</span>
<span>pub</span> <span>type</span> <span>Event</span> <span>{</span>
  <span>OrderCreated</span><span>(</span><span>id</span><span>:</span> <span>String</span><span>,</span> <span>amount</span><span>:</span> <span>Int</span><span>)</span>
  <span>OrderShipped</span><span>(</span><span>id</span><span>:</span> <span>String</span><span>,</span> <span>tracking</span><span>:</span> <span>String</span><span>)</span>
  <span>SystemAlert</span><span>(</span><span>message</span><span>:</span> <span>String</span><span>)</span>
<span>}</span>

<span>pub</span> <span>type</span> <span>Command</span> <span>{</span>
  <span>ProcessOrder</span><span>(</span><span>id</span><span>:</span> <span>String</span><span>,</span> <span>reply_with</span><span>:</span> <span>Subject</span><span>(</span><span>Bool</span><span>)</span><span>)</span>
  <span>GetStatus</span><span>(</span><span>reply_with</span><span>:</span> <span>Subject</span><span>(</span><span>String</span><span>)</span><span>)</span>
  <span>Shutdown</span>
<span>}</span>

<span>// Helper function to match specific atoms</span>
<span>fn</span> <span>expect_atom</span><span>(</span><span>expected</span><span>:</span> <span>String</span><span>)</span> <span>-&gt;</span> <span><span>decode</span><span>.</span><span>Decoder</span></span><span>(</span><span><span>atom</span><span>.</span><span>Atom</span></span><span>)</span> <span>{</span>
  <span>use</span> <span>value</span> <span>&lt;-</span> <span>decode</span><span>.</span><span>then</span><span>(</span><span>atom</span><span>.</span><span>decoder</span><span>(</span><span>)</span><span>)</span>
  <span>case</span> <span>atom</span><span>.</span><span>to_string</span><span>(</span><span>value</span><span>)</span> <span>==</span> <span>expected</span> <span>{</span>
    <span>True</span> <span>-&gt;</span> <span>decode</span><span>.</span><span>success</span><span>(</span><span>value</span><span>)</span>
    <span>False</span> <span>-&gt;</span> <span>decode</span><span>.</span><span>failure</span><span>(</span><span>value</span><span>,</span> <span>&#34;Expected atom: &#34;</span> <span>&lt;&gt;</span> <span>expected</span><span>)</span>
  <span>}</span>
<span>}</span>

<span>// Unsafe cast for Subject decoding - use with caution</span>
<span>@</span><span>external</span><span>(</span><span>erlang</span><span>,</span> <span>&#34;gleam_stdlib&#34;</span><span>,</span> <span>&#34;identity&#34;</span><span>)</span>
<span>fn</span> <span>unsafe_cast_subject</span><span>(</span><span>value</span><span>:</span> <span>Dynamic</span><span>)</span> <span>-&gt;</span> <span>Subject</span><span>(</span>a<span>)</span>

<span>// Create decoder functions</span>
<span>pub</span> <span>fn</span> <span>event_decoder</span><span>(</span><span>)</span> <span>-&gt;</span> <span><span>decode</span><span>.</span><span>Decoder</span></span><span>(</span><span>Event</span><span>)</span> <span>{</span>
  <span>decode</span><span>.</span><span>one_of</span><span>(</span>
    <span>{</span>
      <span>use</span> <span>_</span> <span>&lt;-</span> <span>decode</span><span>.</span><span>field</span><span>(</span><span>0</span><span>,</span> <span>expect_atom</span><span>(</span><span>&#34;order_created&#34;</span><span>)</span><span>)</span>
      <span>use</span> <span>id</span> <span>&lt;-</span> <span>decode</span><span>.</span><span>field</span><span>(</span><span>1</span><span>,</span> <span>decode</span><span>.</span><span>string</span><span>)</span>
      <span>use</span> <span>amount</span> <span>&lt;-</span> <span>decode</span><span>.</span><span>field</span><span>(</span><span>2</span><span>,</span> <span>decode</span><span>.</span><span>int</span><span>)</span>
      <span>decode</span><span>.</span><span>success</span><span>(</span><span>OrderCreated</span><span>(</span><span>id</span><span>,</span> <span>amount</span><span>)</span><span>)</span>
    <span>}</span><span>,</span>
    <span>or</span><span>:</span> <span>[</span>
      <span>{</span>
        <span>use</span> <span>_</span> <span>&lt;-</span> <span>decode</span><span>.</span><span>field</span><span>(</span><span>0</span><span>,</span> <span>expect_atom</span><span>(</span><span>&#34;order_shipped&#34;</span><span>)</span><span>)</span>
        <span>use</span> <span>id</span> <span>&lt;-</span> <span>decode</span><span>.</span><span>field</span><span>(</span><span>1</span><span>,</span> <span>decode</span><span>.</span><span>string</span><span>)</span>
        <span>use</span> <span>tracking</span> <span>&lt;-</span> <span>decode</span><span>.</span><span>field</span><span>(</span><span>2</span><span>,</span> <span>decode</span><span>.</span><span>string</span><span>)</span>
        <span>decode</span><span>.</span><span>success</span><span>(</span><span>OrderShipped</span><span>(</span><span>id</span><span>,</span> <span>tracking</span><span>)</span><span>)</span>
      <span>}</span><span>,</span>
      <span>{</span>
        <span>use</span> <span>_</span> <span>&lt;-</span> <span>decode</span><span>.</span><span>field</span><span>(</span><span>0</span><span>,</span> <span>expect_atom</span><span>(</span><span>&#34;system_alert&#34;</span><span>)</span><span>)</span>
        <span>use</span> <span>message</span> <span>&lt;-</span> <span>decode</span><span>.</span><span>field</span><span>(</span><span>1</span><span>,</span> <span>decode</span><span>.</span><span>string</span><span>)</span>
        <span>decode</span><span>.</span><span>success</span><span>(</span><span>SystemAlert</span><span>(</span><span>message</span><span>)</span><span>)</span>
      <span>}</span><span>,</span>
    <span>]</span>
  <span>)</span>
<span>}</span>

<span>pub</span> <span>fn</span> <span>command_decoder</span><span>(</span><span>)</span> <span>-&gt;</span> <span><span>decode</span><span>.</span><span>Decoder</span></span><span>(</span><span>Command</span><span>)</span> <span>{</span>
  <span>decode</span><span>.</span><span>one_of</span><span>(</span>
    <span>// Shutdown is a simple variant - encoded as bare atom</span>
    <span>decode</span><span>.</span><span>map</span><span>(</span><span>expect_atom</span><span>(</span><span>&#34;shutdown&#34;</span><span>)</span><span>,</span> <span>fn</span><span>(</span><span>_</span><span>)</span> <span>{</span> <span>Shutdown</span> <span>}</span><span>)</span><span>,</span>
    <span>or</span><span>:</span> <span>[</span>
      <span>// ProcessOrder has data - encoded as tuple</span>
      <span>{</span>
        <span>use</span> <span>_</span> <span>&lt;-</span> <span>decode</span><span>.</span><span>field</span><span>(</span><span>0</span><span>,</span> <span>expect_atom</span><span>(</span><span>&#34;process_order&#34;</span><span>)</span><span>)</span>
        <span>use</span> <span>id</span> <span>&lt;-</span> <span>decode</span><span>.</span><span>field</span><span>(</span><span>1</span><span>,</span> <span>decode</span><span>.</span><span>string</span><span>)</span>
        <span>use</span> <span>reply_with</span> <span>&lt;-</span> <span>decode</span><span>.</span><span>field</span><span>(</span><span>2</span><span>,</span> <span>decode</span><span>.</span><span>dynamic</span><span>)</span>
        <span>decode</span><span>.</span><span>success</span><span>(</span><span>ProcessOrder</span><span>(</span><span>id</span><span>,</span> <span>unsafe_cast_subject</span><span>(</span><span>reply_with</span><span>)</span><span>)</span><span>)</span>
      <span>}</span><span>,</span>
      <span>// GetStatus has data - encoded as tuple</span>
      <span>{</span>
        <span>use</span> <span>_</span> <span>&lt;-</span> <span>decode</span><span>.</span><span>field</span><span>(</span><span>0</span><span>,</span> <span>expect_atom</span><span>(</span><span>&#34;get_status&#34;</span><span>)</span><span>)</span>
        <span>use</span> <span>reply_with</span> <span>&lt;-</span> <span>decode</span><span>.</span><span>field</span><span>(</span><span>1</span><span>,</span> <span>decode</span><span>.</span><span>dynamic</span><span>)</span>
        <span>decode</span><span>.</span><span>success</span><span>(</span><span>GetStatus</span><span>(</span><span>unsafe_cast_subject</span><span>(</span><span>reply_with</span><span>)</span><span>)</span><span>)</span>
      <span>}</span><span>,</span>
    <span>]</span>
  <span>)</span>
<span>}</span></pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="import glyn/pubsub
import my_app/orders
import gleam/erlang/process

pub fn main() {
  // Create PubSub system with decoder
  let pubsub = pubsub.new(
    &#34;orders&#34;,
    orders.event_decoder(),
  )

  // Subscribe returns a Selector that can be composed
  let selector =
    process.new_selector()
    |&gt; process.merge_selector(
      pubsub.subscribe(pubsub, &#34;processing&#34;)
      |&gt; process.map_selector(OrderEvent)
    )

  // Publish events
  let assert Ok(Nil) = pubsub.publish(pubsub, &#34;processing&#34;,
    orders.OrderCreated(&#34;ORDER123&#34;, 99))

  // Receive messages through selector
  let assert Ok(OrderEvent(orders.OrderCreated(id, amount))) =
    process.selector_receive(selector, 100)
}"><pre><span>import</span> <span>glyn/pubsub</span>
<span>import</span> <span>my_app/orders</span>
<span>import</span> <span>gleam/erlang/process</span>

<span>pub</span> <span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
  <span>// Create PubSub system with decoder</span>
  <span>let</span> <span>pubsub</span> <span>=</span> <span>pubsub</span><span>.</span><span>new</span><span>(</span>
    <span>&#34;orders&#34;</span><span>,</span>
    <span>orders</span><span>.</span><span>event_decoder</span><span>(</span><span>)</span><span>,</span>
  <span>)</span>

  <span>// Subscribe returns a Selector that can be composed</span>
  <span>let</span> <span>selector</span> <span>=</span>
    <span>process</span><span>.</span><span>new_selector</span><span>(</span><span>)</span>
    <span>|&gt;</span> <span>process</span><span>.</span><span>merge_selector</span><span>(</span>
      <span>pubsub</span><span>.</span><span>subscribe</span><span>(</span><span>pubsub</span><span>,</span> <span>&#34;processing&#34;</span><span>)</span>
      <span>|&gt;</span> <span>process</span><span>.</span><span>map_selector</span><span>(</span><span>OrderEvent</span><span>)</span>
    <span>)</span>

  <span>// Publish events</span>
  <span>let</span> <span>assert</span> <span>Ok</span><span>(</span><span>Nil</span><span>)</span> <span>=</span> <span>pubsub</span><span>.</span><span>publish</span><span>(</span><span>pubsub</span><span>,</span> <span>&#34;processing&#34;</span><span>,</span>
    <span>orders</span><span>.</span><span>OrderCreated</span><span>(</span><span>&#34;ORDER123&#34;</span><span>,</span> <span>99</span><span>)</span><span>)</span>

  <span>// Receive messages through selector</span>
  <span>let</span> <span>assert</span> <span>Ok</span><span>(</span><span>OrderEvent</span><span>(</span><span>orders</span><span>.</span><span>OrderCreated</span><span>(</span><span>id</span><span>,</span> <span>amount</span><span>)</span><span>)</span><span>)</span> <span>=</span>
    <span>process</span><span>.</span><span>selector_receive</span><span>(</span><span>selector</span><span>,</span> <span>100</span><span>)</span>
<span>}</span></pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="import glyn/registry
import my_app/orders  // Using same orders module from above
import gleam/erlang/process.{type Subject}

pub fn main() {
  // Create Registry system with decoder and error default
  let registry = registry.new(
    &#34;orders&#34;,
    orders.command_decoder(),
    orders.Shutdown
  )

  // Register returns a Selector for receiving commands
  let assert Ok(command_selector) = registry.register(registry, &#34;order_processor&#34;, &#34;v1.0&#34;)

  // Compose with other selectors
  let selector =
    process.new_selector()
    |&gt; process.merge_selector(
      process.map_selector(command_selector, UserCommand)
    )

  // Send commands to registered processes
  let assert Ok(_) = registry.send(registry, &#34;order_processor&#34;,
    orders.ProcessOrder(&#34;ORDER123&#34;, process.new_subject()))

  // Or use call for request/reply pattern
  let assert Ok(status) = registry.call(registry, &#34;order_processor&#34;, waiting: 1000,
    sending: fn(reply) { orders.GetStatus(reply) })
}"><pre><span>import</span> <span>glyn/registry</span>
<span>import</span> <span>my_app/orders</span>  <span>// Using same orders module from above</span>
<span>import</span> <span>gleam/erlang/process</span><span>.</span><span>{</span><span>type</span> <span>Subject</span><span>}</span>

<span>pub</span> <span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
  <span>// Create Registry system with decoder and error default</span>
  <span>let</span> <span>registry</span> <span>=</span> <span>registry</span><span>.</span><span>new</span><span>(</span>
    <span>&#34;orders&#34;</span><span>,</span>
    <span>orders</span><span>.</span><span>command_decoder</span><span>(</span><span>)</span><span>,</span>
    <span>orders</span><span>.</span><span>Shutdown</span>
  <span>)</span>

  <span>// Register returns a Selector for receiving commands</span>
  <span>let</span> <span>assert</span> <span>Ok</span><span>(</span><span>command_selector</span><span>)</span> <span>=</span> <span>registry</span><span>.</span><span>register</span><span>(</span><span>registry</span><span>,</span> <span>&#34;order_processor&#34;</span><span>,</span> <span>&#34;v1.0&#34;</span><span>)</span>

  <span>// Compose with other selectors</span>
  <span>let</span> <span>selector</span> <span>=</span>
    <span>process</span><span>.</span><span>new_selector</span><span>(</span><span>)</span>
    <span>|&gt;</span> <span>process</span><span>.</span><span>merge_selector</span><span>(</span>
      <span>process</span><span>.</span><span>map_selector</span><span>(</span><span>command_selector</span><span>,</span> <span>UserCommand</span><span>)</span>
    <span>)</span>

  <span>// Send commands to registered processes</span>
  <span>let</span> <span>assert</span> <span>Ok</span><span>(</span><span>_</span><span>)</span> <span>=</span> <span>registry</span><span>.</span><span>send</span><span>(</span><span>registry</span><span>,</span> <span>&#34;order_processor&#34;</span><span>,</span>
    <span>orders</span><span>.</span><span>ProcessOrder</span><span>(</span><span>&#34;ORDER123&#34;</span><span>,</span> <span>process</span><span>.</span><span>new_subject</span><span>(</span><span>)</span><span>)</span><span>)</span>

  <span>// Or use call for request/reply pattern</span>
  <span>let</span> <span>assert</span> <span>Ok</span><span>(</span><span>status</span><span>)</span> <span>=</span> <span>registry</span><span>.</span><span>call</span><span>(</span><span>registry</span><span>,</span> <span>&#34;order_processor&#34;</span><span>,</span> <span>waiting</span><span>:</span> <span>1000</span><span>,</span>
    <span>sending</span><span>:</span> <span>fn</span><span>(</span><span>reply</span><span>)</span> <span>{</span> <span>orders</span><span>.</span><span>GetStatus</span><span>(</span><span>reply</span><span>)</span> <span>}</span><span>)</span>
<span>}</span></pre></div>
<div dir="auto"><h2 tabindex="-1" dir="auto">Multi-Channel Actor Integration</h2><a id="user-content-multi-channel-actor-integration" aria-label="Permalink: Multi-Channel Actor Integration" href="#multi-channel-actor-integration"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The real power of Gleam&#39;s typed actor system comes from composing multiple message channels in a single actor:</p>
<div dir="auto" data-snippet-clipboard-copy-content="import glyn/pubsub
import glyn/registry
import my_app/orders  // Using the orders module we defined above
import gleam/erlang/process.{type Subject}
import gleam/otp/actor

// Actor message type that composes multiple channels
pub type ProcessorMessage {
  DirectCommand(DirectMessage)  // Direct actor commands
  OrderCommand(orders.Command)  // Registry commands
  OrderEvent(orders.Event)      // PubSub events
  Shutdown
}

pub type DirectMessage {
  GetStats(reply_with: Subject(String))
  Reset
}

pub fn start_order_processor() {
  actor.new_with_initialiser(5000, fn(subject) {
    // Create PubSub and Registry systems
    let event_pubsub = pubsub.new(
      &#34;events&#34;,
      orders.event_decoder(),
    )

    let command_registry = registry.new(
      &#34;commands&#34;,
      orders.command_decoder(),
      orders.Shutdown
    )

    // Get selectors from both systems
    let event_selector = pubsub.subscribe(event_pubsub, &#34;orders&#34;)
    let assert Ok(command_selector) = registry.register(command_registry, &#34;order_processor&#34;, &#34;v1.0&#34;)

    // Create direct command channel
    let direct_subject = process.new_subject()

    // Compose all channels using selectors
    let selector =
      process.new_selector()
      |&gt; process.select(subject)
      |&gt; process.select_map(direct_subject, DirectCommand)
      |&gt; process.merge_selector(process.map_selector(command_selector, OrderCommand))
      |&gt; process.merge_selector(process.map_selector(event_selector, OrderEvent))

    // Return initialized actor
    actor.initialised(ProcessorState(status: &#34;ready&#34;, processed: 0))
    |&gt; actor.selecting(selector)
    |&gt; actor.returning(direct_subject)  // Return direct command interface
    |&gt; Ok
  })
  |&gt; actor.on_message(handle_processor_message)
  |&gt; actor.start()
}

fn handle_processor_message(state, message) {
  case message {
    OrderCommand(orders.ProcessOrder(id, reply_with)) -&gt; {
      // Handle registry command
      process.send(reply_with, True)
      actor.continue(ProcessorState(..state, processed: state.processed + 1))
    }
    OrderCommand(orders.GetStatus(reply_with)) -&gt; {
      // Return status
      process.send(reply_with, state.status)
      actor.continue(state)
    }
    OrderEvent(orders.OrderCreated(id, amount)) -&gt; {
      // React to PubSub event
      actor.continue(ProcessorState(..state, status: &#34;Processing order &#34; &lt;&gt; id))
    }
    OrderEvent(orders.SystemAlert(message)) -&gt; {
      // Handle system-wide alerts
      actor.continue(ProcessorState(..state, status: &#34;Alert: &#34; &lt;&gt; message))
    }
    DirectCommand(user_command) -&gt; {
      // Handle direct commands
      actor.continue(state)
    }
    Shutdown -&gt; {
      actor.stop()
    }
  }
}"><pre><span>import</span> <span>glyn/pubsub</span>
<span>import</span> <span>glyn/registry</span>
<span>import</span> <span>my_app/orders</span>  <span>// Using the orders module we defined above</span>
<span>import</span> <span>gleam/erlang/process</span><span>.</span><span>{</span><span>type</span> <span>Subject</span><span>}</span>
<span>import</span> <span>gleam/otp/actor</span>

<span>// Actor message type that composes multiple channels</span>
<span>pub</span> <span>type</span> <span>ProcessorMessage</span> <span>{</span>
  <span>DirectCommand</span><span>(</span><span>DirectMessage</span><span>)</span>  <span>// Direct actor commands</span>
  <span>OrderCommand</span><span>(</span><span><span>orders</span><span>.</span><span>Command</span></span><span>)</span>  <span>// Registry commands</span>
  <span>OrderEvent</span><span>(</span><span><span>orders</span><span>.</span><span>Event</span></span><span>)</span>      <span>// PubSub events</span>
  <span>Shutdown</span>
<span>}</span>

<span>pub</span> <span>type</span> <span>DirectMessage</span> <span>{</span>
  <span>GetStats</span><span>(</span><span>reply_with</span><span>:</span> <span>Subject</span><span>(</span><span>String</span><span>)</span><span>)</span>
  <span>Reset</span>
<span>}</span>

<span>pub</span> <span>fn</span> <span>start_order_processor</span><span>(</span><span>)</span> <span>{</span>
  <span>actor</span><span>.</span><span>new_with_initialiser</span><span>(</span><span>5000</span><span>,</span> <span>fn</span><span>(</span><span>subject</span><span>)</span> <span>{</span>
    <span>// Create PubSub and Registry systems</span>
    <span>let</span> <span>event_pubsub</span> <span>=</span> <span>pubsub</span><span>.</span><span>new</span><span>(</span>
      <span>&#34;events&#34;</span><span>,</span>
      <span>orders</span><span>.</span><span>event_decoder</span><span>(</span><span>)</span><span>,</span>
    <span>)</span>

    <span>let</span> <span>command_registry</span> <span>=</span> <span>registry</span><span>.</span><span>new</span><span>(</span>
      <span>&#34;commands&#34;</span><span>,</span>
      <span>orders</span><span>.</span><span>command_decoder</span><span>(</span><span>)</span><span>,</span>
      <span>orders</span><span>.</span><span>Shutdown</span>
    <span>)</span>

    <span>// Get selectors from both systems</span>
    <span>let</span> <span>event_selector</span> <span>=</span> <span>pubsub</span><span>.</span><span>subscribe</span><span>(</span><span>event_pubsub</span><span>,</span> <span>&#34;orders&#34;</span><span>)</span>
    <span>let</span> <span>assert</span> <span>Ok</span><span>(</span><span>command_selector</span><span>)</span> <span>=</span> <span>registry</span><span>.</span><span>register</span><span>(</span><span>command_registry</span><span>,</span> <span>&#34;order_processor&#34;</span><span>,</span> <span>&#34;v1.0&#34;</span><span>)</span>

    <span>// Create direct command channel</span>
    <span>let</span> <span>direct_subject</span> <span>=</span> <span>process</span><span>.</span><span>new_subject</span><span>(</span><span>)</span>

    <span>// Compose all channels using selectors</span>
    <span>let</span> <span>selector</span> <span>=</span>
      <span>process</span><span>.</span><span>new_selector</span><span>(</span><span>)</span>
      <span>|&gt;</span> <span>process</span><span>.</span><span>select</span><span>(</span><span>subject</span><span>)</span>
      <span>|&gt;</span> <span>process</span><span>.</span><span>select_map</span><span>(</span><span>direct_subject</span><span>,</span> <span>DirectCommand</span><span>)</span>
      <span>|&gt;</span> <span>process</span><span>.</span><span>merge_selector</span><span>(</span><span>process</span><span>.</span><span>map_selector</span><span>(</span><span>command_selector</span><span>,</span> <span>OrderCommand</span><span>)</span><span>)</span>
      <span>|&gt;</span> <span>process</span><span>.</span><span>merge_selector</span><span>(</span><span>process</span><span>.</span><span>map_selector</span><span>(</span><span>event_selector</span><span>,</span> <span>OrderEvent</span><span>)</span><span>)</span>

    <span>// Return initialized actor</span>
    <span>actor</span><span>.</span><span>initialised</span><span>(</span><span>ProcessorState</span><span>(</span><span>status</span><span>:</span> <span>&#34;ready&#34;</span><span>,</span> <span>processed</span><span>:</span> <span>0</span><span>)</span><span>)</span>
    <span>|&gt;</span> <span>actor</span><span>.</span><span>selecting</span><span>(</span><span>selector</span><span>)</span>
    <span>|&gt;</span> <span>actor</span><span>.</span><span>returning</span><span>(</span><span>direct_subject</span><span>)</span>  <span>// Return direct command interface</span>
    <span>|&gt;</span> <span>Ok</span>
  <span>}</span><span>)</span>
  <span>|&gt;</span> <span>actor</span><span>.</span><span>on_message</span><span>(</span><span>handle_processor_message</span><span>)</span>
  <span>|&gt;</span> <span>actor</span><span>.</span><span>start</span><span>(</span><span>)</span>
<span>}</span>

<span>fn</span> <span>handle_processor_message</span><span>(</span><span>state</span><span>,</span> <span>message</span><span>)</span> <span>{</span>
  <span>case</span> <span>message</span> <span>{</span>
    <span>OrderCommand</span><span>(</span><span>orders</span><span>.</span><span>ProcessOrder</span><span>(</span><span>id</span><span>,</span> <span>reply_with</span><span>)</span><span>)</span> <span>-&gt;</span> <span>{</span>
      <span>// Handle registry command</span>
      <span>process</span><span>.</span><span>send</span><span>(</span><span>reply_with</span><span>,</span> <span>True</span><span>)</span>
      <span>actor</span><span>.</span><span>continue</span><span>(</span><span>ProcessorState</span><span>(</span><span>..</span><span>state</span><span>,</span> <span>processed</span><span>:</span> <span>state</span><span>.</span><span>processed</span> <span>+</span> <span>1</span><span>)</span><span>)</span>
    <span>}</span>
    <span>OrderCommand</span><span>(</span><span>orders</span><span>.</span><span>GetStatus</span><span>(</span><span>reply_with</span><span>)</span><span>)</span> <span>-&gt;</span> <span>{</span>
      <span>// Return status</span>
      <span>process</span><span>.</span><span>send</span><span>(</span><span>reply_with</span><span>,</span> <span>state</span><span>.</span><span>status</span><span>)</span>
      <span>actor</span><span>.</span><span>continue</span><span>(</span><span>state</span><span>)</span>
    <span>}</span>
    <span>OrderEvent</span><span>(</span><span>orders</span><span>.</span><span>OrderCreated</span><span>(</span><span>id</span><span>,</span> <span>amount</span><span>)</span><span>)</span> <span>-&gt;</span> <span>{</span>
      <span>// React to PubSub event</span>
      <span>actor</span><span>.</span><span>continue</span><span>(</span><span>ProcessorState</span><span>(</span><span>..</span><span>state</span><span>,</span> <span>status</span><span>:</span> <span>&#34;Processing order &#34;</span> <span>&lt;&gt;</span> <span>id</span><span>)</span><span>)</span>
    <span>}</span>
    <span>OrderEvent</span><span>(</span><span>orders</span><span>.</span><span>SystemAlert</span><span>(</span><span>message</span><span>)</span><span>)</span> <span>-&gt;</span> <span>{</span>
      <span>// Handle system-wide alerts</span>
      <span>actor</span><span>.</span><span>continue</span><span>(</span><span>ProcessorState</span><span>(</span><span>..</span><span>state</span><span>,</span> <span>status</span><span>:</span> <span>&#34;Alert: &#34;</span> <span>&lt;&gt;</span> <span>message</span><span>)</span><span>)</span>
    <span>}</span>
    <span>DirectCommand</span><span>(</span><span>user_command</span><span>)</span> <span>-&gt;</span> <span>{</span>
      <span>// Handle direct commands</span>
      <span>actor</span><span>.</span><span>continue</span><span>(</span><span>state</span><span>)</span>
    <span>}</span>
    <span>Shutdown</span> <span>-&gt;</span> <span>{</span>
      <span>actor</span><span>.</span><span>stop</span><span>(</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span></pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="gleam test           # Run tests
gleam docs build     # Build documentation"><pre>gleam <span>test</span>           <span><span>#</span> Run tests</span>
gleam docs build     <span><span>#</span> Build documentation</span></pre></div>

<p dir="auto">This project is licensed under the MIT License.</p>
</article></div></div>
  </body>
</html>
