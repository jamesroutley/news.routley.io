<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zarar.dev/good-software-development-habits/">Original</a>
    <h1>Good Software Development Habits</h1>
    
    <div id="readability-page-1" class="page"><p>This post is not advice, it&#39;s what&#39;s working for me.</p><p>It&#39;s easy to pick up bad habits and hard to create good ones. Writing down what&#39;s working for me helps me maintain any good habits I&#39;ve worked hard to develop. Here&#39;s an unordered list of 10 things that have helped me increase speed and maintain a respectable level of quality in the product I&#39;m currently developing.</p><div>
<li><p>Keep commits small enough that you wonder if you&#39;re taking this &#34;keep commits small&#34; thing a little too far. You just never know when you have to revert a particular change and there&#39;s a sense of bliss knowing where you introduced a bug six days ago and only reverting that commit without going through the savagery of merge conflicts. My rule of thumb: compiling software should be commitable.</p>
</li>
<li><p>Live Kent Beck&#39;s <a href="https://x.com/KentBeck/status/250733358307500032?lang=en">holy words of wisdom</a>: &#34;for each desired change, make the change easy (warning: this may be hard), then make the easy change&#34;. Aim for at least half of all commits to be refactorings. Continuous refactoring is thinking of changes I can make in under 10 minutes that improve something. Doing this pays off whenever a bigger requirement comes in and you find yourself making a small change to satisfy it only because of those smaller improvements. Big refactorings are a bad idea.</p>
</li>
<li><p>All code is a liability. Undeployed code is the grim reaper of liabilities. I need to know if it works or at least doesn&#39;t break anything. Tests give you confidence, production gives you approval. The hosting costs might rack up a little with so many deploys but it&#39;s a small price to pay for knowing the last thing you did was a true sign of progression. <em>Working software is the primary measure of progress</em>, says one of the <a href="https://agilemanifesto.org/principles.html">agile principles</a>. Working and progress are doing a lot of heavy lifting in that sentence, so I&#39;ve defined them for myself. Working is something being working enough to be deployed, and if it&#39;s code that&#39;s contributing to a capability, that&#39;s progress.</p>
</li>
<li><p>Know when you&#39;re testing the framework&#39;s capability. If you are, don&#39;t do it. The framework is already tested by people who know a lot more than you, and you have to trust them that the <code>useState()</code> hook does what it&#39;s supposed to do. If you keep components small, then you reduce the need for a lot of tests as the framework will be doing most of the heavy lifting in the component. If the component is big, then you introduce more complexity and now you need to write a lot of tests.</p>
</li>
<li><p>If a particular function doesn&#39;t fit anywhere, create a new module (or class or component) for it and you&#39;ll find a home for it later. It&#39;s better to create a new independent construct than to jam it into an existing module where you know deep down it doesn&#39;t make sense. Worst comes to worst, it lives as an independent module which isn&#39;t too bad anyway.</p>
</li>
<li><p>If you don&#39;t know what an API should look like, write the tests first as it&#39;ll force you to think of the &#34;customer&#34; which in this case is you. You&#39;ll invariably discover cases that you would not have thought of if you had just written the code first and tests after. You don&#39;t have to be religious about TDD and it&#39;s OK to work in larger batches (e.g., write more than just a couple lines of code before making it pass).  The amount of code to write in a red/failing state doesn&#39;t always have to be small. You know what you&#39;re doing, don&#39;t let dogma get in the way of productivity.</p>
</li>
<li><p>Copy-paste is OK once. The second time you&#39;re introducing duplication (i.e., three copies), don&#39;t. You should have enough data points to create a good enough abstraction. The risk of diverging implementations of the same thing is too high at this point, and consolidation is needed.  It&#39;s better to have some wonky parameterization than it is to have multiple implementations of nearly the same thing. Improving the parameters will be easier than to consolidate four different implementations if this situation comes up again.</p>
</li>
<li><p>Designs get stale. You can slow the rate at which they get stale by refactoring, but ultimately you&#39;ll need to change how things work. Don&#39;t feel too bad about moving away from something that was dear to you a while ago and something you felt proud about at the time.  You did the right thing then and shouldn&#39;t beat yourself up for not getting it right enough that you wouldn&#39;t need to change anything. Most of the time writing software is changing software. Just accept it and move on. There&#39;s no such thing as the perfect design, and change is at the core of software development. How good you are at changing things is how good you are at software development.</p>
</li>
<li><p>Technical debt can be classified into three main types: 1) things that are preventing you from doing stuff now, 2) things that will prevent you from doing stuff later, and 3) things that <em>might</em> prevent you from doing stuff later. Every other classification is a subset of these three. Minimize having lots of stuff in #1 and try to focus on #2. Ignore #3.</p>
</li>
<li><p>Testability is correlated with good design. Something not being easily testable hints that the design needs to be changed. Sometimes that design is your test design. As an example, if you find yourself finding it difficult to mock <code>em.getRepository(User).findOneOrFail({id})</code>, then chances are you either need to put that call into its own function that can be mocked, or write a test utility which allows for easier mocking of the entity manager methods. Tests go unwritten when it&#39;s hard to test, not because you don&#39;t want to test.</p>
</li>
</div><p>There&#39;s probably a lot more, but 10 is a nice number.</p></div>
  </body>
</html>
