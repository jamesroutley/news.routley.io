<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pydong.org/posts/PythonsPreprocessor/">Original</a>
    <h1>Python’s Preprocessor</h1>
    
    <div id="readability-page-1" class="page"><div><p>Every now and then you hear outrageous claims such as “Python has no preprocessor”.</p><p>This is simply not true. In fact, Python has the <strong>best preprocessor</strong> of all languages - it quite literally allows us to do whatever we want, and a lot more. It’s just a little tricky to (ab)use.</p><h2 id="python-source-code-encodings"><span>Python source code encodings</span><a href="#python-source-code-encodings"><i></i></a></h2><p>Thanks to <a href="https://peps.python.org/pep-0263/#defining-the-encoding">PEP-0263</a> it is possible to define a <em>source code encoding</em> by placing a magic comment in one of the first 2 lines.</p><p>All of the following lines would instruct the Python interpreter to decode the rest of the file using the <code>utf8</code> codec:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span># coding=utf8
# -*- coding: utf8 -*-
# vim: set fileencoding=utf8 :
</span></pre></td></tr></tbody></table></code></p></div><p>To be precise, the line must match the regular expression <code>^[ \t\f]*#.*?coding[:=][ \t]*([-_.a-zA-Z0-9]+)</code>. Naturally we can use our own encodings, but their names must match <code>[-_.a-zA-Z0-9]+</code>. As you might have guessed by now - our own codec will do a whole lot more than just decode the source file.</p><h2 id="path-configuration-files-pth"><span>Path configuration files (.pth)</span><a href="#path-configuration-files-pth"><i></i></a></h2><p>Unless the Python interpreter was started with the <a href="https://docs.python.org/3.12/using/cmdline.html#cmdoption-S"><code>-S</code></a> option, it will automatically load the <a href="https://docs.python.org/3/library/site.html"><code>site</code></a> package during initialization. This is done to append <em>site-specific</em> paths to the module search path.</p><p>One way to do so is by placing a <em>path configuration file</em> (with <code>.pth</code> suffix) in the <a href="https://docs.python.org/3/library/site.html#index-1"><code>site-packages</code></a> folder of your target Python installation. Every line (except lines starting in <code>#</code> and blank lines) in it will be added to the module search path.</p><p>Interestingly the <a href="https://docs.python.org/3.12/library/site.html#index-2">Python Docs</a> also mention the following:</p><blockquote><p>Lines starting with import (followed by space or tab) are executed.</p></blockquote><p>Which gives us a nice opportunity to always execute arbitrary code during initialization of the Python interpreter. This can be used to load the custom codec - to do so create a file <code>packagename.pth</code> in <a href="https://docs.python.org/3/library/site.html#index-1"><code>site-packages</code></a> with content matching</p><div><p><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>import</span> <span>packagename.register_codec</span>
</pre></td></tr></tbody></table></code></p></div><p>This will import the <code>register_codec</code> module from the <code>packagename</code> package. Importing this module must register the codec, which is done by registering a search function by calling <a href="https://docs.python.org/3/library/codecs.html#codecs.register"><code>codecs.register</code></a>. For example:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td><pre><span>import</span> <span>codecs</span>
<span>from</span> <span>typing</span> <span>import</span> <span>Optional</span>

<span>def</span> <span>search_function</span><span>(</span><span>encoding</span><span>)</span> <span>-&gt;</span> <span>Optional</span><span>[</span><span>codecs</span><span>.</span><span>CodecInfo</span><span>]:</span>
    <span>if</span> <span>encoding</span> <span>==</span> <span>&#34;</span><span>codec_name</span><span>&#34;</span><span>:</span>
        <span>return</span> <span>codecs</span><span>.</span><span>CodecInfo</span><span>(</span>
          <span>name</span><span>=</span><span>encoding</span><span>,</span>
          <span>encode</span><span>=</span><span>codecs</span><span>.</span><span>utf_8_encode</span><span>,</span>
          <span>decode</span><span>=</span><span>your_decoder</span><span>,</span>
          <span>incrementaldecoder</span><span>=</span><span>your_incremental_decoder</span>
      <span>)</span>

<span>codecs</span><span>.</span><span>register</span><span>(</span><span>search_function</span><span>)</span>
</pre></td></tr></tbody></table></code></p></div><p>Since importing modules only executes them once, this is sufficient to register our codec’s search function exactly once. This leaves one thing to do: the actual decoder.</p><h2 id="defining-custom-codecs"><span>Defining custom codecs</span><a href="#defining-custom-codecs"><i></i></a></h2><p>Essentially we need two things to make the Python interpreter happy:</p><ul><li>a decode function <code>decode(data: bytes) -&gt; tuple[str, int]</code></li><li>an incremental decoder class</li></ul><p>Let’s do the decode function first. <code>codecs.utf_8_decode</code> can be used for the actual decoding - this will return a tuple of the decoded content of the source file and how many bytes were consumed. The resulting string can be passed on to our actual preprocessor.</p><blockquote><p>Uncaught exceptions will not be printed with traceback to the terminal as you would expect. Instead the interpreter will simply yield <code>SyntaxError: encoding problem: your_codec</code> with no helpful extra information as to why there was a problem with your codec.</p><p>It is therefore advisable to catch exceptions coming from your preprocessor and explicitly print them before reraising.</p></blockquote><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td><pre><span>import</span> <span>codecs</span>
<span>import</span> <span>traceback</span>

<span>def</span> <span>preprocessor</span><span>(</span><span>data</span><span>:</span> <span>str</span><span>)</span> <span>-&gt;</span> <span>str</span><span>:</span>
    <span># do actual preprocessing here
</span>    <span>return</span> <span>data</span>

<span>def</span> <span>decode</span><span>(</span><span>data</span><span>:</span> <span>bytes</span><span>)</span> <span>-&gt;</span> <span>tuple</span><span>[</span><span>str</span><span>,</span> <span>int</span><span>]:</span>
    <span>decoded</span><span>,</span> <span>consumed</span> <span>=</span> <span>codecs</span><span>.</span><span>utf_8_decode</span><span>(</span><span>data</span><span>,</span> <span>errors</span><span>=</span><span>&#39;</span><span>strict</span><span>&#39;</span><span>,</span> <span>final</span><span>=</span><span>True</span><span>)</span>
    <span>try</span><span>:</span>
        <span># run the preprocessor
</span>        <span>processed</span> <span>=</span> <span>preprocessor</span><span>(</span><span>decoded</span><span>)</span>
    <span>except</span> <span>Exception</span><span>:</span>
        <span># print the traceback
</span>        <span>traceback</span><span>.</span><span>print_exc</span><span>()</span>
        <span>raise</span>
    <span>return</span> <span>processed</span><span>,</span> <span>consumed</span>
</pre></td></tr></tbody></table></code></p></div><p>To get things to work nicely we also need to provide an incremental decoder. Since we don’t want to actually preprocess the file incrementally, we can instead collect it into a buffer and preprocess the entire thing once the final decode call happened. For this purpose we can inherit from <code>codecs.BufferedIncrementalDecoder</code> (or <a href="https://docs.python.org/3/library/codecs.html#codecs.IncrementalDecoder"><code>codecs.IncrementalDecoder</code></a>, since we will override <code>decode</code>, which provides the primary machinery, anyway). This will look something like this:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td><pre><span>import</span> <span>codecs</span>

<span>class</span> <span>Decoder</span><span>(</span><span>codecs</span><span>.</span><span>BufferedIncrementalDecoder</span><span>):</span>
    <span>def</span> <span>_buffer_decode</span><span>(</span><span>self</span><span>,</span> <span>input</span><span>,</span> <span>errors</span><span>,</span> <span>final</span><span>):</span>  <span>&#34;&#34;&#34;</span><span>not used</span><span>&#34;&#34;&#34;</span>

    <span>def</span> <span>decode</span><span>(</span><span>self</span><span>,</span> <span>data</span><span>,</span> <span>final</span><span>=</span><span>False</span><span>)</span> <span>-&gt;</span> <span>str</span><span>:</span>
        <span>self</span><span>.</span><span>buffer</span> <span>+=</span> <span>data</span>

        <span>if</span> <span>self</span><span>.</span><span>buffer</span> <span>and</span> <span>final</span><span>:</span>
            <span>buffer</span> <span>=</span> <span>self</span><span>.</span><span>buffer</span>
            <span>self</span><span>.</span><span>reset</span><span>()</span>
            <span># call our decode function, return only the result string
</span>            <span>return</span> <span>decode</span><span>(</span><span>buffer</span><span>)[</span><span>0</span><span>]</span>

        <span>return</span> <span>&#34;&#34;</span>
</pre></td></tr></tbody></table></code></p></div><p>The search function from earlier can now be updated to use the decode function and the incremental decoder class.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
</pre></td><td><pre><span>def</span> <span>search_function</span><span>(</span><span>encoding</span><span>)</span> <span>-&gt;</span> <span>Optional</span><span>[</span><span>codecs</span><span>.</span><span>CodecInfo</span><span>]:</span>
    <span>if</span> <span>encoding</span> <span>==</span> <span>&#34;</span><span>codec_name</span><span>&#34;</span><span>:</span>
        <span>return</span> <span>codecs</span><span>.</span><span>CodecInfo</span><span>(</span>
          <span>name</span><span>=</span><span>encoding</span><span>,</span>
          <span>encode</span><span>=</span><span>codecs</span><span>.</span><span>utf_8_encode</span><span>,</span>
          <span>decode</span><span>=</span><span>decode</span><span>,</span>              <span># our decode function
</span>          <span>incrementaldecoder</span><span>=</span><span>Decoder</span>  <span># our incremental decoder
</span>      <span>)</span>
</pre></td></tr></tbody></table></code></p></div><p>It does not matter if or how the source file’s content is used, you can also return completely arbitrary code. However note that <strong>the first line will be dropped</strong> (since it is expected to contain the magic line) and it <strong>must</strong> be valid Python.</p><h2 id="extending-python"><span>Extending Python</span><a href="#extending-python"><i></i></a></h2><p>Fortunately extending Python is rather easy since Python’s standard library contains tools to tokenize and parse Python. While regular expressions may be sufficient for simple language extensions, this often tends to be rather error prone.</p><p>If your language extension uses only valid Python tokens, it is possible to use the <a href="https://docs.python.org/3/library/tokenize.html"><code>tokenize</code></a> module to retrieve the file’s token stream, modify it as required and <a href="https://docs.python.org/3/library/tokenize.html#tokenize.untokenize"><code>untokenize</code></a> the result.</p><p>If your language extension transforms syntactically valid Python, it is possible to use the <a href="https://docs.python.org/3/library/ast.html"><code>ast</code></a> module to <a href="https://docs.python.org/3/library/ast.html#ast.parse"><code>parse</code></a> the source file, modify the resulting abstract syntax tree and finally <a href="https://docs.python.org/3/library/ast.html#ast.unparse"><code>unparse</code></a> it.</p><h3 id="unary-increment-and-decrement"><span>Unary increment and decrement</span><a href="#unary-increment-and-decrement"><i></i></a></h3><p>Unlike <a href="https://en.wikipedia.org/wiki/Increment_and_decrement_operators#Supporting_languages">many other languages</a> Python is unfortunately lacking unary increment and decrement operators.</p><p>In case you’re not familiar with the concept, here’s a quick refresher:</p><ul><li>Pre-increment and pre-decrement operators modify their operand by 1 and return the value <strong>after</strong> doing so</li><li>Post-increment and post-decrement operators modify their operand by 1 and return the value <strong>before</strong> doing so</li></ul><p>In Python “post-increment” <code>x++</code> and “post-decrement”<code>x--</code> are syntactically not valid.</p><p>“Pre-increment” <code>++x</code> and “pre-decrement” <code>--x</code> however are syntactically valid, but would result in a call <code>x.__pos__().__pos__()</code> or <code>x.__neg__().__neg__()</code> respectively. Keep in mind that breaking these up with extra parentheses like <code>+(+x)</code> or <code>-(-x)</code> would still result in that call.</p><p>Essentially we want to replace every occurrence of these invalid unary increment and decrement expressions into a Python expression that has the same semantics.</p><p>One possible way to do this is to form a tuple of the <code>x</code> before mutating it and <code>x</code> after mutation. This can be used for both prefix and postfix notation - we can simply pick out whichever value we need using the tuple’s subscript operator. Thanks to <a href="https://peps.python.org/pep-0572/">PEP-0572</a> Python has assignment <em>expressions</em> (also known as the walrus operator), which allow mutation of <code>x</code> but also return the resulting value. <br/></p><p>Here’s the list of replacements:</p><div><table><thead><tr><th>Unary expression</th><th>Token sequence</th><th>Python equivalent</th></tr></thead><tbody><tr><td><code>x++</code></td><td><code>(NAME, &#39;x&#39;), (OP, &#39;+&#39;), (OP, &#39;+&#39;)</code></td><td><code>(x, x := x + 1)[0]</code></td></tr><tr><td><code>x--</code></td><td><code>(NAME, &#39;x&#39;), (OP, &#39;-&#39;), (OP, &#39;-&#39;)</code></td><td><code>(x, x := x - 1)[0]</code></td></tr><tr><td><code>++x</code></td><td><code>(OP, &#39;+&#39;), (OP, &#39;+&#39;), (NAME, &#39;x&#39;)</code></td><td><code>(x, x := x + 1)[1]</code></td></tr><tr><td><code>--x</code></td><td><code>(OP, &#39;-&#39;), (OP, &#39;-&#39;), (NAME, &#39;x&#39;)</code></td><td><code>(x, x := x - 1)[1]</code></td></tr></tbody></table></div><p>Simply replacing these token sequences in the token stream is strictly speaking not sufficient, since it will fail for expressions such as <code>x++ - -y</code>, however this can easily be disambiguated with extra parenthesis: <code>x++ - (-y)</code>.</p><p><a href="https://github.com/dankeyy/incdec.py">incdec.py</a>, the Python project that inspired this blog post, uses regular expressions to do the replacements. While it does try to prevent replacements inside string literals, it is still rather brittle. You can find a reimplementation that directly modifies the token stream at <a href="https://github.com/Tsche/magic_codec/blob/master/src/magic_codec/builtin/incdec.py">magic.incdec</a>.</p><h4 id="example"><span>Example</span><a href="#example"><i></i></a></h4><p>An input file <code>incdec.py</code></p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td><pre><span># coding: magic.incdec
</span><span>i</span> <span>=</span> <span>6</span>

<span>assert</span> <span>i</span><span>--</span> <span>==</span> <span>6</span>
<span>assert</span> <span>i</span> <span>==</span> <span>5</span>
<span>assert</span> <span>++</span><span>i</span> <span>==</span> <span>6</span>
<span>assert</span> <span>--</span><span>i</span> <span>==</span> <span>5</span>
<span>assert</span> <span>i</span><span>++</span> <span>==</span> <span>5</span>
<span>assert</span> <span>i</span> <span>==</span> <span>6</span>
<span>assert </span><span>(</span><span>++</span><span>i</span><span>,</span> <span>&#39;</span><span>i++</span><span>&#39;</span><span>)</span> <span>==</span> <span>(</span><span>7</span><span>,</span> <span>&#39;</span><span>i++</span><span>&#39;</span><span>)</span>
<span>print</span><span>(</span><span>&#34;</span><span>PASSED</span><span>&#34;</span><span>)</span>

</pre></td></tr></tbody></table></code></p></div><p>would be transformed to</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td><pre><span>i</span> <span>=</span> <span>6</span>

<span>assert </span><span>((</span><span>i</span><span>,</span> <span>i</span> <span>:</span><span>=</span> <span>i</span> <span>-</span> <span>1</span><span>)[</span><span>0</span><span>])</span> <span>==</span> <span>6</span>
<span>assert</span> <span>i</span> <span>==</span> <span>5</span>
<span>assert </span><span>((</span><span>i</span><span>,</span> <span>i</span> <span>:</span><span>=</span> <span>i</span> <span>+</span> <span>1</span><span>)[</span><span>1</span><span>])</span> <span>==</span> <span>6</span>
<span>assert </span><span>((</span><span>i</span><span>,</span> <span>i</span> <span>:</span><span>=</span> <span>i</span> <span>-</span> <span>1</span><span>)[</span><span>1</span><span>])</span> <span>==</span> <span>5</span>
<span>assert </span><span>((</span><span>i</span><span>,</span> <span>i</span> <span>:</span><span>=</span> <span>i</span> <span>+</span> <span>1</span><span>)[</span><span>0</span><span>])</span> <span>==</span> <span>5</span>
<span>assert</span> <span>i</span> <span>==</span> <span>6</span>
<span>assert </span><span>(((</span><span>i</span><span>,</span> <span>i</span> <span>:</span><span>=</span> <span>i</span> <span>+</span> <span>1</span><span>)[</span><span>1</span><span>]),</span><span>&#39;</span><span>i++</span><span>&#39;</span><span>)</span> <span>==</span> <span>(</span><span>7</span><span>,</span> <span>&#39;</span><span>i++</span><span>&#39;</span><span>)</span>
<span>print </span><span>(</span><span>&#34;</span><span>PASSED</span><span>&#34;</span><span>)</span>

</pre></td></tr></tbody></table></code></p></div><p>To verify that it actually works, try running <code>python tests/incdec/incdec.py</code> in the <a href="https://github.com/Tsche/magic_codec"><code>magic_codec repository</code></a> after installing <a href="https://pypi.org/project/magic_codec/"><code>magic_codec</code></a>. It should print</p><div><p><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre>$ python tests/incdec/incdec.by
PASSED
</pre></td></tr></tbody></table></code></p></div><h3 id="python-with-braces-bython"><span>Python with braces (Bython)</span><a href="#python-with-braces-bython"><i></i></a></h3><p>Another thing C/C++ programmers usually find rather off-putting about Python is its use of indentation for scoping purposes. Unfortunately the Python developers have strong opinions on using braces for scoping, which can be confirmed by importing <code>braces</code> from <code>__future__</code>:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span>&gt;&gt;&gt;</span> <span>from</span> <span>__future__</span> <span>import</span> <span>braces</span>
  <span>File</span> <span>&#34;</span><span>&lt;stdin&gt;</span><span>&#34;</span><span>,</span> <span>line</span> <span>1</span>
<span>SyntaxError</span><span>:</span> <span>not</span> <span>a</span> <span>chance</span>
</pre></td></tr></tbody></table></code></p></div><p>Let’s do it anyway.</p><p>As with the incdec example, we can directly modify the token stream. To do so get the tokens from the source file using <a href="https://docs.python.org/3/library/tokenize.html#tokenize.generate_tokens"><code>tokenize.generate_tokens</code></a>. Unfortunately <code>generate_tokens</code> expects a callable that yields one line at a time. We can get one by wrapping our string in a <a href="https://docs.python.org/3/library/io.html#io.StringIO"><code>StringIO</code></a> object and use its bound <code>readline</code> method.</p><p>Since whitespace does not matter in the input, all tokens of the types <code>INDENT</code> and <code>DEDENT</code> can be dropped.</p><p>Tokens of the type <code>OP</code> are interesting for primary required machinery - if the token’s string representation matches <code>{</code>, the indentation level needs to be increased and a <code>:</code> emitted. Likewise if the token’s string representation matches <code>}</code>, the indentation level must be decreased.</p><p>Finally to fix indentation every token of type <code>NL</code> must be followed by a token of type <code>INDENT</code> with an appropriate amount of whitespace for the current indentation level as content.</p><p>Since Python uses curly braces for dictionaries, this can be slightly improved upon by only adjusting the indentation level only if the <code>{</code> token is followed by a newline and respectively the <code>}</code> token preceded by a newline. Limiting dictionaries with the curly brace syntax to a single line might seem rather limiting, but remember that</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
</pre></td><td><pre><span>dictionary</span> <span>=</span> <span>{</span> \
    <span>&#39;</span><span>a</span><span>&#39;</span><span>:</span> <span>420</span><span>,</span>  \
    <span>&#39;</span><span>b</span><span>&#39;</span><span>:</span> <span>10</span>    \
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>contains no newline tokens within the curly braces.</p><h4 id="example-1"><span>Example</span><a href="#example-1"><i></i></a></h4><p>An input file <code>test.by</code></p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td><pre><span># coding: magic.braces
</span><span>def</span> <span>print_message</span><span>(</span><span>num_of_times</span><span>)</span> <span>{</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>num_of_times</span><span>)</span> <span>{</span>  
   <span>print</span><span>(</span><span>&#34;</span><span>braces ftw</span><span>&#34;</span><span>)</span>
  <span>print</span><span>({</span><span>&#39;</span><span>x</span><span>&#39;</span><span>:</span> <span>3</span><span>})</span>
 <span>}</span>
<span>}</span>

<span>x</span> <span>=</span> <span>{</span>        \
  <span>&#39;</span><span>foo</span><span>&#39;</span><span>:</span> <span>42</span><span>,</span> \
  <span>&#39;</span><span>bar</span><span>&#39;</span><span>:</span> <span>5</span>   \
<span>}</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#34;</span><span>__main__</span><span>&#34;</span> <span>{</span>
<span>print_message</span><span>(</span><span>2</span><span>)</span>
    <span>print</span><span>({</span><span>k</span><span>:</span><span>v</span> <span>for</span> <span>k</span><span>,</span> <span>v</span> <span>in</span> <span>x</span><span>.</span><span>items</span><span>()})</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>would be transformed to</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td><pre><span># coding: magic.braces
</span><span>def</span> <span>print_message</span><span>(</span><span>num_of_times</span><span>):</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>num_of_times</span><span>):</span>
        <span>print</span><span>(</span><span>&#34;</span><span>braces ftw</span><span>&#34;</span><span>)</span>
        <span>print</span><span>({</span><span>&#39;</span><span>x</span><span>&#39;</span><span>:</span> <span>3</span><span>})</span>

<span>x</span> <span>=</span> <span>{</span>        \
  <span>&#39;</span><span>foo</span><span>&#39;</span><span>:</span> <span>42</span><span>,</span> \
  <span>&#39;</span><span>bar</span><span>&#39;</span><span>:</span> <span>5</span>   \
<span>}</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#34;</span><span>__main__</span><span>&#34;</span><span>:</span>
    <span>print_message</span><span>(</span><span>2</span><span>)</span>
    <span>print</span><span>({</span><span>k</span><span>:</span><span>v</span> <span>for</span> <span>k</span><span>,</span> <span>v</span> <span>in</span> <span>x</span><span>.</span><span>items</span><span>()})</span>

</pre></td></tr></tbody></table></code></p></div><p>You can verify this by running <code>python tests/braces/test.by</code> in the <a href="https://github.com/Tsche/magic_codec"><code>magic_codec repository</code></a> after installing <a href="https://pypi.org/project/magic_codec/"><code>magic_codec</code></a>. It should print</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
</pre></td><td><pre>$ python tests/braces/test.by
braces ftw
{&#39;x&#39;: 3}
braces ftw
{&#39;x&#39;: 3}
{&#39;foo&#39;: 42, &#39;bar&#39;: 5}
</pre></td></tr></tbody></table></code></p></div><h2 id="interpreting-other-languages"><span>Interpreting other languages</span><a href="#interpreting-other-languages"><i></i></a></h2><p>Instead of expanding Python, why not teach the Python interpreter itself a few more tricks? After all there’s all kinds of cool languages it could interpret!</p><p>Some languages (ie. shell script, CMake script, PHP or Ruby) use <code>#</code> for comments, notably every language that supports <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebangs</a> - this can be abused to set the encoding directly.</p><h3 id="c-and-c"><span>C and C++</span><a href="#c-and-c"><i></i></a></h3><p>For C and C++ we have no such luck. Comments use <code>/* comment */</code> or <code>// comment</code> syntax, neither of which is usable. It is however possible to satisfy the source encoding pattern by using preprocessor directives, which happen to start with a <code>#</code>.</p><p>The regular expression for magic lines <code>^[ \t\f]*#.*?coding[:=][ \t]*([-_.a-zA-Z0-9]+)</code> matches, if a line contains:</p><ul><li>any amount of spaces, tabs or form feeds</li><li>the <code>#</code> character</li><li>any amount of any characters</li><li>the word <code>coding</code></li><li>either <code>:</code> or <code>=</code></li><li>any amount of spaces or tabs</li><li>an identifier matching <code>[-_.a-zA-Z0-9]+</code></li></ul><p>One preprocessor directive in C++ that can be used for this is <code>#define</code>. What we want to do is define a macro and let its value match <code>.*?coding[:=][ \t]*([-_.a-zA-Z0-9]+)</code>. For example</p><div><p><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>#define CODEC &#34;coding:magic.cpp&#34;
</span></pre></td></tr></tbody></table></code></p></div><p>would match.</p><p>Great, we can now trigger the <code>magic.cpp</code> decoder with a valid C or C++ source file. To actually get the Python interpreter to interpret this C or C++ code for us, we can use the excellent package <a href="https://pypi.org/project/cppyy/"><code>cppyy</code></a>. In essence <a href="https://cppyy.readthedocs.io/en/latest/"><code>cppyy</code></a> uses <a href="https://root.cern/cling/"><code>cling</code></a> under the hood to interpret our code and generates Python bindings for us to use it.</p><p>After our decoder is done with the input file, the output should look something like</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td><pre><span>import</span> <span>cppyy</span>

<span># interpret the input source code
</span><span>cppyy</span><span>.</span><span>cppdef</span><span>(</span><span>&#34;</span><span>&lt;input source file content&gt;</span><span>&#34;</span><span>)</span>

<span># find the main function
</span><span>from</span> <span>cppyy.gbl</span> <span>import</span> <span>main</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#34;</span><span>__main__</span><span>&#34;</span><span>:</span>
  <span># call C/C++ main
</span>  <span>main</span><span>()</span>
</pre></td></tr></tbody></table></code></p></div><p>Now we can run <code>python foo.cpp</code> if <code>foo.cpp</code> begins with the magic line <code>#define CODEC &#34;coding:magic.cpp&#34;</code>. One example implementation of this can be found at <a href="https://github.com/Tsche/magic_codec/blob/master/src/magic_codec/builtin/cpp.py">magic.cpp</a>.</p><h4 id="example-2"><span>Example</span><a href="#example-2"><i></i></a></h4><p>An input file <code>test.cpp</code></p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
</pre></td><td><pre><span>#define CODEC &#34;coding:magic.cpp&#34;
#include</span> <span>&lt;cstdio&gt;</span><span>
</span>
<span>int</span> <span>main</span><span>()</span> <span>{</span>
    <span>puts</span><span>(</span><span>&#34;Hello World&#34;</span><span>);</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>would be transformed to</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td><pre><span>import</span> <span>cppyy</span>

<span>cppyy</span><span>.</span><span>cppdef</span><span>(</span><span>r</span><span>&#34;&#34;&#34;</span><span>
#define CODEC </span><span>&#34;</span><span>coding:magic.cpp</span><span>&#34;</span><span>
#include &lt;cstdio&gt;

int main() {
    puts(</span><span>&#34;</span><span>Hello World</span><span>&#34;</span><span>);
}
</span><span>&#34;&#34;&#34;</span><span>)</span>
<span>from</span> <span>cppyy.gbl</span> <span>import</span> <span>main</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#34;</span><span>__main__</span><span>&#34;</span><span>:</span>
    <span>main</span><span>()</span>

</pre></td></tr></tbody></table></code></p></div><p>You can try this by running <code>python tests/cpp/test.cpp</code> in the <a href="https://github.com/Tsche/magic_codec"><code>magic_codec repository</code></a> after installing <a href="https://pypi.org/project/magic_codec/"><code>magic_codec</code></a> and <a href="https://pypi.org/project/cppyy/"><code>cppyy</code></a>. It should print</p><div><p><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre>$ python tests/cpp/test.cpp
Hello World
</pre></td></tr></tbody></table></code></p></div><h2 id="validating-data"><span>Validating data</span><a href="#validating-data"><i></i></a></h2><p>One data interchange format that does allow comments and uses <code>#</code> to introduce them is <a href="https://toml.io/en/">TOML</a>. This allows us to set an encoding and let the Python interpreter act as a validation tool instead. <a href="https://pypi.org/project/jsonschema/">jsonschema</a> which is a Python implementation of <a href="https://json-schema.org/">JSON Schema</a> can be used to do the actual validation.</p><p>This one is rather straight forward, a <code>preprocess</code> function could look like this:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td><pre><span>def</span> <span>preprocess</span><span>(</span><span>data</span><span>:</span> <span>str</span><span>):</span>
    <span>return</span> <span>&#34;&#34;&#34;</span><span>
import argparse
import json
import sys
import tomllib
from pathlib import Path
from jsonschema import ValidationError, validate

def main():
    parser = argparse.ArgumentParser(
                    prog=</span><span>&#39;</span><span>magic.toml</span><span>&#39;</span><span>,
                    description=</span><span>&#39;</span><span>Verify toml data against json schemas</span><span>&#39;</span><span>)
    parser.add_argument(</span><span>&#39;</span><span>-s</span><span>&#39;</span><span>, </span><span>&#39;</span><span>--schema</span><span>&#39;</span><span>, type=Path, required=True)
    args = parser.parse_args()

    data = tomllib.loads(Path(sys.argv[0]).read_text(encoding=</span><span>&#34;</span><span>utf-8</span><span>&#34;</span><span>))
    schema = json.loads(args.schema.read_text(encoding=</span><span>&#34;</span><span>utf-8</span><span>&#34;</span><span>))
    try:
        validate(data, schema)
    except ValidationError as exc:
        print(exc)
    else:
        print(</span><span>&#34;</span><span>Successfully validated.</span><span>&#34;</span><span>)

if __name__ == </span><span>&#34;</span><span>__main__</span><span>&#34;</span><span>:
    main()
</span><span>&#34;&#34;&#34;</span>
</pre></td></tr></tbody></table></code></p></div><p>A slightly different example implementation can be found at <a href="https://github.com/Tsche/magic_codec/blob/master/src/magic_codec/builtin/toml.py">magic.toml</a>.</p><h3 id="example-3"><span>Example</span><a href="#example-3"><i></i></a></h3><p>With a schema <code>schema.json</code></p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td><pre><span>{</span>
    <span>&#34;</span><span>type</span><span>&#34;</span><span>:</span> <span>&#34;</span><span>object</span><span>&#34;</span><span>,</span>
    <span>&#34;</span><span>properties</span><span>&#34;</span><span>:</span> <span>{</span>
        <span>&#34;</span><span>name</span><span>&#34;</span><span>:</span> <span>{</span><span>&#34;</span><span>type</span><span>&#34;</span><span>:</span> <span>&#34;</span><span>string</span><span>&#34;</span><span>},</span>
        <span>&#34;</span><span>age</span><span>&#34;</span><span>:</span> <span>{</span><span>&#34;</span><span>type</span><span>&#34;</span><span>:</span> <span>&#34;</span><span>number</span><span>&#34;</span><span>},</span>
        <span>&#34;</span><span>scores</span><span>&#34;</span><span>:</span> <span>{</span>
            <span>&#34;</span><span>type</span><span>&#34;</span><span>:</span> <span>&#34;</span><span>array</span><span>&#34;</span><span>,</span>
            <span>&#34;</span><span>items</span><span>&#34;</span><span>:</span> <span>{</span><span>&#34;</span><span>type</span><span>&#34;</span><span>:</span> <span>&#34;</span><span>number</span><span>&#34;</span><span>}</span>
        <span>},</span>
        <span>&#34;</span><span>address</span><span>&#34;</span><span>:</span> <span>{</span><span>&#34;</span><span>$ref</span><span>&#34;</span><span>:</span> <span>&#34;</span><span>#/$defs/address</span><span>&#34;</span><span>}</span>
    <span>},</span>
    <span>&#34;</span><span>required</span><span>&#34;</span><span>:</span> <span>[</span><span>&#34;</span><span>name</span><span>&#34;</span><span>],</span>
    <span>&#34;</span><span>$defs</span><span>&#34;</span><span>:</span> <span>{</span>
        <span>&#34;</span><span>address</span><span>&#34;</span><span>:</span> <span>{</span>
            <span>&#34;</span><span>type</span><span>&#34;</span><span>:</span> <span>&#34;</span><span>object</span><span>&#34;</span><span>,</span>
            <span>&#34;</span><span>properties</span><span>&#34;</span><span>:</span> <span>{</span>
                <span>&#34;</span><span>street</span><span>&#34;</span><span>:</span> <span>{</span><span>&#34;</span><span>type</span><span>&#34;</span><span>:</span> <span>&#34;</span><span>string</span><span>&#34;</span><span>},</span>
                <span>&#34;</span><span>postcode</span><span>&#34;</span><span>:</span> <span>{</span><span>&#34;</span><span>type</span><span>&#34;</span><span>:</span> <span>&#34;</span><span>number</span><span>&#34;</span><span>}</span>
            <span>},</span>
            <span>&#34;</span><span>required</span><span>&#34;</span><span>:</span> <span>[</span><span>&#34;</span><span>street</span><span>&#34;</span><span>]</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>and an input file <code>data_valid.toml</code></p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
</pre></td><td><pre><span># coding: magic.toml</span>
<span>name</span> <span>=</span> <span>&#34;John Doe&#34;</span>
<span>age</span> <span>=</span> <span>42</span>
<span>scores</span> <span>=</span> <span>[</span><span>40</span><span>,</span> <span>20</span><span>,</span> <span>80</span><span>,</span> <span>90</span><span>]</span>

<span>[address]</span>
<span>street</span> <span>=</span> <span>&#34;Grove St. 4&#34;</span>
<span>postcode</span> <span>=</span> <span>19201</span>
</pre></td></tr></tbody></table></code></p></div><p>the expected output is</p><div><p><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre>$ python tests/toml/data_valid.toml -s tests/toml/schema.json
Successfully validated.
</pre></td></tr></tbody></table></code></p></div><p>However, for an input file <code>data_invalid.toml</code></p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
</pre></td><td><pre><span># coding: magic.toml</span>
<span>name</span> <span>=</span> <span>&#34;John Doe&#34;</span>
<span>age</span> <span>=</span> <span>42</span>
<span>scores</span> <span>=</span> <span>[</span><span>40</span><span>,</span> <span>&#34;20&#34;</span><span>,</span> <span>80</span><span>,</span> <span>90</span><span>]</span>

<span>[address]</span>
<span>street</span> <span>=</span> <span>&#34;Grove St. 4&#34;</span>
<span>postcode</span> <span>=</span> <span>19201</span>
</pre></td></tr></tbody></table></code></p></div><p>the expected output will be</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
</pre></td><td><pre>$ python tests/toml/data_invalid.toml -s tests/toml/schema.json
&#39;20&#39; is not of type &#39;number&#39;

Failed validating &#39;type&#39; in schema[&#39;properties&#39;][&#39;scores&#39;][&#39;items&#39;]:
    {&#39;type&#39;: &#39;number&#39;}

On instance[&#39;scores&#39;][1]:
    &#39;20&#39;
</pre></td></tr></tbody></table></code></p></div><h2 id="conclusion"><span>Conclusion</span><a href="#conclusion"><i></i></a></h2><p>Custom codecs in conjunction with path configuration files can drastically change the behavior of the Python interpreter. While most of the examples here are written purely for entertainment purposes, there are definitely valid uses for this technique. One notable example is <a href="https://github.com/pythonql/pythonql">pythonql</a>, which is a query language extension for Python. Another notable example is <a href="https://github.com/PrettyWood/future-typing">future-typing</a> which backports generic type hints and union syntax via <code>|</code> to Python 3.6+. Similar projects include <a href="https://github.com/asottile-archive/future-fstrings">future-fstrings</a> and <a href="https://github.com/asottile-archive/future-annotations">future-annotations</a>.</p><p>If you want to play around with your own preprocessors but do not wish to mess with <code>site-packages</code> directly, introduce path configuration files and write all the boilerplate yourself, you can instead use <a href="https://github.com/Tsche/magic_codec"><code>magic_codec</code></a>.</p><p>To extend <a href="https://github.com/Tsche/magic_codec"><code>magic_codec</code></a> with your own preprocessors, you can create another Python package whose name is prefixed with <code>magic_</code>. Setting the codec of any file to <code>magic_foo</code> would load the <code>magic_foo</code> package and check if it has a function <code>preprocess</code>.</p><p>The expected signature of <code>preprocess</code> is as follows:</p><div><p><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span>def</span> <span>preprocess</span><span>(</span><span>data</span><span>:</span> <span>str</span><span>)</span> <span>-&gt;</span> <span>str</span><span>:</span>
    <span>raise</span> <span>NotImplementedError</span>
</pre></td></tr></tbody></table></code></p></div><p>You can find an example extension in <a href="https://github.com/Tsche/magic_codec/tree/master/example">example/</a>.</p></div></div>
  </body>
</html>
