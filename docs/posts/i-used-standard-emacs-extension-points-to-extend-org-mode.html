<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://edoput.it/2025/04/16/emacs-paradigm-shift.html">Original</a>
    <h1>I used standard Emacs extension-points to extend org-mode</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>Recently I read <a href="https://blog.tjll.net/a-beginners-guide-to-extending-emacs/">this beginners guide to extend Emacs</a>.
The guide is perfect for starting out with elisp and it shows a lot of care in teaching how to interact with Emacs.</p>

<p>To me, the most important bit though is this one, from the section aptly named <strong>Emacs Wants You to Extend It</strong>.</p>

<blockquote>
  <p>I haven’t written plugins for other editors extensively, but I can tell you this: emacs doesn’t just make deep customization available, but it actively encourages you to make an absolute customization messes masterpieces. Core editor functions aren’t just documented, but often include tidbits about “you probably want to see this other variable” or “here’s how you should use this”.</p>

  <p>Not only that, but emacs happily hands you functions shaped like nuclear warheads like advice-add (that let you override any function) that can absolutely obliterate your editor if you hold it the wrong way. Of course, this also grants you unlimited power.</p>

  <p>Remember that emacs is designed to be torn apart and rearranged.</p>
</blockquote>

<p>This is the core bit of the argument. Emacs, as a system, wants you to
extend it and it gives you all the means to do so. This is in contrast
with systems that can be extended through scripting and instead don’t give
you all the means to do so!</p>

<p>I think the tutorial is a fantastic example of <em>doing things
right</em>. There is a well-thought example, a constructive approach where
the solution grows to a full package.</p>

<p>This is problematic. You may get the impression that extending Emacs
is only possible if you do things right and that is definitely not true.</p>

<p>To make my point I want to walk you through an example. I will show
you how I used standard Emacs extension-points to extend org-mode to sort my
reading lists automatically.</p>

<h2 id="what-do-i-want">What do I want?</h2>

<p>The behavior I want is that when I save an org file the entries are
ordered automatically. I keep a timeline of the papers I am reading
and it is annoying to keep them kind of ordered.</p>

<p>This is the content of an example buffer.</p>

<figure><pre><code data-lang="org">#+TITLE: My tematic reading list

* Paper which is old but not too old
:PROPERTY:
:year: 2002
:END:

* Definitely older paper but unfortunately it&#39;s later in the list
:PROPERTY:
:year: 1998
:END:</code></pre></figure>

<p>When I add a paper to my reading list I run <code>org-sort-entries</code> and
interactively select to order the entries by the value in the property
<code>year</code>. Initally this was nice to have but now it’s just annoying that
I have to keep doing it. Let’s extend org-mode so that this is done automatically.</p>

<h2 id="a-simple-solution">A simple solution</h2>

<p>The first step is to automate the interactive part. Lucky for me this is easy
as <code>org-sort-entries</code> is both a function and a command. I can call it in a
script just as I can run it as a command.</p>

<figure><pre><code data-lang="elisp"><span>(</span><span>defvar</span> <span>org-sort-option</span> <span>&#34;year&#34;</span><span>)</span>

<span>(</span><span>defun</span> <span>org-sort-run</span> <span>()</span>
  <span>(</span><span>when</span> <span>(</span><span>and</span> <span>(</span><span>derived-mode-p</span> <span>&#39;org-mode</span><span>)</span> <span>org-sort-option</span><span>)</span>
    <span>(</span><span>let</span> <span>((</span><span>case-sensitive</span> <span>nil</span><span>)</span>
	  <span>(</span><span>sorting-type</span> <span>?r</span><span>)</span>
	  <span>(</span><span>getkey-func</span> <span>nil</span><span>)</span>
	  <span>(</span><span>compare-func</span> <span>nil</span><span>)</span>
	  <span>(</span><span>property</span> <span>org-sort-option</span><span>)</span>
	  <span>(</span><span>interactive?</span> <span>nil</span><span>))</span>
      <span>(</span><span>org-sort-entries</span> <span>case-sensitive</span> <span>sorting-type</span> <span>getkey-func</span> <span>compare-func</span> <span>property</span> <span>interactive?</span><span>))))</span></code></pre></figure>

<p>This solves one part of the problem. Let’s solve the other one, automatically calling
<code>org-sort-run</code> whenever an org-mode buffer is saved.</p>

<p>Emacs already has support for this use-case through the use of hooks. We can run
<code>org-sort-run</code> all the times we want to save a buffer.</p>

<figure><pre><code data-lang="elisp"><span>(</span><span>add-hook</span> <span>&#39;before-save-hook</span> <span>#&#39;</span><span>org-sort-run</span><span>)</span></code></pre></figure>

<p>These two together solve the problem but the solution presented is “just more code”.
We tapped into the <em>hook</em> extension point but this would be possible in any
<em>scriptable system</em> that exposes well-defined extension points such as hooks and commands.</p>

<h2 id="leveraging-emacs-extensibility-to-extend-org-mode">Leveraging Emacs’ extensibility to extend org-mode</h2>

<p>I want to show that even if something is not thought with
extensibility in mind Emacs allow us to extend it. Most importantly, while we
want to extend org-mode’s behavior we would like this not to be an
extension to org-mode’s code.</p>

<p>Here’s the updated problem statement. Have the buffer be automatically
sorted and have the sorting criteria be in the buffer itself. We will
specify the sorting as a <em>in-buffer setting</em> and use Emacs to
support this never thought before org-mode behavior.</p>

<p>Our example buffer changes to the following.</p>

<figure><pre><code data-lang="diff"> #+TITLE: My tematic reading list
<span>+#+SORT: year
</span> 
 * Paper which is old but not too old
 :PROPERTY:
 :year: 2002
 :END:
 
 * Definitely older paper but unfortunately it&#39;s later in the list
 :PROPERTY:
 :year: 1998
 :END:</code></pre></figure>



<p>The hard part of this is to find how org-mode reads <em><a href="https://orgmode.org/manual/In_002dbuffer-Settings.html">in-buffer
settings</a></em>
from the header. A <kbd>M-x find-library</kbd> later we are in org’s
sources.</p>

<p>Searching for <code>+STARTUP</code> (<kbd>Ctrl+s +STARTUP</kbd>), one of the
supported settings, leads us to <code>org-startup-folded</code> and that in turn
(<kbd>Ctrl+s org-startup-folded</kbd>) leads us to <code>org-startup-options</code>.</p>

<p><code>org-startup-options</code> is the used by (again <kbd>Ctrl+s org-startup-option</kbd>)
<code>org-set-regexps-and-options</code>.</p>



<p>While the documentation for this function is not very convincing, its code
does make sense for what we are after. I copied it here for reference.</p>

<figure><pre><code data-lang="elisp">  <span>(</span><span>when</span> <span>(</span><span>derived-mode-p</span> <span>&#39;org-mode</span><span>)</span>
    <span>(</span><span>let</span> <span>((</span><span>alist</span> <span>(</span><span>org-collect-keyword</span>
		  <span>(</span><span>append</span> <span>&#39;</span><span>(</span><span>&#34;FILETAGS&#34;</span> <span>&#34;TAGS&#34;</span><span>)</span>
			  <span>(</span><span>and</span> <span>(</span><span>not</span> <span>tags-only</span><span>)</span>
			       <span>&#39;</span><span>(</span><span>&#34;ARCHIVE&#34;</span> <span>&#34;CATEGORY&#34;</span> <span>&#34;COLUMNS&#34;</span> <span>&#34;CONSTANTS&#34;</span>
				 <span>&#34;LINK&#34;</span> <span>&#34;OPTIONS&#34;</span> <span>&#34;PRIORITIES&#34;</span> <span>&#34;PROPERTY&#34;</span>
				 <span>&#34;SEQ_TODO&#34;</span> <span>&#34;STARTUP&#34;</span> <span>&#34;TODO&#34;</span> <span>&#34;TYP_TODO&#34;</span><span>)))</span>
		  <span>&#39;</span><span>(</span><span>&#34;ARCHIVE&#34;</span> <span>&#34;CATEGORY&#34;</span> <span>&#34;COLUMNS&#34;</span> <span>&#34;PRIORITIES&#34;</span><span>))))</span>
      <span>;; Startup options.  Get this early since it does change</span>
      <span>;; behavior for other options (e.g., tags).</span>
      <span>(</span><span>let</span> <span>((</span><span>startup</span> <span>(</span><span>cl-mapcan</span> <span>(</span><span>lambda</span> <span>(</span><span>value</span><span>)</span> <span>(</span><span>split-string</span> <span>value</span><span>))</span>
				<span>(</span><span>cdr</span> <span>(</span><span>assoc</span> <span>&#34;STARTUP&#34;</span> <span>alist</span><span>)))))</span>
	     <span>...</span><span>)</span></code></pre></figure>

<p>Unfortunately this function calls <code>org-collect-keyword</code> with a list that we cannot
touch. There is no custom variable to set to pass our own keyword.</p>

<p>If this was a “normal programming environment” we would make our changes
to this function body and forever maintain a fork of org-mode. As this
is elisp instead we have choices.</p>

<p>I think the best choice is to use <code>advice-add</code> and have Emacs call our
advice code every time <code>org-set-regexps-and-options</code> is called. We will copy
what we need from the function body but that will be all.</p>

<p>This is what I ended up with.</p>

<figure><pre><code data-lang="elisp"><span>(</span><span>defvar</span> <span>org-sort-option</span> <span>nil</span><span>)</span>

<span>(</span><span>defun</span> <span>org-sort-set-option</span> <span>(</span><span>&amp;rest</span> <span>r</span><span>)</span>
  <span>&#34;Read the +SORT: spec value into variable `org-sort-option&#39;.&#34;</span>
  <span>(</span><span>when</span> <span>(</span><span>derived-mode-p</span> <span>&#39;org-mode</span><span>)</span>
    <span>(</span><span>let</span> <span>((</span><span>alist</span> <span>(</span><span>org-collect-keywords</span> <span>&#39;</span><span>(</span><span>&#34;SORT&#34;</span><span>))))</span>
      <span>(</span><span>let</span> <span>((</span><span>sort</span> <span>(</span><span>cdr</span> <span>(</span><span>assoc</span> <span>&#34;SORT&#34;</span> <span>alist</span><span>))))</span>
	<span>(</span><span>let</span> <span>((</span><span>sort-spec</span> <span>(</span><span>car</span> <span>(</span><span>read-from-string</span> <span>(</span><span>car</span> <span>sort</span><span>)))))</span>
	  <span>(</span><span>setq-local</span> <span>org-sort-option</span> <span>sort-spec</span><span>))))))</span>

<span>(</span><span>advice-add</span> <span>&#39;org-set-regexps-and-options</span> <span>:after</span> <span>#&#39;</span><span>org-sort-set-option</span><span>)</span>

<span>(</span><span>defun</span> <span>org-sort-run</span> <span>()</span>
  <span>(</span><span>when</span> <span>(</span><span>and</span> <span>(</span><span>derived-mode-p</span> <span>&#39;org-mode</span><span>)</span> <span>org-sort-option</span><span>)</span>
    <span>(</span><span>let</span> <span>((</span><span>case-sensitive</span> <span>nil</span><span>)</span>
	  <span>(</span><span>sorting-type</span> <span>?r</span><span>)</span>
	  <span>(</span><span>getkey-func</span> <span>nil</span><span>)</span>
	  <span>(</span><span>compare-func</span> <span>nil</span><span>)</span>
	  <span>(</span><span>property</span> <span>org-sort-option</span><span>)</span>
	  <span>(</span><span>interactive?</span> <span>nil</span><span>))</span>
      <span>(</span><span>org-sort-entries</span> <span>case-sensitive</span> <span>sorting-type</span> <span>getkey-func</span> <span>compare-func</span> <span>property</span> <span>interactive?</span><span>))))</span>

<span>(</span><span>add-hook</span> <span>&#39;before-save-hook</span> <span>#&#39;</span><span>org-sort-run</span><span>)</span></code></pre></figure>

<p>We keep a buffer-local variable <code>org-sort-option</code> around to store the
property name read from <code>#+SORT: property-name</code>. This variable is initially
<code>nil</code> and will be set from the property name in <code>#+SORT: property-name</code>. To do so
we have a function <code>org-sort-set-option</code>.</p>

<p>But when to call <code>org-sort-set-option</code>? The easy way out is to have Emacs call it whenever
<code>org-set-regexps-and-options</code> is called on a file visit. To achieve this we
tap into <code>advice-add</code> and ask Emacs to run <code>org-sort-set-option</code> after
<code>org-sort-regexps-and-options</code>.</p>

<p>We have now succesfully interposed ourselves in the control flow of the org-mode library.</p>

<p>Org-mode did not provide any interposition point for us, there
is no thought ahead etension-point or configuration variable we can
use to achieve our goal an yet here we are with a sorted buffer.</p>

<p>We succeeded in our effort because <em>Emacs wants you to extend it</em>
and it gives you all the means to do so.</p>

<h2 id="conclusions">Conclusions</h2>

<p>I have made a horrible hack and it works. I have learnt nothing about
how org-mode works or Emacs’ file-visiting extension-points.</p>

  </div>

</article>

      </div>
    </div></div>
  </body>
</html>
