<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.carlmjohnson.net/post/2021/golang-118-minor-features/">Original</a>
    <h1>Three Minor Features in Go 1.18</h1>
    
    <div id="readability-page-1" class="page"><div>
<div>
<main>
<article>
<header>

<time datetime="2021-12-21T00:00:00Z">
Tuesday, December 21, 2021
</time>
</header>
<section>
<p>Everyone is excited that after <a href="https://blog.carlmjohnson.net/post/google-go-the-good-the-bad-and-the-meh/">a decade or so</a> of devs asking for generics, the Go programming language is getting <a href="https://go.dev/blog/why-generics">generic types and functions</a> in Go 1.18 in Q1 2022. Generics are no doubt going to lead to a lot of experiments, some <a href="https://github.com/carlmjohnson/deque/">good</a>, some <a href="https://github.com/carlmjohnson/new/">bad</a>, some <a href="https://github.com/carlmjohnson/truthy/">just weird</a>. Go 1.18 is also poised to lead to an increase in software reliability by <a href="https://go.dev/blog/fuzz-beta">including fuzzing</a> as part of the standard testing package. But today, I want to look at some minor changes in Go 1.18 that might otherwise get lost in all the excitement around the marquee features.</p>
<h2 id="1-version-control-information-included-in-the-binary">1. Version control information included in the binary</h2>
<p>In both my post <a href="https://blog.carlmjohnson.net/post/2016-11-27-how-to-use-go-generate/">on <code>//go:generate</code></a> and <a href="https://blog.carlmjohnson.net/post/2021/how-to-use-go-embed/">on <code>//go:embed</code></a>, one of the motivating examples was being able to embed information about the Git commit hash used to create a binary into it. In Go 1.18, this becomes an automatic part of the everyday <code>go</code> command.</p>
<p>The <a href="https://pkg.go.dev/runtime/debug@master#BuildInfo"><code>runtime/debug.BuildInfo</code></a> returned by <a href="https://pkg.go.dev/runtime/debug@master#ReadBuildInfo"><code>runtime/debug.ReadBuildInfo()</code></a> has been updated to include a new field <code>Settings []debug.BuildSetting</code>. <a href="https://pkg.go.dev/runtime/debug@master#BuildSetting"><code>Settings</code></a> in turn are key-value pairs describing a binary. The commit hash is the value for the key <code>vcs.revision</code>, and <code>vcs.time</code> does what you would expect. There’s even <code>vcs.modified</code> to tell you if the build was “dirty” or “clean”.</p>
<p>Because reading this out of a slice of <code>debug.BuildSetting</code> is slightly convoluted, I wrote a small package called <a href="https://github.com/carlmjohnson/versioninfo/">versioninfo</a> that sets <code>versioninfo.Revision</code>, <code>versioninfo.LastCommit</code>, and <code>versioninfo.DirtyBuild</code> by reading the debug info at startup, but <a href="https://blog.carlmjohnson.net/post/2020/avoid-dependencies/">feel free to write your own helper library</a>.</p>
<h2 id="2-new-httpmaxbyteshandler-middleware">2. New <code>http.MaxBytesHandler</code> middleware</h2>
<p>There’s not much to say about <a href="https://pkg.go.dev/net/http@master#MaxBytesHandler"><code>http.MaxBytesHandler</code></a>, except to brag that <a href="https://golang.org/cl/346569">I wrote it</a>. <a href="https://blog.carlmjohnson.net/post/2020/add-func/">Unlike <code>flag.Func</code></a>, I didn’t actually design it though. It’s just a five line function that <a href="https://github.com/golang/go/issues/39567">had been requested and approved in the Go issues tracker</a>, and I figured it was simple enough to write and submit between other tasks.</p>
<p>Here’s the docstring:</p>
<blockquote>
<p><code>MaxBytesHandler</code> returns a <code>Handler</code> that runs h with its <code>ResponseWriter</code> and <code>Request.Body</code> wrapped by a <code>MaxBytesReader</code>.</p>
</blockquote>
<p>The use case for this is if you’re exposing your server directly to the internet, you may want to put a cap on how large of requests you’ll process to avoid denial of service attacks. This could already be done <em>inside</em> a handler with <a href="https://pkg.go.dev/net/http#MaxBytesReader"><code>http.MaxBytesReader</code></a>, but by enforcing a limit at the middleware level, now you can ensure that it’s not accidentally forgotten in some neglected corner of your web server.</p>
<h2 id="3-unreasonably-effective-stringscut-function">3. Unreasonably effective <code>strings.Cut</code> function</h2>
<p>Something I don’t have any connection to, whatsoever<i>!</i> I just think it’s neat. (Although the name is a little confusing.) <a href="https://pkg.go.dev/strings@master#Cut"><code>strings.Cut</code></a> is similar to <a href="https://docs.python.org/3/library/stdtypes.html#str.partition"><code>str.partition</code> in Python</a>. It cuts a string into two pieces at the first place it find the separator substring. As Russ Cox wrote <a href="https://github.com/golang/go/issues/46336">in the issue introducing the function</a>:</p>
<blockquote>
<h3 id="the-unreasonable-effectiveness-of-cut">The Unreasonable Effectiveness of Cut</h3>
<p>To attempt to cut off the bikeshedding this time, let me present data showing why Cut is worth adding.</p>
<p>Anecdotally, after the discussion on <a href="https://github.com/golang/go/issues/40135">#40135</a> I copied the suggested implementation of Cut into every program that I wrote that could use it for a while, and that turned out to be just about every program I wrote that did anything with strings. That made me think there is something here.</p>
<p>To check that belief, I recently searched for uses of strings.Index, strings.IndexByte, or strings.IndexRune in the main repo and converted the ones that could use strings.Cut instead. Calling those all “Index” for the sake of discussion (any call with a constant sep should use Index anyway), there were:</p>
<ul>
<li>311 Index calls outside examples and testdata.</li>
<li>20 should have been Contains</li>
<li>2 should have been 1 call to IndexAny</li>
<li>2 should have been 1 call to ContainsAny</li>
<li>1 should have been TrimPrefix</li>
<li>1 should have been HasSuffix</li>
</ul>
<p>That leaves 285 calls. Of those, 221 were better written as Cut, leaving 64 that were not. That is, 77% of Index calls are more clearly written using Cut. That’s incredible!</p>
<p>A typical rewrite is to replace:</p>
<pre tabindex="0"><code>  // The first equals separates the key from the value.
  eq := strings.IndexByte(rec, &#39;=&#39;)
  if eq == -1 {
      return &#34;&#34;, &#34;&#34;, s, ErrHeader
  }
  k, v = rec[:eq], rec[eq+1:]
</code></pre><p>with</p>
<pre tabindex="0"><code>  // The first equals separates the key from the value.
  k, v, ok = strings.Cut(rec, &#34;=&#34;)
  if !ok {
      return &#34;&#34;, &#34;&#34;, s, ErrHeader
  }
</code></pre></blockquote>
<p>…</p>
<blockquote>
<p>Looking in my public Go corpus, I found 88,230 calls to strings.SplitN. Of these, 77,176 (87%) use a fixed count 2. I expect that essentially all of them would be more clearly written using Cut.</p>
<p>It is also worth noting that something like Cut had been reinvented in two different packages as an unexported function: golang.org/x/mod/sumdb/note’s chop (7 uses) and net/url’s split (4 uses). Clearly, slicing out the separator is an incredibly common thing to do with the result of strings.Index.</p>
<p>The conversions described here can be viewed in <a href="https://golang.org/cl/322210">CL 322210</a>.</p>
<p>As noted in #40135, Cut is similar to Python’s str.partition(sep), which returns (before, sep, after) if sep is found and (str, &#34;&#34;
, &#34;&#34;) if not. The boolean result seems far more idiomatic in Go, and it was used directly as a boolean in over half the Cut calls I introduced in the main repo. That is, the fact that str.partition is useful in Python is added evidence for Cut, but we need not adopt the Pythonic signature. (The more idiomatic Go signature was first suggested by @nightlyone.)</p>
<p>Again, Cut is a single function that replaces and simplifies the overwhelming majority of the usage of four different standard library functions at once (Index, IndexByte, IndexRune, and SplitN), and it has been invented twice in the main repo. That seems above the bar for the standard library.</p>
</blockquote>
<p>Anyhow, since reading about <code>strings.Cut</code>, I’ve been copying and pasting cut <a href="https://www.reddit.com/r/golang/comments/rincmj/why_i_wrote_my_own_go_http_client/hoybhxi/?context=1">into everything</a> while I wait for it to come out, and it really is super-useful. Is it maybe even my most hotly anticipated feature in Go 1.18?</p>
<p>Nah, but it is a really nice minor feature.</p>
<blockquote><p lang="en" dir="ltr">I wrote about getting excited for some of minor features in <a href="https://twitter.com/hashtag/Golang?src=hash&amp;ref_src=twsrc%5Etfw">#Golang</a> 1.18.<a href="https://t.co/CaeCFCHrme">https://t.co/CaeCFCHrme</a></p>— Carl Johnson (@carlmjohnson) <a href="https://twitter.com/carlmjohnson/status/1473092972661125130?ref_src=twsrc%5Etfw">December 21, 2021</a></blockquote>

</section>

</article>
</main>
</div>
</div></div>
  </body>
</html>
