<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://composehq.com/blog/scaling-websockets-1-23-25">Original</a>
    <h1>The hidden complexity of scaling WebSockets</h1>
    
    <div id="readability-page-1" class="page"><div><p>With the rising demand for sync engines and real-time feature, WebSockets have become a critical component for modern applications. At Compose, WebSockets form the backbone of our service, powering our backend SDKs that enable developers to deliver low-latency interactive applications with just backend code.</p><p>But, scaling WebSockets has proven to be far more complex than we expected. Below are some of the most important lessons we&#39;ve learned along the way.</p><h3>Handle deployments gracefully</h3><div><p>Users should never notice when deployments happen, so WebSocket connections need to persist across deployments. This is a delicate process, and requires robust reconnection logic to deal with unexpected issues. At Compose, we achieve near-zero downtime by following these steps:</p><ol><li><p>Spin up new servers.</p></li><li><p>Once the new servers are healthy, old servers begin returning <code>503 Service Unavailable</code> <!-- -->responses to health checks.</p></li><li><p>After 4 consecutive <code>503</code> responses, the load balancer declares the server unhealthy and removes the old servers from the pool. The load balancer health checks every 5 seconds, so this process takes up to 25 seconds.</p></li><li><div><p>Old servers send a custom WebSocket close message instructing clients to delay reconnection by a random interval to avoid a reconnection surge.</p><ul><li><p>The custom close message lets clients show users a more accurate message during the ~10 second period where the client is disconnected.</p></li><li><p>The random delay helps prevent thundering herd issues where all clients reconnect at once. Clients also double the exponential backoff for deployment-related reconnections to account for unforseen issues.</p></li><li><p>The close message is delayed by 20 seconds to account for the time it takes for the load balancer to shift traffic.</p></li></ul></div></li><li><p>Once all clients disconnect, the old servers shut down completely.</p></li></ol></div><p>If you&#39;re using a managed service like Render or Railway, you should be especially cognizant that client connections are transferred gracefully during deployments.</p><p>Many managed services that tout zero-downtime deployments will wait until all outstanding requests are processed before shutting down a server. Since WebSocket connections are persistent, this can lead to situations in which old servers are active for minutes or even hours after a deploy until the managed service forcibly terminates the process.</p><h3>Establish a consistent message schema</h3><div><p>While HTTP comes with built-in routing conventions (<code>GET /user</code>,</p><!-- --> <p><code>POST /company</code>,</p><!-- --> <p><code>PUT /settings</code>), WebSockets require developers to define their own schema for organizing messages.</p></div><div><p>At Compose, every WebSocket message starts with a fixed 2-byte</p><!-- --> <p><code>type</code> prefix for categorizing messages.</p><ul><li><p>It&#39;s space-efficient (only 2 bytes), while still scaling to 65,536 different types.</p></li><li><p>It enables clients to reliably slice the<!-- --> <code>type</code> prefix from the message without affecting the rest of the data, since the prefix is always 2 bytes.</p></li><li><p>It gives us a simple method for upgrading our APIs by versioning message types.</p></li></ul></div><div><div><pre aria-hidden="true"><span> </span>
<span> </span>
<span> </span>
<span> </span>
<span> </span>
<span> </span>
<span> </span>
</pre><pre><code><span>const</span> <span>MESSAGE_TYPE_TO_HEADER</span> = {
  <span>RENDER_UI</span>: <span>&#34;aa&#34;</span>,
  <span>UPDATE_UI</span>: <span>&#34;ab&#34;</span>,
  <span>SHOW_LOADING</span>: <span>&#34;ac&#34;</span>,
  <span>RENDER_UI_V2</span>: <span>&#34;ad&#34;</span>,
  
}</code></pre></div></div><p>Additionally, we use delimiters to separate different fields inside the message, which is both faster to encode/decode and more memory-efficient than JSON.</p><div><div><pre aria-hidden="true"><span> </span>
<span> </span>
<span> </span>
<span> </span>
<span> </span>
<span> </span>
<span> </span>
<span> </span>
<span> </span>
<span> </span>
</pre><pre><code><span>const</span> <span>DELIMITER</span> = <span>&#34;|&#34;</span>;

<span>function</span> <span>createDelimitedMessage</span>(<span><span>type</span>: <span>string</span>, <span>args</span>: <span>any</span>[]</span>) {
  <span>return</span> [<span>MESSAGE_TYPE_TO_HEADER</span>[<span>type</span>], ...args].<span>join</span>(<span>DELIMITER</span>);
}

<span>function</span> <span>parseDelimitedMessage</span>(<span><span>message</span>: <span>string</span></span>) {
  <span>const</span> [<span>type</span>, ...args] = message.<span>split</span>(<span>DELIMITER</span>);
  <span>return</span> { <span>type</span>, args };
}</code></pre></div></div><p>We&#39;re lucky that our backend and frontend are written in TypeScript, allowing us to share message schemas between the two and ensure that neither falls out of sync.</p><h3>Detect silent disconnects with heartbeats</h3><div><p>Connections can drop unexpectedly without triggering a</p><!-- --> <p><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close_event">close event</a>, leading to a situation in which the client thinks they&#39;re connected, but actually aren&#39;t. To prevent stale connections, implementing a robust heartbeat mechanism is essential.</p></div><div><p>We send periodic</p><!-- --> <p><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#pings_and_pongs_the_heartbeat_of_websockets">ping/pong messages</a></p><!-- --><p>between client and server and reconnect in cases where the heartbeat isn&#39;t received within some interval.</p></div><div><p>Our server sends a <code>ping</code> message every 30 seconds, and expects a <code>pong</code> response. In cases where the client doesn&#39;t receive a</p><!-- --> <p><code>ping</code> every 45 seconds, it immediately drops the connection and tries to reconnect. Similarly, the server closes connections that miss <code>pong</code></p><!-- --><p>responses within 45 seconds.</p></div><p>By monitoring heartbeats on both ends, we detect and handle rare cases where the client side network appears functional but the server never receives responses.</p><h3>Have an HTTP fallback</h3><div><p>WebSocket connections can be unexpectedly blocked, especially on restrictive public networks. To mitigate such issues, Compose uses</p><!-- --> <p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events">server-sent events (SSE)</a></p><!-- --><p>as a fallback for receiving updates, while HTTP requests handle client-to-server communication.</p></div><p><img src="https://jamiepalatnik.com/blog-scaling-websockets-fallback.png" alt="SSE fallback"/></p><p>Since SSE is HTTP-based, it&#39;s much less likely to be blocked, providing a reliable alternative in restricted environments. Plus it still achieves decently low latency, especially compared to short-polling solutions.</p><h3>Concluding thoughts</h3><div><p>There&#39;s a whole lot more to scaling WebSockets that we didn&#39;t cover here. For example:</p><ul><li><p><span>Lack of standard tooling</span>: While most frameworks include built-in tools for rate limiting, data validation, and error handling, you&#39;ll generally have to implement these features on your own for WebSockets.</p></li><li><p><span>Inability to cache responses</span>: Edge networks make it easy to cache HTTP responses close to users, but there&#39;s no standard way to accomplish this with WebSockets.</p></li><li><p><span>Per-message authentication</span>: Guarding against abuse by ensuring that each message is valid for that user before processing it.</p></li></ul></div><p>But regardless of the complexity, users expect modern applications to be fast, realtime, and collaborative. And, as of now, there&#39;s no better way to achieve that than WebSockets.</p><div><p>At Compose, WebSockets power the entire platform - from the database all the way to the main UI thread. Via our SDKs, developers can generate full web apps from their backend logic. Making sure those apps are fast and performant at scale requires WebSockets. If you&#39;re interested in learning more,</p><!-- --> <p><a href="https://docs.composehq.com" target="_blank" rel="noopener noreferrer">check out our docs</a>. It takes less than 5 minutes to install the SDK and build your first app.</p></div></div></div>
  </body>
</html>
