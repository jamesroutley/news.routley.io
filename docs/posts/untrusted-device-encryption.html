<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://docs.syncthing.net/specs/untrusted.html">Original</a>
    <h1>Untrusted Device Encryption</h1>
    
    <div id="readability-page-1" class="page"><div role="main">
            
  <div>
<p>Warning</p>
<p>This feature should still be considered beta / testing only.</p>
</div>
<section id="untrusted-device-encryption">
<span id="untrusted"></span>
<section id="threat-model-primary-goals">
<h2>Threat Model / Primary Goals<a href="#threat-model-primary-goals" title="Permalink to this heading">¶</a></h2>
<p>An “untrusted” device can participate in a Syncthing cluster with the
following assumptions and limitations;</p>
<p>The untrusted device can <em>not</em> observe:</p>
<ul>
<li><p>File data</p></li>
<li><p>File or directory names, symlink names, symlink targets</p></li>
<li><p>File modification time, permissions, or modification history (version
vectors)</p></li>
</ul>
<p>The untrusted device <em>will</em> be able to observe:</p>
<ul>
<li><p>File sizes <a href="#sizes" id="id1" role="doc-noteref"><span>[</span>1<span>]</span></a></p></li>
<li><p>Which parts of files are changed by the other devices and when</p></li>
</ul>
<p>The last point is required by the syncing mechanism, in order to avoid
transferring all unchanged file data when a file block changes. Blocks and
block hashes are encrypted with a per-file key and depends on the block
offset, so correlation is not possible between blocks at different offsets
or different files.</p>
<p>In addition the untrusted device <em>must not</em> be able to modify, remove or
introduce data by itself without detection.</p>
</section>
<section id="primitives-used">
<h2>Primitives Used<a href="#primitives-used" title="Permalink to this heading">¶</a></h2>
<p>The user input to the system is the <em>folder ID</em>, which is a short string
identifying a given folder between devices, and the <em>password</em>. From this we
generate a <em>folder key</em> (32 bytes) using <code><span>scrypt</span></code>:</p>
<div><div><pre><span></span><span>folderKey</span> <span>=</span> <span>scrypt</span><span>.</span><span>Key</span><span>(</span><span>password</span><span>,</span> <span>&#34;syncthing&#34;</span> <span>+</span> <span>folderID</span><span>)</span>
</pre></div>
</div>
<p>The string “syncthing” with the folder ID concatenated make up the salt. The
folder key is used to encrypt file names using AES-SIV without nonce:</p>
<div><div><pre><span></span><span>encryptedFilename</span> <span>=</span> <span>AES</span><span>-</span><span>SIV</span><span>(</span><span>filename</span><span>,</span> <span>folderKey</span><span>)</span>
</pre></div>
</div>
<p>Given the key length of 32 bytes the algorithm in use will be AES-128
(“AES-SIV-256”). To make the encrypted file name usable again as a file
name, we encode it using base32 and add slashes at strategic places.</p>
<p>From the folder key and the plaintext file name we derive the <em>file key</em> by
HKDF of the folder key and the plaintext file name:</p>
<div><div><pre><span></span><span>fileKey</span> <span>=</span> <span>HKDF</span><span>(</span><span>SHA256</span><span>,</span> <span>folderKey</span><span>+</span><span>filename</span><span>,</span> <span>salt</span><span>:</span> <span>&#34;syncthing&#34;</span><span>,</span> <span>info</span><span>:</span> <span>nil</span><span>)</span>
</pre></div>
</div>
<p>This file key is used for all other encryption, specifically file block
hashes and data blocks. In file metadata, block hashes are encrypted using
AES-SIV with the file key:</p>
<div><div><pre><span></span><span>encryptedBlockHash</span> <span>=</span> <span>AES</span><span>-</span><span>SIV</span><span>(</span><span>blockHash</span><span>,</span> <span>fileKey</span><span>)</span>
</pre></div>
</div>
<p>Data blocks are encrypted using XChaCha20-Poly1305 with random nonces and
appended to the nonce itself:</p>
<div><div><pre><span></span><span>encryptedBlock</span> <span>=</span> <span>nonce</span> <span>+</span> <span>XChaCha20</span><span>-</span><span>Poly1305</span><span>.</span><span>Seal</span><span>(</span><span>block</span><span>,</span> <span>nonce</span><span>,</span> <span>fileKey</span><span>)</span>
</pre></div>
</div>
<p>The original file metadata descriptor is encrypted in the same manner and
attached to the encrypted-file metadata.</p>
<p>Devices sharing a folder need to use the same password.
To ensure that a <em>password token</em> in the form of an arbitrary, but commonly
known string encrypted using AES-SIV with the folder key is sent in the
<a href="https://docs.syncthing.net/specs/bep-v1.html#cluster-config"><span>Cluster Config</span></a>:</p>
<div><div><pre><span></span><span>passwordToken</span> <span>=</span> <span>AES</span><span>-</span><span>SIV</span><span>(</span><span>&#34;syncthing&#34;</span> <span>+</span> <span>folderID</span><span>,</span> <span>folderKey</span><span>)</span>
</pre></div>
</div>
<p>Thus an encrypted device can verify all its connected devices use the same
password comparing the encrypted token, without knowing the password itself.</p>
<div>
<p>Note</p>
<p>In Syncthing a file is made up of a number of equal size data blocks,
followed by a usually shorter last data block. The full size data blocks
are at minimum 128 KiB, ranging up to 16 MiB in multiples of two. The
last data block can in principle be as small as one byte. For untrusted
folders the size of the last data block is padded up to a kilobyte if it
was shorter to begin with. The untrusted device isn’t allowed to request
less than a kilobyte of data.</p>
<p>I don’t actually know if this block padding serves a purpose. It was
added to address a worry that something might break or leak if an
attacker is allowed to repeatedly request single-byte data blocks of
their choosing. If there is nothing to worry about here we can remove
the padding. //jb</p>
</div>
<div>
<p>Note</p>
<p>While a well behaved implementation is expected to request data blocks
precisely as announced in the file metadata there is no enforcement of
this. This means that an attacker on the untrusted side can repeatedly
request arbitrary ranges of a file and receive the encrypted result.
With the restriction above, the minimum block size that can be requested
in 1024 bytes.</p>
</div>
</section>
<section id="implementation-details">
<h2>Implementation Details<a href="#implementation-details" title="Permalink to this heading">¶</a></h2>
<section id="metadata-encryption">
<h3>Metadata Encryption<a href="#metadata-encryption" title="Permalink to this heading">¶</a></h3>
<p>The Syncthing protocol is essentially two-phase:</p>
<ul>
<li><p>A device sends file metadata (a <code><span>FileInfo</span></code> structure) for a new or changed file</p></li>
<li><p>The other side determines which blocks it needs to construct the new file, and requests these blocks</p></li>
</ul>
<p>For untrusted devices a fake FileInfo is constructed, with an encrypted
name and block list and other metadata such as modification time and
permissions set to static values.</p>
<p>An original file metadata structure looks something like this:</p>

<p>The fake FileInfo encrypts and adjusts a couple of attributes:</p>
<ul>
<li><p>The name is encrypted (with the folder key), base32 encoded, and slashes
are inserted after the first and third characters, and then every 200
characters.</p></li>
<li><p>The file size is adjusted for the per block overhead, and rounded up so that
the last block is a multiple of 1024 bytes.</p></li>
<li><p>The block size is adjusted for block overhead.</p></li>
</ul>
<p>Other file attributes are set to static values, for example the modification
time is set to UNIX epoch time 1234567890 and permissions are set to 0644.</p>
<p>The block list is encrypted and adjusted:</p>
<ul>
<li><p>The offset and size are adjusted to account for block overhead</p></li>
<li><p>The hash is encrypted using AES-SIV (with the file key)</p></li>
</ul>
<p>The resulting encrypted hash can’t be used for data verification by the
untrusted device, but it can be used as a form of “token” referring to a
given data block for reuse purposes.</p>
<p>Finally, the whole original FileInfo (in protobuf form) is encrypted using
XChaCha20-Poly1305 with the file key and attached to the fake FileInfo. This
is retained on the untrusted side and passed along to trusted devices, where
it will be used in place of the fake FileInfo.</p>

</section>
<section id="incoming-metadata">
<h3>Incoming Metadata<a href="#incoming-metadata" title="Permalink to this heading">¶</a></h3>
<p>File metadata sent from the untrusted device is always decrypted. This means
the original FileInfo is discarded and the attached encrypted FileInfo is
decrypted and used instead. If the FileInfo does not decrypt it’s considered
a protocol error and the connection is dropped. This means only file
metadata created by a trusted device is accepted.</p>
</section>
<section id="data-encryption">
<h3>Data Encryption<a href="#data-encryption" title="Permalink to this heading">¶</a></h3>
<p>When an untrusted device makes a request for a data block, the trusted
device:</p>
<ol>
<li><p>decrypts the given filename,</p></li>
<li><p>reads the corresponding plaintext data block,</p></li>
<li><p>pads the block with random data if the read returned less than 1024 bytes,</p></li>
<li><p>encrypts it using the file encryption key and a random nonce, and</p></li>
<li><p>responds with the result.</p></li>
</ol>

<p>This is repeated for all required blocks. At the end, the untrusted device
appends the fake FileInfo (which includes the original, encrypted, FileInfo)
to the file. This serves no purpose during normal operations, but enables
offline decryption of an encrypted folder without database access and, in
principle, scanning an encrypted folder to populate the database should it
be lost or corrupted.</p>

</section>
<section id="incoming-data">
<h3>Incoming Data<a href="#incoming-data" title="Permalink to this heading">¶</a></h3>
<p>Making a request to an untrusted device is mostly the reverse of the above.
The file name is encrypted and the block offset and size adjusted. The
resulting data is decrypted and thereby also authenticated, meaning it must
have originated on a trusted device. Contrary to the usual case we cannot
simply make arbitrary range requests – only the precise blocks that were
encrypted to begin with will decrypt properly.</p>
<p>—</p>

</section>
</section>
</section>


          </div></div>
  </body>
</html>
