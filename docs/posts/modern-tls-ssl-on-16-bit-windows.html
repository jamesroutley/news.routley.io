<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.dialup.net/wingpt/tls.html">Original</a>
    <h1>Modern TLS/SSL on 16-bit Windows</h1>
    
    <div id="readability-page-1" class="page"><article>

<p>
    Lately, there&#39;s been an resurgence of new programs written for retro computers—everything
    from a Slack client to many Wordle clones, to a Mastodon client. But most of these programs, if they
    connect to the Internet, require a proxy running on a modern computer to handle
    the SSL/TLS connection, which almost all APIs nowadays require. For my Gateway 4DX2-66 running
    Windows 3.11 for Workgroups, making it reliant on a modern machine for any kind of real Internet
    use is a sad state of affairs—so I decided to change the status quo.
</p>
<p>
    It wasn&#39;t that Windows 3.1 didn&#39;t support secure connections; Internet Explorer 2, for instance,
    supported SSL. But over time, both clients and servers have upgraded to newer versions of the SSL
    (now called TLS) protocol and algorithms, and have dropped support for older versions as
    vulnerabilities like <a href="https://en.wikipedia.org/wiki/POODLE" target="_blank">POODLE</a> are found with them.
</p>
<p>
    Normally, programs can upgrade to using a newer TLS library (e.g. OpenSSL) to get support for
    modern TLS, but one of the biggest barriers to this for Windows 3.1 is that it&#39;s a 16-bit OS;
    TLS libraries today tend to support 32-bit OS&#39;s, and sometimes 16-bit OS&#39;s for embedded hardware,
    but never Windows 3.1 itself.<sup><a href="#footnote1">[1]</a></sup>
</p>
<p>
    I was inspired by
    <a href="https://yeokhengmeng.com/2019/12/building-a-new-win-3-1-app-in-2019-part-1-slack-client/" target="_blank">Yeo Kheng Meng&#39;s notes</a>
    as he discovered the same challenges for his aforementioned Slack client—it seemed possible
    to somehow modify a decent TLS library and convince it to compile and work in the Windows 3.1
    environment, and I wanted to give it a shot to give my Gateway, and other Windows 3.1 computers
    around the world, the ability to connect to most of the Internet again.
</p>
<h2>What does success look like?</h2>
<p>
    To connect to most servers today, we need to be able to speak TLS 1.2.
    Older versions of TLS have widely been deprecated by servers in the last few years.
    TLS 1.3 is the newest version of TLS, standardized in 2018, so it&#39;ll be a bonus to support it as well,
    but not all servers support it yet.
</p>

<table>
    <caption>
        From Wikipedia:
        <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank">Transport Layer Security</a>
    </caption>
    <tbody>
        <tr><th>Protocol</th><th>Published</th><th>Status</th></tr>
        <tr><td>SSL 1.0</td><td>Unpublished</td><td>Unpublished</td></tr>
        <tr><td>SSL 2.0</td><td>1995</td><td>Deprecated in 2011 (RFC 6176)</td></tr>
        <tr><td>SSL 3.0</td><td>1996</td><td>Deprecated in 2015 (RFC 7568)</td></tr>
        <tr><td>TLS 1.0</td><td>1999</td><td>Deprecated in 2021 (RFC 8996)</td></tr>
        <tr><td>TLS 1.1</td><td>2006</td><td>Deprecated in 2021 (RFC 8996)</td></tr>
        <tr><td>TLS 1.2</td><td>2008</td><td>In use since 2008</td></tr>
        <tr><td>TLS 1.3</td><td>2018</td><td>In use since 2018</td></tr>
    </tbody>
</table>

<p>
    We also need to support a set of popular
    <a href="https://en.wikipedia.org/wiki/Cipher_suite" target="_blank">cipher suites</a>,
    or the algorithms that the TLS protocol uses under the hood to actually exchange keys and encrypt data.
    Upon connection, the TLS client tells the server which cipher suites it supports in the &#34;Client Hello&#34;
    message; if the server doesn&#39;t
    support any of them, it will reject the connection with a &#34;No common ciphers&#34; error. There are 37 cipher
    suites for TLS 1.2, so we need to at least support the most common (read: less vulnerable) ones for our client.
</p>
<p>
    One non-goal of this effort was actually creating a <em>secure</em> implementation. Given that I&#39;m already
    throwing security out of the window by using 30-year old software on the Internet, I decided it was
    okay to make some tradeoffs to get a working implementation. The biggest limitations are that I am
    using a fake random number generator, and I am not verifying certificates.
</p>

<h2>Finding the right TLS library</h2>
<p>
    Given the success criteria above, I looked into a few different TLS libraries that might work: OpenSSL,
    BearSSL, Mbed TLS, and WolfSSL. WolfSSL stood out among the pack as it had explicit 16-bit compiler support
    while being fully-featured and well-supported.
    It also had a wide range of support code for all sorts of hardware with different constraints—including
    limited memory—giving me a plethora of examples I could learn from.
</p>
<p>
    I also needed a working TCP/IP stack on Windows. It&#39;s hard to believe now, but Windows 3.x didn&#39;t come with
    TCP/IP built in. There were many options users could choose from, including Trumpet Winsock, a popular
    shareware TCP/IP stack. For my testing purposes, I decided to go with Microsoft&#39;s own TCP/IP implementation,
    TCP/IP-32, which came as a separate download from Microsoft. This provides a TCP/IP implementation which
    you interface through Winsock (the Windows Sockets API)—an older version of the same API you can use even
    today on Windows 11, but it should work with any other implementation.
</p>

<h2>Development environment</h2>
<p>
    My plan was to compile WolfSSL into a DLL that could then be used from any program. Because WolfSSL is
    written in C, I needed a C environment that could create 16-bit Windows DLLs. I decided to use
    <a href="https://github.com/open-watcom/open-watcom-v2" target="_blank">Open Watcom v2</a>, which provides phenomenal
    support for 16-bit Windows programs and DLLs, and cross-compilation including from 64-bit Windows 11.
</p>
<p>
    Unlike with <a href="https://www.dialup.net/windle/">Windle</a>, to make things a bit easier for myself, I did the main development
    on Windows 11,
    with a folder shared to a VirtualBox VM running Windows 2000 (which can run 16-bit programs, unlike Windows 11)
    for most of the iteration and testing; then
    verified at intervals that it still worked on Windows 3.11 for Workgroups.
</p>

<h2>DLL Hell</h2>
<p>
    My first challenge was figuring out how to build and use DLLs on Windows 3.x. To do so, I needed to
    understand the difference between <em>far</em> and <em>near</em> pointers.
</p>
<p>
    Nowadays we tend to conceptually think of pointers to memory as absolute addresses; however,
    when programming for 16-bit Windows, the
    <a href="https://en.wikipedia.org/wiki/X86_memory_segmentation" target="_blank">x86 memory segmentation</a>
    architecture dating back to the Intel 8088 and 8086 CPUs has to be taken into account.
</p>
<p>
    <strong>Disclaimer:</strong> This is my understanding after reading up on this subject. I&#39;ve tried to provide a
    simple explanation on this without going into too much of the details, e.g. the differences between Real
    and Protected modes. Please reach out if anything here is fundamentally incorrect.
</p>
<p>
    With segmentation, memory is split in to <em>segments</em> each up to 64KB in size. A segment might represent
    the code (the instructions) for the program, the data (the global and static local variables), or the
    stack for a program. Addresses in memory consist of two parts: the segment the memory lives in, and the
    offset within that segment. A pointer with this full, two-part address is called a <em>far</em> pointer.
</p>
<table>
    <tbody>
    <tr><td></td><td>Segment:</td><td><span>xxxx xxxx xxxx xxxx</span> 0000</td></tr>
    <tr><td>+</td><td>Offset:</td><td>0000 <span>yyyy yyyy yyyy yyyy</span></td></tr>
    <tr><td>=</td><td>Far pointer:</td><td><span>zzzz zzzz zzzz zzzz zzzz</span></td></tr>
    </tbody>
    <caption>Example of a far pointer<sup><a href="#footnote2">[2]</a></sup></caption>
</table>
<p>
    The system has a set of registers, including the Code Segment (CS), Data Segment (DS), and Stack Segment (SS),
    which keep track of the segments that are applicable to the currently running program. When passing a pointer
    to a function inside the same program, you typically pass just the offset of the variable you&#39;re referencing,
    and the segment is implied. This kind of pointer is called a <em>near</em> pointer, and is used most of the
    time to save on memory.
</p>
<p>
    When calling into a DLL from a program, a few things are different. First, the instructions for a DLL are
    in a different segment from the program&#39;s instructions, so the CS register must be changed to the DLL&#39;s in
    the function call. The C compiler takes care of this for us if we use the non-standard <tt>__far</tt> keyword in
    front of the function name, meaning that the compiler will generate a &#34;far call&#34;.
</p>
<p>
    Second, when passing pointers into DLL functions, we have to use far pointers; DLLs are tricky in that
    when running code in them, the Code and Data segments are those of the DLL, but the Stack segment is
    that of the calling program&#39;s. Using far pointers ensures that the wrong assumptions aren&#39;t made about
    which segments pointers point to.
</p>
<p>
    Another non-standard C keyword that is often used for DLL functions is <tt>__pascal</tt>. This specifies
    that this function uses the Pascal
    <a href="https://en.wikipedia.org/wiki/X86_calling_conventions" target="_blank">calling convention</a>.
    A calling convention specifies how parameters are passed to a function in memory and how the stack is
    cleaned up after a function returns. (With pascal, parameters are pushed on the stack left-to-right and the
    callee removes them from the stack on return). Windows 3.x adopted the
    calling convention used by Borland Pascal (and Delphi 1.0),
    hence the name, but later Windows versions dropped it in favor of <tt>stdcall</tt>.
</p>
<p>
    This means all the functions in WolfSSL that will be called from an external program need to be defined as
    <tt>__far __pascal</tt>. For example, the function to initialize WolfSSL is defined as follows:
</p>
<code>
    int __far __pascal wolfSSL_Init(void);
</code>
<p>
    Everything I&#39;ve said above generally applies to calling the Windows API as well; after all, the Windows API
    is implemented as calls into the DLLs that are part of Windows.
</p>

<h2>Segment too large</h2>
<p>
    The biggest limitation I ran into with porting WolfSSL to 16-bit Windows was the 64KB maximum size of
    segments—each Code and Data segment can only be a maximum of 64KB. This is a challenge when you&#39;re
    compiling a TLS library with support for dozens of cipher suites, and various protocols both commonly and
    rarely used.
</p>
<p>
    Thankfully, we&#39;re not limited to 64KB in total code or data for our DLL. 16-bit compilers have a concept of
    &#34;memory models&#34;, which were defined as Small, Medium, Compact, Large, and Huge. All compilers for the platform,
    whether from Microsoft, Borland, or Open Watcom, support these models as a compile flag; models change how the
    compiler uses far/near pointers and which libraries are used in the generated instructions. I decided to use
    the &#34;Large&#34; memory model, which allows for multiple Code segments and Data segments in your program or DLL.
</p>
<table>
    <caption>
        From <em>Programming Windows 3.1, Third Edition</em> by Charles Petzold
    </caption>
    <tbody>
        <tr><th>Model</th><th>Code Segments</th><th>Data Segments</th></tr>
        <tr><td>Small</td><td>1</td><td>1</td></tr>
        <tr><td>Medium</td><td>Multiple</td><td>1</td></tr>
        <tr><td>Compact</td><td>1</td><td>Multiple</td></tr>
        <tr><td>Large</td><td>Multiple</td><td>Multiple</td></tr>
        <tr><td>Huge</td><td>Multiple</td><td>Multiple</td></tr>
    </tbody>
</table>
<p>
    To save on memory in general, I started by turning off as many compile-time feature flags in WolfSSL as
    I could without jeopardizing
    its ability to connect to most modern TLS servers. This includes features used by insecure cipher suites
    (e.g. MD5, DES, RC4) as well as other features like DTLS and server support I wouldn&#39;t be using for a
    simple TLS client.
</p>
<p>
    I quickly found that even that wasn&#39;t enough, as I&#39;m limited to 64KB of code in each object file.
    Every time an object file hit that limit, the compilation would fail with &#34;Segment too large&#34;.
    In particular, WolfSSL&#39;s <tt>internal.c</tt> file is a whopping 1.25MB
    (<a href="https://github.com/wolfSSL/wolfssl/blob/master/src/internal.c" target="_blank">too large</a>
    for even GitHub to render),
    and would fail the build every time I enabled a feature I needed.
</p>
<p>
    I was able to get that file down to a size that would fit into <em>two</em> segments by moving code around
    into two files, <tt>internal.c</tt> and <tt>internal2.c</tt>—elegant, I know!
    This was the most agonizing and time-consuming part of this whole process; I was in a loop of testing
    the code to see if I had enough features to connect to a server, enabling a feature, seeing &#34;Segment too large&#34;,
    and moving more code while trying not to break the intricate dependencies between functions, or inadvertently
    changing the meaning of the nested <tt>ifdef</tt> macros in the code. Eventually, it compiled.
</p>
<p><img src="https://www.dialup.net/wingpt/images/segment.png" alt="Screenshot of Segment too large error" width="600"/></p>
<p>
    Even with WOLFSSL.DLL compiled, I was running into a strange &#34;Access Denied&#34; error while loading the DLL with the
    <tt>LoadLibrary</tt> Windows API call. Eventually, after much agony, I figured out I needed to turn off debugging
    information in the generated code, and change the target processor from the default (Intel 8086) to 80286 in the
    compiler options.
</p>
<p><img src="https://www.dialup.net/wingpt/images/ccomp.png" alt="Screenshot of Open Watcom Compiler Options dialog" width="600"/></p>

<h2>It works!</h2>
<p>
    Once I got everything compiling, I whipped together a quick test program to hit Qualys SSL Lab&#39;s
    <a href="https://clienttest.ssllabs.com:8443/ssltest/viewMyClient.html">browser capability tester</a>
    and download the results to a file.
</p>
<p>
    I could debug what was going on (especially with missing features) by using Wireshark to decode the
    &#34;Client Hello&#34; message, which is the message that a TLS client sends to the server upon connection
    advertising its capabilities.
</p>
<p><img src="https://www.dialup.net/wingpt/images/client_hello.png" alt="Screenshot of Wireshark showing Client Hello message" width="600"/></p>
<p>
    In my initial builds I was missing the Server Name Indication (SNI) extension, which is generally required
    nowadays to allow servers to host multiple TLS websites on one IP address with different certificates. With
    that added, and after some more code moving to <tt>internal2.c</tt>, I was in business.
</p>
<p>
    After downloading the Qualys results on Windows 3.11 for Workgroups and opening the resulting file in
    Internet Explorer 3, voilà:
</p>
<p><img src="https://www.dialup.net/wingpt/images/qualys1.png" alt="Screenshot of Qualys results" width="600"/></p>
<p>
    You can see our build of WolfSSL supports a healthy number (2) of the finest cipher suites, in addition to a
    bunch of less secure ones—which is more than enough for most web sites to talk to us!
</p>

<h2>Bonus: TLS 1.3</h2>
<p>
    Supporting TLS 1.2 was enough for most use cases, but WolfSSL has TLS 1.3 built in and it would be
    awesome if our Windows 3.1 apps could take advantage of it too. TLS 1.3 has some significant changes
    in the protocol compared to TLS 1.2, and also dispenses with the 37 cipher suites in lieu of 5 secure ones.
</p>
<p>
    After playing around with the compiler flags, and moving even more code around to avoid &#34;segment too large&#34; errors,
    I was finally able to get my build of WolfSSL to compile with TLS 1.3 enabled. However, I did run into an issue
    where the code thinks the received encrypted data is &#34;too large&#34; because it&#39;s 1 byte. For now, I&#39;ve commented
    the check out, and it seems to work in real-world situations, but I would love to understand why this is happening.
</p>
<p><img src="https://www.dialup.net/wingpt/images/internal_c.png" alt="Screenshot of code in internal.c" width="600"/></p>
<p>
    Here&#39;s a screenshot of the Qualys page showing TLS 1.3 working, with the <tt>TLS_AES_128_GCM_SHA256</tt> cipher suite:
</p>


<h2>WinGPT</h2>
<p>
    What&#39;s the use of a library if you can&#39;t use it? Check out <a href="https://www.dialup.net/wingpt/">WinGPT, an AI Assistant for
    Windows 3.1</a>, which makes use of the WolfSSL port to connect directly to the OpenAI API servers.
</p>

<h2>Download</h2>
<p>
    I am providing the modified source code for WolfSSL here, under the GNU General Public License (GPL) v2 license
    that WolfSSL is licensed under.
    As noted above, this code with the modifications I have made is <strong>not secure</strong>,
    <strong>not reliable</strong>, and there is <strong>no warranty</strong>. You should definitely not use it for
    any purposes other than testing for your own entertainment. You can find the
    <a href="https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html" target="_blank">full GPL v2 license here</a>.
</p>
<p>
    You will also find that I have not figured out a way to integrate with the build tools (like CMake) that the
    rest of WolfSSL uses, or made changes in a way that will be easy to integrate back into the main source tree.
    If someone wants to make 16-bit Windows a supported architecture for WolfSSL, that would be
    great—I haven&#39;t got there yet.
</p>
<p><a href="https://www.dialup.net/wingpt/download/wolfssl10.zip">WolfSSL for Windows 16-bit + WinGPT 1.0 source code (14M)</a></p>

<h2>Footnotes</h2>

</article></div>
  </body>
</html>
