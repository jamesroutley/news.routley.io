<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://alex-jacobs.com/posts/the-case-against-pgvector/">Original</a>
    <h1>The Case Against PGVector</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="everyone-loves-pgvector-in-theory">Everyone Loves pgvector (in theory)</h2><p>If you’ve spent any time in the vector search space over the past year, you’ve probably read blog posts explaining why pgvector is the obvious choice for your vector database needs. The argument goes something like this: you already have Postgres, vector embeddings are just another data type, why add complexity with a dedicated vector database when you can keep everything in one place?</p><p>It’s a compelling story. And like most of the AI influencer bullshit that fills my timeline, it glosses over the inconvenient details.</p><p>I’m not here to tell you pgvector is bad. It’s not. It’s a useful extension that brings vector similarity search to Postgres. But after spending some time trying to build a production system on top of it, I’ve learned that the gap between “works in a demo” and “scales in production” is… significant.</p><h2 id="nobodys-actually-run-this-in-production">Nobody’s actually run this in production</h2><p>What bothers me most: the majority of content about pgvector reads like it was written by someone who spun up a local Postgres instance, inserted 10,000 vectors, ran a few queries, and called it a day. The posts are optimistic, the benchmarks are clean, and the conclusions are confident.</p><p>They’re also missing about 80% of what you actually need to know.</p><p>I’ve read through  <span onclick="openPgvectorModal()">dozens of these posts.</span></p><p>They all cover the same ground: here’s how to install pgvector, here’s how to create a vector column, here’s a simple similarity search query. Some of them even mention that you should probably add an index.</p><p>What they don’t tell you is what happens when you actually try to run this in production.</p><h2 id="picking-an-index-there-are-no-good-options">Picking an index (there are no good options)</h2><p>Let’s start with indexes, because this is where the tradeoffs start.</p><p>pgvector gives you two index types: IVFFlat and HNSW. The blog posts will tell you that HNSW is newer and generally better, which is… technically true but deeply unhelpful.</p><h3 id="ivfflat">IVFFlat</h3><p>IVFFlat (Inverted File with Flat quantization) partitions your vector space into clusters. During search, it identifies the nearest clusters and only searches within those.</p><p>The good:</p><ul><li>Lower memory footprint during index creation</li><li>Reasonable query performance for many use cases</li><li>Index creation is faster than HNSW</li></ul><p>The bad:</p><ul><li>Requires you to specify the number of lists (clusters) upfront</li><li>That number significantly impacts both recall and query performance</li><li>The commonly recommended formula (<code>rows / 1000</code>) is a starting point at best</li><li>Recall can be… disappointing depending on your data distribution</li><li>New vectors get assigned to existing clusters, but clusters don’t rebalance without a full rebuild</li></ul><p><img loading="lazy" src="https://alex-jacobs.com/posts/the-case-against-pgvector/img_1.png" type="" alt="img_1.png"/>
<em>Image source: <a href="https://unfoldai.com/ivfflat-vs-hnsw/">IVFFlat or HNSW index for similarity search?</a> by Simeon Emanuilov</em></p><h3 id="hnsw">HNSW</h3><p>HNSW (Hierarchical Navigable Small World) builds a multi-layer graph structure for search.</p><p>The good:</p><ul><li>Better recall than IVFFlat for most datasets</li><li>More consistent query performance</li><li>Scales well to larger datasets</li></ul><p>The bad:</p><ul><li>Significantly higher memory requirements during index builds</li><li>Index creation is slow—painfully slow for large datasets</li><li>The memory requirements aren’t theoretical; they are real, and they’ll take down your database if you’re not careful</li></ul><p><img loading="lazy" src="https://alex-jacobs.com/posts/the-case-against-pgvector/img_2.png" type="" alt="img_2.png"/>
<em>Image source: <a href="https://unfoldai.com/ivfflat-vs-hnsw/">IVFFlat or HNSW index for similarity search?</a> by Simeon Emanuilov</em></p><p>None of the blogs mention that building an HNSW index on a few million vectors can consume 10+ GB of RAM or more (depending on your vector dimensions and dataset size). On your production database. While it’s running. For potentially hours.</p><p><img loading="lazy" src="https://alex-jacobs.com/posts/the-case-against-pgvector/img_6.png" type="" alt="img_6.png"/></p><h2 id="real-time-search-is-basically-impossible">Real-time search is basically impossible</h2><p>In a typical application, you want newly uploaded data to be searchable immediately. User uploads a document, you generate embeddings, insert them into your database, and they should be available in search results. Simple, right?</p><h3 id="how-index-updates-actually-work">How index updates actually work</h3><p>When you insert new vectors into a table with an index, one of two things happens:</p><ol><li><p><strong>IVFFlat</strong>: The new vectors are inserted into the appropriate clusters based on the existing structure. This works, but it means your cluster distribution gets increasingly suboptimal over time. The solution is to rebuild the index periodically. Which means downtime, or maintaining a separate index and doing an atomic swap, or accepting degraded search quality.</p></li><li><p><strong>HNSW</strong>: New vectors are added to the graph structure. This is better than IVFFlat, but it’s not free. Each insertion requires updating the graph, which means memory allocation, graph traversals, and potential lock contention.</p></li></ol><p>Neither of these is a deal-breaker in isolation. But here’s what happens in practice: you’re inserting vectors continuously throughout the day. Each insertion is individually cheap, but the aggregate load adds up. Your database is now handling your normal transactional workload, analytical queries, AND maintaining graph structures in memory for vector search.</p><h3 id="handling-new-inserts">Handling new inserts</h3><p>Let’s say you’re building a document search system. Users upload PDFs, you extract text, generate embeddings, and insert them. The user expects to immediately search for that document.</p><p>Here’s what actually happens:</p><p><strong>With no index</strong>: The insert is fast, the document is immediately available, but your searches do a full sequential scan. This works fine for a few thousand documents. At a few hundred thousand? Your searches start taking seconds. Millions? Good luck.</p><p><strong>With IVFFlat</strong>: The insert is still relatively fast. The vector gets assigned to a cluster. But whoops, a problem. Those initial cluster assignments were based on the data distribution when you built the index. As you add more data, especially if it’s not uniformly distributed, some clusters get overloaded. Your search quality degrades. You rebuild the index periodically to fix this, but during the rebuild (which can take hours for large datasets), what do you do with new inserts? Queue them? Write to a separate unindexed table and merge later?</p><p><strong>With HNSW</strong>: The graph gets updated on each insert through incremental insertion, which sounds great. But updating an HNSW graph isn’t free—you’re traversing the graph to find the right place to insert the new node and updating connections. Each insert acquires locks on the graph structure. Under heavy write load, this becomes a bottleneck. And if your write rate is high enough, you start seeing lock contention that slows down both writes and reads.</p><p><img loading="lazy" src="https://alex-jacobs.com/posts/the-case-against-pgvector/img_3.jpg" type="" alt="img_3.jpg"/></p><h3 id="the-operational-reality">The operational reality</h3><p>Here’s the real nightmare: you’re not just storing vectors. You have metadata—document titles, timestamps, user IDs, categories, etc. That metadata lives in other tables (or other columns in the same table). You need that metadata and the vectors to stay in sync.</p><p>In a normal Postgres table, this is easy—transactions handle it. But when you’re dealing with index builds that take hours, keeping everything consistent gets complicated. For IVFFlat, periodic rebuilds are basically required to maintain search quality. For HNSW, you might need to rebuild if you want to tune parameters or if performance has degraded.</p><p>The problem is that index builds are memory-intensive operations, and Postgres doesn’t have a great way to throttle them. You’re essentially asking your production database to allocate multiple (possibly dozens) gigabytes of RAM for an operation that might take hours, while continuing to serve queries.</p><p>You end up with strategies like:</p><ul><li>Write to a staging table, build the index offline, then swap it in (but now you have a window where searches miss new data)</li><li>Maintain two indexes and write to both (double the memory, double the update cost)</li><li>Build indexes on replicas and promote them</li><li>Accept eventual consistency (users upload documents that aren’t searchable for N minutes)</li><li>Provision significantly more RAM than your “working set” would suggest</li></ul><p>None of these are “wrong” exactly. But they’re all workarounds for the fact that pgvector wasn’t really designed for high-velocity real-time ingestion.</p><h2 id="pre--vs-post-filtering-or-why-you-need-to-become-a-query-planner-expert">Pre- vs. Post-Filtering (or: why you need to become a query planner expert)</h2><p>Okay but let’s say you solve your index and insert problems. Now you have a document search system with millions of vectors. Documents have metadata—maybe they’re marked as <code>draft</code>, <code>published</code>, or <code>archived</code>. A user searches for something, and you only want to return published documents.</p><div><pre tabindex="0"><code data-lang="sql"><span><span>1</span><span><span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> </span><span>documents</span><span>
</span></span></span><span><span>2</span><span><span></span><span>WHERE</span><span> </span><span>status</span><span> </span><span>=</span><span> </span><span>&#39;published&#39;</span><span>
</span></span></span><span><span>3</span><span><span></span><span>ORDER</span><span> </span><span>BY</span><span> </span><span>embedding</span><span> </span><span>&lt;-&gt;</span><span> </span><span>query_vector</span><span>
</span></span></span><span><span>4</span><span><span></span><span>LIMIT</span><span> </span><span>10</span><span>;</span><span>
</span></span></span></code></pre></div><p>Simple enough. But now you have a problem: should Postgres filter on status first (pre-filter) or do the vector search first and then filter (post-filter)?</p><p>This seems like an implementation detail. It’s not. It’s the difference between queries that take 50ms and queries that take 5 seconds. It’s also the difference between returning the most relevant results and… not.</p><p><img loading="lazy" src="https://alex-jacobs.com/posts/the-case-against-pgvector/img_4.jpg" type="" alt="img_4.jpg"/></p><p><strong>Pre-filter</strong> works great when the filter is highly selective (1,000 docs out of 10M). It works terribly when the filter isn’t selective—you’re still searching millions of vectors.</p><p><strong>Post-filter</strong> works when your filter is permissive. Here’s where it breaks: imagine you ask for 10 results with <code>LIMIT 10</code>. pgvector finds the 10 nearest neighbors, then applies your filter. Only 3 of those 10 are published. You get 3 results back, even though there might be hundreds of relevant published documents slightly further away in the embedding space.</p><p>The user searched, got 3 mediocre results, and has no idea they’re missing way better matches that didn’t make it into the initial k=10 search.</p><p><img loading="lazy" src="https://alex-jacobs.com/posts/the-case-against-pgvector/img_5.png" type="" alt="img_5.png"/></p><p>You can work around this by fetching more vectors (say, <code>LIMIT 100</code>) and then filtering, but now:</p><ul><li>You’re doing way more distance calculations than needed</li><li>You still don’t know if 100 is enough</li><li>Your query performance suffers</li><li>You’re guessing at the right oversampling factor</li></ul><p>With pre-filter, you avoid this problem, but you get the performance problems I mentioned. Pick your poison.</p><h3 id="multiple-filters">Multiple filters</h3><p>Now add another dimension: you’re filtering by user_id AND category AND date_range.</p><div><pre tabindex="0"><code data-lang="sql"><span><span>1</span><span><span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> </span><span>documents</span><span>
</span></span></span><span><span>2</span><span><span></span><span>WHERE</span><span> </span><span>user_id</span><span> </span><span>=</span><span> </span><span>&#39;user123&#39;</span><span>
</span></span></span><span><span>3</span><span><span>  </span><span>AND</span><span> </span><span>category</span><span> </span><span>=</span><span> </span><span>&#39;technical&#39;</span><span>
</span></span></span><span><span>4</span><span><span>  </span><span>AND</span><span> </span><span>created_at</span><span> </span><span>&gt;</span><span> </span><span>&#39;2024-01-01&#39;</span><span>
</span></span></span><span><span>5</span><span><span></span><span>ORDER</span><span> </span><span>BY</span><span> </span><span>embedding</span><span> </span><span>&lt;-&gt;</span><span> </span><span>query_vector</span><span>
</span></span></span><span><span>6</span><span><span></span><span>LIMIT</span><span> </span><span>10</span><span>;</span><span>
</span></span></span></code></pre></div><p>What’s the right strategy now?</p><ul><li>Apply all filters first, then search? (Pre-filter)</li><li>Search first, then apply all filters? (Post-filter)</li><li>Apply some filters first, search, then apply remaining filters? (Hybrid)</li><li>Which filters should you apply in which order?</li></ul><p>The planner will look at table statistics, index selectivity, and estimated row counts and come up with a plan. That plan will probably be wrong, or at least suboptimal, because the planner’s cost model wasn’t built for vector similarity search.</p><p>And it gets worse: you’re inserting new vectors throughout the day. Your index statistics are outdated. The plans get increasingly suboptimal until you ANALYZE the table. But ANALYZE on a large table with millions of rows takes time and resources. And it doesn’t really understand vector data distribution in a meaningful way—it can tell you how many rows match <code>user_id = &#39;user123&#39;</code>, but not how clustered those vectors are in the embedding space, which is what actually matters for search performance.</p><h3 id="workarounds">Workarounds</h3><p>You end up with hacks: query rewriting for different user types, partitioning your data into separate tables, CTE optimization fences to force the planner’s hand, or just fetching way more results than needed and filtering in application code.</p><p>None of these are sustainable at scale.</p><h3 id="what-vector-databases-do">What vector databases do</h3><p>Dedicated vector databases have solved this. They understand the cost model of filtered vector search and make intelligent decisions:</p><ul><li><strong>Adaptive strategies</strong>: Some databases dynamically choose pre-filter or post-filter based on estimated selectivity</li><li><strong>Configurable modes</strong>: Others let you specify the strategy explicitly when you know your data distribution</li><li><strong>Specialized indexes</strong>: Some build indexes that support efficient filtered search (like filtered HNSW)</li><li><strong>Query optimization</strong>: They track statistics specific to vector operations and optimize accordingly</li></ul><p>OpenSearch’s k-NN plugin, for example, lets you specify pre-filter or post-filter behavior. Pinecone automatically handles filter selectivity. Weaviate has optimizations for common filter patterns.</p><p>With pgvector, you get to build all of this yourself. Or live with suboptimal queries. Or hire a Postgres expert to spend weeks tuning your query patterns.</p><h2 id="hybrid-search-build-it-yourself">Hybrid search? Build it yourself</h2><p>Oh, and if you want hybrid search—combining vector similarity with traditional full-text search—you get to build that yourself too.</p><p>Postgres has excellent full-text search capabilities. pgvector has excellent vector search capabilities. Combining them in a meaningful way? That’s on you.</p><p>You need to:</p><ul><li>Decide how to weight vector similarity vs. text relevance</li><li>Normalize scores from two different scoring systems</li><li>Tune the balance for your use case</li><li>Probably implement Reciprocal Rank Fusion or something similar</li></ul><p>Again, not impossible. Just another thing that many dedicated vector databases provide out of the box.</p><h2 id="pgvectorscale-it-doesnt-solve-everything">pgvectorscale (it doesn’t solve everything)</h2><p>Timescale has released <a href="https://github.com/timescale/pgvectorscale">pgvectorscale</a>, which addresses some of these issues. It adds:</p><ul><li>StreamingDiskANN, a new search backend that’s more memory-efficient</li><li>Better support for incremental index builds</li><li>Improved filtering performance</li></ul><p>This is great! It’s also an admission that pgvector out of the box isn’t sufficient for production use cases.</p><p>pgvectorscale is still relatively new, and adopting it means adding another dependency, another extension, another thing to manage and upgrade. For some teams, that’s fine. For others, it’s just more evidence that maybe the “keep it simple, use Postgres” argument isn’t as simple as it seemed.</p><p>Oh, and if you’re running on RDS, pgvectorscale isn’t available. AWS doesn’t support it. So enjoy managing your own Postgres instance if you want these improvements, or just… keep dealing with the limitations of vanilla pgvector.</p><p>The “just use Postgres” simplicity keeps getting simpler.</p><h2 id="just-use-a-real-vector-database">Just use a real vector database</h2><p>I get the appeal of pgvector. Consolidating your stack is good. Reducing operational complexity is good. Not having to manage another database is good.</p><p>But here’s what I’ve learned: for most teams, especially small teams, dedicated vector databases are actually simpler.</p><h3 id="what-you-actually-get">What you actually get</h3><p>With a managed vector database (Pinecone, Weaviate, Turbopuffer, etc.), you typically get:</p><ul><li>Intelligent query planning for filtered searches</li><li>Hybrid search built in</li><li>Real-time indexing without memory spikes</li><li>Horizontal scaling without complexity</li><li>Monitoring and observability designed for vector workloads</li></ul><p><img loading="lazy" src="https://alex-jacobs.com/posts/the-case-against-pgvector/img_7.jpg" type="" alt="img_7.jpg"/></p><h3 id="its-probably-cheaper-than-you-think">It’s probably cheaper than you think</h3><p>Yes, it’s another service to pay for. But compare:</p><ul><li>The cost of a managed vector database for your workload</li><li>vs. the cost of over-provisioning your Postgres instance to handle index builds</li><li>vs. the engineering time to tune queries and manage index rebuilds</li><li>vs. the opportunity cost of not building features because you’re fighting your database</li></ul><p>Turbopuffer starts at $64 month with generous limits.</p><p>For a lot of teams, the managed service is actually cheaper.</p><h2 id="what-i-wish-someone-had-told-me">What I wish someone had told me</h2><p>pgvector is an impressive piece of technology. It brings vector search to Postgres in a way that’s technically sound and genuinely useful for many applications.</p><p>But it’s not a panacea. Understand the tradeoffs.</p><p>If you’re building a production vector search system:</p><ol><li><p><strong>Index management is hard</strong>. Rebuilds are memory-intensive, time-consuming, and disruptive. Plan for this from day one.</p></li><li><p><strong>Query planning matters</strong>. Filtered vector search is a different beast than traditional queries, and Postgres’s planner wasn’t built for this.</p></li><li><p><strong>Real-time indexing has costs</strong>. Either in memory, in search quality, or in engineering time to manage it.</p></li><li><p><strong>The blog posts are lying to you</strong> (by omission). They’re showing you the happy path and ignoring the operational reality.</p></li><li><p><strong>Managed offerings exist for a reason</strong>. There’s a reason that Pinecone, Weaviate, Qdrant, and others exist and are thriving. Vector search at scale has unique challenges that general-purpose databases weren’t designed to handle.</p></li></ol><p>The question isn’t “should I use pgvector?” It’s “am I willing to take on the operational complexity of running vector search in Postgres?”</p><p>For some teams, the answer is yes. You have database expertise, you need the tight integration, you’re willing to invest the time.</p><p>For many teams—maybe most teams—the answer is probably no. Use a tool designed for the job. Your future self will thank you.</p></div></div>
  </body>
</html>
