<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c23">Original</a>
    <h1>C&#43;&#43;20 coroutines: “The bug is in the C&#43;&#43; standard, not GCC.”</h1>
    
    <div id="readability-page-1" class="page"><div id="comments">




<!-- This auto-sizes the comments and positions the collapse/expand links 
     to the right. -->
<table>
<tbody><tr>
<td>
<div id="c0">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c0">Description</a>
        </span>

        <span>
          <span><span>Avi Kivity</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2020-05-13 17:36:57 UTC
        </span>

      </p>




<pre>coroutines copy their input to the coroutine frame, so a coroutine like

    future&lt;T&gt; f(T x) {
        co_await something();
        co_return x;
    }


will copy x back from the coroutine frame. However, lambdas are passed by pointer, so something like


    [x] () -&gt; future&lt;T&gt; {
        co_await something();
        co_return x;
    }

will fail, it is translated as something like


    struct lambda {
        T x;
    }

    future&lt;T&gt; lambda_operator_parens(const lambda* l) {
        co_await something();
        co_return l-&gt;x;
    }

Since l is captured by value, *l is dangling and is leaked.


I think the following translation would be more useful:


    future&lt;T&gt; lambda_operator_parens_rref(const lambda l) {
        co_await something();
        co_return l.x;
    }

l would be copied by value and would survive copying/moving into the coroutine frame.

I don&#39;t know if the current behavior is mandated by the standard, but if it is, it seems a serious defect.</pre>
    </div>

    <div id="c1">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c1">Comment 1</a>
        </span>

        <span>
          <span><span>Iain Sandoe</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2020-05-13 19:12:37 UTC
        </span>

      </p>




<pre>There are some gotchas with coroutines and references (both regular and rvalue).

* there could still be a bug here, so I want to double-check.

Please could you expand your snippets of code into a small test-case that would would expect to work?

(FWIW, in my original impl. I tried to be more defensive about lambda captures - but that wasn&#39;t correct in the presence of a mutable lambda - and didn&#39;t agree with other implementations - or the collective understanding of the intent of the standard - so I backed that out).</pre>
    </div>

    <div id="c2">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c2">Comment 2</a>
        </span>

        <span>
          <span><span>Avi Kivity</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2020-05-13 19:14:00 UTC
        </span>

      </p>




<pre>Created <span><a href="https://gcc.gnu.org/bugzilla/attachment.cgi?id=48524" name="attach_48524" title="lame testcase">attachment 48524</a> <a href="https://gcc.gnu.org/bugzilla/attachment.cgi?id=48524&amp;action=edit" title="lame testcase">[details]</a></span>
lame testcase

Lame testcase that shows that the lambda is passed as a pointer rather than by value, leading to a leak if the coroutine is suspended.</pre>
    </div>

    <div id="c3">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c3">Comment 3</a>
        </span>

        <span>
          <span><span>Avi Kivity</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2020-05-13 19:15:14 UTC
        </span>

      </p>




<pre>The test case I uploaded only shows the failure, it won&#39;t work if gcc worked as I expect it. I&#39;ll try to get a better testcase, unfortunately a small coroutine testcase is still some work.</pre>
    </div>

    <div id="c4">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c4">Comment 4</a>
        </span>

        <span>
          <span><span>Iain Sandoe</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2020-05-13 19:21:54 UTC
        </span>

      </p>




<pre>(In reply to Avi Kivity from <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c3">comment #3</a>)
<span>&gt; The test case I uploaded only shows the failure, it won&#39;t work if gcc worked
&gt; as I expect it. I&#39;ll try to get a better testcase, unfortunately a small
&gt; coroutine testcase is still some work.</span>

yeah, I have some boiler-plate code in headers in the GCC test-suite that can help.</pre>
    </div>

    <div id="c5">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c5">Comment 5</a>
        </span>

        <span>
          <span><span>Avi Kivity</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2020-05-13 19:27:42 UTC
        </span>

      </p>




<pre>This snippet from cppreference:

  If the coroutine is a non-static member function, such as task&lt;void&gt; 
  my_class::method1(int x) const;, its Promise type is 
  std::coroutine_traits&lt;task&lt;void&gt;, const my_class&amp;, int&gt;::promise_type

implies that both gcc and my interpretation are wrong. gcc passes a pointer for the lambda, and I&#39;d like the lambda to be passed by value. The difference between gcc and cppreference is trivial, and both of them make coroutine lambdas unusable if they contain state and if the lambda is asynchronous.</pre>
    </div>

    <div id="c6">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c6">Comment 6</a>
        </span>

        <span>
          <span><span>Iain Sandoe</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2020-05-13 19:39:33 UTC
        </span>

      </p>




<pre>(In reply to Avi Kivity from <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c5">comment #5</a>)
<span>&gt; This snippet from cppreference:
&gt; 
&gt;   If the coroutine is a non-static member function, such as task&lt;void&gt; 
&gt;   my_class::method1(int x) const;, its Promise type is 
&gt;   std::coroutine_traits&lt;task&lt;void&gt;, const my_class&amp;, int&gt;::promise_type
&gt; 
&gt; implies that both gcc and my interpretation are wrong. gcc passes a pointer
&gt; for the lambda, and I&#39;d like the lambda to be passed by value. The
&gt; difference between gcc and cppreference is trivial, and both of them make
&gt; coroutine lambdas unusable if they contain state and if the lambda is
&gt; asynchronous.</span>

( assuming that this is the problem, I haven&#39;t yet had a chance to check * could still be a bug ;) ).

I have a pending change to pass a reference to the lambda object to the traits, promise preview and allocator lookups.

This was a source of considerable discussion amongst the implementors (GCC, clang, MSVC) about how the std should be interpreted.  The change I mention will make the lambda capture object pointer behave in the same manner as &#39;this&#39; (which was the intended behaviour as determined by the long discussion).  MSVC implements this now, and clang will be changing to match it also.

That won&#39;t solve any lifetime issue with the capture object - you will still need to ensure that it exists for the duration of the coroutine * as you would for a class instance with a method coroutine *.

We (at least several of us) agree that this is a source of easy programming errors - and I expect there to be some revisiting in c++23.  That&#39;s a considerable challenge in the face of a mutable lambda - maybe (thinking aloud) needs something like Apple blocks, but with an automatic promotion of the closure to a heap object if it escapes the creating scope.</pre>
    </div>

    <div id="c7">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c7">Comment 7</a>
        </span>

        <span>
          <span><span>Avi Kivity</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2020-05-13 20:10:47 UTC
        </span>

      </p>




<pre>I have a simple reproducer. A lambda fails while a fake lambda using structs passes. I don&#39;t think gcc is at fault, but the standard is problematic here IMO.</pre>
    </div>

    

    

    <div id="c10">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c10">Comment 10</a>
        </span>

        <span>
          <span><span>Avi Kivity</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2020-05-13 20:24:28 UTC
        </span>

      </p>




<pre>Well, the standard is useless here.

In

    [foo] () -&gt; lazy&lt;foo&gt; { co_return foo; } ()

a temporary is clearly passed to the lambda body, yet the standard mandates that we capture it by reference. As a result, a use-after-free is guaranteed.</pre>
    </div>

    <div id="c11">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c11">Comment 11</a>
        </span>

        <span>
          <span><span>Avi Kivity</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2020-05-14 11:15:57 UTC
        </span>

      </p>




<pre>I started a conversation on the std-proposals list about this.

Meanwhile, how about a -fnonstandard-coroutines-that-actually-work flag that captures the parameter to a non-static member function coroutine by value, if it is an rvalue when the call happens? Without it, lambda coroutines are useless for asynchronous coroutines.</pre>
    </div>

    <div id="c12">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c12">Comment 12</a>
        </span>

        <span>
          <span><span>Ville Voutilainen</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2020-05-14 11:24:34 UTC
        </span>

      </p>




<pre>It sure seems to me that a coroutine lambda&#39;s captures should be copied to the coroutine state. I don&#39;t think the standard says that anywhere.</pre>
    </div>

    <div id="c13">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c13">Comment 13</a>
        </span>

        <span>
          <span><span>Avi Kivity</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2020-05-14 11:29:56 UTC
        </span>

      </p>




<pre>Yes. gcc has a minor bug in that the lambda is reflected as a pointer instead of a reference in coroutine_traits. The major bug is in the standard.</pre>
    </div>

    <div id="c14">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c14">Comment 14</a>
        </span>

        <span>
          <span><span>Iain Sandoe</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2020-05-14 11:46:53 UTC
        </span>

      </p>




<pre>(In reply to Ville Voutilainen from <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c12">comment #12</a>)
<span>&gt; It sure seems to me that a coroutine lambda&#39;s captures should be copied to
&gt; the coroutine state. I don&#39;t think the standard says that anywhere.</span>

Maybe I am missing your point (some of these things were decided long before I joined the fray)

----

Well, the standard is pretty much silent on coros + lambdas.  However, the implementors (Richard, Gor, me, et al) had a long discussion on the topic before Prague - and took what we could from that to Core.

GCC does not comply with the (agreed in that discussion) intent that the capture object should be treated in the same manner as &#39;this&#39;, and a reference passed to the traits lookup, promise parms preview and allocator lookup.  I have a patch for this (will post this week) - but the only implementation with this correct so far is MSVC
clang passes a ref to the traits but does not pass anything for the closure object pointer to promise param preview or allocator)
GCC currently passes the object pointer to all three.

====

The idea of bringing the lambda&#39;s captures into the coro frame was what I originally implemented.  Richard pointed out that this is wrong when the lambda is mutable (see gcc/testsuite/g++.dg/coroutines/torture/lambda-10-mutable.C)

so if one has

auto X = [...] () -&gt; some_coro&lt;xxx&gt; {};

X must exist for the duration of the lambda coro [it was pointed out by Lewis that really this is only the same as saying that if you have a class with a member function lambda, the instance of that class has to persist for the duration of the coro].

We are, I believe, collectively agreed that this is a &#39;foot gun&#39; (and rvalue refs doubly so); however, making a better mousetrap here might require some considerable thought.

I&#39;m happy to be educated if there&#39;s some different consensus as to what to do, and to amend the GCC impl. accordingly.</pre>
    </div>

    <div id="c15">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c15">Comment 15</a>
        </span>

        <span>
          <span><span>Avi Kivity</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2020-05-14 11:54:06 UTC
        </span>

      </p>




<pre>I believe that my suggestion works for mutable lambdas (and for any coroutine called as a member function):

 - if the object passeed to the member function is an lvalue, then the coroutine captures a reference to the object
 - if the object passed to the member function is an rvalue, then the coroutine captures the object by copying it (typically using it move constructor).

Examples:

   auto a = [blah] () mutable -&gt; task&lt;&gt; { ... };
   a();   // a is captured by reference

   [blah] () mutable -&gt; task&lt;&gt; { ... } (); // captured by value

 
   my_class a;
   a.some_coroutine();  // captured by reference
 

   my_class a;
   std::move(a).some_coroutine();   // captured by value


Currently, the &#34;captured by value&#34; cases are captured by reference, and cause a use-after-free if the coroutine outlives the caller scope.</pre>
    </div>

    <div id="c16">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c16">Comment 16</a>
        </span>

        <span>
          <span><span>Ville Voutilainen</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2020-05-14 11:57:00 UTC
        </span>

      </p>




<pre>(In reply to Iain Sandoe from <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c14">comment #14</a>)
<span>&gt; (In reply to Ville Voutilainen from <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c12">comment #12</a>)
&gt; The idea of bringing the lambda&#39;s captures into the coro frame was what I
&gt; originally implemented.  Richard pointed out that this is wrong when the
&gt; lambda is mutable (see
&gt; gcc/testsuite/g++.dg/coroutines/torture/lambda-10-mutable.C)
&gt; 
&gt; so if one has
&gt; 
&gt; auto X = [...] () -&gt; some_coro&lt;xxx&gt; {};
&gt; 
&gt; X must exist for the duration of the lambda coro [it was pointed out by
&gt; Lewis that really this is only the same as saying that if you have a class
&gt; with a member function lambda, the instance of that class has to persist for
&gt; the duration of the coro].</span>

Ah. So the work-around for this problem is to copy the capture to a local variable, and co_return that; then the local variable is in the coro-state. Right?</pre>
    </div>

    <div id="c17">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c17">Comment 17</a>
        </span>

        <span>
          <span><span>Ville Voutilainen</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2020-05-14 11:59:01 UTC
        </span>

      </p>




<pre>(In reply to Ville Voutilainen from <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c16">comment #16</a>)
<span>&gt; (In reply to Iain Sandoe from <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c14">comment #14</a>)
&gt; &gt; (In reply to Ville Voutilainen from <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c12">comment #12</a>)
&gt; &gt; The idea of bringing the lambda&#39;s captures into the coro frame was what I
&gt; &gt; originally implemented.  Richard pointed out that this is wrong when the
&gt; &gt; lambda is mutable (see
&gt; &gt; gcc/testsuite/g++.dg/coroutines/torture/lambda-10-mutable.C)
&gt; &gt; 
&gt; &gt; so if one has
&gt; &gt; 
&gt; &gt; auto X = [...] () -&gt; some_coro&lt;xxx&gt; {};
&gt; &gt; 
&gt; &gt; X must exist for the duration of the lambda coro [it was pointed out by
&gt; &gt; Lewis that really this is only the same as saying that if you have a class
&gt; &gt; with a member function lambda, the instance of that class has to persist for
&gt; &gt; the duration of the coro].
&gt; 
&gt; Ah. So the work-around for this problem is to copy the capture to a local
&gt; variable, and co_return that; then the local variable is in the coro-state.
&gt; Right?</span>

That is, instead of writing

[x] {co_return x;}

write

[x] {auto xx = x; co_return xx;}</pre>
    </div>

    <div id="c18">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c18">Comment 18</a>
        </span>

        <span>
          <span><span>Avi Kivity</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2020-05-14 12:01:17 UTC
        </span>

      </p>




<pre>The work-around works if initial_suspend() returns suspend_never or similar. If the lambda is suspended before execution, the reference may dangle.</pre>
    </div>

    <div id="c19">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c19">Comment 19</a>
        </span>

        <span>
          <span><span>Iain Sandoe</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2020-05-14 12:02:21 UTC
        </span>

      </p>




<pre>(In reply to Ville Voutilainen from <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c17">comment #17</a>)
<span>&gt; (In reply to Ville Voutilainen from <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c16">comment #16</a>)
&gt; &gt; (In reply to Iain Sandoe from <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c14">comment #14</a>)
&gt; &gt; &gt; (In reply to Ville Voutilainen from <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c12">comment #12</a>)
&gt; &gt; &gt; The idea of bringing the lambda&#39;s captures into the coro frame was what I
&gt; &gt; &gt; originally implemented.  Richard pointed out that this is wrong when the
&gt; &gt; &gt; lambda is mutable (see
&gt; &gt; &gt; gcc/testsuite/g++.dg/coroutines/torture/lambda-10-mutable.C)
&gt; &gt; &gt; 
&gt; &gt; &gt; so if one has
&gt; &gt; &gt; 
&gt; &gt; &gt; auto X = [...] () -&gt; some_coro&lt;xxx&gt; {};
&gt; &gt; &gt; 
&gt; &gt; &gt; X must exist for the duration of the lambda coro [it was pointed out by
&gt; &gt; &gt; Lewis that really this is only the same as saying that if you have a class
&gt; &gt; &gt; with a member function lambda, the instance of that class has to persist for
&gt; &gt; &gt; the duration of the coro].
&gt; &gt; 
&gt; &gt; Ah. So the work-around for this problem is to copy the capture to a local
&gt; &gt; variable, and co_return that; then the local variable is in the coro-state.
&gt; &gt; Right?
&gt; 
&gt; That is, instead of writing
&gt; 
&gt; [x] {co_return x;}
&gt; 
&gt; write
&gt; 
&gt; [x] {auto xx = x; co_return xx;}</span>

hmm I&#39;m not sure this is sufficient; if the initial suspend is suspend-always, and the closure object goes away before the initial resume, then xx will be initialised with garbage.</pre>
    </div>

    <div id="c20">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c20">Comment 20</a>
        </span>

        <span>
          <span><span>Avi Kivity</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2020-05-14 12:02:35 UTC
        </span>

      </p>




<pre>My coroutines do return suspend_never from initial_suspend(); so thanks for the workaround, I&#39;ll use it until we have a better fix.</pre>
    </div>

    <div id="c21">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c21">Comment 21</a>
        </span>

        <span>
          <span><span>Iain Sandoe</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2020-05-14 12:25:16 UTC
        </span>

      </p>




<pre>Avi, If we are agreed that there is no GCC bug here (the change from pointer to reference is already in the queue)

I would suggest that new design discussion would be better by putting a paper or suggestions to the WG21 evolution list (and certainly involving folks who are not present &#39;here&#39;).  In which case the bug could be closed.</pre>
    </div>

    <div id="c22">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c22">Comment 22</a>
        </span>

        <span>
          <span><span>Avi Kivity</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2020-05-14 12:33:44 UTC
        </span>

      </p>




<pre>Certainly, closing as invalid.</pre>
    </div>

    <div id="c23">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c23">Comment 23</a>
        </span>

        <span>
          <span><span>Avi Kivity</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2020-05-14 12:34:53 UTC
        </span>

      </p>




<pre>The bug is in the C++ standard, not gcc.</pre>
    </div>

    <div id="c24">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c24">Comment 24</a>
        </span>

        <span>
          <span><span>Eric Gallager</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2020-05-14 18:02:25 UTC
        </span>

      </p>




<pre>(In reply to Iain Sandoe from <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95111#c6">comment #6</a>)
<span>&gt; 
&gt; We (at least several of us) agree that this is a source of easy programming
&gt; errors - and I expect there to be some revisiting in c++23.  That&#39;s a
&gt; considerable challenge in the face of a mutable lambda - maybe (thinking
&gt; aloud) needs something like Apple blocks, but with an automatic promotion of
&gt; the closure to a heap object if it escapes the creating scope.</span>

...(Apple blocks support is <a title="ASSIGNED - GCC lacks support for the Apple &#34;blocks&#34; extension to the C family of languages" href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=78352">bug 78352</a>, for reference)...</pre>
    </div>


  

</td>
<td>
</td>
</tr></tbody></table>
  </div></div>
  </body>
</html>
