<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://healeycodes.com/making-python-less-random">Original</a>
    <h1>Making Python Less Random</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>I was working on a game prototype written in Python when I came across a tricky bug. I was able to reproduce it (good), but because it depended on randomness, it was hard to iterate on a fix (bad).</p><p>I searched and found that my game had two sources of randomness: <code>os.urandom</code> and <code>random.randint</code>. I tried to mock them like this:</p><pre><div><div><p><span>import</span><span> os</span></p><p><span>os</span><span>.</span><span>urandom </span><span>=</span><span> </span><span>lambda</span><span> n</span><span>:</span><span> </span><span>b&#39;\x00&#39;</span><span> </span><span>*</span><span> n</span></p><p><span></span><span>import</span><span> random</span></p><p><span>random</span><span>.</span><span>randint </span><span>=</span><span> </span><span>lambda</span><span> a</span><span>,</span><span> b</span><span>:</span><span> a</span></p></div></div></pre><p>However, I found an imported third-party library was also calling <code>random</code> functions. The library&#39;s code wasn&#39;t well-structured (e.g., importing modules inside functions). I couldn&#39;t mock the call sites without altering the dependency locally.</p><p>At this point, I should have pulled the code I was using out of that library, and refactored my game so that all sources of randomness came from some kind of pseudorandom generator function. This way, I could provide fixed seeds for deterministic debugging.</p><p>Instead, I took a detour to catch and modify syscalls to <code>getrandom</code>.</p><h2 id="where-does-pythons-randomness-come-from">Where Does Python&#39;s Randomness Come From?</h2><p>We can debug this using <a href="https://man7.org/linux/man-pages/man1/strace.1.html">strace</a> to look at the syscalls made by a Python process.</p><pre><div><div><p><span># example.py</span><span></span></p><p><span></span><span>import</span><span> os</span></p><p><span>os</span><span>.</span><span>urandom</span><span>(</span><span>8</span><span>)</span></p></div></div></pre><p>If we run the above program with <code>strace python example.py</code>, we get a fairly verbose output which I&#39;ve trimmed a bit here:</p><pre><div><div><p><span># ..</span><span></span></p><p><span>read</span><span>(</span><span>3</span><span>, </span><span>&#34;import os</span><span>\n</span><span>os.urandom(8)</span><span>\n</span><span>&#34;</span><span>, </span><span>4096</span><span>)</span><span> </span><span>=</span><span> </span><span>24</span><span></span></p><p><span>read</span><span>(</span><span>3</span><span>, </span><span>&#34;&#34;</span><span>, </span><span>4096</span><span>)</span><span>                       </span><span>=</span><span> </span><span>0</span><span></span></p><p><span>close</span><span>(</span><span>3</span><span>)</span><span>                                </span><span>=</span><span> </span><span>0</span><span></span></p><p><span>getrandom</span><span>(</span><span>&#34;</span><span>\x58</span><span>\x54</span><span>\x9d</span><span>\x43</span><span>\xbf</span><span>\x4f</span><span>\xae</span><span>\x75</span><span>&#34;</span><span>, </span><span>8</span><span>, </span><span>0</span><span>)</span><span> </span><span>=</span><span> </span><span>8</span><span></span></p><p><span></span><span># ..</span></p></div></div></pre><p>Every time <code>os.urandom(n)</code> is called, <code>n</code> number of bytes are requested from <a href="https://man7.org/linux/man-pages/man2/getrandom.2.html">getrandom</a>.</p><blockquote><p>The getrandom() system call fills the buffer pointed to by buf with up to buflen random bytes.  These bytes can be used to seed user-space random number generators or for cryptographic purposes.</p></blockquote><p>However, <code>random.randint</code> is a little different; the module is seeded when it&#39;s <em>imported</em>.</p><pre><div><div><p><span># example2.py</span><span></span></p><p><span></span><span>import</span><span> random</span></p></div></div></pre><p>The above program requests <code>2496</code> bytes from <code>getrandom</code> (even though we haven&#39;t actually requested any random numbers yet) in order to seed the module. See the trimmed output from <code>strace python example2.py</code> below:</p><pre><div><div><p><span># ..</span><span></span></p><p><span>getrandom</span><span>(</span><span>&#34;</span><span>\xcf</span><span>\xf3</span><span>\x34</span><span>\xf4</span><span>\x65</span><span>\x49</span><span>\xd2</span><span>\xab</span><span>\xc2</span><span>\x65</span><span>\x26</span><span>\x0</span><span></span></p><p><span></span><span>\xd6</span><span>\x59</span><span>\xdd</span><span>\x4f</span><span>\x5c</span><span>\xf5</span><span>\xa5</span><span>\x2d</span><span>\xe7</span><span>\x65</span><span>\x25</span><span>\xca</span><span>\x0b</span><span>\x74</span><span></span></p><p><span></span><span>\xd3</span><span>\x40</span><span>\x94</span><span>\x8a</span><span>\xe0</span><span>\x4f</span><span>&#34;</span><span>..</span><span>., </span><span>2496</span><span>, GRND_NONBLOCK</span><span>)</span><span> </span><span>=</span><span> </span><span>2496</span><span></span></p><p><span></span><span># ..</span></p></div></div></pre><p>Either way, to achieve deterministic randomness, I need to get between my program and these syscalls to<code>getrandom</code>. I&#39;ll list all the methods I&#39;ve heard of, ordered from most tricky to least tricky:</p><ul><li>Compile the Linux kernel with an altered <code>getrandom</code> function. Downside: my computer becomes hilarious, obscurely, insecure and vulnerable</li><li>Use <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> to hook into the kernel&#39;s existing <code>getrandom</code> function (ideally with some filtering so it&#39;s not <em>all</em> calls to <code>getrandom</code>)</li><li>Compile a Python binary with a modified <a href="https://github.com/python/cpython/blob/3bddd07c2ada7cdadb55ea23a15037bd650e20ef/Python/bootstrap_hash.c#L477">py_urandom function</a></li><li>Use a kernel probe (see: <a href="https://docs.kernel.org/trace/kprobes.html">Kprobes</a>) to hook into the kernel</li><li>Use <code>LD_PRELOAD</code> to alter the call that Python makes to <code>libc</code>&#39;s <code>getrandom</code> (read more on this in <a href="https://blog.jessfraz.com/post/ld_preload/">LD_PRELOAD: The Hero We Need and Deserve</a>)</li><li>Use <a href="https://man7.org/linux/man-pages/man2/ptrace.2.html">ptrace</a> (process trace) to intercept and modify the return value of the <code>getrandom</code> syscall</li></ul><p>Note: I&#39;ve not included methods like monkey patching (e.g. with <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.MagicMock">MagicMock</a>) because that requires  a code change and doesn&#39;t count.</p><h2 id="modifying-system-calls-with-ptrace">Modifying System Calls With ptrace</h2><p>Given the constraint of no code changes allowed, <a href="https://man7.org/linux/man-pages/man2/ptrace.2.html">ptrace</a> is well suited for this job. It only affects a specific process and I don&#39;t need to recompile my dependencies. About 20 or so lines of C will do it.</p><blockquote><p>The ptrace() system call provides a means by which one process (the &#34;tracer&#34;) may observe and control the execution of another process (the &#34;tracee&#34;), and examine and change the tracee&#39;s memory and registers.  It is primarily used to implement breakpoint debugging and system call tracing.</p>
</blockquote><p>First, I need to find the process ID (PID) of a running Python program, so with bash:</p><pre><div><div><p><span>$ </span><span>ps</span><span> aux </span><span>|</span><span> </span><span>grep</span><span> python</span></p><p><span>andrew        </span><span>9792</span><span>  </span><span>0.0</span><span>  </span><span>0.4</span><span>  </span><span>16468</span><span>  </span><span>8264</span><span> pts/5    S+   </span><span>16</span><span>:33   </span><span>0</span><span>:00 python</span></p><p><span></span><span>#             ^ PID</span></p></div></div></pre><p>Here, <code>9792</code> is the PID. Then, I want to call my <code>unrandom</code> program like this: <code>./unrandom &lt;pid&gt;</code>, so my C program starts by reading from <code>argv</code>:</p><pre><div><div><p><span>// unrandom.c</span><span></span></p><p><span></span><span>int</span><span> </span><span>main</span><span>(</span><span>int</span><span> argc</span><span>,</span><span> </span><span>char</span><span> </span><span>*</span><span>argv</span><span>[</span><span>]</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>if</span><span> </span><span>(</span><span>argc </span><span>&lt;</span><span> </span><span>2</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>fprintf</span><span>(</span><span>stderr</span><span>,</span><span> </span><span>&#34;Usage: %s &lt;pid&gt;\n&#34;</span><span>,</span><span> argv</span><span>[</span><span>0</span><span>]</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>return</span><span> </span><span>1</span><span>;</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span>  </span><span>pid_t</span><span> pid </span><span>=</span><span> </span><span>atoi</span><span>(</span><span>argv</span><span>[</span><span>1</span><span>]</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>// ..</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>Next, we need to attach to the Python process (the tracee) so that <code>unrandom.c</code> (the tracer) can gain control.</p><pre><div><div><p><span>// Attach to the process with the given PID and initiate tracing (sends a</span><span></span></p><p><span></span><span>// SIGSTOP) on the tracee to halt its execution.</span><span></span></p><p><span></span><span>if</span><span> </span><span>(</span><span>ptrace</span><span>(</span><span>PTRACE_ATTACH</span><span>,</span><span> pid</span><span>,</span><span> </span><span>NULL</span><span>,</span><span> </span><span>NULL</span><span>)</span><span> </span><span>==</span><span> </span><span>-</span><span>1</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>perror</span><span>(</span><span>&#34;ptrace attach&#34;</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>return</span><span> </span><span>1</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>// Wait for the tracee to stop and become ready for further tracing.</span><span></span></p><p><span></span><span>waitpid</span><span>(</span><span>pid</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>)</span><span>;</span></p></div></div></pre><p>The main part of <code>unrandom</code> is a loop where we intercept the entry and exit of each syscall.</p><p>On the entry, we&#39;ll read the tracee&#39;s register values and check if the syscall is <code>getrandom</code>; if so, then on the exit, we will write to the buffer that the Python process passed as a reference (it expects random bytes to be inside this buffer).</p><p>Let&#39;s start by debug logging to see what&#39;s going on.</p><pre><div><div><p><span>for</span><span> </span><span>(</span><span>;</span><span>;</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>// Restart the tracee and stop at the next system call entry or exit. Here,</span><span></span></p><p><span>  </span><span>// we enter the syscall.</span><span></span></p><p><span>  </span><span>if</span><span> </span><span>(</span><span>ptrace</span><span>(</span><span>PTRACE_SYSCALL</span><span>,</span><span> pid</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>)</span><span> </span><span>==</span><span> </span><span>-</span><span>1</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>perror</span><span>(</span><span>&#34;ptrace syscall enter&#34;</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>break</span><span>;</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span>  </span><span>waitpid</span><span>(</span><span>pid</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>// Retrieve the tracee&#39;s register values.</span><span></span></p><p><span>  </span><span>struct</span><span> </span><span>user_regs_struct</span><span> regs</span><span>;</span><span></span></p><p><span>  </span><span>if</span><span> </span><span>(</span><span>ptrace</span><span>(</span><span>PTRACE_GETREGS</span><span>,</span><span> pid</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>&amp;</span><span>regs</span><span>)</span><span> </span><span>==</span><span> </span><span>-</span><span>1</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>perror</span><span>(</span><span>&#34;ptrace getregs&#34;</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>break</span><span>;</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span>  </span><span>// Check if the syscall being traced is SYS_getrandom.</span><span></span></p><p><span>  </span><span>int</span><span> intercepted </span><span>=</span><span> </span><span>0</span><span>;</span><span></span></p><p><span>  </span><span>if</span><span> </span><span>(</span><span>regs</span><span>.</span><span>orig_rax </span><span>==</span><span> SYS_getrandom</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    intercepted </span><span>=</span><span> </span><span>1</span><span>;</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span>  </span><span>// Exit the syscall and wait for the tracee to stop again.</span><span></span></p><p><span>  </span><span>if</span><span> </span><span>(</span><span>ptrace</span><span>(</span><span>PTRACE_SYSCALL</span><span>,</span><span> pid</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>)</span><span> </span><span>==</span><span> </span><span>-</span><span>1</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>perror</span><span>(</span><span>&#34;ptrace syscall exit&#34;</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>break</span><span>;</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span>  </span><span>waitpid</span><span>(</span><span>pid</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>if</span><span> </span><span>(</span><span>intercepted</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>fprintf</span><span>(</span><span>stderr</span><span>,</span><span></span></p><p><span>      </span><span>&#34;intercepted getrandom call: regs.rdi = %llu, regs.rsi = %zu\n&#34;</span><span>,</span><span></span></p><p><span>      regs</span><span>.</span><span>rdi</span><span>,</span><span> regs</span><span>.</span><span>rsi</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>I compiled this with <code>gcc -o unrandom unrandom.c</code>, started a Python REPL, grabbed the pid, and ran <code>./unrandom &lt;pid&gt;</code> in a different session.</p><p>My <code>unrandom</code> program didn&#39;t print anything initially, it let all the non-getrandom syscalls through to the kernel, and back, without interference. But when I ran <code>os.urandom(8)</code> in the REPL, <code>unrandom</code> logged this:</p><pre><div><div><p><span>intercepted getrandom call: regs.rdi </span><span>=</span><span> </span><span>140219284068912</span><span>, regs.rsi </span><span>=</span><span> </span><span>8</span></p></div></div></pre><p>If we look up a <a href="https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">system call table</a> for x86-64, we can check what these register values mean:</p><ul><li>rdi: <code>char __user *buf</code></li><li>rsi: <code>size_t count</code></li></ul><p>We need to write <code>count</code> zero bytes to <code>*buf</code> after the syscall exits. It&#39;s important that it&#39;s <em>after</em>; otherwise the syscall exit will overwrite our modifications.</p><pre><div><div><p><span>if</span><span> </span><span>(</span><span>intercepted</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>fprintf</span><span>(</span><span>stderr</span><span>,</span><span></span></p><p><span>    </span><span>&#34;intercepted getrandom call: regs.rdi = %llu, regs.rsi = %zu\n&#34;</span><span>,</span><span></span></p><p><span>    regs</span><span>.</span><span>rdi</span><span>,</span><span> regs</span><span>.</span><span>rsi</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>unsigned</span><span> </span><span>long</span><span> </span><span>long</span><span> buf </span><span>=</span><span> regs</span><span>.</span><span>rdi</span><span>;</span><span></span></p><p><span>  </span><span>size_t</span><span> count </span><span>=</span><span> regs</span><span>.</span><span>rsi</span><span>;</span><span></span></p><p><span>  </span><span>// Overwrite the buffer contents with zeroes.</span><span></span></p><p><span>  </span><span>for</span><span> </span><span>(</span><span>size_t</span><span> i </span><span>=</span><span> </span><span>0</span><span>;</span><span> i </span><span>&lt;</span><span> count</span><span>;</span><span> i </span><span>+=</span><span> </span><span>sizeof</span><span>(</span><span>long</span><span>)</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>if</span><span> </span><span>(</span><span>ptrace</span><span>(</span><span>PTRACE_POKEDATA</span><span>,</span><span> pid</span><span>,</span><span> buf </span><span>+</span><span> i</span><span>,</span><span> </span><span>0</span><span>)</span><span> </span><span>==</span><span> </span><span>-</span><span>1</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>      </span><span>perror</span><span>(</span><span>&#34;ptrace pokedata&#34;</span><span>)</span><span>;</span><span></span></p><p><span>      </span><span>break</span><span>;</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span>  </span><span>// Set the return value to indicate the amount of data written.</span><span></span></p><p><span>  regs</span><span>.</span><span>rax </span><span>=</span><span> count</span><span>;</span><span></span></p><p><span>  </span><span>// Modify the tracee&#39;s registers to reflect the changes made.</span><span></span></p><p><span>  </span><span>if</span><span> </span><span>(</span><span>ptrace</span><span>(</span><span>PTRACE_SETREGS</span><span>,</span><span> pid</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>&amp;</span><span>regs</span><span>)</span><span> </span><span>==</span><span> </span><span>-</span><span>1</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>perror</span><span>(</span><span>&#34;ptrace setregs&#34;</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>break</span><span>;</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>When a Python process is the tracee of <code>unrandom</code>, all <code>getrandom</code> syscalls will return zeroes. This means that <code>os.unrandom</code> returns as many <code>\x00</code> as requested, and <code>random.randint</code> returns deterministically random numbers (the same series of numbers, every time the process restarts — internally, it uses the <a href="https://en.wikipedia.org/wiki/Mersenne_Twister">Mersenne Twister</a> as the core generator).</p><p>This is what it looks like in a traced REPL:</p><pre><div><div><p><span>Python </span><span>3.11</span><span>.2 </span><span>(</span><span>main, May  </span><span>2</span><span> </span><span>2024</span><span>, </span><span>6</span><span>:59:08</span><span>)</span><span> </span><span>[</span><span>GCC </span><span>12.2</span><span>.0</span><span>]</span><span> on linux</span></p><p><span>Type </span><span>&#34;help&#34;</span><span>, </span><span>&#34;copyright&#34;</span><span>, </span><span>&#34;credits&#34;</span><span> or </span><span>&#34;license&#34;</span><span> </span><span>for</span><span> </span><span>more</span><span> information.</span></p><p><span></span><span>&gt;&gt;</span><span>&gt;</span><span> </span><span>import</span><span> os</span></p><p><span></span><span>&gt;&gt;</span><span>&gt;</span><span> os.urandom</span><span>(</span><span>8</span><span>)</span><span></span></p><p><span>b</span><span>&#39;\x00\x00\x00\x00\x00\x00\x00\x00&#39;</span><span></span></p><p><span></span><span>&gt;&gt;</span><span>&gt;</span><span> os.urandom</span><span>(</span><span>8</span><span>)</span><span></span></p><p><span>b</span><span>&#39;\x00\x00\x00\x00\x00\x00\x00\x00&#39;</span><span></span></p><p><span></span><span>&gt;&gt;</span><span>&gt;</span><span> </span><span>import</span><span> random</span></p><p><span></span><span>&gt;&gt;</span><span>&gt;</span><span> random.randint</span><span>(</span><span>0</span><span>, </span><span>10</span><span>)</span><span></span></p><p><span></span><span>5</span><span></span></p><p><span></span><span>&gt;&gt;</span><span>&gt;</span><span> random.randint</span><span>(</span><span>0</span><span>, </span><span>10</span><span>)</span><span></span></p><p><span></span><span>8</span><span></span></p><p><span></span><span>&gt;&gt;</span><span>&gt;</span><span> random.randint</span><span>(</span><span>0</span><span>, </span><span>10</span><span>)</span><span></span></p><p><span></span><span>0</span><span></span></p><p><span></span><span># these last three numbers are the same every time the process restarts!</span></p></div></div></pre><p>Detour complete. The source code for <code>unrandom</code> is <a href="https://github.com/healeycodes/unrandom">on GitHub</a>. I imagine it will run on most x86-64 Linux distributions.</p><p>My main resource was the <a href="https://man7.org/linux/man-pages/man2/ptrace.2.html">man page for ptrace</a>. These two blog posts also have helpful code examples and some fun ideas: <a href="https://nullprogram.com/blog/2018/06/23/">Intercepting and Emulating Linux System Calls with Ptrace</a> and <a href="https://www.alfonsobeato.net/c/modifying-system-call-arguments-with-ptrace/">Modifying System Call Arguments With ptrace</a>.</p><p>It was fun digging into system call tracing, so I&#39;m going to do some more research into how the tracing tools I use work under the hood!</p></div></div></div>
  </body>
</html>
