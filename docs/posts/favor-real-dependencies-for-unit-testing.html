<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stackoverflow.blog/2022/01/03/favor-real-dependencies-for-unit-testing/">Original</a>
    <h1>Favor real dependencies for unit testing</h1>
    
    <div id="readability-page-1" class="page"><div>
    
<p>If you’ve worked with <a href="https://stackoverflow.blog/2017/10/17/power-calculations-p-values-ab-testing-stack-overflow/">unit testing</a>, you’ve probably used <a href="https://blog.ploeh.dk/dippp">dependency injection</a> to be able to decouple objects and control their behavior while testing them. You’ve probably injected <a href="https://blog.ploeh.dk/2013/10/23/mocks-for-commands-stubs-for-queries">mocks or stubs</a> into the system under test in order to define repeatable, deterministic unit tests.</p>



<p>Such a test might look like this:</p>



<pre><code>[Fact]
public async Task AcceptWhenInnerManagerAccepts()
{
    var r = new Reservation(
        DateTime.Now.AddDays(10).Date.AddHours(18),
        &#34;x@example.com&#34;,
        &#34;&#34;,
        1);
    var mgrTD = new Mock&lt;IReservationsManager&gt;();
    mgrTD.Setup(mgr =&gt; mgr.TrySave(r)).ReturnsAsync(true);
    var sut = new RestaurantManager(
        TimeSpan.FromHours(18),
        TimeSpan.FromHours(21),
        mgrTD.Object);
 
    var actual = await sut.Check(r);
 
    Assert.True(actual);
}
</code></pre>



<p>(This C# test uses <a href="https://xunit.net/">xUnit.net</a> 2.4.1 with <a href="https://github.com/moq/moq4">Moq</a> 4.14.1.)</p>



<p>Such tests are brittle. They break easily and therefore increase your maintenance burden.</p>



<h3 id="h-why-internal-dependencies-are-bad">Why internal dependencies are bad</h3>



<p id="h-as-the-above-unit-test-implies-the-restaurantmanager-relies-on-an-injected-ireservationsmanager-dependency-this-interface-is-an-internal-implementation-detail-think-of-the-entire-application-as-a-blue-box-with-two-objects-as-internal-components">As the above unit test implies, the <code>RestaurantManager</code> relies on an injected <code>IReservationsManager</code> dependency. This interface is an internal implementation detail. Think of the entire application as a blue box with two objects as internal components:</p>



<figure><img src="https://lh3.googleusercontent.com/E1YJw5Y-d-EyKvKEQvrO1OHVvo44IMFC5lENCGQ-LiukqjHdfbfxU9FoDPxsgLPxbVfqqFtLLEC1JMJPLcXj932qdT7vMmKcFPRT0W2xyugz_PHLkoH21VYLzm5jieSts7GQa-mp" alt=""/></figure>



<p>An application contains many internal building blocks. The above illustration emphasizes two such components, and how they interact with each other.</p>



<p>What happens if you’d like to refactor the application code? Refactoring often involves changing how internal building blocks interact with each other. For example, you might want to change the <code>IReservationsManager</code> interface.</p>



<p>When you make a change like that, you’ll break some of the code that relies on the interface. That’s to be expected. Refactoring, after all, involves changing code.</p>



<p>When your tests also rely on internal implementation details, refactoring also breaks the tests. Now, in addition to improving the internal code, you also have to fix all the tests that broke.</p>



<p>Using a <em>dynamic mock library</em> like <a href="https://github.com/moq/moq4">Moq</a> tends to amplify the problem. You now have to visit all the tests that configure mocks and adjust them to model the new internal interaction.</p>



<p>This kind of friction is likely to deter you from refactoring in the first place. If you know that a warranted refactoring will give you much extra work fixing tests, you may decide that it isn’t worth the trouble. Instead, you leave the production code in a suboptimal state.</p>



<p>Is there a better way?</p>



<h3 id="h-functional-core">Functional core</h3>



<p id="h-in-order-to-find-a-better-alternative-you-must-first-understand-the-problem-why-use-test-doubles-mocks-and-stubs-in-the-first-place">In order to find a better alternative, you must first understand the problem. Why use test doubles (mocks and stubs) in the first place?</p>



<p>Test doubles serve a major purpose: They enable us to write deterministic unit tests.</p>



<p><a href="https://martinfowler.com/articles/nonDeterminism.html">Unit tests should be deterministic</a>. Running a test multiple times should produce the same outcome each time (<a href="https://en.wikipedia.org/wiki/Ceteris_paribus">ceteris paribus</a>). A test that succeeds on a Wednesday shouldn’t fail on a Saturday.</p>



<p>By using a test double each test can control how a dependency behaves. In <a href="http://bit.ly/working-effectively-with-legacy-code"><em>Working Effectively with Legacy Code</em></a><em>,</em> Michael Feathers likens a test to a <a href="https://en.wikipedia.org/wiki/Vise">vise</a>. It’s a tool to fix a particular behavior in place.</p>



<p>Test doubles, however, aren’t the only way to make tests deterministic.</p>



<p>A better alternative is to make the production code itself deterministic. Imagine, for example, that you need to write code that calculates the volume of a <a href="https://en.wikipedia.org/wiki/Frustum">frustum</a>. As long as the frustum doesn’t change, the volume remains the same number. Such a calculation is entirely deterministic.</p>



<p>Write your production code using mostly deterministic operations. For example, instead of the above <code>RestaurantManager</code>, you can write an immutable class with a method like this:</p>



<pre><code>public bool WillAccept(
    DateTime now,
    IEnumerable&lt;Reservation&gt; existingReservations,
    Reservation candidate)
{
    if (existingReservations is null)
        throw new ArgumentNullException(nameof(existingReservations));
    if (candidate is null)
        throw new ArgumentNullException(nameof(candidate));
    if (candidate.At &lt; now)
        return false;
    if (IsOutsideOfOpeningHours(candidate))
        return false;
 
    var seating = new Seating(SeatingDuration, candidate.At);
    var relevantReservations =
        existingReservations.Where(seating.Overlaps);
    var availableTables = Allocate(relevantReservations);
    return availableTables.Any(t =&gt; t.Fits(candidate.Quantity));
}
</code></pre>



<p>This example, like all code in this article, is from my book <a href="https://blog.ploeh.dk/code-that-fits-in-your-head"><em>Code That Fits in Your Head</em></a>. Despite implementing <a href="https://blog.ploeh.dk/2020/01/27/the-maitre-d-kata">quite complex business logic</a>, it’s a <a href="https://en.wikipedia.org/wiki/Pure_function">pure function</a>. All the helper methods involved (<code>IsOutsideOfOpeningHours</code>, <code>Overlaps</code>, <code>Allocate</code>, etc.) are also deterministic.</p>



<p>The upshot is that <a href="https://blog.ploeh.dk/2015/05/07/functional-design-is-intrinsically-testable">deterministic operations are easy to test</a>. For instance, here’s a parametrized test of the happy path:</p>



<pre><code>[Theory, ClassData(typeof(AcceptTestCases))]
public void Accept(MaitreD sut, DateTime now, IEnumerable&lt;Reservation&gt; reservations)
{
    var r = Some.Reservation.WithQuantity(11);
    var actual = sut.WillAccept(now, reservations, r);
    Assert.True(actual);
}
</code></pre>



<p>This code snippet doesn’t show the test case data source (<code>AcceptTestCases</code>), but it’s a small helper class that produces seven test cases that supply values for <code>sut</code>, <code>now</code>, and <code>reservations</code>.</p>



<p>This test method is typical of unit tests of pure functions:</p>



<ol><li>Prepare input value(s)</li><li>Call the function</li><li>Compare the expected outcome with the actual value</li></ol>



<p>If you recognize <a href="https://blog.ploeh.dk/2013/06/24/a-heuristic-for-formatting-code-according-to-the-aaa-pattern">that structure as the Arrange Act Assert pattern</a>, you’re not wrong, but that’s not the main point. What’s worth noticing is that despite non-trivial business logic, no test doubles (i.e. mocks or stubs) are required. This is one of many advantages of pure functions. Since they are already deterministic, you don’t have to introduce artificial seams into the code to enable testing.</p>



<p>Writing most of a code base as deterministic functions is possible, but requires practice. This style of programming is called <em>functional programming</em> (FP), and while it may require effort for object-oriented programmers to shift perspective, it’s quite the game changer—both because of the benefits to testing, and for <a href="https://blog.ploeh.dk/2021/07/28/referential-transparency-fits-in-your-head">other reasons</a>.</p>



<p>Even the most idiomatic FP code base, however, must deal with the messy, non-deterministic real world. Where do input values like <code>now</code> and <code>existingReservations</code> come from?</p>



<h3 id="h-imperative-shell">Imperative shell</h3>



<p id="h-a-typical-functional-architecture-tends-to-resemble-the-ports-and-adapters-architecture-you-implement-all-business-and-application-logic-as-pure-functions-and-push-impure-actions-to-the-edge">A typical <a href="https://blog.ploeh.dk/2018/11/19/functional-architecture-a-definition">functional architecture</a> tends to <a href="https://blog.ploeh.dk/2016/03/18/functional-architecture-is-ports-and-adapters">resemble the Ports and Adapters architecture</a>. You implement all business and application logic as pure functions and push impure actions to the edge.</p>



<p>At the edge, and only at the edge, you allow impure actions to take place. In the example code that runs through <a href="https://blog.ploeh.dk/code-that-fits-in-your-head"><em>Code That Fits in Your Head</em></a>, this happens in controllers. For example, this <code>TryCreate</code> helper method is defined in a <code>ReservationsController</code> class:</p>



<pre><code>private async Task&lt;ActionResult&gt; TryCreate(
    Restaurant restaurant,
    Reservation reservation)
{
    using var scope =
        new TransactionScope(TransactionScopeAsyncFlowOption.Enabled);
 
    var reservations = await Repository
        .ReadReservations(restaurant.Id, reservation.At)
        .ConfigureAwait(false);
    var now = Clock.GetCurrentDateTime();
    if (!restaurant.MaitreD.WillAccept(now, reservations, reservation))
        return NoTables500InternalServerError();
 
    await Repository.Create(restaurant.Id, reservation)
        .ConfigureAwait(false);
 
    scope.Complete();
 
    return Reservation201Created(restaurant.Id, reservation);
}
</code></pre>



<p>The <code>TryCreate</code> method makes use of two impure, injected dependencies: <code>Repository</code> and <code>Clock</code>.</p>



<p>The <code>Repository</code> dependency represents the database that stores reservations, while <code>Clock</code> represents some kind of clock. These dependencies aren’t arbitrary. They’re there to support unit testing of the application’s <a href="https://www.kennethlange.com/functional-core-imperative-shell/"><em>imperative shell</em></a>, and they have to be injected dependencies exactly because they’re sources of non-determinism.</p>



<p>It’s easiest to understand why <code>Clock</code> is a source of non-determinism. Every time you ask what time it is, the answer changes. That’s non-deterministic, because the textbook definition of determinism is that the same input should always produce the same output.</p>



<p>The same definition applies to databases. You can repeat the same database query, and over time receive different outputs because the state of the database changes. By the definition of determinism, that makes a database non-deterministic: The same input may produce varying outputs.</p>



<p>You can still unit test the imperative shell, but you don’t have to use brittle dynamic mock objects. Instead, use Fakes.</p>



<h3 id="h-fakes">Fakes</h3>



<p id="h-in-the-pattern-language-of-xunit-test-patterns-a-fake-is-a-kind-of-test-double-that-could-almost-serve-as-a-real-implementation-of-an-interface-an-in-memory-database-is-a-useful-example">In the pattern language of <a href="http://bit.ly/xunitpatterns">xUnit Test Patterns</a>, a fake is a kind of test double that could <em>almost</em> serve as a “real” implementation of an interface. An in-memory “database” is a useful example:</p>



<pre><code>public sealed class FakeDatabase :
    ConcurrentDictionary&lt;int, Collection&lt;Reservation&gt;&gt;,
    IReservationsRepository
</code></pre>



<p>While implementing <code>IReservationsRepository</code>, this test-specific <code>FakeDatabase</code> class inherits <code>ConcurrentDictionary&lt;int, Collection&lt;Reservation&gt;&gt;</code>, which means it can leverage the dictionary base class to add and remove reservations. Here’s the <code>Create</code> implementation:</p>



<pre><code>public Task Create(int restaurantId, Reservation reservation)
{
    AddOrUpdate(
        restaurantId,
        new Collection&lt;Reservation&gt; { reservation },
        (_, rs) =&gt; { rs.Add(reservation); return rs; });
    return Task.CompletedTask;
}
</code></pre>



<p>And here’s the <code>ReadReservations</code> implementation:</p>



<pre><code>public Task&lt;IReadOnlyCollection&lt;Reservation&gt;&gt; ReadReservations(
    int restaurantId,
    DateTime min,
    DateTime max)
{
    return Task.FromResult&lt;IReadOnlyCollection&lt;Reservation&gt;&gt;(
        GetOrAdd(restaurantId, new Collection&lt;Reservation&gt;())
            .Where(r =&gt; min &lt;= r.At &amp;&amp; r.At &lt;= max).ToList());
}
</code></pre>



<p>The <code>ReadReservations</code> will return the reservations already added to the repository with the <code>Create </code>method. Of course, it only works as long as the <code>FakeDatabase </code>object remains in memory, but that’s sufficient for a unit test:</p>



<pre><code>[Theory]
[InlineData(1049, 19, 00, &#34;juliad@example.net&#34;, &#34;Julia Domna&#34;, 5)]
[InlineData(1130, 18, 15, &#34;x@example.com&#34;, &#34;Xenia Ng&#34;, 9)]
[InlineData( 956, 16, 55, &#34;kite@example.edu&#34;, null, 2)]
[InlineData( 433, 17, 30, &#34;shli@example.org&#34;, &#34;Shanghai Li&#34;, 5)]
public async Task PostValidReservationWhenDatabaseIsEmpty(
    int days,
    int hours,
    int minutes,
    string email,
    string name,
    int quantity)
{
    var at = DateTime.Now.Date + new TimeSpan(days, hours, minutes, 0);
    var db = new FakeDatabase();
    var sut = new ReservationsController(
        new SystemClock(),
        new InMemoryRestaurantDatabase(Grandfather.Restaurant),
        db);
 
    var dto = new ReservationDto
    {
        Id = &#34;B50DF5B1-F484-4D99-88F9-1915087AF568&#34;,
        At = at.ToString(&#34;O&#34;),
        Email = email,
        Name = name,
        Quantity = quantity
    };
    await sut.Post(dto);
 
    var expected = new Reservation(
        Guid.Parse(dto.Id),
        at,
        new Email(email),
        new Name(name ?? &#34;&#34;),
        quantity);
    Assert.Contains(expected, db.Grandfather);
}
</code></pre>



<p>This test injects a <code>FakeDatabase</code> variable called <code>db</code> and ultimately asserts that <code>db</code> has the expected state. Since <code>db</code> stays in scope for the duration of the test, its behavior is deterministic and consistent.</p>



<p>Using a fake is more robust in the face of change. If you wish to refactor code that involves changes to an interface like <code>IReservationsRepository</code>, the only change you’ll need to make to the test code is to edit the fake implementation to make sure that it still preserves the invariants of the type. That’s one test file you’ll have to maintain, rather than the <a href="https://en.wikipedia.org/wiki/Shotgun_surgery">shotgun surgery</a> necessary when using dynamic mock libraries.</p>



<h3 id="h-architectural-dependencies">Architectural dependencies</h3>



<p id="h-to-recap-a-functional-core-needs-no-dependency-injection-to-support-unit-testing-because-functions-are-always-testable-being-deterministic-by-definition-only-the-imperative-shell-needs-dependency-injection-to-support-unit-testing">To recap: A <em>functional core</em> needs no dependency injection to support unit testing, because functions are always testable (being deterministic by definition). Only the <em>imperative shell</em> needs dependency injection to support unit testing.</p>



<p>Which dependencies are required? Every source of non-deterministic behavior and side effects. This tends to correspond to the actual, architectural dependencies of the application in question, with the possible addition of a clock and a random number generator.</p>



<p>The sample system in <a href="https://blog.ploeh.dk/code-that-fits-in-your-head"><em>Code That Fits in Your Head</em></a> has three “real” dependencies: Its database, an SMTP gateway, and the system clock:</p>



<figure><img src="https://lh6.googleusercontent.com/gnPpMc68dQQAguJ2s9Iztl8Jh3d9m7FfMdC_ZisVaK7b1u7BB3nzB-T_VOOvlFj5tilG8U-cZv2wnCqARUyBbor5IwTaL6wRX1OuU63TCcx8482PpUcFG4eu6Dmo-jWGji3KbF-5" alt=""/></figure>



<p>Apart from the system clock, these dependencies are components you’d also draw when illustrating the overall architecture of the system. The application is an opaque box, its internal organization implementation details, but its “real” dependencies represent other processes that may run somewhere else on the network.</p>



<p>These dependencies are the ones you may consider to explicitly model. These dependencies you can hide behind interfaces, inject with Constructor Injection, and replace using test doubles. Not mocks, stubs, or spies, but fakes.</p>



<h3 id="h-conclusion">Conclusion</h3>



<p id="h-which-dependencies-should-be-present-in-your-code-base">Which dependencies should be present in your code base?</p>



<p>Those that represent non-deterministic behavior or side effects. Adding rows to a database. Sending an email. Getting the current time and date. Querying a database.</p>



<p>These tend to correspond to the architectural dependencies of the system in question. If the application requires a database in order to work correctly, you’ll model the database as a polymorphic dependency. If the system must be able to send email, then a messaging gateway interface is warranted.</p>



<p>In addition to such architectural dependencies, system time and random number generators are the other well-known sources of non-determinism, so model those as explicit dependencies as well.</p>



<p>That’s it. Those are the dependencies you need. The rest are implementation details, likely to make your test code more brittle.</p>



<p>The implication is that a typical system will only have a handful of dependencies.</p><p>
    Tags: <a href="https://stackoverflow.blog/tag/dependencies/" rel="tag">dependencies</a>, <a href="https://stackoverflow.blog/tag/testing/" rel="tag">testing</a>  </p></div></div>
  </body>
</html>
