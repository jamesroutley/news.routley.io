<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.morling.dev/blog/building-durable-execution-engine-with-sqlite/">Original</a>
    <h1>Building a Durable Execution Engine with SQLite</h1>
    
    <div id="readability-page-1" class="page"><div>
		






		<div id="main-content">
			

			<div>
				
<p>Lately, there has been a lot of excitement around Durable Execution (DE) engines.
The basic idea of DE is to take (potentially long-running) multi-step workflows,
such as processing a purchase order or a user sign-up,
and make their individual steps persistent.
If a flow gets interrupted while running, for instance due to a machine failure,
the DE engine can resume it from the last successfully executed step and drive it to completion.</p>
<p>This is a very interesting value proposition:
the progress of critical business processes is captured reliably, ensuring they’ll complete eventually.
Importantly, any steps performed already successfully won’t be repeated when retrying a failed flow.
This helps to ensure that flows are executed correctly
(for instance preventing inventory from getting assigned twice to the same purchase order),
efficiently (e.g. avoiding repeated remote API calls),
and deterministically.
One particular category of software which benefits from this are agentic systems, or more generally speaking, any sort of system which interacts with LLMs.
LLM calls are slow and costly, and their results are non-deterministic.
So it is desirable to avoid repeating any previous LLM calls when continuing an agentic flow after a failure.</p>
<p>Now, at a high level, &#34;durable execution&#34; is nothing new.
A scheduler running a batch job for moving purchase orders through their lifecycle?
You could consider this a form of durable execution.
Sending a Kafka message from one microservice to another and reacting to the response message in a callback?
Also durable execution, if you squint a little.
A workflow engine running a BPMN job? Implementing durable execution, before the term actually got popularized.
All these approaches model multi-step business transactions—​making the logical flow of the overall transaction more or less explicit—​in a persistent way,
ensuring that transactions progress safely and reliably and eventually complete.</p>
<p>However, modern DE typically refers to one particular approach for achieving this goal:
Workflows defined in code, using general purpose programming languages such as Python, TypeScript, or Java.
That way, developers don’t need to pick up a new language for defining flows,
as was the case with earlier process automation platforms.
They can use their familiar tooling for editing flows, versioning them, etc.
A DE engine transparently tracks program progress, persists execution state in the form of durable checkpoints, and enables resumption after failures.</p>
<p>Naturally, this piqued my interest:
what would it take to implement a basic DE engine in Java?
Can we achieve something useful with less than, let’s say, 1,000 lines of code?
The idea being not to build a production-ready engine,
but to get a better understanding of the problem space and potential solutions for it.
You can find the result of this exploration, called Persistasaurus, in <a href="https://github.com/gunnarmorling/persistasaurus">this GitHub repository</a>.
Coincidentally, this project also serves as a very nice example of how modern Java versions can significantly simplify the life of developers.</p>
<div>
<h2 id="_hello_persistasaurus">Hello Persistasaurus!</h2>
<div>
<p>Let’s take a look at an example of what you can do with Persistasaurus and then dive into some of the key implementation details.
As per the idea of DE, flows are implemented as regular Java code.
The entry point of a flow is a method marked with the <code>@Flow</code> annotation.
Individual flow steps are methods annotated with <code>@Step</code>:</p>
<div>
<div>
<pre><code data-lang="java"><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
</pre></td><td><pre><span>public</span> <span>class</span> <span>HelloWorldFlow</span> <span>{</span>

  <span>@Flow</span>
  <span>public</span> <span>void</span> <span>sayHello</span><span>()</span> <span>{</span>
    <span>int</span> <span>sum</span> <span>=</span> <span>0</span><span>;</span>

    <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>5</span><span>;</span> <span>i</span><span>++)</span> <span>{</span>
      <span>sum</span> <span>+=</span> <span>say</span><span>(</span><span>&#34;World&#34;</span><span>,</span> <span>i</span><span>);</span>
    <span>}</span>

    <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>&#34;Sum: %s&#34;</span><span>,</span> <span>sum</span><span>));</span>
  <span>}</span>

  <span>@Step</span>
  <span>protected</span> <span>int</span> <span>say</span><span>(</span><span>String</span> <span>name</span><span>,</span> <span>int</span> <span>count</span><span>)</span> <span>{</span>
    <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>&#34;Hello, %s (%s)&#34;</span><span>,</span> <span>name</span><span>,</span> <span>count</span><span>));</span>
    <span>return</span> <span>count</span><span>;</span>
  <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>Steps are the unit of persistence—​their outcomes are recorded, and when resuming a flow after a failure,
it will continue from the last successfully run step method.
Now, which exact parts of a flow warrant being persisted as a step is on the developer to decide.
You don’t want to define steps too granularly, so as to keep the overhead of logging low.
In general, flow sections which are costly or time-consuming to run or whose result cannot easily be reproduced,
are great candidates for being moved into a step method.</p>
<p>A flow is executed by obtaining a <code>FlowInstance</code> object and then calling the flow’s main method:</p>
<div>
<div>
<pre><code data-lang="java"><table><tbody><tr><td><pre>1
2
3
4
5
6
</pre></td><td><pre><span>UUID</span> <span>uuid</span> <span>=</span> <span>UUID</span><span>.</span><span>randomUUID</span><span>();</span>

<span>FlowInstance</span><span>&lt;</span><span>HelloWorldFlow</span><span>&gt;</span> <span>flow</span> <span>=</span> <span>Persistasaurus</span><span>.</span><span>getFlow</span><span>(</span>
    <span>HelloWorldFlow</span><span>.</span><span>class</span><span>,</span> <span>uuid</span><span>);</span>

<span>flow</span><span>.</span><span>run</span><span>(</span><span>f</span> <span>-&gt;</span> <span>f</span><span>.</span><span>sayHello</span><span>());</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>Each flow run is identified by a unique id,
allowing to re-execute it after a failure, or to resume it when waiting for an external signal (&#34;human in the loop&#34;, more on that below).
If the Hello World flow runs to completion, the following will be logged to stdout:</p>
<div>
<div>
<pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
</pre></td><td><pre>Hello, World (0)
Hello, World (1)
Hello, World (2)
Hello, World (3)
Hello, World (4)
Sum: 10
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>Now let’s assume something goes wrong while executing the third step:</p>
<div>
<div>
<pre><code><table><tbody><tr><td><pre>1
2
3
4
</pre></td><td><pre>Hello, World (0)
Hello, World (1)
Hello, World (2)
RuntimeException(&#34;Uh oh&#34;)
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>When re-running the flow, using the same UUID as before, it will retry that failed step and resume from there. The first two steps which were already run successfully are not re-executed.
Instead, they will be replayed from a persistent execution log, which is based on <a href="https://sqlite.org/">SQLite</a>, an embedded SQL database:</p>
<div>
<div>
<pre><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre>Hello, World (3)
Hello, World (4)
Sum: 10
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>In the following, let’s take a closer look at some of the implementation choices in Persistasaurus.</p>
</div>
</div>
<div>
<h2 id="_capturing_execution_state">Capturing Execution State</h2>
<div>
<p>At the core of every DE engine there’s some form of persistent durable execution log.
You can think of this a bit like the write-ahead log of a database.
It captures the intent to execute a given flow step, which makes it possible to retry that step should it fail, using the same parameter values.
Once successfully executed, a step’s result will also be recorded in the log,
so that it can be replayed from there if needed, without having to actually re-execute the step itself.</p>
<p>DE logs come in two flavours largely speaking; one is in the form of an external state store which is accessed via some sort of SDK.
Example frameworks taking this approach include <a href="https://temporal.io/">Temporal</a>, <a href="https://www.restate.dev/">Restate</a>, <a href="https://www.resonatehq.io/">Resonate</a>, and <a href="https://www.inngest.com/">Inngest</a>.
The other option is to persist DE state in the local database of a given application or (micro)service.
One solution in this category is <a href="https://www.dbos.dev/">DBOS</a>, which implements DE on top of Postgres.</p>
<p>To keep things simple, I went with the local database model for Persistasaurus, using SQLite for storing the execution log.
But as we’ll see later on, depending on your specific use case, SQLite actually might also be a great choice for a production scenario,
for instance when building a self-contained agentic system.</p>
<p>The structure of the execution log table in SQLite is straight-forward.
It contains one entry for each durable execution step:</p>
<div>
<div>
<pre><code data-lang="sql"><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
</pre></td><td><pre><span>CREATE</span> <span>TABLE</span> <span>IF</span> <span>NOT</span> <span>EXISTS</span> <span>execution_log</span> <span>(</span>
  <span>flowId</span> <span>TEXT</span> <span>NOT</span> <span>NULL</span><span>,</span> <i data-value="1"></i><b>(1)</b>
  <span>step</span> <span>INTEGER</span> <span>NOT</span> <span>NULL</span><span>,</span> <i data-value="2"></i><b>(2)</b>
  <span>timestamp</span> <span>INTEGER</span> <span>NOT</span> <span>NULL</span><span>,</span> <i data-value="3"></i><b>(3)</b>
  <span>class_name</span> <span>TEXT</span> <span>NOT</span> <span>NULL</span><span>,</span> <i data-value="4"></i><b>(4)</b>
  <span>method_name</span> <span>TEXT</span> <span>NOT</span> <span>NULL</span><span>,</span> <i data-value="5"></i><b>(5)</b>
  <span>delay</span> <span>INTEGER</span><span>,</span> <i data-value="6"></i><b>(6)</b>
  <span>status</span> <span>TEXT</span> <i data-value="7"></i><b>(7)</b>
      <span>CHECK</span><span>(</span> <span>status</span> <span>IN</span> <span>(</span><span>&#39;PENDING&#39;</span><span>,</span><span>&#39;WAITING_FOR_SIGNAL&#39;</span><span>,</span><span>&#39;COMPLETE&#39;</span><span>)</span> <span>)</span>
      <span>NOT</span> <span>NULL</span><span>,</span>
  <span>attempts</span> <span>INTEGER</span> <span>NOT</span> <span>NULL</span> <span>DEFAULT</span> <span>1</span><span>,</span> <i data-value="8"></i><b>(8)</b>
  <span>parameters</span> <span>BLOB</span><span>,</span> <i data-value="9"></i><b>(9)</b>
  <span>return_value</span> <span>BLOB</span><span>,</span> <i data-value="10"></i><b>(10)</b>
  <span>PRIMARY</span> <span>KEY</span> <span>(</span><span>flowId</span><span>,</span> <span>step</span><span>)</span>
<span>)</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div>
<table>
<tbody><tr>
<td><i data-value="1"></i><b>1</b></td>
<td>The UUID of the flow</td>
</tr>
<tr>
<td><i data-value="2"></i><b>2</b></td>
<td>The sequence number of the step within the flow, in the order of execution</td>
</tr>
<tr>
<td><i data-value="3"></i><b>3</b></td>
<td>The timestamp of first running this step</td>
</tr>
<tr>
<td><i data-value="4"></i><b>4</b></td>
<td>The name of the class defining the step method</td>
</tr>
<tr>
<td><i data-value="5"></i><b>5</b></td>
<td>The name of the step method (currently ignoring overloaded methods for this PoC)</td>
</tr>
<tr>
<td><i data-value="6"></i><b>6</b></td>
<td>For delayed steps, the delay in milli-seconds</td>
</tr>
<tr>
<td><i data-value="7"></i><b>7</b></td>
<td>The current status of the step</td>
</tr>
<tr>
<td><i data-value="8"></i><b>8</b></td>
<td>A counter for keeping track of how many times the step has been tried</td>
</tr>
<tr>
<td><i data-value="9"></i><b>9</b></td>
<td>The serialized form of the step’s input parameters, if any</td>
</tr>
<tr>
<td><i data-value="10"></i><b>10</b></td>
<td>The serialized form of the step’s result, if any</td>
</tr>
</tbody></table>
</div>
<p>This log table stores all information needed to capture execution intent and persist results.
More details on the notion of delays and signals follow further down.</p>
<p>When running a flow, the engine needs to know when a given step gets executed so it can be logged.
One common way for doing so is via explicit API calls into the engine, e.g. like so with DBOS Transact:</p>
<div>
<div>
<pre><code data-lang="java"><table><tbody><tr><td><pre>1
2
3
4
5
</pre></td><td><pre><span>@Workflow</span>
<span>public</span> <span>void</span> <span>workflow</span><span>()</span> <span>{</span>
  <span>DBOS</span><span>.</span><span>runStep</span><span>(()</span> <span>-&gt;</span> <span>stepOne</span><span>(),</span> <span>&#34;stepOne&#34;</span><span>);</span>
  <span>DBOS</span><span>.</span><span>runStep</span><span>(()</span> <span>-&gt;</span> <span>stepTwo</span><span>(),</span> <span>&#34;stepTwo&#34;</span><span>);</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>This works, but tightly couples workflows to the DE engine’s API.
For Persistaurus I aimed to avoid this dependency as much as possible.
Instead, the idea is to transparently intercept the invocations of all step methods and track them in the execution log,
allowing for a very concise flow expression, without any API dependencies:</p>
<div>
<div>
<pre><code data-lang="java"><table><tbody><tr><td><pre>1
2
3
4
5
</pre></td><td><pre><span>@Flow</span>
<span>public</span> <span>void</span> <span>workflow</span><span>()</span> <span>{</span>
  <span>stepOne</span><span>();</span>
  <span>stepTwo</span><span>();</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>In order for the DE engine to know when a flow or step method gets invoked,
the <a href="https://en.wikipedia.org/wiki/Proxy_pattern">proxy pattern</a> is being used:
a proxy wraps the actually flow object and handles each of its method invocations,
updating the state in the execution log before and after passing the call on to the flow itself.
Thanks to Java’s dynamic nature, creating such a proxy is relatively easy, requiring just a little bit of bytecode generation.
Unsurprisingly, I’m using the <a href="https://bytebuddy.net/">ByteBuddy</a> library for this job:</p>
<div>
<div>
<pre><code data-lang="java"><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td><pre><span>private</span> <span>static</span> <span>&lt;</span><span>T</span><span>&gt;</span> <span>T</span> <span>getFlowProxy</span><span>(</span><span>Class</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>clazz</span><span>,</span> <span>UUID</span> <span>id</span><span>)</span> <span>{</span>
  <span>try</span> <span>{</span>
    <span>return</span> <span>new</span> <span>ByteBuddy</span><span>()</span>
        <span>.</span><span>subclass</span><span>(</span><span>clazz</span><span>)</span> <i data-value="1"></i><b>(1)</b>
        <span>.</span><span>method</span><span>(</span><span>ElementMatchers</span><span>.</span><span>any</span><span>())</span> <i data-value="2"></i><b>(2)</b>
        <span>.</span><span>intercept</span><span>(</span> <i data-value="3"></i><b>(3)</b>
            <span>MethodDelegation</span><span>.</span><span>withDefaultConfiguration</span><span>()</span>
                <span>.</span><span>withBinders</span><span>(</span>
                    <span>Morph</span><span>.</span><span>Binder</span><span>.</span><span>install</span><span>(</span><span>OverrideCallable</span><span>.</span><span>class</span><span>))</span>
                <span>.</span><span>to</span><span>(</span><span>new</span> <span>Interceptor</span><span>(</span><span>id</span><span>)))</span>
        <span>.</span><span>make</span><span>()</span>
        <span>.</span><span>load</span><span>(</span><span>Persistasaurus</span><span>.</span><span>class</span><span>.</span><span>getClassLoader</span><span>())</span> <i data-value="4"></i><b>(4)</b>
        <span>.</span><span>getLoaded</span><span>()</span>
        <span>.</span><span>getDeclaredConstructor</span><span>()</span>
        <span>.</span><span>newInstance</span><span>();</span> <i data-value="5"></i><b>(5)</b>
  <span>}</span>
  <span>catch</span> <span>(</span><span>Exception</span> <span>e</span><span>)</span> <span>{</span>
    <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>&#34;Couldn&#39;t instantiate flow&#34;</span><span>,</span> <span>e</span><span>);</span>
  <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div>
<table>
<tbody><tr>
<td><i data-value="1"></i><b>1</b></td>
<td>Create a sub-class proxy for the flow type</td>
</tr>
<tr>
<td><i data-value="2"></i><b>2</b></td>
<td>Intercept all method invocations on this proxy…​</td>
</tr>
<tr>
<td><i data-value="3"></i><b>3</b></td>
<td>…​and delegate them to an <code>Interceptor</code> object</td>
</tr>
<tr>
<td><i data-value="4"></i><b>4</b></td>
<td>Load the generated proxy class</td>
</tr>
<tr>
<td><i data-value="5"></i><b>5</b></td>
<td>Instantiate the flow proxy</td>
</tr>
</tbody></table>
</div>
<p>As an aside, Claude Code does an excellent job in creating code using the ByteBuddy API, which is not always self-explanatory.
Now, whenever a method is invoked on the flow proxy,
the call is delegated to the <code>Interceptor</code> class,
which will record the step in the execution log before invoking the actual flow method.
I am going to spare you the complete details of the method interceptor implementation
(you can find it <a href="https://github.com/gunnarmorling/persistasaurus/blob/main/src/main/java/dev/morling/persistasaurus/Persistasaurus.java">here</a> on GitHub),
but the high-level logic looks like so:</p>
<div>
<div>
<pre><code data-lang="java"><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td><pre><span>public</span> <span>Object</span> <span>intercept</span><span>(</span><span>@This</span> <span>Object</span> <span>instance</span><span>,</span>
    <span>@Origin</span> <span>Method</span> <span>method</span><span>,</span>
    <span>@AllArguments</span> <span>Object</span><span>[]</span> <span>args</span><span>,</span>
    <span>@Morph</span> <span>OverrideCallable</span> <span>callable</span><span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>

  <span>if</span> <span>(!</span><span>isFlowOrStep</span><span>(</span><span>method</span><span>))</span> <span>{</span>
    <span>return</span> <span>callable</span><span>.</span><span>call</span><span>(</span><span>args</span><span>);</span>
  <span>}</span>

  <span>Invocation</span> <span>loggedInvocation</span> <span>=</span> <span>executionLog</span><span>.</span><span>getInvocation</span><span>(</span><span>id</span><span>,</span> <span>step</span><span>);</span>

  <span>if</span> <span>(</span><span>loggedInvocation</span> <span>!=</span> <span>null</span> <span>&amp;&amp;</span>
      <span>loggedInvocation</span><span>.</span><span>status</span><span>()</span> <span>==</span> <span>InvocationStatus</span><span>.</span><span>COMPLETE</span><span>)</span> <span>{</span> <i data-value="1"></i><b>(1)</b>
    <span>step</span><span>++;</span>
    <span>return</span> <span>loggedInvocation</span><span>.</span><span>returnValue</span><span>();</span>
  <span>}</span>
  <span>else</span> <span>{</span>
    <span>executionLog</span><span>.</span><span>logInvocationStart</span><span>(</span>
        <span>id</span><span>,</span> <span>step</span><span>,</span> <span>method</span><span>.</span><span>getName</span><span>(),</span> <span>InvocationStatus</span><span>.</span><span>PENDING</span><span>,</span> <span>args</span><span>);</span> <i data-value="2"></i><b>(2)</b>

    <span>int</span> <span>currentStep</span> <span>=</span> <span>step</span><span>;</span>
    <span>step</span><span>++;</span>

    <span>Object</span> <span>result</span> <span>=</span> <span>callable</span><span>.</span><span>call</span><span>(</span><span>args</span><span>);</span> <i data-value="3"></i><b>(3)</b>

    <span>executionLog</span><span>.</span><span>logInvocationCompletion</span><span>(</span><span>id</span><span>,</span> <span>currentStep</span><span>,</span> <span>result</span><span>);</span> <i data-value="4"></i><b>(4)</b>

    <span>return</span> <span>result</span><span>;</span>
  <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div>
<table>
<tbody><tr>
<td><i data-value="1"></i><b>1</b></td>
<td>Replay completed step if present</td>
</tr>
<tr>
<td><i data-value="2"></i><b>2</b></td>
<td>Log invocation</td>
</tr>
<tr>
<td><i data-value="3"></i><b>3</b></td>
<td>Execute the actual step method</td>
</tr>
<tr>
<td><i data-value="4"></i><b>4</b></td>
<td>Log result</td>
</tr>
</tbody></table>
</div>
<p>Replaying completed steps from the log is essential for ensuring deterministic execution.
Each step typically runs exactly once,
capturing non-deterministic values such as the current time or random numbers while doing so.</p>
<p>There’s an important failure mode, though:
if the system crashes <em>after</em> a step has been executed but <em>before</em> the result can be recorded in the log,
that step would be repeated when rerunning the flow.
Odds for this to happen are pretty small, but whether it is acceptable or not depends on the particular use case.
When executing steps with side-effects, such as remote API calls,
it may  be a good idea to add idempotency keys to the requests,
which lets the invoked services detect and ignore any potential duplicate calls.</p>
<p>The actual execution log implementation isn’t that interesting, you can find its source code <a href="https://github.com/gunnarmorling/persistasaurus/blob/main/src/main/java/dev/morling/persistasaurus/internal/ExecutionLog.java">here</a>.
All it does is persist step invocations and their status in the <code>execution_log</code> SQLite table shown above.</p>
</div>
</div>
<div>
<h2 id="_delayed_executions">Delayed Executions</h2>
<div>
<p>At this point, we have a basic Durable Execution engine which can run simple flows as the one above.
Next, I explored implementing delayed execution steps.
As an example, consider a user onboarding flow, where you might want to send out an email with useful resources a few days after a user has signed up.
Using the annotation-based programming model of Persistasaurus, this can be expressed like so:</p>
<div>
<div>
<pre><code data-lang="java"><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td><pre><span>public</span> <span>class</span> <span>SignupFlow</span> <span>{</span>

  <span>@Flow</span>
  <span>public</span> <span>void</span> <span>signUp</span><span>(</span><span>String</span> <span>userName</span><span>,</span> <span>String</span> <span>email</span><span>)</span> <span>{</span>
    <span>long</span> <span>id</span> <span>=</span> <span>createUserRecord</span><span>(</span><span>userName</span><span>,</span> <span>email</span><span>);</span>

    <span>sendUsefulResources</span><span>(</span><span>id</span><span>);</span>
  <span>}</span>

  <span>@Step</span>
  <span>protected</span> <span>long</span> <span>createUserRecord</span><span>(</span><span>String</span> <span>userName</span><span>,</span> <span>String</span> <span>email</span><span>)</span> <span>{</span>
    <span>// persist the user...</span>
    <span>return</span> <span>id</span><span>;</span>
  <span>}</span>

  <span>@Step</span><span>(</span><span>delay</span><span>=</span><span>3</span><span>,</span> <span>timeUnit</span><span>=</span><span>DAYS</span><span>)</span>
  <span>protected</span> <span>void</span> <span>sendUsefulResources</span><span>(</span><span>long</span> <span>userId</span><span>)</span> <span>{</span>
    <span>// send the email...</span>
  <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>Naturally, we don’t want to block the initiating thread when delaying a step—​for instance, a web application’s request handler.
Instead, we need a way to temporarily yield execution of the flow, return control to the caller,
and then later on, when the configured delay has passed, resume the flow.</p>
<p>Unlike other programming languages, Java doesn’t support <a href="https://en.wikipedia.org/wiki/Continuation">continuations</a> via its public API.
So how could we yield control then?
One option would be to define a specific exception type, let’s say <code>FlowYieldException</code>, and raise it from within the method interceptor when encountering a delayed method.
The call stack would be unwound until some framework-provided exception handler catches that exception and returns control to the code triggering the flow.
For this to work, it is essential that no user-provided flow or step code catches that exception type.
Alternatively, one could transform the bytecode of the step method (and all the methods below it in the call stack),
so that it can return control at given suspension points and later on resume from there,
similar to how <a href="https://kotlinlang.org/spec/asynchronous-programming-with-coroutines.html#asynchronous-programming-with-coroutines">Kotlin’s coroutines</a> are implemented under the hood (&#34;continuation passing style&#34;).</p>
<p>Luckily, Java 21 offers a much simpler solution.
This version added support for virtual threads (<a href="https://openjdk.org/jeps/444">JEP 444</a>),
and while you shouldn’t block OS level threads, blocking virtual threads is totally fine.
Virtual threads are lightweight user-mode threads managed by the JVM,
and an application can have hundreds of thousands, or even millions of them at once.
Thus I decided to implement delayed executions in Persistasaurus through virtual threads,
sleeping for the given period of time when encountering a delayed method.</p>
<p>To run a flow with a delayed step, trigger it via <code>runAsync()</code>,
which immediately returns control to the caller:</p>
<div>
<div>
<pre><code data-lang="java"><table><tbody><tr><td><pre>1
2
3
4
</pre></td><td><pre><span>FlowInstance</span><span>&lt;</span><span>SignupFlow</span><span>&gt;</span> <span>flow</span> <span>=</span> <span>Persistasaurus</span><span>.</span><span>getFlow</span><span>(</span>
    <span>SignupFlow</span><span>.</span><span>class</span><span>,</span> <span>uuid</span><span>);</span>

<span>flow</span><span>.</span><span>runAsync</span><span>(</span><span>f</span> <span>-&gt;</span> <span>f</span><span>.</span><span>signUp</span><span>(</span><span>&#34;Bob&#34;</span><span>,</span> <span>&#34;bob@example.com&#34;</span><span>));</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>When putting a virtual thread running a flow method asleep,
it will be unmounted from the underlying OS level carrier thread,
freeing its resources.
Later on, once the sleep time has passed, the virtual thread will be remounted onto a carrier thread and continue the flow.
When rerunning non-finished flows with a delayed execution step,
Persistasaurus will only sleep for the remainder of the configured delay,
which might be zero if enough time has passed since the original run of the flow.</p>
<p>So in fact, you could think of virtual threads as a form of continuations;
and indeed, if you look closely at the stacktrace of a virtual thread, you’ll see that the frame at the very bottom is the <code>enter()</code> method of a JDK-internal class <code>Continuation</code>.
Interestingly, this class was even part of the public Java API in early preview versions of virtual threads,
but it got made private later on.</p>
</div>
</div>
<div>
<h2 id="_human_interaction">Human Interaction</h2>
<div>
<p>As the last step of my exploration I was curious how flows with &#34;human in the loop&#34;-steps could be implemented:
steps where externally provided input or data is required in order for a flow to continue.
Sticking to the sign-up flow example,
this could be an email by the user, so as to confirm their identity (double opt-in).
As much as possible, I tried to stick to the idea of using plain method calls for expressing the flow logic,
but I couldn’t get around making flows invoke a Persistasaurus-specific method, <code>await()</code>, for signalling that a step requires external input:</p>
<div>
<div>
<pre><code data-lang="java"><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
</pre></td><td><pre><span>public</span> <span>class</span> <span>SignupFlow</span> <span>{</span>

  <span>@Flow</span>
  <span>public</span> <span>void</span> <span>signUp</span><span>(</span><span>String</span> <span>userName</span><span>,</span> <span>String</span> <span>email</span><span>)</span> <span>{</span>
    <span>long</span> <span>id</span> <span>=</span> <span>createUserRecord</span><span>(</span><span>userName</span><span>,</span> <span>email</span><span>);</span>

    <span>sendEmailConfirmationRequest</span><span>(</span><span>email</span><span>);</span>

    <span>await</span><span>(()</span> <span>-&gt;</span> <span>confirmEmailAddress</span><span>(</span><span>any</span><span>()));</span> <i data-value="1"></i><b>(1)</b>

    <span>finalizeSignUp</span><span>(</span><span>id</span><span>);</span>
  <span>}</span>

  <span>@Step</span>
  <span>protected</span> <span>void</span> <span>confirmEmailAddress</span><span>(</span><span>Instant</span> <span>timeOfConfirmation</span><span>)</span> <span>{</span>
    <span>// ...</span>
  <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div>
<table>
<tbody><tr>
<td><i data-value="1"></i><b>1</b></td>
<td>Await the invocation of the given step method</td>
</tr>
</tbody></table>
</div>
<p>When the method interceptor encounters a step method invoked from within an <code>await()</code> block,
it doesn’t go on to actually execute right away.
Instead, the flow will await continuation until the step method gets triggered.
This is why it doesn’t matter which parameter values are passed to that step within the flow definition.
You could pass <code>null</code>, or, as a convention, the <code>any()</code> placeholder method.</p>
<p>In order to provide the input to a waiting step and continue the flow,
call the step method via <code>resume()</code>, for instance like so, in a request handler method of a Spring Boot web application:</p>
<div>
<div>
<pre><code data-lang="java"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
</pre></td><td><pre><span>@PostMapping</span><span>(</span><span>&#34;/email-confirmations&#34;</span><span>)</span>
<span>void</span> <span>confirmEmailAddress</span><span>(</span><span>@RequestBody</span> <span>Confirmation</span> <span>confirmation</span><span>)</span> <span>{</span>
  <span>FlowInstance</span><span>&lt;</span><span>UserSignupFlow</span><span>&gt;</span> <span>flow</span> <span>=</span> <span>Persistasaurus</span><span>.</span><span>getFlow</span><span>(</span>
        <span>UserSignupFlow</span><span>.</span><span>class</span><span>,</span> <span>confirmation</span><span>.</span><span>uuid</span><span>());</span>

  <span>flow</span><span>.</span><span>resume</span><span>(</span><span>f</span> <span>-&gt;</span> <span>{</span>
    <span>f</span><span>.</span><span>confirmEmailAddress</span><span>(</span><span>confirmation</span><span>.</span><span>timestamp</span><span>());</span>
  <span>});</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>The flow will then continue from that step, using the given parameter value(s) as its input.
For this to work, we need a way for the engine to know whether a given step method gets invoked from within <code>resume()</code> and thus actually should be executed,
or, whether it gets invoked from within <code>await()</code> and hence should be suspended.</p>
<p>Seasoned framework developers might immediately think of using thread-local variables for this purpose,
but as of Java 25, this can be solved much more elegantly and safely using so-called <em>scoped values</em>,
as defined in <a href="https://openjdk.org/jeps/506">JEP 506</a>.
To quote that JEP, scoped values</p>
<div>
<blockquote>
<p>enable a method to share immutable data both with its callees within a thread, and with child threads. Scoped values are easier to reason about than thread-local variables. They also have lower space and time costs</p>
</blockquote>
</div>
<p>Scoped values are typically defined as as a static field like so:</p>
<div>
<div>
<pre><code data-lang="java"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
</pre></td><td><pre><span>public</span> <span>class</span> <span>Persistasaurus</span> <span>{</span>

  <span>enum</span> <span>CallType</span> <span>{</span> <span>RUN</span><span>,</span> <span>AWAIT</span><span>,</span> <span>RESUME</span><span>;</span> <span>}</span>

  <span>static</span> <span>final</span> <span>ScopedValue</span><span>&lt;</span><span>CallType</span><span>&gt;</span> <span>CALL_TYPE</span> <span>=</span>
      <span>ScopedValue</span><span>.</span><span>newInstance</span><span>();</span>

  <span>// ...</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>To set the scoped value and run some unit of code with that value, call <code>ScopedValue::where()</code>:</p>
<div>
<div>
<pre><code data-lang="java"><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span>public</span> <span>static</span> <span>void</span> <span>await</span><span>(</span><span>Runnable</span> <span>r</span><span>)</span> <span>{</span>
  <span>ScopedValue</span><span>.</span><span>where</span><span>(</span><span>CALL_TYPE</span><span>,</span> <span>CallType</span><span>.</span><span>AWAIT</span><span>).</span><span>run</span><span>(</span><span>r</span><span>);</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>Unlike thread-local variables,
this ensures the scoped value is cleared when leaving the scope.
Then, further down in the call stack, within the method handler, the scoped value can be consumed:</p>
<div>
<div>
<pre><code data-lang="java"><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
</pre></td><td><pre><span>CallType</span> <span>callType</span> <span>=</span> <span>CALL_TYPE</span><span>.</span><span>get</span><span>();</span>

<span>if</span> <span>(</span><span>callType</span> <span>==</span> <span>CallType</span><span>.</span><span>RESUME</span><span>)</span> <span>{</span>
  <span>WaitCondition</span> <span>waitCondition</span> <span>=</span> <span>getWaitCondition</span><span>(</span><span>flowId</span><span>);</span>

  <span>waitCondition</span><span>.</span><span>lock</span><span>.</span><span>lock</span><span>();</span>

  <span>try</span> <span>{</span>
    <span>waitCondition</span><span>.</span><span>condition</span><span>.</span><span>signal</span><span>();</span>
  <span>}</span>
  <span>finally</span> <span>{</span>
    <span>waitCondition</span><span>.</span><span>lock</span><span>.</span><span>unlock</span><span>();</span>
  <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>In order to yield control when waiting for external input and to resume when that input has been provided,
a <code>ReentrantLock</code> with a wait condition is used.
Similar to the <code>sleep()</code> call used for fixed delay steps above,
a virtual thread will be unmounted from its carrier when waiting for a condition.</p>
<p>When accidentally trying to access a scoped value which isn’t actually set, an exception will be raised,
addressing another issue you’d commonly encounter with thread-local variables.
This might not seem like a huge deal,
but it’s great to see how the Java platform continues to evolve and improves things like this.</p>
</div>
</div>
<div>
<h2 id="_managing_state">Managing State</h2>
<div>
<p>Let’s dive a bit deeper into managing state in a durable execution engine.
For the example DE implementation developed for this blog post,
I went with SQLite primarily for the sake of simplicity.
Now, would you use SQLite, as an embedded database, also in an actual production-ready implementation?
The answer is going to depend on your specific use case.
If, for instance, you are building a self-contained AI agent and you want to use DE for making sure LLM invocations are not repeated when the agent crashes,
an embedded database such as SQLite would make for a great store for persisting execution state.
Each agent could have its own database, thus avoiding any concurrent writes, which can pose a bottleneck due to SQLite’s single-writer design.</p>
<p>On the other hand, if you’re building a system with a high number of parallel requests by different users,
such as a typical microservice,
a client/server database such as Postgres or MySQL would be a better fit.
If that system already maintains state in a database (as most services do),
then re-using that same database to store execution state provides a critical advantage:
Updates to the application’s data and its execution state can happen atomically in a single database transaction, providing atomicity guarantees.
This solution is implemented by the DBOS engine, on top of Postgres, for instance.</p>
<p>Another category of DE engines which include systems such as Temporal and Restate,
utilizes a separate server component with its own dedicated store for persisting execution state.
This approach can be very useful to implement flows spanning across a set of multiple services
(sometimes referred to as <a href="https://www.infoq.com/articles/saga-orchestration-outbox/">Sagas</a>).
By keeping track of the overall execution state in one central place,
they essentially avoid the need for cross-system transactions.</p>
<p>Another advantage of this approach is that the actual application doesn’t have to keep running while waiting for delayed execution steps,
making it a great fit for systems implemented in the form of scale-to-zero serverless designs (Function-as-a-Service, Knative, etc.).
The downside of this centralized design is the potentially closer coupling of the participating services,
as they all need to converge on a specific DE engine, on one specific version of that engine, etc.
Also HA and fault tolerance must be a priority in order to avoid the creation of a single point of failure between all the orchestrated services.</p>
</div>
</div>
<div>
<h2 id="_wrapping_up">Wrapping Up</h2>
<div>
<p>At its heart, the idea of Durable Execution is not a complex one:
Potentially long-running workflows are organized into individual steps whose execution status and result is persisted in a durable form.
That way, flows become resumable after failures, while skipping any steps already executed successfully.
You could think of it as a persistent implementation of the <a href="https://en.wikipedia.org/wiki/Memoization">memoization pattern</a>, or a persistent form of continuations.</p>
<p>As demonstrated in this post and the accompanying <a href="https://github.com/gunnarmorling/persistasaurus">source code</a>,
it doesn’t take too much work to create a functioning PoC for a DE engine.
Of course, it’s still quite a way to go from there to a system you’d actually want to put into production.
At the persistence level, you’d have to address aspects such as (horizontal) scalability, fault tolerance and HA.
The engine should support things such as retrying failing steps with exponential back-off,
parallel execution of workflow steps,
throttling flow executions, compensation steps for implementing Sagas, and more.
You’d also want to have a UI for managing flows, analyzing, restarting, and debugging them.
Finally, you should also have a strategy for evolving flow definitions and the state they persist,
in particular when dealing with long-running flows which may take days, weeks, or months to complete.</p>
</div>
</div>
			</div>

			
		</div>

		


</div></div>
  </body>
</html>
