<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/opentffoundation/roadmap/issues/24">Original</a>
    <h1>HashiCorp silently amend Terraform Registry TOS</h1>
    
    <div id="readability-page-1" class="page"><section><picture><source srcset="https://thevaluable.dev/images/2023/grep-guide/grep_family.jpg" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/grep-guide/grep_family.jpg" alt="Darth Vader tries to grep his family"/></picture><p>It’s rainy and dark outside, and it’s not going better inside: another depressing day at MegaCorpMoneyMaker, the company you’re working for. Of course, you need to debug the 28925th bug of the day; some cursed prices made their way into the database, finally reflecting the real value of the low quality products the company is selling. Your manager, of course, doesn’t see this unfortunate change as positively.</p><p>These prices are imported from files you’re fetching from an FTP. You need to search through all these files to find out where the weird pricing is coming from, and you don’t really know how to do that without losing your time (and your mind).</p><p>You try to use some search tools, but they’re too slow; naturally, you begin to bang your hands on the keyboard, almost throwing your computer out the window. Davina, your colleague developer, takes interest in your struggle. After explaining your problem, she gives her recommendations:</p><p>“You might want to use your terminal to search through all these files. GNU grep could help here, but if it’s still too slow we could try a more modern and faster alternative”.</p><p>Davina is right; that’s why this article is about GNU grep and some other, more modern alternatives. GNU grep is already available in most Linux distros, but if you use anything else (like, randomly, macOS), I would recommend you to install GNU grep anyway; it offers many more functionalities than any other grep out there.</p><p>You can see if you have GNU grep installed by running <code>grep --version</code> in your shell.</p><p>Here’s what we’ll see in this article:</p><ul><li>The general use of grep as well as its syntax.</li><li>How to create some aliases to use grep with colored output and a more robust regex engine.</li><li>How to modify the output: inverting the matches, only output the pattern matched, output line numbers…</li><li>How to display or hides the filenames in the output.</li><li>How to include or exclude some specific files.</li><li>How to output some context (the lines before or after the pattern matched).</li><li>How to pipe grep with other CLIs.</li><li>More modern and faster alternatives to grep.</li></ul><p>There is also a <a href="https://github.com/Phantas0s/the_valuable_dev_companion/tree/main/guide-grep" target="_blank" rel="noopener">companion project</a> if you want to follow along and try by yourself the different commands. I’d recommend you to do so, to remember what we’ll see here, and be able to use grep in different contexts.</p><p>Last thing: if you prefer watching a video instead of reading this article, you’ll find one about grep on my YouTube channel in the conclusion of this post, at the end of the page.</p><p>Are you ready to dive into the shallow waters of grep?</p><h2 id="general-use">General Use</h2><p>As you might know, grep can output all lines matching a specific pattern (a <a href="https://thevaluable.dev/regular-expression-basics-vim-grep/">regular expression, or regex</a>) from a text file. It can be used to search some specific information, which can then be piped to other CLI for more processing. As a result, like many CLIs, it’s a fast and powerful tool.</p><h3 id="general-syntax">General Syntax</h3><p>If you look at the man page of grep (something you should definitely do if you want to know more about it, thanks to the command <code>man grep</code>), you’ll get its general syntax as follows:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>grep <span>[</span>options...<span>]</span> <span>&#39;pattern&#39;</span> <span>[</span>files...<span>]</span>
</span></span></code></pre></div><p>It means that:</p><ol><li>You can give to grep one or more <code>options</code> or <code>files</code> (thanks to the three dots <code>...</code>).</li><li>Both <code>options</code> and <code>files</code> are optional (thanks to the square brackets <code>[]</code>). Instead of files, you can pipe an output to grep. We’ll look at that later in this article.</li><li>the <code>&#39;pattern&#39;</code> is mandatory.</li></ol><p>The single quotes I added to <code>&#39;patterns&#39;</code> are important: it will prevent your shell to expand any glob operators; instead, grep should get your raw pattern without any previous processing. Otherwise, it can lead to nasty side effects you might not see at first glance, but which can screw your output.</p><p>Enough rambling. Let’s look at a first example:</p><p>Here’s the result if you run the command above in the <a href="https://github.com/Phantas0s/the_valuable_dev_companion/tree/main/guide-grep" target="_blank" rel="noopener">project companion</a>:</p><picture><source srcset="https://thevaluable.dev/images/2023/grep-guide/01_grep_general_use.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/grep-guide/01_grep_general_use.jpg" alt="Using grep to find a literal string"/></picture><p>As you can see, you get every line containing the regex <code>div</code> as output.</p><p>As we’ve seen above, you can use grep to search in more than one file. In that case, each line will be prefixed by the filename where the pattern matches. For example, you can run:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>grep <span>&#39;div&#39;</span> styles.css Makefile
</span></span></code></pre></div><p>Here’s the result:</p><picture><source srcset="https://thevaluable.dev/images/2023/grep-guide/02_grep_general_use_multiple_files.jpg" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/grep-guide/02_grep_general_use_multiple_files.jpg" alt="Using grep to find a literal string in multiple files"/></picture><p>Wonderful! But there’s an inconvenience: you see the whole line where the pattern is matching, but it’s difficult to see the match itself. Also, we don’t really know what regex engine we’re using here; we can solve these horrible problems with a bit of configuration.</p><h2 id="a-bit-of-configuration">A Bit of Configuration</h2><p>Vanilla grep is great, but we can make it more powerful if we could add automatically some specific options each time we use the holy CLI.</p><h3 id="gimme-some-colors-please">Gimme Some Colors, Please</h3><p>I would strongly recommend you to always use the <code>--color</code> option when running grep, to emphasize all the information you get in the output, including the exact match:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>grep --color<span>=</span>auto <span>&#39;div&#39;</span> styles.css Makefile
</span></span></code></pre></div><p>The result:</p><picture><source srcset="https://thevaluable.dev/images/2023/grep-guide/03_grep_with_colors.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/grep-guide/03_grep_with_colors.jpg" alt="The output of grep is clearer with colors"/></picture><p>Now, do you see yourself adding this option each time you want to use grep? Me neither. The best way to solve this problem is to create an alias. Let’s run the following in your terminal:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>alias</span> <span>grep</span><span>=</span><span>&#34;grep --color=auto&#34;</span>
</span></span></code></pre></div><p>You can also add this line in one of your shell’s config file to always use the option when running grep.</p><p>Let’s try to use grep again:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>grep <span>&#39;div&#39;</span> styles.css Makefile
</span></span></code></pre></div><p>The result:</p><picture><source srcset="https://thevaluable.dev/images/2023/grep-guide/04_aliasing_grep_with_colors.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/grep-guide/04_aliasing_grep_with_colors.jpg" alt="The output of grep is clearer with colors"/></picture><p>This is the most beautiful output you’ll ever see in your life.</p><p>Remember: to bypass an alias in most common shells (it works at least in Bash ans Zsh), you can prefix the CLI’s name with a backslash <code>\</code>. For example:</p><div><pre tabindex="0"><code data-lang="text"><span><span>\grep &#39;div&#39; styles.css Makefile
</span></span></code></pre></div><p>The boring result:</p><picture><source srcset="https://thevaluable.dev/images/2023/grep-guide/05_using_grep_bypassing_alias.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/grep-guide/05_using_grep_bypassing_alias.jpg" alt="The output of grep is clearer with colors"/></picture><p>Now, what if you want to let your artistic side express itself by customizing these wonderful colors?</p><h3 id="customizing-greps-colors">Customizing grep’s Colors</h3><p>I’ve good news: you can configure the colors in the output thanks to the environment variable <code>GREP_COLORS</code>. Here’s the default value:</p><div><pre tabindex="0"><code data-lang="text"><span><span>ms=01;31:mc=01;31:sl=:cx=:fn=35:ln=32:bn=32:se=36
</span></span></code></pre></div><p>Difficult to be more cryptic. What’s going on here?</p><p>We can split this string into different patterns separated with colons <code>:</code>. These pattern always begins with two letters (called <em>capabilities</em>, basically what “thing” to colorize), followed by equal <code>=</code> and one or more integer, sometimes separated with a semi-color<code>;</code>.</p><p>For example, <code>ms=01;31</code> is the capability <code>ms</code> with value <code>01;31</code> (two integers separated with a semicolon). The capability <code>sl</code> is empty here; not like the capability <code>se</code> which has the value <code>36</code>.</p><p>The two integers given to a capability represent the background and the foreground color (or style) respectively.</p><table><tbody><tr><th>Capability</th><th>Description</th><th>Default</th></tr><tr><td><code>sl</code></td><td>The line where the pattern is matched (the selected line), without the match itself.</td><td><code>sl=</code> (empty)</td></tr><tr><td><code>cx</code></td><td>The lines where the pattern is not matched (the context lines).</td><td><code>cx=</code> (empty)</td></tr><tr><td><code>ms</code></td><td>The pattern matched (match in the selected line).</td><td><code>ms=01;31</code></td></tr><tr><td><code>fn</code></td><td>The eventual filename prefixing the selected line.</td><td><code>fn=35</code></td></tr><tr><td><code>ln</code></td><td>The eventual line numbers prefixing the selected line.</td><td><code>ln=32</code></td></tr><tr><td><code>se</code></td><td>Any separator displayed by grep.</td><td><code>se=36</code></td></tr></tbody></table><p>That’s great, but what all these integers stand for? The first one is the background color, the second one is for the foreground color (separated with a semicolon as we saw). But it’s not only about colors: the background color can be used to set up some specific formatting too.</p><p>Here’s a summary of the different integers you can use; they might not all work however, <a href="https://thevaluable.dev/guide-terminal-shell-console/">depending on the terminal you’re using</a>:</p><table><tbody><tr><th>Integer</th><th>Description</th></tr><tr><td><code>1</code></td><td>Bold.</td></tr><tr><td><code>3</code></td><td>Italic.</td></tr><tr><td><code>4</code></td><td>Underline.</td></tr><tr><td><code>5</code></td><td>Blink (to impress your coworkers).</td></tr><tr><td><code>7</code></td><td>Inverse the foreground and background color.</td></tr><tr><td><code>39</code></td><td>Default foreground color of you terminal.</td></tr><tr><td><code>30</code> to <code>37</code></td><td>Foreground colors set up for your terminal.</td></tr><tr><td><code>38;5;0</code> to <code>38;5;255</code></td><td>Foreground color (256 colors ANSI).</td></tr><tr><td><code>49</code></td><td>Default background color.</td></tr><tr><td><code>40</code> to <code>47</code></td><td>Background colors set up for your terminal.</td></tr><tr><td><code>48;5;0</code> to <code>48;5;255</code></td><td>Background color (256 colors ANSI). <strong>TODO to test</strong></td></tr></tbody></table><p>So, for example, if you want to keep grep’s defaults, but you prefer having matches underlined instead of bold, you can do the following:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>export</span> <span>GREP_COLORS</span><span>=</span><span>&#39;ms=04;31:mc=01;31:sl=:cx=:fn=35:ln=32:bn=32:se=36&#39;</span>
</span></span></code></pre></div><p>The only thing we changed is the <code>ms</code> capability; from <code>ms=01;31</code> to <code>ms=04;31</code>. Here’s the result:</p><picture><source srcset="https://thevaluable.dev/images/2023/grep-guide/06_using_grep_colors_environment_variable.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/grep-guide/06_using_grep_colors_environment_variable.jpg" alt="Using grep with the environment variable GREP_COLORS"/></picture><p>You can see that the matches <code>div</code> are now underlined.</p><h3 id="regular-expression-engines">Regular Expression Engines</h3><p>As we saw at the very beginning of the section, the pattern you give to grep is in fact a regular expression (regex). Let’s look again at the following example:</p><p>There is no metacharacter in the pattern here, so grep will try to match the literal <code>div</code> in the file <code>styles.css</code>. If you want to know more about regexes and their metacharacters, <a href="https://thevaluable.dev/regular-expression-basics-vim-grep/">I’ve written an article about that</a>.</p><p>The default regex engine used by grep is the <span>B</span>asic <span>R</span>egular <span>E</span>xpression engine (BRE). It’s not the best regex engine out there; in my opinion, it’s better to use the more common <span>P</span>erl <span>C</span>ompatible <span>R</span>egular <span>E</span>pression (PCRE). This is something which is specific to GNU grep; BSD grep, for example, doesn’t allow you to use this engine.</p><p>To use the <span>P</span>CRE engine, you can simply add the option <code>-P</code> to your commands. For example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>grep -P <span>&#39;^d.*$&#39;</span> styles.css
</span></span></code></pre></div><p>Here’s the result:</p><picture><source srcset="https://thevaluable.dev/images/2023/grep-guide/07_grep_pcre.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/grep-guide/07_grep_pcre.jpg" alt="Using grep with the PCRE engine"/></picture><p>Again, if you want to always use the PCRE engine, you can create another alias:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>alias</span> <span>grep</span><span>=</span><span>&#34;grep -P --color=auto&#34;</span>
</span></span></code></pre></div><p>Lovely.</p><h3 id="case-insensitive-matches">Case Insensitive Matches</h3><p>By default, grep will try to match your pattern in a case-sensitive manner; if you give to grep some lowercase characters, it won’t match their uppercase counterparts. If you prefer having case <span>i</span>nsensitive matches instead, you can use the <code>-i</code> option.</p><p>For example, let’s try the following in the <a href="https://github.com/Phantas0s/the_valuable_dev_companion/tree/main/guide-grep" target="_blank" rel="noopener">companion project</a>:</p><p>It won’t give you any result. But the following will:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>grep -i <span>&#39;reset&#39;</span> styles.css
</span></span></code></pre></div><picture><source srcset="https://thevaluable.dev/images/2023/grep-guide/08_grep_case_insensitive.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/grep-guide/08_grep_case_insensitive.jpg" alt="Using grep with case-insensitive"/></picture><p>Simple and effective. Again, if you want grep to be case-insensitive by default, you can add the option to your alias. You know the drill by now.</p><h3 id="the-deprecated-grep_options">The Deprecated GREP_OPTIONS</h3><p>Some resources on the Internet will recommend you to use the environment variable <code>GREP_OPTIONS</code> to set some default options to grep, instead of creating aliases.</p><p>But this option is deprecated for years, and for good reasons: if you run some third party shell scripts using grep, your default options will apply, something the original author can’t foresee. It can have unfortunate consequences.</p><p>I would recommend never setting <code>GREP_OPTIONS</code> but creating aliases instead; they’re not expanded in scripts by default.</p><h2 id="modifying-the-output">Modifying The Output</h2><p>It’s time to see how to modify grep’s output depending on your needs. This is most useful when you just want to pipe the output of grep to the input of another CLI which only accept a specific input.</p><p>We can also change the entire output to display a totally different kind of information (like the number of matches for example, instead of the matches themselves).</p><p>This section is not about filenames which could (or could not) be in the output. The next section is specifically dedicated to that.</p><h3 id="inverting-the-matching">Inverting the Matching</h3><p>If you want to in<span>v</span>ert the match, that is, to only output the lines which are <em>not</em> matching the pattern, you can use the option <code>-v</code> as follows:</p><p>The result:</p><picture><source srcset="https://thevaluable.dev/images/2023/grep-guide/09_grep_invert_match_output.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/grep-guide/09_grep_invert_match_output.jpg" alt="Output all the lines not matching the pattern given to grep"/></picture><p>You basically output the entire file except the lines matching the pattern <code>div</code>.</p><h3 id="output-only-the-matches">Output Only The Matches</h3><p>It can be useful to <span>o</span>nly output the match instead of the whole line. You can do that with the option <code>-o</code>:</p><p>The usual result:</p><picture><source srcset="https://thevaluable.dev/images/2023/grep-guide/10_grep_only_output_matches.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/grep-guide/10_grep_only_output_matches.jpg" alt="Output all the lines not matching the pattern given to grep"/></picture><p>Not very useful in that case, but it works as expected nonetheless.</p><h3 id="output-line-numbers">Output Line Numbers</h3><p>If you to prefix your matching lines with the line <span>n</span>umbers, you can add the <code>-n</code> option:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>grep -o -n <span>&#39;div&#39;</span> styles.css
</span></span></code></pre></div><p>Here’s the fantastic result:</p><picture><source srcset="https://thevaluable.dev/images/2023/grep-guide/11_grep_output_matches_with_line_number.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/grep-guide/11_grep_output_matches_with_line_number.jpg" alt="Output all the lines not matching the pattern given to grep"/></picture><h3 id="only-output-the-number-of-matches">Only Output the Number of Matches</h3><p>What if we only want to output the number of matches? We could pipe grep output to something like <code>wc</code> for example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>grep <span>&#39;div&#39;</span> styles.css <span>|</span> wc -l
</span></span></code></pre></div><p>But this is not necessary. To <span>c</span>ount the number of matches, we can use grep with the <code>-c</code> option:</p><p>The output:</p><picture><source srcset="https://thevaluable.dev/images/2023/grep-guide/12_output_match_count.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/grep-guide/12_output_match_count.jpg" alt="Output only the number of matches"/></picture><h3 id="summary-modifying-the-output">Summary: Modifying the Output</h3><p>Here’s a summary of every option we’ve seen in this section:</p><table><tbody><tr><th>Option</th><th>Description</th><th>Example</th></tr><tr><td><code>-v</code></td><td>Invert grep’s output: output the lines <em>not</em> matching the pattern.</td><td><code>grep -v &#39;div&#39; styles.css</code></td></tr><tr><td><code>-o</code></td><td>Output only the matches.</td><td><code>grep -o &#39;div&#39; styles.css</code></td></tr><tr><td><code>-n</code></td><td>Add the line numbers to the output.</td><td><code>grep -n &#39;div&#39; styles.css</code></td></tr><tr><td><code>-c</code></td><td>Only output the count of matches.</td><td><code>grep -c &#39;div&#39; styles.css</code></td></tr></tbody></table><h2 id="managing-filenames-in-the-output">Managing Filenames in the Output</h2><p>As we already saw, the filename will appear in the output if you give more than one file to grep. We can also manipulate these filenames thanks to a couple of options.</p><h3 id="hiding-all-filenames-from-the-output">Hiding all Filenames from the Output</h3><p>To <span>h</span>ide all filenames, you can use the <code>-h</code> option. For example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>grep -h <span>&#39;div&#39;</span> styles.css Makefile
</span></span></code></pre></div><p>The result you’ve been waiting for:</p><picture><source srcset="https://thevaluable.dev/images/2023/grep-guide/13_grep_never_output_filenames.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/grep-guide/13_grep_never_output_filenames.jpg" alt="Always hide the filenames from grep&#39;s output"/></picture><p>Because we give more than one file to grep, the output should have included the filenames if we didn’t add the <code>-h</code> option.</p><h3 id="always-output-filenames">Always Output Filenames</h3><p>If you want to always output the filenames before the matched lines, you can use the option <code>-H</code>. Notice that it’s the inverse of the <code>-h</code> option (which always hide the filenames). Many CLI use the uppercase counterpart of an option to invert it.</p><p>Here’s the usual example:</p><p>The result:</p><picture><source srcset="https://thevaluable.dev/images/2023/grep-guide/14_grep_always_output_filenames.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/grep-guide/14_grep_always_output_filenames.jpg" alt="Always output the filenames in grep&#39;s output"/></picture><p>Without the <code>-H</code> option, the filename wouldn’t have been displayed here since we only give one file to grep.</p><h3 id="only-output-filenames">Only Output Filenames</h3><p>What if we on<span>l</span>y want to output the filenames, and nothing else? To do so, we can use the <code>-l</code> option:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>grep -l <span>&#39;div&#39;</span> styles.css Makefile README.md
</span></span></code></pre></div><p>The result:</p><picture><source srcset="https://thevaluable.dev/images/2023/grep-guide/15_grep_only_output_filenames.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/grep-guide/15_grep_only_output_filenames.jpg" alt="Only output the filenames in grep&#39;s output"/></picture><p>We give three files to grep, but only two match the pattern here.</p><h3 id="only-output-filenames-without-matches">Only Output Filenames Without Matches</h3><p>Let’s invert our output once more: what if we only want to output the filenames where the pattern doesn’t match? To do so, we can use the <code>-L</code> option (again, the uppercase <code>-L</code> is the inverse of the lowercase <code>-l</code>). For example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>grep -L <span>&#39;div&#39;</span> styles.css Makefile README.md
</span></span></code></pre></div><p>The expected result:</p><picture><source srcset="https://thevaluable.dev/images/2023/grep-guide/16_only_output_filenames_without_matches.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/grep-guide/16_only_output_filenames_without_matches.jpg" alt="Only output the filenames without matches"/></picture><h3 id="summary-managing-filenames-in-the-output">Summary: Managing Filenames in the Output</h3><p>Let’s make a summary once more. Here’s what we’ve seen in this section:</p><table><tbody><tr><th>Option</th><th>Description</th><th>Example(s)</th></tr><tr><td><code>-h</code></td><td>Always hide the filenames in the output.</td><td><code>grep -h &#39;div&#39; styles.css Makefile</code></td></tr><tr><td><code>-H</code></td><td>Always display the filenames in the output.</td><td><code>grep -H &#39;div&#39; styles.css Makefile</code></td></tr><tr><td><code>-l</code></td><td>Only output the filenames where the pattern is matched.</td><td><code>grep -l &#39;div&#39; styles.css README.md</code></td></tr><tr><td><code>-L</code></td><td>Only output the filenames where the pattern <em>doesn’t</em> match.</td><td><code>grep -L &#39;div&#39; styles.css README.md</code></td></tr></tbody></table><h2 id="adding-some-context-to-the-output">Adding Some Context to the Output</h2><p>By default, grep will output the entire line where the pattern is matched. But to understand the data we’re working with, we might also need to display some context: the lines before and after the matches.</p><p>It’s very useful when parsing any kind of log for example, to get everything we need (like the error message or the Git comment).</p><p>These options accept a value, to specify how many additional lines we want to display.</p><h3 id="output-the-lines-after-the-match">Output the Lines After The Match</h3><p>To output the lines <span>a</span>fter the matches, we can use the <code>-A</code> option:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>grep -A <span>3</span> <span>&#39;div&#39;</span> styles.css
</span></span></code></pre></div><p>The output:</p><picture><source srcset="https://thevaluable.dev/images/2023/grep-guide/17_grep_display_context_after.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/grep-guide/17_grep_display_context_after.jpg" alt="Output the context after the match using grep"/></picture><h3 id="output-the-lines-before-the-match">Output the Lines Before The Match</h3><p>Similarly, if you want to output the lines <span>B</span>efore the match, you can use the option <code>-B</code>:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>grep -B <span>3</span> <span>&#39;div&#39;</span> styles.css
</span></span></code></pre></div><p>Here’s the expected result:</p><picture><source srcset="https://thevaluable.dev/images/2023/grep-guide/18_grep_output_context_before.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/grep-guide/18_grep_output_context_before.jpg" alt="Output the context before the match using grep"/></picture><h3 id="output-the-lines-before-and-after-the-match">Output the Lines Before And After the Match</h3><p>You can even output the lines before <em>and</em> after the match (for a full <span>c</span>ontext) with the <code>-C</code> option:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>grep -C <span>3</span> <span>&#39;div&#39;</span> styles.css
</span></span></code></pre></div><p>The magical output:</p><picture><source srcset="https://thevaluable.dev/images/2023/grep-guide/19_grep_display_context.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/grep-guide/19_grep_display_context.jpg" alt="Output the context before and after the match using grep"/></picture><p>This is equivalent to the following command:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>grep -A <span>3</span> -B <span>3</span> <span>&#39;div&#39;</span> styles.css
</span></span></code></pre></div><h3 id="summary-adding-some-context-to-the-output">Summary: Adding Some Context to the Output</h3><p>Let’s recap what we’ve seen in this section:</p><table><tbody><tr><th>Option</th><th>Description</th><th>Example(s)</th></tr><tr><td><code>-A &lt;value&gt;</code></td><td>Output <code>&lt;value&gt;</code> lines after the lines matching the pattern.</td><td><code>grep -A 3 &#39;div&#39; styles.css</code></td></tr><tr><td><code>-B &lt;value&gt;</code></td><td>Output <code>&lt;value&gt;</code> lines before the lines matching the pattern.</td><td><code>grep -B 3 &#39;div&#39; styles.css</code></td></tr><tr><td><code>-C &lt;value&gt;</code></td><td>Output <code>&lt;value&gt;</code> lines before and after the lines matching the pattern for a full context.</td><td><code>grep -C 3 &#39;div&#39; styles.css</code></td></tr></tbody></table><p>There’s an easy mnemonic to remember these 3 options: <span>A</span>fter, <span>B</span>efore, and <span>C</span>ontext makes… <span>ABC</span>.</p><h2 id="including-or-excluding-files">Including or Excluding Files</h2><p>What about including or excluding files from grep’s parser? We can use two options with GNU grep to do so.</p><h3 id="excluding-files">Excluding files</h3><p>In this article, we always gave the exact files we wanted to parse with grep. What if, instead, we want to parse everything <em>except</em> some specific files? To do so, we can use the <code>--exclude</code> option:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>grep <span>&#39;div&#39;</span> --exclude<span>=</span><span>&#39;Make*&#39;</span> <span>$(</span>find . -type f<span>)</span>
</span></span></code></pre></div><p>The result:</p><picture><source srcset="https://thevaluable.dev/images/2023/grep-guide/20_grep_exclude_files.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/grep-guide/20_grep_exclude_files.jpg" alt="Excluding files"/></picture><p>The command <code>$(find . -type f)</code> output every file (excluding the directories) for grep to parse them; I wrote <a href="https://thevaluable.dev/find-cli-guide-examples/">another article about find</a> if you’re interested to know how it works.</p><p>Since we exclude any file beginning with <code>Make</code> here, grep will parse every file from our <a href="https://github.com/Phantas0s/the_valuable_dev_companion/tree/main/guide-grep" target="_blank" rel="noopener">companion project</a> except the Makefile.</p><h3 id="including-files">Including Files</h3><p>It’s great to exclude the files we don’t want to parse, but what about only including the files we need? You might have guessed it, we can use the option <code>--include</code> to do so:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>grep <span>&#39;div&#39;</span> --include<span>=</span><span>&#39;*.css&#39;</span> <span>$(</span>find . -type f<span>)</span>
</span></span></code></pre></div><p>The usual output:</p><picture><source srcset="https://thevaluable.dev/images/2023/grep-guide/21_grep_including_files.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/grep-guide/21_grep_including_files.jpg" alt="Including files"/></picture><p>Remember: if you want to <span>h</span>ide the filenames in the output, you can use the option <code>-h</code>.</p><h3 id="summary-including-and-excluding-files">Summary: Including and Excluding Files</h3><p>It was a short section, but it still deserves its own recap:</p><table><tbody><tr><th>Option</th><th>Description</th></tr><tr><td><code>--exclude &lt;value&gt;</code></td><td>Exclude the files <code>&lt;value&gt;</code>. Globs can be used here.</td></tr><tr><td><code>--include &lt;value&gt;</code></td><td>Include the files <code>&lt;value&gt;</code>. Globs can be used here.</td></tr></tbody></table><h2 id="piping-grep-a-small-overview">Piping grep: A Small Overview</h2><p>This part is not really interesting if you’re used to pipe CLIs in your shell, but I include it here in case you don’t really know how to pipe another CLI output to grep’s input.</p><p>Instead of giving files to grep to parse them, we can directly give the output of a command to grep’s input. The goal: filtering the output of your first command with grep.</p><p>For example, if I run <code>ps</code> (a CLI to output the processes running), I get this:</p><div><pre tabindex="0"><code data-lang="text"><span><span>    PID TTY          TIME CMD
</span></span><span><span>   2026 pts/9    00:11:36 nvim
</span></span><span><span>   2431 pts/11   00:01:11 hugo
</span></span><span><span>   2584 pts/10   00:00:01 tmuxp
</span></span><span><span>   3009 pts/18   00:00:01 nvim
</span></span><span><span>   3241 pts/20   00:00:17 taskell
</span></span><span><span>   3484 pts/22   00:00:11 taskell
</span></span><span><span>   3663 pts/21   00:00:00 nvim
</span></span></code></pre></div><p>What if I only want the lines matching the <code>nvim</code> pattern? We can run the following then:</p><p>The character <code>|</code> is a pipe: it gives whatever output from the left command to the input of the right command. It means that we pipe here the output of <code>ps -a</code> to the input of <code>grep &#39;nvim&#39;</code>.</p><p>Here’s the result:</p><div><pre tabindex="0"><code data-lang="text"><span><span>   2026 pts/9    00:11:36 nvim
</span></span><span><span>   3009 pts/18   00:00:01 nvim
</span></span><span><span>   3663 pts/21   00:00:00 nvim
</span></span></code></pre></div><h2 id="ripgrep-an-alternative-to-grep">ripgrep: An Alternative to grep</h2><p>As we saw throughout this article, grep is a very useful tool. But it’s also an old tool; it doesn’t really consider the other usual tools we use in a modern development workflow.</p><p>For example, most developers use Git nowadays to manage their projects. Yet, there is no easy way for grep to exclude the files ignored by Git (the filenames written in the <code>.gitignore</code> file).</p><p>To fix this problem and other shortcomings, there are many alternatives to grep available out there. The one I use most often is <code>ripgrep</code> (or <code>rg</code>). It offers nice functionalities and improvement compared to grep:</p><ul><li>If no file is given, it parses all files recursively; useful in case you don’t have globs like <code>**</code> in your shell, or if you don’t want to use another CLI (like find). You can also specify the depth of the recursion easily.</li><li>It’s faster than grep. If your grep commands take too much time, switching to ripgrep will often improve the performances significantly.</li><li>It filters automatically the files specified in some specific ignore files (like <code>.gitignore</code>, or even <code>.rgignore</code> specific to ripgrep), making it easier to exclude the files you don’t care about.</li><li>It can do some string substitutions on the spot; no need to pipe grep to a more convoluted tool (like sed) to replace one string by another.</li><li>It can be directly configured via a configuration file without the need to create aliases.</li></ul><p>Appealing, isn’t it? That said, I still think that knowing how to use the OG grep is useful. It’s likely you won’t find the modern grep alternatives on remote servers or docker containers for example, where grep can be a life savior. Additionally, if you know how to use grep, you won’t have any difficulty to grab one of its alternative.</p><p>Indeed, if you’re used to grep, it will be easy for you to pick up ripgrep. To drive the point home, here are some equivalent commands using both grep and ripgrep. I would recommend you to play with them to get a feeling of the differences:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span># rg display the line numbers by default</span>
</span></span><span><span>grep -n <span>&#39;div&#39;</span> styles.css
</span></span><span><span>rg <span>&#39;div&#39;</span> styles.css
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="bash"><span><span><span># The -N option hide the line numbers</span>
</span></span><span><span>grep <span>&#39;div&#39;</span> styles.css
</span></span><span><span>rg -N <span>&#39;div&#39;</span> styles.css
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="bash"><span><span>grep -P <span>&#39;^d.*$&#39;</span> styles.css
</span></span><span><span>rg -P -N <span>&#39;^d.*$&#39;</span> styles.css
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="bash"><span><span>grep -v <span>&#39;div&#39;</span> styles.css
</span></span><span><span>rg -v -N <span>&#39;div&#39;</span> styles.css
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="bash"><span><span><span># By default, rg will add a heading for filenames instead of a prefix</span>
</span></span><span><span>grep <span>&#39;if&#39;</span> template/*
</span></span><span><span>rg -N --no-heading <span>&#39;if&#39;</span> template
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="bash"><span><span><span># By default, rg will parse every file recursively if none is given</span>
</span></span><span><span><span># rg also ignore every filename written in .gitignore or .rgignore</span>
</span></span><span><span>grep --exclude<span>=</span><span>&#34;</span><span>$(</span>cat .rgignore<span>)</span><span>&#34;</span> <span>&#39;div&#39;</span> <span>$(</span>find . -type f<span>)</span>
</span></span><span><span>rg -N --no-heading <span>&#39;div&#39;</span>
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="bash"><span><span>grep --exclude<span>=</span><span>&#34;</span><span>$(</span>cat .randomignorefile<span>)</span><span>&#34;</span> <span>&#39;div&#39;</span> <span>$(</span>find . -type f<span>)</span>
</span></span><span><span>rg -N --no-heading --no-ignore --ignore-file<span>=</span><span>&#39;.randomignorefile&#39;</span> <span>&#39;div&#39;</span>
</span></span></code></pre></div><p>For the last example, <code>--no-ignore</code> will not ignore the filenames written in the common ignore files (like <code>.gitignore</code> or <code>.rgignore</code>), but we add afterward the option <code>--ignore-file</code> to ignore everything written in the <code>.randomignorefile</code> (a file I made up).</p><h2 id="other-alternatives">Other Alternatives</h2><p>There are many other alternatives to grep. Here are two more which have slightly different usage:</p><table><tbody><tr><th>CLI</th><th>Description</th></tr><tr><td><a href="https://github.com/phiresky/ripgrep-all" target="_blank" rel="noopener">ripgrep-all</a></td><td>Similar to ripgrep, except that you can parse many types of files: PDF, ebooks, office documents…</td></tr><tr><td><a href="https://github.com/Genivia/ugrep" target="_blank" rel="noopener">ugrep</a></td><td>Very fast grep-like CLI, apparently even faster than ripgrep. It also offers a TUI to search in your files.</td></tr></tbody></table><p>If you know more alternative adding some unique spin to the grep experience, don’t hesitate to let a comment at the end of this article.</p><h2 id="we-need-to-grep-everything">We Need to grep Everything!</h2><p>If you prefer watching videos instead of reading this article, most (but not all) of the good tips provided here are also available on YouTube:</p><p><iframe src="https://www.youtube.com/embed/SEkdPKcws3s" allowfullscreen="" title="YouTube Video"></iframe></p><p>What did we see in this article?</p><ul><li>The general syntax of grep is <code>grep [options...] &#39;pattern&#39; [files...]</code>. The patterns are regexes.</li><li>You can create aliases to give some default options to grep: <code>alias grep=&#34;grep -P --color=auto&#34;</code> is a good example, to always have colors in your output and always use the PCRE engine for your regexes.</li><li>We can modify the output easily with some options: in<span>v</span>erting the matching, output <span>o</span>nly the pattern matched, and so on.</li><li>We can also modify the output regarding the display of filenames.</li><li>We can include or exclude some files to grep with <code>--include</code> and <code>--exclude</code>.</li><li>We can add some contexts with the options <code>-A</code>, <code>-B</code> and <code>-C</code>; that is, displaying the lines before and/or after the pattern matched.</li><li>There are many alternatives to grep, like ripgrep or ugrep for example.</li></ul><p>Don’t forget that there are multiple summaries in this article for you to quickly find the options you want when working with grep. Don’t worry if you can’t remember all of them for now; the more you’ll use them, the more you’ll memorize them.</p></section></div>
  </body>
</html>
