<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buttondown.email/krcah/archive/more-control-with-idempotency/">Original</a>
    <h1>More Control with Idempotency</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                    
                        
<p>Idempotency has become one of my favorite principles for designing systems. When programs are designed to be idempotent, I feel much more in control and know better what is going on. So let’s take a closer look into the idempotency by trying to design a simplified real-life idempotent program.</p>
<p>Our use-case here will be about the health monitoring of charge-points for electric vehicles. Let’s assume that our system is already able to detect alerts on such charge-points, and our task is to send emails to the charge-point owners notifying them about the detected alerts. (To make things simpler for now, let’s assume that there can be only one alert on a given charge-point during its whole lifetime. Later, we will also discuss how to approach multiple alerts). Now, let’s try to design such a program in an idempotent way. </p>
<h2>Our visual grammar for this example</h2>
<p>In the drawings below, we will operate with two things. First, we will have an alert for a given charge-point: </p>
<p><img alt="Screenshot 2022-03-09T17.18.png" src="https://buttondown.s3.amazonaws.com/images/c92c7701-be19-49d4-bbc1-84a9cb0ff345.png"/> </p>
<p>And second, we will have emails for charge-point owners:</p>
<p><img alt="Screenshot 2022-03-09T17.19.png" src="https://buttondown.s3.amazonaws.com/images/f8ed9d6c-d65a-4146-a06d-84aafae4e766.png"/> </p>
<h2>Back to idempotency: What is it?</h2>
<blockquote>
<p>A program is idempotent if when we run the program multiple times (on the same input), it will have the same effect as if we run it only once. </p>
</blockquote>
<p>How I like to think about idempotence is that we have some <em>desired state</em> (the input), and then we have <em>an actual state</em> and the purpose of the program is to <em>bring the actual state to the desired state</em>. Such a program is idempotent because: </p>
<ul>
<li>the first run will bring the actual state into the desired state,</li>
<li>the second run will do nothing because the actual state already <em>is</em> the desired state,</li>
<li>the third, fourth, etc runs will also do nothing.</li>
</ul>
<p>Let’s try now to apply this to the health-monitoring use-case. The two key questions that I tend to always ask myself are: What is the <em>desired state</em> and what is the <em>actual state</em>? I think that in our example:</p>
<ul>
<li>the desired state could be the list of emails that <em>should be</em> sent; </li>
<li>and the actual state could be the list of emails there <em>were</em> already sent.</li>
</ul>
<p>We don’t need to store the whole emails, I think we can get away with the list of charge-points IDs only. </p>
<p><img alt="Screenshot 2022-03-21T14.21.png" src="https://buttondown.s3.amazonaws.com/images/fc2ce556-0652-48da-9764-126294e545f3.png"/> </p>
<p>The goal of the program now is to bring the actual state—that is, emails that were already sent—into the desired state—that is, emails that should be sent. This can be accomplished by taking the difference between the two states and sending emails for that difference. </p>
<p>Let’s see how that will work:</p>
<h2>Run #1: With three new alerts, the program sends three emails</h2>
<p>Let’s say three alerts were detected. That means that three emails should be sent. However, as of yet, no emails were sent. The difference is the three emails that the program will send. </p>
<p><img alt="Screenshot 2022-03-21T14.22.png" src="https://buttondown.s3.amazonaws.com/images/238a335f-4fc7-4664-ab90-bcea6880def7.png"/> </p>
<h2>Run #2: No new alert, the program sends no emails</h2>
<p>We run the program again and no new alert has been detected. That means that three emails should be sent, and three emails were already sent. The difference is empty, so the program is not going to send any emails. </p>
<p><img alt="Screenshot 2022-03-21T14.23.png" src="https://buttondown.s3.amazonaws.com/images/6b9af736-4f08-4fb4-9d05-84dd295798cc.png"/> </p>
<h2>Run #3: Let’s change the input: a new alert is detected</h2>
<p>Now let’s say we run the program again and a new alert has been detected. At this point, four emails should be sent, and three emails were already sent. The difference is the one new email that the program will send. </p>
<p><img alt="Screenshot 2022-03-21T14.23.png" src="https://buttondown.s3.amazonaws.com/images/6c9e4d34-a84f-492d-889c-5480e6ef2a7e.png"/> </p>
<h2>Support for multiple alerts</h2>
<p>Now, how can we add support for multiple alerts per one charge-point? One option would be to start considering when did the alert start, and when did the alert stop. Let’s call such an interval the <em>alert interval</em>.  </p>
<p>To define the desired state, we need to first clarify the required business logic: should the charge-point owner be notified of <em>all</em> the alerts or only of <em>the latest alert</em>? Let’s say we’d like to notify the owner of <em>all</em> the alerts. To support multiple alerts, we might need a different desired state: the desired state could be now a list of alerts <em>with their time intervals</em> that the owner should be emailed about. The actual state could be a list of alerts <em>with their time intervals</em> that the owner was already emailed about. The difference between the two states is the list of alerts that the program can transform into emails and send to the charge-point owner. </p>
<p>Now, imagine that we have such logic implemented and the program has been running in production. After months, however, we realize that it would indeed be better—from the business perspective—to send only the <em>latest alert</em>, not all of them. With such an idempotent design, it could be straightforward to update the system for that requirement: we’d quite possibly need to update how the desired state is calculated, and probably slightly touch the actual state and the difference calculation to accommodate for the alert intervals. However, all in all, supporting multiple alerts would seem like a straightforward incremental improvement, as opposed to a BIG SYSTEM CHANGE. </p>
<h2>Pros &amp; Cons</h2>
<p>Let’s look into pros &amp; cons of such an idempotent design. First, the pros:</p>
<ul>
<li>full control over the frequency of sending emails,</li>
<li>resilient towards email service disruptions,</li>
<li>easier auditing and bug-fixing when something is not going according to plan,</li>
<li>flexibility to change the logic for the desired state later and re-run the whole program from the very beginning,</li>
<li>the dev experience might feel more ergonomic, </li>
<li>idempotent concepts might feel easier to think and reason with (idempotency might be considered to fall into the same bucket of mental models as immutability, and declarative and functional code style )</li>
</ul>
<p>For the cons:</p>
<ul>
<li>The key downside that I’m aware of is that calculating the difference between the desired state and the actual state can take long. I’ve encountered this issue when calculating the difference using Postgres cross-joins over two big tables. We had to optimize the calculation by storing the timestamp of the last execution and then computing the difference using that timestamp.</li>
<li>Another possible downside is that <em>sending an email</em> and <em>recording that the email was sent</em> would ideally need to happen atomically. That is, if we send an email and fail to record that fact, we might end up with an inconsistent actual state that could lead to, for example, emails being sent twice. Pragmatically speaking, this hasn’t been an issue for non-critical low-load business-line software that I’ve worked on. However, fo high-load or critical systems, this could be a potential downside that one needs to be aware of. </li>
</ul>
<p>In general, I think that the pros outweigh the cons by a large margin for idemoptency, at least for use-cases that I have encountered. For those reasons, I’ve come to treat idempotency as a fantastic tool that I try to apply by default whenever I can.  </p>
<h2>Further reading</h2>
<ul>
<li><a href="https://arslan.io/2019/07/03/how-to-write-idempotent-bash-scripts/" target="_blank">How to write idempotent Bash scripts by Fatih Arslan</a></li>
<li><a href="https://ericlathrop.com/2021/04/idempotence-now-prevents-pain-later/" target="_blank">Idempotence Now Prevents Pain Later by Eric Lathrop</a>, and also the related <a href="https://news.ycombinator.com/item?id=26726449" target="_blank">HN discussion</a></li>
</ul>
<p><em>Thanks to Peter Nikoden, Michael Anderson, and Daan Debie for reading the draft of this.</em></p>
                    
                
            </div></div>
  </body>
</html>
