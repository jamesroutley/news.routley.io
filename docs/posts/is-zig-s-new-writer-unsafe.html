<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.openmymind.net/Is-Zigs-New-Io-Unsafe/">Original</a>
    <h1>Is Zig&#39;s new writer unsafe?</h1>
    
    <div id="readability-page-1" class="page"><article>
  
  
  
<p>If we wanted to write a function that takes one of Zig&#39;s new <code>*std.Io.Reader</code> and write it to stdout, we might start with something like:</p>

<pre><code><span>fn</span> <span>output</span><span>(</span>r<span>:</span> <span><span>*</span>std<span>.</span>Io<span>.</span>Reader</span><span>)</span> <span><span>!</span><span>void</span></span> <span>{</span>
    <span>const</span> stdout <span>=</span> std<span>.</span>fs<span>.</span>File<span>.</span><span>stdout</span><span>(</span><span>)</span><span>;</span>
    <span>var</span> buffer<span>:</span> <span><span>[</span><span>?</span><span>?</span><span>?</span><span>]</span><span>u8</span></span> <span>=</span> <span>undefined</span><span>;</span>
    <span>var</span> writer <span>=</span> stdout<span>.</span><span>writer</span><span>(</span><span>&amp;</span>buffer<span>)</span><span>;</span>
    _ <span>=</span> <span>try</span> r<span>.</span><span>stream</span><span>(</span><span>&amp;</span>writer<span>.</span>interface<span>,</span> <span>.</span>unlimited<span>)</span><span>;</span>
    <span>try</span> writer<span>.</span>interface<span>.</span><span>flush</span><span>(</span><span>)</span><span>;</span>
<span>}</span></code></pre>

<p>But what should the size of <code>buffer</code> be? If this was a one-and-done, maybe we&#39;d leave it empty or put some seemingly sensible default, like 1K or 4K. If it was a mission critical piece of code, maybe we&#39;d benchmark it or make it platform dependent.</p>

<p>But unless I&#39;m missing something, whatever size we use, this function&#39;s behavior is undefined. You see, the issue is that readers can require a specific buffer sizes on a writer (and writers can require a specific buffer size on a reader). For example, this code, with a small buffer of 64, fails an assertion in debug mode, and falls into an endless loop in release mode:</p>

<pre><code><span>const</span> std <span>=</span> <span>@import</span><span>(</span><span>&#34;std&#34;</span><span>)</span><span>;</span>

<span>pub</span> <span>fn</span> <span>main</span><span>(</span><span>)</span> <span><span>!</span><span>void</span></span> <span>{</span>
    <span>var</span> fixed <span>=</span> std<span>.</span>Io<span>.</span>Reader<span>.</span><span>fixed</span><span>(</span><span>&amp;</span><span>.</span><span>{</span>
        <span>40</span><span>,</span> <span>181</span><span>,</span> <span>47</span><span>,</span> <span>253</span><span>,</span> <span>36</span><span>,</span> <span>110</span><span>,</span> <span>149</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>88</span><span>,</span> <span>111</span><span>,</span> <span>118</span><span>,</span> <span>101</span><span>,</span> <span>114</span><span>,</span> <span>32</span><span>,</span> <span>57</span><span>,</span>
        <span>48</span><span>,</span> <span>48</span><span>,</span> <span>48</span><span>,</span> <span>33</span><span>,</span> <span>10</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>,</span> <span>192</span><span>,</span> <span>105</span><span>,</span> <span>241</span><span>,</span> <span>2</span><span>,</span> <span>170</span><span>,</span> <span>69</span><span>,</span> <span>248</span><span>,</span> <span>150</span>
    <span>}</span><span>)</span><span>;</span>

    <span>var</span> decompressor <span>=</span> std<span>.</span>compress<span>.</span>zstd<span>.</span>Decompress<span>.</span><span>init</span><span>(</span><span>&amp;</span>fixed<span>,</span> <span>&amp;</span><span>.</span><span>{</span><span>}</span><span>,</span> <span>.</span><span>{</span><span>}</span><span>)</span><span>;</span>
    <span>try</span> <span>output</span><span>(</span><span>&amp;</span>decompressor<span>.</span>reader<span>)</span><span>;</span>
<span>}</span>

<span>fn</span> <span>output</span><span>(</span>r<span>:</span> <span><span>*</span>std<span>.</span>Io<span>.</span>Reader</span><span>)</span> <span><span>!</span><span>void</span></span> <span>{</span>
    <span>const</span> stdout <span>=</span> std<span>.</span>fs<span>.</span>File<span>.</span><span>stdout</span><span>(</span><span>)</span><span>;</span>
    <span>var</span> buffer<span>:</span> <span><span>[</span><span>64</span><span>]</span><span>u8</span></span> <span>=</span> <span>undefined</span><span>;</span>
    <span>var</span> writer <span>=</span> stdout<span>.</span><span>writer</span><span>(</span><span>&amp;</span>buffer<span>)</span><span>;</span>
    _ <span>=</span> <span>try</span> r<span>.</span><span>stream</span><span>(</span><span>&amp;</span>writer<span>.</span>interface<span>,</span> <span>.</span>unlimited<span>)</span><span>;</span>
    <span>try</span> writer<span>.</span>interface<span>.</span><span>flush</span><span>(</span><span>)</span><span>;</span>
<span>}</span></code></pre>

<p>Some might argue that this is a documentation challenge. It&#39;s true that the documentation for <code>zstd.Decompress</code> mentions what a <code>Writer</code>&#39;s buffer must be. <strong>But this is not a documentation problem</strong>. There are legitimate scenarios where the nature of a <code>Reader</code> is unknown (or, at least, difficult to figure out). A type of a reader could be conditional, say based on an HTTP response header. A library developer might take a <code>Reader</code> as an input and present their own <code>Reader</code> as an output - what buffer requirement should they document?</p>

<p>Worse is that the failure can be conditional on the input. For example, if we change our source to:</p>

<pre><code><span>var</span> fixed <span>=</span> std<span>.</span>Io<span>.</span>Reader<span>.</span><span>fixed</span><span>(</span><span>&amp;</span><span>.</span><span>{</span>
    <span>40</span><span>,</span> <span>181</span><span>,</span> <span>47</span><span>,</span> <span>253</span><span>,</span> <span>36</span><span>,</span> <span>11</span><span>,</span> <span>89</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>111</span><span>,</span> <span>118</span><span>,</span> <span>101</span><span>,</span> <span>114</span><span>,</span> <span>32</span><span>,</span> <span>57</span><span>,</span>
    <span>48</span><span>,</span> <span>48</span><span>,</span> <span>48</span><span>,</span> <span>33</span><span>,</span> <span>10</span><span>,</span> <span>112</span><span>,</span> <span>149</span><span>,</span> <span>178</span><span>,</span> <span>212</span><span>,</span>
<span>}</span><span>)</span><span>;</span></code></pre>

<p>Everything works, making this misconfiguration particularly hard to catch early.</p>

<p>To me this seems almost impossible - like, I must be doing something wrong. And if I am, I&#39;m sorry. But, if I&#39;m not, this is a problem right?</p>

</article></div>
  </body>
</html>
