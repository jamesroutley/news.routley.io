<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://the.scapegoat.dev/llms-are-kryptonite-for-legacy-code-but-dont-let-them-touch-it/">Original</a>
    <h1>LLMs Are Kryptonite for Legacy Code (But Don&#39;t Let Them Touch It)</h1>
    
    <div id="readability-page-1" class="page"><div>
    

    
        
    

    
        

        <p>
            <i>
                <time datetime="2025-04-09T02:07Z">
                    09 Apr, 2025
                </time>
            </i>
        </p>
    

    <p>There&#39;s a myth floating around that large language models (LLMs) like sonnet or gpt are mainly good for greenfield, one-off projects. It&#39;s true they&#39;re fantastic for brainstorming new ideas, prototyping quickly, or scaffolding out fresh codebases. But what&#39;s surprising‚Äîand actually much more exciting‚Äîis how effectively you can deploy them against legacy code.</p>
<p>I&#39;ve spent a fair bit of my life deep in legacy code, as a freelancer but also just out of curiosity. When ChatGPT came out, I was deep in legacy WordPress/WooCommerce code, including the joyous experience of building new admin views or migrating vast amounts of tangled data into a clean data lake using dbt. Along the way, I&#39;ve developed some strategies to leverage LLMs as &#34;software archeologists,&#34; making the task of untangling old code less painful.</p>
<p>Here&#39;s the practical workflow that works wonders:</p>
<h3 id="step-1-let-the-llm-document-everything">Step 1: Let the LLM Document Everything</h3><p>Today, we&#39;ve got impressive agentic editors and powerful models available. Point them at your codebase, and they quickly map out the landscape‚Äîwhere functions are defined, what frameworks and tools are in play, and even which versions you&#39;re running. It&#39;s frankly remarkable. If you want to try it, just ask &#34;what is this?&#34; in an empty cursor chat.</p>
<p>Better yet, you don&#39;t have to rely solely on the initial output. Chatting with a model allows you to dig deeper, ask pointed questions, and then synthesize that interaction into coherent, human-readable documentation with a clear purpose.</p>
<h3 id="step-2-instrument-and-log-everything">Step 2: Instrument and Log Everything</h3><p>Logs are your best friends. If you&#39;re dealing with legacy systems, robust logging and instrumentation are mandatory. LLMs are great at &#34;transforming language&#34;, and thus can easily replace missing or messy logs. You want to go for consistency and coverage.</p>
<p>Once you have structured logs, LLMs can digest them easily, turning raw data into something actionable. Because they are great at matching patterns in text, they can be used to correlate an error trace to the code, quickly pinpoint which function returned a problematic value, or just create scripts to reproduce the issue. For example, it is now quite easy to create tailored fuzzing scaffolds, something that used to take me a huge amount of effort.</p>
<h3 id="step-3-generate-accurate-mocks-from-your-logs">Step 3: Generate Accurate Mocks from Your Logs</h3><p>Mocks built from real logs usually are closer to  reality than the original specs or documentation. Mocks can of course be built for improved testing, but it is also straightforward to tweak them intentionally to expose subtle edge cases and uncover behaviors that standard unit tests or integration tests might miss. </p>
<h3 id="step-4-let-logs-inform-your-api-and-ui-tools">Step 4: Let Logs Inform Your API and UI Tools</h3><p>Instead of reverse-engineering legacy APIs from spaghetti code, use recorded requests and responses as your baseline. These logged interactions are the ground truth of how your system actually behaves, and you can directly turn these logs into API clients, admin dashboards, or support UIs.</p>
<h3 id="step-5-use-logs-to-create-cleaner-apis-and-database-views">Step 5: Use Logs to Create Cleaner APIs and Database Views</h3><p>You can use logged API interactions as a blueprint for designing newer, cleaner APIs. Similarly, database views built on top of old, dirty schemas can isolate your new code from the chaos below. This allows you to gradually clean up your data and APIs, while potentially keeping other systems to use the old schema.</p>
<h3 id="step-6-migrate-and-clean-data-with-log-driven-scripts">Step 6: Migrate and Clean Data with Log-Driven Scripts</h3><p>When it&#39;s time for the big data migration, logs again come in handy. They&#39;re your reliable guide for creating migration scripts, ensuring that data cleanup is precise and reflective of your actual system state.</p>
<h3 id="why-never-let-llms-directly-touch-legacy-code">Why Never Let LLMs Directly Touch Legacy Code?</h3><p>Legacy code, especially the spaghetti variety, has hidden dependencies, misleading naming conventions, and subtle behaviors embedded deeply. LLMs are powerful pattern-matchers but can easily be tripped up by inconsistencies or seemingly trivial naming issues. Trust me: subtle bugs introduced by an overeager LLM can become nightmarish to debug.</p>
<p>The solution? Use LLMs strategically, as guides or analysts‚Äînot editors. Let them help you deeply understand the existing system until you replace it piece-by-piece with something clean, well-tested, and sane.</p>
<h3 id="bonus-the-joy-of-software-archeology">Bonus: The Joy of Software Archeology</h3><p>One of the coolest roles I&#39;ve discovered for LLMs is as software archeologists. Feed them terse git commit histories or messy design docs, and they&#39;ll piece together surprisingly coherent narratives around past architectural decisions or the evolution of certain features. It&#39;s a bit magical, honestly.</p>
<h3 id="final-thoughts">Final Thoughts</h3><p>Leveraging LLMs in legacy code doesn&#39;t mean giving them the keys to your production system. It means using them to amplify your understanding, documentation, mocks, and ultimately your confidence.</p>
<p>So next time you&#39;re drowning in legacy chaos, remember: the kryptonite is already at hand‚Äîjust don&#39;t let it touch your actual legacy code.</p>
<hr/>
<p>üíª ü§ñ ‚ú® Interested in coding with AI and LLMs? Follow me <a href="https://twitter.com/ProgramWithAI">@ProgramWithAI</a>.</p>
<p>üß† ‚ù§Ô∏è üñ• Connect with me on Mastodon <a href="https://hachyderm.io/@mnl">@mnl@hachyderm.io</a> or check my writing on <a href="https://dev.to/wesen">dev.to/wesen</a>.</p>
<p>For more detailed notes and insights, visit my üß† <a href="https://publish.obsidian.md/manuel">Obsidian vault</a>.</p>
<p>üéµ Explore my music projects as <a href="https://slonomusic.bandcamp.com">slono</a>.</p>
<p>Subscribe via üíå <a href="https://the.scapegoat.dev/feed/?type=rss">RSS</a> to keep updated.</p>


    

    
        

        
            


        
    


  </div></div>
  </body>
</html>
