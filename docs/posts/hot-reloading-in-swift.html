<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.merowing.info/hot-reloading-in-swift/">Original</a>
    <h1>Hot Reloading in Swift</h1>
    
    <div id="readability-page-1" class="page"><div>
                        <p>The year is 2040, and our newest MacBook M30X processors can compile large Swift projects perceivably instantaneously, sounds pretty amazing, right?</p><p>Except, compiling the codebase is just part of our iteration cycle. Other ones include: - restarting it (or deploying it to the device) - navigating to the previous location where you were in the App - re-producing the data you need.</p><p>It doesnâ€™t sound too bad if you have to do it once. But what if you are like me and, on a typical day, do between <strong><strong>200 - 500</strong></strong> iterations on the codebase? It adds up.</p><p>There is a better way, embraced by other platforms and achievable in the Swift/iOS ecosystem. <strong><strong>Iâ€™ve used it for over a decade.</strong></strong></p><p><strong><strong>Do you want to save up to 10h work per week, starting today?</strong></strong></p><h3 id="hot-reloading">Hot Reloading</h3><p>Hot reloading is about getting rid of compiling your whole application and avoiding deploy/restart cycles as much as possible while allowing you to edit your running application code and see changes reflected immediately.</p><p>Causing your workflow to be more productive by reducing the time you spend waiting for apps to rebuild, restart, re-navigate to the previous location where you were in the App itself, and re-produce the data you need.</p><p>This process improvement can save you literally hours of development time, <strong><strong>each day</strong></strong>. I tracked my work for over a month, and for me, it was between 1-2h <strong><strong>each day</strong></strong>.</p><p><strong><strong>Frankly, If saving up to 10h of development time per week doesnâ€™t convince you to give this a try, I donâ€™t think anything will.</strong></strong></p><h3 id="what-other-platforms-are-doing">What other platforms are doing?</h3><p>If you only used Apple platforms, you can be surprised to learn how many platforms have embraced hot-reloading decades ago. Whether you write Node or any other JS framework, there is a setup for you to use hot-reloading. <code>Go</code> also offers hot-reloading (This blog leverages that feature).</p><p>Another example is Googleâ€™s Flutter architecture, designed from the ground up to work with hot-reloading. If you talk to engineers working on Flutter, being able to live code their applications is one of the things they love the most about the Flutter developer experience. I adored it when I wrote a Spelling Bee game for The New York Times.</p><p>Microsoft recently <a href="https://devblogs.microsoft.com/visualstudio/visual-studio-2022-now-available/">launched Visual Studio 2022</a> and offers hot-reloading for both <code>.NET</code> and standard <code>C++</code> applications. Microsoft has been killing it ðŸ‘Œ over the last decade regarding dev tooling and experience, so it is not a big surprise.</p><h3 id="what-about-the-apple-ecosystem">What about the Apple ecosystem?</h3><p>Back in 2014, when it launched, many people were in awe of Swift Playgrounds since they allowed us to quickly iterate and see the results of our code, except they didnâ€™t work very well because it crashed, hanged, etc. didnâ€™t support the entire iPad environment.</p><p>Shortly after they were released, I launched an open-source project called Objective-C Playgrounds that worked much faster and more reliably than official playgrounds. My idea was to design an architecture/workflow that leveraged <a href="https://github.com/DyCI/dyci-main">DyCI</a> code injection tool Iâ€™ve been using for a few years already made by <a href="https://twitter.com/TT_Kilew">Paul</a>.</p><p>Eight years have passed since Swift Playgrounds are still here, and they got better, but are they reliable? Are people using them to drive their development?</p><blockquote><em>In my experience: not really. Playgrounds tend not to be very reliable or applicable in larger projects.</em></blockquote><p>SwiftUI came along, and itâ€™s a fantastic piece of technology (<strong><strong>albeit still buggy</strong></strong>), it introduced the idea of Swift Previews that are very similar to Playgrounds, are they any good?</p><p>Similar story, itâ€™s great when it works, but it works unreliably in bigger projects and tends to break more times than they work. They donâ€™t offer you the ability to debug the code if you have any errors correctly, and as such, the adoption has been limited.</p><h3 id="do-we-need-to-wait-for-apple">Do we need to wait for Apple?</h3><p>If you have followed me for a while, you already know the answer, <strong><strong>ABSOLUTELY NO</strong></strong>. After all, I made a career out of building things that vanilla Apple solutions donâ€™t solve: from language extensions like <a href="https://github.com/krzysztofzablocki/Sourcery">Sourcery</a>, Xcode improvements like <a href="http://merowing.info/sourcery-pro/">Sourcery Pro</a> through <a href="https://github.com/krzysztofzablocki/LifetimeTracker">LifetimeTracker</a> and <a href="https://github.com/krzysztofzablocki">many others</a> open-source tools.</p><p>We can leverage the same approach Iâ€™ve initially used in my 2014 Playgrounds. Iâ€™ve been leveraging it for <strong><strong>over a decade</strong></strong> and Iâ€™ve used it with great success in tens of Swift Projects!</p><p>Many years ago, I switched from using <a href="https://github.com/DyCI/dyci-main">DyCI</a> to <a href="https://github.com/johnno1962/InjectionIII">InjectionForXcode</a>, which works even better by leveraging LLVM inter-op rather than any swizzling. Itâ€™s an entirely free, open-source tool that you run in your menu bar, and it was created by the prolific engineer <a href="https://twitter.com/Injection4Xcode">John Holdsworth</a>. You should <a href="http://books.apple.com/us/book/id1551005489">check out his book Swift Secrets</a>.</p><p>I recognized that <a href="https://github.com/krzysztofzablocki/Playgrounds">Playgrounds</a> approach might have been too heavy-handed, so today, Iâ€™m open-sourcing. A very focused micro-library called <a href="https://github.com/krzysztofzablocki/Inject">Inject</a> that, when paired with <a href="https://github.com/johnno1962/InjectionIII">InjectionForXcode</a>, will make your Apple development much more efficient and enjoyable!</p><p>But donâ€™t trust just my word for it. Look at the feedback from Alexandra and Nate, who were already highly proficient before I even introduced this workflow into <a href="https://thebrowser.company/">The Browser Company</a> setup, which makes it even more impressive.</p><figure><img src="https://www.merowing.info/content/images/2022/07/Feedback.png" alt="" loading="lazy" width="857" height="108" srcset="https://www.merowing.info/content/images/size/w600/2022/07/Feedback.png 600w, https://www.merowing.info/content/images/2022/07/Feedback.png 857w" sizes="(min-width: 720px) 720px"/></figure><h2 id="inject">Inject</h2><p>This small library is entirely universal, and whether you work with <code>UIKit,</code> <code>AppKit,</code> or <code>SwiftUI,</code> you will be able to leverage it.</p><p>You donâ€™t need to add conditional compilation or remove <code>Inject</code> code from your applications for production. It turns into no-op inlined code that will get stripped by the compiling process in non-debug builds. You can integrate it once per view and keep using it for years.</p><p>Refer to <a href="https://github.com/krzysztofzablocki/Inject">GitHub repo</a> for instructions on configuring your project. Now letâ€™s look at the workflow options you have.</p><h3 id="workflows">Workflows</h3><h4 id="swiftui"><strong><strong>SwiftUI</strong></strong></h4><p>There are <strong><strong>only two lines</strong></strong> required to make any SwiftUI enabled for live programming, and the moment you do that, you have a faster workflow than you did with Swift Previews while being able to use actual production data.</p><p>Hereâ€™s an example of my <a href="http://merowing.info/sourcery-pro/">Sourcery Pro</a> app loaded with all my actual data and logic, allowing me to quickly iterate on the whole app design instantaneous without any restarts, reloads, or anything like that.</p><p>Just look how fast this development workflow is :mind-blown: and tell me youâ€™d rather wait for Xcode re-builds and re-deployment each time Iâ€™m touching the code.</p><blockquote>These two lines donâ€™t need to be removed since they are no-op in Release builds. So once added, they can be kept in your repo forever.</blockquote><h4 id="uikit-appkit"><strong><strong>UIKit / AppKit</strong></strong></h4><p>We need a way to clean up the state between code injection phases for standard imperative UI frameworks.</p><p>I create the concept of <strong><strong>Hosts</strong></strong> that work well in that context. There are 2:</p><pre><code>- Inject.ViewHost
- Inject.ViewControllerHost
</code></pre><p>How do we integrate this? We wrap the class we want to iterate on at the parent level, so we donâ€™t modify the type we want to inject but change the parent call site.</p><p>E.g., If you have a <code>SplitViewController</code> that creates <code>PaneA</code> and <code>PaneB,</code>and you want to iterate on layout/logic code in <code>PaneA,</code> you modify the call site in <code>SplitViewController</code>:</p><pre><code>paneA = Inject.ViewHost(
  PaneAView(whatever: arguments, you: want)
)
</code></pre><p>That is all the changes you need to make. Injection now allows you to change anything in <code>PaneAView</code> except its initializer API. The changes will be immediately reflected in your App.</p><hr/><p>A more specific example?</p><ul><li>I downloaded <a href="https://github.com/dkhamsing/covid19.swift">Covid19 App</a></li><li>Added <code>-Xlinker -interposable</code> to <code>Other Linker Flags</code></li><li>Swapped a single line <code>Covid19TabController.swift:L63</code> line</li></ul><p>from:</p><pre><code>let vc = TwitterViewController(title: Tab.twitter.name, usernames: Twitter.content)
</code></pre><p>to:</p><pre><code>let vc = Inject.ViewControllerHost(TwitterViewController(title: Tab.twitter.name, usernames: Twitter.content))
</code></pre><p>And now, I can iterate over the controller design without any restarts of the App:</p><h4 id="how-does-this-work-underneath">How does this work underneath?</h4><p>Hosts leverage auto-closure, so each time you inject code, we create a new instance of your type with the same arguments as initially, allowing you to iterate on any code, memory layout, and everything else. The only thing that you canâ€™t change is your initializer API.</p><blockquote><em>Host changes canâ€™t be fully inlined, so those classes are removed in Release builds. The easiest way is to make a separate commit that swaps this one-liner and then remove it at the end of your workflow.</em></blockquote><h3 id="what-about-logic-injection">What about logic injection?</h3><p>Standard architectures like MVVM / MVC get a free logic injection, recompile your classes, and when the methods re-execute, youâ€™ll already be using new code.</p><p>If, like me, you love <a href="https://github.com/pointfreeco/swift-composable-architecture">PointFree Composable Architecture</a>, youâ€™d probably want to inject reducer code. Vanilla TCA doesnâ€™t allow it because reducer code is a free function that isnâ€™t as straightforward to replace with injection, but [our fork at The Browser Company] supports it.</p><p>When I initially started consulting with TBC, the first thing I wanted was to integrate <code>Inject</code> and <code>XcodeInjection</code> into our workflow. The company management was very supportive.</p><p>I was able to get <a href="https://twitter.com/Injection4Xcode">John Holdsworth</a> to consult with <a href="https://thebrowser.company/">us</a> to help improve the tool a bit and built-in injection support for TCA architecture. <a href="https://twitter.com/Injection4Xcode">John</a> blew our mind with how fast he could execute the idea and deliver stable support for reducer injection. It works very reliably.</p><p>If you switch to <a href="https://github.com/thebrowsercompany/swift-composable-architecture/tree/develop">our fork of TCA</a> (which we keep up-to-date), you can leverage <code>Inject</code> across both UI and TCA layers.</p><h3 id="how-reliable-is-it">How reliable is it?</h3><p>Nothing is perfect, but <strong><strong>Iâ€™ve been using it for over a decade now</strong></strong>. Itâ€™s far more reliable than Apple tech (Playgrounds / Previews).</p><p>If you invest time into learning it, it will save you and your team thousands of hours!</p><!--kg-card-begin: html--><!--kg-card-end: html-->
                    </div></div>
  </body>
</html>
