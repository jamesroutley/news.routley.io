<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://frereit.de/aes_gcm/">Original</a>
    <h1>AES-GCM and breaking it on nonce reuse</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="an-overview-of-this-article-tldr">An overview of this article (TL;DR)</h2><p>TL;DR: AES-GCM is great, as long as every nonce (mnemonic: <strong>n</strong>umber used <strong>once</strong>) is truly unique. Once a nonce is reused, AES-GCM completely falls apart.</p><p>If you’ve ever worked with AES-GCM, you may have heard that reusing a nonce can lead to catastrophic security failures. In this post, we will look at how exactly all security guarantees of AES-GCM can be broken when a nonce is reused even once.</p><p>First, we’ll quickly go over AES, then explain AES-GCM in detail. We’ll then derive some formulas for the AES-GCM authentication tags and see how we can authenticate any message we want as soon as a nonce is reused.</p><p>This post will be somewhat math heavy, especially as we get to the nonce reuse attack. I’ll try my best to explain any concepts not covered by high-school math, and I’ll skip over any details of the algorithms, as these are best understood by reading the original papers.</p><h2 id="aes">AES</h2><p>If you’re reading this, chances are you know what <abbr title="Advanced Encryption Standard">AES</abbr> is. It is the most widely used symmetric encryption algorithm and is almost always the symmetric cipher used when communicating over HTTPS.</p><p>AES is a block cipher, which means it encrypts and decrypts data in fixed-size blocks. The block size for AES is 128 bits, which is 16 bytes. This means that given a key, the AES algorithm can be used to transform a 128-bit block of data into another 128-bit block of data, and back again. We arbitrarily call this process encryption and decryption, respectively. There’s no intrinsic property of AES that assigns one direction to encryption and the other to decryption. It is important to understand that AES is a bijective function, meaning <em>any</em> 128-bit block of data can be encrypted into a 128-bit block of data, and that <em>any</em> 128-bit block of data is a valid ciphertext that can be decrypted again. This is a fundamental property of block ciphers and important to understand.</p><p>Because every single possible block of 128-bit data can be decrypted using AES, it is absolutely incorrect to assume that just because you <em>can</em> decrypt some ciphertext, that it was indeed encrypted using the key you have. Anyone “in the middle” of a transmission can just replace the ciphertext, even if they don’t have the key, and AES won’t tell you that that’s happened.</p><p>There are three key sizes you can choose from when using AES: 128, 192, and 256. The key size changes some internal parameters of the algorithm, but the basic structure is the same. In this blog post, we will only be considering AES-128 but the same principles apply to the other key sizes as well, and for that matter, to any block cipher.</p><figure><img loading="lazy" src="https://frereit.de/img/aes/aes-block-cipher.svg" alt="AES is a bijective function parameterize by a key" data-ffwidth="51%" id="aes-block-cipher"/><figcaption>AES is a bijective function parameterized by a key</figcaption></figure><p>It is important to understand that AES-128 is just that, a cipher that encrypts and decrypts a single 128-bit block of data. AES does not specify how to encrypt multiple blocks of data using a single key, nor does it authenticate the data. It is a simple bijective function parameterized by a key, nothing more, nothing less.</p><p>You can play with the following widget to see how AES-128 works. The widget allows you to encrypt and decrypt a single block of data using a key of your choice.</p><p>In summary, we can treat AES-128 as a simple black box that encrypts and decrypts 128-bit blocks of data using a key. It is a building block that can be used to build more complex cryptographic systems, but it is not a complete cryptographic system in itself.</p><h2 id="gcm">GCM</h2><p>When using a block cipher, we want to be able to encrypt arbitrary amounts of data, and we want to ensure that the encrypted data cannot be tampered with. This is where modes of operation come into play. A mode of operation is a way to use a block cipher to encrypt and authenticate data. There are many different modes of operation, but in this post, we will focus on the Galois/Counter Mode, or GCM for short.</p><p>GCM is a method for authenticated encryption with associated data (AEAD). “Authenticated encryption” means that the mode of operation allows us to validate that a given ciphertext was indeed generated using the secret key, and that it has not been modified. This is called “authenticating” the ciphertext and is essential for secure communication. Without it, a bad actor could modify the ciphertext and the recipient would not be able to detect it, leading to garbled plaintext in the best case, and a huge security issue in the worst case.</p><p>The second part, “with associated data”, means that we can also authenticate additional data that is not encrypted. This is almost a byproduct of the way GCM works, but it is a very useful feature. For example, when sending a message, we might want to encrypt the message but keep the sender in plaintext. Think of a letter you’re mailing, where the contents are “protected” but the sender is plainly visible. By using AES-GCM, we are able to authenticate not only the ciphertext but also the sender so that the recipient can be sure that the message was indeed sent by the sender and that it is intended for them, even if the sender is not part of the ciphertext.</p><p>In this post, we’ll look at the two parts of GCM (encryption and authentication) seperately. We’ll start by seeing how encryption works with AES-GCM, where the nonce comes into play, and how the encryption breaks when a nonce is reused. After that, we’ll dive into the authentication part and see how it can also be broken when a nonce is reused.</p><h3 id="gcm-encryption">GCM encryption</h3><p>GCM, like all modes of operation, provides a way to encrypt and decrypt arbitrary amounts of data using the underlying block cipher.</p><p>To do this, GCM uses the block cipher (in our case, AES-128) to generate a sequence of random-looking bits that are as long as the plaintext. This is called the keystream and it can be generated deterministically using the key (and a nonce, which we will get to in a bit), which means although it looks random, the recipient of a message in possesion of the key is able to calculate the same keystream. To encrypt the plaintext, we take the plaintext and XOR it with the keystream. XOR (⊕) is a simple operation that takes any two bits and returns 1 if exactly one of the bits is 1, and 0 otherwise. It, conveniently, is its own inverse. This means that if we generate by XORing the plaintext and keystream (<code>ciphertext = plaintext ⊕ keystream</code>), we can decrypt the ciphertext, we generate the keystream used during the encryption and XOR it with the cipertext we received: <code>ciphertext ⊕ keystream = (plaintext ⊕ keystream) ⊕ keystream = plaintext</code>. So, technically, in GCM, we don’t actually encrypt the plaintext using the block cipher, we encrypt it using the keystream. The block cipher is only used to generate the keystream.</p><p>However, there’s a problem: Let’s assume for a moment that we have two plaintexts <code>p1</code> and <code>p2</code> and we want to encrypt them both using the same key. If the keystream was only generated using the key, then the keystream for <code>p1</code> would be the same as the keystream for <code>p2</code>. The ciphertexts would then be <code>c1 = p1 ⊕ keystream</code> and <code>c2 = p2 ⊕ keystream</code>. At first glance, this seems fine, but it is not. If an attacker knows the plaintext <code>p1</code> and the ciphertext <code>c1</code>, then they can compute the keystream by XORing <code>p1</code> and <code>c1</code> together (<code>keystream = p1 ⊕ c1</code>) and then decrypt <code>c2</code> by XORing <code>c2</code> with the keystream (<code>p2 = c2 ⊕ keystream = c2 ⊕ (p1 ⊕ c1)</code>). This is a huge security issue, as it allows an attacker to decrypt any ciphertext they have the plaintext for, without knowing the key. This is why we need to introduce a <strong>nonce</strong>.</p><p>A nonce is a random number transfered along with each ciphertext that may never be reused under the same key. We use the nonce as an additional input to the block cipher when generating the keystream so that for each ciphertext, the keystream is different. This means that even if an attacker knows the plaintext and ciphertext for one message, they cannot use that information to decrypt any other ciphertext. When a nonce is reused, however, the keystream is the same, and an attacker can use the same technique as above to decrypt any ciphertext that was encrypted using the same nonce.</p><p>Let’s take a look at an example! First, we choose a nonce and generate a keystream using the key from earlier and the chosen nonce:</p><p>Notice how <code>c2 ⊕ p1 ⊕ c1</code> is the same as <code>p2</code> as long as <code>p1</code> is long enough? This is the security issue we were talking about. If the nonce is reused, an attacker only needs a single pair of plaintext and ciphertext to decrypt any other ciphertext that was encrypted using the same key and nonce. Additionally, by obtaining the keystream, an attacker is able to create their own ciphertext for any plaintext they want, simply by XORing the plaintext with the recovered keystream. Therefore, encryption is trivially broken when a nonce is reused.</p><h4 id="keystream-generation">Keystream generation</h4><p>Although not necessary for understanding the security issue, let’s look at how the keystream is generated in GCM. In GCM, we start off with some initial block of 16 bytes called <code>Y</code><sub><code>0</code></sub> that is calculated from the given nonce. Incrementing this block means taking the last 4 bytes and interpreting them as a 32-bit big-endian integer and incrementing that integer by 1. We start off by incrementing the initial block and then encrypting it using AES-128. This will gives us 16 bytes of output, which we then use as the first 16 bytes of the keystream. We then increment the block again and encrypt it again to get the next 16 bytes of keystream, and so on. This process is repeated until the entire plaintext is encrypted. Note that if the plaintext falls short of a full 16 bytes, we simply only take as many bytes as we need from the keystream instead of the full 16 bytes. This process of “counting up” and encrypting the resulting block to get the keystream is the “Counter Mode” part of Galois/Counter Mode.</p><figure><img loading="lazy" src="https://frereit.de/img/aes/gcm-ctr.svg" alt="GCM uses a simple counter to generate consecutive keystream blocks" data-ffwidth="99%" id="gcm-ctr-mode"/><figcaption>GCM uses a simple counter to generate consecutive keystream blocks</figcaption></figure><p>As you can see, the generated keystream only depends on <code>Y</code><sub><code>0</code></sub>, which in turn only depends on the nonce, and the key. This means that if the nonce is reused across different messages, the keystream will be the same for both messages, and an attacker can use the technique as above to decrypt any ciphertext that was encrypted using the same nonce.</p><h5 id="ysub0sub-calculation"><code>Y</code><sub><code>0</code></sub> calculation</h5><p>I told you before that <code>Y</code><sub><code>0</code></sub> is calculated from the nonce, but I didn’t tell you how. In the simple case, the supplied nonce is 12 bytes long (e.g. <code>deadbeefcafeaffebadbabe0</code>). In that case, <code>Y</code><sub><code>0</code></sub> is the nonce with a 4-byte big endian 1 appended to it, so <code>Y</code><sub><code>0</code></sub><code> = nonce || 0x00000001</code>. If the nonce is not exactly 12 bytes long, we generate <code>Y</code><sub><code>0</code></sub> by passing it through a kind-of hash function called <code>GHASH</code>. We’ll look at <code>GHASH</code> in more detail later but for now, just imagine that <code>GHASH</code> takes a nonce of any length and spits out a 16-byte block that we can use as <code>Y</code><sub><code>0</code></sub>.</p><p>The generated <code>Y</code><sub><code>0</code></sub> is then used to generate the keystream as described above.</p><h4 id="recap">Recap</h4><p>We’ve now seen how the encryption part of GCM works. We’ve seen that the nonce is used together with the key to generate a keystream that is then used to encrypt the plaintext. We’ve also seen that if the nonce is reused, an attacker can use a single known plaintext-ciphertext pair to decrypt any other ciphertext that was encrypted using the same nonce. Once an attacker has obtained the keystream, they can also use it to encrypt any plaintext they want, so there is no guarantee that the plaintext was indeed generated by the sender in possession of the key.</p><h3 id="gcm-authentication">GCM authentication</h3><p>The second and equally important part of GCM is the authentication. This means that we are able to validate that a given ciphertext was indeed generated using the secret key, and that it has not been modified. At the risk of repeating myself, remember that the encryption part of GCM only ensures that the ciphertext cannot be decrypted without the key, but it does not ensure that is has not been tampared with. The encryption operation is a simple XOR operation, so if an attacker changes a single bit in the ciphertext from a <code>0</code> to a <code>1</code>, the corresponding bit in the plaintext will also change. This means that even though the ciphertext cannot be decrypted without the key, an attacker can still modify the ciphertext and the recipient would not be able to detect it. With a single known plaintext-ciphertext pair, an attacker is even able to recover the entire keystream and thus encrypt any plaintext they want. Hence, we need to authenticate the ciphertext.</p><h4 id="galois-field-arithmetic">Galois field arithmetic</h4><p>A core part of the authentication in GCM is the use of Galois field arithmetic, the other part of Galois/Counter Mode. Galois field arithmetic is just a fancy name for a kind of maths where we don’t have infinite numbers like in the real numbers, but instead we have a finite number of elements. This is why sometimes Galois fields are also called “finite fields”.</p><h5 id="gf2"><code>GF(2)</code></h5><p>The simplest example of a Galois field is the field of integers modulo <code>2</code>. This means that we only have two elements, <code>0</code> and <code>1</code>. Forget all other numbers, only <code>0</code> and <code>1</code> exist when we’re talking about <code>GF(2)</code>. Because this is a new number system, we have to definie how mathematical operations work in it. If no other numbers exist, what is <code>1 + 1</code>?</p><p>We <em>define</em> addition of numbers in these fields to be the result of adding the numbers in the real numbers and then taking the result modulo <code>2</code>. The modulo operation simply takes the remainder of a whole number divison. For example, in the real numbers, <code>5 = 2 * 2 + 1</code>, so <code>5 = 1 (mod 2)</code>. Let’s look at how this looks in an addition table:</p><table><tbody><tr><th>+</th><th>0</th><th>1</th></tr><tr><th>0</th><td>0</td><td>1</td></tr><tr><th>1</th><td>1</td><td>0</td></tr></tbody></table><p>As you can see, <code>0 + 0 = 0</code>, <code>0 + 1 = 1</code>, <code>1 + 0 = 1</code>, and <code>1 + 1 = 0</code>. You might recognize this as the XOR operation that we used to encrypt the plaintext with the keystream. This is no coincidence, as the XOR operation is exactly the addition operation in the Galois field of integers modulo <code>2</code>. This means that when we XOR two numbers together, we can also think of it as adding them together in the Galois field of integers modulo <code>2</code>. To make it clear that we are working in a different number system, we don’t use the <code>+</code> symbol for addition in Galois fields, but instead use the <code>⊕</code> symbol. You might have seen this symbol as the XOR operation, and now you know that it is exactly the same as addition in the Galois field of integers modulo <code>2</code>.</p><p>Now, let’s look at how we <em>define</em> multiplication in the Galois field of integers modulo <code>2</code>. We define it to be the result of multiplying the numbers in the real numbers and then taking the result modulo <code>2</code>. Let’s look at how this looks in a multiplication table:</p><table><tbody><tr><th>⋅</th><th>0</th><th>1</th></tr><tr><th>0</th><td>0</td><td>0</td></tr><tr><th>1</th><td>0</td><td>1</td></tr></tbody></table><p>Again, you might notice that this is exactly the same as the AND operation. The result of multiplying two numbers in <code>GF(2)</code> is <code>1</code> if and only if both numbers are <code>1</code>. This means that when we AND two numbers together, we can also think of it as multiplying them together in the Galois field of integers modulo <code>2</code>. Analogously to the addition operation, where we use the <code>⊕</code> symbol, we use the <code>⨂</code> symbol to represent multiplication in Galois fields.</p><h5 id="gf2sup128sup"><code>GF(2</code><sup><code>128</code></sup><code>)</code></h5><p>We can also define Galois fields with more than two elements. For example, we can define a Galois field with <code>2</code><sup><code>128</code></sup> elements. This means that we have <code>2</code><sup><code>128</code></sup> different numbers, which is just to say that we use 128 bits (16 bytes!) to represent each number. You might already notice that this is exactly the same as the block size of AES. As you’ll see later, this is no coincidence, because we’ll start interpreting the 128-bit blocks of data as elements represented by numbers in <code>GF(2</code><sup><code>128</code></sup><code>)</code>.</p><p>First, though, we need to define addition and multiplication in <code>GF(2</code><sup><code>128</code></sup><code>)</code> just like we did for <code>GF(2)</code>. One way to think of elements in <code>GF(2</code><sup><code>128</code></sup><code>)</code> is as polynomials with coefficients in <code>GF(2)</code>. This is just a definition, we have this set of <code>2</code><sup><code>128</code></sup> things, and we say that each of the things corresponds to some polynomial. This means that we can represent each element in <code>GF(2</code><sup><code>128</code></sup><code>)</code> as a polynomial of degree at most <code>127</code> with coefficients in <code>GF(2)</code>. So, some elements of <code>GF(2</code><sup><code>128</code></sup><code>)</code> can be represented like so:</p><ul><li><code>0 ⋅ x</code><sup><code>0</code></sup><code> = 0</code>.</li><li><code>1 ⋅ x</code><sup><code>0</code></sup><code> = 1</code>.</li><li><code>x</code><sup><code>4</code></sup><code> + x</code>.</li><li><code>x</code><sup><code>127</code></sup><code> + x</code><sup><code>126</code></sup><code> + x</code><sup><code>125</code></sup>.</li></ul><p>Because we’ve defined the the coefficients to be in <code>GF(2)</code>, they are all either <code>0</code> or <code>1</code>. Another way to look at this is that <code>x</code><sup><code>i</code></sup> is either in the polynomial or it is not, for each <code>i</code> from <code>0</code> to <code>127</code>. This means that we can represent each element in <code>GF(2</code><sup><code>128</code></sup><code>)</code> as a 128-bit value, where each bit tells us if a certain power of <code>x</code> is in the polynomial or not. Different standards use different ways to assign the bits to the powers of <code>x</code> but the GCM standard uses a kind-of reversed order, so that the most significant bit of the 128-bit value corresponds to <code>x</code><sup><code>0</code></sup>, the next bit to <code>x</code><sup><code>1</code></sup>, and so on, up to the least significant bit corresponding to <code>x</code><sup><code>127</code></sup>. Let’s encode the previous polynomials in this way as hexadecimal values:</p><ul><li><code>0</code> is <code>00000000000000000000000000000000</code> because no powers of <code>x</code> are in the polynomial.</li><li><code>1</code> is <code>80000000000000000000000000000000</code> because <code>x</code><sup><code>0</code></sup> is in the polynomial, which is the most significant bit.</li><li><code>x</code><sup><code>4</code></sup><code> + x</code> is <code>48000000000000000000000000000000</code>.</li><li><code>x</code><sup><code>127</code></sup><code> + x</code><sup><code>126</code></sup><code> + x</code><sup><code>125</code></sup> is <code>00000000000000000000000000000007</code>.</li></ul><p>We now have a way of representing each of the <code>2</code><sup><code>128</code></sup> elements of <code>GF(2</code><sup><code>128</code></sup><code>)</code> as a polynomial. To define addition, we use the polynomial representation, which already has a well-defined addition operation. Remember, all coefficients are in <code>GF(2)</code>, so we add them together using the addition operation we defined earlier, for example <code>(x</code><sup><code>2</code></sup><code> + x) + (x</code><sup><code>4</code></sup><code> + x</code><sup><code>2</code></sup><code> + 1) = x</code><sup><code>4</code></sup><code> + x + 1</code>. The result is a polynomial of degree at most <code>127</code> with coefficients in <code>GF(2)</code>, so it is a valid element in <code>GF(2</code><sup><code>128</code></sup><code>)</code>. Note that if a power of <code>x</code> appears in both polynomials, it will be cancelled out, so for example <code>(x</code><sup><code>2</code></sup><code>) + (x</code><sup><code>2</code></sup><code>) = 0</code>. If it appears in exactly one of the polynomials, it will be in the result. This is exactly the same as the XOR operation, so we can again think of addition in <code>GF(2</code><sup><code>128</code></sup><code>)</code> as the XOR operation on the 128-bit values representing the polynomials.</p><p>You can try it out for yourself here. Enter two polynomials or their hexadecimal representations and see the result of adding them together:</p><p>Hopefully you’re able to convince yourself that adding these polynomials is exactly the same as XORing the 128-bit values representing them. This is the addition operation in <code>GF(2</code><sup><code>128</code></sup><code>)</code>.</p><p>Now, let’s take a look at multiplication. Multiplication, just like addition, works by interpreting the field elements as polynomials and then multiplying the polynomials together. For example, <code>(x</code><sup><code>2</code></sup><code> + x) ⋅ (x</code><sup><code>4</code></sup><code> + 1) = x</code><sup><code>6</code></sup><code> + x</code><sup><code>5</code></sup><code> + x</code><sup><code>2</code></sup><code> + x</code>. We get this result by multiplying all the terms in the first polynomial with all the terms in the second polynomial and then adding the results together. In this case, the result is a polynomial with degree <code>6</code> and coefficients in <code>GF(2)</code>, so it is a valid element in <code>GF(2</code><sup><code>128</code></sup><code>)</code>. However, look at what happens when we multiply <code>x</code><sup><code>127</code></sup> by <code>x</code>: <code>x</code><sup><code>127</code></sup><code> ⋅ x = x</code><sup><code>128</code></sup>. This poses a problem because we defined <code>GF(2</code><sup><code>128</code></sup><code>)</code> to have elements of degree at most <code>127</code> but this polynomial is of degree <code>128</code>. So <code>x</code><sup><code>128</code></sup> is not an element which we can represent as a 128-bit block of data.
Instead, we need to add another step to the multiplication operation:</p><p>After we multiply the polynomials together, we divide the result by a special polynomial called the “reduction polynomial” and take the remainder as the result instead. The reduction polynomial must be defined along with the field. It is an irreducible polynomial, which means that it isn’t the product of any two non-trivial polynomials (like how prime numbers aren’t the product of any two other numbers, except one and itself) and has degree 128, so that the remainder of a division operation is always of degree at most 127. The GCM standard defines the reduction polynomial to be <code>x</code><sup><code>128</code></sup><code> + x</code><sup><code>7</code></sup><code> + x</code><sup><code>2</code></sup><code> + x + 1</code> for the field <code>GF(2</code><sup><code>128</code></sup><code>)</code> used in GCM.</p><p>In this case, where we are trying to reduce <code>x</code><sup><code>128</code></sup>, it’s actually quite easy to see that dividing <code>x</code><sup><code>128</code></sup> by <code>x</code><sup><code>128</code></sup><code> + x</code><sup><code>7</code></sup><code> + x</code><sup><code>2</code></sup><code> + x + 1</code> will result in a remainder of <code>x</code><sup><code>7</code></sup><code> + x</code><sup><code>2</code></sup><code> + x + 1</code> because <code>x</code><sup><code>128</code></sup> fits exactly once into the reduction polynomial, leaving a remainder of <code>x</code><sup><code>7</code></sup><code> + x</code><sup><code>2</code></sup><code> + x + 1</code>. Multiplying <code>x</code><sup><code>128</code></sup> by <code>1</code> and adding the remainder confirms this:</p><p><code>1 ⋅ (x</code><sup><code>128</code></sup><code>) + (x</code><sup><code>7</code></sup><code> + x</code><sup><code>2</code></sup><code> + x + 1) = x</code><sup><code>128</code></sup><code> + x</code><sup><code>7</code></sup><code> + x</code><sup><code>2</code></sup><code> + x + 1</code>.</p><p>For more complex cases, we need to use polynomial long division to divide the result by the reduction polynomial and take the remainder as the result. This is a bit more involved, but it is exactly the same as long division with real numbers, just with polynomials instead. I won’t go into the details here because we can just let the computer do the work for us, but if you’re interested, you can look up polynomial long division on the internet and try to apply it to coefficients in <code>GF(2)</code> instead of real numbers<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>.</p><p>If we look at the multiplication in <code>GF(2</code><sup><code>128</code></sup><code>)</code> from the perspective of the 128-bit blocks of data, instead of the polynomials, the operation is sometimes referred to as “Carry-less multiplication”, because it corresponds to the multiplication of the 128-bit blocks of data, where all carry values are discarded instead of propagated during the multiplication. In this post, we’ll stick to the polynomial representation, but it’s good to know that the operation is also called “Carry-less multiplication” or “CLMUL”, especially if you’re looking at the AES-NI instruction set of modern CPUs. The symbol for multiplication in Galois fields is <code>⨂</code>, so we’ll use that in the following figures.</p><p>Let’s go through another example. Enter two polynomials and see the result of multiplying them together:</p><p>That covers the basics of Galois field arithmetic. We’ve seen that we can add and multiply elements in <code>GF(2</code><sup><code>128</code></sup><code>)</code> just like we can add and multiply real numbers, but with the added step of reducing the result by a reduction polynomial. Importantly, we can also think of addition as the XOR operation, which is why it can also be represented by the <code>⊕</code> symbol. Multiplication is represented by the <code>⨂</code> symbol in the following figures.</p><h4 id="ghash">GHASH</h4><p>Now that we have the basics of Galois field arithmetic down, we can look at the <code>GHASH</code> function. <code>GHASH</code> is a function defined in the GCM standard that takes a key and arbitrary amounts of data and spits out a 128-bit block of data. This block of data is then used in the GCM standard to authenticate the ciphertext and the associated data.</p><p>To use <code>GHASH</code>, we first need to derive a 128-bit block that we can use as the <code>GHASH</code> key <code>H</code>. This is done by encrypting a block of 16 null bytes using AES and the AES key. This block is then interpreted as a polynomial and used as the <code>GHASH</code> key <code>H</code> for the rest of the <code>GHASH</code> computation:</p><figure><img loading="lazy" src="https://frereit.de/img/aes/h-key.svg" alt="The GHASH key H is derived by encrypting a block of 16 null bytes using AES-128 and the AES key" data-ffwidth="51%"/><figcaption>The GHASH key H is derived by encrypting a block of 16 null bytes using AES-128 and the AES key</figcaption></figure><p>To compute <code>GHASH</code>, we first need to represent the data we want to authenticate as a sequence of 128-bit blocks. This is done by splitting the data into 128-bit blocks and then padding the last block with null bytes if it is not already 128 bits long. We do this separately for the associated data and the ciphertext, so for example if we wanted to authenticated the associated data <code>deadbeef</code> and the ciphertext <code>cafeaffe</code>, we’d use the blocks <code>deadbeef000000000000000000000000</code> and <code>cafeaffe000000000000000000000000</code> as the input to <code>GHASH</code>. To make sure the size of the data is not lost, we add one more block at the end that contains the length of the associated data in bits as a 64-bit big-endian integer and the length of the ciphertext in bits as a 64-bit big-endian integer concatenated together, so in this case <code>00000000000000200000000000000020</code> for the associated data <code>deadbeef</code> and the ciphertext <code>cafeaffe</code>.</p><p>To start the computation, we initialize a <code>GF(2</code><sup><code>128</code></sup><code>)</code> element <code>Q</code> to <code>0</code>. We then process the prepared blocks in sequence. The blocks from the associated data are processed first, followed by the blocks from the ciphertext. The length block is processed last. For each block, we interpret the block as a <code>GF(2</code><sup><code>128</code></sup><code>)</code> element and add it to <code>Q</code> using the addition operation in <code>GF(2</code><sup><code>128</code></sup><code>)</code> (which is just the XOR operation) and then multiply <code>Q</code> by the <code>GHASH</code> key <code>H</code> using the multiplication and reduction operation we defined earlier.</p><figure><img loading="lazy" src="https://frereit.de/img/aes/ghash.svg" alt="The GHASH function processes 128-bit blocks in order" data-ffwidth="99%"/><figcaption>The GHASH function processes 128-bit blocks in order</figcaption></figure><p>The <code>result</code> of the <code>GHASH</code> function is the final value of <code>Y</code> after processing all the blocks. For security reasons that will hopefully become clear later, we cannot use the <code>result</code> directly as the authentication tag. Instead, we encrypt the <code>Y</code><sub><code>0</code></sub> block from earlier using the AES key and XOR the encrypted <code>Y</code><sub><code>0</code></sub> block with the <code>result</code> to get the final authentication tag. This is the value that is sent along with the ciphertext and the associated data to the recipient, who can then use the same key to compute the <code>GHASH</code> function and verify that the authentication tag is correct. An attacker who does not know the key cannot modify the ciphertext or the associated data without the recipient noticing, because they would not be able to compute the correct authentication tag, because they cannot derive <code>H</code> and the encrypted <code>Y</code><sub><code>0</code></sub> block.</p><h5 id="formula-for-ghash">Formula for GHASH</h5><p>We can also express the <code>GHASH</code> function as a formula. Let <code>H</code> be the <code>GHASH</code> key and <code>U</code><sub><code>i</code></sub> be the <code>i</code>-th prepared block. So, in the example above, <code>U</code><sub><code>0</code></sub> would be <code>deadbeef000000000000000000000000</code>, <code>U</code><sub><code>1</code></sub> would be <code>cafeaffe000000000000000000000000</code>, and <code>U</code><sub><code>2</code></sub> would be <code>00000000000000200000000000000020</code>.</p><p>We can build the formula for <code>GHASH</code> iteratively:</p><ol><li>First, we initialize <code>Q</code> to <code>0</code>: <code>Q ← 0</code>.</li><li>Then, for the first block, we add it to <code>Q</code>: <code>Q ← Q ⊕ U</code><sub><code>0</code></sub> (which is the same as <code>Q = U</code><sub><code>0</code></sub> because <code>Q</code> is <code>0</code>).</li><li>We then multiply <code>Q</code> by <code>H</code>: <code>Q ← Q ⨂ H = (U</code><sub><code>0</code></sub><code>) ⨂ H</code>.</li><li>For the second block, we add it to <code>Q</code>: <code>Q ← Q ⊕ U</code><sub><code>1</code></sub><code> = ((U</code><sub><code>0</code></sub><code>) ⨂ H) ⊕ U</code><sub><code>1</code></sub>.</li><li>Again, we multiply <code>Q</code> by <code>H</code>: <code>Q ← Q ⨂ H = (((U</code><sub><code>0</code></sub><code>) ⨂ H) ⊕ U</code><sub><code>1</code></sub><code>) ⨂ H</code>.</li><li>We can continue this process for all the blocks and the final result is the <code>GHASH</code> value. The formula for <code>GHASH</code> is then: <code>Q = (((((U</code><sub><code>0</code></sub><code> ⨂ H) ⊕ U</code><sub><code>1</code></sub><code>) ⨂ H) ⊕ U</code><sub><code>2</code></sub><code>) ⨂ H) ⊕ ...</code></li></ol><p>Take some time to look at the formula and see if you can convince yourself that it indeed the same as the graphical representation above.</p><p>Multiplication and addition in <code>GF(2</code><sup><code>128</code></sup><code>)</code> follows the usual laws of multiplication and addition, so we can distribute the multiplication of <code>H</code> over the additions. This means that <code>(((U</code><sub><code>0</code></sub><code>) ⨂ H) ⊕ U</code><sub><code>1</code></sub><code>) ⨂ H = (U</code><sub><code>0</code></sub><code> ⨂ H</code><sup><code>2</code></sup><code>) ⊕ (U</code><sub><code>1</code></sub><code> ⨂ H)</code>.</p><p>We can apply this rule to the formula above to get a more compact formula for <code>GHASH</code>:</p><p><code>Q = (U</code><sub><code>0</code></sub><code> ⨂ H</code><sup><code>n+1</code></sup><code>) ⊕ (U</code><sub><code>1</code></sub><code> ⨂ H</code><sup><code>n</code></sup><code>) ⊕ ... ⊕ (U</code><sub><code>n-1</code></sub><code> ⨂ H</code><sup><code>2</code></sup><code>) ⊕ (U</code><sub><code>n</code></sub><code> ⨂ H)</code>.</p><p>Lastly, we have to XOR the result with the encrypted <code>Y</code><sub><code>0</code></sub> block to get the final authentication tag. We have to add the encrypted <code>Y</code><sub><code>0</code></sub> block to the result to get the final authentication tag <code>T</code>, because adding in <code>GF(2</code><sup><code>128</code></sup><code>)</code> is equal to the XOR operation:</p><p><code>T = Q ⊕ E</code><sub><code>k</code></sub><code>(y</code><sub><code>0</code></sub><code>) = (U</code><sub><code>0</code></sub><code> ⨂ H</code><sup><code>n+1</code></sup><code>) ⊕ ... ⊕ (U</code><sub><code>n</code></sub><code> ⨂ H) ⊕ E</code><sub><code>k</code></sub><code>(y</code><sub><code>0</code></sub><code>)</code>.</p><p>Now that we have a formula for <code>GHASH</code>, we can use it to compute the authentication tag for the ciphertext and the associated data. Let’s take a look at an example! Enter some key, nonce, associated data, and ciphertext and see the authentication tag computed using the <code>GHASH</code> function:</p><p>Okay, that was a lot! We’ve now seen how the <code>GHASH</code> function works and how it is used to authenticate the ciphertext and the associated data. We’ve also seen that we can represent the <code>GHASH</code> function as a formula that we can use to compute the authentication tag in <code>GF(2</code><sup><code>128</code></sup><code>)</code>. To verify the authenticity of the ciphertext and the associated data, the recipient can compute the <code>GHASH</code> function using the same key and the same nonce and compare the result to the authentication tag. If the two values match, the recipient can be sure that the ciphertext and the associated data have not been tampered with and that they were indeed generated by the sender in possession of the key.</p><h3 id="recap-1">Recap</h3><p>We’ve now seen how GCM works. It allows us to encrypt and authenticate data using a secret key, and detect if the encrypted data has been tampered with.</p><p>Enter any plaintext, key, and nonce and see the ciphertext and authentication tag computed using AES-GCM<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>. This time, unlike in plain AES, when you change the ciphertext or authentication tag, the decryption will fail because the authentication tag will not match:</p><p>If you’ve made it this far into the blog post, now may be a good time to take a break and let all the information sink in before we continue on to the attack on AES-GCM when a nonce is reused. If you have any questions, feel free to <a href="https://infosec.exchange/@fre">send me a toot</a>.</p><p><marquee scrollamount="3" scrolldelay="60" direction="right" behavior="alternate">☕☕☕☕☕☕☕☕☕</marquee></p><p>Alright, let’s continue to the attack!</p><h2 id="nonce-reuse">Nonce Reuse</h2><p>We have now seen how AES-GCM works and how the authentication tag is computed. We have also seen that the nonce is used in the computation of the authentication tag. But what happens if the nonce is reused?</p><p>Let’s assume two authentication tags <code>T1</code> and <code>T2</code> are computed using the same key and nonce. For simplicitly, let’s assume the blocks used in the <code>GHASH</code> computation were <code>U1</code><sub><code>0</code></sub>, <code>U1</code><sub><code>1</code></sub> and <code>U1</code><sub><code>2</code></sub> for the first tag and <code>U2</code><sub><code>0</code></sub>, <code>U2</code><sub><code>1</code></sub> and <code>U2</code><sub><code>2</code></sub> for the second tag. In practice, the number of blocks used in the <code>GHASH</code> computation is (almost) irrelevant, but for this example, we’ll stick to three blocks.</p><p>Let’s write out the formula for the first tag <code>T1</code>:</p><p><code>T1 = GHASH1 ⊕ E</code><sub><code>k</code></sub><code>(y</code><sub><code>0</code></sub><code>) = (U1</code><sub><code>0</code></sub><code> ⨂ H</code><sup><code>3</code></sup><code>) ⊕ (U1</code><sub><code>1</code></sub><code> ⨂ H</code><sup><code>2</code></sup><code>) ⊕ (U1</code><sub><code>2</code></sub><code> ⨂ H) ⊕ E</code><sub><code>k</code></sub><code>(y</code><sub><code>0</code></sub><code>)</code>.</p><p>The formula for the second tag <code>T2</code> is similar:</p><p><code>T2 = GHASH2 ⊕ E</code><sub><code>k</code></sub><code>(y</code><sub><code>0</code></sub><code>) = (U2</code><sub><code>0</code></sub><code> ⨂ H</code><sup><code>3</code></sup><code>) ⊕ (U2</code><sub><code>1</code></sub><code> ⨂ H</code><sup><code>2</code></sup><code>) ⊕ (U2</code><sub><code>2</code></sub><code> ⨂ H) ⊕ E</code><sub><code>k</code></sub><code>(y</code><sub><code>0</code></sub><code>)</code>.</p><p>Notice how in both formulas <code>E</code><sub><code>k</code></sub><code>(y</code><sub><code>0</code></sub><code>)</code> appears. This is the crucial part. Remember that <code>E</code><sub><code>k</code></sub><code>(y</code><sub><code>0</code></sub><code>)</code> is the encryption of the <code>Y</code><sub><code>0</code></sub> block using the AES key. The <code>Y</code><sub><code>0</code></sub> block is only dependant on the nonce, which we assume to have been the same in both messages, and of course we assume both messages were encrypted with the same key. This means that <code>E</code><sub><code>k</code></sub><code>(y</code><sub><code>0</code></sub><code>)</code> is exactly the same value in both tags. This means that <code>E</code><sub><code>k</code></sub><code>(y</code><sub><code>0</code></sub><code>)</code> can be cancelled out by adding the two equations together:</p><p><code>T1 ⊕ T2 = ((U1</code><sub><code>0</code></sub><code> ⨂ H</code><sup><code>3</code></sup><code>) ⊕ (U1</code><sub><code>1</code></sub><code> ⨂ H</code><sup><code>2</code></sup><code>) ⊕ (U1</code><sub><code>2</code></sub><code> ⨂ H) ⊕ E</code><sub><code>k</code></sub><code>(y</code><sub><code>0</code></sub><code>)) ⊕ ((U2</code><sub><code>0</code></sub><code> ⨂ H</code><sup><code>3</code></sup><code>) ⊕ (U2</code><sub><code>1</code></sub><code> ⨂ H</code><sup><code>2</code></sup><code>) ⊕ (U2</code><sub><code>2</code></sub><code> ⨂ H) ⊕ E</code><sub><code>k</code></sub><code>(y</code><sub><code>0</code></sub><code>))</code></p><p>By adding the two equations together, we have completely eliminated <code>E</code><sub><code>k</code></sub><code>(y</code><sub><code>0</code></sub><code>)</code>. We’ll now look at what’s left in this formula, and how we can use it to recover <code>H</code>.</p><p>Rearraning the formula by adding <code>T1 ⊕ T2</code> on both sides gives us a zero on one side of the equation:</p><p><code>0 = ((U1</code><sub><code>0</code></sub><code> ⊕ U2</code><sub><code>0</code></sub><code>) ⨂ H</code><sup><code>4</code></sup><code>) ⊕ ((U1</code><sub><code>1</code></sub><code> ⊕ U2</code><sub><code>1</code></sub><code>) ⨂ H</code><sup><code>2</code></sup><code>) ⊕ ((U1</code><sub><code>2</code></sub><code> ⊕ U2</code><sub><code>2</code></sub><code>) ⨂ H) ⊕ T1 ⊕ T2</code></p><p>Now, you might notice, this is <em>extremely</em> similar to a polynomial equation. In fact, it is a polynomial equation for <code>H</code>! Forget for a moment that <code>H</code> and all the <code>U</code> values are in <code>GF(2</code><sup><code>128</code></sup><code>)</code> and think of any other polynomial equation you might have seen, like <code>4x</code><sup><code>4</code></sup><code> + 2x</code><sup><code>3</code></sup><code> + 3x</code><sup><code>2</code></sup><code> + 7x + 1 = 0</code>. This is exactly the same, just with <code>H</code> instead of <code>x</code> and with coefficients the coefficients <code>U1</code><sub><code>i</code></sub><code> ⊕ U2</code><sub><code>i</code></sub> instead of a regular real number like <code>4</code>.</p><p>Note that attacker that has obtained both transmitted messages has knowledge of <code>T1</code>, <code>T2</code> as well as <code>U1</code> and <code>U2</code>, as the tag and ciphetext (with associated data) are the “public” parts of the AES-GCM scheme. So, because an attacker has knowledge of <code>U1</code> and <code>U2</code>, we can treat this coefficient like any other constant coefficient in a polynomial equation. We’ve already defined the addition and multiplication operations in <code>GF(2</code><sup><code>128</code></sup><code>)</code>, so hopefully it becomes clear that we can treat the formula we just derived like any other polynomial equation.</p><p>If we can find a solution for this polynomial equation, we can recover the <code>H</code> value. Why is this interesting? Remember that <code>H</code> is the <code>GHASH</code> key, which is derived from the AES key. If we can recover <code>H</code>, we can use it to compute the <code>GHASH</code> function for any data we want. This means that we can authenticate any data we want, even if we don’t know the AES key. Combined with the keystream recovery demonstrated early, this leads to a <strong><em>full break</em></strong> of the AES-GCM encryption scheme.</p><h3 id="solving-the-polynomial-equation">Solving the polynomial equation</h3><p>So, the question is, how do we solve this polynomial equation? This is where the Cantor-Zassenhaus algorithm comes in. The Cantor-Zassenhaus algorithm is an algorithm that can be used to factor polynomials specifically over finite fields. In our case, we want to factor the polynomial equation we derived earlier over <code>GF(2</code><sup><code>128</code></sup><code>)</code>. The Cantor-Zassenhaus algorithm is a probabilistic algorithm, which means that it might not always find a solution, but given enough attempts, it will find a solution with an arbitrarily high probability.</p><p>The Cantor-Zassenhaus algorithm cannot be applied to just any polynomial equation, there are a few requirements that must be ticked off before the algorithm can be used. Lukily, there exist other algorithms to ensure that these requirements are met for any given polynomial:</p><ol><li><p>The polynomial must be square-free, which means that it has no repeated roots. For example, let’s say we have a polynomial equation <code>H ⊕ 1 = 0</code>. Remember that addition in <code>GF(2</code><sup><code>128</code></sup><code>)</code> is the XOR operation, so if we set <code>H</code> to <code>1</code>, then <code>H ⊕ 1 = 1 ⊕ 1 = 0</code>. So the polynomial has a root at <code>H = 1</code>. If we now multiply this polynomial with itself, we get a new polynomial: <code>(H ⊕ 1) ⨂ (H ⊕ 1) = H</code><sup><code>2</code></sup><code> ⊕ 1</code>. This polynomial has a repeated root at <code>H = 1</code>, because <code>H ⊕ 1</code> appears twice in the factorization of the polynomial. You can also think of this as the polynomial having a factor <code>(H ⊕ 1)</code> squared. The Cantor-Zassenhaus algorithm cannot factor polynomials with repeated roots, so we need to make sure that the polynomial we derived earlier does not have any repeated roots, which is the case when it is “square-free”. To achive this requirement, we will be constructing a new polynomial that contains all the factors of the original polynomial exactly once. Although this algorithm changes the “form” of the polynomial, the values of the roots stay unchanged, only their multiplicity (how often they appear) is set to exactly one.</p></li><li><p>The polynomial must be the product of polynomials of equal degrees. For example, take the polynomial equation <code>H</code><sup><code>2</code></sup><code> ⊕ (x ⨂ H) ⊕ 1 = 0</code>. Here the <code>x</code> is the polynomial representation of the block value <code>40000000000000000000000000000000</code>, like we discussed earlier. This polynomial has degree <code>2</code> and is irreducible, which means that it cannot be factored into two polynomials of degree <code>1</code>. Any polynomial that has a root must have a factor of degree <code>1</code>, therefore any irreducible polynomial of degree <code>2</code> or higher cannot have any roots. If we multiply this by <code>H + 1</code>, we get <code>H</code><sup><code>3</code></sup><code> ⊕ ((x + 1) ⨂ H</code><sup><code>2</code></sup><code>) ⊕ ((x + 1) ⨂ H) ⊕ 1</code>, which is a polynomial of degree <code>3</code>. However, this polynomial cannot be factored using the Cantor-Zassenhaus algorithm because it is the product of one irreducible polynomial of degree <code>2</code> and one polynomial of degree <code>1</code>. We need to split the input polynomial its “parts”, so into a list of polynomials that only have factors of the same degree. This is called “distinct-degree factorization”. It is the last step needed before we can then apply the Cantor-Zassenhaus algorithm to find the roots of each of the “equal-degree” polynomials.</p></li></ol><p>The algorithms to make the polynomial square-free and to split it into polynomials of equal degrees are well-documented and there’s even pseudocode available on Wikipedia for <a href="https://en.wikipedia.org/wiki/Factorization_of_polynomials_over_finite_fields#Square-free_factorization">square-free factorization</a> and <a href="https://en.wikipedia.org/wiki/Factorization_of_polynomials_over_finite_fields#Distinct-degree_factorization">distinct-degree factorization</a> respectively.</p><p>Once we have a square-free polynomial that is the product of polynomials of equal degrees, we can use the Cantor-Zassenhaus algorithm to split the polynomial into two factors and do so repeatedly until we have found all the factors.</p><p>I’ll outline the main idea of the Cantor-Zassenhaus algorithm here, but again, you can find <a href="https://en.wikipedia.org/wiki/Factorization_of_polynomials_over_finite_fields#Cantor%E2%80%93Zassenhaus_algorithm">pseudocode on Wikipedia</a><sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>. We want to factor a polynomial <code>f</code> into two factors. This assumes we already have a square-free polynomial and that it is the product of polynomials of equal degrees <code>d</code>. For polynomials in <code>GF(2</code><sup><code>128</code></sup><code>)</code>, the algorithm works as follows:</p><ol><li>Pick a random polynomial <code>h</code> of degree less than <code>f</code> and compute the greatest common divisor of <code>f</code> and <code>h</code>.</li><li>Set <code>M = ⅓(2</code><sup><code>d ⋅ 128</code></sup><code> - 1)</code> and compute the greatest common denominator of <code>h</code><sup><code>M</code></sup><code> - 1</code> and <code>f</code>. We’ll call this <code>g</code>.</li><li>If <code>g</code> is not <code>1</code> or <code>f</code> (which are both trivial factors that we don’t care about), we have found a non-trivial factor of <code>f</code>. We can then recursively factor <code>g</code> and <code>f / g</code> to find all the factors of <code>f</code>.</li><li>If <code>g</code> is <code>1</code> or <code>f</code>, we need to pick a new random polynomial <code>h</code> and try again.</li></ol><p>By just repeatedly picking a random polynomial, raising it to the power of <code>⅓ ⋅ (2</code><sup><code>d ⋅ 128</code></sup><code> - 1)</code>, subtracting one, and computing the greatest common divisor with the polynomial we want to factor, we can find all the factors of the polynomial. But you might spot a problem: Raising a polynomial to the power of <code>⅓ ⋅ (2</code><sup><code>d ⋅ 128</code></sup><code> - 1)</code> seems almost impossible, because that number is absolutely huge! But, of course, there’s a trick: Instead of raising the polynomial to the power of <code>⅓ ⋅ (2</code><sup><code>d ⋅ 128</code></sup><code> - 1)</code>, and then computing the greatest common denominator immediately, we can reduce the polynomial by <code>f</code> before computing the greatest common denominator, without “losing” any factors. Calculating an almost arbitrarily large power with a given modulus is a well-known problem in computer algebra, and the square-and-multiply algorithm can be used to compute the result efficiently. Without this trick, the Cantor-Zassenhaus algorithm would be infeasible for polynomials of degree <code>128</code> in <code>GF(2</code><sup><code>128</code></sup><code>)</code> and it is one of the core reasons why the Cantor-Zassenhaus algorithm is so powerful.</p><p>Once we have found all the factors of the polynomial, we look at all the factors with degree <code>1</code>. These are the factors that are linear polynomials, so they are of the form <code>H + a</code> where <code>a</code> is a constant. We then know that when we set <code>H = a</code>, this linear polynomial will evaluate to zero, and is thus is a solution to the polynomial equation we derived earlier. Note that we might have multiple solutions for <code>H</code> if there are multiple roots to the polynomial but only one of them is the correct <code>H</code> used in the <code>GHASH</code> computation, which we will need to use if we want to authenticate other data. To do this, we need a third message that was authenticated using the same key and nonce. We can then use the recovered <code>H</code> to compute the <code>GHASH</code> function for the third message and check if the result of our computation matches the real authentication tag of the third message. If it does, we have successfully recovered the <code>H</code> value and can now authenticate any data we want.</p><h3 id="putting-it-all-together">Putting it all together</h3><p>We now have all the pieces we need to recover the <code>GHASH</code> key <code>H</code> if the nonce is reused. We can use the Cantor-Zassenhaus algorithm to factor the polynomial equation we derived earlier and recover the <code>H</code> value. We can then use the recovered <code>H</code> to compute the <code>GHASH</code> function for any data we want and authenticate it. Let’s see it all in action!</p><p>First, we need to simulate the nonce reuse. For simplicity, we’ll ignore the associated data because it doesn’t affect the attack, it just means we have to take the associated data into account when constructing the polynomial equation. Enter a key, nonce and three plaintexts to compute the ciphertexts and the authentication tags<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup>:</p><p>Now that we have the ciphertexts and the authentication tags for three messages that were encrypted using the same key and nonce, we can recover candidate <code>H</code> values by solving the polynomial equation we derived earlier and then verify the correct <code>H</code> value by computing the <code>GHASH</code> function for the third message if more than one <code>H</code> solves the equation.</p><p>We’ll need to figure out the polynomial equation to solve. Let’s split up the first ciphertext into their respective blocks and XOR them together to get the coefficients of the polynomial equation:</p><p>Now, we can solve this equation to get candidate <code>H</code> values, one of which is the real <code>H</code> key used during AES-GCM authentication.</p><p>We have just used the Cantor-Zassenhaus algorithm to recover the <code>H</code> key and <code>E</code><sub><code>k</code></sub><code>(y</code><sub><code>0</code></sub><code>)</code> value used during the AES-GCM authentication, which lets us authenticate <strong>any message we want</strong>.</p><h3 id="recap-2">Recap</h3><p>Although more complicated than the keystream recovery, when a nonce is reused, we can use polynomial factorization to figure out the <code>H</code> key, which ultimately let’s us authenticate any data we want. So, in total, the attack goes like this:</p><ol><li>Alice and Bob agree to a secret shared key. This key is unknown to the attacker.</li><li>Alice sends Bob a secret message, encrypted using AES-GCM. We assume that the attacker knows the plaintext that Alice sent, and records the nonce, ciphertext and tag transmitted by Alice to Bob.</li><li>Bob is able to use the nonce and tag to authenticate the ciphertext, and uses the shared key to decrypt the ciphertext.</li><li>Alice sends Bob two more messages, all encrypted using the <em>same nonce</em>. The attacker can use the first plaintext/ciphertext pair to recover the keystream, and thus recover the plaintext for these messages as well.</li><li>Bob, again, is able to use the nonce and tag to authenticate the ciphertext, and decrypt it using the shared key.</li><li>The attacker has recovered the keystream by XORing the first plaintext with the ciphertext.</li><li>The attacker uses the polynomial factorization to recover the <code>H</code> and <code>E</code><sub><code>k</code></sub><code>(y</code><sub><code>0</code></sub><code>)</code> values.</li><li>The attacker uses these values to construct a message and sends the message to Bob.</li><li>Bob successfully authenticates the ciphertext, even though the ciphertext wasn’t sent by Alice. Because the keystream is the same as well, Bob is also able to decrypt the ciphertext. This means that Bob has now received a message from the attacker that they think was sent by Alice.</li></ol><h2 id="conclusion">Conclusion</h2><p>Thank you for reading all the way through this huge post! I hope I was able to explain AES-GCM well enough and that you’ve got a good feel for why resuing a nonce with AES-GCM is such a big deal.</p><p>If you’re interested, the code powering all the interactive widgets here is on GitHub. The factorization algorithms were implemented in <a href="https://github.com/frereit/frereit.github.io/tree/main/wasm/cantor-zassenhaus/src">Rust and built for WebAssembly</a> and all the DOM manipulation and reactiveness was done manually in a <a href="https://github.com/frereit/frereit.github.io/blob/main/static/js/aesgcm_widgets.js">1200 line JavaScript file 😭</a>.</p><p>This blog post was an enormous amount of work, but I hope it was worth it. If you have any questions, comments, or feedback, please don’t hesitate to reach out to me on <a href="https://infosec.exchange/@fre">Mastodon</a>, I’d love to here from you! Also, if you’d like to send some donation my way, don’t. Instead send some feedback my way and some money to the <a href="https://supporters.eff.org/donate/">Electronic Frontier Foundation</a>, <a href="https://archive.org/donate">The Internet Archive</a> or anything, really, that you think is important.</p><p>Lastly, a huge thank you to <a href="https://johannes-bauer.com/">Prof. Dr. Johannes Bauer</a> who very kindly reviewed this blog post and provided me with some valuable feedback. I really appreciate it!</p><p>Thanks again for reading!</p><h2 id="addendum-using-sagemath-to-do-the-heavy-lifting">Addendum: Using SageMath to do the heavy lifting</h2><p>In this blog post, I’ve shown how the square free factorization, the distinct degree factorization, and the Cantor-Zassenhaus algorithms can be used to break AES-GCM. To be able to show you the internals right in your browser, I’ve implemented the algorithms from scratch in <a href="https://github.com/frereit/frereit.github.io/blob/main/wasm/cantor-zassenhaus/src/factorize.rs">Rust</a> but if you actually want to execute this attack in real life, you can use <a href="https://www.sagemath.org/">SageMath</a> to calculate the roots of the polynomial, instead of implementing the algorithms yourself.</p><p>First, setup the <code>GF(2</code><sup><code>128</code></sup><code>)</code> field:</p><pre tabindex="0"><code>&gt;&gt;&gt; F.&lt;a&gt; = GF(2)[]
&gt;&gt;&gt; F.&lt;x&gt; = GF(2^128, modulus=a^128 + a^7 + a^2 + a + 1)</code></pre><p>Then, construct a polynomial ring over this field:</p><pre tabindex="0"><code>&gt;&gt;&gt; R.&lt;H&gt; = PolynomialRing(F)</code></pre><p>If we now want to find the roots of the polynomial <code>H</code><sup><code>2</code></sup><code> + H + 1</code>, we can use the <code>.roots()</code> method:</p><pre tabindex="0"><code>&gt;&gt;&gt; (H^2 + H + 1).roots()
[(x^125 + x^123 + x^120 + x^118 + x^116 + x^115 + x^113 + x^111 + x^110 + x^103 + x^101 + x^100 + x^96 + x^95 + x^94 + x^93 + x^92 + x^90 + x^86 + x^85 + x^84 + x^81 + x^80 + x^76 + x^75 + x^73 + x^71 + x^70 + x^69 + x^68 + x^67 + x^64 + x^62 + x^61 + x^58 + x^57 + x^56 + x^54 + x^53 + x^51 + x^49 + x^47 + x^45 + x^43 + x^42 + x^39 + x^36 + x^35 + x^34 + x^33 + x^32 + x^31 + x^29 + x^26 + x^23 + x^21 + x^20 + x^17 + x^11 + x^9 + x^8 + x^3,
  1),
 (x^125 + x^123 + x^120 + x^118 + x^116 + x^115 + x^113 + x^111 + x^110 + x^103 + x^101 + x^100 + x^96 + x^95 + x^94 + x^93 + x^92 + x^90 + x^86 + x^85 + x^84 + x^81 + x^80 + x^76 + x^75 + x^73 + x^71 + x^70 + x^69 + x^68 + x^67 + x^64 + x^62 + x^61 + x^58 + x^57 + x^56 + x^54 + x^53 + x^51 + x^49 + x^47 + x^45 + x^43 + x^42 + x^39 + x^36 + x^35 + x^34 + x^33 + x^32 + x^31 + x^29 + x^26 + x^23 + x^21 + x^20 + x^17 + x^11 + x^9 + x^8 + x^3 + 1,
  1)]</code></pre><p>This immediately gives us the candidate values for <code>H</code>, no need to jump through any extra hoops. I’ll leave implementing the whole attack in SageMath as an exercise to the reader ;).</p></div></div>
  </body>
</html>
