<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://john-millikin.com/running-sunos-4-in-qemu-sparc">Original</a>
    <h1>Running SunOS 4 in QEMU (Sparc)</h1>
    
    <div id="readability-page-1" class="page"><div posted="2023-04-13T00:50:27Z"><p><a href="https://en.wikipedia.org/wiki/SunOS">SunOS</a> is a historical UNIX operating system widely used from the mid 80s into the early/mid 90s. Older versions of QEMU struggled to emulate the SPARC platform that SunOS ran on, but QEMU v7.2 supports SPARC well enough to install and run SunOS without any unusual workarounds.</p><blog-section><h2 slot="title">Installation media</h2><p>The installation CD-ROM for SunOS 4.1.4 (also branded Solaris 1.1.2) is available on the Internet Archive:</p><ul><li><a href="https://archive.org/details/solaris112sparc">Solaris v1.1.2 SPARC (704-4662-10)</a> (uploaded 2019-09-23)</li></ul><p>You might also want a dump of the SparcStation 5 boot PROM. QEMU&#39;s bundled OpenBIOS is capable of booting SunOS, but the original PROM is useful for people who want a more authentic emulation experience.</p><ul><li><a href="https://github.com/andarazoroflove/sparc/raw/master/ss5.bin">https://github.com/andarazoroflove/sparc/raw/master/ss5.bin</a></li><li><a href="http://vtda.org/bits/ROMs/Sun/ss5.bin">http://vtda.org/bits/ROMs/Sun/ss5.bin</a></li></ul><blog-code syntax="commands"><pre>shasum -a 256 *
# 559c8455918029ffdaaf9890caf9f791c3a3604d2f2158793751b770593c0a3c  SunOS-v4.1.4.iso
# e7f40845504c65f4011278aa3e97a9810aa36775e6c199b715839fbc25eec45e  ss5.bin</pre></blog-code></blog-section><blog-section><h2 slot="title">Preparing the SunOS mini-root</h2><p>The first stage of the SunOS installation process is to prepare a minimal bootable environment.</p><p>SunOS is designed to run on Sun&#39;s hardware, so it&#39;s relatively fussy about device layout and configuration compared to an OS intended for consumer hardware. The <a href="https://docs.oracle.com/cd/E19127-01/sparc5.ws/801-6396-11/801-6396-11.pdf">SPARCstation 5 Service Manual</a> is a useful reference.</p><ul><li>The internal HDD must have SCSI target 3, and the internal CD-ROM must have SCSI target 6.</li><li>SunOS expects the CD-ROM to have a physical block size of 512 bytes<blog-footnote-ref>[<a href="#fn:1">1</a>]</blog-footnote-ref>.</li><li>Although a real SPARCstation 5 supports up to 256 MiB of RAM, we&#39;ll be giving it only 64 MiB to simplify the installation process<blog-footnote-ref>[<a href="#fn:2">2</a>]</blog-footnote-ref></li></ul><p>Leave off the <tt>-bios ss5.bin</tt> line to use QEMU&#39;s built-in OpenBIOS.</p><blog-code syntax="commands"><pre>qemu-system-sparc -version
# QEMU emulator version 7.2.1
# Copyright (c) 2003-2022 Fabrice Bellard and the QEMU Project developers
qemu-img create -f qcow2 sunos-hdd.img 2G
# Formatting &#39;sunos-hdd.img&#39;, fmt=qcow2 cluster_size=65536 extended_l2=off compression_type=zlib size=2147483648 lazy_refcounts=off refcount_bits=16
qemu-system-sparc \
#    -machine SS-5 \
#    -m 64 \
#    -bios ss5.bin \
#    -drive file=sunos-hdd.img,bus=0,unit=3,media=disk \
#    -device scsi-cd,channel=0,scsi-id=6,id=cdrom,drive=cdrom,physical_block_size=512 \
#    -drive if=none,file=SunOS-v4.1.4.iso,media=cdrom,id=cdrom</pre></blog-code><p>Once at the firmware prompt, type <tt>boot cdrom</tt> (or <tt>boot cdrom:d</tt> for OpenBIOS).</p><p><img src="https://john-millikin.com/by-sha256/f930483c3271679e40e7bffada5f4646116db225bc417d4812a6ef875af0a977/first-boot-ss5.png"/></p><p><img src="https://john-millikin.com/by-sha256/98b29c99084ae8449ff4eefbcf32311fcfa6e552bde34a7f09c76fa1a16bf64f/first-boot-install-prompt.png"/></p><p>In the disk formatter, select disk type 13 (<tt>SUN2.1G</tt>), write the label to disk, then quit the formatting utility.</p><p><img src="https://john-millikin.com/by-sha256/a30764a4ca8e8bbc4a5e0b288db6f0142382d63cbdf6eb0544d0fd3945b8c2b2/first-boot-format-prompt.png"/></p><p><img src="https://john-millikin.com/by-sha256/ef9f1fb5d3f80f8bb4289f48bc07be18033c9e71b39ed9f46ac062cf6f7f3f12/first-boot-format-done.png"/></p><p>The installation script will prep the disk for the main installer, then prompt for a reboot.</p><p>If using OpenBIOS, the VM might not boot into mini-root by itself. Type <tt>boot disk0:b -sw</tt> at the firmware prompt to continue.</p></blog-section><blog-section><h2 slot="title">Installing SunOS itself</h2><p>After rebooting, you should see some logspam and a root prompt. Run <tt>suninstall</tt> to continue the installation process.</p><p><img src="https://john-millikin.com/by-sha256/f3585168e7aeb2ee9b693b31e1d0de050d503cd760f8035e42de0cf89a70d41c/second-boot-root-prompt.png"/></p><p>There&#39;s no complicated decisions to make here, so I just went with the quick install of the full system.</p><p><img src="https://john-millikin.com/by-sha256/393e961d7bb01c02dd152de851aa78978d185f66083ba9b1ee4dfcf92a8aa76a/suninstall-standard-installations.png"/></p><p>After the installation is finished the VM will reboot and you&#39;ll be back at the firmware prompt. Type <tt>boot disk</tt> (or <tt>boot disk3:a</tt> for OpenBIOS) to boot.</p><p>In its original environment, a new SunOS workstation would have received its network configuration from <a href="https://en.wikipedia.org/wiki/Reverse_Address_Resolution_Protocol">RARP</a> (the predecessor of DHCP) and <a href="https://en.wikipedia.org/wiki/Network_Information_Service">NIS</a> (sort of a proto-LDAP). Since we don&#39;t have a lab of 100 workstations to provision, manual data entry is fine.</p><p><img src="https://john-millikin.com/by-sha256/037a765488c67be16f8cb64c5575e449ac394867d59e21b2ffbf82886575b25e/system-setup.png"/></p><p><img src="https://john-millikin.com/by-sha256/0b4bcf9df79e25fb89551d9234442ac64273ea13ecc4fd14f1dc6e00edd45899/manual-setup.png"/></p><p>The default IP address for QEMU&#39;s usermode networking is 10.0.2.15, for which SunOS will assign a netmask of 0xFF000000<blog-footnote-ref>[<a href="#fn:3">3</a>]</blog-footnote-ref>.</p><p><img src="https://john-millikin.com/by-sha256/3fbf9a8bb6f06ebac21fc433ec382219e6f84abf889dd44ea18fbe343f775183/network-setup.png"/></p><p><q>A password should be six to eight characters long</q> ðŸ”’.</p><p><img src="https://john-millikin.com/by-sha256/9f644a2579a79206fb8848c748ab0b6331a00e26d3fbd5edced4a41684897e85/root-password.png"/></p><p>Almost done. The last step is to configure the gateway router, and then the VM will have working networking. Just log in as root, set the gateway address, and write it to <tt>/etc/defaultrouter</tt> so it&#39;ll persist across reboots.</p><p><img src="https://john-millikin.com/by-sha256/f332958b7f1abf3eb611ffa455a683ae47d366143c4c14bd1fd65c077468c274/default-route-ping.png"/></p><p>Log in as a non-root user to launch the native graphical UI of SunOS, OpenWindows.</p><p><img src="https://john-millikin.com/by-sha256/d21350fcf093cda00d40f26bfa28ae0cdc63c0741e4b77d93538dd1f23603d48/openwindows.png"/></p></blog-section><blog-section><h2 slot="title">Installing a web browser (Netscape)</h2><p>The final version of SunOS was released when the Web was in its infancy, and therefore does not have a bundled web browser (or any sort of HTTP-related utilities). Luckily for us SunOS/SPARC was a popular platform and Netscape published binaries for it. Actually <i>finding</i> those binaries was a bit of a slog, but I eventually located a copy of Netscape Communicator v4.61 on the delightfully retro page <a href="http://www.floodgap.com/retrobits/solace/">The Solbourne Solace @ Floodgap Retrobits</a> (<a href="https://web.archive.org/web/20230325091337/http://www.floodgap.com/retrobits/solace/">archive</a>).</p><p>In the least surprising twist ever, the tarball itself is only available via Gopher, at <a href="gopher://gopher.floodgap.com/9/archive/sunos-4-solbourne-os-mp/communicator-v461-us.sparc-sun-sunos4.1.3_U1.tar.gz">gopher://gopher.floodgap.com/9/archive/sunos-4-solbourne-os-mp/communicator-v461-us.sparc-sun-sunos4.1.3_U1.tar.gz</a>. I have mirrored it to archive.org at <a href="https://archive.org/details/netscape-communicator-v461-us.sparc-sun-sunos4.1.3_U1">Netscape Communicator 4.61 [SunOS 4.1.3]</a>.</p><p>In any case, once you&#39;ve obtained a copy of the Netscape installation package you&#39;ll find that it needs gzip, which at the time was a GNU-specific technology. I recommend following the manual installation instructions from <tt>README.install</tt> on your host machine to produce a plain tarball.</p><blog-code syntax="commands"><pre>shasum -a 256 communicator-v461-us.sparc-sun-sunos4.1.3_U1.tar.gz
# c667feb3a73721872d60ffd4aab24e39be8d5a48761397b4dd2184b4dd2bb5de  communicator-v461-us.sparc-sun-sunos4.1.3_U1.tar.gz
tar -xf communicator-v461-us.sparc-sun-sunos4.1.3_U1.tar.gz
cd communicator-v461.sparc-sun-sunos4.1.3_U1/
mkdir -p netscape-v4.61/java/classes
mv *.nif netscape-v4.61/
mv *.jar netscape-v4.61/java/classes/
cd netscape-v4.61/
gzip -dc netscape-v461.nif | tar -xf -
gzip -dc nethelp-v461.nif | tar -xf -
gzip -dc spellchk-v461.nif | tar -xf -
cd ..
tar -cf ../netscape-v4.61.tar netscape-v4.61/</pre></blog-code><p>Getting that tarball into the VM is also a little tricky due to the lack of common network protocols between 1994 and 2023. I ended up writing a helper (<a href="#recv-c">recv.c</a>) that will connect to a TCP socket and stream any data it receives to a file.</p><blog-code syntax="commands"><pre># # host
nc -Nl 127.0.0.1 5000 &lt; netscape-v4.61.tar</pre></blog-code><blog-code syntax="commands" prompt="%"><pre># # VM
cc -o recv recv.c
./recv 10.0.2.2:5000 netscape-v4.61.tar</pre></blog-code><p>Unpack that tarball, write a wrapper script and a stub <tt>/etc/resolv.conf</tt>, and Netscape is ready to go.</p><blog-code syntax="commands" prompt="%"><pre>cat /etc/resolv.conf
# domain sunos.local
# nameserver 10.0.2.3
cat ~/netscape.sh
# #!/bin/sh
# XNLSPATH=&#34;${HOME}/netscape-v4.61/nls&#34;
# XKEYSYMDB=&#34;${HOME}/netscape-v4.61/XKeysymDB&#34;
# export XNLSPATH XKEYSYMDB
# exec &#34;${HOME}/netscape-v4.61/netscape_dns&#34; &#34;$@&#34;</pre></blog-code><p><img src="https://john-millikin.com/by-sha256/6be1f117f67e6cc235088f2788b3542c767e99f3fb5eaba695e38ee717480695/netscape.png"/></p></blog-section><blog-section id="recv-c"><h2 slot="title">Appendix A: recv.c</h2><p>This should be fairly readable despite being written in K&amp;R C; the BSD sockets API hasn&#39;t changed much.</p><p>If you don&#39;t want to type the whole thing in by hand, see the next section about X11 forwarding.</p><blog-code syntax="c"><pre>#include &lt;arpa/inet.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;netdb.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int split_server_address(server_address, server_ip, server_port)
	char *server_address;
	unsigned long *server_ip;
	unsigned short *server_port;
{
	char *port_str, *port_extra;
	long port_raw;

	port_str = strchr(server_address, &#39;:&#39;);
	if (port_str == NULL) {
		return -1;
	}
	*(port_str++) = 0;

	*server_ip = inet_addr(server_address);
	if (*server_ip == -1) {
		return -1;
	}

	port_raw = strtol(port_str, &amp;port_extra, 10);
	if (port_raw &lt; 1 || port_raw &gt; 65535) {
		return -1;
	}
	if (*port_extra != 0) {
		return -1;
	}
	*server_port = port_raw;

	return 0;
}

int recv_file(server_ip, server_port, output_path)
	unsigned long server_ip;
	unsigned short server_port;
	char *output_path;
{
	int socket_fd, output_fd;
	struct sockaddr_in server;
	char buffer[2048];

	socket_fd = socket(AF_INET, SOCK_STREAM, 0);
	if (socket_fd == -1) {
		return -1;
	}

	memset(&amp;server, 0, sizeof server);
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = server_ip;
	server.sin_port = htons(server_port);

	if (connect(socket_fd, (struct sockaddr*)&amp;server, sizeof server) == -1) {
		return -1;
	}

	output_fd = open(output_path, O_WRONLY | O_CREAT, 0600);
	if (output_fd == -1) {
		return -1;
	}

	while (1) {
		int n = read(socket_fd, buffer, sizeof buffer);
		if (n == -1) {
			close(output_fd);
			return -1;
		}
		if (n == 0) {
			return close(output_fd);
		}
		write(output_fd, buffer, n);
	}
}

int main(argc, argv)
	int argc;
	char **argv;
{
	unsigned long server_ip;
	unsigned short server_port;

	if (argc &lt; 3) {
		fprintf(stderr, &#34;Usage: %s &lt;server_address&gt; &lt;output_path&gt;\n&#34;, argv[0]);
		return 1;
	}

	if (split_server_address(argv[1], &amp;server_ip, &amp;server_port) == -1) {
		fprintf(stderr, &#34;Invalid server address \&#34;%s\&#34;\n&#34;, argv[1]);
		return 1;
	}

	if (recv_file(server_ip, server_port, argv[2]) == -1) {
		perror(&#34;Error receiving file&#34;);
		return 1;
	}

	return 0;
}
</pre></blog-code></blog-section><blog-section><h2 slot="title">Appendix B: X11 forwarding</h2><p>The experience of interacting with a GUI from 1994 via QEMU&#39;s console is not great, so I recommend running an X11 server on your host and having the VM connect to it.</p><p>If you&#39;re already running an X11-based desktop (BSD, older Linux, macOS with XQuartz<blog-footnote-ref>[<a href="#fn:4">4</a>]</blog-footnote-ref>) then you can proxy its socket directly to TCP and then connect to it from the VM. This will let you copy-paste big blobs of text such as <a href="#recv-c">recv.c</a>.</p><blog-code syntax="commands"><pre># # host
socat TCP-LISTEN:6001,fork,bind=127.0.0.1 UNIX-CONNECT:/tmp/.X11-unix/X0</pre></blog-code><blog-code syntax="commands" prompt="%"><pre># # VM
setenv DISPLAY 10.0.2.2:1
xterm</pre></blog-code><p>Alternatively, use a nested X11 server such as Xnest or Xephyr. You&#39;ll be able to run the OpenWindows window manager, so it feels a bit like using VNC.</p><blog-code syntax="commands"><pre># # host
Xephyr -ac -listen tcp -screen 2048x1536 :1</pre></blog-code><blog-code syntax="commands" prompt="%"><pre># # VM
setenv DISPLAY 10.0.2.2:1
olwm</pre></blog-code><p><a href="https://john-millikin.com/by-sha256/697985b5647b1048a4e17dd888d0dd5b1dee3d18ce336dc3fb1dad39b5209daf/xephyr.png"><img src="https://john-millikin.com/by-sha256/697985b5647b1048a4e17dd888d0dd5b1dee3d18ce336dc3fb1dad39b5209daf/xephyr.png"/></a></p><p>If <tt>olwm</tt> segfaults on startup, make sure that the host machine has the legacy X11 fonts installed. In Ubuntu 22.04 I had to install the <tt>xfonts-100dpi</tt> package.</p></blog-section><blog-footnotes><hr/><ol><li id="fn:1"><p>Nowadays the physical block size for CD-ROMs is 2048 bytes, but in the 90s this value wasn&#39;t standardized yet. Consumer CD-ROM drives had a physical jumper on the back that could select the block size, and some OSes (including SunOS) would encounter read errors if the jumper wasn&#39;t set to what they expected.</p></li><li id="fn:2"><p>SunOS requires a swap partition that is at least as large as machine memory, and the default swap partition size for <tt>SUN2.1G</tt> is 100 MiB. Using 64 MiB lets us avoid fiddling with the disk geometry in the formatting tool.</p></li><li id="fn:3"><p>SunOS pre-dates CIDR, so it thinks of all 10.x.x.x addresses as belonging to the 10.0.0.0/8 &#34;Class A&#34; network. This is technically wrong for QEMU, which by default uses a netmask of 0xFFFFFF00, but it doesn&#39;t really matter as long as you don&#39;t try to do anything too complicated with multi-VM networking.</p></li><li id="fn:4"><p>Note that the default socket path for XQuartz may contain a colon, which will make socat unhappy because it uses colons as part of its option syntax. You can work around this with a symlink.</p></li></ol></blog-footnotes></div></div>
  </body>
</html>
