<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ntietz.com/blog/rust-vim-workflow-2022/">Original</a>
    <h1>Working with Rust in (neo)vim</h1>
    
    <div id="readability-page-1" class="page"><article>
    

    <p><strong>Friday, December 16, 2022</strong></p>

    <p>I&#39;ve been using vim for nearly as long as I&#39;ve been writing code.
My first introduction to it was being thrown in the deep end in 2009 by my Intro to CS lab assistant, who told us to write our programs using vi on the department servers.
Why he told us that, I have no idea.
But I got used to switching into and out of insert mode, and also how to save and quit.</p>
<p>At my internship in 2011, I learned to use vim in earnest.
The project I worked on thrashed system memory by running HBase in a test suite over and over, and my work would routinely crash Eclipse as a result.
I don&#39;t remember if my mentor suggested it or if I used vim on my own, but he did encourage it.
He urged me to learn <em>proper</em> vim and disable the arrow keys to get used to navigating with the <code>hjkl</code> keys.
That got me to learn it quickly through immersion and I fell in love.</p>
<p>Now vim is how I think about text editing, so I&#39;m mired in it.
I&#39;m not leaving vim if I can help it, so I&#39;ve figured out how to use it effectively for the development I&#39;m doing.
And these days, that&#39;s Rust as often as I can justify it!</p>
<p>I used to use vim in a pretty bare-bones fashion, but I&#39;ve slowly been layering in more plugins.
(Still far fewer than some people I know, but it cannot be described as a minimalist setup.)
One of my batchmates at Recurse Center is a vim aficionado and helped me get a really snazzy setup.</p>
<p>All told, I think vim provides an amazing editing experience for Rust (and in general).
This is how I develop Rust in vim!</p>

<p>First let&#39;s look at what plugins are installed.
(This is all in my <a href="https://git.sr.ht/%7Entietz/config/">public config repo</a>.)</p>
<p>Some general development quality of life ones:</p>
<ul>
<li><a href="https://github.com/preservim/nerdtree">nerdtree</a> for file navigation.</li>
<li><a href="https://github.com/junegunn/fzf.vim">fzf</a> for searching for files by name or content</li>
<li><a href="https://github.com/tpope/vim-obsession">obsession</a> for saving and resuming sessions more easily</li>
<li><a href="https://github.com/editorconfig/editorconfig-vim">editorconfig</a> to setup spaces/tabs etc. based on the current project</li>
</ul>
<p>The Rust-specific ones are:</p>
<ul>
<li><a href="https://github.com/simrat39/rust-tools.nvim">rust-tools</a> to setup the Rust LSP automatically for you</li>
<li><a href="https://github.com/neovim/nvim-lspconfig">nvim-lspconfig</a> for configuring neovim&#39;s LSP (<code>rust-tools</code> depends on this one)</li>
<li><a href="https://github.com/hrsh7th/nvim-cmp">nvim-cmp</a>, <a href="https://github.com/hrsh7th/cmp-nvim-lsp">cmp-nvim-lsp</a>, and <a href="https://github.com/hrsh7th/cmp-buffer">cmp-buffer</a> for completions</li>
</ul>

<p>It&#39;s hard to describe a coding workflow through just prose, so I&#39;ll use some examples.
These are some of the things I run into every day while writing Rust.</p>
<p>The overall workflow is probably familiar to terminal-dwellers, but is different from what IDE-users do.
Where an IDE contains all the things (you run your terminal, your tests, your text editor, all in one place!), that&#39;s what <a href="https://en.wikipedia.org/wiki/Tmux">tmux</a> does for me.
When I sit down to code, I start a new tmux session with a window for git commits/logs, another for my editor, and usually another for my tests.</p>
<p>Once I have my editor and test watcher going, the general workflow is:</p>
<ul>
<li>Write some code in vim, ideally with tests</li>
<li>Check on the build/tests, iterate until it passes</li>
<li>Check <a href="https://github.com/rust-lang/rust-clippy">clippy</a> for any lints</li>
<li>Write a messy commit message</li>
<li>Repeat until I have a unit I want to merge</li>
<li>Push it my git forge, and squash/merge when CI passes</li>
</ul>
<p>A lot of this workflow is not unique at all to vim, tmux, or any of the other tools—it&#39;s just plain software engineering.
I think the more interesting things are how I do some specific things while using vim.</p>
<p><strong>Opening a file.</strong>
The scenario is I know that a file exists with some code I want to modify.
If I know the name of the file, I usually use fzf (bound to <code>control-f</code>) to search by filename and open it directly.
On days when I want to do some sightseeing (more common for codebases I&#39;m not as familiar with, to stumble upon things), I&#39;ll navigate through the file tree from nerdtree, but this is rare these days.
And in the cases where I don&#39;t even know the name of the file, but just something in it, I use ripgrep (bound on <code>control-g</code>) to search through the file tree to find any files which have that content!
The beautiful preview panes are a big help in finding things easily.</p>
<p><img src="https://there.oughta.be/images/vim-2022/vim-fzf.png" alt="Screenshot of the vim text editor showing file search with fzf"/></p>
<p><strong>Creating a new file.</strong>
This is where I turn to the trusty friend, nerdtree.
(Usually. There are tricks to make this faster with the Rust tooling.)
I open up nerdtree, navigate to where I want the new file, and enter a name.
This is the same for moving or renaming files.</p>
<p><img src="https://there.oughta.be/images/vim-2022/nerdtree-make-file.png" alt="Screenshot of the vim text editor showing file operations with nerdtree"/></p>
<p><strong>Writing code.</strong>
This one is pretty common, so I won&#39;t spend a lot of time on it.
I write code in the idiomatic vim way (I think?), and I don&#39;t do anything particularly unusual with it.
I do avoid certain things (code folding) which I find confuse me more than help me.
I just keep it simple as much as I can, and spend complexity points on the <em>really</em> valuable things.</p>
<p><strong>Formatting code.</strong>
This is one where I lean on the Rust tools!
I have bound <code>control-f</code> to run the formatter.
This is a good balance:
It doesn&#39;t run automatically (it&#39;s jarring when things change out from under me), but it is also so easy to do that I do it often.
It&#39;s a great part of my workflow!
I can write something with odd formatting, then hit <code>control-f</code> and *boom* it&#39;s pretty.</p>

<p>One of my favorite things now is using code actions (provided by Rust&#39;s LSP and the neovim integration).
They let me make a lot of common actions faster, and are especially powerful combined with Rust&#39;s type system!</p>
<p><strong>Create missing files.</strong>
From the above section you can probably tell that creating a file was one of my slower manual actions.
Searching for files: super fast!
Making a new one: manual and slow.
This is a little bit easier with code actions.
I just refer to the file (usually <code>use my_new_module;</code> or something in <code>lib.rs</code>), then I press <code>\a</code> and a code action is available to create the missing module!</p>
<p><img src="https://there.oughta.be/images/vim-2022/code-actions-1.png" alt="Screenshot of the vim text editor showing a code action to generate a missing module file"/></p>
<p><strong>Generate missing methods.</strong>
This is similar to the above.
My old workflow was often to think about what method I would need and write that (at least a stub with a <code>todo!()</code> inside of it) that I would then use in another place.
That would get the fewest compiler errors as I went.
With code actions, that&#39;s flipped on its head:
I first write the places where I <em>use</em> the method, then I let it generate the missing method.
The advantage of working this way is that it can usually write the entire type signature for me, since Rust has a strong type system and there&#39;s a lot of information to power its guesses.
(If it can&#39;t guess correctly, it does something conservative, like leaves a hole for the type.)</p>
<p><strong>Generate required members for a trait impl.</strong>
Oh yeah, no more looking up the docs to know what I need to impl a trait.
I can just make the computer do that work for me.
This is really handy for things like <code>std::fmt::Display</code> where I might not remember the exact type signature, and even more so for things like <code>IntoIterator</code> where there are also types I have to define inside the impl block.</p>
<p><img src="https://there.oughta.be/images/vim-2022/code-actions-2.png" alt="Screenshot of the vim text editor showing a code action to generate the required methods for a trait"/>
<img src="https://there.oughta.be/images/vim-2022/code-actions-3.png" alt="Screenshot of the vim text editor showing the methods generated by the code action"/></p>
<p><strong>Generate missing match arms.</strong>
This one is probably my favorite.
One of the great things about Rust is that you can ensure that matches on enums are total:
All the cases are covered.
And with that, you can also generate stubs for the cases which are <em>not</em> covered!
This works basically like generating the trait impl stubs, but also will add missing match arms for a match block you already have.
It&#39;s huge, and it&#39;s the code action I use the most every day.</p>
<p><strong>Even more code actions!</strong>
I&#39;m sure there are more super valuable Rust code actions.
One that my friend uses a lot is extracting some code into a separate function.
I don&#39;t use that one much as it doesn&#39;t seem to fit my workflow, but I might have to try it out—he&#39;s been right about a lot of other workflow improvements so far!
If you know of anything else I should try, please reach out and let me know!</p>
<hr/>





  </article></div>
  </body>
</html>
