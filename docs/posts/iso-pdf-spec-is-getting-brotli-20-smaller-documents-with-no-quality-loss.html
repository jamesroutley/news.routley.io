<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pdfa.org/want-to-make-your-pdfs-20-smaller-for-free/">Original</a>
    <h1>ISO PDF spec is getting Brotli ‚Äì ~20 % smaller documents with no quality loss</h1>
    
    <div id="readability-page-1" class="page"><div><p>For nearly three decades; or November 1996 to be exact, PDFs have relied on Deflate‚Äîthe same compression algorithm that powers your ZIP files. Meanwhile, the web moved on. In 2015, Google introduced Brotli, a compression algorithm so efficient it now powers 95% of internet traffic. Websites got faster. Downloads got smaller. CDNs got cheaper.</p>
<p><strong>Now PDFs are getting the same upgrade.</strong></p>
<p>The PDF Association is bringing this battle-tested web compression technology <a href="https://pdfa.org/brotli-compression-coming-to-pdf/">into the PDF specification</a> itself. After a decade of Brotli proving its worth across billions of web requests daily, it&#39;s now getting ready to make it&#39;s introduction into ISO 32000.</p>
<p>With <a href="https://pdfa.org/member/itext-group-nv/">iText</a>, we can help drive widespread adoption with a <strong>production-ready Brotli encoder and decoder</strong> for the PDF ecosystem. The result? <strong>15-25% smaller files</strong> with zero quality loss, using the same algorithm trusted by Google, Cloudflare, and every major CDN.</p>
<h2 id="why-pdf-compression-has-struggled-to-evolve">Why PDF compression has struggled to evolve</h2>
<p>PDF compression has been stuck in 1996 for a good reason: <strong>backward compatibility is sacred</strong>. The PDF Association operates under a strict principle‚Äîany new feature must work seamlessly with existing readers, or it risks fragmenting the ecosystem. Adding a new compression algorithm isn&#39;t just a technical change; it&#39;s a <em>breaking change</em> that could render documents unreadable in older software. This creates a high barrier for innovation.</p>
<p>Beyond compatibility concerns, there are other practical challenges. The PDF specification moves slowly by design‚Äîit&#39;s an ISO standard that requires consensus by hundreds of stakeholders. Compression algorithms must be <strong>royalty-free</strong> (ruling out patented options), <strong>widely supported</strong> across platforms, and <strong>battle-tested</strong> in production.</p>
<p>Finally, the ecosystem is conservative: enterprises and governments rely on PDFs for archival and legal documents that must remain accessible for decades, making any breaking change a risk that needs extraordinary justification.</p>
<h2 id="encoding-and-decoding-technical-implementation">Encoding and decoding: Technical implementation</h2>
<p>To get Brotli compression working within the iText SDK, we need to solve two problems: reading documents, and also writing them.</p>
<p>Let&#39;s start with the easiest one; reading documents.</p>
<h3>Decoding: Advanced plumbing work</h3>
<p>First of all, let&#39;s look at how the content of a page is stored within a PDF. We can demonstrate this with just the classic &#34;Hello World&#34; text example.</p>
<p>The following PDF syntax simply displays the text &#34;Hello World!&#34; on a page:</p>
<pre>5 0 obj                 % Unique identifier to reference this content from other places within the PDF
&lt;&lt;/Length 49&gt;&gt;stream    % Meta data for the stream object. Here it contains a Length value to indicate how many bytes are there after the `stream` keyword.
q                       % the actual content
BT
/F1 12 Tf
37 788.33 Td
(Hello World!)Tj
ET
Q
endstream               % Indicates the end of the stream object
endobj                  % Indicates the end of the referenceable object
</pre>
<p>So, if we need to render or do anything else with the content, it would look like the following:</p>
<pre>|------------------------|
| Get stream based on id |
|------------------------|
           ||
           \/
|------------------------|
|      Read content      |
|------------------------|
           ||
           \/
|------------------------|
|    Render/Do stuff     |
|    with the content    |
|------------------------|
</pre>
<p>Okay, so now we have a high-level view how PDF processors handle the low-level processing of those stream objects, we can dive a little deeper!</p>
<p>Let&#39;s take a look at the following PDF stream object where the content is encoded using the Deflate algorithm.</p>
<pre>5 0 obj
&lt;&lt;/Filter/FlateDecode/Length 36&gt;&gt;stream                  % The meta data now now includes `Filter`
x≈ìm¬è√ç√Ç0‚Äû√Ø√ª√´M/1?√Ül¬Æ‚Äö√¢U√∏mI)√ç√ª¬∫m¬¢...            % Reduced for clarity
endstream
endobj
</pre>
<p>First of all, we notice there is an additional Key <code>Filter</code> with a value of <code>FlateDecode</code> in the metadata.</p>
<p>So how does this change our working implementation?</p>
<pre>|------------------------|
| Get stream based on id |
|------------------------|
           ||
           \/
|------------------------|
|      Read content      |
|------------------------|
           ||
           \/
|------------------------|
|         Decode         |
|     based on Filter    |
|------------------------|
           ||
           \/
|------------------------|
|    Render/Do stuff     |
|    with the content    |
|------------------------|
</pre>
<p>We can now see we require an operation on the content before it&#39;s usable. The PDF specification already provides a variety of ways to write the content of the PDF streams.</p>
<table>
<tbody>
<tr>
<td><strong>Filter name</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>ASCIIHexDecode</td>
<td>Decodes ASCII hexadecimal data to binary.</td>
</tr>
<tr>
<td>ASCII85Decode</td>
<td>Decodes ASCII base-85 data to binary.</td>
</tr>
<tr>
<td>LZWDecode</td>
<td>Decompresses data using LZW compression.</td>
</tr>
<tr>
<td>FlateDecode</td>
<td>Decompresses data using zlib/deflate compression.</td>
</tr>
<tr>
<td>RunLengthDecode</td>
<td>Decompresses data using run-length encoding.</td>
</tr>
<tr>
<td>CCITTFaxDecode</td>
<td>Decompresses CCITT fax-encoded monochrome images.</td>
</tr>
<tr>
<td>JBIG2Decode</td>
<td>Decompresses JBIG2-encoded monochrome image data.</td>
</tr>
<tr>
<td>DCTDecode</td>
<td>Decompresses JPEG DCT-based image data.</td>
</tr>
<tr>
<td>JPXDecode</td>
<td>Decompresses JPEG 2000 wavelet-based image data.</td>
</tr>
<tr>
<td>Crypt</td>
<td>Decrypts data encrypted by a security handler.</td>
</tr>
</tbody>
</table>
<p>So the idea for Brotli is to simply add another <code>Filter</code> implementation.What we need to get it working into iText is actually pretty minimal:</p>
<ol>
<li>Get the decoding implementation from Google&#39;s repository.</li>
<li>Write some plumbing code to call it from iText</li>
<li>Hook up the plumbing code to the <code>BrotliDecode</code> filter</li>
</ol>
<p>For the first step we simply embedded <strong>Google&#39;s reference Java Brotli decoder</strong> straight from their official repository into our kernel module.</p>
<h4>Why embed the decoder?</h4>
<p>By embedding Google&#39;s reference implementation directly, we guarantee:</p>
<ul>
<li><strong>Zero dependency hell</strong>: No version conflicts with other libraries</li>
<li><strong>Consistent behavior</strong>: Same decoder on all platforms</li>
<li><strong>Long-term stability</strong>: We control the code, even if upstream changes</li>
<li><strong>Automatically generate C# version</strong>: Using our porting mechanism we can have a C# implementation</li>
</ul>
<p>The plumbing implementation lives in <code>BrotliFilter.java</code>, which plugs into iText&#39;s existing filter pipeline:</p>
<pre>public class BrotliFilter extends MemoryLimitsAwareFilter {
    @Override
    public byte[] decode(byte[] b, PdfName filterName, PdfObject decodeParams,
            PdfDictionary streamDictionary) {
        try {
            final byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
            final ByteArrayInputStream input = new ByteArrayInputStream(b);
            final ByteArrayOutputStream output = enableMemoryLimitsAwareHandler(streamDictionary);
            final BrotliInputStream brotliInput = new BrotliInputStream(input);
            int len;
            while ((len = brotliInput.read(buffer, 0, buffer.length)) &gt; 0) {
                output.write(buffer, 0, len);
            }
            brotliInput.close();
            return output.toByteArray();
        } catch (IOException e) {
            throw new PdfException(KernelExceptionMessageConstant.FAILED_TO_DECODE_BROTLI_STREAM, e);
        }
    }
}
</pre>
<p>Let&#39;s break down what&#39;s happening in this implementation:</p>
<ul>
<li><strong>Memory Safety First</strong>: The filter extends <code>MemoryLimitsAwareFilter</code>, which protects against decompression</li>
<li><strong>Wrapped Input Stream</strong>: The compressed bytes <code>b</code> are wrapped in a <code>ByteArrayInputStream</code>, which is then passed to</li>
</ul>
<p>As you can see, writing the plumbing code is pretty easy because of iText&#39;s architecture.</p>
<p>The last thing to do is to ensure iText knows which implementation to associate with the <code>/BrotliDecode</code> filter.</p>
<p>This is also pretty trivial. The filter is registered automatically in <code>FilterHandlers.java</code> alongside <code>/FlateDecode</code> and the other standard PDF</p>
<pre>public final class FilterHandlers {
    private static final Map&lt;PdfName, IFilterHandler&gt; defaults;

    static {
        Map&lt;PdfName, IFilterHandler&gt; map = new HashMap&lt;&gt;();

        map.put(PdfName.FlateDecode, new FlateDecodeFilter());
        map.put(PdfName.Fl, new FlateDecodeFilter());
        //other implementations removed for clarity

        // we add our implementation
        map.put(PdfName.BrotliDecode, new BrotliFilter());

        defaults = Collections.unmodifiableMap(map);
    }
}
</pre>
<p>That&#39;s it. From this point on, <strong>any PDF with <code>/BrotliDecode</code> streams just works</strong>. No configuration needed.</p>
<p>Now we could have stopped here‚Äîour SDK could process Brotli-compressed PDFs from other sources. But reading isn&#39;t enough. To truly bring Brotli to the PDF ecosystem, we needed to let developers create these smaller files. That meant solving the encoding problem.</p>
<p>And encoding turned out to be significantly more complex than decoding.</p>
<h3>Encoding: a separate module for compression</h3>
<h4>The problem: iText‚Äôs compression was hardcoded</h4>
<p>Before Brotli, iText only supported two compression modes for PDF streams:</p>
<ol>
<li><strong>Flate compression</strong></li>
<li><strong>No compression</strong></li>
</ol>
<p>This logic was baked directly into the stream-writing code‚Äîthere was no abstraction, no plugin point. If you wanted to use a different compression algorithm, you were out of luck.</p>
<p>To support Brotli (and future algorithms), we needed to <strong>introduce a new abstraction layer</strong>: <code>IStreamCompressionStrategy</code>.</p>
<pre>public interface IStreamCompressionStrategy {
   /**
    * Gets the PDF filter name that identifies this compression algorithm.
    *
    * @return the PDF name representing the compression filter
    */
   PdfName getFilterName();

   /**
    * Gets the decode parameters required for decompressing the stream.
    * &lt;p&gt;
    * Decode parameters provide additional information needed to correctly
    * decompress the stream data.
    *
    * @return the decode parameters as a PDF object, or {@code null} if not needed
    */
   PdfObject getDecodeParams();

   /**
    * Creates a new output stream that wraps the original stream and applies compression.
    * @param original the original output stream to wrap
    * @param stream the PDF stream being compressed (may be used for context or configuration)
    *
    * @return a new output stream that performs compression
    */
    OutputStream createNewOutputStream(OutputStream original, PdfStream stream);
}
</pre>
<p>This interface decouples compression logic from iText&#39;s core PDF writing machinery. Now, instead of hardcoding Flate everywhere, we can inject different strategies at runtime. To inject the required strategy we make use of the <code>DiContainer</code>. You can find more information about it here: <a href="https://kb.itextpdf.com/itext/adding-dependency-injection-to-the-pdfdocument-cla" target="_blank" rel="noopener">Adding Dependency Injection to the PdfDocument class</a>.</p>
<p>From now on when iText needs to compress a stream, it asks the <code>DiContainer</code> in the <code>PdfDocument</code>: <em>&#34;Do you have an IStreamCompressionStrategy?&#34;</em></p>
<ul>
<li><strong>If yes</strong>: Use the registered strategy (Brotli in this case)</li>
<li><strong>If no</strong>: Fall back to the default Flate compression</li>
</ul>
<p>This design gives us:</p>
<ul>
<li><strong>Zero coupling</strong>: iText Core no longer cares about the algorithm used</li>
<li><strong>Opt-in behavior</strong>: You only pay the cost if you use it</li>
<li><strong>Future-proof</strong>: New algorithms just implement the interface</li>
</ul>
<h4>The Second Problem: No Pure Java Encoder</h4>
<p>Here&#39;s where things got tricky. While Google&#39;s Brotli decoder has a pure Java implementation (which we embedded for reading), the official Brotli <em>encoder</em> <strong>is C++ only</strong>. To use it from Java, you need:</p>
<ul>
<li><strong>JNI bindings</strong> to call native code from Java</li>
<li><strong>Platform-specific native libraries</strong> (<code>.dll</code> for Windows, <code>.so</code> for Linux, <code>.dylib</code> for macOS)</li>
<li><strong>Build infrastructure</strong> to compile and ship these libraries for every platform</li>
</ul>
<p>For a heavily-used library like iText, shipping native binaries is a non-starter:</p>
<ul>
<li><strong>Deployment complexity</strong>: Users need to manage native libraries across platforms</li>
<li><strong>Security concerns</strong>: Native code introduces attack surfaces</li>
<li><strong>Build maintenance</strong>: We&#39;d need to compile for Windows x64, Linux ARM, macOS Silicon, etc.</li>
<li><strong>Version conflicts</strong>: What if another library ships a different Brotli version?</li>
</ul>
<p>We needed a solution that handled this complexity <em>outside</em> iText&#39;s core.</p>
<p>That solution is a separate Maven module (<code>brotli-compressor</code>) that you add as an optional dependency. This</p>
<ul>
<li><strong>BrotliStreamCompressionStrategy</strong>: Implementation of <code>IStreamCompressionStrategy</code></li>
<li><strong>brotli4j dependency</strong>: A third-party library that wraps Google&#39;s C++ encoder with JNI</li>
</ul>
<p>Here&#39;s what <code>BrotliStreamCompressionStrategy</code> looks like:</p>
<pre>public class BrotliStreamCompressionStrategy implements IStreamCompressionStrategy {

    @Override
    public OutputStream createNewOutputStream(OutputStream original, PdfStream stream) {
        int compressionLevel = convertCompressionLevel(stream.getCompressionLevel());
        Encoder.Parameters params = Encoder.Parameters.create(compressionLevel);
        try {
            return new BrotliOutputStream(original, params);
        } catch (IOException e) {
            throw new PdfException(KernelExceptionMessageConstant.CANNOT_WRITE_TO_PDF_STREAM, e);
        }
    }

    @Override
    public PdfName getFilterName() {
        return PdfName.BrotliDecode; // This goes into the /Filter entry
    }
}
</pre>
<h4>The native wrapper: brotli4j</h4>
<p>Instead of writing JNI bindings ourselves, we rely on <a href="https://github.com/hyperxpro/Brotli4j" target="_blank" rel="noopener">brotli4j</a>‚Äîa mature, well-tested library that:</p>
<ul>
<li>Wraps Google&#39;s official C++ Brotli encoder/decoder</li>
<li>Ships <strong>pre-compiled native libraries</strong> for all major platforms (Windows x64/ARM, Linux x64/ARM, macOS Intel/Silicon)</li>
<li>Automatically extracts the correct native library at runtime (no manual setup)</li>
<li>Is actively maintained and widely used (powers projects like Netty, OkHttp)</li>
</ul>
<p>By delegating to brotli4j, we get production-grade native bindings without maintaining our own JNI layer.</p>
<h4>Why keep encoding separate?</h4>
<p>You might ask: <em>&#34;Why not bundle brotli4j in the kernel module like you did with the decoder?&#34;</em></p>
<p>Great question. Here&#39;s the reasoning:</p>
<table>
<tbody>
<tr>
<td><strong>Aspect</strong></td>
<td><strong>Decoder (in kernel)</strong></td>
<td><strong>Encoder (separate module)</strong></td>
</tr>
<tr>
<td><strong>Necessity</strong></td>
<td>Required to read Brotli PDFs</td>
<td>Optional‚Äîonly for <em>writing</em></td>
</tr>
<tr>
<td><strong>Dependencies</strong></td>
<td>Pure Java (Google&#39;s decoder)</td>
<td>Native code (brotli4j with JNI)</td>
</tr>
<tr>
<td><strong>Size impact</strong></td>
<td>~300KB of Java code</td>
<td>~2MB of native libraries</td>
</tr>
<tr>
<td><strong>Use frequency</strong></td>
<td>Every user needs to read PDFs</td>
<td>Most users stick with Flate</td>
</tr>
<tr>
<td><strong>Backward compat</strong></td>
<td>No breaking changes</td>
<td>Opt-in feature</td>
</tr>
</tbody>
</table>
<p>By keeping the encoder separate, we give users choice: add <code>brotli-compressor</code> if you need 20% smaller files, or stick with the default if native dependencies are a concern.</p>
<h4>Putting it all together: Full example</h4>
<p>Here&#39;s what it looks like to create a Brotli-compressed PDF:</p>
<p>First of all add the required dependencies. Notice you have to add iText&#39;s artifactory because of the experimental nature of the code, and so users don&#39;t accidentally enable it.</p>
<pre>&lt;repositories&gt;
  &lt;repository&gt;
    &lt;id&gt;itext-releases&lt;/id&gt;
    &lt;name&gt;iText Repository - releases&lt;/name&gt;
    &lt;url&gt;https://repo.itextsupport.com/releases&lt;/url&gt;
  &lt;/repository&gt;
&lt;/repositories&gt;

&lt;dependency&gt;
&lt;groupId&gt;com.itextpdf&lt;/groupId&gt;
&lt;artifactId&gt;brotli-compressor&lt;/artifactId&gt;
&lt;version&gt;{itext.version.bigger.then.9.5.0}&lt;/version&gt;
&lt;/dependency&gt;
</pre>
<pre>public static void main() {

// 1. Register the compression strategy
   DocumentProperties properties = new DocumentProperties();
   properties.registerDependency(IStreamCompressionStrategy.class, new BrotliStreamCompressionStrategy());
// 2. Create your PDF as normal
   PdfWriter writer = new PdfWriter(&#34;output.pdf&#34;);
   PdfDocument pdf = new PdfDocument(writer, properties);

// Everything from here on uses Brotli automatically
   Document doc = new Document(pdf);
   doc.add(new Paragraph(&#34;This text will be Brotli-compressed!&#34;));
   doc.add(new Image(ImageDataFactory.create(&#34;chart.png&#34;)));
   doc.close();

}
</pre>
<p>When you open <code>output.pdf</code> in a text editor, you&#39;ll see some entries looking like this:</p>
<pre>5 0 obj
&lt;&lt;/Filter/BrotliDecode/Length 847&gt;&gt;stream
[binary Brotli-compressed data]
endstream
endobj
</pre>
<p>The PDF now uses <code>/BrotliDecode</code> instead of <code>/FlateDecode</code>, and the file is 15-25% smaller‚Äîwith <strong>zero changes</strong> to your document-building code.</p>
<h3>The catch: Compatibility isn&#39;t universal (yet)</h3>
<p>Here&#39;s the honest truth: <strong>Brotli-compressed PDFs won&#39;t open in Adobe Acrobat Reader today</strong>. They won&#39;t render in your browser&#39;s built-in PDF viewer. Most third-party PDF libraries will reject them outright.</p>
<p>Why? Because <code>/BrotliDecode</code> isn&#39;t part of the official PDF specification yet. The PDF Association is actively working on adding it to ISO 32000 (the PDF standard), but until that&#39;s finalized and implementations roll out, Brotli PDFs exist in a gray area.</p>
<h4>What about forward compatibility?</h4>
<p>Here&#39;s the good news: <strong>Brotli PDFs are future-proof</strong>. Once the PDF Association finalizes the spec and vendors implement it, your existing Brotli-compressed documents will just work. You&#39;re not creating broken files‚Äîyou&#39;re creating files that are <em>ahead of their time</em>.</p>
<p>Think of it like HTTP/2 in 2015. Early adopters who deployed it got immediate performance wins in their own</p>
<h4>iText&#39;s commitment</h4>
<p>We&#39;re not shipping this as a toy feature. We&#39;re working directly with the PDF Association to:</p>
<ul>
<li><strong>Standardize the specification</strong> (syntax, decode parameters, dictionary support)</li>
<li><strong>Validate implementations</strong> across multiple platforms (Java, .NET, C++)</li>
<li><strong>Contribute test suites</strong> to ensure interoperability when other vendors adopt it</li>
<li><strong>Support migrations</strong> when the spec finalizes (we&#39;ll handle any breaking changes)</li>
</ul>
<p>By adopting Brotli compression now, you&#39;re not taking a risk‚Äîyou&#39;re investing in a proven technology that&#39;s on a clear path to standardization.</p>
<h2>Conclusion</h2>
<p>PDF compression hasn&#39;t evolved in 30 years‚Äîuntil now. Brotli represents the biggest leap in PDF storage efficiency since the format was invented, and iText is bringing it to production <strong>today</strong>.</p>
<p>Yes, there are compatibility limitations. Yes, it&#39;s experimental. But every standard starts this way. HTTP/2, WebP, and TLS 1.3 were all &#34;experimental&#34; once. Early adopters got the benefits first, then the ecosystem caught up.</p>
<p>By using iText&#39;s Brotli implementation now, you&#39;re:</p>
<ul>
<li><strong>Reducing storage costs</strong> by 15-25% immediately</li>
<li><strong>Future-proofing your documents</strong> for inevitable standardization</li>
<li><strong>Helping shape the spec</strong> with real-world feedback</li>
<li><strong>Voting with code</strong> for a more efficient PDF ecosystem</li>
</ul>
<p>The PDF Association is listening. Adobe is watching. And iText is leading.</p>
<p><strong>Let&#39;s make PDFs smaller together.</strong> üöÄ</p>
</div></div>
  </body>
</html>
