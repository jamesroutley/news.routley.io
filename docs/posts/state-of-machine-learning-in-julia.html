<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://discourse.julialang.org/t/state-of-machine-learning-in-julia/74385">Original</a>
    <h1>State of Machine Learning in Julia</h1>
    
    <div id="readability-page-1" class="page"><div id="main-outlet">
        

  


      <div itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        <div>
          
          


          <p><span>
              <time itemprop="datePublished" datetime="2022-01-11T10:39:27Z">
                January 11, 2022, 10:39am
              </time>
              <meta itemprop="dateModified" content="2022-01-11T10:39:27Z"/>
          <span itemprop="position">#1</span>
          </span>
        </p></div>
        <div itemprop="articleBody">
          <p>After the <a href="https://twitter.com/i/spaces/1OwxWzDNopDJQ/peek" rel="noopener nofollow ugc">Twitter space Q&amp;A</a> <a href="https://debamitro.github.io/u/logankilpatrick">@logankilpatrick</a> hosted yesterday on “The future of machine learning and why it looks a lot like Julia,” I thought it would be useful to accumulate some community responses to a few questions about the current state of machine learning in Julia:</p>
<ol>
<li>Where does ML in Julia really shine <em>today</em>? Where do you see the ecosystem outperforming other popular ML frameworks (e.g. PyTorch, Flax, etc) in the near future, and why?</li>
<li>Where is Julia’s ML ecosystem currently inferior in features or performance? What’s the realistic timeline for it becoming competitive in these areas?</li>
<li>How do Julia’s ML packages for “standard ML” (e.g. deep learning) compare with popular alternatives in terms of performance (faster, slower, same order of magnitude)? Are there regularly updated benchmarks somewhere?</li>
<li>What don’t we know yet but suspect is an important experiment to make for benchmarking against popular ML alternatives?</li>
<li>If a company or institution is considering creating multi-year positions to contribute to Julia’s ML ecosystem, what is the best case you can make why they should do this? What contributions would be most impactful?</li>
<li>What is the best case you can make why independent developers who work with other frameworks should consider contributing to Julia’s ML ecosystem?</li>
<li>What packages do you tend to reach for for some specific tasks? Why those packages vs some other Julia package or one in another language? What do you wish existed but currently doesn’t?</li>
</ol>
        </div>

        <meta itemprop="headline" content="State of machine learning in Julia"/>
          <meta itemprop="keywords" content=""/>

        

         

      </div>
      <div itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        
        <div itemprop="articleBody">
          

<p>For scientific machine learning (also known as physics-informed learning, or science-guided AI, or expert-guided AI, etc. see the note at the bottom), Julia is really good. If you don’t know what that is, check out this recent seminar talk which walks through SciML for model discovery in epidemics, climate modeling, and more.</p>
<p><a href="https://www.youtube.com/watch?v=FihLyzdjN_8" target="_blank" rel="noopener">
    <img src="https://aws1.discourse-cdn.com/business5/uploads/julialang/original/3X/d/5/d576bea9355966d43738e582ef44ee3c7b14343d.jpeg" title="The Use and Practice of Scientific Machine Learning (Chris Rackauckas) - nextgen_ai Freiburg 2021" width="480" height="360"/>
  </a>
</p>

<p>The SciML Benchmarks in Neural ODEs and other such dynamical models are pretty damn good. We’re talking 100x, 1000x, etc. across tons of different examples. Here are some. Note that most examples don’t even run in torchdiffeq <a href="https://aip.scitation.org/doi/pdf/10.1063/5.0060697">since it uses the non-robust adjoints and no real stiff ODE solvers</a>, so the ones that are benchmarked are only the easiest cases so that torchdiffeq isn’t just exiting early and outputting <code>Inf</code> for the gradients (I guess that’s one way to be fast <img src="https://emoji.discourse-cdn.com/twitter/sweat_smile.png?v=10" title=":sweat_smile:" alt=":sweat_smile:"/>)</p>
<ul>
<li><a href="https://github.com/SciML/SciMLBenchmarks.jl">SciMLBenchmarks.jl</a></li>
<li><a href="https://gist.github.com/ChrisRackauckas/cc6ac746e2dfd285c28e0584a2bfd320"> Torchdiffeq vs DifferentialEquations.jl (/ DiffEqFlux.jl) Neural ODE Compatible Solver Benchmarks</a></li>
<li><a href="https://gist.github.com/ChrisRackauckas/4a4d526c15cc4170ce37da837bfc32c4">torchdiffeq vs Julia DiffEqFlux Neural ODE Training Benchmark</a></li>
</ul>
<p>Similarly we see torchsde performance on standard SDEs to be not great:</p>
<ul>
<li><a href="https://gist.github.com/ChrisRackauckas/6a03e7b151c86b32d74b41af54d495c6">torchsde vs DifferentialEquations.jl / DiffEqFlux.jl (Julia) (small SDE)</a></li>
</ul>
<p>And those even have input from the package’s devs on how to optimize the benchmarks… so… <img src="https://emoji.discourse-cdn.com/twitter/sweat_smile.png?v=10" title=":sweat_smile:" alt=":sweat_smile:"/>. Though note that all of these benchmarks are on examples which are more realistic to scientific machine learning, so smaller kernels, more nonlinearity, at least mild stiffness, etc. I’ll address “big kernel computing” in the second part.</p>
<p>Another thing that people might not know about is that dynamical models also fall into this space. Simply using a good ODE solver is much better than using a “physics engine”. There’s a paper which should DiffEqFlux outperforming Mujuco and DiffTaichi by a good order of magnitude.</p>


<p>There’s a lot more to say too. <a href="https://sciml.ai/news/2022/01/11/linearsolve_preconditioners/">Managing linear solvers and preconditioners is essential to this kind of stuff</a>, and these other libraries don’t even have them. So really, direct usage of <a href="https://computing.llnl.gov/projects/sundials">Sundials from C or Fortran</a> is our only real competitor in this space, but even then that won’t mix with vjps of ML libraries automatically, <a href="https://ieeexplore.ieee.org/abstract/document/9622796">which we know will decrease performance by two orders of magnitude</a>, and we do beat it in most of the SciMLBenchmarks (most but not all). So even if you use C/Fortran Sundials you have to define every Jacobian, vjp, sparsity, etc. function to even get close to what DifferentialEquations.jl does by default. So I would assume that for the vast majority of the population they wouldn’t hit DiffEq speeds even in C/Fortran anymore in this domain <img src="https://emoji.discourse-cdn.com/twitter/wink.png?v=10" title=":wink:" alt=":wink:"/>.</p>
<p>The other thing is differentiable programming on non quasi-static programs, and I’ll let this blog speak for itself.</p>


<p>Another way to define how far ahead we are is to note that <a href="https://arxiv.org/abs/2109.14158">one of the NeurIPS spotlight papers</a> is a method <a href="https://diffeqflux.sciml.ai/dev/examples/second_order_adjoints/">that we wrote a tutorial on in 2019</a> (this kind of thing isn’t too uncommon, it must’ve happened like 10 times by now). Oh wait, they only did the Newton part, not Newton-Krylov, and they didn’t do forward-over-adjoint which is known to be more efficient (as mentioned in Griewank’s AD book, though it’s easy to see with applications), so that paper doesn’t even match our tutorial <img src="https://emoji.discourse-cdn.com/twitter/sweat_smile.png?v=10" title=":sweat_smile:" alt=":sweat_smile:"/>. Feel free to make figures and publish our tutorials if you want.</p>


<p>This blog touches on this topic in some detail:</p>


<p>(and the <a href="https://news.ycombinator.com/item?id=29682507">Hacker News discussion is quite good for this one</a>). The Julia ML/AD tools are not inferior by design, but in some cases by focus. If you’re only dealing with big kernels, i.e. lots of big matrix multiplications, then PyTorch does not have measurable overhead. If you’re only dealing with such kernels, then XLA will perform fusion operations like <code>A*v1 + A*v2 =&gt; A*[v1;v2]</code>, changing BLAS2 to BLAS3 and exploiting more parallelism. Another case is fusions in <code>conv</code> kernels. cudnn has a billion kernels, <a href="https://dev-discuss.pytorch.org/t/where-do-the-2000-pytorch-operators-come-from-more-than-you-wanted-to-know/373">PyTorch listed them out</a>. Here’s a snippet:</p>
<pre><code>cudnn_convolution
cudnn_convolution_backward_input
cudnn_convolution_backward
cudnn_convolution_backward_weight
cudnn_convolution_transpose
cudnn_convolution_transpose_backward
cudnn_convolution_transpose_backward_input
cudnn_convolution_transpose_backward_weight
cudnn_convolution_relu
cudnn_convolution_add_relu
</code></pre>
<p>So instead of <code>relu(conv(x)) .+ y</code>, on GPUs you’d want to do <code>cudnn_convolution_add_relu</code>. Similarly some of these extra kernels exist for RNNs. XLA, and thus both TensorFlow and Jax, will do these fusions automatically.</p>
<p>Julia does not perform those kinds of optimizations in its “ML compiler” because it’s just using the Julia compiler, and you wouldn’t necessary want to do that on all Julia codes because it’s kind of like <code>@fastmath</code> in that it changes the floating point results. So somehow we need to add such compiler optimizations to the language which only apply in specific user contexts. Even better, it would be nice if mathematical/ML users could help build and maintain these compiler optimizations like they do with automatic differentiation rules for <a href="https://github.com/JuliaDiff/ChainRules.jl">ChainRules.jl</a>. Not everyone is a compiler engineer, but everyone can help with linear algebra equalities. That’s the purpose of the E-graph project:</p>




<p>However, that is still in its elementary stages and cannot even apply rules to arrays (<a href="https://github.com/JuliaSymbolics/Symbolics.jl/pull/495">though Shashi has started that work</a>).</p>
<p>So in theory getting ML performance is simple: you just use fast kernels. In practice, the hard part is allowing users to write simple Julia code but then to allow for, in limited contexts, the compiler to change the high level calls of their code to more efficient kernels. The AbstractInterpreter will give us the tools to do this, but it’s still just the near future. The Julia ML tools picked a much larger scope and that’s good for some things but the downside is that these optimizations are much harder to write.</p>
<p>This does not effect my SciML use cases but is probably the biggest performance issue with standard ML in Julia. But while finishing these optimizations would make Julia really ergonomic for both building and using ML packages, I’m not convinced it will “win over” the standard ML community because you still would only expect to match performance in that domain, so I’m not convinced we have a silver bullet there.</p>


<p>I don’t think each individual benchmark is interesting. They all say pretty much the same thing as my response to 2:</p>
<ol>
<li>Julia’s kernel speeds are fine. On CPUs we’re doing really well, beating most other things with <a href="https://github.com/JuliaLinearAlgebra/Octavian.jl">GitHub - JuliaLinearAlgebra/Octavian.jl: Multi-threaded BLAS-like library that provides pure Julia matrix multiplication</a> and such. On GPUs everyone is just calling the same cudnn etc. so it’s a battle of who calls the better kernels and with the right arguments.</li>
<li>Julia’s AD speeds are fine. Zygote can have some overhead, but it’s actually rather fast in most contexts compared to Jax/PyTorch/TensorFlow. Specifically, PyTorch overhead is much higher but it’s not even measurable in standard ML workflows anyways. One matrix multiplication of a large enough matrix <a href="https://www.stochasticlifestyle.com/when-do-micro-optimizations-matter-in-scientific-computing/">eats up allocation issues or other O(n) stuff</a>.</li>
<li>Julia does not fuse kernels, so in most benchmarks if you look at it you just go “oh, it’s not fusing this conv” or “this RNN cudnn call”.</li>
</ol>
<p>So a lot of the issues which mention PyTorch, like <a href="https://github.com/FluxML/Flux.jl/issues/1365">RNN design for efficient CUDNN usage · Issue #1365 · FluxML/Flux.jl · GitHub</a>, are really just re-design issues to try and make Flux more readily call better kernels by manually fusing some things. So that’s really the main standard ML issue at the moment.</p>


<p>XLA’s distributed scheduler is pretty good. As we are thinking about scaling, we should probably ignore PyTorch and look at DaggerFlux vs TensorFlow/Jax. XLA has more freedom to change operations around so I think it should be the winner here, and we will need to use e-graphs tricks to match it.</p>
<p>One other thing to note though is that there is a “missing middle in automatic differentiation” where one has to choose between loopy mutating code (with Enzyme) vs kernel linear algebra code (with Zygote/Diffractor), and mixing the two code styles does not work right now. For a discussion on that, see:</p>


<p>That said, PyTorch, Jax, and TensorFlow also have this issue so it’s not really inferior, and Julia is closer to solving it than the others. But it’s a big PITA and something we really need to address to make Julia’s differentiable programming feel truly better than the alternatives.</p>


<p>I’m not sure, but I see it around. Both Julia Computing and Pumas-AI have many folks doing SciML though, and if you’re interested in SciML stuff please get in touch.</p>
<p>This topic also explains the parts of the <a href="https://julia.mit.edu/">MIT Julia Lab</a>, where there’s a SciML crew focusing on SciML models and applications, and a compiler/symbolics crew working on these kinds of “customizable compiler for science” issues.</p>


<p>It’s easy to specialize it towards weird research. In fact, there’s an <a href="https://www.stochasticlifestyle.com/useful-algorithms-that-are-not-optimized-by-jax-pytorch-or-tensorflow/">entire research domain in non-quasi-static ML algorithms</a> that’s just full of potential gems. Writing your own kernels <a href="https://dl.acm.org/doi/abs/10.1145/3317550.3321441">gets you new algorithms that aren’t in the rut</a>. Our <a href="https://julialang.org/blog/2021/10/DEQ/">implicit layer tooling all composes</a>, and we’re far enough ahead that <a href="https://www.researchgate.net/profile/Samy-Wu-Fung-2/publication/350371775_JFB_Jacobian-Free_Backpropagation_for_Implicit_Networks/links/61bccc2c63bbd932429db48a/JFB-Jacobian-Free-Backpropagation-for-Implicit-Networks.pdf">there are entire papers</a> that are just what we’ve been doing for years.</p>
<p>And of course, all of the differential equation stuff mentioned at the beginning.</p>


<p>I tend to reach to Flux when I need to, but try to stick to DiffEqFlux. Flux is just the most complete in terms of kernels that exist, but its style irks me. I wish there was a Flux which did not use implicit parameters and instead used explicit parameters. I would like those parameters to be represented by <a href="https://github.com/jonniedie/ComponentArrays.jl">ComponentArrays</a></p>


<p>If you haven’t seen the ComponentArrays DiffEqFlux.jl example it’s really nice:</p>
<p><a href="https://jonniedie.github.io/ComponentArrays.jl/dev/examples/DiffEqFlux/" target="_blank" rel="noopener">https://jonniedie.github.io/ComponentArrays.jl/dev/examples/DiffEqFlux/</a></p>
<pre><code>function dudt(u, p, t)
    @unpack L1, L2 = p
    return L2.W * tanh.(L1.W * u.^3 .+ L1.b) .+ L2.b
end
</code></pre>
<p>That would make there be no implicit global state and everything would be explicit but with nice syntax.  Since ComponentArrays is a flat contiguous vector with helper indexers (that return views), it works nicely with linear algebra for putting into BFGS. Mixing that with a universal optimizer interface GalacticOptim.jl</p>
<p><a href="https://galacticoptim.sciml.ai/dev/" target="_blank" rel="noopener">https://galacticoptim.sciml.ai/dev/</a></p>
<p>Would give me everything I need. It would be a whole lot easier to debug and optimize too. So I would really consider either making that kind of ML package or changing Flux to explicit parameters (which is somewhat underway with <a href="https://github.com/FluxML/Optimisers.jl">Optimisers.jl</a>).</p>
<p>[Note on SciML terminology. It’s pretty funny that these days people attribute SciML to the <a href="https://sciml.ai/">SciML Scientific Machine Learning Open-Source Software Organization</a>. The original attribution was a major <a href="https://www.osti.gov/biblio/1478744">workshop by the US DoE</a> which established the term and essentially proclaimed it to be a field. We started working on this and were JuliaDiffEq before, with half of the repos not being differential equation solvers anymore, so it made sense to change to being “The SciML Scientific Machine Learning Open-Source Software Organization”, which is always just abbreviated to SciML. Soon, the SciML org became synonymous with the term, and so now people are less inclined to use the term as it refers more to us than the field, and so now people ask why we didn’t adopt “standard” terminology like “science-guided AI” which was first developed to avoid referring to us <img src="https://emoji.discourse-cdn.com/twitter/laughing.png?v=10" title=":laughing:" alt=":laughing:"/>. Fun anecdote to show where our community is in this space.]</p>
        </div>

        <meta itemprop="headline" content="State of machine learning in Julia"/>

        

         

      </div>
      <div itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        <div>
          
          


          <p><span>
              <time itemprop="datePublished" datetime="2022-01-11T15:14:23Z">
                January 11, 2022,  3:14pm
              </time>
              <meta itemprop="dateModified" content="2022-01-11T15:14:23Z"/>
          <span itemprop="position">#3</span>
          </span>
        </p></div>
        <div itemprop="articleBody">
          
<p>A note for anyone wondering “how is this true when Zygote takes 20/60/1000 seconds or more to give me gradients?”: runtime performance is generally on par and helped by lower per-op overhead. Almost all of that latency is coming from compilation (the source-to-source part of Zygote). This forms the lion’s share of what has been called “time to first gradient (TTFG)”. If you’re seeing pathological compilation latency or significantly poorer runtime performance and can whip up a MWE, please file an issue.</p>
        </div>

        <meta itemprop="headline" content="State of machine learning in Julia"/>

        

         

      </div>
      <div itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        
        <div itemprop="articleBody">
          <p>I’ll offer a perspective from someone who (as a conscious choice) primarily uses Python over Julia. I work with, and maintain libraries for, all of PyTorch, JAX, and Julia.</p>
<p>For context my answers will draw some parallels between:</p>
<ul>
<li>JAX, with <a href="https://github.com/patrick-kidger/equinox" rel="noopener nofollow ugc">Equinox</a> for neural networks;</li>
<li>Julia, with Flux for neural networks;</li>
</ul>
<p>as these actually feel remarkably similar. JAX and Julia are both based around jit-compilers; both ubiquitously perform program transforms via homoiconicity. Equinox and Flux both build models using the same <code>Flux.@functor</code>-style way of thinking about things. etc.</p>
<h2>
<a name="question-1-where-does-ml-in-julia-shine-1" href="#question-1-where-does-ml-in-julia-shine-1"></a>Question 1: where does ML-in-Julia shine?</h2>
<p>(A) Runtime speed.</p>
<p>Standard Julia story there, really. This is most noticable compared to PyTorch, at least when doing operations that aren’t just BLAS/cuDNN/etc.-dominated. (JAX is generally faster in my experience.)</p>
<p>(B) Compilation speed.</p>
<p>No, really! Julia is substantially faster than JAX on this front. (It <em>really</em> doesn’t help that JAX is essentially a compiler written in Python. JAX is a lovely framework, but IMO it would have been better to handle its program transformations in another language.)</p>
<p>It’s been great watching the recent progress here in Julia.</p>
<p>(C) Introspection.</p>
<p>Julia offers tools like <code>@code_warntype</code>, <code>@code_native</code> etc. Meanwhile JAX offers almost nothing. (Once you hit the XLA backend, it becomes inscrutable.) For example I’ve recently had to navigate some serious performance bugs in the XLA compiler, essentially by trial-and-error.</p>
<p>(D) Julia is a programming language, not a DSL.</p>
<p>JAX/XLA have limitations like not being able to backpropagate while loops, or being able to specify when to modify a buffer in-place. As a “full” programming language, Julia doesn’t share these limitations.</p>
<p>Julia offers native syntax, over e.g. <code>jax.lax.fori_loop(...)</code>.</p>
<p>(PyTorch does just fine on this front, though.)</p>
<h2>
<a name="question-2-2" href="#question-2-2"></a>Question 2.</h2>
<p>(A) Poor documentation.</p>
<p>If I want to do the equivalent of PyTorch’s <code>detach</code> or JAX’s <code>stop_gradient</code>, how should I do that in Flux?</p>
<p>First of all, it’s not in the Flux documentation. Instead it’s in the separate Zygote documentation. So you have to check both.</p>
<p>Once you’ve determined which set of documentation you need to look in, there are the entirely separate <code>Zygote.dropgrad</code> and <code>Zygote.ignore</code>.</p>
<p>What’s the difference? Unclear. Will they sometimes throw mysterious errors? <a href="https://discourse.julialang.org/t/loaderror-when-using-interpolations-as-input-for-a-neural-ode/51224/6">Yes.</a> Do I actually know which to use at this point? Nope.</p>
<p>(B) Inscrutable errors.</p>
<p>Whenever the developer misuses a library, the compilation errors messages returned are typically more akin to “C++ -template-verbiage” than “helpful-Rust-compiler”. (That is to say, less than helpful.) Especially when coupled with point (A), it can feel near-impossible to figure out what one actually did wrong.</p>
<p>Moreover at least a few times I’ve had cases where what I did was theoretically correct, and the error was actually reflective of a bug in the library. (Incidentally, Julia provides very few tools to library authors to verify the correctness of their work.)</p>
<p>Put simply, the trial-and-error development process is <em>slow</em>.</p>
<p>(C) Unreliable gradients</p>
<p>I remember all too un-fondly a time in which one of my models was failing to train. I spent multiple months on-and-off trying to get it working, trying every trick I could think of.</p>
<p>Eventually (eventually) I found the error: Zygote was returning incorrect gradients. After having spent so much energy wrestling with points (A) and (B) above, this was the point where I simply gave up. Two hours of development work later, I had the model successfully training… in PyTorch.</p>
<p>(D) Low code quality</p>
<p>(D.1)</p>
<p>Getting fixes pushed ASAP is great, of course. What’s bad is that the error happened in the first place. In contrast I essentially never get this experience as an end user of PyTorch or JAX.</p>
<p>(D.2)</p>
<p>Even in the major well-known well-respected Julia packages, I see obvious cases of unused local variables, dead code branches that can never be reached, etc.</p>
<p>In Python these are things that a linter (or code review!) would catch. And the use of such linters is ubiquitous. (Moreover in something like Rust, the compiler would catch these errors as well.) Meanwhile Julia simply hasn’t reached the same level of professionalism. <em>(I’m not taking shots at anyone in particular here.)</em></p>
<p>[Additionally there’s the whole <span>#4600</span> - <code>FromFile.jl</code> - <code>include</code> problem that IMO hinders readability. But I’ve spoken about that extensively before, and it seems to be controversial here, so I’ll skip any further mention of that.]</p>
<p>(D.3) Math variable names</p>
<p>APIs like <code>Optimiser(learning_rate=...)</code> are simply more readable than those like <code>Optimiser(η=...)</code>. (I suspect some here will disagree with me on this. After all, APL exists.)</p>
<p>(E) Painful array syntax</p>
<ul>
<li>Julia makes a distinction between <code>A[1]</code> and <code>A[1, :]</code>;</li>
<li>The need to put <code>@view</code> everywhere is annoying;</li>
<li>The need for <code>selectdim</code> over something (NumPy-style) like <code>A[..., 1, :]</code> reduces readability.</li>
<li>The lack of a built-in <code>stack</code> function is annoying (to the extent that Flux provides one!)</li>
</ul>
<p>Array manipulation is such an important part of ML, and these really hinder usability/readability. One gets there eventually, of course, but my PyTorch/JAX code is simply prettier to read, and to understand.</p>
<p>(F) No built-in/ubiquitous way to catch passing arrays of the wrong shape; a very common error. (At least that I know of.)</p>
<p>Meanwhile:</p>
<ul>
<li>JAX probably has the best usable offering for this. Incorrect shapes can be caught during jit compilation using an <code>assert</code> statement. The only downside is that actually do is very unusual (not even close to culturally ubiquitous), probably because of the need for extra code.</li>
<li>
<a href="https://github.com/hasktorch/hasktorch" rel="noopener nofollow ugc">Hasktorch</a> and <a href="https://github.com/google-research/dex-lang" rel="noopener nofollow ugc">Dex</a> encode the entirety of an array’s shape into its type. Huge amounts of safety, ubiquitously. Only downside here is that both are experimental research projects.</li>
<li>PyTorch has <a href="https://github.com/patrick-kidger/torchtyping" rel="noopener nofollow ugc">torchtyping</a>, which provides runtime or test-time shape checking, essentially as part of the type system.</li>
</ul>
<p>My “dream come true” in this regard would be something with the safety of the Rust compiler and the array types of TorchTyping.</p>
<h2>
<a name="question-3-3" href="#question-3-3"></a>Question 3</h2>
<p>My experience has been that all of PyTorch/JAX/Julia are fast enough. I don’t really find myself caring about speed differences between them, and will pick a tool based on other considerations. (Primarily those listed above.)</p>
<h2>
<a name="question-4-4" href="#question-4-4"></a>Question 4</h2>
<p>Maybe not an “experiment” in the sense you mean, but – more Q&amp;As like this one, in particular at other venues where there’s likely to be more folks that have (either just for a project or more broadly) decided against Julia.</p>
<h2>
<a name="question-5-5" href="#question-5-5"></a>Question 5</h2>
<p>Best case argument:</p>
<p>Imagine working in an environment that has both the elegance of JAX (Julia has arrays, a jit compiler, and vmap all built-in to the language!) and the usability of PyTorch (Julia is a language, not a DSL!) Julia still has issues to fix, but come and help pitch in if this is a dream you want to see become reality.</p>
<p>Impactful contributions:</p>
<ul>
<li>Static compilation. Julia’s deployment story is simply nonexistent, and IMO this sharply limits its commercial applicability.</li>
<li>Better autodifferentiation. I know there’s ongoing work in this space (i.e. Diffractor.jl, which I haven’t tried yet) but so far IMO Julia hasn’t yet caught up to PyTorch/JAX on this front.</li>
<li>Fixing all of the negatives I raised above. Right now none of those are issues suffered by the major Python alternatives.</li>
</ul>
<h2>
<a name="question-6-6" href="#question-6-6"></a>Question 6</h2>
<p>As Q5.</p>
<h2>
<a name="question-7-7" href="#question-7-7"></a>Question 7</h2>
<p>What packages? Right now, I’m tending to reach for JAX, Equinox, Optax (all in Python).</p>
<p>Why those packages? They provide the best trade-off between speed/usability for me right now.</p>
<p>What do I wish existed? Solutions to the above problems with Julia ML. I find that I really like the Julia language, but its ML ecosystem problems hold me back.</p>
        </div>

        <meta itemprop="headline" content="State of machine learning in Julia"/>

        

         

      </div>
      <div itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        
        <div itemprop="articleBody">
          <p>I think all of your comments were fair (although I don’t agree with everything, for example the need to opting into <code>@view</code> is because Julia tends to be safe by default and a view when slicing would not be so), but I don’t quite get this point:</p>

<p>Why is that a problem?  <code>A[1]</code> accesses the element with index <code>1</code>, <code>A[1, :]</code> access the row with index <code>1</code>, I fail to see what’s the problem.</p>
        </div>

        <meta itemprop="headline" content="State of machine learning in Julia"/>

        

         

      </div>
      <div itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        
        <div itemprop="articleBody">
          <p>Thanks!</p>

<p>That’s safe-by-default for functionality but not safe-by-default for speed.</p>
<p>Pragmatically speaking, I find that taking views is very common, whilst making a copy is unusual.</p>

<p>Special syntax for implicitly re-striding an array just seems a little odd to me. I don’t think I’ve ever done it deliberately in either Python or Julia.</p>
        </div>

        <meta itemprop="headline" content="State of machine learning in Julia"/>

        

         

      </div>
      <div itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        
        <div itemprop="articleBody">
          
<p>On the contrary I always get a feeling of unease when leaving out indices in numpy, although I’ll admit that I sometimes like how the code turns out. One thing I dislike about it in numpy is that it seems kind of arbitrary why it means the same as <code>A[1, :]</code> rather than <code>A[:, 1]</code>. If the answer is that it’s natural based on the (default) strides, notice that it then would be natural to have the opposite meaning in Julia, which probably would drive everybody nuts. (Obviously it’s not possible to change this without removing the linear indexing feature from Julia.)</p>
        </div>

        <meta itemprop="headline" content="State of machine learning in Julia"/>

        

         

      </div>
      <div itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        <div>
          
          <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            <a itemprop="url" href="https://discourse.julialang.org/u/DNF"><span itemprop="name">DNF</span></a>
            
          </span></p>


          <p><span>
              <time itemprop="datePublished" datetime="2022-01-11T20:53:48Z">
                January 11, 2022,  8:53pm
              </time>
              <meta itemprop="dateModified" content="2022-01-11T20:53:48Z"/>
          <span itemprop="position">#8</span>
          </span>
        </p></div>
        <div itemprop="articleBody">
          
<p>I guess you’re not particularly eager to get stuck on this small side issue, but it seems like Julia has completely general syntax (with a very consistent rule about the dimensionality of the indices vs the output), while the Python syntax seems special and odd.</p>
<p>Otherwise, thanks for an interesting post.</p>
        </div>

        <meta itemprop="headline" content="State of machine learning in Julia"/>

        

         

      </div>
      <div itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        
        <div itemprop="articleBody">
          
<p>For what it’s worth I’m fairly certain that that numpy syntax is internally consistent as well.</p>
        </div>

        <meta itemprop="headline" content="State of machine learning in Julia"/>

        

         

      </div>
      <div itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        
        <div itemprop="articleBody">
          
<p>It is used it in a fair amount of Julia code. I’ve used it. It’s handy, and it’s clear what’s happening.</p>
<p>But, obviously, this is the least important of your criticisms.</p>
<p>I am trying to find a robust way to deploy Julia inside a python project. People have put a ton of work into Julia-Python interop in general. But, the parts closer to deployment are not there yet. It would be a great place for people to lend a hand. (This has been known for long time.) But, it has to compete with the other pressing issues you mentioned.</p>
        </div>

        <meta itemprop="headline" content="State of machine learning in Julia"/>

        

         

      </div>
      <div itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        
        <div itemprop="articleBody">
          <p><a href="https://debamitro.github.io/u/chrisrackauckas">@ChrisRackauckas</a> on the topic of machine learning and E-Graphs, how do you view E-Graphs in comparison to the work of the PyTorch developers on <a href="https://dev-discuss.pytorch.org/t/torchdynamo-an-experiment-in-dynamic-python-bytecode-transformation/361" rel="noopener nofollow ugc">TorchDynamo</a>. While E-Graph does seem to have wider-reaching goals, especially for SciML, than TorchDynamo, I would be intrigued to hear you see the two of them matching up?</p>
<p>Could E-Graph fulfill a similar role than TorchDynamo for the ML-Ecosystem in Julia?</p>
        </div>

        <meta itemprop="headline" content="State of machine learning in Julia"/>

        

         

      </div>
      <div itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        
        <div itemprop="articleBody">
          <p>It’s not the same or similar thing as the E-graph, but instead it’s similar to the interfaces the E-graphs are acting on. Maybe the easiest way to describe it by saying what is the same or similar. The Python bytecode is like “the Julia IR”. Of course, as an optimizing compiler, there isn’t a singular IR, instead there are stages: the untyped IR, the typed IR, and the LLVM IR. Cassette and IRTools, the tools on which <a href="https://github.com/FluxML/Zygote.jl">Zygote.jl</a> was built (some notable others are <a href="https://github.com/oxinabox/AutoPreallocation.jl">AutoPreallocation.jl</a>, <a href="https://github.com/SciML/SparsityDetection.jl">SparsityDetection.jl</a>, etc.), are probably the most similar to TorchDynamo in that on untyped syntactic IR it is a tool that transforms to another untyped syntactic IR.</p>
<p>It turns out that for Julia this was a bad idea because (a) the meaning of code can depend (heavily) on types, and (b) this is before compiler optimizations, and so mixing compiler optimizations with automatic differentiation is impossible. Thus Julia v1.7 added an AbstractInterpreter interface to Julia Base itself for acting on typed IR, which is then used by packages like <a href="https://github.com/aviatesk/EscapeAnalysis.jl">EscapeAnalysis.jl</a> and <a href="https://github.com/JuliaDiff/Diffractor.jl">Diffractor.jl</a> to write compiler passes on typed IR. And of course LLVM IR has standard interpretation techniques along with <a href="https://github.com/wsmoses/Enzyme.jl">Enzyme.jl</a> which is an AD written on LLVM IR.</p>
<p>So TorchDynamo is probably most similar to Cassette/IRTools, but you could also say it’s like AbstractInterpreter in that it’s acting on “the true IR of Python”, where the true IR of Julia is typed when it has all of its information while in Python it is not. But this story is why Zygote has its compile-time issues, higher order AD issues, and why all of the tooling is moving to not just a new AD tool but an entirely different IR target and compiler tool stack (note this doesn’t imply that will happen to TorchDynamo, unless they start rewriting their AD to be source-to-source on Python bytecode, but there’s precedent of that in tangent which didn’t find a nice home). Note that these tools aren’t just for AD. For example, there are PRs to Julia’s Base which are automatically analyzing loops and removing repeated allocations of immutable arrays where they are written using the AbstractInterpreter compiler plugin interface.</p>


<p>So that still doesn’t answer how the heck E-graphs comes into the story because I haven’t described how you write a compiler pass. It doesn’t matter what level of IR you’re on, it’s basically just a function IR-&gt;IR. So where in their blog post they say “just add code here”</p>
<pre><code>def custom_compiler(graph: torch.fx.GraphModule) → Callable:
    # do cool compiler optimizations here
    return graph.forward
    
with torchdynamo.optimize(custom_compiler):
    # any PyTorch code
    # custom_compiler() is called to optimize extracted fragments
    # should reach a fixed point where nothing new is compiled
    
# Optionally:
with torchdynamo.run():
    # any PyTorch code
    # previosly compiled artifacts are reused
    # provides a quiescence guarantee, without compiles
</code></pre>
<p>Well, that’s true in any of these systems, just like in macros. But if you’ve ever written a macro, you’ll know that walking expression graphs is a tedious process to get correct. Wouldn’t it be nice if compiler optimizations for mathematical ideas could be expressed mathematically, and the associated compiler pass could be generated? It turns out that all Symbolics tooling really is is just tooling that performs rewrites on some IR. So Symbolics.jl has an IR that uses SymbolicUtils.jl’s rewriters and MetaTheory.jl’s E-graphs to transform symbolic IR → symbolic IR, but what we have done is made those rewrite tools generic to the IR and boom now it’s a compiler optimization pass generator.</p>
<p>That means you can say define an E-graph that acts on Julia typed IR and spits out the typed IR with the desired simplifications described mathematically. This is what we mean by “democratization of writing compiler passes”: we are trying to use this to build a system so that people who want to add a new linear algebra simplification pass to the Julia typed IR do not need to learn all of the details of the AbstractInterpreter and Julia Typed IR definition, and instead just write a few mathematical equalities and boom it generates a compiler pass which then generates the transformed IR. So think of the E-graphs as replacing this requirement that someone writes a function like <code>def custom_compiler(graph: torch.fx.GraphModule) → Callable:</code> that digs through some expression graph. Instead you just write</p>
<div><a href="https://aws1.discourse-cdn.com/business5/uploads/julialang/original/3X/5/0/50536b1bfb06f59d19c451731694e041b5783a3c.jpeg" data-download-href="/uploads/short-url/bsAV5gpOKxE7NHf1Pww5vz6rRRG.jpeg?dl=1" title="image"><img src="https://aws1.discourse-cdn.com/business5/uploads/julialang/optimized/3X/5/0/50536b1bfb06f59d19c451731694e041b5783a3c_2_690x233.jpeg" alt="image" data-base62-sha1="bsAV5gpOKxE7NHf1Pww5vz6rRRG" width="690" height="233" srcset="https://aws1.discourse-cdn.com/business5/uploads/julialang/optimized/3X/5/0/50536b1bfb06f59d19c451731694e041b5783a3c_2_690x233.jpeg, https://aws1.discourse-cdn.com/business5/uploads/julialang/original/3X/5/0/50536b1bfb06f59d19c451731694e041b5783a3c.jpeg 1.5x, https://aws1.discourse-cdn.com/business5/uploads/julialang/original/3X/5/0/50536b1bfb06f59d19c451731694e041b5783a3c.jpeg 2x" data-small-upload="https://aws1.discourse-cdn.com/business5/uploads/julialang/optimized/3X/5/0/50536b1bfb06f59d19c451731694e041b5783a3c_2_10x10.png"/></a></div>
<p>Man, this came out longer than expected. But since it describes why Zygote is being replaced with Diffractor and Enzyme I guess it’s a useful description for many other reasons than the original question <img src="https://emoji.discourse-cdn.com/twitter/sweat_smile.png?v=10" title=":sweat_smile:" alt=":sweat_smile:"/></p>
        </div>

        <meta itemprop="headline" content="State of machine learning in Julia"/>

        

         

      </div>
      <div itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        
        <div itemprop="articleBody">
          <p>Thanks for the shout-out on the CTPG paper! I whole-heartedly agree that the paper would not have been possible without Julia and DifferentialEquations.jl. It’s cool to see what can be done when you break out of the usual static-graph mode. Thanks and kudos to <a href="https://debamitro.github.io/u/chrisrackauckas">@ChrisRackauckas</a>!</p>
<p>I work in ML, largely in Python, but I have a soft spot for Julia as well. I think <a href="https://debamitro.github.io/u/patrick-kidger">@patrick-kidger</a>’s response summarizes things very well. I’ll just chip in a few of my own experiences/thoughts:</p>
<h3>
<a name="what-does-ml-even-mean-1" href="#what-does-ml-even-mean-1"></a>What does ML even mean?</h3>
<p>There are so many different types of models/problems/architectures these days that it’s worth pointing out that there’s a big difference between “conventional deep learning” – transformers, convnets, large models – and “other” more obscure models – differentiable physics, neural ODEs, implicit models, etc. So far I think Julia is doing better in the “other” category.</p>
<p>It’s worth noting that the requirements for “conventional” vs “other” can be <em>drastically</em> different. Everything from model parallelism to compute architecture to float32 vs float64.</p>
<h3>
<a name="speed-2" href="#speed-2"></a>Speed</h3>
<p>Compilation speed is entirely irrelevant (cf. jax). What matters at the end of the day is iterations/second. Right now, JAX/XLA seem to have Julia beat in the “conventional large model” space since they have all kinds of optimizations for linear algebra, specific kernels, and TPUs. At this point just about every last drop of performance has been squeezed out of pytorch/TF/jax in the “conventional” large models space.</p>
<p>That being said, I am extremely bullish on the MetaTheory.jl line of work with e-graph based optimization. Ultimately I think this is a superior design than anything in the competition. But the devil will be in the details of making it production-ready <em>esp. on GPUs/TPUs</em>.</p>
<h3>
<a name="correctness-3" href="#correctness-3"></a>Correctness</h3>
<p>Like <a href="https://debamitro.github.io/u/patrick-kidger">@patrick-kidger</a>, I have been bit by incorrect gradient bugs in Zygote/ReverseDiff.jl. This cost me weeks of my life and has thoroughly shaken my confidence in the entire Julia AD landscape. As a result I now avoid using Julia AD frameworks if I can. At minimum, I cross-check all of their results against JAX… at which point I might as well just use the JAX implementation. (Excited to check out Diffractor.jl when it’s ready though!)</p>
<p>In all my years of working with PyTorch/TF/JAX I have not once encountered an incorrect gradient bug.</p>
<h3>
<a name="ecosystem-and-library-scope-4" href="#ecosystem-and-library-scope-4"></a>Ecosystem and library scope</h3>
<p>I really wish there was just something like JAX in Julia. Flux.jl is too high-level for me most of the time. Zygote is often too low-level. I like the idea of source-to-source AD though. Maybe we just need new frameworks on top of Zygote/Diffractor to spring up? I don’t know. I expect that solutions here will emerge naturally as more investment is made in ML in Julia and people bump into the limitations of existing tooling…</p>
<p>I’m optimistic for the future of ML in Julia. I really am. For me personally, it’s not ready for what I need it to do just yet. But I’m optimistic that this may change over time.</p>
        </div>

        <meta itemprop="headline" content="State of machine learning in Julia"/>

        

         

      </div>
      <div itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        
        <div itemprop="articleBody">
          <p>Thanks for the very thoughtful post Patrick, and nice to see you around. Some thoughts on the above:</p>

<p>I’d argue this applies to most non-science/numerics projects and ~20-30% of scientific python code, but there is a long, long tail of projects that use no linting or any kind of static analysis. These projects tend to make many of the same faux pas you mentioned.</p>
<p>I think this speaks to three things:</p>
<ol>
<li>The benefits of centralization in the Python ecosystem. A majority users doing data-y stuff can get away with the that top 20-30%.</li>
<li>The relative size/resourcing of both ecosystems. Code quality may well be better for Julia and Python codebases of the same popularity, but if we look at relative in-ecosystem popularity then your point probably holds. I don’t have a good intuition on how much we should weight those two disparate perspectives. For example, the aforementioned exemplary Python projects have multiple magnitudes more engineering time/money/infra to work with, and trying to replicate their quality without those is rather unrealistic.</li>
<li>A need to get more automated tooling running in the Julia ecosystem. I want to say DocumentLint has been used in CI, but it’s still primarily an IDE thing. JET.jl leaves basically every Python type checker in the dust, but its relative novelty means that adoption is still low.</li>
</ol>

<p>This is possible at runtime with libraries like <a href="https://github.com/invenia/NamedDims.jl" rel="noopener nofollow ugc">GitHub - invenia/NamedDims.jl: For working with dimensions of arrays by name</a> and potentially statically with JET + named array libraries. The biggest challenge I see (one you’re likely familiar with developing torchtyping) is adoption + standardization. Guido has been <a href="https://docs.google.com/document/d/1oaG0V2ZE5BRDjd9N-Tr1N0IKGwZQcraIlZ0N8ayqVg8/edit#heading=h.ghrjc29v0brh" rel="noopener nofollow ugc">leading an effort</a> on the Python side, so seriously exploring avenues like <a href="https://twitter.com/KenoFischer/status/1407810981338796035" rel="noopener nofollow ugc">https://twitter.com/KenoFischer/status/1407810981338796035</a> could be fruitful here.</p>
        </div>

        <meta itemprop="headline" content="State of machine learning in Julia"/>

        

         

      </div>
      <div itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        <div>
          
          <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            <a itemprop="url" href="https://discourse.julialang.org/u/Akatz"><span itemprop="name">Akatz</span></a>
            
          </span></p>


          <p><span>
              <time itemprop="datePublished" datetime="2022-01-12T02:18:34Z">
                January 12, 2022,  2:18am
              </time>
              <meta itemprop="dateModified" content="2022-01-12T02:18:34Z"/>
          <span itemprop="position">#15</span>
          </span>
        </p></div>
        <div itemprop="articleBody">
          
<p>Thanks <a href="https://debamitro.github.io/u/samuel_ainsworth">@Samuel_Ainsworth</a> and <a href="https://debamitro.github.io/u/patrick-kidger">@patrick-kidger</a> for your frank thoughts! It’s really important to get this sort of feedback.</p>
<p>How long ago were both of you getting incorrect gradients? Were these errors on recent versions of zygote? After the chainrules switch?</p>
        </div>

        <meta itemprop="headline" content="State of machine learning in Julia"/>

        

         

      </div>
      <div itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        
        <div itemprop="articleBody">
          <p>If you’ll allow me to start from the end first:</p>

<p>This is not well documented and ought to be so (PRs welcome if anyone is interested), but Flux is really an amalgamation of different sub libraries:</p>
<ol>
<li>An AD (Zygote)</li>
<li>A set of ML kernels (NNlib)</li>
<li>A module system (Functors.jl)</li>
<li>A set of layers, optimizers and training loop helpers (Flux itself)</li>
</ol>
<p>Using just <span>#1</span> and <span>#2</span> is equivalent to <code>torch.nn.functional</code>. Using 1, 2, and 3 gets you a JAX equivalent. The plan is to move optimizers out from <span>#4</span> into a separate package (see Optimisers.jl) so that you can use it just like JAX users use Optax. This kind of shared infrastructure is already being exploited in the ecosystem: Knet uses NNlib (NNlib dev is a collaboration between Knet and Flux) and offers a “lower level” interface you may be interested in, while Avalon.jl uses NNlib + Functors for a more PyTorch-esque framework.</p>
<p>Now to the broader, more philosophical point. I also use 100% Python for my own work, and the dynamics/motivation there are very similar to what you’ve described. Though not worded particularly pleasantly, I think this HN comment summarizes the struggle well:</p>
<blockquote>
<p>My impression from your comment is that you don’t care that much about “standard” ML users. As a “standard” ML user (pytorch/jax), and a potential Julia user in the future, this is not what I like to hear.</p>
</blockquote>
<p>Now, there have been very some very good points made here and on different forums that trying to take the Python ML juggernaut on in its own territory is at best aspirational (E: after reading Chris’ response, the original more forceful “fools errand” would’ve been more appropriate <img src="https://emoji.discourse-cdn.com/twitter/stuck_out_tongue.png?v=10" title=":stuck_out_tongue:" alt=":stuck_out_tongue:"/> ). What I don’t think has happened is saying the “quiet part out loud” following the logical conclusion of that. Of course the Julia community is not a monolith and there will be divergent opinions on how to approach ecosystem development, but folks like the aforementioned HN commenter are looking for a clearer statement. That is, where do we fall between the two extremes of “novel architectures/approaches are the only way to go, if they do it well then we shouldn’t bother” to “Julia ML should be <span>#1</span> on everything”? And depending on the vision, what are some concrete steps that can be taken to support it?</p>
<p>Edit: to make sure I’m not underselling or misrepresenting things, there are some great and very clear roadmaps for parts of the ML space already. SciML and advanced AD come to mind. The question above is about the complement: what should be put into the “don’t expect anything big here unless you’re willing to help develop or fund it” bucket?</p>
        </div>

        <meta itemprop="headline" content="State of machine learning in Julia"/>

        

         

      </div>
      <div itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        <div>
          
          <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            <a itemprop="url" href="https://discourse.julialang.org/u/jzr"><span itemprop="name">jzr</span></a>
            
          </span></p>


          <p><span>
              <time itemprop="datePublished" datetime="2022-01-12T04:39:42Z">
                January 12, 2022,  4:39am
              </time>
              <meta itemprop="dateModified" content="2022-01-12T04:39:42Z"/>
          <span itemprop="position">#17</span>
          </span>
        </p></div>
        <p>+1 to calling it “conventional” ML (or some other name), since there is already an important programming language called <a href="https://en.wikipedia.org/wiki/Standard_ML">Standard ML</a> (meta-language) that Julia <a href="https://github.com/JuliaConcurrent/Reagents.jl">packages</a> take <a href="https://thautwarm.github.io/MLStyle.jl/latest/">features</a> from.</p>

        <meta itemprop="headline" content="State of machine learning in Julia"/>

        

         

      </div>
      <div itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        
        <div itemprop="articleBody">
          
<p>Yes, one thing to mention is that the Julia community is large and not a monolith and so there are many people developing these tools, all with their own reasons and aspirations. While there are some institutions that tend to have more of the developers for AD and ML libraries (specifically the Julia Lab and Julia Computing), those entities are large and not monoliths themselves. Even at the Julia Lab, I have no control over why people work on these problems, rather I just work with the students and research software engineers to guide them towards successful projects. Many people are doing it as ML for ML’s sake, and that’s fine.</p>
<p>But I think everyone should just be honest and clear as to some of the technical aspects and how they relate to the higher level decisions that have developed such large labs around this topic.</p>
<blockquote>
<p>trying to take the Python ML juggernaut on in its own territory is at best aspirational</p>
</blockquote>
<p>No, that’s an understatement. Let’s make it absolutely clear: there is nothing in the technical approach of differentiable programming that will make “conventional ML” faster. Period. A perfect Zygote or Diffractor will not make matrix multiplication kernels faster, it will not make convolutional kernels faster, and will not make faster Transformer kernels. For large “big data” conventional machine learning, calls to the kernels are on the order of tens to hundreds of seconds. The AD overhead of a slow AD like PyTorch or even just AutoGrad is in the miliseconds per operation. A source-to-source AD that cuts that down to close to zero is not getting even a 1% gain in those applications. Source-to-source AD is a much larger and harder project which trades the applicability to full dynamism and lower overhead (+ JIT compilation of all reverse paths) for a lot of added complexity. Conventional ML models like transformers do not use this dynamism. Those models do not have to worry about this overhead. The current AD work will not magically some day give you something that will be compelling to conventional ML users to make that pack up and switch from Python. If that was the purpose of those projects, then those projects would be an extremely dumb idea. Why build a brand new multi-million dollar stadium from your kid’s elementary school football team? It’s not a fit-for-purpose idea, and it will actually hold the Julia ecosystem back for a bit in this domain because of the added complexity.</p>
<p>Maybe having full language support will make some ergonomic gains, like it will integrate with the profiler and debuggers better than DSLs generally do, and if someone happens to write a model in the “wrong” way it could play nicer than say something like Jax where if you write something that isn’t functional and pure <img src="https://emoji.discourse-cdn.com/twitter/man_shrugging.png?v=10" title=":man_shrugging:" alt=":man_shrugging:"/> incorrect gradients can occur. But we’re talking minor gains at the end of the day for those applications.</p>
<p>But let’s dig even deeper. <a href="https://arxiv.org/abs/1810.07951">Zygote’s purpose was to not unroll loops so that the AD could JIT compile loopy code with small kernels</a>. That’s a very nice improvement for domains that need loopy code with small kernels. You can expect some pretty good performance gains, and you should choose Zygote if that’s your domain. Conventional ML is not in that domain. <img src="https://emoji.discourse-cdn.com/twitter/man_shrugging.png?v=10" title=":man_shrugging:" alt=":man_shrugging:"/> sorry. This emerging whole SciML domain happened to fit that domain and that’s how it found a home there which launched the organization and such. With that lens, it should be no surprise that in conventional ML Julia did not capture the whole audience whereas in SciML it became a big chunk of the (still rather small) field. It’s not random, and it’s not just sweat and grit, there’s real technical reasons behind it that you shouldn’t just gloss over.</p>
<p><a href="https://www.youtube.com/watch?v=mQnSRfseu0c">Diffractor.jl’s driving emphasis was a category theoretic formulation for higher order derivatives</a>. That gives you some massive speedups if you’re calculating third or fourth derivatives. But in conventional ML, who’s doing that? People don’t take Hessians of neural networks, let alone anything higher. Yes, there will be some spillover effects for how this improves conventional ML cases because of changing the target towards typed IR (potential compile-time improvements, maintainability, etc.). But flipping the Diffractor switch won’t be a day where Flux is suddenly a whole lot better for conventional ML. The reason for this kind of tool is <a href="https://www.youtube.com/watch?v=hKHl68Fdpq4">applications like physics-informed neural networks which routinely take 3rd order derivatives and above</a>. That’s the kind of application that funded it (specifically for use in <a href="https://github.com/SciML/NeuralPDE.jl">NeuralPDE.jl</a>). That’s a growing field, enough so that the <a href="https://youtu.be/jhDiaUL_RaM?t=2964">NVIDIA CEO keeps mentioning physics-informed neural networks</a>, and that’s an area where this kind of tool will cause a substantially noticeable difference. But that’s not NLP or image processing with convnets and transformers. For those cases, Diffractor would be a very hard project to get little gains, it would make no sense. If the purpose of Diffractor was those domains, it would be a bad idea.</p>
<p>So let’s refocus a little. Let’s say your goal is to improve conventional ML. How would you do it? Here’s a few things that come to mind for me:</p>
<ol>
<li>You could focus a project on conventional ML researchers by making it easier to develop faster kernels. This would help people out of the <a href="https://dl.acm.org/doi/abs/10.1145/3317550.3321441">“ML is stuck in a rut” problem</a> where better ideas can be slower than worse ideas simply because of how much the standard kernels have been optimized. If you want to do this, you should develop an AD that is really good at differentiating compute kernels. Zygote and Diffractor are not the tools for this, <a href="https://github.com/wsmoses/Enzyme.jl">Enzyme.jl is</a>. See <a href="https://dl.acm.org/doi/abs/10.1145/3458817.3476165">the paper for generating adjoints of GPU kernels</a> as an example. Or you could develop tools like <a href="https://github.com/JuliaSIMD/LoopVectorization.jl">LoopVectorization.jl</a> that are instead targeted to GPUs. <a href="https://github.com/JuliaGPU/KernelAbstractions.jl">KernelAbstractions.jl</a>.</li>
<li>You could focus a project on making it easier to capture more high level kernel fusions to optimize the kernel-centric code. That’s the e-graphs projects, and that’s what the folks at Google are doing with XLA. That’s what MLIR is aiming to do.</li>
<li>You could focus a project on making it easier to do distributed multi-GPU training. The ergonomics here are still rather difficult, with with TensorFlow/XLA. Easy installation and running it on local compute clusters. <a href="https://github.com/FluxML/DaggerFlux.jl">DaggerFlux</a> is probably the closest project we have to this other than <a href="https://github.com/FluxML/XLA.jl">XLA.jl</a>
</li>
<li>You could focus on writing faster GPU kernels for specific tasks.</li>
<li>You could make packages with experimental APIs to improve the ergonomics of conventional training workflows. Integrate some automation in there. Automatic MLops? ML libraries without implicit global parameter references?</li>
<li>You could, instead of waiting for Zygote and Diffractor to be “complete”, skip ahead and do ML on small DSLs. DSLs will always be easier to optimize given their constrained nature. <a href="https://github.com/dfdx/Yota.jl">Yota.jl is a great example of this</a>. It uses a tracer, <a href="https://github.com/dfdx/Ghost.jl">Ghost.jl</a>, to get a simpler IR and does some nice things on that.</li>
</ol>
<p>Noticeably absent from that list are the current ADs and differentiable programming work. That will do almost nothing for the conventional ML domain except maybe, just maybe, a few ergonomic improvements when everything works out. There are much better projects to work on if conventional ML was the goal. But for me and large parts of the Julia Lab, conventional ML is not the goal, which is why there is so much work and publications in differentiable programming tools. Hopefully this line of reasoning makes it as clear as daylight.</p>
        </div>

        <meta itemprop="headline" content="State of machine learning in Julia"/>

        

         

      </div>






    </div></div>
  </body>
</html>
