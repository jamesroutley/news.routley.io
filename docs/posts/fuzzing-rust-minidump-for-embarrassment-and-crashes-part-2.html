<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hacks.mozilla.org/2022/06/fuzzing-rust-minidump-for-embarrassment-and-crashes/">Original</a>
    <h1>Fuzzing rust-minidump for Embarrassment and Crashes â€“ Part 2</h1>
    
    <div id="readability-page-1" class="page"><article role="article">
    <p><span>This is part 2 of a series of articles on rust-minidump. For part 1, see <a href="https://hacks.mozilla.org/2022/06/everything-is-broken-shipping-rust-minidump-at-mozilla/">here</a>.</span></p>
<p><span>So to recap, we rewrote breakpadâ€™s minidump processor in Rust, wrote a ton of tests, and deployed to production without any issues. We killed it, perfect job.</span></p>
<p><span>And we </span><i><span>still</span></i><span> got massively dunked on by the fuzzer. Just absolutely destroyed.</span></p>
<p><span>I was starting to pivot off of rust-minidump work because I needed a bit of palette cleanser before tackling round 2 (handling native debuginfo, filling in features for other groups who were interested in rust-minidump, adding extra analyses that weâ€™d always wanted but were too much work to do in Breakpad, etc etc etc).</span></p>
<p><span>I was still getting some PRs from people filling in the corners they needed, but nothing that needed too much attention, a</span><span>nd then</span><a href="https://github.com/5225225"> <span>@5225225</span></a><span> smashed through the windows and released a bunch of exploding fuzzy rabbits into my office. </span></p>
<p><span>I had no idea who they were or why they were there. When I asked they just lowered one of their seven pairs of sunglasses and said â€œBecause I can. Now hold this bunnyâ€. I did as I was told and held the bunny. It was a good bun. Dare I say, it was a true </span><i><span>bnnuy</span></i><span>: it was</span><a href="https://www.llvm.org/docs/LibFuzzer.html"> <span>libfuzzer</span></a><span>. (Huh? You thought it was gonna be</span><a href="https://github.com/google/AFL"> <span>AFL</span></a><span>? Weird.)</span></p>
<p><span>As it turns out, several folks had built out some </span><i><span>really nice</span></i><span> infrastructure for quickly setting up a decent fuzzer for some Rust code:</span><a href="https://github.com/rust-fuzz/cargo-fuzz"> <span>cargo-fuzz</span></a><span>. They even wrote</span><a href="https://rust-fuzz.github.io/book/cargo-fuzz.html"> <span>a little book that walks you through the process</span></a><span>.</span></p>
<p><span>Apparently those folks had done such a good job that 5225225 had decided it would be a really great hobby to just pick up a random rust project and implement fuzzing for it. And then to fuzz it. And file issues. And PRs that fix those issues. And then implement even more fuzzing for it.</span></p>
<p><span>Please help my office is drowning in rabbits and I havenâ€™t seen my wife in weeks.</span></p>
<p><span>As far as I can tell, the process seems to genuinely be pretty easy! I think their</span><a href="https://github.com/luser/rust-minidump/pull/405"> <span>first fuzzer for rust-minidump</span></a><span> was basically just:</span></p>
<ul>
<li aria-level="1"><span>checked out the project</span></li>
<li aria-level="1"><span>run cargo fuzz init (which autogenerates a bunch of config files)</span></li>
<li aria-level="1"><span>write a file with this:</span></li>
</ul>
<pre><span>#![no_main]</span>

<span>use libfuzzer_sys::fuzz_target;</span>
<span>use minidump::*;</span>

<span>fuzz_target!(|data: &amp;[u8]| {</span>
<span>Â Â Â Â // Parse a minidump like a normal user of the library</span>
<span>Â Â Â Â if let Ok(dump) = minidump::Minidump::read(data) {</span>
<span>Â Â Â Â Â Â Â Â // Ask the library to get+parse several streams like a normal user.</span>

<span>Â Â Â Â Â Â Â Â let _ = dump.get_stream::&lt;MinidumpAssertion&gt;();</span>
<span>Â Â Â Â Â Â Â Â let _ = dump.get_stream::&lt;MinidumpBreakpadInfo&gt;();</span>
<span>Â Â Â Â Â Â Â Â let _ = dump.get_stream::&lt;MinidumpCrashpadInfo&gt;();</span>
<span>Â Â Â Â Â Â Â Â let _ = dump.get_stream::&lt;MinidumpException&gt;();</span>
<span>Â Â Â Â Â Â Â Â let _ = dump.get_stream::&lt;MinidumpLinuxCpuInfo&gt;();</span>
<span>Â Â Â Â Â Â Â Â let _ = dump.get_stream::&lt;MinidumpLinuxEnviron&gt;();</span>
<span>Â Â Â Â Â Â Â Â let _ = dump.get_stream::&lt;MinidumpLinuxLsbRelease&gt;();</span>
<span>Â Â Â Â Â Â Â Â let _ = dump.get_stream::&lt;MinidumpLinuxMaps&gt;();</span>
<span>Â Â Â Â Â Â Â Â let _ = dump.get_stream::&lt;MinidumpLinuxProcStatus&gt;();</span>
<span>Â Â Â Â Â Â Â Â let _ = dump.get_stream::&lt;MinidumpMacCrashInfo&gt;();</span>
<span>Â Â Â Â Â Â Â Â let _ = dump.get_stream::&lt;MinidumpMemoryInfoList&gt;();</span>
<span>Â Â Â Â Â Â Â Â let _ = dump.get_stream::&lt;MinidumpMemoryList&gt;();</span>
<span>Â Â Â Â Â Â Â Â let _ = dump.get_stream::&lt;MinidumpMiscInfo&gt;();</span>
<span>Â Â Â Â Â Â Â Â let _ = dump.get_stream::&lt;MinidumpModuleList&gt;();</span>
<span>Â Â Â Â Â Â Â Â let _ = dump.get_stream::&lt;MinidumpSystemInfo&gt;();</span>
<span>Â Â Â Â Â Â Â Â let _ = dump.get_stream::&lt;MinidumpThreadNames&gt;();</span>
<span>Â Â Â Â Â Â Â Â let _ = dump.get_stream::&lt;MinidumpThreadList&gt;();</span>
<span>Â Â Â Â Â Â Â Â let _ = dump.get_stream::&lt;MinidumpUnloadedModuleList&gt;();</span>
<span>Â Â Â Â }</span>
<span>});</span></pre>
<p><span>And thatâ€™sâ€¦ it? And all you have to do is type </span><span>cargo fuzz run</span><span> and it downloads, builds, and spins up an instance of</span><a href="https://www.llvm.org/docs/LibFuzzer.html"> <span>libfuzzer</span></a><span> and finds bugs in your project overnight?</span></p>
<p><span>Surely that wonâ€™t find anything interesting. Oh it did? It was largely all bugs in code I wrote? </span><b>Nice.</b></p>
<p><span>cargo fuzz is clearly awesome but letâ€™s not downplay the amount of bafflingly incredible work that 5225225 did here! Fuzzers, sanitizers, and other code analysis tools have a </span><i><span>very bad</span></i><span> reputation for drive-by contributions. </span></p>
<p><span>I think weâ€™ve all heard stories of someone running a shiny new tool on some big project they know nothing about, mass filing a bunch of issues that just say â€œthis tool says your code has a problem, fix itâ€ and then disappearing into the mist and claiming victory.</span></p>
<p><span>This is not a pleasant experience for someone trying to maintain a project. Youâ€™re dumping a lot on my plate if I donâ€™t know the tool, have trouble running the tool, donâ€™t know exactly how you ran it, etc. </span></p>
<p><span>Itâ€™s also very easy to come up with a huge pile of issues with very little sense of how significant they are. </span></p>
<p><span>Some things are only vaguely dubious, while others are horribly terrifying exploits. We only have so much time to work on stuff, youâ€™ve gotta help us out!</span></p>
<p><span>And in this regard 5225225â€™s contributions were just, bloody beautiful. </span></p>
<p><span>Like, shockingly fantastic.</span></p>
<p><span>They wrote really clear and detailed issues. When I skimmed those issues and misunderstood them, they quickly clarified and got me on the same page. And then they submitted a fix for the issue before I even considered working on the fix. And quickly responded to review comments. I didnâ€™t even bother asking them to squashing their commits because damnit they </span><i><span>earned</span></i><span> those 3 commits in the tree to fix one overflow.</span></p>
<p><span>Then they submitted a PR to merge the fuzzer. They helped me understand how to use it and debug issues. Then they started asking questions about the project and started writing more fuzzers for other parts of it. And now thereâ€™s like 5 fuzzers and a bunch of fixed issues!</span></p>
<p><span>I donâ€™t care how good cargo fuzz is, thatâ€™s a lot of frigginâ€™ really good work! Like I am going to cry!! This was so helpful??? ğŸ˜­</span></p>
<p><span>That said, I will take a </span><i><span>little</span></i><span> credit for this going so smoothly: both Rust itself and rust-minidump are written in a way thatâ€™s very friendly to fuzzing. Specifically, rust-minidump is riddled with assertions for â€œhmm this seems messed up and shouldnâ€™t happen but maybe?â€ and Rust turns integer overflows into panics (crashes) in debug builds (and index-out-of-bounds is always a panic).</span></p>
<p><span>Having lots of assertions everywhere makes it </span><i><span>a lot</span></i><span> easier to detect situations where things go wrong. And when you </span><i><span>do</span></i><span> detect that situation, the crash will often point pretty close to where things went wrong.</span></p>
<p><span>As someone who has worked on detecting bugs in Firefox with sanitizer and fuzzing folks, let me tell you what really sucks to try to do anything with: â€œHey so on my machine this enormous complicated machine-generated input caused Firefox to crash </span><i><span>somewhere</span></i><span> this </span><i><span>one time</span></i><span>. No, I canâ€™t reproduce it. You wonâ€™t be able to reproduce it either. Anyway, try to fix it?â€</span></p>
<p><span>Thatâ€™s not me throwing shade on anyone here. I am all of the people in that conversation. The struggle of productively fuzzing Firefox is all too real, and I do not have a good track record of fixing those kinds of bugs.Â </span></p>
<p><span>By comparison I am absolutely </span><i><span>thriving</span></i><span> under â€œYeah you can deterministically trip this assertion with this tiny input you can just check in as a unit testâ€.</span></p>
<p><span>And what did we screw up? Some legit stuff! Itâ€™s Rust code, so I am fairly confident none of the issues were </span><i><span>security</span></i><span> concerns, but they were definitely quality of implementation issues, and could have been used to at very least denial-of-service the minidump processor.</span></p>
<p><span>Now letâ€™s dig into the issues they found!</span></p>
<h2><b>#428: Corrupt stacks caused infinite loops until OOM on ARM64</b></h2>
<p><a href="https://github.com/luser/rust-minidump/issues/428"><span>Issue</span></a></p>
<p><span>As noted in the background, stackwalking is a giant heuristic mess and you can find yourself going backwards or stuck in an infinite loop. To keep this under control, stackwalkers generally require </span><i><span>forward progress</span></i><span>. </span></p>
<p><span>Specifically, they require the stack pointer to move down the stack. If the stack pointer ever goes backwards or stays the same, we just call it quits and end the stackwalk there.</span></p>
<p><span>However, you canâ€™t be </span><i><span>so</span></i><span> strict on ARM because leaf functions </span><i><span>may not change the stack size at all</span></i><span>. Normally this would be impossible because every function call </span><i><span>at least</span></i><span> has to push the return address to the stack, but ARM has the </span><i><span>link register</span></i><span> which is basically an extra buffer for the return address. </span></p>
<p><span>The existence of the link register in conjunction with an ABI that makes the callee responsible for saving and restoring it means leaf functions </span><i><span>can</span></i><span> have 0-sized stack frames!</span></p>
<p><span>To handle this, an ARM stackwalker must allow for there to be no forward progress for the </span><i><span>first</span></i><span> frame of a stackwalk, </span><b>and then become more strict</b><span>. Unfortunately I hand-waved that second part and ended up allowing infinite loops with no forward progress:</span></p>
<pre><span>// If the new stack pointer is at a lower address than the old,</span>
<span>// then that&#39;s clearly incorrect. Treat this as end-of-stack to</span>
<span>// enforce progress and avoid infinite loops.</span>
<span>//</span>
<span>// NOTE: this check allows for equality because arm leaf functions</span>
<span>// may not actually touch the stack (thanks to the link register</span>
<span>// allowing you to &#34;push&#34; the return address to a register).</span>
<span>if frame.context.get_stack_pointer() &lt; self.get_register_always(&#34;sp&#34;) as u64 {</span>
<span>Â Â Â Â trace!(&#34;unwind: stack pointer went backwards, assuming unwind complete&#34;);</span>
<span>Â Â Â Â return None;</span>
<span>}</span></pre>
<p><span>So if the ARM64 stackwalker ever gets stuck in an infinite loop on one frame, it will just build up an infinite backtrace until itâ€™s killed by an OOM. This is very nasty because itâ€™s a potentially very slow denial-of-service that eats up all the memory on the machine!</span></p>
<p><span>This issue was actually originally discovered and fixed in</span><a href="https://github.com/luser/rust-minidump/issues/300"> <span>#300</span></a> <i><span>without</span></i><span> a fuzzer, but when I fixed it for ARM (32-bit) I completely forgot to do the same for ARM64. Thankfully the fuzzer was evil enough to discover this infinite looping situation on its own, and the fix was just â€œcopy-paste the logic from the 32-bit implâ€.</span></p>
<p><span>Because this issue was actually encountered in the wild, we know this was a serious concern! Good job, fuzzer!</span></p>
<p><span>(This issue specifically affected minidump-processor and minidump-stackwalk)</span></p>
<h3><b>#407: MinidumpLinuxMaps address-based queries didnâ€™t work at all</b></h3>
<p><a href="https://github.com/luser/rust-minidump/issues/407"><span>Issue</span></a></p>
<p><span>MinidumpLinuxMaps is an interface for querying the dumped contents of Linuxâ€™s /proc/self/maps file. This provides metadata on the permissions and allocation state for mapped ranges of memory in the crashing process.</span></p>
<p><span>There are two usecases for this: just getting a full dump of all the process state, and specifically querying the memory properties for a specific address (â€œhey is this address executable?â€). The dump usecase is handled by just shoving everything in a Vec. The address usecase requires us to create a RangeMap over the entries.</span></p>
<p><span>Unfortunately, a comparison was flipped in the code that created the keys to the RangeMap, which resulted in every </span><i><span>correct</span></i><span> memory range being discarded AND invalid memory ranges being accepted. The fuzzer was able to catch this because the invalid ranges tripped an assertion when they got fed into the RangeMap (hurray for redundant checks!).</span></p>
<pre><span>// OOPS</span>
<span>if self.base_address &lt; self.final_address {Â </span>
<span>Â return None;Â </span>
<span>}</span></pre>
<p><span>Although tests were written for MinidumpLinuxMaps, they didnâ€™t include any invalid ranges, and just used the dump interface, so the fact that the RangeMap was empty went unnoticed!</span></p>
<p><span>This </span><i><span>probably</span></i><span> would have been quickly found as soon as anyone tried to actually use this API in practice, but itâ€™s nice that we caught it beforehand! Hooray for fuzzers!</span></p>
<p><span>(This issue specifically affected the minidump crate which technically could affect minidump-processor and minidump-stackwalk. Although they didnâ€™t yet actually do address queries, they may have crashed when fed invalid ranges.)</span></p>
<h2><b>#381: OOM from reserving memory based on untrusted list length.</b></h2>
<p><a href="https://github.com/luser/rust-minidump/issues/381"><span>Issue</span></a></p>
<p><span>Minidumps have lots of lists which we end up collecting up in a Vec or some other collection. Itâ€™s quite natural and more efficient to start this process with something like </span><span>Vec::with_capacity(list_length)</span><span>. Usually this is fine, but if the minidump is corrupt (or malicious), then this length could be impossibly large and cause us to immediately OOM.</span></p>
<p><span>We were broadly aware that this was a problem, and had discussed the issue in</span><a href="https://github.com/luser/rust-minidump/issues/326"> <span>#326</span></a><span>, but then everyone left for the holidays. #381 was a nice kick in the pants to actually fix it, and gave us a free simple test case to check in.</span></p>
<p><span>Although the naive solution would be to fix this by just removing the reserves, we opted for a solution that guarded against obviously-incorrect array lengths. This allowed us to keep the performance win of reserving memory while also making rust-minidump fast-fail instead of vaguely trying to do something and hallucinating a mess.</span></p>
<p><span>Specifically, @Swatinem introduced a function for checking that the amount of memory left in the section weâ€™re parsing is </span><i><span>large enough</span></i><span> to even hold the claimed amount of items (based on their known serialized size). This should mean the minidump crate can only be induced to reserve O(n) memory, where n is the size of the minidump itself.</span></p>
<p><span>For some scale:</span></p>
<ul>
<li aria-level="1"><span>A minidump for Firefoxâ€™s main process with about 100 threads is about 3MB.</span></li>
<li aria-level="1"><span>A minidump for a stackoverflow from infinite recursion (8MB stack, 9000 calls) is about 8MB.</span></li>
<li aria-level="1"><span>A breakpad symbol file for Firefoxâ€™s main module can be about </span><b>200MB</b><span>.</span></li>
</ul>
<p><span>If youâ€™re symbolicating, Minidumps probably wonâ€™t be your memory bottleneck. ğŸ˜¹</span></p>
<p><span>(This issue specifically affected the minidump crate and therefore also minidump-processor and minidump-stackwalk.)</span></p>
<h2><b>The Many Integer Overflows and My Greatest Defeat</b></h2>
<p><span>The rest of the issues found were relatively benign integer overflows. I claim theyâ€™re benign because rust-minidump should </span><i><span>already</span></i><span> be working under the assumption that all the values it reads out of the minidump could be corrupt garbage. This means its code is riddled with â€œis this nonsenseâ€ checks and those usually very quickly catch an overflow (or at worst print a nonsense value for some pointer).</span></p>
<p><span>We still fixed them all, because thatâ€™s shaky as heck logic and we want to be robust. But yeah none of these were even denial-of-service issues, as far as I know.</span></p>
<p><span>To demonstrate this, letâ€™s discuss the most evil and embarrassing overflow which was definitely my fault and I am </span><i><span>still</span></i><span> mad about it but in a like â€œhow the heckâ€ kind of way!?</span></p>
<p><span>The overflow is back in our old friend the stackwalker. Specifically in the code that attempts to unwind using frame pointers. Even more specifically, when offsetting the supposed frame-pointer to get the location of the supposed return address:</span></p>
<pre><span>let caller_ip = stack_memory.get_memory_at_address(last_bp + POINTER_WIDTH)?;</span>
<span>let caller_bp = stack_memory.get_memory_at_address(last_bp)?;</span>
<span>let caller_sp = last_bp + POINTER_WIDTH * 2;</span></pre>
<p><span>If the frame pointer (</span><span>last_bp</span><span>) was ~</span><span>u64::MAX</span><span>, the offset on the first line would overflow and we would instead try to load ~null. All of our loads are explicitly fallible (we assume everything is corrupt garbage!), and nothing is ever mapped to the null page in normal applications, so this load would reliably fail as if we had guarded the overflow. Hooray!</span></p>
<p><span>â€¦but the overflow would panic in debug builds because thatâ€™s how debug builds work in Rust!</span></p>
<p><span>This was actually found, reported, and fixed </span><i><span>without</span></i><span> a fuzzer in</span><a href="https://github.com/luser/rust-minidump/issues/251"> <span>#251</span></a><span>. All it took was a simple guard:</span></p>
<p><span>(All the casts are because this specific code is used in the x86 impl </span><i><span>and</span></i><span> the x64 impl.)</span></p>
<pre><span>if last_bp as u64 &gt;= u64::MAX - POINTER_WIDTH as u64 * 2 {</span>
<span>Â Â Â Â // Although this code generally works fine if the pointer math overflows,</span>
<span>Â Â Â Â // debug builds will still panic, and this guard protects against it without</span>
<span>Â Â Â Â // drowning the rest of the code in checked_add.</span>
<span>Â Â Â Â return None;</span>
<span>}</span>

<span>let caller_ip = stack_memory.get_memory_at_address(last_bp as u64 + POINTER_WIDTH as u64)?;</span>
<span>let caller_bp = stack_memory.get_memory_at_address(last_bp as u64)?;</span>
<span>let caller_sp = last_bp + POINTER_WIDTH * 2;</span></pre>
<p><span>And then it was found, reported, and fixed </span><b>again</b> <i><span>with a fuzzer</span></i><span> in</span><a href="https://github.com/luser/rust-minidump/issues/422"> <span>#422</span></a><span>.</span></p>
<p><span>Wait what?</span></p>
<p><span>Unlike the infinite loop bug, I </span><i><span>did</span></i><span> remember to add guards to all the unwinders for this problemâ€¦ but I did the overflow check in 64-bit </span><i><span>even for the 32-bit platforms</span></i><span>.</span></p>
<p><b>slaps forehead</b></p>
<p><span>This made the bug report especially confusing at first because the overflow was like 3 lines away from </span><i><span>a guard for that exact overflow</span></i><span>. As it turns out, the mistake wasnâ€™t actually as obvious as it sounds! To understand what went wrong, letâ€™s talk a bit more about pointer width in minidumps.</span></p>
<p><span>A single instance of rust-minidump has to be able to handle crash reports from </span><i><span>any</span></i><span> platform, even ones it isnâ€™t natively running on. This means it needs to be able to handle both 32-bit and 64-bit platforms in one binary. To avoid the misery of copy-pasting everything or making everything generic over pointer size, rust-minidump prefers to work with 64-bit values wherever possible, even for 32-bit plaftorms.</span></p>
<p><span>This isnâ€™t just us being lazy: the minidump format itself does this! Regardless of the platform, a minidump will refer to ranges of memory with a</span><a href="https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/ns-minidumpapiset-minidump_memory_descriptor"> <span>MINIDUMP_MEMORY_DESCRIPTOR</span></a><span> whose base address is a 64-bit value, even on 32-bit platforms!</span></p>
<pre><span>typedef struct _MINIDUMP_MEMORY_DESCRIPTOR {</span>
<span>Â Â ULONG64Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  StartOfMemoryRange;</span>
<span>Â Â MINIDUMP_LOCATION_DESCRIPTOR Memory;</span>
<span>} MINIDUMP_MEMORY_DESCRIPTOR, *PMINIDUMP_MEMORY_DESCRIPTOR;</span></pre>
<p><span>So quite naturally rust-minidumpâ€™s interface for querying saved regions of memory just operates on 64-bit (u64) addresses unconditionally, and 32-bit-specific code casts its u32 address to a u64 before querying memory.</span></p>
<p><span>That means the code with the overflow guard </span><i><span>was</span></i><span> manipulating those values as u64s on x86! The </span><i><span>problem</span></i><span> is that after all the memory loads we would then go back to â€œnativeâ€ sizes and compute </span><span>caller_sp = last_bp + POINTER_WIDTH * 2</span><span>. This would overflow a u32 and crash in debug builds. ğŸ˜¿</span></p>
<p><span>But hereâ€™s the really messed up part: </span><i><span>getting to that point meant we were successfully loading memory up to that address</span></i><span>. The first line where we compute caller_ip reads it! So this overflow meansâ€¦ we wereâ€¦ loading memoryâ€¦ from an address that was beyond u32::MAXâ€¦!?</span></p>
<p><span>Yes!!!!!!!!</span></p>
<p><span>The fuzzer had found an absolutely </span><i><span>brilliantly evil input</span></i><span>.</span></p>
<p><span>It abused the fact that MINIDUMP_MEMORY_DESCRIPTOR </span><i><span>technically</span></i><span> lets 32-bit minidumps define memory ranges beyond </span><span>u32::MAX</span> <i><span>even though they could never actually access that memory!</span></i><span> It could then have the u64-based memory accesses succeed but still have the â€œnativeâ€ 32-bit operation overflow!</span></p>
<p><span>This is so messed up that I didnâ€™t even </span><i><span>comprehend</span></i><span> that it had done this until I wrote my own test and realized that it wasnâ€™t actually failing because I </span><i><span>foolishly</span></i><span> had limited the range of valid memory to the mere 4GB a normal x86 process is restricted to.</span></p>
<p><span>And I mean that quite literally: this is exactly the issue that creates</span><a href="https://youtu.be/kpk2tdsPh0A?t=638"> <span>Parallel Universes in Super Mario 64</span></a><span>.</span></p>
<p><span>But hey my code was probably just bad. I know google loves sanitizers and fuzzers, so I bet google breakpad found this overflow ages ago and fixed it:</span></p>
<pre><span>uint32_t last_esp = last_frame-&gt;context.esp;</span>
<span>uint32_t last_ebp = last_frame-&gt;context.ebp;</span>
<span>uint32_t caller_eip, caller_esp, caller_ebp;</span>

<span>if (memory_-&gt;GetMemoryAtAddress(last_ebp + 4, &amp;caller_eip) &amp;&amp;</span>
<span>Â Â Â Â memory_-&gt;GetMemoryAtAddress(last_ebp, &amp;caller_ebp)) {</span>
<span>Â Â Â Â caller_esp = last_ebp + 8;</span>
<span>Â Â Â Â trust = StackFrame::FRAME_TRUST_FP;</span>
<span>} else {</span>
<span>Â Â Â Â ...</span></pre>
<p><span>Ah. Hmm. They donâ€™t guard for any kind of overflow for those uint32_tâ€™s (or the uint64_tâ€™s in the x64 impl).</span></p>
<p><span>Well ok GetMemoryAtAddress does actual bounds checks so the load from ~null will generally fail like it does in rust-minidump. But what about the Parallel Universe overflow that lets GetMemoryAtAddress succeed?</span></p>
<p><span>Ah well surely breakpad is more principled with integer width than I wasâ€“</span></p>
<pre><span>virtual bool GetMemoryAtAddress(uint64_t address, uint8_t*Â  value) const = 0;</span>
<span>virtual bool GetMemoryAtAddress(uint64_t address, uint16_t* value) const = 0;</span>
<span>virtual bool GetMemoryAtAddress(uint64_t address, uint32_t* value) const = 0;</span>
<span>virtual bool GetMemoryAtAddress(uint64_t address, uint64_t* value) const = 0;</span>
</pre>
<p><span>Whelp congrats to 5225225 for finding an overflow thatâ€™s portable between two implementations in two completely different languages by exploiting the very nature of the file format itself!</span></p>
<p><span>In case youâ€™re wondering what the implications of this overflow are: itâ€™s still basically benign. Both rust-minidump and google-breakpad will successfully complete the frame pointer analysis and yield a frame with a ~null stack pointer.</span></p>
<p><span>Then the outer layer of the stackwalker which runs all the different passes in sequence will see something succeeded but that the frame pointer went backwards. At this point it will discard the stack frame and terminate the stackwalk normally and just calmly output whatever the backtrace was up to that point. Totally normal and reasonable operation.</span></p>
<p><span>I expect this is why no one would notice this in breakpad even if you run fuzzers and sanitizers on it: nothing in the code actually does anything </span><i><span>wrong</span></i><span>. Unsigned integers are defined to wrap, the program behaves reasonably, everything is </span><i><span>kinda</span></i><span> fine. We only noticed this in rust-minidump because </span><i><span>all</span></i><span> integer overflows panic in Rust debug builds.</span></p>
<p><span>However this â€œbenignâ€ behaviour </span><i><span>is</span></i><span> slightly different from properly guarding the overflow. Both implementations will normally try to move on to </span><i><span>stack scanning</span></i><span> when the frame pointer analysis fails, but in this case they give up immediately. Itâ€™s </span><i><span>important</span></i><span> that the frame pointer analysis properly identifies failures so that this cascading can occur. Failing to do so is definitely a bug!</span></p>
<p><span>However in this case the stack is partially in a parallel universe, so getting any kind of useful backtrace out of it isâ€¦ dubious to say the least.</span></p>
<p><span>So I totally stand by â€œthis is totally benign and not actually a problemâ€ but also â€œthis is sketchy and we should have the bounds check so we can be confident in this codeâ€™s robustness and correctnessâ€.</span></p>
<p><span>Minidumps are </span><i><span>all</span></i><span> corner cases â€” they literally get generated </span><i><span>when a program encounters an unexpected corner case</span></i><span>! Itâ€™s </span><i><span>so</span></i><span> tempting to constantly shrug off situations as â€œwell no reasonable program would ever do this, so we can ignore itâ€â€¦ but YOU CANâ€™T.</span></p>
<p><span>You would not have a minidump at your doorstep if the program had behaved reasonably! The fact that you are trying to inspect a minidump means something messed up happened, and you need to just deal with it!</span></p>
<p><span>Thatâ€™s why we put so much energy into testing this thing, itâ€™s a nightmare!</span></p>
<p><span>I am </span><i><span>extremely</span></i><span> paranoid about this stuff, but that paranoia is based on the horrors I have seen. There are always more corner cases. </span></p>
<p><span>There are </span><i><span>ALWAYS</span></i><span> more corner cases. </span><b>ALWAYS</b><span>.</span></p>

    <section>
                                
                                <p><a href="https://hacks.mozilla.org/author/abeingessnermozilla-com/">More articles by Aria Beingessnerâ€¦</a></p>
                  </section>
  </article></div>
  </body>
</html>
