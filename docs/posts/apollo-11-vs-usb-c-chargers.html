<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://forrestheller.com/Apollo-11-Computer-vs-USB-C-chargers.html">Original</a>
    <h1>Apollo 11 vs. USB-C Chargers</h1>
    
    <div id="readability-page-1" class="page">

<p>
I think it is healthy to compare historical and modern computing. Let&#39;s
see how the CPUs contained in recent USB-C wall chargers compare to the
power of the Apollo 11 Guidance Computer (AGC). The Apollo 11 spacecraft carried 3 humans to the moon and back in 1969.
</p>
<table>
<tbody><tr>
<th>Device</th>
<th>Google Pixel 18W Charger</th>
<th>Huawei 40W SuperCharge</th>
<th>Anker PowerPort Atom PD 2</th>
<th>Apollo 11 Moon Landing Guidance Computer (AGC)</th>
</tr>
<tr>
<td>Function</td>
<td>Charges a phone</td>
<td>Charges a phone or maybe a laptop</td>
<td>Charges 2 phones or maybe laptops </td>
<td>
<ul>
<li>Fly most-of-the-way to moon (<acronym title="Command and Service Module">CSM</acronym>)</li>
<li>Land on moon (<acronym title="Lunar Excursion Module">LEM</acronym>)</li>
<li>Take off from moon (<acronym title="Lunar Excursion Module">LEM</acronym>)</li>
<li>Fly back to Earth (<acronym title="Command and Service Module">CSM</acronym>)</li>
</ul>
</td>
</tr>
<tr>
<td>Microchip(s)</td>
<td>Weltrend WT6630P</td>
<td>Richtek RT7205</td>
<td>Cypress CYPD4225</td>
<td>Discrete components</td>
</tr>
<tr>
<td>Clock Speed</td>
<td>10 MHz</td>
<td>22.7 MHz</td>
<td>48 MHz</td>
<td>1.024 MHz</td>
</tr>
<tr>
<td>RAM</td>
<td>512 bytes</td>
<td>&#34;0.75kB&#34;</td>
<td>8KB</td>
<td>
2048 15-bit words
/
4KB
if you include the parity bit in each word
</td>
</tr>
<tr>
<td>Program Storage Space </td>
<td>8KB</td>
<td>24KB (Mask ROM + OTP)</td>
<td>128KB Flash</td>
<td>36,864 15-bit words
/
72KB
if you include the parity bit in each word
</td>
</tr>
<tr>
<td>Instruction Set</td>
<td>Intel 8051 (8-bit)</td>
<td>Unknown</td>
<td>ARM Cortex-M0 32-bit implementing ARMv6-M</td>
<td>16-bit accumulator based</td>
            </tr>
<tr>
<td>Sources</td>
<td>
<a href="https://www.chargerlab.com/google-pixel-18w-pd-charger-tc-g1000-teardown-review/">ChargerLabs Teardown</a> 
<a href="http://www.sabaotech.cn/uploads/soft/170308/1-1F30Q55327.PDF">WT6630P Datasheet</a>
</td>
<td>
<a href="https://www.chargerlab.com/huawei-40w-supercharge-scp-charger-hw-100400c00-teardown-review/">ChargerLabs Teardown</a>
<a href="https://www.richtek.com/assets/product_file/RT7205A/DS7205A-00.pdf">RT2705 Datasheet</a>
</td>
<td>
<a href="https://www.chargerlab.com/anker-powerport-atom-pd-2-with-gan-a2029-teardown-review/">ChargerLabs Teardown</a>
<a href="https://www.cypress.com/file/220266/download">CYPD4225 Datasheet</a>
</td>
<td>
<a href="https://www.ibiblio.org/apollo/assembly_language_manual.html">CPU description</a> 
<a href="https://history.nasa.gov/computers/Ch2-5.html">Memory</a>
<a href="https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/20090016290.pdf">Functional overview</a>
</td><td>
</td></tr>
</tbody></table>
<h2>Interpretation</h2>
The most powerful CPU in the table is from the Anker PowerPort Atom PD 2 (CYPD4225).  Compared with the Apollo 11 Guidance Computer it runs at ~48 times the clock speed with 1.8x the program space. It&#39;s very tempting to claim that the Anker PowerPort Atom PD 2 could fly me to the moon.  But we need more analysis.  What if the Apollo 11 Guidance Computer contains dedicated hardware which missing in the CYPD4225 and cannot be replicated in software? Let&#39;s compare the CYPD4225 to the Apollo 11 Guidance Computer.  I&#39;ll be using the excellent <a href="https://www.ibiblio.org/apollo/assembly_language_manual.html">Virtual AGC documentation as a reference.</a> 
<h2>Speed</h2>
<p>
The Apollo 11 Guidance Computer has a master clock frequency of 1.024MHz. Instructions need
at least 12 clock cycles (11.72uS). It operates using <a href="https://www.ibiblio.org/apollo/hrst/archive/1029.pdf">one&#39;s compliment integer</a> arithmetic. There is no floating point. There is a single accumulator register to perform arithmetic.
</p>
<p>
The Anker PowerPort Atom PD 2 uses a CYPD4225, containing an ARM Cortex-M0 CPU.  Luckily
for this analysis both the Apollo 11 Guidance Computer and the Cortex-M0 CPUs are very
predictable compared to more sophisticated modern CPUs.  They
have no cache and memory access happens at a constant speed. Instructions execute in-order.
They have no hardware floating point. They have no vector/matrix hardware (like
AVX, SSE, or NEON). Therefore we can learn a lot by just comparing
the cycles of roughly equivalent instructions.</p>
<table>
<tbody><tr>
<th>Instruction</th>
<th><a href="https://www.ibiblio.org/apollo/assembly_language_manual.html">Apollo 11 Guidance Computer Cycles</a></th>
<th><a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0432c/CHDCICDF.html">ARM Cortex-M0 Cycles</a></th>
</tr>
<tr>
<td>15-bit Addition and Subtraction</td>
<td>24 (2 * 12)</td>
<td>1</td>
</tr>
<tr>
<td>31 Bit Addition and Subtraction</td>
<td>36 (3 * 12)
</td><td>1</td>
</tr>
<tr>
<td>Multiply</td>
<td>36 (3 * 12)</td>
<td>1 - <a href="https://www.cypress.com/file/220266/download">see datasheet</a></td>
</tr>
<tr>
<td>Divide</td>
<td>72 (6 * 12)</td>
<td>Not Available</td>
</tr>
<tr>
<td>Branch if zero</td>
<td>24 (2 * 12)</td>
<td>1-4 without CMP, 2-5 with CMP</td>
</tr>
<tr>
<td>CCS (Count Compare Skip) / CMP</td>
<td>24 (2 * 12)</td>
<td>1</td>
</tr>
<tr>
<td>Store accumulator/register to memory (XHC / STR)</td>
<td>24 (2 * 12)</td>
<td>2</td>
</tr>
<tr>
<td>Load memory to accumulator/register (XHC / LD)</td>
<td>24 (2 * 12)</td>
<td>2</td>
</tr>
</tbody></table>
From the table we see that instructions are usually a proportionate number
of low clock cycles. Most of the time each Apollo 11 Guidance
Computer instruction takes 12 times more clock cycles than the
Cortex-M0. Given that the Cortex-M0 runs at 46.9x
the clock speed and
that they are otherwise comparable (no cache, no vectors) I claim,
for most applications:
</div>
  </body>
</html>
