<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.warpstream.com/blog/taking-out-the-trash-garbage-collection-of-object-storage-at-massive-scale">Original</a>
    <h1>Garbage collection of object storage at scale</h1>
    
    <div id="readability-page-1" class="page"><div fs-codehighlight-theme="a11y-light" fs-toc-element="contents" fs-toc-offsettop="5.5rem" fs-richtext-element="rich-text" fs-codehighlight-element="code"><p>Over the last 10 years, I’ve built several distributed systems on top of object storage, with <a href="https://www.warpstream.com/bring-your-own-cloud-kafka-data-streaming" target="_blank">WarpStream</a> being the most recent. One consistent factor across all of these systems is how much time we spent solving what seems like a relatively straightforward problem: removing files from object storage that had been logically deleted either due to data expiry or compaction.</p><p>I discussed this in more detail in <a href="https://www.warpstream.com/blog/the-case-for-shared-storage" target="_blank">“The Case for Shared Storage” blog post</a>, but to briefly recap: every shared storage system I’ve ever built has looked something like this:</p><figure><p><img src="https://cdn.prod.website-files.com/64baaecd9c5c9b1b6c38aa0e/67f716b38eeba2a7e51efdfb_Group%20625.png" loading="lazy" alt=""/></p></figure><p>Clients interact with stateless nodes (that are perhaps split into different “roles”). The stateless nodes abstract over a shared storage backend (like object storage) and a strongly-consistent metadata store to create some kind of logical abstraction, in WarpStream’s case: the Apache Kafka protocol.</p><p>There are a few ways in which a WarpStream file can end up logically deleted in the metadata store, and therefore needs to be physically deleted from the object store:</p><p><strong>All the data in the file has expired due to the configured topic TTLs: ↴</strong></p><figure><p><img src="https://cdn.prod.website-files.com/64baaecd9c5c9b1b6c38aa0e/67f7094e822274e9e061e3ed_Group%20615.png" loading="lazy" alt=""/></p></figure><p><strong>All of the data in the file is deleted due to explicit topic deletions: ↴</strong></p><figure><p><img src="https://cdn.prod.website-files.com/64baaecd9c5c9b1b6c38aa0e/67f7095e1318720a65ab953c_Group%20614.png" loading="lazy" alt=""/></p></figure><p><strong>The file was logically deleted by a compaction in which this particular file participated as an input: ↴</strong></p><figure><p><img src="https://cdn.prod.website-files.com/64baaecd9c5c9b1b6c38aa0e/67f718e5c2520abf68d79666_Group%20617%20(2).png" loading="lazy" alt=""/></p></figure><p>In the rest of this post, I’ll go over a few different ways to solve this problem by using a <a href="#approach-1-delayed-queue">delayed queue</a>, <a href="#approach-2-asynchronous-reconciliation">async reconciliation</a>, or <a href="#bringing-it-all-together">both</a>. But before I introduce what I think the best ways to solve this problem are, let’s first go over a few approaches that seem obvious, but don’t work well in practice like <a href="#why-not-just-use-a-bucket-policy">bucket policies</a> and <a href="#why-not-just-use-synchronous-deletion">synchronous deletion</a>.</p><h2>Why Not Just Use a Bucket Policy?</h2><p>The easiest way to handle object storage cleanup would be to use a bucket policy with a configurable TTL. For example, we could configure an object storage policy that automatically deletes files that are more than 7 days old. For simple or time-series oriented systems, this is often a good solution.</p><p>However, for more complex systems like WarpStream, which has to provide the abstraction of Apache Kafka, this approach doesn’t work. For example, consider a WarpStream cluster with hundreds or thousands of different topics. Some topics could be configured with retention as low as 1 hour, and others with retention as high as 90 days. If we relied on a simple bucket policy, then we’d have to configure the bucket policy to be <em>at least</em> 90 days, which would incur excessive storage costs for the topics with lower retention because a WarpStream file can contain data for many different topics.</p><p>Even if we were comfortable with requiring that all topics within a single cluster share a single retention, other implementation details and features in Kafka can’t be implemented with a simple object storage bucket policy. For example, Kafka has a feature called “compacted topics”. In a compacted topic, records are deleted / expired not when they’re too old, but when <em>they’re overwritten by a new record with the same key</em>. A record may be overwritten seconds after it was first written, or several years later.</p><p>Unfortunately, bucket policies only work as a mechanism for cleaning up object storage files for the most simple use-cases. Shared storage systems that need to provide more advanced functionality will have to implement object cleanup in the system itself.</p><h2>Why Not Just Use Synchronous Deletion?</h2><p>Naively, it seems like whenever the metadata store decides to logically delete a file, it should be able to go and physically remove the file from the object store at the same time, keeping the two systems in sync:</p><div><pre><code>// Tada.
metadataStore.DeleteFile(fileID)
objectStore.DeleteFile(fileID)</code></pre></div><p>‍</p><p>In traditional programming language theory, this method of garbage collection is analogous to “reference tracking”. But distributed systems aren’t programming languages, and the code above doesn’t work in the real world:</p><div><pre><code>if err := metadataStore.DeleteFile(fileID); err != nil {
    // This is fine, we can just retry later.
}

if err := objectStore.DeleteFile(fileID); err != nil {
    // Uh oh. This file will be orphaned in object storage forever.
}</code></pre></div><p>‍</p><p>If the file is removed from the metadata store successfully, but isn’t removed from the object store (because a node crashed, we got a 500, etc.), then that file will be <em>orphaned</em> in the object store.</p><p>An orphan file is a file that is physically present in the object store, but not logically tracked in the metadata store, and therefore not part of the distributed database anymore. This is a problem because these orphaned files will accumulate over time and cost you a lot of money.</p><figure><p><img src="https://cdn.prod.website-files.com/64baaecd9c5c9b1b6c38aa0e/67f7db3fe08da39760fd0fdc_Group%20620%20(5).png" loading="lazy" alt=""/></p></figure><p>But actually, there’s another reason this approach doesn’t work even if both deletes succeeded atomically somehow: in-flight queries. The lifecycle of a query in a shared storage system usually proceeds in two steps:</p><ol role="list"><li>Query the metadata store for relevant files.</li><li>Execute the query on the relevant files.</li></ol><p>If a file is physically deleted after it was returned in step 1, but before step 2 has completed, then that query will fail because its query plan has a reference to a file that no longer exists.</p><p>To make this concrete, imagine the lifecycle of a consumer Fetch request in WarpStream for a consumer trying to read partition 2 of a topic called logs with the next offset to read being 300:</p><ol role="list"><li>The WarpStream Agent will query the metadata store to find which file contains the batch of data that starts at offset 300 for partition 2 of the logs topic. In this example, the metadata store returns file ID 451.</li><li>Next, the WarpStream Agents will go and read the data out of file 451, using the file’s metadata returned from the metadata store as an index.</li></ol><figure><p><img src="https://cdn.prod.website-files.com/64baaecd9c5c9b1b6c38aa0e/67f7db66f980a473e4e8b42b_Group%20627%20(2).png" loading="lazy" alt=""/></p></figure><p>However, WarpStream Agents also <a href="https://docs.warpstream.com/warpstream/overview/architecture/write-path#file-compaction" target="_blank">run compactions</a>. Imagine that between steps 1 and 2, file 451 participated in a compaction. File 451 would not exist anymore logically, and the data it contained for partition 2 of the logs topic would now be in a completely different file, say 936.</p><figure><p><img src="https://cdn.prod.website-files.com/64baaecd9c5c9b1b6c38aa0e/67f715cd681f33e2750c278d_Group%20624.png" loading="lazy" alt=""/></p></figure><p>If the compaction immediately deleted file 451 after compacting it, then there would be a strong chance that step 2 would fail because the file the metadata store told the Agent to read no longer physically exists.</p><figure><p><img src="https://cdn.prod.website-files.com/64baaecd9c5c9b1b6c38aa0e/67f7db73bfa6ae239a95d925_Group%20628%20(1).png" loading="lazy" alt=""/></p></figure><p>The Agent would then have to query the metadata store <em>again</em> to find the new file to read, and hope that the file wasn’t compacted again this time before it could finish running the Fetch request. This would be wasteful, and also increase latency.</p><p>Instead, it would be much better if files that were logically deleted by compaction continued to exist in the object store for some period of time so that in-flight queries could continue to use them.</p><h2>Approach #1: Delayed Queue</h2><p>Now that we’ve looked at two approaches that don’t work, let’s explain one that does. The canonical solution to this type of problem is to introduce a delayed queue: files deleted from the metadata store are first durably enqueued, then deleted later after a sufficient delay to avoid disrupting live queries. However, using an external queue would introduce the same problem as synchronous deletions: if the file is removed from the metadata store, but then the enqueue operation fails, the file will be orphaned in the object store.</p><p>Luckily, we don’t have to use an external queue. The backing database for metadata in a shared storage system is almost always a database with strong consistency and transactional guarantees. This is the case for WarpStream as well. As a result, we can use these transactional properties to delete the file from the metadata store and add it to a delayed queue<em> </em><strong>in the metadata store itself within a single atomic operation</strong>:</p><div><pre><code>if err := metadataStore.DeleteFileAndEnqueueForDeletion(fileID); err != nil {
    // This is fine, we can just retry later.
}</code></pre></div><p>‍</p><p>With this approach, orphaned files will never be introduced (barring bugs in the implementation), and we’ve added no additional dependencies or potential failure modes. Win-win!</p><p>Of course, there’s a big <strong>if</strong> in the statement above: it assumes there are no bugs in the implementation and we never accidentally orphan files. This turns out to be a difficult invariant to maintain throughout a project’s lifetime. </p><p>Of course, even if you never introduce any bugs into the system that result in some orphaned files, there is another reason that delayed file deletion is important: disaster recovery. Imagine something goes wrong: corrupt data enters the system, someone fat-fingers a hard deletion of important data, or the metadata store itself fails in some catastrophic way.</p><p>The metadata store itself is backed by an actual database, and as a result can be restored from a snapshot or backup to recover from data loss. However, restoring a backup of the metadata store will only work if all the files that the backup references <em>still exist in the object store</em>.</p><figure><p><img src="https://cdn.prod.website-files.com/64baaecd9c5c9b1b6c38aa0e/67f7db7f459f7334e2201ab1_Group%20632%20(2).png" loading="lazy" alt=""/></p></figure><p>As a result, the amount of delay between logically deleting a file in the metadata store and physically deleting it from the object store acts as a hard boundary on how old of a backup can ever be restored!</p><h2>Approach #2: Asynchronous Reconciliation</h2><p>Another valid solution besides the delayed queue approach is to use asynchronous reconciliation. In a shared storage system, the metadata store is always the source of truth for what data and files exist in the system. This means that cleaning up logically-deleted files from the object store can be viewed as a reconciliation process where the object store is scanned to identify any files that are no longer tracked by the metadata store.</p><p>If an untracked file is found, then that file can be safely deleted from the object store (after taking into account an appropriate delay that&#39;s large enough to accommodate live queries and the desired disaster recovery requirements):</p><div><pre><code>for _, file := range objectStore.ListFiles() {
    if !metadataStore.Contains(file.FileID) &amp;&amp; file.Age() &gt; $DELETION_DELAY {
        objectStore.DeleteFile(fileID)
    }
}</code></pre></div><p>‍</p><p>In traditional programming language theory, this method of garbage collection is analogous to “mark and sweep” algorithms. This approach is much easier to get right and keep right. Any file in the object store that is not tracked by the metadata store is by definition an orphaned file: it can’t be used by queries or participate in compactions, so it can safely be deleted.</p><p>The problem with this approach is that it’s more expensive than the previous approach, and difficult to tune. Listing files in commodity object stores is a notoriously slow and expensive operation that can easily lead to rate limits being tripped. In addition, obtaining the file’s age requires issuing a HEAD request against the file which costs money as well.</p><p>In the earliest shared storage systems I worked on, we used the delayed queue approach initially because it’s easier to tune and scale. However, invariably, we always added a reconciliation loop later in the project that ran <em>in addition</em> to the delayed queue system to clean up any orphaned files that were missed somehow.</p><p>When we were designing WarpStream, we debated which approach to start with. Ultimately, we decided to use the reconciliation approach despite it being more expensive and harder to tune for two reasons:</p><ol role="list"><li>We would need to add one at some point, so we decided to just build it from the beginning.</li><li>Our BYOC deployment model meant that if we ever orphaned files in customer object storage buckets, we would have to involve them somehow to clean it up, which didn’t feel acceptable to us.</li></ol><p>We built a fairly sophisticated setup that auto-tunes itself based on the observed throughput of the cluster. We also added a lot of built-in safeguards to avoid triggering any object storage rate limits. For example, WarpStream’s reconciliation scanner automatically spreads its LIST and HEAD requests against the object store amongst all the prefixes as evenly as possible. This significantly reduces the risk of being rate-limited since object storage rate limits are tied to key ranges / prefixes in virtually every major implementation.</p><h2>Bringing It All Together</h2><p>The reconciliation loop served WarpStream well for a long time, but as our customers’ clusters got bigger and higher volume, we kept having to allow the reconciliation process to run faster and faster, which increased costs even further.</p><p>Eventually, we decided that it was time to address this issue once and for all. We knew from prior experience that to avoid having to list the entire bucket on a regular basis, we needed to keep track of files that had been deleted in a queue so they could be deleted later.</p><p>We could have introduced this queue into our control plane metadata store as we described earlier, but this felt wasteful. WarpStream’s metadata store is a strongly consistent database that provides extremely high availability, durability, and consistency guarantees. These are desirable properties, but they come with a literal cost. WarpStream’s control plane metadata store is the most expensive component in the stack in terms of cost-per-byte stored. That means we only want to use it to store and track metadata that is absolutely required to guarantee the correctness and performance of the system.</p><p>If we didn’t have a reconciliation process already, then the metadata store would be the only viable place to track the deleted files because losing track of any of them would result in a permanently orphaned object storage file. But since we had a reconciliation loop already, keeping track of the deleted file IDs was just an optimization to reduce costs. In the worst-case scenario, if we lost some file IDs from the deletion queue, the reconciliation loop would catch them within a few hours and clean the files up regardless.</p><p>As a result, we decided to take a slightly different approach and create what we call the “optimistic deletion queue” in the WarpStream Agents. Anytime a WarpStream Agent completes a compaction, it knows that the input files that participated in the compaction were logically deleted in the control plane and should therefore be deleted from the object store later.</p><p>After a compaction completes, the WarpStream Agent inserts the deleted file ID into a large buffered Go channel (a large buffered queue). A separate goroutine running in the background pulls file IDs from the channel and waits for the appropriate amount of time to elapse before physically removing the file from the object store:</p><div><pre><code>// Goroutine 1
err := controlPlane.ApplyCompaction(req)
if err == nil {
    delayedDeletionQueue.Submit(inputFileIDs)
}

// Goroutine 2
for _, fileID := range delayedDeletionQueue {
    time.Sleep(time.Until(fileID.CreatedAt + $DELETION_DELAY))
    if !metadataStore.Contains(file.FileID) {
    	objectStore.DeleteFile(fileID)
    }
}</code></pre></div><p>‍</p><p>Note that this approach only works for files that were deleted as part of a compaction, and not for files that were logically deleted because all of the data they contain logically expired. We didn’t think this would matter much in practice because WarpStream’s storage engine is a <a href="https://en.wikipedia.org/wiki/Log-structured_merge-tree" target="_blank">log-structured merge tree</a>, and as a result, compactions should be the largest source of deleted files.</p><p>This bore out in practice, and with this new hybrid approach, we found that the vast majority of files could be removed before the reconciliation loop ever found them, dramatically reducing costs and overhead.</p><figure><p><img src="https://cdn.prod.website-files.com/64baaecd9c5c9b1b6c38aa0e/67f71a489ba9dcc51572b6a3_Frame%20523.png" loading="lazy" alt=""/></p></figure><p>And if a WarpStream Agent happens to die or be rescheduled and lose track of some of the files it was scheduled to delete? No harm, no foul, the reconciliation loop will detect and clean up the issue within a few hours.</p><p>Having solved this problem more than three different times in my career now, I can confidently say that this is now my favorite solution: it’s highly scalable, cheap, and easy to reason about.</p></div></div>
  </body>
</html>
