<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://leanrada.com/notes/sweep-and-prune/">Original</a>
    <h1>Sort, sweep, and prune: Collision detection algorithms</h1>
    
    <div id="readability-page-1" class="page"><div>

          <!-- prettier-ignore -->
          <div>
            
            
            <p><span>5 Aug 2023</span> ¬∑ 13 min read
            </p>
            
            <p>tags:
              <span title="algorithm">algo</span>
              <span>games</span>
            </p>

            <p>Sweep-and-prune is my go-to algorithm when I want to quickly implement collision detection for a game. I think it‚Äôs an awesome and elegant algorithm, so I wrote a post about it.</p>
            <p>This post is lengthy with many examples and explanations, thus split into two parts. You can jump to specific bits using this special springboard:</p>
            <ul>
              <li><strong>Part 1:</strong> <a target="_self" href="https://leanrada.com/notes/sweep-and-prune/">Simplified version</a>
                <ul>
                  <li>üîç <a target="_self" href="https://leanrada.com/notes/sweep-and-prune/#comparisons">Visual comparison</a></li>
                  <li>üìù <a target="_self" href="https://leanrada.com/notes/sweep-and-prune/#code1">Code</a></li>
                </ul>
              </li>
              <li><strong>Part 2:</strong> <a target="_self" href="https://leanrada.com/notes/sweep-and-prune-2/">Sophisticated versions</a>
                <ul>
                  <li>üîç <a target="_self" href="https://leanrada.com/notes/sweep-and-prune-2/#comparisons">Visual comparison</a></li>
                  <li>üìù <a target="_self" href="https://leanrada.com/notes/sweep-and-prune-2/#final-code">Final code</a></li>
                </ul>
              </li>
            </ul>
            <p>As for the rest of the post, I try to paint a picture of what I think are first principles and show it with <strong>interactive demos</strong>! Let‚Äôs go!</p>
            <hr/>
            <h2 id="collision-detection">Collision detection</h2>
            <p>As you may know, the problem of collision detection is pretty common in video game programming. It‚Äôs a prerequisite to the implementation of certain game mechanics or simulations.</p>
            <p><img loading="lazy" width="100%" data-placeholder="" alt="video of mario with goombas bumping into each other" src="https://leanrada.com/notes/sweep-and-prune/mario.gif" caption="Goombas colliding"/><span>Goombas colliding</span>
            </p>
            
            <p>Some of these mechanics include: preventing characters from passing through each other, <a target="_blank" href="https://youtu.be/Ky69PjyHCqg">goombas</a> turning around when bumping into another, big cells eating smaller cells in <a target="_blank" href="https://agar.io/">agar.io</a>, or just about any game physics. All of these need some kind of collision detection.</p>
            <p><img loading="lazy" width="100%" data-placeholder="" alt="video of agar.io with cells eating smaller cells" src="https://leanrada.com/notes/sweep-and-prune/agario.gif" caption="Cells consuming smaller cells on contact"/><span>Cells consuming smaller cells on contact</span>
            </p>
            
            <p>Here I‚Äôll cover several related approaches, starting with the simplest and building up to the <a target="_blank" href="https://en.wikipedia.org/wiki/Sweep_and_prune"><strong>sweep-and-prune</strong></a> algorithm. I won‚Äôt cover other approaches, such as space partitioning or spatial tree subdivision.</p>
            <p>Balls.</p>
            <p>I‚Äôll use this <strong>rigid-body ball simulation</strong> as a recurring example to demonstrate the algorithms throughout the post:</p>
            

            <p>Alright, let‚Äôs dive in! How do we detect these collisions?</p>
            <h2 id="naive-approach-üê•">Naive approach üê•</h2>
            <p>The straightforward solution is to test every potential pair of objects for collision. That is, <em>check every ball against every other ball</em>.</p>
            <pre><code>
<span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> balls<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
  <span>const</span> ball1 <span>=</span> balls<span>[</span>i<span>]</span><span>;</span>
  
  <span>for</span> <span>(</span><span>let</span> j <span>=</span> i <span>+</span> <span>1</span><span>;</span> j <span>&lt;</span> balls<span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>
    <span>const</span> ball2 <span>=</span> balls<span>[</span>j<span>]</span><span>;</span>
    
    <span>if</span> <span>(</span><span>intersects</span><span>(</span>ball1<span>,</span> ball2<span>)</span><span>)</span> <span>{</span>
      <span>bounce</span><span>(</span>ball1<span>,</span> ball2<span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>
<span>}</span></code></pre>
            <p>Note in the above code that the inner loop starts at <code>i + 1</code> to prevent duplicate pairs from being counted (A-B vs B-A). Other than that, it‚Äôs a pretty simple solution.</p>
            <p>These checks are done on every time step, ensuring that balls will bounce exactly when they collide.</p>
            <p>Here‚Äôs a slowed-down, highlighted simulation, showing pairs being tested for intersection per time step:</p>
            <div>
              <sap-demo-client data-rss="interactive" alt="demo of the collision detection algorithm using &#39;pairwise&#39; strategy" strategy="pairwise" skip-interval="4" decorations="checks:#4c8"></sap-demo-client>
              <p>
                Pairs are highlighted <span aria-label="a connecting green line"></span> when being tested via <code>intersects()</code>.
              </p>
            </div>

            <p>And it works. But if we had more than just a handful of balls we would start seeing performance issues.</p>
            <h2 id="performance-or-lack-thereof">Performance, or lack thereof</h2>
            <p>This naive algorithm runs in <em><strong>O(n<sup>2</sup>)</strong></em> time in <a target="_blank" href="https://en.wikipedia.org/wiki/Big_O_notation">Big O terms</a>. That is, for an input of <em>n</em> balls, the algorithm‚Äôs running time grows proportionally to the <em>square</em> of the input <em>n</em>. That‚Äôs a lot! üìà</p>
            <p>This is because for <em>n</em> balls, there are around <em>(n¬†*¬†(n-1))/2</em> pairs to test, or <em>0.5n<sup>2</sup>¬†-¬†0.5n</em>. For example, if n = 5 there would be a total of 10 pairs. For n = 10, there would be 45 pairs. For n = 15, 105 pairs (!). And so on‚Ä¶ Using Big O notation, we can simplify this information into a compact expression <em>‚ÄúO(n<sup>2</sup>)‚Äù</em></p>
            <p>To (painfully) demonstrate how the performance scales badly for bigger inputs, here‚Äôs a simulation with n¬†=¬†20:</p>
            <div>
              <sap-demo-client data-rss="interactive" alt="demo of the collision detection algorithm using &#39;pairwise&#39; strategy" balls="20" strategy="pairwise" skip-interval="4" decorations="checks:#4c8"></sap-demo-client>
              <p>
                20 balls = 190 pairs to test
              </p>
            </div>

            <p>That‚Äôs a lot of tests per frame! Clearly, the naive solution does not scale well for large numbers of objects.</p>
            <p>How can we improve this solution?</p>
            <p><span>
              <p>The worst case running time for <em>any</em> collision detection algorithm is always <em>O(n<sup>2</sup>)</em>. That‚Äôs when all objects intersect simultaneously and you have no choice but to process each of the n<sup>2</sup> collisions.</p>
              <p>Thus, it‚Äôs more practical to compare the average and best cases.</p>
              <p>Having said that, the naive algorithm is still <em>Œò(n<sup>2</sup>)</em> for <em>any</em> case, no matter the number of actual collisions. A lot of room for improvement!</p>
            </span></p><h2 id="prologue-improving-the-solution">Prologue: Improving the solution</h2>
            <p>Usually when optimising algorithms, you wanna find <strong>redundant or unnecessary work</strong>. Then find a way to consolidate that redundancy. (That sounded corporate-ish.)</p>
            <p>A good place to start would be the <code>intersects()</code> function since it is called for every candidate pair. If we take the <a target="_blank" href="https://gdbooks.gitbooks.io/3dcollisions/content/Chapter2/static_aabb_aabb.html">typical object intersection test</a> to be its implementation, we get a bunch of these <strong>inequality checks</strong>:</p>
            <pre><code><span>function</span> <span>intersects</span><span>(</span><span>object1<span>,</span> object2</span><span>)</span> <span>{</span>
  
  <span>return</span> object1<span>.</span>left <span>&lt;</span> object2<span>.</span>right
      <span>&amp;&amp;</span> object1<span>.</span>right <span>&gt;</span> object2<span>.</span>left
      <span>&amp;&amp;</span> object1<span>.</span>top <span>&lt;</span> object2<span>.</span>bottom
      <span>&amp;&amp;</span> object1<span>.</span>bottom <span>&gt;</span> object2<span>.</span>top<span>;</span>
<span>}</span></code></pre>
            <p>In the above code, the <code>intersects()</code> function checks if two objects intersect by comparing their opposing bounds for each direction. (Refer to <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_collision_detection#aabb_vs._aabb">this MDN article</a> for a better explanation.)</p>
            <p>We can break the test down to its constituent checks:</p>
            <ol>
              <li><code>object1.left &lt; object2.right</code></li>
              <li><code>object1.right &gt; object2.left</code></li>
              <li><code>object1.top &lt; object2.bottom</code></li>
              <li><code>object1.bottom &gt; object2.top</code></li>
            </ol>
            <p>Each check is solely concerned with one particular axis in a specific direction.</p>
            <p>Here‚Äôs the key thing: Due to the <code>&amp;&amp;</code> operator‚Äôs <a target="_blank" href="https://en.wikipedia.org/wiki/Short-circuit_evaluation">short-circuit evaluation</a>, if any one of these checks turns out to be false, then the overall test will immediately evaluate to false.</p>
            <p>Our goal then is to generalise the case where at least <em>one</em> of these checks is false across many tests as possible.</p>
            <p><span>It‚Äôs the same idea as the <a target="_blank" href="https://personal.math.vt.edu/mrlugo/sat.html">separating axis theorem</a>, which implies that two objects can‚Äôt be colliding if there‚Äôs at least one axis where their shadows don‚Äôt overlap.</span></p>
            <p>Let‚Äôs say we focus only on the second check - <code>object1.right &gt; object2.left</code>. Don‚Äôt worry about the rest of the checks. As hinted above, optimising in just one axis can still make a big difference later, so we‚Äôll focus on this single check for now.</p>
            <p><img srcset="/gen/_notes_sweep_and_prune_surprise-tool_200.generated.jpg 200w" sizes=" 200px" spec="200" loading="lazy" width="100%" data-placeholder="" alt="Still of a cartoon mouse saying, &#39;that‚Äôs a surprise tool that can help us later&#39;" src="https://leanrada.com/notes/sweep-and-prune/surprise-tool.jpg"/>
            </p>
            
            <p>Let‚Äôs look at it in the context of multiple objects. Consider three objects - A, B, and C - in this horizontal configuration:</p>
            <p><img srcset="/notes/sweep-and-prune/abc.png 664w" sizes=" 664px" spec="100% [664) 664" loading="lazy" width="100%" data-placeholder="" alt="Three objects, from left to right: A, B, and C" src="https://leanrada.com/notes/sweep-and-prune/abc.png"/>
            </p>
            
            <p>There are three potential pairs to be checked here: A-B, B-C, and A-C. Remember, we‚Äôre trying to find redundant work. Pretend we‚Äôre running all the pairs through the check, like so:</p>
            <pre><code><span>A</span><span>.</span>right <span>&gt;</span> <span>B</span><span>.</span>left 
<span>B</span><span>.</span>right <span>&gt;</span> <span>C</span><span>.</span>left 
<span>A</span><span>.</span>right <span>&gt;</span> <span>C</span><span>.</span>left </code></pre>
            <p>See any redundant work? Maybe abstractify it a little‚Ä¶</p>
            <pre><code><span>A</span> <span>&gt;</span> <span>B</span> 
<span>B</span> <span>&gt;</span> <span>C</span> 
<span>A</span> <span>&gt;</span> <span>C</span> </code></pre>
            <p>Voil√†. Due to the <a target="_blank" href="https://www.mathwords.com/t/transitive_property_inequalities.htm"><strong>transitive property of inequality</strong></a>, realise that we don‚Äôt need to run the <strong>third test</strong>! <em>If we know that <code>A¬†&gt;¬†B</code> and <code>B¬†&gt;¬†C</code> are both <code>false</code>, then we would know that <code>A¬†&gt;¬†C</code> is <code>false</code> as well.</em></p>
            <blockquote>
              <p>‚ÄúIf <i>a ‚â§ b</i> and <i>b ‚â§ c</i>, then <i>a ‚â§ c</i>.‚Äù
                <cite>the transitive property of inequality</cite>
              </p>
            </blockquote>
            <p>So in this example, we don‚Äôt really need to run <code>intersects(A, C)</code>.</p>
            <pre><code>
<span>intersects</span><span>(</span><span>A</span><span>,</span> <span>B</span><span>)</span> 


<span>intersects</span><span>(</span><span>B</span><span>,</span> <span>C</span><span>)</span> 



</code></pre>
            <p>We‚Äôve skipped one <code>intersects()</code> call for free! ‚ú®</p>
            <p><span>
              I‚Äôm handwaving the fact that <code>P.left ‚â§ P.right</code> is implied for any object P. Nevertheless, working those details out would just mean more transitivity.
            </span></p><p>You might be wondering how this contrived example could apply to general n-body collision detection. A smart reader such as you might also have realised that this skip only works if A, B, and C are in a <strong>particular order</strong>.</p>
            <p>What particular order? Try <span>dragging</span> the balls below to see when the optimisation applies and when it does not:</p>
            <div>
              <sap-demo-client data-rss="interactive" alt="interactive diagram showing a specific mechanism" id="abc-demo" balls="[[150,250,50],[300,150,55],[450,275,60]]" strategy="sap-nativesort" static="" draggable="" labels="A,B,C" rainbow=""></sap-demo-client>
              <pre><code>
<span>intersects</span><span>(</span><span>A</span><span>,</span> <span>B</span><span>)</span> 
<span>intersects</span><span>(</span><span>B</span><span>,</span> <span>C</span><span>)</span> 
</code></pre>
            </div>



            <p><span><strong>Tip:</strong> Drag the balls so that they‚Äôre horizontally spaced out in this order: A‚ÄëB‚ÄëC</span></p>
            <p>While it‚Äôs true that this skip only works when A, B, and C are ordered, remember that these labels are <em>arbitrary</em>! What if we simply decided to always call the leftmost ball A, the middle ball B, and the rightmost C? Then the optimisation would always be applicable! üååüß†</p>
            <p>But wait‚Ä¶ labeling objects according to some logical ordering is essentially ‚ú®<strong>sorting</strong>‚ú®! What if we sorted the list of objects every time? Would the number of skipped tests be worth the cost of sorting?</p>
            <h2 id="chapter-1-sorting">Chapter 1. Sorting</h2>
            <p>Sorting, inequalities, and optimisation go hand in hand in hand. <em>A sorted list allows us to exploit the transitive property of inequality en masse.</em></p>
            <p><img srcset="/gen/_notes_sweep_and_prune_sorted_664.generated.png 664w" sizes=" 664px" spec="100% [664) 664" loading="lazy" width="100%" data-placeholder="" alt="a[0] ‚â§ a[1] ‚â§ a[2] ‚â§ ... ‚â§ a[n-1]" src="https://leanrada.com/notes/sweep-and-prune/sorted.png" caption="The inequality relationships of elements in a sorted list."/><span>The inequality relationships of elements in a sorted list.</span>
            </p>
            
            <p><span>Even if we had to sort the list of objects every frame, the quickest general sorting algorithm runs in <em>O(n log n)</em> time which is certainly lower than <em>O(n<sup>2</sup>)</em>.</span></p>
            <p>As shown by the tri-object example above, to achieve the power to skip tests we need to sort the list of objects by x position.</p>
            <p>However, objects aren‚Äôt zero-width points. They‚Äôre <em>widthy</em>, by which I mean having a size thus occupying an interval in the x-axis, also known as ‚Äúwidth‚Äù. How can one unambiguously sort by x position if objects span intervals in the x-axis?</p>
            <h2 id="sort-by-min-x">Sort by min x</h2>
            <p>A solution to sorting widthy objects is to sort them by their <strong>minimum x</strong> (their left edge‚Äôs x-coordinate). This technique can be applied to improve the naive approach.</p>
            <p>It involves minimal modifications to the O(n<sup>2</sup>) solution. But it will result in a good chunk of tests skipped. I‚Äôll explain later.</p>
            <p>First, the modified code:</p>
            <pre><code><span><span>+</span> 
<span>+</span> <span>sortByLeft</span><span>(</span>balls<span>)</span><span>;</span>
<span>+</span> 
</span><span><span> </span> 
<span> </span> <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> balls<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
<span> </span>   <span>const</span> ball1 <span>=</span> balls<span>[</span>i<span>]</span><span>;</span>
<span> </span>   
<span> </span>   <span>for</span> <span>(</span><span>let</span> j <span>=</span> i <span>+</span> <span>1</span><span>;</span> j <span>&lt;</span> balls<span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>
<span> </span>     <span>const</span> ball2 <span>=</span> balls<span>[</span>j<span>]</span><span>;</span>
</span><span><span>+</span> 
<span>+</span>     
<span>+</span>     <span>if</span> <span>(</span>ball2<span>.</span>left <span>&gt;</span> ball1<span>.</span>right<span>)</span> <span>break</span><span>;</span>
<span>+</span> 
</span><span><span> </span>     
<span> </span>     <span>if</span> <span>(</span><span>intersects</span><span>(</span>ball1<span>,</span> ball2<span>)</span><span>)</span> <span>{</span>
<span> </span>       <span>bounce</span><span>(</span>ball1<span>,</span> ball2<span>)</span><span>;</span>
<span> </span>     <span>}</span>
<span> </span>   <span>}</span>
<span> </span> <span>}</span></span></code></pre>
            <p>It‚Äôs mostly the same as the naive solution, differing only in two extra lines of code.</p>
            <p>The first line <code>sortByLeft(balls)</code> simply sorts the list, with ranking based on the balls‚Äô left edge x-coords.</p>
            <pre><code><span>function</span> <span>sortByLeft</span><span>(</span><span>balls</span><span>)</span> <span>{</span>
  balls<span>.</span><span>sort</span><span>(</span><span>(</span><span>a<span>,</span>b</span><span>)</span> <span>=&gt;</span> a<span>.</span>left <span>-</span> b<span>.</span>left<span>)</span><span>;</span>
<span>}</span></code></pre>
            <p>And in the inner loop, there is now this break:</p>
            <pre><code><span>if</span> <span>(</span>ball2<span>.</span>left <span>&gt;</span> ball1<span>.</span>right<span>)</span> <span>break</span><span>;</span></code></pre>
            <p>Let‚Äôs break that down.</p>
            <p>First, we know that the list is sorted, so the following statement
              holds true for any positive integer
              <code>c</code>:
            </p>
            <p>
              <code>balls[<span>j</span> + <span>c</span>].left <span>&gt;=</span> balls[<span>j</span>].left</code>
            </p>

            <p>The break condition, which is derived from the first operand of the intersection test, if true indicates early that the current pair being tested for intersection would fail:</p>
            <p>
              <code>balls2.left <span>&gt;</span> ball1.right</code></p>

            <p>But there are more implications. If it was true, then by combining the above two inequations‚Ä¶</p>
            <p>
              <code>balls[<span>j</span> + <span>c</span>].left <span>&gt;=</span> balls[<span>j</span>].left <span>&gt;</span> ball1.right</code>
            </p>

            <p>And by transitive property, the following statement would also be true!</p>
            <p>
              <code>balls[<span>j</span> + <span>c</span>].left <span>&gt;</span> ball1.right</code>
            </p>

            <p>Which means the intersection tests of balls at
              <code>balls[<span>j</span> + <span>c</span>]</code>
              would also fail. We know this without needing to test those balls individually. A range of balls have been eliminated from testing!
            </p>
            <p>In conclusion, when the current <em>ball2</em>
              <code>balls[<span>j</span>]</code>
              stops overlapping with the current <em>ball1</em>, then any further <em>ball2</em>s in the iteration
              <code>balls[<span>j</span> + <span>c</span>]</code>
              would be guaranteed to not overlap <em>ball1</em> as well. In other words, we stop the inner loop when it gets too far away.
            </p>
            <p>Finally, here‚Äôs a demo:</p>
            <div>
              <sap-demo-client data-rss="interactive" alt="demo of the collision detection algorithm using &#39;simple-sap&#39; strategy" strategy="simple-sap" skip-interval="4" decorations="checks:#4c8"></sap-demo-client>
              <p>
                Pairs highlighted <span aria-label="a connecting green line"></span> when tested by <code>intersects()</code>.
              </p>
            </div>

            <p>Pretty cool, right! It‚Äôs much faster now.</p>
            <p>Some observations:</p>
            <ul>
              <li>Since the list is sorted, the tests are performed from left to right.</li>
              <li>More importantly, it visibly does fewer tests than the naive approach. üìâ This is due the above optimisation which effectively limits pairs to those that overlap in the x-axis!</li>
            </ul>
            <p>Let‚Äôs analyse the time complexity. üëì</p>
            <p>The sort - if we take the &#34;fastest&#34; sorting algorithm, like mergesort or quicksort - would add an <em>O(n log n)</em> term.</p>
            <p>The two-level loop, now with an early break, would average out to <em>O(n¬†+¬†m)</em> where <em>m</em> is the total number of x-overlaps. This could degenerate into n<sup>2</sup> but as mentioned above, it‚Äôs more useful to look at the average and best cases. At best, the loop would be <em>O(n)</em>, wasting no excess processing when there are no overlaps. On average it‚Äôs <em>O(n¬†+¬†m)</em>.</p>
            <p><span>The average case refers to a world where objects are mostly evenly distributed and only a couple intersections per object is happening. I think this is a reasonable assumption for a relatively simple video game like a platformer or side-scroller.</span></p>
            <p>Here‚Äôs the code with running time annotations:</p>
            <pre><code>
<span>sortByLeft</span><span>(</span>balls<span>)</span><span>;</span>


<span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> balls<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
  <span>const</span> ball1 <span>=</span> balls<span>[</span>i<span>]</span><span>;</span>
  
  <span>for</span> <span>(</span><span>let</span> j <span>=</span> i <span>+</span> <span>1</span><span>;</span> j <span>&lt;</span> balls<span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>
    <span>const</span> ball2 <span>=</span> balls<span>[</span>j<span>]</span><span>;</span>
    <span>if</span> <span>(</span>ball2<span>.</span>left <span>&gt;</span> ball1<span>.</span>right<span>)</span> <span>break</span><span>;</span>
    <span>if</span> <span>(</span><span>intersects</span><span>(</span>ball1<span>,</span> ball2<span>)</span><span>)</span> <span>{</span>
      <span>bounce</span><span>(</span>ball1<span>,</span> ball2<span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>
<span>}</span></code></pre>
            <p>Adding those together we get <em><strong>O(n¬†log¬†n¬†+¬†m)</strong></em>.</p>
            <p>This is a super good improvement over the naive approach‚Äôs <em>O(n<sup>2</sup>)</em>, because <strong>[1]</strong> <em>n¬†log¬†n</em> is <a target="_blank" href="https://bigocheatsheet.com/">much smaller</a> than <em>n<sup>2</sup></em> and <strong>[2]</strong> it is partially output-based - depending on the number of overlaps, it does not process more than necessary.</p>
            <a target="_blank" href="https://www.bigocheatsheet.com">
              <p><img loading="lazy" src="https://www.bigocheatsheet.com/img/big-o-complexity-chart.png" caption="bigocheatsheet.com"/><span>bigocheatsheet.com</span>
              </p>
            </a>

            <p>Furthermore, the choice of sorting algorithm could be improved. We‚Äôll look into that in the next part (somehow better than <em>n¬†log¬†n</em>!).</p>
            <p><span>
              If you got this far trying to find a decent collision detection algorithm, then you can stop reading and take the above design! It‚Äôs the perfect balance between programming effort and running time performance. If you are curious how this develops or just want to see more interactive demos, read on to the next part.
            </span></p><h2 id="visual-comparison">Visual comparison</h2>
            <p><a id="comparisons"></a>Here‚Äôs a side-by-side comparison of the strategies we‚Äôve covered so far! Observe the amount of intersection tests required per frame. üîç n = 10</p>
            

            

            <p>(Not shown: the cost of sorting. Let‚Äôs just say the intersection test is sufficiently expensive.)</p>
            <p>Aaand that concludes the first part. Those two lines of code definitely were the MVPs.</p>
            <p>How will it compare to the more advanced versions?</p>
            <p><a target="_self" href="https://leanrada.com/notes/sweep-and-prune-2/">Continued in part 2.</a>
            </p>

          </div>

        </div></div>
  </body>
</html>
