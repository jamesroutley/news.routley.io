<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://0x44.cc/reversing/2021/07/21/reversing-x86-and-c-code-for-beginners.html">Original</a>
    <h1>Reversing for dummies â€“ x86 assembly and C code (Beginner/ADHD friendly)</h1>
    
    <div id="readability-page-1" class="page"><div>
          <h3 id="context">Context</h3>

          <p>
            Before I got into reverse engineering, executables always seemed
            like black magic to me. I always wondered how stuff worked under the
            hood, and how binary code is represented inside .exe files, and how
            hard it is to modify this â€˜compiled codeâ€™ without access to the
            original source code.
          </p>

          <p>
            But one of the main intimidating hurdles always seemed to be the
            assembly language, itâ€™s the thing that scares most people away from
            trying to learn about this field.
          </p>

          <p>
            Thatâ€™s the main reason why I thought of writing this
            straight-to-the-point article that only contains the essential stuff
            that you encounter the most when reversing, albeit missing crucial
            details for the sake of brevity, and assumes the reader has a reflex
            of finding answers online, looking up definitions, and more
            importantly, coming up with examples/ideas/projects to practice on.
          </p>

          <p>
            The goal is to hopefully guide an aspiring reverse engineer and
            arouse motivation towards learning more about this seemingly elusive
            passion.
          </p>

          <p>
            <strong><em>Note</em></strong>: This article assumes the reader has elementary knowledge
            regarding the
            <a href="https://en.wikipedia.org/wiki/Hexadecimal" rel="noopener noreferrer" target="_blank">hexadecimal numeral system</a>, as well as the
            <a href="https://en.wikipedia.org/wiki/C_(programming_language)" rel="noopener noreferrer" target="_blank">C programming language</a>, and is based on a 32-bit Windows executable case study - results
            might differ across different OSes/architectures.
          </p>

          <h3 id="introduction">Introduction</h3>

          <h4 id="compilation">Compilation</h4>

          <p>
            After writing code using a
            <a href="https://en.wikipedia.org/wiki/Compiled_language" rel="noopener noreferrer" target="_blank">compiled language</a>, a compilation takes place <del>(duh)</del>, in order to generate
            the output binary file (an example of such is an .exe file).
          </p>

          <p>
            <img src="https://i.0x44.cc/b/compilation-c-to-exe-file.png"/>
          </p>

          <p>
            Compilers are sophisticated programs which do this task. They make
            sure the syntax of your <del>ugly</del> code is correct, before
            compiling and optimizing the resulting machine code by minimizing
            its size and improving its performance, whenever applicable.
          </p>

          <h4 id="binary-code">Binary code</h4>

          <p>
            As we were saying, the resulting output file contains binary code,
            which can only be â€˜understoodâ€™ by a CPU, itâ€™s essentially a
            succession of varying-length instructions to be executed in order -
            hereâ€™s what some of them look like:
          </p>

          <table>
            <thead>
              <tr>
                <th>CPU-readable instruction data (in hex)</th>
                <th>Human-readable interpretation</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>55</td>
                <td>push ebp</td>
              </tr>
              <tr>
                <td>8B EC</td>
                <td>mov ebp, esp</td>
              </tr>
              <tr>
                <td>83 EC 08</td>
                <td>sub esp, 8</td>
              </tr>
              <tr>
                <td>33 C5</td>
                <td>xor eax, ebp</td>
              </tr>
              <tr>
                <td>83 7D 0C 01</td>
                <td>cmp dword ptr [ebp+0Ch], 1</td>
              </tr>
            </tbody>
          </table>

          <p>
            These instructions are predominantly arithmetical, and they
            manipulate CPU registers/flags as well as volatile memory, as
            theyâ€™re executed.
          </p>

          <h4 id="cpu-registers">CPU registers</h4>

          <p>
            <a href="https://en.wikipedia.org/wiki/Processor_register" rel="noopener noreferrer" target="_blank">A CPU register</a>
            is almost like a temporary integer variable - thereâ€™s a small fixed
            number of them, and they exist because theyâ€™re quick to access,
            unlike memory-based variables, and they help the CPU keep track of
            its data (results, operands, counts, etc.) during execution.
          </p>

          <p>
            Itâ€™s important to note the presence of a special register called the
            <a href="https://en.wikipedia.org/wiki/FLAGS_register" rel="noopener noreferrer" target="_blank"><code>FLAGS</code>
              register</a>
            (<code>EFLAGS</code> on
            32-bit), which houses a bunch of flags (boolean indicators), which
            hold information about the state of the CPU, which include details
            about the last arithmetic operation (zero:
            <code>ZF</code>,
            overflow:
            <code>OF</code>,
            parity:
            <code>PF</code>, sign:
            <code>SF</code>, etc.).
          </p>

          <p>
            <img src="https://i.0x44.cc/b/x32dbg-cpu-registers.png"/>
            <small>CPU registers visualized while debugging a 32-bit process on
              x64dbg, a debugging tool.</small>
          </p>

          <p>
            Some of these registers can also be spotted on the assembly excerpt
            mentioned <a href="#binary-code">previously</a>, namely:
            <code>EAX</code>,
            <code>ESP</code> (stack
            pointer) and
            <code>EBP</code> (base
            pointer).
          </p>

          <h4 id="memory-access">Memory access</h4>

          <p>
            As the CPU executes stuff, it needs to access and interact with
            memory, thatâ€™s when the role of the <em>stack</em> and the
            <em>heap</em> comes.
          </p>

          <p>
            These are (without getting into too much detail) the 2 main ways of
            â€˜keeping track of variable dataâ€™ during the execution of a program:
          </p>

          <h5 id="-stack">ðŸ¥ž <em>Stack</em></h5>
          <p>
            The simpler and faster of the two - itâ€™s a linear contiguous LIFO
            (last in = first out) data structure with a push/pop mechanism, it
            serves to remember function-scoped variables, arguments, and keeps
            track of calls (ever heard of a
            <a href="https://en.wikipedia.org/wiki/Stack_trace" rel="noopener noreferrer" target="_blank">stack trace</a>?)
          </p>

          <h5 id="-heap">â›° <em>Heap</em></h5>
          <p>
            The heap, however, is pretty unordered, and is for more complicated
            data structures, itâ€™s typically used for dynamic allocations, where
            the size of the buffer isnâ€™t initially known, and/or if itâ€™s too
            big, and/or needs to be modified later.
          </p>

          <h3 id="assembly-instructions">Assembly instructions</h3>

          <p>
            As Iâ€™ve mentioned earlier, assembly instructions have a varying
            â€˜byte-sizeâ€™, and a varying number of arguments.
          </p>

          <p>
            Arguments can also be either immediate (â€˜hardcodedâ€™), or they can be
            registers, depending on the instruction:
          </p>

          <div>
            <div>
              <pre><code>55         push    ebp     ; size: 1 byte,  argument: register
6A 01      push    1       ; size: 2 bytes, argument: immediate
</code></pre>
            </div>
          </div>

          <p>
            Letâ€™s quickly run through a very small set of some of the common
            ones weâ€™ll get to see - feel free to do your own research for more
            detail:
          </p>

          <h4 id="stack-operations">Stack operations</h4>
          <ul>
            <li>
              <strong>push
                <code>value</code></strong>
              <em>; pushes a value into the stack (decrements
                <code>ESP</code> by
                4, the size of one stack â€˜unitâ€™).</em>
            </li>
            <li>
              <strong>pop
                <code>register</code></strong>
              <em>; pops a value to a register (increments
                <code>ESP</code> by
                4).</em>
            </li>
          </ul>

          <h4 id="data-transfer">Data transfer</h4>
          <ul>
            <li>
              <strong>mov
                <code>destination</code>,
                <code>source</code></strong>
              ; <em><del>moves</del> copies a value from/to a register.</em>
            </li>
            <li>
              <strong>mov
                <code>destination</code>, [<code>expression</code>]</strong>
              ;
              <em>copies a value from a memory address resolved from a â€˜register
                expressionâ€™ (single register or arithmetic expression involving
                one or more registers) into a register.</em>
            </li>
          </ul>

          <h4 id="flow-control">Flow control</h4>
          <ul>
            <li>
              <strong>jmp
                <code>destination</code></strong>
              ;
              <em>jumps into a code location (sets
                <code>EIP</code>
                (instruction pointer)).</em>
            </li>
            <li>
              <strong>jz/je
                <code>destination</code></strong>
              ;
              <em>jumps into a code location if
                <code>ZF</code>
                (the zero flag) is set.</em>
            </li>
            <li>
              <strong>jnz/jne
                <code>destination</code></strong>
              ;
              <em>jumps into a code location if
                <code>ZF</code> is
                not set.</em>
            </li>
          </ul>

          <h4 id="operations">Operations</h4>
          <ul>
            <li>
              <strong>cmp
                <code>operand1</code>,
                <code>operand2</code></strong>
              ;
              <em>compares the 2 operands and sets
                <code>ZF</code> if
                theyâ€™re equal.</em>
            </li>
            <li>
              <strong>add
                <code>operand1</code>,
                <code>operand2</code></strong>
              ; <em>operand1 += operand2;</em>
            </li>
            <li>
              <strong>sub
                <code>operand1</code>,
                <code>operand2</code></strong>
              ; <em>operand1 -= operand2;</em>
            </li>
          </ul>

          <h4 id="function-transitions">Function transitions</h4>
          <ul>
            <li>
              <strong>call
                <code>function</code></strong>
              ;
              <em>calls a function (pushes current
                <code>EIP</code>,
                then jumps to the function).</em>
            </li>
            <li>
              <strong>retn</strong> ;
              <em>returns to caller function (pops back the previous
                <code>EIP</code>).</em>
            </li>
          </ul>

          <p>
            <strong><em>Note</em></strong>: You might notice the words â€˜equalâ€™ and â€˜zeroâ€™ being used
            interchangeably in x86 terminology - thatâ€™s because comparison
            instructions internally perform a subtraction, which means if the 2
            operands are equal,
            <code>ZF</code> is set.
          </p>

          <h3 id="assembly-patterns">Assembly patterns</h3>

          <p>
            Now that we have a rough idea of the main elements used during the
            execution of a program, letâ€™s get familiarized with the patterns of
            instructions that you can encounter reverse engineering your average
            everyday 32-bit
            <a href="https://en.wikipedia.org/wiki/Portable_Executable" rel="noopener noreferrer" target="_blank">PE</a>
            binary.
          </p>

          <h4 id="function-prologue">Function prologue</h4>

          <p>
            A
            <a href="https://en.wikipedia.org/wiki/Function_prologue" rel="noopener noreferrer" target="_blank">function prologue</a>
            is some initial code embedded in the beginning of most functions, it
            serves to set up a new stack frame for said function.
          </p>

          <p>It typically looks like this (X being a number):</p>

          <div>
            <div>
              <pre><code>55          push    ebp        ; preserve caller function&#39;s base pointer in stack
8B EC       mov     ebp, esp   ; caller function&#39;s stack pointer becomes base pointer (new stack frame)
83 EC XX    sub     esp, X     ; adjust the stack pointer by X bytes to reserve space for local variables
</code></pre>
            </div>
          </div>

          <h4 id="function-epilogue">Function epilogue</h4>

          <p>
            The
            <a href="https://en.wikipedia.org/wiki/Function_epilogue" rel="noopener noreferrer" target="_blank">epilogue</a>
            is simply the opposite of the prologue - it undoes its steps to
            restore the stack frame of the caller function, before it returns to
            it:
          </p>

          <div>
            <div>
              <pre><code>8B E5    mov    esp, ebp    ; restore caller function&#39;s stack pointer (current base pointer) 
5D       pop    ebp         ; restore base pointer from the stack
C3       retn               ; return to caller function
</code></pre>
            </div>
          </div>

          <p>
            Now at this point, you might be wondering - how do functions talk to
            each other? How exactly do you send/access arguments when calling a
            function, and how do you receive the return value? Thatâ€™s precisely
            why we have calling conventions.
          </p>

          <h4 id="calling-conventions-__cdecl">Calling conventions: __cdecl</h4>

          <p>
            A
            <a href="https://en.wikipedia.org/wiki/Calling_convention" rel="noopener noreferrer" target="_blank">calling convention</a>
            is basically a protocol used to communicate with functions, thereâ€™s
            a few variations of them, but they share the same principle.
          </p>

          <p>
            We will be looking at the
            <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#cdecl" rel="noopener noreferrer" target="_blank">__cdecl (C declaration) convention</a>, which is the standard one when compiling C code.
          </p>

          <p>
            In __cdecl (32-bit), function arguments are passed on the stack
            (pushed in reverse order), while the return value is returned in the
            <code>EAX</code>
            register (assuming itâ€™s not a float).
          </p>

          <p>
            This means that a
            <code>func(1, 2, 3);</code>
            call will generate the following:
          </p>

          <div>
            <div>
              <pre><code>6A 03             push    3
6A 02             push    2
6A 01             push    1
E8 XX XX XX XX    call    func
</code></pre>
            </div>
          </div>

          <h4 id="putting-everything-together">Putting everything together</h4>

          <p>
            Assuming
            <code>func()</code>
            simply does an addition on the arguments and returns the result, it
            would probably look like this:
          </p>

          <div>
            <div>
              <pre><code>int __cdecl func(int, int, int):

           prologue:
55           push    ebp               ; save base pointer
8B EC        mov     ebp, esp          ; new stack frame

           body:
8B 45 08     mov     eax, [ebp+8]      ; load first argument to EAX (return value)
03 45 0C     add     eax, [ebp+0Ch]    ; add 2nd argument
03 45 10     add     eax, [ebp+10h]    ; add 3rd argument

           epilogue:
5D           pop     ebp               ; restore base pointer
C3           retn                      ; return to caller
</code></pre>
            </div>
          </div>

          <p>
            Now if youâ€™ve been paying attention and youâ€™re still confused, you
            might be asking yourself one of these 2 questions:
          </p>

          <p>
            1) Why do we have to adjust
            <code>EBP</code> by 8
            to get to the first argument?
          </p>

          <ul>
            <li>
              If you
              <a href="#assembly-instructions">check the definition</a> of the
              <code>call</code>
              instruction we mentioned earlier, youâ€™ll realize that, internally,
              it actually pushes
              <code>EIP</code> to
              the stack. And if you also check the definition for
              <code>push</code>,
              youâ€™ll realize that it decrements
              <code>ESP</code>
              (which is copied to
              <code>EBP</code>
              after the prologue) by 4 bytes. In addition, the prologueâ€™s first
              instruction is also a
              <code>push</code>, so
              we end up with 2 decrements of 4, hence the need to add 8.
            </li>
          </ul>

          <p>
            2) What happened to the prologue and epilogue, why are they
            seemingly â€˜truncatedâ€™?
          </p>

          <ul>
            <li>
              Itâ€™s simply because we havenâ€™t had a use for the stack during the
              execution of our function - if youâ€™ve noticed, we havenâ€™t modified
              <code>ESP</code> at
              all, which means we also donâ€™t need to restore it.
            </li>
          </ul>

          <h4 id="if-conditions">If conditions</h4>

          <p>
            To demo the flow control assembly instructions, Iâ€™d like to add one
            more example to show how an if condition was compiled to assembly.
          </p>

          <p>Assume we have the following function:</p>

          <div>
            <div>
              <pre><code><span>void</span> <span>print_equal</span><span>(</span><span>int</span> <span>a</span><span>,</span> <span>int</span> <span>b</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>a</span> <span>==</span> <span>b</span><span>)</span> <span>{</span>
        <span>printf</span><span>(</span><span>&#34;equal&#34;</span><span>);</span>
    <span>}</span>
    <span>else</span> <span>{</span>
        <span>printf</span><span>(</span><span>&#34;nah&#34;</span><span>);</span>
    <span>}</span>
<span>}</span>
</code></pre>
            </div>
          </div>

          <p>
            After compiling it, hereâ€™s the disassembly that I got with the help
            of
            <a href="https://hex-rays.com/ida-pro/" rel="noopener noreferrer" target="_blank">IDA</a>:
          </p>

          <div>
            <div>
              <pre><code>void __cdecl print_equal(int, int):

     10000000   55                push   ebp
     10000001   8B EC             mov    ebp, esp
     10000003   8B 45 08          mov    eax, [ebp+8]       ; load 1st argument
     10000006   3B 45 0C          cmp    eax, [ebp+0Ch]     ; compare it with 2nd
  â”Œâ”… 10000009   75 0F             jnz    short loc_1000001A ; jump if not equal
  â”Š  1000000B   68 94 67 00 10    push   offset aEqual  ; &#34;equal&#34;
  â”Š  10000010   E8 DB F8 FF FF    call   _printf
  â”Š  10000015   83 C4 04          add    esp, 4
â”Œâ”€â”Šâ”€ 10000018   EB 0D             jmp    short loc_10000027
â”‚ â”Š
â”‚ â”” loc_1000001A:
â”‚    1000001A   68 9C 67 00 10    push   offset aNah    ; &#34;nah&#34;
â”‚    1000001F   E8 CC F8 FF FF    call   _printf
â”‚    10000024   83 C4 04          add    esp, 4
â”‚
â””â”€â”€ loc_10000027:
     10000027   5D                pop    ebp
     10000028   C3                retn
</code></pre>
            </div>
          </div>

          <p>
            Give yourself a minute and try to make sense of this disassembly
            output (for simplicityâ€™s sake, Iâ€™ve changed the real addresses and
            made the function start from
            <code>10000000</code>
            instead).
          </p>

          <p>
            In case youâ€™re wondering about the
            <code>add esp, 4</code>
            part, itâ€™s simply there to adjust
            <code>ESP</code> back
            to its initial value (same effect as a
            <code>pop</code>,
            except without modifying any register), since we had to
            <code>push</code> the
            printf string argument.
          </p>

          <h3 id="basic-data-structures">Basic data structures</h3>

          <p>
            Now letâ€™s move on and talk about how data is stored (integers and
            strings especially).
          </p>

          <h4 id="endianness">Endianness</h4>

          <p>
            <a href="https://en.wikipedia.org/wiki/Endianness" rel="noopener noreferrer" target="_blank">Endianness</a>
            is the order of the sequence of bytes representing a value in
            computer memory.
          </p>

          <p>Thereâ€™s 2 types - big-endian and little-endian:</p>

          

          <p>
            For reference, x86 family processors (the ones on pretty much any
            computer you can find) always use little-endian.
          </p>

          <p>
            To give you a live example of this concept, Iâ€™ve compiled a Visual
            Studio C++ console app, where I declared an
            <code>int</code>
            variable with the value
            <code>1337</code>
            assigned to it, then I printed the variableâ€™s address using
            <code>printf()</code>,
            on the main function.
          </p>

          <p>
            Then I ran the program attached to the debugger in order to check
            the printed variableâ€™s address on the memory hex view, and hereâ€™s
            the result I obtained:
          </p>

          <p>
            <img src="https://i.0x44.cc/b/vs-debug-memory-view.png" alt=""/>
          </p>

          <p>
            To elaborate more on this -
            <code>int</code>
            variables are 4 bytes long (32 bits) (in case you didnâ€™t know), so
            this means that if the variable starts from the address
            <code>D2FCB8</code> it
            would end right before
            <code>D2FCBC</code>
            (+4).
          </p>

          <p>
            To go from human readable value to memory bytes, follow these steps:
          </p>

          <p>
            decimal:
            <code>1337</code> -&gt;
            hex:
            <code>539</code> -&gt;
            bytes:
            <code>00 00 05 39</code>
            -&gt; little-endian:
            <code>39 05 00 00</code>
          </p>

          <h4 id="signed-integers">Signed integers</h4>

          <p>
            This part is interesting yet relatively simple. What you should know
            here is that integer signing (positive/negative) is typically done
            on computers with the help of a concept called
            <a href="https://en.wikipedia.org/wiki/Signed_number_representations#Two&#39;s_complement" rel="noopener noreferrer" target="_blank">twoâ€™s complement</a>.
          </p>

          <p>
            The gist of it is that the lowest/first half of an integer is
            reserved for positive numbers, while the highest/last half is for
            negative numbers, hereâ€™s what this looks like in hex, for a 32-bit
            signed int (highlighted = hex, in parenthesis = decimal):
          </p>

          <p>
            Positives (1/2):
            <code>00000000</code>
            (0) -&gt;
            <code>7FFFFFFF</code>
            (2,147,483,647 or
            <code>INT_MAX</code>)
          </p>

          <p>
            Negatives (2/2):
            <code>80000000</code>
            (-2,147,483,648 or
            <code>INT_MIN</code>)
            -&gt;
            <code>FFFFFFFF</code>
            (-1)
          </p>

          <p>
            If youâ€™ve noticed, weâ€™re always <em>ascending</em> in value. Whether
            we go up in hex or decimal. And thatâ€™s the crucial point of this
            concept - arithmetical operation do not have to do anything special
            to handle signing, they can simply treat all values as
            unsigned/positive, and the result would still be interpreted
            correctly (as long as we donâ€™t go beyond
            <code>INT_MAX</code> or
            <code>INT_MIN</code>),
            and thatâ€™s because integers will also <em>â€˜rolloverâ€™</em> on
            overflow/underflow by design, kinda like an analog odometer.
          </p>

          <p>
            <img src="https://i.0x44.cc/b/odometer-rollover.jpg"/>
          </p>

          <p>
            <strong><em>Protip</em></strong>: The Windows calculator is a very helpful tool - you can set it to
            programmer mode and set the size to DWORD (4 bytes), then enter
            negative decimal values and visualize them in hex and binary, and
            have fun performing operations on them.
          </p>

          <p>
            <img src="https://i.0x44.cc/b/calcexe-int-signing.png" alt=""/>
          </p>

          <h4 id="strings">Strings</h4>

          <p>
            In C, strings are stored as
            <code>char</code>
            arrays, therefore, thereâ€™s nothing special to note here, except for
            something called null termination.
          </p>

          <p>
            If you ever wondered how
            <code>strlen()</code>
            is able to know the size of a string, itâ€™s very simple - strings
            have a character that indicates their end, and thatâ€™s the null
            byte/character -
            <code>00</code> or
            <code>&#39;\0&#39;</code>.
          </p>

          <p>
            If you declare a string constant in C code, and hover over it in
            Visual Studio, for instance, it will tell you the size of the
            generated array, and as you can see, for this reason, itâ€™s one
            element more than the â€˜visibleâ€™ string size.
          </p>

          <p>
            <img src="https://i.0x44.cc/b/vs-null-termination.png" alt=""/>
          </p>

          <p>
            <strong><em>Note</em></strong>: The endianness concept is not applicable on arrays, only on
            single variables. Therefore, the order of characters in memory would
            be normal here - low to high.
          </p>

          <h3 id="making-sense-of-call-and-jmp-instructions">
            Making sense of
            <code>call</code> and
            <code>jmp</code>
            instructions
          </h3>

          <p>
            Now that you know all of this, youâ€™re likely able to start making
            sense of some machine code, and emulate a CPU with your brain, to
            some extent, so to speak.
          </p>

          <p>
            Letâ€™s take the
            <a href="#if-conditions"><code>print_equal()</code>
              example</a>, but letâ€™s only focus on the
            <code>printf()</code>
            <code>call</code>
            instructions this time.
          </p>

          <div>
            <div>
              <pre><code>void print_equal(int, int):
...
     10000010   E8 DB F8 FF FF    call   _printf
...
     1000001F   E8 CC F8 FF FF    call   _printf
</code></pre>
            </div>
          </div>

          <p>
            You might be wondering to yourself - wait a second, if these are the
            same instructions, then why are their bytes different?
          </p>

          <p>
            Thatâ€™s because,
            <code>call</code> (and
            <code>jmp</code>)
            instructions (usually) take an <em>offset</em> (relative address) as
            an argument, not an absolute address.
          </p>

          <p>
            An offset is basically the difference between the current location,
            and the destination, which also means that it can be either negative
            or positive.
          </p>

          <p>
            As you can see, the
            <a href="https://en.wikipedia.org/wiki/Opcode" rel="noopener noreferrer" target="_blank">opcode</a>
            of a
            <code>call</code>
            instruction that takes a 32-bit offset, is
            <code>E8</code>, and is
            followed by said offset - which makes the full instruction:
            <code>E8 XX XX XX XX</code>.
          </p>

          <p>
            Pull out your calculator,
            <del>whyâ€™d you close it so early?!</del> and calculate the
            difference between the offset of both instructions (donâ€™t forget the
            endianness).
          </p>

          <p>
            Youâ€™ll notice that (the absolute value of) this difference is the
            same as the one between the instruction addresses (<code>1000001F</code>
            -
            <code>10000010</code> =
            <code>F</code>):
          </p>

          <p>
            <img src="https://i.0x44.cc/b/calcexe-call-inst-diff.png" alt=""/>
          </p>

          <p>
            Another small detail that we should add, is the fact that the CPU
            only executes an instruction after fully â€˜readingâ€™ it, which means
            that by the time the CPU starts â€˜executingâ€™,
            <code>EIP</code> (the
            instruction pointer) is already pointing at the
            <em>next</em> instruction to be executed.
          </p>

          <p>
            Thatâ€™s why these offsets are actually accounting for this behaviour,
            which means that in order to get the <em>real</em> address of the
            target function, we have to also <em>add</em> the size of the
            <code>call</code>
            instruction: 5.
          </p>

          <p>
            Now letâ€™s apply all these steps in order to resolve
            <code>printf()</code>â€™s
            address from the first instruction on the example:
          </p>

          <div>
            <div>
              <pre><code>10000010   E8 DB F8 FF FF    call   _printf
</code></pre>
            </div>
          </div>

          <p>
            1) Extract the offset from the instruction:
            <code>E8 (DB F8 FF FF)</code>
            -&gt;
            <code>FFFFF8DB</code>
            (-1829)
          </p>

          <p>
            2) Add it to the instruction address:
            <code>10000010</code> +
            <code>FFFFF8DB</code> =
            <code>0FFFF8EB</code>
          </p>

          <p>
            3) And finally, add the instruction size:
            <code>0FFFF8EB</code> +
            5 =
            <code>0FFFF8F0</code>
            (<code>&amp;printf</code>)
          </p>

          <p>
            The exact same principle applies to the
            <code>jmp</code>
            instruction:
          </p>

          <div>
            <div>
              <pre><code>...
â”Œâ”€â”€â”€ 10000018   EB 0D             jmp    short loc_10000027
...
â””â”€â”€ loc_10000027:
     10000027   5D                pop    ebp
...
</code></pre>
            </div>
          </div>
          <p>
            The only difference in this example is that
            <code>EB XX</code> is a
            short version
            <code>jmp</code>
            instruction - which means it only takes an 8-bit (1 byte) offset.
          </p>

          <p>
            Therefore:
            <code>10000018</code> +
            <code>0D</code> + 2 =
            <code>10000027</code>
          </p>

          <h3 id="conclusion">Conclusion</h3>

          <p>
            Thatâ€™s it! You should now have enough information (and hopefully,
            motivation) to start your journey reverse engineering executables.
          </p>

          <p>
            Start by writing dummy C code, compiling it, and debugging it while
            single-stepping through the disassembly instructions (Visual Studio
            allows you to do this, by the way).
          </p>

          <p>
            <a href="https://godbolt.org/" rel="noopener noreferrer" target="_blank">Compiler Explorer</a>
            is also an extremely helpful website which compiles C code to
            assembly for you in real time using multiple compilers (select the
            <code>x86 msvc</code>
            compiler for Windows 32-bit).
          </p>

          <p>
            After that, you can try your luck with closed-source native
            binaries, by the help of disassemblers such as
            <a href="https://ghidra-sre.org/" rel="noopener noreferrer" target="_blank">Ghidra</a>
            and
            <a href="https://hex-rays.com/ida-free" rel="noopener noreferrer" target="_blank">IDA</a>, and debuggers such as
            <a href="https://x64dbg.com/" rel="noopener noreferrer" target="_blank">x64dbg</a>.
          </p>

          <p>
            <strong><em>Note</em></strong>: If youâ€™ve noticed inaccurate information, or room for improvement
            regarding this article, and would like to improve it, feel free to
            <a href="https://github.com/thedroidgeek/0x44.cc/edit/master/_posts/2021-07-21-reversing-x86-and-c-code-for-beginners.md" rel="noopener noreferrer" target="_blank">submit a pull request</a>
            on GitHub.
          </p>

          <p>Thanks for reading!</p>

          <p>
            <a href="https://github.com/thedroidgeek/0x44.cc/commits/master/_posts/2021-07-21-reversing-x86-and-c-code-for-beginners.md" rel="noopener noreferrer" target="_blank">(edited)</a>
          </p>

          
        </div></div>
  </body>
</html>
