<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fast.github.io/blog/stop-forwarding-errors-start-designing-them/">Original</a>
    <h1>Stop Forwarding Errors, Start Designing Them</h1>
    
    <div id="readability-page-1" class="page"><div>  <p>It’s 3am. Production is down. You’re staring at a log line that says:</p>
<div><figure><pre data-language="text"><code><div><p><span>Error: serialization error: expected &#39;,&#39; or &#39;}&#39; at line 3, column 7</span></p></div></code></pre></figure></div>
<p>You know JSON is broke. But you have zero idea <em>why</em>, <em>where</em>, or <em>who</em> caused it. Was it the config loader? The user API? The webhook consumer?</p>
<p>The error has successfully bubbled up through 20 layers of your stack, preserving its original message perfectly, yet losing every scrap of meaning along the way.</p>
<p>We have a name for this. We call it “Error Handling.” But in reality, it’s just <strong>Error Forwarding</strong>. We treat errors like hot potatoes—catch them, wrap them (maybe), and throw them up the stack as fast as possible.</p>
<p>You add a <code>println!</code>, restart the service, wait for the bug to reproduce. It’s going to be a long night.</p>
<p>As noted in a <a href="https://bugenzhao.com/2024/04/24/error-handling-1/">detailed analysis of error handling in a large Rust project</a>:</p>
<blockquote>
<p>“There’re tons of opinionated articles or libraries promoting their best practices, leading to an epic debate that never ends. We were all starting to notice that there was something wrong with the error handling practices, but pinpointing the exact problems is challenging.”</p>
</blockquote>
<hr/>
<h2 id="whats-wrong-with-current-practices">What’s Wrong with Current Practices</h2>
<h3 id="the-stderrorerror-trait-a-noble-but-flawed-abstraction">The <code>std::error::Error</code> Trait: A Noble but Flawed Abstraction</h3>
<p>Rust’s <code>std::error::Error</code> trait assumes errors form a chain—each error has an optional <code>source()</code> pointing to the underlying cause. This works for most cases; the vast majority of errors have no source or a single one.</p>
<p>But as a <em>standard library</em> abstraction, it’s too opinionated. It categorically excludes cases where sources form a tree: a validation error with multiple field failures, a timeout with partial results. These scenarios exist, and the standard trait offers no way to represent them.</p>
<h3 id="backtraces-expensive-medicine-for-the-wrong-disease">Backtraces: Expensive Medicine for the Wrong Disease</h3>
<p>Rust’s <code>std::backtrace::Backtrace</code> was meant to improve error observability. They’re better than nothing. But they have serious limitations:</p>
<p><strong>In async code, they’re nearly useless.</strong> Your backtrace will contain <a href="https://github.com/rust-lang/rust/issues/74779">49 stack frames, of which 12 are calls to <code>GenFuture::poll()</code></a>. The <a href="https://rust-lang.github.io/wg-async/design_docs/async_stack_traces.html">Async Working Group notes</a> that suspended tasks are invisible to traditional stack traces.</p>
<p><strong>They only show the origin, not the path.</strong> A backtrace tells you where the error was <em>created</em>, not the logical path it took through your application. It won’t tell you “this was the request handler for user X, calling service Y, with parameters Z.”</p>
<p><strong>Capturing backtraces is expensive.</strong> The standard library documentation acknowledges: “Capturing a backtrace can be a quite expensive runtime operation.”</p>
<h3 id="the-providerequest-api-overengineering-in-action">The Provide/Request API: Overengineering in Action</h3>
<p>The <a href="https://github.com/rust-lang/rust/issues/96024">Provider API (RFC 3192)</a> and <a href="https://github.com/rust-lang/rfcs/pull/2895">generic member access (RFC 2895)</a> add dynamic type-based data access to errors:</p>
<div><figure><pre data-language="rust"><code><div><p><span>fn</span><span> </span><span>provide</span><span>&lt;&#39;</span><span>a</span><span>&gt;(</span><span>&amp;</span><span>&#39;</span><span>a</span><span> </span><span>self</span><span>, request</span><span>:</span><span> </span><span>&amp;mut</span><span> </span><span>Request</span><span>&lt;&#39;</span><span>a</span><span>&gt;) {</span></p></div><div><p><span><span>    </span></span><span>request</span><span>.</span><span>provide_ref</span><span>::</span><span>&lt;</span><span>Backtrace</span><span>&gt;(</span><span>&amp;</span><span>self</span><span>.</span><span>backtrace);</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>The unstable <code>Provide</code>/<code>Request</code> API represents the latest attempt to make errors more flexible. The idea: errors can dynamically provide typed context (like HTTP status codes or backtraces) that callers can request at runtime.</p>
<p>This sounds powerful. In practice, it introduces new problems:</p>
<p><strong>Unpredictability</strong>: Your error <em>might</em> provide an HTTP status code. Or it might not. You won’t know until runtime.</p>
<p><strong>Complexity</strong>: The API is subtle enough that <a href="https://github.com/rust-lang/rfcs/pull/3192#issuecomment-1018020335">LLVM struggles to optimize multiple provide calls</a>.</p>
<p>Sometimes, a simple struct with named fields is better than a clever abstraction.</p>
<h3 id="thiserror-categorizing-by-origin-not-by-action"><code>thiserror</code>: Categorizing by Origin, Not by Action</h3>
<p><code>thiserror</code> makes it easy to define error enums:</p>
<div><figure><pre data-language="rust"><code><div><p><span>#[derive(</span><span>Debug</span><span>, thiserror</span><span>::</span><span>Error</span><span>)]</span></p></div><div><p><span>pub</span><span> </span><span>enum</span><span> </span><span>DatabaseError</span><span> {</span></p></div><div><p><span><span>    </span></span><span>#[error(</span><span>&#34;connection failed: {0}&#34;</span><span>)]</span></p></div><div><p><span>    </span><span>Connection</span><span>(#[from] </span><span>ConnectionError</span><span>),</span></p></div><div><p><span><span>    </span></span><span>#[error(</span><span>&#34;query failed: {0}&#34;</span><span>)]</span></p></div><div><p><span>    </span><span>Query</span><span>(#[from] </span><span>QueryError</span><span>),</span></p></div><div><p><span><span>    </span></span><span>#[error(</span><span>&#34;serialization failed: {0}&#34;</span><span>)]</span></p></div><div><p><span>    </span><span>Serde</span><span>(#[from] </span><span>serde_json</span><span>::</span><span>Error</span><span>),</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>This looks reasonable. But notice how this common practice categorizes errors: by <em>origin</em>, not by <em>what the caller can do about it</em>.</p>
<p>When you receive a <code>DatabaseError::Query</code>, what should you do? Retry? Report to the user? Log and continue? The error doesn’t tell you. It just tells you which dependency failed.</p>
<p>As one blogger <a href="https://mmapped.blog/posts/12-rust-error-handling">aptly put it</a>: “This error type does not tell the caller what problem you are solving but how you solve it.”</p>
<h3 id="anyhow-so-convenient-youll-forget-to-add-context"><code>anyhow</code>: So Convenient You’ll Forget to Add Context</h3>
<p><code>anyhow</code> takes the opposite approach: type erasure. Just use <code>anyhow::Result&lt;T&gt;</code> everywhere and propagate with <code>?</code>. No more enum variants, no more <code>#[from]</code> annotations.</p>
<p>The problem? It’s <em>too</em> convenient.</p>
<div><figure><pre data-language="rust"><code><div><p><span>fn</span><span> </span><span>process_request</span><span>(req</span><span>:</span><span> </span><span>Request</span><span>) </span><span>-&gt;</span><span> </span><span>anyhow</span><span>::</span><span>Result</span><span>&lt;</span><span>Response</span><span>&gt; {</span></p></div><div><p><span>    </span><span>let</span><span> user </span><span>=</span><span> db</span><span>.</span><span>get_user</span><span>(req</span><span>.</span><span>user_id)</span><span>?</span><span>;</span></p></div><div><p><span>    </span><span>let</span><span> data </span><span>=</span><span> </span><span>fetch_external_api</span><span>(user</span><span>.</span><span>api_key)</span><span>?</span><span>;</span></p></div><div><p><span>    </span><span>let</span><span> result </span><span>=</span><span> </span><span>compute</span><span>(data)</span><span>?</span><span>;</span></p></div><div><p><span>    </span><span>Ok</span><span>(result)</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>Every <code>?</code> is a missed opportunity to add context. What was the user ID? What API were we calling? What computation failed? The error knows none of this.</p>
<p>The <code>anyhow</code> documentation encourages using <code>.context()</code> to add information. But <code>.context()</code> is optional—the type system doesn’t require it. “I’ll add context later” is the easiest lie to tell yourself. Later means never—until 3am when production is on fire.</p>
<hr/>
<h2 id="the-problem-error-handling-without-purpose">The Problem: Error Handling Without Purpose</h2>
<p>Consider this common pattern in Rust codebases:</p>
<div><figure><pre data-language="rust"><code><div><p><span>#[derive(thiserror</span><span>::</span><span>Error</span><span>, </span><span>Debug</span><span>)]</span></p></div><div><p><span>pub</span><span> </span><span>enum</span><span> </span><span>ServiceError</span><span> {</span></p></div><div><p><span><span>    </span></span><span>#[error(</span><span>&#34;database error: {0}&#34;</span><span>)]</span></p></div><div><p><span>    </span><span>Database</span><span>(#[from] </span><span>sqlx</span><span>::</span><span>Error</span><span>),</span></p></div><div><p><span><span>    </span></span><span>#[error(</span><span>&#34;http error: {0}&#34;</span><span>)]</span></p></div><div><p><span>    </span><span>Http</span><span>(#[from] </span><span>reqwest</span><span>::</span><span>Error</span><span>),</span></p></div><div><p><span><span>    </span></span><span>#[error(</span><span>&#34;serialization error: {0}&#34;</span><span>)]</span></p></div><div><p><span>    </span><span>Serde</span><span>(#[from] </span><span>serde_json</span><span>::</span><span>Error</span><span>),</span></p></div><div><p><span>    </span><span>// ... ten more variants</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>This looks reasonable. But ask yourself:</p>
<ol>
<li>
<p><strong>What can the caller do with <code>ServiceError::Database</code>?</strong> Can they retry? Should they show the raw SQL error to users? The error type doesn’t help answer these questions.</p>
</li>
<li>
<p><strong>When debugging at 3 AM</strong>, does “serialization error: expected <code>,</code> or <code>}</code>” tell you which request, which field, which code path led here?</p>
</li>
</ol>
<p>This is the fundamental disconnect in how we think about error handling. We focus on <em>propagating</em> errors exactly, on making the types line up, on satisfying the compiler. But we forget that errors are messages—messages that will eventually be read by either a machine trying to recover, or a human trying to debug.</p>
<h2 id="the-library-vs-application-myth">The “Library vs Application” Myth</h2>
<p>You’ve probably heard the conventional wisdom: <em>“Use <code>thiserror</code> for libraries, <code>anyhow</code> for applications.”</em></p>
<p>It’s a nice, simple rule, just not quite right. As <a href="https://lpalmieri.com/posts/error-handling-rust/">Luca Palmieri notes</a>: “It is not the right framing. You need to reason about intent.”</p>
<p>The real question isn’t whether you’re writing a library or an application. The real question is: <strong>what do you expect the caller to do with this error?</strong></p>
<h2 id="two-audiences-two-needs">Two Audiences, Two Needs</h2>
<p>Let’s be explicit about who consumes errors and what they need:</p>




















<table><thead><tr><th>Audience</th><th>Goal</th><th>Needs</th></tr></thead><tbody><tr><td><strong>Machines</strong></td><td>Automated recovery</td><td>Flat structure, clear error kinds, predictable codes</td></tr><tr><td><strong>Humans</strong></td><td>Debugging</td><td>Rich context, call path, business-level information</td></tr></tbody></table>
<p>When a retry middleware receives an error, it doesn’t care about your beautifully nested error chain. It just needs to know: <em>is this retryable?</em> A simple boolean or enum variant suffices.</p>
<p>When you’re debugging at 3am, you don’t need to know that somewhere deep in the stack there was an <code>io::Error</code>. You need to know: <em>which file, which user, which request, what were we trying to do?</em></p>
<p>Most error handling designs optimize for neither audience. They optimize for <em>the compiler</em>.</p>
<h3 id="for-machines-flat-actionable-kind-based">For Machines: Flat, Actionable, Kind-Based</h3>
<p>When errors need to be handled programmatically, complexity is the enemy. Your retry logic doesn’t want to traverse a nested error chain checking for specific variants. It wants to ask: <code>is_retryable()?</code></p>
<p>Here’s a pattern that works, drawn from <a href="https://github.com/apache/opendal/pull/977">Apache OpenDAL’s error design</a>:</p>
<div><figure><pre data-language="rust"><code><div><p><span>pub</span><span> </span><span>struct</span><span> </span><span>Error</span><span> {</span></p></div><div><p><span><span>    </span></span><span>kind</span><span>:</span><span> </span><span>ErrorKind</span><span>,</span></p></div><div><p><span><span>    </span></span><span>message</span><span>:</span><span> </span><span>String</span><span>,</span></p></div><div><p><span><span>    </span></span><span>status</span><span>:</span><span> </span><span>ErrorStatus</span><span>,</span></p></div><div><p><span><span>    </span></span><span>operation</span><span>:</span><span> </span><span>&amp;</span><span>&#39;</span><span>static</span><span> </span><span>str</span><span>,</span></p></div><div><p><span><span>    </span></span><span>context</span><span>:</span><span> </span><span>Vec</span><span>&lt;(</span><span>&amp;</span><span>&#39;</span><span>static</span><span> </span><span>str</span><span>, </span><span>String</span><span>)&gt;,</span></p></div><div><p><span><span>    </span></span><span>source</span><span>:</span><span> </span><span>Option</span><span>&lt;anyhow</span><span>::</span><span>Error</span><span>&gt;,</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>pub</span><span> </span><span>enum</span><span> </span><span>ErrorKind</span><span> {</span></p></div><div><p><span>    </span><span>NotFound</span><span>,</span></p></div><div><p><span>    </span><span>PermissionDenied</span><span>,</span></p></div><div><p><span>    </span><span>RateLimited</span><span>,</span></p></div><div><p><span>    </span><span>// ... categorized by what the caller CAN DO</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>pub</span><span> </span><span>enum</span><span> </span><span>ErrorStatus</span><span> {</span></p></div><div><p><span>    </span><span>Permanent</span><span>,   </span><span>// Don&#39;t retry</span></p></div><div><p><span>    </span><span>Temporary</span><span>,   </span><span>// Safe to retry</span></p></div><div><p><span>    </span><span>Persistent</span><span>,  </span><span>// Was retried, still failing</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>This design enables clear decision-making:</p>
<div><figure><pre data-language="rust"><code><div><p><span>// Caller can make informed decisions</span></p></div><div><p><span>match</span><span> result {</span></p></div><div><p><span>    </span><span>Err</span><span>(e) </span><span>if</span><span> e</span><span>.</span><span>kind</span><span>() </span><span>==</span><span> </span><span>ErrorKind</span><span>::</span><span>RateLimited</span><span> </span><span>&amp;&amp;</span><span> e</span><span>.</span><span>is_temporary</span><span>() </span><span>=&gt;</span><span> {</span></p></div><div><p><span>        </span><span>sleep</span><span>(</span><span>Duration</span><span>::</span><span>from_secs</span><span>(</span><span>1</span><span>))</span><span>.await</span><span>;</span></p></div><div><p><span>        </span><span>retry</span><span>()</span><span>.await</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div><p><span>    </span><span>Err</span><span>(e) </span><span>if</span><span> e</span><span>.</span><span>kind</span><span>() </span><span>==</span><span> </span><span>ErrorKind</span><span>::</span><span>NotFound</span><span> </span><span>=&gt;</span><span> {</span></p></div><div><p><span>        </span><span>create_default</span><span>()</span><span>.await</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div><p><span>    </span><span>Err</span><span>(e) </span><span>=&gt;</span><span> </span><span>return</span><span> </span><span>Err</span><span>(e),</span></p></div><div><p><span>    </span><span>Ok</span><span>(v) </span><span>=&gt;</span><span> v,</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>Notice the key design decisions:</p>
<p><strong>ErrorKind is categorized by response, not origin.</strong> <code>NotFound</code> means “the thing doesn’t exist, don’t retry.” <code>RateLimited</code> means “slow down and try again.” The caller doesn’t need to know whether it was an S3 404 or a filesystem ENOENT—they need to know what to do about it.</p>
<p><strong>ErrorStatus is explicit.</strong> Instead of guessing retryability from error types, it’s a first-class field. Services can mark errors as temporary when they know a retry might help.</p>
<p><strong>One Error type per library.</strong> Instead of scattering error enums across modules, a single flat structure keeps things simple. The <code>context</code> field provides all the specificity you need without type proliferation.</p>
<p>No more traversing error chains, no more guessing from error types. Just ask the error directly.</p>
<h3 id="for-humans-low-friction-context-capture">For Humans: Low-Friction Context Capture</h3>
<p>The biggest enemy of good error context isn’t capability—it’s friction. If adding context is annoying, developers won’t do it.</p>
<p>The <a href="https://github.com/fast/exn">exn</a> library (294 lines of Rust, zero dependencies) demonstrates one approach: errors form a <em>tree</em> of frames, each automatically capturing its source location via <code>#[track_caller]</code>. Unlike linear error chains, trees can represent multiple causes—useful when parallel operations fail or validation produces multiple errors.</p>
<p>Here’s what we need:</p>
<p><strong>Automatic location capture.</strong> Instead of expensive backtraces, use <code>#[track_caller]</code> to capture file/line/column at <strong>zero cost</strong>. Every error frame should know where it was created.</p>
<p><strong>Ergonomic context addition.</strong> The API for adding context should be so natural that <em>not</em> adding it feels wrong:</p>
<div><figure><pre data-language="rust"><code><div><p><span>fetch_user</span><span>(user_id)</span></p></div><div><p><span>    </span><span>.</span><span>or_raise</span><span>(</span><span>||</span><span> </span><span>AppError</span><span>(</span><span>format!</span><span>(</span><span>&#34;failed to fetch user {user_id}&#34;</span><span>)))</span><span>?</span><span>;</span></p></div></code></pre></figure></div>
<p>Compare this to <code>thiserror</code>, where adding the same context requires defining a new variant and manual wrapping:</p>
<div><figure><pre data-language="rust"><code><div><p><span>#[derive(thiserror</span><span>::</span><span>Error</span><span>, </span><span>Debug</span><span>)]</span></p></div><div><p><span>pub</span><span> </span><span>enum</span><span> </span><span>AppError</span><span> {</span></p></div><div><p><span><span>    </span></span><span>#[error(</span><span>&#34;failed to fetch user {user_id}: {source}&#34;</span><span>)]</span></p></div><div><p><span>    </span><span>FetchUser</span><span> {</span></p></div><div><p><span><span>        </span></span><span>user_id</span><span>:</span><span> </span><span>String</span><span>,</span></p></div><div><p><span><span>        </span></span><span>#[source]</span></p></div><div><p><span><span>        </span></span><span>source</span><span>:</span><span> </span><span>DbError</span><span>,</span></p></div><div><p><span><span>    </span></span><span>},</span></p></div><div><p><span>    </span><span>// ... one variant per call site that needs context</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>fn</span><span> </span><span>fetch_user</span><span>(user_id</span><span>:</span><span> </span><span>&amp;</span><span>str</span><span>) </span><span>-&gt;</span><span> </span><span>Result</span><span>&lt;</span><span>User</span><span>, </span><span>AppError</span><span>&gt; {</span></p></div><div><p><span><span>    </span></span><span>db</span><span>.</span><span>query</span><span>(user_id)</span><span>.</span><span>map_err</span><span>(</span><span>|</span><span>e</span><span>|</span><span> </span><span>AppError</span><span>::</span><span>FetchUser</span><span> {</span></p></div><div><p><span><span>        </span></span><span>user_id</span><span>:</span><span> user_id</span><span>.</span><span>to_string</span><span>(),</span></p></div><div><p><span><span>        </span></span><span>source</span><span>:</span><span> e,</span></p></div><div><p><span><span>    </span></span><span>})</span><span>?</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p><strong>Enforce context at module boundaries.</strong> This is where exn differs critically from <code>anyhow</code>. With <code>anyhow</code>, every error is erased to <code>anyhow::Error</code>, so you can always use <code>?</code> and move on—the type system won’t stop you. The context methods exist, but but <em>nothing</em> prevents you from ignoring them.</p>
<p>exn takes a different approach: <code>Exn&lt;E&gt;</code> preserves the outermost error type. If your function returns <code>Result&lt;T, Exn&lt;ServiceError&gt;&gt;</code>, you can’t directly <code>?</code> a <code>Result&lt;U, Exn&lt;DatabaseError&gt;&gt;</code>—the types don’t match. The compiler <em>forces</em> you to call <code>or_raise()</code> and provide a <code>ServiceError</code>, which is exactly the moment you should be adding context about what your module was trying to do.</p>
<div><figure><pre data-language="rust"><code><div><p><span>// This won&#39;t compile--type mismatch forces you to add context</span></p></div><div><p><span>pub</span><span> </span><span>fn</span><span> </span><span>fetch_user</span><span>(user_id</span><span>:</span><span> </span><span>&amp;</span><span>str</span><span>) </span><span>-&gt;</span><span> </span><span>Result</span><span>&lt;</span><span>User</span><span>, </span><span>Exn</span><span>&lt;</span><span>ServiceError</span><span>&gt;&gt; {</span></p></div><div><p><span>    </span><span>let</span><span> user </span><span>=</span><span> db</span><span>.</span><span>query</span><span>(user_id)</span><span>?</span><span>;  </span><span>// Error: expected Exn&lt;ServiceError&gt;, found Exn&lt;DbError&gt;</span></p></div><div><p><span>    </span><span>Ok</span><span>(user)</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>// You must provide context at the boundary</span></p></div><div><p><span>pub</span><span> </span><span>fn</span><span> </span><span>fetch_user</span><span>(user_id</span><span>:</span><span> </span><span>&amp;</span><span>str</span><span>) </span><span>-&gt;</span><span> </span><span>Result</span><span>&lt;</span><span>User</span><span>, </span><span>Exn</span><span>&lt;</span><span>ServiceError</span><span>&gt;&gt; {</span></p></div><div><p><span>    </span><span>let</span><span> user </span><span>=</span><span> db</span><span>.</span><span>query</span><span>(user_id)</span></p></div><div><p><span>        </span><span>.</span><span>or_raise</span><span>(</span><span>||</span><span> </span><span>ServiceError</span><span>(</span><span>format!</span><span>(</span><span>&#34;failed to fetch user {user_id}&#34;</span><span>)))</span><span>?</span><span>;  </span><span>// Now it compiles</span></p></div><div><p><span>    </span><span>Ok</span><span>(user)</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>The type system becomes your ally: it won’t let you be lazy at module boundaries.</p>
<p>Here’s what this looks like in practice:</p>
<div><figure><pre data-language="rust"><code><div><p><span>pub</span><span> </span><span>async</span><span> </span><span>fn</span><span> </span><span>execute</span><span>(</span><span>&amp;</span><span>self</span><span>, task</span><span>:</span><span> </span><span>Task</span><span>) </span><span>-&gt;</span><span> </span><span>Result</span><span>&lt;</span><span>Output</span><span>, </span><span>ExecutorError</span><span>&gt; {</span></p></div><div><p><span>    </span><span>let</span><span> make_error </span><span>=</span><span> </span><span>||</span><span> </span><span>ExecutorError</span><span>(</span><span>format!</span><span>(</span><span>&#34;failed to execute task {}&#34;</span><span>, task</span><span>.</span><span>id));</span></p></div><div></div><div><p><span>    </span><span>let</span><span> user </span><span>=</span><span> </span><span>self</span><span>.</span><span>fetch_user</span><span>(task</span><span>.</span><span>user_id)</span><span>.await.</span><span>or_raise</span><span>(make_error)</span><span>?</span><span>;</span></p></div><div><p><span>    </span><span>let</span><span> result </span><span>=</span><span> </span><span>self</span><span>.</span><span>process</span><span>(user)</span><span>.</span><span>or_raise</span><span>(make_error)</span><span>?</span><span>;</span></p></div><div></div><div><p><span>    </span><span>Ok</span><span>(result)</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>Every <code>?</code> has context. When this fails at 3am, instead of the cryptic <code>serialization error</code>, you see:</p>
<div><figure><pre data-language="plaintext"><code><div><p><span>failed to execute task 7829, at src/executor.rs:45:12</span></p></div><div><p><span>|</span></p></div><div><p><span>|-&gt; failed to fetch user &#34;John Doe&#34;, at src/executor.rs:52:10</span></p></div><div><p><span>|</span></p></div><div><p><span>|-&gt; connection refused, at src/client.rs:89:24</span></p></div></code></pre></figure></div>
<p>Now you know: it was task 7829, we were fetching user data, and the connection was refused. You can grep for that task ID in your request logs and find everything you need.</p>
<hr/>
<h2 id="putting-it-together">Putting It Together</h2>
<p>In real systems, you often need both: machine-readable errors for automated recovery, and human-readable context for debugging. The pattern: use a flat, kind-based error type (like Apache OpenDAL’s) for the structured data, and wrap it in a context-tracking mechanism for propagation.</p>
<div><figure><pre data-language="rust"><code><div><p><span>// Machine-oriented: flat struct with status</span></p></div><div><p><span>pub</span><span> </span><span>struct</span><span> </span><span>StorageError</span><span> {</span></p></div><div><p><span>    </span><span>pub</span><span> status</span><span>:</span><span> </span><span>ErrorStatus</span><span>,</span></p></div><div><p><span>    </span><span>pub</span><span> message</span><span>:</span><span> </span><span>String</span><span>,</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>// Human-oriented: propagate with context at each layer</span></p></div><div><p><span>pub</span><span> </span><span>async</span><span> </span><span>fn</span><span> </span><span>save_document</span><span>(doc</span><span>:</span><span> </span><span>Document</span><span>) </span><span>-&gt;</span><span> </span><span>Result</span><span>&lt;(), </span><span>Exn</span><span>&lt;</span><span>StorageError</span><span>&gt;&gt; {</span></p></div><div><p><span>    </span><span>let</span><span> data </span><span>=</span><span> </span><span>serialize</span><span>(</span><span>&amp;</span><span>doc)</span></p></div><div><p><span>        </span><span>.</span><span>or_raise</span><span>(</span><span>||</span><span> </span><span>StorageError</span><span>::</span><span>permanent</span><span>(</span><span>&#34;serialization failed&#34;</span><span>))</span><span>?</span><span>;</span></p></div><div></div><div><p><span><span>    </span></span><span>storage</span><span>.</span><span>write</span><span>(</span><span>&amp;</span><span>doc</span><span>.</span><span>path, data)</span></p></div><div><p><span>        </span><span>.await</span></p></div><div><p><span>        </span><span>.</span><span>or_raise</span><span>(</span><span>||</span><span> </span><span>StorageError</span><span>::</span><span>temporary</span><span>(</span><span>&#34;write failed&#34;</span><span>))</span><span>?</span><span>;</span></p></div><div></div><div><p><span>    </span><span>Ok</span><span>(())</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>At the boundary, walk the error tree to find the structured error:</p>
<div><figure><pre data-language="rust"><code><div><p><span>// Extract a typed error from anywhere in the tree</span></p></div><div><p><span>fn</span><span> </span><span>find_error</span><span>&lt;</span><span>T</span><span>&gt;(exn</span><span>:</span><span> </span><span>&amp;</span><span>Exn</span><span>&lt;</span><span>impl</span><span> </span><span>Error</span><span>&gt;) </span><span>-&gt;</span><span> </span><span>Option</span><span>&lt;</span><span>&amp;</span><span>T</span><span>&gt; {</span></p></div><div><p><span>    </span><span>fn</span><span> </span><span>walk</span><span>&lt;</span><span>T</span><span>&gt;(frame</span><span>:</span><span> </span><span>&amp;</span><span>Frame</span><span>) </span><span>-&gt;</span><span> </span><span>Option</span><span>&lt;</span><span>&amp;</span><span>T</span><span>&gt; {</span></p></div><div><p><span>        </span><span>if</span><span> </span><span>let</span><span> </span><span>Some</span><span>(e) </span><span>=</span><span> frame</span><span>.</span><span>as_any</span><span>()</span><span>.</span><span>downcast_ref</span><span>::</span><span>&lt;</span><span>T</span><span>&gt;() {</span></p></div><div><p><span>            </span><span>return</span><span> </span><span>Some</span><span>(e);</span></p></div><div><p><span><span>        </span></span><span>}</span></p></div><div><p><span><span>        </span></span><span>frame</span><span>.</span><span>children</span><span>()</span><span>.</span><span>iter</span><span>()</span><span>.</span><span>find_map</span><span>(walk)</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div><p><span>    </span><span>walk</span><span>(exn</span><span>.</span><span>as_frame</span><span>())</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>match</span><span> </span><span>save_document</span><span>(doc)</span><span>.await</span><span> {</span></p></div><div><p><span>    </span><span>Ok</span><span>(()) </span><span>=&gt;</span><span> </span><span>Ok</span><span>(()),</span></p></div><div><p><span>    </span><span>Err</span><span>(report) </span><span>=&gt;</span><span> {</span></p></div><div><p><span>        </span><span>// For humans: log the full context tree</span></p></div><div><p><span>        </span><span>log</span><span>::</span><span>error!</span><span>(</span><span>&#34;{:?}&#34;</span><span>, report);</span></p></div><div></div><div><p><span>        </span><span>// For machines: find and handle the structured error</span></p></div><div><p><span>        </span><span>if</span><span> </span><span>let</span><span> </span><span>Some</span><span>(err) </span><span>=</span><span> </span><span>find_error</span><span>::</span><span>&lt;</span><span>StorageError</span><span>&gt;(</span><span>&amp;</span><span>report) {</span></p></div><div><p><span>            </span><span>if</span><span> err</span><span>.</span><span>status </span><span>==</span><span> </span><span>ErrorStatus</span><span>::</span><span>Temporary</span><span> {</span></p></div><div><p><span>                </span><span>return</span><span> </span><span>queue_for_retry</span><span>(report);</span></p></div><div><p><span><span>            </span></span><span>}</span></p></div><div><p><span>            </span><span>return</span><span> </span><span>Err</span><span>(</span><span>map_to_http_status</span><span>(err</span><span>.</span><span>kind));</span></p></div><div><p><span><span>        </span></span><span>}</span></p></div><div></div><div><p><span>        </span><span>Err</span><span>(</span><span>StatusCode</span><span>::</span><span>INTERNAL_SERVER_ERROR</span><span>)</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>Yes, you still need to walk the tree. But unlike the <code>Provide</code>/<code>Request</code> API, you end up with a concrete type like <code>StorageError</code>—a documented struct with named fields that your IDE can autocomplete. No guessing, no runtime surprises—just something you can reason about and maintain.</p>
<hr/>
<h2 id="conclusion">Conclusion</h2>
<p>The next time you write a function, look at the <code>Result</code> return type.</p>
<p>Don’t think of it as “I might fail.”
Think of it as “I might need to explain myself.”</p>
<p>If your error type can’t answer “Should I retry?”—you failed the Machine.
If your error logs don’t answer “Which user was it?”—you failed the Human.</p>
<p>Errors aren’t just failure modes to be propagated. They’re communication. They’re the messages your system sends when things go wrong. And like any communication, they deserve to be designed.</p>
<p>Stop forwarding errors. Start designing them.</p>
<h2 id="resources">Resources</h2>
<ul>
<li><a href="https://github.com/apache/opendal/pull/977">OpenDAL Error Design RFC</a></li>
<li><a href="https://xuanwo.io/en-us/reports/2022-46/">OpenDAL’s Error Handling Practices</a></li>
<li><a href="https://github.com/fast/exn">exn: Context-aware errors for Rust</a></li>
<li><a href="https://greptime.com/blogs/2024-05-07-error-rust">Error Handling in Large Rust Projects (GreptimeDB)</a></li>
<li><a href="https://bugenzhao.com/2024/04/24/error-handling-1/">A Guide to Error Handling that Just Works</a></li>
<li><a href="https://matklad.github.io/2020/10/15/study-of-std-io-error.html">Study of std::io::Error</a></li>
<li><a href="https://lpalmieri.com/posts/error-handling-rust/">Error Handling In Rust - A Deep Dive</a></li>
<li><a href="https://github.com/rust-lang/rust/issues/96024">Tracking Issue for Provider API</a></li>
<li><a href="https://rust-lang.github.io/wg-async/design_docs/async_stack_traces.html">Async Stack Traces Working Group</a></li>
</ul> <p> Last edited Jan 04 </p> </div></div>
  </body>
</html>
