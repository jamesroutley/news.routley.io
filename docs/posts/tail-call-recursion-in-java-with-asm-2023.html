<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://unlinkedlist.org/2023/03/19/tail-call-recursion-in-java-with-asm/">Original</a>
    <h1>Tail Call Recursion in Java with ASM (2023)</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>One kind of optimization offered by some compilers is <em>tail call optimization</em>. This optimization does not bring much, since the programmer can always tailor his code without recursion, especially in an imperative language. On the other side, recursive code often times more elegant, so why we don’t let the compiler do the nasty stuff when it is possible? In this article I will present a neat way to implement tail call optimization in Java using byte code manipulation with ASM. </p>



<h2>What is tail call recursion?</h2>



<p>A tail call recursion is a special form of recursion where the last operation is the recursive call. It belongs to the more general class of tail calls, where the last operation is a method call. I will limit myself to the more restrictive case of tail recursion. Let’s illustrate with an example.</p>



<div data-code-block-pro-font-family="Code-Pro-JetBrains-Mono"><pre tabindex="0"><code><span><span>long</span><span> </span><span>factorial</span><span>(</span><span>int</span><span> n, </span><span>long</span><span> f) {</span></span>
<span><span>    </span><span>if</span><span>(n</span><span>&lt;</span><span>2</span><span>) {</span></span>
<span><span>        </span><span>return</span><span> f;</span></span>
<span><span>    }</span></span>
<span><span>    </span><span>return</span><span> </span><span>factorial</span><span>(n</span><span>-</span><span>1</span><span>, f</span><span>*</span><span>n);</span></span>
<span><span>}</span></span></code></pre></div>



<p>As one can see, the last operation is a call to the same function, but with different parameters. The next example is not a tail recursion.</p>



<div data-code-block-pro-font-family="Code-Pro-JetBrains-Mono"><pre tabindex="0"><code><span><span>long</span><span> </span><span>factorial</span><span>(</span><span>int</span><span> n) {</span></span>
<span><span>    </span><span>if</span><span>(n</span><span>&lt;</span><span>2</span><span>) {</span></span>
<span><span>        </span><span>return</span><span> f;</span></span>
<span><span>    }</span></span>
<span><span>    </span><span>return</span><span> n </span><span>*</span><span> </span><span>factorial</span><span>(n</span><span>-</span><span>1</span><span>);</span></span>
<span><span>}</span></span></code></pre></div>



<p>The reason why the previous example is not a tail call recursion is that the last operation is not the recursive call, but the multiplication operation. Multiplication happens after the recursive call returns. </p>



<p>A tail recursion has a specific form which allows a faster execution by avoiding allocating a new stack frame since the execution can utilize the current stack. </p>



<h2>Anatomy of a method call</h2>



<p>If you don’t know much of how Java Virtual Machine make method calls this is a brief overview of it. The idea is almost universal in programming, however the details presented are specific to JVM.</p>



<p>In order for a method to be able to execute it needs a space called frame, where some specific things should be contained:</p>



<ul>
<li>local variables space: a fixed array of entries with values of various types</li>



<li>operand stack: a stack where the current operands are stored</li>
</ul>



<p>There is also an execution stack managed by JVM. The JVM execution stack, collects frames. When a method is called for execution a new frame is created, initialized properly and pushed on the JVM execution stack. The eventual parameters of the method call are collected from the current stack and used for the initialization of the new frame. After the method ends it’s execution, the returned value (if any) is collected, the frame allocated for that method call is removed from the JVM stack, the previous frame is referenced and the collected return value is pushed on stack. </p>



<p>The size of the local variables and operand stack parts depends on the method’s code, it’s computed at compile time and is stored along with the bytecode instructions in compiled classes. All the frames that correspond to the invocation of the same method are identical in size, but those that correspond to different methods can have different sizes.</p>



<p>When it is created, a frame is initialized with an empty stack, and its local variables are initialized with the target object <em>this</em> (for non static methods) and with the method’s arguments (in this order). For instance, calling the method <em>a.equals(b)</em> creates a frame with an empty stack and with the first two local variables initialized to <em>a</em> and <em>b</em> (other local variables are uninitialized).</p>



<p>As you can see, calling methods in chains will increase the space required by the JVM execution stack since for each inner method call a new frame is pushed on the stack. Since stack is limited, calling multiple time nested methods can fill the JVM execution stack to the point that it throws exceptions like StackOverflowError, about which you have heard about.</p>



<p>Exhausting stack space is often encountered when one implements algorithms in recursive fashion. </p>



<h2>A practical example of  a compiled class</h2>



<p>Let’s study the generated code for the following class.</p>



<div data-code-block-pro-font-family="Code-Pro-JetBrains-Mono"><pre tabindex="0"><code><span><span>public</span><span> </span><span>class</span><span> </span><span>Factorial</span><span> </span><span>implements</span><span> </span><span>FactorialInterface</span><span> {</span></span>
<span><span>    </span><span>public</span><span> </span><span>long</span><span> </span><span>fact</span><span>(</span><span>int</span><span> </span><span>n</span><span>) {</span></span>
<span><span>        </span><span>return</span><span> </span><span>factTailRec</span><span>(n, </span><span>1L</span><span>);</span></span>
<span><span>    }</span></span>
<span><span>    </span><span>private</span><span> </span><span>long</span><span> </span><span>factTailRec</span><span>(</span><span>int</span><span> </span><span>n</span><span>, </span><span>long</span><span> </span><span>ret</span><span>) {</span></span>
<span><span>        </span><span>if</span><span> (n </span><span>&lt;</span><span> </span><span>1</span><span>) {</span></span>
<span><span>            </span><span>return</span><span> ret;</span></span>
<span><span>        }</span></span>
<span><span>        </span><span>return</span><span> </span><span>factTailRec</span><span>(n </span><span>-</span><span> </span><span>1</span><span>, ret </span><span>*</span><span> n);</span></span>
<span><span>    }</span></span>
<span><span>}</span></span></code></pre></div>



<p>As you can see we have a simple class which implements the factorial function in a tail recursive fashion. The first method is a facade for better user experience, while the second method implements the actual computations. </p>



<p>The generated class looks like the following</p>



<div data-code-block-pro-font-family="Code-Pro-JetBrains-Mono"><pre tabindex="0"><code><span><span>// class version 63.0 (63)</span></span>
<span><span>// access flags 0x21</span></span>
<span><span>public</span><span> </span><span>class</span><span> </span><span>rapaio</span><span>/experiment/asm/Factorial </span><span>implements</span><span> rapaio/experiment/asm/</span><span>FactorialInterface</span><span> {</span></span>
<span><span>  </span><span>// compiled from: Factorial.java</span></span>
<span><span>  </span><span>// access flags 0x1</span></span>
<span><span>  </span><span>public</span><span> &lt;</span><span>init</span><span>&gt;()V</span></span>
<span><span>   L0</span></span>
<span><span>    LINENUMBER 34 L0</span></span>
<span><span>    ALOAD 0</span></span>
<span><span>    INVOKESPECIAL java/lang/Object.&lt;</span><span>init</span><span>&gt; ()V</span></span>
<span><span>    RETURN</span></span>
<span><span>   L1</span></span>
<span><span>    LOCALVARIABLE this Lrapaio/experiment/asm/Factorial; L0 L1 </span><span>0</span></span>
<span><span>    MAXSTACK </span><span>=</span><span> </span><span>1</span></span>
<span><span>    MAXLOCALS </span><span>=</span><span> </span><span>1</span></span>
<span><span>  </span><span>// access flags 0x1</span></span>
<span><span>  </span><span>public</span><span> </span><span>fact</span><span>(I)J</span></span>
<span><span>   L0</span></span>
<span><span>    LINENUMBER </span><span>37</span><span> L0</span></span>
<span><span>    ALOAD </span><span>0</span></span>
<span><span>    ILOAD </span><span>1</span></span>
<span><span>    LCONST_1</span></span>
<span><span>    INVOKEVIRTUAL rapaio</span><span>/</span><span>experiment</span><span>/</span><span>asm</span><span>/</span><span>Factorial.</span><span>factTailRec</span><span> (IJ)J</span></span>
<span><span>    LRETURN</span></span>
<span><span>   L1</span></span>
<span><span>    LOCALVARIABLE </span><span>this</span><span> Lrapaio</span><span>/</span><span>experiment</span><span>/</span><span>asm</span><span>/</span><span>Factorial; L0 L1 </span><span>0</span></span>
<span><span>    LOCALVARIABLE n I L0 L1 </span><span>1</span></span>
<span><span>    MAXSTACK </span><span>=</span><span> </span><span>4</span></span>
<span><span>    MAXLOCALS </span><span>=</span><span> </span><span>2</span></span>
<span><span>  </span><span>// access flags 0x2</span></span>
<span><span>  </span><span>private</span><span> </span><span>factTailRec</span><span>(IJ)J</span></span>
<span><span>   L0</span></span>
<span><span>    LINENUMBER </span><span>41</span><span> L0</span></span>
<span><span>    ILOAD </span><span>1</span></span>
<span><span>    ICONST_1</span></span>
<span><span>    IF_ICMPGE L1</span></span>
<span><span>   L2</span></span>
<span><span>    LINENUMBER </span><span>42</span><span> L2</span></span>
<span><span>    LLOAD </span><span>2</span></span>
<span><span>    LRETURN</span></span>
<span><span>   L1</span></span>
<span><span>    LINENUMBER </span><span>44</span><span> L1</span></span>
<span><span>   FRAME SAME</span></span>
<span><span>    ALOAD </span><span>0</span></span>
<span><span>    ILOAD </span><span>1</span></span>
<span><span>    ICONST_1</span></span>
<span><span>    ISUB</span></span>
<span><span>    LLOAD </span><span>2</span></span>
<span><span>    ILOAD </span><span>1</span></span>
<span><span>    I2L</span></span>
<span><span>    LMUL</span></span>
<span><span>    INVOKEVIRTUAL rapaio</span><span>/</span><span>experiment</span><span>/</span><span>asm</span><span>/</span><span>Factorial.</span><span>factTailRec</span><span> (IJ)J</span></span>
<span><span>    LRETURN</span></span>
<span><span>   L3</span></span>
<span><span>    LOCALVARIABLE </span><span>this</span><span> Lrapaio</span><span>/</span><span>experiment</span><span>/</span><span>asm</span><span>/</span><span>Factorial; L0 L3 </span><span>0</span></span>
<span><span>    LOCALVARIABLE n I L0 L3 </span><span>1</span></span>
<span><span>    LOCALVARIABLE ret J L0 L3 </span><span>2</span></span>
<span><span>    MAXSTACK </span><span>=</span><span> </span><span>6</span></span>
<span><span>    MAXLOCALS </span><span>=</span><span> </span><span>4</span></span>
<span><span>}</span></span></code></pre></div>



<p>Let us explain the byte code. We have a class which implements an interface and we have a default constructor. </p>



<p>The default constructor is optional in Java language, but it is not in JVM bytecode. The default constructor has, as a first instruction <em>ALOAD 0</em> which loads the <em>this</em> pointer on the operational stack from local variable with index <em>0</em> (remember how the local variables are initialized). The second instruction invokes method <em>init</em> of class Object. This method takes one parameter, which is a pointer to an object. This pointer is taken from operational stack (this is why we have the first instruction). It returns <em>void</em> as it is signaled in it’s description with <em>V</em>. After that it simply returns the control to the previous call. Notice that it follows the description of the initial frame with variables used, the number of entries allocated for operand stack and for local variable table.</p>



<p>It follows the description of method <em>fact</em>, which takes a single integer argument (described by <em>I</em>) and it returns a long value (described by <em>J</em>). The instruction list starts with loading <em>this</em> pointer (<em>ALOAD 0</em>), the value of the parameter (<em>ILOAD 1</em>) and pushing on operand stack the constant long value 1 (<em>LCONST_1</em>). All the three values loaded on operational stack are used by the following instruction which is a call to method <em>factTailRect</em> in reverse order (it’s a stack). After the method call ends, it’s returned value is pushed on the operand stack. That value is used by the next instruction <em>LRETURN</em> which returns the long value from the operand stack and resumes the control to the calling method.</p>



<p>The description of method <em>factTailRect</em> is a little bit more complex, but not overly complicated. Load the value of the first parameter on operand stack (<em>ILOAD 1</em>) and also the integer constant <em>1</em> (<em>ICONST_1</em>). The next instruction compares the value of the parameter with the constant (<em>IF_ICMPGE L1</em>) and if the variable is greater or equal than constant go to label <em>L1</em>, otherwise continue. If the comparison fails than loads the value of the second variable on operand stack (<em>LLOAD 2</em>) and returns it (<em>LRETURN</em>). </p>



<p>At the label <em>L1</em> there are instructions for the recursive call. First the <em>this</em> pointer is loaded on stack in preparation for recursive call (<em>ALOAD 0</em>). Then the first variable is loaded on stack (<em>ILOAD 1</em>) and constant <em>1</em> (<em>ICONST_1</em>). Those two are used by subtract operation which decrease the value of variable with the value of constant (<em>ISUB</em>). The returned value is put on stack. Notice at this point that on stack we have two values: the value of <em>this</em> pointer and the decreased value of variable (the subtraction instruction pop up two operands from stack and put back one, the result).</p>



<p>Next the second variable is put on stack (<em>LLOAD 2</em>) and also the value of the first variable (<em>ILOAD 1</em>). The first variable still has the original value, the modified one being on stack. The integer variable is converted to long type (<em>I2L</em>) and both values are multiplied (<em>LMUL</em>). The multiplication uses the last two stack operands and push back the result of multiplication. </p>



<p>The operand stack has now three values, the values required for the recursive call function <em>(INVOKEVIRTUAL</em>). The three operands are consumed by method call and the result is put on stack. The final result is returned (<em>LRETURN</em>). Last part is the description of the frame which contains three local variables and has allocated 6 places on stack and 4 on local variable table. </p>



<p>I hope you were not bored reading all of that. Maybe you know how the JVM stack machine works, but I have put that description for the case when you don’t. </p>



<h2>The structure of a tail call recursion</h2>



<p>In general a <em>tail call recursion</em> has a very simple structure. A tail recursive method has three phases. The first phase are the stopping rules. Those rules defines when the recursion will end. The second phase contains calculations and the third stage is the recursive call who’s result is returned. Often times, when the computation is simple the last two phases are merged into a single one, where the computation happens just before passing parameter values. This is the case with our method. </p>



<p>Having this clear design some observations can be made which leads to a straightforward optimization. </p>



<p>The first observation is that since the same method is called, the shape of the frame for the recursive call is identical with the current frame. The reason is that the shape of a frame is determined at compile time and remains fixed. Since we call recursively the same method, we are sure that the current frame fits the needs of the recursive call. The possible optimization is to avoid creating a new frame which has to be pushed on JVM execution stack with each call. </p>



<p>The second observation is that in order to reuse the current frame we need to prepare the stack and local variables in the same way as it would be if a proper frame initialization would happen. However this is very easy to be done simply because the last call before return is the recursive call. In order to make a recursive call the stack needs to be filled with the value of <em>this</em> pointer and all parameter values in order. The call would pop all those values from the current operational stack and would initialize the next frame with those values. This is what we have to do. Simply to take all those values and properly initialize the local variables of the current frame. The values are already prepared for us.</p>



<h2>Using ASM to transform byte code</h2>



<p>ASM is a wonderfull and neat library which allows one to analyze, transform and generate byte code at compile time or at runtime. It is used by many platforms and tools, including the OpenJDK compiler itself. I have not enough words to describe the usefulness and elegance of this library and I feel in great debt to its creator and contributors. </p>



<p>ASM library allows one to transform byte code using two approaches: event based and tree based. I will use the tree based API since the changes are not trivial and could not be performed in a single pass of the parser. This is the code used to optimize a method which is tail recursive:</p>



<div data-code-block-pro-font-family="Code-Pro-JetBrains-Mono"><pre tabindex="0"><code><span><span>class</span><span> </span><span>TailRecTransformer</span><span> </span><span>extends</span><span> </span><span>ClassNode</span><span> {</span></span>
<span><span>    </span><span>private</span><span> </span><span>static</span><span> </span><span>final</span><span> String METHOD_SUFFIX </span><span>=</span><span> </span><span>&#34;TailRec&#34;</span><span>;</span></span>
<span><span>    </span><span>public</span><span> </span><span>TailRecTransformer</span><span>(ClassVisitor </span><span>cv</span><span>) {</span></span>
<span><span>        </span><span>super</span><span>(ASM9);</span></span>
<span><span>        </span><span>this</span><span>.cv </span><span>=</span><span> cv;</span></span>
<span><span>    }</span></span>
<span><span>    @</span><span>Override</span></span>
<span><span>    </span><span>public</span><span> </span><span>void</span><span> </span><span>visitEnd</span><span>() {</span></span>
<span><span>        </span><span>// we optimize all methods which ends with TailRec for simplicity</span></span>
<span><span>        methods.</span><span>stream</span><span>().</span><span>filter</span><span>(mn </span><span>-&gt;</span><span> mn.name.</span><span>endsWith</span><span>(METHOD_SUFFIX))</span></span>
<span><span>                .</span><span>forEach</span><span>(</span><span>this</span><span>::</span><span>transformTailRec);</span></span>
<span><span>        </span><span>accept</span><span>(cv);</span></span>
<span><span>    }</span></span>
<span><span>    </span><span>void</span><span> </span><span>transformTailRec</span><span>(MethodNode </span><span>methodNode</span><span>) {</span></span>
<span><span>        </span><span>// method argument types</span></span>
<span><span>        </span><span>Type</span><span>[] argumentTypes </span><span>=</span><span> Type.</span><span>getArgumentTypes</span><span>(methodNode.desc);</span></span>
<span><span>        </span><span>// iterator over instructions</span></span>
<span><span>        </span><span>var</span><span> it </span><span>=</span><span> methodNode.instructions.</span><span>iterator</span><span>();</span></span>
<span><span>        LabelNode firstLabel </span><span>=</span><span> </span><span>null</span><span>;</span></span>
<span><span>        </span><span>while</span><span> (it.</span><span>hasNext</span><span>()) {</span></span>
<span><span>            </span><span>var</span><span> inode </span><span>=</span><span> it.</span><span>next</span><span>();</span></span>
<span><span>            </span><span>// locate the first label</span></span>
<span><span>            </span><span>// this label will be used to jump instead of recursive call</span></span>
<span><span>            </span><span>if</span><span> (firstLabel </span><span>==</span><span> </span><span>null</span><span> </span><span>&amp;&amp;</span><span> inode </span><span>instanceof</span><span> LabelNode labelNode) {</span></span>
<span><span>                firstLabel </span><span>=</span><span> labelNode;</span></span>
<span><span>                </span><span>continue</span><span>;</span></span>
<span><span>            }</span></span>
<span><span>            </span><span>if</span><span> (inode </span><span>instanceof</span><span> FrameNode) {</span></span>
<span><span>                </span><span>// remove all frames since we recompute them all at writing</span></span>
<span><span>                it.</span><span>remove</span><span>();</span></span>
<span><span>                </span><span>continue</span><span>;</span></span>
<span><span>            }</span></span>
<span><span>            </span><span>if</span><span> (inode </span><span>instanceof</span><span> MethodInsnNode methodInsnNode </span><span>&amp;&amp;</span></span>
<span><span>                    methodInsnNode.name.</span><span>equals</span><span>(methodNode.name) </span><span>&amp;&amp;</span></span>
<span><span>                    methodInsnNode.desc.</span><span>equals</span><span>(methodNode.desc)) {</span></span>
<span><span>                </span><span>// find the recursive call which has to have</span></span>
<span><span>                </span><span>// same signature and be followed by return</span></span>
<span><span>                </span><span>// check if the next instruction is return of proper type</span></span>
<span><span>                </span><span>var</span><span> nextInstruction </span><span>=</span><span> it.</span><span>next</span><span>();</span></span>
<span><span>                Type returnType </span><span>=</span><span> Type.</span><span>getReturnType</span><span>(methodNode.desc);</span></span>
<span><span>                </span><span>if</span><span> (</span><span>!</span><span>(nextInstruction.</span><span>getOpcode</span><span>() </span><span>==</span><span> </span></span>
<span><span>                        returnType.</span><span>getOpcode</span><span>(IRETURN))) {</span></span>
<span><span>                    </span><span>continue</span><span>;</span></span>
<span><span>                }</span></span>
<span><span>                </span><span>// remove the return and recursive call from instructions</span></span>
<span><span>                it.</span><span>previous</span><span>();</span></span>
<span><span>                it.</span><span>previous</span><span>();</span></span>
<span><span>                it.</span><span>remove</span><span>();</span></span>
<span><span>                it.</span><span>next</span><span>();</span></span>
<span><span>                it.</span><span>remove</span><span>();</span></span>
<span><span>                </span><span>// pop values from stack and store them in local </span></span>
<span><span>                </span><span>// variables in reverse order</span></span>
<span><span>                </span><span>for</span><span> (</span><span>int</span><span> i </span><span>=</span><span> argumentTypes.length </span><span>-</span><span> </span><span>1</span><span>; i </span><span>&gt;=</span><span> </span><span>0</span><span>; i</span><span>--</span><span>) {</span></span>
<span><span>                    Type type </span><span>=</span><span> argumentTypes[i];</span></span>
<span><span>                    it.</span><span>add</span><span>(</span><span>new</span><span> </span><span>VarInsnNode</span><span>(type.</span><span>getOpcode</span><span>(ISTORE), i </span><span>+</span><span> </span><span>1</span><span>));</span></span>
<span><span>                }</span></span>
<span><span>                </span><span>// add a new jump instruction to the first label</span></span>
<span><span>                it.</span><span>add</span><span>(</span><span>new</span><span> </span><span>JumpInsnNode</span><span>(GOTO, firstLabel));</span></span>
<span><span>                </span><span>// finally remove the instruction which loaded &#39;this&#39;</span></span>
<span><span>                </span><span>// since it was required by the recursive call</span></span>
<span><span>                </span><span>while</span><span> (it.</span><span>hasPrevious</span><span>()) {</span></span>
<span><span>                    AbstractInsnNode node </span><span>=</span><span> it.</span><span>previous</span><span>();</span></span>
<span><span>                    </span><span>if</span><span> (node </span><span>instanceof</span><span> VarInsnNode varInsnNode) {</span></span>
<span><span>                        </span><span>if</span><span> (varInsnNode.</span><span>getOpcode</span><span>() </span><span>==</span><span> Opcodes.ALOAD </span><span>&amp;&amp;</span><span> </span></span>
<span><span>                                varInsnNode.var </span><span>==</span><span> </span><span>0</span><span>) {</span></span>
<span><span>                            it.</span><span>remove</span><span>();</span></span>
<span><span>                            </span><span>// we remove only the last instruction of this kind</span></span>
<span><span>                            </span><span>// we don&#39;t touch it other similar instructions </span></span>
<span><span>                            </span><span>// to not break the existent code</span></span>
<span><span>                            </span><span>break</span><span>;</span></span>
<span><span>                        }</span></span>
<span><span>                    }</span></span>
<span><span>                }</span></span>
<span><span>            }</span></span>
<span><span>        }</span></span>
<span><span>    }</span></span>
<span><span>}</span></span></code></pre></div>



<p>I really hope the code and comments are self contained. I will briefly present the logic of it for consistency.</p>



<p>In order to transform a method with tree API of ASM library, one needs to change the values in class <em>MethodNode</em> since this is the representation of JVM byte code in the ASM library. For simplicity, I created a transformer which tries to optimize all the methods who’s name ends with suffix <em>TailRec</em>. This is for illustrative purpose, an annotation would be preferable, but require more code and building an agent.</p>



<p>The core of the optimization logic lies in method <em>transformTailRec</em>. This method receives the corresponding representation of the bytecode of any class method who’s name ends with our sufix. The optimization has the following stages.</p>



<p>We identify the first code label. This is the start of the code for the recursive methods. We will use this label when we will replace the recursive call with a simple jump instruction. This jump instruction is <em>goto</em>. As a fun fact this infamous instruction does not exist in the Java language for good reason. This kind of uncontrolled jump would break all the accounting machinery of the JVM. However the same instruction exists in JVM. Because in JVM we can jump only inside a set of instructions from the same method call, it is safe to be used.</p>



<p>Instead of the recursive method call which would create a new frame, we will reuse the current frame. The next stage is to remove the recursive call and the return instruction after it, altogether with preparing the local variables and stack for next use. In place of the recursive call we introduce a <em>goto</em> instruction which points to the first label. Basically we implemented a <em>while</em> loop. The stopping conditions are already in the code, so we will not obtain an infinite loop because of the optimization.</p>



<p>We are done!</p>



<h2>Testing the recursive tail optimization</h2>



<p>A complete treatment of this would imply implementing a Java agent which would optimize the code before class loading. A avoided those complications because it is irrelevant to the subject. Maybe in the future I will create a tiny github project with this annotation and optimization. </p>



<p>To keep thing simple I wrote a custom class loader which creates classes with optimized code. Java allows one to have two classes with the same specification if those classes are loaded by different class loaders. In order to be easy to use them, I created also an interface. </p>



<p>In this way we will have two classes, one optimized and the other not optimized, and both implementing the same interface. In this way we can use them in the same JVM instance and test them with JMH. For reference the code for class loader is listed below.</p>



<div data-code-block-pro-font-family="Code-Pro-JetBrains-Mono"><pre tabindex="0"><code><span><span>public</span><span> </span><span>class</span><span> </span><span>CustomClassLoader</span><span> </span><span>extends</span><span> </span><span>ClassLoader</span><span> {</span></span>
<span><span>    </span><span>private</span><span> </span><span>final</span><span> </span><span>boolean</span><span> verbose;</span></span>
<span><span>    </span><span>public</span><span> </span><span>CustomClassLoader</span><span>(</span><span>boolean</span><span> </span><span>verbose</span><span>) {</span></span>
<span><span>        </span><span>this</span><span>.verbose </span><span>=</span><span> verbose;</span></span>
<span><span>    }</span></span>
<span><span>    @</span><span>Override</span></span>
<span><span>    </span><span>protected</span><span> Class&lt;</span><span>?</span><span>&gt; </span><span>findClass</span><span>(String </span><span>name</span><span>) {</span></span>
<span><span>        ClassWriter cw </span><span>=</span><span> </span><span>new</span><span> </span><span>ClassWriter</span><span>(</span><span>0</span><span>);</span></span>
<span><span>        ClassVisitor lastCv;</span></span>
<span><span>        </span><span>if</span><span> (verbose) {</span></span>
<span><span>            TraceClassVisitor beforeTcv </span><span>=</span><span> </span><span>new</span><span> </span><span>TraceClassVisitor</span><span>(cw, </span><span>new</span><span> </span><span>PrintWriter</span><span>(System.out));</span></span>
<span><span>            TailRecTransformer trt </span><span>=</span><span> </span><span>new</span><span> </span><span>TailRecTransformer</span><span>(beforeTcv);</span></span>
<span><span>            lastCv </span><span>=</span><span> </span><span>new</span><span> </span><span>TraceClassVisitor</span><span>(trt, </span><span>new</span><span> </span><span>PrintWriter</span><span>(System.out));</span></span>
<span><span>        } </span><span>else</span><span> {</span></span>
<span><span>            lastCv </span><span>=</span><span> </span><span>new</span><span> </span><span>TailRecTransformer</span><span>(cw);</span></span>
<span><span>        }</span></span>
<span><span>        ClassReader cr;</span></span>
<span><span>        </span><span>try</span><span> {</span></span>
<span><span>            cr </span><span>=</span><span> </span><span>new</span><span> </span><span>ClassReader</span><span>(name);</span></span>
<span><span>        } </span><span>catch</span><span> (IOException </span><span>e</span><span>) {</span></span>
<span><span>            </span><span>throw</span><span> </span><span>new</span><span> </span><span>RuntimeException</span><span>(e);</span></span>
<span><span>        }</span></span>
<span><span>        cr.</span><span>accept</span><span>(lastCv, </span><span>0</span><span>);</span></span>
<span><span>        </span><span>byte</span><span>[] buffer </span><span>=</span><span> cw.</span><span>toByteArray</span><span>();</span></span>
<span><span>        </span><span>return</span><span> </span><span>defineClass</span><span>(name, buffer, </span><span>0</span><span>, buffer.length);</span></span>
<span><span>    }</span></span>
<span><span>    </span><span>public</span><span> &lt;</span><span>T</span><span>&gt; T </span><span>newTailRecInstance</span><span>(Class&lt;</span><span>T</span><span>&gt; </span><span>external</span><span>, Class&lt;</span><span>?</span><span>&gt; </span><span>internal</span><span>) </span><span>throws</span><span> NoSuchMethodException,</span></span>
<span><span>            InvocationTargetException, InstantiationException, IllegalAccessException {</span></span>
<span><span>        Class&lt;</span><span>?</span><span>&gt; c </span><span>=</span><span> </span><span>findClass</span><span>(internal.</span><span>getCanonicalName</span><span>());</span></span>
<span><span>        </span><span>return</span><span> (T) c.</span><span>getConstructor</span><span>().</span><span>newInstance</span><span>();</span></span>
<span><span>    }</span></span>
<span><span>}</span></span></code></pre></div>



<h3>Factorial JMH benchmark</h3>



<p>I implemented two simple recursive method calls. The first one was already presented and it is the factorial. </p>



<div data-code-block-pro-font-family="Code-Pro-JetBrains-Mono"><pre tabindex="0"><code><span><span>public</span><span> </span><span>class</span><span> </span><span>Factorial</span><span> </span><span>implements</span><span> </span><span>FactorialInterface</span><span> {</span></span>
<span><span>    </span><span>public</span><span> </span><span>long</span><span> </span><span>fact</span><span>(</span><span>int</span><span> </span><span>n</span><span>) {</span></span>
<span><span>        </span><span>return</span><span> </span><span>factTailRec</span><span>(n, </span><span>1L</span><span>);</span></span>
<span><span>    }</span></span>
<span><span>    </span><span>private</span><span> </span><span>long</span><span> </span><span>factTailRec</span><span>(</span><span>int</span><span> </span><span>n</span><span>, </span><span>long</span><span> </span><span>ret</span><span>) {</span></span>
<span><span>        </span><span>if</span><span> (n </span><span>&lt;</span><span> </span><span>1</span><span>) {</span></span>
<span><span>            </span><span>return</span><span> ret;</span></span>
<span><span>        }</span></span>
<span><span>        ret </span><span>*=</span><span> n;</span></span>
<span><span>        n </span><span>-=</span><span> </span><span>1</span><span>;</span></span>
<span><span>        </span><span>return</span><span> </span><span>factTailRec</span><span>(n, ret);</span></span>
<span><span>    }</span></span>
<span><span>}</span></span></code></pre></div>



<p>JMH benchmark results are presented below:</p>



<div data-code-block-pro-font-family="Code-Pro-JetBrains-Mono"><pre tabindex="0"><code><span><span>Benchmark</span><span>                     (n)   Mode  Cnt    Score   Error   Units</span></span>
<span><span>TailRec.recursiveFact           </span><span>1</span><span>  thrpt    </span><span>5</span><span>  </span><span>771.714</span><span> ± </span><span>9.722</span><span>  ops</span><span>/</span><span>us</span></span>
<span><span>TailRec.recursiveFact           </span><span>3</span><span>  thrpt    </span><span>5</span><span>  </span><span>242.958</span><span> ± </span><span>1.693</span><span>  ops</span><span>/</span><span>us</span></span>
<span><span>TailRec.recursiveFact           </span><span>5</span><span>  thrpt    </span><span>5</span><span>  </span><span>194.606</span><span> ± </span><span>2.418</span><span>  ops</span><span>/</span><span>us</span></span>
<span><span>TailRec.recursiveFact          </span><span>10</span><span>  thrpt    </span><span>5</span><span>   </span><span>90.850</span><span> ± </span><span>2.345</span><span>  ops</span><span>/</span><span>us</span></span>
<span><span>TailRec.recursiveFact          </span><span>15</span><span>  thrpt    </span><span>5</span><span>   </span><span>66.567</span><span> ± </span><span>0.898</span><span>  ops</span><span>/</span><span>us</span></span>
<span><span>TailRec.recursiveFact          </span><span>20</span><span>  thrpt    </span><span>5</span><span>   </span><span>48.615</span><span> ± </span><span>0.308</span><span>  ops</span><span>/</span><span>us</span></span>
<span><span>TailRec.recursiveFactTailRec    </span><span>1</span><span>  thrpt    </span><span>5</span><span>  </span><span>735.701</span><span> ± </span><span>4.936</span><span>  ops</span><span>/</span><span>us</span></span>
<span><span>TailRec.recursiveFactTailRec    </span><span>3</span><span>  thrpt    </span><span>5</span><span>  </span><span>512.596</span><span> ± </span><span>0.946</span><span>  ops</span><span>/</span><span>us</span></span>
<span><span>TailRec.recursiveFactTailRec    </span><span>5</span><span>  thrpt    </span><span>5</span><span>  </span><span>409.343</span><span> ± </span><span>3.884</span><span>  ops</span><span>/</span><span>us</span></span>
<span><span>TailRec.recursiveFactTailRec   </span><span>10</span><span>  thrpt    </span><span>5</span><span>  </span><span>263.263</span><span> ± </span><span>3.033</span><span>  ops</span><span>/</span><span>us</span></span>
<span><span>TailRec.recursiveFactTailRec   </span><span>15</span><span>  thrpt    </span><span>5</span><span>  </span><span>184.061</span><span> ± </span><span>2.992</span><span>  ops</span><span>/</span><span>us</span></span>
<span><span>TailRec.recursiveFactTailRec   </span><span>20</span><span>  thrpt    </span><span>5</span><span>  </span><span>133.968</span><span> ± </span><span>1.070</span><span>  ops</span><span>/</span><span>us</span></span></code></pre></div>



<p>The difference is pretty clear. The optimized version is faster. The differences are not large, thought. This is simply because of the small number of recursive calls, which has to be small to not produce integer overflow. </p>



<h3>Sum JMH Benchmark</h3>



<p>For illustrative purposes I implemented a sum over the values of an array in tail recursive manner. Of course, this is not the best option, but if the container would be a linked list it would be an appealing implementation in functional style. Below is the implementation of the sum method.</p>



<div data-code-block-pro-font-family="Code-Pro-JetBrains-Mono"><pre tabindex="0"><code><span><span>public</span><span> </span><span>class</span><span> </span><span>Sum</span><span> </span><span>implements</span><span> </span><span>SumInterface</span><span> {</span></span>
<span><span>    </span><span>public</span><span> </span><span>int</span><span> </span><span>sum</span><span>(</span><span>int</span><span>[] </span><span>array</span><span>) {</span></span>
<span><span>        </span><span>return</span><span> </span><span>sumTailRec</span><span>(array, </span><span>0</span><span>, </span><span>0</span><span>);</span></span>
<span><span>    }</span></span>
<span><span>    </span><span>public</span><span> </span><span>int</span><span> </span><span>sumTailRec</span><span>(</span><span>int</span><span>[] </span><span>array</span><span>, </span><span>int</span><span> </span><span>i</span><span>, </span><span>int</span><span> </span><span>sum</span><span>) {</span></span>
<span><span>        </span><span>if</span><span>(i</span><span>&gt;=</span><span>array.length) {</span></span>
<span><span>            </span><span>return</span><span> sum;</span></span>
<span><span>        }</span></span>
<span><span>        </span><span>return</span><span> </span><span>sumTailRec</span><span>(array, i</span><span>+</span><span>1</span><span>, sum</span><span>+</span><span>array[i]);</span></span>
<span><span>    }</span></span>
<span><span>}</span></span></code></pre></div>



<p>And below we have the JMH benchmark results.</p>



<div data-code-block-pro-font-family="Code-Pro-JetBrains-Mono"><pre tabindex="0"><code><span><span>Benchmark</span><span>                      (n)   Mode  Cnt       Score      Error   Units</span></span>
<span><span>TailRec.recursiveSum            </span><span>10</span><span>  thrpt    </span><span>5</span><span>  </span><span>102800.521</span><span> ± </span><span>7870.635</span><span>  ops</span><span>/</span><span>ms</span></span>
<span><span>TailRec.recursiveSum           </span><span>100</span><span>  thrpt    </span><span>5</span><span>    </span><span>8949.731</span><span> ±  </span><span>473.936</span><span>  ops</span><span>/</span><span>ms</span></span>
<span><span>TailRec.recursiveSum          </span><span>1000</span><span>  thrpt    </span><span>5</span><span>     </span><span>846.104</span><span> ±   </span><span>30.766</span><span>  ops</span><span>/</span><span>ms</span></span>
<span><span>TailRec.recursiveSum         </span><span>10000</span><span>  thrpt    </span><span>5</span><span>      </span><span>73.955</span><span> ±   </span><span>17.637</span><span>  ops</span><span>/</span><span>ms</span></span>
<span><span>TailRec.recursiveSumTailRec     </span><span>10</span><span>  thrpt    </span><span>5</span><span>  </span><span>132477.710</span><span> ± </span><span>2955.738</span><span>  ops</span><span>/</span><span>ms</span></span>
<span><span>TailRec.recursiveSumTailRec    </span><span>100</span><span>  thrpt    </span><span>5</span><span>   </span><span>16956.311</span><span> ±  </span><span>541.083</span><span>  ops</span><span>/</span><span>ms</span></span>
<span><span>TailRec.recursiveSumTailRec   </span><span>1000</span><span>  thrpt    </span><span>5</span><span>    </span><span>1915.083</span><span> ±  </span><span>116.170</span><span>  ops</span><span>/</span><span>ms</span></span>
<span><span>TailRec.recursiveSumTailRec  </span><span>10000</span><span>  thrpt    </span><span>5</span><span>     </span><span>187.088</span><span> ±   </span><span>10.059</span><span>  ops</span><span>/</span><span>ms</span></span></code></pre></div>



<p>We also notice improvements produced by tail call elimination.</p>



<h2>Final remarks</h2>



<p>I am not a huge fun of recursion in general, and I tend to prefer tight iterative implementations when is possible. This is by no means an argument against tail call optimization, especially tail call recursion. </p>



<p>Java at this moment does not offer any kind of tail call optimizations. Project Loom seems to take into consideration an even greater class of call optimizations, but those does not look to be a priority now. The tail recursion optimization can be implemented instead into a library, like Lombok, offering the proposed optimization when a given annotation is present.</p>




</div></div>
  </body>
</html>
