<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sdomi.pl/weblog/07-windows-3-flash-edition/">Original</a>
    <h1>Windows 3.1 Flash Edition</h1>
    
    <div id="readability-page-1" class="page"><div><h3>Windows 3.1 Flash Edition</h3>
    <p>Recently, a friend of mine paid me a visit with a few of his ThinkPads. Over a course of a weekend, I&#39;ve prepared a SPI flasher based on flashrom and a Raspberry Pi and flashed a few ThinkPads. Besides my rage that was mostly a result of badly written libreboot and coreboot docs (things are hard to find, a ton of the info is outdated, etc), I came up with an idea for corebooting my own X200.</p>
    <p><img src="https://sdomi.pl/weblog/07-windows-3-flash-edition/img/x200.jpg"/></p><h3>(totally unncessary) SeaBIOS hacking</h3>
    <p>Because the standard coreboot payload with SeaBIOS only occupies only about 1MB out of the full 8 on the ROM, I thought about embedding a full OS on the remaining 7 megs. It turns out that SeaBIOS has partial support for booting from flash - it sets up a virtual floppy drive with your floppy of choice loaded from floppyimg/&lt;name&gt;.lzma, but this gives us at best 2.88MB (standard ED floppy disk size, exactly 2x as large as a popular 1.44M), and I wanted more.</p>
    <p>To use the whole area, I&#39;ve tried modifying a few bits of SeaBIOS source code. I&#39;ve mostly looked at the part used for handling the floppy itself..</p>
        <p><code><a href="https://github.com/coreboot/seabios/blob/master/src/hw/floppy.c">// from src/hw/floppy.c</a>

struct floppyinfo_s FloppyInfo[] VARFSEG = {
    // Unknown
    { {0, 0, 0}, 0x00, 0x00},
    // 1 - 360KB, 5.25&#34; - 2 heads, 40 tracks, 9 sectors
    { {2, 40, 9}, FLOPPY_SIZE_525, FLOPPY_RATE_300K},
    // 2 - 1.2MB, 5.25&#34; - 2 heads, 80 tracks, 15 sectors
    { {2, 80, 15}, FLOPPY_SIZE_525, FLOPPY_RATE_500K},
    // 3 - 720KB, 3.5&#34;  - 2 heads, 80 tracks, 9 sectors
    { {2, 80, 9}, FLOPPY_SIZE_350, FLOPPY_RATE_250K},
    // 4 - 1.44MB, 3.5&#34; - 2 heads, 80 tracks, 18 sectors
    { {2, 80, 18}, FLOPPY_SIZE_350, FLOPPY_RATE_500K},
    // 5 - 2.88MB, 3.5&#34; - 2 heads, 80 tracks, 36 sectors
    { {2, 80, 36}, FLOPPY_SIZE_350, FLOPPY_RATE_1M},
    // 6 - 160k, 5.25&#34;  - 1 heads, 40 tracks, 8 sectors
    { {1, 40, 8}, FLOPPY_SIZE_525, FLOPPY_RATE_250K},
    // 7 - 180k, 5.25&#34;  - 1 heads, 40 tracks, 9 sectors
    { {1, 40, 9}, FLOPPY_SIZE_525, FLOPPY_RATE_300K},
    // 8 - 320k, 5.25&#34;  - 2 heads, 40 tracks, 8 sectors
    { {2, 40, 8}, FLOPPY_SIZE_525, FLOPPY_RATE_250K},
}</code></p><p>As we can see, this struct is used to determine floppy size. By modifying the amount of sectors I should be able to load bigger floppy images. I&#39;ve tried changing the fifth case to 2 heads, 80 tracks and 72 sectors... But it resulted in an I/O Error.</p>
    <p>The logical explanation as to why is that so is rather complicated. It&#39;s either that SeaBIOS can&#39;t allocate a proper amount of memory for the disk and it stops half-way, or it&#39;s about how the floppy controller talks with the hardware. After reading about how floppy systems are complicated on <a href="https://wiki.osdev.org/Floppy_Disk_Controller">oswiki</a> and fiddling with the code a bit more, I gave upon the idea about filling the whole ROM. Now, 2.88MB was the target.</p>
    <h4>Even more problems..?</h4>
    <p>After deciding upon the 2.88MB barrier, I tried booting windows from a flash drive, just as a test to see if everything worked. Well.. It turns out that libgfxinit isn&#39;t 100% VESA compliant and some older operating systems might crap out trying to init the display - all I could get was a black screen after typing `win` at the prompt. The fix was to embed a proprietary VGA Option ROM inside the coreboot image, which was hard only because no one dumped it before.</p>
    <p>Option ROMs should reside inside the original proprietary BIOS images. I&#39;ve had a few dumps of lenovo BIOSes, but couldn&#39;t get anything out of them with tools like <a href="https://github.com/coreboot/bios_extract">bios_extract</a> or <a href="https://github.com/LongSoft/UEFITool">UEFITool</a>. As it turns out, the X200 ROM is the &#34;new&#34; ROM variant (which is kinda weird considering that I&#39;ve unpacked a T420 ROM before without a problem). The fix was to use some phoenix-proprietary tools, which I can&#39;t find now. You can download the VGA Option ROM <a href="https://f.sakamoto.pl/x200_vgabios.bin">here</a>. </p>
    <h3>Choosing the software</h3>
    <p>The whole pack consists of a few of my favourite programs and games, notably..</p>
    <ul>
        <li>Notepad</li>
        <li>Calculator</li>
        <li>Write</li>
        <li>Paintbrush</li>
        <li>Sound Recorder</li>
        <li>Calmira (replaces the default Program Manager)</li>
        <li>Minesweeper</li>
        <li>SkiFree</li>
        <li>Tetris</li>
        <li>LifeGenesis</li>
        <li>JezzBall</li>
        <li>Reversi</li>
        <li>Visual Basic 3.0 (fully functional, because why not!)</li>
    </ul>
    <p>
        <img src="https://sdomi.pl/weblog/07-windows-3-flash-edition/img/life.gif"/><small title="Also it took me like 30 mins to make this GIF, fffffff">Conway&#39;s game of life is coooool</small>
        To achieve the glorious 256 colors and 1024x768 (partially seen in the screenshot above), I&#39;ve had to use a modified SVGA driver. There are two patching programs for the standard SVGA256.DRV - one supposedly for VirtualBox, another one for VMWare. The VMWare one turned out to also work with my X200.
    </p>
    <p>To have an acceptably working system, I also needed audio. Because the Conexant audio device doesn&#39;t have drivers for any system older than XP nor does it have a Sound Blaster compatibility mode, I was forced to use a generic PC Speaker driver. It&#39;s terrible, but it allows me to hear <i>anything</i>. It works on a principle of using very frequent interrupts to create some crude-sounding audio.</p>
    <p>Besides graphics and audio, a fully-working OS should be able to transfer data. This was achieved via a DOS USB driver (if the device got hotplugged, R:\WINDOWS\USB\USB.BAT is your friend), or via SeaBIOS mounting it as the C: drive. Unfortunately, Windows doesn&#39;t properly interface with the drive and all files have to be transferred by saving them into RAMDisk, quitting Windows and copying them in DOS.</p>
    <p><a href="https://sdomi.pl/weblog/07-windows-3-flash-edition/img/haruhi.png"><img src="https://sdomi.pl/weblog/07-windows-3-flash-edition/img/screen.png"/></a><small>Click for a weeb version..</small></p><h3>Compression time!</h3>
    <p>At the beginning, I thought about using PKUNZIP as a decompressor and RAMDRIVE.SYS as a ramdisk driver. When the project was half-way done, my archive got around the 2.6MB level, at which point it no longer fit on the floppy (there was around 150K of files that couldn&#39;t be compressed, like IO.SYS, MSDOS.SYS and COMMAND.COM). My fix was to use ZIP as an archiver (no compression) and XZ as a compressor. This way, I was able to fit around 7MB of data (!) on a 2.88MB floppy. As a fun fact, by compressing the XZ binary (that weighs an enormous 300KB!) with ZIP, I&#39;ve saved another 150KB!</p>
    <p>The testing process looked more or less like this, assuming that the floppy image has already existed..</p>
    <p><code>$ cd win3_build
$ zip -0 -r ../win3_build.zip *
$ cd ..
$ xz -e win3_build.zip # win3_build.zip -&gt; win3_build.xz
$ sudo mount win3.img /mnt/wrk
$ cp win3_build.xz /mnt/wrk/win3.xz
$ sudo umount /mnt/wrk</code></p><p>I didn&#39;t use `xz -9` mostly because it needed a ton of RAM and it just couldn&#39;t be properly unpacked under DOS. The `-e` switch is the &#34;extreme&#34; compression option which only takes a bit longer to compress and leaves no memory impact.</p>

    <h3>Download</h3>
    <ul>
            <li><a href="https://f.sakamoto.pl/Win3Flash.img">Windows 3.1 Flash Edition</a> (2.88M ED floppy disk image)</li>
            <li><a href="https://f.sakamoto.pl/x200_vgabios.bin">VGA Option ROM</a> (because dumping this is a huge waste of time)</li>
        </ul>
    
    <iframe width="640" height="360" src="https://www.youtube-nocookie.com/embed/g6WYm0BsgNA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
    <p>
        As a bonus, here&#39;s my project directory after a week of work :P
        <a href="https://sdomi.pl/weblog/07-windows-3-flash-edition/img/listing.png"><img src="https://sdomi.pl/weblog/07-windows-3-flash-edition/img/listing.png"/></a>
    </p>
<hr/><p><a href="https://ko-fi.com/sdomi/"><img alt="Support me on ko-fi!" src="https://sdomi.pl/img/ko-fi.png"/></a></p><hr/><h3>Comments:</h3></div><p>this is pretty cool, I&#39;m glad that I&#39;m not alone at doing strange things with old hardware, just to see if it can be done.</p><p>Is this Windows 3.1 or Windows 9x? The first screenshot has the Win3x min/max buttons but the second screenshot clearly has a Recycle Bin which was new in Win9x. What is this?</p><p>This is Windows 3.1 with Calmira installed, which is a replacement shell resembling the 95 one.</p><p>The recycle bin is added by Calmira, which also in general makes Win3x look and behave a bit more like Win9x</p><p>Very cool! I did this with TinyCore Linux on my X210. It included drivers for everything including WiFi and a basic GUI - but I first expanded the RAM chip to 16MB.

FWIW I first started with the floppy images and also failed to make it larger. But then, coreboot can directly load a Linux kernel, so that was the easier way in the end...</p><p>Have you tried compressing the executables with UPX? Might help squeezing in some KB more :-)</p><p>looks pretty cool, i&#39;ll show my buddies.</p></div>
  </body>
</html>
