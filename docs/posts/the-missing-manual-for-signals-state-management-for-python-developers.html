<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bui.app/the-missing-manual-for-signals-state-management-for-python-developers/">Original</a>
    <h1>The Missing Manual for Signals: State Management for Python Developers</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p><em>A practical guide to reactive state management in Python</em></p>
<h2 id="introduction">Introduction</h2>
<p>I maintain <a href="https://github.com/buiapp/reaktiv?ref=bui.app">reaktiv</a>. When I demo it to Python teams, I get the same response: &#34;Why do I need this? I can just call functions when things change.&#34;</p>
<p>Fair question. Python has excellent patterns for coordinating state changes. You can trigger updates manually, use the observer pattern, or set up event systems. Most Python applications handle state coordination just fine.</p>
<p>But some don&#39;t.</p>
<p>If you&#39;re building systems where state changes cascade through multiple components, where derived values need to stay synchronized, or where manual coordination is becoming a maintenance burden - signals might solve real problems for you.</p>
<p>Frontend developers recognize the pattern immediately. They&#39;ve dealt with forgetting to trigger updates when state changes, or having component state get out of sync. Signals solve the &#34;forgot to update X when Y changed&#34; class of bugs.</p>
<p>This manual shows you when that coordination problem is worth solving with reactive programming, and when it&#39;s not.</p>
<h3 id="what-youll-learn">What You&#39;ll Learn</h3>
<ul>
<li>When reactive state management solves real problems (and when it doesn&#39;t)</li>
<li>How to adopt signals incrementally in existing systems</li>
<li>Patterns that work in production Python applications</li>
</ul>
<p>Let&#39;s start with what breaks as state coordination scales.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<ol>
<li><a href="#the-problem-with-traditional-state-management">The Problem with Traditional State Management</a></li>
<li><a href="#what-are-signals-really">What Are Signals, Really?</a></li>
<li><a href="#the-mental-model-shift">The Mental Model Shift</a></li>
<li><a href="#when-signals-matter-and-when-they-dont">When Signals Matter (And When They Don&#39;t)</a></li>
<li><a href="#common-patterns-and-anti-patterns">Common Patterns and Anti-Patterns</a></li>
<li><a href="#real-world-scenarios">Real-World Scenarios</a></li>
<li><a href="#performance-considerations">Performance Considerations</a></li>
<li><a href="#integration-strategies">Integration Strategies</a></li>
<li><a href="#testing-reactive-code">Testing Reactive Code</a></li>
<li><a href="#migration-guide">Migration Guide</a></li>
</ol>
<hr/>
<h2 id="the-problem-with-traditional-state-management">The Problem with Traditional State Management</h2>
<p>As developers, we&#39;ve all written variations of this code:</p>
<pre><code>class OrderService:
    def __init__(self):
        self.orders = []
        self.total_revenue = 0.0
        self.daily_stats = {}
        self.notification_service = NotificationService()
        self.analytics_service = AnalyticsService()
    
    def add_order(self, order):
        self.orders.append(order)
        self.total_revenue += order.amount
        self._update_daily_stats(order)
        self._send_notifications(order)
        self._track_analytics(order)
        
    def _update_daily_stats(self, order):
        date = order.created_at.date()
        if date not in self.daily_stats:
            self.daily_stats[date] = {&#34;count&#34;: 0, &#34;revenue&#34;: 0.0}
        self.daily_stats[date][&#34;count&#34;] += 1
        self.daily_stats[date][&#34;revenue&#34;] += order.amount
    
    def _send_notifications(self, order):
        if order.amount &gt; 1000:
            self.notification_service.send_high_value_alert(order)
        if len(self.orders) % 100 == 0:
            self.notification_service.send_milestone_alert(len(self.orders))
    
    def _track_analytics(self, order):
        self.analytics_service.track_order(order)
        if self.total_revenue &gt; 50000:
            self.analytics_service.track_milestone(&#34;revenue_50k&#34;)
</code></pre>
<p>This looks reasonable at first glance. But let&#39;s visualize the hidden complexity:</p>

<!--kg-card-begin: html-->
<p>
  graph TD
    A[add_order called] --&gt; B[Update orders list]
    B --&gt; C[Update total_revenue]
    C --&gt; D[Update daily_stats]
    D --&gt; E[Send notifications]
    E --&gt; F[Track analytics]
    
    G[‚ùå Miss one step?] --&gt; H[Silent bugs]
    I[‚ùå Add new derived state?] --&gt; J[Update every entry point]
    K[‚ùå Race condition?] --&gt; L[Inconsistent state]
    
    style G fill:#F44336,color:#fff
    style I fill:#F44336,color:#fff
    style K fill:#F44336,color:#fff
    style H fill:#D32F2F,color:#fff
    style J fill:#D32F2F,color:#fff
    style L fill:#D32F2F,color:#fff
</p>
<!--kg-card-end: html-->
<h3 id="the-hidden-dependencies">The Hidden Dependencies</h3>
<p>The real problem isn&#39;t visible in the code - it&#39;s the implicit dependency graph:</p>

<!--kg-card-begin: html-->
<p>
graph LR
    Orders[orders] --&gt; Revenue[total_revenue]
    Orders --&gt; Stats[daily_stats]
    Orders --&gt; Notifications[notifications]
    Orders --&gt; Analytics[analytics]
    
    Revenue --&gt; Analytics
    Stats --&gt; Notifications
    
    classDef implicit stroke-dasharray: 5 5
    class Revenue,Stats,Notifications,Analytics implicit
  </p>
<!--kg-card-end: html-->
<p>These dependencies are <strong>implicit</strong> and <strong>manually maintained</strong>. Every time <code>orders</code> changes, you must remember to update all dependent values in the correct order.</p>
<h3 id="1-tight-coupling-through-side-effects">1. <strong>Tight Coupling Through Side Effects</strong></h3>
<p>Every time we add an order, we must remember to update:</p>
<ul>
<li>Total revenue</li>
<li>Daily statistics</li>
<li>Notifications</li>
<li>Analytics</li>
<li>Any future derived state</li>
</ul>
<p>Miss one update? Silent bugs. Add a new derived value? Modify every entry point.</p>
<h3 id="2-implicit-dependencies">2. <strong>Implicit Dependencies</strong></h3>
<p>The relationship between orders and derived state is buried in imperative code. New developers (or future you) must trace through method calls to understand what depends on what.</p>
<h3 id="3-inconsistent-state-windows">3. <strong>Inconsistent State Windows</strong></h3>
<p>Between the moment <code>orders.append(order)</code> executes and <code>total_revenue += order.amount</code> completes, your system is in an inconsistent state. In concurrent environments, this creates race conditions.</p>
<h3 id="4-testing-complexity">4. <strong>Testing Complexity</strong></h3>
<p>Testing requires mocking all the side effects, or carefully orchestrating partial updates. Want to test just the revenue calculation? Good luck isolating it.</p>
<h3 id="5-performance-blind-spots">5. <strong>Performance Blind Spots</strong></h3>
<p>Every order addition triggers every derived calculation, even if only some values are actually needed. No easy way to optimize without restructuring.</p>
<hr/>
<h2 id="what-are-signals-really">What Are Signals, Really?</h2>
<p>Signals aren&#39;t just &#34;reactive variables.&#34; They&#39;re a <strong>dependency graph abstraction</strong> that inverts the control flow of state management.</p>
<p><strong>Important</strong>: Signals are <strong>value containers</strong>, not event streams. If you&#39;re thinking &#34;this sounds like event listeners,&#34; there&#39;s a key difference. Signals hold current state and create a snapshot of your application at any point in time. When you call <code>signal()</code>, you get the current value - not a subscription to future events.</p>
<pre><code># Signal: value container (current state)
user_count = Signal(42)
print(user_count())  # 42 - current value, right now

# Event listener: reacts to future events
button.addEventListener(&#39;click&#39;, handler)  # waits for future clicks
</code></pre>
<p>This distinction matters. Signals create a <strong>state graph</strong>-a snapshot of how values relate to each other at any moment. Event listeners create <strong>reaction patterns</strong>-responses to things happening over time.</p>
<h3 id="the-dependency-graph-model">The Dependency Graph Model</h3>

<!--kg-card-begin: html-->
<p>
graph LR
    subgraph &#34;Traditional Approach (Push-based)&#34;
        A1[X changes] --&gt; B1[Manually update Y]
        B1 --&gt; C1[Manually update Z]
        C1 --&gt; D1[Manually notify observers]
    end
    
    subgraph &#34;Signals Approach (Pull-based)&#34;
        A2[X = Signal] --&gt; B2[Y = Computed from X]
        A2 --&gt; C2[Z = Computed from X, Y]
        B2 --&gt; C2
        C2 --&gt; D2[Effect observes X, Y, Z]
        
        E2[&#34;X.set(new_value)&#34;] --&gt; F2[Y and Z update automatically]
    end
    
    style A1 fill:#F44336,color:#fff
    style A2 fill:#4CAF50,color:#fff
</p>
<!--kg-card-end: html-->
<p>Instead of <strong>push-based updates</strong> (imperative):</p>
<pre><code># When X changes, manually update Y and Z
x = new_value
y = calculate_y(x)
z = calculate_z(x, y)
notify_observers(x, y, z)
</code></pre>
<p>Signals provide <strong>pull-based derivation</strong> (declarative):</p>
<pre><code># Define relationships once
x = Signal(initial_value)
y = Computed(lambda: calculate_y(x()))
z = Computed(lambda: calculate_z(x(), y()))
notify_effect = Effect(lambda: notify_observers(x(), y(), z()))

# Updates happen automatically
x.set(new_value)  # y, z, and notifications update automatically
</code></pre>
<h3 id="the-three-primitives">The Three Primitives</h3>

<!--kg-card-begin: html-->
<div><p>
graph LR
    subgraph &#34;Signal Primitives&#34;
        A[Signal</p></div>
<!--kg-card-end: html-->
<p>Think of them as:</p>
<ul>
<li><strong>Signal</strong>: A cell in a spreadsheet that holds a value</li>
<li><strong>Computed</strong>: A formula cell that derives from other cells (e.g., <code>=A1+B1</code>)</li>
<li><strong>Effect</strong>: A macro that runs when referenced cells change</li>
</ul>
<p><strong>The key insight:</strong> your entire application state becomes a live spreadsheet where changing one cell automatically updates all dependent cells.</p>
<h3 id="state-snapshots-vs-event-reactions">State Snapshots vs Event Reactions</h3>

<!--kg-card-begin: html-->
<p>
graph LR
    subgraph &#34;Signals: State Snapshot&#34;
        S1[user: Signal] --&gt; S2[&#34;name: &#39;John&#39;&#34;]
        S1 --&gt; S3[&#34;age: 30&#34;]
        SC1[user_display: Computed] --&gt; S4[&#34;&#39;John (30)&#39;&#34;]
        S1 --&gt; SC1
        
        Note1[&#34;üì∏ Current state, right now&#34;]
    end
    
    subgraph &#34;Event Listeners: Future Reactions&#34;
        E1[button.addEventListener] --&gt; E2[&#34;click handler&#34;]
        E3[window.addEventListener] --&gt; E4[&#34;resize handler&#34;] 
        E5[socket.on] --&gt; E6[&#34;message handler&#34;]
        E7[&#34;...waiting for events&#34;]
        
        Note2[&#34;üéØ Waiting for future events&#34;]
    end
    
    style S1 fill:#2196F3,color:#fff
    style SC1 fill:#9C27B0,color:#fff
    style E1 fill:#FF9800,color:#fff
</p>
<!--kg-card-end: html-->
<p>When you access a signal, you&#39;re asking: &#34;What&#39;s the current state?&#34; When you set up an event listener, you&#39;re saying: &#34;Do this when something happens later.&#34;</p>
<h3 id="example-order-processing-with-signals">Example: Order Processing with Signals</h3>

<!--kg-card-begin: html-->
<p>
graph TD
    Orders[orders: Signal] --&gt; Revenue[total_revenue: Computed]
    Orders --&gt; Stats[daily_stats: Computed]
    Orders --&gt; Count[order_count: Computed]
    
    Revenue --&gt; NotifEffect[notification_effect: Effect]
    Stats --&gt; NotifEffect
    Count --&gt; NotifEffect
    
    Orders --&gt; AnalyticsEffect[analytics_effect: Effect]
    Revenue --&gt; AnalyticsEffect
    
    style Orders fill:#2196F3,color:#fff
    style Revenue fill:#9C27B0,color:#fff
    style Stats fill:#9C27B0,color:#fff
    style Count fill:#9C27B0,color:#fff
    style NotifEffect fill:#FF9800,color:#fff
    style AnalyticsEffect fill:#FF9800,color:#fff
</p>
<!--kg-card-end: html-->
<hr/>
<h2 id="the-mental-model-shift">The Mental Model Shift</h2>
<p>The hardest part about adopting Signals isn&#39;t the API - it&#39;s the mental model shift from imperative to declarative state management.</p>
<h3 id="before-vs-after-visualization">Before vs After: Visualization</h3>

<!--kg-card-begin: html-->
<p>
flowchart LR
    subgraph &#34;Imperative Thinking (Before)&#34;
        A1[User Action] --&gt; B1[Step 1: Update user]
        B1 --&gt; C1[Step 2: Update stats]
        C1 --&gt; D1[Step 3: Check achievements]
        D1 --&gt; E1[Step 4: Update leaderboard]
        E1 --&gt; F1[Step 5: Send notification]
        F1 --&gt; G1[Step 6: Log activity]
        
        H1[‚ùå Easy to miss steps] 
        I1[‚ùå Order matters]
        J1[‚ùå Hard to test parts]
    end
    
    subgraph &#34;Declarative Thinking (After)&#34;
        A2[user_action: Signal]
        A2 --&gt; B2[user_stats: Computed]
        A2 --&gt; C2[achievements: Computed]
        B2 --&gt; C2
        B2 --&gt; D2[leaderboard: Computed]
        
        C2 --&gt; E2[notification_effect: Effect]
        A2 --&gt; F2[logging_effect: Effect]
        
        G2[‚úÖ Relationships declared once]
        H2[‚úÖ Order handled automatically]
        I2[‚úÖ Easy to test individually]
    end
    
    style A1 fill:#F44336,color:#fff
    style A2 fill:#4CAF50,color:#fff
</p>
<!--kg-card-end: html-->
<h3 id="before-imperative-thinking">Before: Imperative Thinking</h3>
<p>&#34;When this happens, do these things in this order.&#34;</p>
<pre><code>def process_user_action(user_id, action):
    user = get_user(user_id)
    user.last_action = action
    user.last_active = datetime.now()
    
    update_user_stats(user)
    check_achievement_progress(user)
    update_leaderboard(user)
    send_activity_notification(user)
    log_user_activity(user, action)
</code></pre>
<h3 id="after-declarative-thinking">After: Declarative Thinking</h3>
<p>&#34;These relationships always hold true.&#34;</p>
<pre><code># Define relationships once
user_action = Signal(None)
user_last_active = Computed(lambda: datetime.now() if user_action() else None)
user_stats = Computed(lambda: calculate_stats(user_action()))
achievements = Computed(lambda: check_achievements(user_stats()))
leaderboard_position = Computed(lambda: calculate_position(user_stats()))

# Effects for side effects
notify_effect = Effect(lambda: send_notification(user_stats()) if user_action() else None)
log_effect = Effect(lambda: log_activity(user_action()) if user_action() else None)

# Usage becomes simple
def process_user_action(user_id, action):
    user_action.set(action)  # Everything else happens automatically
</code></pre>
<h3 id="dependency-flow-visualization">Dependency Flow Visualization</h3>

<!--kg-card-begin: html-->
<p>
graph LR
    subgraph &#34;Signal Dependency Flow&#34;
        UA[user_action] --&gt; ULA[user_last_active]
        UA --&gt; US[user_stats]
        US --&gt; ACH[achievements]
        US --&gt; LB[leaderboard_position]
        
        US --&gt; NE[notification_effect]
        UA --&gt; LE[logging_effect]
    end
    
    subgraph &#34;Change Propagation&#34;
        Change[&#34;user_action.set()&#34;] --&gt; Trigger[Triggers computation chain]
        Trigger --&gt; Auto[All dependent values update automatically]
    end
    
    style UA fill:#2196F3,color:#fff
    style US fill:#9C27B0,color:#fff
    style ACH fill:#9C27B0,color:#fff
    style LB fill:#9C27B0,color:#fff
    style ULA fill:#9C27B0,color:#fff
    style NE fill:#FF9800,color:#fff
    style LE fill:#FF9800,color:#fff
</p>
<!--kg-card-end: html-->
<hr/>
<h2 id="when-signals-matter-and-when-they-dont">When Signals Matter (And When They Don&#39;t)</h2>
<h3 id="signals-shine-when-visual-patterns">Signals Shine When: Visual Patterns</h3>

<!--kg-card-begin: html-->
<p>
graph LR
    subgraph &#34;Complex Derived State&#34;
        UP[user_profile] --&gt; UPerm[user_permissions]
        UP --&gt; UTheme[ui_theme]
        UPerm --&gt; Dashboard[dashboard_config]
        UTheme --&gt; Dashboard
    end
    
    subgraph &#34;Cross-Cutting Concerns&#34;
        Config[app_config] --&gt; DB[database_pool]
        Config --&gt; Cache[cache_client]
        Config --&gt; Logger[logger_config]
        Config --&gt; Monitor[monitoring]
    end
    
    subgraph &#34;Real-Time Data Flows&#34;
        Raw[raw_market_data] --&gt; Norm[normalized_data]
        Norm --&gt; Risk[risk_metrics]
        Risk --&gt; Alerts[alerts]
        Alerts --&gt; Broadcast[broadcast_effect]
    end
    
    subgraph &#34;State Synchronization&#34;
        Model[model_data] --&gt; JSON[json_representation]
        Model --&gt; XML[xml_representation]
        Model --&gt; DB2[database_record]
        JSON --&gt; CacheEffect[cache_effect]
    end
    
    style UP fill:#2196F3,color:#fff
    style Config fill:#2196F3,color:#fff
    style Raw fill:#2196F3,color:#fff
    style Model fill:#2196F3,color:#fff
</p>
<!--kg-card-end: html-->
<h3 id="signals-are-overkill-when">Signals Are Overkill When:</h3>

<!--kg-card-begin: html-->
<div><p>
graph LR
    subgraph &#34;‚ùå Avoid Signals For&#34;
        A[Simple Linear</p></div>
<!--kg-card-end: html-->
<hr/>
<h2 id="common-patterns-and-anti-patterns">Common Patterns and Anti-Patterns</h2>
<h3 id="pattern-configuration-cascades">Pattern: Configuration Cascades</h3>

<!--kg-card-begin: html-->
<p>
graph LR
    Config[config: Signal] --&gt; DBConfig[db_config: Computed]
    Config --&gt; RedisConfig[redis_config: Computed]
    
    DBConfig --&gt; DBPool[db_pool: Computed]
    RedisConfig --&gt; CacheClient[cache_client: Computed]
    
    Config --&gt; MonitorEffect[monitoring_effect: Effect]
    
    subgraph &#34;‚úÖ Good: Grouped Configuration&#34;
        GoodConfig[&#34;{host, port, user, password}&#34;]
    end
    
    subgraph &#34;‚ùå Bad: Over-granular Signals&#34;
        BadHost[db_host: Signal]
        BadPort[db_port: Signal] 
        BadUser[db_user: Signal]
        BadPass[db_password: Signal]
    end
    
    style Config fill:#2196F3,color:#fff
    style GoodConfig fill:#4CAF50,color:#fff
    style BadHost fill:#F44336,color:#fff
    style BadPort fill:#F44336,color:#fff
    style BadUser fill:#F44336,color:#fff
    style BadPass fill:#F44336,color:#fff
</p>
<!--kg-card-end: html-->
<pre><code># Good: Grouped configuration
from reaktiv import Signal, Computed

# Good: Single grouped signal
app_config = Signal({
    &#34;database&#34;: {&#34;host&#34;: &#34;localhost&#34;, &#34;port&#34;: 5432, &#34;user&#34;: &#34;app&#34;, &#34;password&#34;: &#34;secret&#34;},
    &#34;redis&#34;: {&#34;host&#34;: &#34;localhost&#34;, &#34;port&#34;: 6379},
    &#34;api&#34;: {&#34;timeout&#34;: 30, &#34;retries&#34;: 3}
})

# Derived configs
db_config = Computed(lambda: app_config().get(&#34;database&#34;, {}))
redis_config = Computed(lambda: app_config().get(&#34;redis&#34;, {}))

# Connection pools derived from configs
db_pool = Computed(lambda: create_db_pool(**db_config()))
redis_client = Computed(lambda: create_redis_client(**redis_config()))

# Bad: Overly granular signals
db_host = Signal(&#34;localhost&#34;)
db_port = Signal(5432)
db_user = Signal(&#34;app&#34;)
db_password = Signal(&#34;secret&#34;)
# This approach makes it harder to update related settings together
</code></pre>
<h3 id="pattern-data-processing-pipelines">Pattern: Data Processing Pipelines</h3>

<!--kg-card-begin: html-->
<p>
graph LR
    Raw[raw_data: Signal] --&gt; Clean[cleaned_data: Computed]
    Clean --&gt; Agg[aggregated_data: Computed]
    Agg --&gt; Format[formatted_output: Computed]
    
    Format --&gt; CacheEffect[cache_effect: Effect]
    
    subgraph &#34;‚ùå Anti-Pattern: Side Effects in Computed&#34;
        BadComputed[computed_with_api_call] 
        BadComputed -.-&gt; API[expensive_api_call]
    end
    
    subgraph &#34;‚úÖ Better: Effects for Side Effects&#34;  
        GoodTrigger[api_trigger: Signal]
        GoodTrigger --&gt; GoodEffect[api_effect: Effect]
    end
    
    style Raw fill:#2196F3,color:#fff
    style Clean fill:#9C27B0,color:#fff
    style Agg fill:#9C27B0,color:#fff
    style Format fill:#9C27B0,color:#fff
    style CacheEffect fill:#FF9800,color:#fff
    style BadComputed fill:#F44336,color:#fff
    style GoodTrigger fill:#4CAF50,color:#fff
    style GoodEffect fill:#4CAF50,color:#fff
</p>
<!--kg-card-end: html-->
<pre><code># Good: Clean separation of computation and effects
from reaktiv import Signal, Computed, Effect

# Data pipeline
raw_data = Signal([])
cleaned_data = Computed(lambda: [clean_item(item) for item in raw_data()])
aggregated_data = Computed(lambda: aggregate_by_category(cleaned_data()))
formatted_output = Computed(lambda: format_for_display(aggregated_data()))

# Good: Side effects in Effects only
cache_effect = Effect(lambda: cache_service.store(&#34;agg_data&#34;, formatted_output()))

# Bad: Side effects in Computed
def bad_computed_with_api_call():
    data = expensive_api_call()  # Side effect!
    return process_data(data)

# Better: Use separate Signal and Effect
api_trigger = Signal(False)

def api_effect():
    if api_trigger():
        data = expensive_api_call()
        processed = process_data(data)
        store_result(processed)

api_effect_instance = Effect(api_effect)
</code></pre>
<h3 id="pattern-event-sourcing-integration">Pattern: Event Sourcing Integration</h3>
<p><strong>Good</strong>: Signals as event processors</p>
<pre><code>event_stream = Signal([])
current_state = Computed(lambda: reduce_events(event_stream()))
projections = {
    &#34;user_stats&#34;: Computed(lambda: project_user_stats(event_stream())),
    &#34;daily_summary&#34;: Computed(lambda: project_daily_summary(event_stream()))
}

# Append events, projections update automatically
def add_event(event):
    event_stream.update(lambda events: events + [event])
</code></pre>

<!--kg-card-begin: html-->
<p>
graph TD
    EventStream[event_stream: Signal] --&gt; CurrentState[current_state: Computed]
    EventStream --&gt; UserStats[user_stats: Computed]
    EventStream --&gt; DailySummary[daily_summary: Computed]
    
    AddEvent[add_event] --&gt; EventStream
    
    style EventStream fill:#2196F3,color:#fff
    style CurrentState fill:#9C27B0,color:#fff
    style UserStats fill:#9C27B0,color:#fff
    style DailySummary fill:#9C27B0,color:#fff
    style AddEvent fill:#4CAF50,color:#fff
</p>
<!--kg-card-end: html-->
<hr/>
<h2 id="real-world-scenarios">Real-World Scenarios</h2>
<h3 id="scenario-1-microservice-configuration-management">Scenario 1: Microservice Configuration Management</h3>

<!--kg-card-begin: html-->
<p>
graph TB
    subgraph &#34;Configuration Sources&#34;
        ENV[env_config: Signal]
        FILE[file_config: Signal]
        REMOTE[remote_config: Signal]
    end
    
    subgraph &#34;Merged Configuration&#34;
        ENV --&gt; EFFECTIVE[effective_config: Computed]
        FILE --&gt; EFFECTIVE
        REMOTE --&gt; EFFECTIVE
    end
    
    subgraph &#34;Service Configs&#34;
        EFFECTIVE --&gt; DBCONFIG[database_config: Computed]
        EFFECTIVE --&gt; REDISCONFIG[redis_config: Computed]
        EFFECTIVE --&gt; FEATURES[feature_flags: Computed]
    end
    
    subgraph &#34;Service Instances&#34;
        DBCONFIG --&gt; DBPOOL[db_pool: Computed]
        REDISCONFIG --&gt; CACHECLIENT[cache_client: Computed]
    end
    
    subgraph &#34;Effects&#34;
        EFFECTIVE --&gt; LOGGER[config_logger: Effect]
        EFFECTIVE --&gt; METRICS[metrics_updater: Effect]
    end
    
    style ENV fill:#4CAF50,color:#fff
    style FILE fill:#4CAF50,color:#fff
    style REMOTE fill:#4CAF50,color:#fff
    style EFFECTIVE fill:#9C27B0,color:#fff
</p>
<!--kg-card-end: html-->
<pre><code>class ServiceConfig:
    def __init__(self):
        # Base configuration sources
        self.env_config = Signal(os.environ.copy())
        self.file_config = Signal(load_config_file())
        self.remote_config = Signal({})  # Updated via API calls
        
        # Merged configuration with precedence
        self.effective_config = Computed(lambda: {
            **self.file_config(),
            **self.remote_config(),
            **self.env_config()
        })
        
        # Service-specific configurations
        self.database_config = Computed(
            lambda: DatabaseConfig.from_dict(self.effective_config().get(&#34;database&#34;, {}))
        )
        self.redis_config = Computed(
            lambda: RedisConfig.from_dict(self.effective_config().get(&#34;redis&#34;, {}))
        )
        self.feature_flags = Computed(
            lambda: self.effective_config().get(&#34;features&#34;, {})
        )
        
        # Derived services
        self.db_pool = Computed(lambda: create_database_pool(self.database_config()))
        self.cache_client = Computed(lambda: create_redis_client(self.redis_config()))
        
        # Effects for configuration changes
        self._config_logger = Effect(
            lambda: logger.info(f&#34;Config updated: {list(self.effective_config().keys())}&#34;)
        )
        self._metrics_updater = Effect(
            lambda: update_config_metrics(self.effective_config())
        )
    
    def update_remote_config(self, new_config):
        &#34;&#34;&#34;Called by configuration service webhook&#34;&#34;&#34;
        self.remote_config.set(new_config)
        # Database pool, cache client, etc. automatically recreated
</code></pre>
<h3 id="scenario-2-real-time-analytics-dashboard">Scenario 2: Real-Time Analytics Dashboard</h3>

<!--kg-card-begin: html-->
<p>
graph TB
    subgraph &#34;Data Sources&#34;
        EVENTS[raw_events: Signal]
        SESSIONS[user_sessions: Signal]
        METRICS[system_metrics: Signal]
        TIMEWINDOW[time_window: Signal]
    end
    
    subgraph &#34;Time Filtering&#34;
        TIMEWINDOW --&gt; CUTOFF[cutoff_time: Computed]
        EVENTS --&gt; RECENT[recent_events: Computed]
        SESSIONS --&gt; ACTIVE[active_sessions: Computed]
        CUTOFF --&gt; RECENT
        CUTOFF --&gt; ACTIVE
    end
    
    subgraph &#34;Analytics&#34;
        RECENT --&gt; COUNTS[event_counts: Computed]
        COUNTS --&gt; CONVERSION[conversion_rate: Computed]
        ACTIVE --&gt; USERCOUNT[active_user_count: Computed]
        
        COUNTS --&gt; DASHBOARD[dashboard_data: Computed]
        CONVERSION --&gt; DASHBOARD
        USERCOUNT --&gt; DASHBOARD
        METRICS --&gt; DASHBOARD
        TIMEWINDOW --&gt; DASHBOARD
    end
    
    subgraph &#34;Effects&#34;
        DASHBOARD --&gt; WEBSOCKET[websocket_broadcaster: Effect]
        CONVERSION --&gt; ALERTS[alert_monitor: Effect]
    end
    
    style EVENTS fill:#2196F3,color:#fff
    style SESSIONS fill:#2196F3,color:#fff
    style METRICS fill:#2196F3,color:#fff
    style TIMEWINDOW fill:#2196F3,color:#fff
</p>
<!--kg-card-end: html-->
<pre><code># Real-Time Analytics Implementation
from reaktiv import Signal, Computed, Effect
import asyncio

class AnalyticsDashboard:
    def __init__(self, websocket):
        # Data sources
        self.raw_events = Signal([])
        self.time_window = Signal(60)  # Last 60 seconds
        
        # Computed metrics
        self.cutoff_time = Computed(
            lambda: time.time() - self.time_window()
        )
        
        self.recent_events = Computed(
            lambda: [e for e in self.raw_events() 
                    if e[&#34;timestamp&#34;] &gt;= self.cutoff_time()]
        )
        
        self.event_counts = Computed(
            lambda: {
                &#34;total&#34;: len(self.recent_events()),
                &#34;by_type&#34;: self._count_by_type(self.recent_events())
            }
        )
        
        # Dashboard data
        self.dashboard_data = Computed(
            lambda: {
                &#34;counts&#34;: self.event_counts(),
                &#34;window&#34;: self.time_window(),
                &#34;updated_at&#34;: time.time()
            }
        )

        async def dashboard_update():
            await self._send_dashboard_update(websocket, self.dashboard_data())
        
        # Effect to broadcast updates
        self._broadcaster = Effect(dashboard_update)
    
    def _count_by_type(self, events):
        result = {}
        for event in events:
            event_type = event.get(&#34;type&#34;, &#34;unknown&#34;)
            result[event_type] = result.get(event_type, 0) + 1
        return result
    
    async def _send_dashboard_update(self, websocket, data):
        if websocket.open:
            await websocket.send_json(data)
    
    def add_event(self, event):
        self.raw_events.update(lambda events: events + [event])
    
    def change_time_window(self, seconds):
        self.time_window.set(seconds)
</code></pre>
<h3 id="scenario-3-distributed-system-health-monitoring">Scenario 3: Distributed System Health Monitoring</h3>

<!--kg-card-begin: html-->
<p>
graph TB
    subgraph &#34;Raw Status Data&#34;
        NODES[node_statuses: Signal]
        SERVICES[service_statuses: Signal]
    end
    
    subgraph &#34;Cluster Health Metrics&#34;
        NODES --&gt; HEALTHY[healthy_nodes: Computed]
        HEALTHY --&gt; CAPACITY[cluster_capacity: Computed]
        NODES --&gt; LOAD[cluster_load: Computed]
        CAPACITY --&gt; LOADPCT[load_percentage: Computed]
        LOAD --&gt; LOADPCT
    end
    
    subgraph &#34;Service Availability&#34;
        SERVICES --&gt; AVAILABILITY[service_availability: Computed]
        AVAILABILITY --&gt; CRITICAL[critical_services: Computed]
    end
    
    subgraph &#34;Automated Actions&#34;
        HEALTHY --&gt; LBUPDATE[load_balancer_updater: Effect]
        CRITICAL --&gt; INCIDENT[alert_manager: Effect]
        LOADPCT --&gt; SCALER[capacity_scaler: Effect]
    end
    
    style NODES fill:#2196F3,color:#fff
    style SERVICES fill:#2196F3,color:#fff
    style LBUPDATE fill:#FF9800,color:#fff
    style INCIDENT fill:#E91E63,color:#fff
    style SCALER fill:#9C27B0,color:#fff
</p>
<!--kg-card-end: html-->
<pre><code># Health Monitoring Implementation
from reaktiv import Signal, Computed, Effect

class ClusterMonitor:
    def __init__(self, alert_service, load_balancer):
        # Raw status data
        self.node_statuses = Signal({})  # node_id -&gt; status
        
        # Derived metrics
        self.healthy_nodes = Computed(
            lambda: [node_id for node_id, status in self.node_statuses().items() 
                    if status[&#34;healthy&#34;]]
        )
        
        self.cluster_capacity = Computed(
            lambda: sum(status[&#34;capacity&#34;] for status in self.node_statuses().values()
                        if status[&#34;healthy&#34;])
        )
        
        self.cluster_load = Computed(
            lambda: sum(status[&#34;current_load&#34;] for status in self.node_statuses().values())
        )
        
        self.load_percentage = Computed(
            lambda: (self.cluster_load() / self.cluster_capacity() * 100) 
                    if self.cluster_capacity() &gt; 0 else 100
        )
        
        # Effects for automated actions
        self._lb_updater = Effect(
            lambda: load_balancer.update_backends(self.healthy_nodes())
        )
        
        self._scaler = Effect(lambda: self._check_scaling_needs())
    
    def _check_scaling_needs(self):
        load_pct = self.load_percentage()
        if load_pct &gt; 80:
            # Trigger scaling
            print(f&#34;High load detected ({load_pct:.1f}%), initiating scale out&#34;)
        elif load_pct &lt; 20:
            # Scale in
            print(f&#34;Low load detected ({load_pct:.1f}%), initiating scale in&#34;)
    
    def update_node_status(self, node_id, status):
        self.node_statuses.update(lambda statuses: {
            **statuses,
            node_id: status
        })
</code></pre>
<hr/>
<h2 id="performance-considerations">Performance Considerations</h2>
<h3 id="fine-grained-reactivity-visualization">Fine-Grained Reactivity Visualization</h3>

<!--kg-card-begin: html-->
<p>
graph LR
    subgraph &#34;Traditional: Everything Recalculates&#34;
        T1[Update Data] --&gt; T2[Calculate Mean]
        T1 --&gt; T3[Calculate Std Dev]
        T1 --&gt; T4[Calculate Percentiles]
        
        T5[‚ùå All run every time]
    end
    
    subgraph &#34;Signals: Only Affected Parts Run&#34;
        S1[&#34;data.set()&#34;] --&gt; S2[Check: mean accessed?]
        S2 --&gt; S3[‚úÖ Calculate mean only]
        S4[std_dev not accessed] 
        S5[percentiles not accessed]
        
        S6[‚úÖ Lazy evaluation]
    end
    
    style T1 fill:#F44336,color:#fff
    style S1 fill:#4CAF50,color:#fff
    style T5 fill:#D32F2F,color:#fff
    style S6 fill:#388E3C,color:#fff
</p>
<!--kg-card-end: html-->
<pre><code># Optimizing computation with fine-grained signals
from reaktiv import Signal, Computed, Effect

# Dataset
data = Signal([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

# Expensive computations
mean = Computed(lambda: sum(data()) / len(data()) if data() else 0)

def calculate_std_dev(values, mean_value):
    if not values:
        return 0
    return (sum((x - mean_value) ** 2 for x in values) / len(values)) ** 0.5

std_dev = Computed(lambda: calculate_std_dev(data(), mean()))

# Efficient: Only accessed values are computed
def display_stats():
    # If we only access mean, std_dev won&#39;t be calculated
    print(f&#34;Mean: {mean()}&#34;)
    
    # Conditional computation: Only calculate std_dev when needed
    if user_wants_detailed_stats():
        print(f&#34;Standard Deviation: {std_dev()}&#34;)

stats_effect = Effect(display_stats)

# Adding data only triggers what&#39;s needed
data.update(lambda d: d + [11])
</code></pre>
<h3 id="memory-management-pattern">Memory Management Pattern</h3>

<!--kg-card-begin: html-->
<div><p>
graph TB
    Signal --&gt; WeakRef[Weak References</p></div>
<!--kg-card-end: html-->
<pre><code># Proper effect management in components
from reaktiv import Signal, Computed, Effect

class Component:
    def __init__(self):
        self.counter = Signal(0)
        
        # BAD: Effect not retained, will be garbage collected
        Effect(lambda: print(f&#34;Counter: {self.counter()}&#34;))
        
        # GOOD: Store reference to effect
        self._effect = Effect(lambda: print(f&#34;Counter: {self.counter()}&#34;))
    
    def increment(self):
        self.counter.update(lambda c: c + 1)
        
    def cleanup(self):
        # Optional: Explicitly dispose the effect when done
        self._effect.dispose()
</code></pre>
<hr/>
<h2 id="migration-guide">Migration Guide</h2>
<h3 id="migration-phases-visualization">Migration Phases Visualization</h3>

<!--kg-card-begin: html-->
<div><p>
graph TB
    subgraph &#34;Phase 1: Identify Candidates&#34;
        P1A[Manual State Sync]
        P1B[Observer Patterns]
        P1C[Cache Invalidation]
    end
    
    subgraph &#34;Phase 2: Gradual Replacement&#34;
        P2A[Replace Leaf Nodes</p></div>
<!--kg-card-end: html-->
<h3 id="before-and-after-architecture">Before and After Architecture</h3>

<!--kg-card-begin: html-->
<p>
graph LR
    subgraph &#34;Before: Manual Coordination&#34;
        OrderAdd[&#34;add_order()&#34;] --&gt; OrderList[&#34;orders.append()&#34;]
        OrderList --&gt; Revenue[&#34;total_revenue +=&#34;]
        Revenue --&gt; Stats[&#34;update_daily_stats()&#34;]
        Stats --&gt; Notif[&#34;send_notifications()&#34;]
        Notif --&gt; Analytics[&#34;track_analytics()&#34;]
        
        Error1[‚ùå Forget a step?]
        Error2[‚ùå Wrong order?]
        Error3[‚ùå Race condition?]
    end
    
    subgraph &#34;After: Declarative Relationships&#34;
        OrderSignal[orders: Signal]
        OrderSignal --&gt; RevenueComp[total_revenue: Computed]
        OrderSignal --&gt; StatsComp[daily_stats: Computed]
        
        OrderSignal --&gt; NotifEffect[notification_effect: Effect]
        OrderSignal --&gt; AnalyticsEffect[analytics_effect: Effect]
        
        Success1[‚úÖ Relationships declared once]
        Success2[‚úÖ Automatic consistency]
        Success3[‚úÖ Easy to test]
    end
    
    style OrderAdd fill:#F44336,color:#fff
    style OrderSignal fill:#4CAF50,color:#fff
    style Error1 fill:#D32F2F,color:#fff
    style Error2 fill:#D32F2F,color:#fff
    style Error3 fill:#D32F2F,color:#fff
    style Success1 fill:#388E3C,color:#fff
    style Success2 fill:#388E3C,color:#fff
    style Success3 fill:#388E3C,color:#fff
</p>
<!--kg-card-end: html-->
<hr/>
<h2 id="conclusion">Conclusion</h2>
<p>Signals represent a fundamental shift from imperative to declarative state management. They&#39;re not just &#34;reactive variables&#34; - they&#39;re a way to express complex state relationships that automatically maintain consistency.</p>
<h3 id="the-signal-advantage">The Signal Advantage</h3>

<!--kg-card-begin: html-->
<p>
graph LR
    subgraph &#34;Traditional Challenges&#34;
        TC1[Manual Coordination]
        TC2[Implicit Dependencies]
        TC3[Inconsistent State]
        TC4[Testing Complexity]
        TC5[Performance Blind Spots]
    end
    
    subgraph &#34;Signal Solutions&#34;
        SS1[Automatic Updates]
        SS2[Explicit Relationships]
        SS3[Always Consistent]
        SS4[Isolated Testing]
        SS5[Fine-grained Reactivity]
    end
    
    TC1 --&gt; SS1
    TC2 --&gt; SS2
    TC3 --&gt; SS3
    TC4 --&gt; SS4
    TC5 --&gt; SS5
    
    style TC1 fill:#F44336,color:#fff
    style TC2 fill:#F44336,color:#fff
    style TC3 fill:#F44336,color:#fff
    style TC4 fill:#F44336,color:#fff
    style TC5 fill:#F44336,color:#fff
    style SS1 fill:#4CAF50,color:#fff
    style SS2 fill:#4CAF50,color:#fff
    style SS3 fill:#4CAF50,color:#fff
    style SS4 fill:#4CAF50,color:#fff
    style SS5 fill:#4CAF50,color:#fff
</p>
<!--kg-card-end: html-->
<p>The key insight is that most state management bugs come from <strong>forgetting to update something</strong> when related state changes. Signals eliminate this entire class of bugs by making relationships explicit and automatic.</p>
<p>Start small: identify one area of your codebase where you manually coordinate state updates. Replace it with Signals, and experience the difference. Once you see how much cleaner and more reliable it makes your code, you&#39;ll start seeing Signal opportunities everywhere.</p>
<p>Remember: Signals are a tool, not a religion. Use them where they add value - complex derived state, cross-cutting concerns, real-time data flows. Skip them for simple, linear transformations.</p>

    </div></div>
  </body>
</html>
