<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://esolangs.org/wiki/Birb">Original</a>
    <h1>Birb: Programming with bird emojis</h1>
    
    <div id="readability-page-1" class="page"><div id="mw-content-text" lang="en" dir="ltr"><div><table>
<caption><b>Birb</b></caption>

<tbody><tr>
<th><a href="https://esolangs.org/wiki/Esolang:Categorization#Paradigm" title="Esolang:Categorization">Paradigm(s)</a></th>
<td>functional</td>
</tr>
<tr>
<th>Designed by</th>
<td><a href="https://esolangs.org/wiki/User:Melvin" title="User:Melvin">User:Melvin</a>, <a href="https://esolangs.org/w/index.php?title=User:SCKelemen&amp;action=edit&amp;redlink=1" title="User:SCKelemen (page does not exist)">User:SCKelemen</a></td>
</tr>
<tr>
<th><a href="https://esolangs.org/wiki/Category:Years" title="Category:Years">Appeared in</a></th>
<td><a href="https://esolangs.org/wiki/Category:2021" title="Category:2021">2021</a></td>
</tr>
<tr>
<th>Type system</th>
<td>untyped</td>
</tr>
<tr>
<th><a href="https://esolangs.org/wiki/Esolang:Categorization#Memory" title="Esolang:Categorization">Memory system</a></th>
<td>stack-based</td>
</tr>

<tr>
<th><a href="https://esolangs.org/wiki/Computational_class" title="Computational class">Computational class</a></th>
<td><a href="https://esolangs.org/wiki/Category:Turing_complete" title="Category:Turing complete">Turing complete</a></td>
</tr>
<tr>
<th>Reference implementation</th>
<td><a rel="nofollow" href="https://github.com/marvinborner/birb">[1]</a></td>
</tr>

<tr>
<th>Influenced by</th>
<td>Combinatory Logic, Lambda Calculus, Gabriel Lebec,  Samuel Kelemen</td>
</tr>

<tr>
<th>File extension(s)</th>
<td><code>.birb</code>, <code>.bird</code>,</td>
</tr>
</tbody></table><p><b>Birb</b> is an untyped, purely functional language based on Lambda Calculus and Combinatory Logic.
</p>


<h2><span id="Language_overview">Language overview</span></h2>
<p>The birb language is entirely comprised of bird emojis. 
</p>
<h2><span id="Symbols">Symbols</span></h2>
<table>

<tbody><tr>
<th>Symbol</th>
<th>Name</th>
<th>Lambda Calculus</th>
<th>Combinator
</th></tr>
<tr>
<td>🦉</td>
<td>owl</td>
<td>\ab.b(ab)</td>
<td>owl
</td></tr>
<tr>
<td>🦅</td>
<td>eagle</td>
<td>\abcde.ab(cde)</td>
<td>eagle
</td></tr>
<tr>
<td>🪽</td>
<td>wing</td>
<td>\abcd.a(bd)(cd)</td>
<td>phoenix
</td></tr>
<tr>
<td>🕊️</td>
<td>dove</td>
<td>\abcd.ab(cd)</td>
<td>dove
</td></tr>
<tr>
<td>🦜</td>
<td>parrot</td>
<td>\a.aa</td>
<td>mockingbird
</td></tr>
<tr>
<td>🦆</td>
<td>duck</td>
<td>\abc.c(ba)</td>
<td>quacky
</td></tr>
<tr>
<td>🐤</td>
<td>touring chick</td>
<td>\ab.b(aab)</td>
<td>turing
</td></tr>
<tr>
<td>🐥</td>
<td>kool chick</td>
<td>\ab.a</td>
<td>kestrel
</td></tr>
<tr>
<td>🐣</td>
<td>hatching chick</td>
<td>\abc.c(ab)</td>
<td>quirky
</td></tr>
<tr>
<td>🐦</td>
<td>simple bird</td>
<td>\a.a</td>
<td>identity
</td></tr>
<tr>
<td>🦚</td>
<td>peacock</td>
<td>\abc.b(ac)</td>
<td>queer
</td></tr>
<tr>
<td>🦤</td>
<td>dodo</td>
<td>\ab.a(bb)\ab.a(bb)</td>
<td>sage
</td></tr>
<tr>
<td>🐧</td>
<td>penguin</td>
<td>\abc.a(bc)</td>
<td>blackbird
</td></tr>
<tr>
<td>🦢</td>
<td>swan</td>
<td>\abc.ac(bc)</td>
<td>substitution
</td></tr>
<tr>
<td>🦩</td>
<td>flamingo</td>
<td>\abc.acb</td>
<td>cardinal
</td></tr></tbody></table>
<h2><span id="Syntax">Syntax</span></h2>
<ul><li><code>[birb]+</code>: Birb</li>
<li>everything else: Comment</li></ul>
<p>Syntax errors are impossible as long as you use at least one birb.
</p>
<h2><span id="Semantics">Semantics</span></h2>
<p>Birbs stagger as they walk: they are reduced in alternating associative order, starting with left associativity at birb index ⌊len/2⌋:
</p>
<pre>   🐦🐦 -&gt; (🐦🐦)
   🐦🐦🐦 -&gt; ((🐦🐦)🐦)
   🐦🐦🐦🐦 -&gt; (🐦((🐦🐦)🐦))
   🐦🐦🐦🐦🐦 -&gt; ((🐦((🐦🐦)🐦))🐦)
   🐦🐦🐦🐦🐦🐦 -&gt; (🐦((🐦((🐦🐦)🐦))🐦))
   🐦🐦🐦🐦🐦🐦🐦 -&gt; ((🐦((🐦((🐦🐦)🐦))🐦))🐦)
   ...
</pre>
<h2><span id="Examples">Examples</span></h2>
<p>You can find more examples (with comments) in the <code>samples/</code> directory.
</p>
<h3><span id="Relationships">Relationships</span></h3>
<ul><li>🪽🐦 -&gt; 🦢</li>
<li>🦢🐦 -&gt; 🦉</li>
<li>🦉🐦 -&gt; 🦜</li>
<li>🕊️🐦 -&gt; 🐧</li>
<li>🐧🐧 -&gt; 🕊️</li>
<li>🦩🐧 -&gt; 🦚</li>
<li>🦩🦚 -&gt; 🐧</li>
<li>🦩🦆 -&gt; 🐣</li></ul>
<p>One can only imagine what happens if two parrots talk to each other: 🦜🦜 -&gt; 💥. The same happens with 🐤🐤; they just can’t stop waddling!
</p>
<h3><span id="Arithmetic">Arithmetic</span></h3>
<p>For this example I use the Church numerals. Zero would then be encoded as 🐥🐦. The successor function can be written as 🦢🐧:
</p>
<ul><li>🐦🐧🐦🦢🐧🐥🐦 -&gt; <code>\\(10)</code> (Church numeral 1)</li>
<li>🐦🐧🐦🐧🕊️🦢🐧🦢🐧🐥🐦 -&gt; <code>\\(1(10))</code> (Church numeral 2)</li></ul>
<p>Similarly, one can translate the Church addition function to 🪽🐧. Now, to calculate <code>1+2</code> based on their increments from zero:
</p>
<ul><li>🐦🐦🕊️🐧🕊️🐧🐦🐧🕊️🐧🕊️🪽🐧🦢🐧🦢🐧🐥🐦🦢🐧🐥🐦 -&gt; <code>\\(1(1(10)))</code> (Church numeral 3)</li></ul>
<p>Also: 🐧 is <code>a*b</code>, 🦜 is <code>n^n</code> and 🦚🐦 <code>a^b</code>.
</p><p>Note that there exist many alternative ways to do arithmetic. Try writing the functions above with other birbs!
</p>
<h3><span id="Containers">Containers</span></h3>
<p>You can create a pair <code>[X,Y]</code> using <code>🦩🦩🦩YX</code>.
</p><p>Typically, one would now construct a list using repeated application of pairs (Boehm-Berarducci/Church encoding). However, due to the reversed application and alternating associativity, the Mogensen-Scott encoding is more suitable:
</p><p>List <code>[X_1,X_2,...,X_n]</code>: <code>[🦩]ⁿ🦩X2X1...XN</code>.
</p>
<h2><span id="Turing-completeness">Turing-completeness</span></h2>
<p>Birb is Turing complete, since one can construct any term of the <a href="https://esolangs.org/wiki/Jot" title="Jot">Jot</a> variant of <a href="https://esolangs.org/wiki/Iota" title="Iota">Iota</a>. A Jot term <code>((X s) k)</code> is equivalent to <code>🐦X🦢🐥</code>. Similarly, <code>(s (k X))</code> is equivalent to <code>🐦🐦🐧🦢🐥X</code>. This can be extended for arbitrary long terms using increasingly more complicated construction of composition combinators.
</p>
<h2><span id="Implementations">Implementations</span></h2>
<p>As of right now there is one interpreter, written by <a href="https://esolangs.org/wiki/User:Melvin" title="User:Melvin">User:melvin</a> in Haskell: <a rel="nofollow" href="https://github.com/marvinborner/birb">[2]</a>.
</p>
<!-- 
NewPP limit report
Cached time: 20230914123024
Cache expiry: 86400
Reduced expiry: false
Complications: []
CPU time usage: 0.015 seconds
Real time usage: 0.016 seconds
Preprocessor visited node count: 110/1000000
Post‐expand include size: 2164/2097152 bytes
Template argument size: 448/2097152 bytes
Highest expansion depth: 5/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 0/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    1.352      1 Template:Infobox_proglang
100.00%    1.352      1 -total
-->

<!-- Saved in parser cache with key esolang_wiki:pcache:idhash:14181-0!canonical and timestamp 20230914123050 and revision id 115957. Serialized with JSON.
 -->
</div>
</div></div>
  </body>
</html>
