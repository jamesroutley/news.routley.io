<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gamesbymason.com/blog/2025/stop-shipping-pngs/">Original</a>
    <h1>Shipping textures as PNGs is suboptimal</h1>
    
    <div id="readability-page-1" class="page"><div id="page">
    

    
      
        <div id="intro"><p>Are you shipping textures to players as PNGs? The goal of this post is to convince you that this is suboptimal, and walk you through a better approach.</p><p>I’ll also share <a href="https://github.com/games-by-Mason/zex" target="_blank">my implementation</a> of the suggested approach, but if you’d rather do it yourself I’ll also provide you with the information you need to get started.</p><p><em>If you’re using a game engine, it is almost certainly doing what this post suggests automatically, but it doesn’t hurt to double check!</em></p></div>
      
      
    
      
      
        
      
    
      
        <div id="pngs"><p><img src="https://gamesbymason.com/blog/2025/stop-shipping-pngs/png.png" alt="PNG"/> <em><a href="https://libpng.org/pub/png/" target="_blank">source</a></em></p><p>PNGs are great for interchange. They’re lossless, they compresses well, and support is ubiquitous. PNG is my image interchange format of choice.</p><p>This post isn’t a criticism of PNGs–it’s just that the PNG format is designed for image data, not texture data.</p><p>Here are some examples of features you would expect out of a texture format that you’re not going to find in an image format:</p><ul><li>Pregenerated <a href="https://en.wikipedia.org/wiki/Mipmap" target="_blank">mipmaps</a></li><li><a href="https://en.wikipedia.org/wiki/Cube_mapping" target="_blank">Cubemaps</a></li><li><a href="https://tomforsyth1000.github.io/blog.wiki.html#%5B%5BPremultiplied%20alpha%5D%5D" target="_blank">Premultiplied alpha</a><ul><li>Technically PNGs can be premultplied, but yours probably aren’t.</li></ul></li></ul><p>Can you work around all these issues? Sure.</p><p>You can premultiply and generate your mipmaps at load time. You can ship separate images for each cuebmap face. But now you’re resigned to cheap mipmap generation, and cubemaps that are difficult to downsample correctly.</p><p>You can certainly make it work, but you’re making things unnecessarily difficult for yourself by using the wrong tool for the job.</p><p>Furthermore, texture formats have a killer feature not mentioned above–support for GPU compatible texture compression like <a href="https://en.wikipedia.org/wiki/S3_Texture_Compression" target="_blank">BCn</a>.</p><p>An in-depth explanation of GPU compression formats it out of scope for this post, but at a high level, these formats store each block of pixels as a couple of endpoints and a method for interpolating between those endpoints.</p><p>This trades mild degradation of image quality for improvements in storage, VRAM usage, <em>and</em> sampling performance. It’s so good it feels like you’re cheating thermodynamics.</p><p>GPUs can’t decompress PNGs on the fly, so as a result, if you ship PNGs you either can’t take advantage of this compression, or you have to first decompress the PNGs and then do an extremely expensive compression step to convert to the desired block based format every time a player loads the game.</p><p>That’s a little goofy, right?</p><p><em>(EDIT: Well, it’s goofy when done naively–see discussion w/ Ignacio Castaño <a href="https://mastodon.gamedev.place/@castano/115149810770624408" target="_blank">here</a>, something along these lines can become viable if you can transcode quickly.)</em></p></div>
      
      
    
      
        <div id="alternatives"><p><img src="https://gamesbymason.com/blog/2025/stop-shipping-pngs/formats.png" alt="some of Way of Rhea&#39;s data files"/></p><p>Texture formats like Khronos’ <a href="https://www.khronos.org/ktx/" target="_blank">KTX2</a> and Microsoft’s <a href="https://learn.microsoft.com/en-us/windows/win32/direct3ddds/dx-graphics-dds-pguide" target="_blank">DDS</a> are designed for exactly our use case. They’re just headers followed by some image data that you can upload directly to the GPU without any additional processing.</p><p>Well, unless you use supercompression. GPU compression formats don’t provide great compression ratios, so it’s typical to apply lossless compression as well (think zlib or lz4.) In that case you’ll decompress, and then upload.</p><p>The meta here is to design your lossy compressor to be aware that its output is going to be losslessly compressed afterwards. This lets it make decisions that reduce entropy, improving the effectiveness of the lossless step.</p><p>I used DXT5 + lz4 compressed DDS files for <a href="https://store.steampowered.com/app/1110620/Way_of_Rhea/" target="_blank">Way of Rhea</a>, I’m switching to BC7 + zlib compressed KTX2 files for my next game. Both approaches are reasonable.</p><p><em><strong>Note: I primarily develop games for desktop platforms. IIUC, on mobile, hardware support for various types of GPU compression varies but the formats are similar-ish, so the meta is to use something like <a href="https://binomialllc.github.io/basis_universal/" target="_blank">Basis Universal</a> to quickly transcode to the correct format on load.</strong></em></p></div>
      
      
    
      
        <div id="exporting"><p><img src="https://gamesbymason.com/blog/2025/stop-shipping-pngs/ktx2.svg" alt="KTX2"/></p><p>At this point, you’re likely looking through the export menu of your image editor of choice for KTX2 and DDS, and not seeing any results.</p><p>Unfortunately, AFAICT most people end up rolling their own exporters. People used to use <a href="https://github.com/castano/nvidia-texture-tools/" target="_blank">Nvidia Texture Tools</a>, but it’s archived as there wasn’t funding to maintain it. It’s still a great reference. Nvidia has a <a href="https://developer.nvidia.com/texture-tools-exporter" target="_blank">closed source fork</a>, but I don’t love having a closed source dependency for such an integral part of my engine.</p><p>I’ve implemented an open source texture tool that you’re welcome to use directly or as a reference for your own implementation: <a href="https://github.com/games-by-Mason/zex" target="_blank">Zex</a>.</p><p>It can be used as a command line tool, or as a <a href="https://ziglang.org/" target="_blank">Zig</a> library. It reads PNGs using <a href="https://github.com/nothings/stb/blob/master/stb_image.h" target="_blank">stb_image</a>, and converts them to KTX2, with support BC7 compression + rate distortion optimization from <a href="https://github.com/richgel999/bc7enc_rdo/" target="_blank">bc7enc_rdo</a>, and supercompression via <a href="https://zlib.net/" target="_blank">zlib</a>.</p><p>It supports most standard features, such as mipmap generation with configurable filters and address modes.</p><p>I haven’t implemented cubemap exports yet as my current game isn’t using them. If you need support before I get around to it, PRs are welcome–it should be a pretty straightforward addition.</p><p>If you want to implement your own exporter, here are some useful references. Keep in mind that you don’t need to support all possible features, just the ones your engine uses:</p><ul><li><a href="https://www.khronos.org/ktx/" target="_blank">KTX2</a> (<a href="https://registry.khronos.org/KTX/specs/2.0/ktxspec.v2.html" target="_blank">Format Specification</a> / <a href="https://registry.khronos.org/DataFormat/specs/1.3/dataformat.1.3.inline.html" target="_blank">DFD Specification</a>)</li><li><a href="https://learn.microsoft.com/en-us/windows/win32/direct3ddds/dx-graphics-dds-pguide" target="_blank">DDS</a></li></ul></div>
      
      
    
      
        
      
      
    
      
        <div id="viewers"><h2><a href="#viewers">Texture Viewers</a></h2><p><img src="https://gamesbymason.com/blog/2025/stop-shipping-pngs/tacentview.gif" alt="animated screenshot of tacentview"/> <em><a href="https://bluescan.github.io/tacentview/" target="_blank">source</a></em></p><p>Most image viewers won’t be able to open texture formats like DDS/KTX2. This sorta makes sense–image viewers are typically designed to show a single image, whereas a texture may be comprised of multiple mipmaps and cubemap faces and such, and may be HDR. This requires a fancier UI.</p><p>I’m personally a fan of <a href="https://github.com/bluescan/tacentview" target="_blank">Tacentview</a> for this use case. It’s open source, cross platform, and supports a large number of formats.</p></div>
      
      
    
      
        <div id="alpha-coverage"><h2><a href="#alpha-coverage">Preserving Alpha Coverage</a></h2><p><img src="https://gamesbymason.com/blog/2025/stop-shipping-pngs/tree.jpg" alt="a 3d tree"/> <em>source: firewatch inspired me so I made a tree and then never used it for anything</em></p><p>Pregenerating your mipmaps gives you a chance to be a little more “correct” about them.</p><p>For example, if you’ve ever tried to render a tree or a chain link fence in-game as a cutout (or with <a href="https://en.wikipedia.org/wiki/Alpha_to_coverage" target="_blank">alpha to coverage</a>) but found that it vanishes when you get far away, <a href="https://www.ludicon.com/castano/blog/articles/computing-alpha-mipmaps/" target="_blank">your mipmap filtering likely isn’t taking into account the alpha test</a>.</p><p>You can see Zex’s alpha test aware resize <a href="https://github.com/Games-by-Mason/Zex/blob/686fce714e711437d2a6ef4cdd71bd14ca87f3ce/src/Image.zig#L555" target="_blank">here</a>. This isn’t battle tested yet, compare results visually in-engine to see if it provides a benefit for your artwork.</p></div>
      
      
    
      
        <div id="automation"><h2><a href="#automation">Automation</a></h2><p><img src="https://gamesbymason.com/blog/2025/stop-shipping-pngs/oven.png" alt="a screenshot of the Oven GitHub repo"/> <em><a href="https://github.com/Games-by-Mason/oven" target="_blank">source</a></em></p><p>You probably don’t want to convert all your images by hand. I did this for <a href="https://store.steampowered.com/app/1110620/Way_of_Rhea/" target="_blank">Way of Rhea</a> for a while, but eventually realized that it was a <a href="https://youtu.be/89bLKVvF85M?t=1468" target="_blank">waste of time</a>. Every time a texture changes you have to go back and figure out what settings you used last time. Just automate it.</p><p>I’ll probably write a follow up post describing my strategy for automating this at some point in the future, but if you want a sneak peak, check out <a href="https://github.com/Games-by-Mason/oven" target="_blank">Oven</a>. It’s not exactly general purpose right now, but might be an interesting reference.</p></div>
      
      
    
    

    
  </div></div>
  </body>
</html>
