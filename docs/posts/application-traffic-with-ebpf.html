<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thebsdbox.co.uk/2023/12/08/Application-traffic-with-eBPF/">Original</a>
    <h1>Application Traffic with eBPF</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                <p>In a <a href="https://thebsdbox.co.uk/2023/11/18/eBPF-adventures-in-networking/">previous post</a> I talked a little bit about building up the knowledge with eBPF to start to understand a little bit more about what is going in and out of a network adapter. Basically taking your ethernet frame and stripping off the headers (Ethernet + IP Header + TCP/UDP Header) you are finally left with what remains within the packet from an application or data sense. </p>
<p>All of the code lives within the ‚Äúlearning eBPF‚Äù repository, specifically the eBPF code is <a target="_blank" rel="noopener" href="https://github.com/thebsdbox/learning-ebpf/blob/main/ebpf/http/http.c">here</a>. The plan for this post is to step through the bits that I think are useful or could be important‚Ä¶</p>
<p><strong>Note</strong> This code did do some Ingress/Egress packet modification so uses some eBPF helpers that requires 6.1+ of the Linux Kernel to work.</p>
<h2 id="The-maps"><a href="#The-maps" title="The maps!"></a>The maps!</h2><p>Presumably you‚Äôve come across these before? If not never fear!! Simply put an eBPF map is the mechanism for communicating between user-land and the in-kernel eBPF program. What is exceptionally cool (in my mind at least) is that these maps use keys and values.. so I don‚Äôt have to loop around data comparing and looking for what matches whatver it is i‚Äôm looking for, I pass a key and if something matches I get the corresponding data :D </p>
<p>Below is the map that I will use, which is called <code>url_map</code> the key is 20 characters long (a bounded ‚Äústring‚Äù some might say), and the value that is assigned to that key is a struct that i‚Äôve defined above.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><code></code></pre></td></tr></tbody></table></figure>

<h2 id="The-eBPF-programs"><a href="#The-eBPF-programs" title="The eBPF programs!"></a>The eBPF programs!</h2><p>There are two eBPF programs defined in the code <code>tc_egress</code> and <code>tc_ingress</code>, bonus points if you can guess how they are attached! For this post, we will only concern ourselves with the <code>tc_ingress</code> program.</p>
<p>So as we would see in the myriad of examples that already exist we need to go through the header identification dance. </p>
<ol>
<li>Do the sanity checks, and cast the <code>data</code> to the type of <code>ethhdr</code> (<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Ethernet_frame">Ethernet header</a>)</li>
<li>Find the protocol within the ethernet frame by reading the <code>h_proto</code> within the ethernet header (also called <code>Ethertype</code>).</li>
<li>Cast the data <em>after</em> the ethernet header as a <code>iphdr</code> (<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Internet_Protocol_version_4#Header">IP header</a>)</li>
<li>Find the protocol within the IP Header, we also will need to determine the size of the IP header (turns out they can be different sizes!  <code>¬Ø\_(„ÉÑ)_/¬Ø</code>)</li>
<li>To determine the size of the header we times it‚Äôs value by four, why I hear you ask! Well this value is multiplied by 32bits do determine the size of the header, so if the value was 6 then the header would be 192 bits (or 24 bytes). So to simply determine the IP header in bytes we can multiply this value by 4!</li>
<li>Cast the data *after the IP Header as a <code>tcphdr</code> (<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure">TCP Header</a>)</li>
<li>Like step (5) we will need to determine the size of the TCP Header (it again can be dynamic) and it‚Äôs the same step here, we simply need to multiply the value <code>doff</code> by four to determine the header size in bytes.</li>
<li>With all of this calculated we can now infer that the data lives at the end of the Ethernet Header size, the IP Header size and the TCP Header size. </li>
<li>Finally we can determine how big the application data is by taking the <code>tot_len</code> (total length) from the IP Header and subtracting the IP and TCP Header sizes.</li>
</ol>
<h3 id="Application-Data"><a href="#Application-Data" title="Application Data !!"></a>Application Data !!</h3><p>In order to read this data we will need a few things that were mentioned above! </p>
<p>First, we will need the data offset (where the data starts) and that is found after the Ethernet header + the IP Header size (once calculated) and the TCP Header (again, once calculated). We will also need a buffer in order to store the data we will be reading from the socket buffer.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><code></code></pre></td></tr></tbody></table></figure>

<p>We use the <code>bpf_skb_load_bytes</code> to read the a set amount of data (<code>60</code> bytes) into our buffer (<code>pdata</code>) from the socket buffer (<code>skb</code>) starting from the offset where we know the data is (<code>poffset</code>)!</p>
<p>At this point we have 60 bytes of data, should be enough for us to write some code to understand it.</p>
<h3 id="HTTP-Data"><a href="#HTTP-Data" title="HTTP Data :-)"></a>HTTP Data :-)</h3><p>Lets look at what happens when we try a HTTP request!</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><code> ~ curl code/test -vvv</code></pre></td></tr></tbody></table></figure>

<p>I‚Äôm using <code>curl</code> to request the URL <code>/test</code> from the host <code>code</code> (code is my development VM, that runs code-server). We can see the data that is sent to the server (each line begins with <code>&gt;</code> to determine the direction of communication). The first line of data in a HTTP request is typically a <em>verb</em> followed by the resource we would like to interact with and this request ends with the HTTP specification and a carriage return as defined in the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/HTTP#HTTP/1.1_request_messages">HTTP standards</a>. So we can see the line that we care about is <code>GET /test</code> (we/I don‚Äôt really care about the HTTP specification at this point :D). </p>
<h4 id="Find-the-HTTP-method"><a href="#Find-the-HTTP-method" title="Find the HTTP method"></a>Find the HTTP method</h4><p>The first step is to read the first three characters of <code>pdata</code> and make find if <code>pdata[0] == G</code>, <code>pdata[1] == E</code> and <code>pdata[2] == T</code> this will effectively allow us to find if this is both a HTTP request in the first place and specifically if it is a HTTP request!</p>
<p>Once we‚Äôve validated those first 3 bytes we will want to read the more data starting from the 4 byte (three bytes for the request and one for the space between)!</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><code><span>char</span> <span>path</span>[max_path_len];</code></pre></td></tr></tbody></table></figure>

<p>The above function will read through the rest of the HTTP data (from the 4th byte) until it encounters a space, leaving us with the URL we are trying to <code>GET</code>! We can validate this with a debug print statement:</p>
<figure><table><tbody><tr><td><pre><span>1</span><br/></pre></td><td><pre><code>bpf_printk(<span>&#34;&lt;- incoming path [%s], length [%d]&#34;</span>, path, path_len);<br/></code></pre></td></tr></tbody></table></figure>

<p>Which will look like the following in your logs:</p>
<figure><table><tbody><tr><td><pre><span>1</span><br/></pre></td><td><pre><code>&lt;idle&gt;-0        dNs3. 2252901.017812: bpf_trace_printk: &lt;- incoming path , length <br/></code></pre></td></tr></tbody></table></figure>

<h3 id="Acting-on-the-HTTP-application-request"><a href="#Acting-on-the-HTTP-application-request" title="Acting on the HTTP application request"></a>Acting on the HTTP application request</h3><p>The above explanations detail what and how we‚Äôre reading the data, but if we want to ‚Äúdynamically‚Äù look up the HTTP requests we will need to make use of eBPF maps. </p>
<p>In our GO userland code we do the following:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><code>path<span> :</span>= flag.String(<span>&#34;path&#34;</span>, <span>&#34;&#34;</span>, <span>&#34;The URL Path to watch for&#34;</span>)</code></pre></td></tr></tbody></table></figure>

<p>As we can see in the code above our Go program when started will read from the flag <code>-path</code> and that will be used as a <strong>key</strong> in our eBPF map, the value can be ignored for now.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><code>struct url_path *found_path = bpf_map_lookup_elem(&amp;url_map, <span>path</span>);</code></pre></td></tr></tbody></table></figure>

<p>In our eBPF program we will do a map lookup on the HTTP request, if that request as a char array exists as a <strong>key</strong> then we can operate on it!</p>
<p>Starting our Go program now <code>sudo ./http -interface ens160 -path /test</code> will yield the following:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><code>INFO<span>[0000]</span> Starting üêù the eBPF HTTP watcher, on interface <span>[ens160]</span> <span>for</span> path <span>[/test]</span> </code></pre></td></tr></tbody></table></figure>

<h2 id="Conclusion"><a href="#Conclusion" title="Conclusion"></a>Conclusion</h2><p>Parsing HTTP isn‚Äôt too bad as it is a relatively simple protocol, it uses easy verbs and simple methods for structure with spaces and carriage returns to differentiate. This methodology would potentially work OK with other protocols like DNS, POP3 or SMTP. When things are encrypted we would need someway of decrypting before we can parse the data (that‚Äôs beyond me‚Ä¶). However, I hope that this sparks some ideas into playing more with eBPF and attempting to parse and operate on applications with eBPF!</p>

                
              </div></div>
  </body>
</html>
