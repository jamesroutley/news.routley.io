<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.doyensec.com/2022/10/11/ebpf-bypass-security-monitoring.html">Original</a>
    <h1>On Bypassing eBPF Security Monitoring</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
  
  <p><span>11 Oct 2022 - Posted by Lorenzo Stella</span></p><p>There are many security solutions available today that rely on the <a href="https://ebpf.io/">Extended Berkeley Packet Filter (eBPF)</a> features of the Linux kernel to monitor kernel functions. Such a paradigm shift in the latest monitoring technologies is being driven by a variety of reasons. Some of them are motivated by performance needs in an increasingly cloud-dominated world, among <a href="https://www.youtube.com/watch?v=44nV6Mj11uw">others</a>. The Linux kernel always had kernel tracing capabilities such as <a href="https://docs.kernel.org/trace/kprobes.html">kprobes</a> (2.6.9), <a href="https://www.kernel.org/doc/Documentation/trace/ftrace.txt">ftrace</a> (2.6.27 and later), <a href="https://perf.wiki.kernel.org/index.php/Main_Page">perf</a> (2.6.31), or <a href="https://docs.kernel.org/trace/uprobetracer.html">uprobes</a> (3.5), but with BPF it’s finally possible to run kernel-level programs on events and consequently modify the state of the system, without needing to write a kernel module. This has dramatic implications for any attacker looking to compromise a system and go undetected, opening new areas of research and application. Nowadays, eBFP-based programs are used for <a href="https://blog.cloudflare.com/how-to-drop-10-million-packets/">DDoS mitigations</a>, <a href="https://dl.acm.org/doi/abs/10.1016/j.jnca.2021.103283">intrusion detection</a>, <a href="https://developers.redhat.com/articles/2021/12/16/secure-your-kubernetes-deployments-ebpf">container security</a>, and general observability.</p>

<p>In 2021 <a href="https://goteleport.com/">Teleport</a> introduced a new feature called <a href="https://goteleport.com/blog/enhanced-session-recording/">Enhanced Session Recording</a> to close some monitoring gaps in Teleport’s audit abilities. All issues reported have been promptly fixed, mitigated or documented as described in their <a href="https://goteleport.com/resources/audits/teleport-features-security-audit-q4-2021/">public Q4 2021 report</a>. Below you can see an illustration of how we managed to bypass eBPF-based controls, along with some ideas on how red teams or malicious actors could evade these new intrusion detection mechanisms. These techniques can be generally applied to other targets while attempting to bypass any security monitoring solution based on eBPF:</p>

<ul id="markdown-toc">
  <li><a href="#a-few-words-on-how-ebpf-works" id="markdown-toc-a-few-words-on-how-ebpf-works">A few words on how eBPF works</a></li>
  <li><a href="#common-shortcomings--potential-bypasses-here-be-dragons" id="markdown-toc-common-shortcomings--potential-bypasses-here-be-dragons">Common shortcomings &amp; potential bypasses (here be dragons)</a>    <ul>
      <li><a href="#1-understand-which-events-are-caught" id="markdown-toc-1-understand-which-events-are-caught">1. Understand which events are caught</a>        <ul>
          <li><a href="#11-execution-bypasses" id="markdown-toc-11-execution-bypasses">1.1 Execution bypasses</a></li>
          <li><a href="#12-network-bypasses" id="markdown-toc-12-network-bypasses">1.2 Network bypasses</a></li>
        </ul>
      </li>
      <li><a href="#2-delayed-execution" id="markdown-toc-2-delayed-execution">2. Delayed execution</a></li>
      <li><a href="#3-evade-scoped-event-monitoring-based-on-cgroup" id="markdown-toc-3-evade-scoped-event-monitoring-based-on-cgroup">3. Evade scoped event monitoring based on <code>cgroup</code></a></li>
      <li><a href="#4-memory-limits-and-loss-of-events" id="markdown-toc-4-memory-limits-and-loss-of-events">4. Memory limits and loss of events</a></li>
      <li><a href="#5-never-trust-the-userspace" id="markdown-toc-5-never-trust-the-userspace">5. Never trust the userspace</a></li>
      <li><a href="#6-abuse-the-lack-of-seccomp-bpf--kernel-discrepancies" id="markdown-toc-6-abuse-the-lack-of-seccomp-bpf--kernel-discrepancies">6. Abuse the lack of <code>seccomp-bpf</code> &amp; kernel discrepancies</a></li>
      <li><a href="#7-interfere-with-the-agents" id="markdown-toc-7-interfere-with-the-agents">7. Interfere with the agents</a></li>
    </ul>
  </li>
</ul>

<h2 id="a-few-words-on-how-ebpf-works">A few words on how eBPF works</h2>


<p>Extended BPF programs are written in a high-level language and compiled into eBPF bytecode using a toolchain. A user mode application loads the bytecode into the kernel using the <code>bpf()</code> syscall, where the eBPF verifier will perform a number of checks to ensure the program is “safe” to run in the kernel. This verification step is critical — eBPF exposes a path for unprivileged users to execute in ring 0. Since allowing unprivileged users to run code in the kernel is a ripe attack surface, several pieces of research in the past focused on local privilege exploitations (LPE), which we won’t cover in this blog post.
After the program is loaded, the user mode application attaches the program to a hook point that will trigger the execution when a certain hook point (event) is hit (occurs). The program can also be JIT compiled into native assembly instructions in some cases. User mode applications can interact with, and get data from, the eBPF program running in the kernel using eBPF maps and eBPF helper functions.</p>

<h2 id="common-shortcomings--potential-bypasses-here-be-dragons">Common shortcomings &amp; potential bypasses (here be dragons)</h2>

<h3 id="1-understand-which-events-are-caught">1. Understand which events are caught</h3>
<p>While eBPF is fast (much faster than <a href="https://linux.die.net/man/8/auditd">auditd</a>), there are plenty of interesting areas that can’t be reasonably instrumented with BPF due to performance reasons. Depending on what the security monitoring solution wants to protect the most (e.g., network communication vs executions vs filesystem operations), there could be areas where excessive probing could lead to a performance overhead pushing the development team to ignore them. This depends on how the endpoint agent is designed and implemented, so carefully auditing the code security of the eBPF program is paramount.</p>

<h4 id="11-execution-bypasses">1.1 Execution bypasses</h4>
<p>By way of example, a simple monitoring solution could decide to hook only the <code>execve</code> system call. Contrary to popular belief, multiple ELF-based Unix-like kernels don’t need a file on disk to load and run code, even if they usually require one. One way to achieve this is by using a technique called reflective loading. Reflective loading is an important post-exploitation technique usually used to avoid detection and execute more complex tools in locked-down environments. The man page for <code>execve()</code> states: “<em><code>execve()</code> executes the program pointed to by filename…</em>”, and goes on to say that “<em>the text, data, bss, and stack of the calling process are overwritten by that of the program loaded</em>”. This overwriting doesn’t necessarily constitute something that the Linux kernel must have a monopoly over, unlike filesystem access, or any number of other things. Because of this, the <code>execve()</code> system call can be mimicked in userland with a minimal difficulty. Creating a new process image is therefore a simple matter of:</p>
<ul>
  <li>cleaning out the address space;</li>
  <li>checking for, and loading, the dynamic linker;</li>
  <li>loading the binary;</li>
  <li>initializing the stack;</li>
  <li>determining the entry point and</li>
  <li>transferring control of execution.</li>
</ul>

<p>By following these six steps, a new process image can be created and run. Since this technique was <a href="https://grugq.github.io/docs/ul_exec.txt">initially reported in 2004</a>, the process has nowadays been pioneered and streamlined by OTS post-exploitation tools. As anticipated, an eBPF program hooking <code>execve</code> would not be able to catch this, since this custom userland <code>exec</code> would effectively replace the existing process image within the current address space with a new one. In this, userland exec mimics the behavior of the system call <code>execve()</code>. However, because it operates in userland, the kernel process structures which describe the process image remain unchanged.</p>

<p>Other system calls may go unmonitored and decrease the detection capabilities of the monitoring solution. Some of these are <code>clone</code>, <code>fork</code>, <code>vfork</code>, <code>creat</code>, or <code>execveat</code>.</p>

<p>Another potential bypass may be present if the BPF program is naive and trusts the <code>execve</code> syscall argument referencing the complete path of the file that is being executed. An attacker could create symbolic links of Unix binaries in different locations and execute them - thus tampering with the logs.</p>

<h4 id="12-network-bypasses">1.2 Network bypasses</h4>

<p>Not hooking all the network-related syscalls can have its own set of problems. Some monitoring solutions may only want to hook the EGRESS traffic, while an attacker could still send data to a non-allowed host abusing other network-sensitive operations (<a href="https://code.woboq.org/linux/linux/security/apparmor/include/audit.h.html#78">see</a> <code>aa_ops</code> at <code>linux/security/apparmor/include/audit.h:78</code>) related to INGRESS traffic:</p>
<ul>
  <li><code>OP_BIND</code>, the <code>bind()</code> function shall assign a local socket address to a socket identified by descriptor socket that has no local socket address assigned.</li>
  <li><code>OP_LISTEN</code>, the <code>listen()</code> function shall mark a connection-mode socket, specified by the socket argument, as accepting connections.</li>
  <li><code>OP_ACCEPT</code>, the <code>accept()</code> function shall extract the first connection on the queue of pending connections, create a new socket with the same socket type protocol and address family as the specified socket, and allocate a new file descriptor for that socket.</li>
  <li><code>OP_RECVMSG</code>, the <code>recvmsg()</code> function shall receive a message from a connection-mode or connectionless-mode socket.</li>
  <li><code>OP_SETSOCKOPT</code>, the <code>setsockopt()</code> function shall set the option specified by the option_name argument, at the protocol level specified by the level argument, to the value pointed to by the option_value argument for the socket associated with the file descriptor specified by the socket argument. Interesting options for attackers are <code>SO_BROADCAST</code>, <code>SO_REUSEADDR</code>, <code>SO_DONTROUTE</code>.</li>
</ul>

<p>Generally, the network monitoring should look at all socket-based operations similarly to <em>AppArmor</em>.</p>

<p>In case the same local user has mixed monitored and unmonitored console sessions, it could be possible for an attacker in a monitored session to leverage open file descriptors and sockets to send data to restricted hosts. In 2020 some versions of Linux kernels had introduced a <a href="https://man7.org/linux/man-pages/man2/pidfd_getfd.2.html">new system call</a> to achieve this called <code>pidfd_getfd</code>. A small number of operating systems (like Ubuntu) implement the <a href="https://www.kernel.org/doc/Documentation/security/Yama.txt">Yama</a> kernel module that limit file descriptor access to only child-parent processes. A PoC code for using this function is available on Github (<a href="https://github.com/TheZ3ro/fdstealer">TheZ3ro/fdstealer</a>).</p>

<p><img src="https://blog.doyensec.com/public/images/fd-stealing.png" alt="File descriptor stealing using pidfd_getfd"/></p>

<h3 id="2-delayed-execution">2. Delayed execution</h3>
<p>If only active console sessions are monitored, eBPF programs may only live for the time span of the session. By delaying the execution of a command (through <code>sleep</code>, <code>timeout</code>, <code>sar</code>, <code>vmstat</code>, <code>inotifywait</code>, <code>at</code>, <code>cron</code> …) and quitting the session, it could be possible to completely evade the solution.</p>

<h3 id="3-evade-scoped-event-monitoring-based-on-cgroup">3. Evade scoped event monitoring based on <code>cgroup</code></h3>
<p>A security monitoring solution may only be interested in auditing a specific user or cgroup (such in the context of a remote console session). Taking Teleport as an example, it achieves this by correlating every event to a session with control groups (<code>cgroupv2</code> in particular). Control grouping is a Linux kernel feature to limit access to resources to a group of processes. It is used in many containerization technologies (behind the scenes Docker creates a set of namespaces and control groups for the container) and its peculiarity is that all child processes will keep the id of the parent process. When Teleport starts an SSH session, it first re-launches itself and places itself within a cgroup. This allows not only that process, but all future processes that Teleport launches, to be tracked with a unique ID. The BPF programs that Teleport runs have been updated to also emit the cgroup ID of the program executing them. The BPF script checks the value returned by <code>bpf_get_current_cgroup_id()</code> and only cares about the important session cgroup. The simplest evasion to this auditing strategy would be changing your cgroup ID, but an attacker needs to be root to achieve this. Meddling with the cgroupv2 pseudo file system or abusing PAM configuration are also potential opportunities to affect the cgroup/session correlation.</p>

<p>Another technique involves being reallocated by init. In the case of Teleport, when the <code>bash</code> process spawned by the session dies, its child processes become orphans and the Teleport process terminates its execution. When a child process becomes an orphan, it can be assigned to a different cgroup by the operating system under certain conditions (not having a tty, being a process group leader, joining a new process session). This allows an attacker to bypass the restrictions in place. The following PoC is an example of a bypass for this design:</p>

<ol>
  <li>Open a new eBPF-monitored session</li>
  <li>Start <a href="https://github.com/tmux/tmux/wiki">tmux</a> by executing the <code>tmux</code> command</li>
  <li>Detach from <code>tmux</code> by pressing <code>CTRL+B</code> and then <code>D</code></li>
  <li>Kill the bash process that is <code>tmux</code>’s parent</li>
  <li>Re-attach to the <code>tmux</code> process by executing <code>tmux attach</code>. The process tree will now look like this:</li>
</ol>

<p><img src="https://blog.doyensec.com/public/images/cgroup-evasion.png" alt="CGroupV2 evasion PoC"/></p>

<p>As another attack avenue, leveraging processes run by different local users/<code>cgroupv2</code> on the machine (abusing other daemons, delegating systemd) can also help an attacker evade this. This aspect obviously depends on the system hosting the monitoring solution. Protecting against this is tricky, since even if <code>PR_SET_CHILD_SUBREAPER</code> is set to ensure that the descendants can’t re-parent themselves to init, if the ancestor reaper dies or is killed (DoS), then processes in that service can escape their cgroup “container”. Any compromise of this privileged service process (or malfeasance by it) allows it to kill its hierarchy manager process and escape all control.</p>

<h3 id="4-memory-limits-and-loss-of-events">4. Memory limits and loss of events</h3>
<p>BPF programs have a lot of constraints. Only 512 bytes of stack space are reserved for the eBPF program. Variables will get hoisted and instantiated at the start of execution, and if the script tries to dump syscall arguments or <code>pt-regs</code>, it will run out of stack space very quickly. If no workaround on the instruction limit is set, it could be possible to push the script into retrieving something too big to ever fit on the stack, losing visibility very soon when the execution gets complicated. But even when workarounds are used (e.g., when using multiple probes to trace the same events but capture different data, or split your code into multiple programs that call each other using a program map) there still may be a chance to abuse it. BPF programs are not meant to be run forever, but they have to stop at some point. By way of example, if a monitoring solution is running on CentOS 7 and trying to capture a process arguments and its environment variables, the emitted event could have too many argv and too many envp. Even in that case, you may miss some of them because the loop stops earlier. In these cases, the event data will be truncated. It’s important to note that these limitations are different based on the kernel where BPF is being run, and how the endpoint agent is written.</p>

<p>Another peculiarity of eBPFs is that they’ll drop events if they can not be consumed fast enough, instead of dragging down the performance of the entire system with it. An attacker could abuse this by generating a sufficient number of events to fill up the perf ringbuffer and overwrite data before the agent can read it.</p>

<h3 id="5-never-trust-the-userspace">5. Never trust the userspace</h3>
<p>The kernel-space understanding of a <code>pid</code> is not the same as the user-space understanding of a <code>pid</code>. If the eBPF script is trying to identify a file, the right way would be to get the inode number and device number, while a file descriptor won’t be as useful. Even in that case, probes could be subject to TOCTOU issues since they’ll be sending data to user mode that can easily change. If the script is instead tracing syscalls directly (using <code>tracepoint</code> or <code>kprobe</code>) it is probably stuck with file descriptors and it could be possible to obfuscate executions by playing around with the current working directory and file descriptors, (e.g., by combining <code>fchdir</code>, <code>openat</code>, and <code>execveat</code>).</p>

<h3 id="6-abuse-the-lack-of-seccomp-bpf--kernel-discrepancies">6. Abuse the lack of <code>seccomp-bpf</code> &amp; kernel discrepancies</h3>
<p>eBPF-based monitoring solutions should protect themselves by using <a href="https://www.kernel.org/doc/html/v4.19/userspace-api/seccomp_filter.html">seccomp-BPF</a> to permanently drop the ability to make the <code>bpf()</code> syscall before spawning a console session. If not, an attacker will have the ability to make the bpf() syscall to unload the eBPF programs used to track execution. Seccomp-BPF uses BPF programs to filter arbitrary system calls and their arguments (constants only, no pointer dereference).</p>

<p>Another thing to keep in mind when working with kernels, is that interfaces aren’t guaranteed to be consistent and stable. An attacker may abuse eBPF programs if they are not run on verified kernel versions. Usually, conditional compilation for a different architecture is very convoluted for these programs and you may find that the variant for your specific kernel is not targeted correctly. One common pitfall of using seccomp-BPF is filtering on system call numbers without checking the <code>seccomp_data-&gt;arch</code> <a href="https://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt">BPF program argument</a>. This is because on any architecture that supports multiple system call invocation conventions, the system call numbers may vary based on the specific invocation. If the numbers in the different calling conventions overlap, then checks in the filters may be abused. It is therefore important to ensure that the differences in <code>bpf()</code> invocations for each newly supported architecture are taken into account by the seccomp-BPF filter rules.</p>

<h3 id="7-interfere-with-the-agents">7. Interfere with the agents</h3>
<p>Similarly to (6), it may be possible to interfere with the eBPF program loading in different ways, such as targeting the eBPF compiler libraries (<a href="https://github.com/iovisor/bcc">BCC</a>’s <code>libbcc.so</code>) or adapting other shared libraries preloading methods to tamper with the behavior of legit binaries of the solution, ultimately performing harmful actions. In case an attacker succeeds in altering the solution’s host environment, they can add in front of the <code>LD_LIBRARY_PATH</code>, a directory where they saved a malicious library having the same <code>libbcc.so</code> name and exporting all the symbols used (to avoid a runtime linkage error). When the solution starts, instead of the legit bcc library, it gets linked with the malicious library. Defenses against this may include using statically linked programs, linking the library with the full path, or running the program into a controlled environment.</p>

<p>Many thanks to the whole <a href="https://goteleport.com/">Teleport Security Team</a>, <a href="https://tmpout.sh/2/4.html">@FridayOrtiz</a>, <a href="https://twitter.com/th3zer0">@Th3Zer0</a>, &amp; <a href="https://mobile.twitter.com/alessandrogario">@alessandrogario</a> for the inspiration and feedback while writing this blog post.</p>

</div>


    </div></div>
  </body>
</html>
