<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://florian.noeding.com/posts/risc-v-toy-cpu/cpu-from-scratch/">Original</a>
    <h1>How a CPU works: Bare metal C on my RISC-V toy CPU</h1>
    
    <div id="readability-page-1" class="page"><div>
        
        <p>I always wanted to understand how a CPU works, how it transitions from one instruction to the next and makes a computer work. So after reading <a href="https://www.righto.com/2022/11/a-bug-fix-in-8086-microprocessor.html">Ken Shirrif’s blog about a bug fix in the 8086 processor</a> I thought: Well, let’s try to write one in a hardware description language. This post is a write up of my learning experiment.</p>
<p>I’ll walk through my steps of creating an emulator, compiling and linking C for bare metal, CPU design and finally the implementation of my toy RISC-V CPU.</p>

<ul>
<li>implement a CPU in a hardware description language (HDL),</li>
<li>code must be synthesizable (except memory),</li>
<li>simulate it,</li>
<li>and run a bare metal C program on it.</li>
</ul>
<p>While I had plenty research time, I had only about 30 hours of development time. Without prior hardware design experience the goals had to be simple enough:</p>
<ul>
<li>RISC V Integer instruction set only (minus system and break calls),</li>
<li>no interrupt handling or other complexities,</li>
<li>no or only minimal optimizations.</li>
</ul>
<p>My test program written in C is Conway’s game of life, try the <a href="https://playgameoflife.com/lexicon/60P312">interactive web version</a>.</p>
<p>In a future iteration I plan to run my project on a real FPGA and implement a memory controller. Let’s say I made it to about 85% of what I wanted to achieve.</p>

<p>Writing an emulator, i.e. a program that can execute the instructions of a CPU, is an excellent stepping stone towards a hardware implementation. For me - without a hardware background - it is much easier to reason about and learn the instruction set.</p>
<p>So my first step was to understand the RISC V instruction set. The <a href="https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf">RISC V specification</a> is quite long, but I only needed chapters 2 (integer instruction set), 19 (RV32 / 64G instruction set listings) and 20 (assembly programmer’s handbook). These give detailed definitions of how each instruction must be executed, what kind of registers must be implemented, etc.</p>
<p>Let’s look at an example: Arithmetic / logical instructions operating on a register and an immediate value. For <code>ADDI</code> (add immediate) the following is done: <code>rd &lt;- rs1 + imm</code>: The register identified by rd is set to the sum of the value stored in register rs1 and the value given in the instruction itself.</p>
<p><img src="https://florian.noeding.com/posts/risc-v-toy-cpu/risc-v_integer_immediate.png" alt="Integer Register-Immediate Instructions"/></p>
<p>The emulator is implemented in C++ with a C-style interface in a shared library. This makes it easy to hook it into Python via <a href="https://cffi.readthedocs.io/en/latest/">cffi</a>. This saved me quite a bit of time for file system and user interactions, which were all done in Python.</p>
<div><pre tabindex="0"><code data-lang="C++"><span><span><span>struct</span> <span>RV32EmuState</span>;
</span></span><span><span>
</span></span><span><span><span>extern</span> <span>&#34;C&#34;</span> RV32EmuState<span>*</span> rv32emu_init();
</span></span><span><span><span>extern</span> <span>&#34;C&#34;</span> <span>void</span> rv32emu_free(RV32EmuState <span>*</span>state);
</span></span><span><span>
</span></span><span><span><span>extern</span> <span>&#34;C&#34;</span> <span>void</span> rv32emu_set_rom(RV32EmuState <span>*</span>state, <span>void</span> <span>*</span>data, <span>uint32_t</span> size);
</span></span><span><span><span>extern</span> <span>&#34;C&#34;</span> <span>void</span> rv32emu_read(RV32EmuState <span>*</span>state, <span>uint32_t</span> addr, <span>uint32_t</span> size, <span>void</span> <span>*</span>p);
</span></span><span><span>
</span></span><span><span><span>extern</span> <span>&#34;C&#34;</span> <span>int32_t</span> rv32emu_step(RV32EmuState <span>*</span>state);
</span></span><span><span><span>extern</span> <span>&#34;C&#34;</span> <span>int32_t</span> rv32emu_run(RV32EmuState <span>*</span>state, <span>uint32_t</span> <span>*</span>breakpoints, <span>uint32_t</span> num_breakpoints);
</span></span><span><span>
</span></span><span><span><span>extern</span> <span>&#34;C&#34;</span> <span>void</span> rv32emu_print(RV32EmuState <span>*</span>state);
</span></span></code></pre></div><p>The core of the emulator is the <code>rv32emu_step</code> function, which executes exactly one instruction and then returns. In RISC V each instruction is exactly 32 bits. It first decodes the op code (what kind of operation) and then the specific operation (e.g. ADD immediate). It’s a large, nested switch.</p>
<div><pre tabindex="0"><code data-lang="C++"><span><span><span>int32_t</span> <span>rv32emu_step</span>(RV32EmuState <span>*</span>state) {
</span></span><span><span>    <span>uint32_t</span> <span>*</span>instr_p <span>=</span> (<span>uint32_t</span><span>*</span>)(_get_pointer(state, state<span>-&gt;</span>pc));
</span></span><span><span>    <span>uint32_t</span> instr <span>=</span> <span>*</span>instr_p;
</span></span><span><span>
</span></span><span><span>    <span>// decode
</span></span></span><span><span><span></span>    <span>uint32_t</span> opcode <span>=</span> instr <span>&amp;</span> <span>0x7F</span>; <span>// instr[6..0]
</span></span></span><span><span><span></span>
</span></span><span><span>    <span>switch</span>(opcode) {
</span></span><span><span>        <span>//
</span></span></span><span><span><span></span>        <span>// ... all opcode types ...
</span></span></span><span><span><span></span>        <span>//
</span></span></span><span><span><span></span>        <span>case</span> OPCODE_OP_IMM: {
</span></span><span><span>            <span>uint32_t</span> funct3 <span>=</span> (instr <span>&gt;&gt;</span> <span>12</span>) <span>&amp;</span> <span>0x07</span>; <span>// instr[14..12]
</span></span></span><span><span><span></span>            <span>uint32_t</span> rs1 <span>=</span> ((instr <span>&gt;&gt;</span> <span>15</span>) <span>&amp;</span> <span>0x1F</span>);
</span></span><span><span>
</span></span><span><span>            <span>uint32_t</span> imm <span>=</span> (instr <span>&gt;&gt;</span> <span>20</span>) <span>&amp;</span> <span>0x0FFF</span>; <span>// 12 bits
</span></span></span><span><span><span></span>            <span>uint32_t</span> imm_sign <span>=</span> instr <span>&amp;</span> (<span>1ul</span> <span>&lt;&lt;</span> <span>31</span>);
</span></span><span><span>            <span>if</span>(imm_sign) {
</span></span><span><span>                imm <span>|=</span> <span>0xFFFFF000</span>;
</span></span><span><span>            }
</span></span><span><span>
</span></span><span><span>            <span>uint32_t</span> data1 <span>=</span> state<span>-&gt;</span>reg[rs1];
</span></span><span><span>            <span>uint32_t</span> data2 <span>=</span> imm;
</span></span><span><span>            <span>uint32_t</span> reg_dest <span>=</span> (instr <span>&gt;&gt;</span> <span>7</span>) <span>&amp;</span> <span>0x1F</span>;
</span></span><span><span>            <span>if</span>(reg_dest <span>!=</span> <span>0</span>) { <span>// register 0 is always zero and never written too
</span></span></span><span><span><span></span>                <span>switch</span>(funct3) {
</span></span><span><span>                    <span>//
</span></span></span><span><span><span></span>                    <span>// ... all OP_IMM instructions ...
</span></span></span><span><span><span></span>                    <span>//
</span></span></span><span><span><span></span>                    <span>case</span> FUNCT3_OP_ADD: {
</span></span><span><span>                        state<span>-&gt;</span>reg[reg_dest] <span>=</span> data1 <span>+</span> data2;
</span></span><span><span>                        <span>break</span>;
</span></span><span><span>                    }
</span></span><span><span>                }
</span></span><span><span>            }
</span></span><span><span>            <span>break</span>;
</span></span><span><span>        }
</span></span><span><span>
</span></span><span><span>    <span>// ...
</span></span></span><span><span><span></span>
</span></span><span><span>    state<span>-&gt;</span>pc <span>+=</span> <span>4</span>; <span>// go to next instruction for non-jump / non-branch
</span></span></span><span><span><span></span>    <span>return</span> <span>0</span>;
</span></span><span><span>}
</span></span></code></pre></div><p>The mathematical and logical operations are simplest to implement, so I started with them. Iteratively I’ve added branches, jumps and the remaining logic until I had covered all instructions other than <code>ECALL</code> and <code>EBREAK</code>. These two were not necessary for my bare metal experiment.</p>
<p>For testing I relied on simple hand-written assembly code. Of course this did not exercise my emulator thoroughly. So as a next step I wanted to finally run my Conway’s game of life simulation.</p>

<p>Going from C to a bare metal CPU takes a few steps: cross compile, ensure proper memory layout and converting the ELF file to a binary blob. Also instead of having a <code>main</code> function my code has a <code>_start</code> function defined as follows:</p>
<div><pre tabindex="0"><code data-lang="C"><span><span><span>void</span> <span>__attribute__</span>((section (<span>&#34;.text.boot&#34;</span>))) _start() {
</span></span><span><span>    run(); <span>// call the actual &#34;entrypoint&#34;
</span></span></span><span><span><span></span>}
</span></span></code></pre></div><p>I’ll explain the details later.</p>
<p>My CPU only supports the RISC-V 32 bit integer instruction set, but my host system is running on x86-64. So I needed a cross compiler and used the Ubuntu package <code>gcc-riscv64-unknown-elf</code>. Then I could compile my code using the following command:</p>
<div><pre tabindex="0"><code data-lang="sh"><span><span>riscv64-unknown-elf-gcc -march<span>=</span>rv32i -mabi<span>=</span>ilp32 <span>\
</span></span></span><span><span><span></span>    -nostdlib -ffreestanding -Tprograms/memory_map.ld <span>\
</span></span></span><span><span><span></span>    -o life.rv32.elf life.c
</span></span></code></pre></div><p>Let’s take this apart:</p>
<ol>
<li>execute the RISC-V cross-compiler</li>
<li>set it’s architecture to rv32i, which is RISC-V 32bit integer instruction set</li>
<li>define the application binary interface, i.e. conventions how to emit assembly. This makes it so that integers, longs and pointers are 32 bit
<ul>
<li>these three are needed to emit code compatible with my emulator and later CPU</li>
</ul>
</li>
<li>compile without a standard library
<ul>
<li>Standard libraries like the system libc assume operating system support, but my toy CPU will be running bare metal. So we have to switch that off. This means we won’t have access to <code>malloc</code>, <code>printf</code>, <code>puts</code> etc. Instead we’ll need to implement this ourselves, if we want to use it. This means we have no startup code either.</li>
</ul>
</li>
<li>compile freestanding, that is, do not assume presence of a operating system or library and switch of libc specific optimizations and defaults
<ul>
<li>for example we won’t have a main function, which is otherwise required</li>
</ul>
</li>
<li>use a memory map
<ul>
<li>we need to tell the compiler and linker where instructions and global variables will be placed in memory. We do not have a loader to do this at application startup</li>
</ul>
</li>
</ol>
<p>Even though we do not yet have any hardware, we must make a few decisions for item 6: how should our address space look like?</p>
<ul>
<li>program execution starts at 0x1000, which below I’ll call rom for read-only-memory</li>
<li>memory for globals, stack variables and heap will be located at 0x10000000</li>
</ul>
<p>These values are kind of arbitrary. I wanted to avoid having code at address zero to avoid issues with NULL pointers. This script also ensures that our program entry point, the function <code>_start</code> is placed at 0x1000, so that the emulator will execute that code first. Here’s my linker script for my address space setup:</p>
<div><pre tabindex="0"><code data-lang="C"><span><span>ENTRY(_start)
</span></span><span><span>
</span></span><span><span>MEMORY
</span></span><span><span>{
</span></span><span><span>    rom (rx )<span>:</span> ORIGIN <span>=</span> <span>0x00001000</span>, LENGTH <span>=</span> <span>16</span>M
</span></span><span><span>    ram (rw)<span>:</span> ORIGIN <span>=</span> <span>0x10000000</span>, LENGTH <span>=</span> <span>32</span>M
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span>SECTIONS
</span></span><span><span>{
</span></span><span><span>    .text : {
</span></span><span><span>        <span>/*
</span></span></span><span><span><span>            entry point is expected to be the first function here
</span></span></span><span><span><span>            --&gt; we are assuming there&#39;s only a single function in the .text.boot segment and by convention that is &#34;_start&#34;
</span></span></span><span><span><span>
</span></span></span><span><span><span>            KEEP ensures that &#34;_start&#34; is kept here, even if there are no references to it
</span></span></span><span><span><span>        */</span>
</span></span><span><span>        KEEP(<span>*</span>(.text.boot))
</span></span><span><span>
</span></span><span><span>        <span>/*
</span></span></span><span><span><span>            all other code follows
</span></span></span><span><span><span>        */</span>
</span></span><span><span>        <span>*</span>(.text<span>*</span>)
</span></span><span><span>    } <span>&gt;</span> rom
</span></span><span><span>
</span></span><span><span>    .rodata : { <span>*</span>(.rodata<span>*</span>) } <span>&gt;</span> rom
</span></span><span><span>
</span></span><span><span>    .bss : { <span>*</span>(.bss<span>*</span>) } <span>&gt;</span> ram
</span></span><span><span>}
</span></span></code></pre></div><p>After compilation we can check that <code>_start</code> is actually at 0x1000:</p>
<div><pre tabindex="0"><code data-lang="sh"><span><span>riscv64-unknown-elf-readelf -s life.rv32.elf | grep <span>&#39;_start$$&#39;</span>
</span></span></code></pre></div><p>Now the “problem” is that gcc generates an <a href="https://wiki.osdev.org/ELF">ELF</a> and not just a stream of instructions. The Executable and Linkable Format is simplified a container to store executable code, data and metadata in a way that makes it easy to later load into memory. As specified by the memory map like the one above. Since my program is fairly it simple does not need memory initialization. So we can simply dump the RISC-V instructions from the .text segment into a binary file.</p>
<div><pre tabindex="0"><code data-lang="sh"><span><span>riscv64-unknown-elf-objdump -O binary life.rv32.elf life.rv32.bin
</span></span></code></pre></div><p>So now the C snippet from above should make more sense:</p>
<div><pre tabindex="0"><code data-lang="C"><span><span><span>void</span> <span>__attribute__</span>((section (<span>&#34;.text.boot&#34;</span>))) _start() {
</span></span><span><span>    run();
</span></span><span><span>}
</span></span></code></pre></div><p>We are defining a function <code>_start</code> which should go into the segment <code>.text.boot</code>. The linker script instructs the toolchain to make sure this code is placed at 0x1000, even when no other code references it. By having exactly one function in <code>.text.boot</code> this is guaranteed to happen.</p>
<p>Turns out this is still not enough to make the code work. The startup code above does not initialize the stack pointer, i.e. where local variables live in memory. I decided to simplify things and hard-code the initial stack pointer value in my emulator and CPU. This means simply setting register <code>x2</code> also known as <code>sp</code> to the end of the memory, here 0x12000000.</p>
<p>A couple other registers defined in the ABI with special purpose are not used by my program, so I did not implement support: global pointer <code>gp</code> and thread pointer <code>tp</code>.</p>

<p>When the program is running on my host I rely on the standard library for memory allocation like <code>malloc</code> or <code>putchar</code> for output. But when running bare metal these functions are not available.</p>
<p>I’ve replaced dynamic memory allocation with static memory assignments. Since my program is the only one running on CPU, I can use all resources how I see fit. If the flag <code>FREESTANDING</code> is set, when the program is compiled for my RISC-V emulator / CPU. Without it, the program can run as-is on my host system like any other program.</p>
<div><pre tabindex="0"><code data-lang="C"><span><span><span>void</span> <span>run</span>() {
</span></span><span><span>    <span>#ifdef FREESTANDING
</span></span></span><span><span><span></span>        map0 <span>=</span> (<span>unsigned</span> <span>char</span><span>*</span>)<span>0x10080000</span>;                              <span>// gamestate
</span></span></span><span><span><span></span>        map1 <span>=</span> map0 <span>+</span> <span>0x80000</span>;                                          <span>// new gamestate
</span></span></span><span><span><span></span>        leds <span>=</span> map1 <span>+</span> <span>0x80000</span>;                                          <span>// output for emulator
</span></span></span><span><span><span></span>    <span>#else
</span></span></span><span><span><span></span>        map0 <span>=</span> (<span>unsigned</span> <span>char</span><span>*</span>)malloc((WIDTH <span>+</span> <span>2</span>) <span>*</span> (HEIGHT <span>+</span> <span>2</span>));
</span></span><span><span>        map1 <span>=</span> (<span>unsigned</span> <span>char</span><span>*</span>)malloc((WIDTH <span>+</span> <span>2</span>) <span>*</span> (HEIGHT <span>+</span> <span>2</span>));
</span></span><span><span>    <span>#endif
</span></span></span><span><span><span></span>
</span></span><span><span>    <span>// ...
</span></span></span><span><span><span></span>}
</span></span></code></pre></div><p>Instead of relying on <code>putchar</code> for output to the console, my program assumes that the address of the variable <code>leds</code> is memory-mapped to an external LED array. In case of the emulator, it will simply read this memory area and display it on console. When running in the simulator (or FPGA in the next iteration), the memory controller will set output pins accordingly.</p>

<p>Here’s the result of all of that work: First setting a breakpoint for each game of life cycle, and then manually stepping through the program on the emulated CPU.</p>
<p>Best viewed in full-screen mode due to web-unfriendly layout.</p>

    
    







<p>With the emulator completed I now have a working reference system to debug my CPU. And so I started working implementing it.</p>
<p>A simple CPU consists of the following components:</p>
<ul>
<li>Arithmetic Logic Unit (ALU): the compute part, for operations like “add” or “xor”</li>
<li>Register File: provides and stores register values</li>
<li>Decoder: transform instruction to a set of control signals, controlling the CPU operation</li>
<li>Program Counter: manages the address where the next instruction is found</li>
<li>Load Store Unit (LSU): connects the CPU to its memory</li>
<li>Control Unit: tieing all the parts together to form a CPU</li>
</ul>
<p>These are the basic elements of a CPU and sufficient for my toy RISC-V implementation.</p>

<p>Hardware is designed with special programming languages, called hardware description languages (HDL). The most common ones are Verilog and VHDL. For my project I decided to use <a href="https://github.com/amaranth-lang/amaranth">Amaranth HDL</a>, because it’s higher level and easier to use - plus it’s written in my favorite language Python. Simplified it enables an engineer to describe a program in Python that generates a hardware description, instead of directly describing it directly in Verilog or VHDL. A nice property of Amaranth HDL is that by design the resulting programs are synthesizable, i.e. they can be “compiled” into a description executable in FPGAs or built as an ASIC.</p>
<p>A key difference between software and hardware is concurrency: In software code is executed line by line, in order and we need special constructs like threads to achieve parallelism. In hardware it’s different: Everything is happening at the same time. We are not describing high-level operations, but rather how logic gates are connected to each other.</p>
<h2 id="combinational-logic">
  Combinational logic
  <a href="#combinational-logic">
    <i aria-hidden="true"></i>
  </a>
</h2>
<p>There are two key concepts in hardware: combinational logic (sometimes also called combinatorial logic) and synchronous logic. Simplified combinational logic executes all the time and all at the same time. In the following example green are input signals, yellow are internal signals (output of logic and input to the next logic), blue is logic and orange is the final output signal:</p>
<p>
    
graph LR
    count_1((signal: count 1)) --&gt; adder1[[logic: Adder]]
    count_2((signal: count 2)) --&gt; adder1
    adder1 --&gt; sum((signal: temp sum))
    sum --&gt; adder2[[logic: Adder]]
    count_3((signal: count 3)) --&gt; adder2
    adder2 --&gt; output((signal: result))

    style count_1 fill:#7e6,stroke:#333,stroke-width:1px
    style count_2 fill:#7e6,stroke:#333,stroke-width:1px
    style count_3 fill:#7e6,stroke:#333,stroke-width:1px

    style adder1 fill:#5ae,stroke:#333,stroke-width:1px
    style adder2 fill:#5ae,stroke:#333,stroke-width:1px

    style sum fill:#ee3,stroke:#333,stroke-width:1px
    style output fill:#e90,stroke:#333,stroke-width:1px

</p>
<p>Combinational logic always updates its output immediately when any input changes. There are a couple physical limitations here, but we’ll simplify this for now. This means changing any signal will immediately change the output signal <code>sum</code>.</p>
<p>In Amaranth we can implement this as</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span># to run tests: python3 -m pytest add3.py</span>
</span></span><span><span>
</span></span><span><span><span>import</span> pytest
</span></span><span><span>
</span></span><span><span><span>from</span> amaranth <span>import</span> Signal, Module, Elaboratable
</span></span><span><span><span>from</span> amaranth.build <span>import</span> Platform
</span></span><span><span><span>from</span> amaranth.sim <span>import</span> Simulator, Settle
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>class</span> <span>Add3Comb</span>(Elaboratable):
</span></span><span><span>    <span>def</span> __init__(self):
</span></span><span><span>        self<span>.</span>count_1 <span>=</span> Signal(<span>32</span>)
</span></span><span><span>        self<span>.</span>count_2 <span>=</span> Signal(<span>32</span>)
</span></span><span><span>        self<span>.</span>count_3 <span>=</span> Signal(<span>32</span>)
</span></span><span><span>        self<span>.</span>result <span>=</span> Signal(<span>32</span>)
</span></span><span><span>
</span></span><span><span>    <span>def</span> <span>elaborate</span>(self, _: Platform) <span>-&gt;</span> Module:
</span></span><span><span>        m <span>=</span> Module()
</span></span><span><span>
</span></span><span><span>        <span># technically this is not needed: a second `+` below would do</span>
</span></span><span><span>        <span>#     but let&#39;s build the circuit exactly as shown above</span>
</span></span><span><span>        temp_sum <span>=</span> Signal(<span>32</span>)
</span></span><span><span>
</span></span><span><span>        <span># define how our logic works</span>
</span></span><span><span>        m<span>.</span>d<span>.</span>comb <span>+=</span> temp_sum<span>.</span>eq(self<span>.</span>count_1 <span>+</span> self<span>.</span>count_2)
</span></span><span><span>        m<span>.</span>d<span>.</span>comb <span>+=</span> self<span>.</span>result<span>.</span>eq(self<span>.</span>count_3 <span>+</span> temp_sum)
</span></span><span><span>
</span></span><span><span>        <span>return</span> m
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>test_add3comb</span>():
</span></span><span><span>    <span># set up our device under test</span>
</span></span><span><span>    dut <span>=</span> Add3Comb()
</span></span><span><span>
</span></span><span><span>    <span>def</span> <span>bench</span>():
</span></span><span><span>        <span># set inputs to defined values</span>
</span></span><span><span>        <span>yield</span> dut<span>.</span>count_1<span>.</span>eq(<span>7</span>)
</span></span><span><span>        <span>yield</span> dut<span>.</span>count_2<span>.</span>eq(<span>14</span>)
</span></span><span><span>        <span>yield</span> dut<span>.</span>count_3<span>.</span>eq(<span>21</span>)
</span></span><span><span>
</span></span><span><span>        <span># let the simulation settle down, i.e. arrive at a defined state</span>
</span></span><span><span>        <span>yield</span> Settle()
</span></span><span><span>
</span></span><span><span>        <span># check that the sum is the expected value</span>
</span></span><span><span>        <span>assert</span> (<span>yield</span> dut<span>.</span>result) <span>==</span> <span>42</span>
</span></span><span><span>
</span></span><span><span>    sim <span>=</span> Simulator(dut)
</span></span><span><span>    sim<span>.</span>add_process(bench)
</span></span><span><span>    sim<span>.</span>run()
</span></span></code></pre></div><p>The key takeaway here is that the lines</p>
<div><pre tabindex="0"><code data-lang="python"><span><span>        m<span>.</span>d<span>.</span>comb <span>+=</span> temp_sum<span>.</span>eq(self<span>.</span>count_1 <span>+</span> self<span>.</span>count_2)
</span></span><span><span>        m<span>.</span>d<span>.</span>comb <span>+=</span> self<span>.</span>result<span>.</span>eq(self<span>.</span>count_3 <span>+</span> temp_sum)
</span></span></code></pre></div><p>are executed at the same time and also whenever the inputs change.</p>
<h2 id="synchronous-logic">
  Synchronous Logic
  <a href="#synchronous-logic">
    <i aria-hidden="true"></i>
  </a>
</h2>
<p>There’s a second kind of commonly used logic: synchronous logic. The difference to combinational logic is that outputs only change on a clock edge. I.e. when the clock signal goes from low to high (positive edge) or vice versa (negative edge). Let’s use the adder example again. Colors as before, but we’ll use turquoise for synchronous logic.</p>
<p>
    
graph LR
    count_1((signal: count 1)) --&gt; adder1[[logic: Adder]]
    count_2((signal: count 2)) --&gt; adder1
    adder1 --&gt; sum((signal: temp sum))
    sum --&gt; adder2[[logic: Adder]]
    count_3((signal: count 3)) --&gt; adder2
    adder2 --&gt; output((signal: result))

    clock((signal: clock)) --&gt; adder1
    clock --&gt; adder2

    style count_1 fill:#7e6,stroke:#333,stroke-width:1px
    style count_2 fill:#7e6,stroke:#333,stroke-width:1px
    style count_3 fill:#7e6,stroke:#333,stroke-width:1px
    style clock fill:#7e6,stroke:#333,stroke-width:1px

    style adder1 fill:#0ff,stroke:#333,stroke-width:1px
    style adder2 fill:#0ff,stroke:#333,stroke-width:1px

    style sum fill:#ee3,stroke:#333,stroke-width:1px
    style output fill:#e90,stroke:#333,stroke-width:1px

</p>
<p>We use positive edge triggered logic here. So unless the clock goes from low to high, both <code>temp sum</code> and <code>result</code> will never change. The following table shows how values change. Let’s furthermore assume the logic was just resetted, so outputs start at 0.</p>
<table>
<thead>
<tr>
<th>signal / time</th>
<th>t=0</th>
<th>t=1</th>
<th>t=2</th>
<th>t=3</th>
</tr>
</thead>
<tbody>
<tr>
<td>clock</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>count_1</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
</tr>
<tr>
<td>count_2</td>
<td>14</td>
<td>14</td>
<td>14</td>
<td>14</td>
</tr>
<tr>
<td>count_3</td>
<td>21</td>
<td>21</td>
<td>21</td>
<td>21</td>
</tr>
<tr>
<td>temp_sum</td>
<td>0</td>
<td><strong>21</strong></td>
<td>21</td>
<td>21</td>
</tr>
<tr>
<td>result</td>
<td>0</td>
<td><strong>21</strong></td>
<td>21</td>
<td><strong>42</strong></td>
</tr>
</tbody>
</table>
<p>Changes highlighted in bold. This circuit takes on the expected value only after two full clock cycles. Even if the input signals are not defined in the time period after a positive edge and the next positive edge, this will not change the output in any way</p>
<table>
<thead>
<tr>
<th>signal / time</th>
<th>t=0</th>
<th>t=1</th>
<th>t=2</th>
<th>t=3</th>
</tr>
</thead>
<tbody>
<tr>
<td>clock</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>count_1</td>
<td>7</td>
<td>7</td>
<td><strong>0</strong></td>
<td>7</td>
</tr>
<tr>
<td>count_2</td>
<td>14</td>
<td>14</td>
<td><strong>0</strong></td>
<td>14</td>
</tr>
<tr>
<td>temp_sum</td>
<td></td>
<td><strong>21</strong></td>
<td>21</td>
<td>21</td>
</tr>
</tbody>
</table>
<p>Physically things are more complex (“delta time”) and this results in interesting tradeoffs between the length of combinational logic paths (number of gates, circuit length) and the attainable clock speed. Luckily this does not matter for my toy CPU.</p>
<p>In Amaranth we can implement this as</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>class</span> <span>Add3Sync</span>(Elaboratable):
</span></span><span><span>    <span>def</span> __init__(self):
</span></span><span><span>        self<span>.</span>sync <span>=</span> ClockDomain(<span>&#34;sync&#34;</span>)
</span></span><span><span>        self<span>.</span>count_1 <span>=</span> Signal(<span>32</span>)
</span></span><span><span>        self<span>.</span>count_2 <span>=</span> Signal(<span>32</span>)
</span></span><span><span>        self<span>.</span>count_3 <span>=</span> Signal(<span>32</span>)
</span></span><span><span>        self<span>.</span>result <span>=</span> Signal(<span>32</span>)
</span></span><span><span>
</span></span><span><span>    <span>def</span> <span>elaborate</span>(self, _: Platform) <span>-&gt;</span> Module:
</span></span><span><span>        m <span>=</span> Module()
</span></span><span><span>
</span></span><span><span>        temp_sum <span>=</span> Signal(<span>32</span>)
</span></span><span><span>
</span></span><span><span>        <span># define how our logic works</span>
</span></span><span><span>        m<span>.</span>d<span>.</span>sync <span>+=</span> temp_sum<span>.</span>eq(self<span>.</span>count_1 <span>+</span> self<span>.</span>count_2)
</span></span><span><span>        m<span>.</span>d<span>.</span>sync <span>+=</span> self<span>.</span>result<span>.</span>eq(self<span>.</span>count_3 <span>+</span> temp_sum)
</span></span><span><span>
</span></span><span><span>        <span>return</span> m
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>test_add3sync</span>():
</span></span><span><span>    <span># set up our device under test</span>
</span></span><span><span>    dut <span>=</span> Add3Sync()
</span></span><span><span>
</span></span><span><span>    <span>def</span> <span>bench</span>():
</span></span><span><span>        <span># set inputs to defined values</span>
</span></span><span><span>        <span>yield</span> dut<span>.</span>count_1<span>.</span>eq(<span>7</span>)
</span></span><span><span>        <span>yield</span> dut<span>.</span>count_2<span>.</span>eq(<span>14</span>)
</span></span><span><span>        <span>yield</span> dut<span>.</span>count_3<span>.</span>eq(<span>21</span>)
</span></span><span><span>
</span></span><span><span>        <span># let the simulation settle down, i.e. arrive at a defined state</span>
</span></span><span><span>        <span>yield</span> Settle()
</span></span><span><span>
</span></span><span><span>        <span># no positive edge yet, so still at reset value</span>
</span></span><span><span>        <span>assert</span> (<span>yield</span> dut<span>.</span>result) <span>==</span> <span>0</span>
</span></span><span><span>
</span></span><span><span>        <span># trigger a positive edge on the clock and wait for things to settle down</span>
</span></span><span><span>        <span>yield</span> Tick()
</span></span><span><span>        <span>yield</span> Settle()
</span></span><span><span>
</span></span><span><span>        <span># count3 is reflect in output, since temp sum is still zero</span>
</span></span><span><span>        <span>assert</span> (<span>yield</span> dut<span>.</span>result) <span>==</span> <span>21</span>
</span></span><span><span>
</span></span><span><span>        <span>yield</span> Tick()
</span></span><span><span>        <span>yield</span> Settle()
</span></span><span><span>
</span></span><span><span>        <span># now both count3 and temp sum will be reflected in the output</span>
</span></span><span><span>        <span>assert</span> (<span>yield</span> dut<span>.</span>result) <span>==</span> <span>42</span>
</span></span><span><span>
</span></span><span><span>    sim <span>=</span> Simulator(dut)
</span></span><span><span>    sim<span>.</span>add_process(bench)
</span></span><span><span>    sim<span>.</span>add_clock(<span>1e-6</span>)
</span></span><span><span>    sim<span>.</span>run()
</span></span></code></pre></div>
<p>Armed with this knowledge I figured out which things needed to happen in parallel and which things in sequence.</p>
<p>So if we have an ALU related instruction it would work like this:</p>
<ol>
<li>in parallel
<ul>
<li>read instruction from ROM at the instruction address,</li>
<li>decode the instruction,</li>
<li>read register values and if present immediate value,</li>
<li>compute the result in the ALU,</li>
<li>assign ALU result to destination register (not yet visible!)</li>
<li>increment instruction address by 4 bytes (not yet visible!)</li>
</ul>
</li>
<li>wait for positive clock edge, giving step 1 time to settle, and in the following instant
<ul>
<li>update instruction address, making the new value visible</li>
<li>update destination register value, making the new value visible</li>
</ul>
</li>
<li>repeat, starting at 1.</li>
</ol>
<p>Iteratively creating a diagrams of how things should work was immensely helpful. Below is a simplified version of my CPU design, though it lacks many of the control signals and special cases for operations related to jumping and branching. Please view in full screen mode, where you can also toggle ALU or LSU layers to make it easier to read. Colors here are just to help with readability of the diagram.</p>




<p>Now let’s talk about the CPU components in detail. Designing them reminded me a lot about functional programming, where the parameters of a function and types naturally guide the implementation. All necessary details about the RISC-V instruction set are specified in detail in the <a href="https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf">spec</a>.</p>
<h2 id="alu">
  ALU
  <a href="#alu">
    <i aria-hidden="true"></i>
  </a>
</h2>
<p>Compute <code>data1 $OPERATION data2</code>. I decided to merge the branch unit into the ALU, so there’s a branch for <code>is_branch</code>.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>class</span> <span>ALU</span>(Elaboratable):
</span></span><span><span>    <span>def</span> __init__(self):
</span></span><span><span>        <span># if set to 0, then normal ALU operation,</span>
</span></span><span><span>        <span>#     otherwise treat funct3 as branch condition operator</span>
</span></span><span><span>        self<span>.</span>i_is_branch <span>=</span> Signal(<span>1</span>)
</span></span><span><span>
</span></span><span><span>        <span># operation, e.g. &#34;add&#34; or &#34;xor&#34;, from decoder</span>
</span></span><span><span>        self<span>.</span>i_funct3 <span>=</span> Signal(<span>3</span>)
</span></span><span><span>
</span></span><span><span>        <span># sub-operation, e.g. &#34;sub&#34; for &#34;add&#34;, from decodert</span>
</span></span><span><span>        self<span>.</span>i_funct7 <span>=</span> Signal(<span>7</span>)
</span></span><span><span>
</span></span><span><span>        <span># value of register 1</span>
</span></span><span><span>        self<span>.</span>i_data1 <span>=</span> SignedSignal(<span>32</span>)
</span></span><span><span>
</span></span><span><span>        <span># value of register 2 or immediate</span>
</span></span><span><span>        self<span>.</span>i_data2 <span>=</span> SignedSignal(<span>32</span>)
</span></span><span><span>
</span></span><span><span>        <span># computation result</span>
</span></span><span><span>        self<span>.</span>o_result <span>=</span> SignedSignal(<span>32</span>)
</span></span><span><span>
</span></span><span><span>    <span>def</span> <span>elaborate</span>(self, _: Platform) <span>-&gt;</span> Module:
</span></span><span><span>        m <span>=</span> Module()
</span></span><span><span>
</span></span><span><span>        <span># this ALU also implements branch logic</span>
</span></span><span><span>        <span>with</span> m<span>.</span>If(self<span>.</span>i_is_branch <span>==</span> <span>0</span>):
</span></span><span><span>            <span># normal ALU</span>
</span></span><span><span>            <span>with</span> m<span>.</span>Switch(self<span>.</span>i_funct3):
</span></span><span><span>                <span>with</span> m<span>.</span>Case(FUNCT3_OP_XOR):
</span></span><span><span>                    m<span>.</span>d<span>.</span>comb <span>+=</span> self<span>.</span>o_result<span>.</span>eq(self<span>.</span>i_data1 <span>^</span> self<span>.</span>i_data2)
</span></span><span><span>                <span>with</span> m<span>.</span>Case(FUNCT3_OP_SLL):
</span></span><span><span>                    shift_amount <span>=</span> self<span>.</span>i_data2[<span>0</span>:<span>5</span>]
</span></span><span><span>                    m<span>.</span>d<span>.</span>comb <span>+=</span> self<span>.</span>o_result<span>.</span>eq(
</span></span><span><span>                        self<span>.</span>i_data1<span>.</span>as_unsigned() <span>&lt;&lt;</span> shift_amount)
</span></span><span><span>                <span># ...</span>
</span></span></code></pre></div><p>In this snippet you can see how Amaranth is really a code generator: Instead of using the normal <code>switch</code> and <code>if</code> statements, which control Python flow, you have to use the <code>m.Switch</code> etc. methods on the module.</p>
<h2 id="decoder">
  Decoder
  <a href="#decoder">
    <i aria-hidden="true"></i>
  </a>
</h2>
<p>Provide all necessary signals to control execution.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>class</span> <span>InstructionDecoder</span>(Elaboratable):
</span></span><span><span>    <span>def</span> __init__(self):
</span></span><span><span>        self<span>.</span>i_instruction <span>=</span> Signal(<span>32</span>)
</span></span><span><span>        self<span>.</span>i_instruction_address <span>=</span> Signal(<span>32</span>)
</span></span><span><span>
</span></span><span><span>        <span># select signals for register file</span>
</span></span><span><span>        self<span>.</span>o_rs1 <span>=</span> Signal(<span>5</span>)
</span></span><span><span>        self<span>.</span>o_rs2 <span>=</span> Signal(<span>5</span>)
</span></span><span><span>        self<span>.</span>o_rd <span>=</span> Signal(<span>5</span>)
</span></span><span><span>        self<span>.</span>o_rd_we <span>=</span> Signal(<span>1</span>)
</span></span><span><span>
</span></span><span><span>        <span># ALU / LSU operations</span>
</span></span><span><span>        self<span>.</span>o_funct3 <span>=</span> Signal(<span>3</span>)
</span></span><span><span>        self<span>.</span>o_funct7 <span>=</span> Signal(<span>7</span>)
</span></span><span><span>
</span></span><span><span>        <span># immediate value</span>
</span></span><span><span>        self<span>.</span>o_imm <span>=</span> SignedSignal(<span>32</span>)
</span></span><span><span>
</span></span><span><span>        <span># control signals</span>
</span></span><span><span>        self<span>.</span>o_invalid <span>=</span> Signal(<span>1</span>)
</span></span><span><span>        self<span>.</span>o_has_imm <span>=</span> Signal(<span>1</span>)
</span></span><span><span>        self<span>.</span>o_is_branch <span>=</span> Signal(<span>1</span>)
</span></span><span><span>        self<span>.</span>o_is_memory <span>=</span> Signal(<span>2</span>)
</span></span><span><span>
</span></span><span><span>    <span>def</span> <span>elaborate</span>(self, _: Platform) <span>-&gt;</span> Module:
</span></span><span><span>        m <span>=</span> Module()
</span></span><span><span>
</span></span><span><span>        m<span>.</span>d<span>.</span>comb <span>+=</span> self<span>.</span>o_invalid<span>.</span>eq(<span>0</span>)
</span></span><span><span>        m<span>.</span>d<span>.</span>comb <span>+=</span> self<span>.</span>o_is_branch<span>.</span>eq(<span>0</span>)
</span></span><span><span>
</span></span><span><span>        opcode <span>=</span> self<span>.</span>i_instruction[<span>0</span>:<span>7</span>]
</span></span><span><span>
</span></span><span><span>        <span>with</span> m<span>.</span>Switch(opcode):
</span></span><span><span>            <span>with</span> m<span>.</span>Case(OPCODE_OP_IMM):
</span></span><span><span>                <span># rd = rs1 $OP imm</span>
</span></span><span><span>                <span># use ALU with immediate</span>
</span></span><span><span>                m<span>.</span>d<span>.</span>comb <span>+=</span> [
</span></span><span><span>                    self<span>.</span>o_rd<span>.</span>eq(self<span>.</span>i_instruction[<span>7</span>:<span>12</span>]),
</span></span><span><span>                    self<span>.</span>o_rd_we<span>.</span>eq(<span>1</span>),
</span></span><span><span>                    self<span>.</span>o_funct3<span>.</span>eq(self<span>.</span>i_instruction[<span>12</span>:<span>15</span>]),
</span></span><span><span>                    self<span>.</span>o_rs1<span>.</span>eq(self<span>.</span>i_instruction[<span>15</span>:<span>20</span>]),
</span></span><span><span>                    self<span>.</span>o_rs2<span>.</span>eq(<span>0</span>),
</span></span><span><span>                    self<span>.</span>o_imm<span>.</span>eq(self<span>.</span>i_instruction[<span>20</span>:<span>32</span>]),
</span></span><span><span>                    self<span>.</span>o_has_imm<span>.</span>eq(<span>1</span>),
</span></span><span><span>                    self<span>.</span>o_funct7<span>.</span>eq(<span>0</span>),
</span></span><span><span>                ]
</span></span><span><span>            <span># ...</span>
</span></span></code></pre></div><h2 id="register-file">
  Register File
  <a href="#register-file">
    <i aria-hidden="true"></i>
  </a>
</h2>
<p>Implement 32 registers. Special case: register <code>x0</code> is hard-wired to zero, by not allowing writes to it.</p>
<p>I’m not sure if this is the best implementation, but it works well in simulation so far.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>class</span> <span>RegisterFile</span>(Elaboratable):
</span></span><span><span>    <span>def</span> __init__(self):
</span></span><span><span>        self<span>.</span>sync <span>=</span> ClockDomain(<span>&#34;sync&#34;</span>)
</span></span><span><span>
</span></span><span><span>        self<span>.</span>i_select_rs1 <span>=</span> Signal(<span>5</span>)
</span></span><span><span>        self<span>.</span>i_select_rs2 <span>=</span> Signal(<span>5</span>)
</span></span><span><span>        self<span>.</span>i_select_rd <span>=</span> Signal(<span>5</span>)
</span></span><span><span>
</span></span><span><span>        self<span>.</span>i_we <span>=</span> Signal(<span>1</span>)
</span></span><span><span>        self<span>.</span>i_data <span>=</span> SignedSignal(<span>32</span>)
</span></span><span><span>
</span></span><span><span>        self<span>.</span>o_rs1_value <span>=</span> SignedSignal(<span>32</span>)
</span></span><span><span>        self<span>.</span>o_rs2_value <span>=</span> SignedSignal(<span>32</span>)
</span></span><span><span>
</span></span><span><span>        self<span>.</span>registers <span>=</span> Signal(<span>32</span> <span>*</span> <span>32</span>)
</span></span><span><span>
</span></span><span><span>        self<span>.</span>ports <span>=</span> [self<span>.</span>sync, self<span>.</span>i_select_rs1, self<span>.</span>i_select_rs2, self<span>.</span>i_select_rd, self<span>.</span>i_data, self<span>.</span>i_we]
</span></span><span><span>
</span></span><span><span>    <span>def</span> <span>elaborate</span>(self, _: Platform) <span>-&gt;</span> Module:
</span></span><span><span>        <span>&#34;&#34;&#34;
</span></span></span><span><span><span>        on clock edge if i_we is set: stores i_data at reg[i_select_rd]
</span></span></span><span><span><span>        combinationally returns register values
</span></span></span><span><span><span>        &#34;&#34;&#34;</span>
</span></span><span><span>
</span></span><span><span>        m <span>=</span> Module()
</span></span><span><span>
</span></span><span><span>        m<span>.</span>d<span>.</span>comb <span>+=</span> [
</span></span><span><span>            self<span>.</span>o_rs1_value<span>.</span>eq(self<span>.</span>registers<span>.</span>word_select(self<span>.</span>i_select_rs1, <span>32</span>)),
</span></span><span><span>            self<span>.</span>o_rs2_value<span>.</span>eq(self<span>.</span>registers<span>.</span>word_select(self<span>.</span>i_select_rs2, <span>32</span>)),
</span></span><span><span>        ]
</span></span><span><span>
</span></span><span><span>        <span>with</span> m<span>.</span>If((self<span>.</span>i_we <span>==</span> <span>1</span>) <span>&amp;</span> (self<span>.</span>i_select_rd <span>!=</span> <span>0</span>)):
</span></span><span><span>            m<span>.</span>d<span>.</span>sync <span>+=</span> self<span>.</span>registers<span>.</span>word_select(self<span>.</span>i_select_rd, <span>32</span>)<span>.</span>eq(self<span>.</span>i_data)
</span></span><span><span>
</span></span><span><span>        <span>return</span> m
</span></span></code></pre></div><h2 id="program-counter">
  Program Counter
  <a href="#program-counter">
    <i aria-hidden="true"></i>
  </a>
</h2>
<p>The simplest component: we start executing programs at 0x1000 and then go to the next instruction. The decoder computes offset based on the instruction to allow both absolute and relative jumps.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>class</span> <span>ProgramCounter</span>(Elaboratable):
</span></span><span><span>    <span>def</span> __init__(self):
</span></span><span><span>        self<span>.</span>sync <span>=</span> ClockDomain(<span>&#34;sync&#34;</span>)
</span></span><span><span>        self<span>.</span>i_offset <span>=</span> SignedSignal(<span>32</span>)
</span></span><span><span>        self<span>.</span>o_instruction_address <span>=</span> Signal(<span>32</span>, reset<span>=</span><span>0x1000</span>)
</span></span><span><span>
</span></span><span><span>        self<span>.</span>ports <span>=</span> [self<span>.</span>o_instruction_address]
</span></span><span><span>
</span></span><span><span>    <span>def</span> <span>elaborate</span>(self, _: Platform) <span>-&gt;</span> Module:
</span></span><span><span>        m <span>=</span> Module()
</span></span><span><span>
</span></span><span><span>        m<span>.</span>d<span>.</span>sync <span>+=</span> self<span>.</span>o_instruction_address<span>.</span>eq(self<span>.</span>o_instruction_address <span>+</span> self<span>.</span>i_offset)
</span></span><span><span>
</span></span><span><span>        <span>return</span> m
</span></span></code></pre></div><h2 id="load-store-unit">
  Load Store Unit
  <a href="#load-store-unit">
    <i aria-hidden="true"></i>
  </a>
</h2>
<p>I’m co-simulating this part, so there is no implementation. Also simulating even small amounts of memory turned out to be way to slow. I hope to find more time in the future to complete this part of the project. And then also run it with real memory on an FPGA instead of just in simulation.</p>
<p>But let’s at least discuss the most interesting aspect of memory: Memory is usually very slow compared to the CPU. So the CPU has to be stalled, i.e. wait, while we are waiting for the memory to execute the read or write. In my design I have defined an <code>o_done</code> signal. This signal tells the control unit to not advance the program counter until the result is available. Not sure if this is the best approach, but it works for now.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>class</span> <span>LoadStoreUnit</span>(Elaboratable):
</span></span><span><span>    <span>def</span> __init__(self):
</span></span><span><span>        self<span>.</span>sync <span>=</span> ClockDomain(<span>&#34;sync&#34;</span>)
</span></span><span><span>
</span></span><span><span>        <span># from decoder, not in spec, internal control signals</span>
</span></span><span><span>        self<span>.</span>i_lsu_mode <span>=</span> Signal(<span>2</span>)
</span></span><span><span>
</span></span><span><span>        <span># from decoder, memory operation</span>
</span></span><span><span>        self<span>.</span>i_funct3 <span>=</span> Signal(<span>3</span>)
</span></span><span><span>
</span></span><span><span>        <span># address</span>
</span></span><span><span>        self<span>.</span>i_address_base <span>=</span> Signal(<span>32</span>)
</span></span><span><span>        self<span>.</span>i_address_offset <span>=</span> SignedSignal(<span>12</span>)
</span></span><span><span>
</span></span><span><span>        <span># reading / writing</span>
</span></span><span><span>        self<span>.</span>i_data <span>=</span> Signal(<span>32</span>)
</span></span><span><span>        self<span>.</span>o_data <span>=</span> Signal(<span>32</span>)
</span></span><span><span>
</span></span><span><span>        <span># </span>
</span></span><span><span>        self<span>.</span>o_done <span>=</span> Signal(<span>1</span>)
</span></span><span><span>
</span></span><span><span>    <span>def</span> <span>elaborate</span>(self, _: Platform) <span>-&gt;</span> Module:
</span></span><span><span>        m <span>=</span> Module()
</span></span><span><span>
</span></span><span><span>        <span># empty by design: this is co-simulated</span>
</span></span><span><span>
</span></span><span><span>        <span>return</span> m
</span></span></code></pre></div><h2 id="tieing-it-all-together-and-testing-it">
  Tieing it all together and testing it
  <a href="#tieing-it-all-together-and-testing-it">
    <i aria-hidden="true"></i>
  </a>
</h2>
<p>The control unit connects all modules, as described in the simplified diagram above. And uses the control logic from the decoder to correctly advance the program counter.</p>
<p>Instead of showing the boring glue code, here’s how I’m testing the CPU via simulation. The assembly program is designed to set registers to certain values, that can be checked afterwards. It does not follow any ABI constraints.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>def</span> <span>test_cpu</span>():
</span></span><span><span>    dut <span>=</span> CPU()
</span></span><span><span>    sim <span>=</span> Simulator(dut)
</span></span><span><span>
</span></span><span><span>    rom <span>=</span> [
</span></span><span><span>        <span>0x02A00093</span>,  <span># addi x1 x0 42   --&gt; x1 = 42</span>
</span></span><span><span>        <span>0x00100133</span>,  <span># add x2 x0 x1    --&gt; x2 = 42</span>
</span></span><span><span>        <span>0x123451B7</span>,  <span># lui x3 0x12345  --&gt; x3 = 0x12345</span>
</span></span><span><span>        <span>0x00208463</span>,  <span># beq x1 x2 8     --&gt; skip the next instruction</span>
</span></span><span><span>        <span>0x00700193</span>,  <span># addi x3 x0 7    [skipped]</span>
</span></span><span><span>        <span>0x00424233</span>,  <span># xor x4 x4 x4    --&gt; x4 = 0</span>
</span></span><span><span>        <span>0x00A00293</span>,  <span># addi x5 x0 10   --&gt; x5 = 10</span>
</span></span><span><span>        <span>0x00120213</span>,  <span># addi x4 x4 1    --&gt; x4 = x4 + 1</span>
</span></span><span><span>        <span>0x00520463</span>,  <span># beq x4 x5 8     --&gt; skip the next instruction</span>
</span></span><span><span>        <span>0xFF9FF36F</span>,  <span># jal x6 -8       --&gt; jump up; effectively setting x4 = 10</span>
</span></span><span><span>                     <span>#                     also setting x6 = pc + 4</span>
</span></span><span><span>        <span>0x000013B7</span>,  <span># lui x7 0x1      --&gt; x7 = 0x1000</span>
</span></span><span><span>        <span>0x03438467</span>,  <span># jalr x8 x7 52   --&gt; skip the next instruction</span>
</span></span><span><span>        <span>0x00634333</span>,  <span># xor x6 x6 x6    [skipped]</span>
</span></span><span><span>        <span>0x100004B7</span>,  <span># lui x9 0x10000  --&gt; x9 = 0x1000_0000</span>
</span></span><span><span>        <span>0x0324A503</span>,  <span># lw x10 50 x9    --&gt; x10 = *((int32*)(mem_u8_ptr[x9 + 0x32]))</span>
</span></span><span><span>        <span>0x00000013</span>,  <span># nop</span>
</span></span><span><span>        <span>0</span>,
</span></span><span><span>    ]
</span></span><span><span>
</span></span><span><span>    ram <span>=</span> [<span>0</span> <span>for</span> x <span>in</span> range(<span>128</span>)]
</span></span><span><span>    ram[<span>0x32</span> <span>+</span> <span>3</span>], ram[<span>0x32</span> <span>+</span> <span>2</span>], ram[<span>0x32</span> <span>+</span> <span>1</span>], ram[<span>0x32</span>] <span>=</span> <span>0xC0</span>, <span>0xFF</span>, <span>0xEE</span>, <span>0x42</span>
</span></span><span><span>
</span></span><span><span>    done <span>=</span> [<span>0</span>]
</span></span><span><span>
</span></span><span><span>    <span>def</span> <span>bench</span>():
</span></span><span><span>        <span>assert</span> (<span>yield</span> dut<span>.</span>o_tmp_pc) <span>==</span> <span>0x1000</span>
</span></span><span><span>
</span></span><span><span>        <span>while</span> <span>True</span>:
</span></span><span><span>            instr_addr <span>=</span> <span>yield</span> dut<span>.</span>o_tmp_pc
</span></span><span><span>            print(<span>&#34;instr addr: &#34;</span>, hex(instr_addr))
</span></span><span><span>            rom_addr <span>=</span> (instr_addr <span>-</span> <span>0x1000</span>) <span>//</span> <span>4</span>
</span></span><span><span>
</span></span><span><span>            <span>if</span> rom[rom_addr] <span>==</span> <span>0</span>:
</span></span><span><span>                done[<span>0</span>] <span>=</span> <span>1</span>
</span></span><span><span>                print(<span>&#34;bench: done.&#34;</span>)
</span></span><span><span>                <span>break</span>
</span></span><span><span>
</span></span><span><span>            print(<span>&#34;instr: &#34;</span>, hex(rom[rom_addr]))
</span></span><span><span>
</span></span><span><span>            <span>yield</span> dut<span>.</span>i_tmp_instruction<span>.</span>eq(rom[rom_addr])
</span></span><span><span>            <span>yield</span> Settle()
</span></span><span><span>
</span></span><span><span>            <span>assert</span> (<span>yield</span> dut<span>.</span>decoder<span>.</span>o_invalid) <span>==</span> <span>False</span>
</span></span><span><span>
</span></span><span><span>            <span>yield</span> Tick()
</span></span><span><span>            <span>yield</span> Settle()
</span></span><span><span>
</span></span><span><span>        read_reg <span>=</span> <span>lambda</span> x: dut<span>.</span>registers<span>.</span>registers<span>.</span>word_select(x, <span>32</span>)
</span></span><span><span>
</span></span><span><span>        <span>assert</span> (<span>yield</span> read_reg(<span>1</span>)) <span>==</span> <span>42</span>
</span></span><span><span>        <span>assert</span> (<span>yield</span> read_reg(<span>2</span>)) <span>==</span> <span>42</span>
</span></span><span><span>        <span>assert</span> (<span>yield</span> read_reg(<span>3</span>)) <span>==</span> <span>0x12345000</span>
</span></span><span><span>        <span>assert</span> (<span>yield</span> read_reg(<span>5</span>)) <span>==</span> <span>10</span>
</span></span><span><span>        <span>assert</span> (<span>yield</span> read_reg(<span>4</span>)) <span>==</span> <span>10</span>
</span></span><span><span>        <span>assert</span> (<span>yield</span> read_reg(<span>6</span>)) <span>==</span> <span>0x1000</span> <span>+</span> <span>4</span> <span>*</span> rom<span>.</span>index(<span>0xFF9FF36F</span>) <span>+</span> <span>4</span>
</span></span><span><span>        <span>assert</span> (<span>yield</span> read_reg(<span>7</span>)) <span>==</span> <span>0x1000</span>
</span></span><span><span>        <span>assert</span> (<span>yield</span> read_reg(<span>8</span>)) <span>==</span> <span>0x1000</span> <span>+</span> <span>4</span> <span>*</span> rom<span>.</span>index(<span>0x03438467</span>) <span>+</span> <span>4</span>
</span></span><span><span>        <span>assert</span> (<span>yield</span> read_reg(<span>9</span>)) <span>==</span> <span>0x1000_0000</span>
</span></span><span><span>        <span>assert</span> (<span>yield</span> read_reg(<span>10</span>)) <span>==</span> <span>0xC0FFEE42</span>
</span></span><span><span>
</span></span><span><span>        <span>yield</span> Passive()
</span></span><span><span>
</span></span><span><span>    <span>def</span> <span>memory_cosim</span>():
</span></span><span><span>        lsu <span>=</span> dut<span>.</span>lsu
</span></span><span><span>
</span></span><span><span>        was_busy <span>=</span> <span>False</span>
</span></span><span><span>
</span></span><span><span>        <span>while</span> <span>not</span> done[<span>0</span>]:
</span></span><span><span>            lsu_mode <span>=</span> <span>yield</span> lsu<span>.</span>i_lsu_mode
</span></span><span><span>            <span>if</span> lsu_mode <span>==</span> INTERNAL_LSU_MODE_DISABLED:
</span></span><span><span>                was_busy <span>=</span> <span>False</span>
</span></span><span><span>                <span>yield</span> lsu<span>.</span>o_data<span>.</span>eq(<span>0</span>)
</span></span><span><span>                <span>yield</span> lsu<span>.</span>o_done<span>.</span>eq(<span>0</span>)
</span></span><span><span>            <span>elif</span> lsu_mode <span>==</span> INTERNAL_LSU_MODE_LOAD <span>and</span> was_busy <span>is</span> <span>False</span>:
</span></span><span><span>                was_busy <span>=</span> <span>True</span>
</span></span><span><span>                base <span>=</span> <span>yield</span> lsu<span>.</span>i_address_base
</span></span><span><span>                offset <span>=</span> <span>yield</span> lsu<span>.</span>i_address_offset
</span></span><span><span>                addr <span>=</span> base <span>+</span> offset
</span></span><span><span>                funct3 <span>=</span> <span>yield</span> lsu<span>.</span>i_funct3
</span></span><span><span>                print(<span>f</span><span>&#34;memory read request: addr=</span><span>{</span>hex(addr)<span>}</span><span>&#34;</span>)
</span></span><span><span>
</span></span><span><span>                <span>yield</span> Tick()  <span># a read takes a while</span>
</span></span><span><span>                <span>yield</span> Tick()
</span></span><span><span>                <span>yield</span> Tick()
</span></span><span><span>
</span></span><span><span>                ram_offset <span>=</span> addr <span>-</span> <span>0x10000000</span>
</span></span><span><span>                <span>if</span> funct3 <span>==</span> FUNCT3_LOAD_W:
</span></span><span><span>                    value <span>=</span> (ram[ram_offset <span>+</span> <span>3</span>] <span>&lt;&lt;</span> <span>24</span>) <span>|</span> (ram[ram_offset <span>+</span> <span>2</span>] <span>&lt;&lt;</span> <span>16</span>) <span>|</span> (ram[ram_offset <span>+</span> <span>1</span>] <span>&lt;&lt;</span> <span>8</span>) <span>|</span> ram[ram_offset]
</span></span><span><span>                <span># ...</span>
</span></span><span><span>
</span></span><span><span>                <span>yield</span> lsu<span>.</span>o_data<span>.</span>eq(value)
</span></span><span><span>                <span>yield</span> lsu<span>.</span>o_done<span>.</span>eq(<span>1</span>)
</span></span><span><span>            <span># ...</span>
</span></span><span><span>
</span></span><span><span>            <span>yield</span> Tick()
</span></span><span><span>        print(<span>&#34;memory_cosim: done.&#34;</span>)
</span></span><span><span>
</span></span><span><span>        <span>yield</span> Passive()
</span></span><span><span>
</span></span><span><span>    sim<span>.</span>add_clock(<span>1e-6</span>)
</span></span><span><span>    sim<span>.</span>add_process(bench)
</span></span><span><span>    sim<span>.</span>add_process(memory_cosim)
</span></span><span><span>    sim<span>.</span>run()
</span></span></code></pre></div>
<p>My development time ran out before I completed the project, so no game of life on my toy CPU for now. So what’s missing?</p>
<ul>
<li>memory mapped I/O, so that instead of keeping the LEDs in memory, signals / pins of the CPU are used,</li>
<li>adding support for a few missing read / write operations to the memory controller (read byte, write byte),</li>
<li>integrating the emulator and simulator, re-using the existing debugger user interface,</li>
<li>and then likely spending some time on debugging,</li>
<li>maybe porting the simulator to Verilator or another framework to make it fast enough.</li>
</ul>
<p>But I thought having a blog post is much better than completing this experiment now. I hope to find time in the future to again work on this, finally run game of life on my CPU and actually run it in an FPGA. That would be fun.</p>
<p>But the best part is really: I’ve learned so much as you’ve read. Try it yourself. Thank you for reading :)</p>

<p>You can find my source code at <a href="https://github.com/fnoeding/fpga-experiments">https://github.com/fnoeding/fpga-experiments</a> . It’s not as clean as the snippets above, but I hope it provides additional context if you’d like to dive deeper.</p>

<p>If you want to learn more I’ve collected some links that helped me below:</p>
<ul>
<li><a href="https://github.com/mortbopet/Ripes">Ripes - visual RISC-V emulator</a> perfect for verifying the emulator / cpu, but too slow for larger programs</li>
<li><a href="https://edaplayground.com/">https://edaplayground.com/</a> sandbox / “fiddle” to play with different HDL frameworks</li>
<li><a href="https://github.com/RobertBaruch/amaranth-tutorial/">Amaranth Tutorial</a></li>
<li><a href="https://github.com/RobertBaruch/amaranth-exercises">Amaranth beginner exercises</a></li>
<li><a href="https://vivonomicon.com/2020/06/13/lets-write-a-minimal-risc-v-cpu-in-nmigen/">Let’s Write a Minimal RISC-V CPU in nMigen</a> Amaranth is a fork of nMigen</li>
<li><a href="https://domipheus.com/blog/rpu-series-quick-links/">Designing a CPU in VHDL Series</a></li>
<li><a href="https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf">RISC-V Spec</a></li>
<li><a href="https://godbolt.org/">Compiler Explorer</a> (was useful before setting up my own cross-compiler)</li>
<li><a href="https://mcyoung.xyz/2021/06/01/linker-script/">Everything You Never Wanted To Know About Linker Scripts</a></li>
<li><a href="https://cs107e.github.io/guides/gcc/">Guide: GCC and Bare Metal Programming</a></li>
<li><a href="https://stackoverflow.com/questions/58574924/creating-a-boot-program-in-risc-v">Creating a Boot Program in RISC-V</a></li>
<li><a href="https://wiki.osdev.org/ELF">ELF format details</a></li>
<li><a href="https://github.com/mborgerson/gdbstub">GDB Stub</a> (instead of writing my own debugger, I was considering this library)</li>
</ul>

<p>Please share comments on</p>
<ul>
<li><a href="https://news.ycombinator.com/item?id=34533752">Hacker News</a></li>
</ul>

      </div></div>
  </body>
</html>
