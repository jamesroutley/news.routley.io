<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/scandum/quadsort">Original</a>
    <h1>Show HN: QuadSort, Esoteric Fast Sort</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text"><h2 dir="auto"><a id="user-content-intro" aria-hidden="true" href="#intro"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Intro</h2>
<p dir="auto">This document describes a stable bottom-up adaptive branchless merge sort named quadsort. A <a href="https://github.com/scandum/quadsort#visualization">visualisation</a> and <a href="https://github.com/scandum/quadsort#benchmark-quadsort-vs-stdstable_sort-vs-timsort">benchmarks</a> are available at the bottom.</p>
<h2 dir="auto"><a id="user-content-the-quad-swap" aria-hidden="true" href="#the-quad-swap"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>The quad swap</h2>
<p dir="auto">At the core of quadsort is the quad swap. Traditionally most sorting
algorithms have been designed using the binary swap where two variables
are sorted using a third temporary variable. This typically looks as
following.</p>
<div dir="auto" data-snippet-clipboard-copy-content="    if (val[0] &gt; val[1])
    {
        swap[0] = val[0];
        val[0] = val[1];
        val[1] = swap[0];
    }"><pre>    <span>if</span> (val[<span>0</span>] &gt; val[<span>1</span>])
    {
        swap[<span>0</span>] = val[<span>0</span>];
        val[<span>0</span>] = val[<span>1</span>];
        val[<span>1</span>] = swap[<span>0</span>];
    }</pre></div>
<p dir="auto">Instead the quad swap sorts four variables at once. During the first
stage the four variables are partially sorted in the four
swap variables, in the second stage they are fully sorted back to the
original four variables.</p>
<div dir="auto" data-snippet-clipboard-copy-content="            ╭─╮             ╭─╮                  ╭─╮          ╭─╮
            │A├─╮         ╭─┤S├────────┬─────────┤?├─╮    ╭───┤F│
            ╰─╯ │   ╭─╮   │ ╰─╯        │         ╰┬╯ │   ╭┴╮  ╰─╯
                ├───┤?├───┤            │       ╭──╯  ╰───┤?│
            ╭─╮ │   ╰─╯   │ ╭─╮        │       │         ╰┬╯  ╭─╮
            │A├─╯         ╰─┤S├────────│────────╮         ╰───┤F│
            ╰─╯             ╰┬╯        │       ││             ╰─╯
                            ╭┴╮ ╭─╮   ╭┴╮ ╭─╮  ││
                            │?├─┤F│   │?├─┤F│  ││
                            ╰┬╯ ╰─╯   ╰┬╯ ╰─╯  ││
            ╭─╮             ╭┴╮        │       ││             ╭─╮
            │A├─╮         ╭─┤S├────────│───────╯│         ╭───┤F│
            ╰─╯ │   ╭─╮   │ ╰─╯        │        ╰─╮      ╭┴╮  ╰─╯
                ├───┤?├───┤            │          │  ╭───┤?│
            ╭─╮ │   ╰─╯   │ ╭─╮        │         ╭┴╮ │   ╰┬╯  ╭─╮
            │A├─╯         ╰─┤S├────────┴─────────┤?├─╯    ╰───┤F│
            ╰─╯             ╰─╯                  ╰─╯          ╰─╯"><pre>            <span>╭─╮</span>             <span>╭─╮</span>                  <span>╭─╮</span>          <span>╭─╮</span>
            <span>│A├─╮</span>         <span>╭─┤S├────────┬─────────┤</span>?<span>├─╮</span>    <span>╭───┤F│</span>
            <span>╰─╯</span> <span>│</span>   <span>╭─╮</span>   <span>│</span> <span>╰─╯</span>        <span>│</span>         <span>╰┬╯</span> <span>│</span>   <span>╭┴╮</span>  <span>╰─╯</span>
                <span>├───┤</span>?<span>├───┤</span>            <span>│</span>       <span>╭──╯</span>  <span>╰───┤</span>?<span>│</span>
            <span>╭─╮</span> <span>│</span>   <span>╰─╯</span>   <span>│</span> <span>╭─╮</span>        <span>│</span>       <span>│</span>         <span>╰┬╯</span>  <span>╭─╮</span>
            <span>│A├─╯</span>         <span>╰─┤S├────────│────────╮</span>         <span>╰───┤F│</span>
            <span>╰─╯</span>             <span>╰┬╯</span>        <span>│</span>       <span>││</span>             <span>╰─╯</span>
                            <span>╭┴╮</span> <span>╭─╮</span>   <span>╭┴╮</span> <span>╭─╮</span>  <span>││</span>
                            <span>│</span>?<span>├─┤F│</span>   <span>│</span>?<span>├─┤F│</span>  <span>││</span>
                            <span>╰┬╯</span> <span>╰─╯</span>   <span>╰┬╯</span> <span>╰─╯</span>  <span>││</span>
            <span>╭─╮</span>             <span>╭┴╮</span>        <span>│</span>       <span>││</span>             <span>╭─╮</span>
            <span>│A├─╮</span>         <span>╭─┤S├────────│───────╯│</span>         <span>╭───┤F│</span>
            <span>╰─╯</span> <span>│</span>   <span>╭─╮</span>   <span>│</span> <span>╰─╯</span>        <span>│</span>        <span>╰─╮</span>      <span>╭┴╮</span>  <span>╰─╯</span>
                <span>├───┤</span>?<span>├───┤</span>            <span>│</span>          <span>│</span>  <span>╭───┤</span>?<span>│</span>
            <span>╭─╮</span> <span>│</span>   <span>╰─╯</span>   <span>│</span> <span>╭─╮</span>        <span>│</span>         <span>╭┴╮</span> <span>│</span>   <span>╰┬╯</span>  <span>╭─╮</span>
            <span>│A├─╯</span>         <span>╰─┤S├────────┴─────────┤</span>?<span>├─╯</span>    <span>╰───┤F│</span>
            <span>╰─╯</span>             <span>╰─╯</span>                  <span>╰─╯</span>          <span>╰─╯</span></pre></div>
<p dir="auto">This process is visualized in the diagram above.</p>
<p dir="auto">After the first round of sorting a single if check determines if the four
swap variables are sorted in-order, if that&#39;s the case the swap
finishes up immediately. Next it checks if the swap variables
are sorted in reverse-order, if that&#39;s the case the sort finishes up
immediately. If both checks fail the final arrangement is known and
two checks remain to determine the final order.</p>
<p dir="auto">This eliminates 1 wasteful comparison for in-order sequences while creating
1 additional comparison for random sequences. However, in the real world we
are rarely comparing truly random data, so in any instance where data is
more likely to be orderly than disorderly this shift in probability will give
an advantage.</p>
<p dir="auto">In C the basic quad swap looks as following:</p>
<div dir="auto" data-snippet-clipboard-copy-content="    if (val[0] &gt; val[1])
    {
        swap[0] = val[1];
        swap[1] = val[0];
    }
    else
    {
        swap[0] = val[0];
        swap[1] = val[1];
    }

    if (val[2] &gt; val[3])
    {
        swap[2] = val[3];
        swap[3] = val[2];
    }
    else
    {
        swap[2] = val[2];
        swap[3] = val[3];
    }

    if (swap[1] &lt;= swap[2])
    {
        val[0] = swap[0];
        val[1] = swap[1];
        val[2] = swap[2];
        val[3] = swap[3];
    }
    else if (swap[0] &gt; swap[3])
    {
        val[0] = swap[2];
        val[1] = swap[3];
        val[2] = swap[0];
        val[3] = swap[1];
    }
    else
    {
       if (swap[0] &lt;= swap[2])
       {
           val[0] = swap[0];
           val[1] = swap[2];
       }
       else
       {
           val[0] = swap[2];
           val[1] = swap[0];
       }

       if (swap[1] &lt;= swap[3])
       {
           val[2] = swap[1];
           val[3] = swap[3];
       }
       else
       {
           val[2] = swap[3];
           val[3] = swap[1];
       }
    }"><pre>    <span>if</span> (val[<span>0</span>] &gt; val[<span>1</span>])
    {
        swap[<span>0</span>] = val[<span>1</span>];
        swap[<span>1</span>] = val[<span>0</span>];
    }
    <span>else</span>
    {
        swap[<span>0</span>] = val[<span>0</span>];
        swap[<span>1</span>] = val[<span>1</span>];
    }

    <span>if</span> (val[<span>2</span>] &gt; val[<span>3</span>])
    {
        swap[<span>2</span>] = val[<span>3</span>];
        swap[<span>3</span>] = val[<span>2</span>];
    }
    <span>else</span>
    {
        swap[<span>2</span>] = val[<span>2</span>];
        swap[<span>3</span>] = val[<span>3</span>];
    }

    <span>if</span> (swap[<span>1</span>] &lt;= swap[<span>2</span>])
    {
        val[<span>0</span>] = swap[<span>0</span>];
        val[<span>1</span>] = swap[<span>1</span>];
        val[<span>2</span>] = swap[<span>2</span>];
        val[<span>3</span>] = swap[<span>3</span>];
    }
    <span>else</span> <span>if</span> (swap[<span>0</span>] &gt; swap[<span>3</span>])
    {
        val[<span>0</span>] = swap[<span>2</span>];
        val[<span>1</span>] = swap[<span>3</span>];
        val[<span>2</span>] = swap[<span>0</span>];
        val[<span>3</span>] = swap[<span>1</span>];
    }
    <span>else</span>
    {
       <span>if</span> (swap[<span>0</span>] &lt;= swap[<span>2</span>])
       {
           val[<span>0</span>] = swap[<span>0</span>];
           val[<span>1</span>] = swap[<span>2</span>];
       }
       <span>else</span>
       {
           val[<span>0</span>] = swap[<span>2</span>];
           val[<span>1</span>] = swap[<span>0</span>];
       }

       <span>if</span> (swap[<span>1</span>] &lt;= swap[<span>3</span>])
       {
           val[<span>2</span>] = swap[<span>1</span>];
           val[<span>3</span>] = swap[<span>3</span>];
       }
       <span>else</span>
       {
           val[<span>2</span>] = swap[<span>3</span>];
           val[<span>3</span>] = swap[<span>1</span>];
       }
    }</pre></div>
<h2 dir="auto"><a id="user-content-in-place-quad-swap" aria-hidden="true" href="#in-place-quad-swap"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>In-place quad swap</h2>
<p dir="auto">There are however several problems with the simple quad swap above. If an array is already fully sorted it writes a lot of data back and forth from swap unnecessarily. If an array is fully in reverse order it will change <strong>8 7 6 5  4 3 2 1</strong> to <strong>5 6 7 8  1 2 3 4</strong> which reduces the degree of orderliness rather than increasing it.</p>
<p dir="auto">To solve these problems the quad swap needs to be implemented in-place.</p>
<h2 dir="auto"><a id="user-content-reverse-order-handling" aria-hidden="true" href="#reverse-order-handling"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Reverse order handling</h2>
<p dir="auto">Reverse order data is typically handled using a simple reversal function, as following.</p>
<div dir="auto" data-snippet-clipboard-copy-content="int reverse(int array[], int start, int end, int swap)
{
    while (start &lt; end)
    {
        swap = array[start];
        array[start++] = array[end];
        array[end--] = swap;
    }
}"><pre><span>int</span> <span>reverse</span>(<span>int</span> array[], <span>int</span> start, <span>int</span> end, <span>int</span> swap)
{
    <span>while</span> (start &lt; end)
    {
        swap = array[start];
        array[start++] = array[end];
        array[end--] = swap;
    }
}</pre></div>
<p dir="auto">While random data can only be sorted using <strong>n log n</strong> comparisons and
<strong>n log n</strong> moves, reverse-order data can be sorted using <strong>n</strong> comparisons
and <strong>n</strong> moves through run detection. Without run detection the best you
can do is sort it in <strong>n</strong> comparisons and <strong>n log n</strong> moves.</p>
<p dir="auto">Run detection, as the name implies, comes with a detection cost. Thanks
to the laws of probability a quad swap can cheat however. The chance of
4 random numbers having the order <strong>4 3 2 1</strong> is 1 in 24. So when sorting
random data we&#39;ll only make a wasteful run check in 4.16% of cases.</p>
<p dir="auto">What about run detection for in-order data? While we&#39;re turning
<strong>n log n</strong> moves into <strong>n</strong> moves with reverse order run detection, we&#39;d be
turning <strong>0</strong> moves into <strong>0</strong> moves with forward run detection. So there&#39;s
no point in doing so.</p>
<p dir="auto">The next optimization is to write the quad swap in such a way that we can
perform a simple check to see if the entire array was in reverse order,
if so, the sort is finished.</p>
<p dir="auto">One final optimization, reverse order handling is only beneficial on
runs longer than 4 elements. When no reverse order run is detected
the next 4 elements are merged with the first 4 elements. This reduces
the chance of a wasteful run check to 2.08%.</p>
<p dir="auto">At the end of the loop the array has been turned into a series of ordered
blocks of 8 elements.</p>
<h2 dir="auto"><a id="user-content-ping-pong-quad-merge" aria-hidden="true" href="#ping-pong-quad-merge"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Ping-Pong Quad Merge</h2>
<p dir="auto">Most textbook mergesort examples merge two blocks to swap memory, then copy
them back to main memory.</p>
<div data-snippet-clipboard-copy-content="main memory ┌────────┐┌────────┐
            └────────┘└────────┘
                  ↓ merge ↓
swap memory ┌──────────────────┐
            └──────────────────┘
                  ↓ copy ↓
main memory ┌──────────────────┐
            └──────────────────┘"><pre><code>main memory ┌────────┐┌────────┐
            └────────┘└────────┘
                  ↓ merge ↓
swap memory ┌──────────────────┐
            └──────────────────┘
                  ↓ copy ↓
main memory ┌──────────────────┐
            └──────────────────┘
</code></pre></div>
<p dir="auto">This doubles the amount of moves and we can fix this by merging 4 blocks at once
using a quad merge / ping-pong merge like so:</p>
<div data-snippet-clipboard-copy-content="main memory ┌────────┐┌────────┐┌────────┐┌────────┐
            └────────┘└────────┘└────────┘└────────┘
                  ↓ merge ↓           ↓ merge ↓
swap memory ┌──────────────────┐┌──────────────────┐
            └──────────────────┘└──────────────────┘
                            ↓ merge ↓
main memory ┌──────────────────────────────────────┐
            └──────────────────────────────────────┘"><pre><code>main memory ┌────────┐┌────────┐┌────────┐┌────────┐
            └────────┘└────────┘└────────┘└────────┘
                  ↓ merge ↓           ↓ merge ↓
swap memory ┌──────────────────┐┌──────────────────┐
            └──────────────────┘└──────────────────┘
                            ↓ merge ↓
main memory ┌──────────────────────────────────────┐
            └──────────────────────────────────────┘
</code></pre></div>
<p dir="auto">It is possible to interleave the two merges to swap memory for increased memory-level parallelism, but this can both increase and decrease performance.</p>
<h2 dir="auto"><a id="user-content-skipping" aria-hidden="true" href="#skipping"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Skipping</h2>
<p dir="auto">Just like with the quad swap it is beneficial to check whether the 4 blocks
are in-order.</p>
<p dir="auto">In the case of the 4 blocks being in-order the merge operation is skipped,
as this would be pointless. Because reverse order data is handled in the
quad swap there is no need to check for reverse order blocks.</p>
<p dir="auto">This allows quadsort to sort in-order sequences using <strong>n</strong> comparisons instead
of <strong>n * log n</strong> comparisons.</p>
<h2 dir="auto"><a id="user-content-parity-merge" aria-hidden="true" href="#parity-merge"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Parity merge</h2>
<p dir="auto">A parity merge takes advantage of the fact that if you have two n length arrays,
you can fully merge the two arrays by performing n merge operations on the start
of each array, and n merge operations on the end of each array. The arrays must
be of exactly equal length.</p>
<p dir="auto">The main advantage of a parity merge over a traditional merge is that the loop
of a parity merge can be fully unrolled.</p>
<p dir="auto">If the arrays are not of equal length a hybrid parity merge can be performed. One
way to do so is using n parity merges where n is the size of the smaller array,
before switching to a traditional merge.</p>
<h2 dir="auto"><a id="user-content-branchless-parity-merge" aria-hidden="true" href="#branchless-parity-merge"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Branchless parity merge</h2>
<p dir="auto">Since the parity merge can be unrolled it&#39;s very suitable for branchless
optimizations to speed up the sorting of random data. Another advantage
is that two separate memory regions are accessed in the same loop, allowing
memory-level parallelism. This makes the routine up to 2.5 times faster for
random data on most hardware.</p>
<p dir="auto">Increasing the memory regions from two to four can result in both performance
gains and performance losses.</p>
<p dir="auto">The following is a visualization of an array with 256 random elements getting
turned into sorted blocks of 32 elements using ping-pong parity merges.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/scandum/quadsort/blob/master/images/quadswap.gif"><img src="https://github.com/scandum/quadsort/raw/master/images/quadswap.gif" alt="quadsort visualization" data-animated-image=""/></a></p>
<h2 dir="auto"><a id="user-content-quad-galloping-merge" aria-hidden="true" href="#quad-galloping-merge"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Quad galloping merge</h2>
<p dir="auto">While a branchless parity merge sorts random data faster, it sorts ordered data
slower. One way to solve this problem is by using a method with a resemblance
to the galloping merge concept first introduced by timsort.</p>
<p dir="auto">The quad galloping merge works in a similar way to the quad swap.
Instead of merging the ends of two arrays two items at a time, it merges
four items at a time.</p>
<div data-snippet-clipboard-copy-content="┌───┐┌───┐┌───┐    ┌───┐┌───┐┌───┐            ╭───╮  ┌───┐┌───┐┌───┐
│ A ││ B ││ C │    │ X ││ Y ││ Z │        ┌───│B&lt;X├──┤ A ││ B ││C/X│
└─┬─┘└─┬─┘└───┘    └─┬─┘└─┬─┘└───┘        │   ╰─┬─╯  └───┘└───┘└───┘
  └────┴─────────────┴────┴───────────────┘     │  ╭───╮  ┌───┐┌───┐┌───┐
                                                └──│A&gt;Y├──┤ X ││ Y ││A/Z│
                                                   ╰─┬─╯  └───┘└───┘└───┘
                                                     │    ┌───┐┌───┐┌───┐
                                                     └────│A/X││X/A││B/Y│
                                                          └───┘└───┘└───┘"><pre><code>┌───┐┌───┐┌───┐    ┌───┐┌───┐┌───┐            ╭───╮  ┌───┐┌───┐┌───┐
│ A ││ B ││ C │    │ X ││ Y ││ Z │        ┌───│B&lt;X├──┤ A ││ B ││C/X│
└─┬─┘└─┬─┘└───┘    └─┬─┘└─┬─┘└───┘        │   ╰─┬─╯  └───┘└───┘└───┘
  └────┴─────────────┴────┴───────────────┘     │  ╭───╮  ┌───┐┌───┐┌───┐
                                                └──│A&gt;Y├──┤ X ││ Y ││A/Z│
                                                   ╰─┬─╯  └───┘└───┘└───┘
                                                     │    ┌───┐┌───┐┌───┐
                                                     └────│A/X││X/A││B/Y│
                                                          └───┘└───┘└───┘
</code></pre></div>
<p dir="auto">When merging ABC and XYZ it first checks if B is smaller or equal to X. If
that&#39;s the case A and B are copied to swap. If not, it checks if A is greater
than Y. If that&#39;s the case X and Y are copied to swap.</p>
<p dir="auto">If either check is false it&#39;s known that the two remaining distributions
are A X and X A. This allows performing an optimal branchless merge. Since
it&#39;s known each block still has at least 1 item remaining (B and Y) and
there is a high probability of the data to be random, another (sub-optimal)
branchless merge can be performed.</p>
<p dir="auto">In C this looks as following:</p>
<div dir="auto" data-snippet-clipboard-copy-content="while (l &lt; l_size - 1 &amp;&amp; r &lt; r_size - 1)
{
    if (left[l + 1] &lt;= right[r])
    {
        swap[s++] = left[l++];
        swap[s++] = left[l++];
    }
    else if (left[l] &gt; right[r + 1])
    {
        swap[s++] = right[r++];
        swap[s++] = right[r++];
    }
    else
    {
        a = left[l] &gt; right[r];
        x = !a;
        swap[s + a] = left[l++];
        swap[s + x] = right[r++];
        s += 2;
    }
}"><pre><span>while</span> (l &lt; l_size - <span>1</span> &amp;&amp; r &lt; r_size - <span>1</span>)
{
    <span>if</span> (left[l + <span>1</span>] &lt;= right[r])
    {
        swap[s++] = left[l++];
        swap[s++] = left[l++];
    }
    <span>else</span> <span>if</span> (left[l] &gt; right[r + <span>1</span>])
    {
        swap[s++] = right[r++];
        swap[s++] = right[r++];
    }
    <span>else</span>
    {
        a = left[l] &gt; right[r];
        x = !a;
        swap[s + a] = left[l++];
        swap[s + x] = right[r++];
        s += <span>2</span>;
    }
}</pre></div>
<p dir="auto">Overall the quad galloping merge gives a slight performance gain for both ordered and random data.</p>
<h2 dir="auto"><a id="user-content-merge-strategy" aria-hidden="true" href="#merge-strategy"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Merge strategy</h2>
<p dir="auto">Quadsort will merge blocks of 8 into blocks of 32, which it will merge into
blocks of 128, 512, 2048, 8192, etc.</p>
<p dir="auto">For each ping-pong merge quadsort will perform two comparisons to see if it will be faster
to use a parity merge or a quad galloping merge, and pick the best option.</p>
<h2 dir="auto"><a id="user-content-tail-merge" aria-hidden="true" href="#tail-merge"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Tail merge</h2>
<p dir="auto">When sorting an array of 33 elements you end up with a sorted array of 32
elements and a sorted array of 1 element in the end. If a program sorts in
intervals it should pick an optimal array size (32, 128, 512, etc) to do so.</p>
<p dir="auto">To minimalize the impact the remainder of the array is sorted using a tail
merge.</p>
<p dir="auto">The main advantage of a tail merge is that it allows reducing the swap
space of quadsort to <strong>n / 2</strong> and that the galloping merge strategy works best
on arrays of different lengths. It also greatly simplifies the ping-pong
quad merge routine which only needs to work on arrays of equal length.</p>
<h2 dir="auto"><a id="user-content-rotate-merge" aria-hidden="true" href="#rotate-merge"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Rotate merge</h2>
<p dir="auto">By using rotations the swap space of quadsort is reduced further from <strong>n / 2</strong>
to <strong>n / 4</strong>. Rotations can be performed with minimal performance loss by using
<a href="https://github.com/scandum/binary_search">monobound binary searches</a> and <a href="https://github.com/scandum/rotate">trinity / bridge rotations</a>.</p>
<h2 dir="auto"><a id="user-content-big-o" aria-hidden="true" href="#big-o"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Big O</h2>
<div dir="auto" data-snippet-clipboard-copy-content="                 ┌───────────────────────┐┌───────────────────────┐
                 │comparisons            ││swap memory            │
┌───────────────┐├───────┬───────┬───────┤├───────┬───────┬───────┤┌──────┐┌─────────┐┌─────────┐
│name           ││min    │avg    │max    ││min    │avg    │max    ││stable││partition││adaptive │
├───────────────┤├───────┼───────┼───────┤├───────┼───────┼───────┤├──────┤├─────────┤├─────────┤
│mergesort      ││n log n│n log n│n log n││n      │n      │n      ││yes   ││no       ││no       │
├───────────────┤├───────┼───────┼───────┤├───────┼───────┼───────┤├──────┤├─────────┤├─────────┤
│quadsort       ││n      │n log n│n log n││1      │n      │n      ││yes   ││no       ││yes      │
├───────────────┤├───────┼───────┼───────┤├───────┼───────┼───────┤├──────┤├─────────┤├─────────┤
│quicksort      ││n log n│n log n│n²     ││1      │1      │1      ││no    ││yes      ││no       │
└───────────────┘└───────┴───────┴───────┘└───────┴───────┴───────┘└──────┘└─────────┘└─────────┘"><pre>                 ┌───────────────────────┐┌───────────────────────┐
                 │comparisons            ││swap <span>memory</span>            │
┌───────────────┐├───────┬───────┬───────┤├───────┬───────┬───────┤┌──────┐┌─────────┐┌─────────┐
│<span>name</span>           ││<span>min</span>    │avg    │<span>max</span>    ││<span>min</span>    │avg    │<span>max</span>    ││stable││partition││adaptive │
├───────────────┤├───────┼───────┼───────┤├───────┼───────┼───────┤├──────┤├─────────┤├─────────┤
│mergesort      ││n <span>log</span> n│n <span>log</span> n│n <span>log</span> n││n      │n      │n      ││yes   ││<span>no</span>       ││<span>no</span>       │
├───────────────┤├───────┼───────┼───────┤├───────┼───────┼───────┤├──────┤├─────────┤├─────────┤
│quadsort       ││n      │n <span>log</span> n│n <span>log</span> n││<span>1</span>      │n      │n      ││yes   ││<span>no</span>       ││yes      │
├───────────────┤├───────┼───────┼───────┤├───────┼───────┼───────┤├──────┤├─────────┤├─────────┤
│quicksort      ││n <span>log</span> n│n <span>log</span> n│n²     ││<span>1</span>      │<span>1</span>      │<span>1</span>      ││<span>no</span>    ││yes      ││<span>no</span>       │
└───────────────┘└───────┴───────┴───────┘└───────┴───────┴───────┘└──────┘└─────────┘└─────────┘</pre></div>
<p dir="auto">Quadsort makes n comparisons when the data is fully sorted or reverse sorted.</p>
<h2 dir="auto"><a id="user-content-data-types" aria-hidden="true" href="#data-types"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Data Types</h2>
<p dir="auto">The C implementation of quadsort supports long doubles and 8, 16, 32, and 64 bit data types. By using pointers it&#39;s possible to sort any other data type, like strings.</p>
<h2 dir="auto"><a id="user-content-interface" aria-hidden="true" href="#interface"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Interface</h2>
<p dir="auto">Quadsort uses the same interface as qsort, which is described in <a href="https://man7.org/linux/man-pages/man3/qsort.3p.html" rel="nofollow">man qsort</a>.</p>
<p dir="auto">In addition to supporting <code>(l - r)</code> and <code>((l &gt; r) - (l &lt; r))</code> for the comparison function, <code>(l &gt; r)</code> is valid as well. Special note should be taken that C++ sorts use <code>(l &lt; r)</code> for the comparison function, which is incompatible with the C standard. When porting quadsort to C++ or Rust, switch <code>(l, r)</code> to <code>(r, l)</code> for every comparison.</p>
<h2 dir="auto"><a id="user-content-memory" aria-hidden="true" href="#memory"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Memory</h2>
<p dir="auto">By default quadsort uses between n and n / 4 swap memory. If memory allocation fails quadsort will switch to sorting in-place through rotations. The minimum memory requirement is 32 elements of stack memory.</p>
<h2 dir="auto"><a id="user-content-performance" aria-hidden="true" href="#performance"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Performance</h2>
<p dir="auto">Quadsort is one of the fastest merge sorts written to date. It is faster than quicksort for most data distributions, with the notable exception of generic data.</p>
<p dir="auto">On arrays exceeding the L1 cache quicksort has an advantage due to its ability to partition. For small arrays quadsort has a significant advantage due to quicksort&#39;s inability to cost effectively pick a reliable pivot.</p>
<p dir="auto">To take full advantage of branchless operations the cmp macro needs to be uncommented in bench.c, which will increase the performance by 30% on primitive types.</p>
<h2 dir="auto"><a id="user-content-variants" aria-hidden="true" href="#variants"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Variants</h2>
<ul dir="auto">
<li>
<p dir="auto"><a href="https://github.com/scandum/blitsort">blitsort</a> is a hybrid stable in-place rotate quicksort / quadsort.</p>
</li>
<li>
<p dir="auto"><a href="https://github.com/scandum/crumsort">crumsort</a> is a hybrid unstable in-place quicksort / quadsort.</p>
</li>
<li>
<p dir="auto"><a href="https://github.com/scandum/fluxsort">fluxsort</a> is a hybrid stable quicksort / quadsort.</p>
</li>
<li>
<p dir="auto"><a href="https://github.com/scandum/gridsort">gridsort</a> is a hybrid stable cubesort / quadsort. Gridsort makes O(n) moves rather than the typical O(n log n) moves. It is an online sort and might be of interest to those interested in data structures and sorting very large arrays.</p>
</li>
<li>
<p dir="auto"><a href="https://github.com/scandum/twinsort">twinsort</a> is a simplified quadsort with a
much smaller code size. Twinsort might be of use to people who want to port or understand quadsort; it does not use
pointers or gotos.</p>
</li>
<li>
<p dir="auto"><a href="https://github.com/scandum/wolfsort">wolfsort</a> is a hybrid stable radixsort / fluxsort with improved performance on random data. It&#39;s mostly a proof of concept that only works on unsigned 32 bit integers.</p>
</li>
<li>
<p dir="auto"><a href="https://github.com/mlochbaum/rhsort">Robin Hood Sort</a> is a hybrid stable radixsort / dropsort with improved performance on random and generic data. It has a compilation option to use quadsort for its merging.</p>
</li>
</ul>
<h2 dir="auto"><a id="user-content-credits" aria-hidden="true" href="#credits"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Credits</h2>
<p dir="auto">I personally invented the quad swap, quad galloping merge, parity merge, branchless parity merge,
monobound binary search, bridge rotation, and trinity rotation.</p>
<p dir="auto">The ping-pong quad merge had been independently implemented in wikisort prior to quadsort, and
likely by others as well.</p>
<p dir="auto">The monobound binary search has been independently implemented, often referred to as a branchless binary search.</p>
<p dir="auto">Special kudos to <a href="https://www.youtube.com/c/Musicombo" rel="nofollow">Musiccombo and Co</a> for getting me interested in rotations and branchless logic.</p>
<h2 dir="auto"><a id="user-content-visualization" aria-hidden="true" href="#visualization"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Visualization</h2>
<p dir="auto">In the visualization below nine tests are performed on 256 elements.</p>
<ol dir="auto">
<li>Random order</li>
<li>Ascending order</li>
<li>Ascending Saw</li>
<li>Generic random order</li>
<li>Descending order</li>
<li>Descending Saw</li>
<li>Random tail</li>
<li>Random half</li>
<li>Ascending tiles.</li>
</ol>
<p dir="auto">The upper half shows the swap memory and the bottom half shows the main memory.
Colors are used to differentiate various operations. Quad swaps are in cyan, reversals in magenta, skips in green, parity merges in orange, bridge rotations in yellow, and trinity rotations are in violet.</p>
<p dir="auto"><a href="https://www.youtube.com/watch?v=GJjH_99BS70" rel="nofollow"><img src="https://github.com/scandum/quadsort/raw/master/images/quadsort.gif" alt="quadsort benchmark" data-animated-image=""/></a></p>
<p dir="auto">The <a href="https://www.youtube.com/watch?v=GJjH_99BS70" rel="nofollow">visualization is available on YouTube</a> and there&#39;s also a <a href="https://www.youtube.com/watch?v=drSeVadf05M" rel="nofollow">YouTube video of a java port of quadsort</a> in <a href="https://github.com/Gaming32/ArrayV-v4.0">ArrayV</a> on a wide variety of data distributions.</p>
<h2 dir="auto"><a id="user-content-benchmark-quadsort-vs-stdstable_sort-vs-timsort" aria-hidden="true" href="#benchmark-quadsort-vs-stdstable_sort-vs-timsort"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Benchmark: quadsort vs std::stable_sort vs timsort</h2>
<p dir="auto">The following benchmark was on WSL 2 gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04)
using the <a href="https://github.com/scandum/wolfsort">wolfsort benchmark</a>.
The source code was compiled using <code>g++ -O3 -w -fpermissive bench.c</code>. Stablesort is g++&#39;s std:stablesort function. Each test was ran 100 times
on 100,000 elements. A table with the best and average time in seconds can be uncollapsed below the bar graph.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/scandum/quadsort/blob/master/images/graph1.png"><img src="https://github.com/scandum/quadsort/raw/master/images/graph1.png" alt="Graph"/></a></p>
<details><summary><b>data table</b></summary>
<table>
<thead>
<tr>
<th>Name</th>
<th>Items</th>
<th>Type</th>
<th>Best</th>
<th>Average</th>
<th>Compares</th>
<th>Samples</th>
<th>Distribution</th>
</tr>
</thead>
<tbody>
<tr>
<td>stablesort</td>
<td>100000</td>
<td>32</td>
<td>0.006096</td>
<td>0.006141</td>
<td>1</td>
<td>100</td>
<td>random order</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.002677</td>
<td>0.002696</td>
<td>1</td>
<td>100</td>
<td>random order</td>
</tr>
<tr>
<td>timsort</td>
<td>100000</td>
<td>32</td>
<td>0.007388</td>
<td>0.007431</td>
<td>1</td>
<td>100</td>
<td>random order</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>stablesort</td>
<td>100000</td>
<td>32</td>
<td>0.003936</td>
<td>0.003974</td>
<td>1</td>
<td>100</td>
<td>random % 100</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.001971</td>
<td>0.001983</td>
<td>1</td>
<td>100</td>
<td>random % 100</td>
</tr>
<tr>
<td>timsort</td>
<td>100000</td>
<td>32</td>
<td>0.005349</td>
<td>0.005387</td>
<td>1</td>
<td>100</td>
<td>random % 100</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>stablesort</td>
<td>100000</td>
<td>32</td>
<td>0.000692</td>
<td>0.000711</td>
<td>1</td>
<td>100</td>
<td>ascending order</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.000069</td>
<td>0.000069</td>
<td>1</td>
<td>100</td>
<td>ascending order</td>
</tr>
<tr>
<td>timsort</td>
<td>100000</td>
<td>32</td>
<td>0.000045</td>
<td>0.000045</td>
<td>1</td>
<td>100</td>
<td>ascending order</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>stablesort</td>
<td>100000</td>
<td>32</td>
<td>0.001378</td>
<td>0.001409</td>
<td>1</td>
<td>100</td>
<td>ascending saw</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.000639</td>
<td>0.000648</td>
<td>1</td>
<td>100</td>
<td>ascending saw</td>
</tr>
<tr>
<td>timsort</td>
<td>100000</td>
<td>32</td>
<td>0.000834</td>
<td>0.000842</td>
<td>1</td>
<td>100</td>
<td>ascending saw</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>stablesort</td>
<td>100000</td>
<td>32</td>
<td>0.000838</td>
<td>0.000856</td>
<td>1</td>
<td>100</td>
<td>pipe organ</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.000266</td>
<td>0.000269</td>
<td>1</td>
<td>100</td>
<td>pipe organ</td>
</tr>
<tr>
<td>timsort</td>
<td>100000</td>
<td>32</td>
<td>0.000175</td>
<td>0.000176</td>
<td>1</td>
<td>100</td>
<td>pipe organ</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>stablesort</td>
<td>100000</td>
<td>32</td>
<td>0.000926</td>
<td>0.000938</td>
<td>1</td>
<td>100</td>
<td>descending order</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.000056</td>
<td>0.000056</td>
<td>1</td>
<td>100</td>
<td>descending order</td>
</tr>
<tr>
<td>timsort</td>
<td>100000</td>
<td>32</td>
<td>0.000101</td>
<td>0.000101</td>
<td>1</td>
<td>100</td>
<td>descending order</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>stablesort</td>
<td>100000</td>
<td>32</td>
<td>0.001377</td>
<td>0.001408</td>
<td>1</td>
<td>100</td>
<td>descending saw</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.000639</td>
<td>0.000645</td>
<td>1</td>
<td>100</td>
<td>descending saw</td>
</tr>
<tr>
<td>timsort</td>
<td>100000</td>
<td>32</td>
<td>0.000835</td>
<td>0.000853</td>
<td>1</td>
<td>100</td>
<td>descending saw</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>stablesort</td>
<td>100000</td>
<td>32</td>
<td>0.002074</td>
<td>0.002094</td>
<td>1</td>
<td>100</td>
<td>random tail</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.000882</td>
<td>0.000888</td>
<td>1</td>
<td>100</td>
<td>random tail</td>
</tr>
<tr>
<td>timsort</td>
<td>100000</td>
<td>32</td>
<td>0.001945</td>
<td>0.001957</td>
<td>1</td>
<td>100</td>
<td>random tail</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>stablesort</td>
<td>100000</td>
<td>32</td>
<td>0.003553</td>
<td>0.003578</td>
<td>1</td>
<td>100</td>
<td>random half</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.001576</td>
<td>0.001585</td>
<td>1</td>
<td>100</td>
<td>random half</td>
</tr>
<tr>
<td>timsort</td>
<td>100000</td>
<td>32</td>
<td>0.003921</td>
<td>0.003947</td>
<td>1</td>
<td>100</td>
<td>random half</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>stablesort</td>
<td>100000</td>
<td>32</td>
<td>0.000982</td>
<td>0.001006</td>
<td>1</td>
<td>100</td>
<td>ascending tiles</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.000812</td>
<td>0.000823</td>
<td>1</td>
<td>100</td>
<td>ascending tiles</td>
</tr>
<tr>
<td>timsort</td>
<td>100000</td>
<td>32</td>
<td>0.000879</td>
<td>0.000916</td>
<td>1</td>
<td>100</td>
<td>ascending tiles</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>stablesort</td>
<td>100000</td>
<td>32</td>
<td>0.001532</td>
<td>0.001973</td>
<td>1</td>
<td>100</td>
<td>bit reversal</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.002336</td>
<td>0.002347</td>
<td>1</td>
<td>100</td>
<td>bit reversal</td>
</tr>
<tr>
<td>timsort</td>
<td>100000</td>
<td>32</td>
<td>0.002197</td>
<td>0.002762</td>
<td>1</td>
<td>100</td>
<td>bit reversal</td>
</tr>
</tbody>
</table>
</details>
<p dir="auto">The following benchmark was on WSL 2 gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04)
using the <a href="https://github.com/scandum/wolfsort">wolfsort benchmark</a>.
The source code was compiled using <code>g++ -O3 -w -fpermissive bench.c</code>. It measures the performance on random data with array sizes
ranging from 8 to 524288. The benchmark is weighted, meaning the number of repetitions
halves each time the number of items doubles. A table with the best and average time in seconds can be uncollapsed below the bar graph.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/scandum/quadsort/blob/master/images/graph2.png"><img src="https://github.com/scandum/quadsort/raw/master/images/graph2.png" alt="Graph"/></a></p>
<details><summary><b>data table</b></summary>
<table>
<thead>
<tr>
<th>Name</th>
<th>Items</th>
<th>Type</th>
<th>Best</th>
<th>Average</th>
<th>Reps</th>
<th>Samples</th>
<th>Distribution</th>
</tr>
</thead>
<tbody>
<tr>
<td>stablesort</td>
<td>8</td>
<td>32</td>
<td>0.006182</td>
<td>0.006221</td>
<td>65536</td>
<td>100</td>
<td>random 8</td>
</tr>
<tr>
<td>quadsort</td>
<td>8</td>
<td>32</td>
<td>0.001628</td>
<td>0.001644</td>
<td>65536</td>
<td>100</td>
<td>random 8</td>
</tr>
<tr>
<td>timsort</td>
<td>8</td>
<td>32</td>
<td>0.006378</td>
<td>0.006680</td>
<td>65536</td>
<td>100</td>
<td>random 8</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>stablesort</td>
<td>32</td>
<td>32</td>
<td>0.009514</td>
<td>0.009653</td>
<td>16384</td>
<td>100</td>
<td>random 32</td>
</tr>
<tr>
<td>quadsort</td>
<td>32</td>
<td>32</td>
<td>0.003978</td>
<td>0.004041</td>
<td>16384</td>
<td>100</td>
<td>random 32</td>
</tr>
<tr>
<td>timsort</td>
<td>32</td>
<td>32</td>
<td>0.013349</td>
<td>0.013524</td>
<td>16384</td>
<td>100</td>
<td>random 32</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>stablesort</td>
<td>128</td>
<td>32</td>
<td>0.012961</td>
<td>0.013043</td>
<td>4096</td>
<td>100</td>
<td>random 128</td>
</tr>
<tr>
<td>quadsort</td>
<td>128</td>
<td>32</td>
<td>0.005179</td>
<td>0.005270</td>
<td>4096</td>
<td>100</td>
<td>random 128</td>
</tr>
<tr>
<td>timsort</td>
<td>128</td>
<td>32</td>
<td>0.019949</td>
<td>0.020191</td>
<td>4096</td>
<td>100</td>
<td>random 128</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>stablesort</td>
<td>512</td>
<td>32</td>
<td>0.016774</td>
<td>0.016886</td>
<td>1024</td>
<td>100</td>
<td>random 512</td>
</tr>
<tr>
<td>quadsort</td>
<td>512</td>
<td>32</td>
<td>0.006800</td>
<td>0.006895</td>
<td>1024</td>
<td>100</td>
<td>random 512</td>
</tr>
<tr>
<td>timsort</td>
<td>512</td>
<td>32</td>
<td>0.024646</td>
<td>0.024794</td>
<td>1024</td>
<td>100</td>
<td>random 512</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>stablesort</td>
<td>2048</td>
<td>32</td>
<td>0.020439</td>
<td>0.020530</td>
<td>256</td>
<td>100</td>
<td>random 2048</td>
</tr>
<tr>
<td>quadsort</td>
<td>2048</td>
<td>32</td>
<td>0.008351</td>
<td>0.008394</td>
<td>256</td>
<td>100</td>
<td>random 2048</td>
</tr>
<tr>
<td>timsort</td>
<td>2048</td>
<td>32</td>
<td>0.028911</td>
<td>0.029043</td>
<td>256</td>
<td>100</td>
<td>random 2048</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>stablesort</td>
<td>8192</td>
<td>32</td>
<td>0.024204</td>
<td>0.024298</td>
<td>64</td>
<td>100</td>
<td>random 8192</td>
</tr>
<tr>
<td>quadsort</td>
<td>8192</td>
<td>32</td>
<td>0.009967</td>
<td>0.010036</td>
<td>64</td>
<td>100</td>
<td>random 8192</td>
</tr>
<tr>
<td>timsort</td>
<td>8192</td>
<td>32</td>
<td>0.033020</td>
<td>0.033134</td>
<td>64</td>
<td>100</td>
<td>random 8192</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>stablesort</td>
<td>32768</td>
<td>32</td>
<td>0.028113</td>
<td>0.028206</td>
<td>16</td>
<td>100</td>
<td>random 32768</td>
</tr>
<tr>
<td>quadsort</td>
<td>32768</td>
<td>32</td>
<td>0.011645</td>
<td>0.011692</td>
<td>16</td>
<td>100</td>
<td>random 32768</td>
</tr>
<tr>
<td>timsort</td>
<td>32768</td>
<td>32</td>
<td>0.037227</td>
<td>0.037328</td>
<td>16</td>
<td>100</td>
<td>random 32768</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>stablesort</td>
<td>131072</td>
<td>32</td>
<td>0.032113</td>
<td>0.032197</td>
<td>4</td>
<td>100</td>
<td>random 131072</td>
</tr>
<tr>
<td>quadsort</td>
<td>131072</td>
<td>32</td>
<td>0.013344</td>
<td>0.013388</td>
<td>4</td>
<td>100</td>
<td>random 131072</td>
</tr>
<tr>
<td>timsort</td>
<td>131072</td>
<td>32</td>
<td>0.041431</td>
<td>0.041528</td>
<td>4</td>
<td>100</td>
<td>random 131072</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>stablesort</td>
<td>524288</td>
<td>32</td>
<td>0.036110</td>
<td>0.036244</td>
<td>1</td>
<td>100</td>
<td>random 524288</td>
</tr>
<tr>
<td>quadsort</td>
<td>524288</td>
<td>32</td>
<td>0.015046</td>
<td>0.015115</td>
<td>1</td>
<td>100</td>
<td>random 524288</td>
</tr>
<tr>
<td>timsort</td>
<td>524288</td>
<td>32</td>
<td>0.045705</td>
<td>0.045935</td>
<td>1</td>
<td>100</td>
<td>random 524288</td>
</tr>
</tbody>
</table>
</details>
<h2 dir="auto"><a id="user-content-benchmark-quadsort-vs-qsort-mergesort" aria-hidden="true" href="#benchmark-quadsort-vs-qsort-mergesort"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Benchmark: quadsort vs qsort (mergesort)</h2>
<p dir="auto">The following benchmark was on WSL 2 gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04).
The source code was compiled using gcc -O3 bench.c. Each test was ran 10 times. It&#39;s generated
by running the benchmark using 100000 100 1 as the argument. In the benchmark quadsort is
compared against glibc qsort() using the same general purpose interface and without any known
unfair advantage, like inlining. A table with the best and average time in seconds can be
uncollapsed below the bar graph.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/scandum/quadsort/blob/master/images/graph3.png"><img src="https://github.com/scandum/quadsort/raw/master/images/graph3.png" alt="Graph"/></a></p>
<details><summary><b>data table</b></summary>
<table>
<thead>
<tr>
<th>Name</th>
<th>Items</th>
<th>Type</th>
<th>Best</th>
<th>Average</th>
<th>Compares</th>
<th>Samples</th>
<th>Distribution</th>
</tr>
</thead>
<tbody>
<tr>
<td>qsort</td>
<td>100000</td>
<td>64</td>
<td>0.017014</td>
<td>0.017276</td>
<td>1536228</td>
<td>10</td>
<td>random string</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>64</td>
<td>0.011095</td>
<td>0.011311</td>
<td>1650839</td>
<td>10</td>
<td>random string</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Name</th>
<th>Items</th>
<th>Type</th>
<th>Best</th>
<th>Average</th>
<th>Compares</th>
<th>Samples</th>
<th>Distribution</th>
</tr>
</thead>
<tbody>
<tr>
<td>qsort</td>
<td>100000</td>
<td>128</td>
<td>0.019056</td>
<td>0.019849</td>
<td>1536323</td>
<td>10</td>
<td>random order</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>128</td>
<td>0.012036</td>
<td>0.012106</td>
<td>1651422</td>
<td>10</td>
<td>random order</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Name</th>
<th>Items</th>
<th>Type</th>
<th>Best</th>
<th>Average</th>
<th>Compares</th>
<th>Samples</th>
<th>Distribution</th>
</tr>
</thead>
<tbody>
<tr>
<td>qsort</td>
<td>100000</td>
<td>64</td>
<td>0.009368</td>
<td>0.009600</td>
<td>1536323</td>
<td>10</td>
<td>random order</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>64</td>
<td>0.004311</td>
<td>0.004383</td>
<td>1651422</td>
<td>10</td>
<td>random order</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Name</th>
<th>Items</th>
<th>Type</th>
<th>Best</th>
<th>Average</th>
<th>Compares</th>
<th>Samples</th>
<th>Distribution</th>
</tr>
</thead>
<tbody>
<tr>
<td>qsort</td>
<td>100000</td>
<td>32</td>
<td>0.008917</td>
<td>0.009079</td>
<td>1536558</td>
<td>10</td>
<td>random order</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.003550</td>
<td>0.003554</td>
<td>1650950</td>
<td>10</td>
<td>random order</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>qsort</td>
<td>100000</td>
<td>32</td>
<td>0.006732</td>
<td>0.006882</td>
<td>1532595</td>
<td>10</td>
<td>random % 100</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.002869</td>
<td>0.002874</td>
<td>1377639</td>
<td>10</td>
<td>random % 100</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>qsort</td>
<td>100000</td>
<td>32</td>
<td>0.002248</td>
<td>0.002406</td>
<td>815024</td>
<td>10</td>
<td>ascending order</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.000200</td>
<td>0.000203</td>
<td>99999</td>
<td>10</td>
<td>ascending order</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>qsort</td>
<td>100000</td>
<td>32</td>
<td>0.003086</td>
<td>0.003249</td>
<td>915016</td>
<td>10</td>
<td>ascending saw</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.000945</td>
<td>0.000960</td>
<td>368067</td>
<td>10</td>
<td>ascending saw</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>qsort</td>
<td>100000</td>
<td>32</td>
<td>0.002502</td>
<td>0.002591</td>
<td>884462</td>
<td>10</td>
<td>pipe organ</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.000481</td>
<td>0.000483</td>
<td>277410</td>
<td>10</td>
<td>pipe organ</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>qsort</td>
<td>100000</td>
<td>32</td>
<td>0.002462</td>
<td>0.002519</td>
<td>853904</td>
<td>10</td>
<td>descending order</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.000165</td>
<td>0.000166</td>
<td>99999</td>
<td>10</td>
<td>descending order</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>qsort</td>
<td>100000</td>
<td>32</td>
<td>0.003308</td>
<td>0.003398</td>
<td>953901</td>
<td>10</td>
<td>descending saw</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.000946</td>
<td>0.000955</td>
<td>380124</td>
<td>10</td>
<td>descending saw</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>qsort</td>
<td>100000</td>
<td>32</td>
<td>0.003960</td>
<td>0.004027</td>
<td>1012038</td>
<td>10</td>
<td>random tail</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.001278</td>
<td>0.001281</td>
<td>562760</td>
<td>10</td>
<td>random tail</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>qsort</td>
<td>100000</td>
<td>32</td>
<td>0.005834</td>
<td>0.005985</td>
<td>1200828</td>
<td>10</td>
<td>random half</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.002162</td>
<td>0.002176</td>
<td>974954</td>
<td>10</td>
<td>random half</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>qsort</td>
<td>100000</td>
<td>32</td>
<td>0.004132</td>
<td>0.004509</td>
<td>1209200</td>
<td>10</td>
<td>ascending tiles</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.002137</td>
<td>0.002224</td>
<td>658723</td>
<td>10</td>
<td>ascending tiles</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>qsort</td>
<td>100000</td>
<td>32</td>
<td>0.005134</td>
<td>0.005557</td>
<td>1553378</td>
<td>10</td>
<td>bit reversal</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.003227</td>
<td>0.003254</td>
<td>1711215</td>
<td>10</td>
<td>bit reversal</td>
</tr>
</tbody>
</table>
</details>
<p dir="auto">The following benchmark was on WSL 2 gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04).
The source code was compiled using gcc -O3 bench.c. Each test was ran 100 times. It&#39;s generated by running the benchmark using
1000000 0 0 as the argument. The benchmark is weighted, meaning the number of repetitions
halves each time the number of items doubles.  A table with the best and average time in seconds can be uncollapsed below the bar graph.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/scandum/quadsort/blob/master/images/graph5.png"><img src="https://github.com/scandum/quadsort/raw/master/images/graph5.png" alt="Graph"/></a></p>
<details><summary><b>data table</b></summary>
<table>
<thead>
<tr>
<th>Name</th>
<th>Items</th>
<th>Type</th>
<th>Best</th>
<th>Average</th>
<th>Compares</th>
<th>Samples</th>
<th>Distribution</th>
</tr>
</thead>
<tbody>
<tr>
<td>qsort</td>
<td>8</td>
<td>32</td>
<td>0.009393</td>
<td>0.010391</td>
<td>17</td>
<td>100</td>
<td>random 8</td>
</tr>
<tr>
<td>quadsort</td>
<td>8</td>
<td>32</td>
<td>0.003489</td>
<td>0.003504</td>
<td>21</td>
<td>100</td>
<td>random 8</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>qsort</td>
<td>32</td>
<td>32</td>
<td>0.014392</td>
<td>0.015333</td>
<td>121</td>
<td>100</td>
<td>random 32</td>
</tr>
<tr>
<td>quadsort</td>
<td>32</td>
<td>32</td>
<td>0.006165</td>
<td>0.006362</td>
<td>146</td>
<td>100</td>
<td>random 32</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>qsort</td>
<td>128</td>
<td>32</td>
<td>0.019507</td>
<td>0.020682</td>
<td>745</td>
<td>100</td>
<td>random 128</td>
</tr>
<tr>
<td>quadsort</td>
<td>128</td>
<td>32</td>
<td>0.008249</td>
<td>0.008440</td>
<td>840</td>
<td>100</td>
<td>random 128</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>qsort</td>
<td>512</td>
<td>32</td>
<td>0.024801</td>
<td>0.025837</td>
<td>3968</td>
<td>100</td>
<td>random 512</td>
</tr>
<tr>
<td>quadsort</td>
<td>512</td>
<td>32</td>
<td>0.009946</td>
<td>0.010153</td>
<td>4388</td>
<td>100</td>
<td>random 512</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>qsort</td>
<td>2048</td>
<td>32</td>
<td>0.029895</td>
<td>0.030677</td>
<td>19962</td>
<td>100</td>
<td>random 2048</td>
</tr>
<tr>
<td>quadsort</td>
<td>2048</td>
<td>32</td>
<td>0.011792</td>
<td>0.011903</td>
<td>21641</td>
<td>100</td>
<td>random 2048</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>qsort</td>
<td>8192</td>
<td>32</td>
<td>0.035080</td>
<td>0.036282</td>
<td>96149</td>
<td>100</td>
<td>random 8192</td>
</tr>
<tr>
<td>quadsort</td>
<td>8192</td>
<td>32</td>
<td>0.013840</td>
<td>0.014034</td>
<td>102965</td>
<td>100</td>
<td>random 8192</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>qsort</td>
<td>32768</td>
<td>32</td>
<td>0.040274</td>
<td>0.041420</td>
<td>450105</td>
<td>100</td>
<td>random 32768</td>
</tr>
<tr>
<td>quadsort</td>
<td>32768</td>
<td>32</td>
<td>0.015838</td>
<td>0.016109</td>
<td>477571</td>
<td>100</td>
<td>random 32768</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>qsort</td>
<td>131072</td>
<td>32</td>
<td>0.045464</td>
<td>0.047044</td>
<td>2062601</td>
<td>100</td>
<td>random 131072</td>
</tr>
<tr>
<td>quadsort</td>
<td>131072</td>
<td>32</td>
<td>0.017921</td>
<td>0.018207</td>
<td>2172670</td>
<td>100</td>
<td>random 131072</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>qsort</td>
<td>524288</td>
<td>32</td>
<td>0.050499</td>
<td>0.051669</td>
<td>9298689</td>
<td>100</td>
<td>random 524288</td>
</tr>
<tr>
<td>quadsort</td>
<td>524288</td>
<td>32</td>
<td>0.019855</td>
<td>0.020284</td>
<td>9739167</td>
<td>100</td>
<td>random 524288</td>
</tr>
</tbody>
</table>
</details>
<h2 dir="auto"><a id="user-content-benchmark-quadsort-vs-pdqsort-pattern-defeating-quicksort" aria-hidden="true" href="#benchmark-quadsort-vs-pdqsort-pattern-defeating-quicksort"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Benchmark: quadsort vs pdqsort (pattern defeating quicksort)</h2>
<p dir="auto">The following benchmark was on WSL 2 gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04)
using the <a href="https://github.com/scandum/wolfsort">wolfsort benchmark</a>.
The source code was compiled using <code>g++ -O3 -w -fpermissive bench.c</code>. Pdqsort is a branchless
quicksort/insertionsort hybrid. Each test was ran 100 times on 100,000 elements. Comparisons
are fully inlined. A table with the best and average time in seconds can be uncollapsed below the bar graph.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/scandum/quadsort/blob/master/images/graph4.png"><img src="https://github.com/scandum/quadsort/raw/master/images/graph4.png" alt="Graph"/></a></p>
<details><summary><b>data table</b></summary>
<table>
<thead>
<tr>
<th>Name</th>
<th>Items</th>
<th>Type</th>
<th>Best</th>
<th>Average</th>
<th>Compares</th>
<th>Samples</th>
<th>Distribution</th>
</tr>
</thead>
<tbody>
<tr>
<td>pdqsort</td>
<td>100000</td>
<td>32</td>
<td>0.002679</td>
<td>0.002701</td>
<td>1</td>
<td>100</td>
<td>random order</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.002675</td>
<td>0.002692</td>
<td>1</td>
<td>100</td>
<td>random order</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>pdqsort</td>
<td>100000</td>
<td>32</td>
<td>0.000777</td>
<td>0.000786</td>
<td>1</td>
<td>100</td>
<td>random % 100</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.001969</td>
<td>0.001988</td>
<td>1</td>
<td>100</td>
<td>random % 100</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>pdqsort</td>
<td>100000</td>
<td>32</td>
<td>0.000085</td>
<td>0.000085</td>
<td>1</td>
<td>100</td>
<td>ascending order</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.000069</td>
<td>0.000069</td>
<td>1</td>
<td>100</td>
<td>ascending order</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>pdqsort</td>
<td>100000</td>
<td>32</td>
<td>0.003489</td>
<td>0.003509</td>
<td>1</td>
<td>100</td>
<td>ascending saw</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.000634</td>
<td>0.000640</td>
<td>1</td>
<td>100</td>
<td>ascending saw</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>pdqsort</td>
<td>100000</td>
<td>32</td>
<td>0.002828</td>
<td>0.002853</td>
<td>1</td>
<td>100</td>
<td>pipe organ</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.000265</td>
<td>0.000267</td>
<td>1</td>
<td>100</td>
<td>pipe organ</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>pdqsort</td>
<td>100000</td>
<td>32</td>
<td>0.000188</td>
<td>0.000189</td>
<td>1</td>
<td>100</td>
<td>descending order</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.000056</td>
<td>0.000057</td>
<td>1</td>
<td>100</td>
<td>descending order</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>pdqsort</td>
<td>100000</td>
<td>32</td>
<td>0.003148</td>
<td>0.003166</td>
<td>1</td>
<td>100</td>
<td>descending saw</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.000636</td>
<td>0.000651</td>
<td>1</td>
<td>100</td>
<td>descending saw</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>pdqsort</td>
<td>100000</td>
<td>32</td>
<td>0.002564</td>
<td>0.002578</td>
<td>1</td>
<td>100</td>
<td>random tail</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.000880</td>
<td>0.000888</td>
<td>1</td>
<td>100</td>
<td>random tail</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>pdqsort</td>
<td>100000</td>
<td>32</td>
<td>0.002638</td>
<td>0.002653</td>
<td>1</td>
<td>100</td>
<td>random half</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.001573</td>
<td>0.001582</td>
<td>1</td>
<td>100</td>
<td>random half</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>pdqsort</td>
<td>100000</td>
<td>32</td>
<td>0.002310</td>
<td>0.002335</td>
<td>1</td>
<td>100</td>
<td>ascending tiles</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.000819</td>
<td>0.000830</td>
<td>1</td>
<td>100</td>
<td>ascending tiles</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>pdqsort</td>
<td>100000</td>
<td>32</td>
<td>0.002660</td>
<td>0.002679</td>
<td>1</td>
<td>100</td>
<td>bit reversal</td>
</tr>
<tr>
<td>quadsort</td>
<td>100000</td>
<td>32</td>
<td>0.002338</td>
<td>0.002357</td>
<td>1</td>
<td>100</td>
<td>bit reversal</td>
</tr>
</tbody>
</table>
</details>
</article>
          </div></div>
  </body>
</html>
