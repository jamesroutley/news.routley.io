<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wordsandbuttons.online/apl_deserves_its_renaissance_too.html">Original</a>
    <h1>APL deserves its renaissance too (2018)</h1>
    
    <div id="readability-page-1" class="page"><div>
	<p>This is <a href="https://wordsandbuttons.online/index.html">Words and Buttons Online</a> — a collection of interactive <a href="https://wordsandbuttons.online/all_tutorials.html">#tutorials</a>, <a href="https://wordsandbuttons.online/all_demos.html">#demos</a><a>, and </a><a href="https://wordsandbuttons.online/all_quizzes.html">#quizzes</a> about <a href="https://wordsandbuttons.online/all_mathematics.html">#mathematics</a>, <a href="https://wordsandbuttons.online/all_algorithms.html">#algorithms</a> and <a href="https://wordsandbuttons.online/all_programming.html">#programming</a>.</p>
	
	<p>
This is the <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Game of Life</a> in <span id="index_apl">APL</span>.
	</p>
	<div>
	<pre>life←{↑1 ⍵∨.∧3 4=+/,¯1 0 1∘.⊖¯1 0 1∘.⌽⊂⍵}</pre>
	</div>
	<p>
I know, I know. I should have started with the introduction. But doesn’t it introduce itself rather well? You can see for yourself that it’s ultimately concise, expressive and utterly alien to all the mainstream computer languages.
	</p>
	<p>
In fact, it didn’t originate as a computer language at all. It was proposed as a better notation for tensor algebra by Harvard mathematician Kenneth E. Iverson. It was meant to be written by hand on a blackboard to transfer mathematic ideas from one person to another.
	</p>
	<p>
But due to its formality, it turned up to be surprisingly good to transfer ideas from people to computers as well. It was made into a computer language in the early 60&#39;s, and these weird symbols like <b>↑</b> or <b>⌽</b> were not a problem at all, because every hardware manufacturer had its own keyboard at the time anyway. ASCII wasn’t yet even ratified.
	</p>
	<p>
Its popularity grew through the following years peaking in the 70&#39;s. Fun fact, the very first portable computer by IBM — IBM 5100 “a 50-lb package of interactive personal computing” — came 6 years before the famous IBM PC and with APL on board.
	</p>
	<img src="https://upload.wikimedia.org/wikipedia/commons/a/af/Ibm5100_%282297950254%29.jpg"/>
	
	<p>
The secret of APL’s popularity was simple: learning all the alien symbols is a one-time investment, and expressiveness — the leverage you as a programmer gain — is for life.
	</p>
	<p>
However, later on, with the rise of BASIC based personal computing and C powered UNIX platform, APL came off the scene. It is still used in some niches, such as in financial sector, so there are people who actually make good money using APL up to this day. But it is, of course, as far from the mainstream as it can get.
	</p>
	<p>
Still, it&#39;s a nice and powerful language. And it&#39;s simple too. You might not believe it, but it’s one of the simplest languages in existence. Here, let me show you how the Game of Life works.
	</p>
	<img src="https://upload.wikimedia.org/wikipedia/commons/e/e5/Gospers_glider_gun.gif"/>
	
	<p>
The left arrow is an assignment, and the brackets mark a function&#39;s body. So this: <b>life←{...}</b> is simply a function definition.
	</p>
	<p>
In APL function&#39;s arguments are tacit, meaning you don’t have to specify a name for every argument, you just know by convention, that the left argument is always <b>⍺</b> and the right is always <b>⍵</b>. But doesn’t it mean that APL functions take only two arguments at most? Not really. When you want to call C-like function like this: <i>foo(x, y, z)</i>, in APL terms you simply pass a tuple of 3 values as a single argument. It’s still one <b>⍵</b>. And you can&#39;t do <i>(a, b, c)foo(x, y, z)</i> in C at all, so APL is actually more powerful than C in this regard.
	</p>
	<p>
Let’s run our life with some input. We’ll use a ⍴ function to form a 5x5 matrix out of a linear array.
	</p>

	<div>
	<pre><span id="input_1"><b>1. Form the <i>in</i> variable as a 5x5 matrix</b>

    in ← 5 5 ⍴ 0 0 0 0 0 0 0 1 0 0
0 0 0 1 0 0 1 1 1 0 0 0 0 0 0





</span></pre>
</div>
	

	<p>
In the Game of Life this figure is called Glider. Running the <i>life</i> function on <i>in</i> will result in this:
	</p>
	<div>
	<pre><span id="life_1"><b>1. Show the <i>in</i> variable</b>

    in

0 0 0 0 0
0 0 <b>1</b> 0 0
0 0 0 <b>1</b> 0
0 <b>1 1 1</b> 0
0 0 0 0 0
</span></pre>
	</div>
	
	<p>
The Glider moves!
	</p>
	<p>
In APL what we would normally call <i>operators</i> are <i>functions</i> too. Things like <b>+</b>, <b>-</b>, <b>×</b> etc. The functions are executed from right to left one at the time. There is no precedence, all the functions are equal.
	</p>
	
	<p>
The first function of the <i>life</i>&#39;s body would be <i>enclose</i>: <b>⊂</b>. What it does — it makes our 5x5 matrix input into a scalar containing 5x5 matrix.
	</p>
	<div>
	<pre><span id="enclose_1"><b>1. Show the <i>in</i> variable</b>

    in

0 0 0 0 0
0 0 1 0 0
0 0 0 1 0
0 1 1 1 0
0 0 0 0 0


</span></pre>
	</div>
	<p>
The next thing, as we&#39;re going right to left, is a bit trickier. It is <i>rotate</i>: <b>⌽</b>. It rotates an array at given index.
	</p>
	<div>
	<pre><span id="rotate_1"><b>1. Rotate an array 1 position left</b>

    1 ⌽ <b>1</b> 2 3 4

2 3 4 <b>1</b>
</span>
	</pre>
	</div>
	<p>
But in our example, it doesn’t go by itself. It is itself an argument for an <i><span id="index_outer_product_operator">outer product operator</span></i>: <b>∘.</b> (in APL functions that take other functions as arguments are called operators).
	</p>
	<p>
And together they do this:
	</p>
	<div>
	<pre><span id="rotate_enclosed_1"><b>1. Enclose the <i>in</i> variable</b>

    ⊂ in

┌─────────┐
│0 0 0 0 0│
│0 0 <b>1</b> 0 0│
│0 0 0 <b>1</b> 0│
│0 <b>1 1 1</b> 0│
│0 0 0 0 0│
└─────────┘</span></pre>
	</div>
	<p>
The next function also goes with an operator. It’s <i>rotate first</i>: <b>⊖</b>. It works pretty much like <i>rotate</i>, but it rotates a nested array around the first level of “nestedness”. Basically, it scrolls matrices.
	</p>
	<div>
	<pre><span id="rotate_vertical_1"><b>1. Just show the <i>in</i></b>

    in

0 0 0 0 0
0 0 <b>1</b> 0 0
0 0 0 <b>1</b> 0
0 <b>1 1 1</b> 0
0 0 0 0 0
</span>
	</pre>
	</div>
	<p>
With the outer product operator and our previous result it goes like this:
	</p>
	<div>
	<pre><span id="rotate_enclosed_vertical_1"><b>1. Enclose the <i>in</i> variable</b>

    ⊂ in

┌─────────┐
│0 0 0 0 0│
│0 0 <b>1</b> 0 0│
│0 0 0 <b>1</b> 0│
│0 <b>1 1 1</b> 0│
│0 0 0 0 0│
└─────────┘












</span></pre>
	</div>
	<p>
The next function in called <i><span id="index_ravel">ravel</span></i>: <b>,</b> and it looks like a comma. What it does, it makes a nested array 1-dimensional.
	</p>
	<div>
	<pre><span id="ravel_1"><b>1. Form the <i>x</i> variable as a 2x3 matrix</b>

    x ← 2 3 ⍴ 1 2 3 4 5 6



</span></pre>
	</div>
	<p>
It doesn’t ravel scalars, so being applied to our 3x3 matrix of enclosed matrices, it would make a linear array of 9 enclosed matrices.
	</p>
	<div>
	<pre>    ,¯1 0 1∘.⊖¯1 0 1∘.⌽⊂in

┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│0 0 0 0 0│0 0 0 0 0│0 0 0 0 0│0 0 0 0 0│0 0 0 0 0│0 0 0 0 0│0 0 0 <b>1</b> 0│0 0 <b>1</b> 0 0│0 <b>1</b> 0 0 0│
│0 0 0 0 0│0 0 0 0 0│0 0 0 0 0│0 0 0 <b>1</b> 0│0 0 <b>1</b> 0 0│0 <b>1</b> 0 0 0│0 0 0 0 <b>1</b>│0 0 0 <b>1</b> 0│0 0 <b>1</b> 0 0│
│0 0 0 <b>1</b> 0│0 0 <b>1</b> 0 0│0 <b>1</b> 0 0 0│0 0 0 0 <b>1</b>│0 0 0 <b>1</b> 0│0 0 <b>1</b> 0 0│0 0 <b>1 1 1</b>│0 <b>1 1 1</b> 0│<b>1 1 1</b> 0 0│
│0 0 0 0 <b>1</b>│0 0 0 <b>1</b> 0│0 0 <b>1</b> 0 0│0 0 <b>1 1 1</b>│0 <b>1 1 1</b> 0│<b>1 1 1</b> 0 0│0 0 0 0 0│0 0 0 0 0│0 0 0 0 0│
│0 0 <b>1 1 1</b>│0 <b>1 1 1</b> 0│<b>1 1 1</b> 0 0│0 0 0 0 0│0 0 0 0 0│0 0 0 0 0│0 0 0 0 0│0 0 0 0 0│0 0 0 0 0│
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘</pre>
	</div>
	<p>
The next piece of code is an operator and function pair. Operator <i>reduce</i>: <b>/</b>, and a function <i>plus</i>: <b>+</b>. As you might guess, it reduces, as in map-reduce, a summation of all the matrices in the linear array.
	</p>
	<div>
	<pre>+/,¯1 0 1∘.⊖¯1 0 1∘.⌽⊂in

┌─────────┐
│0 1 1 1 0│
│0 1 2 2 1│
│1 3 5 4 2│
│1 2 4 3 2│
│1 2 3 2 1│
└─────────┘
	</pre>
	</div>
	<p>
Operator <i>compare</i>: <b>=</b> produces matrices of 0 and 1 based on whether every element in the right argument equals a corresponding element in the left argument. In our case we would use it to filter out 3s and 4s:
	</p>
	<div>
	<pre><span id="compare_1"><b>1. Sum all the rotated matrices</b>

    +/,¯1 0 1∘.⊖¯1 0 1∘.⌽⊂in

┌─────────┐
│0 1 1 1 0│
│0 1 2 2 1│
│1 <span>3</span> 5 <span>4</span> 2│
│1 2 <span>4</span> <span>3</span> 2│
│1 2 <span>3</span> 2 1│
└─────────┘
</span></pre>
	</div>
	<p>
Then there is the logical part. Functions <i>or</i>: <b>∨</b> and <i>and</i>: <b>∧</b> used with the <b>.</b> — the <i><span id="index_inner_product_operator">inner product operator</span></i>. They form an operator that makes an <i>and</i> on every element pair and then an <i>or</i> on a result.
	</p>
	<div>
	<pre><span id="slides_1"><b>1. And function</b>

    1 0 1 0 ∧ 1 1 0 0

1 0 0 0

</span></pre>
	</div>
	<p>
Remember, we didn&#39;t count the neighbors exactly, we counted them along with the value in each cell. This was the 0 0 rotation. Now we have to build our logic around this.
	</p>
<ul>
<li>If the sum is 3 and the cell had 0, then it has 3 neighbors</li>
<li>If the sum is 3 and the cell had 1, then it has 2 neighbors</li>
<li>If the sum is 4 and the cell had 0, then it has 4 neighbors</li>
<li>If the sum is 4 and the cell had 1, then it has 3 neighbors</li>
</ul>
	
	<p>
That&#39;s why when we want our <i>and</i> to work with 3s unconditionally, we supply it with identity matrix 1. And when we want to and 4s with the original input, we supply it with <i>in</i>. Then we only have to <i>or</i> the results so any condition produces a living cell. That&#39;s how <b>1 in ∨.∧ 3 4...</b> works.
	</p>
	<div>
	<pre>    1 in ∨.∧3 4=+/,¯1 0 1∘.⊖¯1 0 1∘.⌽⊂in

┌─────────┐      ⍝   Identity      Original <i>in</i>
│0 0 0 0 0│      ⍝     1 1 1 1 1     0 0 0 0 0
│0 0 0 0 0│      ⍝     1 1 1 1 1     0 0 1 0 0
│0 <span>1</span> 0 <span>1</span> 0│      ⍝     1 <b>1</b> 1 1 1     0 0 0 <b>1</b> 0
│0 0 <span>1</span> <span>1</span> 0│      ⍝     1 1 1 <b>1</b> 1     0 1 <b>1</b> 1 0
│0 0 <span>1</span> 0 0│      ⍝     1 1 <b>1</b> 1 1     0 0 0 0 0
└─────────┘
	</pre>
	</div>
	<p>
The last function <i>mix</i> <b>↑</b> here simply removes enclosure.
	</p>

	<div>
	<pre><span id="mix_1"><b>1. Enclosed</b>

    1 in ∨.∧3 4=+/,¯1 0 1∘.⊖¯1 0 1∘.⌽⊂in

┌─────────┐
│0 0 0 0 0│
│0 0 0 0 0│
│0 1 0 1 0│
│0 0 1 1 0│
│0 0 1 0 0│
└─────────┘
</span></pre>
	</div>
	
	<p>
Not so alien now, is it?
	</p>

	<img src="https://upload.wikimedia.org/wikipedia/commons/a/a2/MCM_Model_70_microcomputer_1974_APL_keyboard.jpg"/>
	
	<p>
If you got interested but not enough to get things installed, you can try an online APL interpreter: <a href="https://tryapl.org/">https://tryapl.org/</a>.
	</p>
	<h2>
But why does it deserve its renaissance after all?
	</h2>
	<p>
The last decade was a renaissance for the <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a> being reborn in <a href="https://clojure.org/">Clojure</a>. Also <a href="https://en.wikipedia.org/wiki/Erlang_(programming_language)">Erlang</a>, being a niche language for telecom, decided to waltz into the mainstream with a plethora of <a href="https://www.google.com/search?q=erlang+web+framework">web frameworks</a>. Even <a href="https://www.haskell.org/">Haskell</a> not only gained popularity on its own but deeply influenced <a href="https://fsharp.org/">F#</a> and <a href="https://www.scala-lang.org/">Scala</a>. APL however, despite its tremendous power, didn&#39;t get too much acclaim.
	</p>
	<p>
My theory is, since it was designed to be written by hand, it didn&#39;t work out very well with an ASCII. Didn&#39;t survive the standardization. Of course, APL has its ASCII friendly descendants inherited its expressiveness but frankly, they are all ugly far beyond the possibility of public success. Roughly 86% of all the fun you get from APL programming comes from the mysterious symbols and the magic behind them. It’s not that APL is alien to computers, it’s just the computers were alien to APL for quite a while.
	</p>
	<p>
But now, with the development of touch interfaces and optical character recognition, it might just get its second chance. Since on a tablet or on a phone you do have to use a virtual keyboard anyway, why not choose APL for its tablet-friendly concision? Or you could even draw APL symbols with your fingers. Not being constrained with the keyboard, you could name your own functions with hand-written symbols as well. You could develop your own truly free-form language just like Iverson did.
	</p>
	<p>
I would love that! Wouldn&#39;t you?
	</p>

	
	</div></div>
  </body>
</html>
