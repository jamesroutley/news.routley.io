<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://alexyorke.github.io//2025/06/29/a-list-is-a-monad/">Original</a>
    <h1>A list is a monad</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p><strong>This post got a lot more interest than expected! Currently working on revising this post to incorporate the excellent suggestions from Hacker News. Having said that, please still provide feedback.</strong></p>

<p>The term “monad” is often invoked when describing patterns in functional programming. Yet explanations typically swing between high-level metaphors and deep mathematical abstractions. Each approach offers part of the picture, intuition without precision, or rigor without intuition but seldom both.</p>

<p>Monads can be <a href="https://en.wikipedia.org/wiki/Idealization_%28philosophy_of_science%29">idealized</a> as a <strong>container</strong> (albeit is <a href="https://byorgey.github.io/blog/posts/2025/06/16/monads-are-not-burritos.html">a flawed metaphor</a>) or context holding a value (or multiple values, or no value), <strong>but in some cases we will get into later on</strong> it’s better to think of it as a <strong>recipe</strong> or <strong>deferred computation</strong> for producing a value. At the heart of monadic programming is the idea that you write <strong>one</strong> function, say, <code>f(x) = x + 1</code>, and then <strong>reuse</strong> it across different contexts without rewriting control-flow logic.</p>

<h2 id="two-flavours-result-vs-recipe">Two Flavours: Result vs Recipe</h2>

<p>While all monads provide a computational context, they generally fall into two flavors:</p>

<ul>
  <li>Monads as “Results”: These represent a value that has already been computed, but with extra context. <code>List&lt;int&gt;</code> is a result with the context. <code>Maybe&lt;int&gt;</code> is the result of a computation with the context of “possible optionalness.” For these, the “container” metaphor is a useful, if limited, starting point.</li>
  <li>Monads as “Recipes”: These represent a computation that has not happened yet. They are a blueprint for producing a value. C#’s <code>Task&lt;T&gt;</code> is a perfect example: it doesn’t hold a value, it holds the promise of a value to be computed asynchronously. For these, the “recipe” metaphor is a much better fit. Unwrapping a task doesn’t give you the computed result, it just gives you the instructions <strong>to</strong> compute it.</li>
</ul>

<p>Sometimes, you can mix the flavors. In this post, we will focus on the first category to build our core intuition. We’ll start with <code>List</code> and <code>Maybe</code> to understand the mechanics of <code>map</code> and <code>flatMap</code> on concrete results. In Part 2, we’ll see how these same patterns unlock immense power when applied to “recipe” monads like <code>Task</code>.</p>

<h2 id="list-map--flatmap-in-practice">List<t>: Map &amp; FlatMap in Practice</t></h2>
<p>To an OOP developer, monadic types (<code>List&lt;T&gt;</code>) might look just like generics. It’s a typical pitfall to think “we have generics, so we have monads,” which isn’t true by itself. Monads do usually involve generic types, but they <strong>require specific operations (Unit and flatMap) and the three monad laws on those types to ensure uniform behavior.</strong> <strong>This is key</strong> and is fundamental to working with monads.</p>

<p>A good example of a monad is a list. You’re likely very familiar with lists and working with lists.</p>

<p>The monad Map operation is responsible for:</p>

<ul>
  <li><strong>Applying your function.</strong> For a <code>List</code>, <code>Map</code> runs <code>f</code> on <em>every</em> element, so the list <code>[0,1,2,3]</code> becomes <code>[1,2,3,4]</code>. If the list doesn’t have any elements, then, well, <code>Map</code> doesn’t call <code>f</code>. <code>f</code> doesn’t need to worry about that. Also, <code>f</code> doesn’t care if it’s a list, all <code>f</code> is, is just <code>f(x) = x + 1</code>. <code>Map</code> is responsible for running it.</li>
  <li><strong>Managing sequencing and combination.</strong> The list context concatenates results into one list. We don’t need to manually modify or re-add elements to the list via <code>Add</code>.</li>
</ul>

<p>Notice that the monad is responsible for running <code>f(x)</code>. This shift means your business logic stays <strong>declarative</strong> and <strong>composable</strong>, you describe <em>what</em> happens to a single value, and the monad describes <em>how</em> and <em>when</em> it happens.</p>

<p>This is different from OO and procedural programming because in procedural programming, if you want to process data, it is your responsibility to understand how to apply the function to your data. We have to use different control constructs to handle different types of data, and are also responsible for the “how”.</p>

<p>Here’s examples in C#:</p>

<div><div><pre><code>
<span>public</span> <span>string</span> <span>f</span><span>(</span><span>string</span> <span>input</span><span>)</span> <span>{</span>
  <span>return</span> <span>input</span> <span>+</span> <span>&#34; -appended text&#34;</span><span>;</span>
<span>}</span>

<span>// 1. List&lt;string&gt;: you must foreach and build a new list</span>

<span>var</span> <span>fruits</span> <span>=</span> <span>new</span> <span>List</span><span>&lt;</span><span>string</span><span>&gt;</span> <span>{</span>
  <span>&#34;apple&#34;</span><span>,</span>
  <span>&#34;banana&#34;</span><span>,</span>
  <span>&#34;cherry&#34;</span>
<span>};</span>

<span>var</span> <span>newFruits</span> <span>=</span> <span>new</span> <span>List</span><span>&lt;</span><span>string</span><span>&gt;</span> <span>();</span>

<span>foreach</span> <span>(</span><span>var</span> <span>fruit</span> <span>in</span> <span>fruits</span><span>)</span>

<span>{</span>

  <span>newFruits</span><span>.</span><span>Add</span><span>(</span><span>f</span><span>(</span><span>fruit</span><span>));</span>

<span>}</span>

<span>// 2. Single string: you must check for null first, then concatenate</span>

<span>string</span> <span>userInput</span> <span>=</span> <span>GetUserInput</span><span>();</span> <span>// could be null</span>

<span>if</span> <span>(</span><span>userInput</span> <span>!=</span> <span>null</span><span>)</span>

<span>{</span>

  <span>userInput</span> <span>=</span> <span>f</span><span>(</span><span>userInput</span><span>);</span>

<span>}</span>

<span>// userInput could still be null here, or, it could be the concatenated result</span>


<span>// 3. Dictionary&lt;string, string&gt;: you must know it’s key/value pairs</span>

<span>var</span> <span>dict</span> <span>=</span> <span>new</span> <span>Dictionary</span><span>&lt;</span><span>string</span><span>,</span> <span>string</span><span>&gt;</span>

  <span>{</span>

    <span>[</span><span>&#34;a&#34;</span><span>]</span> <span>=</span> <span>&#34;alpha&#34;</span><span>,</span>

    <span>[</span><span>&#34;b&#34;</span><span>]</span> <span>=</span> <span>&#34;beta&#34;</span><span>,</span>

    <span>[</span><span>&#34;c&#34;</span><span>]</span> <span>=</span> <span>&#34;gamma&#34;</span>

  <span>};</span>

<span>// can’t modify while iterating, so capture keys first</span>

<span>foreach</span> <span>(</span><span>var</span> <span>key</span> <span>in</span> <span>dict</span><span>.</span><span>Keys</span><span>.</span><span>ToList</span><span>())</span>

<span>{</span>

  <span>dict</span><span>[</span><span>key</span><span>]</span> <span>=</span> <span>f</span><span>(</span><span>dict</span><span>[</span><span>key</span><span>]);</span>

<span>}</span>
</code></pre></div></div>

<p>In this example, we are forced to deal with knowing <strong>how</strong> to procedurally update these structures. For a <code>List</code>, we have to call <code>Add</code>, for the <code>String</code> we can update it in place, for the <code>Dictionary</code>, we have to access the keys. We have to know it’s a <code>List</code> beforehand so we know to use <code>foreach</code>. We have to know it’s just a string to append another string to it. We have to know it’s a <code>Dictionary</code> to know how to iterate and update its keys.</p>

<p>But you still need to <code>foreach</code>, loop, etc. Instead, monads delegate control flow to itself and are responsible for knowing how to update the underlying value(s). Recall, however, that even the simplest of monads (essentially containers) <strong>must implement two methods in order to be monads (Unit and flatMap), and also follow three monad laws.</strong></p>

<h3 id="unit"><strong>Unit</strong></h3>

<p><strong>Unit</strong> moves a raw value into the monadic context, sometimes called “lifting”, “identity”, “return”, “wrap”, or “promotion”, or some fancy operation names like “liftM” or “liftA”.</p>

<ul>
  <li>
    <p>In the list monad (let’s just call it a list), <strong>Unit</strong> takes a single element and returns a list containing that element.</p>
  </li>
  <li>
    <p>For example, given the integer <code>1</code>, Unit produces a list via:</p>
  </li>
</ul>

<p><strong>Example (C#)</strong></p>

<div><div><pre><code><span>var</span> <span>list</span> <span>=</span> <span>new</span> <span>List</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>{</span> <span>1</span> <span>};</span>
</code></pre></div></div>

<p>Nothing about the value <code>1</code> changes, it’s simply wrapped in a <code>List</code>. If you access element <code>0</code> of that list, you get back <code>1</code>. That’s it.</p>

<hr/>

<h3 id="map"><strong>Map</strong></h3>

<p><strong>Map</strong> applies a function to each value inside the monad.</p>

<p>In the <code>List</code>, <code>Map</code> runs a function on every element and outputs a new changed list with that function applied to each element. Don’t overcomplicate it. For example, say there is a function that just adds one to its input, for example <code>f(x) = x + 1</code>. Then, passing this function to <code>Map</code> would simply add one to each element in the list. The list <code>[0,1,2,3]</code> would become <code>[1,2,3,4]</code>.</p>

<h4 id="example-c"><strong>Example (C#):</strong></h4>

<div><div><pre><code><span>var</span> <span>originalList</span> <span>=</span> <span>new</span> <span>List</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>{</span> <span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span> <span>};</span>  
<span>var</span> <span>mapped</span> <span>=</span> <span>originalList</span><span>.</span><span>Map</span><span>(</span><span>x</span> <span>=&gt;</span> <span>x</span> <span>+</span> <span>1</span><span>);</span> <span>// Map doesn’t exist in C# (and instead is called Select in LINQ) but just use this as pseudocode</span>
</code></pre></div></div>

<p><strong>Example (C#, procedural):</strong></p>
<div><div><pre><code><span>var</span> <span>originalList</span> <span>=</span> <span>new</span> <span>List</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>{</span> <span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span> <span>};</span>  
<span>var</span> <span>mappedList</span> <span>=</span> <span>new</span> <span>List</span><span>&lt;</span><span>int</span><span>&gt;();</span>

<span>foreach</span> <span>(</span><span>int</span> <span>x</span> <span>in</span> <span>originalList</span><span>)</span>  
<span>{</span>  
    <span>mappedList</span><span>.</span><span>Add</span><span>(</span><span>x</span> <span>+</span> <span>1</span><span>);</span>  
<span>}</span>
</code></pre></div></div>

<h3 id="how-do-you-get-the-damn-values-out-of-the-monads">How do you get the damn values out of the monads?</h3>

<p>You kind of don’t really want to take them out per-se, unless required. It’s possible to implement a <code>GetValue()</code> method that just returns the underlying value, but when the value leaves the monadic context, we lose its benefits and can no longer compose them.</p>

<p>Recall that a <code>List</code> is a monad, and pretend that it’s your first time using a list. You might say, I don’t want my values trapped in this list, how am I supposed to use them? Then proceed to take them out as separate variables and pass them around individually.</p>

<div><div><pre><code><span>// Pretend it’s your first time with a List&lt;T&gt;  </span>
<span>var</span> <span>numbers</span> <span>=</span> <span>new</span> <span>List</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>{</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span> <span>};</span>

<span>// --- Manual extraction (values “trapped” in the list) ---  </span>
<span>var</span> <span>a</span> <span>=</span> <span>numbers</span><span>[</span><span>0</span><span>];</span>  
<span>var</span> <span>b</span> <span>=</span> <span>numbers</span><span>[</span><span>1</span><span>];</span>  
<span>var</span> <span>c</span> <span>=</span> <span>numbers</span><span>[</span><span>2</span><span>];</span>

<span>// You’d then have to call your function separately on each:  </span>
<span>var</span> <span>r1</span> <span>=</span> <span>AddOne</span><span>(</span><span>a</span><span>);</span>  
<span>var</span> <span>r2</span> <span>=</span> <span>AddOne</span><span>(</span><span>b</span><span>);</span>  
<span>var</span> <span>r3</span> <span>=</span> <span>AddOne</span><span>(</span><span>c</span><span>);</span>
</code></pre></div></div>

<p>But in doing so, you lose the advantage of lists, that is, the ability to store arbitrarily long sequences, the ability to pass all of the values at once, to concatenate with other lists, and the ability to iterate through the items. If you want to add one to each of the items, then you’ll have to individually address each variable and add one to it. It’s very tedious.</p>

<p>Up to this point, monads only look like fancy containers that have to implement two weird methods, Unit and flatMap.</p>

<h2 id="maybe">Maybe<t></t></h2>
<p>Let’s move to a slightly more complex example where it may not always make sense to unwrap or “get at” the underlying value. Let’s create a monad called <code>Maybe</code>, which holds an already-computed result (or the absence of one.)</p>

<p>For simplicity, our MaybeMonad will hold an <code>int</code>, but in a real-world library, this would be a generic <code>Maybe&lt;T&gt;</code>. It’s not exactly a monad yet, because it doesn’t implement <code>flatMap</code> (we’ll get to this in part 2.)</p>

<div><div><pre><code><span>public</span> <span>class</span> <span>MaybeMonad</span> <span>{</span>  
    <span>private</span> <span>int</span> <span>value</span><span>;</span>  
    <span>private</span> <span>bool</span> <span>hasValue</span><span>;</span>  
      
    <span>// Unit  </span>
    <span>public</span> <span>MaybeMonad</span><span>(</span><span>int</span> <span>value</span><span>)</span> <span>{</span>  
        <span>this</span><span>.</span><span>value</span> <span>=</span> <span>value</span><span>;</span>  
        <span>this</span><span>.</span><span>hasValue</span> <span>=</span> <span>true</span><span>;</span>  
    <span>}</span>  
      
    <span>// Unit  </span>
    <span>public</span> <span>MaybeMonad</span><span>()</span> <span>{</span>  
          
    <span>}</span>  
      
    <span>// Map  </span>
    <span>public</span> <span>MaybeMonad</span> <span>Map</span><span>(</span><span>Func</span><span>&lt;</span><span>int</span><span>,</span> <span>int</span><span>&gt;</span> <span>func</span><span>)</span> <span>{</span>  
        <span>if</span> <span>(</span><span>hasValue</span><span>)</span> <span>{</span>  
            <span>return</span> <span>new</span> <span>MaybeMonad</span><span>(</span><span>func</span><span>(</span><span>value</span><span>));</span>  
        <span>}</span>  
          
        <span>return</span> <span>this</span><span>;</span>  
    <span>}</span>  
<span>}</span>
</code></pre></div></div>

<p>The Unit operation is just calling the constructor, that is, there has to be a way to move a value to be inside of a <code>MaybeMonad</code>. The <code>Map</code> operation might feel a bit awkward, because it’s just a single value. You might be used to mapping over a <code>List</code>.</p>

<p>Here’s an example to add <code>1</code> to a <code>MaybeMonad</code>.</p>

<div><div><pre><code><span>var</span> <span>age</span> <span>=</span> <span>new</span> <span>MaybeMonad</span><span>(</span><span>30</span><span>);</span>  
<span>var</span> <span>newAge</span> <span>=</span> <span>age</span><span>.</span><span>Map</span><span>(</span><span>x</span> <span>=&gt;</span> <span>x</span> <span>+</span> <span>1</span><span>);</span>  
<span>// newAge is now 31</span>
</code></pre></div></div>

<p>Or,</p>
<div><div><pre><code><span>var</span> <span>age</span> <span>=</span> <span>new</span> <span>MaybeMonad</span><span>();</span>  
<span>var</span> <span>newAge</span> <span>=</span> <span>age</span><span>.</span><span>Map</span><span>(</span><span>x</span> <span>=&gt;</span> <span>x</span> <span>+</span> <span>1</span><span>);</span>  
<span>// newAge is still nothing, Map decided it should not run f(x) because there is no value</span>
</code></pre></div></div>

<p>It may look very verbose. Why do I have to type all of this stuff to add <code>1</code> to a number? The issue is that age is a <code>MaybeMonad</code>, which defines it as a value that may or may not exist. In the case where there is no value, <code>MaybeMonad</code> doesn’t execute <code>f(x)</code>. You would have to do the same thing if you wrote it procedurally.</p>

<p>Procedurally, we would have written an if statement to check if there was a value, then update it conditionally. So, we would have to be responsible for <strong>how</strong> to run this function:</p>

<div><div><pre><code><span>int</span><span>?</span> <span>age</span> <span>=</span> <span>null</span><span>;</span>  
<span>if</span> <span>(</span><span>age</span> <span>!=</span> <span>null</span><span>)</span> <span>age</span><span>++;</span>
</code></pre></div></div>

<p>Or,</p>
<div><div><pre><code><span>int</span><span>?</span> <span>age</span> <span>=</span> <span>30</span><span>;</span>  
<span>if</span> <span>(</span><span>age</span> <span>!=</span> <span>null</span><span>)</span> <span>age</span><span>++;</span>
</code></pre></div></div>

<p>We can start to see why a monad is not simply a container, or something to be unwrapped. How does one unwrap a <code>MaybeMonad</code>? If it has a value, it’s straightforward, just return the value. If there isn’t a value, then, well, there’s nothing in the container. <code>Nothing</code> is an abstraction the <code>MaybeMonad</code> defines, it isn’t representable via null because null is something, it is null. <code>MaybeMonad</code> defines that no computations can run in the case that a value does not exist. This is where unwrapping the container, or a box doesn’t always make sense.</p>

<p>This means that you can chain computations that themselves return <code>Maybe</code>s, then compose them. The issue with only having <code>Map</code> is that we may end up with extraneous nested containers. For example, let’s say a function returns a <code>Maybe&lt;int&gt;</code>. If we chain it with <code>Map</code>, then the input to that function is also a <code>Maybe&lt;int&gt;</code>, which itself gets wrapped into a Maybe, giving a <code>Maybe&lt;Maybe&lt;int&gt;</code>. We need another way to chain the computations, but to avoid having the unnecessary nested containers as we compose monads.</p>

<h3 id="flatmap"><strong>flatMap</strong></h3>

<p><code>flatMap</code> is like our <code>Map</code>, but it also flattens the result. <strong>flatMap provides the ability to chain computations that themselves produce monadic values, which is the defining feature of monads.</strong> For example, if you have a function that looks up a user and returns a <code>Maybe&lt;User&gt;</code>, but you want to pass it to another function that returns the user’s profile. Using Map would give you a <code>Maybe&lt;Maybe&lt;UserProfile&gt;&gt;</code>, an awkward nested container because the input would be a <code>Maybe&lt;UserProfile&gt;</code>. With <code>flatMap</code>, you both apply your lookup and collapse the layers in one go, so you can seamlessly sequence optional, error-handling, or asynchronous operations (e.g. promises/tasks) without ever wrestling with nested monadic types.</p>

<div><div><pre><code><span>Maybe</span><span>&lt;</span><span>User</span><span>&gt;</span> <span>lookupUser</span><span>(</span><span>string</span> <span>id</span><span>)</span>
<span>{</span>
    <span>// Call your data‐access method which already returns Maybe&lt;User&gt;</span>
    <span>return</span> <span>GetUserFromDatabase</span><span>(</span><span>id</span><span>);</span>
<span>}</span>

<span>Maybe</span><span>&lt;</span><span>string</span><span>&gt;</span> <span>userIdMaybe</span> <span>=</span> <span>GetUserId</span><span>();</span>

<span>// Map gives Maybe&lt;Maybe&lt;User&gt;&gt; (nested container) because LookupUser returns a Maybe&lt;User&gt;  </span>
<span>// This quickly becomes unwieldy, and these nested containers do not help us and make it difficult to process values later on  </span>
<span>var</span> <span>nested</span> <span>=</span> <span>userIdMaybe</span>  
    <span>.</span><span>Map</span><span>(</span><span>lookupUser</span><span>);</span>

<span>// flatMap collapses it to Maybe&lt;User&gt;  </span>
<span>var</span> <span>user</span> <span>=</span> <span>userIdMaybe</span>  
    <span>.</span><span>FlatMap</span><span>(</span><span>lookupUser</span><span>);</span>
</code></pre></div></div>

<p><code>flatMap</code> is arguably much more important than Map, in fact, <code>flatMap</code> is a requirement to implement a monad and itself can implement <code>Map</code>.</p>

<p>Procedurally, it might look like this:</p>

<div><div><pre><code><span>string</span> <span>userId</span> <span>=</span> <span>GetUserId</span><span>();</span> <span>// could be null  </span>
<span>if</span> <span>(</span><span>userId</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
  <span>// throw an error, stop, etc.  </span>
<span>}</span>

<span>var</span> <span>user</span> <span>=</span> <span>GetUserFromDatabase</span><span>(</span><span>userId</span><span>);</span> <span>// user is a User or null  </span>
<span>if</span> <span>(</span><span>user</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
  <span>// error here  </span>
<span>}</span> <span>else</span> <span>{</span>
  <span>// user is valid  </span>
<span>}</span>
</code></pre></div></div>

<p>In the procedural example, notice that we have to specify the control flow ourselves, however, in the monadic example, control flow is implied through the monads. If <code>userIdMaybe</code> doesn’t contain a value, then <code>flatMap</code> just doesn’t execute <code>lookupUser</code>.</p>

<p>In the mondaic example, you could write:</p>

<div><div><pre><code><span>Maybe</span><span>&lt;</span><span>string</span><span>&gt;</span> <span>userIdMaybe</span> <span>=</span> <span>GetUserId</span><span>();</span>
<span>Maybe</span><span>&lt;</span><span>User</span><span>&gt;</span> <span>=</span> <span>userIdMaybe</span><span>.</span><span>FlatMap</span><span>(</span><span>lookupUser</span><span>);</span>
</code></pre></div></div>

<p>The control flow is handled by the monads. <code>GetUserId</code> returns a <code>Maybe</code> because we’ve defined <code>Maybe</code> as something that may or may not have a value. Its semantics and how it runs subsequent functions are inside of <code>Maybe</code>. This means that if <code>userIdMaybe</code> doesn’t have a user id, then <code>lookupUser</code> doesn’t run. This is not mysterious, we’ve defined <code>Maybe</code> to not run subsequent functions when there is no value.</p>

<p>This is why it makes sense to have everything as monads, so that you can chain the <code>Maybe</code> monad with other monads, like a pipeline and keep it in the mondaic context.</p>

<p>If you try to take the value out right away (let’s assume we had a <code>GetValue()</code> command that returned the value, or <code>null</code> otherwise):</p>

<div><div><pre><code><span>Maybe</span><span>&lt;</span><span>string</span><span>&gt;</span> <span>userIdMaybe</span> <span>=</span> <span>GetUserId</span><span>();</span>
<span>var</span> <span>actualUserId</span> <span>=</span> <span>userIdMaybe</span><span>.</span><span>GetValue</span><span>();</span>
<span>if</span> <span>(</span><span>actualUserId</span> <span>!=</span> <span>null</span><span>)</span> <span>{...}</span>
</code></pre></div></div>

<p>Eww. If it’s treated as simply a container, then it looks like a waste of time, why am I putting a value into this and just taking it out again immediately? What’s the point? I think this is where a lot of people stop when studying monads (myself previously.) You might think it’s just a burrito, a container, some box, or a package, and there are some fancy academic math stuff with this container thing. In part 2, we’ll go over more advanced monads, which are not simply containers.</p>

<h2 id="monad-laws">Monad Laws</h2>

<p>To be a true monad, a type must not only have Unit and flatMap operations but also obey three simple laws. These laws ensure that chaining operations behaves predictably.</p>

<ol>
  <li>Left Identity: <code>Unit(x).flatMap(f)</code> is the same as <code>f(x)</code>. (Wrapping a value and then immediately applying a function is the same as just applying the function to the value).</li>
  <li>Right Identity: <code>m.flatMap(Unit)</code> is the same as <code>m</code>. (Applying the simplest possible wrapping function shouldn’t change the monad).</li>
  <li>Associativity: <code>m.flatMap(f).flatMap(g)</code> is the same as <code>m.flatMap(x =&gt; f(x).flatMap(g))</code>. (The order in which you group chained operations doesn’t matter).</li>
</ol>

<p>You don’t need to memorize these, but they are the mathematical guarantee that allows monads to be composed so reliably. Our <code>MaybeMonad </code>follows these laws, making it a true monad.</p>

<p>We’ve seen how monads provide a context for computation. By defining two core operations, Unit (to wrap a value) and flatMap (to sequence operations that return a new context), we can abstract away control flow like loops and null-checks. This turns scattered procedural code into a single, declarative expression.</p>

<p>The real power comes from applying this pattern to different contexts. In Part 2, we’ll explore other useful monads like Either for more descriptive error handling and see how to compose them together to manage multiple concerns at once.</p>

<p><a href="https://alexyorke.github.io/2025/06/30/a-list-is-a-monad-part-2/">Part 2</a></p>

  </div>

  
</article>

      </div>
    </div></div>
  </body>
</html>
