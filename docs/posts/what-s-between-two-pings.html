<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bytes.zone/micro/thing-a-month-03-02/">Original</a>
    <h1>what&#39;s between two pings?</h1>
    
    <div id="readability-page-1" class="page"><article><p><em>Brian Hicks, March 5, 2024</em></p><p>I got to thinking about how pings work in this system (<a href="https://bytes.zone/micro/thing-a-month-03-01/">last post</a> and realized an optimization. Right now I&#39;m treating them as though they&#39;re all the same size—that&#39;s safe because of the law of large numbers, remember—but they&#39;re not all the same size! Time varies between pings.</p><span id="continue-reading"></span><p>Say you have these pings with these tags:</p><table><thead><tr><th>Time</th><th>Tag</th></tr></thead><tbody><tr><td>8:00</td><td>work</td></tr><tr><td>9:00</td><td>work</td></tr><tr><td>9:30</td><td>coffee</td></tr><tr><td>10:30</td><td>work</td></tr></tbody></table><p>Assuming we&#39;re comfortable with this small sample as being representative of what you actually did, you can say with confidence that between 8:00 and 9:00 you were working. But sometime (vaguely) between 9:00 and 9:30 you transitioned to making coffee, and sometime (vaguely) between 9:30 and 10:30 you transitioned back to working.</p><p>If we treat every ping as equal, assuming λ is 1 hour, this will be reported as 3 hours (± 0.85 hours) working and one hour (± 0.85 hours) getting coffee. That&#39;s pretty good—or at least enough to get a sense of how you&#39;re spending your time.</p><p>But what if we take advantage of the fact that pings <em>aren&#39;t</em> exactly hourly? We&#39;d have to take care of the vagueness of when you transitioned. In the absence of other data, we might just take the time halfway between two pings as the transition time. So that means that our times look like this:</p><table><thead><tr><th>Time</th><th>Tag</th><th>Duration</th></tr></thead><tbody><tr><td>8:00</td><td>work</td><td>0:30 (halfway to 9)</td></tr><tr><td>9:00</td><td>work</td><td>0:45 (halfway back to 8 plus halfway to 9:30)</td></tr><tr><td>9:30</td><td>coffee</td><td>0:45 (halfway back to 9:30 plus halfway to 10:30)</td></tr><tr><td>10:30</td><td>work</td><td>0:30 (halfway back to 9:30)</td></tr></tbody></table><p>This makes it look like we have less time, though: we now have 2.5 hours tracked instead of 4. This is probably not a problem in real life: we can take pings continuously and tag any that aren&#39;t answered as &#34;afk.&#34; If we really need to, it&#39;s probably safe to double the duration of the first and last ping, giving us a total of 3.5 hours in this sample.</p><p>But does it give us better insight into our life? Let&#39;s see. Doing this by hand:</p><table><thead><tr><th>Tag</th><th>Ping as hour</th><th>Ping as halfway between</th></tr></thead><tbody><tr><td>work</td><td>3h ± 0.85h</td><td>2.75h ± 0.82h</td></tr><tr><td>coffee</td><td>1h ± 0.85h</td><td>0.75h ± 0.82h</td></tr></tbody></table><p>It feels weird to me that the error bar goes below zero for coffee now. I definitely didn&#39;t spend <em>no</em> time on it, much less negative time. But let&#39;s pretend that getting coffee took 15 minutes and the remainder of the 4 hours was spent working: both of these systems produce a perfectly acceptable answer to the question of &#34;where did my day go?&#34;</p><p>Given that, I think the first version of this system should assume that pings are <code>1 hour / λ</code> or similar instead of trying to get fancy. The transformation is not <em>that</em> hard (I&#39;ll attach a Python script below that can evaluate <a href="https://bytes.zone/micro/thing-a-month-03-01/">the same data I generated in the last post</a>) so it would hypothetically be feasible to change if it looked like there was a big advantage to doing so. Although I want to be careful to avoid giving precise-but-fuzzy numbers, though: sticking with a rougher-grained unit as a base unit probably makes a ton of sense for setting expectations… you wouldn&#39;t want to bill a client on data from this system, for example!</p><p>All this talk of coffee has made me want some. brb.</p><pre data-lang="python"><code data-lang="python"><span>#!/usr/bin/env python3
</span><span>import </span><span>argparse
</span><span>import </span><span>collections
</span><span>from </span><span>datetime </span><span>import </span><span>datetime, timedelta
</span><span>import </span><span>json
</span><span>import </span><span>math
</span><span>import </span><span>sys
</span><span>
</span><span>
</span><span>class </span><span>Ping</span><span>:
</span><span>    </span><span>def </span><span>__init__</span><span>(</span><span>self</span><span>, </span><span>at</span><span>, </span><span>tag</span><span>, </span><span>duration</span><span>):
</span><span>        </span><span>self</span><span>.at </span><span>= </span><span>at
</span><span>        </span><span>self</span><span>.tag </span><span>= </span><span>tag
</span><span>        </span><span>self</span><span>.duration </span><span>= </span><span>duration
</span><span>
</span><span>    @</span><span>classmethod
</span><span>    </span><span>def </span><span>from_json</span><span>(</span><span>cls</span><span>, </span><span>obj</span><span>):
</span><span>        </span><span>return </span><span>cls</span><span>(datetime.</span><span>fromisoformat</span><span>(obj[</span><span>&#39;at&#39;</span><span>]), obj[</span><span>&#39;tag&#39;</span><span>], </span><span>timedelta</span><span>(</span><span>0</span><span>))
</span><span>
</span><span>    </span><span>def </span><span>__repr__</span><span>(</span><span>self</span><span>):
</span><span>        </span><span>return f</span><span>&#34;&lt;Ping at=</span><span>{</span><span>self</span><span>.at.</span><span>isoformat</span><span>()}</span><span> tag=</span><span>{</span><span>repr</span><span>(</span><span>self</span><span>.tag)}</span><span>, duration=</span><span>{</span><span>str</span><span>(</span><span>self</span><span>.duration)}</span><span>&gt;&#34;
</span><span>
</span><span>
</span><span>def </span><span>main</span><span>(</span><span>args</span><span>):
</span><span>    pings </span><span>= </span><span>[Ping.</span><span>from_json</span><span>(obj) </span><span>for </span><span>obj </span><span>in </span><span>json.</span><span>load</span><span>(sys.stdin)]
</span><span>
</span><span>    </span><span>for </span><span>(i, ping) </span><span>in </span><span>enumerate</span><span>(pings):
</span><span>        </span><span>if </span><span>i </span><span>== </span><span>0</span><span>:
</span><span>            </span><span>continue
</span><span>
</span><span>        before </span><span>= </span><span>pings[i</span><span>-</span><span>1</span><span>]
</span><span>
</span><span>        halfway </span><span>= </span><span>(ping.at </span><span>- </span><span>before.at) </span><span>/ </span><span>2
</span><span>        ping.duration </span><span>+= </span><span>halfway
</span><span>        before.duration </span><span>+= </span><span>halfway
</span><span>
</span><span>    total_seconds </span><span>= </span><span>sum</span><span>((ping.duration.</span><span>total_seconds</span><span>() </span><span>for </span><span>ping </span><span>in </span><span>pings))
</span><span>    </span><span>print</span><span>(</span><span>f</span><span>&#34;From </span><span>{</span><span>timedelta</span><span>(</span><span>seconds</span><span>=</span><span>total_seconds)}</span><span> hours tracked...</span><span>\n</span><span>&#34;</span><span>)
</span><span>
</span><span>    total_seconds_by_tag </span><span>= </span><span>collections.</span><span>Counter</span><span>()
</span><span>    </span><span>for </span><span>ping </span><span>in </span><span>pings:
</span><span>        total_seconds_by_tag[ping.tag] </span><span>+= </span><span>ping.duration.</span><span>total_seconds</span><span>()
</span><span>
</span><span>    </span><span>for </span><span>(tag, tag_total) </span><span>in </span><span>total_seconds_by_tag.</span><span>most_common</span><span>():
</span><span>        proportion </span><span>= </span><span>tag_total </span><span>/ </span><span>total_seconds
</span><span>        other_ping_proportion </span><span>= </span><span>1 </span><span>- </span><span>proportion
</span><span>        sem </span><span>= </span><span>math.</span><span>sqrt</span><span>(proportion </span><span>* </span><span>other_ping_proportion </span><span>/ </span><span>len</span><span>(pings))
</span><span>        plus_minus </span><span>= </span><span>sem </span><span>* </span><span>total_seconds
</span><span>
</span><span>        </span><span>print</span><span>(</span><span>f</span><span>&#34;</span><span>{tag}</span><span>\t</span><span>{tag_total</span><span>/</span><span>60</span><span>/</span><span>60:.2f</span><span>}</span><span> hours</span><span>\t</span><span>plus or minus </span><span>{plus_minus</span><span>/</span><span>60</span><span>/</span><span>60:.2f</span><span>}</span><span> hours&#34;</span><span>)
</span><span>
</span><span>
</span><span>if </span><span>__name__ </span><span>== </span><span>&#39;__main__&#39;</span><span>:
</span><span>    parser </span><span>= </span><span>argparse.</span><span>ArgumentParser</span><span>()
</span><span>    parser.</span><span>add_argument</span><span>(</span><span>&#39;-l&#39;</span><span>, </span><span>type</span><span>=</span><span>float, </span><span>default</span><span>=</span><span>1</span><span>)
</span><span>
</span><span>    </span><span>main</span><span>(parser.</span><span>parse_args</span><span>())
</span></code></pre></article></div>
  </body>
</html>
