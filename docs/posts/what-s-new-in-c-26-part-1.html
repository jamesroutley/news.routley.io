<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mariusbancila.ro/blog/2024/09/06/whats-new-in-c26-part-1/">Original</a>
    <h1>What&#39;s new in C&#43;&#43;26 (part 1)</h1>
    
    <div id="readability-page-1" class="page"><article id="post-4733">

	

	
	<div>
		
<p>The C++26 version of the C++ standard is a work in progress, but a series of language and library features have been already added. Furthermore, some of them are already supported by Clang and GCC. One of these new changes was discussed in my previous article, <a href="https://mariusbancila.ro/blog/2024/04/21/erroneous-behaviour-has-entered-the-chat/" target="_blank" rel="noopener" title="">Erroneous behaviour has entered the chat</a>. In this post, we will look at several language features added in C++26.</p>



<h2>Specifying a reason for deleting a function</h2>



<p>Since C++11, we can declare a function as deleted, so that the compiler will prevent its use. This can be used to prevent the use of class special member functions, but also to delete any other function. A function can be deleted as follows (example from the proposal paper):</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">class NonCopyable
{
public:
    // ...
    NonCopyable() = default;

    // copy members
    NonCopyable(const NonCopyable&amp;) = delete;
    NonCopyable&amp; operator=(const NonCopyable&amp;) = delete;
    // maybe provide move members instead
};</pre>



<p>In C++26, you can specify a reason why this function is deleted:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">class NonCopyable
{
public:
    // ...
    NonCopyable() = default;

    // copy members
    NonCopyable(const NonCopyable&amp;)
        = delete(&#34;Since this class manages unique resources, copy is not supported; use move instead.&#34;);
    NonCopyable&amp; operator=(const NonCopyable&amp;)
        = delete(&#34;Since this class manages unique resources, copy is not supported; use move instead.&#34;);
    // provide move members instead
};</pre>



<p>The reason for having this feature is to help API authors to provide tailored messages for the removal of a function, instead of just relying on the generic compiler error for using a deleted function.</p>



<p>For more info see: <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2573r2.html" target="_blank" rel="noopener" title="">P2573R2: = delete(“should have a reason”);</a></p>



<h2>Placeholder variables with no name</h2>



<p>There are cases when a variable has to be declared but its name is never used. An example is structure bindings. Another is locks (like <code>lock_guard</code>), that are only used for their side-effects. In the future, another example could be pattern matching (for which several proposals exist).</p>



<p>In C++26, we can use a single underscore (<code>_</code>) to define an unnamed variable.</p>



<p>For instance, in the following example, <code>unused</code> is a variable that is not used:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">[[maybe_unused]] auto [data, unused] = get_data();</pre>



<p>In C++26, the <code>unused</code> variable can be named <code>_</code> (single underscore):</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">auto [data, _] = get_data();</pre>



<p>When the single underscore identifier is used for the declaration of a variable, non-static class member variable, lambda capture, or structure binding, the <code>[[maybe_unused]]</code> attribute is implicitly added, therefore, there is no need to explicitly use it.</p>



<p>A declaration with the name <code>_</code> is said to be <em>name-independent</em> if it declares:</p>



<ul><li>a variable with automatic storage duration</li><li>a structure binding, but not in a namespace scope</li><li>a variable introduced by an init capture</li><li>a non-static data member</li></ul>



<p>The compiler will not emit warnings that a name-independent declaration is used or not. Moreover, multiple name-independent declarations can be used in the same scope (that is not a namespace scope):</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">int main()
{
  int _;
  _ = 0;         // OK

  std::string _; // OK, because _ is a name-independent declaration
  _ = &#34;0&#34;;       // Error: ambiguous reference to placeholder &#39;_&#39;, which is defined multiple times
}</pre>



<p>On the other hand, the following is not possible:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">int main()
{
  int _;
  _ = 0;                // OK

  static std::string _; // Error: static variables are not name-independent
}</pre>



<p>The following is also not possible, because the declarations are in a namespace scope:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">namespace n
{
  int f() {return 42;}

  auto _ = f(); // OK
  auto _ = f(); // Error: redefinition of _
}</pre>



<p>To learn more about this feature see: <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2169r4.pdf" target="_blank" rel="noopener" title="">P2169: A nice placeholder with no name</a>.</p>



<h2>Structured binding declaration as a condition</h2>



<p>A structure binding defines a set of variables that are bound to sub-objects or elements of their initializer.</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">auto [position, length] = get_next_token(text, offset);</pre>



<p>A structure binding can appear in a for-range declaration, such as in the following example:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">for (auto [position, length] : tokenize(text, offset))
{
  std::println(&#34;pos {}, len {}&#34;, position, length);
}</pre>



<p>On the other hand, variables can appear in the condition of an <code>if</code>, <code>while</code>, or <code>for</code> statement:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">if (auto it = std::find_if(begin(arr), end(arr), is_even); it != std::end(arr))
{
  std::println(&#34;{} is the 1st even number&#34;, *it);
}</pre>



<p>However, structure bindings cannot be declared in the condition of an <code>if</code>, <code>while</code>, or <code>for</code> statement. That changes in C++26, which makes it possible:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">if(auto [position, length] = get_next_token(text, offset); position &gt;= 0)
{
  std::println(&#34;pos {}, len {}&#34;, position, length);
}</pre>



<p>An interesting and very useful case is presented in the proposal paper (P0963). Consider the following C++26 example for using <code>std::to_chars</code>:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">if (auto result = std::to_chars(p, last, 42))
{
​​​​    auto [ptr, _] = result;
​​​​    // okay to proceed
​​​​} 
else 
{
​​​​    auto [ptr, ec] = result;
​​​​    // handle errors
​​​​}</pre>



<p>When the function succeeds, we are only interested in the <code>ptr</code> member of <code>std::to_chars_result</code>, which contains a pointer to the one-past-the-end pointer of the characters written. If the function fails, then we also need to look at the <code>ec</code> member (of the <code>std::errc</code> type) representing an error code.</p>



<p>This code can be simplified with structure bindings, in C++26, as follows:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">​​​​if (auto [ptr, ec] = std::to_chars(p, last, 42))
{
​​​​    // okay to proceed
​​​​} 
else 
{
​​​​    // handle errors
​​​​}</pre>



<p>To learn more about this feature see: <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0963r3.html" target="_blank" rel="noopener" title="">P0963: Structured binding declaration as a condition</a>.</p>



<h2>user-generated static_assert messages</h2>



<p>The <code>static_assert</code>‘s second parameter, which is a string representing the error message, can now be a compile-time user-generated string-like object. The following example uses a hypothetical constexpr <code>std::format</code>, although this may also later appear in C++26:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">static_assert(sizeof(int) == 4, std::format(&#34;Expected 4, actual {}&#34;, sizeof(int)));</pre>



<p>To learn more about this feature see: <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2741r3.pdf" target="_blank" rel="noopener" title="P2471R3: user-generated static_assert messages">P2471R3: user-generated static_assert messages</a>.</p>





	</div><!-- .entry-content -->

	</article></div>
  </body>
</html>
