<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.sunfishcode.online/bugs-in-hello-world/">Original</a>
    <h1>Bugs in Hello World</h1>
    
    <div id="readability-page-1" class="page"><article>
  

  
    <p>Posted on <time datetime="2022-03-08T00:00:00+00:00">March 08, 2022</time></p>
  

  <p>Hello World might be the most frequently written computer program. For decades,
it&#39;s been the first program many people write, when getting started in a new
programming language.</p>
<p>Surely, this humble starting-point program should be bug free, right?</p>
<p><a href="https://www.monkeyuser.com/2019/bug-free/"><img src="https://www.monkeyuser.com/assets/images/2019/131-bug-free.png" alt="&#34;Bug Free&#34; comic at monkeyuser.com"/></a></p>
<p>After all, hello world programs only do one thing. How could there be a bug?</p>
<h2 id="hello-world-in-c">Hello world in C</h2>
<p>There are a lot of different ways to write hello world in C. There&#39;s
the <a href="https://en.wikipedia.org/wiki/%22Hello,_World!%22_program#C">Wikipedia version</a>, <a href="https://riptutorial.com/c/example/3675/original--hello--world---in-k-r-c">the hello world in the K&amp;R book</a>, and there&#39;s
even [the oldest known C hello world program from 1974].</p>
<p><a title="Brian Kernighan, CC BY-SA 3.0 &lt;https://creativecommons.org/licenses/by-sa/3.0&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Hello_World_Brian_Kernighan_1978.jpg"><img width="512" alt="Hello World Brian Kernighan 1978" src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/Hello_World_Brian_Kernighan_1978.jpg/512px-Hello_World_Brian_Kernighan_1978.jpg"/></a></p>
<p>Here&#39;s another, this one <a href="http://helloworldcollection.de/#C%C2%A0(ANSI)">in &#34;ANSI C&#34;</a>:</p>
<pre data-lang="c"><code data-lang="c"><span>/* Hello World in C, Ansi-style */
</span><span>
</span><span>#include </span><span>&lt;</span><span>stdio.h</span><span>&gt;
</span><span>#include </span><span>&lt;</span><span>stdlib.h</span><span>&gt;
</span><span>
</span><span>int </span><span>main</span><span>(</span><span>void</span><span>)
</span><span>{
</span><span>  </span><span>puts</span><span>(&#34;</span><span>Hello World!</span><span>&#34;);
</span><span>  </span><span>return</span><span> EXIT_SUCCESS;
</span><span>}
</span></code></pre>
<p>This is the most careful version of the bunch. It uses <code>(void)</code> to ensure that
<code>main</code> is a new-style declaration. It uses the <code>EXIT_SUCCESS</code> macro instead
of just assuming that the platform uses 0 to indicate success, which isn&#39;t
necessary, according to the C standard, but we&#39;re not taking any chances here.
And it uses the appropriate headers to avoid implicitly declaring <code>puts</code>. This
version attempts to do <em>everything</em> right.</p>
<p>And yet, it still has a bug.</p>
<p>All the versions linked above have a bug.</p>
<h2 id="a-bug">A bug?</h2>
<p>Linux has this fun device file called &#34;/dev/full&#34;, which is like its more
famous cousin &#34;/dev/null&#34;, but when you write to &#34;/dev/full&#34;, instead of
throwing away the data, it fails. It acts like a file on a filesystem that
has just run out of space:</p>
<pre data-lang="sh"><code data-lang="sh"><span>$</span><span> echo &#34;</span><span>Hello World!</span><span>&#34; &gt; /dev/full
</span><span>bash:</span><span> echo: write error: No space left on device
</span><span>$</span><span> echo $</span><span>?
</span><span>1
</span></code></pre>
<p>This is a great little tool for testing that programs handle I/O errors
correctly. It&#39;s inconvenient to create actual filesystems with no
space left, or disks that actually fail, but it&#39;s really easy to ask a
program to write its output to &#34;/dev/full&#34; and see what happens.</p>
<p>So let&#39;s test the C example above:</p>
<pre data-lang="sh"><code data-lang="sh"><span>$</span><span> gcc hello.c</span><span> -o</span><span> hello
</span><span>$</span><span> ./hello &gt; /dev/full
</span><span>$</span><span> echo $</span><span>?
</span><span>0
</span></code></pre>
<p>Unlike when we used <code>echo</code> in the shell above, here, we got no output, and
the exit status was zero. That means the <code>hello</code> program reported successful
execution. However, it didn&#39;t actually succeed. We can confirm that it
encounters a failure using <a href="https://man7.org/linux/man-pages/man1/strace.1.html">strace</a>:</p>
<pre data-lang="sh"><code data-lang="sh"><span>$</span><span> strace</span><span> -etrace</span><span>=write ./hello &gt; /dev/full
</span><span>write</span><span>(1, &#34;</span><span>Hello World!\n</span><span>&#34;, 13)          = </span><span>-1</span><span> ENOSPC (No space left on device)
</span><span>+++</span><span> exited with 0 +++
</span></code></pre>
<p>There&#39;s our &#34;No space&#34; error getting reported by the OS, but no matter,
the program silently swallows it and returns 0, the code for success. That&#39;s
a bug!</p>
<p>How severe is this bug? Arguably, hello world isn&#39;t going to be safety-critical
anywhere. However, hello world does do something that programs in the real
world do: print to standard output, which might be redirected to a file. And
files in the real world can run out of space. If a program doesn&#39;t detect this
kind of error and report it through its return code, its parent process won&#39;t
know that the child failed, and will continue running as if nothing was wrong,
even though the output it expected to have been produced has silently lost data.</p>
<p>For example, consider a program that prints a <a href="https://yaml.org/">yaml</a> file to standard output.
If standard output runs out of space, the output may be truncated at some
arbitrary point, though it <a href="https://www.sqlservercentral.com/editorials/do-you-have-all-the-yaml">may still be valid yaml</a>. So we should expect
programs to detect and report this kind of situation.</p>
<h2 id="what-about-other-languages">What about other languages?</h2>
<p>We looked at bash and C above; what about Python, which tells us that
<a href="https://www.python.org/dev/peps/pep-0020/#id2">&#34;Errors should never pass silently&#34;</a>? Here&#39;s Python 2:</p>
<pre data-lang="sh"><code data-lang="sh"><span>$</span><span> python2 hello.py &gt; /dev/full
</span><span>close</span><span> failed in file object destructor:
</span><span>sys.excepthook</span><span> is missing
</span><span>lost</span><span> sys.stderr
</span><span>$</span><span> echo $</span><span>?
</span><span>0
</span></code></pre>
<p>It did print a message to stderr, though it&#39;s a confusing message. However, it
also returned 0, which means it&#39;s telling whoever ran it that it exited
succeesfully.</p>
<p>Fortunately, Python 3 properly reports the error, and prints a nicer
error message too:</p>
<pre data-lang="sh"><code data-lang="sh"><span>$</span><span> python3 hello.py &gt; /dev/full
</span><span>Exception</span><span> ignored in: &lt;_io.TextIOWrapper name=&#39;</span><span>&lt;stdout&gt;</span><span>&#39; mode=&#39;</span><span>w</span><span>&#39; encoding=&#39;</span><span>utf-8</span><span>&#39;&gt;
</span><span>OSError: </span><span>[</span><span>Errno 28</span><span>]</span><span> No space left on device
</span><span>$</span><span> echo $</span><span>?
</span><span>120
</span></code></pre>
<p>Using hello world programs from common tutorial sites in a few languages that
I happened to try, here are the results:</p>
<table><thead><tr><th>Language</th><th>Has the bug</th><th>Versions tested</th></tr></thead><tbody>
<tr><td>C</td><td>Yes</td><td>(all)</td></tr>
<tr><td>C++</td><td>Yes</td><td>(all)</td></tr>
<tr><td>Python 2</td><td>Yes</td><td><code>Python 2.7.18</code></td></tr>
<tr><td>Ruby</td><td>Yes</td><td><code>ruby 2.7.2p137 (2020-10-01 revision 5445e04352) [x86_64-linux-gnu]</code></td></tr>
<tr><td>Java</td><td>Yes</td><td><code>openjdk 11.0.11 2021-04-20</code></td></tr>
<tr><td>Node.js</td><td>Yes</td><td><code>v12.21.0</code></td></tr>
<tr><td>Haskell</td><td>Yes</td><td><code>The Glorious Glasgow Haskell Compilation System, version 8.8.4</code></td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>Rust</td><td>No</td><td><code>rustc 1.59.0 (9d1b2106e 2022-02-23)</code></td></tr>
<tr><td>Python 3</td><td>No</td><td><code>Python 3.9.5</code></td></tr>
<tr><td>Perl</td><td>No</td><td><code>perl 5, version 32, subversion 1 (v5.32.1) built for x86_64-linux-gnu-thread-multi (with 46 registered patches...)</code></td></tr>
<tr><td>Perl 6</td><td>No</td><td><code>v2020.12</code></td></tr>
<tr><td>Bash</td><td>No</td><td><code>GNU bash, version 5.1.4(1)-release (x86_64-pc-linux-gnu)</code></td></tr>
<tr><td>Awk</td><td>No</td><td><code>GNU Awk 5.1.0, API: 3.0 (GNU MPFR 4.1.0, GNU MP 6.2.1)</code></td></tr>
<tr><td>OCaml</td><td>No</td><td><code>4.08.1</code></td></tr>
<tr><td>Tcl</td><td>No</td><td><code>8.6.11</code></td></tr>
<tr><td>C#</td><td>No</td><td><code>Mono JIT compiler version 6.8.0.105</code></td></tr>
</tbody></table>

</article></div>
  </body>
</html>
