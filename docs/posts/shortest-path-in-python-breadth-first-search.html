<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://onestepcode.com/graph-shortest-path-python/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=graph-shortest-path-python">Original</a>
    <h1>Shortest path in Python (Breadth first search)</h1>
    
    <div id="readability-page-1" class="page"><div id="overflow-container">
			<div>
				<div id="main-sidebar">
																<header id="site-header" role="banner">
							<div id="title-container">
																<div>
																		<p>Computer Science learning blog</p>								</div>
							</div>
							
																				</header>
																
									</div>
								<section id="main" role="main">
						<div id="loop-container">
		<div>
			<article>
		
		<div>
						
<p>In this post, we’ll see an implementation of shortest path finding in a graph of connected nodes using Python. The shortest path will be found by traversing the graph in breadth first order. </p>



<h2>Breadth first search</h2>



<p>Let’s consider the following graph.  We will traverse it in breadth first order starting from node <code>0</code>. Our goal will be to find node <code>x</code>.</p>



<div><figure><img loading="lazy" src="https://onestepcode.com/wp-content/uploads/2022/01/breadth-first-search-graph.png" alt="" width="261" height="206" srcset="https://onestepcode.com/wp-content/uploads/2022/01/breadth-first-search-graph.png 521w, https://onestepcode.com/wp-content/uploads/2022/01/breadth-first-search-graph-300x237.png 300w" sizes="(max-width: 261px) 100vw, 261px"/><figcaption>Breadth first search</figcaption></figure></div>



<p>First, we will traverse the nodes that are directly connected to <code>0</code>. Those are <code>{1, 2, 3}</code>. If node <code>x</code> is part of <code>{1, 2, 3}</code>, we stop. If not, we continue traversing the graph.</p>



<p>Next, we consider the set of nodes that are connected to or previous set <code>{1, 2, 3}</code>. Those would be <code>{4, 5, 6}</code>. Nodes <code>4</code> and <code>5</code> are connected to node <code>1</code> and node <code>6</code> is connected to node <code>3</code>.  We look for node <code>x</code> again and then we stop becausre there aren’t any more nodes.</p>



<p>If the graph was larger, we would continue traversing the graph by considering the nodes connected to <code>{4, 5, 6}</code> and so on. </p>



<p>See that this order of traversal guarantees that we find the shortest path between node <code>0</code> and node <code>x</code> because we start by searching the nodes that are one edge away from <code>node1</code>, then those that are two edges distant, and so on.</p>



<h2>Graph representation</h2>



<p>We will represent our graph as a dictionary, mapping each node to the set of the nodes it is connected to. </p>



<p>For example, let’s consider the following graph.</p>







<p>In this graph, node <code>4</code> is connected to nodes <code>3</code>, <code>5</code>, and <code>6</code>. Our <code>graph</code> dictionary would then have the following <code>key: value</code> pair:</p>



<pre data-enlighter-language="python" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">graph[4] = {3, 5, 6}</pre>



<p>We would have similar <code>key: value</code> pairs for each one of the nodes in the graph.</p>



<h2>Shortest path function input and output</h2>



<h3>Function input</h3>



<p>Our BFS function will take a <code>graph</code> dictionary, and two node ids (<code>node1</code> and <code>node2</code>). For this tutorial, each graph will be identified using integer numbers (<code>1</code>, <code>2</code>, etc).</p>



<h3>Function output</h3>



<p>The function will return a list of nodes that connect <code>node1</code> and <code>node2</code>, starting with <code>node1</code> and including <code>node2</code>: <code>[node1, node_x, node_y, ..., node2]</code>. This list will be the shortest path between node1 and node2.</p>



<p>If there is more than one possible shortest path, it will return any of them. </p>



<p>In case no path is found, it will return an empty list <code>[]</code>.</p>



<pre data-enlighter-language="python" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">from typing import Dict, List

def shortest_path(graph: Dict[int, set], node1: int, node2: int) -&gt; List[int]:
     pass</pre>



<h2>Shortest path algorithm</h2>



<p>Our algorithm starts by defining a list of possible paths. A “path” is a list of connected nodes. Initially, we have only one “path” possible: <code>[node1]</code>, because we start traversing the graph from that node. We also define a set of previously visited nodes to avoid backtracking.</p>



<p>After these initial steps the algorithm does the following:</p>



<ol><li>Take the next path from the list of paths.<ul><li>If all possible paths have been traversed, stop. No path was found.</li></ul></li><li>Set the “current node” to the last node in the current path.</li><li>Search the goal node, <code>node2</code>, between the nodes that are connected to the current node.<ul><li>If node2 is connected to the current node, we have found path from node1 to node2. Stop.</li></ul></li><li>If node2 isn’t connected to the current node, update the list of paths to traverse.<ul><li>Add a new path from <code>node1</code> to each one of the connected nodes to traverse next.</li></ul></li><li>Go back to step 1.</li></ol>



<h2>Shortest path implementation in Python</h2>



<p>Finally, we have the implementation of the shortest path algorithm in Python. </p>



<pre data-enlighter-language="python" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">def shortest_path(graph, node1, node2):
    path_list = [[node1]]
    path_index = 0
    # To keep track of previously visited nodes
    previous_nodes = {node1}

    if node1 == node2:
        return path_list[0]
        
    while path_index &lt; len(path_list):
        current_path = path_list[path_index]
        last_node = current_path[-1]
        next_nodes = graph[last_node]
        # Search goal node
        if node2 in next_nodes:
            current_path.append(node2)
            return current_path
        # Add new paths
        for next_node in next_nodes:
            if not next_node in previous_nodes:
                new_path = current_path[:]
                new_path.append(next_node)
                path_list.append(new_path)
                # To avoid backtracking
                previous_nodes.add(next_node)
        # Continue to next path in list
        path_index += 1
    # No path is found
    return []</pre>



<p>We return the trivial path <code>[node1]</code> for the case <code>node1 == node2</code>.</p>



<p>Variable <code>path_index</code> keeps track of the path that we’re currently following. We stop the loop when we reach the end of <code>path_list</code>.</p>



<p>At all times, we have a shortest path from <code>node1</code> to <code>last_node</code>. Based on this path, we can find the path from <code>node1</code> to <code>node2</code> if <code>node2</code> is connected to <code>last_node</code>.</p>



<p>The order in which new paths are added to <code>path_list</code> guarantees that we traverse the graph in breadth first order.</p>



<h2>Verification</h2>



<p>Let’s check our algorithm with the graph shared at the beginning of this post.</p>



<div><figure><img loading="lazy" width="359" height="239" src="https://onestepcode.com/wp-content/uploads/2022/01/graph.png" alt="" srcset="https://onestepcode.com/wp-content/uploads/2022/01/graph.png 359w, https://onestepcode.com/wp-content/uploads/2022/01/graph-300x200.png 300w" sizes="(max-width: 359px) 100vw, 359px"/></figure></div>



<p>We create a <code>graph</code> dictionary.</p>



<pre data-enlighter-language="python" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">graph = {}

graph[1] = {2, 5}
graph[2] = {1, 3, 5}
graph[3] = {2, 4}
graph[4] = {3, 5, 6}
graph[5] = {1, 2, 4}
graph[6] = {4}</pre>



<p>Now, let’s find the shortest path from node  <code>1</code> to node  <code>6</code>.</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">&gt;&gt;&gt; shortest_path(graph, 1, 6)
[1, 5, 4, 6]</pre>
					</div>
					</article>
		<nav>
	
	
</nav>	    
    
    
    
    </div>	</div>
</section><!-- .main -->
    
</div><!-- .max-width -->
</div></div>
  </body>
</html>
