<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://diekmann.uk/blog/2024-06-25-statically-known-undefined-behaviour.html">Original</a>
    <h1>How GCC and Clang handle statically known undefined behaviour</h1>
    
    <div id="readability-page-1" class="page"><p>
        Recently, we had a discussion in our team about undefined behaviour
        (UB) in C. For those unfamiliar: We say that a program has undefined
        behaviour when we write code where the language specification doesn&#39;t
        define what should happen during execution. That means compilers can do
        whatever they like if they encounter such code and there is no
        guarantee that execution will behave in a predictable way. Thus,
        undefined behaviour must be avoided at all cost as it not only makes
        programs misbehave but is also a common source of security vulnerabilities.
             Examples of code that
        has undefined behaviour are out-of-bounds indexing of an array, integer
        overflow, division by zero, and nullpointer dereferencing
        <a href="#fn_1" onclick="show_footnote(this, &#39;fn_1&#39;); return false;">[1]</a>.
        </p><p>
    Compilers often use undefined language semantics to make assumptions about the program.
    For example, if we write something like <code>int x = y/z</code>, then
    the compiler may assume that <code>z</code> must not be zero, since division by
    zero is undefined, and programmers surely wouldn&#39;t write undefined code. It
    can then use that information to further optimise the program:
        </p><div>
    <div>
        <div>
            <p>Program</p>
<div><pre><span></span><span>int</span><span> </span><span>main</span><span>(</span><span>int</span><span> </span><span>argc</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>int</span><span> </span><span>div</span><span> </span><span>=</span><span> </span><span>5</span><span> </span><span>/</span><span> </span><span>argc</span><span>;</span>
<span>  </span><span>if</span><span> </span><span>(</span><span>argc</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span>
<span>      </span><span>printf</span><span>(</span><span>&#34;A</span><span>\n</span><span>&#34;</span><span>);</span>
<span>  </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span>
<span>    </span><span>printf</span><span>(</span><span>&#34;B</span><span>\n</span><span>&#34;</span><span>);</span>
<span>  </span><span>}</span>
<span>  </span><span>return</span><span> </span><span>div</span><span>;</span>
<span>}</span>
</pre></div>

        </div>
        <div>
            <p>gcc -O2</p>
<div><pre><span></span><span>.LC0:</span>
<span>    </span><span>.string</span><span> </span><span>&#34;A&#34;</span>
<span>.LC1:</span>
<span>    </span><span>.string</span><span> </span><span>&#34;B&#34;</span>
<span>main:</span>
<span>    </span><span>mov</span><span>     </span><span>eax</span><span>,</span><span> </span><span>5</span>
<span>    </span><span>xor</span><span>     </span><span>edx</span><span>,</span><span> </span><span>edx</span>
<span>    </span><span>push</span><span>    </span><span>rbx</span>
<span>    </span><span>idiv</span><span>    </span><span>edi</span>
<span>    </span><span>mov</span><span>     </span><span>ebx</span><span>,</span><span> </span><span>eax</span>
<span>    </span><span>test</span><span>    </span><span>edi</span><span>,</span><span> </span><span>edi</span>
<span>    </span><span>jne</span><span>     </span><span>.L2</span>
<span>    </span><span>mov</span><span>     </span><span>edi</span><span>,</span><span> </span><span>OFFSET</span><span> </span><span>FLAT</span><span>:</span><span>.LC0</span>
<span>    </span><span>call</span><span>    </span><span>puts</span>
<span>.L1:</span>
<span>    </span><span>mov</span><span>     </span><span>eax</span><span>,</span><span> </span><span>ebx</span>
<span>    </span><span>pop</span><span>     </span><span>rbx</span>
<span>    </span><span>ret</span>
<span>.L2:</span>
<span>    </span><span>mov</span><span>     </span><span>edi</span><span>,</span><span> </span><span>OFFSET</span><span> </span><span>FLAT</span><span>:</span><span>.LC1</span>
<span>    </span><span>call</span><span>    </span><span>puts</span>
<span>    </span><span>jmp</span><span>     </span><span>.L1</span>
</pre></div>

        </div>
        <div>
            <p>clang -O2</p>
<div><pre><span></span><span>main:</span>
<span>    </span><span>push</span><span>    </span><span>rbx</span>
<span>    </span><span>mov</span><span>     </span><span>ebx</span><span>,</span><span> </span><span>edi</span>
<span>    </span><span>lea</span><span>     </span><span>rdi</span><span>,</span><span> </span><span>[</span><span>rip</span><span> </span><span>+</span><span> </span><span>.Lstr</span><span>]</span>
<span>    </span><span>call</span><span>    </span><span>puts@PLT</span>
<span>    </span><span>mov</span><span>     </span><span>eax</span><span>,</span><span> </span><span>5</span>
<span>    </span><span>xor</span><span>     </span><span>edx</span><span>,</span><span> </span><span>edx</span>
<span>    </span><span>idiv</span><span>    </span><span>ebx</span>
<span>    </span><span>pop</span><span>     </span><span>rbx</span>
<span>    </span><span>ret</span>
<span>.Lstr:</span>
<span>    </span><span>.asciz</span><span>  </span><span>&#34;B&#34;</span>
</pre></div>

        </div>
    </div><p>

        In this example, we can see that clang used the fact that division by
        zero is undefined and thus <code>argc</code> must not be zero to
        entirely remove the condition <code>if (argc == 0)</code>, knowing this
        case can never happen <a href="#fn_2" onclick="show_footnote(this, &#39;fn_2&#39;); return false;">[2]</a>.

        </p><h2>Statically known undefined behaviour</h2><p>

        While I knew that compilers can do clever optimisations when assuming that no UB may exists in the program, I was
        wondering what they do when they <strong>statically detect the
        existence of UB</strong>, or in other words, when we force the compiler
    to compile code that both we and the compiler know is undefined. Eager to
    find excuses to use <a href="https://godbolt.org">Compiler Explorer</a>, I did some quick
        experiments. For many these results may not be surprising (and the experiments, if you can even call them that, are certainly
        not exhaustive), but they satisfied my curiosity, and, by putting this out there, I hope others
        may get some value from this too.
        </p>

        <h2>I need a <strike>h</strike>zero</h2>

        <p>
        The simplest program I could think of that forces UB in C is
        division by zero with a constant. The program and its output by gcc (v14.1) and clang
        (v18.1) compiled to x86_64 are shown below:
        </p>

    <div>
        <div>
            <p>Program</p>
<div><pre><span></span><span>int</span><span> </span><span>main</span><span>(</span><span>int</span><span> </span><span>argc</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>int</span><span> </span><span>ub</span><span> </span><span>=</span><span> </span><span>argc</span><span> </span><span>/</span><span> </span><span>0</span><span>;</span>
<span>  </span><span>return</span><span> </span><span>ub</span><span>;</span>
<span>}</span>
</pre></div>

        </div>
        
        
    </div>

        <p>
During compilation, both gcc and clang give a warning:
        </p>

<pre><source/>:2:17: warning: division by zero [-Wdiv-by-zero]
    2 |     int ub = argc / 0;
      |                   ^
</pre>

<p>
However, while gcc compiled the program to a single (illegal instruction)
<code>ud2</code>, clang reduced it to a <code>ret</code>. Under UB, both
approaches are valid, yet they are very different: one crashes the
program, while the other ignores the problematic code <a href="#fn_3" onclick="show_footnote(this, &#39;fn_3&#39;); return false;">[3]</a>.
</p>

<p>
What if we changed the program slightly by replacing the constant inside
the division with a variable:
</p>

    <div>
        <div>
            <p>Program</p>
<div><pre><span></span><span>int</span><span> </span><span>main</span><span>(</span><span>int</span><span> </span><span>argc</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>int</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span>
<span>    </span><span>int</span><span> </span><span>ub</span><span> </span><span>=</span><span> </span><span>argc</span><span> </span><span>/</span><span> </span><span>i</span><span>;</span>
<span>    </span><span>return</span><span> </span><span>ub</span><span>;</span>
<span>}</span>
</pre></div>

        </div>
        
        
    </div>

<p>
While the compiled programs stayed the same, we no longer get a warning (even
with <code>-Wall</code>), even though both compilers can easily work out
statically (e.g. via constant folding) that a division by zero occurs <a href="#fn_4" onclick="show_footnote(this, &#39;fn_4&#39;); return false;">[4]</a>.
</p>

<h2>No guarantees</h2>

<p>
Let&#39;s add some more code before the division-by-zero line and see how this affects the output:</p>

    <div>
        <div>
            <p>Program</p>
                <div><pre><span></span><span>int</span><span> </span><span>main</span><span>(</span><span>int</span><span> </span><span>argc</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>int</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span>
<span>    </span><span>printf</span><span>(</span><span>&#34;before&#34;</span><span>);</span>
<span>    </span><span>int</span><span> </span><span>ub</span><span> </span><span>=</span><span> </span><span>argc</span><span> </span><span>/</span><span> </span><span>i</span><span>;</span>
<span>    </span><span>printf</span><span>(</span><span>&#34;%d&#34;</span><span>,</span><span> </span><span>ub</span><span>);</span>
<span>    </span><span>return</span><span> </span><span>ub</span><span>;</span>
<span>}</span>
</pre></div>

        </div>
        <div>
            <p>gcc -O2</p>
                <div><pre><span></span><span>main:</span>
<span>    </span><span>sub</span><span>     </span><span>rsp</span><span>,</span><span> </span><span>8</span>
<span>    </span><span>mov</span><span>     </span><span>edi</span><span>,</span><span> </span><span>OFFSET</span><span> </span><span>FLAT</span><span>:</span><span>.LC0</span>
<span>    </span><span>xor</span><span>     </span><span>eax</span><span>,</span><span> </span><span>eax</span>
<span>    </span><span>call</span><span>    </span><span>printf</span>
<span>    </span><span>ud2</span>
</pre></div>

        </div>
        <div>
            <p>clang -O2</p>
                <div><pre><span></span><span>main:</span>
<span>    </span><span>push</span><span>    </span><span>rax</span>
<span>    </span><span>lea</span><span>     </span><span>rdi</span><span>,</span><span> </span><span>[</span><span>rip</span><span> </span><span>+</span><span> </span><span>.L.str</span><span>]</span>
<span>    </span><span>xor</span><span>     </span><span>eax</span><span>,</span><span> </span><span>eax</span>
<span>    </span><span>call</span><span>    </span><span>printf@PLT</span>
<span>    </span><span>lea</span><span>     </span><span>rdi</span><span>,</span><span> </span><span>[</span><span>rip</span><span> </span><span>+</span><span> </span><span>.L.str.1</span><span>]</span>
<span>    </span><span>xor</span><span>     </span><span>eax</span><span>,</span><span> </span><span>eax</span>
<span>    </span><span>pop</span><span>     </span><span>rcx</span>
<span>    </span><span>jmp</span><span>     </span><span>printf@PLT</span>
</pre></div>

        </div>
    </div>

<p>
Somewhat expectedly, gcc remains faithful to its crash approach, though note
that it only inserts the crash when it compiles the division-by-zero, not earlier, like at the beginning of the function.
Clang on the other hand compiled both prints, before and after the division,
simply removing the division itself. As with the code after the division-by-zero,
there are also no guarantees for the code leading up to it. The mere existence
of UB in the program means all bets are off and the compiler could chose to
crash the function immediatley upon entering it. <a href="#fn_5" onclick="show_footnote(this, &#39;fn_5&#39;); return false;">[5]</a>.
</p>

<h2>If there&#39;s UB in a program but no one is around to use it, does it still make a sound?</h2>

<p>
Do compilers treat code that exhibits undefined behaviour but is never used,
like the proverbial soundless tree in the forest, and ignore it? Let&#39;s find out:
</p>
    <div>
        <div>
            <p>Program</p>
<div><pre><span></span><span>int</span><span> </span><span>main</span><span>(</span><span>int</span><span> </span><span>argc</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>int</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span>
<span>    </span><span>int</span><span> </span><span>ub</span><span> </span><span>=</span><span> </span><span>argc</span><span> </span><span>/</span><span> </span><span>i</span><span>;</span>
<span>    </span><span>return</span><span> </span><span>1</span><span>;</span>
<span>}</span>
</pre></div>

        </div>
        
        
    </div>

        <p>
        We can see that the answer to our question is &#34;yes&#34;, and now both compilers have optimised the division away.
        Most likely dead code elimination will have removed the division before
        the compiler figured out it is UB.
        Again, it is important to understand that this is something the
        compilers <em>chose</em> to do (and only if we enable optimisations, otherwise the division is compiled as is). Even if the UB &#34;isn&#39;t used&#34;, that
        doesn&#39;t mean the program has no UB. We just got &#34;lucky&#34; that the
        compiler removed the dead code <em>before</em> realising it had UB.
        There is no guarantee other compilers
        will do the same, nor that this behaviour will be consistent between
        different versions of the compilers. It would have been equally valid
        to crash the program or open your CD-ROM drive.
        </p>


<h2>That <strike>girl</strike> value is poison</h2>

<p>
We are now left with two questions: 1) Why do we often not get warnings
about UB in a program even if the compiler was able to work out that it exists?
2) Why are clang (and sometimes gcc) lenient when handling UB, compiling
(and running) code instead of making it crash (e.g. by inserting an illegal
instruction)?
</p>

<p>
We can find answers for both questions in a <a href="https://blog.llvm.org/2011/05/what-every-c-programmer-should-know_21.html">blog
post</a> by Chris Lattner.
In regards to the warnings, he explains that it would often generate too many
warnings to be useful (with lots of false positives). It&#39;s also difficult to
know when people want these warnings and when not (e.g. nobody cares about UB
in dead code). In regards to the leniency, especially in relation to our
programs above, the following paragraph from the blog post gives some insight:
</p>

<blockquote>“Arithmetic that operates on <a href="http://llvm.org/docs/LangRef.html#undefvalues">undefined values</a> is considered to produce a
undefined value instead of producing undefined behavior. The distinction is
that undefined values can&#39;t format your hard drive or produce other undesirable
effects.”</blockquote>

<p>
These days LLVM uses mostly ‘<a href="https://llvm.org/docs/LangRef.html#poison-values">poison</a>’
values which enable more optimisations
than ‘undef’, but the idea is the same: just because a value is the result of
undefined behaviour, that doesn&#39;t mean we need to immediatley invalidate any code using that value. For example, taking a poison value and <code>and</code>ing it with 0, we may assume
that the result will always be 0, no matter what the actual poison value is.
</p>

<p>
This makes sense when, for example, the result of an undefined operation is
irrelevant for the execution of the remainder of the program as the following
example shows:
</p>

    <div>
        <div>
            <p>Program</p>
<div><pre><span></span><span>int</span><span> </span><span>main</span><span>(</span><span>int</span><span> </span><span>argc</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>int</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span>
<span>  </span><span>// nullptr dereference</span>
<span>  </span><span>int</span><span> </span><span>ub</span><span> </span><span>=</span><span> </span><span>*</span><span>(</span><span>int</span><span>*</span><span>)</span><span>i</span><span>;</span>
<span>  </span><span>int</span><span> </span><span>p</span><span> </span><span>=</span><span> </span><span>ub</span><span> </span><span>|</span><span> </span><span>1</span><span>;</span>
<span>  </span><span>printf</span><span>(</span><span>&#34;print&#34;</span><span>);</span>
<span>  </span><span>if</span><span> </span><span>(</span><span>p</span><span>)</span><span> </span><span>{</span>
<span>      </span><span>printf</span><span>(</span><span>&#34;%d&#34;</span><span>,</span><span> </span><span>ub</span><span>);</span>
<span>  </span><span>}</span>
<span>  </span><span>return</span><span> </span><span>1</span><span>;</span>
<span>}</span>
</pre></div>

        </div>
        <div>
            <p>gcc -O2</p>
<div><pre><span></span><span>main:</span>
<span>    </span><span>mov</span><span>     </span><span>eax</span><span>,</span><span> </span><span>DWORD</span><span> </span><span>PTR</span><span> </span><span>ds</span><span>:</span><span>0</span>
<span>    </span><span>ud2</span>
</pre></div>

        </div>
        <div>
            <p>clang -O2</p>
<div><pre><span></span><span>main:</span>
<span>    </span><span>push</span><span>    </span><span>rax</span>
<span>    </span><span>lea</span><span>     </span><span>rdi</span><span>,</span><span> </span><span>[</span><span>rip</span><span> </span><span>+</span><span> </span><span>.L.str</span><span>]</span>
<span>    </span><span>xor</span><span>     </span><span>eax</span><span>,</span><span> </span><span>eax</span>
<span>    </span><span>call</span><span>    </span><span>printf@PLT</span>
<span>    </span><span>lea</span><span>     </span><span>rdi</span><span>,</span><span> </span><span>[</span><span>rip</span><span> </span><span>+</span><span> </span><span>.L.str.1</span><span>]</span>
<span>    </span><span>xor</span><span>     </span><span>eax</span><span>,</span><span> </span><span>eax</span>
<span>    </span><span>call</span><span>    </span><span>printf@PLT</span>
<span>    </span><span>mov</span><span>     </span><span>eax</span><span>,</span><span> </span><span>1</span>
<span>    </span><span>pop</span><span>     </span><span>rcx</span>
<span>    </span><span>ret</span>
<span>.L.str:</span>
<span>    </span><span>.asciz</span><span>  </span><span>&#34;print&#34;</span>

<span>.L.str.1:</span>
<span>    </span><span>.asciz</span><span>  </span><span>&#34;%d&#34;</span>
</pre></div>

        </div>
    </div>

<p>
Since a bit-wise <code>or</code> with a non-zero value will always evaluate to
true, the if-condition will always succeed, no matter what the value of
<code>ub</code> is. In LLVM, arithmetic with <code>poison</code> values
doesn&#39;t necessarily produce another <code>poison</code> value. This is the case here,
where the compiler can thus remove the condition. Gcc on the other hand bailed with a <code>ud2</code> as soon as it saw the null-pointer dereference.
</p>
<h2>Conclusion</h2>
<p>
While these were all
very cherry-picked examples, they weren&#39;t selected in order paint one compiler in a worse light.
The goal was to show a difference
in philosophies when handling UB: LLVM just carries on compiling when it can,
crossing its fingers that this won&#39;t cause problems later on, in an attempt
to to make more programs run and to closer match what it believes a developer, unaware of
undefined behaviour in their code, might expect. Gcc, at least in the examples above, appears to be more conservative and
prefers to crash the program instead, making it more obvious to developers when
their programs contain UB. Neither approach is objectively better than the
other and both are equally valid in the face of UB, and which one to choose
ultimately comes down to personal preference of the compiler developers and their
users.
</p>

<p>
<strong>Acknowledgements</strong>: Thanks to
<a href="https://theunixzoo.co.uk/">Edd Barrett</a> and
<a href="https://tratt.net/laurie/">Laurence Tratt</a> for comments.


    </p><h2>Footnotes</h2>
    
    
         <hr/>
        <p>Copyright © Lukas Diekmann</p>
    </div></div>
  </body>
</html>
