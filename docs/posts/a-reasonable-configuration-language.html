<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ruudvanasseldonk.com/2024/a-reasonable-configuration-language">Original</a>
    <h1>A reasonable configuration language</h1>
    
    <div id="readability-page-1" class="page"><article id="content" itemscope=""><header><p>written by </p></header><p><span>About six months ago</span>, I was fed up with it. The particular <em>it</em> was <abbr>HCL</abbr> — Hashicorp Configuration Language — but that was just the trigger, it was hardly the only offender. The issue I was struggling with that day was to define six cloud storage buckets in Terraform. They were similar, but not quite identical. The kind of thing you’d do with <a href="https://github.com/ruuda/rcl/blob/bedbd3eea1129ba6053427d67b77a955240ceca8/examples/buckets.rcl#L9-L10">a two-line nested loop</a> in any general-purpose language, but where all the ways of achieving that in <abbr>HCL</abbr> were so much hassle, that is was far simpler to just copy-paste the config six times.</p><p>Although this <abbr>HCL</abbr> episode was the droplet, my bucket of frustration had been filling up for a long time:</p><ul><li><strong>GitHub Actions workflows</strong> that differ in only a few commands — there is no native way to abstract those. The same applies to jobs within a workflow.</li><li><strong>Kubernetes manifests</strong> that are 80% the same for most applications, and an entire industry that fails to adopt a proper solution for this, and instead resorts to templating yaml, which to me is <a href="https://ruudvanasseldonk.com/2023/01/11/the-yaml-document-from-hell#templating-yaml-is-a-terrible-terrible-idea">very obviously very wrong on so many levels</a>.</li><li><strong>The prevalence of yaml in general</strong>, a format that does solve some problems (adding comments and a lighter syntax to json), but in the process introduces <a href="https://ruudvanasseldonk.com/2023/01/11/the-yaml-document-from-hell">so many new problems</a> that the cure is almost as bad as the disease.</li><li><strong>Ansible playbooks</strong> that are too similar to justify duplicating, but different enough that parametrizing over data is insufficient. Related to this, the parameter data is difficult to share between Ansible and other tools.</li></ul><p>So that day, when I was in a particularly defiant mood, I decided to write my own configuration language. With list comprehensions. And types.</p><p><img alt="I’ll build my own configuration language. With list comprehensions. And types." src="https://ruudvanasseldonk.com/images/ill-build-my-own-configuration-language.png" width="1024" height="768"/></p><p>I never expected or intended for it to go anywhere — it was just a way to vent. But six months later, <a href="https://github.com/ruuda/rcl"><em>Ruud’s Configuration Language</em></a> is no longer completely vaporware. I find it increasingly useful, and I think it might benefit others too. So let’s dive in!</p><h2 id="a-functional-foundation"><a href="#a-functional-foundation"></a>A functional foundation</h2><p>To be clear, I’m not criticizing the designers of Ansible or <abbr>HCL</abbr>. The limits of these tools are a natural consequence of their organic growth: you start out with a tool that needs simple configuration, adoption grows and people start doing more complex things with it, and suddenly you find yourself without a good way to do abstraction. So as a quick stopgap, you <a href="https://developer.hashicorp.com/terraform/language/v1.7.x/meta-arguments/for_each">bolt on</a> control flow <a href="https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_loops.html#standard-loops">encoded inside</a> the <a href="https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstrategymatrix">data format</a>, because that’s easy to do within the limits of the existing syntax.</p><p>When it comes to adding more principled abstraction features, the authors have a background in infrastructure administration, not in language design or type theory. So they accidentally implement <a href="https://developer.hashicorp.com/terraform/language/v1.7.x/functions/flatten">some functions</a> in an ad-hoc way that seemed helpful, but causes surprises down the line. (A <code>flatten</code> that <em>sometimes</em> flattens recursively can’t be typed properly, which breaks generic code.) Many of JavaScript and <abbr>PHP</abbr>’s idiosyncrasies can be explained in the same way.</p><p>The <a href="https://nixos.org/manual/nix/stable/language/index.html">Nix language</a> had a more solid foundation in functional programming from the start, which enables abstraction in a natural way. Even though it predates Terraform by more than a decade, the language has stood the test of time far better than <abbr>HCL</abbr>. With very few changes, it scaled to massive configuration repositories like <a href="https://github.com/NixOS/nixpkgs">Nixpkgs</a>, and although Nix has issues, abstracting repetition away is not one of them. I’ve used Nix to generate repetitive GitHub Actions workflows, and of course it is at the heart of NixOS, where it generates configuration files such as systemd units from a consistent declarative specification. This is the power of having few simple features that compose well.</p><p>Though Nix is great, I don’t think it is the answer to all configuration problems. Nix-the-language is intimately tied to Nix-the-package-manager and the Nix store, and the <abbr>ML</abbr>-style syntax can look foreign to people who are used to more mainstream languages. Still, Nix has many good ideas that have been proven to work, and my own configuration language is heavily inspired by it.</p><p>The other language that I take a lot of inspiration from is Python. Python is not primarily a functional language, but you can certainly use it in that way (avoid mutation, write pure functions, prefer list comprehensions over loops, etc.), and this is very natural. I find the syntax pleasant and readable: the meaning of idiomatic Python code is clear even to people who are not intimately familiar with the language. As a configuration language, Python is not bad! In fact, I’ve <em>also</em> used Python to generate repetitive GitHub Actions configurations. List and dict literals are very similar to json, and with functions, list comprehensions, and format strings, there is ample room to abstract repetitive configuration. Types can help to document and enforce structure.</p><p>But like Nix, I don’t think that Python is the answer to all configuration problems. A Python file is still primarily code, not data. You can have an entry point <code>json.dump</code> data to files or stdout, but it’s not always easy to import or evaluate intermediate pieces in isolation. Python’s module system is great for larger codebases, but less suitable for sharing pieces of data between many small scripts.</p><p>For my own language, I took the parts that I like about Nix: functional, more data than code, but with enough room to code when needed, and simple features that compose well. I took what I like about Python: the clean and familiar syntax, list comprehensions, format strings, and types. And consciously or unconsciously, I’m influenced by many more languages that I’ve been exposed to. Those ideas I combined into a language that <em>I</em> like working with.</p><h2 id="oh-no-yet-another-configuration-language"><a href="#oh-no-yet-another-configuration-language"></a>Oh no, yet another configuration language!</h2><p>I am not the first person to be frustrated by the lack of abstraction features in various tools, nor am I the first person to think that a configuration language would solve that. There exist more configuration languages than I can count on one hand already (see <a href="#appendix-a-non-exhaustive-list-of-configuration-languages">the appendix</a>), and probably many more that I’m not aware of. So why add one more to the mix? Why is <em>this one</em> going to <em>really</em> solve all our problems, when five more mature ones haven’t seen widespread adoption (yet)?</p><p>First of all, I did not start out writing my own language thinking it would be a viable alternative to existing configuration languages. I started it to vent, because I find it fun to work on, because it’s a good learning exercise, and because I can do things in exactly the way that <em>I</em> want to. Dhall has been around longer, has wider support, and a bigger community. But I don’t really like the syntax and the way it names some things. That’s a superficial complaint, and if I was looking for a tool to solve my configuration problems with the least amount of effort, then I can set my taste aside — I’ll get used to it. But for a personal project that I spend my free time on, I enjoy exploring ideas and building exactly the tool that <em>I</em> want to have.</p><p>So that’s how it started, as a toy project. I put a big vaporware warning on it, expecting that I would lose interest in it before it got to a point where it was useful. It’s certainly <a href="https://ruudvanasseldonk.com/2017/04/27/a-language-for-designing-slides">not the first time</a> that I’m writing a toy language that stalled, and maybe this one will meet the same fate. (I do still occasionally use Pris, and occasionally I get excited about adding features, but it’s mostly abandoned, like many of my side projects.) But then my tool started being useful. First in unexpected places (as a <code>jq</code> replacement, more on that below), and as I added features, in more places, to the point where now — despite its shortcomings — I would prefer it over some of the tools that I use at my day job.</p><p>So now what, is it a Serious Software Project now? No, it’s still a hobby project without stability promise. I don’t recommend using it for anything serious. But it’s also <em>useful</em> to the point where I expect I’ll keep it in my toolbelt for the forseeable future — if only as a <code>jq</code> replacement. And if it’s useful to me, maybe it’s useful to others, so that’s why I’m writing about it today.</p><h2 id="ruuds-configuration-language"><a href="#ruuds-configuration-language"></a>Ruud’s Configuration Language</h2><p>So what is this language? I call it <abbr>RCL</abbr>, named after myself in Bender meme style, but it turns out that <code>rcl</code> is a pretty good file extension and name for a command-line tool. If you prefer, it might stand for Reasonable Configuration Language, or, in classic <abbr>GNU</abbr> style, for <abbr>RCL</abbr> configuration language.</p><p>The language is a superset of json. This makes it easy to export data from many tools and incrementally upgrade it to <abbr>RCL</abbr>, including from yaml: just serialize it to json, and you’re good to go. This is a valid <abbr>RCL</abbr> document:</p><div id="cb1"><pre><code><span id="cb1-1"><span>{</span></span>
<span id="cb1-2">  <span>&#34;buckets&#34;</span><span>:</span> <span>[</span></span>
<span id="cb1-3">    <span>{</span></span>
<span id="cb1-4">      <span>&#34;name&#34;</span><span>:</span> <span>&#34;bucket-0&#34;</span><span>,</span></span>
<span id="cb1-5">      <span>&#34;location&#34;</span><span>:</span> <span>&#34;eu-west1&#34;</span><span>,</span></span>
<span id="cb1-6">      <span>&#34;delete-after-seconds&#34;</span><span>:</span> <span>86400</span></span>
<span id="cb1-7">    <span>}</span><span>,</span></span>
<span id="cb1-8">    <span>{</span></span>
<span id="cb1-9">      <span>&#34;name&#34;</span><span>:</span> <span>&#34;bucket-1&#34;</span><span>,</span></span>
<span id="cb1-10">      <span>&#34;location&#34;</span><span>:</span> <span>&#34;eu-west1&#34;</span><span>,</span></span>
<span id="cb1-11">      <span>&#34;delete-after-seconds&#34;</span><span>:</span> <span>86400</span></span>
<span id="cb1-12">    <span>}</span></span>
<span id="cb1-13">  <span>]</span></span>
<span id="cb1-14"><span>}</span></span></code></pre></div><p>It’s 2024, so <abbr>RCL</abbr> has some features that you might expect from a “modern” language: trailing commas and numeric underscores. Furthermore, dicts can be written with <code>ident = value</code> syntax to omit the quotes and reduce some line noise:</p><pre><code>{
  <span>buckets</span> = [
    {
      <span>name</span> = <span>&#34;bucket-0&#34;</span>,
      <span>location</span> = <span>&#34;eu-west1&#34;</span>,
      <span>delete-after-seconds</span> = <span>86_400</span>,
    },
    {
      <span>name</span> = <span>&#34;bucket-1&#34;</span>,
      <span>location</span> = <span>&#34;eu-west1&#34;</span>,
      <span>delete-after-seconds</span> = <span>86_400</span>,
    },
  ],
}</code></pre><p>There are arithmetic expressions as you would expect, list comprehensions, format strings, and functions:</p><pre><code>{
  <span>buckets</span> = [
    <span>for</span> <span>i</span> <span>in</span> <span>std</span>.<span>range</span>(<span>0</span>, <span>2</span>):
    {
      <span>name</span> = <span>f&#34;bucket-</span><span>{</span><span>i</span><span>}</span><span>&#34;</span>,
      <span>location</span> = <span>&#34;eu-west1&#34;</span>,
      <span>delete-after-seconds</span> = <span>24</span> <span>*</span> <span>3600</span>,
    },
  ],
}</code></pre><p>For validation, the <a href="https://docs.ruuda.nl/rcl/type_list/#key_by"><code>key_by</code></a> method is useful. In the above example, if we’d name the buckets by hand and there are many of them, how do we ensure that we don’t accidentally create two buckets with the same name? We can do that by building a mapping from name to bucket:</p><pre><code><span>let</span> <span>buckets</span> = [
  <span>// Omitted here for brevity, defined as before.</span>
];

<span>// Build a mapping of bucket name to bucket. If a key (bucket name)</span>
<span>// occurs multiple times, this will fail with an error that reports</span>
<span>// the offending key and the associated values. The type annotation</span>
<span>// is for clarification, it is not mandatory.</span>
<span>let</span> <span>buckets_by_name</span>: <span>Dict</span>[<span>String</span>, <span>Dynamic</span>] = <span>buckets</span>.<span>key_by</span>(<span>b</span> <span>=&gt;</span> <span>b</span>.<span>name</span>);

<span>// Constructing the mapping is enough for validation, the document still</span>
<span>// evaluates to the same dict as before. Note, the left &#34;buckets&#34; is the</span>
<span>// name of the field, the right &#34;buckets&#34; is a variable reference.</span>
{ <span>buckets</span> = <span>buckets</span> }
</code></pre><p>This is just a quick overview of some features. For a more thorough introduction, check out <a href="https://docs.ruuda.nl/rcl/tutorial/">the tutorial</a> and <a href="https://docs.ruuda.nl/rcl/syntax/">the syntax guide</a>.</p><p>An <abbr>RCL</abbr> document is always an expression, and you can evaluate it to a json document with the <code>rcl</code> command-line tool:</p><pre><code>rcl evaluate --output=json buckets.rcl</code></pre><p>The tool can also output in <abbr>RCL</abbr> syntax, which is a bit less noisy when inspecting data, and it’s a way to upgrade json documents to <abbr>RCL</abbr>. Aside from the standalone command-line tool, I also recently added a Python module that enables importing <abbr>RCL</abbr> documents in much the same way as <code>json.loads</code>.</p><p>Abstraction in a single document is nice, but the real power comes from <em>imports</em>. These allow you to break down configuration into small reusable pieces. Let’s say that all your cloud resources are in the same location. Then we might have a file <code>cloud_config.rcl</code>:</p><pre><code>{
  default_location = <span>&#34;eu-west1&#34;</span>,
}</code></pre><p>Then in <code>buckets.rcl</code>, we can use that like so:</p><pre><code><span>let</span> cloud_config = <span>import</span> <span>&#34;cloud_config.rcl&#34;</span>;
{
  <span>buckets</span> = [
    <span>for</span> <span>i</span> <span>in</span> <span>std</span>.<span>range</span>(<span>0</span>, <span>2</span>):
    {
      <span>name</span> = <span>f&#34;bucket-</span><span>{</span><span>i</span><span>}</span><span>&#34;</span>,
      <span>location</span> = cloud_config.default_location,
      <span>delete-after-seconds</span> = <span>24</span> <span>*</span> <span>3600</span>,
    },
  ],
}</code></pre><p>Because every document is an expression, you can always evaluate it and inspect it, even if it’s only an intermediate stage in a larger configuration. For more fine-grained inspection there is <a href="https://docs.ruuda.nl/rcl/syntax/#debug-tracing"><code>trace</code></a>, and with <a href="https://docs.ruuda.nl/rcl/rcl_query/"><code>rcl query</code></a> you can evaluate an expression against a document to drill down into it. For example, to look only at the first bucket:</p><pre><code>rcl query buckets.rcl &#39;input.buckets[0]&#39;</code></pre><p>This feature is what made <abbr>RCL</abbr> useful for a use case that I did not anticipate: querying json documents.</p><h2 id="an-unexpected-jq-replacement"><a href="#an-unexpected-jq-replacement"></a>An unexpected jq replacement</h2><p>I use <a href="https://jqlang.github.io/jq/">jq</a> a lot. Most of the time, only to pretty-print a json document returned from some <abbr>API</abbr>. Because <abbr>RCL</abbr> is a superset of json, <code>rcl</code> can do that too now:</p><pre><code>curl --silent https://api.example.com | rcl evaluate</code></pre><p>By itself that is nothing special, the true power comes when querying. Jq features its own stream processing <abbr>DSL</abbr>, and for simple expressions I can usually remember the syntax — unpack the list, extract a few fields. But when it gets more complex, I’m at a loss. A while while ago, I was dealing with a json document that had roughly this structure:</p><div id="cb5"><pre><code><span id="cb5-1"><span>[</span></span>
<span id="cb5-2">  <span>{</span> <span>&#34;name&#34;</span><span>:</span> <span>&#34;server-1&#34;</span><span>,</span> <span>&#34;tags&#34;</span><span>:</span> <span>[</span><span>&#34;amd&#34;</span><span>,</span> <span>&#34;fast&#34;</span><span>]</span> <span>}</span><span>,</span></span>
<span id="cb5-3">  <span>{</span> <span>&#34;name&#34;</span><span>:</span> <span>&#34;server-2&#34;</span><span>,</span> <span>&#34;tags&#34;</span><span>:</span> <span>[</span><span>&#34;intel&#34;</span><span>,</span> <span>&#34;slow&#34;</span><span>]</span> <span>}</span><span>,</span></span>
<span id="cb5-4">  <span>{</span> <span>&#34;name&#34;</span><span>:</span> <span>&#34;server-3&#34;</span> <span>}</span><span>,</span></span>
<span id="cb5-5">  <span>{</span> <span>&#34;name&#34;</span><span>:</span> <span>&#34;server-4&#34;</span><span>,</span> <span>&#34;tags&#34;</span><span>:</span> <span>[</span><span>&#34;amd&#34;</span><span>,</span> <span>&#34;vm&#34;</span><span>,</span> <span>&#34;slow&#34;</span><span>]</span> <span>}</span></span>
<span id="cb5-6"><span>]</span></span></code></pre></div><p>I wanted to know the names of all the machines that had a particular tag applied. That the <code>tags</code> field is missing from some machines complicates that, and the real input consisted of hundreds of machines, so fixing that by hand was not feasible. I spent about 10 minutes struggling with <code>jq</code> and scrolling through unhelpful Stack Overflow answers. I did not think to try ChatGPT at the time, but in hindsight it <em>almost</em> gets the query right to a point where I could then get it working myself. But fundamentally, these kind of queries come up so infrequently that the things I learn about <code>jq</code> never really stick. ChatGPT is no excuse to tolerate bad tools: if the one-liner is easy to write, that’s still faster than leaving your terminal. At that point I remembered: I have a language in which this query is straightforward to express, and it can import json!</p><pre><code>$ rcl query --output=raw machines.json &#39;[
  for m in input:
  if m.get(&#34;tags&#34;, []).contains(&#34;amd&#34;):
  m.name
]&#39;
server-1
server-4</code></pre><p>That’s how <abbr>RCL</abbr>, even though it is intended as a configuration language, became one of my most frequently used query languages.</p><h2 id="the-future-of-rcl"><a href="#the-future-of-rcl"></a>The future of <abbr>RCL</abbr></h2><p>That day when I was fed up with <abbr>HCL</abbr> and I ran <code>git init</code>, I didn’t expect to produce anything useful aside from entertaining myself for a few evenings. Now six months later, <abbr>RCL</abbr> is no longer vaporware, and it regularly solves real problems for me!</p><p>Some parts of <abbr>RCL</abbr> are already quite polished. It has mostly good error reporting, <a href="https://docs.ruuda.nl/rcl/">there is reference documentation</a>, it has an autoformatter, and it is very well tested with a suite of golden tests and fuzzers. Although I’m not sure at what point it starts being worth the complication of an additional tool, <abbr>RCL</abbr> can define cloud storage buckets today with <a href="https://developer.hashicorp.com/terraform/language/syntax/json">Terraform’s json syntax</a>. But <abbr>RCL</abbr> is also far from ready for prime time: there is no syntax highlighting for any editor aside from Vim, the type system is a work in progress, it doesn’t support floats yet, the Python module doesn’t expose errors nicely, the autoformatter has quirks, and I’m still ambivalent about whether there should be a <code>:</code> after <code>else</code>.</p><p>But most of all, I’m not sure whether I <em>want</em> <abbr>RCL</abbr> to experience prime time. Of course it is very gratifying to see your project be adopted and solve real-world problems for other people. I’m proud of what I built so far and I <em>want</em> people to see it and try it — that’s why I publish everything as free and open source software, and that’s why I’m writing this post. It always cheers me up when somebody who found one of my projects useful or interesting sends me an e-mail. But I also already experience a bit of maintainer fatigue from some of my successful Rust crates, and I don’t always spend the time on them that they deserve. When a project takes off, inevitably users start making requests, having opinions, and submitting well-intentioned but low-quality contributions. Keeping up with that takes time and mental energy. I like working on <abbr>RCL</abbr> right now, because I get to build it in exactly the way I want, and it solves exactly the problems that I have. Building a tool for the open source community would require making different trade-offs. For now, I’m treating it as a source-available project. It solves a need for me, and if others find it useful that’s great, but it is provided as-is. Maybe Haskell’s <em>avoid success at all cost</em> isn’t such a bad idea.</p><h2 id="appendix-a-non-exhaustive-list-of-configuration-languages"><a href="#appendix-a-non-exhaustive-list-of-configuration-languages"></a>Appendix: A non-exhaustive list of configuration languages</h2><p>Aside from Nix, Python, and <abbr>HCL</abbr>, which I’ve already discussed extensively, I am aware of the following configuation languages. For the ones that I’ve used or at least evaluated briefly, I added my personal impressions, but beware that these are very superficial.</p><p><a href="https://github.com/Azure/bicep"><strong>Bicep</strong></a> — Microsoft’s <abbr>DSL</abbr> for configuring Azure resources declaratively. I haven’t looked into it in much detail because I don’t work with Azure, but it looks potentially interesting.</p><p><a href="https://cuelang.org/"><strong>Cue</strong></a> — Out of all the configuration languages that I evaluated during a company hackathon, I found Cue to be the most promising one. Its type system is interesting: it helps to constrain and validate configuration (as you would expect from a type system), but it also plays a role in eliminating boilerplate. Like Nix, Cue is based on few simple constructs that compose well, and grounded in solid theory. It took me some time before it clicked, but when it did, Cue became really powerful. A few things I don’t like about it are the package/module system that has its roots in the Go ecosystem, and its string interpolation syntax which is hideous. The command-line tooling works but could be more polished, and I found it to become slow quickly, even for fairly small configurations. It has <a href="https://cuelang.org/docs/usecases/configuration/#comparisons">a page</a> comparing itself against a few other configuation languages.</p><p><a href="https://dhall-lang.org/"><strong>Dhall</strong></a> — This is the first configuration language that I learned about many years ago. From what I can tell, it is one of the most mature and widely supported configuration languages. I use <a href="https://github.com/purescript/spago">Spago</a>, the PureScript package manager, in some of my projects, and it uses Dhall as its configuration format. Unfortunately it looks like it is being <a href="https://github.com/purescript/spago/tree/bbe37b6cd497aa544bd0761fa7a56a5f5d002a87#migrate-from-spagodhall-to-spagoyaml">deprecated</a> in favor of yaml. I tried to use Dhall once to solve an Advent of Code challenge, but got stuck immediately because it’s not possible to split strings in Dhall. Of course, this is an unfair test to evaluate a configuration language on, but it does give an impression of the expressivity of a language. I’ve used Nix to <a href="https://github.com/ruuda/adventofcode/blob/c452562c72cdd203df4dd0fd631596e6c0e2aa13/2022/03/main.nix">solve</a> a few Advent of Code challenges in the past, and this year I <a href="https://github.com/ruuda/adventofcode/blob/c452562c72cdd203df4dd0fd631596e6c0e2aa13/2023/11/main.rcl">solved</a> a few in <abbr>RCL</abbr>, which went pretty well for small inputs, but the lack of unbounded loops and tail calls make it unsuitable as a general-purpose language. Although I used to work as a Haskell developer, the formatting and names of built-in functions in Dhall look awkward to me.</p><p><a href="https://json-e.js.org/"><strong><abbr>JSON</abbr>-e</strong></a> — A json parametrization language. I discovered this one in Rimu’s list of related projects. I think I’ve seen it mentioned a few times before, but I haven’t evaluated it at all.</p><p><a href="https://jsonnet.org/"><strong>Jsonnet</strong></a> — I never properly evaluated Jsonnet, but probably I should. Superficially it looks like one of the more mature formats, and in many ways it looks similar to <abbr>RCL</abbr>. Its has <a href="https://jsonnet.org/articles/comparisons.html">a page</a> comparing itself against other configuration languages.</p><p><a href="https://kcl-lang.io/"><strong><abbr>KCL</abbr></strong></a> — This is an odd one. From the website and repository it looks like a lot of resources went into this project, but somehow I’ve never seen it come up or be used anywhere. I only learned about it when I started searching for configuration languages. From the way it describes itself, it sounds like the tool I want, but I am generally wary of tools that use lots of buzzwords, especially when it involves the words “modern” and “cloud native”. I should evaluate it properly at some point. It has <a href="https://kcl-lang.io/docs/0.6.0/user_docs/getting-started/intro/#how-to-choose">a page</a> comparing itself against other configuation languages.</p><p><a href="https://nickel-lang.org/"><strong>Nickel</strong></a> — <a href="https://www.tweag.io/blog/2020-10-22-nickel-open-sourcing/">An attempt to create a language similar to Nix</a>, but without being tied to the package manager and Nix store. It looked very promising to me, but after evaluating it during a company hackathon, I found it difficult or impossible to express sanity checks that I can easily express in Cue and <abbr>RCL</abbr>. Its has <a href="https://github.com/tweag/nickel/blob/6cf2902d3db768618e1d990c549671e308dd3ff4/RATIONALE.md#comparison-with-alternatives">a page</a> comparing itself against other configuation languages.</p><p><a href="https://pkl-lang.org/"><strong>Pkl</strong></a> — A configuration language by Apple. The timing is eerie: I wrote this post on a Saturday with the intention of proofreading and publishing it the next day, and right that Sunday morning, <a href="https://pkl-lang.org/blog/introducing-pkl.html">the Pkl announcement post</a> was on the Hacker News frontpage. From the comments, it <a href="https://news.ycombinator.com/item?id=39248081">has been in use</a> at Apple internally for a few years already. I haven’t had the opportunity to evaluate it yet. Its has <a href="https://pkl-lang.org/main/current/introduction/comparison.html">a page</a> comparing itself against other configuation languages, but only superficially.</p><p><a href="https://www.pulumi.com/"><strong>Pulumi</strong></a> — Not a configuration language, but an infrastructure automation tool like Terraform. It can be configured using existing general-purpose programming languages. I haven’t had the opportunity to try it, but I suppose I don’t get to complain about <abbr>HCL</abbr> without at least acknowledging Pulumi’s existence.</p><p><a href="https://rimu.dev/"><strong>Rimu</strong></a> — I stumbled upon this one recently while browsing <a href="https://github.com/topics/configuration-language">the configuration-language tag</a> on GitHub. It might be an eerie case of <a href="https://en.wikipedia.org/wiki/Multiple_discovery">parallel discovery</a>: like <abbr>RCL</abbr>, it looks like a configuration language developed as a side project, written in Rust, started in August 2023, and not ready for serious use yet. Unlike <abbr>RCL</abbr>, its syntax is based on yaml.</p><p><a href="https://bazel.build/rules/language"><strong>Starlark</strong></a> — A Python dialect used by the Bazel build tool. I used it intensively when I was working with Blaze/Bazel, and it works well for defining build targets. Starlark has multiple implementations, including <a href="https://github.com/facebookexperimental/starlark-rust">one in Rust</a> that can be used as a standalone command-line tool, but all the implementations clearly focus on being embedded. From my limited attempts to use them in an infrastructure-as-code repository, they are not suitable for incremental adoption there.</p><p><a href="https://www.typescriptlang.org/"><strong>TypeScript</strong></a> — Not a configuration language, but it deserves a mention here, because <abbr>RCL</abbr> intends to be json with abstraction and types, and since TypeScript is a superset of JavaScript, which is a superset of json, it falls in the same category of tools that can type and abstract json. I haven’t used TypeScript enough to have a strong opinion on its type system. Possibly <abbr>RCL</abbr>’s type system will end up being similar.</p></article></div>
  </body>
</html>
