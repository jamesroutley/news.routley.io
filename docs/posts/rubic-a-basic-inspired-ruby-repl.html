<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.scd31.com/posts/basic-repl">Original</a>
    <h1>Rubic - a BASIC-inspired Ruby REPL</h1>
    
    <div id="readability-page-1" class="page"><div><section><p>There was a point in time where most computers were primarily used as BASIC REPLs. BASIC is a language (or, more accurately, a family of languages) that are designed to be simple.</p><p>As an example, a few years ago I wrote a dialect of BASIC which I call <a href="https://gitlab.scd31.com/stephen/xbasic">xBASIC</a>. As far as BASICs go, it&#39;s honestly not super BASIC-y. This is what a simple xBASIC program might look like:</p><pre><span>for</span><span> x = </span><span>10</span><span> to </span><span>20
</span><span>    </span><span>print</span><span> x
</span><span>next</span><span> x
</span></pre>
<p>This program counts from 10 to 20, with each number on a new line.</p><p>But I&#39;m not that interested in talking about the BASIC languages. I&#39;m more interested in talking about the (typical) BASIC REPL.</p><p>REPLs are what allow you to type code and have it evaluated in real-time. For example, with Ruby, you can type <code>irb</code> and it drops you into a Ruby REPL, where you can type Ruby code and have it run immediately.</p><p>Modern REPLs aren&#39;t terrible, but really they&#39;re optimized for single-line, quick debugging. In contrast, the BASIC REPL was usually also your text editor, so it had to work for writing multi-line, full programs. For this, BASIC REPLs used the concept of line numbers. The program up above might be written now like this:</p><pre><span>10 </span><span>for</span><span> x = </span><span>10</span><span> to </span><span>20
</span><span>20  </span><span>print</span><span> x
</span><span>30 </span><span>next</span><span> x
</span></pre>
<p>When the BASIC REPL sees a line number, it doesn&#39;t execute it immediately. Instead it saves it to the current program. This makes it easy to update lines, or add lines in between. For example, maybe you want to print &#34;hi&#34; before each number. All you need to do is type <code>15 print &#34;hi&#34;</code> and your program has been updated. Maybe you don&#39;t want to print the number at all - type <code>20</code> and it&#39;ll remove that line from the program.</p><p>Contrast that to writing a multi-line program in something like IRB. If you want to create, update, or delete a line, you need to rewrite the entire program in your REPL, changing what you need. It&#39;s super cumbersome if what you&#39;re working on is more than 2 or 3 lines.</p><p>So, over the last few days, I wrote <a href="https://gitlab.scd31.com/stephen/rubic">Rubic</a>. Rubic is a BASIC-inspired Ruby REPL. Here&#39;s what a session in Rubic might look like:</p><pre><span>&gt; </span><span>10 </span><span>puts </span><span>&#34;</span><span>what is your name?</span><span>&#34;
</span><span>&gt; </span><span>20 </span><span>name </span><span>= </span><span>gets</span><span>.</span><span>chomp
</span><span>&gt; </span><span>30 </span><span>puts </span><span>&#34;</span><span>nice to meet you, </span><span>#{</span><span>name</span><span>}</span><span>!</span><span>&#34;
</span><span>&gt;
</span><span>&gt; list
</span><span>10 </span><span>puts </span><span>&#34;</span><span>what is your name?</span><span>&#34;
</span><span>20 </span><span>name </span><span>= </span><span>gets</span><span>.</span><span>chomp
</span><span>30 </span><span>puts </span><span>&#34;</span><span>nice to meet you, </span><span>#{</span><span>name</span><span>}</span><span>!</span><span>&#34;
</span><span>&gt; run
</span><span>what is your name?
</span><span>stephen
</span><span>nice to meet you, stephen!
</span><span>=&gt; </span><span>nil
</span><span>&gt; </span><span># but wouldn&#39;t it be nice if we printed the last line a few times?
</span><span>=&gt; </span><span>nil
</span><span>&gt; </span><span>25 </span><span>for</span><span> _ </span><span>in </span><span>0</span><span>..</span><span>5
</span><span>&gt; </span><span>35 </span><span>end
</span><span>&gt; list
</span><span>10 </span><span>puts </span><span>&#34;</span><span>what is your name?</span><span>&#34;
</span><span>20 </span><span>name </span><span>= </span><span>gets</span><span>.</span><span>chomp
</span><span>25 </span><span>for</span><span> _ </span><span>in </span><span>0</span><span>..</span><span>5
</span><span>30 </span><span>puts </span><span>&#34;</span><span>nice to meet you, </span><span>#{</span><span>name</span><span>}</span><span>!</span><span>&#34;
</span><span>35 </span><span>end
</span><span>&gt; run
</span><span>what is your name?
</span><span>stephen
</span><span>nice to meet you, stephen!
</span><span>nice to meet you, stephen!
</span><span>nice to meet you, stephen!
</span><span>nice to meet you, stephen!
</span><span>nice to meet you, stephen!
</span><span>nice to meet you, stephen!
</span><span>=&gt; </span><span>0</span><span>..</span><span>5
</span><span>&gt; </span><span># but now our line numbers aren&#39;t equidistant anymore! let&#39;s clean them up
</span><span>=&gt; </span><span>nil
</span><span>&gt; squish
</span><span>&gt; list
</span><span>1 </span><span>puts </span><span>&#34;</span><span>what is your name?</span><span>&#34;
</span><span>2 </span><span>name </span><span>= </span><span>gets</span><span>.</span><span>chomp
</span><span>3 </span><span>for</span><span> _ </span><span>in </span><span>0</span><span>..</span><span>5
</span><span>4 </span><span>puts </span><span>&#34;</span><span>nice to meet you, </span><span>#{</span><span>name</span><span>}</span><span>!</span><span>&#34;
</span><span>5 </span><span>end
</span><span>&gt; </span><span># or alternatively...
</span><span>=&gt; </span><span>nil
</span><span>&gt; widen
</span><span>&gt; list
</span><span>10 </span><span>puts </span><span>&#34;</span><span>what is your name?</span><span>&#34;
</span><span>20 </span><span>name </span><span>= </span><span>gets</span><span>.</span><span>chomp
</span><span>30 </span><span>for</span><span> _ </span><span>in </span><span>0</span><span>..</span><span>5
</span><span>40 </span><span>puts </span><span>&#34;</span><span>nice to meet you, </span><span>#{</span><span>name</span><span>}</span><span>!</span><span>&#34;
</span><span>50 </span><span>end
</span><span>&gt; </span><span># alright, let&#39;s save our program
</span><span>=&gt; </span><span>nil
</span><span>&gt; save greeter.rub
</span><span>&gt; </span><span># or if you just want a normal ruby file
</span><span>=&gt; </span><span>nil
</span><span>&gt; export greeter.rb
</span><span>&gt; </span><span># with load/import you can also do the opposite (load an existing rub or rb file)
</span><span>=&gt; </span><span>nil
</span></pre>
<p>This, in my opinion, is a much nicer way to write scripts in the REPL. Aside from normal BASIC operations, I&#39;ve also added <code>squish</code> and <code>widen</code> commands. <code>squish</code> will change the line numbers so they go 1, 2, 3, etc., and <code>widen</code> will change the line numbers so that they go 10, 20, 30, etc. I think <code>widen</code> especially is quite useful, as it&#39;s easy to run out of line numbers when making changes otherwise! I&#39;m not sure if any BASIC REPLs implement an equivalent of these commands. I didn&#39;t check, so it&#39;s probably not a new idea, but I don&#39;t think it&#39;s a super common one either.</p><p>Also worth pointing out is <code>save</code> / <code>load</code> and <code>import</code> / <code>export</code>. The former works with Rubic files (which are Ruby files with the line numbers) and the latter works with normal Ruby files. This allows you to write a full Ruby program in Rubic, and then save it to a file. It also allows you to take an existing Ruby file and iterate on it in Rubic.</p><p>Rubic also supports a bunch of creature comforts that you would expect (primarily through use of IRB under the hood). You can write code without line numbers to have it run immediately, and it supports syntax highlighting and autocomplete as well.</p><p>One thing I&#39;m quite proud of is that Rubic&#39;s syntax highlighting is context-aware! For example, imagine this is what your current program looks like:</p><pre><span>10 </span><span>for</span><span> i </span><span>in </span><span>0</span><span>..</span><span>10
</span></pre>
<p>If you try to do <code>5 end</code>, that <code>end</code> doesn&#39;t match up with anything, so it turns red. But if you do <code>20 end</code>, the <code>end</code> matches the <code>for</code> and so it turns green!</p></section><h2>Motivation</h2><section><p>I should probably talk a bit about why I built this. I find when writing scripts, I&#39;d like a slightly faster development loop than &#34;edit file&#34; -&gt; &#34;run script&#34; -&gt; &#34;repeat&#34;. I think being able to just change lines and type &#34;run&#34; in the same context should be a little less annoying.</p><p>Another thing specific to Ruby is that large-ish projects have fairly awful startup times. A mid-sized Rails project might take 30 seconds just to start the environment. Having to do that every time you rerun a script can be a bit dreadful. Rails does include a <code>reload!</code> method which helps, but it still takes a few seconds, and it&#39;s another thing to have to type every iteration. I&#39;m hoping that Rubic delivers real value for me, using it to iterate on scripts, but I&#39;m also hoping it serves as a PoC for writing more modern REPLs that use the same concepts.</p></section><h2>Disclaimer</h2><section><p>I should probably mention that Rubic is not exactly stellar in terms of code quality. The way it works under-the-hood is pretty inefficient (though it shouldn&#39;t matter unless you have many thousands of lines of code). It&#39;s also a bit hacky (for example, using a private IRB method in once place). It does its job well, but improvements certainly wouldn&#39;t hurt.</p></section></div></div>
  </body>
</html>
