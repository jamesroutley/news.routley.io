<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://alexgarcia.xyz/blog/2024/building-new-vector-search-sqlite/index.html">Original</a>
    <h1>I’m writing a new vector search SQLite Extension</h1>
    
    <div id="readability-page-1" class="page"><div><p>2024-05-02 by <a href="https://alexgarcia.xyz/">Alex Garcia</a></p><section>


<div>
<blockquote>
<p><em>tl;dr — <a href="https://github.com/asg017/sqlite-vec"><code>sqlite-vec</code></a> will be a new
SQLite extension for vector search, replacing <code>sqlite-vss</code>. It will be an
embeddable &#34;fast enough&#34; vector search tool, that can run anywhere SQLite
runs - including WASM! It&#39;s still in active development, but
<a href="https://github.com/asg017/sqlite-vec">check out the repo</a> to learn when it
will be ready!</em></p>
</blockquote>
<hr/>
</div>

<p>I&#39;m working on a new SQLite extension! It&#39;s called
<a href="https://github.com/asg017/sqlite-vec"><code>sqlite-vec</code></a>, an extension for vector
search, written purely in C. It&#39;s meant to replace
<a href="https://github.com/asg017/sqlite-vss"><code>sqlite-vss</code></a>, another vector search
SQLite extension I released in February 2023, which
<a href="#wrong-sqlite-vss">has a number of problems</a>. I believe the approach I&#39;m taking
with <code>sqlite-vec</code> solves a number of problem it&#39;s predecessor has, will have a
much nicer and performant SQL API, and is a better fit for all applications who
want an embed vector search solution!</p>
<h2>What <code>sqlite-vec</code> will be</h2>
<p><code>sqlite-vec</code> will be a SQLite extension written purely in C with no
dependencies. It will provide custom SQL functions and virtual tables for fast
vector search, as well as other tools and utilities for working with vectors
(quantization, JSON/BLOB/numpy conversions, vector arithmetic, etc.).</p>
<p>A quick sample of what vector search will look like with <code>sqlite-vec</code>, in pure
SQL:</p>
<pre tabindex="0"><code><span><span>.</span><span>load</span><span> .</span><span>/</span><span>vec0</span></span>
<span></span>
<span><span>-- a &#34;vector store&#34; for 8-dimensional floating point numbers</span></span>
<span><span>create</span><span> virtual</span><span> table</span><span> vec_examples </span><span>using</span><span> vec0(</span></span>
<span><span>  sample_embedding </span><span>float</span><span>[8]</span></span>
<span><span>);</span></span>
<span></span>
<span><span>-- vectors can be provided as JSON or in a compact binary format</span></span>
<span><span>insert into</span><span> vec_examples(rowid, sample_embedding)</span></span>
<span><span>  values</span></span>
<span><span>    (</span><span>1</span><span>, </span><span>&#39;[-0.200, 0.250, 0.341, -0.211, 0.645, 0.935, -0.316, -0.924]&#39;</span><span>),</span></span>
<span><span>    (</span><span>2</span><span>, X</span><span>&#39;E5D0E23E894100BF8FC2B53E426045BFF4FD343F7D3F35BFA4703DBE1058B93E&#39;</span><span>),</span></span>
<span><span>    (</span><span>3</span><span>, </span><span>&#39;[0.716, -0.927, 0.134, 0.052, -0.669, 0.793, -0.634, -0.162]&#39;</span><span>),</span></span>
<span><span>    (</span><span>4</span><span>, X</span><span>&#39;8FC235BFC3F5A83E9EEF273F9EEF273DA4707DBF23DB393FB81EC53E7D3F75BF&#39;</span><span>);</span></span>
<span></span>
<span></span>
<span><span>-- KNN style query goes brrrr</span></span>
<span><span>  select</span></span>
<span><span>    rowid,</span></span>
<span><span>    distance</span></span>
<span><span>  from</span><span> vec_examples</span></span>
<span><span>  where</span><span> sample_embedding match </span><span>&#39;[0.890, 0.544, 0.825, 0.961, 0.358, 0.0196, 0.521, 0.175]&#39;</span></span>
<span><span>  order by</span><span> distance</span></span>
<span><span>  limit</span><span> 2</span><span>;</span></span>
<span></span>
<span><span>/*</span></span>
<span><span>rowid,distance</span></span>
<span><span>2,2.38687372207642</span></span>
<span><span>1,2.38978505134583</span></span>
<span><span>*/</span></span></code></pre>
<p>Using <code>sqlite-vec</code> means using pure SQL, just <code>CREATE VIRTUAL TABLE</code>,
<code>INSERT INTO</code>, and <code>SELECT</code> statements.</p>
<p>This work is exciting - for many reasons! First off, &#34;written in pure C&#34; means
it will be able to run anywhere. The previous <code>sqlite-vss</code> extension, which had
some cumbersome C++ dependencies, was only able to reliably run on Linux and
MacOS machines, with binaries in the <code>3MB</code>-<code>5MB</code> range. By contrast,
<code>sqlite-vec</code> will run on all platforms (Linux/MacOS/Windows), in the browser
with WebAssembly, and even smaller devices like mobile phones and Raspberry Pis!
Smaller binaries too, in the few 100&#39;s of KB range.</p>
<p>Additionally, <code>sqlite-vec</code> has more control over memory usage. By default,
vectors are stored in &#39;chunks&#39; in shadow tables, and are read chunk-by-chunk
during KNN searches. This means you don&#39;t need to store everything in RAM!
Though if you do want in-memory speed, you could use the
<a href="https://www.sqlite.org/pragma.html#pragma_mmap_size"><code>PRAGMA mmap_size</code></a>
command to make KNN searches much faster.</p>
<p>And finally, <code>sqlite-vec</code> is built in a new &#34;era&#34; of vector search tooling and
research. There will be better support for &#34;adative-length embeddings&#34; (aka
<a href="https://huggingface.co/blog/matryoshka">Matryoshka embeddings</a>), and
<code>int8</code>/<code>bit</code> vector support for
<a href="https://huggingface.co/blog/embedding-quantization">binary and scalar quantization</a>.
This means more control over the speed, accuracy, and disk space that your
vectors take up.</p>
<p>Though initially, <code>sqlite-vec</code> will only support exhaustive full-scan vector
search. There will be no &#34;approximate nearest neighbors&#34; (ANN) options. But I
hope to add IVF + HNSW in the future!</p>
<h2>Demo</h2>
<p>Enough yappin&#39; let&#39;s see a demo</p>
<p><code>sqlite-vec</code> is running right now in your browser! If you open up devtools,
you&#39;ll see an (un-optimized) <code>5.9MB</code> <code>sqlite3.wasm</code> file, which is the
<a href="https://sqlite.org/wasm/doc/trunk/about.md">official SQLite WASM build</a> with
<code>sqlite-vec</code> compiled in. There is a <code>movies.bit.db</code> SQLite database also
loaded, which is a <code>2.6MB</code> SQLite database, which has
<a href="https://www.kaggle.com/datasets/tmdb/tmdb-movie-metadata?select=tmdb_5000_movies.csv">this movies dataset</a>
with 4,800 movie overviews in the <code>articles</code> table. The separate <code>vec_movies</code>
virtual table is a vector index of those &#34;overviews&#34; embedded, with
<a href="https://blog.nomic.ai/posts/nomic-embed-matryoshka">Nomic&#39;s 1.5 embeddings model</a>,
quantized to binary vectors.</p>
<p>Here&#39;s a quick sample of what the data looks like:</p>

<p>Here we see the <code>articles</code> table has columns like <code>title</code>, <code>release_date</code>, and
<code>overview</code>. The <code>overview</code> column here is important - it&#39;s a very short sentence
describing the plot of the movie. We also have the <code>vec_articles</code> virtual table,
which stores embeddings of the <code>articles.overview</code> as the <code>overview_embeddings</code>
column. Thy are binary vectors with 768 dimensions, which takes up 96 bytes
(<code>768 / 8 = 96</code>).</p>
<p>Now let&#39;s see how a KNN-style search works! Here&#39;s a lil&#39; table select
component. Select a movie with the radio button on the left-hand side.</p>

<p>The movie ID you selected will now pre-populate the <code>:selected_movie</code> SQL
parameter in this KNN SQL query!</p>

<p>Those are the 10 closest movies to the one you selected! The &#34;closest&#34; one
(using hamming distance, because it&#39;s a binary vector) will always be the same
movie, with a distance of 0. Keep in mind, embedding a single-sentence plot
description of a small movie dataset doesn&#39;t give the best results (and binary
quantization sacrifices even more quality), but the core idea remains. Fast,
&#34;good enough&#34; vector search, in your browser!</p>
<p>More docs about this KNN-style query will come soon, but in case you wanted to
poke around at the internals, try adding a <code>EXPLAIN QUERY PLAN</code> to the beginning
of the <code>SELECT</code> statement. You&#39;ll see the <code>0:knn</code> &#34;index&#34; that <code>vec_movies</code>
uses.</p>
<h2 id="wrong-sqlite-vss"> But what&#39;s wrong with <code>sqlite-vss</code>?</h2>
<p>I won&#39;t go into all the details, but there were a number of roadblocks in the
development and adoption of <code>sqlite-vss</code>, including:</p>
<ul>
<li>Only worked on Linux + MacOS machines (no Windows, WASM, mobile devices, etc.)</li>
<li>Stored vectors all in-memory</li>
<li>Various transaction-related bugs and issues</li>
<li>Extremely hard and time-consuming to compile</li>
<li>Missing common vector operations (scalar/binary quantization)</li>
</ul>
<p>Nearly all of these are because <code>sqlite-vss</code> depended on
<a href="https://github.com/facebookresearch/faiss">Faiss</a>. With a lot of time and
energy, some of these issues could <em>maybe</em> be solved, but many of them would be
blocked by Faiss.</p>
<p>Given all this, a no-dependency and low-level solution seemed really enticing.
Turns out, vector search isn&#39;t too complicated, so <code>sqlite-vec</code> was born!</p>
<h2>Still not ready, but soon!</h2>
<p>The core features of <code>sqlite-vec</code> work, but I have very little error handling +
testing. I have 246 TODOs in the <code>sqlite-vec.c</code> file, which I&#39;m tracking with a
lil script:</p>
<pre tabindex="0"><code><span><span>$ make progress</span></span>
<span><span>deno run --allow-read=sqlite-vec.c scripts/progress.ts</span></span>
<span><span>Number of todo_assert()&#39;s:      191</span></span>
<span><span>Number of &#34;// TODO&#34; comments:   41</span></span>
<span><span>Number of todo panics:          14</span></span>
<span><span>Total TODOs:                    246</span></span>
<span><span></span></span>
<span><span>░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ (0/246)</span></span>
<span><span></span></span>
<span><span>0% complete to sqlite-vec v0</span></span></code></pre>
<p>Once those 246 TODOs are completed, then the first <code>v0.1.0</code> of <code>sqlite-vec</code> will
be released, with documentation, demos, bindings, and more! I&#39;m aiming for a
month or so, but we shall see!</p>
<h2>I&#39;m looking for sponsors!</h2>
<p>Is your company interested in the success of <code>sqlite-vec</code>? I&#39;d love to chat!
<a href="https://alexgarcia.xyz/">Email me</a> for more information.</p>
</section></div></div>
  </body>
</html>
