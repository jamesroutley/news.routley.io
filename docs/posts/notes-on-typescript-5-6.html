<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://effectivetypescript.com/2024/09/30/ts-56/">Original</a>
    <h1>Notes on TypeScript 5.6</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>We TypeScript developers are a lucky bunch. While some languages (<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/History_of_Python" onclick="return trackOutboundLink(&#39;notes on typescript&#39;, &#39;https://en.wikipedia.org/wiki/History_of_Python&#39;, event);">Python</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/ECMAScript_version_history" onclick="return trackOutboundLink(&#39;notes on typescript&#39;, &#39;https://en.wikipedia.org/wiki/ECMAScript_version_history&#39;, event);">JavaScript</a>) are released annually, every three years (<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/C%2B%2B#Standardization" onclick="return trackOutboundLink(&#39;notes on typescript&#39;, &#39;https://en.wikipedia.org/wiki/C%2B%2B#Standardization&#39;, event);">C++</a>) or even less, we get <em>four</em> new versions of TypeScript every year. TypeScript 5.6 was <a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-6/" onclick="return trackOutboundLink(&#39;notes on typescript&#39;, &#39;https://devblogs.microsoft.com/typescript/announcing-typescript-5-6/&#39;, event);">released</a> on September 9th, 2024. Let&#39;s take a look.</p>
<h2 id="New-Features"><a href="#New-Features" title="New Features"></a>New Features</h2><h3 id="Disallowed-Nullish-and-Truthy-Checks"><a href="#Disallowed-Nullish-and-Truthy-Checks" title="Disallowed Nullish and Truthy Checks"></a>Disallowed Nullish and Truthy Checks</h3><p>TypeScript will now alert you to certain conditionals that are always true or false:</p>
<figure><div><pre><code><span>const</span> value = {} || <span>&#39;unreachable&#39;</span>;<br/></code></pre></div></figure>

<p>Because <code>{}</code> is truthy, the right-hand side of the <code>||</code> is dead code. It should either be removed or investigated, since it might indicate a logic error.</p>
<p>If your project is large and has been around for a while, this check is likely to turn up some strange-looking code. For example, I got a &#34;this expression is always truthy&#34; error on code that looked like this:</p>
<figure><div><pre><code><span>const</span> val = { ...obj, <span>prop</span>: value } || {};<br/></code></pre></div></figure>

<p>What&#39;s that <code>|| {}</code> doing there? Running <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-blame" onclick="return trackOutboundLink(&#39;new features&#39;, &#39;https://git-scm.com/docs/git-blame&#39;, event);">git blame</a> revealed the story. The code originally looked like this:</p>
<figure><div><pre><code><span>const</span> val = obj || {};<br/></code></pre></div></figure>

<p>Then a subsequent change added <code>prop: value</code> to the object and didn&#39;t remove the fallback. In this case, it&#39;s fine to remove the <code>|| {}</code> since using <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" onclick="return trackOutboundLink(&#39;new features&#39;, &#39;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&#39;, event);">object spread</a> on a <code>null</code>/<code>undefined</code> value is OK.</p>
<p>This new check is the single best reason to update to TS 5.6. I haven&#39;t seen a single false positive, and I&#39;ve found lots of strange-looking code. This matches the TypeScript team&#39;s <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/59217#issuecomment-2222103311" onclick="return trackOutboundLink(&#39;new features&#39;, &#39;https://github.com/microsoft/TypeScript/pull/59217#issuecomment-2222103311&#39;, event);">findings</a>.</p>
<h3 id="Iterator-Helper-Methods"><a href="#Iterator-Helper-Methods" title="Iterator Helper Methods"></a>Iterator Helper Methods</h3><p>In addition to finding new errors in your code, new TypeScript releases continue the ongoing process of implementing all stage 3 ECMAScript features.</p>
<p>TypeScript 5.6 now supports <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator#iterator_helpers" onclick="return trackOutboundLink(&#39;new features&#39;, &#39;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator#iterator_helpers&#39;, event);">Iterator Helper methods</a> like <code>map</code> and <code>take</code>. If you&#39;ve ever used Python&#39;s <a target="_blank" rel="noopener" href="https://docs.python.org/3/library/itertools.html" onclick="return trackOutboundLink(&#39;new features&#39;, &#39;https://docs.python.org/3/library/itertools.html&#39;, event);"><code>itertools</code> package</a>, this will be familiar. The appeal of iterators is that you can apply a series of operations to an array, for example, without constructing all the intermediate arrays. This reduces memory usage and should improve cache efficiency and performance.</p>
<p>Because these are JavaScript runtime methods, you&#39;ll need to use a runtime that supports them. At the moment that&#39;s Node.js 22 (which should enter long-term support in October) and around <a target="_blank" rel="noopener" href="https://caniuse.com/mdn-javascript_builtins_iterator_take" onclick="return trackOutboundLink(&#39;new features&#39;, &#39;https://caniuse.com/mdn-javascript_builtins_iterator_take&#39;, event);">67% of browsers</a>. Unless you can guarantee support in your environment, you may want to wait on these for a bit.</p>
<h3 id="Strict-Builtin-Iterator-Checks-and-strictBuiltinIteratorReturn"><a href="#Strict-Builtin-Iterator-Checks-and-strictBuiltinIteratorReturn" title="Strict Builtin Iterator Checks (and --strictBuiltinIteratorReturn)"></a>Strict Builtin Iterator Checks (and --strictBuiltinIteratorReturn)</h3><p>TypeScript&#39;s <code>any</code> type is dangerous: not only does it disable type checking, it can also silently spread through your program. <a href="https://effectivetypescript.com/#Chapter-5-Unsoundness-and-the-any-Type">Chapter 5</a> of <a target="_blank" rel="noopener" href="https://amzn.to/3UjPrsK" onclick="return trackOutboundLink(&#39;new features&#39;, &#39;https://amzn.to/3UjPrsK&#39;, event);"><em>Effective TypeScript</em></a> is all about taming the <code>any</code> type.</p>
<p>Perhaps the scariest source of <code>any</code> types is type declaration files (<code>.d.ts</code>). If you call a function and it&#39;s declared to return <code>any</code>, then <code>any</code> is what you get, even if the word &#34;any&#34; never appears in your source code. <code>JSON.parse</code> is a famous example of this:</p>
<figure><div><pre><code><span>const</span> obj = <span>JSON</span>.parse(<span>&#39;{&#34;a&#34;: 2}&#39;</span>);  </code></pre></div></figure>

<p>(Matt Pocock&#39;s <a target="_blank" rel="noopener" href="https://github.com/mattpocock/ts-reset" onclick="return trackOutboundLink(&#39;new features&#39;, &#39;https://github.com/mattpocock/ts-reset&#39;, event);">ts-reset</a> fixes this and a few other well known issues.)</p>
<p>One subtle source of <code>any</code> came from direct use of an iterator&#39;s <code>.next()</code> method:</p>
<figure><div><pre><code><span>const</span> letters = <span>new</span> <span>Set</span>([<span>&#39;a&#39;</span>, <span>&#39;b&#39;</span>, <span>&#39;c&#39;</span>]);</code></pre></div></figure>

<p>The type in TS 5.6 makes a lot of sense! If the Set were empty, <code>oneLetter</code> would be <code>undefined</code>. Otherwise it would be a <code>string</code>. (You can also check the <code>done</code> property to narrow the type.) While directly working with an iterator is rare (you should typically use <code>for-of</code> loops or the new iterator helpers), this is a welcome improvement because it eliminates a surprising source of <code>any</code> types.</p>
<p>So the real question is… why was this an <code>any</code> type in older versions of TypeScript? To understand why, the TypeScript blog gives <a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-6/#strict-builtin-iterator-checks-(and---strictbuiltiniteratorreturn)" onclick="return trackOutboundLink(&#39;new features&#39;, &#39;https://devblogs.microsoft.com/typescript/announcing-typescript-5-6/#strict-builtin-iterator-checks-(and---strictbuiltiniteratorreturn)&#39;, event);">this example</a>:</p>
<figure><div><pre><code><span><span>function</span>* <span>abc123</span>(<span></span>) </span>{</code></pre></div></figure>

<p>A generator function (which returns an iterator) can both <code>yield</code> and <code>return</code> values. When it returns a value, that goes into the <code>value</code> property of the iterator&#39;s value.</p>
<p>TypeScript models this with two type parameters: <code>Iterator&lt;T, TReturn&gt;</code>. Most iterators don&#39;t return a special value when they&#39;re done, so <code>TReturn</code> is typically <code>void</code> (the return type of a function without a <code>return</code> statement).</p>
<p>When TypeScript <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/12346" onclick="return trackOutboundLink(&#39;new features&#39;, &#39;https://github.com/microsoft/TypeScript/pull/12346&#39;, event);">first added support for iterators</a> in 2016, they didn&#39;t distinguish <code>T</code> and <code>TReturn</code>. When they did split these types in 2019, they had to default <code>TReturn</code> to <code>any</code> to <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/30790#:~:text=boolean%2C%20A%20%26%20B%3E%27-,Notes,-For%20these%20definitions" onclick="return trackOutboundLink(&#39;new features&#39;, &#39;https://github.com/microsoft/TypeScript/pull/30790#:~:text=boolean%2C%20A%20%26%20B%3E%27-,Notes,-For%20these%20definitions&#39;, event);">maintain backwards compatibility</a>. The <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/33353#issuecomment-532574516" onclick="return trackOutboundLink(&#39;new features&#39;, &#39;https://github.com/microsoft/TypeScript/issues/33353#issuecomment-532574516&#39;, event);">kicked the can down the road</a> for years until this release, when they <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/58243" onclick="return trackOutboundLink(&#39;new features&#39;, &#39;https://github.com/microsoft/TypeScript/pull/58243&#39;, event);">added a new flag</a>, <code>strictBuiltinIteratorReturn</code>, to fix it. This is enabled with <code>--strict</code>, so you should get it right away.</p>
<p>A few more quick notes on this:</p>
<ul>
<li>The types around iterators, generators and async iterators are all pretty confusing. I hope to write a blog post about them at some point in the future.</li>
<li>If you don&#39;t have <code>strictNullChecks</code> enabled, you may see some strange errors around <code>value</code> having a type of <code>string | void</code>. The fix is to enable <code>strictNullChecks</code>!</li>
<li>This was a surprising source of <code>any</code> types that could spread in your code. To limit the damage from these sorts of <code>any</code>s, consider using typescript-eslint&#39;s <a target="_blank" rel="noopener" href="https://typescript-eslint.io/rules/no-unsafe-assignment/" onclick="return trackOutboundLink(&#39;new features&#39;, &#39;https://typescript-eslint.io/rules/no-unsafe-assignment/&#39;, event);"><code>no-unsafe-assignment</code></a>, York Yao&#39;s <a target="_blank" rel="noopener" href="https://github.com/plantain-00/type-coverage" onclick="return trackOutboundLink(&#39;new features&#39;, &#39;https://github.com/plantain-00/type-coverage&#39;, event);">type-coverage</a> tool, or my brand-new <a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=danvk.any-xray" onclick="return trackOutboundLink(&#39;new features&#39;, &#39;https://marketplace.visualstudio.com/items?itemName=danvk.any-xray&#39;, event);">Any X-Ray Vision</a> VS Code extension.</li>
</ul>
<h3 id="The-noUncheckedSideEffectImports-Option"><a href="#The-noUncheckedSideEffectImports-Option" title="The --noUncheckedSideEffectImports Option"></a>The --noUncheckedSideEffectImports Option</h3><p>I first noticed this issue when I was working on the second edition of <a target="_blank" rel="noopener" href="https://amzn.to/3UjPrsK" onclick="return trackOutboundLink(&#39;new features&#39;, &#39;https://amzn.to/3UjPrsK&#39;, event);"><em>Effective TypeScript</em></a>. I claimed that this would be an error:</p>
<figure><div><pre><code><span>import</span> <span>&#39;non-existent-file.css&#39;</span>;<br/></code></pre></div></figure>

<p>… but it wasn&#39;t! This is a pretty strange TypeScript behavior. For these &#34;side-effect imports,&#34; where you don&#39;t import any symbols, TypeScript will try to resolve the path to the module. If it can, it will type check the file that you import. But if it can&#39;t, it will just ignore the import entirely.</p>
<p>Now you can change this behavior with <code>noUncheckedSideEffectImports</code>. If you use CSS imports, you&#39;re likely to get tons of errors when you first enable this, one for every import. The solution that the release notes <a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-6/#the---nouncheckedsideeffectimports-option" onclick="return trackOutboundLink(&#39;new features&#39;, &#39;https://devblogs.microsoft.com/typescript/announcing-typescript-5-6/#the---nouncheckedsideeffectimports-option&#39;, event);">suggest</a> is to add this line to a <code>.d.ts</code> file:</p>
<figure><div><pre><code><span>declare</span> <span>module</span> <span>&#39;*.css&#39;</span> {}<br/></code></pre></div></figure>

<p>But this feels a bit too lenient. It will catch a typo if you get the extension wrong (<code>.cs</code> instead of <code>.css</code>). But it won&#39;t check that you&#39;re importing a file that exists. I experimented with listing all my CSS files in a <code>.d.ts</code> file:</p>
<figure><div><pre><code><span>declare</span> <span>module</span> <span>&#39;css/file1.css&#39;</span> {}</code></pre></div></figure>

<p>But this didn&#39;t seem to work at all. Relative imports of these files still produced type errors. So I think this feature still needs some work to be useful.</p>
<h3 id="Region-Prioritized-Diagnostics-in-Editors"><a href="#Region-Prioritized-Diagnostics-in-Editors" title="Region-Prioritized Diagnostics in Editors"></a>Region-Prioritized Diagnostics in Editors</h3><p>Like most compilers, TypeScript is <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Self-hosting_(compilers)" onclick="return trackOutboundLink(&#39;new features&#39;, &#39;https://en.wikipedia.org/wiki/Self-hosting_(compilers)&#39;, event);">self-hosting</a>: <code>tsc</code> is written in TypeScript. This is a good idea because it&#39;s a form of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Eating_your_own_dog_food" onclick="return trackOutboundLink(&#39;new features&#39;, &#39;https://en.wikipedia.org/wiki/Eating_your_own_dog_food&#39;, event);">dogfooding</a>. The idea is that, since the TS team works in TypeScript every day, they&#39;ll be acutely aware of all the same issues that face other TypeScript developers.</p>
<p>Sometimes, though, this can have strange consequences. I suspect that most developers who contribute to TypeScript had a chuckle when they saw <a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-6/#region-prioritized-diagnostics-in-editors" onclick="return trackOutboundLink(&#39;new features&#39;, &#39;https://devblogs.microsoft.com/typescript/announcing-typescript-5-6/#region-prioritized-diagnostics-in-editors&#39;, event);">Region-Prioritized Diagnostics in Editors</a> in the TS 5.6 release notes. The idea is that, for very large TypeScript files, the editor can focus on just the part that you&#39;re editing, rather than checking the whole file.</p>
<p>Sounds like a nice performance win. So why did I find this funny? It&#39;s because it&#39;s so clearly targeted at just one file, TypeScript&#39;s 50,000+ line <code>checker.ts</code>. It&#39;s incredible to me that the TS team implemented this feature rather than breaking up that file, but there you go!</p>
<h2 id="New-Errors"><a href="#New-Errors" title="New Errors"></a>New Errors</h2><p>Whenever a new version of TypeScript comes out, I like to run it over all my projects and the code samples in <a target="_blank" rel="noopener" href="https://amzn.to/3UjPrsK" onclick="return trackOutboundLink(&#39;new errors&#39;, &#39;https://amzn.to/3UjPrsK&#39;, event);"><em>Effective TypeScript</em></a> using <a target="_blank" rel="noopener" href="https://github.com/danvk/literate-ts" onclick="return trackOutboundLink(&#39;new errors&#39;, &#39;https://github.com/danvk/literate-ts&#39;, event);">literate-ts</a> to look for new errors. There were a few of them, including some surprises.</p>
<p>Several errors came from the new checks I discussed earlier in this post, &#34;this expression is always truthy&#34; and <code>.next()</code> calls having stricter types. These were all true positives: they flagged code that was suspicious.</p>
<p>There were also two types of errors that came as surprises.</p>
<p>One was a change in circularity detection for a code sample in Effective TypeScript, in <a target="_blank" rel="noopener" href="https://github.com/danvk/effective-typescript/blob/main/samples/ch-design/null-values-to-perimeter.md" onclick="return trackOutboundLink(&#39;new errors&#39;, &#39;https://github.com/danvk/effective-typescript/blob/main/samples/ch-design/null-values-to-perimeter.md&#39;, event);">Item 33: Push Null Values to the Perimeter of Your Types</a>:</p>
<figure><div><pre><code><span><span>function</span> <span>extent</span>(<span>nums: Iterable&lt;<span>number</span>&gt;</span>) </span>{</code></pre></div></figure>

<p>In the first edition of <em>Effective TypeScript</em>, the same snippet avoided destructuring assignment in the <code>else</code> clause due to the circularity error:</p>
<figure><div><pre><code>result = [<span>Math</span>.min(num, result[<span>0</span>]), <span>Math</span>.max(num, result[<span>1</span>])];<br/></code></pre></div></figure>

<p>I <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/33191" onclick="return trackOutboundLink(&#39;new errors&#39;, &#39;https://github.com/microsoft/TypeScript/issues/33191&#39;, event);">filed an issue</a> about this in 2019 and was excited to see that it was <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/56753" onclick="return trackOutboundLink(&#39;new errors&#39;, &#39;https://github.com/microsoft/TypeScript/pull/56753&#39;, event);">fixed</a> with TS 5.4, just in time for the book release. Unfortunately, the fix got reverted and we&#39;re <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/33191#issuecomment-2218027441" onclick="return trackOutboundLink(&#39;new errors&#39;, &#39;https://github.com/microsoft/TypeScript/issues/33191#issuecomment-2218027441&#39;, event);">back to the circularity error</a>. So I&#39;ll need to update the book.</p>
<p>I also ran into an <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/60077" onclick="return trackOutboundLink(&#39;new errors&#39;, &#39;https://github.com/microsoft/TypeScript/issues/60077&#39;, event);">issue</a> where the inferred type parameters for a generic function call changed. It boiled down to something like this:</p>
<figure><div><pre><code><span>declare</span> <span>const</span> f: &lt;P&gt;(</code></pre></div></figure>

<p>I used <a target="_blank" rel="noopener" href="https://github.com/jakebailey/every-ts" onclick="return trackOutboundLink(&#39;new errors&#39;, &#39;https://github.com/jakebailey/every-ts&#39;, event);">every-ts</a> to bisect this to <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/57909" onclick="return trackOutboundLink(&#39;new errors&#39;, &#39;https://github.com/microsoft/TypeScript/pull/57909&#39;, event);">#57909</a>. This PR changed how type inference worked between covariant and contravariant parameters. If you see a surprising type change like this after updating to TS 5.6, this change might be the reason.</p>
<p>After <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/59764#issuecomment-2311067288" onclick="return trackOutboundLink(&#39;new errors&#39;, &#39;https://github.com/microsoft/TypeScript/issues/59764#issuecomment-2311067288&#39;, event);">reading</a> some <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/59764#issuecomment-2311543160" onclick="return trackOutboundLink(&#39;new errors&#39;, &#39;https://github.com/microsoft/TypeScript/issues/59764#issuecomment-2311543160&#39;, event);">comments</a>, this all seems pretty <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/59772#discussion_r1733190826" onclick="return trackOutboundLink(&#39;new errors&#39;, &#39;https://github.com/microsoft/TypeScript/pull/59772#discussion_r1733190826&#39;, event);">murky</a>. There&#39;s often no clearly correct inference, just tradeoffs. Given that, I&#39;m a bit surprised that TypeScript changed the existing behavior. Be on the lookout for this one!</p>
<h2 id="Performance-changes"><a href="#Performance-changes" title="Performance changes"></a>Performance changes</h2><p>New TypeScript releases have the potential to speed up or slow down compile times, but I was unable to measure any significant changes with this release.</p>
<h2 id="Conclusions"><a href="#Conclusions" title="Conclusions"></a>Conclusions</h2><p>While TS 5.6 isn&#39;t quite the <a href="https://effectivetypescript.com/2024/07/02/ts-55/">blockbuster</a> that TS 5.5 was, the new &#34;this expression is always truthy&#34; checks and the more precise iterator types make it a worthwhile upgrade.</p>
<p>It&#39;s <a target="_blank" rel="noopener" href="https://matklad.github.io/2024/03/22/basic-things.html#Releases" onclick="return trackOutboundLink(&#39;conclusions&#39;, &#39;https://matklad.github.io/2024/03/22/basic-things.html#Releases&#39;, event);">sometimes said</a> that software dependencies obey a &#34;reverse <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Triangle_inequality" onclick="return trackOutboundLink(&#39;conclusions&#39;, &#39;https://en.wikipedia.org/wiki/Triangle_inequality&#39;, event);">triangle inequality</a>:&#34; it&#39;s easier to go from v1→v2→v3 than it is to go from v1→v3 directly. The idea is that you can fix a smaller set of issues at a time. There&#39;s not much reason to hold off on adopting TypeScript 5.6. Doing so now will make upgrading to 5.7 easier in a few months.</p>
<p>Speaking of which, keep an eye on that release! I&#39;m hoping that it will include the proposed <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/58296" onclick="return trackOutboundLink(&#39;conclusions&#39;, &#39;https://github.com/microsoft/TypeScript/pull/58296&#39;, event);"><code>enforceReadonly</code> flag</a>.</p>

          </div></div>
  </body>
</html>
