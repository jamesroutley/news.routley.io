<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://news.ycombinator.com/item?id=30339187">Original</a>
    <h1>Ask HN: How to prepare as soon-to-be blind developer?</h1>
    
    <div id="readability-page-1" class="page"><div>
						
<p>A <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">heap</a> is a tree data structure where each child node is greater than its parent node.</p>



<blockquote><p>child node &gt;= parent node</p></blockquote>



<p>With this property satisfied, it’s ensured that the root node is the minimum value in the heap. This is very useful for many types of problems. Getting the minimum value in the heap is <em>O(1)</em>, and both adding new values and removing the root node are <em>O(log n)</em>.</p>



<p>To be more precise, the description above corresponds to a <em>min heap</em>. Similarly, if each child node is smaller than its parent node, we have a <em>max heap</em>. In general, nodes can be compared using any criterion, depending on the properties of the nodes. We’ll focus on <em>min heaps</em> in this blog post, but the principles can be generalized to any kind of heap.</p>



<h2 id="heap-properties-and-uses">Heap properties and uses</h2>



<p>A heap allows us to recover the smallest element in a collection in constant time <em>O(1)</em>. Consider the heap below.</p>



<div><figure><img src="https://onestepcode.com/wp-content/uploads/2022/02/heap.drawio-1.png" alt="" width="419" height="271" srcset="https://onestepcode.com/wp-content/uploads/2022/02/heap.drawio-1.png 559w, https://onestepcode.com/wp-content/uploads/2022/02/heap.drawio-1-300x194.png 300w" sizes="(max-width: 419px) 100vw, 419px"/><figcaption>Heap example</figcaption></figure></div>



<p>It consists of 6 nodes, with the (unordered) values: <code>[2, 10, -1, 9, 0, 8]</code>. See that the value at the top, <code>-1</code>, is the minimum in the collection. Getting the minimum of a heap is as simple as getting the root node. </p>



<p>There is only one condition that holds in the heap: each child is greater than its parent. There is no ordering between children nodes at the same level. This simple single condition allows for efficient ordering of the elements.</p>



<p>Heaps allow for two extra operations: deleting the root node (which is always the minimum value) and adding any new value. Both operations are performed in logarithmic time <em>O(log n)</em>.</p>



<h3 id="adding-new-elements">Adding new elements</h3>



<p>Every time we add a new element, we fill the next available position in the tree, from top to bottom, left to right. Let’s add the value <code>1</code>. It would fill the empty right child of node <code>2</code>.</p>



<div><figure><img loading="lazy" src="https://onestepcode.com/wp-content/uploads/2022/02/heap-add-value.drawio.png" alt="Adding value 1 to the heap" width="419" height="271" srcset="https://onestepcode.com/wp-content/uploads/2022/02/heap-add-value.drawio.png 559w, https://onestepcode.com/wp-content/uploads/2022/02/heap-add-value.drawio-300x194.png 300w" sizes="(max-width: 419px) 100vw, 419px"/><figcaption>Adding value 1 to the heap</figcaption></figure></div>



<p>After adding this new node, the heap isn’t ordered. We have to reestablish the property of each child node being greater than its parent. This can be done by “bubbling up” the new node <code>1</code> until it’s greater than its parent node. We do this by swapping positions between the new node and its parent.</p>



<div><figure><img loading="lazy" src="https://onestepcode.com/wp-content/uploads/2022/02/heap-new-element-ordered.png" alt="Node 1 and its parent swap places" width="419" height="271" srcset="https://onestepcode.com/wp-content/uploads/2022/02/heap-new-element-ordered.png 559w, https://onestepcode.com/wp-content/uploads/2022/02/heap-new-element-ordered-300x194.png 300w" sizes="(max-width: 419px) 100vw, 419px"/><figcaption>Node 1 and its parent swap places</figcaption></figure></div>



<p>Then, we compare node <code>1</code> with its new parent, and continue bubbling up the node if the heap property still isn’t satisfied or until we have reached the root node. In this case, <code>1</code> is greater than its parent <code>-1</code>, so we stop. If we had added a value such as <code>-2</code>, it would have bubbled up all the way up to the root node. This bubbling up process is performed in <em>O(log n)</em>. Once we’re done, the root node is once again the minimum in the collection.</p>



<h3 id="deleting-values">Deleting values</h3>



<p>Deletion is possible only for the root (minimum) node. It’s performed by removing the root node and substituting it with the last node (from top to bottom, left to right). </p>



<div><figure><img loading="lazy" src="https://onestepcode.com/wp-content/uploads/2022/02/heap-deletion.drawio.png" alt="Deleting the root node of the heap" width="361" height="356" srcset="https://onestepcode.com/wp-content/uploads/2022/02/heap-deletion.drawio.png 481w, https://onestepcode.com/wp-content/uploads/2022/02/heap-deletion.drawio-300x296.png 300w" sizes="(max-width: 361px) 100vw, 361px"/><figcaption>Deleting the root node of the heap</figcaption></figure></div>



<p>See that node <code>-1</code> isn’t part of the heap anymore. See also that the heap property (each child is greater than its parent) isn’t satisfied anymore. We have to “sink down” the new root node to its correct position. This is done by swapping the position of the parent node with the <strong>smallest</strong> of its children. We start by swapping 2 and 0.</p>



<div><figure><img loading="lazy" src="https://onestepcode.com/wp-content/uploads/2022/02/heap-deletion-reordered.drawio.png" alt="Reordering the heap after extracting the root node" width="361" height="271" srcset="https://onestepcode.com/wp-content/uploads/2022/02/heap-deletion-reordered.drawio.png 481w, https://onestepcode.com/wp-content/uploads/2022/02/heap-deletion-reordered.drawio-300x225.png 300w" sizes="(max-width: 361px) 100vw, 361px"/><figcaption>Reordering the heap after extracting the root node</figcaption></figure></div>



<p>This process continues as long as the heap property isn’t satisfied or until we reach the bottom of the tree. In this case, the heap is ordered again after swapping nodes <code>2</code> and <code>0</code>, so we stop. After reordering, the root node of the heap is again the smallest in the collection. This reordering process after deletion is also <em>O(log n)</em>.</p>



<h2 id="heap-tree-data-structure-implementation">Heap tree data structure implementation</h2>



<p>We could implement the heap using node objects.</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">class Node {
  constructor(val, left, right) {
    this.val = val;
    this.left = left ? left : null;
    this.right = right ? right: null;
  }
}</pre>



<p>However, an easier and more efficient approach is to just use an array. We stack the elements of the heap, from top to bottom, left to right. </p>



<p>For our initial heap example:</p>



<div><figure><img src="https://onestepcode.com/wp-content/uploads/2022/02/heap.drawio-1.png" alt="" width="419" height="271" srcset="https://onestepcode.com/wp-content/uploads/2022/02/heap.drawio-1.png 559w, https://onestepcode.com/wp-content/uploads/2022/02/heap.drawio-1-300x194.png 300w" sizes="(max-width: 419px) 100vw, 419px"/><figcaption>Heap example</figcaption></figure></div>



<p>This would result in the array:</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">[-1, 0, 2, 10, 9, 8]</pre>



<p>In order to simplify the indices of the heap nodes in the array, we add a dummy value at the beginning of the array.</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">[-1, -1, 0, 2, 10, 9, 8]</pre>



<p>We used the value <code>-1</code>, but <code>null</code> or any other value works fine, too.</p>



<p>Counting the nodes starting from 1, yields the following result:</p>



<div><figure><img loading="lazy" src="https://onestepcode.com/wp-content/uploads/2022/02/heap-indices.drawio-1.png" alt="" width="419" height="299" srcset="https://onestepcode.com/wp-content/uploads/2022/02/heap-indices.drawio-1.png 559w, https://onestepcode.com/wp-content/uploads/2022/02/heap-indices.drawio-1-300x214.png 300w" sizes="(max-width: 419px) 100vw, 419px"/><figcaption>Heap indices</figcaption></figure></div>



<p>See that with this convention, we can get the parent, left node, and right node for any node at index <code>i</code> as follows:</p>



<blockquote><p>parent index = Math.floor(i/2)</p></blockquote>



<p>For example, the left child of node at index<code>3</code> is <code>2 * 3 = 6</code>. Its parent node is <code>3 / 2 = 1</code>.</p>



<h2 id="heap-implementation">Heap implementation</h2>



<p>As it was stated, we will use an array to store the heap’s tree. The first value of the array is a dummy value, <code>-1</code>.</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">class MinHeap {
  constructor(values) {
    this.list = [-1];
    if (typeof values == &#34;number&#34;) values = [values];
    values.forEach((value) =&gt; this.add(value));
  }
  ...
}</pre>



<p>The heap is constructed by passing an array of numbers (or a single number that is converted to an array), to it. Then, each value is added to the heap using the <code>add</code> method.</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">class MinHeap {
  ...
  add(value) {
    const len = this.list.length;
    // add value to heap
    this.list.push(value);
    if (len == 1) {
      return value;
    }    
    // reorder from bottom to top
    this.heapifyUp();
    return this.list[1];
  }
}</pre>



<p>Adding a value to the heap starts by adding it to the next empty position in the tree. This is as simple as calling<code>this.list.push</code>. If the heap has only one value, it’s already ordered. Otherwise, we call the <code>heapifyUp</code> method to reorder the heap. Once that’s done, this method returns the minimum value in the collection, which is the one with index 1.</p>



<p>Removing elements is done by taking the bottom-right node of the tree and moving it to the root. Prior to that, we verify the heap is not empty. We also deal with the trivial case of a heap with a single element. After replacing the root node with the last node, we reorder the heap with the <code>heapifyDown</code> method. The deleted element, which corresponds to the previous minimum value, is returned.</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">class MinHeap {
  ...
  remove() {
    if (this.list.length == 1) return null;
    if (this.list.length == 2) return this.list.pop();
    const prevRoot = this.list[1];
    // bring last val to root
    this.list[1] = this.list.pop();
    // reorder top to bottom
    this.heapifyDown();
    return prevRoot;
  }
}</pre>



<p>The reordering functions are implemented as follows:</p>



<p>When we add a new node, it will always be the last value in the array. </p>



<ol><li>Compare the new node with its parent node.</li><li>If the new node is smaller than its parent, the heap is not ordered. Parent and new node swap positions.</li><li>Repeat from 1 until reaching the root node or 2 is false. </li></ol>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">class MinHeap {
  ...
  heapifyUp() {
    let i = this.list.length - 1;
    const val = this.list[i];
    while (!this.isRoot(i) &amp;&amp; this.getParentNode(i) &gt; val) {
      // swap values
      [this.list[this.getParentIndex(i)], this.list[i]] = [
        val,
        this.getParentNode(i),
      ];
      i = this.getParentIndex(i);
    }
  }
}</pre>



<p>When we remove the root node, the last node of the tree takes its place.</p>



<ol><li>Start from the new root node, with value <code>val</code>.</li><li>If node <code>val</code> is greater than any of its children, replace it with the <strong>smallest</strong> child.</li><li>Else stop.</li><li>Repeat from 2 until it’s false or reaching the bottom of the tree.</li></ol>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">class MinHeap {
  ...
  heapifyDown() {
    if (this.list.length &lt; 3) return;
    let i = 1;
    const currentVal = this.list[1];
    let leftVal = this.getLeftNode(i);
    let rightVal = this.getRightNode(i);
    while (
      leftVal !== undefined &amp;&amp;
      (currentVal &gt; leftVal || currentVal &gt; rightVal)
    ) {
      if (
        currentVal &gt; leftVal &amp;&amp;
        (rightVal === undefined || leftVal &lt; rightVal)
      ) {
        [this.list[this.getLeftIndex(i)], this.list[i]] = [currentVal, leftVal];
        i = this.getLeftIndex(i);
      } else {
        [this.list[this.getRightIndex(i)], this.list[i]] = [
          currentVal,
          rightVal,
        ];
        i = this.getRightIndex(i);
      }
      leftVal = this.getLeftNode(i);
      rightVal = this.getRightNode(i);
    }
  }
}</pre>



<p>We add special clauses to deal with empty nodes, which yield <code>undefined</code>.</p>



<p>All of the above functions use the following helpers:</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">class MinHeap {
  ...
  isRoot(index) {
    return index == 1;
  }

  getLeftIndex(index) {
    return 2 * index;
  }

  getLeftNode(index) {
    return this.list[this.getLeftIndex(index)];
  }

  getRightIndex(index) {
    return 2 * index + 1;
  }

  getRightNode(index) {
    return this.list[this.getRightIndex(index)];
  }

  getParentIndex(index) {
    return Math.floor(index / 2);
  }

  getParentNode(index) {
    return this.list[this.getParentIndex(index)];
  }
}
</pre>



<h2 id="example">Example</h2>



<p>Let’s use the heap to get the minimum value of the array: <code>[1, 2, 3, -10, -100, 99, 0]</code>.</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">const heap = new MinHeap([1, 2, 3, -10, -100, 99, 0])
heap.remove()
// -100
heap.remove()
// -10
heap.add(-3)
// -3
heap.add(5)
// -3</pre>



<h2 id="bonus-implementing-heapsort">Bonus: Implementing heapsort</h2>



<p>After every removal, the heap reorders itself so that the minimum value is always at the root. This means that subsequent calls to the <code>remove</code> method will yield the heap values in increasing order. We’ll exploit this to implement a sort algorithm.</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">class MinHeap {
  ...
  sort() {
    const sorted = [];
    let nextVal;
    while ((nextVal = this.remove()) !== null) {
      sorted.push(nextVal);
    }
    return sorted;
  }
}</pre>



<p>Let’s see it in action.</p>



<pre data-enlighter-language="js" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">const heap = new MinHeap([1, 2, 3, -10, -100, 99, 0])
heap.sort()
// [ -100, -10, 0, 1, 2, 3, 99 ]</pre>



<p>Since reordering the heap after each removal is <em>O(log n)</em> sorting an array of <em>n </em>elements with heapsort is <em>O(n log n)</em>. Quite performant!</p>



<h2 id="additional-resources">Additional resources</h2>



<ul><li>Videos explaining heaps: <a href="https://www.youtube.com/watch?v=dM_JHpfFITs">freeCodeCamp</a>, <a href="https://www.youtube.com/watch?v=t0Cq6tVNRBA">hackerRank</a></li><li>Heap implementation explanation: <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)#Implementation">Wikipedia</a>.</li><li>Codepen with demo and TypeScript source code: <a href="https://codepen.io/onestepcode/pen/Exbwmye">codepen</a>.</li></ul>
					</div></div>
  </body>
</html>
