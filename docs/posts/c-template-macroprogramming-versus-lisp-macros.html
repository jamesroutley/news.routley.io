<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://simondobson.org/2024/06/21/c%2B%2B-template-macroprogramming-versus-lisp-macros/">Original</a>
    <h1>C&#43;&#43; Template Macroprogramming versus Lisp Macros</h1>
    
    <div id="readability-page-1" class="page"><div id="text-org1aec963">
<p>
Following on from <a href="https://simondobson.org/2024/06/14/lisp-macros-versus-rust-macros/">Lisp macros versus Rust macros</a>, I also want to
compare C++ templates to Lisp macros.
</p>

<p>
Templates in C++ were designed as a way of generating typed versions
of classes. The template declares some type variables that can be
used as placeholders within a class declaration. When the template
is instanciated and provided with actual type names, these are
substituted for the type variables and the class is expanded. (It
used to literally happen like this, so each use generated a
completely new class. Modern compilers are smart enough to avoid the
code repetition.) A classic example is a typed singly-linked list:
</p>

<div><pre><span></span><span>  </span><span>template</span><span>&lt;</span><span>typename</span><span> </span><span>A</span><span>&gt;</span>
<span>  </span><span>struct</span><span> </span><span>List</span><span>&lt;</span><span>A</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>A</span><span> </span><span>value</span><span>;</span>
<span>    </span><span>struct</span><span> </span><span>List</span><span>&lt;</span><span>A</span><span>&gt;</span><span> </span><span>next</span><span>;</span>
<span>  </span><span>};</span>
</pre></div>

<p>
However, the template system also allows values to be used in
templates instead of (or as well as) type names. When these are
encountered they are expanded at compile-time, and may cause further
templates to be expanded. A classic example of this is to
pre-compute some factorials:
</p>

<div><pre><span></span><span>  </span><span>template</span><span>&lt;</span><span>unsigned</span><span> </span><span>n</span><span>&gt;</span>
<span>  </span><span>struct</span><span> </span><span>factorial</span><span> </span><span>{</span>
<span>    </span><span>enum</span><span> </span><span>{</span><span> </span><span>value</span><span> </span><span>=</span><span> </span><span>n</span><span> </span><span>*</span><span> </span><span>factorial</span><span>&lt;</span><span>n</span><span> </span><span>-</span><span> </span><span>1</span><span>&gt;::</span><span>value</span><span> </span><span>};</span>
<span>  </span><span>};</span>

<span>  </span><span>template</span><span> </span><span>&lt;&gt;</span>
<span>  </span><span>struct</span><span> </span><span>factorial</span><span>&lt;</span><span>0</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>enum</span><span> </span><span>{</span><span> </span><span>value</span><span> </span><span>=</span><span> </span><span>1</span><span> </span><span>};</span>
<span>  </span><span>};</span>
</pre></div>

<p>
In this code the first clause defines a template that defines the
usual recursive factorial calculation. The second clause bottoms-out
this recursion by defining a specialised template that directly
provides the factorial of zero. This can then be used in code such as:
</p>

<div><pre><span></span><span>  </span><span>template</span><span>&lt;</span><span>unsigned</span><span> </span><span>n</span><span>&gt;</span>
<span>  </span><span>struct</span><span> </span><span>factorial</span><span> </span><span>{</span>
<span>    </span><span>enum</span><span> </span><span>{</span><span> </span><span>value</span><span> </span><span>=</span><span> </span><span>n</span><span> </span><span>*</span><span> </span><span>factorial</span><span>&lt;</span><span>n</span><span> </span><span>-</span><span> </span><span>1</span><span>&gt;::</span><span>value</span><span> </span><span>};</span>
<span>  </span><span>};</span>

<span>  </span><span>template</span><span> </span><span>&lt;&gt;</span>
<span>  </span><span>struct</span><span> </span><span>factorial</span><span>&lt;</span><span>0</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>enum</span><span> </span><span>{</span><span> </span><span>value</span><span> </span><span>=</span><span> </span><span>1</span><span> </span><span>};</span>
<span>  </span><span>};</span>

<span>  </span><span>int</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span>
<span>    </span><span>std</span><span>::</span><span>cout</span><span> </span><span>&lt;&lt;</span><span> </span><span>factorial</span><span>&lt;</span><span>7</span><span>&gt;::</span><span>value</span><span> </span><span>&lt;&lt;</span><span> </span><span>std</span><span>::</span><span>endl</span><span>;</span>
<span>  </span><span>}</span>
</pre></div>

<pre>5040
</pre>


<p>
which outputs the factorial of 7 as one might expect – but with the
factorial having been computed at compile-time and inserted into the
code as a literal, so the calculation introduces no run-time calculation.
</p>

<p>
There are some stringent limitations on the ways in which templates
can be expanded. They can’t have mutable variables for a start
(that’s why we needed to use the recursive factorial algorithm).
Weirdly this makes the template language a <i>functional programming
sub-set</i> of C++. Having said that, as with Lisp macros, it allows
calculations that can be statically performed forward to be brought
forward to compile-time. This makes it useful for building read-only
tables, unrolling loops, and the like.
</p>

<p>
It’s <a href="https://en.wikipedia.org/wiki/Template_metaprogramming#Benefits_and_drawbacks_of_template_metaprogramming">claimed</a> that templates are now so akin to “normal” C++ that
they incur less of a readability penalty. That’s a subjective
statement that may be true. But the template language <i>isn’t</i> C++.
While one <i>can</i> write programs in it, they’re <i>nothing like</i> the C++ one
would normally write. The template language is Turing complete, but
that just means one can encode any <i>computation</i>, not that one can
encode any <i>particular program</i> – and most template programs will
require massive re-writing from the code one would write normally
for execution at run-time. Template macroprogramming is therefore a
non-trivial programming task to undertake.
</p>

<p>
Again as with Rust <i>versus</i> Lisp, C++ templates are an extension to
the language rather than a core part of it, although they’re now
used quite extensively in the standard library for generic typing.
Also as with Rust, use of templates is semantically and
syntactically distinct from “normal” C++ code or syntax, and it’s
this that causes the programming load.
</p>

<p>
A Lisp macro for the factorial computation, by contrast, looks
<i>almost exactly</i> like a normal factorial function that can access the
entire language, both when defined and when used:
</p>

<div><pre><span></span><span>  </span><span>(</span><span>defmacro</span><span> </span><span>factorial</span><span> </span><span>(</span><span>n</span><span>)</span>
<span>    </span><span>(</span><span>labels</span><span> </span><span>((</span><span>fact</span><span> </span><span>(</span><span>m</span><span>)</span>
<span>               </span><span>(</span><span>if</span><span> </span><span>(</span><span>=</span><span> </span><span>m</span><span> </span><span>0</span><span>)</span>
<span>                   </span><span>1</span>
<span>                   </span><span>(</span><span>*</span><span> </span><span>m</span><span> </span><span>(</span><span>fact</span><span> </span><span>(</span><span>1-</span><span> </span><span>m</span><span>))))))</span>
<span>      </span><span>`,</span><span>(</span><span>fact</span><span> </span><span>n</span><span>)))</span>

<span>  </span><span>(</span><span>princ</span><span> </span><span>(</span><span>factorial</span><span> </span><span>7</span><span>))</span>
</pre></div>

<pre>5040
</pre>


<p>
The choice of macro or function (<code>defmacro</code> or <code>defun</code>) has no further
<i>syntactic</i> implications for the rest of the program, and no
restrictions on the code that can be used within the definition; we
could re-write the to use iteration, mutable variables, or any other
code, and it would simply be executed at compile-time. The whole
language is there, all the time. We can show this by taking a
factorial function written in “normal” Lisp and macro-ifying it to
be computed at compile-time:
</p>

<div><pre><span></span><span>  </span><span>(</span><span>defun</span><span> </span><span>fact</span><span> </span><span>(</span><span>m</span><span>)</span>
<span>    </span><span>&#34;Compute the factorial of M.&#34;</span>
<span>    </span><span>(</span><span>if</span><span> </span><span>(</span><span>=</span><span> </span><span>m</span><span> </span><span>0</span><span>)</span>
<span>        </span><span>1</span>
<span>        </span><span>(</span><span>*</span><span> </span><span>m</span><span> </span><span>(</span><span>fact</span><span> </span><span>(</span><span>1-</span><span> </span><span>m</span><span>)))))</span>

<span>  </span><span>(</span><span>defmacro</span><span> </span><span>factorial</span><span> </span><span>(</span><span>n</span><span>)</span>
<span>    </span><span>`,</span><span>(</span><span>fact</span><span> </span><span>n</span><span>))</span>

<span>  </span><span>(</span><span>princ</span><span> </span><span>(</span><span>factorial</span><span> </span><span>7</span><span>))</span>
</pre></div>

<pre>5040
</pre>


<p>
More importantly, Lisp (and indeed Rust) macro can abstract over
syntax as well as classes and values, and so allow the language to
be extended with new first-class-at-compile-time structures.
Templates are restricted to instanciating templates written with
a fixed syntax; in Lisp the syntax has to be “Lisp-like”, although
that’s a very light restriction; and in Rust a macro can use any
syntax that Rust can tokenise.
</p>

<p>
While C++ templates are sometimes described as macroprogramming (or
metaprogramming), they’re addressing a substantially different use
case to that addressed by Lisp or Rust macros, and doing so within a
more restricted computational and syntactic envelope.
</p>
</div></div>
  </body>
</html>
