<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.collabora.com/news-and-blog/blog/2025/05/06/matt-godbolt-sold-me-on-rust-by-showing-me-c-plus-plus/">Original</a>
    <h1>Matt Godbolt sold me on Rust (by showing me C&#43;&#43;)</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Matt Godbolt, of <a href="https://godbolt.org/" target="_blank" rel="noopener">Compiler Explorer</a> fame, is awesome and you should scour the web for every single bit of content he puts out. That is exactly what I was doing when I watched <a href="https://www.youtube.com/watch?v=nLSm3Haxz0I" target="_blank" rel="noopener">Correct by Construction: APIs That Are Easy to Use and Hard to Misuse</a>. After 20+ years of working with C/C++, this theme resonates a lot with me.</p>
<p>While watching the talk I kept thinking &#34;Yes! And that&#39;s why Rust does it that way.&#34; I came out at the end thinking that this talk was actually a great way of getting the intuition for how Rust helps you beyond the whole memory safety thing, and that is what this article intends to show.</p>
<p>But before we talk about that we should talk about the problems Matt raised and how he proposes to solve them in C++. Do yourself a favor and watch the full talk, but let me break one of them down!</p>
<h3>What&#39;s in a type</h3>
<p>Matt starts the talk by showing what a function that sends orders to a stock exchange might look like.</p>
<pre>void sendOrder(const char *symbol, bool buy, int quantity, double price)</pre>
<p>Before we go any further, let me just say he acknowledges floating point is not right for price and later talks about how he usually deals with it. But it makes for a nice example, bear with us.</p>
<p>Another obvious improvement that anyone used to this stuff will call out immediately is the bool for identifying a buy. That is error prone and Matt does call it out towards the end of this section.</p>
<p>But he first focuses on quantity and price and how C++ makes it really hard for you to stop callers from confusing them: the compiler will allow 1000.00 for quantity and 100 for price with no warnings, despite them being different types. It just silently converts.</p>
<p>How about some type aliasing?</p>
<pre>#include 

using Price = double;
using Quantity = int;

void sendOrder(const char *symbol, bool buy, int quantity, double price) {
  std::cout &lt;&lt; symbol &lt;&lt; &#34; &#34; &lt;&lt; buy &lt;&lt; &#34; &#34; &lt;&lt; quantity &lt;&lt; &#34; &#34; &lt;&lt; price
            &lt;&lt; std::endl;
}

int main(void) {
  sendOrder(&#34;GOOG&#34;, false, Quantity(100), Price(1000.00)); // Correct
  sendOrder(&#34;GOOG&#34;, false, Price(1000.00), Quantity(100)); // Wrong
}</pre>
<p>No luck! Both clang 19 and gcc 14 will take that and not complain - <em>even with -std=c++23 -Wall -Wextra -Wpedantic</em>, which I use for all of the C++ code in this article! A few rounds of improvements and we have the following version:</p>
<pre>#include 

class Price {
public:
  explicit Price(double price) : m_price(price) {};
  double m_price;
};

class Quantity {
public:
  explicit Quantity(unsigned int quantity) : m_quantity(quantity) {};
  unsigned int m_quantity;
};

void sendOrder(const char *symbol, bool buy, Quantity quantity, Price price) {
  std::cout &lt;&lt; symbol &lt;&lt; &#34; &#34; &lt;&lt; buy &lt;&lt; &#34; &#34; &lt;&lt; quantity.m_quantity &lt;&lt; &#34; &#34;
            &lt;&lt; price.m_price &lt;&lt; std::endl;
}

int main(void) {
  sendOrder(&#34;GOOG&#34;, false, Quantity(100), Price(1000.00));  // Correct
  sendOrder(&#34;GOOG&#34;, false, Quantity(-100), Price(1000.00)); // Wrong
}</pre>
<p>We have classes, we have explicit constructors (very important or C++ will trip you!), we have unsigned types… and now it&#39;s hard to put a Price where you want a Quantity! But we can still give Quantity a negative value without a single compiler warning, even though we moved to an unsigned type. A bit more magic and we can make that go away:</p>
<pre>#include 
#include 

class Price {
public:
  explicit Price(double price) : m_price(price) {};
  double m_price;
};

class Quantity {
public:
  template  explicit Quantity(T quantity) : m_quantity(quantity) {
    static_assert(std::is_unsigned(), &#34;Please use only unsigned types&#34;);
  }

  unsigned int m_quantity;
};

void sendOrder(const char *symbol, bool buy, Quantity quantity, Price price) {
  std::cout &lt;&lt; symbol &lt;&lt; &#34; &#34; &lt;&lt; buy &lt;&lt; &#34; &#34; &lt;&lt; quantity.m_quantity &lt;&lt; &#34; &#34;
            &lt;&lt; price.m_price &lt;&lt; std::endl;
}

int main(void) {
  sendOrder(&#34;GOOG&#34;, false, Quantity(100u), Price(1000.00)); // Correct
  sendOrder(&#34;GOOG&#34;, false, Quantity(-100), Price(1000.00)); // Wrong
}</pre>
<p>Finally we can get clang (and gcc) to complain loudly that this is being misused. All it took was a templated constructor that performs a static assert at compile time. Nice!</p>
<pre>order/order-5.cpp:13:19: error: static assertion failed due to requirement &#39;std::is_unsigned()&#39;: Please use only unsigned types
   13 |     static_assert(std::is_unsigned(), &#34;Please use only unsigned types&#34;);
      |                   ^~~~~~~~~~~~~~~~~~~~~
order/order-5.cpp:26:28: note: in instantiation of function template specialization &#39;Quantity::Quantity&#39; requested here
   26 |   sendOrder(&#34;GOOG&#34;, false, Quantity(-100), Price(1000.00)); // Wrong
      |                            ^
1 error generated.</pre>
<p>It&#39;s a lot of code, but at least we now have compiler protection. We are good, there is no other way to misuse quantity and price. Right?</p>
<p>What if we need to pass in a value the user typed on a UI, such that we need to convert it from string? Well, you are out of luck again:</p>
<pre>sendOrder(&#34;GOOG&#34;, false, Quantity(static_cast(atoi(&#34;-100&#34;))),
            Price(1000.00)); // Wrong</pre>
<p>Not only will it not fail to compile, but it will also not produce any errors at runtime. You will end up selling 4294967196 shares and going bankrupt.</p>
<p>Not ideal.</p>
<p>Matt keeps going, showing a few more magic tricks (and their pitfalls) to perform the runtime checks you will need to fully defend against this. I think this is a good point for us to stop on the C++ side and look at how Rust does, shall we?</p>
<h3>Enter Rust</h3>
<p>So is Rust any better? Rust has the benefit of decades of learning from all of these issues. And learn it did. Let&#39;s take a look. How does our first attempt fare?</p>
<pre>fn send_order(symbol: &amp;str, buy: bool, quantity: i64, price: f64) {
    println!(&#34;{symbol} {buy} {quantity} {price}&#34;);
}

fn main() {
    send_order(&#34;GOOG&#34;, false, 100, 1000.00); // Correct
    send_order(&#34;GOOG&#34;, false, 1000.00, 100); // Wrong
}</pre>
<p>After all the work we had to do with C++ it can&#39;t be this easy, can it?</p>
<pre>error[E0308]: arguments to this function are incorrect
 --&gt; order/order-1.rs:7:5
  |
7 |     send_order(&#34;GOOG&#34;, false, 1000.00, 100); // Wrong
  |     ^^^^^^^^^^                -------  --- expected `f64`, found `{integer}`
  |                               |
  |                               expected `i64`, found `{float}`
  |
note: function defined here
 --&gt; order/order-1.rs:1:4
  |
1 | fn send_order(symbol: &amp;str, buy: bool, quantity: i64, price: f64) {
  |    ^^^^^^^^^^ ------------  ---------  -------------  ----------
help: swap these arguments
  |
7 |     send_order(&#34;GOOG&#34;, false, 100, 1000.00); // Wrong
  |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</pre>
<p>Welp, what do you know? It even tells us the arguments we swapped, and everything. It&#39;s like we live in the future! Ok, but numbers are still easy to confuse, we could also create types like we did in C++ to make it extra explicit, right? Indeed, and let&#39;s throw in protection against negative values by switching from i64 to u64. Is it that easy?</p>
<pre>struct Price(pub f64);
struct Quantity(pub u64);

fn send_order(symbol: &amp;str, buy: bool, quantity: Quantity, price: Price) {
    println!(&#34;{symbol} {buy} {} {}&#34;, quantity.0, price.0);
}

fn main() {
    send_order(&#34;GOOG&#34;, false, Quantity(100), Price(1000.00)); // Correct
    send_order(&#34;GOOG&#34;, false, Quantity(-100), Price(1000.00)); // Wrong
}</pre>
<p>Yes, it is that easy:</p>
<pre>error[E0600]: cannot apply unary operator `-` to type `u64`
  --&gt; order/order-4.rs:10:40
   |
10 |     send_order(&#34;GOOG&#34;, false, Quantity(-100), Price(1000.00)); // Wrong
   |                                        ^^^^ cannot apply unary operator `-`
   |
   = note: unsigned values cannot be negated</pre>
<p>Ok, all that remains is the case where we need to convert the number from a string the user typed. I got you now, Rust… runtime input is not something you can fix at compile time, how would you ever be able to improve on the C++ case?</p>
<pre>struct Price(pub f64);
struct Quantity(pub u64);

fn send_order(symbol: &amp;str, buy: bool, quantity: Quantity, price: Price) {
    println!(&#34;{symbol} {buy} {} {}&#34;, quantity.0, price.0);
}

fn main() {
    send_order(&#34;GOOG&#34;, false, Quantity(100), Price(1000.00)); // Correct
    send_order(
        &#34;GOOG&#34;,
        false,
        Quantity(&#34;-100&#34;.parse::()),
        Price(1000.00),
    ); // Wrong
}</pre>
<p>How about forcing the user to handle potential bad conversions caused by the target type not being able to represent the number we have on the string, does that help?</p>
<pre>error[E0308]: mismatched types
  --&gt; order/order-6.rs:13:18
   |
13 |         Quantity(&#34;-100&#34;.parse::()),
   |         -------- ^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `Result&lt;u64, ParseIntError&gt;`
   |         |
   |         arguments to this struct are incorrect
   |
   = note: expected type `u64`
              found enum `Result&lt;u64, ParseIntError&gt;`
note: tuple struct defined here
  --&gt; order/order-6.rs:2:8
   |
2  | struct Quantity(pub u64);
   |        ^^^^^^^^
help: consider using `Result::expect` to unwrap the `Result&lt;u64, ParseIntError&gt;` value, panicking if the value is a `Result::Err`
   |
13 |         Quantity(&#34;-100&#34;.parse::().expect(&#34;REASON&#34;)),
   |                                       +++++++++++++++++

error: aborting due to 1 previous error</pre>
<p>Yes, it does help, I can’t just blindly cast.</p>
<p>Damn, you’re good.</p>
<p>This error should be enough for me as a user of this API to understand that I should elegantly handle this possibility and maybe return an error all the way to the UI saying &#34;no negative numbers, please&#34;. But what if I just go ahead and add that .expect() it is telling me about and then a user types a negative number? Well, then I get a crash at runtime. Better than going bankrupt? I would say so.</p>
<pre>&gt; ./order-6
GOOG false 100 1000
thread &#39;main&#39; panicked at order/order-6.rs:16:18:
Quantities cannot be negative: ParseIntError { kind: InvalidDigit }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</pre>
<h3>Closing thoughts</h3>
<p>You know what&#39;s the most interesting part of this whole article? The thing Rust is very famous for, memory safety, did not feature at all. Sure, you could make the argument that mixing integers with floats is a memory issue, but you&#39;d be stretching the definition most people have for memory safety.</p>
<p>What we learn in this exercise is that a well designed language can protect you from mistakes in ways that go way beyond stopping you from writing a use after free or a data race. The design can save you a lot of brain cycles by not forcing you to think about how to protect your code from the simplest mistakes — the language has your back.</p>
<p>Now, let&#39;s be honest. Most of the brain power you save will go, as a Rust beginner, to figuring out how to convince the borrow checker what you are doing is correct. It gets better, I promise. But I won&#39;t lie to you: your first few months with the borrow checker will suck.</p>
<p>Are we done here? Not really. There are two more topics that Matt covers in his talk that I will discuss in future articles, one of them related to my biggest pet peeve with C++. And for those of you who are thinking &#34;if C++ had decades to learn it would also have features that are this well designed&#34;, well… let&#39;s just say you are in for a treat.</p>
<p>Again, go check <a href="https://xania.org/MattGodbolt" target="_blank" rel="noopener">Matt Godbolt</a>. Listen to what the man says, read everything he writes, watch every video of his talks on YouTube, and play with his Compiler Explorer. You&#39;ll learn a lot and have fun while doing it!</p>


</div></div>
  </body>
</html>
