<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tucson-josh.com/posts/rust-clap-cli/">Original</a>
    <h1>Rust CLI with Clap</h1>
    
    <div id="readability-page-1" class="page"><div><h3 id="types-define-interfaces">Types Define Interfaces</h3>
<p>Types are important. In fact, I&#39;d guess that the expressive type system in rust
is the single biggest reason why so many developers love the language. Types
allow us to have a contract between parts of the system about our data and how
to interact with it. All programming languages have the concept of types, but
these exist along several dimensions. Strongly typed vs weakly typed as well as
static vs dynamic typing. Rust stakes out its place as a statically,
strongly typed language.</p>
<p>Many languages that are go-to solutions for creating custom command line tools
fall in the opposite quadrant with weak, dynamic typing. Whether looking at
currently popular tooling like python and node.js or more traditional solutions
like awk and perl, they tend to favor a loose approach to types. Perhaps this
is the result of an iterative approach to designing CLI tools that might favor
flexibility. Or it could just be that those languages are already popular,
leading to an abundance of such programs. Regardless of the reasons, I feel that
there is tremendous value for both the developer and user which can arise from
interacting with the command line via the sort of strict contract that rust&#39;s
type system enables.</p>

<div>
    <p>Note</p>
    <p>I assume that if you&#39;re already a rust developer, or at least rust-curious, then
I don&#39;t need to convince you of the general value of strong, static typing.
Rather, this is a call to use this same approach for interacting with a command
line user as you would when developing a library or service API.</p>

  </div>

<h3 id="how-programs-interact-with-the-command-line">How Programs Interact with the Command Line</h3>
<p>At the very lowest level rust exposes command line arguments through the
<code>std::env::args</code> function that returns an <code>Args</code> struct, an <code>Iterator</code> for the
<code>String</code> arguments passed to start the program. This is illustrated in the Rust
Book&#39;s section on
<a href="https://doc.rust-lang.org/book/ch12-01-accepting-command-line-arguments.html">accepting command line arguments</a>:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>use</span><span> </span><span>std</span>::<span>env</span><span>;</span><span>
</span></span></span><span><span> 2</span><span><span>
</span></span></span><span><span> 3</span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span> 4</span><span><span>    </span><span>let</span><span> </span><span>args</span>: <span>Vec</span><span>&lt;</span><span>String</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>env</span>::<span>args</span><span>().</span><span>collect</span><span>();</span><span>
</span></span></span><span><span> 5</span><span><span>
</span></span></span><span><span> 6</span><span><span>    </span><span>let</span><span> </span><span>query</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>args</span><span>[</span><span>1</span><span>];</span><span>
</span></span></span><span><span> 7</span><span><span>    </span><span>let</span><span> </span><span>file_path</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>args</span><span>[</span><span>2</span><span>];</span><span>
</span></span></span><span><span> 8</span><span><span>
</span></span></span><span><span> 9</span><span><span>    </span><span>println!</span><span>(</span><span>&#34;Searching for </span><span>{query}</span><span>&#34;</span><span>);</span><span>
</span></span></span><span><span>10</span><span><span>    </span><span>println!</span><span>(</span><span>&#34;In file </span><span>{file_path}</span><span>&#34;</span><span>);</span><span>
</span></span></span><span><span>11</span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>The naive approach seen above obviously lacks robustness as it relies entirely
on argument positioning and also makes a number of other assumptions about the
results. Perhaps for very simple tools this solution can work but as the number
and types of arguments increases, it seems unlikely that a developer would want
to try and rely on just argument position for the interface to their program.</p>
<p>A more flexible approach would be to examine all of the arguments passed in and
parse these for patterns that would allow customary <code>-x</code> and <code>--x_long</code> style
options. Doing this by hand for every CLI tool would be error-prone and tedious,
but fortunately some awesome folks have already done that for you with the
excellent <a href="https://github.com/clap-rs/clap">clap</a> crate.</p>
<h3 id="the-sound-of-one-hand-clapping">The Sound of One Hand Clapping</h3>
<p>The Command Line Argument Parser for Rust, or clap, is one of the most
widely-used crates in the rust ecosystem. GitHub shows that there are over 445k
repos which depend on clap at the time of writing. Adding clap to your project
will allow you to avoid writing your own parsing logic to interact with the
command line:</p>
<p>Out of the box clap offers a builder pattern approach that can be used to
get arguments from the command line without the hassle of parsing an <code>Iterator</code>
of <code>String</code> values:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>use</span><span> </span><span>clap</span>::<span>{</span><span>Command</span><span>,</span><span> </span><span>arg</span><span>};</span><span>
</span></span></span><span><span> 2</span><span><span>
</span></span></span><span><span> 3</span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span> 4</span><span><span>    </span><span>let</span><span> </span><span>cmd</span><span> </span><span>=</span><span> </span><span>Command</span>::<span>new</span><span>(</span><span>&#34;clap_test&#34;</span><span>)</span><span>
</span></span></span><span><span> 5</span><span><span>        </span><span>.</span><span>arg</span><span>(</span><span>arg!</span><span>([</span><span>main_arg</span><span>]</span><span> </span><span>&#34;The main argument, with no flags&#34;</span><span>))</span><span>
</span></span></span><span><span> 6</span><span><span>        </span><span>.</span><span>arg</span><span>(</span><span>arg!</span><span>(</span><span>-</span><span>x</span><span> </span><span>--</span><span>x_long</span><span> </span><span>&#34;Enable x long mode&#34;</span><span>));</span><span>
</span></span></span><span><span> 7</span><span><span>    </span><span>let</span><span> </span><span>matches</span><span> </span><span>=</span><span> </span><span>cmd</span><span>.</span><span>get_matches</span><span>();</span><span>
</span></span></span><span><span> 8</span><span><span>    </span><span>if</span><span> </span><span>let</span><span> </span><span>Some</span><span>(</span><span>main_arg</span><span>)</span><span> </span><span>=</span><span> </span><span>matches</span><span>.</span><span>get_one</span>::<span>&lt;</span><span>String</span><span>&gt;</span><span>(</span><span>&#34;main_arg&#34;</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span> 9</span><span><span>        </span><span>println!</span><span>(</span><span>&#34;Main argument: </span><span>{main_arg}</span><span>&#34;</span><span>);</span><span>
</span></span></span><span><span>10</span><span><span>    </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span>
</span></span></span><span><span>11</span><span><span>        </span><span>println!</span><span>(</span><span>&#34;No main argument passed in&#34;</span><span>);</span><span>
</span></span></span><span><span>12</span><span><span>    </span><span>}</span><span>
</span></span></span><span><span>13</span><span><span>    </span><span>if</span><span> </span><span>matches</span><span>.</span><span>get_flag</span><span>(</span><span>&#34;x_long&#34;</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span>14</span><span><span>        </span><span>println!</span><span>(</span><span>&#34;x long mode: enabled&#34;</span><span>);</span><span>
</span></span></span><span><span>15</span><span><span>    </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span>
</span></span></span><span><span>16</span><span><span>        </span><span>println!</span><span>(</span><span>&#34;x long mode: not enabled&#34;</span><span>);</span><span>
</span></span></span><span><span>17</span><span><span>    </span><span>}</span><span>
</span></span></span><span><span>18</span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>Your users can now invoke the above <code>clap_test</code> program from the command line
and pass in the main argument and optionally enable your x long mode:</p>
<div><pre tabindex="0"><code data-lang="fish"><span><span>1</span><span>‚ùØ clap_test foo <span>-x</span>
</span></span><span><span>2</span><span><span>Main</span> argument: foo
</span></span><span><span>3</span><span><span>x</span> long mode: enabled
</span></span></code></pre></div><p>Clap offers a lot more than just parsing arguments, though. It can also reject
options and arguments that are not specified by the programmer and it provides
built-in help:</p>
<div><pre tabindex="0"><code data-lang="fish"><span><span>1</span><span>‚ùØ clap_test <span>-h</span>
</span></span><span><span>2</span><span><span>Usage</span>: clap_test <span>[</span>OPTIONS<span>]</span> <span>[</span>main_arg<span>]</span>
</span></span><span><span>3</span><span>
</span></span><span><span>4</span><span><span>Arguments</span>:
</span></span><span><span>5</span><span>  <span>[</span>main_arg<span>]</span>  The main argument, with no flags
</span></span><span><span>6</span><span>
</span></span><span><span>7</span><span><span>Options</span>:
</span></span><span><span>8</span><span>  <span>-x</span>, <span>--x_long</span>  Enable x long mode
</span></span><span><span>9</span><span>  <span>-h</span>, <span>--help</span>    Print <span>help</span>
</span></span></code></pre></div><p>Okay, so I think we can all agree that clap has some nice features and is far
more robust than trying to roll your own command line argument parser, but this
post started off talking about rust&#39;s type system and how that can be used as an
interface with the command line user. And that is where clap&#39;s <code>derive</code> feature
comes in.</p>
<h3 id="defining-your-cli-interactions-with-derive">Defining Your CLI Interactions with <code>derive</code></h3>
<p>Clap offers a much more ergonomic way to specify your program&#39;s arguments than
the builder method shown above, but first you need to include the <code>derive</code>
feature in your dependencies:</p>
<div><pre tabindex="0"><code data-lang="fish"><span><span>1</span><span>‚ùØ cargo add clap <span>-F</span> derive
</span></span></code></pre></div><p>You can now define rust types in your source which will be translated into an
interface contract for your program when called from the command line:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>use</span><span> </span><span>clap</span>::<span>Parser</span><span>;</span><span>
</span></span></span><span><span> 2</span><span><span>
</span></span></span><span><span> 3</span><span><span></span><span>/// Program to illustrate clap usage
</span></span></span><span><span> 4</span><span><span></span><span>#[derive(Parser)]</span><span>
</span></span></span><span><span> 5</span><span><span></span><span>pub</span><span> </span><span>struct</span> <span>Args</span><span> </span><span>{</span><span>
</span></span></span><span><span> 6</span><span><span>    </span><span>/// The main argument, with no flags
</span></span></span><span><span> 7</span><span><span></span><span>    </span><span>pub</span><span> </span><span>main_arg</span>: <span>Option</span><span>&lt;</span><span>String</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span> 8</span><span><span>    </span><span>/// Enable x long mode
</span></span></span><span><span> 9</span><span><span></span><span>    </span><span>#[arg(short, long, default_value_t = false)]</span><span>
</span></span></span><span><span>10</span><span><span>    </span><span>pub</span><span> </span><span>x_long</span>: <span>bool</span><span>,</span><span>
</span></span></span><span><span>11</span><span><span></span><span>}</span><span>
</span></span></span><span><span>12</span><span><span>
</span></span></span><span><span>13</span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span>14</span><span><span>    </span><span>let</span><span> </span><span>args</span><span> </span><span>=</span><span> </span><span>Args</span>::<span>parse</span><span>();</span><span>
</span></span></span><span><span>15</span><span><span>    </span><span>if</span><span> </span><span>let</span><span> </span><span>Some</span><span>(</span><span>main_arg</span><span>)</span><span> </span><span>=</span><span> </span><span>args</span><span>.</span><span>main_arg</span><span> </span><span>{</span><span>
</span></span></span><span><span>16</span><span><span>        </span><span>println!</span><span>(</span><span>&#34;Main argument: </span><span>{main_arg}</span><span>&#34;</span><span>);</span><span>
</span></span></span><span><span>17</span><span><span>    </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span>
</span></span></span><span><span>18</span><span><span>        </span><span>println!</span><span>(</span><span>&#34;No main argument passed in&#34;</span><span>);</span><span>
</span></span></span><span><span>19</span><span><span>    </span><span>}</span><span>
</span></span></span><span><span>20</span><span><span>    </span><span>if</span><span> </span><span>args</span><span>.</span><span>x_long</span><span> </span><span>{</span><span>
</span></span></span><span><span>21</span><span><span>        </span><span>println!</span><span>(</span><span>&#34;x long mode: enabled&#34;</span><span>);</span><span>
</span></span></span><span><span>22</span><span><span>    </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span>
</span></span></span><span><span>23</span><span><span>        </span><span>println!</span><span>(</span><span>&#34;x long mode: not enabled&#34;</span><span>);</span><span>
</span></span></span><span><span>24</span><span><span>    </span><span>}</span><span>
</span></span></span><span><span>25</span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>The above program behaves identically to the builder version from the previous
section, with a <code>-h</code> help option and all the other features that clap offers.
The key difference is that we are now using the type system to define the
interface rather than imperative calls to a builder. Note that the doc
comments for the <code>Args</code> struct are used to build the <code>-h</code> help subcommand for
the resulting application.</p>
<p>Clap isn&#39;t limited to simple structs for the definition of the interface either.
As shown above, <code>Option</code> works just as you would expect. To build up more
complex command line interactions you can use enums to define subcommand syntax
with configuration options for each different subcommand via associated values
(think <code>git</code> or <code>npm</code> subcommands). This offers an elegant solution for managing
the complexity that your tool might need to expose to the user.</p>
<p>There are tons of other great features in clap that can be found in the
<a href="https://docs.rs/clap/latest/clap/index.html">docs</a>, but rather than get into
the specifics of this crate, I want to discuss how type-driven design
can elevate command line interfaces to be on equal footing with published
libraries and service APIs.</p>
<p>What can be gained from specifying your software&#39;s command line interactions via
the rust type system?</p>
<h3 id="advantage-1-code-maintainability-and-readability">Advantage 1: Code Maintainability and Readability</h3>
<p>Perhaps the most obvious benefit of using explicit rust types to define your
command line interface is that it provides a clear, concise definition of what
input the program accepts. If you peel away the clap macro calls which annotate
the type, it looks just like any other data structure that you would expect to
pass between portions of the program. Because clap builds help from the doc
comments, the developer documentation for the type also transcends the command
line boundary to help users understand how to properly use your software. There
are no<a href="https://tucson-josh.com/posts/rust-clap-cli/#good-for-the-environment-too">**</a> hidden inputs that will affect your
program. This helps new developers on a project to understand a codebase and
also assists maintainers down the road when they need to add new features, as
there is a single entry point from which they can start designing their changes.</p>
<p>Alternative approaches such as using the builder pattern or a custom parsing of
<code>std::env::args</code> don&#39;t offer this same clarity. At best, these solutions would
be contained in one or more functions that abstract away the interface logic. At
worst these could be scattered across the codebase as each portion of the
program tries to interact directly with the arguments passed in.</p>
<p>As software grows in complexity the case grows stronger for type-driven CLI
specification. Imagine that we are creating a tool which will interact with a
key-value store and allow the user to add, remove and list the entries of the
store, all of which also require an access token to validate the user. We could
use the following to model the interface:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>pub</span><span> </span><span>struct</span> <span>Args</span><span> </span><span>{</span><span>
</span></span></span><span><span> 2</span><span><span>    </span><span>pub</span><span> </span><span>token</span>: <span>String</span><span>,</span><span>
</span></span></span><span><span> 3</span><span><span>    </span><span>pub</span><span> </span><span>action</span>: <span>Action</span><span>,</span><span>
</span></span></span><span><span> 4</span><span><span></span><span>}</span><span>
</span></span></span><span><span> 5</span><span><span>
</span></span></span><span><span> 6</span><span><span></span><span>pub</span><span> </span><span>enum</span> <span>Action</span><span> </span><span>{</span><span>
</span></span></span><span><span> 7</span><span><span>    </span><span>Add</span><span> </span><span>{</span><span>
</span></span></span><span><span> 8</span><span><span>        </span><span>key</span>: <span>String</span><span>,</span><span>
</span></span></span><span><span> 9</span><span><span>        </span><span>value</span>: <span>String</span><span>,</span><span>
</span></span></span><span><span>10</span><span><span>    </span><span>},</span><span>
</span></span></span><span><span>11</span><span><span>    </span><span>Remove</span><span> </span><span>{</span><span>
</span></span></span><span><span>12</span><span><span>        </span><span>key</span>: <span>String</span><span>,</span><span>
</span></span></span><span><span>13</span><span><span>    </span><span>},</span><span>
</span></span></span><span><span>14</span><span><span>    </span><span>List</span><span>,</span><span>
</span></span></span><span><span>15</span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>The <code>Args</code> type that we&#39;ve outlined above allows us to clearly express that a
token is always required for all actions, but the <code>key</code> argument is only needed,
and indeed only allowed, when the user is either adding or removing entries. The
type that we have created is concise and removes the complexity one would have
to deal with if command line arguments were being handled imperatively.</p>
<h3 id="advantage-2-reduced-test-surface-area-and-mock-support">Advantage 2: Reduced Test Surface Area and Mock Support</h3>
<p>Using a crate like clap can eliminate huge swathes of imperative code that would
otherwise be necessary to parse, validate and consume arguments from the command
line. Every line of code that you don&#39;t write saves time on tests that don&#39;t
need to be created as well. Moving your interaction with the command line from
imperative functions to a declarative description of possible states moves the
testing burden upstream to the maintainers of the clap crate, which is widely
used and well supported.</p>
<p>Type-driven command line interaction does more for us than just reducing the
surface area, though. It also provides a foundation for more complete unit tests
by providing the simplest possible mock for an actual command line interaction.
Imagine that our key-value client above delegates each of the top-level actions
(add, remove, list) to one function each, where more complex operations are
orchestrated. Something like the following:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>pub</span><span> </span><span>enum</span> <span>KVStoreError</span><span> </span><span>{</span><span>
</span></span></span><span><span> 2</span><span><span>    </span><span>InvalidRequest</span><span>,</span><span>
</span></span></span><span><span> 3</span><span><span>    </span><span>NetworkError</span><span>,</span><span>
</span></span></span><span><span> 4</span><span><span></span><span>}</span><span>
</span></span></span><span><span> 5</span><span><span>
</span></span></span><span><span> 6</span><span><span></span><span>fn</span> <span>add_item</span><span>(</span><span>add_req</span>: <span>&amp;</span><span>Args</span><span>)</span><span> </span>-&gt; <span>Result</span><span>&lt;</span><span>String</span><span>,</span><span> </span><span>KVStoreError</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span> 7</span><span><span>    </span><span>let</span><span> </span><span>Action</span>::<span>Add</span><span> </span><span>{</span><span> </span><span>key</span><span>,</span><span> </span><span>value</span><span> </span><span>}</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>add_req</span><span>.</span><span>action</span><span> </span><span>else</span><span> </span><span>{</span><span>
</span></span></span><span><span> 8</span><span><span>        </span><span>return</span><span> </span><span>Err</span><span>(</span><span>KVStoreError</span>::<span>InvalidRequest</span><span>);</span><span>
</span></span></span><span><span> 9</span><span><span>    </span><span>};</span><span>
</span></span></span><span><span>10</span><span><span>    </span><span>// ... complicated things happening ...
</span></span></span><span><span>11</span><span><span></span><span>    </span><span>Ok</span><span>(</span><span>key_returned_from_server</span><span>)</span><span>
</span></span></span><span><span>12</span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>Some obvious tests of the above method might involve asserting that <code>add_item</code>
would return an <code>Err</code> wrapping a <code>KVStoreError::InvalidRequest</code> if we call the
function with <code>Action::List</code>, for instance. We could also verify that the key
returned by the server matches the key we requested to add:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>#[test]</span><span>
</span></span></span><span><span> 2</span><span><span></span><span>fn</span> <span>verify_add_test_key_match</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span> 3</span><span><span>    </span><span>let</span><span> </span><span>add_args</span><span> </span><span>=</span><span> </span><span>Args</span><span> </span><span>{</span><span>
</span></span></span><span><span> 4</span><span><span>        </span><span>token</span>: <span>&#34;ABC_123&#34;</span><span>.</span><span>to_owned</span><span>(),</span><span>
</span></span></span><span><span> 5</span><span><span>        </span><span>action</span>: <span>Action</span>::<span>Add</span><span> </span><span>{</span><span>
</span></span></span><span><span> 6</span><span><span>            </span><span>key</span>: <span>&#34;foo&#34;</span><span>.</span><span>to_owned</span><span>(),</span><span>
</span></span></span><span><span> 7</span><span><span>            </span><span>value</span>: <span>&#34;bar&#34;</span><span>.</span><span>to_owned</span><span>(),</span><span>
</span></span></span><span><span> 8</span><span><span>        </span><span>},</span><span>
</span></span></span><span><span> 9</span><span><span>    </span><span>};</span><span>
</span></span></span><span><span>10</span><span><span>    </span><span>let</span><span> </span><span>Ok</span><span>(</span><span>returned_key</span><span>)</span><span> </span><span>=</span><span> </span><span>add_item</span><span>(</span><span>&amp;</span><span>add_args</span><span>)</span><span> </span><span>else</span><span> </span><span>{</span><span>
</span></span></span><span><span>11</span><span><span>        </span><span>panic!</span><span>(</span><span>&#34;Error adding entry with add_item&#34;</span><span>);</span><span>
</span></span></span><span><span>12</span><span><span>    </span><span>};</span><span>
</span></span></span><span><span>13</span><span><span>    </span><span>assert_eq!</span><span>(</span><span>returned_key</span><span>,</span><span> </span><span>&#34;foo&#34;</span><span>,</span><span> </span><span>&#34;Key mismatch in add_item&#34;</span><span>);</span><span>
</span></span></span><span><span>14</span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>The above test is simplistic, but it is representative of the way data must be
structured from an actual user because of the strict typing. This approach gives
us a high fidelity mock of a command line interaction.</p>
<h3 id="advantage-3-semantic-versioning-not-just-for-libraries">Advantage 3: Semantic Versioning: Not Just for Libraries</h3>
<p>Semantic versioning, or SemVer, is a widely-used framework for determining how
software creators should version their releases so that downstream users of that
code can confidently know what versions are safe to upgrade to from other
versions. It leads to the familiar three-part version number consisting of
<em>Major.Minor.Patch</em> where each component conveys different levels of change and
potential upgrade risk. The rust core team follows SemVer for rust releases and
even have an extensive
<a href="https://doc.rust-lang.org/cargo/reference/semver.html">section</a> about the topic
in the Cargo Book.</p>
<p>Library maintainers generally follow SemVer so that other developers who depend
on their crate can understand when it is safe to upgrade without needing to
delve into the release notes of every single release. Authors of binary tools,
however, have been less likely to strictly follow SemVer, as illustrated by the
<a href="https://blog.rust-lang.org/2025/03/04/Rustup-1.28.1/">rustup 1.28.0</a> adventure,
wherein a minor release ended up breaking CI for many rust projects.</p>
<p>Perhaps the reason why authors of binary CLI tools are less likely to follow
SemVer is because they have an image in their head of the user being a person
who can adapt to changes between versions. The reality, however, is that any
sufficiently useful CLI tool will eventually be integrated into an automated
toolchain that expects input and output to be consistent across versions. Good
CLI tools end up operating very similarly to a library. Unlike libraries,
though, upgrading a binary version doesn&#39;t get a chance to throw compiler
errors. Worse yet, CLI tools are often integrated in parts of the stack where
observability is poor and errors are only discovered when catastrophic failure
has already occurred.</p>
<p>So, how can a strictly-typed approach to command line arguments help us to
better follow SemVer with CLI applications? The answer to this is through
tooling that already exists,
<a href="https://github.com/obi1kenobi/cargo-semver-checks">cargo-semver-checks</a>. This
cargo tool examines your source code and compares it against a prior release
in order to determine if your changes constitute major, minor or merely
patch level changes. Importantly, though, you should begin to think of your
command line program more like a library in order to help cargo-semver-checks
to analyze the importance of changes. Your CLI argument types should be made
<code>pub</code> even if this level isn&#39;t required for your program to run properly.
They are, after all, truly the most public part of the software. A similar
approach is also reasonable with the types that might represent your program&#39;s
output, whether they are used to write back to the shell, to files or some other
form of output. Once you&#39;ve done this, start versioning your binaries
accordingly. If cargo-semver-checks warns you that a change is major and you
only thought that it was a patch, that&#39;s a big warning. Did you really intend to
make a major, breaking change? If you did, then don&#39;t hesitate to change the
major version number.</p>
<p>Merely knowing about a tool like cargo-semver-checks and having it installed
is nice, but we all know that things like this are best when they become an
automated part of our workflow. It&#39;s easy to add a GitHub Action to run a SemVer
check automatically:</p>
<div><pre tabindex="0"><code data-lang="yaml"><span><span>1</span><span>- <span>name</span><span>:</span><span> </span><span>Check semver</span><span>
</span></span></span><span><span>2</span><span><span>  </span><span>uses</span><span>:</span><span> </span><span>obi1kenobi/cargo-semver-checks-action@v2</span><span>
</span></span></span></code></pre></div><p>Now, even if you forget to run your SemVer check manually, you probably won&#39;t
push out a binary release that breaks some dependency in a completely hidden
way.</p>
<h3 id="good-for-the-environment-too">Good for the Environment Too</h3>
<p>There is a loose end that may have been nagging at some readers going over the
previous sections: <em>What about environment variables?</em> After all, many command
line programs can also look at the shell&#39;s environment variables as a source of
input. We see this particularly around secrets or omnipresent settings.
Fortunately clap has us covered here too with the crate feature <code>env</code> that lets
you specify an environment variable which will be queried when a given argument
was not specified as part of the command invocation.</p>
<div><pre tabindex="0"><code data-lang="fish"><span><span>1</span><span>‚ùØ cargo add clap <span>-F</span> env
</span></span></code></pre></div><p>Let&#39;s use this to flesh out the code from our key-value store client example in
the <a href="https://tucson-josh.com/posts/rust-clap-cli/#advantage-1-code-maintainability-and-readability">maintainability</a> section
above. In that example, it would make a lot of sense to make <code>token</code> an argument
which can be stored in an environment variable as well as be overridden from the
command line.</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>use</span><span> </span><span>clap</span>::<span>{</span><span>Parser</span><span>,</span><span> </span><span>Subcommand</span><span>};</span><span>
</span></span></span><span><span> 2</span><span><span>
</span></span></span><span><span> 3</span><span><span></span><span>/// Simple client for a key value store
</span></span></span><span><span> 4</span><span><span></span><span>#[derive(Parser)]</span><span>
</span></span></span><span><span> 5</span><span><span></span><span>pub</span><span> </span><span>struct</span> <span>Args</span><span> </span><span>{</span><span>
</span></span></span><span><span> 6</span><span><span>    </span><span>/// Access token
</span></span></span><span><span> 7</span><span><span></span><span>    </span><span>#[arg(short, long, env = </span><span>&#34;ACCESS_TOKEN&#34;</span><span>)]</span><span>
</span></span></span><span><span> 8</span><span><span>    </span><span>pub</span><span> </span><span>token</span>: <span>String</span><span>,</span><span>
</span></span></span><span><span> 9</span><span><span>    </span><span>/// Action
</span></span></span><span><span>10</span><span><span></span><span>    </span><span>#[command(subcommand)]</span><span>
</span></span></span><span><span>11</span><span><span>    </span><span>pub</span><span> </span><span>action</span>: <span>Action</span><span>,</span><span>
</span></span></span><span><span>12</span><span><span></span><span>}</span><span>
</span></span></span><span><span>13</span><span><span>
</span></span></span><span><span>14</span><span><span></span><span>/// Modes of operation for this key value client
</span></span></span><span><span>15</span><span><span></span><span>#[derive(Subcommand)]</span><span>
</span></span></span><span><span>16</span><span><span></span><span>pub</span><span> </span><span>enum</span> <span>Action</span><span> </span><span>{</span><span>
</span></span></span><span><span>17</span><span><span>    </span><span>/// Add a new entry
</span></span></span><span><span>18</span><span><span></span><span>    </span><span>Add</span><span> </span><span>{</span><span>
</span></span></span><span><span>19</span><span><span>        </span><span>/// Key used for new entry
</span></span></span><span><span>20</span><span><span></span><span>        </span><span>#[arg(short, long)]</span><span>
</span></span></span><span><span>21</span><span><span>        </span><span>key</span>: <span>String</span><span>,</span><span>
</span></span></span><span><span>22</span><span><span>        </span><span>/// Value to be inserted
</span></span></span><span><span>23</span><span><span></span><span>        </span><span>#[arg(short, long)]</span><span>
</span></span></span><span><span>24</span><span><span>        </span><span>value</span>: <span>String</span><span>,</span><span>
</span></span></span><span><span>25</span><span><span>    </span><span>},</span><span>
</span></span></span><span><span>26</span><span><span>    </span><span>/// Remove an entry by key
</span></span></span><span><span>27</span><span><span></span><span>    </span><span>Remove</span><span> </span><span>{</span><span>
</span></span></span><span><span>28</span><span><span>        </span><span>/// Key to find and remove from the store
</span></span></span><span><span>29</span><span><span></span><span>        </span><span>#[arg(short, long)]</span><span>
</span></span></span><span><span>30</span><span><span>        </span><span>key</span>: <span>String</span><span>,</span><span>
</span></span></span><span><span>31</span><span><span>    </span><span>},</span><span>
</span></span></span><span><span>32</span><span><span>    </span><span>/// List the keys present in the store
</span></span></span><span><span>33</span><span><span></span><span>    </span><span>List</span><span>,</span><span>
</span></span></span><span><span>34</span><span><span></span><span>}</span><span>
</span></span></span><span><span>35</span><span><span>
</span></span></span><span><span>36</span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span>37</span><span><span>    </span><span>let</span><span> </span><span>args</span><span> </span><span>=</span><span> </span><span>Args</span>::<span>parse</span><span>();</span><span>
</span></span></span><span><span>38</span><span><span>    </span><span>let</span><span> </span><span>token</span><span> </span><span>=</span><span> </span><span>args</span><span>.</span><span>token</span><span>.</span><span>clone</span><span>();</span><span>
</span></span></span><span><span>39</span><span><span>    </span><span>println!</span><span>(</span><span>&#34;Access token: </span><span>{token}</span><span>&#34;</span><span>);</span><span>
</span></span></span><span><span>40</span><span><span>    </span><span>match</span><span> </span><span>args</span><span>.</span><span>action</span><span> </span><span>{</span><span>
</span></span></span><span><span>41</span><span><span>        </span><span>Action</span>::<span>Add</span><span> </span><span>{</span><span> </span><span>key</span><span>,</span><span> </span><span>value</span><span> </span><span>}</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span>42</span><span><span>            </span><span>println!</span><span>(</span><span>&#34;Add called with (</span><span>{key}</span><span>, </span><span>{value}</span><span>)&#34;</span><span>);</span><span>
</span></span></span><span><span>43</span><span><span>        </span><span>}</span><span>
</span></span></span><span><span>44</span><span><span>        </span><span>Action</span>::<span>Remove</span><span> </span><span>{</span><span> </span><span>key</span><span> </span><span>}</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span>45</span><span><span>            </span><span>println!</span><span>(</span><span>&#34;Remove called for key </span><span>{key}</span><span>&#34;</span><span>);</span><span>
</span></span></span><span><span>46</span><span><span>        </span><span>}</span><span>
</span></span></span><span><span>47</span><span><span>        </span><span>Action</span>::<span>List</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span>48</span><span><span>            </span><span>println!</span><span>(</span><span>&#34;List called&#34;</span><span>);</span><span>
</span></span></span><span><span>49</span><span><span>        </span><span>}</span><span>
</span></span></span><span><span>50</span><span><span>    </span><span>}</span><span>
</span></span></span><span><span>51</span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>All that was required (aside from adding the <code>env</code> feature to our dependencies)
was to add <code>env = &#34;ACCESS_TOKEN&#34;</code> on line 7. The user can now either pass in the
token via <code>-t FOOBAR</code> or by setting the environment variable <code>ACCESS_TOKEN</code>. The
generated help will automatically pick this up and educate the user about this
option (line 13 below):</p>
<div><pre tabindex="0"><code data-lang="fish"><span><span> 1</span><span>‚ùØ clap_test <span>help
</span></span></span><span><span> 2</span><span><span></span><span>Simple</span> client for a key value store
</span></span><span><span> 3</span><span>
</span></span><span><span> 4</span><span><span>Usage</span>: clap_test <span>--token</span> <span>&lt;</span>TOKEN<span>&gt;</span> <span>&lt;</span>COMMAND<span>&gt;</span>
</span></span><span><span> 5</span><span>
</span></span><span><span> 6</span><span><span>Commands</span>:
</span></span><span><span> 7</span><span>  <span>add</span>     Add a new entry
</span></span><span><span> 8</span><span>  <span>remove</span>  Remove an entry by key
</span></span><span><span> 9</span><span>  <span>list</span>    List the keys present in the store
</span></span><span><span>10</span><span>  <span>help    </span>Print this message or <span>the</span> <span>help </span>of the given subcommand<span>(</span><span>s</span><span>)</span>
</span></span><span><span>11</span><span>
</span></span><span><span>12</span><span><span>Options</span>:
</span></span><span><span>13</span><span>  <span>-t</span>, <span>--token</span> <span>&lt;</span>TOKEN<span>&gt;</span>  Access token <span>[</span>env: <span>ACCESS_TOKEN</span><span>=]</span>
</span></span><span><span>14</span><span>  <span>-h</span>, <span>--help</span>           Print <span>help</span>
</span></span></code></pre></div><p>We are now able to have a fully type-driven specification of our command line
interface that seamlessly incorporates both the arguments passed in as well as
environment variables from the shell. What&#39;s not to love?</p>
<hr/>
<p>
    If you want to discuss  this post
     or any other, please feel free to drop me a message on
    <a href="https://www.instagram.com/tucson.josh/">Instagram</a>
    or over at
    <a href="https://bsky.app/profile/tucson-josh.com">Bluesky</a>.
</p>

    </div></div>
  </body>
</html>
