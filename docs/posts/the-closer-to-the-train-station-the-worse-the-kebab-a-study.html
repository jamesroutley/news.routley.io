<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.jmspae.se/write-ups/kebabs-train-stations/">Original</a>
    <h1>‚ÄúThe closer to the train station, the worse the kebab‚Äù ‚Äì a ‚Äústudy‚Äù</h1>
    
    <div id="readability-page-1" class="page"><section>
			<div>
				

<p><strong>2025-02-14</strong></p>

    <ul>
    
        <li>
            <a href="https://jmspae.se/write-ups/kebabs-train-stations/#introduction">Introduction</a>
            
        </li>
    
        <li>
            <a href="https://jmspae.se/write-ups/kebabs-train-stations/#method">Method</a>
            
                <ul>
                    
                        <li>
                            <a href="https://jmspae.se/write-ups/kebabs-train-stations/#network-data">Network Data</a>
                        </li>
                    
                        <li>
                            <a href="https://jmspae.se/write-ups/kebabs-train-stations/#restaurant-data">Restaurant Data</a>
                        </li>
                    
                        <li>
                            <a href="https://jmspae.se/write-ups/kebabs-train-stations/#routing-and-distance">Routing and Distance</a>
                        </li>
                    
                </ul>
            
        </li>
    
        <li>
            <a href="https://jmspae.se/write-ups/kebabs-train-stations/#results">Results</a>
            
        </li>
    
        <li>
            <a href="https://jmspae.se/write-ups/kebabs-train-stations/#discussion">Discussion</a>
            
        </li>
    
    </ul>

<p><em>This write-up was originally posted <a href="https://www.reddit.com/r/gis/comments/1iph0yy/the_closer_to_the_railway_station_the_less_tasty/">on reddit</a>, though I&#39;ve cleaned things up specifically for this post. Due to reasons discussed towards the end of this post, I&#39;m not entirely happy with the results and intend to take another shot at it in the near future.</em></p>

<p>I came across <a href="https://www.reddit.com/r/gis/comments/1iopp56/anyone_motivated_to_prove_that_the_closer_from/">this post</a> sharing a hypothesis from a French subreddit;</p>
<blockquote>
<p>The closer to the train station, the worse the kebab.</p>
</blockquote>
<p>The original French post gained a decent amount of traction compared to the subreddit&#39;s relatively small size, indicating a certain amount of agreement among its members. There were some detractors in the comments, however, sharing experiences which ran contrary to the stated hypothesis.</p>
<p>Thus, I figured I had nothing better to do, being a burned-out, unemployed drop-out with a newly-obtained autism diagnosis, so I figured I&#39;d sacrifice my time for a worthy cause and perform this informal <em>&#34;study&#34;</em>. I&#39;ll be expecting my Nobel peace prize in the postbox and several job offers in my DMs within the next 3 working days.</p>

<p>I assumed the best study area to be Paris, France since;</p>
<ol>
<li>The original post was French</li>
</ol>
<p>I haven&#39;t personally heard of this hypothesis in my home country (Sweden, also home to many a kebab-serving restaurant) so I figured I&#39;d assume this to be a French phenomenon for the purpose of this informal &#34;Study&#34;.</p>
<ol start="2">
<li>Density</li>
</ol>
<p>The inner city is <em><strong>dense</strong></em> with dozens of train/metro stations and god knows how many kebab shops. I knew early on that this would make my life pretty miserable, but at least it&#39;d provide plenty of sample data.</p>
<h2 id="network-data">Network Data<a href="#network-data" aria-label="Anchor link for: network-data">üîó</a></h2>
<p>I used OSMnx to download and save a navigation network. Given the public transit-centric nature of the French subreddit, I though it&#39;d make sense to stick to walking distance (eg. footpaths, side-walks) thus i set the OSMnx <code>network_type</code> to <code>&#34;walk&#34;</code>. Given the location (and that OSMnx used this CRS automatically when none was provided), all data was projected to EPSG:32631 (UTM zone 31N).</p>
<pre data-lang="py"><code data-lang="py"><span>import </span><span>osmnx </span><span>as </span><span>ox
</span><span>from </span><span>geopandas </span><span>import </span><span>GeoDataFrame
</span><span>
</span><span>#EPSG
</span><span>PROJECTION </span><span>= </span><span>32631
</span><span>
</span><span>graph </span><span>= </span><span>ox.</span><span>graph_from_place</span><span>(</span><span>&#39;Paris, FR&#39;</span><span>, </span><span>network_type</span><span>=</span><span>&#34;walk&#34;</span><span>)
</span><span>graph </span><span>= </span><span>ox.</span><span>project_graph</span><span>(graph, </span><span>to_crs</span><span>=</span><span>PROJECTION</span><span>)
</span><span>
</span><span>ox.</span><span>save_graphml</span><span>(graph, </span><span>filepath</span><span>=</span><span>&#34;network.graphml&#34;</span><span>)
</span></code></pre>
<p>
<a href="https://jmspae.se/write-ups/kebabs-train-stations/fig-1.webp" target="_blank"><img src="https://jmspae.se/processed_images/fig-1.c53f23b9b1fd351c.jpg"/></a>

<em>Figure 1: The study area and network</em></p>
<p>Next up is the various train/metro stations. Given the nature of the original French sub, I figured it&#39;d make sense to include both the long-distance central stations along with the countless metro stations. This was also rather trivial with OSMnx, filtering by <code>railway=subway_entrance</code> or <code>railway=train_station_entrance.</code></p>
<pre data-lang="py"><code data-lang="py"><span>stations: GeoDataFrame </span><span>= </span><span>ox.</span><span>features_from_place</span><span>(</span><span>&#39;Paris, FR&#39;</span><span>, </span><span>tags </span><span>= </span><span>{
</span><span>    </span><span>&#34;railway&#34;</span><span>: [</span><span>&#34;subway_entrance&#34;</span><span>, </span><span>&#34;train_station_entrance&#34;</span><span>]
</span><span>})
</span><span>
</span><span># Filter results to points
</span><span>station_nodes: GeoDataFrame </span><span>= </span><span>stations.loc[stations.geom_type</span><span>==</span><span>&#34;Point&#34;</span><span>]
</span><span>station_nodes </span><span>= </span><span>station_nodes.</span><span>to_crs</span><span>(</span><span>epsg</span><span>=</span><span>PROJECTION</span><span>)
</span><span>
</span><span>station_nodes.</span><span>to_file</span><span>(</span><span>&#34;train_station_entrances.gpkg&#34;</span><span>)
</span></code></pre>
<p>I saved outputs religiously so I could easily inspect them in QGIS. I did attempt to get python notebooks working with my NeoVIM setup, but it was all for naught.</p>
<p>
<a href="https://jmspae.se/write-ups/kebabs-train-stations/fig-2.webp" target="_blank"><img src="https://jmspae.se/processed_images/fig-2.51f0e47dcd63c0a8.jpg"/></a>

<em>Figure 2: Rail/metro entrances... Please ignore the airport iconography.</em></p>
<p>... And there we have the first half of the data, now for the restaurants.</p>
<h2 id="restaurant-data">Restaurant Data<a href="#restaurant-data" aria-label="Anchor link for: restaurant-data">üîó</a></h2>
<p>The Google Places API (and their respective reviews) seemed like a reasonable choice. Google reviews are naturally far from perfect and subject to their fair share of botting and the like, but it&#39;s the best I could think of at the time. There are alternatives such as Yelp, but their API is horrifically expensive for poor old me, and I was not in the mood to build a web scraper (it has the same soul-sucking effect on me as prompting an LLM). The $200 of free credit was also enticing.</p>
<p>However, as I started exploring the API... I realised that the Places API doesn&#39;t seem to have any way to search within a polygon, only within a point radius. Thank you, Mr. publicly owned mega-corporation. How Fun.</p>
<p>It also didn&#39;t help that autocomplete for the <code>googlemaps</code> library wasn&#39;t working. Python&#39;s a fine language, but its tooling does like to test my patience a little too often. And whilst I&#39;m still complaining... The Google Cloud dashboard is likely the slowest &#34;website&#34; I&#39;ve ever had the displeasure of interacting with.</p>
<p>So... This meant I&#39;d have to perform some sort of grid search of the whole of Paris, crossing my fingers that I wouldn&#39;t bust my free usage. This, along with a couple interesting questions;</p>
<ol>
<li>What is... <em>A kebab?</em></li>
</ol>
<p>When I search for &#34;kebab&#34; (no further context necessary)... How does Google decide what restaurant serves kebab?</p>
<p>After some perusing, it didn&#39;t seem to be as deep as I thought. Plenty of restaurants simply had &#34;kebab&#34; in the name, some were designated as &#34;Mediterranean&#34; (Kebab has its origins in Turkey, Persia, middle east in general) and others had a fair few reviews simply mentioning &#34;kebab.&#34; Good enough for me.</p>
<ol start="2">
<li>Trouble in query-land</li>
</ol>
<p>It turns out that when you query for places within a given radius, it&#39;s only a &#34;bias.&#34; It&#39;s not a hard cut-off that&#39;ll help narrow-down our data harvesting and reduce unnecessary requests. It was becoming increasingly clear that google isn&#39;t really a fan of people doing this.</p>
<p>Now with all of that preamble out of the way, I needed to prepare my search.</p>
<p>
<a href="https://jmspae.se/write-ups/kebabs-train-stations/fig-3.webp" target="_blank"><img src="https://jmspae.se/processed_images/fig-3.605c84ffddad8323.jpg"/></a>

<em>Figure 3. Original admin boundaries</em></p>
<p>Paris&#39; administrative boundary contains a couple of large green spaces. To the west, a park and to the east, some sort of sports institute.</p>
<p>After perusing these rather large spaces in Google maps, they seemed to contain a distinct lack of kebab-serving establishments. Thus, they were a burden on our API budget and needed to go.</p>
<p>
<a href="https://jmspae.se/write-ups/kebabs-train-stations/fig-4.webp" target="_blank"><img src="https://jmspae.se/processed_images/fig-4.b360881962350eea.jpg"/></a>

<em>Figure 4. Adjusted admin boundaries w/ network</em></p>
<p>I figured keeping the network and stations wouldn&#39;t do any harm, so they went unmodified.</p>
<p>
<a href="https://jmspae.se/write-ups/kebabs-train-stations/fig-5.webp" target="_blank"><img src="https://jmspae.se/processed_images/fig-5.eedb86cb4c85e12c.jpg"/></a>

<em>Figure 5. Sampling points, later projected to WGS84 for harvesting purposes</em></p>
<p>To maximise data-harvesting, I decided to go with a hex layout with a vertical spacing of 1 km. This should give us a search radius of 500m * ‚àö3 ~= 866 meters. Plenty of overlap, sure, but we shouldn&#39;t be getting any holes anywhere. I&#39;m not sure why I was spending this much time ensuring &#34;data integrity&#34; when that might just have flown the window courtesy of Google, but it&#39;s the illusion of control that counts.</p>
<p>This give us 99 sample points which... Should be enough?</p>
<p>Regardless, here&#39;s how my 3AM python turned out:</p>
<pre data-lang="py"><code data-lang="py"><span># Already projected to WGS84
</span><span>sample_points: GeoDataFrame </span><span>= </span><span>GeoDataFrame.</span><span>from_file</span><span>(</span><span>&#34;samples.gpkg&#34;</span><span>)
</span><span>gmaps: googlemaps.Client </span><span>= </span><span>googlemaps.</span><span>Client</span><span>(</span><span>key</span><span>=</span><span>&#39;get-your-own&#39;</span><span>)
</span><span>
</span><span>output </span><span>= </span><span>{}
</span><span>
</span><span>for </span><span>point </span><span>in </span><span>sample_points.geometry:
</span><span>    lat, lon </span><span>= </span><span>point.y, point.x
</span><span>
</span><span>    next_page_token </span><span>= </span><span>None
</span><span>    num_fetches </span><span>= </span><span>3
</span><span>
</span><span>    </span><span>while </span><span>num_fetches </span><span>&gt; </span><span>0</span><span>:
</span><span>        result </span><span>= </span><span>{}
</span><span>
</span><span>        </span><span>if </span><span>next_page_token </span><span>== </span><span>None</span><span>:
</span><span>            result </span><span>= </span><span>gmaps.</span><span>places</span><span>(
</span><span>                </span><span>&#34;kebab&#34;</span><span>,
</span><span>                </span><span>location</span><span>=</span><span>(lat, lon),
</span><span>                </span><span>radius</span><span>=</span><span>866</span><span>,
</span><span>            )
</span><span>        </span><span>else</span><span>:
</span><span>            result </span><span>= </span><span>gmaps.</span><span>places</span><span>(
</span><span>                </span><span>page_token</span><span>=</span><span>next_page_token
</span><span>            )
</span><span>
</span><span>        next_page_token </span><span>= </span><span>result.</span><span>get</span><span>(</span><span>&#34;next_page_token&#34;</span><span>)
</span><span>        </span><span>print</span><span>(result[</span><span>&#34;status&#34;</span><span>], next_page_token)
</span><span>
</span><span>        </span><span>for </span><span>p </span><span>in </span><span>result[</span><span>&#34;results&#34;</span><span>]:
</span><span>            output[p[</span><span>&#34;place_id&#34;</span><span>]] </span><span>= </span><span>p
</span><span>
</span><span>        </span><span>if </span><span>next_page_token </span><span>== </span><span>None</span><span>:
</span><span>            </span><span>break
</span><span>
</span><span>        num_fetches </span><span>-= </span><span>1
</span><span>
</span><span>        </span><span>sleep</span><span>(</span><span>2</span><span>)
</span><span>
</span><span>json_out </span><span>= </span><span>json.</span><span>dumps</span><span>(output)
</span><span>
</span><span>with </span><span>open</span><span>(</span><span>&#34;output.json&#34;</span><span>, </span><span>&#34;w&#34;</span><span>) </span><span>as </span><span>file:
</span><span>    file.</span><span>write</span><span>(json_out)
</span></code></pre>
<p>This worked quite well. Initially I skipped paging, resulting in 322 results. However, I noticed that a few establishments were missing in the results compared to my explorations in Google Maps.</p>
<p>After implementing paging and re-running, this gave us a grand total of 400 kebab-serving establishments. I was likely over-zealous with the paging considering how few additional results were retrieved. That, and that the API doesn&#39;t cap the search radius (again, it&#39;s only a bias) likely led to a fair few redundant API calls.</p>
<p>The raw Google Places API-output also needed to be clipped to the study area, projected to the local UTM zone as well as converted to a geospatial format;</p>
<pre data-lang="py"><code data-lang="py"><span>import </span><span>pandas </span><span>as </span><span>pd
</span><span>
</span><span>with </span><span>open</span><span>(</span><span>&#34;output.json&#34;</span><span>, </span><span>&#34;r&#34;</span><span>) </span><span>as </span><span>file:
</span><span>    data </span><span>= </span><span>json.</span><span>load</span><span>(file)
</span><span>    file.</span><span>close</span><span>()
</span><span>    
</span><span>    </span><span>for </span><span>id </span><span>in </span><span>data:
</span><span>        place </span><span>= </span><span>data[</span><span>id</span><span>]
</span><span>        point </span><span>= </span><span>place[</span><span>&#34;geometry&#34;</span><span>][</span><span>&#34;location&#34;</span><span>]
</span><span>        data[</span><span>id</span><span>][</span><span>&#34;lng&#34;</span><span>] </span><span>= </span><span>point[</span><span>&#34;lng&#34;</span><span>]
</span><span>        data[</span><span>id</span><span>][</span><span>&#34;lat&#34;</span><span>] </span><span>= </span><span>point[</span><span>&#34;lat&#34;</span><span>]
</span><span>        </span><span>del </span><span>data[</span><span>id</span><span>][</span><span>&#34;geometry&#34;</span><span>]
</span><span>
</span><span>    data </span><span>= </span><span>pd.DataFrame.</span><span>from_dict</span><span>(data).T
</span><span>    data.rating </span><span>= </span><span>pd.</span><span>to_numeric</span><span>(data.rating)
</span><span>    data.user_ratings_total </span><span>= </span><span>pd.</span><span>to_numeric</span><span>(data.user_ratings_total)
</span><span>    data </span><span>= </span><span>data[data[</span><span>&#34;user_ratings_total&#34;</span><span>] </span><span>&gt; </span><span>0</span><span>]
</span><span>
</span><span>    </span><span># Cleanup was added after the screenshot below was taken
</span><span>    data </span><span>= </span><span>data.</span><span>drop</span><span>(</span><span>columns</span><span>=</span><span>[
</span><span>        </span><span>&#34;icon&#34;</span><span>,
</span><span>        </span><span>&#34;icon_background_color&#34;</span><span>,
</span><span>        </span><span>&#34;icon_mask_base_uri&#34;</span><span>,
</span><span>        </span><span>&#34;plus_code&#34;</span><span>,
</span><span>        </span><span>&#34;reference&#34;</span><span>,
</span><span>        </span><span>&#34;photos&#34;</span><span>,
</span><span>        </span><span>&#34;opening_hours&#34;
</span><span>    ])
</span><span>
</span><span>    gdata </span><span>= </span><span>GeoDataFrame</span><span>(
</span><span>        data, </span><span>geometry</span><span>=</span><span>geopandas.</span><span>points_from_xy</span><span>(data.lng, data.lat),
</span><span>        </span><span>crs</span><span>=</span><span>4326
</span><span>    )
</span><span>
</span><span>    gdata: GeoDataFrame </span><span>= </span><span>gdata.</span><span>to_crs</span><span>(</span><span>PROJECTION</span><span>)
</span><span>
</span><span>    </span><span># Modified boundaries from Figure 4.
</span><span>    paris </span><span>= </span><span>GeoDataFrame.</span><span>from_file</span><span>(</span><span>&#34;mod_bounary.gpkg&#34;</span><span>);
</span><span>
</span><span>    gdata: GeoDataFrame </span><span>= </span><span>gdata.</span><span>clip</span><span>(paris)
</span><span>
</span><span>    gdata.</span><span>to_file</span><span>(</span><span>&#34;establishments.gpkg&#34;</span><span>)
</span></code></pre>
<p>
<a href="https://jmspae.se/write-ups/kebabs-train-stations/fig-6.webp" target="_blank"><img src="https://jmspae.se/processed_images/fig-6.1eab106a30493ee2.jpg"/></a>

<em>Figure 6. We&#39;re in f###ing business</em></p>
<h2 id="routing-and-distance">Routing and Distance<a href="#routing-and-distance" aria-label="Anchor link for: routing-and-distance">üîó</a></h2>
<p>Finally, the fun part. I need to get the distance to the nearest station entrance for each establishment.</p>
<p>I could&#39;ve absolutely just routed to every single entrance for every single restaurant to get the nearest... But that would&#39;ve taken several decades. I needed to build some sort of spatial index and route to the nearest ~3 or something along those lines. Since Paris is so dense with plenty of routing options, I figured I wouldn&#39;t need to perform too many routing operations.</p>
<p>After some googling and dredging through API docs, however, it seemed GeoPandas was nice enough to do that for us with <code>sindex</code>. Although it didn&#39;t have the same &#34;return nearest N&#34; like my beloved r-tree rust library I was all too used to, it did allow me to search within a certain radius (1 km was large enough) and go from there. The query results weren&#39;t sorted, so I had to sort the indexes by distance and cut it down to size.</p>
<p>The network analysis was relatively straight-forward thanks to NetworkX, and after a couple of hours I managed to cobble together the following;</p>
<pre data-lang="py"><code data-lang="py"><span>import </span><span>networkx </span><span>as </span><span>nx
</span><span>import </span><span>shapely </span><span>as </span><span>shp
</span><span>
</span><span>establishments: GeoDataFrame </span><span>= </span><span>GeoDataFrame.</span><span>from_file</span><span>(</span><span>&#34;establishments.gpkg&#34;</span><span>)
</span><span>entrances: GeoDataFrame </span><span>= </span><span>GeoDataFrame.</span><span>from_file</span><span>(</span><span>&#34;entrances.gpkg&#34;</span><span>)
</span><span>graph </span><span>= </span><span>ox.</span><span>load_graphml</span><span>(</span><span>&#34;network.graphml&#34;</span><span>)
</span><span>graph </span><span>= </span><span>ox.</span><span>project_graph</span><span>(graph, </span><span>to_crs </span><span>= </span><span>PROJECTION</span><span>)
</span><span>
</span><span># Ensure the same CRS
</span><span>if </span><span>(establishments.crs </span><span>!= </span><span>entrances.crs </span><span>!= </span><span>PROJECTION</span><span>):
</span><span>    </span><span>exit</span><span>(</span><span>100</span><span>)
</span><span>
</span><span># Helper function to get the distance between a graph node and establishment geometry
</span><span>def </span><span>node_geom_dist</span><span>(</span><span>node_id</span><span>: int, </span><span>geom</span><span>: shp.Point):
</span><span>    node </span><span>= </span><span>graph.nodes[node_id]
</span><span>    </span><span>return </span><span>math.</span><span>sqrt</span><span>((geom.x </span><span>- </span><span>node[</span><span>&#39;x&#39;</span><span>]) </span><span>** </span><span>2 </span><span>+ </span><span>(geom.y </span><span>- </span><span>node[</span><span>&#39;y&#39;</span><span>]) </span><span>** </span><span>2</span><span>)
</span><span>
</span><span>distances: list[float] </span><span>= </span><span>[]
</span><span>
</span><span>for </span><span>(</span><span>id</span><span>, establishment) </span><span>in </span><span>establishments.</span><span>iterrows</span><span>():
</span><span>    establishment_geom: shp.Point </span><span>= </span><span>establishment.geometry
</span><span>    establishment_node: int </span><span>= </span><span>ox.</span><span>nearest_nodes</span><span>(graph, establishment_geom.x, establishment_geom.y)
</span><span>    establishment_dist_to_node: float </span><span>= </span><span>node_geom_dist</span><span>(establishment_node, establishment_geom)
</span><span>    
</span><span>    </span><span># Spatial index for rail entrances
</span><span>    index: shp.STRtree </span><span>= </span><span>entrances.sindex
</span><span>    nearest_q </span><span>= </span><span>index.</span><span>query</span><span>(establishment_geom, </span><span>predicate</span><span>=</span><span>&#34;dwithin&#34;</span><span>, </span><span>distance </span><span>= </span><span>1000</span><span>)
</span><span>    nearest_entrances: list[tuple[int, float]] </span><span>= </span><span>[]
</span><span>
</span><span>    </span><span>for </span><span>i </span><span>in </span><span>nearest_q:
</span><span>        ent </span><span>= </span><span>entrances.iloc[i]
</span><span>        ent_geom: shp.Point </span><span>= </span><span>ent.geometry
</span><span>
</span><span>        dist </span><span>= </span><span>ent_geom.</span><span>distance</span><span>(establishment.geometry)
</span><span>        
</span><span>        nearest_entrances.</span><span>append</span><span>((i, dist))
</span><span>     
</span><span>    nearest_entrances </span><span>= </span><span>sorted</span><span>(nearest_entrances, </span><span>key </span><span>= lambda </span><span>e</span><span>: e[</span><span>1</span><span>])[:</span><span>3</span><span>]
</span><span>    entrance_geom: list[shp.Point] </span><span>= </span><span>[entrances.iloc[i].geometry </span><span>for </span><span>(i, </span><span>_</span><span>) </span><span>in </span><span>nearest_entrances]
</span><span>    entrance_nodes: list[int] </span><span>= </span><span>[ox.</span><span>nearest_nodes</span><span>(graph, point.x, point.y) </span><span>for </span><span>point </span><span>in </span><span>entrance_geom]
</span><span>    entrance_geom_dist_to_node: list[float] </span><span>= </span><span>[</span><span>node_geom_dist</span><span>(entrance_nodes[i], entrance_geom[i]) </span><span>for </span><span>i </span><span>in </span><span>range</span><span>(</span><span>len</span><span>(nearest_entrances))]
</span><span>
</span><span>    result_paths </span><span>= </span><span>[nx.</span><span>shortest_path</span><span>(graph, establishment_node, dest_node, </span><span>weight</span><span>=</span><span>&#34;length&#34;</span><span>) </span><span>for </span><span>dest_node </span><span>in </span><span>entrance_nodes]
</span><span>    result_lengths: list[float] </span><span>= </span><span>[nx.</span><span>path_weight</span><span>(graph, path, </span><span>&#34;length&#34;</span><span>) </span><span>+ </span><span>entrance_geom_dist_to_node[i] </span><span>+ </span><span>establishment_dist_to_node </span><span>for </span><span>(i, path) </span><span>in </span><span>enumerate</span><span>(result_paths)]
</span><span>
</span><span>    distances.</span><span>append</span><span>(</span><span>min</span><span>(result_lengths))
</span><span>
</span><span>establishments[</span><span>&#34;distance&#34;</span><span>] </span><span>= </span><span>distances 
</span><span>establishments.</span><span>to_file</span><span>(</span><span>&#34;establishment_results.gpkg&#34;</span><span>)
</span></code></pre>
<p>Not exactly my finest work. The sheer amount of list comprehension is perhaps a little terrifying, but it works.</p>
<p>After some prodding around in QGIS with the resulting data and networks (and many print() statements), I was confident in the accuracy of the results.</p>

<p>Now with all of this data, it is time to settle the question of whether or not the kebabs are less tasty the closer they are to a train/metro station...</p>
<p>
<a href="https://jmspae.se/write-ups/kebabs-train-stations/fig-7.webp" target="_blank"><img src="https://jmspae.se/processed_images/fig-7.1ff7f2b316a90f62.jpg"/></a>

<em>Figure 7. Hmmmmm....</em></p>
<p>With a mighty Pearson&#39;s correlation of 0.091, the data indicates that this could be true! If you ignore the fact that the correlation is so weak that calling it &#39;statistically insignificant&#39; would be quite generous.</p>
<p>Outliers can have an outsized impact on a Pearson&#39;s correlation, so after ridding the dataset of some outliers via IQR fencing...</p>
<p>
<a href="https://jmspae.se/write-ups/kebabs-train-stations/fig-8.webp" target="_blank"><img src="https://jmspae.se/processed_images/fig-8.af2b5c5cacb7b32d.jpg"/></a>

<em>Figure 8. Removed outliers</em></p>
<p>... This increased the coefficient to a whopping 0.098.</p>
<p>This was a bit of a bummer (though hardly surprising) and figuring I had nothing to lose from messing around a little, I tried filtering out metro stations in case my original assumption of the metro being included in the original hypothesis was incorrect.</p>
<p>
<a href="https://jmspae.se/write-ups/kebabs-train-stations/fig-9.webp" target="_blank"><img src="https://jmspae.se/processed_images/fig-9.3427bdea5242e0b1.jpg"/></a>

*Figure 9. Not much better, eh? Correction: &#34;... Nearest train station entrance.&#34;</p>
<p>With an even worse coefficient of 0.001, I think It&#39;s time to hang up the towel.</p>
<p>Whilst there are some minor indications that the hypothesis <em>could</em> be correct (eg. Many of the absolute worst restaurants being some of the closest) the correlation is simply too weak.</p>

<p><em><strong>- Are Google reviews an objective measurement of how tasty the kebabs are?</strong></em></p>
<p>Absolutely the f### not. This was a rather subjective observation from the very beginning and Google reviews aren&#39;t exactly a good measure of &#34;is the food good?&#34; There are many aspects of the dining experience that could hypothetically impact a review score. The staff, cleanliness, the surrounding environment, etc. Not to mention online skulduggery and review manipulation.</p>
<p><em><strong>- Can tourism have an impact?</strong></em></p>
<p>It absolutely could. I don&#39;t want to make any definitive assumptions, but I can absolutely imagine the local regulars being harsher than the massive tourist population, or even vice-versa.</p>
<p><em><strong>- Were the Google results accurate?</strong></em></p>
<p>To an extent, yes. From what I could gather, every location from the query seemed to serve kebab in some form. There were a few weird outliers and nuances, such as Pizza Hut which likely only serves kebab pizza rather than the multitude of different forms in which kebab could possibly be consumed.</p>
<p><em><strong>- Why not restaurants in general?</strong></em></p>
<p>Because the initial hypothesis was too comically hyper-specific for me to give up on.</p>
<p><em><strong>- What about review count?</strong></em></p>
<p>This could very well have an effect, though I was not entirely certain how to properly implement this metric into the analysis at the time.</p>
<p><em><strong>- Gib Data</strong></em></p>
<p>I&#39;m not quite comfortable in doing so, mostly due to potential breaches of Google&#39;s TOS. I don&#39;t think they would care about me harvesting some 400 POIs for this little experiment, I&#39;m not quite willing to gamble sharing the data with others.</p>
<p>Besides, I gave you the code. Go burn some of your own credits.</p>
<p><em><strong>- Are you Ok?</strong></em></p>
<p>... I guess? Are you?</p>
<p>In conclusion, this was actually quite fun. I wrote this as the project went on (otherwise I would likely never have found the motivation) and I would encourage others to do other silly explorations like this, even if the results end up slightly depressing.</p>
<p>... <em>However</em>, after some additional discussion, I decided I wasn&#39;t quite done.</p>
<p>As stated earlier, there were a few detracting comments on the original French post. Interestingly, many of the provided examples of good kebab restaurants next to train stations just so happened to be in Paris.</p>
<p>The user who originally posted the French post for the sub in English provided some <a href="https://imgur.com/gallery/kebab-railway-stations-wuYG9D2">examples</a> which seem to strengthen the hypothesis. It could very well be that whatever conditions affect Paris restaurants (whether it be higher rent, wages, tourism, population density...) had a larger impact than I initially suspected.</p>
<p><em><strong>Stay tuned for part 2... Whenever I get around to doing it!</strong></em></p>


			</div>
		</section></div>
  </body>
</html>
