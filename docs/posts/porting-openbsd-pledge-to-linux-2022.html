<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://justine.lol/pledge/">Original</a>
    <h1>Porting OpenBSD Pledge() to Linux (2022)</h1>
    
    <div id="readability-page-1" class="page">

<p>
July 13<sup>th</sup>, 2022 @ <a href="https://justine.lol/index.html">justine&#39;s web page</a>
</p>

<a href="https://justine.lol/pledge/openbsd.png"><img width="330" height="290" alt="[OpenBSD Blowfish Logo]" src="https://worker.jart.workers.dev/pledge/openbsd.png"/></a>

<p>
OpenBSD is an operating system that&#39;s famous for its focus on security.
Unfortunately, OpenBSD leader Theo states that there
are <a href="https://everything2.com/title/BSD+is+dying">only 7000
users</a> of OpenBSD. So it&#39;s a very small but elite group, that wields
a disproportionate influence; since we hear all the time about the
awesome security features these guys get to use, even though we usually
can&#39;t use them ourselves.

</p><p>
Pledge is like the forbidden fruit we all covet when the boss says we
must use things like Linux. Why does it matter? It&#39;s because pledge()
actually makes security comprehensible. Linux has never really had a
security layer that mere mortals can understand. For example, let&#39;s say
you want to do something on Linux like control whether or not some
program you downloaded from the web is allowed to have telemetry. You&#39;d
need to write stuff like this:

</p><pre><span>static const struct</span> <span>sock_filter</span> <span>kFilter</span>[] = {
    <span>/* L0*/</span> BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, syscall, 0, 14 - 1),
    <span>/* L1*/</span> BPF_STMT(BPF_LD | BPF_W | BPF_ABS, OFF(args[0])),
    <span>/* L2*/</span> BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 2, 4 - 3, 0),
    <span>/* L3*/</span> BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 10, 0, 13 - 4),
    <span>/* L4*/</span> BPF_STMT(BPF_LD | BPF_W | BPF_ABS, OFF(args[1])),
    <span>/* L5*/</span> BPF_STMT(BPF_ALU | BPF_AND | BPF_K, ~0x80800),
    <span>/* L6*/</span> BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 1, 8 - 7, 0),
    <span>/* L7*/</span> BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 2, 0, 13 - 8),
    <span>/* L8*/</span> BPF_STMT(BPF_LD | BPF_W | BPF_ABS, OFF(args[2])),
    <span>/* L9*/</span> BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 0, 12 - 10, 0),
    <span>/*L10*/</span> BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 6, 12 - 11, 0),
    <span>/*L11*/</span> BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 17, 0, 13 - 11),
    <span>/*L12*/</span> BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),
    <span>/*L13*/</span> BPF_STMT(BPF_LD | BPF_W | BPF_ABS, OFF(nr)),
    <span>/*L14*/ /* next filter */</span>
};
</pre>

<p>
Oh my gosh. It&#39;s like we traded one form of security privilege for
another. OpenBSD limits security to a small pond, but makes it easy.
Linux is a big tent, but makes it impossibly hard. SECCOMP BPF might as
well be the Traditional Chinese of programming languages, since only a
small number of people who&#39;ve devoted the oodles of time it takes to
understand code like what you see above have actually been able to
benefit from it. But if you&#39;ve got OpenBSD privilege, then doing the
same thing becomes easy:

</p><pre>pledge(<span>&#34;stdio rpath&#34;</span>, 0);
</pre>

<p>
That&#39;s really all OpenBSD users have to do to prevent things like leaks
of confidential information. So how do we get it that simple on Linux? I
believe the answer is to find someone with enough free time to figure
out how to use SECCOMP BPF to implement pledge. The latest volunteer is
me, so look upon my code ye mighty and despair.

</p><ul>
  <li><a href="https://github.com/jart/cosmopolitan/blob/pledge-1.8/libc/calls/pledge.c">cosmopolitan/libc/calls/pledge.c</a></li><li><a href="https://github.com/jart/cosmopolitan/blob/pledge-1.8/libc/calls/pledge-linux.c">cosmopolitan/libc/calls/pledge-linux.c</a></li><li><a href="https://github.com/jart/cosmopolitan/blob/pledge-1.8/tool/build/pledge.c">cosmopolitan/tool/build/pledge.c</a></li><li><a href="https://github.com/jart/cosmopolitan/blob/pledge-1.8/test/libc/calls/pledge_test.c">cosmopolitan/test/libc/calls/pledge_test.c</a></li></ul>

<p>
There&#39;s been a few devs in the past who&#39;ve tried this. I&#39;m not going to
name names, because most of these projects were never completed. When it
comes to SECCOMP, the online tutorials only explain how to whitelist the
system calls themselves, so most people lose interest before figuring
out how to filter arguments. The projects that got further along also
had oversights like allowing the changing of setuid/setgid/sticky bits.
So none of the current alternatives should be used. I believe this
effort gets us much closer to having pledge() than ever before.

</p><h2 class="page" id="download">
  <a href="#download">
    Command Line Utility
    Â 
    <img src="https://worker.jart.workers.dev/redbean/linux.png" title="Linux" alt="[Linux]" width="28" height="32"/>
  </a>
</h2>

<p>
I originally wrote my pledge() polyfill for
the <a href="https://redbean.dev/">redbean</a> web server as a
sandboxing solution. However it turns out pledge() is robust enough as
an abstraction that I thought it&#39;d be useful to create a small command
line utility which launches processes under pledge(), so that anyone can
use it, without having to configure it in C code.

<!-- JUSTINE JUSTINE DON'T FORGET TO UPDATE https://justine.lol/pledge/latest.txt -->

</p><p>
  <a href="https://justine.lol/pledge/pledge-1.8.com">pledge-1.8.com</a></p><p>
That binary will work on all Linux distros since RHEL6. Root privileges
are not required. You just use it to wrap your command invocations. It&#39;s
so tiny and lightweight that it only adds a few microseconds of startup
latency to your program. It&#39;s great for shell scripts and automated
tools. For example, if you want to run the list directory command, and
only permit that command to do basic stdio (<code>-p stdio</code>) and
filesystem path (<code>-p rpath</code>) reading in the current directory
(<code>-v .</code>), then you&#39;d say:

</p><pre>$ wget https://justine.lol/pledge/pledge.com
$ chmod +x pledge.com
$ ./pledge.com -v. -p <span>&#39;stdio rpath&#39;</span> ls
<em>file listing output...</em>
</pre>

<p>
You can now be certain your ls command isn&#39;t doing things like spying on
you, or uploading your bitcoin wallet to the cloud. However let&#39;s say
authorizing network access is what you want. One command that has a real
legitimate need for that is curl. However, since it needs needs DNS,
it&#39;s a little trickier because DNS is the Hunger Games of systems
engineering, and not all Libc implementations agree on how it should be
implemented. Here&#39;s some strategies depending on your tools and distro:

</p><pre><span># standard curl on alpine linux 3.16 (musl)</span>
./pledge.com -p <span>&#39;stdio rpath dns inet&#39;</span> \
  curl -s http://justine.lol/hello.txt

<span># standard curl on ubuntu 22.04 (glibc)</span>
./pledge.com -p <span>&#39;stdio rpath inet dns tty sendfd recvfd&#39;</span> \
  curl -s http://justine.lol/hello.txt
hello world

<span># cosmopolitan&#39;s curl as static binary</span>
<span># see git clone and make instructions below</span>
./assimilate.com ./curl.com
./pledge.com -p <span>&#39;stdio rpath dns inet&#39;</span> \
  ./curl.com https://justine.lol/hello.txt

<span># cosmopolitan&#39;s curl as ape binary</span>
<span># non-assimilated cosmopolitan ape binary</span>
./pledge.com -p <span>&#39;stdio rpath prot_exec dns inet&#39;</span> \
  ./curl.com https://justine.lol/hello.txt
</pre>

<p>
The choice of C library usually impacts which permissions are needed.
Musl and Cosmopolitan need the least permission since they were built
with sandboxing in mind. Glibc on the other hand does some strange stuff
with DNS, which requires us to weaken the sandbox with recvmsg() and
sendmsg() which also enable SCM_RIGHTS unfortunately.

</p><p>
Both Musl and Glibc use dynamic binaries. In order to be able to launch
them, pledge.com temporarily implies both <code>exec</code> and
<code>prot_exec</code>. We then inject an
<code>LD_PRELOAD</code> library which runs inside the process at
initialization. That library calls pledge() again automatically, and
drops the both <code>exec</code> and <code>prot_exec</code> privileges
if needed. This dynamic library also lets us print helpful messages to
stderr to explain which promises are needed when a violation occurs.

</p><p>
Let&#39;s say you have a public ssh server and you want to let people read
and take notes of your book collection, but you don&#39;t want anyone
rewriting your books. In that case, you can repupose something like the
nano command as a strictly read-only editor. Since nano has a TUI
interface, you&#39;d need to grant it TTY privileges.

</p><pre>./pledge.com -v $<span>HOME</span>/books -np <span>&#39;stdio rpath tty&#39;</span> nano ~/books/bofh.txt
</pre>

<p>
Here&#39;s how you&#39;d sandbox Vim to only be able to change the current
directory, tested on Alpine and Ubuntu.

</p><pre>./pledge.com \
  -v rwc:. \
  -v /etc/vim \
  -v $HOME/.vimrc \
  -v /usr{,/local}/share/vim \
  -p &#39;stdio rpath wpath cpath tty prot_exec&#39; \
  vim
</pre>

<p>
Here&#39;s how you&#39;d sandbox Emacs to only be able to change the current
directory, tested on Alpine and Ubuntu.

</p><pre>./pledge.com \
  -v rwc:. \
  -v $HOME/.emacs \
  -v rwc:$HOME/.emacs.d \
  -v /etc/emacs \
  -v /etc/passwd \
  -v /usr/share/X11/locale \
  -v /usr{,/local}/{libexec,share}/emacs \
  -p &#39;stdio rpath wpath cpath tty proc tmppath prot_exec&#39; \
  emacs -nw
</pre>

<h3 class="page">
  Troubleshooting
</h3>

<p>
If your program crashes, then you can figure out why by tracing the
binary and seeing which system call is EPERM&#39;ing or which veiled path is
EACCES&#39;ing. For example, let&#39;s see what happens if we reduce the
privileges to just stdio.

</p><pre>$ strace -ff ./pledge.com -p stdio ls
open(<span>&#34;/etc/ld-musl-x86_64.path&#34;</span>, O_RDONLY|O_CLOEXEC) = -1 EPERM (Operation not permitted)
</pre>

<p>
Well that didn&#39;t take long. Now that you know what&#39;s wrong, you would
then consult the <a href="#promises">Promises</a> section to see which
promise you need. For example, you&#39;d know <code>open(O_RDONLY)</code> is
provided by <code>rpath</code> and that in order to <code>fork()</code>
you need <code>-p proc</code>.

</p><h3 class="page">
  Resource Limits
</h3>

<p>
In addition to polyfilling pledge, your pledge command is also able to
apply some other very important safety hacks that aren&#39;t obvious to the
uninitiated. For example, we&#39;ve all run a program before that hammers
the system. Linux is very generous in how much memory programs can
allocate. An accidental loop in just one program, by default on Linux,
will absolutely take the whole machine out of commission for a few
minutes before the &#34;OOM Killer&#34; kicks in. In other cases, like a fork()
bomb, the default Linux environment provides no such protection, so it&#39;s
essentially equivalent to a blue screen of death.

</p><p>
Your pledge command imposes some perfectly reasonable resource quotas on
programs by default, to prevent that from happening. By default, unless
you tune the flags, a program is allowed to use only the amount of
memory you have. If you&#39;ve permitted it to fork off new processes, then
it won&#39;t be able to spawn more of them at the same time than twice your
number of CPUs. This way if your sandboxed program gets out of control,
it&#39;ll most likely crash itself before it can crash your whole computer.

</p><p>
We also have a niceness feature. Have you ever had a program use so much
disk i/o that everything crawls to a halt? You run some program, and
then suddenly every small file takes seconds to load in Emacs? Your
pledge command can fix that. If you&#39;re got a compute heavy long running
program, then pass the <code>-n</code> flag for a <code>nice</code>
that&#39;s actually nice. The naive nice command doesn&#39;t really do much,
since it doesn&#39;t change the scheduler and it doesn&#39;t change the i/o
priority. This command actually does. Using the <code>-n</code> flag
will guarantee the sandbox program will stay out of the way, since the
kernel will only let it use spare capacity.

</p><h3 class="page">
  Pledge Command Flags
</h3>

<dl>
<dt>-n
</dt><dd>Apply maximum niceness to program. This means
  <ol>
    <li>nice is set to 19,
    </li><li>i/o priority is set to idle, and
    </li><li>scheduler is set to idle.
  </li></ol>
</dd><dt>-p PROMISES
  </dt><dd>Defaults to <code>-p &#39;stdio rpath&#39;</code>. It&#39;s repeatable. May
  contain any of following separated by spaces:</dd><dt>-v [PERM:]PATH
</dt><dd>
  Unveils path. By default, your sandbox restricts access to all file
  system paths (except for metadata [e.g. file size] which is always
  visible). Using this flag will allow a new path to be used, and it may
  be a directory too in which case all paths beneath that folder are
  allowed. <code>PERM</code> defaults to <code>r</code> and may have any
  of the following:
    <ul>
      <li><code>r</code> makes <code>PATH</code> available for read-only
        path operations, corresponding to the pledge promise &#34;rpath&#34;.
      </li><li><code>w</code> makes <code>PATH</code> available for write
        operations, corresponding to the pledge promise &#34;wpath&#34;.
      </li><li><code>x</code> makes <code>PATH</code> available for execute
        operations, corresponding to the pledge promises &#34;exec&#34; and
        &#34;execnative&#34;.
      </li><li><code>c</code> allows <code>PATH</code> to be created and
        removed, corresponding to the pledge promise &#34;cpath&#34;.
    </li></ul>
  <p>
    Some paths are implicitly defined by pledge.com depending on which
    promises you&#39;ve used. See the
    <a href="#paths">Implicitly Unveiled Paths</a> section for further
    details. Unveiling is implemented using
    <a href="https://landlock.io/">Landlock</a> which requires Linux
    Kernel 5.13+. On older kernels, all filesystem paths will be allowed
    (unless you use the chroot flag).
</p></dd><dt>-N
</dt><dd>Don&#39;t normalize file descriptors. by default, pledge.com guarantees
    (1) the stdio file descriptors exist, and (2) file descriptors that
    the parent process or shell forgot to close will be closed. We do
    this using close_range() which needs Linux 5.9+. On older kernels,
    we use poll() to quickly make sure the first 256 file descriptors
    are safe, but the number may be lower depending on system limits.
</dd><dt>-V
</dt><dd>Disable unveiling (i.e. only pledge)
</dd><dt>-T pledge
</dt><dd>If SECCOMP BPF isn&#39;t available, then pledge.com will launch your
command anyway without it. If you need a guarantee that restrictions are
imposed, then you can run <code>pledge.com -T pledge</code> to test for
the availability of this feature. Please note this only impacts very old
Linux systems like RHEL5 since SECCOMP was introduced around 2010.
</dd><dt>-T unveil
</dt><dd>If Landlock LSM isn&#39;t available (introduced in 2021) then pledge.com
will launch your command anyway without it. If you need a guarantee that
filesystem restrictions are imposed, then you can run <code>pledge.com
-T unveil</code> to test for the availability of this feature.
</dd><dt>-T unveil
</dt><dd>exits 0 if unveil() is supported by host system
</dd><dt>-g GID
</dt><dd>Call setgid() before executing program (not allowed if setuid binary)
</dd><dt>-u UID
</dt><dd>Call setuid() before executing program (not allowed if setuid binary)
</dd><dt>-c PATH
</dt><dd>Call chroot() before executing program (needs root privileges)
</dd><dt>-C SECS
</dt><dd>Set CPU time limit in seconds. By default, this is not changed from
what was inherited (which in practice means unlimited). A negative value
means unlimited. If the requested limit is greater than the limit
already being imposed by a parent process, then the limit will be
silently scaled down. If this limit is violated, then a
<code>SIGXCPU</code> signal is sent to your program, after which it has
precisely one second to gratefully shutdown before <code>SIGKILL</code>
is used.
</dd><dt>-M BYTES
</dt><dd>Set virtual memory limit. The default is the total amount of
physical RAM on the host machine. This is specified in bytes and may use
Si notation. A negative value means unlimited. If the requested limit is
greater than the limit already being imposed by a parent process, then
the limit will be silently scaled down. When this limit is violated,
mmap() will start returning <code>ENOMEM</code> which will trickle down
into functions like malloc() failing.
</dd><dt>-P PROCS
</dt><dd>Sets process and thread limit. This applies user-wide. The default
is the preexisting process count added to the cpu count. A negative
value means unlimited. If the requested limit is greater than the limit
already being imposed by a parent process, then the limit will be
silently scaled down. If this limit is violated, functions like fork()
will start returning <code>EAGAIN</code>.
</dd><dt>-F BYTES
</dt><dd>Sets resource limit on individual file sizes. The default is 256mb.
This is specified in bytes and may use Si notation. A negative value
means unlimited. If the requested limit is greater than the limit
already being imposed by a parent process, then the limit will be
silently scaled down. If this limit is violated, then a
<code>SIGXFSZ</code> signal is sent to your program. If the limit is
150% exceeded then <code>SIGKILL</code> is used.
</dd><dt>-O COUNT
</dt><dd>Sets file descriptor limit. If this limit is violated, functions
like open() will start returning <code>EMFILE</code>.
</dd></dl>

<h2 class="page" id="paths">
  <a href="#paths">
    Implicitly Unveiled Paths
  </a>
</h2>

<p>
The pledge.com program will automatically unveil the following paths for
your convenience when certain conditions are met. In most cases, we use
the categories you&#39;ve pledged as a hint as to what needs unveiling.
Please note that this automatic unveiling does not apply to the Linux C
API interface for pledge(), where unveil() must be called explicitly.
However OpenBSD will unveil some key paths for things like stdio. The
files we&#39;ve chosen below are a superset of what OpenBSD does, intended
to conform to the same principles adapted for Linux.

</p><dl>

<dt><code>pledge(&#34;stdio&#34;)</code>
</dt><dd>
<code>-v /dev/fd</code></dd><dt><code>pledge(&#34;rpath&#34;)</code>
</dt><dd>
<code>-v /proc/filesystems</code>

</dd><dt><code>pledge(&#34;inet&#34;)</code>
</dt><dd>
<code>-v /etc/ssl/certs/ca-certificates.crt</code>

</dd><dt><code>pledge(&#34;dns&#34;)</code>
</dt><dd>
<code>-v /etc/hosts</code></dd><dt><code>pledge(&#34;tty&#34;)</code>
</dt><dd>
<code>-v rw:$PTY</code></dd><dt><code>pledge(&#34;prot_exec&#34;)</code>
</dt><dd>
<code>-v rx:/usr/bin/ape</code>

</dd><dt><code>pledge(&#34;vminfo&#34;)</code>
</dt><dd>
<code>-v /proc/stat</code></dd><dt><code>pledge(&#34;tmppath&#34;)</code>
</dt><dd>
<code>-v rwc:/tmp</code></dd><dt>for dynamic executables only
</dt><dd>
<code>-v rx:/lib</code></dd></dl>

<h2 class="page" id="assimilate">
  <a href="#assimilate">
    Securing APE Binaries
  </a>
</h2>

<p>
Actually Portable Executables should be written to call pledge()
internally. But if you want to secure an APE binary that doesn&#39;t, using
the pledge.com command, then you need to convert (or &#34;assimilate&#34;) it
into the ELF format beforehand. You can usually do this by saying:

</p><pre>$ file redbean.com
redbean.com: DOS/MBR boot sector
$ ./redbean.com --assimilate
$ file redbean.com
redbean.com: ELF 64-bit LSB executable
</pre>

<p>
Please note that won&#39;t work if you&#39;re using the binfmt_misc with the new
<a href="https://justine.lol/apeloader/">APE Loader</a> then you can&#39;t
run the APE shell script to assimilate your binary. We instead provide a
new assimilate.com program which can be used to convert APE programs to
ELF or Mach-O.

</p><p>
  <a href="https://justine.lol/pledge/assimilate.com">assimilate.com</a></p><h2 class="page" id="c">
  <a href="#c">
    C API
  </a>
</h2>

<p>
Pledge works best when developing software using
<a href="https://github.com/jart/cosmopolitan">Cosmpolitan Libc</a>. You
can get started relatively easily writing pledge() programs using the
cosmopolitan monorepo. The zero config solution is to just plop this
program file into the examples folder. Start by cloning the repo:

</p><pre>$ git clone https://github.com/jart/cosmopolitan
$ cd cosmopolitan
$ nano examples/mypledge.c
</pre>

<p>
You can then copy and paste this code:

</p><pre><span>#include</span> <span>&#34;libc/calls/calls.h&#34;</span>
<span>#include</span> <span>&#34;libc/stdio/stdio.h&#34;</span>

<span>int</span> main() {
  pledge(<span>&#34;stdio&#34;</span>, 0);
  printf(<span>&#34;hello world\n&#34;</span>);
}
</pre>

<p>
You can then build and run your program as follows:

</p><pre>$ make -j8 o//examples/mypledge.com
$ o//examples/mypledge.com
hello world
</pre>

<p>
One of the things you may have noticed about the pledge.com command, is
its most restrictive mode (<code>pledge.com -p &#34;&#34; cmd...</code>) can&#39;t
actually be used. Your program will just crash. That&#39;s because it&#39;s
intended for the C API. What it means is that your process or thread
won&#39;t be able to call any system call except exit. Such a program might
sound impossible, but you can actually communicate between processes
using shared memory. For example, here&#39;s how you&#39;d do it with threads.

</p><pre><span>int</span> enclave(<span>void</span> *arg, <span>int</span> tid) {
  if (pledge(&#34;&#34;, 0)) <span>return</span> 1;
  <span>int</span> *job = arg;            <span>// get job</span>
  job[0] = job[0] + job[1];  <span>// do work</span>
  <span>return</span> 0;                  <span>// exit</span>
}
<span>int</span> main() {
  <span>struct</span> <span>spawn</span> worker;
  <span>int</span> job[2] = {2, 2};            <span>// create workload</span>
  _spawn(enclave, job, &amp;worker);  <span>// create worker</span>
  _join(&amp;worker);                 <span>// wait for exit</span>
  assert(job[0] == 4);            <span>// check result</span>
}
</pre>

<p>
The above example shows an enclaved worker doing some kind of
computational task, possibly executing untrusted code, and then storing
the result to some memory location that the parent thread can see when
the worker has finished executing. It works great and is fast.

</p><p>
One of the disadvantages of the above example, is that the enclaved
worker has unfettered access to your stack memory and might make a mess
of things. That&#39;s potentially creepy and not very enclaved. One way to
fix that is to use fork() instead of threads. In that case, you can
explicitly whitelist which memory is shared.

</p><pre><span>int</span> ws;
<span>// create small shared memory region</span>
<span>int</span> *job = mmap(0, FRAMESIZE, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
job[0] = 2;  <span>// create workload</span>
job[1] = 2;
<span>if</span> (!fork()) {  <span>// create enclaved worker</span>
  <span>if</span> (pledge(&#34;&#34;, 0)) _Exit(1);
  job[0] = job[0] + job[1];  <span>// do work</span>
  _Exit(0);
}
wait(&amp;ws);  <span>// wait for worker</span>
assert(WIFEXITED(ws));
assert(WEXITSTATUS(ws) == 0);
assert(job[0] == 4);  <span>// check result</span>
munmap(job, FRAMESIZE);
</pre>

<p>
Most of our the Cosmopolitan Libc unit tests have been set up to use
pledge() these days. Not necessarily because we&#39;re concerned about them
being compromised, but because the pledge function has outstanding
documentation value in helping people understand our tests, since it
readily communicates what system functionality they need. For example,
our tests for the access() filesystem function says:

</p><pre><span>__attribute__</span>((<span>__constructor__</span>)) <span>static</span> <span>void</span> init(<span>void</span>) {
  pledge(<span>&#34;stdio rpath wpath cpath fattr&#34;</span>, 0);
  errno = 0;
}
</pre>

<h3 class="page" id="msyscall">
  <a href="#msyscall">
    System Call Origin Verification
  </a>
</h3>

<p>
When you write your own Actually Portable Executables, you also get some
added security benefits compared to pledge.com. For example, another
famous OpenBSD system call is msyscall() which causes the kernel to
validate the RIP register of anything that issues a system call. In
Cosmopolitan, calling pledge() will polyfill that feature too
automatically, to only allow functions which are annotated with
the <code>privileged</code> keyword to use <code>SYSCALL</code>. What
that means is if someone manages to compromise your server to inject
executable code into your program&#39;s memory, then that code effectively
will have <code>pledge(&#34;&#34;, 0)</code> privileges, even if when your app
called pledge(), it specified something much broader. The redbean web
server&#39;s <a href="https://redbean.dev/#unix.pledge">unix.pledge</a>()
function is also able to take advantage of this.

</p><h2 class="page" id="caveats">
  <a href="#caveats">
    Caveats
  </a>
</h2>

<p>
File system access is a blind spot <strong>[update 2022-07-22: we now
have unveil() thanks to the Landlock system calls introduced a one year
ago]</strong>. OpenBSD solves this with another famous system call
called unveil(), which lets users control file system paths too. Right
now there&#39;s no clear way to implement that for Linux. However our
pledge() polyfill does do a reasonable job in restricting which file
system operations are possible. But once you permit the file system ops,
the ops are allowed to happen on pretty much any file the user has
access to.

</p><p>
I personally don&#39;t view this as a problem. What I love about pledge.com
is it tells me if the programs I run that I downloaded from random
strangers on the Internet, are actually the good little command line
citizens that they claim to be. For example, if I download a tool for
computing some math, or compressing a file, then it really shouldn&#39;t
need any access except <code>-p &#34;stdio rpath&#34;</code> especially if I&#39;m
able to use pipes. So I can use pledge.com to make sure the command
keeps its promise and lets me know if there&#39;s any surprising behaviors.
So this is great security if you&#39;re dealing with command line programs
that are written in a conscientious manner. If it&#39;s only able to read
files and can&#39;t talk to the Internet, then seriously, what could it
possibly do? It&#39;s such a simple pareto-optimized niche that I can&#39;t
believe no one&#39;s made it easily addressable until now.

</p><p>
However, there&#39;s always going to be that one program you want that&#39;s
power hungry, possibly due to bloated frameworks and dependencies. In
that case, we may want access to <em>some</em> (but not all) of the file
system. pledge.com is able to address the need somewhat using chroot().
It&#39;s worth noting though that chroot() has weaknesses that kernel devs
have refused to fix for decades. Most of the docs on this subject are
unprofessional and crazy. For example, the chroot(2) man page is
probably the only category 2 man page I&#39;ve ever seen that uses shell
script code to describe its functionality. As far as I can tell, the
only convincing weakness with chroot() is that the jail is only locked
from the inside. If you take away the freedom of a process by putting it
in a chroot jail, then another process that&#39;s free can use its freedom
to bust its friend out of jail. For example, here&#39;s how root can leave a
backdoor that lets the process escape:

</p><pre>mkdir(<span>&#34;/tmp/mydir&#34;</span>, 0755);
<span>// privileged user opens a backdoor</span>
<span>int</span> dirfd = open(<span>&#34;/tmp&#34;</span>, O_RDONLY | O_DIRECTORY);
<span>// process enters chroot jail</span>
chdir(<span>&#34;/tmp/mydir&#34;</span>);
chroot(<span>&#34;/tmp/mydir&#34;</span>);
<span>// process escapes jail</span>
fchdir(dirfd);
chdir(<span>&#34;..&#34;</span>);
<span>// list root directory</span>
<span>struct</span> <span>dirent</span> *e;
<span>DIR</span> *d = opendir(&#34;.&#34;);
<span>while</span> ((e = readdir(d))) {
  printf(&#34;%s\n&#34;, e-&gt;d_name);
}
closedir(d);
</pre>

<p>
The Linux devs could fix that if they wanted to. However I personally
don&#39;t see why it&#39;s a total dealbreaker, pledge.com helps avoid it by
closing rogue file descriptors at startup using poll(). What even more
surprising is that this weakness is also exploitable on OpenBSD, since
they too seem to have given up on securing the traditional chroot()
call. But at least OpenBSD provides an alternative that&#39;s easy to use,
called unveil(). It&#39;d be great to see that leadership from the Linux
kernel, but instead we just see blog posts from companies like RedHat
saying that having chroot() will make us more insecure than having no
security at all. It&#39;s like banning locks because lockpick kits exist.
RedHat must be experts at mental gymnastics to publish such communiquÃ©s.
It&#39;s also comical that Linux addresses the problem by restricting
chroot() to the root user account, since clearly something which is so
&#34;insecure&#34; will become more secure if you only do it from the most
privileged user. What an unfortunate state of affairs, since many of us
have needed to look elsewhere for answers, and the only folks offering
those right now is bloatware like Docker that locks-in your filesystem
with a bunch of cryptically named tar files. And they say that Docker
isn&#39;t a security layer too! Even though it&#39;s based things like cgroups
which are even more elite and difficult to understand than SECCOMP BPF.
We can only guess why the kernel devs do it. Maybe they&#39;re afraid of
issue workload burnout and figure people won&#39;t complain about security
if no one understands it! That&#39;s something we&#39;re working to change.

</p><p>
It should also be noted that there&#39;s some features OpenBSD bakes into
pledge() that we&#39;re not able to polyfill with Linux SECCOMP BPF. One of
the things OpenBSD does is it can check file system paths, in order to
loosen up restrictions around things like accessing the time zone
database. This isn&#39;t a problem if you&#39;re a Cosmopolitan Libc user.
Because APE binaries don&#39;t read tzdata from the filesystem and instead
embed time zone data inside the ZIP structure of the binary. However it
could potentially be problematic if you&#39;re using pledge.com to launch
binaries that are provided by your distro. Ask your friendly distro
maintainers to improve their security solutions. If they can&#39;t, then you
can always switch to Cosmopolitan Libc.

</p><p>
Another caveat is that, so far, I&#39;ve only implemented the things
described in the OpenBSD pledge(2) manual page. We still need to
reconcile this properly with the primary materials which would be the
OpenBSD pledge() kernel source code. We also need more community
feedback to make sure there aren&#39;t things we haven&#39;t considered. For
example, Linux has a lot of sneaky capabilities in a shifting landscape
that aren&#39;t always widely understood, which can potentially bite the
authors of security tools, even when they&#39;ve done due diligence.

</p><p>
I&#39;ve also only really tested this on console applications. If you want a
pledge() that&#39;s likely to work with GUIs, then, knowing the way the
Linux desktop goes, you really should consider
<a href="https://awesomekling.github.io/pledge-and-unveil-in-SerenityOS/">SerenityOS</a>
since Andreas added pledge() support a couple years ago.

</p><h2 class="page" id="docs">
  <a href="#docs">
    Pledge Documentation
  </a>
</h2>

<p>
Pledging causes most system calls to become unavailable. Your system
call policy is enforced by the kernel, which means it can propagate
across execve() if permitted. This system call is supported on OpenBSD
and Linux where it&#39;s polyfilled using SECCOMP BPF. The way it works on
Linux is verboten system calls will raise <code>EPERM</code> whereas
OpenBSD just kills the process while logging a helpful message to
/var/log/messages explaining which promise category you needed.

</p><p>
By default exit() is allowed. This is useful for processes that perform
pure computation and interface with the parent via shared memory. On
Linux we mean sys_exit (_Exit1), not sys_exit_group (_Exit). The
difference is effectively meaningless, since _Exit() will attempt both.
All it means is that, if you&#39;re using threads, then a <code>pledge(&#34;&#34;,
0)</code> thread can&#39;t kill all your threads unless
you <code>pledge(&#34;stdio&#34;)</code>.

</p><p>
Once pledge is in effect, the chmod functions (if allowed) will not
permit the sticky/setuid/setgid bits to change. Linux
will <code>EPERM</code> here and OpenBSD should ignore those three bits
rather than crashing.

</p><p>
User and group IDs can&#39;t be changed once pledge is in effect. OpenBSD
should ignore chown without crashing; whereas Linux will
just <code>EPERM</code>.

</p><p>
Memory functions won&#39;t permit creating executable code after pledge.
Restrictions on origin of <code>SYSCALL</code> instructions will become
enforced on Linux (cf. msyscall()) after pledge too, which means the
process gets killed if <code>SYSCALL</code> is used outside the
.privileged section. One exception is if the &#34;exec&#34; group is specified,
in which case these restrictions need to be loosened.

</p><p>
Using pledge is irreversible. On Linux it
causes <code>PR_SET_NO_NEW_PRIVS</code> to be set on your process;
however, if &#34;id&#34; or &#34;recvfd&#34; are allowed then then they theoretically
could permit the gaining of some new privileges. You may call pledge()
multiple times if &#34;stdio&#34; is allowed. In that case, the process can only
move towards a more restrictive state.

</p><p>
pledge() can&#39;t filter file system paths or internet addresses. For
example, if you enable a category like &#34;inet&#34; then your process will
be able to talk to any internet address. The same applies to
categories like &#34;wpath&#34; and &#34;cpath&#34;; if enabled, any path the
effective user id is permitted to change will be changeable.

</p><p>
The Linux pledge() polyfill isn&#39;t able to support the OpenBSD
<code>execpromises</code> parameter.

</p><h3 class="page" id="promises">
  <a href="#promises">
    Promises
  </a>
</h3>

<p>
  Your promises is a string that may include any of the following groups
  delimited by spaces.

</p><dl>
<dt>stdio
</dt><dd>allows exit_group, close, dup, dup2, dup3, fchdir, fstat, fsync,
fdatasync, ftruncate, getdents, getegid, getrandom, geteuid, getgid,
getgroups, getitimer, getpgid, getpgrp, getpid, getppid, getresgid,
getresuid, getrlimit, getsid, wait4, gettimeofday, getuid, lseek,
madvise, brk, arch_prctl, uname, set_tid_address, clock_getres,
clock_gettime, clock_nanosleep, mmap (PROT_EXEC and weird flags aren&#39;t
allowed), mprotect (PROT_EXEC isn&#39;t allowed), msync, munmap, nanosleep,
pipe, pipe2, read, readv, pread, recv, poll, recvfrom, preadv, write,
writev, pwrite, pwritev, select, send, sendto (only if addr is null),
setitimer, shutdown, sigaction (but SIGSYS is forbidden), sigaltstack,
sigprocmask, sigreturn, sigsuspend, umask, socketpair, ioctl(FIONREAD),
ioctl(FIONBIO), ioctl(FIOCLEX), ioctl(FIONCLEX), fcntl(F_GETFD),
fcntl(F_SETFD), fcntl(F_GETFL), fcntl(F_SETFL).

</dd><dt>rpath
</dt><dd>(read-only path ops) allows chdir, getcwd, open(O_RDONLY),
openat(O_RDONLY), stat, fstat, lstat, fstatat, access, faccessat,
readlink, readlinkat, statfs, fstatfs.

</dd><dt>wpath
</dt><dd>(write path ops) allows getcwd, open(O_WRONLY),
openat(O_WRONLY), stat, fstat, lstat, fstatat, access, faccessat,
readlink, readlinkat, chmod, fchmod, fchmodat.

</dd><dt>cpath
</dt><dd>(create path ops) allows open(O_CREAT), openat(O_CREAT),
rename, renameat, renameat2, link, linkat, symlink, symlinkat,
unlink, rmdir, unlinkat, mkdir, mkdirat.

</dd><dt>dpath
</dt><dd>(create special path ops) allows mknod, mknodat, mkfifo.

</dd><dt>chown
</dt><dd>(file ownership changes) allows chown, fchown, lchown, fchownat.

</dd><dt>flock
</dt><dd>allows flock, fcntl(F_GETLK), fcntl(F_SETLK),
fcntl(F_SETLKW).

</dd><dt>tty
</dt><dd>allows ioctl(TIOCGWINSZ), ioctl(TCGETS), ioctl(TCSETS),
ioctl(TCSETSW), ioctl(TCSETSF).

</dd><dt>recvfd
</dt><dd>allows recvmsg(SCM_RIGHTS).

</dd><dt>fattr
</dt><dd>allows chmod, fchmod, fchmodat, utime, utimes, futimens,
utimensat.

</dd><dt>inet
</dt><dd>allows socket(AF_INET), listen, bind, connect, accept,
accept4, getpeername, getsockname, setsockopt, getsockopt, sendto.

</dd><dt>unix
</dt><dd>allows socket(AF_UNIX), listen, bind, connect, accept,
accept4, getpeername, getsockname, setsockopt, getsockopt.

</dd><dt>dns
</dt><dd>allows socket(AF_INET), sendto, recvfrom, connect.

</dd><dt>proc
</dt><dd>allows fork, vfork, kill, getpriority, setpriority, prlimit,
setrlimit, setpgid, setsid, sched_getscheduler, sched_setscheduler,
sched_get_priority_min, sched_get_priority_max, sched_get_param,
sched_set_param.

</dd><dt>thread
</dt><dd>allows clone, futex, and permits PROT_EXEC in mprotect.

</dd><dt>id
</dt><dd>allows setuid, setreuid, setresuid, setgid, setregid,
setresgid, setgroups, prlimit, setrlimit, getpriority, setpriority,
setfsuid, setfsgid.

</dd><dt>exec
</dt><dd>Allows execve, execveat. If the executable in question needs a
loader, then you&#39;ll need rpath and prot_exec too. However that&#39;s not
needed if you assimilate your APE binary beforehand, because security is
strongest for static binaries; use the --assimilate flag or
assimilate.com program.

</dd><dt>tmppath
</dt><dd>Allows unlink, unlinkat, and lstat. When this promise is used,
certain paths will be automatically unveiled too, e.g. /tmp.

</dd><dt>vminfo
</dt><dd>OpenBSD intended this promise to be used by tools like `htop`. Using
this causes paths such as /proc/stat to be automatically unveiled.

</dd></dl>

<h2 class="page" id="funding">
  <a href="#funding">
    Funding
  </a>
</h2>

<p>
  <a href="https://justine.lol/lemuria.png">
    <picture>
      <source srcset="//worker.jart.workers.dev/sectorlisp2/lemuria.webp" type="image/webp"/>
      <img src="https://worker.jart.workers.dev/sectorlisp2/lemuria.png" width="850" height="360" alt="[United States of Lemuria - two dollar bill - all debts public and primate]"/>
    </picture>
  </a>

</p><p>
Funding for the development of pledge() on Linux was crowdsourced from
Justine Tunney&#39;s <a href="https://github.com/sponsors/jart">GitHub
sponsors</a> and <a href="https://www.patreon.com/jart">Patreon
subscribers</a>. Your support is what makes projects like Cosmopolitan
Libc possible. Thank you.

</p>
<img src="https://ipv4.games/claim?name=jart"/>
</div>
  </body>
</html>
