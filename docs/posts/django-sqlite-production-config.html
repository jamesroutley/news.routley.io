<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.pecar.me/sqlite-django-config">Original</a>
    <h1>Django SQLite Production Config</h1>
    
    <div id="readability-page-1" class="page"><div>
    <hgroup>
      
      <h2>Python, Django, and the Web</h2>
    </hgroup>
  </div><div><span>14 Jun 2024</span>

<section><p>The default SQLite configuration in Django is not ideal for running your application in production. SQLite is optimized for embedded low-concurrency systems out of the box, which is the exact opposite of what your Django application is supposed to do.</p>

<p>Luckily, you can improve concurrency by tweaking a few settings. See how to do it based on the version of Django that you are currently running:</p>

<!-- 

# Use `django-sqlite-engine`

`django-sqlite-engine` comes preconfigured with defaults that should work for most web apps.

1. Install through PyPI:

    ```bash
    pip install django-sqlite-engine
    ```

2. Configure in your `DATABASES`:

    ```python
    # yourproject/settings.py
    DATABASES = {
        "default": {
            "ENGINE": "django_sqlite_engine", # <-- Use custom engine with predefined defaults
            "NAME": BASE_DIR / "db.sqlite3",
        }
    }
    ```
-->

<h2 id="in-django-50-42-or-older">In Django 5.0, 4.2, or older</h2>

<h3 id="1-enable-wal-journal-mode">1. Enable WAL journal mode</h3>

<p>The most impactful change you can make is to enable <code>WAL</code> <code>journal_mode</code>. Without <code>WAL</code>, every write request blocks reads and vice versa, which can kill your throughput.</p>

<p>Enabling <code>WAL</code> mode has no real downsides and can be achieved by running the following command on your database:</p>

<div><div><pre><code>sqlite3 db.sqlite3 <span>&#39;PRAGMA journal_mode=WAL;&#39;</span>
</code></pre></div></div>

<p>You only have to run this command <strong>once</strong> per database, and the setting will persist.</p>

<h3 id="2-use-immediate-transactions">2. Use IMMEDIATE transactions</h3>

<p>Using immediate transactions isn’t a performance improvement. It will decrease your performance when running transactions, but it will avoid unexpected <a href="https://blog.pecar.me/django-sqlite-dblock#cause-2-writes-after-reads-in-transactions">database is locked errors</a>, so it’s worth enabling.</p>

<p>To enable IMMEDIATE transactions, you are going to have to create your database engine:</p>

<ol>
  <li>
    <p>Create a <code>yourproject/sqlite3/base.py</code> file with a <code>DatabaseWrapper</code> class:</p>

    <div><div><pre><code> <span># yourproject/sqlite3/base.py
</span> <span>from</span> <span>django.db.backends.sqlite3</span> <span>import</span> <span>base</span>


 <span>class</span> <span>DatabaseWrapper</span><span>(</span><span>base</span><span>.</span><span>DatabaseWrapper</span><span>):</span>
     <span>def</span> <span>_start_transaction_under_autocommit</span><span>(</span><span>self</span><span>):</span>
         <span># Acquire a write lock immediately for transactions
</span>         <span>self</span><span>.</span><span>cursor</span><span>().</span><span>execute</span><span>(</span><span>&#34;BEGIN IMMEDIATE&#34;</span><span>)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Use the created <code>DatabaseWrapper</code> as your SQLite3 engine in your <code>settings.py</code>:</p>

    <div><div><pre><code>
 <span># yourproject/settings.py
</span> <span>DATABASES</span> <span>=</span> <span>{</span>
     <span>&#34;default&#34;</span><span>:</span> <span>{</span>
         <span>&#34;ENGINE&#34;</span><span>:</span> <span>&#34;yourproject.sqlite3&#34;</span><span>,</span> <span># &lt;-- Use our custom engine
</span>         <span>&#34;NAME&#34;</span><span>:</span> <span>BASE_DIR</span> <span>/</span> <span>&#34;db.sqlite3&#34;</span><span>,</span>
     <span>}</span>
 <span>}</span>
</code></pre></div>    </div>
  </li>
</ol>



<p>A few SQLite settings can improve your application’s performance by a few additional percentage points. The magic values below are now also the default in Rails 7.1 and should give you a good starting point, but feel free to tweak <code>mmap_size</code>, <code>journal_size_limit</code>, and <code>cache_size</code> to best suit your application:</p>

<div><div><pre><code><span># yourproject/sqlite3/base.py
</span><span>from</span> <span>sqlite3</span> <span>import</span> <span>dbapi2</span> <span>as</span> <span>Database</span>

<span>from</span> <span>django.db.backends.sqlite3</span> <span>import</span> <span>base</span>
<span>from</span> <span>django.db.backends.sqlite3._functions</span> <span>import</span> <span>register</span> <span>as</span> <span>register_functions</span>
<span>from</span> <span>django.utils.asyncio</span> <span>import</span> <span>async_unsafe</span>


<span>class</span> <span>DatabaseWrapper</span><span>(</span><span>base</span><span>.</span><span>DatabaseWrapper</span><span>):</span>
    <span>def</span> <span>_start_transaction_under_autocommit</span><span>(</span><span>self</span><span>):</span>
        <span># Acquire a write lock immediately for transactions
</span>        <span>self</span><span>.</span><span>cursor</span><span>().</span><span>execute</span><span>(</span><span>&#34;BEGIN IMMEDIATE&#34;</span><span>)</span>

    <span>@</span><span>async_unsafe</span>
    <span>def</span> <span>get_new_connection</span><span>(</span><span>self</span><span>,</span> <span>conn_params</span><span>):</span>
        <span>conn</span> <span>=</span> <span>Database</span><span>.</span><span>connect</span><span>(</span><span>**</span><span>conn_params</span><span>)</span>
        <span>register_functions</span><span>(</span><span>conn</span><span>)</span>

        <span>conn</span><span>.</span><span>execute</span><span>(</span><span>&#34;PRAGMA foreign_keys = ON&#34;</span><span>)</span>
        <span># The macOS bundled SQLite defaults legacy_alter_table ON, which
</span>        <span># prevents atomic table renames.
</span>        <span>conn</span><span>.</span><span>execute</span><span>(</span><span>&#34;PRAGMA legacy_alter_table = OFF&#34;</span><span>)</span>

        <span>conn</span><span>.</span><span>execute</span><span>(</span><span>&#34;PRAGMA journal_mode = WAL&#34;</span><span>)</span>
        <span>conn</span><span>.</span><span>execute</span><span>(</span><span>&#34;PRAGMA synchronous = NORMAL&#34;</span><span>)</span>
        <span>conn</span><span>.</span><span>execute</span><span>(</span><span>&#34;PRAGMA mmap_size = 134217728&#34;</span><span>)</span>
        <span>conn</span><span>.</span><span>execute</span><span>(</span><span>&#34;PRAGMA journal_size_limit = 27103364&#34;</span><span>)</span>
        <span>conn</span><span>.</span><span>execute</span><span>(</span><span>&#34;PRAGMA cache_size = 2000&#34;</span><span>)</span>

        <span>return</span> <span>conn</span>

</code></pre></div></div>

<h2 id="in-django-51-or-newer">In Django 5.1 or newer</h2>

<p><mark>Django 5.1 is currently in <strong>development</strong> and is expected to be released in August 2024</mark></p>

<p>In Django 5.1, you will be able to tweak all the necessary changes in your <code>settings.py</code>:</p>

<div><div><pre><code><span># yourproject/settings.py
</span><span>DATABASES</span> <span>=</span> <span>{</span>
    <span>&#34;default&#34;</span><span>:</span> <span>{</span>
        <span>&#34;ENGINE&#34;</span><span>:</span> <span>&#34;django.db.backends.sqlite3&#34;</span><span>,</span>
        <span>&#34;OPTIONS&#34;</span><span>:</span> <span>{</span>
            <span>&#34;transaction_mode&#34;</span><span>:</span> <span>&#34;IMMEDIATE&#34;</span><span>,</span>
            <span>&#34;init_command&#34;</span><span>:</span> <span>&#34;&#34;&#34;
                PRAGMA journal_mode=WAL;
                PRAGMA synchronous=NORMAL;
                PRAGMA mmap_size = 134217728;
                PRAGMA journal_size_limit = 27103364;
                PRAGMA cache_size=2000;
            &#34;&#34;&#34;</span><span>,</span>
        <span>},</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>



<p>That’s it; with these settings, your SQLite database is going to handle the load that most small to medium-sized websites typically get, as long as your use case isn’t write-heavy!</p>
</section>

</div></div>
  </body>
</html>
