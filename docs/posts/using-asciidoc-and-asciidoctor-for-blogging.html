<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://duncanlock.net/blog/2021/01/12/using-asciidoc-and-asciidoctor-for-blogging/">Original</a>
    <h1>Using AsciiDoc and Asciidoctor for Blogging</h1>
    
    <div id="readability-page-1" class="page"><section itemprop="text articleBody">
<section id="preamble" aria-label="Preamble"><figure><img src="https://duncanlock.net/images/posts/using-asciidoc-and-asciidoctor-for-blogging/asciidoctor-logo-blueprint-cropped-compressed.svg" alt="Asciidoc" width="400"/>
<figcaption>Figure 1. Asciidoc.</figcaption></figure>
<p>I’ve been using reStructuredText for writing on this blog, because it has lots of built-in features that markdown doesn’t.</p>
<p>However, reStructuredText’s <em>actual syntax</em> is a bit…​ fiddly - particularly its non-atx headings, too many things relying on lining up white space, etc…​ If I don’t use it for a bit, I have to look up or copy <span>&amp;</span> paste all the advanced syntax.</p>
<p>I’d prefer to use AsciiDoc, as it has all the extra features, and if you use Asciidoctor, <a href="https://docs.asciidoctor.org/asciidoc/latest/asciidoc-vs-markdown/">all the simple stuff is the same as markdown</a> - which isn’t (currently) standard AsciiDoc, but is a nice simplification.</p>
<p>The subset of features from reStructuredText (or Asciidoc) that Markdown doesn’t have – and that I’m <em>actually using</em> on this blog, are:</p>
<div><ul><li>Figure/Images with captions</li><li>Admonitions</li><li>Front-matter/Metadata</li><li>Footnotes</li></ul></div></section>
<section><h2 id="_worse_is_better">Worse is better?</h2><p>Markdown has <em>lots</em> of problems. Most of these problems stem from two things: <a href="https://commonmark.org/">Until CommonMark</a> it was lazily, pointlessly, stubbornly non-standard - and it has very few structural or semantic features. Because of people wanting to add some of these features - and because there was no standard and therefore no way to extend one, Markdown has exploded into many fragmented semi-compatible dialects.</p>
<p>However, <a href="https://en.wikipedia.org/wiki/Worse_is_better">worse is better</a>. Markdown’s simplicity makes it pretty simple to implement, to the extent that there are native implementations of Markdown in probably every language: <a href="https://bitbucket.org/yiyus/md2html.awk"><span>AWK</span></a>, <a href="https://github.com/chadbraunduin/markdown.bash">Bash</a>, <a href="https://github.com/commonmark/cmark">C</a> …​ to <a href="https://github.com/kivikakk/koino">Zig</a>. There are <a href="https://github.com/markdown/markdown.github.com/wiki/Implementations">hundreds</a> of more-or-less complete <a href="https://github.com/search?q=markdown+implementation">markdown implementations</a> to choose from, to fit any project; here are <a href="https://github.com/commonmark/commonmark-spec/wiki/List-of-CommonMark-Implementations">fifty high quality maintained ones, that support CommonMark, sorted by language</a>, for example.</p>
<p>AsciiDoc is <em>much</em> better than Markdown, but these extra features for the <em>writer</em> come with extra complexity for the person <em>implementing</em> the tools. Probably as a consequence, the AsciiDoc ecosystem and tooling is very anemic and leaves <em>a lot</em> to be desired.</p>
<p>The <em>only</em> complete and well maintained AsciiDoc processor is <a href="https://asciidoctor.org/">Asciidoctor</a> - which is written in Ruby. That’s it - there are no other options as of early 2021<a id="_footnoteref_1" href="#_footnote_1" title="View footnote 1" role="doc-noteref">[1]</a>. I don’t have anything against Ruby, particularly, but I don’t know it or use it for anything, so it’s not familiar. It <em>also</em> has all the same well know problems as Python with packaging/running projects <span>&amp;</span> managing dependencies. Instead of pip/setuptools/virtualenv, etc…​ its gem/rbvenv/rake/bundler/rvm, etc…​ hundreds of global gem files, the whole giant mess. I get the impression that the Ruby version of this mess is…​ less of a problem somehow than the python one, but it’s still a mess.</p>
<p>So, the AsciiDoc story is obviously much more limited than the markdown story. If you want native markdown support, you got it, no matter what you’re doing. If you want native AsciiDoc support, you can only have it if your project is in Ruby (or Java <span>&amp;</span> JavaScript with some caveats <a href="#_footnote_1" title="View footnote 1" role="doc-noteref">[1]</a>). Other than that, you have to shell out and run a Ruby process - and have all the required Ruby dependencies installed.</p>
<p>This turns your document processing into a slower-than-it-could-be, annoying to setup and maintain, external black box. Don’t take this the wrong way - the contents of that black box are <em>fantastic</em> and good people have worked hard on them, but there are only a few of those people and pitting them against the markdown community - which is much, much larger - isn’t really fair.</p></section>
<section><h2 id="_what_are_the_consequences_of_this_for_blogging">What are the consequences of this for blogging?</h2>
<section><h3 id="_editing_experience_isnt_as_good">Editing experience isn’t as good</h3><p>Most modern editors support AsciiDoc syntax highlighting and sometimes preview, via plugins. But, as expected, these aren’t as well-developed, numerous or as fully featured as the Markdown equivalents. If you’re using the Asciidoctor markdown-a-like syntax for the simple stuff, then you can just tell the editor it’s Markdown, and use the more fully featured markdown support.</p></section>
<section><h3 id="_not_much_native_support">Not much native support</h3><p>If you’re using a Ruby blog engine, it <em>might</em> have <a href="https://gist.github.com/briandominick/e5754cc8438dd9503d936ef65fffbb2d">native AsciiDoc support</a>, or your blog engine might have a plugin that supports it. Don’t expect every blog engine to support it, though. Some blog engines have an escape hatch that let you use <a href="https://pandoc.org/index.html">Pandoc</a> or some other custom command to process your content - and while Pandoc <em>does</em> have AsciiDoc support, it’s neither complete nor flawless.</p></section>
<section><h3 id="_does_native_support_matter">Does native support matter?</h3><p>Does the fact that the document processing is shelled out to a black box actually affect using AsciiDoc for blogging? Well, it makes publishing a bit slower to <em>a lot</em> slower, depending on the size of your site. But in most blog/publishing systems you have a template that defines the structure of the page with some kind of placeholder that says <code>{{content-goes-here}}</code>. It doesn’t really matter <em>how</em> the content is generated, as long as it is - and as long as the <span>HTML</span> that’s produced lines up with your <span>CSS</span> <span>&amp;</span> is reasonable. Speaking of which…​</p></section>
<section><h3 id="_asciidoctors_built_in_html_output_could_be_better">Asciidoctor’s built-in <span>HTML</span> output could be better</h3><p>When <code>asciidoctor</code> processes your <code>.adoc</code> file you can tell it what converter (or “back-end”) you want to use - i.e. what kind of output you want. <a href="https://docs.asciidoctor.org/asciidoctor/latest/converters/">These are the built-in options</a>. This is what they say about the default <span>HTML</span> converter:</p>
<div><blockquote><p>The <span>HTML</span> 5 converter (<code>html</code> or <code>html5</code>) generates <span>HTML</span> 5 styled with <span>CSS3</span>. This is the converter Asciidoctor uses by default.</p></blockquote></div>
<p>This is <em>technically</em> true, however, while the <span>HTML</span> it produces is <em>technically</em> <span>HTML5</span>, it’s also <code>&lt;div&gt;</code> soup. For example, this document processor for processing documents doesn’t output paragraph tags (<code>&lt;p&gt;…​&lt;/p&gt;</code>) - it outputs this instead: <code>&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;…​&lt;/p&gt;&lt;/div&gt;</code> - and it does something like that for basically everything. To be fair, <a href="https://github.com/asciidoctor/asciidoctor/projects/1">they are aware of this <span>&amp;</span> working on it</a>.</p>
<p>So, I’m not going to use that, I’ll just use some community written back-end/converter that’s better…​ oh…​ yeah. Well, luckily, in this case there actually <em>is</em> one: <a href="https://github.com/jirutka/asciidoctor-html5s">html5s</a> - which does a <em>much</em> better job.</p></section></section>
<section><h2 id="_asciidoc_rough_edges">AsciiDoc Rough Edges</h2><p>I’ve written a few articles from scratch and <a href="#_converting_your_existing_content_to_asciidoc">converted the existing 80 reStructuredText articles to AsciiDoc</a>, and it’s been <em>fairly</em> painless, but I <em>have</em> come across a few rough edges and problems with AsciiDoc.</p>
<section><p>AsciiDoc has <a href="https://docs.asciidoctor.org/asciidoc/latest/macros/footnote/">built-in support for footnotes</a>, but there are some rough edges:</p>

<p>The combination of these issues means that if you want externalized footnotes that work like the rest of your content, you have to give the footnote an <span>ID</span> and wrap the footnote definition in an inline pass-through. Because these become document attributes, you have to define them before you use them, so you should probably put these at the top.</p>
<p>This is more complex <span>&amp;</span> convoluted than it needs to be - footnotes should just work. Anyway, it looks like this:</p>
<div><pre><code data-lang="asciidoc">:fn-disclaimer: pass:q[footnote:disclaimer[Opinions are *my own*.]]

A bold statement!{fn-disclaimer}

Another bold statement!{fn-disclaimer}</code></pre></div>
<p>They have a proposal for <a href="https://github.com/asciidoctor/asciidoctor/issues/559">an improved footnote syntax</a> - although it doesn’t talk about text formatting inside the footnote.</p></section>
<section><h3 id="_blockquotes">Blockquotes</h3><p>I took me ages poking around on GitHub before I found out how to set the link text in the citation for a quoted block. This is the basic syntax:</p>
<div><pre><code data-lang="asciidoc">[quote, attribution, citation title and information]
Quote or excerpt text</code></pre></div>
<p>You can put a <span>URL</span> in there, and it works, but giving the <span>URL</span> a title doesn’t seem to work. So this works:</p>
<div><pre><code data-lang="asciidoc">[quote, https://en.wikipedia.org/wiki/Main_Page]
Quote or excerpt text</code></pre></div>
<p>but this doesn’t:</p>
<div><pre><code data-lang="asciidoc">[quote, https://en.wikipedia.org/wiki/Main_Page[Wikipedia]]
Quote or excerpt text</code></pre></div>
<p>However, using the <a href="https://docs.asciidoctor.org/asciidoc/latest/blocks/blockquotes/#quoted-paragraph">Quoted paragraph</a> syntax works:</p>
<div><pre><code data-lang="asciidoc">&#34;Quote or excerpt text&#34;
-- https://en.wikipedia.org/wiki/Main_Page[Wikipedia]</code></pre></div>
<p><a href="https://github.com/asciidoctor/asciidoctor/issues/1254">Apparently, the correct way to do this with quoted blocks</a>, is to “use single quotes around the attribute value, that gives Asciidoctor the hint to apply normal substitutions (just like paragraph text)”<a id="_footnoteref_2" href="#_footnote_2" title="View footnote 2" role="doc-noteref">[2]</a>. Not sure what that means at this point, but the docs on <a href="https://docs.asciidoctor.org/asciidoc/latest/subs/substitutions/">subtitutions are here</a>. This is what it looks like in this case:</p>
<div><pre><code data-lang="asciidoc">[quote, &#39;https://en.wikipedia.org/wiki/Main_Page[Wikipedia]&#39;]
Quote or excerpt text</code></pre></div></section></section>
<section><h2 id="_using_asciidoc_with_pelican">Using AsciiDoc with Pelican</h2><p>I’m currently using <a href="https://blog.getpelican.com/">Pelican</a> for this blog and writing this post in AsciiDoc. This is what you need to do to get that working.</p>
<p>First <a href="https://asciidoctor.org/#gem-install">install the Ruby dependencies <span>&amp;</span> Asciidoctor itself</a>. Unlike me, you should listen to them and use <span>RVM</span> for this. Once you have that installed, you need to <a href="https://github.com/jirutka/asciidoctor-html5s#installation">install html5s and its dependencies</a>. Next, you need to add the <a href="https://github.com/getpelican/pelican-plugins/tree/master/asciidoc_reader">asciidoc_reader Pelican Plugin</a> and add it to your <code>pelicanconf.py</code></p>
<div><pre><code data-lang="python"><span>PLUGINS</span> <span>=</span> <span>[</span>
    <span>&#39;asciidoc_reader&#39;</span><span>,</span>
<span>]</span></code></pre></div>
<p>You should then set the Asciidoctor command line options. These will configure it to use the <code>html5s</code> backend and <a href="https://github.com/rouge-ruby/rouge">rouge for source code syntax highlighting</a>:</p>
<div><pre><code data-lang="python"><span>ASCIIDOC_OPTIONS</span> <span>=</span> <span>[</span>
    <span>&#39;-a source-highlighter=rouge&#39;</span><span>,</span>
    <span>&#39;-a rouge-style=monokai&#39;</span><span>,</span>
    <span>&#39;-r asciidoctor-html5s&#39;</span><span>,</span>
    <span>&#39;-b html5s&#39;</span>
<span>]</span></code></pre></div>
<p>Rouge is compatible with pygments - which I was using previously and my theme is set up to expect, so this was a drop-in replacement - which is very convenient.</p>
<section><h3 id="_adding_removing_plugins">Adding <span>&amp;</span> removing plugins</h3><p>The AsciiDoctor + htmls output has better figure output than reStructuredText + my Better Figures <span>&amp;</span> Images Plugin, so I don’t need that anymore - provided that I convert all articles using figures to AsciiDoc. On the other hand, the <code>extract_toc</code> plugin doesn’t work for AsciiDoc + htmls output, so I copied it to a local plugin and modified it to work:</p>
<div><pre><code data-lang="python"><span># -*- coding: utf-8 -*-
</span><span>&#34;&#34;&#34;
Extract Table of Contents from AsciiDoc output from the htmls backend
========================

A Pelican plugin to extract table of contents (ToC) from `article.content` and
place it in its own `article.toc` variable for use in templates.
&#34;&#34;&#34;</span>

<span>from</span> <span>os</span> <span>import</span> <span>path</span>
<span>from</span> <span>bs4</span> <span>import</span> <span>BeautifulSoup</span>
<span>from</span> <span>pelican</span> <span>import</span> <span>signals</span><span>,</span> <span>readers</span><span>,</span> <span>contents</span>
<span>import</span> <span>logging</span>

<span>logger</span> <span>=</span> <span>logging</span><span>.</span><span>getLogger</span><span>(</span><span>__name__</span><span>)</span>


<span>def</span> <span>extract_asciidoc_toc</span><span>(</span><span>content</span><span>):</span>
    <span>if</span> <span>isinstance</span><span>(</span><span>content</span><span>,</span> <span>contents</span><span>.</span><span>Static</span><span>):</span>
        <span>return</span>

    <span>soup</span> <span>=</span> <span>BeautifulSoup</span><span>(</span><span>content</span><span>.</span><span>_content</span><span>,</span> <span>&#34;html.parser&#34;</span><span>)</span>
    <span>toc</span> <span>=</span> <span>None</span>

    <span>toc</span> <span>=</span> <span>soup</span><span>.</span><span>find</span><span>(</span><span>&#34;nav&#34;</span><span>,</span> <span>id</span><span>=</span><span>&#34;toc&#34;</span><span>)</span>

    <span>if</span> <span>toc</span><span>:</span>
        <span>toc</span><span>.</span><span>extract</span><span>()</span>
        <span>content</span><span>.</span><span>_content</span> <span>=</span> <span>soup</span><span>.</span><span>decode</span><span>()</span>

        <span># Remove: &lt;h2 id=&#34;toc-title&#34;&gt;Table of Contents&lt;/h2&gt;
</span>        <span>toc</span><span>.</span><span>h2</span><span>.</span><span>decompose</span><span>()</span>

        <span># Change all ordered lists to unordered
</span>        <span>for</span> <span>l</span> <span>in</span> <span>toc</span><span>(</span><span>&#34;ol&#34;</span><span>):</span>
            <span>l</span><span>.</span><span>name</span> <span>=</span> <span>&#34;ul&#34;</span>

        <span>content</span><span>.</span><span>toc</span> <span>=</span> <span>toc</span><span>.</span><span>decode</span><span>()</span>

        <span>logger</span><span>.</span><span>debug</span><span>(</span><span>f</span><span>&#34;ExtractAsciidocToc: content.toc: </span><span>{</span><span>content</span><span>.</span><span>toc</span><span>}</span><span>&#34;</span><span>)</span>


<span>def</span> <span>register</span><span>():</span>
    <span>signals</span><span>.</span><span>content_object_init</span><span>.</span><span>connect</span><span>(</span><span>extract_asciidoc_toc</span><span>)</span></code></pre></div></section>
<section><h3 id="_converting_your_existing_content_to_asciidoc">Converting your existing content to AsciiDoc</h3><p>This depends on the format of your existing content:</p>
<section><h4 id="_converting_restructuredtext_to_asciidoc">Converting reStructuredText to AsciiDoc</h4><p>I tried <em>lots</em> of different way of converting reStructuredText to AsciiDoc - and none of them are perfect.</p>
<p><a href="https://pandoc.org/">Pandoc</a> does a <em>reasonable</em> job, unless you use figures, which get pretty mangled. They are <a href="https://github.com/jgm/pandoc/projects/3#card-61138871">aware/working on this</a>. If you want to use pandoc, This is the basic command:</p>
<div><pre><code data-lang="console"><span>$</span><span> </span>pandoc <span>--wrap</span><span>=</span>preserve <span>-f</span> rst <span>-t</span> asciidoctor <span>&#34;source.rst&#34;</span> <span>&gt;</span> <span>&#34;dest.adoc&#34;</span></code></pre></div>
<p>As well as figures, this <em>also</em> messes up metadata and pelican <code>{static}</code> links, so you probably want some pre- <span>&amp;</span> post-processing to fix that. I wrote a little shell script to fix everything except the figures:</p>
<div><pre><code data-lang="shell"><span>#</span>
<span># Pre-process</span>
<span>#</span>
<span>cat</span> <span>&#34;</span><span>$src_path</span><span>&#34;</span> | <span>\</span>
<span># Remove :alt: tags from figures &amp; images, otherwise they get lost</span>
<span>sed</span> <span>-r</span> <span>&#39;s/:alt: /\n/g&#39;</span> | <span>\</span>
<span># Tabs to spaces</span>
<span>sed</span> <span>-r</span> <span>&#39;s/\t/  /g&#39;</span> | <span>\</span>
<span>#</span>
<span># Convert rst to asciidoc using pandoc</span>
<span>#</span>
pandoc <span>--wrap</span><span>=</span>preserve <span>--from</span> rst <span>--to</span> asciidoctor | <span>\</span>
<span>#</span>
<span># Post-process</span>
<span>#</span>
<span># Fix metadata syntax, from date:: to :date:</span>
<span>sed</span> <span>-r</span> <span>&#39;N; s/^(.*)::\n /:\1:/g; P; D&#39;</span> | <span>\</span>
<span># Remove extra breaks created from figure caption conversion</span>
<span>sed</span> <span>-r</span> <span>&#39;N; s/____\n//g; P; D&#39;</span> | <span>\</span>
<span># Fix Pelican {static} links</span>
<span>sed</span> <span>-e</span> <span>&#39;s/%7B/{/g&#39;</span> <span>-e</span> <span>&#39;s/%7D/}/g&#39;</span> <span>\</span>
<span>&gt;</span> <span>&#34;</span><span>$src_folder</span><span>/</span><span>$src_name</span><span>&#34;</span>.adoc</code></pre></div></section>
<section><h4 id="_fine_ill_write_my_own_converter">Fine, I’ll write my own converter…​</h4><p>I use figures quite a bit, so this wasn’t a very satisfactory solution. Thinking about it, reStructuredText is basically <em>the</em> Python documentation format, so I looked for <a href="https://docutils.sourceforge.io/"><code>docutils</code></a> based tools to convert reStructuredText to other things. I eventually found <a href="https://github.com/wsidl/sphinx_asciidoc">sphinx_asciidoc</a>, which sort of worked - and was a fairly straightforward python script that I could improve. I <a href="https://github.com/dflock/sphinx_asciidoc">forked it here</a> and fixed all the issues I found - <a href="https://github.com/dflock/sphinx_asciidoc/commits/master">fixing metadata, figures, tables, linked images and various other things</a>.</p>
<p>I developed <span>&amp;</span> tested this by converting all 80 odd rst articles on this site to AsciiDoc and fixing all the issues that I fond in the converter.</p>
<p>Until pandoc fixes their figures, as far as I know, this is probably the best, highest fidelity way to convert reStructuredText to AsciiDoc. If you want to use this, do something like this to get it setup:</p>
<div><pre><code data-lang="console"><span>$</span><span> </span>git clone https://github.com/dflock/sphinx_asciidoc.git
<span>$</span><span> </span><span>cd </span>sphinx_asciidoc
<span>$</span><span> </span>python3 <span>-m</span> venv ~/venv/sphinx_asciidoc
<span>$</span><span> </span><span>source</span> ~/venv/sphinx_asciidoc/bin/activate
<span>$</span><span> </span>python3 <span>-m</span> pip <span>install</span> <span>-r</span> requirements.txt</code></pre></div>
<p>then this to run it:</p>
<div><pre><code data-lang="console"><span>$</span><span> </span>python3 ./sphinx_asciidoc/writer.py source.rst</code></pre></div>
<p>This will create a <code>source.rst.adoc</code> file in the same folder. I tried to keep this as general purpose as possible, but there are <em>probably</em> some things in here which are specific to my documents. There is a section at the top of <code>writer.py</code> with some knobs to twiddle:</p>
<div><pre><code data-lang="python"><span>#
# Things that should be options, but aren&#39;t
#
# Output the rendered TOC from docutils, or just `:toc:`
</span><span>self</span><span>.</span><span>outputTOC</span> <span>=</span> <span>False</span>
<span># Table column alignment, if not specified. Can be &lt;&gt;^ or
# &#39;&#39; for unspecified.
</span><span>self</span><span>.</span><span>defaultTableColAlign</span> <span>=</span> <span>&#34;&#34;</span>
<span># Specify percentages for columns widths, or leave browser to auto-layout?
</span><span>self</span><span>.</span><span>defaultTableColWidths</span> <span>=</span> <span>True</span>
<span># Do you want to output the [1] ref&#39;s after the {footnote}, or let asciidoctor do it?
</span><span>self</span><span>.</span><span>outputFootnoteRef</span> <span>=</span> <span>False</span></code></pre></div></section>
<section><h4 id="_converting_markdown_to_asciidoc">Converting Markdown to AsciiDoc</h4><p>If your content is in Markdown, you need <a href="https://github.com/asciidoctor/kramdown-asciidoc">Kramdown</a>. Kramdown is a very good markdown to AsciiDoc converter, that works great and produces flawless AsciiDoc - unsurprising, given that it’s written by <a href="https://github.com/mojavelinux">Dan Allen</a>, the same guy who largely runs the Asciidoctor project. Once you have Kramdown installed, you can just do: <code>$ kramdoc source.md</code> and it’ll create a <code>source.adoc</code> file in the same folder.</p></section></section></section>
<section><h2 id="_future_of_asciidoc_asciidoctor">Future of AsciiDoc <span>&amp;</span> Asciidoctor</h2><p>There are a few promising projects that will help improve the AsciiDoc ecosystem.</p>
<section><h3 id="_the_asciidoc_specification">The AsciiDoc Specification</h3><p>The first and biggest one is that AsciiDoc is <a href="https://asciidoctor.org/news/2019/01/07/asciidoc-spec-proposal/">finally getting a proper spec</a>, under the umbrella of the Eclipse Foundation. This is something that Markdown never had until CommonMark - and that AsciiDoc has lacked up to now. What this means is:</p>
<div><blockquote><p>The specification for the AsciiDoc language will include an open source specification document, which defines required and optional <span>API</span> definitions, semantic behaviours, data formats, and protocols, as well as an open source Technology Compatibility Kit (<span>TCK</span>) that developers can use to develop and test compatible implementations. …​ A compatible implementation, as defined by the <span>EFSP</span>, must fully implement all non-optional elements of a specification version, must fulfill all the requirements of the corresponding <span>TCK</span>, and must not alter the specified <span>API</span>.</p>
<p>For users and developers alike, the AsciiDoc specification will mean a clear, working definition of what AsciiDoc is and how it should be interpreted. Developers will be able to build implementations, tools, and services around AsciiDoc without risk of diluting its meaning or splintering it. In turn, users will have more options, greater document portability, and the assurance that compatible implementations and tools will handle their AsciiDoc documents according to a versioned specification.</p></blockquote></div>
<p>Here is the <a href="https://projects.eclipse.org/proposals/asciidoc-language">AsciiDoc Language project proposal</a> and the <a href="https://gitlab.eclipse.org/eclipse/asciidoc/asciidoc-lang/-/blob/main/process/scope.adoc">approved scope of the project</a>.</p>
<p>So, this should help prevent the fragmentation that plagues the Markdown ecosystem, as well a making it easier for people to develop AsciiDoc parsers <span>&amp;</span> tools. Still nowhere near as easy as implementing a Markdown one, though - AsciiDoc is just more complex.</p>
<p>Having said that, this is a big project and most of the activity is taking place on <a href="https://www.eclipse.org/lists/asciidoc-wg">mailing lists</a> - there also now a <a href="https://asciidoc-wg.eclipse.org/committees/">website for the Working Group</a> which currently includes meeting minutes etc…​ There is now an AsciiDoc language repo for discussing the spec work, but it’s still early days: <a href="https://gitlab.eclipse.org/eclipse/asciidoc/asciidoc-lang/">https://gitlab.eclipse.org/eclipse/asciidoc/asciidoc-lang/</a></p></section>
<section><h3 id="_libasciidoc">libasciidoc</h3><p><a href="https://github.com/bytesparadise/libasciidoc">Libsciidoc is a Golang library for processing AsciiDoc files</a>. This uses a <a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar"><span>PEG</span> parser</a> with a formal grammar for AsciiDoc. It already supports a useful subset of AsciiDoc and is being slowly worked on by a few people, I think with the intention to use it with <a href="https://gohugo.io/">Hugo</a>, which will make a nice combination, when it’s done.</p>
<p>Like most software written in Go, it’s statically linked, which means no dependencies at all - you just need to put the <code>libacsiidoc</code> binary somewhere and run it. This is <em>really nice</em> compared to setting up and maintaining the Ruby dependencies required for Asciidoctor, or the <span>JS</span> <span>&amp;</span> Java ones for Asciidoctor-J/Java, for example.</p>
<hr/></section>
<section></section></section>
<hr/>

<hr/>

</section></div>
  </body>
</html>
