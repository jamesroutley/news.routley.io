<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.gitbutler.com/fearless-rebasing/">Original</a>
    <h1>GitButler now supports first class conflicts, making rebasing less annoying</h1>
    
    <div id="readability-page-1" class="page"><article>
	
	<div>
		<p>I have a confession to make. For most of my Git life, I have been a <strong>merger</strong>.</p><p>I have been asked countless times if it&#39;s better to merge or to rebase and while I never want to stir up a hornet&#39;s nest, I have always advocated merging over rebasing. Not only that, but I have nearly always done so myself when working on a project.</p><p>To me, merging has always been better. It keeps more of the history, there are by definition fewer conflicts since it only has to merge the last tree rather than every intermediate tree, it&#39;s easier to see what each series actually was, it&#39;s easier to see when it was integrated, etc.</p><p>However, let&#39;s admit it, <strong>rebasing is sexy</strong>. </p><figure><img src="https://blog.gitbutler.com/content/images/2024/10/CleanShot-2024-10-02-at-13.42.13@2x.png" alt="" loading="lazy" width="2000" height="731" srcset="https://blog.gitbutler.com/content/images/size/w600/2024/10/CleanShot-2024-10-02-at-13.42.13@2x.png 600w, https://blog.gitbutler.com/content/images/size/w1000/2024/10/CleanShot-2024-10-02-at-13.42.13@2x.png 1000w, https://blog.gitbutler.com/content/images/size/w1600/2024/10/CleanShot-2024-10-02-at-13.42.13@2x.png 1600w, https://blog.gitbutler.com/content/images/size/w2400/2024/10/CleanShot-2024-10-02-at-13.42.13@2x.png 2400w" sizes="(min-width: 1200px) 1200px"/><figcaption><span>Rebasing versus merging, which is better?</span></figcaption></figure><p>I&#39;ve always loved the idea of a linear history, of rewriting a series until it&#39;s perfect and getting that nice useful blame and bisecting power. Getting rid of that subway map history graph in favor of a nice simple series of patches.</p><p>But <strong>rebasing is also a pain in the ass</strong>.</p><p>You run <code>rebase --pull</code> and get conflict after conflict and can&#39;t do anything else until you&#39;re done. You can&#39;t save your progress if you get tired of the exercise halfway through. It&#39;s also difficult to keep your series clean anyhow - doing fix-up commits, <a href="https://blog.gitbutler.com/git-autosquash/" rel="noreferrer">autosquashing</a>, interactive rebasing. Even those of us fairly used to the tooling mess up or get frustrated sometimes. Now compound that with the need for your <em>entire team</em> to feel comfortable with this tooling. <em>Heavy sigh.</em></p><p>Recently, however, I have completely changed my mind. I am now an official <strong>rebaser</strong>.</p><p>The reason is not because I was convinced by someone that I&#39;ve been wrong this whole time, nor was it because Git&#39;s tooling around rebasing got better. It&#39;s because of <strong>Fearless Rebasing</strong>.</p><h2 id="fearless-rebasing">Fearless Rebasing</h2><p>One of the things that GitButler has never been very good at so far is merge conflicts. We just didn&#39;t have a good story for it because we weren&#39;t sure what a good way was to handle it. What is actually an ideal (or even, <em>not horrible</em>) way to deal with merge conflicts?</p><p>When researching other tools, I ran across the Jujutsu project that is being developed at Google.</p><figure><iframe width="200" height="113" src="https://www.youtube.com/embed/LV0JzI8IcCY?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="" title="Jujutsu - A Git-compatible VCS - Martin von Zweigbergk | GitMerge 2024"></iframe></figure><p>Jujutsu has a novel concept of &#34;<a href="https://martinvonz.github.io/jj/latest/conflicts/?ref=blog.gitbutler.com">first class conflicts</a>&#34;, where it can record conflicted states in it&#39;s commit objects. Git can&#39;t do this. If Git runs into a conflict when trying to merge, rebase or cherry-pick something, it halts everything and makes you fix it before moving forward. It has no way to save the conflict for later resolution and keep going. </p><p>But Jujutsu does, which means that every time you do a rebase operation, it is <strong><em>always</em> successful</strong>. </p><p>How does this work?</p><p>When Jujutsu tries to rebase commits and runs into a conflict, instead of writing the conflict out to the working directory and throwing a bunch of status files into your <code>.git</code> directory, it instead writes a specially formatted commit that lists out the trees it attempted to merge, pretends that this commit was not there and continues with the next commits.</p><p>This means that you can end up in a state like this, where you have several conflicted commits and then some commits <em>after</em> them that are not in a conflicted state.</p><figure><img src="https://blog.gitbutler.com/content/images/2024/10/CleanShot-2024-10-02-at-13.36.45@2x.png" alt="" loading="lazy" width="1536" height="602" srcset="https://blog.gitbutler.com/content/images/size/w600/2024/10/CleanShot-2024-10-02-at-13.36.45@2x.png 600w, https://blog.gitbutler.com/content/images/size/w1000/2024/10/CleanShot-2024-10-02-at-13.36.45@2x.png 1000w, https://blog.gitbutler.com/content/images/2024/10/CleanShot-2024-10-02-at-13.36.45@2x.png 1536w" sizes="(min-width: 720px) 720px"/></figure><p>Then to resolve the conflicts, you can edit one of the commits and resolve it, which amends that commit and automatically rebases everything above it again.</p><h2 id="fearless-rebasing-in-gitbutler">Fearless Rebasing in GitButler</h2><p>We loved this concept so much that we decided to implement an approach that is very similar.</p><p>When working with a virtual branch, we want to empower you to think about your changes as a series of patches that you can constantly and easily change, amend, squash, split, edit and <strong><em>rebase</em></strong>.</p><p>If you can do all of that fearlessly, knowing that everything is easy to do, simple to undo and much more painless to resolve, then that lets us maintain that beautiful and simple history.</p><p>In our 0.13 release of GitButler, we are introducing a very similar workflow to rebasing your commits to what Jujutsu does. If you create a series of commits and then rebase it onto new upstream work and there are conflicts, we will <em>always</em> rebase successfully but mark any problematic commits and only apply the parts of them to your working directory that do not conflict.</p><p>So let&#39;s say that you have three commits in your branch and rebase and the first two have conflict problems. Now we will partially apply them (whichever hunks do not conflict), write a special commit that has a conflicted header, then try the next one.</p><figure><img src="https://blog.gitbutler.com/content/images/2024/10/CleanShot-2024-10-02-at-13.48.51@2x.png" alt="" loading="lazy" width="1334" height="1022" srcset="https://blog.gitbutler.com/content/images/size/w600/2024/10/CleanShot-2024-10-02-at-13.48.51@2x.png 600w, https://blog.gitbutler.com/content/images/size/w1000/2024/10/CleanShot-2024-10-02-at-13.48.51@2x.png 1000w, https://blog.gitbutler.com/content/images/2024/10/CleanShot-2024-10-02-at-13.48.51@2x.png 1334w" sizes="(min-width: 720px) 720px"/></figure><p>Now you can solve these conflicts one by one. Even in any order - you don&#39;t have to approach the first one first, you can start with the second one if you prefer.</p><p>To solve the conflicts, you can click on a commit that is in a conflicted state and click the &#34;Resolve Conflicts&#34; button, which <em>now</em> checks out just those conflicts into your working directory.</p><figure><img src="https://blog.gitbutler.com/content/images/2024/10/CleanShot-2024-10-02-at-13.52.38@2x.png" alt="" loading="lazy" width="1784" height="1446" srcset="https://blog.gitbutler.com/content/images/size/w600/2024/10/CleanShot-2024-10-02-at-13.52.38@2x.png 600w, https://blog.gitbutler.com/content/images/size/w1000/2024/10/CleanShot-2024-10-02-at-13.52.38@2x.png 1000w, https://blog.gitbutler.com/content/images/size/w1600/2024/10/CleanShot-2024-10-02-at-13.52.38@2x.png 1600w, https://blog.gitbutler.com/content/images/2024/10/CleanShot-2024-10-02-at-13.52.38@2x.png 1784w" sizes="(min-width: 720px) 720px"/></figure><p>It also changes your GitButler UI to let you know you are in this special state and allows you to either abort the session using the &#34;Cancel&#34; button or save your conflicted state and rebase the remaining commits with the &#34;Save&#34; button.</p><figure><img src="https://blog.gitbutler.com/content/images/2024/10/CleanShot-2024-10-02-at-13.51.43@2x.png" alt="" loading="lazy" width="2000" height="1120" srcset="https://blog.gitbutler.com/content/images/size/w600/2024/10/CleanShot-2024-10-02-at-13.51.43@2x.png 600w, https://blog.gitbutler.com/content/images/size/w1000/2024/10/CleanShot-2024-10-02-at-13.51.43@2x.png 1000w, https://blog.gitbutler.com/content/images/size/w1600/2024/10/CleanShot-2024-10-02-at-13.51.43@2x.png 1600w, https://blog.gitbutler.com/content/images/size/w2400/2024/10/CleanShot-2024-10-02-at-13.51.43@2x.png 2400w" sizes="(min-width: 1200px) 1200px"/></figure><p>Now the entire rebasing workflow in Git is massively easier. You can solve conflicts whenever you prefer and you can push off the work until you&#39;re ready to work on them, even continuing to make new commits while some of your commits are in a conflicted state.</p><p>We believe that fearless rebasing is a much nicer way to deal with conflicts. If you want to try it out, download GitButler and see how it feels. Maybe we&#39;ll make a rebaser out of you too.</p>
			</div>
</article></div>
  </body>
</html>
