<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://incolumitas.com/2021/11/03/so-you-want-to-scrape-like-the-big-boys/">Original</a>
    <h1>So you want to Scrape like the Big Boys? (2021)</h1>
    
    <div id="readability-page-1" class="page"><div>
    <h2>Intro</h2>
<p>Let&#39;s do some thinking, shall we?</p>
<p>When I used to run a scraping service, I managed to scrape at most a couple of million Google SERPs per week. But I never ever purchased proxies from proxy providers such as <a href="https://brightdata.com/">Brightdata</a>, <a href="https://packetstream.io/">Packetstream</a> or <a href="https://oxylabs.io/">Oxylabs</a>.</p>
<p>Why? </p>
<p>Because I could not fully trust the other customers with whom I shared the proxy bandwidth. What if I share proxy servers with criminals that do more malicious stuff than the somewhat innocent SERP scraping?</p>
<p>Full disclosure: Non-DoS scraping of public information is okay for me. Ad-fraud, social media spam, web attacks such as automated SQL injections or XSS is not.</p>
<p>Furthermore, those proxy services are quite <em>pricey</em>, and me being a stingy German, I didn&#39;t possibly see a reasonable way for this combination to work out.</p>
<figure>
  <img src="https://incolumitas.com/images/work different.png" alt="farm man"/>
  <figcaption>It had to be said.</figcaption>
</figure>

<p>So how did I manage to scrape millions of Google SERP&#39;s?</p>
<p>I used <a href="https://aws.amazon.com/lambda/">AWS Lambda</a>, put Headless Chrome into an <a href="https://aws.amazon.com/getting-started/hands-on/run-serverless-code/">AWS Lambda function</a> and used <a href="https://github.com/berstend/puppeteer-extra">puppeteer-extra</a> and <a href="https://github.com/alixaxel/chrome-aws-lambda">chrome-aws-lambda</a> to create a function that automatically launches a browser for 300 seconds that I can solely use for scraping.</p>
<p>Actually, I could have probably achieved the same with plain <code>curl</code>, because Google really doesn&#39;t put too much effort into blocking bots from their own search engine (they mostly rate limit by IP). But I needed a full browser for other projects, so there was that.</p>
<p>Anyhow, AWS gives you access to 16 regions all around the world (are they offering even more regions in the meantime?) and after three AWS Lambda function invocations, your function obtains a new public IP address. And if you concurrently invoke 1000 Lambda functions, you will bottom out at around 250 public IP addresses. And then you have 16 regions, which gives you around <code>16 * 250 = 4000</code> public IP addresses at any time when using AWS Lambda. This was enough to be able to scrape millions of Google SERPs / week, even when sharing public datacenter IP addresses.</p>
<p>I tried the same with <a href="https://cloud.google.com/">Google Cloud Platform</a>, but funnily enough, Google blocks their own cloud infrastructure much more aggressively compared to traffic from AWS.</p>
<p>(This was all in 2019 and 2020, things possibly changed)</p>
<p><strong>But I digress.</strong></p>
<p>The above setup is not good. It will work for scraping Google / Bing / Amazon, because they <em>want</em> to be scraped to a certain extent.</p>
<p>But it will never work against well protected websites that employ protection from anti bot companies such as <a href="https://datadome.co/">DataDome</a>, <a href="https://www.akamai.com/">Akamai</a> or <a href="https://www.imperva.com/">Imperva</a> (there are more anti bot companies, don&#39;t be salty when I didn&#39;t name you, okay?).</p>
<p>Those companies employ ill-adjusted individuals that do nothing else than look for the most recent techniques to fingerprint browsers, find out if a browser <a href="https://github.com/abrahamjuliot/creepjs">lies about it&#39;s own configuration</a> or exhibits artifacts that don&#39;t pertain to a humanly controlled browser. When normal people are out drinking beers in the pub on Friday night, these individuals invent increasingly bizarre ways to fingerprint browsers and detect bots ;)</p>
<ol>
<li><a href="https://www.usenix.org/system/files/conference/woot14/woot14-ho.pdf">Browser Red Pills - Dan Boneh - Awesome Paper</a> </li>
<li><a href="https://incolumitas.com/2021/01/10/browser-based-port-scanning/">Browser Based Port Scanning</a></li>
<li><a href="https://research.google/pubs/pub45581/">Google Picasso</a></li>
<li><a href="https://browserleaks.com/fonts">Font Fingerprinting</a></li>
<li><a href="https://github.com/NikolaiT/zardaxt">TCP/IP Fingerprinting - zardaxt.py</a></li>
<li><a href="https://en.wikipedia.org/wiki/Proof_of_work">Browser based Crypto Challenges - Proof of Work</a></li>
<li>Generic Browser Fingerprinting</li>
<li><a href="https://github.com/salesforce/ja3">TLS Fingerprinting</a></li>
<li>WebGL Fingerprinting</li>
<li>WebRTC real IP detection</li>
<li><a href="https://incolumitas.com/2021/04/11/bot-detection-with-behavioral-analysis/">Behavioral Classification</a></li>
<li><a href="https://incolumitas.com/2021/02/05/why-does-this-website-know-i-am-sitting-on-the-toilet/">Gyroscope API querying (device movement / rotation detection)</a></li>
<li><a href="https://fingerprintjs.com/blog/disabling-javascript-wont-stop-fingerprinting/">Fingerprinting without JavaScript using HTTP headers, CSS feature queries and Fonts.</a></li>
<li>...</li>
</ol>
<p>I kid you not, there are millions of different ways to detect if a browser is being controlled by a bot or not. It&#39;s insanely complex and almost all bot architectures are to a degree vulnerable to detection.</p>
<p>Maybe I am just not a good enough bot developer myself, but I think it&#39;s harder to create a good bot than to detect a bot. The real problem for anti bot companies is to reduce the false positive rate, not detecting most bots.</p>
<p>The main reason that makes bots prone to detection is simple economics: In order to scrape millions of pages, bot programmers put their browsers into docker containers and orchestrate them with docker swarm. Others use Kubernetes to orchestrate scraping clusters. And of course they will use cloud providers such as Hetzner, AWS or Digitalocean to host their bots. Nobody uses their MacBook Pro to run 20 Chrome Docker images over night. </p>
<p>The above described architecture is highly non-humanlike. What sane human being is browsing Instagram from within a docker container on a Hetzner VPS?!</p>
<p>Let&#39;s propose a scraping architecture that is not that easily detectable.</p>
<h2>An undetectable and scalable scraping infrastructure</h2>
<p>First let&#39;s proclaim the two laws of successful scraping: </p>
<ol>
<li>The second most important rule about evading anti bot companies is: <strong>You shall not lie about your browser configuration</strong>.</li>
<li>And the most important rule is: <strong>You shall only lie about your browser configuration if nobody catches you</strong>.</li>
</ol>
<p>Because I am not that good at reverse engineering those <a href="https://incolumitas.com/data/imperva.js">heavily obfuscated fingerprinting libraries</a> from anti bot companies, my suggestion is to just use real devices for scraping.</p>
<figure>
  <img src="https://incolumitas.com/images/shelf_closeup_790x.jpg" alt="phones man"/>
  <figcaption>Device Farm (Source: https://github.com/DeviceFarmer/stf)</figcaption>
</figure>

<p>If I would try to create a <em>undetectable</em> scraping service, I would probably buy 500 <a href="https://www.zdnet.com/article/best-phone-under-100/">cheap Android devices</a> (Starting at 58$ per device), maybe from 5 different manufacturers. We want diversity after all for fingerprinting reasons! You can also buy old (but more powerful) Android devices. If you buy 100 devices at once, you&#39;ll get a massive discount. </p>
<p>Then I would buy cheap data plans for the devices and I would control the devices with <a href="https://github.com/DeviceFarmer/stf">DeviceFarmer/stf</a> and rent some cheap storage space (With a mobile cellular antenna closeby) in five top major cities of the world such as London, Paris, Boston, Frankfurt and Los Angeles and put 100 phones in there each.</p>
<p>Then I install the lightweight Android Go on each device, throw out everything unnecessary that bloats my device and then plug it into a power source. Every 5 minutes I turn on/off airplane mode so my phone gets another IP address from the <a href="https://en.wikipedia.org/wiki/Carrier-grade_NAT">4G carrier grade NAT</a>.</p>
<p>Mobile IP addresses (4G, 5G, LTE) are practically un-bannable, because they are shared by up to hundred thousands of legitimate users in major cities. Instagram will never dare to ban 200.000 people in LA just because of some pesky spammers use the same IP! When Carrier Grade NATs were designed, <a href="https://www.ofcom.org.uk/__data/assets/pdf_file/0020/37802/cgnat.pdf">the designers knew about this issue</a>:</p>
<blockquote>
<p>In the event that an IPv4 address is blocked or blacklisted as a source of spam, the impact on a
CGN would be greater, potentially affecting an entire subscriber base. This would increase cost
and support load for the ISP, and, as we have seen earlier, damage its IP reputation.</p>
</blockquote>
<p>Do you think IPv6 comes to a rescue? Think again! Most anti bot companies give little to no IP reputation to IPv6 addresses, because the address space is so insanely vast.</p>
<p>One problem with the setup described above is that I will need to spoof those pesky <code>deviceorientation</code> and <code>devicemotion</code> <a href="https://developer.mozilla.org/en-US/docs/Web/Events/Detecting_device_orientation">JavaScript events</a> on a kernel level, because no real device is laying on the ground without rotation/movement all day long. Every website can access rotation and velocity data from Android data without asking for permission. So we have to spoof that.</p>
<p>But apart from that, I cannot see a way how bot detection systems are going to block this scraping infrastructure.</p>
<p>Of course the downsides are apparent: </p>
<ol>
<li>I have to buy 500 Android devices. I own already three of those things, I would go ballistic with 500 of them.</li>
<li>I need to rent storage space in major cities. That&#39;s expensive.</li>
<li>I need people in 5 cities to fix problems in the device farms.</li>
<li>I have to deal with hardware. I hate that. It causes problems non stop.</li>
</ol>
<p>So that would be a larger project, probably costing thousands of dollars in maintenance.</p>
<h3>Improvement: Emulate Android</h3>
<p>Instead of buying real Android devices, it would be better to emulate Android devices with Android emulators such as </p>
<ul>
<li><a href="https://www.android-x86.org/documentation/virtualbox.html">Android-x86 on VirtualBox</a></li>
<li><a href="https://www.bluestacks.com/de/index.html">bluestacks</a></li>
<li>Or the <a href="https://developer.android.com/studio/run/emulator">Android Studio Emulator</a></li>
</ul>
<p>Obviously, here we play with the devil again because we want to cut costs!</p>
<p>How are those pesky anti bot companies going to find out that we are emulating Android devices?</p>
<ol>
<li>An idea is to use browser based red pills that reveal that the browser is running in an emulated environment</li>
<li>Maybe they will launch <a href="https://incolumitas.com/2021/01/10/browser-based-port-scanning/">browser based port scans</a> against well known ports that are only running on emulated Android devices (such as <code>adb</code> service)?</li>
<li>Maybe Google sets some device wide <a href="https://support.google.com/googleplay/android-developer/answer/6048248?hl=en">advertisement ID&#39;s</a> on each mobile device? If this ID is missing or always stays the same, it could be a sign of suspicion.</li>
<li>Every website can find out whether you are logged into a Gmail or YouTube account with <a href="https://browserleaks.com/social">Social Media Login Detection</a>. No logged in Google account on Android equals suspicion!</li>
<li>There are probably 1000 more techniques that can be used to detect emulated Android devices</li>
</ol>
<p>Most likely, the Android emulators are imperfect and this imperfection is exhibited over the massive JavaScript API that each mobile browser offers to every website.</p>
<p>I am absolutely in favour of the emulation approach. This would mean that we only have to own several powerful servers, plug <a href="https://proxidize.com/">4G dongles into them</a> and we are ready to go. It could look like this (The image is taken from <a href="https://proxidize.com/">proxidize.com</a>): </p>
<figure>
  <img src="https://incolumitas.com/images/MicrosoftTeams-image-33.png.webp" alt="phones man"/>
  <figcaption>A couple of 4G dongles that I use for my personal E-Mail checking and writing Whatsapp messages (Source: https://proxidize.com/gallery/)</figcaption>
</figure>

<p>What <a href="https://proxidize.com/">proxidize.com</a> is doing is offering 4G mobile proxies. I don&#39;t want proxies, because <a href="https://bot.incolumitas.com/proxy_detect.html">proxies are detectable by itself</a>. I want to directly use the 4G dongle from the Android emulator! No latency due to geographical discrepancy between Android emulator and proxy.</p>
<p>So in the end, the scraping infrastructure could look like this:</p>
<ol>
<li>Install one powerful scraping server with 50 4G dongles connected to it in one geographical location</li>
<li>For each scraping server, run 50-100 emulated Android devices.</li>
<li>Put this scraping station in 5 major cities.</li>
<li>A simple command &amp; control server orchestrates the 5 scraping stations.</li>
<li>Profit.</li>
</ol>
  </div></div>
  </body>
</html>
