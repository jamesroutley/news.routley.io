<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kidger.site/thoughts/jax-vs-julia/">Original</a>
    <h1>Jax vs. Julia (Vs PyTorch)</h1>
    
    <div id="readability-page-1" class="page"><div>
        
  <section class="page">
  <article>
    <header>
      
	  <em><a href="https://kidger.site/thoughts/">&lt; Back to &#34;Thoughts&#34;</a></em> | <em>Posted on May 3, 2022</em>
    </header>

    <p>A while ago there was an interesting thread on the Julia Discourse about the “state of machine learning in Julia”. I posted a response <a href="https://discourse.julialang.org/t/state-of-machine-learning-in-julia/74385/4">discussing the differences between Julia and Python (both JAX and PyTorch)</a>, and it seemed to be really well received!</p>
<p>Since then this topic seems to keep coming up, so I thought I’d tidy up that post and put it somewhere I could link to easily. Rather than telling all the people who ask for my opinion to go searching through the Julia Discourse until they find that one post… :D</p>
<p>To my mind <a href="https://github.com/google/jax">JAX</a> and <a href="https://kidger.site/thoughts/jax-vs-julia/julialang.org">Julia</a> are unquestionably the current state-of-the-art frameworks for autodifferentiation, scientific computing, and ML computing. So let’s dig into the differences.</p>
<div>
<p><span></span>What about PyTorch?</p><p>I used PyTorch throughout my whole PhD. But about a year ago I switched to JAX and haven’t looked back. At least for my use cases it’s faster and more feature-complete. I’ll discuss PyTorch a little bit in this post, but it won’t be the focus.</p></div>

<p><em>TL;DR? Julia is amazing, but I’m using JAX. Read on to find out why.</em></p>
<hr/>
<h2 id="similarities">Similarities</h2>
<p>First of all:</p>
<ul>
<li>JAX, with <a href="https://github.com/patrick-kidger/equinox">Equinox</a> for neural networks;</li>
<li>Julia, with <a href="https://github.com/FluxML/Flux.jl">Flux</a> for neural networks.</li>
</ul>
<p>are really – I mean <em>really</em> – similar.</p>
<p>Both represent models (such as neural networks) in the same way, as a tree of modules and parameters. What Equinox calls <code>equinox.Module</code> is what Flux calls <code>Flux.@functor</code>. What JAX calls <code>jax.tree_map</code> is what Julia calls <code>Flux.fmap</code>.</p>
<p>Both of them are based around just-in-time (JIT) compilers. That is, your code is compiled and optimised down to efficient machine code the first time it is run.</p>
<p>As such, both JAX and Julia have excellent speed at runtime. This is particularly noticeable when compared to PyTorch for scientific computing. Differential equation solvers are quite complicated, and here the overhead of PyTorch’s use of the Python interpreter starts to bite. <em>If you want to know more, check out Horace He’s excellent post on whether your operation is limited by compute, memory, or overhead: <a href="https://horace.io/brrr_intro.html">Making Deep Learning Go Brrrr From First Principles</a>.</em></p>
<p>Both JAX and Julia ubiquitously perform program transforms via <a href="https://en.wikipedia.org/wiki/Homoiconicity">homoiconicity</a>. For example, backpropagation is performed by parsing your code in reverse.</p>
<div>
<p><span></span>Homoiconicity</p><p>If you haven’t heard of homoiconicity before: this is the property of <em>being able to represent code as data</em>. For example, you could represent your code as a list of strings; one per line.</p>
<p>There are better ways of representing code than that though, of course. JAX has <a href="https://jax.readthedocs.io/en/latest/jaxpr.html">jaxprs</a>; Julia has <a href="https://docs.julialang.org/en/v1/manual/metaprogramming/">macros and metaprogramming</a>.</p>
<p>Either way, this allows you to write code that modifies other code. Once again using backpropagation as an example: rewriting your code to be evaluated in reverse order, so as to compute a gradient.</p></div>

<h2 id="where-does-julia-shine--where-is-jax-lacklustre">Where does Julia shine / where is JAX lacklustre?</h2>
<ol>
<li>
<p>Compilation speed.</p>
<p>Julia is substantially faster than JAX on this front. JAX is a lovely framework, but a substantial part of it – the part that computes its program transformations like <code>jax.vmap</code>, <code>jax.grad</code> etc. –  is written in Python. These tracing and transformation mechanisms are pretty complicated (more precisely, they have very deep call stacks), and these can simply take quite a long time for the Python interpreter to chug through.</p>
<p>Meanwhile, the Julia folks have put in <a href="https://docs.julialang.org/en/v1.8-dev/NEWS/#Compiler/Runtime-improvements">a lot of effort</a> to really speed up compile times, and it shows.</p>
</li>
<li>
<p>Introspection.</p>
<p>Julia offers tools like <code>@code_warntype</code>, <code>@code_native</code>, which you can use to see how your code is being compiled, what the generated assembly looks like, etc.</p>
<p>The closest you can get in JAX is the rather-wordy</p>
<div><pre><code data-lang="python"><span>print</span>(
    jax<span>.</span>jit(your_function)
    <span>.</span>lower(<span>*</span>args, <span>**</span>kwargs)
    <span>.</span>compile()
    <span>.</span>runtime_executable()
    <span>.</span>hlo_modules()[<span>0</span>]
    <span>.</span>to_string()
)
</code></pre></div><p>…which in any case only tends to print out an inscrutable mess of XLA. Eurgh.</p>
<p><em>For the uninitiated: XLA is the backend that JAX translates your code into, to efficiently compile it.</em></p>
<p>In turn this represents a lack of control over the XLA compiler, as it becomes difficult to verify whether any desired optimisations are really being compiled in. For example, <a href="https://github.com/google/jax/issues/9132">it’s not possible to check whether an array was updated in-place or out-of-place</a>, and very rarely odd performance bugs in the XLA compiler mean that <a href="https://github.com/patrick-kidger/diffrax/blob/15c2ab9145ab0eda69af22d98d27f8ed02c90977/diffrax/integrate.py#L248">adding dead code can improve runtime performance</a>. (!)</p>
</li>
<li>
<p>Julia is a programming language; JAX is a DSL.</p>
<p>JAX basically uses Python as a “metaprogramming language” that specifies how to build an XLA program. This means, for example, that we get things like <code>jax.lax.fori_loop</code> instead of native syntax for <code>for</code> loops. Unless you’re relatively practiced at JAX, it can be a bit tricky to read.</p>
</li>
</ol>
<h2 id="where-does-jax-shine--where-is-julia-lacklustre">Where does JAX shine / where is Julia lacklustre?</h2>
<ol>
<li>
<p>Documentation.</p>
<p>If I want to do the equivalent of <code>detach</code> in PyTorch or <code>jax.lax.stop_gradient</code> in JAX, how should I do that in Julia/Flux?</p>
<p>First of all, it’s not in the Flux documentation. Instead it’s in the documentation for a separate component library – Zygote. So you have to check both, and you have to know to check both.</p>
<p>Once you’ve determined which set of documentation you need to look in, there are the entirely separate <code>Zygote.dropgrad</code> and <code>Zygote.ignore</code>.</p>
<p>What’s the difference? Not specified. Will they sometimes throw mysterious errors? <a href="https://discourse.julialang.org/t/loaderror-when-using-interpolations-as-input-for-a-neural-ode/51224/6">Yes.</a> Do I actually know which to use at this point? Nope.</p>
<p>Meanwhile <a href="https://jax.readthedocs.io/">JAX’s documentation</a> is “fine”. The clear winner here is actually PyTorch, which has <a href="https://pytorch.org/docs/stable/index.html">much better documentation than either of the others</a>.</p>
</li>
<li>
<p>Gradient reliability.</p>
<p>I remember all too un-fondly a time in which one of my Julia models was failing to train. I spent multiple months on-and-off trying to get it working, trying every trick I could think of.</p>
<p>Eventually – eventually! – I found the error: Julia/Flux/Zygote was returning incorrect gradients. After having spent so much energy wrestling with points 1 and 2 above, this was the point where I simply gave up. Two hours of development work later, I had the model successfully training… in PyTorch. (And as you can probably guess, these days I’d use JAX.)</p>
</li>
<li>
<p>Code quality.</p>
<p>Okay – this is the big one. The fundamental problem here is that most Julia packages are written by academics, not professional software developers.</p>
<p>Academic code quality is famously poor, and the Julia ecosystem is no exception. Here’s a small sample of the issues plaguing the ecosystem:</p>
<p>(A) Taking compatibility seriously.</p>
<p>It’s pretty common to see posts on the Julia Discourse saying “XYZ library doesn’t work”, followed by a reply from one of the library maintainers stating something like “This is an upstream bug in the new version a.b.c of the ABC library, which XYZ depends upon. We’ll get a fix pushed ASAP.”</p>
<p>Getting fixes pushed ASAP is great, of course. What’s bad is that the error happened in the first place. In contrast this experience has essentially never cropped up for me as an end user of PyTorch or JAX.</p>
<p>(B) Dead code, unused local variables, …</p>
<p>Even in the major well-known well-respected Julia packages – I’ll avoid naming names – the source code has very obvious cases of unused local variables, dead code branches that can never be reached, etc.</p>
<p>In Python these are things that a linter (or code review!) would catch. And the use of such linters is ubiquitous. (Moreover in something like Rust, the compiler would catch these errors as well.) Meanwhile Julia simply hasn’t reached the same level of professionalism.</p>
<p>(C) Math variable names.</p>
<p>Many Julia APIs look like <code>Optimiser(η=...)</code> rather than <code>Optimiser(learning_rate=...)</code>. This is a pretty unreadable convention.</p>
<p>(D) Inscrutable errors.</p>
<p>When misusing a Julia library, the errors tend to be pretty unhelpful. For example it’s pretty common to get errors about missing methods – essentially, that you called a function with inputs of the wrong type – somewhere internal to a library.</p>
<p>This isn’t a problem with Julia so much as a problem with library authors failing to write out readable errors for common misuses. The result is that the end-user really has to understand the internals of the library to understand what went wrong.</p>
<p>Moreover, a few times I’ve had cases where what I did was theoretically correct, and the error was actually reflective of a bug in the library! (Incidentally, Julia does provide very few tools to library authors to verify the correctness of their work.)</p>
<p>Put simply, the trial-and-error development process in Julia is slow.</p>
</li>
<li>
<p>Array syntax.</p>
<p>In Julia, <code>A[1]</code> and <code>A[1, :]</code> do different things. The first one will implicitly flatten the array before performing the indexing. This is not functionality I have needed so frequently that it really needed special syntax.</p>
<p>When slicing, Julia makes copies by default, and you need to use the <code>@view</code> macro to avoid this. This is a silent performance footgun.</p>
<p>Julia doesn’t have an equivalent of Python’s <code>...</code>, which means something NumPy-like <code>A[..., 1, :]</code> instead becomes <code>selectdim(A, ndims(A) - 1, 1)</code>.</p>
<p>Array manipulation is such an important part of ML, but collectively this kind of thing really hinders usability and readability. One gets there in the end, of course, but I find my PyTorch/JAX code to simply be prettier to read and easier to understand.</p>
</li>
</ol>
<h2 id="conclusion">Conclusion</h2>
<p>JAX is great. Whilst I’ve not discussed this in this post, if you ever dig into the internals of JAX then you’ll find that it’s a technical marvel. (See <a href="https://jax.readthedocs.io/en/latest/autodidax.html">Autodidax</a> for the advanced user.)</p>
<p>The Julia language is great. My criticisms above are primarily of its ML ecosystem (not the language) so with some effort I could see these being fixed. In a few years, perhaps I’ll be using Julia instead.</p>
<p>And yes, also: PyTorch is great. It has a good deployment story, and it has a mature ecosystem. Nonetheless I do find it to be noticeably too slow for the kinds of workloads (mostly based around differential equations) that I tend to put on it.</p>
<p>I maintain libraries for all of PyTorch, JAX, and Julia. But of these, I definitely enjoy maintaining and working with my JAX libraries the most!</p>
<p>And so to conclude on that note: if you’re using JAX, or thinking of switching, then do look at <a href="https://github.com/patrick-kidger/equinox">Equinox</a> and <a href="https://github.com/patrick-kidger/diffrax">Diffrax</a>, which are my libraries for neural networks and differential equation solvers respectively. So far they’ve been <a href="https://www.reddit.com/r/MachineLearning/comments/u34oh2/d_what_jax_nn_library_to_use/">pretty well received</a> – about ~1000 GitHub stars between them, at the time of writing this post – so give them a try and let me know what you think.</p>

  </article>
</section>

  

      </div></div>
  </body>
</html>
