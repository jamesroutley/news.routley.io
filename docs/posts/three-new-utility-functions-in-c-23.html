<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mariusbancila.ro/blog/2022/11/08/three-new-utility-functions-in-cpp23/">Original</a>
    <h1>Three new utility functions in C&#43;&#43;23</h1>
    
    <div id="readability-page-1" class="page"><article id="post-4554">

	

	
	<div>
		
<p>Some time ago I wrote a blog post called <a href="https://mariusbancila.ro/blog/2022/01/17/three-cpp23-features-for-common-use/" target="_blank" rel="noopener" title="">Three C++23 features for common use</a>. In this article, I want to continue on that idea and discuss three new utility functions that were added to C++23.</p>



<h3>std::unreachable</h3>



<p>This new function is available in the <code>&lt;utility&gt;</code> header. It’s intended to be used when you know you have an execution path in your code that cannot be reached but the compiler cannot figure that out. Informing the compiler could help to optimize impossible code branches.</p>



<p>A typical use case for this function are switch statements on a variable that can take only a limited set of values from its domain. For instance, an integer that can only be between 0 – 9. Here is a simple example with a switch that checks a <code>char</code> value and executes operations. Only a limited number of commands are supported but the argument is checked before invoking the function so it shouldn’t be possible to receive other values than already handled in the switch.</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">void execute_command(char ch)
{
   switch (ch)
   {
   case &#39;a&#39;:
      /* add */ break;
   case &#39;d&#39;:
      /* delete */ break;
   default:
      std::unreachable();
   }
}

bool is_valid(char ch)
{
   return ch == &#39;a&#39; || ch == &#39;d&#39;;
}

int main()
{
   char ch = 0;
   while (!is_valid(ch))
      std::cin &gt;&gt; ch;
   execute_command(ch);
}</pre>



<p>It could be argued though that it might be safer to handle the default case in some way to ensure safe failure rather than assume that a variable/argument would always take a limited number of values. This depends on the particularities of your code.</p>



<p>It should be noted that <code>std::unreachable</code> invokes undefined behavior. </p>



<p><strong>Learn more</strong></p>



<ul><li><a href="https://en.cppreference.com/w/cpp/utility/unreachable" target="_blank" rel="noopener" title="">std::unreachable</a></li><li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0627r6.pdf" target="_blank" rel="noopener" title="">P0627R6: Function to mark unreachable code</a></li></ul>



<h3>std::to_underlying</h3>



<p>This is yet another utility function from the <code>&lt;utility&gt;</code> header. It converts an enumeration to its underlying type. It is basically syntactic sugar for the expression <code>static_cast&lt;std::underlying_type_t&lt;Enum&gt;&gt;(e)</code>.</p>



<p>Let’s look at an example. Consider the following program:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">void apply_style(int style)
{
   std::cout &lt;&lt; std::format(&#34;applying style {}\n&#34;, style);
}

enum class styles
{
   A = 0x1,
   B = 0x2,
   C = 0x8000
};

int main()
{
   apply_style(static_cast&lt;int&gt;(styles::C));
}</pre>



<p>You need a <code>static_cast</code> to convert from the scoped enum <code>styles</code> to <code>int</code>. This can be simplified using <code>std::to_underlying</code>, as follows:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">int main()
{
   apply_style(std::to_underlying(styles::C));
}</pre>



<p>The <code>static_cast</code> is actually moved to the body of this function, whose implementation can be as follows:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">template &lt;typename Enum&gt;
constexpr auto to_underlying(Enum e) noexcept
{
    return static_cast&lt;std::underlying_type_t&lt;Enum&gt;&gt;(e);
}</pre>



<p><strong>Learn more</strong></p>



<ul><li><a href="https://en.cppreference.com/w/cpp/utility/to_underlying" target="_blank" rel="noopener" title="">std::to_underlying</a></li><li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1682r3.html" target="_blank" rel="noopener" title="">P1682R3 std::to_underlying for enumerations</a></li></ul>



<h3>std::byteswap</h3>



<p>This utility function is available in the <code>&lt;bit&gt;</code> header and reverses the bytes of an integral value. This is an addition to the bit utilities added with this header in C++20. Its purpose is to allow developers perform this byte reversal in a performant way without relying to compiler intrinsics.</p>



<p>Here is an example:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">template &lt;std::integral T&gt;
void print_hex(T v)
{
   for (std::size_t i = 0; i &lt; sizeof(T); ++i, v &gt;&gt;= 8)
   {
      std::cout &lt;&lt; std::format(&#34;{:02X} &#34;, static_cast&lt;unsigned&gt;(T(0xFF) &amp; v));
   }
   std::cout &lt;&lt; &#39;\n&#39;;
}

int main()
{
   unsigned char a = 0xBA;
   print_hex(a);                    // BA
   print_hex(std::byteswap(a));     // BA

   unsigned short b = 0xBAAD;
   print_hex(b);                    // AD BA
   print_hex(std::byteswap(b));     // BA AD

   int c = 0xBAADF00D;
   print_hex(c);                    // 0D F0 AD BA
   print_hex(std::byteswap(c));     // BA AD F0 0D

   long long d = 0xBAADF00DBAADC0FE;
   print_hex(d);                    // FE C0 AD BA 0D F0 AD BA
   print_hex(std::byteswap(d));     // BA AD F0 0D BA AD C0 FE
}</pre>



<p>Byte swapping is important when transferring data between system that use different order for the sequence of bytes stores in memory. This is called endianness. In Big Endian systems, the most significant byte is stored at the smaller address (first). In Little Endian systems, the least significant byte is stored at the smaller address. x86/x64 architectures use the little endian format. ARM supports both little and big endianness. Network protocols specify big endian for the order of transmission which requires swapping to/from systems using little endian order.</p>



<p><strong>Learn more</strong></p>



<ul><li><a href="https://en.cppreference.com/w/cpp/numeric/byteswap" target="_blank" rel="noopener" title="">std::byteswap</a></li><li><a href="https://isocpp.org/files/papers/P1272R4.html" target="_blank" rel="noopener" title="">P1272R4 Byteswapping for fun&amp;&amp;nuf</a></li></ul>



<hr/>



<p>All these utility functions are supported by the major compilers. You can check the compiler support matrix <a href="https://en.cppreference.com/w/cpp/compiler_support/23" target="_blank" rel="noopener" title="">here</a>.</p>





	</div><!-- .entry-content -->

	</article></div>
  </body>
</html>
