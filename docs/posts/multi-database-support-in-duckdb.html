<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://duckdb.org/2024/01/26/multi-database-support-in-duckdb.html">Original</a>
    <h1>Multi-database support in DuckDB</h1>
    
    <div id="readability-page-1" class="page"><div>
					
						<div>
							<p><span>2024-01-26</span><span>Mark Raasveldt</span></p>
							
							<p><em>TL;DR: DuckDB can attach MySQL, Postgres, and SQLite databases in addition to databases stored in its own format. This allows data to be read into DuckDB and moved between these systems in a convenient manner.</em></p>

<p><img src="https://duckdb.org/images/blog/duckdb-multidb-support.png" alt="DuckDB supports reading and writing to MySQL, Postgres, and SQLite" width="700"/></p>

<p>In modern data analysis, data must often be combined from a wide variety of different sources. Data might sit in CSV files on your machine, in Parquet files in a data lake, or in an operational database. DuckDB has strong support for moving data between many different data sources. However, this support has previously been limited to reading data and writing data to files.</p>

<p>DuckDB supports advanced operations on its own native storage format – such as deleting rows, updating values, or altering the schema of a table. It supports all of these operations using ACID semantics. This guarantees that your database is always left in a sane state – operations are atomic and do not partially complete.</p>

<p>DuckDB now has a pluggable storage and transactional layer. This flexible layer allows new storage back-ends to be created by DuckDB extensions. These storage back-ends can support all database operations in the same way that DuckDB supports them, including inserting data and even modifying schemas.</p>

<p>The <a href="https://duckdb.org/docs/extensions/mysql">MySQL</a>, <a href="https://duckdb.org/docs/extensions/postgres">Postgres</a>, and <a href="https://duckdb.org/docs/extensions/sqlite">SQLite</a> extensions implement this new pluggable storage and transactional layer, allowing DuckDB to connect to those systems and operate on them in the same way that it operates on its own native storage engine.</p>

<p>These extensions enable a number of useful features. For example, using these extensions you can:</p>

<ul>
  <li>Export data from SQLite to JSON</li>
  <li>Read data from Parquet into Postgres</li>
  <li>Move data from MySQL to Postgres</li>
</ul>

<p>… and much more.</p>
      <h2 id="attaching-databases">
        
        <a href="#attaching-databases">Attaching Databases</a>
        
      </h2>
    

<p>The <a href="https://duckdb.org/docs/sql/statements/attach"><code>ATTACH</code> statement</a> can be used to attach a new database to the system. By default, a native DuckDB file will be attached. The <code>TYPE</code> parameter can be used to specify a different storage type. Alternatively, the <code>{type}:</code> prefix can be used.</p>

<p>For example, using the SQLite extension, we can open <a href="https://github.com/duckdb/sqlite_scanner/raw/main/data/db/sakila.db">a SQLite database file</a> and query it as we would query a DuckDB database.</p>

<div><div><pre><code><span>ATTACH</span> <span>&#39;sakila.db&#39;</span> <span>AS</span> <span>sakila</span> <span>(</span><span>TYPE</span> <span>sqlite</span><span>);</span>
<span>SELECT</span> <span>title</span><span>,</span> <span>release_year</span><span>,</span> <span>length</span> <span>FROM</span> <span>sakila</span><span>.</span><span>film</span> <span>LIMIT</span> <span>5</span><span>;</span>
</code></pre></div></div>
<div><div><pre><code>┌──────────────────┬──────────────┬────────┐
│      title       │ release_year │ length │
│     varchar      │   varchar    │ int64  │
├──────────────────┼──────────────┼────────┤
│ ACADEMY DINOSAUR │ 2006         │     86 │
│ ACE GOLDFINGER   │ 2006         │     48 │
│ ADAPTATION HOLES │ 2006         │     50 │
│ AFFAIR PREJUDICE │ 2006         │    117 │
│ AFRICAN EGG      │ 2006         │    130 │
└──────────────────┴──────────────┴────────┘
</code></pre></div></div>

<p>The <code>USE</code> command switches the main database.</p>

<div><div><pre><code><span>USE</span> <span>sakila</span><span>;</span>
<span>SELECT</span> <span>first_name</span><span>,</span> <span>last_name</span> <span>FROM</span> <span>actor</span> <span>LIMIT</span> <span>5</span><span>;</span>
</code></pre></div></div>
<div><div><pre><code>┌────────────┬──────────────┐
│ first_name │  last_name   │
│  varchar   │   varchar    │
├────────────┼──────────────┤
│ PENELOPE   │ GUINESS      │
│ NICK       │ WAHLBERG     │
│ ED         │ CHASE        │
│ JENNIFER   │ DAVIS        │
│ JOHNNY     │ LOLLOBRIGIDA │
└────────────┴──────────────┘
</code></pre></div></div>

<p>The SQLite database can be manipulated as if it were a native DuckDB database. For example, we can create a new table, populate it with values from a Parquet file, delete a few rows from the table and alter the schema of the table.</p>

<div><div><pre><code><span>CREATE</span> <span>TABLE</span> <span>lineitem</span> <span>AS</span> <span>FROM</span> <span>&#39;lineitem.parquet&#39;</span> <span>LIMIT</span> <span>1000</span><span>;</span>
<span>DELETE</span> <span>FROM</span> <span>lineitem</span> <span>WHERE</span> <span>l_returnflag</span> <span>=</span> <span>&#39;N&#39;</span><span>;</span>
<span>ALTER</span> <span>TABLE</span> <span>lineitem</span> <span>DROP</span> <span>COLUMN</span> <span>l_comment</span><span>;</span>
</code></pre></div></div>

<p>The <code>duckdb_databases</code> table contains a list of all attached databases and their types.</p>

<div><div><pre><code><span>SELECT</span> <span>database_name</span><span>,</span> <span>path</span><span>,</span> <span>type</span> <span>FROM</span> <span>duckdb_databases</span><span>;</span>
<span>┌───────────────┬───────────┬─────────┐</span>
<span>│</span> <span>database_name</span> <span>│</span>   <span>path</span>    <span>│</span>  <span>type</span>   <span>│</span>
<span>│</span>    <span>varchar</span>    <span>│</span>  <span>varchar</span>  <span>│</span> <span>varchar</span> <span>│</span>
<span>├───────────────┼───────────┼─────────┤</span>
<span>│</span> <span>sakila</span>        <span>│</span> <span>sakila</span><span>.</span><span>db</span> <span>│</span> <span>sqlite</span>  <span>│</span>
<span>│</span> <span>memory</span>        <span>│</span> <span>NULL</span>      <span>│</span> <span>duckdb</span>  <span>│</span>
<span>└───────────────┴───────────┴─────────┘</span>
</code></pre></div></div>
      <h2 id="mix-and-match">
        
        <a href="#mix-and-match">Mix and Match</a>
        
      </h2>
    

<p>While attaching to different database types is useful – it becomes even more powerful when used in combination. For example, we can attach both a SQLite, MySQL and a Postgres database.</p>

<div><div><pre><code><span>ATTACH</span> <span>&#39;sqlite:sakila.db&#39;</span> <span>AS</span> <span>sqlite</span><span>;</span>
<span>ATTACH</span> <span>&#39;postgres:dbname=postgresscanner&#39;</span> <span>AS</span> <span>postgres</span><span>;</span>
<span>ATTACH</span> <span>&#39;mysql:user=root database=mysqlscanner&#39;</span> <span>AS</span> <span>mysql</span><span>;</span>
</code></pre></div></div>

<p>Now we can move data between these attached databases and query them together. Let’s copy the <code>film</code> table to MySQL, and the <code>actor</code> table to Postgres:</p>

<div><div><pre><code><span>CREATE</span> <span>TABLE</span> <span>mysql</span><span>.</span><span>film</span> <span>AS</span> <span>FROM</span> <span>sqlite</span><span>.</span><span>film</span><span>;</span>
<span>CREATE</span> <span>TABLE</span> <span>postgres</span><span>.</span><span>actor</span> <span>AS</span> <span>FROM</span> <span>sqlite</span><span>.</span><span>actor</span><span>;</span>
</code></pre></div></div>

<p>We can now join tables from these three attached databases together. Let’s find all of the actors that starred in <code>Ace Goldfinger</code>.</p>

<div><div><pre><code><span>SELECT</span> <span>first_name</span><span>,</span> <span>last_name</span>
<span>FROM</span> <span>mysql</span><span>.</span><span>film</span>
<span>JOIN</span> <span>sqlite</span><span>.</span><span>film_actor</span> <span>ON</span> <span>(</span><span>film</span><span>.</span><span>film_id</span> <span>=</span> <span>film_actor</span><span>.</span><span>film_id</span><span>)</span>
<span>JOIN</span> <span>postgres</span><span>.</span><span>actor</span> <span>ON</span> <span>(</span><span>actor</span><span>.</span><span>actor_id</span> <span>=</span> <span>film_actor</span><span>.</span><span>actor_id</span><span>)</span>
<span>WHERE</span> <span>title</span> <span>=</span> <span>&#39;ACE GOLDFINGER&#39;</span><span>;</span>
</code></pre></div></div>
<div><div><pre><code>┌────────────┬───────────┐
│ first_name │ last_name │
│  varchar   │  varchar  │
├────────────┼───────────┤
│ BOB        │ FAWCETT   │
│ MINNIE     │ ZELLWEGER │
│ SEAN       │ GUINESS   │
│ CHRIS      │ DEPP      │
└────────────┴───────────┘
</code></pre></div></div>

<p>Running <code>EXPLAIN</code> on the query shows how the data from the different engines is combined into the final query result.</p>

<div><div><pre><code><span>┌───────────────────────────┐</span>                                                          
<span>│</span>         <span>PROJECTION</span>        <span>│</span>                                                          
<span>│</span>   <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span>   <span>│</span>                                                          
<span>│</span>         <span>first_name</span>        <span>│</span>                                                          
<span>│</span>         <span>last_name</span>         <span>│</span>                                                          
<span>└─────────────┬─────────────┘</span>                                                                                       
<span>┌─────────────┴─────────────┐</span>                                                          
<span>│</span>         <span>HASH_JOIN</span>         <span>│</span>                                                          
<span>│</span>   <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span>   <span>│</span>                                                          
<span>│</span>           <span>INNER</span>           <span>│</span>                                                          
<span>│</span>     <span>film_id</span> <span>=</span> <span>film_id</span>     <span>├───────────────────────────────────────────┐</span>              
<span>└─────────────┬─────────────┘</span>                                           <span>│</span>                                           
<span>┌─────────────┴─────────────┐</span>                             <span>┌─────────────┴─────────────┐</span>
<span>│</span>         <span>HASH_JOIN</span>         <span>│</span>                             <span>│</span>           <span>FILTER</span>          <span>│</span>
<span>│</span>   <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span>   <span>│</span>                             <span>│</span>   <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span>   <span>│</span>
<span>│</span>           <span>INNER</span>           <span>│</span>                             <span>│</span> <span>(</span><span>title</span> <span>=</span> <span>&#39;ACE GOLDFINGER&#39;</span><span>)</span><span>│</span>
<span>│</span>    <span>actor_id</span> <span>=</span> <span>actor_id</span>    <span>├──────────────┐</span>              <span>│</span>                           <span>│</span>
<span>└─────────────┬─────────────┘</span>              <span>│</span>              <span>└─────────────┬─────────────┘</span>                             
<span>┌─────────────┴─────────────┐┌─────────────┴─────────────┐┌─────────────┴─────────────┐</span>
<span>│</span>        <span>SQLITE_SCAN</span>        <span>││</span>       <span>POSTGRES_SCAN</span>       <span>││</span>        <span>MYSQL_SCAN</span>         <span>│</span>
<span>│</span>   <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span>   <span>││</span>   <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span>   <span>││</span>   <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span>   <span>│</span>
<span>│</span>    <span>sakila</span><span>.</span><span>db</span><span>:</span><span>film_actor</span>   <span>││</span>           <span>actor</span>           <span>││</span>            <span>film</span>           <span>│</span>
<span>│</span>   <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span>   <span>││</span>   <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span>   <span>││</span>   <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span> <span>─</span>   <span>│</span>
<span>│</span>          <span>film_id</span>          <span>││</span>          <span>actor_id</span>         <span>││</span>          <span>film_id</span>          <span>│</span>
<span>│</span>          <span>actor_id</span>         <span>││</span>         <span>first_name</span>        <span>││</span>           <span>title</span>           <span>│</span>
<span>│</span>                           <span>││</span>         <span>last_name</span>         <span>││</span>                           <span>│</span>
<span>└───────────────────────────┘└───────────────────────────┘└───────────────────────────┘</span> 
</code></pre></div></div>

<blockquote>
  <p>Several changes have been made to Postgres extension since the last release. Use <code>FORCE INSTALL postgres</code> to install the latest version of the extension.</p>
</blockquote>
      <h2 id="transactions">
        
        <a href="#transactions">Transactions</a>
        
      </h2>
    

<p>All statements executed within DuckDB are executed within a transaction. If an explicit <code>BEGIN TRANSACTION</code> is not called, every statement will execute in its own transaction. This also applies to queries that are executed over other storage engines. These storage engines also support explicit <code>BEGIN</code>, <code>COMMIT</code> and <code>ROLLBACK</code> statements.</p>

<p>For example, we can begin a transaction within our attached <code>SQLite</code> database, make a change, and then roll it back. The original data will be restored.</p>

<div><div><pre><code><span>BEGIN</span><span>;</span>
<span>TRUNCATE</span> <span>film</span><span>;</span>
<span>SELECT</span> <span>title</span><span>,</span> <span>release_year</span><span>,</span> <span>length</span> <span>FROM</span> <span>film</span><span>;</span>
</code></pre></div></div>
<div><div><pre><code>┌─────────┬──────────────┬────────┐
│  title  │ release_year │ length │
│ varchar │   varchar    │ int64  │
├─────────────────────────────────┤
│             0 rows              │
└─────────────────────────────────┘
</code></pre></div></div>
<div><div><pre><code><span>ROLLBACK</span><span>;</span>
<span>SELECT</span> <span>title</span><span>,</span> <span>release_year</span><span>,</span> <span>length</span> <span>FROM</span> <span>film</span> <span>LIMIT</span> <span>5</span><span>;</span>
</code></pre></div></div>
<div><div><pre><code>┌──────────────────┬──────────────┬────────┐
│      title       │ release_year │ length │
│     varchar      │   varchar    │ int64  │
├──────────────────┼──────────────┼────────┤
│ ACADEMY DINOSAUR │ 2006         │     86 │
│ ACE GOLDFINGER   │ 2006         │     48 │
│ ADAPTATION HOLES │ 2006         │     50 │
│ AFFAIR PREJUDICE │ 2006         │    117 │
│ AFRICAN EGG      │ 2006         │    130 │
└──────────────────┴──────────────┴────────┘
</code></pre></div></div>
      <h3 id="multi-database-transactions">
        
        <a href="#multi-database-transactions">Multi-Database Transactions</a>
        
      </h3>
    

<p>Every storage engine has their own transactions that are stand-alone and managed by the storage engine itself. Opening a transaction in Postgres, for example, calls <code>BEGIN TRANSACTION</code> in the Postgres client. The transaction is managed by Postgres itself. Similarly, when the transaction is committed or rolled back, the storage engine handles this by itself.</p>

<p>Transactions are used both for <strong>reading</strong> and for <strong>writing</strong> data. For reading data, they are used to provide a consistent snapshot of the database. For writing, they are used to ensure all data in a transaction is packed together and written at the same time.</p>

<p>When executing a transaction that involves multiple attached databases we need to open multiple transactions: one per attached database that is used in the transaction. While this is not a problem when <strong>reading</strong> from the database, it becomes complicated when <strong>writing</strong>. In particular, when we want to <code>COMMIT</code> a transaction it is challenging to ensure that either (a) every database has successfully committed, or (b) every database has rolled back.</p>

<p>For that reason, it is currently not supported to <strong>write</strong> to multiple attached databases in a single transaction. Instead, an error is thrown when this is attempted:</p>

<div><div><pre><code><span>BEGIN</span><span>;</span>
<span>CREATE</span> <span>TABLE</span> <span>postgres</span><span>.</span><span>new_table</span><span>(</span><span>i</span> <span>INT</span><span>);</span>
<span>CREATE</span> <span>TABLE</span> <span>mysql</span><span>.</span><span>new_table</span><span>(</span><span>i</span> <span>INT</span><span>);</span>
</code></pre></div></div>
<div><div><pre><code>Error: Attempting to write to database &#34;mysql&#34; in a transaction that has
already modified database &#34;postgres&#34; – a single transaction can only write
to a single attached database.
</code></pre></div></div>
      <h2 id="copying-data-between-databases">
        
        <a href="#copying-data-between-databases">Copying Data Between Databases</a>
        
      </h2>
    

<p><code>CREATE TABLE AS</code>, <code>INSERT INTO</code> and <code>COPY</code> can be used to copy data between different attached databases. The dedicated <a href="https://duckdb.org/docs/sql/statements/copy.html#copy-from-database--to"><code>COPY FROM DATABASE ... TO</code></a> can be used to copy all data from one database to another. This includes all tables and views that are stored in the source database.</p>

<div><div><pre><code><span>-- attach a Postgres database</span>
<span>ATTACH</span> <span>&#39;postgres:dbname=postgresscanner&#39;</span> <span>AS</span> <span>postgres</span><span>;</span>
<span>-- attach a DuckDB file</span>
<span>ATTACH</span> <span>&#39;database.db&#39;</span> <span>AS</span> <span>ddb</span><span>;</span>
<span>-- export all tables and views from the Postgres database to the DuckDB file</span>
<span>COPY</span> <span>FROM</span> <span>DATABASE</span> <span>postgres</span> <span>TO</span> <span>ddb</span><span>;</span>
</code></pre></div></div>

<p>Note that this statement is currently only available in the development build. It will be available in the next DuckDB release (v0.10).</p>
      <h2 id="directly-opening-a-database">
        
        <a href="#directly-opening-a-database">Directly Opening a Database</a>
        
      </h2>
    

<p>The explicit <code>ATTACH</code> statement is not required to connect to a different database type. When instantiating a DuckDB instance a connection can be made directly to a different database type using the <code>{type}:</code> prefix. For example, to connect to a SQLite file, use <code>sqlite:file.db</code>. To connect to a Postgres instance, use <code>postgres:dbname=postgresscanner</code>. This can be done in any client, including the CLI. For instance:</p>

<p><strong>CLI:</strong></p>



<p><strong>Python:</strong></p>

<div><div><pre><code><span>import</span> <span>duckdb</span>
<span>con</span> <span>=</span> <span>duckdb</span><span>.</span><span>connect</span><span>(</span><span>&#39;sqlite:file.db&#39;</span><span>)</span>
</code></pre></div></div>

<p>This is equivalent to attaching the storage engine and running <code>USE</code> afterwards.</p>
      <h2 id="conclusion">
        
        <a href="#conclusion">Conclusion</a>
        
      </h2>
    

<p>DuckDB’s pluggable storage engine architecture enables many use cases. By attaching multiple databases, data can be extracted in a transactionally safe manner for bulk ETL or ELT workloads, as well as for on-the-fly data virtualization workloads. These techniques also work well in combination, for example, by moving data in bulk on a regular cadence, while filling in the last few data points on the fly.</p>

<p>Pluggable storage engines also unlock new ways to handle concurrent writers in a data platform. Each separate process could write its output to a transactional database, and the results could be combined within DuckDB – all in a transactionally safe manner. Then, data analysis tasks can occur on the centralized DuckDB database for improved performance.</p>

<p>We look forward to hearing the many creative ways you are able to use this feature!</p>
      <h2 id="future-work">
        
        <a href="#future-work">Future Work</a>
        
      </h2>
    

<p>We intend to continue enhancing the performance and capabilities of the existing extensions. In addition, all of these features can be leveraged by the community to connect to other databases.</p>

							<p><a href="https://duckdb.org/news/">back to news archive <span></span></a>
						</p></div>
					
				</div></div>
  </body>
</html>
