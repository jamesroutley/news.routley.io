<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://podviaznikov.com/readings/the-unbearable-lightness-of-being">Original</a>
    <h1>The Unbearable Lightness of Being</h1>
    
    <div id="readability-page-1" class="page"><div>
                <menu><menuitem><h6><label for="table-of-contents-toggle">Contents</label></h6><ul><li><a href="#the-basics-of-how-to-use-has-as-a-parent-selector">The basics of how to use :has() as a parent selector</a></li><li><a href="#a-practical-example-using-has-with-css-grid">A practical example using :has() with CSS Grid</a></li><li><a href="#using-has-with-the-child-combinator">Using :has() with the child combinator</a></li><li><a href="#using-has-with-sibling-combinators">Using :has() with sibling combinators</a></li><li><a href="#styling-form-states-without-js">Styling form states without JS</a></li><li><a href="#dark-mode-toggle-with-no-js">Dark mode toggle with no JS</a></li><li><a href="#and-more">And more</a></li><li><a href="#the-has-revolution">The :has() revolution</a></li></ul></menuitem></menu>                
                <p>It’s been a long-standing dream of front-end developers to have a way to apply CSS to an element based on what’s happening inside that element.</p>
<p>Maybe we want to apply one layout to an article element if there’s a hero image at the top, and a different layout if there is no hero image. Or maybe we want to apply different styles to a form depending on the state of one of its input fields. How about giving a sidebar one background color if there’s a certain component in that sidebar, and a different background color if that component is not present? Use cases like these have been around for a long time, and web developers have repeatedly approached the CSS Working Group, begging them to invent a “parent selector”.</p>
<p>Over the last <a href="https://lists.w3.org/Archives/Public/www-style/2002May/0037.html">twenty years</a>, the CSS Working Group discussed the possibility many, many times. The need was clear and well understood. Defining syntax was a doable task. But figuring out how a browser engine could handle potentially very complex circular patterns, and get through the calculations fast enough seemed impossible. Early versions of a parent selector were drafted for CSS3, only to be deferred. Finally, the <code>:has()</code>  pseudo-class was officially defined in <a href="https://www.w3.org/TR/selectors-4/#relational">CSS Selectors level 4</a>. But having a web standard alone didn’t make <code>:has()</code> a reality. We still needed a browser team to figure out the very real performance challenge. In the meantime, computers continued to get more powerful and faster year after year.</p>
<p>In 2021, <a href="https://www.igalia.com/">Igalia</a> started advocating for <code>:has()</code> among browser engineering teams, <a href="https://bkardell.com/blog/canihas.html">prototyping</a> their ideas and <a href="https://github.com/Igalia/explainers/tree/main/css/has">documenting</a> their findings regarding performance. The renewed attention on <code>:has()</code> caught the attention of engineers who work on WebKit at Apple. We started implementing the pseudo-class, thinking through possibilities for the needed performance enhancements to make this work. We debated whether to start with a faster version with a very limited and narrow scope of what it could do, and then try to remove those limits if possible… or to start with something that had no limits, and only apply restrictions as required. We went for it, and implemented the more powerful version. We developed a number of novel <code>:has</code>-specific caching and filtering optimizations, and leveraged the existing advanced optimization strategies of our CSS engine. And our approach worked, proving that after a two decade wait, it is finally possible to implement such a selector with fantastic performance, even in the presence of large DOM trees and large numbers of <code>:has()</code> selectors.</p>
<p>The WebKit team shipped <code>:has()</code> in <a href="https://webkit.org/blog/12156/release-notes-for-safari-technology-preview-137/">Safari Technology Preview 137</a> in December 2021, and in <a href="https://webkit.org/blog/12445/new-webkit-features-in-safari-15-4/">Safari 15.4</a> on March 14, 2022. Igalia did the engineering work to implement <code>:has()</code> in Chromium, which will ship in <a href="https://groups.google.com/a/chromium.org/g/blink-dev/c/bRsbl3wLuyk/m/mt3iSKNHBQAJ?pli=1">Chrome 105</a> on August 30, 2022. Presumably the <a href="https://caniuse.com/?search=%3Ahas()">other browsers</a> built on Chromium won’t be far behind. Mozilla is currently <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=418039">working on</a> the Firefox implementation.</p>
<p>So, let’s take a step-by-step hands-on look at what web developers can do with this <a href="https://2020.stateofcss.com/en-US/opinions/#currently_missing_from_css">desperately desired</a> tool. It turns out, the <code>:has()</code> pseudo-class is not just a “parent selector”. After decades of dead-ends, this selector can do far more.</p>
<h2><a name="the-basics-of-how-to-use-has-as-a-parent-selector"></a>The basics of how to use :has() as a parent selector</h2>
<p>Let’s start with the basics. Imagine we want to style a <code>&lt;figure&gt;</code> element based on the kind of content in the figure. Sometimes our figure wraps only an image.</p>
<pre><code><span>&lt;<span>figure</span>&gt;</span>
  <span>&lt;<span>img</span> <span>src</span>=<span>&#34;flowers.jpg&#34;</span> <span>alt</span>=<span>&#34;spring flowers&#34;</span>&gt;</span>
<span>&lt;/<span>figure</span>&gt;</span>
</code></pre>
<p>While other times there’s an image with a caption.</p>
<pre><code><span>&lt;<span>figure</span>&gt;</span>
  <span>&lt;<span>img</span> <span>src</span>=<span>&#34;dog.jpg&#34;</span> <span>alt</span>=<span>&#34;black dog smiling in the sun&#34;</span>&gt;</span>
  <span>&lt;<span>figcaption</span>&gt;</span>Maggie loves being outside off-leash.<span>&lt;/<span>figcaption</span>&gt;</span>
<span>&lt;/<span>figure</span>&gt;</span>
</code></pre>
<p>Now let’s apply some styles to the <code>figure</code> that will only apply if there is a <code>figcaption</code> inside the figure.</p>
<pre><code><span>figure</span><span>:has</span>(<span>figcaption</span>) {
  <span>background</span>: <span>white</span>;
  <span>padding</span>: <span>0.6</span><span>rem</span>;
}
</code></pre>
<p>This selector means what it says — any <code>figure</code> element that <em>has</em> a <code>figcaption</code> inside will be selected.</p>
<p>Here’s the demo, if you’d like to alter the code and see what happens. Be sure to use a browser that <a href="https://caniuse.com/css-has">supports <code>:has()</code></a> — as of today, that’s Safari.</p>
<p data-height="810" data-default-tab="css,result" data-slug-hash="eYGKNYy" data-user="jensimmons">
  <span>See the Pen <a href="https://codepen.io/jensimmons/pen/eYGKNYy"></a> by Jen Simmons (<a href="https://codepen.io/jensimmons">@jensimmons</a>)</span>
</p>
<p>In this demo, I also target any <code>figure</code> that contains a <code>pre</code> element by using <code>figure:has(pre)</code>.</p>
<pre><code><span>figure</span><span>:has</span>(<span>pre</span>) { 
  <span>background</span>: <span>rgb</span>(<span>252</span>, <span>232</span>, <span>255</span>);
  <span>border</span>: <span>3px</span> <span>solid</span> <span>white</span>;
  <span>padding</span>: <span>1</span><span>rem</span>;
}
</code></pre>
<p>And I use a Selector Feature Query to hide a reminder about browser support whenever the current browser supports <code>:has()</code>.</p>
<pre><code><span>@supports</span> <span>selector</span>(<span>:has</span>(<span>img</span>)) {
  <span>small</span> {
    <span>display</span>: <span>none</span>;
  }
}
</code></pre>
<p>The <code>@supports selector()</code> at-rule is itself <a href="https://caniuse.com/mdn-css_at-rules_supports_selector">very well supported</a>. It can be incredibly useful anytime you want to use a <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Conditional_Rules/Using_Feature_Queries">feature query</a> to test for browser support of a particular selector.</p>
<p>And finally, in this first demo, I also write a complex selector using the <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:not"><code>:not() pseudo-class</code></a>. I want to apply <code>display: flex</code> to the figure — but only if an image is the sole content. Flexbox makes the image stretch to fill all available space.</p>
<p>I use a selector to target any <code>figure</code> that does <em>not</em> have any element that is <em>not</em> an image. If the <code>figure</code> has a <code>figcaption</code>,  <code>pre</code>,  <code>p</code>, or an <code>h1</code> — or any element at all besides <code>img</code> — then the selector doesn’t apply.</p>
<pre><code><span>figure</span><span>:not</span>(<span>:has</span>(<span>:not</span>(<span>img</span>))) {
  <span>display</span>: <span>flex</span>;
}
</code></pre>
<p><code>:has()</code> is a powerful thing.</p>
<h2><a name="a-practical-example-using-has-with-css-grid"></a>A practical example using :has() with CSS Grid</h2>
<p>Let’s look at a second demo where I’ve used <code>:has()</code> as a parent selector to easily solve a very practical need.</p>
<p>I have several article teaser cards laid out using CSS Grid. Some cards contain only headlines and text, while others also have an image. I want the cards with images to take up more space on the grid than those without images.</p>
<p>I don’t want to have to do extra work to get my content management system to apply a class or to use JavaScript for layout. I just want to write a simple selector in CSS that will tell the browser to make any teaser card with an image to take up two rows and two columns in the grid.</p>
<p>The <code>:has()</code> pseudo-class makes this simple:</p>
<pre><code><span>article</span><span>:has</span>(<span>img</span>) {
  <span>grid-column</span>: <span>span</span> <span>2</span>;
  <span>grid-row</span>: <span>span</span> <span>2</span>;
}
</code></pre>
<p data-height="700" data-default-tab="result" data-slug-hash="bGoMydw" data-user="jensimmons">
  <span>See the Pen <a href="https://codepen.io/jensimmons/pen/bGoMydw"></a> by Jen Simmons (<a href="https://codepen.io/jensimmons">@jensimmons</a>)</span>
</p>
<p>These first two demos use simple <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Type_selectors">element selectors</a> from the early days of CSS, but all of the selectors can be combined with <code>:has()</code>, including the <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Class_selectors">class selector</a>, the <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/ID_selectors">ID selector</a>, the <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors">attribute selector</a> — and powerful combinators.</p>
<h2><a name="using-has-with-the-child-combinator"></a>Using :has() with the child combinator</h2>
<p>First, a quick review of the difference between the <a href="https://www.w3.org/TR/selectors-4/#descendant-combinators">descendant combinator</a> and the <a href="https://www.w3.org/TR/selectors-4/#child-combinators">child combinator</a> (<code>&gt;</code>).</p>
<p>The descendant combinator has been around since the very beginning of CSS. It’s the fancy name for when we put a space between two simple selectors. Like this:</p>
<pre><code><span>a</span> <span>img</span> { ... }
</code></pre>
<p>This targets all <code>img</code> elements that are contained within an <code>a</code> element, no matter how far apart the <code>a</code> and the <code>img</code> are in the HTML DOM tree.</p>
<pre><code><span>&lt;<span>a</span>&gt;</span>
  <span>&lt;<span>figure</span>&gt;</span>
    <span>&lt;<span>img</span> <span>src</span>=<span>&#34;photo.jpg&#34;</span> <span>alt</span>=<span>&#34;don&#39;t forget alt text&#34;</span> <span>width</span>=<span>&#34;200&#34;</span> <span>height</span>=<span>&#34;100&#34;</span>&gt;</span>
  <span>&lt;/<span>figure</span>&gt;</span>
<span>&lt;/<span>a</span>&gt;</span>
</code></pre>
<p>Child combinator is the name for when we put an <code>&gt;</code> between two selectors — which tells the browser to target anything that matches the second selector, but only when the second selector is a direct child of the first.</p>
<pre><code><span>a</span> &gt; <span>img</span> { ... }
</code></pre>
<p>For example, this selector targets all <code>img</code> elements wrapped by an <code>a</code> element, but <em>only</em> when the <code>img</code> is immediately after the <code>a</code> in the HTML.</p>
<pre><code><span>&lt;<span>a</span>&gt;</span>
  <span>&lt;<span>img</span> <span>src</span>=<span>&#34;photo.jpg&#34;</span> <span>alt</span>=<span>&#34;don&#39;t forget alt text&#34;</span> <span>width</span>=<span>&#34;200&#34;</span> <span>height</span>=<span>&#34;100&#34;</span>&gt;</span>
<span>&lt;/<span>a</span>&gt;</span>
</code></pre>
<p>With that in mind, let’s consider the difference between the following two examples. Both select the <code>a</code> element, rather than the <code>img</code>, since we are using <code>:has()</code>.</p>
<pre><code><span>a</span><span>:has</span>(<span>img</span>) { ... }
</code></pre>
<pre><code><span>a</span><span>:has</span>(&gt; <span>img</span>) { ... }
</code></pre>
<p>The first selects any <code>a</code> element with an <code>img</code> inside — any place in the HTML structure. While the second selects an element only if the <code>img</code> is a direct child of the <code>a</code>.</p>
<p>Both can be useful; they accomplish different things.</p>
<p data-height="500" data-default-tab="css,result" data-slug-hash="BaYoWea" data-user="jensimmons">
  <span>See the Pen <a href="https://codepen.io/jensimmons/pen/BaYoWea"></a> by Jen Simmons (<a href="https://codepen.io/jensimmons">@jensimmons</a>)</span>
</p>
<p>There are two additional types of combinators — both are siblings. And it’s through these that <code>:has()</code> becomes more than a parent selector.</p>
<h2><a name="using-has-with-sibling-combinators"></a>Using :has() with sibling combinators</h2>
<p>Let’s review the two selectors with sibling relationships. There’s the <a href="https://www.w3.org/TR/selectors-4/#adjacent-sibling-combinators">next-sibling combinator</a> (<code>+</code>) and the <a href="https://www.w3.org/TR/selectors-4/#general-sibling-combinators">subsequent-sibling combinator</a> (<code>~</code>).</p>
<p>The next-sibling combinator (<code>+</code>)  selects only the paragraphs that come <em>directly</em> after an <code>h2</code> element.</p>
<pre><code><span>h2</span> + <span>p</span>
</code></pre>
<pre><code><span>&lt;<span>h2</span>&gt;</span>Headline<span>&lt;/<span>h2</span>&gt;</span>
<span>&lt;<span>p</span>&gt;</span>Paragraph that is selected by `h2 + p`, because it&#39;s directly after `h2`.<span>&lt;/<span>p</span>&gt;</span>
</code></pre>
<p>The subsequent-sibling combinator (<code>~</code>) selects all paragraphs that come after an <code>h2</code> element. They must be siblings, but there can be any number of other HTML elements in between.</p>
<pre><code><span>h2</span> ~ <span>p</span>
</code></pre>
<pre><code><span>&lt;<span>h2</span>&gt;</span>Headline<span>&lt;/<span>h2</span>&gt;</span>
<span>&lt;<span>h3</span>&gt;</span>Something else<span>&lt;/<span>h3</span>&gt;</span>
<span>&lt;<span>p</span>&gt;</span>Paragraph that is selected by `h2 ~ p`.<span>&lt;/<span>p</span>&gt;</span>
<span>&lt;<span>p</span>&gt;</span>This paragraph is also selected.<span>&lt;/<span>p</span>&gt;</span>
</code></pre>
<p>Note that both <code>h2 + p</code> and <code>h2 ~ p</code> select the paragraph elements, and not the <code>h2</code> headlines. Like other selectors (think of <code>a img</code>), it’s the last element listed that is targeted by the selector. But what if we want to target the <code>h2</code>? We can use sibling combinators with <code>:has().</code></p>
<p>How often have you wanted to adjust the margins on a headline based on the element following it? Now it’s easy. This code allows us to select any <code>h2</code> with a <code>p</code> immediately after it.</p>
<pre><code><span>h2</span><span>:has</span>(+ <span>p</span>) { <span>margin-bottom</span>: <span>0</span>; }
</code></pre>
<p>Amazing.</p>
<p>What if we want to do this for all six headline elements, without writing out six copies of the selector. We can use <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:is"><code>:is</code></a> to simplify our code.</p>
<pre><code><span>:is</span>(<span>h1</span>, <span>h2</span>, <span>h3</span>, <span>h4</span>, <span>h5</span>, <span>h6</span>)<span>:has</span>(+ <span>p</span>) { <span>margin-bottom</span>: <span>0</span>; }
</code></pre>
<p>Or what if we want to write this code for more elements than just paragrapahs? Let’s eliminate the bottom margin of all headlines whenever they are followed by paragraphs, captions, code examples and lists.</p>
<pre><code><span>:is</span>(<span>h1</span>, <span>h2</span>, <span>h3</span>, <span>h4</span>, <span>h5</span>, <span>h6</span>)<span>:has</span>(+ <span>:is</span>(<span>p</span>, <span>figcaption</span>, <span>pre</span>, <span>dl</span>, <span>ul</span>, <span>ol</span>)) { <span>margin-bottom</span>: <span>0</span>; }
</code></pre>
<p>Combining <code>:has()</code> with <a href="https://www.w3.org/TR/selectors-4/#descendant-combinators">descendant combinators</a>, <a href="https://www.w3.org/TR/selectors-4/#child-combinators">child combinators</a> (<code>&gt;</code>), <a href="https://www.w3.org/TR/selectors-4/#adjacent-sibling-combinators">next-sibling combinators</a> (<code>+</code>), and <a href="https://www.w3.org/TR/selectors-4/#general-sibling-combinators">subsequent-sibling combinators</a> (<code>~</code>) opens up a world of possibilities. But oh, this is <em>still</em> just the beginning.</p>
<h2><a name="styling-form-states-without-js"></a>Styling form states without JS</h2>
<p>There are a lot of fantastic <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes">pseudo-classes</a> that can be used inside has:(). In fact, it revolutionizes what pseudo-classes can do. Previously, pseudo-classes were only used for styling an element based on a special state — or styling one of its children. Now, pseudo-classes can be used to capture state, without JavaScript, and style anything in the DOM based on that state.</p>
<p>Form input fields provide a powerful way to capture such a state. Form-specific pseudo-classes include <code>:autofill</code>, <code>:enabled</code>, <code>:disabled</code>, <code>:read-only</code>, <code>:read-write</code>, <code>:placeholder-shown</code>, <code>:default</code>, <code>:checked</code>, <code>:indeterminate</code>, <code>:valid</code>, <code>:invalid</code>, <code>:in-range</code>, <code>:out-of-range</code>, <code>:required</code> and <code>:optional</code>.</p>
<p>Let’s solve one of the use cases I described in the introduction — the long-standing need to style a form label based on the state of the input field. Let’s start with a basic form.</p>
<pre><code><span>&lt;<span>form</span>&gt;</span>
  <span>&lt;<span>div</span>&gt;</span>
    <span>&lt;<span>label</span> <span>for</span>=<span>&#34;name&#34;</span>&gt;</span>Name<span>&lt;/<span>label</span>&gt;</span> 
    <span>&lt;<span>input</span> <span>type</span>=<span>&#34;text&#34;</span> <span>id</span>=<span>&#34;name&#34;</span>&gt;</span>
  <span>&lt;/<span>div</span>&gt;</span>
  <span>&lt;<span>div</span>&gt;</span>
    <span>&lt;<span>label</span> <span>for</span>=<span>&#34;site&#34;</span>&gt;</span>Website<span>&lt;/<span>label</span>&gt;</span> 
    <span>&lt;<span>input</span> <span>type</span>=<span>&#34;url&#34;</span> <span>id</span>=<span>&#34;site&#34;</span>&gt;</span>
  <span>&lt;/<span>div</span>&gt;</span>
  <span>&lt;<span>div</span>&gt;</span>
    <span>&lt;<span>label</span> <span>for</span>=<span>&#34;email&#34;</span>&gt;</span>Email<span>&lt;/<span>label</span>&gt;</span>
    <span>&lt;<span>input</span> <span>type</span>=<span>&#34;email&#34;</span> <span>id</span>=<span>&#34;email&#34;</span>&gt;</span>
  <span>&lt;/<span>div</span>&gt;</span>
<span>&lt;/<span>form</span>&gt;</span>
</code></pre>
<p>I’d like to apply a background to the whole form whenever one of the fields is in focus.</p>
<pre><code><span>form</span><span>:has</span>(<span>:focus-visible</span>) { 
  <span>background</span>: <span>antiquewhite</span>;
}
</code></pre>
<p>Now I could have used <code>form:focus-within</code> instead, but it would behave like <code>form:has(:focus)</code>. The <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:focus"><code>:focus</code></a> pseudo-class always applies CSS whenever a field is in focus. The  <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:focus-visible"><code>:focus-visible</code></a> pseudo-class provides a reliable way to style a focus indicator only when the browser would draw one natively, using the same <a href="https://webkit.org/blog/12179/the-focus-indicated-pseudo-class-focus-visible/">complex heuristics the browser uses</a> to determine whether or not to apply a focus-ring.</p>
<p>Now, let’s imagine I want to style the other fields, the ones <em>not</em> in focus — changing their label text color and the input border color. Before <code>:has()</code>, this required JavaScript. Now we can use this CSS.</p>
<pre><code><span>form</span><span>:has</span>(<span>:focus-visible</span>) <span>div</span><span>:has</span>(<span>input</span><span>:not</span>(<span>:focus-visible</span>)) <span>label</span> {
  <span>color</span>: <span>peru</span>;
}
<span>form</span><span>:has</span>(<span>:focus-visible</span>) <span>div</span><span>:has</span>(<span>input</span><span>:not</span>(<span>:focus-visible</span>)) <span>input</span> {
  <span>border</span>: <span>2px</span> <span>solid</span> <span>peru</span>;
}
</code></pre>
<p>What does that selector say? If one of the controls inside this form has focus, and the input element for this particular form control does not have focus, then change the color of this label’s text to <code>peru</code>. And change the border of the input field to be <code>2px solid peru</code>.</p>
<p>You can see this code in action in the following demo by clicking inside one of the text fields. The background of the form changes, as I described earlier. And the label and input border colors of the fields that are not in focus also change.</p>
<p data-height="530" data-default-tab="result" data-slug-hash="BarwGpV" data-user="jensimmons">
  <span>See the Pen <a href="https://codepen.io/jensimmons/pen/BarwGpV"></a> by Jen Simmons (<a href="https://codepen.io/jensimmons">@jensimmons</a>)</span>
</p>
<p>In this same demo, I would also like to improve the warning to the user when there’s an error in how they filled out the form. For years, we’ve been able to easily put a red box around an invalid input with this CSS.</p>
<pre><code><span>input</span><span>:invalid</span> {
  <span>outline</span>: <span>4px</span> <span>solid</span> <span>red</span>;
  <span>border</span>: <span>2px</span> <span>solid</span> <span>red</span>;
} 
</code></pre>
<p>Now with <code>:has()</code>, we can turn the label text red as well:</p>
<pre><code><span>div</span><span>:has</span>(<span>input</span><span>:invalid</span>) <span>label</span> {
  <span>color</span>: <span>red</span>;
}
</code></pre>
<p>You can see the result by typing something in the website or email field that’s not a fully-formed URL or email address. Both are invalid, and so both will trigger a red border and red label, with an “X”.</p>
<h2><a name="dark-mode-toggle-with-no-js"></a>Dark mode toggle with no JS</h2>
<p>And last, in this same demo I’m using a checkbox to allow the user to toggle between a light and dark theme.</p>
<pre><code><span>body</span><span>:has</span>(<span>input</span>[<span>type</span>=<span>&#34;checkbox&#34;</span>]<span>:checked</span>) {
  <span>background</span>: <span>blue</span>;
  <span>--primary-color</span>: <span>white</span>;
}
<span>body</span><span>:has</span>(<span>input</span>[<span>type</span>=<span>&#34;checkbox&#34;</span>]<span>:checked</span>) <span>form</span> { 
  <span>border</span>: <span>4px</span> <span>solid</span> <span>white</span>;
}
<span>body</span><span>:has</span>(<span>input</span>[<span>type</span>=<span>&#34;checkbox&#34;</span>]<span>:checked</span>) <span>form</span><span>:has</span>(<span>:focus-visible</span>) {
  <span>background</span>: <span>navy</span>;
}
<span>body</span><span>:has</span>(<span>input</span>[<span>type</span>=<span>&#34;checkbox&#34;</span>]<span>:checked</span>) <span>input</span><span>:focus-visible</span> {
  <span>outline</span>: <span>4px</span> <span>solid</span> <span>lightsalmon</span>;
}
</code></pre>
<p>I’ve styled the dark mode checkbox using custom styles, but it does still look like a checkbox. With more complex styles, I could <a href="https://codepen.io/jemin/pen/RwaqNoz?editors=1100">create a toggle in CSS</a>.</p>
<p>In a similar fashion, I could use a select menu to provide a user with multiple <a href="https://adactio.com/about/site/">themes</a> for my site.</p>
<pre><code><span>body</span><span>:has</span>(<span>option</span>[<span>value</span>=<span>&#34;pony&#34;</span>]<span>:checked</span>) {
  <span>--font-family</span>: <span>cursive</span>;
  <span>--text-color</span>: <span>#b10267</span>;
  <span>--body-background</span>: <span>#ee458e</span>;
  <span>--main-background</span>: <span>#f4b6d2</span>;
}
</code></pre>
<p data-height="485" data-default-tab="css,result" data-slug-hash="vYdKKbL" data-user="jensimmons">
  <span>See the Pen <a href="https://codepen.io/jensimmons/pen/vYdKKbL"></a> by Jen Simmons (<a href="https://codepen.io/jensimmons">@jensimmons</a>)</span>
</p>
<p>Any time there’s an opportunity to use CSS instead of JavaScript, I’ll take it. This results in a faster experience and a more robust website. JavaScript can do amazing things, and we should use it when it’s the right tool for the job. But if we can accomplish the same result in HTML and CSS alone, that’s even better.</p>
<h2><a name="and-more"></a>And more</h2>
<p>Looking through other <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes">pseudo-classes</a>, there are so many that can be combined with <code>:has()</code>. Imagine the possibilities with <code>:nth-child</code>, <code>:nth-last-child</code>, <code>:first-child</code>, <code>:last-child</code>, <code>:only-child</code>, <code>:nth-of-type</code>, <code>:nth-last-of-type</code>, <code>:first-of-type</code>, <code>:last-of-type</code>, <code>:only-of-type</code>. The brand new <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:modal"><code>:modal</code></a> pseudo-class is triggered when a <code>dialog</code> is in the open state. With <code>:has(:modal)</code> you can style anything in the DOM based on whether the <code>dialog</code> is open or closed.</p>
<p>However, not every pseudo-class is currently supported inside <code>:has()</code> in every browser, so do try out your code in multiple browsers. Currently the dynamic media pseudo-classes don’t work — like  <code>:playing</code>, <code>:paused</code>, <code>:muted</code>, etc. They very well may work in the future, so if you are reading this in the future, test them out! Also, form invalidation support is currently missing in certain specific situations, so dynamic state changes to those pseudo-classes may not update with <code>:has()</code>.</p>
<p>Safari 16 will add support for <code>:has(:target)</code> opening up interesting possibilities for writing code that looks at the current URL for a fragment that matches the ID of a specific element. For example, if a user clicks on a table of contents at the top of a document, and jumps down to the section of the page matching that link, <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:target"><code>:target</code></a> provides a way to style that content uniquely, based on the fact the user clicked the link to get there. And <code>:has()</code> opens up what such styling can do.</p>
<p>Something to note — the CSS Working Group <a href="https://github.com/w3c/csswg-drafts/issues/7463">resolved</a> to disallow all existing pseudo-elements inside of <code>:has()</code>. For example, <code>article:has(p::first-line)</code> and <code>ol:has(li::marker)</code> won’t work. Same with <code>::before</code> and <code>::after.</code></p>
<h2><a name="the-has-revolution"></a>The :has() revolution</h2>
<p>This feels like a revolution in how we will write CSS selectors, opening up a world of possibilities previously either impossible or often not worth the effort. It feels like while we might recognize immediately how useful <code>:has()</code> will be, we also have no idea what is truly possible. Over the next several years, people who make demos and dive deep into what CSS can do will come up with amazing ideas, stretching <code>:has()</code> to its limits.</p>
<p>Michelle Barker created a <a href="https://codepen.io/michellebarker/pen/vYRVbQX?editors=1100">fantastic demo</a> that triggers the animation of Grid track sizes through the use of <code>:has()</code> and hover states. Read more about it in <a href="https://css-irl.info/animated-grid-tracks-with-has/">her blog post</a>. Support for animated grid tracks will ship in <a href="https://webkit.org/blog/12824/news-from-wwdc-webkit-features-in-safari-16-beta/">Safari 16</a>. You can try out this demo today in <a href="https://developer.apple.com/safari/resources/">Safari Technology Preview or Safari 16 beta</a>.</p>
<p>The hardest part of <code>:has()</code> will be opening our minds to its possibilities. We’ve become so used to the limits imposed on us by not having a parent selector. Now, we have to break those habits.</p>
<p>That’s all the more reason to use vanilla CSS, and not limit yourself to the classes defined in a framework. By writing your own CSS, custom for your project, you can fully leverage all the powerful abilities of today’s browsers.</p>
<p>What will you use <code>:has()</code> for? Last December, I <a href="https://twitter.com/jensimmons/status/1474060698124697606">asked on Twitter</a> what use cases folks might have for <code>:has()</code>, and got lots of replies with incredible ideas. I can’t wait to see yours.</p>


                            </div></div>
  </body>
</html>
