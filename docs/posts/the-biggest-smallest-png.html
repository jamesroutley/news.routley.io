<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://belkadan.com/blog/2024/01/The-Biggest-Smallest-PNG/">Original</a>
    <h1>The Biggest Smallest PNG</h1>
    
    <div id="readability-page-1" class="page"><div>
		<p>A few days ago, my former coworker Evan Hahn posted “<a href="https://evanhahn.com/worlds-smallest-png/">The world’s smallest PNG</a>”, an article walking through the minimum required elements of the PNG image format. He gave away the answer in the very first line:</p>

<blockquote>
  <p>The smallest PNG file is 67 bytes. It’s a single black pixel.</p>
</blockquote>

<p>However (spoilers!) he later points out that there are <em>several</em> valid 67-byte PNGs, such as a 1x1 all-white image, or an 8x1 all-black image, or a 1x1 gray image. All of these exploit the fact that you can’t have less than one byte of pixel data, so you might as well use all eight bits of it. Clever!</p>

<p>However <em>again</em>…are we really limited to one byte of pixel data?</p>

<p>(At this point you should <a href="https://evanhahn.com/worlds-smallest-png/">go read Evan’s article</a> before continuing with mine.)<!--more--></p>

<h3 id="when-compression-isnt">When “Compression” Isn’t</h3>

<p>The shortest <em>uncompressed</em> image data chunk contents for a PNG is two bytes: one byte to introduce the current “scanline” (row) of pixels, and one byte for the pixel data (which can be up to 8 pixels if you’re encoding a black-and-white PNG). Evan represents this as <code>00 00</code>, since he’s encoding a single black pixel with no filter. But then there’s a “compression” step, and even ignoring the additional attached header and checksum those two bytes turn into a 4-byte “<a href="https://zlib.net/feldspar.html">DEFLATE</a>” block: <code>63 60 00 00</code>.</p>

<p>What a worthless compression algorithm, right? Well, not really. It is mathematically impossible for <em>every</em> input to a (lossless) compression algorithm to get shorter, for the same reason that it’s impossible to assign every letter of the alphabet a unique number between 1 and 10: no matter how hard you try when going the other way, you’re only going to produce ten possible outputs. This is the <a href="https://en.wikipedia.org/wiki/Pigeonhole_principle">pigeonhole principle</a>, and it’s not really a problem in practice: most of the time the things you want to compress aren’t random or extremely short, and so there’s room for improvement. We’re just in a weird edge case where that’s not true.</p>

<p>Anyway, Evan mostly skipped over DEFLATE (which, totally fair, there’s plenty to say about PNG), but left in a footnote about what was in those four bytes:</p>

<blockquote>
  <p>The first bit signifies that this is the final DEFLATE block. The next 2 say that this is block that uses hard-coded Huffman codes; no “dictionary” is included in the payload. The next 8 bits encode a literal zero, and then another 8 bits encode the same. The next 7 bits are the “end of block” marker, and the final 6 pad the data so that it’s byte-aligned.</p>
</blockquote>

<p>He also recommended the <a href="https://github.com/madler/infgen/"><code>infgen</code></a> tool for playing with DEFLATE, which gives the same breakdown:</p>

<pre><code>% infgen -dd evan-deflate-block
! infgen 3.2 output
!
last            ! 1
fixed           ! 01
literal 0       ! 00001100
literal 0       ! 00001100
end             ! 0000000
                ! 000000
</code></pre>

<p>At which point I stopped to ask myself: is that really the best we can do?</p>

<h3 id="a-self-referential-format">A self-referential format</h3>

<p>The LZ77 compression strategy that DEFLATE uses saves space by encoding “backreferences” to earlier parts of the string, rather than wastefully repeating those bytes. (Many years ago <a href="https://jvns.ca/blog/2013/10/24/day-16-gzip-plus-poetry-equals-awesome/">Julia Evans did an extremely neat visualization of how these backreferences work by using poetry</a>, which I highly recommend taking a look at to get some intuition for how this works.) One somewhat surprising property is that these backreferences can overlap with themselves; the explainer Evan found for <a href="https://zlib.net/feldspar.html">DEFLATE</a> uses the string “Blah blah blah blah blah!” as an example, which compresses to “Blah b<code>[distance=5, length=18]</code>!”<sup id="fnref:infinite" role="doc-noteref"><a href="#fn:infinite" rel="footnote">1</a></sup> (I’m not going to explain that here, click through to the <a href="https://zlib.net/feldspar.html">DEFLATE</a> explainer to see how it works.) Can we use that to our advantage?</p>

<p>From the breakdown above, we know the block is going to be a minimum of 18 bits: the <code>last</code> flag (1 bit) + the compression scheme <code>fixed</code> (2 bits) + at least one literal 0 (8 bits) + the <code>end</code> marker (7 bits). If we could squeeze out a second byte of output in 6 bits, we’d beat Evan’s record (because our DEFLATE block would only be three total bytes long), but unfortunately there’s no way to do that in DEFLATE. So instead, we assume we’re going to match Evan’s 32 bits total, and we have to decide how to use those remaining 14 bits. Evan’s straightforward encoding used 8 bits to encode the second <code>00</code> byte, and left 6 bits as padding. What alternatives do we have?</p>

<p>I scanned through <a href="https://datatracker.ietf.org/doc/html/rfc1951">RFC 1951</a>, the DEFLATE spec, and found this in section 3.2.6, “Compression with fixed Huffman codes (BTYPE=01)”:</p>

<pre><code>Lit Value    Bits        Codes
---------    ----        -----
  0 - 143     8          00110000 through
                         10111111
144 - 255     9          110010000 through
                         111111111
256 - 279     7          0000000 through
                         0010111
280 - 287     8          11000000 through
                         11000111
</code></pre>

<p>(Note that these “codes” are written backwards from how <code>infgen</code> displays them. The “<a href="https://en.wikipedia.org/wiki/Endianness">endianness</a>” problem gets even worse when you start talking about bits grouped into bytes instead of just bytes grouped into multi-byte integers.)</p>

<p>To summarize a <em>second</em> table, values 0 - 255 are literal bytes (like the “literal 0” above), 256 is the <code>end</code> marker, and 257 - 285 are “length codes” for backreferences. (286 and 287 are unused.) Which means we’re in business! We can encode an overlapping backreference rather than a second “literal 0”, and repeat that first <code>00</code> N times.</p>

<p>The way backreferences are encoded is a bit tricky, and I’m not going to go into it here; if you’re curious you can poke through the tables in the RFC like I did. Fortunately, the <em>longest possible backreference</em> has a relatively simple encoding: #285, i.e. <code>11000101</code>, followed by a fixed 5-bit “distance” encoding of <code>00000</code> (i.e. “zero bytes back from the most recent byte”). Putting this together gives us a DEFLATE block of <code>63 18 05 00</code>, or</p>

<pre><code>% infgen -dd jordan-deflate-block
! infgen 3.2 output
!
last            ! 1
fixed           ! 01
literal 0       ! 00001100
match 258 1     ! 00000 10100011
end             ! 0000000
                ! 0
</code></pre>

<p>This decompresses to a series of 259 zeros, still encoded in just 32 bits. (31 bits, even.)</p>

<h3 id="what-can-you-do-with-259-zeros">What can you do with 259 zeros?</h3>

<p>As Evan points out, you have to spend one byte to introduce a new row in a PNG. If we’re trying to maximize the number of <em>pixels</em> in our 67-byte PNG, we should therefore put them all in one row, so we only have to pay this cost once. That results in 258 bytes of pixel data, which at 1 bit per pixel gives us a whopping 2064 pixels.</p>

<p>Which, after updating all the CRC32 and DEFLATE (Adler-32) checksums, produces <a href="https://belkadan.com/blog/2024/01/The-Biggest-Smallest-PNG/biggest-smallest.png">this PNG</a>. Which I’m not even going to bother embedding, because there’s no good way to show a 2064x1 image on a vertically-scrolling website layout. As a consolation prize, here’s a 48x37 image (1776 pixels), which is the closest to square you can get with 259 zeros:</p>

<p><img src="https://belkadan.com/blog/2024/01/The-Biggest-Smallest-PNG/squarish.png" alt="(It&#39;s a black rectangle, you&#39;re not missing anything.)"/></p>

<p>Evan set a lower bound on the size of a PNG file, and now I think I’ve set an upper bound on the <em>contents</em> of a valid<sup id="fnref:valid" role="doc-noteref"><a href="#fn:valid" rel="footnote">2</a></sup> smallest-possible PNG file. But I’d love to be wrong!</p>

<h3 id="appendix-a-do-we-have-to-use-zeros">Appendix A: Do we have to use zeros?</h3>

<p>Technically no! The byte has to be a valid “filter type”, which can be 0 “None”, 1 “Sub”, 2 “Up”, 3 “Average”, or 4 “Paeth Predictor”, but then we can repeat that as pixel data as much as we want. Encoded as bits, that’s <code>0000_0000</code>, <code>0000_0001</code>, <code>0000_0010</code>, <code>0000_0011</code>, or <code>0000_00100</code>. Here’s what the other four rectangles look like:</p>

<p><img src="https://belkadan.com/blog/2024/01/The-Biggest-Smallest-PNG/squarish-1.png" alt="1. A black rectangle with some oddly repeating vertical white lines."/>
<img src="https://belkadan.com/blog/2024/01/The-Biggest-Smallest-PNG/squarish-2.png" alt="2. A black rectangle with some odd fractal shapes repeating at regular intervals horizontally."/>
<img src="https://belkadan.com/blog/2024/01/The-Biggest-Smallest-PNG/squarish-3.png" alt="3. A black rectangle with some odd noise at the top and then white bands stretching down vertically."/>
<img src="https://belkadan.com/blog/2024/01/The-Biggest-Smallest-PNG/squarish-4.png" alt="4. A black rectangle with some odd fractal shapes, similar to #2, at a slight diagonal above horizontal."/></p>

<p>*shrug* Not much use for these but there you go!</p>

<h3 id="appendix-b-tools-used-in-the-creation-of-this-post">Appendix B: Tools used in the creation of this post</h3>

<p>As noted, I used Mark Adler’s <a href="https://github.com/madler/infgen/"><code>infgen</code></a> tool (the one Evan recommended) to play with and check my DEFLATE blocks. I used Python’s <code>zlib.decompress()</code> to check that I got the zlib checksums correct without needing to update the PNG checksums.</p>

<p>For calculating the PNG checksums, I used <code>crc32</code>. (Note that these <em>include</em> the header name but <em>exclude</em> the length field.) I did the <a href="https://en.wikipedia.org/wiki/Adler-32">Adler-32</a> checksums for zlib by hand (well, I constructed the arithmetic expressions, then let the computer evaluate them). This was a bit silly because I could have used Python’s <code>zlib.adler32()</code>.</p>

<p>For hopping in and out of hex on the command line, I used <code>xxd</code>. <code>xxd -r -p</code> goes from text hex to binary, allowing spaces, which was useful for passing into <code>crc32</code>.</p>

<p>On a Mac, I recommend doing hex editing in <a href="https://hexfiend.com">Hex Fiend</a>. And I didn’t do anything special to open the resulting PNGs; if they worked, they displayed in Preview just fine. I did also use <a href="http://www.libpng.org/pub/png/apps/pngcheck.html"><code>pngcheck</code></a> to examine what was in the file.</p>




		<p>
			This entry was posted on
			<a href="https://belkadan.com/blog/2024/01">January</a>
			07,
			
				<a href="https://belkadan.com/blog/2024">2024</a>
				and is filed under
				<a href="https://belkadan.com/blog/technical">Technical</a>.
			
			
			
				Tags:
				
					<a href="https://belkadan.com/blog/tags/graphics">Graphics</a>, 
				
					<a href="https://belkadan.com/blog/tags/compression">Compression</a>
				
			
		</p>
	</div></div>
  </body>
</html>
