<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://healeycodes.com/compressing-cs2-demos">Original</a>
    <h1>Compressing CS2 Demos</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>Counter-Strike 2 demo files (.dem) are game recordings of CS2 matches. They contain demo information and network messages encoded using Google&#39;s Protocol Buffers (protobuf). There is some sparse information on this <a href="https://github.com/ValveSoftware/csgo-demoinfo/tree/master/demoinfogo">eight-year-old repository</a> but, broadly, it&#39;s an undocumented format. Demos can be combined with a CS2 game client to playback a match with the same detail it was originally played with.</p><p>There are demo <a href="https://github.com/markus-wa/demoinfocs-golang">parsing</a> <a href="https://github.com/pnxenopoulos/awpy">libraries</a> that let you read demos outside of CS2 and operate on structured data that&#39;s more useful for analysis, and easier to create graphics with, than the raw network messages. I used one of these libraries when I worked on a <a href="https://healeycodes.com/rendering-counter-strike-demos-in-the-browser">prototype demo player</a> that runs in the browser. For that project, to shrink the demo data I sent to the browser, I threw away most of the data. A 2D overhead view doesn&#39;t need granular position data so I used e.g. one in every hundred frames.</p><p>However, there are use cases when you want to preserve granular demo data. For example, when you&#39;re performing data analysis on how people aim with their mouse in-game. This kind of analysis is useful for professional e-sports organizations to measure their team&#39;s performance, and to scout unsigned players.</p><p>When you are iterating on data analysis, it&#39;s better to have a quick testing cycle. Parsing a 300MB demo file to build a series of events takes ~20sec on a desktop PC. It&#39;s also likely you&#39;ll be parsing <em>many</em> demos at once.</p><p>An obvious optimization is saving the generated events to a file so you don&#39;t need to reparse demos every time.</p><p>For this example, let&#39;s say I&#39;m doing some analysis on player positions and their equipment. There is a lot of information I can throw away, like shooting events and player view direction. I&#39;ll use <a href="https://github.com/markus-wa/demoinfocs-golang">demoinfocs-golang</a> to parse a demo and store events in my own data types.</p><p>This is all the information I need for my analysis:</p><pre><div><div><p><span>type</span><span> Player </span><span>struct</span><span> </span><span>{</span><span></span></p><p><span>    ID        </span><span>int</span><span></span></p><p><span>    Name      </span><span>string</span><span></span></p><p><span>    Position  r3</span><span>.</span><span>Vector</span></p><p><span>    Equipment </span><span>[</span><span>]</span><span>string</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>type</span><span> Frame </span><span>struct</span><span> </span><span>{</span><span></span></p><p><span>    Players </span><span>[</span><span>]</span><span>Player</span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>type</span><span> Game </span><span>struct</span><span> </span><span>{</span><span></span></p><p><span>    Frames </span><span>[</span><span>]</span><span>Frame</span></p><p><span></span><span>}</span></p></div></div></pre><p>To fill up these structs, I loop over every frame and store the data I need.</p><pre><div><div><p><span>moreFrames</span><span>,</span><span> err </span><span>:=</span><span> p</span><span>.</span><span>ParseNextFrame</span><span>(</span><span>)</span><span></span></p><p><span></span><span>for</span><span> </span><span>;</span><span> moreFrames </span><span>&amp;&amp;</span><span> err </span><span>==</span><span> </span><span>nil</span><span>;</span><span> moreFrames</span><span>,</span><span> err </span><span>=</span><span> p</span><span>.</span><span>ParseNextFrame</span><span>(</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    frame </span><span>:=</span><span> Frame</span><span>{</span><span>Players</span><span>:</span><span> </span><span>[</span><span>]</span><span>Player</span><span>{</span><span>}</span><span>}</span><span></span></p><p><span>    </span><span>for</span><span> </span><span>_</span><span>,</span><span> player </span><span>:=</span><span> </span><span>range</span><span> p</span><span>.</span><span>GameState</span><span>(</span><span>)</span><span>.</span><span>Participants</span><span>(</span><span>)</span><span>.</span><span>Playing</span><span>(</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>        equipment </span><span>:=</span><span> </span><span>[</span><span>]</span><span>string</span><span>{</span><span>}</span><span></span></p><p><span>        </span><span>for</span><span> </span><span>_</span><span>,</span><span> equip </span><span>:=</span><span> </span><span>range</span><span> player</span><span>.</span><span>Weapons</span><span>(</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>            equipment </span><span>=</span><span> </span><span>append</span><span>(</span><span>equipment</span><span>,</span><span> equip</span><span>.</span><span>String</span><span>(</span><span>)</span><span>)</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>        frame</span><span>.</span><span>Players </span><span>=</span><span> </span><span>append</span><span>(</span><span>frame</span><span>.</span><span>Players</span><span>,</span><span> Player</span><span>{</span><span></span></p><p><span>        ID</span><span>:</span><span>        </span><span>int</span><span>(</span><span>player</span><span>.</span><span>SteamID64</span><span>)</span><span>,</span><span></span></p><p><span>        Name</span><span>:</span><span>      player</span><span>.</span><span>Name</span><span>,</span><span></span></p><p><span>        Position</span><span>:</span><span>  player</span><span>.</span><span>Position</span><span>(</span><span>)</span><span>,</span><span></span></p><p><span>        Equipment</span><span>:</span><span> equipment</span><span>,</span><span></span></p><p><span>        </span><span>}</span><span>)</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    game</span><span>.</span><span>Frames </span><span>=</span><span> </span><span>append</span><span>(</span><span>game</span><span>.</span><span>Frames</span><span>,</span><span> frame</span><span>)</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>Then I write it to a JSON file that I can use in my analysis program:</p><pre><div><div><p><span>jsonData</span><span>,</span><span> err </span><span>:=</span><span> json</span><span>.</span><span>Marshal</span><span>(</span><span>game</span><span>)</span><span></span></p><p><span></span><span>if</span><span> err </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span></span></p><p><span>    log</span><span>.</span><span>Panicf</span><span>(</span><span>&#34;Failed to marshal JSON: %s\n&#34;</span><span>,</span><span> err</span><span>)</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span>f</span><span>,</span><span> err </span><span>=</span><span> os</span><span>.</span><span>Create</span><span>(</span><span>&#34;./naive.json&#34;</span><span>)</span><span></span></p><p><span></span><span>if</span><span> err </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span></span></p><p><span>    log</span><span>.</span><span>Panicf</span><span>(</span><span>&#34;Failed to write JSON: %s\n&#34;</span><span>,</span><span> err</span><span>)</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>By picking out just the data that I need, I should be rewarded with a much smaller file than the original demo file, right? Wrong. The JSON file is ~355MB, ~15% larger than the input demo.</p><p>There are two reasons for this:</p><ol start="1"><li>The data types lead to a lot of duplicate data (e.g. player names and ids)</li><li>JSON is a verbose textual representation that doesn&#39;t use efficient encoding</li></ol><h2 id="removing-duplicate-data">Removing Duplicate Data</h2><p>It&#39;s always always a good idea to look directly at the data. Let&#39;s do that. Here&#39;s a slice from the middle of the frames we&#39;re writing to disk. I&#39;ve selected two frames, 16ms apart, and removed all the players apart from one.</p><pre><div><div><p><span>[</span><span></span></p><p><span>    </span><span>{</span><span></span></p><p><span>        </span><span>&#34;Players&#34;</span><span>:</span><span> </span><span>[</span><span></span></p><p><span>            </span><span>{</span><span></span></p><p><span>                </span><span>&#34;Id&#34;</span><span>:</span><span> </span><span>76561198073395520</span><span>,</span><span></span></p><p><span>                </span><span>&#34;Name&#34;</span><span>:</span><span> </span><span>&#34;Chill&#34;</span><span>,</span><span></span></p><p><span>                </span><span>&#34;Position&#34;</span><span>:</span><span> </span><span>{</span><span></span></p><p><span>                    </span><span>&#34;X&#34;</span><span>:</span><span> </span><span>-1293.3974609375</span><span>,</span><span></span></p><p><span>                    </span><span>&#34;Y&#34;</span><span>:</span><span> </span><span>-1328.162841796875</span><span>,</span><span></span></p><p><span>                    </span><span>&#34;Z&#34;</span><span>:</span><span> </span><span>11488.03125</span><span></span></p><p><span>                </span><span>}</span><span>,</span><span></span></p><p><span>                </span><span>&#34;Equipment&#34;</span><span>:</span><span> </span><span>[</span><span></span></p><p><span>                    </span><span>&#34;Knife&#34;</span><span>,</span><span></span></p><p><span>                    </span><span>&#34;Flashbang&#34;</span><span>,</span><span></span></p><p><span>                    </span><span>&#34;Desert Eagle&#34;</span><span>,</span><span></span></p><p><span>                    </span><span>&#34;Smoke Grenade&#34;</span><span>,</span><span></span></p><p><span>                    </span><span>&#34;AK-47&#34;</span><span></span></p><p><span>                </span><span>]</span><span></span></p><p><span>            </span><span>}</span><span></span></p><p><span>            </span><span>// &lt;rest of players&gt;</span><span></span></p><p><span>        </span><span>]</span><span></span></p><p><span>    </span><span>}</span><span>,</span><span></span></p><p><span>    </span><span>{</span><span></span></p><p><span>        </span><span>&#34;Players&#34;</span><span>:</span><span> </span><span>[</span><span></span></p><p><span>            </span><span>{</span><span></span></p><p><span>                </span><span>&#34;Id&#34;</span><span>:</span><span> </span><span>76561198073395520</span><span>,</span><span></span></p><p><span>                </span><span>&#34;Name&#34;</span><span>:</span><span> </span><span>&#34;Chill&#34;</span><span>,</span><span></span></p><p><span>                </span><span>&#34;Position&#34;</span><span>:</span><span> </span><span>{</span><span></span></p><p><span>                    </span><span>&#34;X&#34;</span><span>:</span><span> </span><span>-1293.3974609375</span><span>,</span><span></span></p><p><span>                    </span><span>&#34;Y&#34;</span><span>:</span><span> </span><span>-1328.162841796875</span><span>,</span><span></span></p><p><span>                    </span><span>&#34;Z&#34;</span><span>:</span><span> </span><span>11488.03125</span><span></span></p><p><span>                </span><span>}</span><span>,</span><span></span></p><p><span>                </span><span>&#34;Equipment&#34;</span><span>:</span><span> </span><span>[</span><span></span></p><p><span>                    </span><span>&#34;Flashbang&#34;</span><span>,</span><span></span></p><p><span>                    </span><span>&#34;Desert Eagle&#34;</span><span>,</span><span></span></p><p><span>                    </span><span>&#34;Smoke Grenade&#34;</span><span>,</span><span></span></p><p><span>                    </span><span>&#34;AK-47&#34;</span><span>,</span><span></span></p><p><span>                    </span><span>&#34;Knife&#34;</span><span></span></p><p><span>                </span><span>]</span><span></span></p><p><span>            </span><span>}</span><span></span></p><p><span>            </span><span>// &lt;rest of players&gt;</span><span></span></p><p><span>        </span><span>]</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span></span><span>]</span></p></div></div></pre><p>Can you see where we&#39;ve duplicated data? The most obvious is the id and name as they don&#39;t change during the match.</p><p>You might have also noticed that although the order of equipment changes, the set of equipment does not. You only get full marks if you noticed that I&#39;ve selected two frames where a player&#39;s position <em>also</em> doesn&#39;t change. Sure, players are moving most of the time but not <em>all of the time</em>.</p><p>Here are some optimizations we can make here.</p><ul><li>Move static data (like id and name) to an object at the top level. Use a new short id to identify players</li><li>Only report player positions when they change</li><li>Rather than listing the players every frame, just track when they spawn and die</li><li>Only report equipment when it changes. Also store the equipment names in an object at the top level and use another new short id as a key</li></ul><p>This an example of <a href="https://en.wikipedia.org/wiki/Delta_encoding">delta encoding</a> or <a href="https://en.wikipedia.org/wiki/Data_differencing">data differencing</a>.</p><p>The new data types look like this:</p><pre><div><div><p><span>type</span><span> Player </span><span>=</span><span> </span><span>struct</span><span> </span><span>{</span><span></span></p><p><span>    Id      </span><span>uint64</span><span> </span><span>`json:&#34;id&#34;`</span><span></span></p><p><span>    IdShort </span><span>uint32</span><span> </span><span>`json:&#34;idShort&#34;`</span><span></span></p><p><span>    Name    </span><span>string</span><span> </span><span>`json:&#34;name&#34;`</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>type</span><span> PlayerMeta </span><span>map</span><span>[</span><span>uint64</span><span>]</span><span>Player</span></p><p><span></span><span>type</span><span> EquipmentMeta </span><span>map</span><span>[</span><span>string</span><span>]</span><span>int32</span><span></span></p><p><span></span><span>type</span><span> Frame </span><span>struct</span><span> </span><span>{</span><span></span></p><p><span>    PlayerSpawn     </span><span>[</span><span>]</span><span>uint32</span><span>             </span><span>`json:&#34;playerSpawn,omitempty&#34;`</span><span></span></p><p><span>    PlayerDeath     </span><span>[</span><span>]</span><span>uint32</span><span>             </span><span>`json:&#34;playerDeath,omitempty&#34;`</span><span></span></p><p><span>    PositionChange  </span><span>map</span><span>[</span><span>uint32</span><span>]</span><span>r3</span><span>.</span><span>Vector </span><span>`json:&#34;positionChange,omitempty&#34;`</span><span></span></p><p><span>    EquipmentChange </span><span>map</span><span>[</span><span>uint32</span><span>]</span><span>[</span><span>]</span><span>int32</span><span>   </span><span>`json:&#34;equipmentChange,omitempty&#34;`</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>type</span><span> Game </span><span>struct</span><span> </span><span>{</span><span></span></p><p><span>    PlayerMeta    </span><span>`json:&#34;playerMeta&#34;`</span><span></span></p><p><span>    EquipmentMeta </span><span>`json:&#34;equipmentMeta&#34;`</span><span></span></p><p><span>    Frames        </span><span>[</span><span>]</span><span>Frame </span><span>`json:&#34;frames&#34;`</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>By omitting empty structures, there are occasions in the game when frames take up just three bytes when encoded as JSON: <code>{},</code>. In these cases, for the events we&#39;re interested in, nothing changed when compared to the previous frame.</p><p>The most interesting one here is the <code>EquipmentChange</code> events. Rather than listing the entire inventory, just the <em>difference</em> is stored as a change event. When an equipment <code>id</code> is listed, it means that item has been added to the player&#39;s inventory on this frame. When there&#39;s a negative <code>-id</code>, that item was removed on this frame.</p><p>To convert equipment strings to integers ids, a new id is generated when the equipment string first appears.</p><p>When we loop through frames to create change events, we&#39;re comparing the last frame to the current frame. In the case of equipment, let&#39;s use an example where a player buys a HE Grenade:</p><ul><li>Create an id for the string by adding an entry to <code>EquipmentMeta</code> (the id is <code>1</code>)</li><li>Check if the player had the item on the last frame (they didn&#39;t)</li><li>Append to the frame&#39;s <code>EquipmentChange</code> map by appending <code>1</code> to the player&#39;s change events</li></ul><p>If they drop it on the next frame:</p><ul><li>Check if the player is missing any items from the last frame (they&#39;re missing <code>1</code>)</li><li>Append the negative of that id (<code>-1</code>) to the player&#39;s change events for the current frame</li></ul><p>Or, in code:</p><pre><div><div><p><span>// Compare current frame to last frame</span><span></span></p><p><span></span><span>for</span><span> id</span><span>,</span><span> info </span><span>:=</span><span> </span><span>range</span><span> curFrame </span><span>{</span><span></span></p><p><span>    </span><span>// Player didn&#39;t exist on the last frame</span><span></span></p><p><span>    </span><span>if</span><span> lastInfo</span><span>,</span><span> ok </span><span>:=</span><span> lastFrame</span><span>[</span><span>id</span><span>]</span><span>;</span><span> </span><span>!</span><span>ok </span><span>{</span><span></span></p><p><span>    </span><span>// So we can just add all the items as &#34;add events&#34;</span><span></span></p><p><span>    frame</span><span>.</span><span>EquipmentChange</span><span>[</span><span>id</span><span>]</span><span> </span><span>=</span><span> info</span><span>.</span><span>Equipment</span></p><p><span>    </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>// Handle new equipment (positive ids)</span><span></span></p><p><span>        </span><span>for</span><span> </span><span>_</span><span>,</span><span> idEquip </span><span>:=</span><span> </span><span>range</span><span> info</span><span>.</span><span>Equipment </span><span>{</span><span></span></p><p><span>            </span><span>if</span><span> </span><span>!</span><span>contains</span><span>[</span><span>int32</span><span>]</span><span>(</span><span>lastInfo</span><span>.</span><span>Equipment</span><span>,</span><span> idEquip</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>                </span><span>if</span><span> frame</span><span>.</span><span>EquipmentChange</span><span>[</span><span>id</span><span>]</span><span> </span><span>==</span><span> </span><span>nil</span><span> </span><span>{</span><span></span></p><p><span>                    frame</span><span>.</span><span>EquipmentChange</span><span>[</span><span>id</span><span>]</span><span> </span><span>=</span><span> </span><span>[</span><span>]</span><span>int32</span><span>{</span><span>}</span><span></span></p><p><span>                </span><span>}</span><span></span></p><p><span>                frame</span><span>.</span><span>EquipmentChange</span><span>[</span><span>id</span><span>]</span><span> </span><span>=</span><span> </span><span>append</span><span>(</span><span>frame</span><span>.</span><span>EquipmentChange</span><span>[</span><span>id</span><span>]</span><span>,</span><span> idEquip</span><span>)</span><span></span></p><p><span>            </span><span>}</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>        </span><span>// Handle missing equipment (negative ids)</span><span></span></p><p><span>        </span><span>for</span><span> </span><span>_</span><span>,</span><span> idEquip </span><span>:=</span><span> </span><span>range</span><span> lastInfo</span><span>.</span><span>Equipment </span><span>{</span><span></span></p><p><span>            </span><span>if</span><span> contains</span><span>[</span><span>int32</span><span>]</span><span>(</span><span>lastInfo</span><span>.</span><span>Equipment</span><span>,</span><span> idEquip</span><span>)</span><span> </span><span>&amp;&amp;</span><span> </span><span>!</span><span>contains</span><span>[</span><span>int32</span><span>]</span><span>(</span><span>info</span><span>.</span><span>Equipment</span><span>,</span><span> idEquip</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>                </span><span>if</span><span> frame</span><span>.</span><span>EquipmentChange</span><span>[</span><span>id</span><span>]</span><span> </span><span>==</span><span> </span><span>nil</span><span> </span><span>{</span><span></span></p><p><span>                    frame</span><span>.</span><span>EquipmentChange</span><span>[</span><span>id</span><span>]</span><span> </span><span>=</span><span> </span><span>[</span><span>]</span><span>int32</span><span>{</span><span>}</span><span></span></p><p><span>                </span><span>}</span><span></span></p><p><span>                frame</span><span>.</span><span>EquipmentChange</span><span>[</span><span>id</span><span>]</span><span> </span><span>=</span><span> </span><span>append</span><span>(</span><span>frame</span><span>.</span><span>EquipmentChange</span><span>[</span><span>id</span><span>]</span><span>,</span><span> idEquip</span><span>)</span><span></span></p><p><span>            </span><span>}</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>The same logic is used for player spawn and player death events; positive and negative player ids. For new positions, the absolute position is added as an event (it&#39;s like saying: the player is now at X, Y, Z).</p><p>After removing duplicated data, we&#39;ve made some improvements to the file size. The new JSON file is ~58MB, or ~84% smaller.</p><h2 id="adding-efficient-encoding">Adding Efficient Encoding</h2><p>We can get a free compression win by serializing the data as a protobuf message.</p><p>I wrote a quick schema that copies the existing structs.</p><pre><div><div><p><span>syntax = &#34;proto3&#34;;</span></p><p><span>// ... omitted fields</span></p><p><span>message Frame {</span></p><p><span>  repeated uint32 player_spawn = 1;</span></p><p><span>  repeated uint32 player_death = 2;</span></p><p><span>  map&lt;uint32, Vector&gt; position_change = 3;</span></p><p><span>  map&lt;uint32, EquipmentList&gt; equipment_change = 4;</span></p><p><span>}</span></p><p><span>message Game {</span></p><p><span>  PlayerMeta player_meta = 1;</span></p><p><span>  EquipmentMeta equipment_meta = 2;</span></p><p><span>  repeated Frame frames = 3;</span></p><p><span>}</span></p></div></div></pre><p>This takes us further, from ~58MB to ~27MB.</p><p>The resulting binary encoded file is faster to parse than the JSON, and magnitudes faster to read than the original demo.</p><p>There are other tricks to achieve further compression like this blog series on <a href="https://aras-p.info/blog/2023/01/29/Float-Compression-0-Intro/">float compression</a>. I could also use my domain knowledge of the data to create a custom encoding. For example, there will only 10 players, and there is a low upper bound on the different types of equipment. The range of valid positions on a map is quite small for X and Y, and even smaller for Z, when compared to the available space of <code>float64</code>.</p><p>I could also encode position data using <a href="https://en.wikipedia.org/wiki/Bit_array">bit arrays</a>. I&#39;ll explain how this would work with equipment changes as it&#39;s easier to explain than float compression.</p><p>Instead of storing a map with a <code>uint8</code> as a key, and a list of <code>int8</code> for the change events. I can compress the data into a bit array where each value is: a player id (4 bits) and an add or remove event (5 bits) for 9 bits total. A frame&#39;s equipment change field can just be a list of those (repeating the player id is actually okay because it&#39;s rare that multiple piece of equipment are acquired on the same frame).</p><p>It&#39;s fun to theorize but a protobuf schema is as far as I need to go for now.</p></div></div></div>
  </body>
</html>
