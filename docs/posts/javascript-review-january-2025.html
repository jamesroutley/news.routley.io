<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://elijer.github.io/garden/devnotes/Javascript/Review/Javascript-Review-January-2025">Original</a>
    <h1>Javascript Review January 2025</h1>
    
    <div id="readability-page-1" class="page"><article><p><img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/c579257af2cc0b8326977ec01fc0643c.png" alt="image"/></p>

<p>In a fast-faced situation like a DSA interview or on a tough day where you are having trouble sorting through your logs to the console, it can be helpful to do this instead:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>console.</span><span>log</span><span>({someVal})</span></span>
<span data-line=""><span>// someVal: 4</span></span></code></pre></figure>
<p>This technique quickly prints both the variable name and value of an object so you don’t need to write i manually, and can easily be used to spit out a bunch without getting confused:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>console.</span><span>log</span><span>({name, address, phoneNum})</span></span></code></pre></figure>

<p>Because mixing these up can break an entire program, I am constantly looking this one up.</p>
<pre><code>0 ?? &#39;zero!&#39;
// 0

0 || &#39;zero!&#39;
// &#39;zero!&#39;
</code></pre>
<p>Where <code>??</code> is known as the <code>nullish coalescence</code> operator and <code>||</code> is the <code>logical OR</code> operator, their names are the key.</p>
<p>Nullish coalescence evaluates to the righthand operand <em>only</em> when lefthand operand is <code>null</code> or <code>undefined</code>.</p>
<p>Logical OR on the other hand evaluates to the righthand operand in <em>all</em> falsy cases
<code>&#39;&#39;, 0, [], false, null, undefined, trump&#39;s moral consciousness</code>.</p>
<p>The name makes it easy to remember. Logical OR has to do with logic, true and false. In Javascript, any value that evaluates to <code>false</code> will trip a Logical OR.</p>
<p>Nullish Coalescence is more particular, and <em>doesn’t really</em> have to do with the logic of true or false. It’s only concerned with strict <code>nullness</code>.</p>
<p>Nullish coalescence can be really helpful when dealing with dynamic data or algorithms that may evaluate to <code>0</code> or empty arrays at some point.</p>

<p>It’s really tempting to use the <code>in</code> operator all the time as if it were the same as a <code>for...</code> loop in Javascript. But there’s a really important difference.</p>
<p>The for loop: <code>for (let i = 0; i &lt; something; i__)</code>
is dealing with integers. <code>i</code> is of type Number.</p>
<p>Whereas <code>for (i in something</code> (maddeningly) deals in strings.
The <code>i</code> <em>here</em> is of type <code>string</code>.</p>
<p>Especially in typescript, this is a good enough reason to use the traditional <code>for...</code> loop whenever you are going to use indexes as indexes.</p>

<p>Deconstruction can be really helpful right in a loop:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>for</span><span> (</span><span>const</span><span> {</span><span>first</span><span>, </span><span>last</span><span>} </span><span>of</span><span> people){</span></span>
<span data-line=""><span>	console.</span><span>log</span><span>(</span><span>`Mr. ${</span><span>last</span><span>} is my father&#39;s name, you can call me ~~${</span><span>first</span><span>}~~ Muad&#39;Dib`</span><span>)</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>Or when iterating through an object in another way:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>people.</span><span>map</span><span>(({</span><span>first</span><span>, </span><span>last</span><span>})</span><span>=&gt;</span><span>{</span></span>
<span data-line=""><span>	console.</span><span>log</span><span>(</span><span>&#34;AYE BUB! YEH YOU&#34;</span><span>)</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>And can also be useful when iterating through other data structures:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>const</span><span> moose</span><span> =</span><span> new</span><span> Map</span><span>()</span></span>
<span data-line=""><span>moose.</span><span>set</span><span>(</span><span>&#39;jo&#39;</span><span>, </span><span>&#39;McMoose&#39;</span><span>)</span></span>
<span data-line=""><span>[</span><span>...</span><span>moose].</span><span>map</span><span>(([</span><span>key</span><span>, </span><span>value</span><span>])</span><span>=&gt;</span><span>console.</span><span>log</span><span>(key, value))</span></span>
<span data-line=""><span>jo moo</span></span></code></pre></figure>

<p>I think everyone knows this yet still I often forget to use it when it could help me drop an <code>if</code> statement.</p>

<p>It can be helpful to know that <code>something &amp;&amp; go()</code>
often evaluates to <code>if (something) go()</code> for truthiness conditions. This is notably a common pattern for conditional rendering in react.</p>
<p>Just be careful of order - execution left of <code>&amp;&amp;</code> ends up executing.</p>

<h3 id="usefulness-of-in-as-an-expression">Usefulness of <code>in</code> as an expression<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#usefulness-of-in-as-an-expression"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>There is another type of <code>in</code> that is well-known to pythonistas but I rarely remember. It is less versatile than in python though.</p>
<p>It works for objects:</p>
<pre><code>const nicknames = {
	aang: &#34;twinkle toes&#34;,
	katara: &#34;the painted lady&#34;,
	sokka: &#34;captain boomerang&#34;
}

console.log(&#39;aang&#39; in nickames)
// true
</code></pre>
<p>And technically arrays, but only for index name so not really how I would want or expect personally:</p>
<pre><code>const aminals = [&#39;sqrl&#39;]
console.log(&#39;sqrl&#39; in aminals)
// false

const aminals = [&#39;sqrl&#39;]
console.log(&#39;0&#39; in aminals)
true

const aminals = [&#39;sqrl&#39;]
console.log(&#39;2&#39; in aminals)
false
</code></pre>
<h3 id="throwback-to-while-loops">Throwback to while loops<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#throwback-to-while-loops"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><code>for</code> loops are still really useful, but sometimes <code>while (i &lt; something.length)</code> will cut it when all you need is <code>i</code> as a number, no special conditions, and you trust yourself to remember adding <code>i++</code> into your loop manually.</p>
<h3 id="handling-index-edge-cases-in-for-loops">Handling index edge cases in <code>for</code> loops<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#handling-index-edge-cases-in-for-loops"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>The middle expression of for loops is more flexible than its everyday usage. More nuanced checks can help to add in bounds checking for more complex cases:</p>
<p><code>(let j = 0; j &lt; 4 &amp;&amp; i + j &lt; s.length; j++)</code></p></article></div>
  </body>
</html>
