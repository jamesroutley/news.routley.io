<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://joeyh.name/code/moreutils/">Original</a>
    <h1>Moreutils: A collection of Unix tools that nobody thought to write long ago</h1>
    
    <div id="readability-page-1" class="page"><article class="page">







<div id="pagebody">

<section id="content" role="main">
<p>moreutils is a collection of the unix tools that nobody thought to
write long ago when unix was young.</p>

<p>It began when I <a href="https://joeyh.name/blog/entry/unix_tools_vidir/">blogged</a>:</p>

<blockquote><p>I&#39;m a fan of the unix tools philosophy, but I sometimes wonder if there&#39;s much
room for new tools to be added to that toolbox. I&#39;ve always wanted to come up
with my own general-purpose new unix tool.</p></blockquote>

<p>Well, after lots of feedback documented in the many followups
(<a href="https://joeyh.name/blog/entry/unix_tools_followup/">1</a> <a href="https://joeyh.name/blog/entry/moreutils/">2</a>
<a href="https://joeyh.name/blog/entry/moreutils_update/">3</a>) in my blog, I&#39;ve concluded:</p>

<blockquote><p>Maybe the problem isn&#39;t that no-one is writing them, or that the unix
toolspace is covered except for specialised tools, but that the most
basic tools fall through the cracks and are never noticed by people who
could benefit from them.</p></blockquote>

<p>And so the moreutils collection was born, to stop these programs from
falling through the cracks.</p>

<h2>What&#39;s included</h2>

<p>Probably the most general purpose tool in moreutils so far is <code>sponge</code>(1),
which lets you do things like this:</p>

<pre><code>% sed &#34;s/root/toor/&#34; /etc/passwd | grep -v joey | sponge /etc/passwd
</code></pre>

<p>There are lots more listed below, and the goal is to collect more,
as long as they&#39;re suitably general-purpose,
and don&#39;t duplicate other well-known tools.</p>

<ul>
<li>chronic: runs a command quietly unless it fails</li>
<li>combine: combine the lines in two files using boolean operations</li>
<li>errno: look up errno names and descriptions</li>
<li>ifdata: get network interface info without parsing ifconfig output</li>
<li>ifne: run a program if the standard input is not empty</li>
<li>isutf8: check if a file or standard input is utf-8</li>
<li>lckdo: execute a program with a lock held</li>
<li>mispipe: pipe two commands, returning the exit status of the first</li>
<li>parallel: run multiple jobs at once</li>
<li>pee: tee standard input to pipes</li>
<li>sponge: soak up standard input and write to a file</li>
<li>ts: timestamp standard input</li>
<li>vidir: edit a directory in your text editor</li>
<li>vipe: insert a text editor into a pipe</li>
<li>zrun: automatically uncompress arguments to command</li>
</ul>


<h2>Download</h2>

<p>A Debian package as well as the source tarball for moreutils can be
downloaded from
<a href="http://packages.debian.org/unstable/utils/moreutils">packages.debian.org</a>,
or using apt. It&#39;s also in Ubuntu, and, I hear in several other Linux
distributions.</p>

<p>The git repository can be cloned from <code>git://git.joeyh.name/moreutils</code></p>

<h2>News</h2>


<article>



<section>
<p>moreutils 0.67 released with <a href="#code-moreutils-news-version-0.67.default">these changes</a></p>

<div id="code-moreutils-news-version-0.67.default">


<ul>
<li>README: Formalize that I am not adding new tools to moreutils,
and have not for a long while. This package needs someone new to
take over editorial responsibility.</li>
<li>Makefile: Install man pages without executable bit.
Thanks, meator</li>
<li>ifne.1: Improve example that pipes to mail to avoid escape
sequences.</li>
</ul>


</div>


</section>





</article>
<article>



<section>
<p>moreutils 0.66 released with <a href="#code-moreutils-news-version-0.66.default">these changes</a></p>

<div id="code-moreutils-news-version-0.66.default">


<ul>
<li>vipe: When no output is piped into vipe, and stdin is connected to
the terminal, don&#39;t read from stdin before opening the editor.
This allows eg: vipe | command
Thanks, Florian Pensec</li>
<li>chronic: With -v, flush stdout after printing &#34;STDERR&#34; header.
Thanks, Adam Sjøgren</li>
</ul>


</div>


</section>





</article>
<article>



<section>
<p>moreutils 0.65 released with <a href="#code-moreutils-news-version-0.65.default">these changes</a></p>

<div id="code-moreutils-news-version-0.65.default">


<ul>
<li>vipe: Added --suffix option.
Thanks, Pål Grønås Drange.</li>
<li>ifdata: fail when -ph is given but no hwaddr is available
(Closes: #<a href="http://bugs.debian.org/386755">386755</a>)
Thanks, Nicolas Schier</li>
</ul>


</div>


</section>





</article>



<h2>TODO</h2>

<ul>
<li><p>pee should support non-blocking i/o to write to the pipes to allow
concurrent processing of the data by the programs. Alternatively, switch
to fountain
<a href="http://hea-www.cfa.harvard.edu/~dj/tmp/fountain-1.0.2.tar.gz">http://hea-www.cfa.harvard.edu/~dj/tmp/fountain-1.0.2.tar.gz</a>.</p>

<p>Alternatively, make sponge buffer to stdout if no file is given, and use it
to buffer the data from pee. Although this will be less efficient and
will not work as well for very large streams unless sponge avoids
buffering the whole contents in memory in this case.</p></li>
</ul>


<h2>Tools under consideration</h2>

<p>This collection is closed at this time for suggestions of
additional tools to add to it. If you would like to take up editorial
responsibility for adding tools, as well as take over maintenance of
moreutils, please contact me.</p>

<p>Here are some that have been suggested but not yet been included:</p>

<ul>
<li><p>dirempty/exists</p>

<p>It&#39;s too hard to tell if a directory is empty in shell.
Also, while test -e works ok for a single file, it fails if you want to
see if a wildcard matches anything.</p>

<p>Suggested in <a href="http://bugs.debian.org/385069">bug #385069</a>, see bug for my
comments.</p></li>
<li><p>cattail</p>

<p>Allows catting a file that&#39;s still changing (ie, being downloaded)
to a program. The new bits of the file will continue to be fed to the
program until the download is done.</p>

<p>Submitted by Justin Azoff, with code. However, it has to use heuristics
to guess when the download (or whatever) is done. The current heuristic,
10 seconds w/o growth, wouldn&#39;t work very well for me on dialup.</p>

<p>Using inotify is probably the best approach.
<a href="http://files.minuslab.net/doc.html">fsniper</a> is a less general-purpose
tool that uses inotify to detect when a file is closed.</p></li>
<li><p>phoenix</p>

<p>Respawns a process unless a user really wants to quit. Suggested
in <a href="http://bugs.debian.org/382428">bug #382428</a></p>

<p>Doesn&#39;t seem general enough.</p></li>
<li><p>haschanged</p>

<p>Run it once to store a file&#39;s hash, and the second time it&#39;ll check
whether the file has changed.
<a href="https://blog.steve.fi/the_traffic_is_waiting_outside.html">https://blog.steve.fi/the_traffic_is_waiting_outside.html</a></p></li>
<li><p>tmp</p>

<p>puts stdin into a temp file and passes it to the specified program</p>

<p>ex: zcat file.bmp.gz | tmp zxgv</p>

<p>Alternative: <a href="http://membled.com/work/apps/pip">pip</a></p></li>
<li><p>connect</p>

<p>connect &#39;cmd1&#39; op &#39;cmd2&#39; ... -- connects fd&#39;s of commands together, etc</p>

<ul>
<li>In the same spirit as &#39;pee&#39;, but much more powerful.</li>
<li>If done very simply, this is handy for writing coprocesses as pipelines
that need to communicate back and forth.</li>
<li>You can do SOME of this with a great shell, like bash or zsh; you can do
almost all the rest with a bunch of mkfifo commands plus simple
redirection, but with added complexity and a lot of manual steps.</li>
<li>This command could be even more powerful if you gave it
essentially a &#34;netlist&#34; of fd&#39;s to connect. I&#39;m sure the command line
syntax could be improved, but you get the idea. Very very complex
example just to illustrate:
  connect &#39;cmd1&#39; &#39;&lt;&gt; #0:3&gt;4&#39; &#39;cmd2&#39; &#39;3&gt;&#39; \
  &#39;cmd3&#39; &#39;3&lt;&gt;3 #0:0&gt;&#39; &#39;cmd4&#39; &#39;3&gt;#1:5&#39;

<pre><code>* specs specify connections between adjacent cmds
* qualified specs (w/ &#39;#&#39;) allow more complex connections
* Some sane defaults, but can be overridden
  * stdin goes to first process that doesn&#39;t redirect it
  * stdout comes from everyone that doesn&#39;t redirect it
  * stderr comes from everyone that doesn&#39;t redirect it
* cmd1&#39;s stdout -&gt; cmd2&#39;s stdin
* cmd2&#39;s stdout -&gt; cmd1&#39;s stdin
* fd3           -&gt; cmd2&#39;s fd4
* cmd2&#39;s fd3    -&gt; cmd3&#39;s stdin
* cmd3&#39;s fd3    -&gt; cmd4&#39;s fd3
* cmd4&#39;s fd3    -&gt; cmd3&#39;s fd3
* stdin         -&gt; cmd4
* cmd4&#39;s fd3    -&gt; cmd1&#39;s fd5
* stdout &lt;- all w/o redirected stdout (in this case, cmd3)
* stderr &lt;- all w/o redirected stderr (in this case, all)
</code></pre></li>
<li><p>If you think this is a good idea, let me know. I have a basic connect
command, but it only does two commands. However, I&#39;ll be happy to code
this up if there is interest. (In fact, I think I may anyway, so I don&#39;t
keep doing stuff like this ad-hoc all the time).  -- from Wesley J. Landaker</p></li>
<li><p>Should be possible to roll mispipe up into this by adding a way to flag
which command(s) exit status to return.</p></li>
</ul>
</li>
</ul>


<h2>Rejected tools</h2>

<p>(Some of these rejections may be reconsidered later.)</p>

<ul>
<li><p>add</p>

<p>adds up numbers from stdin</p>

<p>Already available in <a href="https://suso.suso.org/programs/num-utils/index.phtml">numutils</a>.
RFP bug filed.</p></li>
<li><p>todist</p>

<p>inputs a list of numbers and outputs their distribution, a value
and how many time it occurs in the input
<a href="http://baruch.ev-en.org/files/todist">http://baruch.ev-en.org/files/todist</a></p>

<p>More suitable for <a href="https://suso.suso.org/programs/num-utils/index.phtml">numutils</a>,
which can probably do it already. RFP bug filed.</p></li>
<li><p>tostats</p>

<p>inputs a list of numbers and outputs some statistics about the
numbers: average, stddev, min, max, mid point
<a href="http://baruch.ev-en.org/files/tostats">http://baruch.ev-en.org/files/tostats</a></p>

<p>More suitable for <a href="https://suso.suso.org/programs/num-utils/index.phtml">numutils</a>,
which can probably do it already. RFP bug filed.</p></li>
<li><p>unsort</p>

<p>Randomise the lines of a file. Perfect candidate, but bogosort and rl
(from the randomize-lines package) already do it.</p>

<p><a href="http://savannah.nongnu.org/projects/shuffle/">http://savannah.nongnu.org/projects/shuffle/</a> is a similar thing,
which its author describes as &#34;almost coreutil ready, but its memory
bound, a big nono&#34;. (Apparently coreutils 6 has a <code>shouf</code> and <code>sort
--random-sort</code>.)</p></li>
<li><p><code>mime</code></p>

<p>determines the mime type of a file using the gnome mine database</p>

<p>The File::MimeInfo perl module has a <code>mimetype</code> that works like this, and
uses the freedesktop.org mime database, same as GNOME.</p>

<p><code>file -bi</code> can do this too.</p></li>
<li><p>srename</p>

<p>Applies a sed pattern to a list of files to rename them. Rejected because
perl has a <code>rename</code> program that works nearly identically.</p></li>
</ul>


</section>







</div>



</article></div>
  </body>
</html>
