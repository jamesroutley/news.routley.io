<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://railsatscale.com/2025-02-12-tiny-jits-for-a-faster-ffi/">Original</a>
    <h1>Tiny JITs for a Faster FFI</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>Can we have a faster FFI for CRuby?  Yes.</p>

<h2 id="can-we-have-a-faster-ffi-for-cruby">Can we have a faster FFI for CRuby?</h2>

<p>I love programming in Ruby, and I advocate for people to write as much Ruby as possible.
But sometimes you really really must call out to native code.
Even in those cases, I encourage people to <em>write as much Ruby as possible</em>, especially because YJIT can optimize Ruby code but not C code.</p>

<p>Taken to its logical extreme, this guidance means that if you want to call a native library, you should write a native extension with a very very limited API
where most work is done in Ruby.
Any native code would be a very thin wrapper around the function <em>we actually want to call</em> that just converts Ruby types in to the types required by the native function.</p>

<p>Of course such a simplistic API would be well suited to work with a library like FFI.</p>

<p>Now, usually I steer clear of FFI, and to be honest the reason is simply that it doesn’t provide the same performance as a native extension.</p>

<p>Lets take a look at a very simple example benchmark to better understand what I mean.
In this benchmark, we’re going to wrap the <code>strlen</code> C function with FFI.
We’ll compare the FFI implementation with a C extension that does the same thing (using the <code>strlen</code> Ruby Gem that yours truly wrote just for this post).
We’ll also include a comparison with indirectly calling the <code>String#bytesize</code>, as well as directly calling <code>String#bytesize</code>.</p>

<div><div><pre><code><span>require</span> <span>&#34;ffi&#34;</span>
<span>require</span> <span>&#34;strlen&#34;</span>
<span>require</span> <span>&#34;benchmark/ips&#34;</span>

<span>module</span> <span>A</span>
  <span>extend</span> <span>FFI</span><span>::</span><span>Library</span>
  <span>ffi_lib</span> <span>&#39;c&#39;</span>
  <span>attach_function</span> <span>:strlen</span><span>,</span> <span>[</span><span>:string</span><span>],</span> <span>:int</span>
<span>end</span>

<span>module</span> <span>B</span>
  <span>def</span> <span>self</span><span>.</span><span>strlen</span><span>(</span><span>x</span><span>)</span>
    <span>x</span><span>.</span><span>bytesize</span>
  <span>end</span>
<span>end</span>

<span>str</span> <span>=</span> <span>&#34;foo&#34;</span>

<span>Benchmark</span><span>.</span><span>ips</span> <span>do</span> <span>|</span><span>x</span><span>|</span>
  <span>x</span><span>.</span><span>report</span><span>(</span><span>&#34;strlen-ffi&#34;</span><span>)</span>  <span>{</span> <span>A</span><span>.</span><span>strlen</span><span>(</span><span>str</span><span>)</span> <span>}</span>
  <span>x</span><span>.</span><span>report</span><span>(</span><span>&#34;strlen-ruby&#34;</span><span>)</span> <span>{</span> <span>B</span><span>.</span><span>strlen</span><span>(</span><span>str</span><span>)</span> <span>}</span>
  <span>x</span><span>.</span><span>report</span><span>(</span><span>&#34;strlen-cext&#34;</span><span>)</span> <span>{</span> <span>Strlen</span><span>.</span><span>strlen</span><span>(</span><span>str</span><span>)</span> <span>}</span>
  <span>x</span><span>.</span><span>report</span><span>(</span><span>&#34;ruby-direct&#34;</span><span>)</span> <span>{</span> <span>str</span><span>.</span><span>bytesize</span> <span>}</span>
  <span>x</span><span>.</span><span>compare!</span>
<span>end</span>
</code></pre></div></div>

<p>Here is the output from the benchmark:</p>

<div><div><pre><code>ruby 3.5.0dev (2025-02-11T16:42:26Z master 4ac75f6f64) +PRISM [arm64-darwin24]
Warming up --------------------------------------
          strlen-ffi     1.557M i/100ms
         strlen-ruby     2.875M i/100ms
         strlen-cext     3.047M i/100ms
         ruby-direct     4.048M i/100ms
Calculating -------------------------------------
          strlen-ffi     15.682M (± 0.5%) i/s   (63.77 ns/i) -     79.398M in   5.063141s
         strlen-ruby     28.697M (± 0.3%) i/s   (34.85 ns/i) -    143.747M in   5.009135s
         strlen-cext     30.661M (± 0.8%) i/s   (32.61 ns/i) -    155.406M in   5.068838s
         ruby-direct     39.879M (± 0.6%) i/s   (25.08 ns/i) -    202.412M in   5.075857s

Comparison:
         ruby-direct: 39878845.7 i/s
         strlen-cext: 30661398.4 i/s - 1.30x  slower
         strlen-ruby: 28697184.3 i/s - 1.39x  slower
          strlen-ffi: 15681971.0 i/s - 2.54x  slower
</code></pre></div></div>

<p>First, directly calling <code>String#bytesize</code> is the fastest, and we can think of it as our baseline.
Any indirection we add will necessarily add more overhead, and we probably can’t “beat” this number.
Calling <code>strlen</code> via C extension is second fastest, followed by indirectly calling <code>String#bytesize</code>, and finally the FFI implementation is slowest.</p>

<p>These benchmark results can teach us a couple interesting things.</p>

<p>First, the difference between the “ruby-direct” benchmark and the “strlen-ruby” benchmark shows that there definitely is overhead in pushing and popping stack frames.
Eliminating this overhead is one of the things that JIT compilers like YJIT specialize in.</p>

<p>Second, the difference between the “strlen-cext” benchmark and the “strlen-ffi” benchmark shows that there is significant overhead incurred when calling a native function via FFI.
Calling the C extension is slower than directly calling <code>String#bytesize</code>, but calling <code>strlen</code> via FFI adds <em>even more</em> overhead than the C extension does.</p>

<p>In other words, if Ruby provides a method to do something you need, then just use the method that Ruby provides.
But if you need to call a foreign function, a small C extension wrapper will generally have less overhead than an FFI wrapper.</p>

<p>I’ve not avoided FFI because I think it’s <em>intrinsically worse</em> than a C extension.
Rather, paying the FFI tax is just a reality I’ve tried to avoid.</p>

<h3 id="can-we-change-reality">Can we change reality?</h3>

<p>A few years ago <a href="https://chrisseaton.com/">Chris Seaton</a> gave me an idea that’s been rattling around in my head ever since.
Rather than calling out to a 3rd party library, could we just JIT the code required to call the external function?</p>

<p>Lets take a look at the FFI wrapper example:</p>

<div><div><pre><code><span>module</span> <span>A</span>
  <span>extend</span> <span>FFI</span><span>::</span><span>Library</span>
  <span>ffi_lib</span> <span>&#39;c&#39;</span>
  <span>attach_function</span> <span>:strlen</span><span>,</span> <span>[</span><span>:string</span><span>],</span> <span>:int</span>
<span>end</span>
</code></pre></div></div>

<p>The call to <code>attach_function</code> tells us the name of the function we need to call (<code>strlen</code>) as well as the parameter types (a string) and the return type (an int).
Since we know these types at the time we’re defining the wrapper function, we could generate the machine code required to wrap and unwrap Ruby types, as well as call in to the foreign function.</p>

<p>For years I’ve been scheming for a way to do this, and I think the stars will finally align with the release of Ruby 3.5 later this year.</p>

<p>In order to make this dream happen, we need a few things to come together.</p>

<p>First, we need a way to generate machine code. This is why I wrote <a href="https://github.com/tenderlove/aarch64">the AArch64 gem</a> as well as <a href="https://github.com/tenderlove/fisk">the Fisk gem</a> which can generate ARM64 and x86_64 machine code respectively.</p>

<p>Second, we need a way to allocate executable memory so that we can actually <em>execute</em> the machine code.
Assembling machine code isn’t good enough, we have to place that machine code in memory that’s marked as “executable”.
That is why I wrote the creatively named <a href="https://github.com/tenderlove/jit_buffer">JITBuffer gem</a>.</p>

<p>With these utilities, we have a way to generate executable machine code.
Unfortunately, we have one more hurdle to overcome, and that is trying to <em>get Ruby to jump in to the machine code</em>.</p>

<p>It’s not good enough to just generate executable machine code.
Any rag-tag team of misfits can do that.
We also need to get Ruby to jump in to that machine code so that we can <em>skip the FFI overhead</em>.</p>

<h3 id="leveraging-rjit">Leveraging RJIT</h3>

<p>For those that don’t know, RJIT is a JIT compiler for Ruby that is itself written in Ruby, and also it ships with Ruby.
It’s internal structure is quite similar to YJIT, but it wasn’t intended for production use, which is why most people have probably heard of YJIT but not RJIT.</p>

<p>Kokubun, the author of RJIT, recently filed a feature request to <a href="https://bugs.ruby-lang.org/issues/21116">extract RJIT as a gem</a>.
The major feature provided by this extraction is that people will be able to more easily write JIT compilers for Ruby as 3rd party gems.
The proposed feature does 2 important things.</p>

<p>First, it extracts RJIT as a gem.  RJIT uses a mechanism similar to <a href="https://github.com/rust-lang/rust-bindgen">bindgen from Rust</a>, where it <strong>generates Ruby data structures</strong> that map out all of Ruby’s internal types (you can see some of that generated code <a href="https://github.com/ruby/ruby/blob/f32d5071b7b01f258eb45cf533496d82d5c0f6a1/rjit_c.rb">here</a>).  This means that 3rd party JIT compilers can get the information they need to <em>wrap and unwrap Ruby data types</em>.</p>

<p>The second important thing it does is <em>always execute the JIT entry function pointer if there is one</em>.  This is important because it means that 3rd party JITs will have a way to register their machine code and Ruby will automatically jump to that machine code.</p>

<p>With these two pieces in place, we can write a very small-scale, single-purpose JIT compiler that acts as an FFI interface.</p>

<h3 id="proof-of-concept">Proof of Concept</h3>

<p>I created a very small <a href="https://gist.github.com/tenderworks/f4cbb60f2c0dc3ab334eb73fec36f702">proof of concept</a> called “FJIT”.
“FJIT” is short for “FFI JIT” and does what it says on the tin.
Namely, it generates machine code at runtime that can call a foreign function.
In this case we’re going to use it to call the <code>strlen</code> function.</p>

<p>I’m not going to put the entire program in this post because even though it’s “small”, it still contains a whole JIT compiler.
The important part is the benchmark:</p>

<div><div><pre><code><span>module</span> <span>A</span>
  <span>extend</span> <span>FFI</span><span>::</span><span>Library</span>
  <span>ffi_lib</span> <span>&#39;c&#39;</span>
  <span>attach_function</span> <span>:strlen</span><span>,</span> <span>[</span><span>:string</span><span>],</span> <span>:int</span>
<span>end</span>

<span>module</span> <span>B</span>
  <span>def</span> <span>self</span><span>.</span><span>strlen</span><span>(</span><span>x</span><span>)</span>
    <span>x</span><span>.</span><span>bytesize</span>
  <span>end</span>
<span>end</span>

<span>module</span> <span>C</span>
  <span>extend</span> <span>FJIT</span>
  <span>attach_function</span> <span>:strlen</span><span>,</span> <span>[</span><span>:string</span><span>],</span> <span>:int</span>
<span>end</span>

<span>str</span> <span>=</span> <span>&#34;foo&#34;</span>

<span>Benchmark</span><span>.</span><span>ips</span> <span>do</span> <span>|</span><span>x</span><span>|</span>
  <span>x</span><span>.</span><span>report</span><span>(</span><span>&#34;strlen-ffi&#34;</span><span>)</span>  <span>{</span> <span>A</span><span>.</span><span>strlen</span><span>(</span><span>str</span><span>)</span> <span>}</span>
  <span>x</span><span>.</span><span>report</span><span>(</span><span>&#34;strlen-ruby&#34;</span><span>)</span> <span>{</span> <span>B</span><span>.</span><span>strlen</span><span>(</span><span>str</span><span>)</span> <span>}</span>
  <span>x</span><span>.</span><span>report</span><span>(</span><span>&#34;strlen-cext&#34;</span><span>)</span> <span>{</span> <span>Strlen</span><span>.</span><span>strlen</span><span>(</span><span>str</span><span>)</span> <span>}</span>
  <span>x</span><span>.</span><span>report</span><span>(</span><span>&#34;ruby-direct&#34;</span><span>)</span> <span>{</span> <span>str</span><span>.</span><span>bytesize</span> <span>}</span>
  <span>x</span><span>.</span><span>report</span><span>(</span><span>&#34;strlen-fjit&#34;</span><span>)</span> <span>{</span> <span>C</span><span>.</span><span>strlen</span><span>(</span><span>str</span><span>)</span> <span>}</span>
  <span>x</span><span>.</span><span>compare!</span>
<span>end</span>
</code></pre></div></div>

<p>Module <code>C</code> in this updated benchmark uses an <code>FJIT</code> module, and you can see that its interface is very similar to that of FFI.
When <code>attach_function</code> is called, FJIT will generate the machine code required to unwrap the Ruby string, call the <code>strlen</code> function, and return the length of the string as a Ruby object.</p>

<p>Here are the benchmark results:</p>

<div><div><pre><code>ruby 3.5.0dev (2025-02-11T16:42:26Z master 4ac75f6f64) +RJIT +PRISM [arm64-darwin24]
Warming up --------------------------------------
          strlen-ffi     1.558M i/100ms
         strlen-ruby     2.953M i/100ms
         strlen-cext     2.981M i/100ms
         ruby-direct     4.142M i/100ms
         strlen-fjit     3.206M i/100ms
Calculating -------------------------------------
          strlen-ffi     15.629M (± 0.7%) i/s   (63.98 ns/i) -     79.455M in   5.083899s
         strlen-ruby     28.851M (± 0.3%) i/s   (34.66 ns/i) -    144.704M in   5.015659s
         strlen-cext     29.778M (± 2.8%) i/s   (33.58 ns/i) -    149.025M in   5.008456s
         ruby-direct     41.907M (± 0.8%) i/s   (23.86 ns/i) -    211.219M in   5.040449s
         strlen-fjit     32.508M (± 0.9%) i/s   (30.76 ns/i) -    163.504M in   5.030060s

Comparison:
         ruby-direct: 41907248.7 i/s
         strlen-fjit: 32507961.2 i/s - 1.29x  slower
         strlen-cext: 29778234.0 i/s - 1.41x  slower
         strlen-ruby: 28850712.3 i/s - 1.45x  slower
          strlen-ffi: 15629443.7 i/s - 2.68x  slower
</code></pre></div></div>

<p>Of course directly calling <code>String#bytesize</code> is still the fastest. However, the machine code generated by FJIT is second fastest.
Surprisingly, it’s slightly faster than the <code>strlen</code> C extension.
But even more promising is that it’s faster than the indirect Ruby call, and more than 2x faster than calling via FFI!</p>

<h3 id="conclusion">Conclusion</h3>

<p>I think this is very exciting because it means that we can achieve the same speeds (or even better) than a C extension while maintaining the “write as much Ruby as possible” philosophy.
I’ve been very jealous of programming languages like Zig, that are able to support calling native code without the use of FFI.
If we can get all of these moving parts to settle, then I think Ruby can have the same advantages.</p>

<h3 id="caveats">Caveats</h3>

<p>I know the conclusion is supposed to come last, since it is a “conclusion”.
But I didn’t want people to wade through the current caveats before getting to the good stuff.</p>

<p>First, the JIT compiler I wrote <a href="https://gist.github.com/tenderworks/f4cbb60f2c0dc3ab334eb73fec36f702">in the proof of concept</a> is limited to ARM64 platforms.
If we want to make this “for real”, we need to add an x86_64 backend.
Of course this is possible, it just needs to be done.
Second, it currently doesn’t handle all parameter types and return types.
I am confident we can support all parameter types and the work would not be onerous.
Third, it also only handles functions that take a single parameter and return a single parameter.
Again, I think it’s just a matter of fleshing out the rest of the compiler.
Fourth, you have to run Ruby with <code>--rjit --rjit-disable</code> flags at the moment.
Once <a href="https://bugs.ruby-lang.org/issues/21116">Kokubun’s feature</a> lands, that shouldn’t be the case anymore.
Last, this proof of concept only runs with current Ruby head at the moment.</p>

<p>Whew, I know its a fairly long list of restrictions, but it is shorter than the average EULA, and also nothing we can’t overcome.</p>

<p>Anyway, that’s the end. Have a good day!</p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
