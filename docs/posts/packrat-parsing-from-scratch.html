<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.bruce-hill.com/packrat-parsing-from-scratch">Original</a>
    <h1>Packrat Parsing from Scratch</h1>
    
    <div id="readability-page-1" class="page"><div>
<article>
<p><img src="https://www.johndcook.com/media/packrat-parsing/parse-tree.png" alt="Packrat
Parsing from Scratch"/>
</p>

<p>How to implement a packrat parser from scratch, one easy
piece at a time.</p>
<p>Estimated reading time: 12 mins</p>

<span>June 5, 2021</span>

<p>Packrat parsing is a relatively new approach to parsing code introduced by
Bryan Ford in <a href="https://pdos.csail.mit.edu/~baford/packrat/thesis/" target="_blank" rel="noreferrer">his 2002 Master’s thesis.</a> Packrat parsers
are capable of very efficiently parsing a class of grammars called Parsing
Expression Grammars (PEGs). I covered PEGs in more depth in my previous post, <a href="https://www.johndcook.com/pegs-and-the-structure-of-languages">PEGs and the Structure of
Languages</a>, so if you’re new to the topic, I recommend you begin there. The
packrat parser is based on earlier work on recursive descent parsers, dating
back to the 70s, but focused specifically on Parsing Expression Grammars. In
this post, I’ll attempt to demystify packrat parsers by walking through a
complete packrat parser implementation that fits in a few dozen lines of
Javascript code.</p>
<p>The core idea of the packrat parsing algorithm is incredibly simple. It boils
down to: when you attempt to match a rule at a particular position, remember
whether it succeeds, and if so, how much input it consumes. Because PEGs have no
context-dependencies, if a pattern matches in a particular place in a string, it
will <em>always</em> match there, exactly the same, regardless of where it fits
into a larger structure. This means there’s a fixed number of combinations of
grammar rules to match and string positions to match them at. There’s no need to
try matching the same pattern in different ways at the same position. Here, you
can see what the parsing algorithm looks like in action (click “Run” to run the
demo):</p>

<h2 id="making-a-packrat-parser">Making a Packrat Parser</h2>
<p>The architecture I’m going to use is a functional style that represents
grammar rules as functions that will either match an input string or not, and
return some information if it does match. This makes the implementation easy,
but a more efficient approach might be to use a virtual machine. We’re going to
start with a simple container class that stores info about the match:</p>
<p><span>Here, <code>start</code> is <em>inclusive</em> and
<code>end</code> is <em>exclusive</em>, i.e. <code>start</code> is the index
where the match begins, and <code>end</code> is the index where subsequent
matches would begin. A zero-length match would have
<code>start == end</code>.</span></p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>class</span> Match {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span>constructor</span>(text<span>,</span> start<span>,</span> end<span>,</span> children<span>=</span>[]) {</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span>this</span><span>.</span><span>text</span> <span>=</span> text<span>;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span>this</span><span>.</span><span>start</span> <span>=</span> start<span>;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span>this</span><span>.</span><span>end</span> <span>=</span> end<span>;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span>this</span><span>.</span><span>children</span> <span>=</span> children<span>;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h2 id="pattern-building-blocks">Pattern Building Blocks</h2>
<p>Next, let’s begin implementing support for matching different pattern types.
The first and simplest pattern is one that matches literal text. The
<code>literal</code> pattern will check whether the exact string match occurs at
the starting string position:</p>
<p><span>In Javascript, functions implicitly return
<code>undefined</code> if they run to the end without an explicit
<code>return</code> statement, so that will represent “no match.”</span></p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>function</span> <span>literal</span>(pattern) {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span>return</span> ((text<span>,</span> i)<span>=&gt;</span> {</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span>if</span> (text<span>.</span><span>startsWith</span>(pattern<span>,</span> i))</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>      <span>return</span> <span>new</span> <span>Match</span>(text<span>,</span> i<span>,</span> i<span>+</span>pattern<span>.</span><span>length</span>)<span>;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  })<span>;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Using this, we can perform simple string matching:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>var</span> HelloPattern <span>=</span> <span>literal</span>(<span>&#34;hello&#34;</span>)<span>;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span>HelloPattern</span>(<span>&#34;hello world&#34;</span><span>,</span> <span>0</span>)<span>;</span> <span>// -&gt; new Match(text, 0, 5))</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span>HelloPattern</span>(<span>&#34;goodbye&#34;</span><span>,</span> <span>0</span>)<span>;</span> <span>// -&gt; no match (undefined)</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span>HelloPattern</span>(<span>&#34;hello world&#34;</span><span>,</span> <span>5</span>)<span>;</span> <span>// -&gt; no match at index 5</span></span></code></pre></div>
<p>Great, that works! Let’s get to the meatier patterns. The next pattern is a
chain or sequence of other patterns one after the other:</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>function</span> <span>chain</span>(<span>...</span>patterns) {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span>return</span> ((text<span>,</span> i)<span>=&gt;</span> {</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span>let</span> children <span>=</span> []<span>,</span> start <span>=</span> i<span>;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span>for</span> (<span>let</span> pattern <span>of</span> patterns) {</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>      <span>let</span> result <span>=</span> <span>pattern</span>(text<span>,</span> i)<span>;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>      <span>if</span> (<span>!</span>result) <span>return</span><span>;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>      children<span>.</span><span>push</span>(result)<span>;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>      i <span>=</span> result<span>.</span><span>end</span><span>;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>new</span> <span>Match</span>(text<span>,</span> start<span>,</span> i<span>,</span> children)<span>;</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>  })<span>;</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>We can use it like this:</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>var</span> HelloWorldPattern <span>=</span> <span>chain</span>(</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span>literal</span>(<span>&#34;hello&#34;</span>)<span>,</span> <span>literal</span>(<span>&#34; &#34;</span>)<span>,</span> <span>literal</span>(<span>&#34;world&#34;</span>))<span>;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span>HelloWorldPattern</span>(<span>&#34;hello world&#34;</span><span>,</span> <span>0</span>)<span>;</span> <span>// -&gt; new Match(text, 0, 11))</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span>HelloWorldPattern</span>(<span>&#34;goodbye&#34;</span><span>,</span> <span>0</span>)<span>;</span> <span>// -&gt; undefined</span></span></code></pre></div>
<p>Now, let’s get to the first really interesting pattern: a branching choice
option. This will walk through a list of patterns one at a time, and return the
results of the first one that succeeds:</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>function</span> <span>oneof</span>(<span>...</span>patterns) {</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span>return</span> ((text<span>,</span> i)<span>=&gt;</span> {</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span>for</span> (<span>let</span> pattern <span>of</span> patterns) {</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>      <span>let</span> result <span>=</span> <span>pattern</span>(text<span>,</span> i)<span>;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>      <span>if</span> (result) <span>return</span> result<span>;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  })<span>;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>We can use it like this:</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span>var</span> AddressWorldPattern <span>=</span> <span>chain</span>(</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span>oneof</span>(<span>literal</span>(<span>&#34;hello&#34;</span>)<span>,</span> <span>literal</span>(<span>&#34;goodbye&#34;</span>))<span>,</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span>literal</span>(<span>&#34; &#34;</span>)<span>,</span> <span>literal</span>(<span>&#34;world&#34;</span>))<span>;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span>AddressWorldPattern</span>(<span>&#34;hello world&#34;</span><span>,</span> <span>0</span>)<span>;</span> <span>// -&gt; new Match(text, 0, 11))</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span>AddressWorldPattern</span>(<span>&#34;goodbye world&#34;</span><span>,</span> <span>0</span>)<span>;</span> <span>// -&gt; new Match(text, 0, 13)</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span>AddressWorldPattern</span>(<span>&#34;hello sky&#34;</span><span>,</span> <span>0</span>)<span>;</span> <span>// -&gt; undefined</span></span></code></pre></div>
<p>At this point, we need a way to match repeating patterns. There’s two ways to
do that: looping and recursion. I’m going to choose recursion here because it
will make it easier to have a fine-grained cache in the future (this will have
one recursive function call per iteration). The approach for recursion is to
recursively define “0 or more repetitions of a pattern” to mean: either the
pattern followed by 0 or more repetitions of the pattern, or the empty string
(in PEG syntax: <code>repeating <span>&lt;-</span> (pat repeating) <span>/</span> <span>&#34;&#34;</span></code>).
Because PEGs formally specify parsing order, the empty string will only match if
“one or more repetitions” doesn’t match:</p>
<p><span>The code here uses a lazy lookup of
<code>zero_or_more</code> using a function closure. This is a little hacky, but
later, we will implement a less hacky way to do this.</span></p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span>function</span> <span>repeat</span>(pattern) {</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span>let</span> zero_or_more <span>=</span> <span>oneof</span>(</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>      <span>chain</span>(pattern<span>,</span> (text<span>,</span>i)<span>=&gt;</span><span>zero_or_more</span>(text<span>,</span>i))<span>,</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>      <span>literal</span>(<span>&#34;&#34;</span>))<span>;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span>return</span> zero_or_more</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>These four primitive pattern types (literals, chains, options, and repeating)
are incredibly powerful, and you can define a huge range of PEG grammars in with
only these tools, but there’s one thing missing: negation. Negation will allow
us to specify that something <em>shouldn’t</em> match a pattern (e.g. variables
can’t be keywords). A successful negation will return a zero-length result that
means “the pattern I’m negating doesn’t match at my starting position:”</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>function</span> <span>not</span>(pattern) {</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span>return</span> ((text<span>,</span> i) <span>=&gt;</span> {</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span>if</span> (<span>!</span><span>pattern</span>(text<span>,</span> i))</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>      <span>return</span> <span>new</span> <span>Match</span>(text<span>,</span>i<span>,</span>i)<span>;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  })<span>;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Now, the last component here isn’t strictly necessary, but it’s very handy to
have a wildcard pattern that matches any single character, the equivalent of
<code>.</code> in regular expressions. You could achieve the same goal by
creating a <code>oneof()</code> that has a <code>literal()</code> corresponding
to every character, but that’s just tedious.</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span>function</span> <span>anychar</span>() {</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span>return</span> ((text<span>,</span> i)<span>=&gt;</span> {</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span>if</span> (i <span>&lt;</span> text<span>.</span><span>length</span>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>      <span>return</span> <span>new</span> <span>Match</span>(text<span>,</span> i<span>,</span> i<span>+</span><span>1</span>)<span>;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  })<span>;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h2 id="a-simple-csv-parser">A Simple CSV Parser</h2>
<p>With these functions, we can implement a parser for a full language! Let’s
try it out with a CSV parser (comma separated values) to see what it will look
like:</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span>// Equivalent to the regex: [^,\n]*</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span>let</span> CSVItem <span>=</span> <span>repeat</span>(<span>chain</span>(<span>not</span>(<span>&#34;,&#34;</span>)<span>,</span> <span>not</span>(<span>&#34;</span><span>\n</span><span>&#34;</span>)<span>,</span> <span>anychar</span>()))<span>;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span>// Sorta like: CSVItem (&#34;,&#34; CSVItem)*</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span>let</span> CSVLine <span>=</span> <span>chain</span>(CSVItem<span>,</span> <span>repeat</span>(<span>chain</span>(<span>&#34;,&#34;</span><span>,</span> CSVItem)))<span>;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span>// Sorta like: CSVLine (&#34;\n&#34; CSVLine)*</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span>let</span> CSVFile <span>=</span> <span>chain</span>(CSVLine<span>,</span> <span>repeat</span>(<span>chain</span>(<span>&#34;</span><span>\n</span><span>&#34;</span><span>,</span> CSVLine)))<span>;</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span>// It works (but only for validation)</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span>let</span> my_file <span>=</span> <span>&#34;x,y,z</span><span>\n</span><span>a,b,c&#34;</span><span>;</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span>Console</span><span>.</span><span>assert</span>(<span>CSVFile</span>(my_file)) <span>// new Match(...)</span></span></code></pre></div>
<h2 id="capturing-data">Capturing Data</h2>
<p>Right now, the parsing framework is very flexible, but it’s not very
<em>useful</em> because the return value it produces is just a bunch of string
indices. Let’s add the ability to explicitly capture snippets of the source text
and the ability to tag a match with a descriptive name.</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span>function</span> <span>capture</span>(pattern) {</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span>return</span> (text<span>,</span> i)<span>=&gt;</span> {</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span>let</span> result <span>=</span> <span>pattern</span>(text<span>,</span> i)<span>;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span>if</span> (result) {</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>      <span>let</span> match <span>=</span> <span>new</span> <span>Match</span>(</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        text<span>,</span> result<span>.</span><span>start</span><span>,</span> result<span>.</span><span>end</span><span>,</span> [result])<span>;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>      match<span>.</span><span>captured</span> <span>=</span> text<span>.</span><span>substring</span>(i<span>,</span> result<span>.</span><span>end</span>)<span>;</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>      <span>return</span> match<span>;</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  }<span>;</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span>function</span> <span>named</span>(name<span>,</span> pattern) {</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>  <span>return</span> (text<span>,</span> i)<span>=&gt;</span> {</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    <span>let</span> result <span>=</span> <span>pattern</span>(text<span>,</span> i)<span>;</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    <span>if</span> (result) {</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>      <span>let</span> match <span>=</span> <span>new</span> <span>Match</span>(text<span>,</span> i<span>,</span> result<span>.</span><span>end</span><span>,</span> [result])<span>;</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>      match<span>.</span><span>name</span> <span>=</span> name<span>;</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>      <span>return</span> match<span>;</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>  }<span>;</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Now we can define our earlier grammar with captures:</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span>let</span> CSVItem <span>=</span> <span>named</span>(<span>&#34;Item&#34;</span><span>,</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span>capture</span>(<span>repeat</span>(<span>chain</span>(<span>not</span>(<span>literal</span>(<span>&#39;,&#39;</span>)<span>,</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span>not</span>(<span>literal</span>(<span>&#34;</span><span>\n</span><span>&#34;</span>))<span>,</span> <span>anychar</span>()))))<span>;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span>let</span> CSVLine <span>=</span> <span>named</span>(<span>&#34;Line&#34;</span><span>,</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  <span>chain</span>(CSVItem<span>,</span> <span>repeat</span>(<span>chain</span>(<span>literal</span>(<span>&#39;,&#39;</span>)<span>,</span> CSVItem))))</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span>let</span> CSVFile <span>=</span> <span>named</span>(<span>&#34;File&#34;</span><span>,</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  <span>chain</span>(CSVLine<span>,</span> <span>repeat</span>(<span>chain</span>(<span>literal</span>(<span>&#34;</span><span>\n</span><span>&#34;</span>)<span>,</span> CSVLine))))</span></code></pre></div>
<p>This finally gets us to a usable result! Here’s a program that uses our CSV
parser to print the sum of the numbers on each row.</p>
<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span>let</span> my_file <span>=</span> <span>&#34;1,2,3</span><span>\n</span><span>4,5,6&#34;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span>let</span> csv_data <span>=</span> <span>CSVFile</span>(my_file)<span>:</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span>// Extract the captured values from the tree structure</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span>// of chain()s and oneof()s and so forth:</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span>function</span><span>*</span> <span>get_captures</span>(n) {</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  <span>if</span> (n<span>.</span><span>captured</span>) <span>yield</span> n<span>.</span><span>captured</span><span>;</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>  <span>for</span> (<span>let</span> child <span>of</span> n<span>.</span><span>children</span>) {</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span>yield</span> <span>from</span> <span>get_captures</span>(child)<span>;</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span>// Print the sum of the numbers on each row:</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span>for</span> (<span>let</span> row <span>of</span> csv_data<span>.</span><span>children</span>) {</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>  <span>let</span> total <span>=</span> <span>0</span><span>;</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>  <span>for</span> (<span>let</span> item_text <span>of</span> <span>get_captures</span>(row)) {</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>    total <span>+=</span> <span>parseInt</span>(item_text)<span>;</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>  <span>console</span><span>.</span><span>log</span>(total)<span>;</span> <span>// First logs 6, then 15</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h2 id="recursion">Recursion</h2>
<p>Earlier, when we defined the <code>repeat</code> rule, we had to use a
somewhat hacky version of recursion that relied on local variables and function
closures. It worked, but it wasn’t clean. The way to solve this more elegantly
is to use lazy rule lookups on a single grammar object:</p>
<div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span>class</span> Grammar {</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span>ref</span>(name) {</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span>return</span> (text<span>,</span> i) <span>=&gt;</span> <span>this</span>[name](text<span>,</span> i)<span>;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Using this object, we can implement recursive (and corecursive) definitions
by using <code>grammar.ref()</code> instead of referencing the rule directly,
and the lookup will be delayed until after the rule is defined:</p>
<div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span>let</span> g <span>=</span> <span>new</span> <span>Grammar</span>()<span>;</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>g<span>.</span><span>A</span> <span>=</span> <span>chain</span>(<span>&#34;A&#34;</span><span>,</span> <span>oneof</span>(g<span>.</span><span>ref</span>(<span>&#34;A&#34;</span>)<span>,</span> g<span>.</span><span>ref</span>(<span>&#34;B&#34;</span>)<span>,</span> <span>literal</span>(<span>&#34;&#34;</span>)))<span>;</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>g<span>.</span><span>B</span> <span>=</span> <span>chain</span>(<span>&#34;B&#34;</span><span>,</span> <span>oneof</span>(g<span>.</span><span>ref</span>(<span>&#34;B&#34;</span>)<span>,</span> g<span>.</span><span>ref</span>(<span>&#34;A&#34;</span>)<span>,</span> <span>literal</span>(<span>&#34;&#34;</span>)))<span>;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>g<span>.</span><span>AB</span> <span>=</span> <span>oneof</span>(g<span>.</span><span>A</span><span>,</span> g<span>.</span><span>B</span>)<span>;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span>Console</span><span>.</span><span>assert</span>(g<span>.</span><span>AB</span>(<span>&#34;ABBBAAABA&#34;</span><span>,</span> <span>0</span>))<span>;</span></span></code></pre></div>
<h2 id="some-conveniences">Some Conveniences</h2>
<p>There’s also a few other helper functions that provide some features you
might expect or desire to have, like lookaheads (<code><span>&amp;</span>patt</code>), optionals
(<code>patt<span>?</span></code>), character
ranges (<code><span>[a-z]</span></code>),
character sets (<code><span>[aeiou]</span></code>), and inverted
character sets (<code><span>[^,;]</span></code>). All of these can
be implemented in terms of the previously defined functions, but they’re common
enough that it makes sense to make slightly more optimized versions of them and
provide an API to access them easily.</p>
<div id="cb17"><pre><code><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span>// Equivalent to not(not(pattern))</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span>function</span> <span>ahead</span>(pattern) {</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span>return</span> (text<span>,</span>i)<span>=&gt;</span> (<span>pattern</span>(text<span>,</span> i) <span>&amp;&amp;</span> <span>new</span> <span>Match</span>(text<span>,</span> i<span>,</span>i))<span>;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span>// Equivalent to oneof(pattern, literal(&#34;&#34;))</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span>function</span> <span>maybe</span>(pattern) {</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  <span>return</span> (text<span>,</span>i)<span>=&gt;</span> (<span>pattern</span>(text<span>,</span> i) <span>||</span> <span>new</span> <span>Match</span>(text<span>,</span> i<span>,</span>i))<span>;</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span>// Equivalent to oneof(literal(min), ..., literal(max))</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span>function</span> <span>between</span>(min<span>,</span> max) {</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>  <span>return</span> ((text<span>,</span> i)<span>=&gt;</span> {</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>    <span>if</span> (i <span>&lt;</span> text<span>.</span><span>length</span> <span>&amp;&amp;</span> min <span>&lt;=</span> text[i] <span>&amp;&amp;</span> text[i] <span>&lt;=</span> max)</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>      <span>return</span> <span>new</span> <span>Match</span>(text<span>,</span> i<span>,</span> i<span>+</span><span>1</span>)<span>;</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>  })<span>;</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a><span>// Equivalent to oneof(literal(allowed[0], allowed[1], ...))</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a><span>// or chain(not(oneof(...)), anychar()) when inclusive=false</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a><span>function</span> <span>charfrom</span>(allowed<span>,</span> inclusive<span>=</span><span>true</span>) {</span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>  <span>if</span> (<span>!</span>inclusive)</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>chain</span>(<span>not</span>(<span>charfrom</span>(allowed))<span>,</span> <span>anychar</span>())<span>;</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>  <span>return</span> <span>oneof</span>(<span>...</span>allowed)<span>;</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>All right! That’s it. In total, it’s about 100 lines of code for a full
parsing library that can parse any arbitrary PEG. Unfortunately, it’s kinda slow
because it’s not a proper packrat parser. The defining feature of packrat
parsers is that they <em>memoize</em> everything, which is what gives them their
amazing speed.</p>
<h2 id="packrat-parsing">Packrat Parsing</h2>
<p>We can make this code orders of magnitude faster with 10 lines of code, and
one tiny tweak. All it takes adding caching to the definitions:</p>
<div id="cb18"><pre><code><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span>function</span> <span>cached</span>(fn) {</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span>let</span> cache <span>=</span> {}<span>,</span> cache_text <span>=</span> <span>&#34;&#34;</span><span>;</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span>return</span> (text<span>,</span> i)<span>=&gt;</span> {</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span>if</span> (text <span>!=</span> cache_text) <span>// cache is per-input-text</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>      cache <span>=</span> {}<span>,</span> cache_text <span>=</span> text<span>;</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span>if</span> (<span>!</span>(i <span>in</span> cache))</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>      cache[i] <span>=</span> <span>fn</span>(text<span>,</span> i)<span>;</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span>return</span> cache[i]<span>;</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>And then, wrap all the returned functions with <code><span>cached</span>()</code>. For
example, with <code><span>literal</span>()</code>:</p>
<div id="cb19"><pre><code><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span>function</span> <span>literal</span>(pattern) {</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span>return</span> <span>cached</span>((text<span>,</span> i)<span>=&gt;</span> {</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span>if</span> (text<span>.</span><span>startsWith</span>(pattern<span>,</span> i))</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>      <span>return</span> <span>new</span> <span>Match</span>(text<span>,</span> i<span>,</span> i<span>+</span>pattern<span>.</span><span>length</span>)<span>;</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  })<span>;</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>That’s it! This is a complete packrat parser! As you’ve seen, the fundamental
components of a packrat parser are individually quite simple, and there aren’t
very many of them. At its heart, a packrat parser is nothing more than a
memoized matcher of literals, chains, choices, negations, and recursive
references. There’s nothing that’s fundamentally difficult to understand, just a
simple idea that can be implemented in a few dozen lines of code and endlessly
tweaked and improved on.</p>
<h2 id="future-improvements">Future Improvements</h2>
<p>The parser that I’ve walked you through implementing in this post is
asymptotically quite fast. It runs in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>G</mi><mi>N</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(G N)</annotation></semantics></math>
time, where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>
is the size of the grammar and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>
is the size of input text; in other words, for a fixed grammar, you will get
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">θ(N)</annotation></semantics></math>
performance for arbitrary input text. It will also use
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>G</mi><mi>N</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(G N)</annotation></semantics></math>
memory space
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">θ(N)</annotation></semantics></math>
for a fixed grammar). For comparison, packrat parsers are capable of matching
recursive grammars that are <a href="https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags" target="_blank" rel="noreferrer"><em>impossible</em> to match with extended
regular expressions,</a> but can do so in <em>linear time,</em> while extended
regular expressions have potentially unbounded runtime. The downside is that
packrat parsers use an amount of memory proportional to the length of the input
text. <span>Packrat parser runtime may be close to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">θ(N)</annotation></semantics></math>
for arbitrary real-world (non-malicious) grammars, since grammars tend to follow
power-law distributions, where a few rules are called often, but the rest are
only rarely called. When this is the case, the expected number of rules tested
at each string index is bounded by a constant number that doesn’t grow as the
grammar adds more rules.</span> However, the implementation here has a lot of
constant-time overhead on common operations and it can potentially use quite a
lot of stack space. Using a virtual machine with a heap-allocated stack instead
of recursive function calls will lower function call overhead and prevent stack
overflow, but the overall performance would need to be tuned using a profiler to
find performance bottlenecks if you truly cared about speed. In other words,
this blog post is intended to give you an understanding of the concepts behind a
packrat parser, but the code here won’t outperform a real parsing library.</p>
<p>Besides performance, the programming ergonomics could also use a lot of
improvement. The code <code><span>repeat</span>(<span>charfrom</span>(<span>&#39;aeiou&#39;</span>))(input_text<span>,</span> <span>0</span>)</code>
is much more cumbersome than regex pattern matching: <code>input_text<span>.</span><span>match</span>(<span>/</span><span>[aeiou]*</span><span>/</span>)</code>.
Fortunately, the regex/BNF-like PEG grammar discussed in <a href="https://www.johndcook.com/pegs-and-the-structure-of-languages">PEGs and the structure of
languages</a> is <em>itself</em> a grammar that can be parsed by a packrat
parser. In my next post, I’ll discuss how to write a program that automatically
converts PEG-syntax grammars into runnable parsers–in other words, how to make a
parser-generator. As a quick teaser, here is how we might start building it:</p>
<div id="cb20"><pre><code><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span>let</span> g <span>=</span> <span>new</span> <span>Grammar</span>()<span>;</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>g<span>.</span><span>AnyChar</span> <span>=</span> <span>named</span>(<span>&#34;AnyChar&#34;</span><span>,</span> <span>literal</span>(<span>&#34;.&#34;</span>))<span>;</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>g<span>.</span><span>CharSet</span> <span>=</span> <span>named</span>(<span>&#34;CharSet&#34;</span><span>,</span> <span>chain</span>(<span>literal</span>(<span>&#34;[&#34;</span>)<span>,</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  <span>repeat</span>(<span>not</span>(<span>literal</span>(<span>&#34;]&#34;</span>))<span>,</span> <span>capture</span>(<span>anychar</span>()))<span>,</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  <span>literal</span>(<span>&#34;]&#34;</span>)))<span>;</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span>// ...</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>g<span>.</span><span>Expression</span> <span>=</span> <span>oneof</span>(</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>  g<span>.</span><span>ref</span>(<span>&#34;AnyChar&#34;</span>)<span>,</span> g<span>.</span><span>ref</span>(<span>&#34;CharSet&#34;</span>)<span>,</span> <span>...</span>)<span>;</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span>function</span> <span>make_parser</span>(grammar_text) {</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>  <span>let</span> match <span>=</span> g<span>.</span><span>Expression</span>(grammar_text<span>,</span> <span>0</span>)<span>;</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>  <span>if</span> (<span>!</span>match) <span>throw</span> <span>&#34;Grammar failed to compile&#34;</span><span>;</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>  <span>switch</span> (match<span>.</span><span>name</span>) {</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    <span>case</span> <span>&#34;AnyChar&#34;</span><span>:</span> <span>return</span> <span>anychar</span>()<span>;</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>    <span>case</span> <span>&#34;CharSet&#34;</span><span>:</span> <span>return</span> <span>charfrom</span>(<span>get_captures</span>(match))<span>;</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>    <span>//...</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a><span>function</span> <span>match</span>(grammar<span>,</span> text<span>,</span> offset<span>=</span><span>0</span>) {</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>  <span>return</span> <span>make_parser</span>(grammar)(text<span>,</span> offset)</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a><span>let</span> result <span>=</span> <span>match</span>(<span>&#34;[aeiou]&#34;</span><span>,</span> input_text)<span>;</span></span></code></pre></div>
<p>Look forward to a new post coming soon!</p>

</article>

</div></div>
  </body>
</html>
