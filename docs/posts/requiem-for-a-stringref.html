<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wingolog.org/archives/2023/10/19/requiem-for-a-stringref">Original</a>
    <h1>Requiem for a stringref</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>Good day, comrades.  Today&#39;s missive is about strings!</p><h3>a problem for java</h3><p>Imagine you want to compile a program to WebAssembly, with the new <a href="https://github.com/WebAssembly/gc/blob/master/proposals/gc/MVP.md">GC
support for
WebAssembly</a>.
Your WebAssembly program will run on web browsers and render its
contents using the DOM API:
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement"><tt>Document.createElement</tt></a>,
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/createTextNode"><tt>Document.createTextNode</tt></a>,
and so on.  It will also use DOM interfaces to read parts of the page
and read input from the user.</p><p>How do you go about representing your program in WebAssembly?  The GC
support gives you the ability to define a number of different kinds of
<a href="https://webassembly.github.io/gc/core/syntax/types.html#aggregate-types">aggregate data
types</a>:
structs (records), arrays, and functions-as-values.  Earlier versions of
WebAssembly gave you 32- and 64-bit integers, floating-point numbers,
and opaque references to host values (<tt>externref</tt>).  This is what you
have in your toolbox.  But what about strings?</p><p>WebAssembly&#39;s historical answer has been to throw its hands in the air
and punt the problem to its user.  This isn&#39;t so bad: the direct user of
WebAssembly is a compiler developer and can fend for themself.  Using
the primitives above, it&#39;s clear we should represent strings as some
kind of array.</p><p>The source language may impose specific requirements regarding string
representations:  for example, in Java, you will want to use an <tt>(array i16)</tt>, because Java&#39;s strings are specified as sequences of UTF-16¬π code
units, and Java programs are written assuming that random access to a
code unit is constant-time.</p><p>Let&#39;s roll with the Java example for a while.  It so happens that
JavaScript, the main language of the web, also specifies strings in
terms of 16-bit code units.  The DOM interfaces are optimized for
JavaScript strings, so at some point, our WebAssembly program is going
to need to convert its <tt>(array i16)</tt> buffer to a JavaScript string.  You
can imagine that a high-throughput interface between WebAssembly and the
DOM is going to involve a significant amount of copying; could there be
a way to avoid this?</p><p>Similarly, Java is going to need to perform a number of gnarly
operations on its strings, for example, locale-specific collation.  This
is a hard problem whose solution basically amounts to shipping a copy of
<a href="https://unicode-org.github.io/icu/userguide/icu/"><tt>libICU</tt></a> in their
WebAssembly module; that&#39;s a lot of binary size, and it&#39;s not even clear
how to compile <tt>libICU</tt> in such a way that works on GC-managed arrays
rather than linear memory.</p><p>Thinking about it more, there&#39;s also the problem of regular expressions.
A high-performance regular expression engine is a lot of investment, and
not really portable from the native world to WebAssembly, as the main
techniques require just-in-time code generation, which is unavailable on
Wasm.</p><p>This is starting to sound like a terrible system: big binaries, lots of
copying, suboptimal algorithms, and a likely ongoing functionality gap.
What to do?</p><h3>a solution for java</h3><p>One observation is that in the specific case of Java, we could just use
JavaScript strings in a web browser, instead of implementing our own
string library.  We may need to make some shims here and there, but the
basic functionality from JavaScript gets us what we need: constant-time
UTF-16¬π code unit access from within WebAssembly, and efficient access
to browser regular expression, internationalization, and DOM
capabilities that doesn&#39;t require copying.</p><p>A sort of minimum viable product for improving the performance of Java
compiled to Wasm/GC would be to represent strings as
<a href="https://webassembly.github.io/gc/core/syntax/types.html#syntax-heaptype"><tt>externref</tt></a>,
which is WebAssembly&#39;s way of making an opaque reference to a host
value.  You would operate on those values by importing the equivalent of
<tt>String.prototype.charCodeAt</tt> and friends; to get the receivers right
you&#39;d need to run them through
<a href="https://github.com/WebAssembly/stringref/issues/5#issuecomment-1243487288"><tt>Function.call.bind</tt></a>.
It&#39;s a somewhat convoluted system, but a WebAssembly engine could be
taught to recognize such a function and compile it specially, using the
same code that JavaScript compiles to.</p><p>(Does this sound too complicated or too distasteful to implement?
Disabuse yourself of the notion:  it&#39;s happening already.  V8 does this
and other JS/Wasm engines will be forced to follow, as users file bug
reports that such-and-such an app is slow on e.g. Firefox but fast on
Chrome, and so on and so on.  It&#39;s the same dynamic that led <tt>asm.js</tt>
adoption.)</p><p>Getting properly good performance will require a bit more, though.
String literals, for example, would have to be loaded from e.g. UTF-8 in
a WebAssembly data section, then transcoded to a JavaScript string.  You
need a function that can convert UTF-8 to JS string in the first place;
let&#39;s call it <tt>fromUtf8Array</tt>.  An engine can now optimize the
<tt>array.new_data</tt> + <tt>fromUtf8Array</tt> sequence to avoid the intermediate
array creation.  It would also be nice to tighten up the typing on the
WebAssembly side: having everything be <tt>externref</tt> imposes a dynamic
type-check on each operation, which is something that can&#39;t always be
elided.</p><h3>beyond the web?</h3><p>&#34;JavaScript strings for Java&#34; has two main limitations: JavaScript and
Java.  On the first side, this MVP doesn&#39;t give you anything if your
WebAssembly host doesn&#39;t do JavaScript.  Although it&#39;s a bit of a
failure for a universal virtual machine, to an extent, the WebAssembly
ecosystem is OK with this distinction: there are different compiler and
toolchain options when targetting the web versus, say, Fastly&#39;s edge
compute platform.</p><p>But does that mean you can&#39;t run Java on Fastly&#39;s cloud?  Does the Java
compiler have to actually implement all of those things that we were
trying to avoid?  Will Java actually implement those things?  I think
the answers to all of those questions is &#34;no&#34;, but also that I expect a
pretty crappy outcome.</p><p>First of all, it&#39;s not technically required that Java implement its own
strings in terms of <tt>(array i16)</tt>.  A Java-to-Wasm/GC compiler can keep
the strings-as-opaque-host-values paradigm, and instead have these
string routines provided by an auxiliary WebAssembly module that itself
probably uses <tt>(array i16)</tt>, effectively polyfilling what the browser
would give you.  The effort of creating this module can be shared
between e.g. Java and C#, and the run-time costs for instantiating the
module can be amortized over a number of Java users within a process.</p><p>However, I don&#39;t expect such a module to be of good quality.  It doesn&#39;t
seem possible to implement a good regular expression engine that way,
for example.  And, absent a very good run-time system with an adaptive
compiler, I don&#39;t expect the low-level per-codepoint operations to be as
efficient with a polyfill as they are on the browser.</p><p>Instead, I could see non-web WebAssembly hosts being pressured into
implementing their own built-in UTF-16¬π module which has accelerated
compilation, a native regular expression engine, and so on.  It&#39;s nice
to have a portable fallback but in the long run, first-class UTF-16¬π
will be everywhere.</p><h3>beyond java?</h3><p>The other drawback is Java, by which I mean, Java (and JavaScript) is
outdated: if you were designing them today, their strings would not be
UTF-16¬π.</p><p>I keep this little &#34;¬π&#34; sigil when I mention UTF-16 because Java (and
JavaScript) don&#39;t actually use UTF-16 to represent their strings.
UTF-16 is standard <i>Unicode encoding form</i>.  A Unicode encoding form
encodes a sequence of <i>Unicode scalar values</i> (USVs), using one or two
16-bit <i>code units</i> to encode each USV.  A USV is a <i>codepoint</i>: an
integer in the range [0,0x10FFFF], but excluding <i>surrogate
codepoints</i>: codepoints in the range [0xD800,0xDFFF].</p><p>Surrogate codepoints are an accident of history, and occur either when
accidentally slicing a two-code-unit UTF-16-encoded-USV in the middle,
or when treating an arbitrary <tt>i16</tt> array as if it were valid UTF-16.
They are annoying to detect, but in practice are here to stay: no amount
of wishing will make them go away from Java, JavaScript, C#, or other
similar languages from those heady days of the mid-90s.  Believe me, I have
engaged in some serious wishing, but if you, the virtual machine
implementor, want to support Java as a source language, your strings
have to be accessible as 16-bit code units, which opens the door
(eventually) to surrogate codepoints.</p><p>So when I say UTF-16¬π, I really mean
<a href="https://simonsapin.github.io/wtf-8/">WTF-16</a>: sequences of any 16-bit
code units, without the UTF-16 requirement that surrogate code units be
properly paired.  In this way, WTF-16 encodes a larger language than
UTF-16: not just USV codepoints, but also surrogate codepoints.</p><p>The existence of WTF-16 is a consequence of a kind of original sin,
originating in the choice to expose 16-bit code unit access to the Java
programmer, and which everyone agrees should be somehow firewalled off
from the rest of the world.  The usual way to do this is to prohibit
WTF-16 from being transferred over the network or stored to disk: a
message sent via an HTTP <tt>POST</tt>, for example, will never include a
surrogate codepoint, and will either replace it with the U+FFFD
replacement codepoint or throw an error.</p><p>But within a Java program, and indeed within a JavaScript program, there
is no attempt to maintain the UTF-16 requirements regarding surrogates,
because any change from the current behavior would break programs.  (How
many?  Probably very, very few.  But productively deprecating web
behavior is hard to do.)</p><p>If it were just Java and JavaScript, that would be one thing, but WTF-16
poses challenges for using JS strings from non-Java languages.  Consider
that any JavaScript string can be invalid UTF-16: if your language
defines strings as sequences of USVs, which excludes surrogates, what do
you do when you get a fresh string from JS?  Passing your string <i>to</i> JS
is fine, because WTF-16 encodes a superset of USVs, but when you receive
a string, you need to have a plan.</p><p>You only have a few options.  You can eagerly check that a string is
valid UTF-16; this might be a potentially expensive O(n) check, but
perhaps this is acceptable.  (This check may be <a href="https://github.com/tc39/proposal-is-usv-string">faster in the
future</a>.)  Or, you can
replace surrogate codepoints with U+FFFD, when accessing string
contents; lossy, but preserves your language&#39;s semantic domain.  Or, you
can extend your language&#39;s semantics to somehow deal with surrogate
codepoints.</p><p>My point is that if you want to use JS strings in a non-Java-like
language, your language will need to define what to do with invalid
UTF-16.  Ideally the browser will give you a way to put your policy into
practice: replace with U+FFFD, error, or pass through.</p><h3>beyond java? (reprise) (feat: snakes)</h3><p>With that detail out of the way, say you are compiling Python to
Wasm/GC.  <a href="https://docs.python.org/3/reference/datamodel.html#immutable-sequences">Python&#39;s language
reference</a>
says: &#34;A string is a sequence of values that represent Unicode code
points. All the code points in the range U+0000 - U+10FFFF can be
represented in a string.&#34;  This corresponds to the domain of
JavaScript&#39;s strings; great!</p><p>On second thought, how do you actually access the contents of the
string?  Surely not via the equivalent of JavaScript&#39;s
<tt>String.prototype.charCodeAt</tt>; Python strings are sequences of codepoints, not
16-bit code units.</p><p>Here we arrive to the second, thornier problem, which is less about
domain and more about idiom: in Python, we expect to be able to access
strings by codepoint index.  This is the case not only to access string
contents, but also to refer to positions in strings, for example when
extracting a substring.  These operations need to be fast (or fast
enough anyway; CPython doesn&#39;t have a very high performance baseline to
meet).</p><p>However, the web platform doesn&#39;t give us O(1) access to string
codepoints.  Usually a codepoint just takes up one 16-bit code unit, so
the (zero-indexed) 5th codepoint of JS string <tt>s</tt> may indeed be at
<tt>s.codePointAt(5)</tt>, but it may also be at offset 6, 7, 8, 9, or 10.  You
get the point: finding the <i>n</i>th codepoint in a JS string requires a
linear scan from the beginning.</p><p>More generally, <i>all</i> languages will want to expose O(1) access to
<i>some</i> primitive subdivision of strings.  For Rust, this is bytes; 8-bit
bytes are the <i>code units</i> of UTF-8.  For others like Java or C#, it&#39;s
16-bit code units.  For Python, it&#39;s codepoints.  When targetting
JavaScript strings, there may be a performance impedance mismatch
between what the platform offers and what the language requires.</p><p>Languages also generally offer some kind of string iteration facility,
which doesn&#39;t need to correspond to how a JavaScript host sees strings.
In the case of Python, one can implement <tt>for char in s: print(char)</tt>
just fine on top of JavaScript strings, by decoding WTF-16 on the fly.
Iterators can also map between, say, UTF-8 offsets and WTF-16 offsets,
allowing e.g. Rust to preserve its preferred &#34;strings are composed of
bytes that are UTF-8 code units&#34; abstraction.</p><p>Our O(1) random access problem remains, though.  Are we stuck?</p><h3>what does the good world look like</h3><p>How should a language represent its strings, anyway?  Here we depart
from a precise gathering of requirements for WebAssembly strings, but in
a useful way, I think: we should build abstractions not only for what
is, but also for what should be.  We should favor a better future;
imagining the ideal helps us design the real.</p><p>I keep returning to Henri Sivonen&#39;s authoritative article, <a href="https://hsivonen.fi/string-length/">It‚Äôs Not
Wrong that &#34;ü§¶üèº‚Äç‚ôÇÔ∏è&#34;.length == 7, But It‚Äôs Better that &#34;ü§¶üèº‚Äç‚ôÇÔ∏è&#34;.len() == 17
and Rather Useless that len(&#34;ü§¶üèº‚Äç‚ôÇÔ∏è&#34;) ==
5</a>.  It is <i>so</i> good and if you have
reached this point, pop it open in a tab and go through it when you can.
In it, Sivonen argues (among other things) that random access to
codepoints in a string is not actually important; he thinks that if you
were designing Python today, you wouldn&#39;t include this interface in its
standard library.  Users would prefer extended grapheme clusters, which
is variable-length anyway and a bit gnarly to compute; storage wants
bytes; array-of-codepoints is just a bad place in the middle.  Given
that UTF-8 is more space-efficient than either UTF-16 or
array-of-codepoints, and that it embraces the variable-length nature of
encoding, programming languages should just use that.</p><p>As a model for how strings are represented, array-of-codepoints is
outdated, as indeed is UTF-16.  Outdated doesn&#39;t mean irrelevant, of
course; there is lots of Python code out there and we have to support it
somehow.  But, if we are designing for the future, we should nudge our
users towards other interfaces.</p><p>There is even a case that a JavaScript engine should represent its
strings as UTF-8 internally, despite the fact that JS exposes a UTF-16
view on strings in its API.  The pitch is that UTF-8 takes less memory,
is probably what we get over the network anyway, and is probably what
many of the low-level APIs that a browser uses will want; it would be
faster and lighter-weight to pass UTF-8 to text shaping libraries, for
example, compared to passing UTF-16 or having to copy when going to JS
and when going back.  JavaScript engines already have a dozen internal
string representations or so (narrow or wide, cons or slice or flat,
inline or external, interned or not, and the product of many of those);
adding another is just a Small Matter Of Programming that could show
benefits, even if some strings have to be later transcoded to UTF-16
because JS accesses them in that way.  I have talked with JS engine
people in all the browsers and everyone thinks that UTF-8 has a chance
at being a win; the drawback is that actually implementing it would
take a lot of effort for uncertain payoff.</p><p>I have two final data-points to indicate that UTF-8 is the way.  One is
that <a href="https://swift.org/">Swift</a> used to use UTF-16 to represent its
strings, but was able to <a href="https://www.swift.org/blog/utf8-string/">switch to
UTF-8</a>.  To adapt to the newer
performance model of UTF-8, Swift maintainers designed new APIs to allow
users to request a <i>view</i> on a string: treat this string as UTF-8, or
UTF-16, or a sequence of codepoints, or even a sequence of extended
grapheme clusters.  Their users appear to be happy, and I expect that
many languages will follow Swift&#39;s lead.</p><p>Secondly, as a maintainer of the <a href="https://gnu.org/s/guile/">Guile
Scheme</a> implementation, I also want to switch
to UTF-8.  Guile has long used Python&#39;s representation strategy: array
of codepoints, with an optimization if all codepoints are &#34;narrow&#34; (less
than 256).  The Scheme language exposes codepoint-at-offset
(<tt>string-ref</tt>) as one of its fundamental string access primitives, and
array-of-codepoints maps well to this idiom.  However, we do plan to move to
UTF-8, with a Swift-like
<a href="(https://www.swift.org/blog/utf8-string/#breadcrumbs)">breadcrumbs</a>
strategy for accelerating per-codepoint access.  We hope to lower memory
consumption, simplify the implementation, and have general (but not
uniform) speedups; some things will be slower but most should be faster.
Over time, users will learn the performance model and adapt to prefer
string builders / iterators (&#34;string ports&#34;) instead of <tt>string-ref</tt>.</p><h3>a solution for webassembly in the browser?</h3><p>Let&#39;s try to summarize: it definitely makes sense for Java to use
JavaScript strings when compiled to WebAssembly/GC, when running on the
browser.  There is an OK-ish compilation strategy for this use case
involving <tt>externref</tt>, <tt>String.prototype.charCodeAt</tt> imports, and so on,
along with some engine heroics to specially recognize these operations.
There is an <a href="https://github.com/WebAssembly/js-string-builtins/blob/main/proposals/js-string-builtins/Overview.md">early
proposal</a>
to sand off some of the rough edges, to make this use-case a bit more
predictable.  However, there are two limitations:</p><ol><li><p>Focussing on providing JS strings to Wasm/GC is only really good for
Java and friends; the cost of mapping <tt>charCodeAt</tt> semantics to,
say, Python&#39;s strings is likely too high.</p></li><li><p>JS strings are only present on browsers (and Node and such).</p></li></ol><p>I see the outcome being that Java will have to keep its implementation
that uses <tt>(array i16)</tt> when targetting the edge, and use JS strings on
the browser.  I think that polyfills will not have acceptable
performance.  On the edge there will be a binary size penalty and a
performance and functionality gap, relative to the browser.  Some edge
Wasm implementations will be pushed to implement fast JS strings by
their users, even though they don&#39;t have JS on the host.</p><p>If the JS string builtins proposal were a local maximum, I could see
putting some energy into it; it does make the Java case a bit better.
However I think it&#39;s likely to be an unstable saddle point; if you are
going to infect the edge with WTF-16 anyway, you might as well step back and
try to solve a problem that is a bit more general than Java on JS.</p><h3>stringref: a solution for webassembly?</h3><p>I think WebAssembly should just bite the bullet and try to define a
string data type, for languages that use GC.  It should support UTF-8
and UTF-16 views, like Swift&#39;s strings, and support some kind of
iterator API that decodes codepoints.</p><p>It should be abstract as regards the concrete representation of strings,
to allow JavaScript strings to stand in for WebAssembly strings, in the
context of the browser.  JS hosts will use UTF-16 as their
internal representation.  Non-JS hosts will likely prefer UTF-8, and
indeed an abstract API favors migration of JS engines away from UTF-16
over the longer term.  And, such an abstraction should give the user control
over what to do for surrogates: allow them, throw an error, or replace
with U+FFFD.</p><p>What I describe is what the
<a href="https://github.com/WebAssembly/stringref/blob/main/proposals/stringref/Overview.md">stringref</a>
proposal gives you.  We don&#39;t yet have consensus on this proposal in the
Wasm standardization group, and we may never reach there, although I think
it&#39;s still possible.  As I understand them, the objections are two-fold:</p><ol><li><p>WebAssembly is an instruction set, like AArch64 or x86.  Strings are
too high-level, and should be built on top, for example with <tt>(array i8)</tt>.</p></li><li><p>The requirement to support fast WTF-16 code unit access will mean
that we are effectively standardizing JavaScript strings.</p></li></ol><p>I think the first objection is a bit easier to overcome.  Firstly,
WebAssembly now defines quite a number of components that don&#39;t map to
machine ISAs: typed and extensible locals, <tt>memory.copy</tt>, and so on.
You could have defined <tt>memory.copy</tt> in terms of primitive operations,
or required that all local variables be represented on an explicit stack
or in a fixed set of registers, but WebAssembly defines higher-level
interfaces that instead allow for more efficient lowering to machine
primitives, in this case SIMD-accelerated copies or machine-specific
sets of registers.</p><p>Similarly with garbage collection, there was a very interesting
<a href="https://github.com/WebAssembly/exception-handling/issues/105">&#34;continuation marks&#34;
proposal</a>
by Ross Tate that would give a low-level primitive on top of which users
could implement root-finding of stack values.  However when choosing
what to include in the standard, the group preferred a more high-level
facility in which a Wasm module declares managed data types and allows
the WebAssembly implementation to do as it sees fit.  This will likely
result in more efficient systems, as a Wasm implementation can more
easily use concurrency and parallelism in the GC implementation than a
guest WebAssembly module could do.</p><p>So, the criteria of what to include in the Wasm standard is not &#34;what is
the most minimal primitive that can express this abstraction&#34;, or even
&#34;what looks like an ARMv8 instruction&#34;, but rather &#34;what makes Wasm a
good compilation target&#34;.  Wasm is designed for its compiler-users, not
for the machines that it runs on, and if we manage to find an abstract
definition of strings that works for Wasm-targetting toolchains, we
should think about adding it.</p><p>The second objection is trickier.  When you compile to Wasm, you need a
good model of what the performance of the Wasm code that you emit will
be.  Different Wasm implementations may use different stringref
representations; requesting a UTF-16 view on a string that is already
UTF-16 will be cheaper than doing so on a string that is UTF-8.  In the
worst case, requesting a UTF-16 view on a UTF-8 string is a linear
operation on one system but constant-time on another, which in a loop
over string contents makes the former system quadratic: a real
performance failure that we need to design around.</p><p>The stringref proposal tries to reify as much of the cost model as
possible with its &#34;view&#34; abstraction; the compiler can reason that any
cost may incur then rather than when accessing a view.  But, this
abstraction can leak, from a performance perspective.  What to do?</p><p>I think that if we look back on what the expected outcome of the
JS-strings-for-Java proposal is, I believe that if Wasm succeeds as a
target for Java, we will probably already end up with WTF-16 everywhere.
We might as well admit this, I think, and if we do, then this objection
goes away.  Likewise on the Web I see UTF-8 as being potentially
advantageous in the medium-long term for JavaScript, and certainly
better for other languages, and so I expect JS implementations to also
grow support for fast UTF-8.</p><h3>i&#39;m on a horse</h3><p>I may be off in some of my predictions about where things will go, so
who knows.  In the meantime, in the time that it takes other people to
reach the same conclusions, stringref is in a kind of hiatus.</p><p>The <a href="https://gitlab.com/spritely/guile-hoot/">Scheme-to-Wasm compiler</a>
that I work on does still emit stringref, but it is purely a toolchain
concept now: we have a <a href="https://gitlab.com/spritely/guile-hoot/-/blob/main/module/wasm/lower-stringrefs.scm">post-pass that lowers stringref to
WTF-8</a>
via <tt>(array i8)</tt>, and which emits calls to host-supplied conversion
routines when passing these strings to and from the host.  When compiling
to Hoot&#39;s built-in Wasm virtual machine, we can leave stringref in, instead of lowering it down,
resulting in more efficient interoperation with the host Guile than if we had to bounce through byte arrays.</p><p>So, we wait for now.  Not such a bad situation, at least we have GC coming soon to all the browsers.  appy hacking to all my stringfolk, and until next time!</p></div></div></div>
  </body>
</html>
