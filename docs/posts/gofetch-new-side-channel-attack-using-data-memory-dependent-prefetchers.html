<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gofetch.fail">Original</a>
    <h1>GoFetch: New side-channel attack using data memory-dependent prefetchers</h1>
    
    <div id="readability-page-1" class="page"><div>
			<section id="abstract">
				<h4><i></i>Overview of <span>GoFetch Attack</span></h4>
				<div>
					<p>
						GoFetch is a microarchitectural side-channel attack 
						that can extract secret keys from 
						constant-time cryptographic implementations via 
						data memory-dependent prefetchers (DMPs).
						</p>

					

					
				</div>
			</section>

			<section id="demos">
				<h4><i></i>Demo <span>Videos.</span></h4>
				<div>
					<div>
						
						<div>
							<h5>Go&#39;s RSA-2048 Key Extraction on Apple m1</h5>
							
						</div>
						
					</div>
				</div>
			</section>

			<section id="people">
				<h4><i></i>People
					<span>Behind GoFetch</span>
				</h4>
				
			</section>

			<section id="qa">
				<h4><i></i>Frequently Asked <span>Questions</span></h4>

				<div id="all-question-answer">
					<div>
						
						<div id="panelsStayOpen-collapseAffected" aria-labelledby="panelsStayOpen-headingAffected">
							<div>
								<p>
									The GoFetch attack is based on a CPU feature 
									called data memory-dependent prefetcher (DMP), 
									which is present in the latest Apple processors. 
									We reverse-engineered DMPs on Apple m-series CPUs 
									and found that the DMP activates (and attempts to dereference) 
									data loaded from memory that &#34;looks like&#34; a pointer. 
									This explicitly violates a requirement 
									of the constant-time programming paradigm, 
									which forbids mixing data and memory access patterns. 
								</p>
								<p>
									To exploit the DMP, we craft chosen inputs to cryptographic operations, 
									in a way where pointer-like values only appear 
									if we have correctly guessed some bits of the secret key. 
									We verify these guesses by monitoring whether the DMP performs 
									a dereference through cache-timing analysis. 
									Once we make a correct guess, we proceed to guess the next batch of key bits. 
									Using this approach, we show end-to-end key extraction attacks on popular 
									constant-time implementations of classical 
									(OpenSSL Diffie-Hellman Key Exchange, Go RSA decryption) 
									and post-quantum cryptography (CRYSTALS-Kyber and CRYSTALS-Dilithium).
								</p>
							</div>
						</div>
					</div>
					<div>
						
						<div id="panelsStayOpen-collapseDifference" aria-labelledby="panelsStayOpen-headingDifference">
							<p>
								We have mounted end-to-end GoFetch attacks on Apple hardware equipped with m1 processors. 
								We also tested DMP activation patterns on other Apple processors 
								and found that m2 and m3 CPUs also exhibit similar exploitable DMP behavior. 
								While we have not tested other m-series variants (e.g., m2 Pro, etc), 
								we hypothesize that since these parts have the same microarchitecture as their simpler counterparts, 
								they are likewise equipped with exploitable DMPs. 
								Finally, we found that Intel&#39;s 13th Gen Raptor Lake microarchitecture also features a DMP. 
								However, its activation criteria are more restrictive, making it robust to our attacks.
							</p>
						</div>
					</div>
					<div>
						
						<div id="panelsStayOpen-collapseCacheAttack" aria-labelledby="panelsStayOpen-headingCacheAttack">
							<div>
								<p>
									The Apple m-series DMP was first discovered by <a href="https://www.prefetchers.info/">Augury</a>, 
									which suggested that DMPs might mix data and addresses under some conditions. 
									However, we found that the DMP activation criteria outlined by Augury are overly restrictive. 
									This prevents Augury&#39;s findings from being sufficient to mount attacks on real-world constant-time cryptography. 
								</p>
								<p>
									GoFetch shows that the DMP is significantly more aggressive than previously thought, 
									and thus poses a much greater security risk. 
									Specifically, we find that any value loaded from memory is a candidate for being dereferenced (literally!). 
									This allows us to sidestep many of Augury&#39;s limitations and demonstrate end-to-end attacks on real constant-time code.
								</p>
							</div>
						</div>
					</div>
					<div>
						
						<div id="panelsStayOpen-collapseConstantTime" aria-labelledby="panelsStayOpen-headingConstantTime">
							<p>
								Modern processors use caches to reduce a program&#39;s memory access latency. 
								If data has been accessed before, it gets cached, which makes subsequent accesses to it faster. 
								Since the cache is shared by processes running on the same machine, 
								attackers co-located to the same machine can monitor the cache&#39;s state to deduce a victim&#39;s access pattern.
							</p>
						</div>
					</div>
					<div>
						
						<div id="panelsStayOpen-collapseDMP" aria-labelledby="panelsStayOpen-headingDMP">
							<div>
								<p>
									Constant-time programming is a paradigm that aims to harden code against side-channel attacks by ensuring that all operations take the same amount of time, regardless of their operands. In particular, constant-time code cannot contain secret-dependent branches, loops, or other control structures. Moreover, as the CPU caches different addresses with attacker-observable latency, constant-time code cannot mix data and addresses in any way and prohibits the use of secret-dependent memory accesses or array indices.
								</p>
								<p>
									We show that even if a victim correctly separates data from addresses by following the constant-time paradigm, the DMP will generate secret-dependent memory access on the victim&#39;s behalf, resulting in variable-time code susceptible to our key-extraction attacks. 
								</p>
							</div>
						</div>
					</div>
					<div>
						
						<div id="panelsStayOpen-collapseOther" aria-labelledby="panelsStayOpen-headingOther">
							<p>
								Prefetchers are a hardware optimization that predicts memory addresses to be accessed in the near future and fetches the data into the cache accordingly from the main memory. To make a prediction, classical prefetchers use the address trace of previous demand accesses. This strategy performs poorly when it comes to irregular access patterns like linked-list traversals. Aiming to handle such irregular patterns, data memory-dependent prefetchers (DMPs) also consider the content of memory to determine what to fetch, which is capable of capturing those indirect access patterns. Unfortunately, this behavior inherently mixes data and memory addresses at the hardware level, making the entire compute stack non-constant-time, enabling our attack.
							</p>
						</div>
					</div>
					<div>
						
						<div id="panelsStayOpen-collapseOthers" aria-labelledby="panelsStayOpen-headingOthers">
							<p>
								We don&#39;t know. Our attack relies on the fact that it is possible to craft inputs to control specific intermediate states, making them contain memory addresses in a key-dependent way. The DMP then serves as an oracle, allowing us to learn if the intermediate state indeed looks like a pointer and thus leaks secret key bits. Unfortunately, to assess if an implementation is vulnerable, cryptanalysis and code inspection are required to understand when and how intermediate values can be made to look like pointers in a way that leaks secrets. This process is manual and slow and does not rule out other attack approaches. 
							</p>
						</div>
					</div>
					<div>
						
						<div id="panelsStayOpen-collapseDisable" aria-labelledby="panelsStayOpen-headingDisable">
							<p>
								Yes, but only on some processors.
								We observe that the <a href="https://developer.apple.com/documentation/xcode/writing-arm64-code-for-apple-platforms#Enable-DIT-for-constant-time-cryptographic-operations">DIT bit</a>
								set on m3 CPUs effectively disables the DMP.
								This is not the case for the m1 and m2.
								Also, Intel&#39;s counterpart, <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/best-practices/data-operand-independent-timing-isa-guidance.html">DOIT bit</a>, 
								can be used to disable DMP on the Raptor Lake processors.
							</p>
						</div>
					</div>
					<div>
						
						<div id="panelsStayOpen-collapseCountermeasure" aria-labelledby="panelsStayOpen-headingCountermeasure">
							<p>
								For users, we recommend using the latest versions of software, 
								as well as performing updates regularly. 
								Developers of cryptographic libraries can either set the 
								<a href="https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/best-practices/data-operand-independent-timing-isa-guidance.html">DOIT bit</a>
								and 
								<a href="https://developer.apple.com/documentation/xcode/writing-arm64-code-for-apple-platforms#Enable-DIT-for-constant-time-cryptographic-operations">DIT bit</a> 
								bits, which disable the DMP on some CPUs. 
								Additionally, input blinding can help some cryptographic schemes avoid having attacker-controlled intermediate values, 
								avoiding key-dependent DMP activation. 
								Finally, preventing attackers from measuring DMP activation in the first place, 
								for example by avoiding hardware sharing, can further enhance the security of cryptographic protocols.
							</p>
						</div>
					</div>
					<div>
						
						<div id="panelsStayOpen-collapsePoC" aria-labelledby="panelsStayOpen-headingPoC">
							<p>
								Yes, we will release it soon.
							</p>
						</div>
					</div>
					<div>
						
						<div id="panelsStayOpen-collapseLogo" aria-labelledby="panelsStayOpen-headingLogo">
							<p>
								Yes, <a href="https://gofetch.fail/img/gofetch.svg">SVG</a> and <a href="https://gofetch.fail/img/gofetch.png">PNG</a> versions 
								of GoFetch logo are free to use under a <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a> licence.
							</p>
						</div>
					</div>
					<div>
						
						<div id="panelsStayOpen-collapseNotify" aria-labelledby="panelsStayOpen-headingNotify">
							<p>
								We disclosed our findings to Apple on December 5, 2023 (107 days before public release).
							</p>
						</div>
					</div>
				</div>
			</section>

			<section id="news">
				<h4><i></i><span>GoFetch</span> in the News</h4>
				
			</section>

			<section id="acknowledgments">
				<h4><i></i>Acknowledgments</h4>
				<p>
						This work was partially supported by
						the Air Force Office of Scientific Research (AFOSR) under award number FA9550-20-1-0425;
						the Defense Advanced Research Projects Agency (DARPA) under contract
						numbers W912CG-23-C-0022 and HR00112390029;
						the National Science Foundation (NSF) under grant numbers 1954712, 1954521, 2154183, 2153388, and 1942888;
						the Alfred P. Sloan Research Fellowship;
						and gifts from Intel, Qualcomm,
						and Cisco.
					</p>
			</section>
		</div></div>
  </body>
</html>
