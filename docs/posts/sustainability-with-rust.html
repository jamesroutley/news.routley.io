<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://aws.amazon.com/blogs/opensource/sustainability-with-rust/">Original</a>
    <h1>Sustainability with Rust</h1>
    
    <div id="readability-page-1" class="page"><article vocab="http://schema.org/" typeof="TechArticle"> 
      <meta property="inLanguage" content="en-US"/> 
       
       
      <section property="articleBody"> 
       <p>Rust is a programming language implemented as a set of open source projects. It combines the performance and resource efficiency of systems programming languages like C with the memory safety of languages like Java. Rust started as a research project at Mozilla in 2010, and Rust 1.0 launched in 2015. In 2020, support for Rust moved from Mozilla to the <a href="https://foundation.rust-lang.org/">Rust Foundation</a>, a non-profit organization created as a partnership between Amazon Web Services, Inc (AWS), Google, Huawei, Microsoft, and Mozilla. The Foundation’s mission is to support the growth and innovation of Rust, and the member companies have grown from the founding 5 to 27 companies in the first year. </p> 
       <p>At AWS, Rust has quickly become critical to building infrastructure at scale. <a href="https://firecracker-microvm.github.io/">Firecracker </a>is an open source virtualization technology that powers <a href="https://aws.amazon.com/lambda/">AWS Lambda</a> and other serverless offerings. It launched publicly in 2018 as our first notable product implemented in Rust. We use Rust to deliver services such as <a href="https://aws.amazon.com/s3/">Amazon Simple Storage Service</a> (Amazon S3), <a href="https://aws.amazon.com/ec2">Amazon Elastic Compute Cloud</a> (Amazon EC2), <a href="https://aws.amazon.com/cloudfront/">Amazon CloudFront</a>, and more. In 2020, we launched <a href="https://aws.amazon.com/bottlerocket/">Bottlerocket</a>, a Linux-based container operating system written in Rust, and our Amazon EC2 team uses Rust as the language of choice for new <a href="https://aws.amazon.com/ec2/nitro/">AWS Nitro System</a> components, including sensitive applications, such as <a href="https://aws.amazon.com/blogs/aws/aws-nitro-enclaves-isolated-ec2-environments-to-process-confidential-data/">Nitro Enclaves</a>. </p> 
       <p>At AWS, we believe leaders create more than they consume and always leave things better than they found them. In 2019, <a href="https://aws.amazon.com/blogs/opensource/aws-sponsorship-of-the-rust-project/">AWS was proud to become a sponsor of the Rust project</a>. In 2020, <a href="https://aws.amazon.com/blogs/opensource/how-our-aws-rust-team-will-contribute-to-rusts-future-successes/">we started hiring Rust maintainers and contributors</a>, and <a href="https://aws.amazon.com/blogs/opensource/congratulations-rustaceans-on-the-creation-of-the-rust-foundation/">we partnered with Google, Huawei, Microsoft, and Mozilla to create the Rust Foundation</a> with a mission to support Rust. AWS is investing in the sustainability of Rust, a language we believe should be used to build sustainable and secure solutions. </p> 
       <h3 id="temp:C:YMB7e65c5c1f645bb5ec5206c68c">Energy Efficiency in the Cloud</h3> 
       <p><img src="https://d2908q01vomqb2.cloudfront.net/ca3512f4dfa95a03169c5a670a4c91a19b3077b4/2022/02/09/Global-data-centre-energy.png" id="temp:C:YMBd810b339631791d13a2eef4ef" width="800" height="357" alt="A chart showing energy efficiency in the cloud, comparing Traditional, Cloud (non hyperscale), and Hyperscale data centers."/> 
       </p> 
       <p><i>Source: IEA (2021), <b>Global data centre energy demand by data centre type, 2010-2022,</b> https://www.iea.org/data-and-statistics/charts/global-data-centre-energy-demand-by-data-centre-type-2010-2022. All rights reserved.</i></p> 
       <p>Worldwide, <a href="https://www.iea.org/data-and-statistics/charts/global-data-centre-energy-demand-by-data-centre-type-2010-2022">data centers consume about 200 terawatt hours per year</a>. That’s roughly 1% of all energy consumed on our planet. There are a couple of really interesting things about the details of that energy use. If you look at the graph of energy consumption, the top line is basically flat going back as far as 2010. That’s incredibly counter-intuitive give the tremendous growth of big data, machine learning, and edge devices our industry has experienced over that same period of time. </p> 
       <p>The second interesting detail is that while the top line of the graph is flat, inside the graph, the distribution over traditional, cloud, and hyperscale data centers has changed dramatically in the same period. Those cloud and hyperscale data centers have been implementing huge energy efficiency improvements, and the migration to that cloud infrastructure has been keeping the total energy use of data centers in balance despite massive growth in storage and compute for more than a decade.</p> 
       <p>There have been too many data center efficiency improvements to list, but here are a few examples. In compute, we’ve made efficiency improvements in hardware and implemented smarter utilization of resources to reduce idle time. We’ve slowed the growth of our servers with support for multi-instance and multi-tenant, and we’ve improved drive density and efficiency for storage. We’ve also adopted more energy efficient building materials and cooling systems.</p> 
       <p>As incredible as that success story is, there are two questions it raises. First, is the status quo good enough? Is keeping data center energy use to 1% of worldwide energy consumption adequate? The second question is whether innovations in energy efficiency will continue to keep pace with growth in storage and compute in the future? Given the explosion we know is coming in autonomous drones, delivery robots, and vehicles, and the incredible amount of data consumption, processing, and machine learning training and inference required to support those technologies, it seems unlikely that energy efficiency innovations will be able to keep pace with demand.</p> 
       <p><img src="https://d2908q01vomqb2.cloudfront.net/ca3512f4dfa95a03169c5a670a4c91a19b3077b4/2022/02/09/sust-rust-2.png" id="temp:C:YMB044d3e69f8e255d25af6a2949" width="800" height="337" alt="Image showing how Customers are responsible for sustainability in the cloud and how AWS is responsible for sustainability of the cloud"/> 
       </p> 
       <p>The energy efficiency improvements we’ve talked about so far have been the responsibility of AWS, but just like security, sustainability is a shared responsibility. AWS customers are responsible for energy efficient choices in storage policies, software design, and compute utilization, while AWS owns efficiencies in hardware, utilization features, and cooling systems. We are also making huge investments in renewable energy.</p> 
       <p>AWS is on a path to have 100% of our data centers powered with renewable energy by 2025, but even renewables have an environmental impact. It will take about half a million acres of solar panels to generate the 200 terawatt hours of energy used by data centers today. The mining, manufacturing, and management of that many solar panels has substantial environmental impact. So, while we’re really proud of our success with renewable energy, as Peter DeSantis, SVP, AWS said at re:Invent 2020, “The greenest energy is the energy we don’t use.”</p> 
       <p>Renewables should not replace energy efficiency as a design principle. In the same way that operational excellence, security, and reliability have been principles of traditional software design, sustainability must be a principle in modern software design. That’s why <a href="https://docs.aws.amazon.com/wellarchitected/latest/sustainability-pillar/sustainability-pillar.html">AWS announced a sixth pillar for sustainability to the AWS Well-Architected Framework</a>.</p> 
       <p>What that looks like in practice is choices like relaxing SLAs for non-critical functions and prioritizing resource use efficiency. We can take advantage of virtualization and allow for longer device upgrade cycles. We can leverage caching and longer TTLs whenever possible. We can classify our data and implement automated lifecycle policies that delete data as soon as possible. When we choose algorithms for cryptography and compression, we can include efficiency in our decision criteria. Last, but not least, we can choose to implement our software in energy efficient programming languages.</p> 
       <h3 id="temp:C:YMB37456d154ebfc92c7c2114a81">Energy Efficient Program Languages</h3> 
       <p><a href="https://greenlab.di.uminho.pt/wp-content/uploads/2017/10/sleFinal.pdf">There was a really interesting study a few years ago</a> that looked at the correlation between energy consumption, performance, and memory use. This is a really common conversation in sustainability. Given how little visibility we have into energy or carbon use by our services, is there a metric that can serve as a proxy? Can I look at my existing service dashboards with infrastructure costs, performance, memory, etc and use the trends I see to infer something about the trends in my service’s energy consumption? </p> 
       <p>What the study did is implement 10 benchmark problems in 27 different programming languages and measure execution time, energy consumption, and peak memory use. C and Rust significantly outperformed other languages in energy efficiency. In fact, they were roughly 50% more efficient than Java and 98% more efficient than Python.</p> 
       <p><img src="https://d2908q01vomqb2.cloudfront.net/ca3512f4dfa95a03169c5a670a4c91a19b3077b4/2022/02/09/sust-rust-3.png" id="temp:C:YMB95148c074ca41c45e9ef60d92" alt="Table showing energy efficiency scores for various programming languages. C and Rust are circled in green at the top of the list as the most energy efficient. Java is circled in red, it is in 5th place. Python is circled in red, it is in 26th place."/> 
       </p> 
       <p>It’s not a surprise that C and Rust are more efficient than other languages. What is shocking is the magnitude of the difference. Broad adoption of C and Rust could reduce energy consumption of compute by 50% – even with a conservative estimate.</p> 
       <p>So the question is why not use more C? The language and developer tools are extremely mature, and the size of the developer community is much bigger than Rust. During his keynote at Open Source Summit in 2021, <a href="https://thenewstack.io/linus-torvalds-on-community-rust-and-linuxs-longevity/">Linus Torvalds, the creator of Linux, acknowledged that implementing code in C can be like juggling chainsaws</a>. As a lifelong C programmer, Torvalds knows that, “[C’s subtle type interactions] are not always logical [and] are pitfalls for pretty much anybody.”</p> 
       <p>Torvalds called Rust the first language he’s seen that might actually be a solution. Rust delivers the energy efficiency of C without the risk of undefined behavior. We can cut energy use in half without losing the benefits of memory safety.</p> 
       <p>Several analyses have concluded that more than 70% of the high severity CVEs that occur in C/C++ would be prevented by implementing those same solutions in Rust. In fact, the Internet Security Research Group (ISRG), the nonprofit that supports the Let’s Encrypt project, the Certificate Authority for 260 million websites, has a <a href="https://www.memorysafety.org/">goal to move all internet security sensitive infrastructure to Rust</a>. The projects underway include support for Rust in the Linux kernel and migrating curl to Rust implementations of TLS and HTTP. </p> 
       <p><img src="https://d2908q01vomqb2.cloudfront.net/ca3512f4dfa95a03169c5a670a4c91a19b3077b4/2022/02/09/sust-rust-4.png" id="temp:C:YMB3e0465d6fc21e71aac63eba53" alt="Table showing Time efficiency for various programming languages. C and Rust are circled in green at the top of the list as the most efficient."/> 
       </p> 
        
       <p>Looking again at that study about correlation, we have measurements for more than just energy consumption. The middle column shows the results for execution time, and the times for Rust and C are really similar. Both languages are executing faster than other languages. That means, when you choose to implement your software in Rust for the sustainability and security benefits, you also get the optimized performance of C.</p> 
       <h3 id="temp:C:YMB415250d0bd35c734dfb4abffb">Rust Customer Success Stories</h3> 
       <p><img src="https://d2908q01vomqb2.cloudfront.net/ca3512f4dfa95a03169c5a670a4c91a19b3077b4/2022/02/09/sust-rust-5.png" id="temp:C:YMBc5d1a91007f2ea25712cb06d5" alt="Bar chart showing Javascript compared to Rust in terms of Latency per datagram. In both Median Latency and P95 Latency, Javascript has significantly higher latency than Rust."/> 
       </p> 
        
       <p id="temp:C:YMB652f6799460e72ff381011efa"><i><a href="https://medium.com/tenable-techblog/optimizing-700-cpus-away-with-rust-dc7a000dbdb2">https://medium.com/tenable-techblog/optimizing-700-cpus-away-with-rust-dc7a000dbdb2</a></i></p> 
        
       <p>Tenable is a cyber security solutions provider focused on exposure visibility tools, and they had a sidecar agent that filtered out unnecessary metrics. It was written in JavaScript and had been working in production for a few months when the performance started to degrade due to scaling. Tenable decided to rewrite the filter in a more efficient language, and they chose Rust for its performance and safety. The result was about a 50% improvement in latency at both the median and the P95.</p> 
       <p><img src="https://d2908q01vomqb2.cloudfront.net/ca3512f4dfa95a03169c5a670a4c91a19b3077b4/2022/02/09/sust-rust-6.png" id="temp:C:YMB7376ab31ea744c96a68c413b6" alt="Line graph showing CPU Usage, Cores vs Time, the line starts out flat at around 1000 Cores at 0 time, then at roughly the 14:00 mark, it trends downward and stabilizes at slightly above 300 Cores."/> 
       </p> 
       <p><img src="https://d2908q01vomqb2.cloudfront.net/ca3512f4dfa95a03169c5a670a4c91a19b3077b4/2022/02/09/sust-rust-7.png" id="temp:C:YMBa654ee716ae5c5eea42fbb5d9" alt="Line graph showing Memory Usage, GB vs Time, the line starts out relatively flat around 650 GB, then at roughly the 14:00 mark, it trends downward and stabilizes at approximately 100 GB"/> 
       </p> 
        
       <p>50% performance improvements are great, but here are some other graphs from that migration. Tenable also saw a 75% reduction in CPU usage and a 95% reduction in memory usage. That is substantial savings, and that’s not just dollars saved – that’s energy saved. These are the graphs of an energy efficient, sustainable implementation.</p> 
       <p>Rust is being used today to ship real world production software, but developers aren’t choosing Rust to reduce carbon emissions. When we ask Rust developers why they started using Rust, by far the most common answer is some variant of runtime performance, whether it is because Rust is faster or because Rust has more reliable tail latencies. It’s almost always about performance.</p> 
       <p><img src="https://d2908q01vomqb2.cloudfront.net/ca3512f4dfa95a03169c5a670a4c91a19b3077b4/2022/02/09/sust-rust-8.png" id="temp:C:YMBfbef5747dbaebeae86f09d6d5" width="800" height="321" alt="Four charts, the first showing System CPU usage over time. The line shows regular spikes from approximately 20% usage to 40% usage on a roughly 2 minute interval. The second chart shows Average Response time in milliseconds, with a baseline just above 0, but with spikes up to 10 ms on a roughly 2 minute interval. The third chart shows Response Time in the 95th percentile and it has a similar line to the second chart except that the spikes go up to 200 and 300 ms. The final chart shows Max @mentions per second over time, and is extremely erratic but averages out at about 2."/> 
       </p> 
       <p id="temp:C:YMBe03fdb035301caee51eb619c9"><a href="https://discord.com/blog/why-discord-is-switching-from-go-to-rust"><i>https://discord.com/blog/why-discord-is-switching-from-go-to-rust</i></a></p> 
        
       <p>Discord started as a mostly Python, Go, and Elixir shop, and they had a problem with one of their key Go services. It was a pretty simple service, but it had slow tail latencies. Because Go is a garbage collection (GC) language, as objects are created and released, every so often, the garbage collector needs to stop execution of the program and run a garbage collection pass. While the GC is running, the process is unable to respond to requests, and you can see the spikes on the CPU and response time graphs when it’s running. </p> 
       <p><span><b>Go</b></span> <span><b>Rust</b></span></p> 
       <p><img src="https://d2908q01vomqb2.cloudfront.net/ca3512f4dfa95a03169c5a670a4c91a19b3077b4/2022/02/09/sust-rust-9.png" id="temp:C:YMBa1930e7d973d1f7dec96a1749" width="800" height="312" alt="Four charts, the first two showing results with Go and the second two showing results with Rust. Chart one shows average response times in milliseconds (it is identical to the second chart in the previous image), with a baseline just above 0, but with spikes up to 10 ms on a roughly 2 minute interval. The second Go chart shows Max @mentions per second over time (it is identical to the fourth chart in the previous image), and is extremely erratic but averages out at about 2. The same metrics are graphed in two additional charts for Rust, with the key difference that Rust&#39;s charts are shown in units of nanoseconds and microseconds respectively. This illustrates how significant the improvement in these areas is for Rust."/> 
       </p> 
       <p>To fix the issue, Discord decided to try rewriting the service in Rust, and these are the results. The Go implementation is on the left and the Rust implementation is on the right. While the GC spike pattern is gone on the Rust graph, the really amazing difference is the magnitude of the change. The Go and Rust graphs are actually using different units. </p> 
       <p>The Rust version is more than 10 times faster over all with the worst tail latencies reduced 100 times. These are incredible improvements, and because the server is able to respond to requests far more efficiently, fewer servers are needed, which means that less energy is used. While Discord didn’t decide to start using Rust to reduce energy consumption, that’s the impact.</p> 
       <p>Again, Rust isn’t the first efficient language. C has been around for a long time, but Rust is the first mainstream programming language that is efficient without sacrificing safety. 70% of all high severity security vulnerabilities written with C and C++ are due to memory unsafety, and Rust gives you efficiency without feeling like you’re playing with fire.</p> 
       <h3 id="temp:C:YMB5a77ca187a864b52e7249a5b7">Revealing the Rust Secret Sauce</h3> 
       <p>Most languages achieve memory safety by automatically managing memory at runtime with a garbage collector. Garbage collectors track outstanding references to a piece of memory and when all references go out of scope, the associated memory can be freed.</p> 
       <p>Instead of using a garbage collector to maintain safety, Rust uses ownership and borrow checking. Ownership is fairly simple but has deep implications for the rest of the Rust programming language. In Rust, all memory is owned by a single variable. That variable is called its owner. There can be only one owner at a time, but ownership of the data can be passed around. </p> 
       <p><img src="https://d2908q01vomqb2.cloudfront.net/ca3512f4dfa95a03169c5a670a4c91a19b3077b4/2022/02/09/sust-rust-10.png" id="temp:C:YMB57a1f6faf00973b4f4c4b939d" width="800" height="110" alt="Go code showing an example of message passing"/> 
       </p> 
       <p>First, here is an example of message passing with Go. On the left side, we create a gift, then send it via the channel. On some other go routine on the right side, the gift is received and opened. The Go’s garbage collector is going to manage the memory for us. However, in the code on the left side, we accidentally opened the gift after sending it into the channel. The gift is going to be opened twice, resulting in a bug.</p> 
       <p><img src="https://d2908q01vomqb2.cloudfront.net/ca3512f4dfa95a03169c5a670a4c91a19b3077b4/2022/02/09/sust-rust-11.png" width="800" height="146" alt="Additional Go code showing a bug."/> 
       </p> 
       <p>Here is the same message passing example with Rust. The gift is created and assigned. We say that the `gift` variable owns the data. Ownership of the gift is passed into the channel. The channel consumer receives the gift, taking ownership, and is able to open it. If we try to open the gift after sending it into the channel, the compiler will shout at us, because we are violating the ownership rules. Already, we are seeing how Rust helps us prevent bugs.</p> 
       <p><img src="https://d2908q01vomqb2.cloudfront.net/ca3512f4dfa95a03169c5a670a4c91a19b3077b4/2022/02/09/sust-rust-12.png" id="temp:C:YMBe355b281d213fe5adfe793b6e" width="800" height="110" alt="Rust code showing the equivalent code to the previous Go example code."/> 
       </p> 
       <p>Because Rust enforces the rule that only one variable owns data, when that variable goes out of scope <b>without</b> passing off ownership, there is no possible way for the data to be accessed. Rust takes advantage of that and will automatically free the memory at that point. There is no need to manually free the memory.</p> 
       <p>Rust’s ownership model is part of the type system and based on a concept called <a href="https://en.wikipedia.org/wiki/Substructural_type_system">affine types</a>. An affine type imposes a rule that every variable is used at most once. The key is to define what “used” means. In the context of Rust, a use is either moving the data or dropping it. By using affine types, the Rust compiler is able to reason about a program and enforce its ownership rules.</p> 
       <p> The affine type system used by Rust is based on the work done in the early 1990s, when some folks attempted to design a garbage collector free lisp. While successful, they found that they lost a lot of runtime performance due to the excessive copying introduced by not being able to have multiple references to the same piece of data.</p> 
       <p><img src="https://d2908q01vomqb2.cloudfront.net/ca3512f4dfa95a03169c5a670a4c91a19b3077b4/2022/02/09/sust-rust-13.png" id="temp:C:YMB1624e168e26b4534d9de82a1c" width="800" height="142" alt="An iteration on the previous Rust example code which introduces a function."/> 
       </p> 
       <p>And this gets us to the second innovation that has enabled Rust: the borrow checker. When writing larger programs we tend to use abstractions to help organize ideas. One abstraction that you’re probably familiar with is a function. Functions often require arguments. With only ownership, to call a function, we would need to pass ownership of the data into the function and the function would need to pass ownership of the data back when returning. This requires copying memory around and was the source of garbage collector-less lisp performance challenges.</p> 
       <p><img src="https://d2908q01vomqb2.cloudfront.net/ca3512f4dfa95a03169c5a670a4c91a19b3077b4/2022/02/09/sust-rust-14.png" id="temp:C:YMB85d0a709dcdce8ff71e449bac" width="800" height="123" alt="Another iteration on the Rust last example code showing the use of a reference."/> 
       </p> 
       <p>To solve this, Rust lets you borrow data. So, if we have a gift, we own it it. It is ours. If our friend wants to admire it, she can borrow it for a moment, but then she has to give it back to us. Also, while our friend is borrowing the gift, we cannot hand off ownership of the gift to anyone else, because it is currently being borrowed. Most crucially, the Rust compiler enforces these rules, so our friend can’t just run off with the gift. And because the Rust compiler enforces that guarantee, when borrowing data, memory doesn’t have to be copied. The memory stays where it is, and a pointer is passed around. The pointer is guaranteed to be valid. When you put it all together, you have a system that is efficient and prevents bugs, even as the program gets larger and more complex. </p> 
       <p>And the same system that prevents memory unsafety can also prevent data races, a category of concurrency bug. A data race happens when two or more threads are concurrently accessing the same data and at least one of those accesses is a mutation. The type system that models ownership and borrowing is able to uphold the same guarantee across multiple threads, enabling more aggressive use of concurrency.</p> 
       <p><span><b>Synchronous</b></span> <span><b>Concurrent</b></span></p> 
       <p><img src="https://d2908q01vomqb2.cloudfront.net/ca3512f4dfa95a03169c5a670a4c91a19b3077b4/2022/02/09/sust-rust-15.png" id="temp:C:YMB020242ec59d9da33e8f362125" width="800" height="170" alt="Two examples of similar Rust code, one showing a synchronous model (on the left), the other showing a concurrent model (on the right)"/> 
       </p> 
       <p>Here is an example of how easy it can be to safely add concurrency to a Rust application. We have a function that iterates through an array of numbers and sums all even numbers. This is a highly parallelizable operation and for very large arrays, we could see the function getting significantly faster by adding concurrency.</p> 
       <p> The left side shows a single threaded version and the right side shows you the parallel version using the rayon library. And look at how similar the functions are. You get all the power of concurrency, without the hazards, by basically writing the same code. The only difference is that we use the par_iter() method instead of iter(). </p> 
       <p>The parallel version will spread the computation across many threads, all while avoiding copying the array of numbers being passed as the argument. Rayon is able to provide this API safely thanks to Rust’s ownership and borrow checking system. All the checks to guarantee safety happen at compile time.</p> 
       <h3 id="temp:C:YMB53f1408b1294005851996022c">Getting Started with Rust</h3> 
       <p>Hopefully, by now we have gotten you interested in Rust and starting your journey of sustainability in the cloud. So where to start? The good news is, all the content you need is available online and there are places you can go to get started.</p> 
       <p> First, you will need to learn the Rust programming language. <a href="https://doc.rust-lang.org/book/">The Rust book</a> is an excellent resource to get started learning the language. It will help you get the Rust toolchain installed and teach you the language. The website also has exercises and lots of code examples to read. If you get stuck at any point, have questions, or need clarification, you can post on the user forum or talk directly on the community Discord server. The Discord server is usually the fastest way to get help. There are always people active there who can answer questions in real time.</p> 
       <p> Once you have gone through the Rust website, you should be comfortable enough to start building things, but there is another resource we want to call out for diving deeper. The <a href="https://www.youtube.com/c/JonGjengset">Crust of Rust</a> is a great youtube channel by Jon Gjenset. He does really deep dives on various Rust related topics, popping the hood and explaining how things work. His videos are multiple hours long, but we keep hearing from people how valuable they are for learning Rust. </p> 
       <h3 id="temp:C:YMBe0c570047cb764772d7fa8221">The Future of Rust</h3> 
       <p><img src="https://d2908q01vomqb2.cloudfront.net/ca3512f4dfa95a03169c5a670a4c91a19b3077b4/2022/02/09/sust-rust-16.png" id="temp:C:YMBb40bf78f29bd19a6b5c13cea5" alt="A bar chart titled How would you rate your expertise in Rust. The highest bar is at a 7, with almost 1200 responses, while Beginner (or 1) is at almost 250 responses, and Expert (or 10) is below 100 responses. The distribution is roughly shaped like a Bell curve."/> 
       </p> 
        
       <p id="temp:C:YMBde78b52ef661df4fdcd6404a7"><i><a href="https://blog.rust-lang.org/2020/12/16/rust-survey-2020.html">https://blog.rust-lang.org/2020/12/16/rust-survey-2020.html</a></i></p> 
        
       <p>Rust is challenging to learn. Of the more than 8,000 developers responding to the 2020 Rust user survey, only about 100 identified as “expert”, and of the respondents that said they were no longer using Rust, 55% cited learning or productivity as their reason for abandoning the language. </p> 
       <p>It takes experienced engineers 3-6 months of study, supported by access to subject matter experts, to become productive with Rust. Some engineers have likened learning Rust to learning to eat your vegetables, and while many of them love it once they are productive, a lot of engineers are deciding against learning it or abandoning the effort before they become productive. The potential impact of Rust on sustainability and security will only materialize if we turn the broccoli into a brownie. </p> 
       <p><img src="https://d2908q01vomqb2.cloudfront.net/ca3512f4dfa95a03169c5a670a4c91a19b3077b4/2022/02/09/sust-rust-17.png" id="temp:C:YMB4aaa10b7230fbe333cb4a2c4e" alt="A screenshot showing a visualization of the size of programming languages communities in Q3 2021. Rust is the second from the last in the list, showing 1.1M active developers globally."/> 
       </p> 
        
       <p><i>SlashData, State of the Developer Nation Q3 2021</i></p> 
       <p>No one developer, service, or corporation can deliver substantial impact on sustainability. Adoption of Rust is like recycling; it only has impact if we all participate. To achieve broad adoption, we are going to have to grow the developer community. </p> 
       <p>The Rust developer community has been the fastest growing over the last two years, but based on historical trends, we know that of the half million developers that joined the Rust community in the last 12 months, most of them are not yet proficient with the language. We have some work to do on the Rust developer experience.</p> 
       <p>The question that raises is which developer experience? Engineers working on the Linux kernel have a very different ideal developer experience than an engineer building a database service or an engineer delivering a retail website. We can identify the Rust user personas by looking at three dimensions. </p> 
       <p>The first distinction is their reason for coming to Rust. Are they choosing Rust for performance? For security? For sustainability? The second distinction is domain. Are they working in an embedded environment with restricted resources? Are they working in machine learning with long running jobs that have huge amounts of data in incremental computations? The third distinction is the developer’s experience. Are they a systems programmer? Maybe they’ve only worked with dynamically typed languages?</p> 
       <p>We need to evolve those permutations of priority, domain, and developer experience into personas that allow us to develop a robust understanding, a common vocabulary, and an explicit set of engineering trade offs. We usually give these personas names, so let’s consider an example we’ll call “Bob”. </p> 
       <p>Bob is building a cryptographic solution, and he’s choosing Rust for the security properties. Bob has a distinct set of engineering trade offs. Bob prioritizes security over performance; he prioritizes security over operations. What that means in practice is that Bob would rather have a slow response than plain text, and he would rather have an outage than respond to an unsigned request.</p> 
       <p>For each of these personas, there are unique engineering trade offs, and what we want to do is to create a space in the Rust landscape that’s well-defined and easily discoverable and empowers all the Bobs to collaborate on building the best, whole developer experience for themselves without negatively impacting other personas.</p> 
       <p>Rust is an amazing technology to sustain and secure our industry, and you can start doing that today. We have a lot of work to do before everyone can use Rust, and the <a href="https://foundation.rust-lang.org/">Rust Foundation</a> is working to create platforms for effective, cross industry collaboration on that work. We hope you’ll join us.</p> 
       <!-- '"` --> 
      </section> 
       
       
       
     </article></div>
  </body>
</html>
