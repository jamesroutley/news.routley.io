<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://retrocomputing.stackexchange.com/questions/27741/how-were-the-signs-for-logical-and-arithmetic-operators-decided">Original</a>
    <h1>How were the signs for logical and arithmetic operators decided?</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="text">
<p>Martin Richards, the designer of BCPL (based on Algol-60 and CPL, and the predecessor for B and C), <a href="https://www.cl.cam.ac.uk/%7Emr10/cpl2bcpl.pdf" rel="nofollow noreferrer">had this to say on the motivation for many such decisions:</a></p>
<blockquote>
<p>It was not until July 1967 that a specification of a character set was published that closely resembles the ASCII character set we have today. Prior to that, computers typically had their own character sets and these were often quite limited. For instance, on the first machine on which BCPL ran, namely an IBM 7094 running CTSS, the standard code used 6-bit characters packed in 36-bit words. The characters available were essentially those used in Fortran and did not include square or curly brackets ([ ] { }), semicolon (;), double quote (&#34;) or underscore (_) and commonly used terminals such as the Model 35 Teletype only permitted letters in upper case. However, at Cambridge, CPL programs used a much richer character set since they were typically prepared using a Flexowriter which was an electric typewriter that was combined with a 7-track paper tape reader and punch. The available characters included backspace and so overprinting was possible and used to represent symbols such as ≠. System words such as while were underlined to distinguish them from ordinary identifiers. BCPL on the 7094 thus had to represent lexical tokens quite differently.</p>
</blockquote>
<p>Most of the commonly-used ASCII representations of operators were codified in either B or C.   Many two-character tokens seem to have been chosen based on how some terminals could print one character on top of another. For example, on many paper terminals, ê would have been represented as <code>e</code>-backspace-<code>^</code>, which on a terminal that didn’t support overstriking, would display as <code>e^</code>.  When programming languages were transitioning to ASCII in the late ’60s, this seems to have inspired several of the two-character operators familiar to us today.  So, <code>!=</code> would look like a vertical stroke across an equals sign if they were printed on top of each other.  Note that <code>=|</code> was already taken in B for the binary operator that became <code>|=</code> in C.</p>
<p>Algol and BCPL originally had <code>≤</code> (which some machines could represent as an underlined <code>&lt;</code>, and others replaced with a text mnemonic).  This became <code>=&lt;</code> in B and early C, and <code>&lt;=</code> in BASIC, C and languages influenced by them.  Probably, C reversed all the equals operators at the same time, so that typos such <code>x=-1</code> for <code>x = -1</code> would no longer cause so many bugs.  This happened to make the existing <code>!=</code> operator look as though <code>x != 0</code> should be a synonym for <code>x = !0</code>, which the syntax of B did not imply.  However, perhaps because all C users knew B and <code>!=</code> is never used in a context where anyone would ever suspect it meant <code>if (x = !0)</code>, the designers of C saw no need to change it.</p>
<h2>Multiplication and Exponentiation</h2>
<p>A recent question <a href="https://langdev.stackexchange.com/questions/2935/why-do-programming-languages-use-the-asterisk-for-multiplication">on LangDev.SX</a> discussed the history of <code>*</code>.  <a href="https://www.jstor.org/stable/2300111?seq=1" rel="nofollow noreferrer">The use of an asterisk for multiplication in printed books goes back at least to Johann Heinrich Rahn in 1659.</a> The first programming language to use it was Fortran.  Fortran’s preliminary report, in 1954, <a href="https://www.softwarepreservation.org/projects/FORTRAN/BackusEtAl-Preliminary%20Report-1954.pdf" rel="nofollow noreferrer">proposed using <code>×</code> for multiplication and <code>××</code> for exponentiation.</a>.  By 1956, <code>*</code> and <code>**</code> had been chosen instead.  <a href="http://archive.computerhistory.org/resources/access/text/2016/06/102724614-05-01-acc.pdf" rel="nofollow noreferrer">MATH-MATIC</a> (deriving from work by Grace Hopper) was being developed at the same time and also settled on <code>*</code> sometime between 1955 and 1957.  John Backus said this was a coincidence, and that he was unaware of much previous work that came to light later.  <a href="https://www.softwarepreservation.org/projects/FORTRAN/paper/p165-backus.pdf" rel="nofollow noreferrer">He made this choice because of the very limited 48-character set of the BCD-coded punch cards he needed to support, and even removed comparisons from <code>DO</code> loops because of the lack of a <code>&lt;</code> character</a> (giving rise to <code>.LT.</code>).</p>
<p>The convention of <code>^</code> for exponentiation derived from Algol’s choice of <code>↑</code> (perhaps because it represents raising the exponent).  Dartmouth BASIC in 1964 <a href="http://bitsavers.trailing-edge.com/pdf/dartmouth/BASIC_Oct64.pdf" rel="nofollow noreferrer">originally used this symbol as well,</a> despite being primarily based on Fortran.  Some early teletypes and computers displayed character 5E as <code>↑</code>, but ASCII standardized it as <code>^</code>, and BASIC was the first language to officially make exponentiation <code>^</code>.  This symbol was later adopted by AWK and Donald E. Knuth’s TeX.  The ubiquity of TeX in mathematics is probably what led other languages used primarily by mathematicians to follow suit.</p>
<h2>Logical Operators</h2>
<p>The Medieval Latin abbreviation <code>&amp;</code> (originally a stylized <em>et</em>) came to be read as <em>and</em> in many languages that use the Latin script.  Algol used <code>⋎</code> for or in the reference language itself, but <a href="https://www.masswerk.at/algol60/report.htm" rel="nofollow noreferrer">the hugely influential ALGOL-60 report</a> also was the first to use BNF grammar.  Its section 1.1 introduces the syntax of BNF with:</p>
<blockquote>
<p>The marks <code>::=</code> and <code>|</code> (the latter with the meaning of or) are metalinguistic connectives.</p>
</blockquote>
<p>Successor languages designed after ASCII had become dominant used <code>|</code> to mean or within the language itself.  B in particular had no short-circuting logical or, only bitwise or, and used <code>|</code> to mean that.  BCPL and B had the optimization that a <code>&amp;</code> at the top level of a conditional expression, such as <code>if (p &amp; q)</code>, would short-circuit.</p>
<p>Algol had used the standard symbol <code>¬</code> for logical not.  Since that did not make it into ASCII and B had only bitwise complement (representing false as 0 and true as ~0, or -1 in two’s-complement), B used the closest available character to <code>¬</code> in ASCII, <code>~</code>.</p>
<p>Ken Thompson would later <a href="https://softwareengineering.stackexchange.com/questions/331388/why-was-the-caret-used-for-xor-instead-of-exponentiation">call the choice of <code>^</code> for exclusive-or in B</a> “a random choice of the characters left,” and say, “if i had it to do over again (which i did) i would use the same operator for xor (<code>^</code>) and bit complement (<code>~</code>)”  The “(which i did)” is a reference to how he made “the better-known operator” <code>^</code> mean both bitwise complement and exclusive-or in Golang.</p>
<p>The <code>&amp;&amp;</code> and <code>||</code> operators first appeared in C.  Dennis Ritchie <a href="https://www.bell-labs.com/usr/dmr/www/chist.html" rel="nofollow noreferrer">credits Alan Snyder for them.</a></p>
<blockquote>
<p>Rapid changes continued after the language had been named, for example the introduction of the &amp;&amp; and || operators. In BCPL and B, the evaluation of expressions depends on context: within if and other conditional statements that compare an expression&#39;s value with zero, these languages place a special interpretation on the and (&amp;) and or (|) operators. In ordinary contexts, they operate bitwise, but in the B statement</p>
<pre><code>if (e1 &amp; e2) ...
</code></pre>
<p>the compiler must evaluate e1 and if it is non-zero, evaluate e2, and if it too is non-zero, elaborate the statement dependent on the if. The requirement descends recursively on &amp; and | operators within e1 and e2. The short-circuit semantics of the Boolean operators in such `truth-value&#39; context seemed desirable, but the overloading of the operators was difficult to explain and use. At the suggestion of Alan Snyder, I introduced the &amp;&amp; and || operators to make the mechanism more explicit.</p>
</blockquote>
<h2>Speculation</h2>
<p>The division sign <code>/</code> was probably chosen to represent a fraction slash, as in 2/3.  The <code>%</code> symbol for modulus was likely picked as the closest ASCII equivalent of ÷.  Its occasional use for cents might have suggested its use for a remainder.</p>
    </div></div>
  </body>
</html>
