<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eli.thegreenplace.net/2025/implementing-forth-in-go-and-c/">Original</a>
    <h1>Implementing Forth in Go and C</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                <p>I first ran into Forth about 20 years ago when reading a book about
<a href="https://www.oreilly.com/library/view/designing-embedded-hardware/0596007558/">designing embedded hardware</a>.
The reason I got the book back then was to actually learn more about the HW
aspects, so having skimmed the Forth chapter I just registered an &#34;oh, this is neat&#34;
mental note and moved on with my life. Over the last two decades I
heard about Forth a few more times here and there, such as that time when
<a href="https://factorcode.org/">Factor</a> was talked about for a brief period, maybe
10-12 years ago or so.</p>
<p>It always occupied a slot in the &#34;weird language&#34; category inside my brain, and
I never paid it much attention. Until June this year, when a couple of factors
combined fortuitously:</p>
<ul>
<li>After spending much of the <a href="https://eli.thegreenplace.net/archives/2025">earlier part of 2025</a>
exploring the inner workings
of LLMs and digging in random mathy and algorithmic topics, I had an itch
to just write some code.</li>
<li>I somehow found <a href="https://ratfactor.com/forth/the_programming_language_that_writes_itself.html">Dave Gauer&#39;s page about Forth</a>
and also the one on <a href="https://ratfactor.com/forth/implementing">Implementing a Forth</a>.</li>
</ul>
<p>And something clicked. I&#39;m going to implement a Forth, because... why not?</p>
<p>So I spent much of my free hacking time over the past two months learning
about Forth and implementing <em>two</em> of them.</p>
<div id="forth-the-user-level-and-the-hacker-level">
<h2>Forth: the user level and the hacker level</h2>
<p>It&#39;s useful to think of Forth (at least <a href="https://forth-standard.org/">standard Forth</a>,
not offshoots like Factor) as having two different &#34;levels&#34;:</p>
<ol>
<li><strong>User</strong> level: you just want to use the language to write programs. Maybe
you&#39;re indeed bringing up new hardware, and find Forth a useful
calculator + REPL + script language. You don&#39;t care about Forth&#39;s
implementation or its soul, you just want to complete your task.</li>
<li><strong>Hacker</strong> level: you&#39;re interested in the deeper soul of Forth. Isn&#39;t it
amazing that even control flow constructs like <tt><span>IF...THEN</span></tt> or loops like
<tt><span>BEGIN...UNTIL</span></tt> are just Forth words, and if you wanted, you could implement
your own control flow constructs and have them be first-class citizens, as
seamless and efficient as the standard ones?</li>
</ol>
<p>Another way to look at it (useful if you belong to a certain crowd) is that
user-level Forth is like Lisp without macros, and hacker-level Forth has macros
enabled. Lisp can still be great and useful without macros, but macros take
it to an entire new level and also unlock the deeper soul of the language.</p>
<p>This distinction will be important when discussing my Forth implementations
below.</p>
</div>
<div id="goforth-and-ctil">
<h2>goforth and ctil</h2>
<p><img alt="Logo of goforth" src="https://eli.thegreenplace.net/images/pages/goforth-logo-sm.png"/></p><p>There&#39;s a certain way Forth is supposed to be implemented; this is how it was
originally designed, and if you get closer to the hacker level, it
becomes apparent that you&#39;re pretty much required to implement it this way -
otherwise supporting all of the language&#39;s standard words will be very
difficult. I&#39;m talking about the classical approach of a linked dictionary,
where a word is represented as a &#34;threaded&#34; list <a href="#footnote-1" id="footnote-reference-1">[1]</a>, and this dictionary is
available for user code to augment and modify. Thus, much of the Forth
implementation can be written in Forth itself.</p>
<p>The first implementation I tried is stubbornly different. Can we just make a
pure interpreter? This is what <a href="https://github.com/eliben/goforth">goforth</a>
is trying to explore (the Go implementation located in the root directory of
that repository). Many built-in words are supported - definitely enough to
write useful programs - and compilation
(the definition of new Forth words using <tt>: word ... ;</tt>) is implemented by
storing the actual string following the word name in the dictionary, so it can
be interpreted when the word is invoked.</p>
<p>This was an interesting approach and in some sense, it &#34;works&#34;. For the user
level of Forth, this is perfectly usable (albeit slow). However, it&#39;s
insufficient for the hacker level, because the host language interpreter (the
one in Go) has all the control, so it&#39;s impossible to implement <tt><span>IF...THEN</span></tt> in
Forth, for example (it has to be implemented in the host language).</p>
<p>That was a fun way to get a deeper sense of what Forth is about, but I did want
to implement the hacker level as well, so the second implementation -
<a href="https://github.com/eliben/goforth/tree/main/ctil">ctil</a> - does just that.
It&#39;s inspired by the <a href="http://git.annexia.org/?p=jonesforth.git">jonesforth</a>
assembly implementation, but done in C instead <a href="#footnote-2" id="footnote-reference-2">[2]</a>.</p>
<p>ctil actually lets us implement major parts of Forth in Forth itself. For
example, <tt>variable</tt>:</p>
<div><pre><span></span><span>:</span><span> </span><span>variable</span><span> </span><span>create</span><span> </span><span>1</span><span> </span><span>cells</span><span> </span><span>allot</span><span> </span><span>;</span><span></span>
</pre></div>
<p>Conditionals:</p>
<div><pre><span></span><span>\ IF, ELSE, THEN work together to compile to lower-level branches.</span><span></span>
<span>\</span><span></span>
<span>\ IF ... THEN compiles to:</span><span></span>
<span>\   0BRANCH OFFSET true-part rest</span><span></span>
<span>\ where OFFSET is the offset of rest</span><span></span>
<span>\</span><span></span>
<span>\ IF ... ELSE ... THEN compiles to :</span><span></span>
<span>\   0BRANCH OFFSET true-part BRANCH OFFSET2 false-part rest</span><span></span>
<span>\ where OFFSET is the offset of false-part and OFFSET2 is the offset of rest</span><span></span>
<span>:</span><span> </span><span>if</span><span> </span><span>immediate</span><span></span>
<span>  </span><span>&#39;</span><span> </span><span>0</span><span>branch</span><span> </span><span>,</span><span></span>
<span>  </span><span>here</span><span></span>
<span>  </span><span>0</span><span> </span><span>,</span><span></span>
<span>  </span><span>;</span><span></span>

<span>:</span><span> </span><span>then</span><span> </span><span>immediate</span><span></span>
<span>  </span><span>dup</span><span></span>
<span>  </span><span>here</span><span> </span><span>swap</span><span> </span><span>-</span><span></span>
<span>  </span><span>swap</span><span></span>
<span>  </span><span>!</span><span> </span><span>;</span><span></span>

<span>:</span><span> </span><span>else</span><span> </span><span>immediate</span><span></span>
<span>  </span><span>&#39;</span><span> </span><span>branch</span><span> </span><span>,</span><span></span>
<span>  </span><span>here</span><span></span>
<span>  </span><span>0</span><span> </span><span>,</span><span></span>
<span>  </span><span>swap</span><span></span>
<span>  </span><span>dup</span><span></span>
<span>  </span><span>here</span><span> </span><span>swap</span><span> </span><span>-</span><span></span>
<span>  </span><span>swap</span><span></span>
<span>  </span><span>!</span><span> </span><span>;</span><span></span>
</pre></div>
<p>These are actual examples of ctil&#39;s &#34;prelude&#34; - a Forth file loaded before any
user code. If you understand Forth, this code is actually rather mind-blowing.
We compile <tt>IF</tt> and the other words by directly laying our their low-level
representation in memory, and different words communicate with each other
using the data stack <em>during compilation</em>.</p>
</div>
<div id="thoughts-on-forth-itself">
<h2>Thoughts on Forth itself</h2>
<p>Forth made perfect sense in the historic context in which it was created in
the early 1970s. Imagine having some HW connected to your computer (a telescope
in the case of Forth&#39;s creator), and you have to interact with it. In terms
of languages at your disposal - you don&#39;t have much, even BASIC wasn&#39;t invented
yet. Perhaps your machine still didn&#39;t have a C compiler ported to it; C
compilers aren&#39;t simple, and C isn&#39;t very great for exploratory scripting
anyway. So you mostly just have your assembly language and whatever you build
on top.</p>
<p>Forth is easy to implement in assembly and it gives you a much higher-level
language; you can use it as a calculator, as a REPL, and as a DSL for pretty
much anything due to its composable nature.</p>
<p>Forth certainly has interesting aspects; it&#39;s a <a href="https://en.wikipedia.org/wiki/Concatenative_programming_language">concatenative language</a>,
and thus inherently <a href="https://en.wikipedia.org/wiki/Tacit_programming">point-free</a>.
A classical example is that instead of writing the following in a more
traditional syntax:</p>
<div><pre><span></span>eat(bake(prove(mix(ingredients))))
</pre></div>
<p>You just write this:</p>
<div><pre><span></span>ingredients mix prove bake eat
</pre></div>
<p>There is no need to explicitly pass parameters, or to explicitly return results.
Everything happens implicitly on the stack.</p>
<p>This is useful for REPL-style programming where you use your language not
necessarily for writing large programs, but more for interactive instructions to
various HW devices. This dearth of syntax is also what makes Forth simple
to implement.</p>
<p>All that said, in my mind Forth is firmly in the &#34;weird language&#34; category;
it&#39;s instructive to learn and to implement, but I wouldn&#39;t actually use it
for anything real these days. The stack-based programming model is cool for
very terse point-free programs, but it&#39;s not particularly readable and hard
to reason about without extensive comments, in my experience.</p>
<p>Consider the implementation of a pretty standard Forth word: <tt>+!</tt>. It expects
and address at the top of stack, and an addend below it. It adds the addend to
the value stored at that address. Here&#39;s a Forth implementation from
ctil&#39;s prelude:</p>
<div><pre><span></span><span>:</span><span> </span><span>+!</span><span>        </span><span>( addend addr -- )</span><span></span>
<span>  </span><span>tuck</span><span>      </span><span>( addr addend addr )</span><span></span>
<span>  </span><span>@</span><span>         </span><span>( addr addend value-at-addr )</span><span></span>
<span>  </span><span>+</span><span>         </span><span>( addr updated-value )</span><span></span>
<span>  </span><span>swap</span><span>      </span><span>( updated-value addr )</span><span></span>
<span>  </span><span>!</span><span> </span><span>;</span><span></span>
</pre></div>
<p>Look at that stack wrangling! It&#39;s really hard to follow what goes where without
the detailed comments showing the stack layout on the right of each instruction
(a common practice for Forth programs). Sure, we can create additional words
that would make this simpler, but that just increases the lexicon of words to
know.</p>
<p>My point is, there&#39;s fundamental difficulty here. When you see this C code:</p>
<div><pre><span></span><span>int</span><span> </span><span>func</span><span>(</span><span>int</span><span> </span><span>a</span><span>,</span><span> </span><span>int</span><span> </span><span>b</span><span>)</span><span> </span><span>{</span><span></span>
<span>  </span><span>return</span><span> </span><span>foo</span><span>(</span><span>a</span><span>,</span><span> </span><span>bar</span><span>(</span><span>b</span><span>));</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>Even without any documentation, you can immediately know several important
things:</p>
<ul>
<li><tt>bar</tt> has one parameter and one return value</li>
<li><tt>foo</tt> has two parameters and one return value</li>
<li><tt>func</tt> also has two parameters and one return value</li>
<li>It&#39;s immediately obvious how the various values flow from one function call
to the next.</li>
</ul>
<p>Written in Forth <a href="#footnote-3" id="footnote-reference-3">[3]</a>:</p>

<p>How can you know the arity of the functions without adding explicit comments?
Sure, if you have a handful of words like <tt>bar</tt> and <tt>foo</tt> you know like the
back of your hand, this is easy. But imagine reading a large, unfamiliar code
base full of code like this and trying to comprehend it.</p>
</div>
<div id="summary-and-links">
<h2>Summary and links</h2>
<p>The source code of my <a href="https://github.com/eliben/goforth">goforth project is on GitHub</a>; both
implementations are there, with a comprehensive test harness that tests both.</p>
<p>The learn Forth itself, I found these resources very useful:</p>
<ul>
<li><a href="https://ratfactor.com/forth/the_programming_language_that_writes_itself.html">Dave Gauer&#39;s Forth page</a></li>
<li><a href="https://www.forth.com/starting-forth/">Starting Forth</a> - a free online
book / tutorial on Forth for beginners</li>
</ul>
<p>To learn how to implement Forth:</p>
<ul>
<li><a href="https://ratfactor.com/forth/implementing">Dave Gauer&#39;s page on Implementing a Forth</a></li>
<li><a href="http://git.annexia.org/?p=jonesforth.git">jonesforth</a> implementation</li>
<li><a href="https://archive.org/details/R.G.LoeligerThreadedInterpretiveLanguagesTheirDesignAndImplementationByteBooks1981">Threaded Interpretive Languages</a> - an
old but nice book that explains how Forth implementations typically work</li>
</ul>
<p>Implementing Forth is a great self-improvement project for a coder; there&#39;s a
pleasantly challenging hump of understanding to overcome, and you gain valuable
insights into stack machines, interpretation vs. compilation and mixing these
levels of abstraction in cool ways.</p>
<p>Also, implementing programming languages
from scratch is fun! It&#39;s hard to beat the feeling of getting to interact with
your implementation for the first time, and then iterating on improving it
and making it more featureful. <a href="https://www.urbandictionary.com/define.php?term=One+More+Turn+Syndrome">Just one more word</a>!</p>
<hr/>



</div>

            </div></div>
  </body>
</html>
