<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.evalapply.org/posts/emerging-from-dotemacs-bankruptcy-ide-experience/index.html">Original</a>
    <h1>Emerging from dotemacs bankruptcy the hard way: integrating the IDE (feat. Clojure(Script))</h1>
    
    <div id="readability-page-1" class="page"><div id="the-very-top"><main id="main"><article id="blog-post"><header><div><p>Emerging from dotemacs bankruptcy the hard way: integrating the IDE (feat. Clojure(Script))</p><p>The one in which we design a rich Integrated Development Environment (IDE) experience, using Clojure as our muse. Featuring Language Server Protocol (lsp-mode + clojure-lsp), clojure-mode, cider, and more! Buckle up and get a coffee.</p><hr/></div></header><section><hr/><blockquote><p>Wild brush strokes across canvas</p><p>Hands invisible</p><p>A cool Starry Night</p></blockquote><figure><img src="https://www.bitsaboutmoney.com/archive/the-waste-stream-of-consumer-finance/emacs-clojure-ide-lsp-cider-reveal-gui.jpeg" alt=""/><figcaption>My Clojure IDE experience, built around Emacs <a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</figcaption></figure><p>Programs—even small ones—can be incredibly dense and complex. Beyond a point, they cannot be understood as mere textual entities. Nor can the human mind keep track of a self-updating correct emulation of their live meaning.</p><p>This is why people have built, and continue to build, a vast array of tools to help us understand and manipulate <em>meanings</em> of programming languages, their surroundings, and their runtimes.</p><p><em>Integrated Development Environments</em> (IDEs) provide bundles of these tools and services to assist the programmer. Tools and services that:</p><ul><li>are aware of code syntax and semantics, project layouts and structures</li><li>are aware of error checks and safeties the language provides (or need bolted-on)</li><li>can build, publish, use, run, observe, analyze software artifacts</li><li>help experiment with code, e.g. change code as we step through a debugger</li><li>these days, even unburden us from pinching StackOverflow answers <a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</li></ul><p>A big task calls for a little philosophical indulgence. I think there are at least two lenses we can use to explore this question.</p><p><em><strong>One lens:</strong> Tools integrating with <strong>us</strong> as humans.</em></p><p>Emacs, our building material, lets us mould it in our image, all the way from the guts of the lisp machine, to packages we use, to how various modes play off each other, to interoperability with the OS and third party software, to our muscle memory and our brains <a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</p><p><em><strong>The other lens:</strong> Integrating with how <strong>other things</strong> are integrated.</em></p><p>For example, a programming language <em>along with</em> its ecosystem. A plaintext notebook integrating TODOs, checklists, calendar, live code evaluation, export to other formats. A deep integration into code review and CI/CD <a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a>.</p><p><em><strong>Perhaps a third lens:</strong> is us integrating back with the development environment…</em></p><p>…by learning the tools, using them better, switching them out when we meet their limits. For example, Kotlin is IntelliJ-only. So I just port my daily driver Emacs shortcuts to IntelliJ, run it in &#34;Zen&#34; mode. I know it works because A) colleagues don&#39;t believe that it is, in fact, IntelliJ until I restore all the menus, file tree, and sundry visual cues, and because B) my muscle memory is oblivious to the differences. It simply continues taking care of me. <a href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a></p><p>We can configure our Emacs for this kind of deep integration, with the help of specialist tools designed for each language + ecosystem + runtime.</p><p>I will make an appeal to authority to set the touchstone for IDE requirements.</p><figure><iframe width="560" height="315" src="https://www.youtube.com/embed/tzr7hRXcwkw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</figure><p>Ok, motivation! Let&#39;s make working config now!</p><p>Programs, for better or worse, continue to be written in plain text. Our Emacs already is a pretty good general-purpose text editor that also &#34;just works&#34; for <em>any</em> text based programming language. Neat!</p><ul><li><code>projectile</code> for project-aware directory navigation</li><li><code>magit</code> for version control</li><li><code>avy</code> + <code>key-chord</code> to fluidly navigate / select text units</li><li><code>flyspell</code> for spellchecks</li><li><code>yasnippet</code> for boilerplate templates</li><li><code>expand-region</code> for incremental selection of units of text</li><li><code>multiple-cursors</code> to edit structured text</li><li><code>imenu</code> to display top-level names (vars, methods)</li><li><code>wgrep</code> for grep-powered search/replace across multiple files</li><li><code>eldoc</code> to surface function doc-strings and argument lists</li><li><code>paren</code> + <code>smartparens</code> for structural editing support, which works uniformly across Lispy languages, as well as for data representations in most other languages (e.g. quoted strings, JSON data, python tuples and dicts etc.)</li></ul><p>However we can <em>and should</em> do better. Much better! <a href="#fn6" id="fnref6" role="doc-noteref"><sup>6</sup></a></p><p>We write and modify code not as plain text, but as structural elements of the programming language at hand; viz. its syntax, semantics, idioms, patterns, conventions, method or function call graphs, object hierarchies, compiler feedback etc.</p><p>Historically, language-aware editors and IDEs have been purpose-built for individual languages. Emacs has historically been extended to new languages, because we can <a href="#fn7" id="fnref7" role="doc-noteref"><sup>7</sup></a>. In all cases, everyone has had to implement the same set of features from scratch, such as, auto-complete, documentation on hover, go to definition, code browsing, project browsing etc.</p><p>Recently, the <a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol (LSP) Project</a> changed the game, and quickly became foundational infrastructure for code editors <a href="#fn8" id="fnref8" role="doc-noteref"><sup>8</sup></a>. So much so that Emacs 29 baked in the <a href="https://github.com/joaotavora/eglot">eglot</a> language server client. We also have the <a href="https://github.com/emacs-lsp/">Emacs LSP</a> project that gives us <a href="https://emacs-lsp.github.io/">lsp-mode</a>, and other packages with which to design a general-purpose IDE experience.</p><p>I have been itching to design my baseline programming workflow around LSP. Familiarity with Emacs lsp-mode led me to choose it. Though I will probably switch to eglot whenever I upgrade my Emacs. I am using:</p><ul><li><a href="https://github.com/emacs-lsp/lsp-mode">lsp-mode</a>: Emacs client/library for the Language Server Protocol</li><li><a href="https://github.com/emacs-lsp/lsp-ui">lsp-ui</a>: inline UI display of flycheck diagnostics, LSP code actions, code lenses, documentation etc.</li><li><a href="https://github.com/emacs-lsp/lsp-ivy">lsp-ivy</a>: interactive ivy interface to lsp-mode&#39;s workspace symbol functionality</li></ul><p>Optionally (not sure about these two yet):</p><ul><li><a href="https://github.com/emacs-lsp/lsp-treemacs">lsp-treemacs</a>: treemacs-driven views of project files, symbols, errors, call graphs etc.</li><li><a href="https://github.com/emacs-lsp/dap-mode">dap-mode</a>: &#34;Debug Adapter Protocol&#34;, optionally, to integrate language specific debuggers</li></ul><pre><code>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Programming languages
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(use-package lsp-mode
  ;; ref: https://emacs-lsp.github.io/lsp-mode/page/installation/#use-package
  :ensure t
  :init
  (setq lsp-keymap-prefix &#34;C-c C-l&#34;)
  :hook ((clojure-mode clojurescript-mode clojurec-mode) . lsp-deferred)
  :hook (lsp-mode . lsp-enable-which-key-integration)
  :custom
  ;; LSP &#34;workspace&#34; dirs:
  ;; nb. &#34;workspace&#34; seems to be a confusing concept. It is a VSCode concept
  ;; that lsp-mode superseded as &#34;session&#34;, because lsp-mode was already using
  ;; the word &#34;workspace&#34; in some other context. See: `lsp-describe-session&#39;.
  ;; https://github.com/emacs-lsp/lsp-mode/discussions/3095
  ;; &#34;workspace&#34; directories still seem to server some purpose (no idea what),
  ;; and seem to be language specific.
  (lsp-clojure-workspace-dir
   (file-name-as-directory (expand-file-name &#34;workspace&#34;
                                             adi/dotemacs-dir)))
  :config
  (setq lsp-server-install-dir (file-name-as-directory ; install local to dotemacs
                                (expand-file-name &#34;lsp&#34; adi/dotemacs-cache-dir))
        ;; Perf. tweaks. Ref: https://emacs-lsp.github.io/lsp-mode/page/performance/
        lsp-idle-delay 0.500 ; bump higher if lsp-mode gets sluggish
        lsp-log-io nil
        ; lsp-enable-indentation nil ; set &#39;nil&#39; to use cider indentation instead of lsp
        ; lsp-enable-completion-at-point nil; set &#39;nil&#39; to use cider completion instead of lsp

        ;; No semgrep. https://emacs-lsp.github.io/lsp-mode/page/lsp-semgrep/
        ;; IDK why semgrep is on by default, docs are thin on configuring it
        ;; I don&#39;t want the error &#39;Command &#34;semgrep lsp&#34; is not present on the path.&#39;
        ;; because I don&#39;t want to &#34;pip install semgrep --user&#34;.
        lsp-semgrep-server-command nil)
  ;; LANGUAGE SPECIFIC SETTINGS
  ;; clojure-lsp: cf. https://clojure-lsp.io/clients/#emacs
  (add-to-list &#39;lsp-language-id-configuration
                `(clojurex-mode . &#34;clojure&#34;))
  :commands (lsp lsp-deferred))

(use-package lsp-ui
  :ensure t
  :after lsp-mode
  :commands lsp-ui-mode
  :bind (:map lsp-ui-mode-map ; h/t github.com/bbatsov/prelude
              ([remap xref-find-definitions] . #&#39;lsp-ui-peek-find-definitions)
              ([remap xref-find-references] . #&#39;lsp-ui-peek-find-references)
              (&#34;C-c C-l .&#34; . &#39;lsp-ui-peek-find-definitions)
              (&#34;C-c C-l ?&#34; . &#39;lsp-ui-peek-find-references)
              (&#34;C-c C-l r&#34; . &#39;lsp-rename)
              (&#34;C-c C-l x&#34; . &#39;lsp-workspace-restart)
              (&#34;C-c C-l w&#34; . &#39;lsp-ui-peek-find-workspace-symbol)
              (&#34;C-c C-l i&#34; . &#39;lsp-ui-peek-find-implementation)
              (&#34;C-c C-l d&#34; . &#39;lsp-describe-thing-at-point)
              (&#34;C-c C-l e&#34; . &#39;lsp-execute-code-action))
  :config
  ; h/t github.com/bbatsov/prelude
  (setq lsp-ui-sideline-enable t
        lsp-ui-doc-enable t
        lsp-ui-peek-enable t
        lsp-ui-peek-always-show t))

(use-package lsp-ivy
  :ensure t
  :after lsp-mode
  :commands lsp-ivy-workspace-symbol)

;; treemacs is cool, but I&#39;m not sure I want it yet.
;; cf: https://github.com/emacs-lsp/lsp-treemacs
;; and https://github.com/Alexander-Miller/treemacs
;; (use-package lsp-treemacs
;;   :ensure t
;;   :after lsp-mode
;;   :commands lsp-treemacs-errors-list
;;   :config
;;   (setq treemacs-space-between-root-nodes nil))

;; dap-mode, optionally to use LANGUAGE-specific debuggers
;; cf. https://emacs-lsp.github.io/lsp-mode/page/installation/#use-package
;; (use-package dap-mode)
;; (use-package dap-LANGUAGE :ensue t :after dap-mode) ; load dap adapter for LANGUAGE
</code></pre><p>LSP can solve a good chunk of the overall IDE design problem, but plenty is left for more specialised tools. Often, a language will have properties, runtimes, ecosystems which is out of scope for the language server project. For those needs, language-specific Emacs packages will likely be available.</p><p>Using Clojure as a practical example, here are some features we expect.</p><ul><li>Editing and linting support for all Clojure dialects, viz. Clojure, ClojureScript, Babashka, Cljc files, and EDN.</li><li>Tight integration with REPLs, test tools, debugger, profiler.</li><li>And hopefully some automagical support for Clojure-like languages such as <a href="https://janet-lang.org/">janet-lang</a>, <a href="https://ferret-lang.org/">ferret-lang</a>.</li></ul><p>Here are two demos of rock-solid professional Clojure IDE experiences.</p><figure><iframe width="560" height="315" src="https://www.youtube.com/embed/kjJVfoqFj_k" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe></figure><figure><iframe width="560" height="315" src="https://www.youtube.com/embed/gIoadGfm5T8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe></figure><p>We are well-served by the <a href="https://github.com/clojure-emacs">clojure-emacs</a> and <a href="https://github.com/clojure-lsp">clojure-lsp</a> projects. These, with allied packages enhance our Emacs&#39;s baseline programming experience, with Clojure focused features and capabilities.</p><h2 id="clojure-mode-foundational-clojure-programming-support">clojure-mode: foundational Clojure programming support</h2><p>This major mode provides syntax highlighting, indentation, navigation, and refactoring support for Clojure, ClojureScript, and mixed cljc code.</p><p>It also provides language-specific hooks that other modes can use to add more behaviours and features. For example, I want to defer the start of language servers until after a major mode is activated, so I set the hook in the lsp-mode config (<a href="#integration-level-two-language-as-structured-material-lsp-ftw">see above</a>).</p><pre><code>(use-package clojure-mode
  ;; Brings in clojure-mode for Clj, clojurescript-mode for Cljs,
  ;; and clojurec-mode for Cljc
  :ensure t
  ;; Hook into subword-mode to work with CamelCase tokens like Java classes
  ;; h/t suvratapte/dot-emacs-dot-d
  :hook ((clojure-mode . subword-mode)
         (clojure-mode . yas-minor-mode))

  :config
  (setq clojure-indent-style &#39;align-arguments)
  :blackout &#34;Clj&#34;)
</code></pre><h2 id="clojure-lsp-for-a-static-analysis-style-workflow-no-repl-needed">clojure-lsp: for a static-analysis style workflow, no REPL needed</h2><p><em><strong><a href="https://clojure-lsp.io/">clojure-lsp</a></strong></em> is a language server, and Emacs lsp-mode already knows about it (see <a href="#integration-level-two-language-as-structured-material-lsp-ftw">configuration above</a>).</p><figure><iframe width="560" height="315" src="https://www.youtube.com/embed/grL3DQyvneI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe></figure><p>clojure-lsp helps us <em>&#34;navigate, identify and fix errors, perform refactors and much more!&#34;</em>, with features like:</p><ul><li>Autocomplete</li><li>Jump to definition/implementation</li><li>Find references</li><li>Renaming</li><li>Code actions</li><li>Errors</li><li>Automatic ns cleaning</li><li>Lots of Refactorings</li><li>Code lens</li><li>Semantic tokens (syntax highlighting)</li><li>Linting (via clj-kondo)</li><li>Call hierarchy</li><li>Java interop</li></ul><p>All of this is available without even firing up a Clojure REPL, or adding any other package. For example, if we used only <code>clojure-mode</code>, we would have had to add linting support with <code>flycheck-clj-kondo</code> for Clojure and <code>flycheck-joker</code> for ClojureScript. And if we used only CIDER, then for better auto-complete using CIDER, we would use <code>ac-cider</code>.</p><p><em>However</em> static analysis is no substitute for programming Clojure interactively, against a live REPL. The excellent CIDER package enhances that for us.</p><h2 id="cider-putting-the-interactive-in-the-ide">CIDER: Putting the &#34;Interactive&#34; in the IDE</h2><p>In the nearly half century old tradition of Lisps, Smalltalks, and APLs, Clojure programming is a highly interactive exercise. We converse with the live runtime. Supporting this requires its own kind of tooling.</p><figure><iframe width="560" height="315" src="https://www.youtube.com/embed/IvTDzKVL58Y?start=1827" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe></figure><p><strong><a href="https://cider.mx/">CIDER</a>:</strong> is <em>&#34;the Clojure(Script) Interactive Development Environment that Rocks!&#34;</em>. Wherever CIDER and clojure-lsp offer similar features, I pick clojure-lsp, only adding what is unique to CIDER, viz.:</p><ul><li>Enhanced REPL experience and REPL session manager</li><li>Value inspector</li><li>Interactive Debugger</li><li>Profiler (CIDER profiler)</li><li>Session tracking (cider-spy + cider-spy-nrepl)</li><li>Test runner integration</li><li>Minibuffer code evaluation</li><li>Macro expansion</li><li>Smart namespace reloading</li><li>Refactor intelligently with clj-refactor</li></ul><p>Optionally, I will bring in clj-refactor to patch up corner cases where cider, and lsp-mode may both fall short.</p><pre><code>(use-package clojure-mode
  ;; Brings in clojure-mode for Clj, clojurescript-mode for Cljs,
  ;; and clojurec-mode for Cljc
  :ensure t
  ;; Hook into subword-mode to work with CamelCase tokens like Java classes
  ;; h/t suvratapte/dot-emacs-dot-d
  :hook ((clojure-mode . subword-mode)
         (clojure-mode . yas-minor-mode))

  :config
  (setq clojure-indent-style &#39;align-arguments)
  :blackout &#34;Clj&#34;)

(use-package cider
  ;; Note: Ensure CIDER and lsp-mode play well together, as we use both.
  ;; - LSP for more static-analysis-y services (completions, lookups, errors etc.),
  ;; - CIDER for &#34;live&#34; runtime services (enhanced REPL, interactive debugger etc.).
  :ensure t
  :after clojure-mode
  :init
  ;; Use clojure-lsp for eldoc and completions
  ;; h/t cider docs and ericdallo/dotfiles/.config/doom/config.el
  (remove-hook &#39;eldoc-documentation-functions #&#39;cider-eldoc)
  (remove-hook &#39;completion-at-point-functions #&#39;cider-complete-at-point)
  :custom
  (cider-preferred-build-tool &#39;clj)
  :bind
  (:map cider-mode-map
        (&#34;C-c C-l&#34; . nil))
  :config
  ;; settings h/t suvratapte/dot-emacs-dot-d
  (setq cider-repl-pop-to-buffer-on-connect nil
        cider-show-error-buffer t
        cider-auto-select-error-buffer t
        cider-repl-history-file (expand-file-name &#34;cider-history&#34;
                                                  adi/dotemacs-savefile-dir)
        cider-repl-wrap-history t
        cider-prompt-for-symbol nil
        cider-repl-use-pretty-printing t
        nrepl-log-messages nil
        ;; play nice with lsp-mode
        ;; h/t ericdallo/dotfiles/.config/doom/config.el
        cider-font-lock-dynamically nil ; use lsp semantic tokens
        cider-eldoc-display-for-symbol-at-point nil ; use lsp
        cider-prompt-for-symbol nil ; use lsp
        cider-use-xref nil ; use lsp
        ;; Maybe customize variables for cider-jack-in
        ;; https://docs.cider.mx/cider/basics/up_and_running.html
        )
  :blackout)

;; clj-refactor can go where clojure-lsp refactor can&#39;t go
(use-package clj-refactor
  ;; config h/t ericdallo/dotfiles doom emacs config
  :after clojure-mode
  :config
  (setq cljr-warn-on-eval nil
        cljr-eagerly-build-asts-on-startup nil
        cljr-add-ns-to-blank-clj-files nil ; use lsp
        cljr-magic-require-namespaces
        &#39;((&#34;s&#34;   . &#34;schema.core&#34;)
          (&#34;pp&#34; . &#34;clojure.pprint&#34;))))
</code></pre><h2 id="clojure-with-org-mode-for-live-demos-and-more">Clojure with org-mode for live demos and more</h2><p>As it happens, I do all my conference talks as live demos (What can I say, I like to live dangerously and embrace the demofails :)). The upshot of using org-mode is that I can publish my talks as plaintext org files that others can read or use, as well as static PDF or html files, optionally with in-line &#34;results capture&#34;.</p><p>Here is one such talk I gave last year, and <a href="https://www.bitsaboutmoney.com/archive/n-ways-to-fizz-buzz-in-clojure/index.html#main">its associated blog post</a>.</p><figure><iframe width="560" height="315" src="https://www.youtube.com/embed/BTouODWov-A" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe></figure><div id="cb5" data-org-language="emacs-lisp"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>(<span>use-package</span> org</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>  :ensure <span>nil</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>  :config</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>  (<span>setq</span> org-export-coding-system &#39;utf<span>-8</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>        org-babel-clojure-backend &#39;cider)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>  (org-babel-do-load-languages</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>   &#39;org-babel-load-languages</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>   &#39;((shell . <span>t</span>)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>     (clojure . <span>t</span>)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>     (clojurescript . <span>t</span>)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>     (sql .<span>t</span> )</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>     (sqlite . <span>t</span>)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a>     (plantuml . <span>t</span>))))</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a>(<span>use-package</span> ob-clojurescript</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true"></a>  :blackout)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true"></a>(<span>use-package</span> org-tree-slide</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true"></a>  <span>;; Simple org outline based presentation mode</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true"></a>  <span>;; ref: https://github.com/takaxp/org-tree-slide</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true"></a>  :ensure <span>t</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true"></a>  :bind ((<span>&#34;&lt;f8&gt;&#34;</span> . &#39;org-tree-slide-mode)</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true"></a>         (<span>&#34;S-&lt;f8&gt;&#34;</span> . &#39;org-tree-slide-skip-done-toggle)</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true"></a>         :map org-tree-slide-mode-map</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true"></a>         (<span>&#34;&lt;f9&gt;&#34;</span> . &#39;org-tree-slide-move-previous-tree)</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true"></a>         (<span>&#34;&lt;f10&gt;&#34;</span> . &#39;org-tree-slide-move-next-tree)</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true"></a>         (<span>&#34;&lt;f11&gt;&#34;</span> . &#39;org-tree-slide-content))</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true"></a>  :config</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true"></a>  (<span>setq</span> org-tree-slide-skip-outline-level <span>4</span>))</span></code></pre></div><h2 id="assist-emacs-with-graphical-interactive-development">Assist Emacs with <em>Graphical</em> Interactive Development</h2><p>Clojure programs model the world in terms of composite data structures; hash-maps, vectors, sequences, streams and so forth. <em>And</em> we also access host platform objects, classes, metadata. <em>And</em> we also like to traverse / inspect / visualise any of those entities from different angles, to further our understanding of what&#39;s actually going on in the live runtime.</p><p>Emacs is great for text UIs (e.g. magit), but not for rich graphical UIs. CIDER affords navigable views into much of this stuff right inside Emacs. <em>And</em> graphical tools like <em>vlaaad</em>&#39;s <a href="https://vlaaad.github.io/reveal/">Reveal</a>, <a href="https://docs.datomic.com/cloud/other-tools/REBL.html">Cognitect REBL</a> by Datomic Team, or Chris Badahdah&#39;s browser-based <a href="https://djblue.github.io/portal/">portal</a> data navigator level up our runtime visualisations and interactions to a whole other level.</p><figure><iframe width="560" height="315" src="https://www.youtube.com/embed/jq-7aiXPRKs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe></figure><figure><iframe width="560" height="315" src="https://www.youtube.com/embed/c52QhiXsmyI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe></figure><figure><iframe width="560" height="315" src="https://www.youtube.com/embed/Tj-iyDo3bq0?si=2G_BDhjZrmEDvsu0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe></figure><p>And finally, we have to integrate back with our programming ecosystem&#39;s build tooling. I have chosen to switch away from <a href="https://github.com/technomancy/leiningen/">Leiningen</a>, to the new-ish CLI tools by the Clojure team, that come bundled with Clojure these days. From the official <a href="https://clojure.org/guides/deps_and_cli">Deps and CLI Guide</a>:</p><blockquote><p>Clojure provides command line tools for:</p><ul><li>Running an <a href="https://clojure.org/guides/repl/introduction">interactive REPL</a> (Read-Eval-Print Loop)</li><li>Running Clojure programs</li><li>Evaluating Clojure expressions</li></ul></blockquote><p>My CLI tools invocation looks like this:</p><pre><code>adi@tardis:~/src/github/adityaathalye/planet_coloniser
\_$ clj -M:dev/base:repl/clj:repl/reveal
nREPL server started on port 34139 on host localhost - nrepl://localhost:34139
nREPL 1.0.0
Clojure 1.10.3
OpenJDK 64-Bit Server VM 18.0.2-ea+9-Ubuntu-222.04
Interrupt: Control+C
Exit:      Control+D or (exit) or (quit)
user=&gt;
</code></pre><p>And below is my global <code>deps.edn</code> configuration that declare a few standard clj aliases (e.g. <code>:dev/base</code>, <code>:repl/clj</code>, <code>:repl/reveal</code>) that I want across all Clojure(Script) projects. These configurations let our Emacs play well with CIDER middleware, clj-refactor, Reveal etc.</p><div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>{<span>;; Ref. deps configs by Sean Corfield and practicalli</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a> <span>;; Lots of stuff taken from there.</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a> <span>;; https://github.com/seancorfield/dot-clojure/blob/develop/deps.edn</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a> <span>;; https://github.com/practicalli/clojure-cli-config/blob/main/deps.edn</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a> <span>;; Enumerate aliases as:</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a> <span>;; clj -T:deps aliases</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a> <span>;; Start a typical session as:</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a> <span>;; clj -M:dev/base:repl/clj:repl/reveal</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a> <span>:paths</span> [<span>&#34;src&#34;</span>]</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a> <span>:mvn/repos</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a> {<span>&#34;central&#34;</span> {<span>:url</span> <span>&#34;https://repo1.maven.org/maven2/&#34;</span>}</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a>  <span>&#34;clojars&#34;</span> {<span>:url</span> <span>&#34;https://repo.clojars.org/&#34;</span>}}</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a> <span>:aliases</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a> {<span>:build</span> {<span>:deps</span> {io.github.clojure/tools.build {<span>:mvn/version</span> <span>&#34;0.9.5&#34;</span>}}</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a>          <span>:ns-default</span> build}</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true"></a></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true"></a>  <span>;; LOCAL DEVELOPMENT</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true"></a>  <span>:dev/base</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true"></a>  {<span>:extra-paths</span> [<span>&#34;dev&#34;</span>]}</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true"></a></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true"></a>  <span>:dev/test</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true"></a>  {<span>:extra-paths</span> [<span>&#34;test&#34;</span>]</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true"></a>   <span>:extra-deps</span> {org.clojure/test.check {<span>:mvn/version</span> <span>&#34;1.1.1&#34;</span>}</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true"></a>                io.github.cognitect-labs/test-runner {<span>:git/tag</span> <span>&#34;v0.5.1&#34;</span> <span>:git/sha</span> <span>&#34;dfb30dd&#34;</span>}}}</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true"></a></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true"></a>  <span>:dev/tools</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true"></a>  {<span>:extra-deps</span> {criterium/criterium {<span>:mvn/version</span> <span>&#34;RELEASE&#34;</span>}}}</span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true"></a></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true"></a>  <span>;; CIDER AND REPL THINGS</span></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true"></a>  <span>;; https://docs.cider.mx/cider/basics/middleware_setup.html</span></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true"></a>  <span>;; nb. we should get nrepl and refactor-nrepl bundled with cider-nrepl</span></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true"></a>  <span>;; - for clojure-only: clj -M:repl/clj</span></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true"></a>  <span>;; - for clj and cljs: clj -M:repl/clj:repl/cljs</span></span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true"></a>  <span>;; - for reveal GUI:   clj -M:repl/clj:repl/cljs:repl/reveal</span></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true"></a>  <span>:repl/clj</span></span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true"></a>  {<span>:extra-deps</span> {cider/cider-nrepl {<span>:mvn/version</span> <span>&#34;0.37.0&#34;</span>}</span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true"></a>                org.clojure/tools.deps {<span>:mvn/version</span> <span>&#34;0.18.1354&#34;</span>}</span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true"></a>                org.clojure/tools.<span>namespace</span> {<span>:mvn/version</span> <span>&#34;RELEASE&#34;</span>}}</span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true"></a>   <span>:main-opts</span> [<span>&#34;-m&#34;</span> <span>&#34;nrepl.cmdline&#34;</span></span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true"></a>               <span>&#34;--middleware&#34;</span> <span>&#34;[cider.nrepl/cider-middleware]&#34;</span></span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true"></a>               <span>&#34;--interactive&#34;</span>]}</span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true"></a></span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true"></a>  <span>:repl/cljs</span></span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true"></a>  {<span>:extra-deps</span> {org.clojure/clojurescript {<span>:mvn/version</span> <span>&#34;1.10.339&#34;</span>}</span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true"></a>                cider/piggieback {<span>:mvn/version</span> <span>&#34;0.5.3&#34;</span>}}</span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true"></a>   <span>:main-opts</span> [<span>&#34;-m&#34;</span> <span>&#34;nrepl.cmdline&#34;</span></span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true"></a>               <span>&#34;--middleware&#34;</span> <span>&#34;[cider.piggieback/wrap-cljs-repl]&#34;</span></span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true"></a>               <span>&#34;--interactive&#34;</span>]}</span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true"></a></span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true"></a>  <span>;; :repl/refactor</span></span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true"></a>  <span>;; {:extra-deps {refactor-nrepl/refactor-nrepl {:mvn/version &#34;3.9.0&#34;}}</span></span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true"></a>  <span>;;  :main-opts [&#34;--middleware&#34; &#34;[refactor-nrepl.middleware/wrap-refactor]&#34;]}</span></span>
<span id="cb7-58"><a href="#cb7-58" aria-hidden="true"></a></span>
<span id="cb7-59"><a href="#cb7-59" aria-hidden="true"></a>  <span>:repl/reveal</span> <span>;; https://vlaaad.github.io/reveal/setup#clj--nrepl-middleware</span></span>
<span id="cb7-60"><a href="#cb7-60" aria-hidden="true"></a>  {<span>:extra-deps</span> {vlaaad/reveal {<span>:mvn/version</span> <span>&#34;1.3.280&#34;</span>}}</span>
<span id="cb7-61"><a href="#cb7-61" aria-hidden="true"></a>   <span>;; optional: preferences</span></span>
<span id="cb7-62"><a href="#cb7-62" aria-hidden="true"></a>   <span>;; :jvm-opts [&#34;-Dvlaaad.reveal.prefs={:theme,:light}&#34;]</span></span>
<span id="cb7-63"><a href="#cb7-63" aria-hidden="true"></a>   <span>:main-opts</span> [<span>&#34;-m&#34;</span> <span>&#34;nrepl.cmdline&#34;</span></span>
<span id="cb7-64"><a href="#cb7-64" aria-hidden="true"></a>               <span>&#34;--middleware&#34;</span> <span>&#34;[vlaaad.reveal.nrepl/middleware]&#34;</span></span>
<span id="cb7-65"><a href="#cb7-65" aria-hidden="true"></a>               <span>&#34;--interactive&#34;</span>]}}</span></code></pre></div><p><a href="https://www.youtube.com/watch?v=4X-1fJm25Ww">The evolution of the Emacs tooling for Clojure (2014)</a>, Bozhidar Batsov.</p><blockquote><p>A session dedicated to the evolution of CIDER (the Clojure dev environment for Emacs) and all the new features that have been added since I took over the project exactly one year ago.</p></blockquote><p>CIDER was already cool circa 2014, and has come a long way since then!</p><p><a href="https://www.youtube.com/watch?v=dZ4xczP5zDI">The Future of Clojure Tooling (2018)</a>, Bozhidar Batsov is a nice follow-up to his 2014 talk. By 2018, LSP had arrived and debates about &#34;REPL Powered&#34; <em>versus</em> &#34;Static Analysis Powered&#34; tooling were in the air. We now have the best of both worlds, because even though those world overlap, they are not, in fact, in conflict!</p><p>As you have seen so far, both LSP and CIDER enhance our Clojure programming life in Emacs. The fantastic Cursive IDE for IntelliJ is the original model of a seamless static+REPL powered Clojure IDE. If I weren&#39;t already invested in Emacs, I would have picked Cursive.</p><p><a href="https://www.youtube.com/watch?v=vt1y2FbWQMg">Cursive: A different type of IDE (2014)</a> , Colin Fleming.</p><p>In contrast to the majority of Clojure development environments, Cursive uses static analysis of the source code to work its magic rather than taking advantage of the REPL.</p><p><a href="https://www.youtube.com/watch?v=ql77RwhcCK0">Debugging Clojure Code With Cursive</a>, Colin Fleming</p><p>A very good showcase of a rock-solid debugger and debugging experience. Cursive provides a complete JVM debugger based on the one provided in IntelliJ, including breakpoints, stepping and expression evaluation.</p><h2 id="emacs-is-a-first-rate-c-ide-john">Emacs is a first-rate C++ IDE, John</h2><p>I feel compelled to include this section because I set up this post by quoting famous C++ developer and a lover of great IDEs, John Carmack.</p><p>Even without LSP, Emacs was configurable as a first-rate IDE for large scale codebases: <a href="https://www.youtube.com/watch?v=5FQwQ0QWBTU">CppCon 2015: Emacs as a C++ IDE</a> - Atila Neves.</p><p>Now that we <span>have</span> LSP, <a href="https://emacs-lsp.github.io/lsp-mode/tutorials/CPP-guide/">the C++ IDE story is even better</a>!</p><p>We have come a long way!</p><p>All the big pieces are in place, and the general design looks good to me. I will add enhancements, and fix bad ideas and bugs as I go along.</p><ul><li>[✓] Set the very preliminaries.</li><li>[✓] Set up package management. I&#39;ll probably stick with the old familiars; elpa and melpa. I&#39;m not sure about straight.el at this time.</li><li>[✓] Choose <code>use-package</code> to get and configure each package. I like how neat configs are, when defined with use-package.</li><li>[✓] Unexpectedly refactor the whole thing.</li><li>[✓] Make completions and &#34;getting about&#34; work (the right mix of ivy, consul, swiper, company, helm, imenu). Someone mentioned newer alternatives to helm. Have a look at that.</li><li>[✓] Fix general text editing stuff (keybindings, multiple cursors, snippets etc.)</li><li>[✓] Add support for favourite programming languages.<ul><li>[✓] Emacs Lisp (built-in + smartparens, eldoc etc.)</li><li>[✓] Clojure (clojure-mode, clojure-lsp, CIDER, and lispy editing packages)</li><li>[✓] Bash (lsp-bash)</li><li>Others will be configured on an as-needed basis.</li></ul></li><li>[✓] org-mode specifics that suit <a href="https://www.bitsaboutmoney.com/archive/why-and-how-i-use-org-mode/index.html#main">how I use org</a><ul><li>[✓] org-babel (currently for Clojure, elisp, shell, SQL and some other langs)</li><li>[✓] tree-slide for presentations</li></ul></li><li>then let&#39;s see…</li></ul><p>This was educational, fun, satisfying, and useful.</p><p>I <a href="https://github.com/adityaathalye/dotemacs">published it</a>, and call it done (for now)!</p><pre><code># https://github.com/adityaathalye/dotemacs
ln -s ~/src/github/adityaathalye/dotemacs ~/.emacs.d
</code></pre></section></article></main></div></div>
  </body>
</html>
