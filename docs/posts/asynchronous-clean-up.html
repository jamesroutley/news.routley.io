<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://without.boats/blog/asynchronous-clean-up/">Original</a>
    <h1>Asynchronous clean-up</h1>
    
    <div id="readability-page-1" class="page"><section><p>One problem with the design of async Rust is what do about async clean-up code. Consider that you
have a type representing some object or operation (like an async IO handle) and it runs clean up
code when you are done using it, but that clean up code itself is also non-blocking and could yield
control. Async Rust has no good way to handle this pattern today.</p><p>The nicest solution seems to be to just use the mechanism that already exists: destructors. If only
you could <code>await</code> inside a destructor, everything would seem to be solved. Alas, this would present
several problems, and I personally do not believe it is realistic to imagine Rust gaining this
feature in the same way that destructors work.</p><p>The first problem is this: what happens if you drop the the value in a non-async scope? It’s not
possible to <code>await</code> there! There are two options: either the async destructor doesn’t run
(considered too easy a mistake to make), or there is a type-checking rule that prevents users from
dropping values with async destructors in non-async scopes. The second solution reduces to
undroppable types, which I will discuss later in this post: this rule is just undroppable types with
an exception to allow them to be dropped in an async scope. What I can say with certainty is that
undroppable types, even with an exception, would be very difficult to add to Rust.</p><p>The second problem is the way that the state of the async destructor would impact the state of any
future any containing it. This is actually a re-emergence of the problems with async methods, but
now applied to any generic type (because you don’t know of a generic type <code>T</code> has an async
destructor). The first problem is that you have any trait object, when it drops, what happens if it
has an async destructor? This introduces the same object safety issues as async methods: you have
nowhere to store the future returned by the async destructor of a trait object. The second problem
is that you want to send a value to a different thread, that state of its async destructor also
needs to be <code>Send</code>. This is the same problem that motivated RTN, except that now its a problem for
<em>every</em> generic type being moved to another thread, not only types on which you explicitly call an
async method. I wrote about this problem years and years ago, but it seems to have been
misunderstood and ignored since then.</p><p>The third problem is that users are concerned about having implicit await points added to their
future without them realizing it. Therefore there would need to be some restriction that not only
doesn’t allow these types to be dropped in a non-async scope, but also makes it so that they are
destructed at an already explicit <code>await</code> point. This would make the rules around when their async
destructors run very different from other destructors, if its even possible to make them coherent.</p><p>The fourth problem, I believe maybe never raised before, is that it is not the ideal code generation
to run async destructors sequentially no matter what. For example, if I have two values that I am
asynchronously dropping, possibly I want to <code>join</code> the destructors so they run concurrently. But
doing this implicitly would be very risky, because maybe I actually carefully expect one to run
before the other.</p><p>All of these problems hint at a different way to frame the problem of asynchronous clean-up: the
problem is not that there is no async drop, but that destructors really only work when you can write
a destructor function that returns <code>()</code>. Async clean-up is just a special case of clean-up which
does not return <code>()</code>. In this case it returns a future, but there are also scenarios in which the
issue is a lack of destructors that can return <code>Result</code>, for example.</p><p>I want to explore the design space for asynchronous clean up and clean up code that returns values
in general, without a focus on destructors specifically. The proposal I’ve fleshed out here, based
heavily on the work of others (especially Eric Holk and Tyler Mandry), combines two distinct
features - async future cancellation and a <code>do</code> … <code>final</code> construct - to enable users to write
asynchronous clean up code that is consistently called. I will also show how these constructs are
required for any sort of “linear type” mechanism in Rust, so rather than seeing them as alternative
to type-based async clean up code, they should be seen as prerequisites that can be implemented in
the nearer term.</p><p>There are two reasons a future could need to clean up its state. The first would be that the future
is ready, and is returning its final value. The second is that while the future was pending, the
caller lost interest in it and canceled it. This section is about introducing an asynchronous
cancellation mechanism, so that asynchronous clean-up can occur during cancellation.</p><p>Canceling work is one of the big issues of concurrent programming, and different concurrency
systems have different approaches. One way to frame the design space is to position designs for
cancellation on a spectrum of <em>cooperativeness</em>. At one end you would have <em>non-cooperative
cancellation</em>, in which a unit of work can be canceled without any handling within the work unit
itself. At the other end you would have <em>cooperative cancellation</em>, in which a unit of work cannot
be canceled and will be run until it finishes (you can implement cancellation in such a system by
the work unit returning an <code>Option</code> or a nullable type, depending on your language, and having a
mechanism for your work unit to receive a message to cancel it).</p><p>Go’s goroutines are cooperatively canceled; they can’t be canceled unless they explicitly opt into
cancellation. POSIX threads can be non-cooperatively canceled by sending them <code>SIGKILL</code> with
<code>pthread_kill(3)</code> (EDIT: this is wrong, because sending a POSIX thread <code>SIGKILL</code> will kill your
whole process; I don’t have an example of fully non-cooperative cancellation available off the top
of my head.)</p><p>The problem with non-cooperative cancellation is that it might leave the program in a bad state, as
that unit of work could have held locks or owned heap memory, which now will all be leaked. The
problem with cooperative cancellation is that if a unit of work doesn’t opt into being canceled, it
will run to completion even if its work is no longer necessary.</p><p>Between these extremes there exists a range of what you might call <em>semi-cooperative cancellation</em>
mechanisms. With these mechanisms, a unit of work might be moved into a control-flow path for
cancellation, without its cooperation, but it can execute some specifically designated code to
“clean up” its state as it is canceled. This is intended to find a middle ground between
cooperative and non-cooperative cancellation.</p><p>Rust’s async model currently adopts a semi-cooperative cancellation model in practice: during any
<code>await</code> point in a future, the future might be canceled. A correctly implemented runtime will run
the destructor on that future, allowing it to clean up its state. However, that cancellation code
must be entirely synchronous; to support asynchronous clean-up code, what is required is some form
of <em>asynchronous semi-cooperative cancellation</em>, which I will just refer to as “async cancellation.”</p><p>Some additional nuance should be noted, if this isn’t already too complex. First, async Rust only
supports cancellation at <code>await</code> points: except at an <code>await</code> point, the user can be assured the
future will not be canceled. This is an implication of the fact that async Rust uses <em>cooperative
scheduling</em>, in which units of work cannot be preempted and only yield control back to the scheduler
when they choose to. This has its own pros and cons. Second, though cancellation in async Rust is
semi-cooperative in practice, code authors cannot rely on cancellation for soundness: it is not
undefined behavior to cancel a future without running its clean up code. This will we return to in a
later section of the post.</p><h2 id="poll_cancel"><code>poll_cancel</code></h2><p>To support async cancellation, the traits for async units of work need to gain an API for canceling
them asynchronously. This is <code>poll_cancel</code>, as in this change to the definition of <code>Future</code>:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>trait</span><span> </span><span>Future</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>type</span> <span>Output</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>poll</span><span>(</span><span>self</span>: <span>Pin</span><span>&lt;&amp;</span><span>mut</span><span> </span><span>Self</span><span>&gt;</span><span>,</span><span> </span><span>cx</span>: <span>&amp;</span><span>mut</span><span> </span><span>Context</span><span>&lt;</span><span>&#39;_</span><span>&gt;</span><span>)</span><span> </span>-&gt; <span>Poll</span><span>&lt;</span><span>Self</span>::<span>Output</span><span>&gt;</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>poll_cancel</span><span>(</span><span>self</span>: <span>Pin</span><span>&lt;&amp;</span><span>mut</span><span> </span><span>Self</span><span>&gt;</span><span>,</span><span> </span><span>cx</span>: <span>&amp;</span><span>mut</span><span> </span><span>Context</span><span>&lt;</span><span>&#39;_</span><span>&gt;</span><span>)</span><span> </span>-&gt; <span>Poll</span><span>&lt;</span><span>()</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>// By default, futures do not have any async cancellation code
</span></span></span><span><span><span></span><span>        </span><span>Poll</span>::<span>Ready</span><span>(())</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>Eric Holk discussed this new API at length in a great <a href="https://theincredibleholk.org/blog/2023/11/14/a-mechanism-for-async-cancellation/">post</a> last year. Some notes on this
from my perspective follow.</p><p>First, I would not immediately support an <code>on_cancel</code> extension to <code>Future</code>: I think that it does
not make sense for ordinary async Rust (not written in the lower level poll register) to have
clean-up that <em>only</em> runs on cancellation, and not whenever it finishes. I think there’s a risk of
bugs here, because if a user writes a loop that never terminates in their cancellation code, the
task will never actually be canceled. Then anything which cancels them non-concurrently, like
<code>select!</code>, would also never terminate. Because this code only runs on cancellation, it would not be
as likely to be tested for bugs like this. I would be interested in examples of code that users
believe require cancellation-specific async code, though. Later in this post I’ll show a way to
support async clean-up code that runs on both cancellation and normal completion.</p><p>This also alleviates the need for considering any sort of question about “what happens if you cancel
the cancellation future,” and whether that is recursive or idempotent: once a future begins
canceling, “canceling” it again is idempotent, because its already canceling; there is no second
future to cancel.</p><p>Second, a critical addition would be to add <code>poll_cancel</code> to <code>AsyncIterator</code> as well. This would
allow <code>AsyncIterator</code>s to also support async clean up on cancellation (including async generators).
As a result of this, the code generation of <code>poll_cancel</code> on an async block or function would be
more complex. First, it would call <code>poll_cancel</code> on whatever future was being awaited, if it was
awaiting a future. Then, it would walk backwards to call <code>poll_cancel</code> on every <code>AsyncIterator</code> it
was looping over with <code>for await</code>, canceling them as well.</p><p>Once these APIs are stabilized in the minimum supported Rust version of the frameworks, those
frameworks should begin calling <code>poll_cancel</code> on any futures that they cancel. In this way, async
Rust will come to support async cancellation on any runtime updated to the version which supports
this mechanism. Though it won’t be an iron-clad guaranteed, in the same way that destructors are not
an iron-clad guarantee, if you’re using a supportive version of any good runtime, your futures will
consistently run their cancellation code.</p><h2 id="async-unwinding">Async unwinding</h2><p>Eric Holk touches on unwinding in his blog post, but I think there are some mistakes in his remarks.
Here is my attempt to describe async unwinding behavior.</p><p>The unwinding path for a future would need to also call <code>poll_cancel</code>. The only complication that
arises is what to do about calling <code>Pending</code>.</p><p>A new API, an async version of <code>catch_unwind</code>, would be added to the standard library. When this
catches an unwinding that returned <code>Pending</code>, it would itself return <code>Pending</code> and unset the panic
state. When it is polled again, it sets the panic state and polls itself, proceeding further through
the <code>poll_cancel</code> method of the future it wraps. Eventually, <code>poll_cancel</code> returns ready, at which
point the async <code>catch_unwind</code> returns with a panic error.</p><p>If <code>poll_cancel</code> returns <code>Pending</code> while unwinding not inside of the async <code>catch_unwind</code>, one of
two choices can be made: either the entire process aborts, or control jumps immediately to the
innermost <code>catch_unwind</code> without executing any further unwinding code. Probably the former is the
safer choice.</p><p>In addition to upgrading to handle cancellation, runtimes would need to upgrade to use the
asynchronous version of <code>catch_unwind</code>.</p><p>The second step to make async clean up work is totally separate from supporting async cancellation:
it’s a way to do clean up other than destructors. This will solve several problems: first, it will
solve the general “clean up with meaningful return values” problem (whether they return <code>Result</code> or
<code>Future</code>) discussed earlier. Second, it will provide a way to do ad hoc clean up without the
rigamarole of creating a custom guard type with a destructor, which code that needs to do one-off ad
hoc clean up currently needs to do.</p><p>The basic concept is to add a new kind of block construct, which has a way to specify code that runs
whenever that block exits. I’ve chosen the syntax <code>do</code> … <code>final</code>, because both of these are
already reserved words without meaning in Rust. You can easily imagine other syntaxes: Go’s <code>defer</code>
blocks are basically the same feature, but with less of the block structuring of this syntax.</p><p>For example:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>do</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>if</span><span> </span><span>fallible_call</span><span>()</span><span>?</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>println!</span><span>(</span><span>&#34;successful and true&#34;</span><span>)</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>panic!</span><span>(</span><span>&#34;successful but true&#34;</span><span>)</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span> </span><span>final</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>println!</span><span>(</span><span>&#34;exiting block&#34;</span><span>)</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>This code could exit the <code>do</code> block in 3 different ways: it could exit normally, <code>fallible_call</code>
could return an error, or the block could panic. In all cases, the final block will be run before
proceeding, so it will print the message <code>&#34;exiting block&#34;</code> whatever happens.</p><p>The <code>final</code> block must always evaluate to <code>()</code>, and the entire construct will evaluate to the type
that the <code>do</code> block evaluates to.</p><p>This reduces the pattern of “ad hoc guards” to relatively simple constructs. Consider this example:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>foo</span><span>.</span><span>bar</span><span>();</span><span>
</span></span></span><span><span><span></span><span>closure</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>foo</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span></span><span>foo</span><span>.</span><span>unbar</span><span>();</span><span>
</span></span></span></code></pre></div><p>If the user’s intent is to call <code>unbar</code> every time the closure exits, they will fail: if the closure
exits by panicking or by returning an error, <code>unbar</code> will not be called. For this reason, ad hoc
guard types are used in that scenario:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>struct</span> <span>Guard</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span>(</span><span>&amp;</span><span>&#39;a</span><span> </span><span>mut</span><span> </span><span>Foo</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>impl</span><span> </span><span>Drop</span><span> </span><span>for</span><span> </span><span>Guard</span><span>&lt;</span><span>&#39;_</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>drop</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>self</span><span>.</span><span>0.</span><span>unbar</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>mut</span><span> </span><span>guard</span><span> </span><span>=</span><span> </span><span>Guard</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>foo</span><span>);</span><span>
</span></span></span><span><span><span></span><span>guard</span><span>.</span><span>0.</span><span>bar</span><span>();</span><span>
</span></span></span><span><span><span></span><span>closure</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>guard</span><span>.</span><span>0</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span></span><span>drop</span><span>(</span><span>guard</span><span>);</span><span>
</span></span></span></code></pre></div><p>This is quite a bit of code to have to add for this case. <code>do</code> … <code>final</code> blocks will make the
whole thing simpler:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>foo</span><span>.</span><span>bar</span><span>();</span><span>
</span></span></span><span><span><span></span><span>do</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>closure</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>foo</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span></span><span>}</span><span> </span><span>final</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>foo</span><span>.</span><span>unbar</span><span>();</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>They’re also helpful for handling errors in fallible clean up. Consider the case of closing a file:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span><span> </span><span>mut</span><span> </span><span>file</span><span> </span><span>=</span><span> </span><span>File</span>::<span>open</span><span>(</span><span>path</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span></span><span>operate_on_file</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>file</span><span>);</span><span>
</span></span></span><span><span><span></span><span>drop</span><span>(</span><span>file</span><span>);</span><span>
</span></span></span></code></pre></div><p>On a UNIX system, the file is closed in the call to <code>drop</code> by calling <code>close(2)</code>. What happens if
that call returns an error? The standard library ignores it. This is partly because there’s not much
you can do to respond to <code>close(2)</code> erroring, as a comment in the standard library elucidates:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>// Note that errors are ignored when closing a file descriptor. The
</span></span></span><span><span><span>// reason for this is that if an error occurs we don&#39;t actually know if
</span></span></span><span><span><span>// the file descriptor was closed or not, and if we retried (for
</span></span></span><span><span><span>// something like EINTR), we might close another valid file descriptor
</span></span></span><span><span><span>// opened after we closed ours.
</span></span></span></code></pre></div><p>“Worse is better.”</p><p>However, a user may still want some level of control over what happens in this case, even if just to
log that an error occurred (which can be used to assist in debugging any incident that may arise).
Toward that end, <code>File</code> could also have a close method which returns a <code>Result</code>. Users would then be
able to use <code>final</code> blocks to call that method and handle the error however they like, should it
arise:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span><span> </span><span>mut</span><span> </span><span>file</span><span> </span><span>=</span><span> </span><span>File</span>::<span>open</span><span>(</span><span>path</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span></span><span>do</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>operate_on_file</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>file</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span></span><span>}</span><span> </span><span>final</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>if</span><span> </span><span>let</span><span> </span><span>Err</span><span>(</span><span>err</span><span>)</span><span> </span><span>=</span><span> </span><span>file</span><span>.</span><span>close</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>info!</span><span>(</span><span>&#34;Error occurred closing file at {path}: {err}&#34;</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><h2 id="awaiting-in-final-blocks">Awaiting in <code>final</code> blocks</h2><p>Both of these use cases are completely separate from async clean up, but the feature is also useful
for async clean up, because <code>final</code> blocks would be able to contain <code>await</code> expressions. For
example:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>do</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>process_messages</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>socket</span><span>).</span><span>await</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span></span><span>}</span><span> </span><span>final</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>socket</span><span>.</span><span>shutdown_graceful</span><span>().</span><span>await</span><span>;</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>The <code>poll_cancel</code> implementation for async scopes would also execute the <code>final</code> blocks for any <code>do</code>
blocks that the future is currently within, in addition to the <code>poll_cancel</code> for the future being
awaited and any async iterators being looped over.</p><p>Thus, between async cancellation and <code>do</code> … <code>final</code>, a method of performing async clean up is
achieved. The limitation of this, in contrast to async destructors, is that it is not tied to
specific types: a socket type cannot guarantee that it will always be shutdown gracefully. This will
be addressed in the later section on linear types.</p><p>Before moving on to linear types, I have some notes on other control flow operators and their
relationship to <code>final</code> blocks. There may be errors of reasoning in this section, I’m not confident
I’ve correctly thought through the control flow possibilities.</p><h2 id="early-exit-in-final-blocks">Early exit in <code>final</code> blocks</h2><p>One particular quirk of <code>final</code> blocks will be what to do if they early exit with a value, because
the user might <em>already</em> be early exiting with a value. Consider:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>do</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>read</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>file</span><span>,</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>buffer</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span></span><span>}</span><span> </span><span>final</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>close</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>file</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>If <code>read</code> returns an error and we enter the <code>final</code> block, what happens then if close also returns
an error? We can’t return <em>both</em> errors. There are only two options that I can imagine:</p><ol><li>Disallow early exit in <code>final</code> blocks. This is the most restrictive, but leads to no confusing
scenarios.</li><li>Allow early exit in <code>final</code> blocks, but drop the value if we are already early exiting. Only the
original error will be returned.</li></ol><p>In the latter scenario, you would continue to execute any other <code>final</code> blocks further down even if
this one early exited; just the remainder of this <code>final</code> block would not be executed.</p><h2 id="yielding-from-final-blocks">Yielding from <code>final</code> blocks</h2><p>If early return from <code>final</code> blocks is permitted, note that <code>yield</code> could also be permitted.
Consider:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>gen</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>do</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>for</span><span> </span><span>elem</span><span> </span><span>in</span><span> </span><span>iter</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>if</span><span> </span><span>elem</span><span>.</span><span>has_foo</span><span>()</span><span>?</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>                </span><span>yield</span><span> </span><span>&#34;elem has foo&#34;</span><span>;</span><span>
</span></span></span><span><span><span>            </span><span>}</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span> </span><span>final</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>yield</span><span> </span><span>&#34;final yield&#34;</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>If <code>has_foo</code> never fails, this will yield <code>&#34;elem has foo&#34;</code> as many times as an <code>elem</code> in <code>iter</code> “has
foo” and then one <code>&#34;final yield&#34;</code>. If it fails, it will return <code>&#34;elem has foo&#34;</code> every time before
that, then enter the <code>final</code> block and yield the <code>&#34;final yield&#34;</code> value.</p><h2 id="unwinding-through-final-blocks">Unwinding through <code>final</code> blocks</h2><p>Some special attention is needed for figuring out what happens when unwinding through <code>final</code> blocks
that include control flow other than the ordinary control flow.</p><p>For <code>await</code>, this is already covered by the discussion of async unwinding: if you are wrapped by an
async <code>catch_unwind</code>, it will proceed as normal, otherwise it will either abort or stop unwinding.</p><p>If <code>yield</code> and early <code>return</code> operators are permitted in <code>final</code> blocks, these would need to escape
this <code>final</code> block but drop the item. We would proceed with unwinding, skipping the remaining code
inside of this particular <code>final</code> block. If it was a <code>yield</code>, we would not yield that value, instead
we would exit the loop and continue unwinding.</p><p>With async cancellation and <code>do</code> … <code>final</code> blocks, asynchronous clean-up is possible, but it can
not be guaranteed that any particular asynchronous clean-up code will be run when a type goes out of
scope. It’s already the case today that you can’t guarantee clean-up code runs when a type goes out
of scope, asynchronous or not. There are two possible solutions to this problem, though they often
are conflated under the single term “linear types,” so I’m going to refer to them with two distinct
names.</p><p>The first solution would be to allow types to express as part of their contract that their
destructor (remember, their normal, non-asynchronous, non-value-returning destructor) runs whenever
they go out of scope. I call these <em>unforgettable types</em>. It would require adding a <code>Leak</code> auto
trait and bounding any API which can cause a leak (like <code>mem::forget</code>) with that auto trait.</p><p>The second solution would be to allow types that cannot be dropped at all. This is actually what
“linear types” means outside of the context of Rust, but I am going to call these <em>undroppable
types</em> to avoid any confusion. Niko Matsakis has <a href="https://smallcultfollowing.com/babysteps/blog/2023/03/16/must-move-types/">written</a> about adding this
functionality under the term “must move types,” because such types must be moved, they cannot be
dropped. I’m going look briefly at each of these as a solution to the problem, without considering
the challenges of adding them to Rust or how they would impact other use cases.</p><h2 id="unforgettable-types">Unforgettable types</h2><p>This weaker limitation would not allow defining types with functionality like async destructors, but
it would allow solving the <a href="https://without.boats/md/blog/the-scoped-task-trilemma">scoped task trilemma</a>: the scoped task API would return a
future which is <code>!Leak</code>, guaranteeing that its destructor will run.</p><p>In practice, the API would ensure that it is asynchronously cleaned up almost all of the time, to a
similar degree that even without unforgettable types, right now destructors almost always run. The
async <code>scope</code> function would look something like this:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>fn</span> <span>async</span><span> </span><span>scope</span><span>&lt;</span><span>&#39;env</span><span>,</span><span> </span><span>F</span><span>,</span><span> </span><span>T</span><span>&gt;</span><span>(</span><span>f</span>: <span>F</span><span>)</span><span> </span>-&gt; <span>T</span><span>
</span></span></span><span><span><span></span><span>where</span><span>
</span></span></span><span><span><span>    </span><span>F</span>: <span>for</span><span>&lt;</span><span>&#39;scope</span><span>&gt;</span><span> </span><span>async</span><span> </span><span>FnOnce</span><span>(</span><span>&amp;</span><span>&#39;scope</span><span> </span><span>Scope</span><span>&lt;</span><span>&#39;scope</span><span>,</span><span> </span><span>&#39;env</span><span>&gt;</span><span>)</span><span> </span>-&gt; <span>T</span><span>
</span></span></span><span><span><span></span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>scope</span><span> </span><span>=</span><span> </span><span>..</span><span>.;</span><span>
</span></span></span><span><span><span>    </span><span>do</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>f</span><span>(</span><span>&amp;</span><span>scope</span><span>).</span><span>await</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span> </span><span>final</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>scope</span><span>.</span><span>await_all_tasks</span><span>().</span><span>await</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>Because the <code>Scope</code> type would be <code>!Leak</code>, the future returned by this function would also be
<code>!Leak</code>. If <code>poll_cancel</code> on that future is not called, the synchronous destructor will run: that
will act as an “emergency backstop,” blocking this thread and ensuring memory safety. But as long as
this is executed with a correctly implemented runtime, instead the asynchronous clean up code will
run, ensuring that all the child tasks are awaited without blocking the thread.</p><h2 id="undroppable-types">Undroppable types</h2><p>Undroppable types allow expressing a wider variety of contracts in the types, but require more code
to use correctly. This would involve adding the ability to define a type that does not implement
<code>Drop</code>, and so cannot be dropped (this would be different from today where types that don’t
implement <code>Drop</code> can still be dropped; remember we’re avoiding discussing the migration story in
this post).</p><p>Whereas adding <code>Leak</code> impacts only a handful of APIs, <code>!Drop</code> would impact a large many more: any
time you drop any generic value in any code path of that function, that type would need to be bound
by <code>Drop</code>.</p><p>Because undroppable types cannot be dropped, the only way to get rid of them is to destructure them.
If they have private fields, they can only be destructured by calling a public method which
destructures them internally; this lets the author of an undroppable type provide one or more clean
up methods which <em>must</em> be called: users cannot forget to call it, because it will result in an
error.</p><p>For example, an undroppable <code>File</code> type could expose a <code>close</code> method, which is the only way to get
rid of that <code>File</code>. Users would get an error if they did not remember to close the <code>File</code> explicitly
in their code.</p><p>Niko Matsakis proposes this as a way to implement async destructors: there would be some sort of
<code>AsyncDrop</code> trait; types which are meant to have an async destructor would implement this trait but
not <code>Drop</code>. Then there would be an <code>async_drop</code> function which you are meant to call explicitly on
these types to run the clean up code. This is the only proposal for “async destructors” that I
believe avoids all of the problems I listed earlier: instead of implicit async destructors, you use
undroppable types that require you to explicitly call their async clean-up code.</p><p>In the scoped task API shown before, the <code>await_all_tasks</code> method would be the <em>only</em> way to destroy
the <code>Scope</code> type, which would not implement <code>Drop</code>. This ensures that this method is ultimately
called, solving the scoped task trilemma.</p><h2 id="async-cancellation-and-do--final-are-prerequisite">Async cancellation and <code>do</code> … <code>final</code> are prerequisite</h2><p>There was one issue with Niko Matsakis’s proposal about how undroppable types could be used for
asynchronous clean up. Consider his description:</p><blockquote><p>The simplest way to achieve “async drop” then would to define a trait <code>trait AsyncDrop { async fn async_drop(self); }</code> and then make the type “must move”. This will force callers to eventually
invoke <code>async_drop(x).await</code>. We might want some syntactic sugar to handle <code>?</code> more easily, but
that could come later.</p></blockquote><p>What Matsakis fails to mention in this comment is the problem of the future returned by <code>async_drop</code>
itself: what if you drop <em>that future</em>? Now the async destructor isn’t run to completion, violating
the contract. The implication is that the future returned by <code>async_drop</code> must itself not implement
<code>Drop</code>.</p><p>But how would you cancel a future which is not <code>Drop</code>? You would need an async cancellation path
which evaluates the destructor. If a runtime wants to support tasks that have async destructors, it
would have to guarantee that it either polls all tasks to completion, or if they are canceled it
runs their async cancellation path to completion.</p><p>In other words, <code>poll_cancel</code> is a prerequisite of making undroppable types work. And when Matsakis
alludes to “syntactic sugar to handle <code>?</code> more easily,” that is what <code>do</code> … <code>final</code> is meant to
do: it allows you to hold an undroppable type across any code block that has an early return or a
panic in it.</p><p>These are also prerequisites for unforgettable types, because you need a combination of async
cancellation and a <code>do</code> … <code>final</code> block to make the scoped task API asynchronously await all of
the scoped tasks by default, without resorting to the blocking emergency backstop.</p><p>What this means is that the other features in this post would also be prerequisites for either
undroppable or unforgettable types. Because either definition of “linear” types would be a massive
change to Rust, and one that seems unlikely to happen before 2027, the immediately actionable thing
to do would be to add async cancellation and <code>do</code> … <code>final</code>, which will allow users to perform
some sort of async clean up in the near term even without linear types.</p></section></div>
  </body>
</html>
