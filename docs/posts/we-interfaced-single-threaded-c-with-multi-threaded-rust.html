<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://antithesis.com/blog/2026/rust_cpp/">Original</a>
    <h1>We interfaced single-threaded C&#43;&#43; with multi-threaded Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
    <section>
        
            <nav>
                <a id="back-to-blog-button" href="https://antithesis.com/blog">← Blog</a>
            </nav>
        
        <header>
            <div>
                
                <div>
                    <p><img alt="Michael Gibson pic" src="https://antithesis.com/images/people/043_michael.jpg"/></p><div>
                        
                        <p>Senior Engineer, Antithesis</p>
                    </div>
                </div>
                
            </div>
            
            
            
        </header>
        <p data-sid="4334.4"><em>This blog post is adapted from a talk Shuxian Wang and I gave at the <a href="https://luma.com/lt31g7a2">Rust UnConf</a>, organized by <a href="https://rust.nyc/">Rust NYC</a>. The UnConf was a truly awesome group of Rust enthusiasts who met for a couple hours of deep technical conversations (and also gelato).</em></p>
<p data-sid="4334.5">When you give us your software to test, we run it in containers on our <a href="https://antithesis.com/blog/deterministic_hypervisor/">deterministic hypervisor</a>. The deterministic hypervisor (or Determinator) took us years to develop and replaces all non-deterministic operations (getting the time, anything involving random numbers, any inputs, etc.) with deterministic versions controlled by a stream of control signals. For a given set of control signals, the determinator will do exactly the same thing every single time.</p>
<p data-sid="4334.6">The Antithesis <em>fuzzer</em> is the program that controls all of this. It figures out which control signals to send to the Determinator to manipulate the system under test and find bugs.</p>
<p data-sid="4334.7">The fuzzer creates a state tree of control signal bytes, and some of those bytes find bugs, and some don’t:</p>
<p><picture><source type="image/webp" srcset="/img_opt/6b1ckXDMqr-2217.webp 2217w"/><img src="https://antithesis.com/img_opt/6b1ckXDMqr-2217.png" alt="State tree of bytes for the fuzzer, showing which find bugs and which don&#39;t." loading="lazy" decoding="async" width="2217" height="1205"/></picture></p>
<p data-sid="4334.8">The logical part of the fuzzer, which I’ll call the <em>controller</em>, is responsible for figuring out <em>where to start</em> and <em>what inputs to give</em>. For example, in the image below, we’re starting at the green state (labeled f3) and providing input bytes 6f, 64, 70:</p>
<p><picture><source type="image/webp" srcset="/img_opt/Iof9d28zOM-1832.webp 1832w"/><img src="https://antithesis.com/img_opt/Iof9d28zOM-1832.png" alt="State tree of bytes, with input bytes provided by the controller." loading="lazy" decoding="async" width="1832" height="1148"/></picture></p>
<div><p data-sid="4334.9">The fuzzer is written in single-threaded C++.<sup>1</sup> We have different controllers that try to find bugs in different ways, and they all interact with the core fuzzer via a callback interface like this:<sup>2</sup></p></div>
<div><div><pre data-lang="Rust" data-sid="4334.11"><code><span><span>poll_for_inputs</span><span>(&amp;</span><span>controller</span><span>)</span><span> -&gt;</span><span> (</span><span>start</span><span> state</span><span>,</span><span> inputs</span><span>)</span></span>
<span></span>
<span><span>advertise_outputs</span><span>(&amp;</span><span>controller</span><span>,</span><span> states</span><span>)</span></span></code></pre></div></div>
<div><p data-sid="4334.13">The main loop of the fuzzer (1) calls into a controller’s <code><span><span>poll_for_inputs</span></span></code> method and asks “where should I start and what should I do?” and (2) calls into the controller’s <code><span><span>advertise_outputs</span></span></code> method and says “I did what you said, and here are the outputs<sup>3</sup> that the system returned when run on the Determinator.”</p></div>
<p data-sid="4334.15">A couple years ago we added the ability for the fuzzer to call into Rust, so that we could implement new control strategies more easily. We’ve been using that functionality to <em>research</em> new control strategies, but none of the Rust code is used in production. And the Rust side is multi-threaded and asynchronous. The Rust side’s controller uses an asynchronous interface of roughly “start here, give these inputs, and then <code><span><span>await</span></span></code> the outputs that come back,” rather than the callback-oriented C++ interface.</p>
<p data-sid="4334.16">This post talks about how we interface multi-threaded asynchronous Rust with single-threaded synchronous C++. The story is 90% Rust and 10% C++, and it definitely goes into the weeds on the Rust side. But have no fear, we’ll come with you, and maybe even tell a joke or two as we go.</p>
<h2 id="the-basics" tabindex="-1" data-sid="4334.17"><a href="#the-basics"><span>The basics</span></a></h2>
<p data-sid="4334.18">Let’s start with some background information. How do you combine C++ and Rust, without the added complexity of the asynchronous mismatch? And how do you combine <em>any</em> kind of synchronous and asynchronous code in Rust, without the added complexity of C++?</p>
<p data-sid="4334.19">And what kind of problems come up when you combine the two?</p>
<h3 id="combining-c%2B%2B-and-rust" tabindex="-1" data-sid="4334.20"><a href="#combining-c%2B%2B-and-rust"><span>Combining C++ and Rust</span></a></h3>
<div><div><p data-sid="4334.21">To interoperate Rust and C++, we use the Rust crate <a href="https://docs.rs/cxx/latest/cxx/"><em>cxx</em></a>, which creates a Foreign Function Interface (FFI) between C++ and Rust.<sup>4</sup> It lets you define three kinds of things:</p>
<ol>
<li data-sid="4334.22"><code><span><span>extern Rust</span></span></code> types: Rust types that are exposed to C++. The cxx tooling creates a C++ header file that you include, and it generates code that converts C++ calling conventions to Rust calling conventions, so that you can call from C++ into Rust.</li>
<li data-sid="4334.23"><code><span><span>extern C++</span></span></code> types: C++ types that are exposed to Rust. You specify the Rust signature for function calls, and cxx matches that up with existing C++ functions (according to some rules). Cxx converts the calling conventions appropriately so that your Rust code can call into C++ by simply calling a Rust function of the given signature.</li>
<li data-sid="4334.24">shared structures: types that don’t have any methods/functions on them (i.e., just pure structs). You declare them in Rust and cxx creates a C++ header file, so you can create them, use them, or both on the C++ side. You can pass these structs back and forth freely. The big difference between this and the previous two types is that these shared structures are only typed memory layouts; they don’t have executable function code on either side associated with them, so there’s no converting calling conventions.</li>
</ol>
</div></div>
<h3 id="combining-sync-and-async" tabindex="-1" data-sid="4334.26"><a href="#combining-sync-and-async"><span>Combining sync and async</span></a></h3>
<div><p data-sid="4334.27">The core idea is that we’re going to write some asynchronous, multi-threaded Rust – the “asynchronous part” of the diagram below  – and it will send information across async channels.<sup>5</sup> The other end of those channels is in synchronous Rust, which is called synchronously from C++. The synchronous Rust will send and receive data from the async channels<sup>6</sup> and convert back-and-forth between C++ format and Rust format. The more complicated controller logic will be pure Rust, isolated from having to worry about C++, either for object conversion or for sync/async mismatches.</p></div>
<div><p><picture><source type="image/webp" srcset="/img_opt/u7-7tlnBFT-1046.webp 1046w"/><img src="https://antithesis.com/img_opt/u7-7tlnBFT-1046.png" alt="Diagram showing data flow between synchronous C++ and asynchronous, multi-threaded Rust." loading="lazy" decoding="async" width="1046" height="776"/></picture></p></div>
<h2 id="challenge-1%3A-thread-unsafe-objects" tabindex="-1" data-sid="4334.30"><a href="#challenge-1%3A-thread-unsafe-objects"><span>Challenge 1: thread-unsafe <em>objects</em></span></a></h2>
<p data-sid="4334.31">With the preliminaries out of the way, let’s dive a little deeper into the code pictured above.</p>
<p data-sid="4334.32">There’s a technical challenge with this code: <code><span><span>start</span></span></code> and <code><span><span>result_states</span></span></code> are C++ objects (of type <code><span><span>State</span></span></code>), and we need to pass them back and forth across threads. When we call execute, we pass <code><span><span>start</span></span></code> from right to left, with <code><span><span>run</span></span></code> sending it and <code><span><span>poll_for_inputs</span></span></code> receiving it. And then in <code><span><span>advertise_outputs</span></span></code>, we pass <code><span><span>result_states</span></span></code> from left to right with <code><span><span>run</span></span></code> receiving it. By default, <em>cxx</em> doesn’t implement <code><span><span>Send</span></span></code> or <code><span><span>Sync</span></span></code> for C++ types. (We also send <code><span><span>inputs</span></span></code>, but that’s a Rust-native object.)</p>
<h3 id="interlude-%E2%80%93-send-and-sync" tabindex="-1" data-sid="4334.33"><a href="#interlude-%E2%80%93-send-and-sync"><span>Interlude – Send and Sync</span></a></h3>
<p data-sid="4334.34">No talk of thread safety in Rust would be complete without a discussion of <a href="https://doc.rust-lang.org/nomicon/send-and-sync.html">Send and Sync</a>. <code><span><span>Send</span></span></code> and <code><span><span>Sync</span></span></code> are two marker traits (i.e., traits that have no methods) that tell you – and more importantly tell the compiler – what thread-related operations are and aren’t safe to do with a type.</p>
<p data-sid="4334.35">Paraphrasing the standard library documentation slightly:</p>
<ul>
<li data-sid="4334.36">A type <code><span><span>T</span></span></code> is <code><span><span>Send</span></span></code> if it is safe to have <em>exclusive access</em> (<code><span><span>T</span></span></code> or <code><span><span>&amp;mut T</span></span></code>) across different threads</li>
<li data-sid="4334.37">A type <code><span><span>T</span></span></code> is <code><span><span>Sync</span></span></code> if it is safe to have <em>shared access</em> (<code><span><span>&amp;T</span></span></code>) across different threads</li>
</ul>
<p data-sid="4334.38">There’s a well-known consequence that <code><span><span>T</span></span></code> is <code><span><span>Sync</span></span></code> if and only if <code><span><span>&amp;T</span></span></code> is <code><span><span>Send</span></span></code>.</p>
<p data-sid="4334.39">Usually the compiler implements <code><span><span>Send</span></span></code> and <code><span><span>Sync</span></span></code> for you automatically, based on reasoning about the Rust code. Of course, the Rust compiler can’t reason about C++ code, so it doesn’t implement them for you automatically, but you can implement them manually if it makes sense to do so.</p>
<h3 id="back-to-the-problem" tabindex="-1" data-sid="4334.40"><a href="#back-to-the-problem"><span>Back to the problem</span></a></h3>
<p data-sid="4334.41">I suppose this would be a good time to mention that I’ve been programming in C++ since the 90s, and in Rust for about 2 years and a little bit. And that the events we’re talking about happened 2 years ago, when I was brand new to Rust. At least that’s my excuse.</p>
<p data-sid="4334.42">The Rust compiler complained that it couldn’t pass <code><span><span>State</span></span></code> across thread boundaries because it didn’t implement <code><span><span>Send</span></span></code>, so I wrote this code:</p>
<pre data-lang="Rust" data-sid="4334.43"><code><span><span>unsafe</span><span> impl</span><span> Send</span><span> for</span><span> State</span><span> {}</span></span></code></pre><p data-sid="4334.44">Pop quiz: do you think this ended well?</p>
<p data-sid="4334.45">Of course it didn’t. This causes an intermittent segfault. Which as we all know, shouldn’t be possible in Rust code. Unless you do something <em>unsafe</em> that you really shouldn’t have.</p>
<p data-sid="4334.46">Why, specifically, did this fail?</p>
<p data-sid="4334.47">On the C++ side, there’s some code like this:</p>
<pre data-lang="C++" data-sid="4334.48"><code><span><span>struct</span><span> State</span><span> {</span></span>
<span><span>    ref_ptr</span><span>&lt;</span><span>StateImpl</span><span>&gt;</span><span> impl</span><span>;</span></span>
<span><span>    ...</span></span>
<span><span>}</span></span></code></pre><div><div><p data-sid="4334.49">Here <code><span><span>ref_ptr</span></span></code> is a class that implements a reference counted pointer. Similar to <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code><span><span>Rc</span></span></code></a> or <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code><span><span>Arc</span></span></code></a> in Rust or <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr.html"><code><span><span>shared_ptr</span></span></code></a> in C++. In particular, <code><span><span>ref_ptr</span></span></code> isn’t thread safe. So when we’re using <code><span><span>State</span></span></code> objects on the Rust side, sometimes we hit a race condition<sup>7</sup> where we get the wrong value of the reference count and then delete an object that is still being used; when we go to access that object, we get the segfault.</p>
<p data-sid="4334.50">So clearly <code><span><span>State</span></span></code> isn’t <code><span><span>Send</span></span></code>. We can only do things that affect the refcount (clone or drop) on the main C++ thread. Phrased as in the interlude: it’s not safe to own a <code><span><span>State</span></span></code> in another thread, because cloning it and dropping it (operations you can do if you own <code><span><span>T</span></span></code>) change the refcount, which isn’t safe to do in other threads. For the same reason, it’s not safe to have a <code><span><span>&amp;State</span></span></code> in another thread, because you could clone the shared reference on the other thread.</p>
</div></div>
<h3 id="the-solution" tabindex="-1" data-sid="4334.52"><a href="#the-solution"><span>The solution</span></a></h3>
<p data-sid="4334.53">Other than cloning and dropping - things that affect the refcount - we should be okay to <em>use</em> <code><span><span>State</span></span></code> on different threads, as long as we keep the underlying object around long enough. So we came up with this solution.</p>
<p data-sid="4334.54">The solution involves two Rust structs. <code><span><span>CppOwner</span></span></code> only lives on the main thread and owns the original C++ object. <code><span><span>CppBorrower</span></span></code> acts like a reference to the C++ object. <code><span><span>CppBorrower</span></span></code> is fine to pass around between threads; <code><span><span>CppOwner</span></span></code> needs to live on the main thread. When you want to drop things, you have to drop all <code><span><span>CppBorrower</span></span></code>s first, then drop the <code><span><span>CppOwner</span></span></code> (on the main thread):</p>
<p data-sid="4334.55">On the main thread only:</p>
<pre data-lang="Rust" data-sid="4334.56"><code><span><span>pub</span><span> struct</span><span> CppOwner</span><span>&lt;</span><span>T</span><span>&gt;</span><span> {</span></span>
<span><span>    value</span><span>:</span><span> Arc</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span></span>
<span><span>}</span></span>
<span></span>
<span><span>impl&lt;</span><span>T</span><span>&gt;</span><span> CppOwner</span><span>&lt;</span><span>T</span><span>&gt;</span><span> {</span></span>
<span><span>    pub</span><span> fn</span><span> borrow</span><span>(&amp;</span><span>self</span><span>)</span><span> -&gt;</span><span> CppBorrower</span><span>&lt;</span><span>T</span><span>&gt;</span><span> {</span></span>
<span><span>        CppBorrower</span><span> {</span><span> value</span><span>:</span><span> self</span><span>.</span><span>value</span><span>.</span><span>clone</span><span>()</span><span> }</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    pub</span><span> fn</span><span> has_borrowers</span><span>(&amp;</span><span>self</span><span>)</span><span> -&gt;</span><span> bool</span><span> {</span></span>
<span><span>        Arc</span><span>::</span><span>strong_count</span><span>(&amp;</span><span>self</span><span>.</span><span>value</span><span>)</span><span> &gt;</span><span> 1</span></span>
<span><span>    }</span><span> </span></span>
<span><span>}</span></span>
<span></span>
<span><span>impl&lt;</span><span>T</span><span>&gt;</span><span> Drop</span><span> for</span><span> CppOwner</span><span>&lt;</span><span>T</span><span>&gt;</span><span> {</span></span>
<span><span>    fn</span><span> drop</span><span>(&amp;</span><span>mut</span><span> self</span><span>)</span><span> {</span></span>
<span><span>        if</span><span> self</span><span>.</span><span>has_borrowers</span><span>()</span><span> {</span></span>
<span><span>            panic!</span><span>(</span><span>&#34;</span><span>No!</span><span>&#34;</span><span>);</span><span>         </span></span>
<span><span>        }</span></span>
<span><span>    }</span></span>
<span><span>}</span></span></code></pre><p data-sid="4334.57">On all threads:</p>
<pre data-lang="Rust" data-sid="4334.58"><code><span><span>pub</span><span> struct</span><span> CppBorrower</span><span>&lt;</span><span>T</span><span>&gt;</span><span> {</span></span>
<span><span>    value</span><span>:</span><span> Arc</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span></span>
<span><span>}</span></span>
<span></span>
<span><span>impl&lt;</span><span>T</span><span>&gt;</span><span> Clone</span><span> for</span><span> CppBorrower</span><span>&lt;</span><span>T</span><span>&gt;</span><span> {</span></span>
<span><span>    fn</span><span> clone</span><span>(&amp;</span><span>self</span><span>)</span><span> -&gt;</span><span> Self</span><span> {</span></span>
<span><span>        Self</span><span> {</span><span> value</span><span>:</span><span> self</span><span>.</span><span>value</span><span>.</span><span>clone</span><span>()</span><span> }</span></span>
<span><span>    }</span></span>
<span><span>}</span></span>
<span></span>
<span><span>unsafe</span><span> impl&lt;</span><span>T</span><span>:</span><span> Sync</span><span>&gt;</span><span> Send</span><span> for</span><span> CppBorrower</span><span>&lt;</span><span>T</span><span>&gt;</span><span> {}</span></span>
<span></span>
<span><span>impl</span><span> Deref</span><span> ...</span></span></code></pre><p data-sid="4334.59">To <em>use</em> this, we create a <code><span><span>CppOwner</span></span></code> on the main thread and keep it around in an “in flight” set, then pass a <code><span><span>CppBorrower</span></span></code> around where we need it:</p>
<pre data-lang="Rust" data-sid="4334.60"><code><span><span>// On the main thread</span></span>
<span><span>let</span><span> cpp_state</span><span> =</span><span> CppOwner</span><span>::</span><span>new</span><span>(</span><span>state</span><span>.</span><span>cpp_clone</span><span>());</span></span>
<span><span>// Send borrow to other threads via the async channel</span></span>
<span><span>channel</span><span>.</span><span>send</span><span>(</span><span>cpp_state</span><span>.</span><span>borrow</span><span>());</span></span>
<span><span>// Keep track of the CppOwner</span></span>
<span><span>self</span><span>.</span><span>in_flight</span><span>.</span><span>insert</span><span>(</span><span>cpp_state</span><span>);</span></span></code></pre><p data-sid="4334.61">Later, but also on the main thread, we check for “in flight” C++ objects that no longer have any borrowers, and drop them:</p>
<pre data-lang="Rust" data-sid="4334.62"><code><span><span>// Later, but still on the main thread</span></span>
<span><span>self</span><span>.</span><span>in_flight</span><span>.</span><span>retain</span><span>(</span><span>|</span><span>s</span><span>|</span><span> s</span><span>.</span><span>has_borrowers</span><span>());</span></span></code></pre><p data-sid="4334.63">You can look at the mechanics in the code above; we’re using <code><span><span>Arc</span></span></code> to give us the refcount we need and make it possible to pass things around.</p>
<p data-sid="4334.64">Summarizing this: we make <code><span><span>CppOwner</span></span></code>s on the main thread and keep track of them in the “in flight” set. We make <code><span><span>CppBorrower</span></span></code>s on demand and pass them around freely. We garbage collect a <code><span><span>CppOwner</span></span></code> on the main thread when it has no more <code><span><span>CppBorrower</span></span></code>s. And because the only operations that affect the (C++) refcount happen in <code><span><span>CppOwner</span></span></code>, on the main thread, we avoid the race condition we had before.</p>
<h3 id="the-design-challenge" tabindex="-1" data-sid="4334.65"><a href="#the-design-challenge"><span>The design challenge</span></a></h3>
<p data-sid="4334.66">This approach worked. We used it for about two years.</p>
<p data-sid="4334.67">And then something happened that made us question our design choices: someone else tried to use the Rust interface to the fuzzer. <strong>For production code!</strong></p>
<p data-sid="4334.68">This caused us to think harder about the methodology. The garbage collection isn’t very efficient – from time to time we loop through all the <code><span><span>CppOwner</span></span></code>s that exist and say “should I delete you?” If we do that very frequently, we’ll do a lot of wasted work. If we do it very infrequently, we’ll use a lot more memory than we should. Fundamentally, the amount of work we <em>should</em> be doing should be proportional to <em>number of deletions</em>, but our current implementation is proportional to <em>number of objects</em>. Or maybe to <em>number of objects X number of iterations</em>. For the research work flows we had, this worked out okay, because we didn’t have a lot of objects around at the same time, but for the production case, it was problematic. (Said another way, the amount of work depends on the number of objects we keep around, rather than the smaller number we delete.)</p>
<h3 id="a-better-solution" tabindex="-1" data-sid="4334.69"><a href="#a-better-solution"><span>A better solution</span></a></h3>
<p data-sid="4334.70">Previously, <code><span><span>CppOwner</span></span></code> had an <code><span><span>Arc&lt;T&gt;</span></span></code> (where <code><span><span>T</span></span></code> is a C++ type):</p>
<pre data-lang="Rust" data-sid="4334.71"><code><span><span>struct</span><span> CppOwner</span><span>&lt;</span><span>T</span><span>&gt;</span><span> {</span></span>
<span><span>    value</span><span>:</span><span> Arc</span><span>&lt;</span><span>T</span><span>&gt;</span></span>
<span><span>}</span></span></code></pre><p data-sid="4334.72"><code><span><span>CppOwner</span></span></code> had to remain on the main thread and we could only pass <code><span><span>CppBorrower</span></span></code>s around.</p>
<p data-sid="4334.73">Our new solution is to make <code><span><span>CppOwner</span></span></code> own <code><span><span>T</span></span></code> directly (not <code><span><span>Arc&lt;T&gt;</span></span></code>):</p>
<pre data-lang="Rust" data-sid="4334.74"><code><span><span>struct</span><span> CppOwner</span><span>&lt;</span><span>T</span><span>&gt;</span><span> {</span></span>
<span><span>    value</span><span>:</span><span> T</span></span>
<span><span>}</span></span></code></pre><p data-sid="4334.75">We then pass <code><span><span>Arc&lt;CppOwner&lt;T&gt;&gt;</span></span></code> around. To do that safely, when the last refcount goes away and  we drop <code><span><span>CppOwner&lt;T&gt;</span></span></code>, we send <code><span><span>T</span></span></code> back to the main thread for deletion.</p>
<p data-sid="4334.76">This sounds like a great plan, but it immediately hits a snag. We can only do that if <code><span><span>CppOwner&lt;T&gt;</span></span></code> is <code><span><span>Send</span></span></code>, which only happens automatically if <code><span><span>T</span></span></code> is <code><span><span>Send</span></span></code>. And we don’t want every C++ type to <code><span><span>unsafe impl Send</span></span></code> (we saw how dangerous that was before with the segfault). So how can <code><span><span>CppOwner&lt;T&gt;</span></span></code> be <code><span><span>Send</span></span></code> when <code><span><span>T</span></span></code> is not <code><span><span>Send</span></span></code>?</p>
<h4 id="sendwrapper" tabindex="-1" data-sid="4334.77"><a href="#sendwrapper"><span>SendWrapper</span></a></h4>
<p data-sid="4334.78">There’s a <a href="https://en.wikipedia.org/wiki/Fundamental_theorem_of_software_engineering">saying</a> in computer science that you can solve everything with one more layer of indirection. Let’s try that.</p>
<p data-sid="4334.79">Here’s a struct <code><span><span>SendWrapper&lt;T&gt;</span></span></code> that can smuggle <code><span><span>T</span></span></code> across thread boundaries:</p>
<pre data-lang="Rust" data-sid="4334.80"><code><span><span>pub</span><span> struct</span><span> SendWrapper</span><span>&lt;</span><span>T</span><span>&gt;(</span><span>T</span><span>);</span></span>
<span></span>
<span><span>// Even when T: !Send  </span></span>
<span><span>unsafe</span><span> impl&lt;</span><span>T</span><span>&gt;</span><span> Send</span><span> for</span><span> SendWrapper</span><span>&lt;</span><span>T</span><span>&gt;</span><span> {}</span></span></code></pre><p data-sid="4334.81">The key here is the comment: <code><span><span>SendWrapper&lt;T&gt;</span></span></code> is <code><span><span>Send</span></span></code> even if <code><span><span>T</span></span></code> itself isn’t.</p>
<p data-sid="4334.82"><em>But</em>, since <code><span><span>T</span></span></code> may or may not be <code><span><span>Send</span></span></code>, it’s not safe to get exclusive access to <code><span><span>T</span></span></code>, so we have to be careful that <code><span><span>SendWrapper&lt;T&gt;</span></span></code> prevents that. It’s fairly easy not to expose any way to get <code><span><span>&amp;mut T</span></span></code> (for example, <code><span><span>SendWrapper</span></span></code> doesn’t implement <a href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html"><code><span><span>DerefMut</span></span></code></a>), but we also have to make sure you don’t drop a <code><span><span>SendWrapper</span></span></code>. So we wrote code like this:</p>
<pre data-lang="Rust" data-sid="4334.83"><code><span><span>impl&lt;</span><span>T</span><span>&gt;</span><span> Drop</span><span> for</span><span> SendWrapper</span><span>&lt;</span><span>T</span><span>&gt;</span><span> {</span><span>  </span></span>
<span><span>    fn</span><span> drop</span><span>(&amp;</span><span>mut</span><span> self</span><span>)</span><span> {</span><span>  </span></span>
<span><span>        panic!</span><span>(</span><span>&#34;</span><span>Cannot drop a SendWrapper!</span><span>&#34;</span><span>)</span><span>  </span></span>
<span><span>    }</span><span>  </span></span>
<span><span>}</span></span></code></pre><h4 id="a-better-cppowner" tabindex="-1" data-sid="4334.84"><a href="#a-better-cppowner"><span>A better CppOwner</span></a></h4>
<p data-sid="4334.85">Now we want to put the right logic in <code><span><span>CppOwner</span></span></code> to send <code><span><span>T</span></span></code> back to the main thread when we drop:</p>
<pre data-lang="Rust" data-sid="4334.86"><code><span><span>pub</span><span> struct</span><span> CppOwner</span><span>&lt;</span><span>T</span><span>&gt;(</span><span>ManuallyDrop</span><span>&lt;</span><span>SendWrapper</span><span>&lt;</span><span>T</span><span>&gt;&gt;);</span></span></code></pre><p data-sid="4334.87"><code><span><span>CppOwner</span></span></code> now contains a <code><span><span>SendWrapper</span></span></code> (wrapped in <a href="https://doc.rust-lang.org/std/mem/struct.ManuallyDrop.html">ManuallyDrop</a>, “A wrapper to inhibit the compiler from automatically calling T’s destructor.”).</p>
<p data-sid="4334.88">Our Drop implementation for <code><span><span>CppOwner</span></span></code> pulls the <code><span><span>SendWrapper</span></span></code> and pushes it into a special “drop queue” that sends it back to the main thread:</p>
<pre data-lang="Rust" data-sid="4334.89"><code><span><span>impl&lt;</span><span>T</span><span>&gt;</span><span> Drop</span><span> for</span><span> CppOwner</span><span>&lt;</span><span>T</span><span>&gt;</span><span> {</span><span>  </span></span>
<span><span>    fn</span><span> drop</span><span>(&amp;</span><span>mut</span><span> self</span><span>)</span><span> {</span><span>  </span></span>
<span><span>        let</span><span> val</span><span>:</span><span> SendWrapper</span><span>&lt;</span><span>T</span><span>&gt;</span><span> =</span><span> unsafe</span><span> {</span><span> ManuallyDrop</span><span>::</span><span>take</span><span>(&amp;</span><span>mut</span><span> self</span><span>.</span><span>0</span><span>)</span><span> };</span><span>  </span></span>
<span><span>        DROP_QUEUE</span><span>.</span><span>push</span><span>(</span><span>val</span><span>);</span><span>  </span></span>
<span><span>    }</span><span>  </span></span>
<span><span>}</span></span></code></pre><p data-sid="4334.90">Wait, what’s this <code><span><span>DROP_QUEUE</span></span></code>? It’s a static instance of a new <code><span><span>DropQueue</span></span></code> type. The type is defined as:</p>
<pre data-lang="Rust" data-sid="4334.91"><code><span><span>pub</span><span> struct</span><span> DropQueue</span><span>&lt;</span><span>T</span><span>&gt;(</span><span>ConcurrentQueue</span><span>&lt;</span><span>SendWrapper</span><span>&lt;</span><span>T</span><span>&gt;&gt;);</span></span></code></pre><p data-sid="4334.92">And <code><span><span>DropQueue</span></span></code> has a <code><span><span>drain</span></span></code> method that you call on the main thread to extract and drop <code><span><span>T</span></span></code>. (It’s only safe to call <code><span><span>drain</span></span></code> on the main thread, because it’s only safe to drop <code><span><span>T</span></span></code> on the main thread.)</p>
<pre data-lang="Rust" data-sid="4334.93"><code><span><span>impl&lt;</span><span>T</span><span>&gt;</span><span> DropQueue</span><span>&lt;</span><span>T</span><span>&gt;</span><span> {</span><span>  </span></span>
<span><span>    // SAFETY: Only call on main thread  </span></span>
<span><span>    pub</span><span> unsafe</span><span> fn</span><span> drain</span><span>(&amp;</span><span>self</span><span>)</span><span> {</span><span>  </span></span>
<span><span>        for</span><span> val</span><span> in</span><span> self</span><span>.</span><span>0</span><span>.</span><span>try_iter</span><span>()</span><span> {</span><span>  </span></span>
<span><span>            drop</span><span>(unsafe</span><span> {</span><span> val</span><span>.</span><span>unwrap_unchecked</span><span>()</span><span> })</span><span>  </span></span>
<span><span>        }</span><span>  </span></span>
<span><span>    }</span><span>  </span></span>
<span><span>}</span></span></code></pre><div><div><p data-sid="4334.94">This uses another function on <code><span><span>SendWrapper</span></span></code> that we didn’t talk about – an unsafe method to get the <code><span><span>T</span></span></code> out of <code><span><span>SendWrapper</span></span></code>.<sup>8</sup></p>
<pre data-lang="Rust" data-sid="4334.95"><code><span><span>impl&lt;</span><span>T</span><span>&gt;</span><span> SendWrapper</span><span>&lt;</span><span>T</span><span>&gt;</span><span> {</span><span>  </span></span>
<span><span>    pub</span><span> unsafe</span><span> fn</span><span> unwrap_unchecked</span><span>(</span><span>self</span><span>)</span><span> -&gt;</span><span> T</span><span>  </span></span>
<span><span>}</span></span></code></pre><p data-sid="4334.96">We’ve now solved the garbage collection problem. <code><span><span>CppOwner</span></span></code>’s drop method sends the object back to the main thread for destruction, and we only do work proportional to the number of things we need to drop, not to the number of iterations. Moreover, we’ve mostly gotten rid of <code><span><span>CppBorrower</span></span></code>, replacing it with <code><span><span>Arc&lt;CppOwner&gt;</span></span></code>.</p>
</div></div>
<h2 id="challenge-2%3A-thread-unsafe-functions" tabindex="-1" data-sid="4334.98"><a href="#challenge-2%3A-thread-unsafe-functions"><span>Challenge 2: thread-unsafe <em>functions</em></span></a></h2>
<p data-sid="4334.99">Let’s back up time to when we had the original solution of garbage collection, with <code><span><span>CppOwner</span></span></code> and <code><span><span>CppBorrower</span></span></code>, but before the <code><span><span>SendWrapper</span></span></code> improvement. At that time, we found another problem.</p>
<p data-sid="4334.100">Here’s some code we had written:</p>
<pre data-lang="Rust" data-sid="4334.101"><code><span><span>async</span><span> fn</span><span> run</span><span>()</span><span> {</span></span>
<span><span>  loop</span><span> {</span></span>
<span><span>    let</span><span> (</span><span>start</span><span>,</span><span> inputs</span><span>)</span><span> =</span><span> create_rollout_somehow</span><span>();</span></span>
<span><span>    let</span><span> result_states</span><span> =</span><span> execute</span><span>(</span><span>start</span><span>,</span><span> inputs</span><span>).</span><span>await</span><span>;</span></span>
<span><span>    let</span><span> details</span><span> =</span><span> result_states</span><span>.</span><span>get_details</span><span>();</span></span>
<span><span>    do_something_with</span><span>(</span><span>details</span><span>);</span></span>
<span><span>  }</span></span>
<span><span>}</span></span></code></pre><div><p data-sid="4334.102">In this code, <code><span><span>start</span></span></code> is a C++ object of type <code><span><span>State</span></span></code>, which we had converted to a <code><span><span>CppOwner&lt;State&gt;</span></span></code> and <code><span><span>CppBorrower&lt;State&gt;</span></span></code>, so garbage collection/refcounting worked correctly. But <code><span><span>get_details</span></span></code>,<sup>9</sup> a function on the C++ side, isn’t safe to call across threads; it can only be called safely on the main thread. (More generally, functions on the C++ side <em>may or may not</em> be safe to call across threads; this particular one isn’t.)</p></div>
<h3 id="first-solution" tabindex="-1" data-sid="4334.104"><a href="#first-solution"><span>First solution</span></a></h3>
<p data-sid="4334.105">There’s a solution to this too:</p>
<p><picture><source type="image/webp" srcset="/img_opt/a1IUx8iJD8-1111.webp 1111w"/><img src="https://antithesis.com/img_opt/a1IUx8iJD8-1111.png" alt="Diagram showing channels between sync and async code." loading="lazy" decoding="async" width="1111" height="385"/></picture></p>
<p data-sid="4334.106">Whenever we have a function (like <code><span><span>get_details</span></span></code>) that can only be called on the main thread, rather than call that function, we go through a layer of indirection.</p>
<p data-sid="4334.107">In the asynchronous part, we:</p>
<ol>
<li data-sid="4334.108">create a request object with the parameters to the function</li>
<li data-sid="4334.109">pass the request object across the thread boundary via a “request” channel</li>
</ol>
<p data-sid="4334.110">In the synchronous Rust part, we:</p>
<ol>
<li data-sid="4334.111">poll the channel for the request object</li>
<li data-sid="4334.112">call the C++ function with the given parameters</li>
<li data-sid="4334.113">push the results into a second,  async “results” channel</li>
</ol>
<p data-sid="4334.114">On the async side, we then await the results of this “results” channel.</p>
<p data-sid="4334.115">This general pattern worked; we just had to be careful about what we called on the main thread and what we called on arbitrary threads.</p>
<h3 id="the-design-challenge-1" tabindex="-1" data-sid="4334.116"><a href="#the-design-challenge-1"><span>The design challenge</span></a></h3>
<p data-sid="4334.117">As we started preparing this for production, one concern was the very subtle thread-safety story. Rust has the model that a <em>struct</em> is either thread-safe or it isn’t (and there are two kinds of thread-safety: <code><span><span>Send</span></span></code> and <code><span><span>Sync</span></span></code>). But what we found is that <em>some methods</em> on a struct may be thread safe but others aren’t. This mismatch between the languages is fairly fundamental; it’s not that either one is right or wrong, they’re just different. And we need to make them work together.</p>
<p data-sid="4334.118">Also, the initial solution feels right to me as a C++ programmer, but not to me as a Rust programmer. It boils down to “be very careful and think really hard about what you’re doing” – that’s totally the vibe of writing this kind of code in C++. But in Rust, that isn’t the vibe. The Rust way is “enlist the compiler’s help to find problems for you, rather than you have to find them manually.” My initial solution wasn’t very Rust-y at all.</p>
<p data-sid="4334.119">Summarizing this problem, we want to:</p>
<ul>
<li data-sid="4334.120">deal with “functions you can only call on the main thread”</li>
<li data-sid="4334.121">figure out how to model the partial thread safety of some of our C++ types</li>
<li data-sid="4334.122">be safe and ergonomic, so other people on the team can use it without introducing subtle bugs</li>
<li data-sid="4334.123">define well-documented safety obligations for the C++ code (what kinds of things are you and aren’t you allowed to do in C++ code that’ll interact with Rust code?)</li>
</ul>
<h3 id="a-better-solution-1" tabindex="-1" data-sid="4334.124"><a href="#a-better-solution-1"><span>A better solution</span></a></h3>
<p data-sid="4334.125">The better, more Rust-y solution involves two pieces: (1) The <code><span><span>MainThreadToken</span></span></code>, which we can use to ensure that a certain function can only be called on the main thread, and (2) a set of conventions and rules for which functions are and aren’t safe to call on other threads.</p>
<h4 id="the-mainthreadtoken" tabindex="-1" data-sid="4334.126"><a href="#the-mainthreadtoken"><span>The MainThreadToken</span></a></h4>
<p data-sid="4334.127">We want to mark functions as only callable on the main thread, so we invented a <code><span><span>MainThreadToken</span></span></code> struct. It is a proof-carrier: having a <code><span><span>MainThreadToken</span></span></code> means you’re on the main thread. The code is deceptively simple:</p>
<pre data-lang="Rust" data-sid="4334.128"><code><span><span>#[</span><span>derive</span><span>(</span><span>Clone</span><span>,</span><span> Copy</span><span>)]</span><span>  </span></span>
<span><span>pub</span><span> struct</span><span> MainThreadToken</span><span>(</span><span>PhantomData</span><span>&lt;*</span><span>mut</span><span> ()&gt;);</span></span></code></pre><p data-sid="4334.129">If you haven’t ever used <a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html">PhantomData</a>, it’s a Rust construct that doesn’t actually store any data; it just tells the compiler “pretend this thing has this type.” So this whole token takes 0 bytes of RAM, but acts like it has a type of <code><span><span>*mut()</span></span></code>. The <code><span><span>*mut</span></span></code> ensures that the struct isn’t <code><span><span>Send</span></span></code> or <code><span><span>Sync</span></span></code>.</p>
<p data-sid="4334.130">I’ve pulled a bit of a fast one on you. This code ensures that you can’t pass a <code><span><span>MainThreadToken</span></span></code> between threads, but there’s no guarantee that you made it <em>on the main thread</em>, you could have made it on any other thread and it’d be stuck on that thread, not the main C++ thread. So there’s a little more code:</p>
<pre data-lang="Rust" data-sid="4334.131"><code><span><span>pub</span><span> static</span><span> MAIN_THREAD_ID</span><span> .</span><span> .</span><span> .</span></span>
<span></span>
<span><span>// Somewhere guaranteed to be in the main thread  </span></span>
<span><span>initialize</span><span>(</span><span>MAIN_THREAD_ID</span><span>);</span></span>
<span></span>
<span><span>/// # Safety  </span></span>
<span><span>/// This function must be called from the main fuzzer thread.  </span></span>
<span><span>pub</span><span> unsafe</span><span> fn</span><span> new</span><span>()</span><span> -&gt;</span><span> Self</span><span> {</span><span>  </span></span>
<span><span>    assert_eq!</span><span>(*</span><span>MAIN_THREAD_ID</span><span>,</span><span> std</span><span>::</span><span>thread</span><span>::</span><span>current</span><span>().</span><span>id</span><span>());</span><span>  </span></span>
<span><span>    Self</span><span>(</span><span>PhantomData</span><span>)</span><span>  </span></span>
<span><span>}</span></span></code></pre><div><div><p data-sid="4334.132">There are two overlapping controls here. (1) The <code><span><span>unsafe</span></span></code> keyword and the safety comment should be enough to ensure you use this correctly. But then we also have (2) a runtime check, so if you don’t use it correctly, you’ll get a panic rather than undefined behavior.<sup>10</sup></p>
<p data-sid="4334.133">In general, you shouldn’t be calling this <code><span><span>new()</span></span></code> much. You can call it once and then Copy or Clone the resulting token (on the same thread).</p>
</div></div>
<p data-sid="4334.135">How does this help us? If we have a function that’s only safe to call on the main thread, for example, the <code><span><span>drain</span></span></code> method we talked about before:</p>
<pre data-lang="Rust" data-sid="4334.136"><code><span><span>// SAFETY: Only call on main thread</span></span>
<span><span>pub</span><span> unsafe</span><span> fn</span><span> drain</span><span>(&amp;</span><span>self</span><span>)</span></span></code></pre><p data-sid="4334.137">We can make it safe with the <code><span><span>MainThreadToken</span></span></code>:</p>
<pre data-lang="Rust" data-sid="4334.138"><code><span><span>pub</span><span> fn</span><span> drain</span><span>(&amp;</span><span>self</span><span>,</span><span> _token</span><span>:</span><span> MainThreadToken</span><span>)</span></span></code></pre><p data-sid="4334.139">We don’t actually <em>use</em> the <code><span><span>MainThreadToken</span></span></code> anywhere in the implementation; just the fact that you have it and are able to call the function with it means that we’re on the main thread. So the compiler can statically check that you’re only calling a method (like <code><span><span>drain</span></span></code>) where you should be.</p>
<h4 id="modeling-thread-safety-for-our-c%2B%2B-types" tabindex="-1" data-sid="4334.140"><a href="#modeling-thread-safety-for-our-c%2B%2B-types"><span>Modeling thread safety for our C++ types</span></a></h4>
<p data-sid="4334.141">The <em>cxx</em> crate distinguishes between two types of C++ methods: const methods (which become <code><span><span>&amp;self</span></span></code> on the Rust side) and non-const methods (which become <code><span><span>Pin&lt;&amp;mut Self&gt;</span></span></code> on the Rust side).</p>
<!-- The table has an HTML version of the following code snippets, to get syntax highlighting on inline code: -->
<!-- | `int get_data() const;` | `fn get_data(&amp;self) -&gt; i32;` |
| `void push(int x);` | `fn push(self: Pin<&amp;mut Self>, x: i32) -&gt; ();` | -->
<table>
<thead>
<tr>
<th data-sid="4334.142">C++</th>
<th data-sid="4334.143">Rust</th>
</tr>
</thead>
<tbody>
<tr>
<td data-sid="4334.144"><code><span><span>int</span><span> get_data</span><span>()</span><span> const</span><span>;</span></span></code></td>
<td data-sid="4334.145"><code><span><span>fn</span><span> get_data</span><span>(&amp;</span><span>self</span><span>)</span><span> -&gt;</span><span> i32</span><span>;</span></span></code></td>
</tr>
<tr>
<td data-sid="4334.146"><code><span><span>void</span><span> push</span><span>(</span><span>int</span><span> x</span><span>)</span><span>;</span></span></code></td>
<td data-sid="4334.147"><code><span><span>fn</span><span> push</span><span>(</span><span>self</span><span>:</span><span> Pin</span><span>&lt;&amp;</span><span>mut</span><span> Self</span><span>&gt;,</span><span> x</span><span>:</span><span> i32</span><span>)</span><span> -&gt;</span><span> ();</span></span></code></td>
</tr>
</tbody>
</table>
<p data-sid="4334.148">We’re going to leave the non-const ones as they are – the <code><span><span>&amp;mut Self</span></span></code> ensures that you never call these concurrently, and <code><span><span>SendWrapper</span></span></code> specifically avoids giving you <code><span><span>&amp;mut</span></span></code> access – so the non-const functions are only callable on the main thread from C++.</p>
<div><p data-sid="4334.149">The const methods are a bit of a trick though. In C++, const means that the binary bits of the representation don’t change in the function. But it’s totally possible that a class has a pointer to another class, and even though the pointer isn’t changing, something in the other class is changing concurrently.<sup>11</sup></p></div>
<p data-sid="4334.151">For example, if some other code has a copy of the <code><span><span>other</span></span></code> pointer, it could change <code><span><span>x</span></span></code> and affect the value returned by <code><span><span>do_const</span></span></code>.</p>
<pre data-lang="C++" data-sid="4334.152"><code><span><span>struct</span><span> Other</span><span> {</span></span>
<span><span>    int</span><span> x</span><span>;</span></span>
<span><span>}</span><span>;</span></span>
<span></span>
<span><span>struct</span><span> MyObj</span><span> {</span></span>
<span><span>    Other</span><span>*</span><span> other</span><span>;</span></span>
<span><span>    int</span><span> do_const</span><span>() </span><span>const</span><span> {</span></span>
<span><span>        return</span><span> other</span><span>-&gt;</span><span>x</span><span>;</span></span>
<span><span>    }</span></span>
<span><span>}</span><span>;</span></span></code></pre><p data-sid="4334.153">Going a step further, <code><span><span>do_const</span></span></code> can’t change the <em>pointer</em> <code><span><span>other</span></span></code>, but it <em>can</em> change <code><span><span>x</span></span></code>. So <code><span><span>other-&gt;x++</span></span></code> is completely valid in <code><span><span>do_const</span></span></code>.</p>
<h4 id="sync-and-unsync-methods" tabindex="-1" data-sid="4334.154"><a href="#sync-and-unsync-methods"><span>Sync and Unsync methods</span></a></h4>
<p data-sid="4334.155">Evidently const is not enough to tell us whether a C++ method is or is not safe to call on other threads, so we’ll make our own distinction. We’ll call things that are safe to call on other threads “sync” and things that aren’t “unsync.” (Exact definitions below.)</p>
<p data-sid="4334.156">On the C++ side, we define two dumb “marker macros” for <code><span><span>SYNC</span></span></code> and <code><span><span>UNSYNC</span></span></code>:</p>
<pre data-lang="C++" data-sid="4334.157"><code><span><span>#</span><span>define</span><span> SYNC</span></span>
<span><span>#</span><span>define</span><span> UNSYNC</span></span></code></pre><p data-sid="4334.158">These don’t actually do anything. But we can use them to label our functions. For example:</p>
<pre data-lang="C++" data-sid="4334.159"><code><span><span>int</span><span> get_immutable_data</span><span>()</span><span> SYNC </span><span>const</span><span>;</span></span>
<span><span>int</span><span> get_mutable_data</span><span>()</span><span> UNSYNC </span><span>const</span><span>;</span></span></code></pre><p data-sid="4334.160">For example, you could imagine <code><span><span>get_immutable_data</span></span></code> returns the value of an ID that’s set in the constructor, and <code><span><span>get_mutable_data</span></span></code> dereferences a pointer and returns some value from that, where the internals of the underlying object may change (like in the <code><span><span>MyObj</span></span></code> example above).</p>
<p data-sid="4334.161">These macros aren’t for the compiler; they’re for us. When we’re defining a class, it’s really easy to see during code review (1) did someone use <code><span><span>SYNC</span></span></code> and <code><span><span>UNSYNC</span></span></code>? and (2) did they do it correctly? If they didn’t use the macros at all, we send the code review back with “please figure this out and add it.” There’s also a really long comment where the macros are defined saying exactly what the obligations are (imagine this blog post in the form of a comment).</p>
<div><div><p data-sid="4334.162">While we’re at it, let’s change the name of the unsync function to emphasize that it’s unsync. That doesn’t help us right now, but it will help us when we get to Rust.<sup>12</sup></p>
<p data-sid="4334.163">So now we have:</p>
<pre data-lang="C++" data-sid="4334.164"><code><span><span>int</span><span> get_immutable_data</span><span>()</span><span> SYNC </span><span>const</span><span>;</span></span>
<span><span>int</span><span> get_mutable_data_unsync</span><span>()</span><span> UNSYNC </span><span>const</span><span>;</span></span></code></pre></div></div>
<h4 id="what-are-sync-and-unsync-methods%3F" tabindex="-1" data-sid="4334.166"><a href="#what-are-sync-and-unsync-methods%3F"><span>What are Sync and Unsync methods?</span></a></h4>
<p data-sid="4334.167">So what exactly does this made-up SYNC/UNSYNC distinction mean?</p>
<ol>
<li data-sid="4334.168">Non-const methods can have <em>exclusive access</em>. For example: non-atomic writes, constructor/destructor</li>
<li data-sid="4334.169">const, sync methods can have synchronized <em>shared access</em>. These functions are thread-safe without external synchronization. For example: reading immutable data, atomic operations, operations where the C++ class implements synchronization</li>
<li data-sid="4334.170">const, unsync methods can have unsynchronized <em>shared access</em>. These functions are only safe to call with external synchronization. For example: non-atomic read on mutable data</li>
</ol>
<p data-sid="4334.171">It <em>must</em> be the case that “const, sync” are safe to call concurrently with other “const, sync” methods and with “const, unsync” methods. But “const, unsync” methods are only safe to call with “const, sync” methods, not with other “const, unsync” methods. And neither is safe to call concurrently with non-const methods, which we’ll summarize in this table:</p>
<table>
<thead>
<tr>
<th data-sid="4334.172">Concurrency safe?</th>
<th data-sid="4334.173">non-const</th>
<th data-sid="4334.174">const, sync</th>
<th data-sid="4334.175">const, unsync</th>
</tr>
</thead>
<tbody>
<tr>
<td data-sid="4334.176">non-const</td>
<td data-sid="4334.177">N</td>
<td data-sid="4334.178">N</td>
<td data-sid="4334.179">N</td>
</tr>
<tr>
<td data-sid="4334.180">const, sync</td>
<td data-sid="4334.181">N</td>
<td data-sid="4334.182">Y</td>
<td data-sid="4334.183">Y</td>
</tr>
<tr>
<td data-sid="4334.184">const, unsync</td>
<td data-sid="4334.185">N</td>
<td data-sid="4334.186">Y</td>
<td data-sid="4334.187">N</td>
</tr>
</tbody>
</table>
<h4 id="sync-and-unsync-methods-on-the-rust-side" tabindex="-1" data-sid="4334.188"><a href="#sync-and-unsync-methods-on-the-rust-side"><span>Sync and Unsync methods on the Rust side</span></a></h4>
<p data-sid="4334.189">For SYNC methods like this:</p>
<pre data-lang="C++" data-sid="4334.190"><code><span><span>int</span><span> get_immutable_data</span><span>()</span><span> SYNC </span><span>const</span><span>;</span></span></code></pre><p data-sid="4334.191">on the Rust side, we just use the default signatures, like:</p>
<pre data-lang="Rust" data-sid="4334.192"><code><span><span>fn</span><span> get_immutable_data</span><span>(&amp;</span><span>self</span><span>)</span><span> -&gt;</span><span> i32</span><span>;</span></span></code></pre><p data-sid="4334.193">For <code><span><span>UNSYNC</span></span></code> methods like this:</p>
<pre data-lang="C++" data-sid="4334.194"><code><span><span>int</span><span> get_mutable_data_unsync</span><span>()</span><span> UNSYNC </span><span>const</span><span>;</span></span></code></pre><p data-sid="4334.195">on the Rust side, we make the method unsafe and add a Safety comment:</p>
<pre data-lang="Rust" data-sid="4334.196"><code><span><span>/// # Safety: main thread only</span></span>
<span><span>unsafe</span><span> fn</span><span> get_mutable_data_unsync</span><span>(&amp;</span><span>self</span><span>)</span><span> -&gt;</span><span> i32</span><span>;</span></span></code></pre><p data-sid="4334.197">At this point, we can mark the Rust type (which cxx derived from the C++ type) as <code><span><span>Sync</span></span></code>. Not <code><span><span>Send</span></span></code>, just <code><span><span>Sync</span></span></code> (meaning it’s safe to have a shared reference to it).</p>
<div><div><p data-sid="4334.198">Finally, we use <code><span><span>MainThreadToken</span></span></code> to make a <em>safe</em> version of the <code><span><span>_unsync</span></span></code> function:<sup>13</sup></p>
<pre data-lang="Rust" data-sid="4334.199"><code><span><span>fn</span><span> get_mutable_data</span><span>(&amp;</span><span>self</span><span>,</span><span> _token</span><span>:</span><span> MainThreadToken</span><span>)</span><span> -&gt;</span><span> i32</span><span> {</span><span>  </span></span>
<span><span>    // SAFETY: We&#39;re on the main fuzzer thread as we own a `MainThreadToken`.  </span></span>
<span><span>    unsafe</span><span> {</span><span> self</span><span>.</span><span>get_mutable_data_unsync</span><span>()</span><span> }</span><span>  </span></span>
<span><span>}</span></span></code></pre></div></div>
<p data-sid="4334.201">Anyone using this class should call the <em>safe</em> version of the function. (This is also why we added the <code><span><span>_unsync</span></span></code> to the end of the function name, so that the <em>safe</em> version could have the non-weird name.)</p>
<h4 id="calling-c%2B%2B-methods-in-other-threads" tabindex="-1" data-sid="4334.202"><a href="#calling-c%2B%2B-methods-in-other-threads"><span>Calling C++ methods in other threads</span></a></h4>
<p data-sid="4334.203">Let’s look back at <code><span><span>SendWrapper&lt;T&gt;</span></span></code> for a second. We didn’t say this before, but here are some implementations:</p>
<pre data-lang="Rust" data-sid="4334.204"><code><span><span>unsafe</span><span> impl&lt;</span><span>T</span><span>&gt;</span><span> Send</span><span> for</span><span> SendWrapper</span><span>&lt;</span><span>T</span><span>&gt;</span><span> {}</span></span>
<span></span>
<span><span>// &amp;SendWrapper&lt;T&gt; -&gt; &amp;T, only if T is Sync  </span></span>
<span><span>impl&lt;</span><span>T</span><span>:</span><span> Sync</span><span>&gt;</span><span> Deref</span><span> for</span><span> SendWrapper</span><span>&lt;</span><span>T</span><span>&gt;</span><span> .</span><span> .</span><span> .</span></span></code></pre><p data-sid="4334.205">So <code><span><span>SendWrapper</span></span></code> <em>always</em> implements <code><span><span>Send</span></span></code>, regardless of whether or not <code><span><span>T</span></span></code> does, but it only implements <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code><span><span>Deref</span></span></code></a> if <code><span><span>T</span></span></code> implements <code><span><span>Sync</span></span></code>. So you: (1) can’t get a <code><span><span>T</span></span></code> or a <code><span><span>&amp;mut T</span></span></code>, (2) can only get a <code><span><span>&amp;T</span></span></code> if <code><span><span>T</span></span></code> is <code><span><span>Sync</span></span></code> (i.e., if <code><span><span>&amp;T</span></span></code> is safe to use across thread boundaries).</p>
<p data-sid="4334.206">Wow, that’s kind of a mouthful. What does it mean? It means we can define a couple different kinds of Rust structs derived from C++ structs:</p>
<ol>
<li data-sid="4334.207">Structs that can be smuggled around in <code><span><span>SendWrapper&lt;T&gt;</span></span></code>, but that you can’t call any methods on in other threads</li>
<li data-sid="4334.208">Structs whose methods you can call in other threads</li>
</ol>
<p data-sid="4334.209">If you stare at that for a while, you might wonder why type (1) would ever be useful. The key is the last couple words: “you can’t call any methods on <em>in other threads</em>.” Using the request object model, we can pass <code><span><span>SendWrapper&lt;T&gt;</span></span></code> back and forth across threads, and then call the methods in the main thread.</p>
<p data-sid="4334.210">For case (2), our implementation of <code><span><span>Deref</span></span></code> means that we need to implement <code><span><span>Sync</span></span></code> on the original C++ type <code><span><span>T</span></span></code> to be able to call functions on a class on different threads:</p>
<pre data-lang="Rust" data-sid="4334.211"><code><span><span>// Long #Safety comment</span></span>
<span><span>unsafe</span><span> impl</span><span> Sync</span><span> for</span><span> SomeCppType</span><span> {}</span></span></code></pre><div><div><p data-sid="4334.212">As before, we have a long Safety comment explaining this whole scheme and your obligations in the part of the cxx file<sup>14</sup> where the <code><span><span>impl Sync</span></span></code> lines go.</p>
<p data-sid="4334.213">Summarizing the method, if we want to call <em>any</em> functions on a type on different threads, we do the following:</p>
</div></div>
<p data-sid="4334.215">On the C++ side, we:</p>
<div><div><ol>
<li data-sid="4334.216">use <code><span><span>SYNC</span></span></code> or <code><span><span>UNSYNC</span></span></code> markers on each const method depending on whether or not it’s safe to call the method on multiple threads.<sup>15</sup></li>
<li data-sid="4334.217">name unsync functions using a suffix <code><span><span>_unsync</span></span></code>.</li>
<li data-sid="4334.218">use code review to confirm all the correct obligations are upheld.</li>
</ol>
</div></div>
<p data-sid="4334.220">On the Rust side, we:</p>
<ol>
<li data-sid="4334.221">use the same name as the C++ side</li>
<li data-sid="4334.222">make any <code><span><span>_unsync</span></span></code> methods <code><span><span>unsafe</span></span></code> with an appropriate Safety comment. (The Safety comment is by convention, but clippy helps us to enforce it.)</li>
</ol>
<div><div><ol start="3">
<li data-sid="4334.223">make a <em>safe</em> version of the <code><span><span>_unsync</span></span></code> function, without the <code><span><span>_unsync</span></span></code> suffix, by using the <code><span><span>MainThreadToken</span></span></code>.<sup>16</sup></li>
<li data-sid="4334.224">mark the type as <code><span><span>Sync</span></span></code>. (The unsafe <code><span><span>_unsync</span></span></code> methods “opt-out” of that, and the <em>safe</em> versions of those <code><span><span>_unsync</span></span></code> methods require the <code><span><span>MainThreadToken</span></span></code>, which enforces the right thread.)</li>
</ol>
</div></div>
<p data-sid="4334.226">This solution is much more “Rust-y,” but also makes the C++ programmer in me happy. On the C++ side, we’ve defined some things exactly and know what to check in code review. That ensures that the functions we <em>expose</em> are properly constructed. (The C++ programmer in me is okay with having “and be careful and <em>a developer</em> will verify something during code review” as long as I have a clear definition of what that something is.) On the Rust side, once we’ve applied the rules above, <em>the compiler</em> can check that where the functions are <em>used</em>, they’re used correctly. And the combination of the two ensures that the whole thing works together.</p>
<h2 id="summarizing-the-methodology" tabindex="-1" data-sid="4334.227"><a href="#summarizing-the-methodology"><span>Summarizing the methodology</span></a></h2>
<p data-sid="4334.228">I’ve covered a lot of material here. We’re using <em>cxx</em> to call from C++ into Rust, and the C++ code is single-threaded, but the Rust code is multi-threaded. This causes two main problems.</p>
<p data-sid="4334.229">The first problem is non-thread-safe <em>objects</em>, which we originally solved using <code><span><span>CppOwner</span></span></code> and <code><span><span>CppBorrower</span></span></code> structs. Then we improved the solution with a new version of <code><span><span>CppOwner</span></span></code> that included a <code><span><span>SendWrapper</span></span></code> struct to smuggle a C++ type across thread boundaries, and <code><span><span>CppOwner</span></span></code> handled dropping by sending the <code><span><span>SendWrapper</span></span></code> back to the main thread, where it can safely be deleted.</p>
<p data-sid="4334.230">The second problem is non-thread-safe <em>functions</em>. We solved that by creating some conventions for naming and tagging functions on the C++ side, and then marking some functions on the Rust side as <code><span><span>unsafe</span></span></code>. We also created a proof-carrier type called <code><span><span>MainThreadToken</span></span></code>, which you can only have on the main thread. Using that, we made safe versions of the unsafe functions.</p>
<p data-sid="4334.231">By the time we got to the second/later solution of both problems, we had converted to a very Rust-y solution, where the compiler has the information it needs to ensure you are calling things correctly. So the Rust part of the fuzzer is ready to use in production, even by other developers.</p>
<hr/>
<p data-sid="4334.232">If you’ve made it this far and are thinking “what I don’t like about this post is that it’s too short and doesn’t go into the weeds enough,” I have good news for you. There’s a Part 2 on the way, where my co-conspirator Shuxian explains how we formally proved that these primitives have the behavior we’ve claimed.</p>

    </section>
   
   
   
   
</div></div>
  </body>
</html>
