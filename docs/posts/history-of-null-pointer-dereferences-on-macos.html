<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://afine.com/history-of-null-pointer-dereferences-on-macos/">Original</a>
    <h1>History of Null Pointer Dereferences on macOS</h1>
    
    <div id="readability-page-1" class="page"><div>
                                                
<p>Finding a crash while fuzzing is just the beginning of Vulnerability Research. After finding a crash, Exploit Development is often a long journey. Not every bug is exploitable, and my previous article (<a href="https://afine.com/case-study-analyzing-macos-ionvmefamily-driver-denial-of-service-issue/">Case Study: Analyzing macOS IONVMeFamily Driver Denial of Service Issue</a>) is great proof of that. Sometimes, I am sure that something can be exploited, but then I face a wall of mitigations implemented by the OS.</p>



<p>During my recent fuzzing session, I discovered a bug that, after some readings, trial and error, and reverse engineering, was determined to be unexploitable due to various mitigations implemented in macOS over the years. One of these mitigations specifically addresses NULL pointer dereferences.</p>



<p>I have come across numerous valuable resources on this subject, but locating them took considerable time. Therefore, I decided to write an overview article summarizing the key points and include links to these references for others seeking answers to a specific question:</p>



<blockquote>
<p>Why NULL Pointer Dereferences on macOS since arm64 is no longer exploitable? ENJOY!</p>
</blockquote>



<h2 class="wp-block-heading" id="introduction-null-pointer-dereferences-on-apple-silicon">Introduction: NULL Pointer Dereferences on Apple Silicon</h2>



<p>A <strong>NULL pointer dereference</strong> occurs when software attempts to access memory at address 0 (the NULL address) via a pointer set to NULL. On ARM64 (like Apple Silicon)<span>, ad</span>dress 0 is typically not mapped in virtual memory as on other architectures. Thus, dereferencing a NULL pointer usually triggers a memory access fault. In kernel context, this fault causes an immediate <strong>panic</strong> rather than reading or writing valid data. The consequence is a Denial of Service (crash) since the kernel stops the execution to protect itself.</p>



<figure><img decoding="async" width="1024" height="226" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABAAAAADiAQMAAADqECdaAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAADJJREFUGBntwQEBAAAAgqD+r3ZIwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADuBXHiAAFAGTuIAAAAAElFTkSuQmCC" alt="" data-src="https://afine.com/wp-content/uploads/2025/02/image-28-1024x226.png" data-srcset="https://afine.com/wp-content/uploads/2025/02/image-28-1024x226.png 1024w, https://afine.com/wp-content/uploads/2025/02/image-28-300x66.png 300w, https://afine.com/wp-content/uploads/2025/02/image-28-768x170.png 768w, https://afine.com/wp-content/uploads/2025/02/image-28-1536x339.png 1536w, https://afine.com/wp-content/uploads/2025/02/image-28-2048x452.png 2048w, https://afine.com/wp-content/uploads/2025/02/image-28-970x214.png 970w" data-sizes="auto" data-eio-rwidth="1024" data-eio-rheight="226" data-src-webp="https://afine.com/wp-content/uploads/2025/02/image-28-1024x226.png.webp" data-srcset-webp="https://afine.com/wp-content/uploads/2025/02/image-28-1024x226.png.webp 1024w, https://afine.com/wp-content/uploads/2025/02/image-28-300x66.png.webp 300w, https://afine.com/wp-content/uploads/2025/02/image-28-768x170.png.webp 768w, https://afine.com/wp-content/uploads/2025/02/image-28-1536x339.png.webp 1536w, https://afine.com/wp-content/uploads/2025/02/image-28-2048x452.png.webp 2048w, https://afine.com/wp-content/uploads/2025/02/image-28-970x214.png.webp 970w"/></figure>



<p>A NULL pointer dereference is a programming error that does not execute attacker-controlled code — it simply faults. Below is a simple userland example you can compile and run to see for yourself:</p>


<pre aria-describedby="shcb-language-1" data-shcb-language-name="PHP" data-shcb-language-slug="php"><span><code>


int main() {
    int *ptr = <span>NULL</span>;  
    int value = *ptr; 

    printf(<span>&#34;Value: %d\n&#34;</span>, value); 

    <span>return</span> <span>0</span>;
}</code></span><small id="shcb-language-1"><span>Code language:</span> <span>PHP</span> <span>(</span><span>php</span><span>)</span></small></pre>


<figure><img decoding="async" width="1024" height="328" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABAAAAAFIAQMAAAD04B5mAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAD9JREFUGBntwQEBAAAAgqD+r3ZIwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAewGlSAABYRRwzgAAAABJRU5ErkJggg==" alt="" data-src="https://afine.com/wp-content/uploads/2025/02/image-29-1024x328.png" data-srcset="https://afine.com/wp-content/uploads/2025/02/image-29-1024x328.png 1024w, https://afine.com/wp-content/uploads/2025/02/image-29-300x96.png 300w, https://afine.com/wp-content/uploads/2025/02/image-29-768x246.png 768w, https://afine.com/wp-content/uploads/2025/02/image-29-1536x491.png 1536w, https://afine.com/wp-content/uploads/2025/02/image-29-2048x655.png 2048w, https://afine.com/wp-content/uploads/2025/02/image-29-970x310.png 970w" data-sizes="auto" data-eio-rwidth="1024" data-eio-rheight="328" data-src-webp="https://afine.com/wp-content/uploads/2025/02/image-29-1024x328.png.webp" data-srcset-webp="https://afine.com/wp-content/uploads/2025/02/image-29-1024x328.png.webp 1024w, https://afine.com/wp-content/uploads/2025/02/image-29-300x96.png.webp 300w, https://afine.com/wp-content/uploads/2025/02/image-29-768x246.png.webp 768w, https://afine.com/wp-content/uploads/2025/02/image-29-1536x491.png.webp 1536w, https://afine.com/wp-content/uploads/2025/02/image-29-2048x655.png.webp 2048w, https://afine.com/wp-content/uploads/2025/02/image-29-970x310.png.webp 970w"/></figure>



<blockquote>
<p>Historically, attackers have found ways to <strong>exploit kernel NULL dereferences</strong> under certain conditions. </p>
</blockquote>



<h3 class="wp-block-heading" id="how-could-we-exploit-it">How could we exploit it?</h3>



<p>The classic exploit scenario involves tricking the kernel into <em>not</em> faulting on address zero by <strong>mapping a controlled memory page at that address</strong>. If successful, instead of crashing, the kernel might read or execute attacker-supplied data at address 0, potentially leading to code execution in kernel mode.</p>



<p>On ARM64-based systems, Apple has set up memory protections such that the <strong>zero address remains unmapped</strong> during normal operation. Any attempt to use a NULL pointer results in a data abort (memory access exception). Thus, a NULL dereference in the kernel will generally <strong>halt the system</strong> for safety. </p>



<blockquote>
<p>Only if an attacker can somehow place controlled data at address zero and have the kernel use it could it become an exploitable condition. As we will see, modern macOS make this extremely difficult.</p>
</blockquote>



<h2 class="wp-block-heading" id="historical-exploitation-of-null-dereferences-in-macos">Historical Exploitation of NULL Dereferences in macOS</h2>



<p>In earlier macOS versions (on Intel architectures), the general method was to <strong>map a fake object at the NULL address in user space</strong> so that when the kernel mistakenly dereferenced a NULL pointer, it would access the attacker’s fake data instead of faulting. This required bypassing the OS’s normal prevention of low-address memory mapping. </p>



<blockquote>
<p>There were a few cases where this was possible.</p>
</blockquote>



<h3 class="wp-block-heading" id="__pagezero">__PAGEZERO</h3>



<p>On macOS, <strong>64-bit processes by default cannot map memory at address 0</strong> – the system reserves a large unmapped region to catch null pointer bugs. In every Mach-o, we can find <code>__PAGEZERO</code> segment:</p>





<blockquote>
<p>In fact, for 64-bit Mach-O binaries, the first 4GB of address space is reserved and inaccessible​. </p>
</blockquote>



<h3 class="wp-block-heading" id="null-page-mapping-technique-with-32-bit-binaries">NULL Page Mapping Technique with 32-bit binaries</h3>



<p>However, in older macOS versions, back when 32-bit apps were supported, we could compile a <strong>32-bit</strong> binary (<code>-m 32</code>) with the linker flag to disable the page-zero reservation (<code>-pagezero_size 0x0</code>).</p>


<pre aria-describedby="shcb-language-2" data-shcb-language-name="JSON / JSON with Comments" data-shcb-language-slug="json"><span><code></code></span><small id="shcb-language-2"><span>Code language:</span> <span>JSON / JSON with Comments</span> <span>(</span><span>json</span><span>)</span></small></pre>


<p>This legacy quirk allowed a 32-bit process to allocate memory successfully at address 0. Attackers used this to place shellcode or fake objects at NULL and then trigger the kernel vulnerability.</p>


<pre aria-describedby="shcb-language-3" data-shcb-language-name="JavaScript" data-shcb-language-slug="javascript"><span><code>
err = vm_deallocate(mach_task_self(), <span>0x0</span>, <span>0x1000</span>); 


vm_address_t addr = <span>0</span>;
err = vm_allocate(mach_task_self(), &amp;addr, <span>0x1000</span>, <span>0</span>);


char* np = <span>0</span>;
<span>for</span> (int i = <span>0</span>; i &lt; <span>0x1000</span>; i++){
  np[i] = <span>&#39;\x41&#39;</span>;
}</code></span><small id="shcb-language-3"><span>Code language:</span> <span>JavaScript</span> <span>(</span><span>javascript</span><span>)</span></small></pre>


<p>For instance, <a href="https://twitter.com/piotrbania" target="_blank" rel="noreferrer noopener">Piotr Bania</a> from <a href="https://talosintelligence.com/vulnerability_info" target="_blank" rel="noreferrer noopener">Cisco Talos</a> demonstrateWd this in 2016 by exploiting an <a href="https://talosintelligence.com/vulnerability_reports/TALOS-2016-0088/" target="_blank" rel="noreferrer noopener">Intel graphics driver bug</a>. He compiled a 32-bit payload with no <code>pagezero</code>, mapped a page at <code>0</code>, and got the kernel to call a function pointer from that page, achieving kernel code execution and even bypassing KASLR​.</p>



<blockquote>
<p>Notably, this required disabling <strong>SMEP</strong> <strong>protection</strong> which is discussed later.</p>
</blockquote>



<h3 class="wp-block-heading" id="tpwn-0-day-os-x-yosemite-2015">TPWN 0-day <strong>(OS X Yosemite, 2015)</strong></h3>



<p>But before that, a well-known example was <a href="https://appleinsider.com/articles/15/08/16/new-privilege-escalation-exploit-discovered-in-os-x-yosemite-also-affects-just-released-10105#:~:text=a%20password">Luca T</a><a href="https://appleinsider.com/articles/15/08/16/new-privilege-escalation-exploit-discovered-in-os-x-yosemite-also-affects-just-released-10105#:~:text=a%20password" target="_blank" rel="noreferrer noopener">o</a><a href="https://appleinsider.com/articles/15/08/16/new-privilege-escalation-exploit-discovered-in-os-x-yosemite-also-affects-just-released-10105#:~:text=a%20password">desco’s 2015 exploit targeti</a><a href="https://appleinsider.com/articles/15/08/16/new-privilege-escalation-exploit-discovered-in-os-x-yosemite-also-affects-just-released-10105#:~:text=a%20password" target="_blank" rel="noreferrer noopener">n</a><a href="https://appleinsider.com/articles/15/08/16/new-privilege-escalation-exploit-discovered-in-os-x-yosemite-also-affects-just-released-10105#:~:text=a%20password">g OS X Yosemite</a>, who combined a <a href="https://news.ycombinator.com/item?id=10067711" target="_blank" rel="noreferrer noopener">NULL pointer dereference in IOKit with an info leak</a> to gain root privileges. The exploit was called “<code>tpwn</code>” and is publicly <a href="https://github.com/kpwn/tpwn" target="_blank" rel="noreferrer noopener">available here</a>. Below is a simplified exploit flow:</p>


<pre aria-describedby="shcb-language-4" data-shcb-language-name="CSS" data-shcb-language-slug="css"><span><code><span>[Initial User Access]</span>
        ↓
<span>[Information Leak Vulnerability]</span>
        ↓
<span>[Obtain kalloc.1024 zone pointer]</span>
        ↓
<span>[Bypass Kernel ASLR]</span>
        ↓
<span>[Memory Corruption Primitive]</span>
        ↓
<span>[NULL Pointer Dereference in IOKit]</span>
        ↓
<span>[OR 0x10 anywhere in kernel memory]</span>
        ↓
<span>[Corrupt vtable pointer]</span>
        ↓
<span>[Trigger IOServiceRelease]</span>
        ↓
<span>[Execute code at vtable+0x20]</span>
        ↓
<span>[Stack pivot (RSP = RAX)]</span>
        ↓
<span>[Execute ROP chain]</span>
        ↓
<span>[Set UID to 0 (root)]</span>
        ↓
<span>[Clean up memory corruption]</span>
        ↓
<span>[Adjust task counts]</span>
        ↓
<span>[Unlock IOAudioEngine locks]</span>
        ↓
<span>[Root privileges achieved]</span></code></span><small id="shcb-language-4"><span>Code language:</span> <span>CSS</span> <span>(</span><span>css</span><span>)</span></small></pre>


<p><span>Todesco also developed a protection called <a href="https://github.com/kpwn/NULLGuard" target="_blank">NULLGuard</a> to defend against NULL pointer dereference bugs, which were later mitigat</span>ed in OS X 10.11 (El Capitan), which introduced System Integrity Protection (SIP) and other hardening measures.</p>



<blockquote>
<p>At the time, NULL dereferences could be a stepping stone to escalation if other conditions were met.</p>
</blockquote>



<h3 class="wp-block-heading" id="macos-os-x-10-11-el-capitan-iokit-driver-exploits-race-2015-2016">macOS OS X 10.11 (El Capitan) – IOKit Driver Exploits Race (2015–2016)</h3>



<p>Many vulnerabilities were discovered during that time in macOS kernel drivers where a NULL pointer was used as an object reference. <span>By <strong>mapping the NULL page</strong> in a malicious process and then racing or </span><strong><span>forcing a pointer to become</span> NULL</strong>, researchers could achieve control of the instruction pointer.</p>



<ul>
<li>For example, <a href="https://www.exploit-db.com/exploits/39920#:~:text=By%20mapping%20the%20NULL%20page,on%20a%20NULL%20object%20pointer" target="_blank" rel="noreferrer noopener">CVE-2016-1846</a> in the NVIDIA GeForce driver found by <a href="https://x.com/i41nbeer" target="_blank" rel="noreferrer noopener">Ian Beer</a>, allowed a user to map address zero and place a fake C++ object there. The driver then called a virtual function on a NULL object, <strong>jumping to an attacker-controlled function pointer</strong> from the fake Virtual Table.</li>
</ul>


<pre aria-describedby="shcb-language-5" data-shcb-language-name="Clean" data-shcb-language-slug="clean"><span><code>┌────────────────────────────────────────────────────────────────┐
│                       Process Virtual Memory                   │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  ┌─────────────┐                                               │
│  │ NULL Page   │ ◄── <span>1.</span> vm_deallocate(<span>0x0</span>, <span>0x1000</span>)             │
│  │ (<span>0x0</span><span>-0xFFF</span>) │ ◄── <span>2.</span> vm_allocate(&amp;addr=<span>0</span>, <span>0x1000</span>, <span>0</span>)        │
│  │             │ ◄── <span>3.</span> Fill <span>with</span> <span>0x41</span> bytes                   │
│  └─────────────┘                                               │
│      │                                                         │
│      ▼                                                         │
│  ┌─────────────┐                                               │
│  │ Fake VTable │                                               │
│  │ <span>0x41414141</span>  │ ◄── Function pointers <span>in</span> VTable               │
│  │ <span>0x41414141</span>  │     (will be called by kernel)                │
│  │ ...         │                                               │
│  └─────────────┘                                               │
│                                                                │
└────────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────────┐
│                       Kernel Execution Flow                    │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  Thread <span>1</span>                      Thread <span>2</span>                        │
│  ┌─────────────┐              ┌─────────────┐                  │
│  │ Open driver │              │ Wait for    │                  │
│  │ connection  │──┐        ┌──│ spinlock    │                  │
│  └─────────────┘  │        │  └─────────────┘                  │
│         │         │        │         │                         │
│         ▼         │        │         ▼                         │
│  ┌─────────────┐  │        │  ┌─────────────┐                  │
│  │ Release     │  │        │  │ Acquire     │                  │
│  │ spinlock    │──┼────────┼─▶│ spinlock    │                  │
│  └─────────────┘  │        │  └─────────────┘                  │
│         │         │        │         │                         │
│         ▼         │        │         ▼                         │
│  ┌─────────────┐  │        │  ┌─────────────┐                  │
│  │ Close driver│  │        │  │ Call IOKit  │                  │
│  │ connection  │◄─┘        └─▶│ method      │                  │
│  └─────────────┘              └─────────────┘                  │
│                                        │                       │
│                                        ▼                       │
│                               ┌─────────────────────────┐      │
│                               │ nvCommandQueue::        │      │
│                               │ GetHandleIndex accesses │      │
│                               │ NULL pointer at +<span>0x5b8</span>  │      │
│                               └─────────────────────────┘      │
│                                        │                       │
│                                        ▼                       │
│                               ┌───────────────────────────┐    │
│                               │ Virtual method call on    │    │
│                               │ NULL object jumps to      │    │
│                               │ address <span>0x4141414141414141</span>|    │
│                               └───────────────────────────┘    │
│                                                                │
└────────────────────────────────────────────────────────────────┘</code></span><small id="shcb-language-5"><span>Code language:</span> <span>Clean</span> <span>(</span><span>clean</span><span>)</span></small></pre>


<ul>
<li>Similarly, a bug in IOAudioEngine (<a href="https://www.exploit-db.com/exploits/39926#:~:text=getObject%20is%20a%20virtual%20function%2C,giving%20us%20easy%20RIP%20control" target="_blank" rel="noreferrer noopener">CVE-2016-1821</a>) set an object to NULL but later used it, letting an attacker supply a fake <code>reserved-&gt;streams</code> array at address zero and redirect execution​.</li>
</ul>



<blockquote>
<p>In these cases, mapping the null page gave trivial kernel RIP control to the attacker.</p>
</blockquote>



<h3 class="wp-block-heading" id="supervisor-mode-execution-prevention"><strong>Supervisor Mode Execution Prevention</strong></h3>



<p>On some older Macs, hardware protections against <strong>executing user memory in kernel</strong> were absent or disabled. In the Talos example, the <a href="https://blog.talosintelligence.com/apple-gfx-deep-dive/">researchers noted that modern CPUs have <strong>SMEP</strong></a>, which would <strong>prevent the kernel from executing code placed in user pages</strong> (like the NULL page)​. If SMEP was not enabled on the system, the exploit could directly execute shellcode from the mapped NULL page​. </p>



<blockquote>
<p>On newer hardware, Apple had started using CPU feature called SMEP to forbid executing user-space memory in kernel mode. It was introduced in OS X 10.11 (El Capitan) by late 2016.</p>
</blockquote>



<h3 class="wp-block-heading" id="intel-mitigations-on-macos">Intel Mitigations on macOS</h3>



<p>These historical exploits show that when an attacker could map address zero and<em> </em>if the kernel then used that memory as a pointer or code, a NULL dereference bug could lead to arbitrary code execution.</p>



<p>Apple closed these avenues by late 2016. <a href="https://support.apple.com/en-mk/103801#:~:text=Impact%3A%20A%20local%20user%20may,a%20system%20denial%20of%20service" target="_blank" rel="noreferrer noopener">Apple’s security updates</a> reclassified such bugs as Denial of Service issues and fixed them by adding NULL checks or better state handling:</p>



<figure><img decoding="async" width="1024" height="278" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABAAAAAEWAQMAAADCZHfhAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAADhJREFUGBntwQEBAAAAgqD+r3ZIwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgXowWAAHq0JdgAAAAAElFTkSuQmCC" alt="" data-src="https://afine.com/wp-content/uploads/2025/02/image-36-1024x278.png" data-srcset="https://afine.com/wp-content/uploads/2025/02/image-36-1024x278.png 1024w, https://afine.com/wp-content/uploads/2025/02/image-36-300x81.png 300w, https://afine.com/wp-content/uploads/2025/02/image-36-768x209.png 768w, https://afine.com/wp-content/uploads/2025/02/image-36-1536x417.png 1536w, https://afine.com/wp-content/uploads/2025/02/image-36-970x263.png 970w, https://afine.com/wp-content/uploads/2025/02/image-36.png 1653w" data-sizes="auto" data-eio-rwidth="1024" data-eio-rheight="278" data-src-webp="https://afine.com/wp-content/uploads/2025/02/image-36-1024x278.png.webp" data-srcset-webp="https://afine.com/wp-content/uploads/2025/02/image-36-1024x278.png.webp 1024w, https://afine.com/wp-content/uploads/2025/02/image-36-300x81.png.webp 300w, https://afine.com/wp-content/uploads/2025/02/image-36-768x209.png.webp 768w, https://afine.com/wp-content/uploads/2025/02/image-36-1536x417.png.webp 1536w, https://afine.com/wp-content/uploads/2025/02/image-36-970x263.png.webp 970w, https://afine.com/wp-content/uploads/2025/02/image-36.png.webp 1653w"/></figure>



<blockquote>
<p><strong>Apple removed 32-bit process support</strong> entirely in macOS 10.15 and <strong>enabed SMEP</strong> in fact eliminating the primary trick to map the NULL page completely for Intel based machines.</p>
</blockquote>



<h2 class="wp-block-heading" id="modern-mitigations-on-macos-apple-silicon">Modern Mitigations on macOS Apple Silicon</h2>



<p>With the transition to Apple Silicon (ARM64 architecture) and modern macOS versions (11.0 Big Sur and later), Apple has introduced strong mitigations that make NULL pointer dereferences unexploitable.</p>



<h3 class="wp-block-heading" id="strict-null-page-mapping-protections">Strict NULL Page Mapping Protections</h3>



<p>All user processes on Apple Silicon are 64-bit, and the <strong>kernel will not map any memory at address 0</strong> in user space. As noted in <code>__PAGEZERO</code> the Mach-O format reserves the low address region (4GB). </p>





<p>Even without this reservation, the macOS kernel enforces a minimum address (like <code><a href="https://wiki.debian.org/mmap_min_addr" target="_blank" rel="noreferrer noopener">mmap_min_addr</a></code> in Linux) that user code cannot allocate. In short, we <strong>cannot place data at or near the NULL address</strong>.</p>



<blockquote>
<p>This means any kernel dereference of a NULL pointer will hit an unmapped region and immediately trigger a fault rather than accessing attacker-controlled memory.</p>
</blockquote>



<h3 class="wp-block-heading" id="hardware-execution-and-access-controls-pxn-pan">Hardware Execution and Access Controls (PXN/PAN)</h3>



<p>Apple’s Silicon leverages ARMv8 features analogous to SMEP/SMAP on Intel. <span>ARM64 has <strong>Privileged Execute Never (PXN)</strong>, which ensures the kernel cannot execute code from pages marked as user space.</span></p>



<p>In contrast, <strong>Privileged Access Never (PAN)</strong> prevents the kernel from accidentally reading/writing user space memory without an <span><span>explicit override.</span></span> <strong>Kernel marks all user memory as PXN</strong>, so even if an exploit somehow redirected execution to a user page (e.g., address 0), the processor would refuse to execute it. </p>



<p>Likewise, PAN would stop the kernel from reading malicious data placed in a user-controlled NULL page (it would require a special instruction sequence to access user memory intentionally).</p>


<pre aria-describedby="shcb-language-6" data-shcb-language-name="PHP" data-shcb-language-slug="php"><span><code><span>1.</span> Attacker maps shellcode at user-space <span>NULL</span> (<span>0x0</span>).  
<span>2.</span> Exploit hijacks kernel control flow to <span>0x0</span>.  
<span>3.</span> Hardware checks:  
   ├─ PXN=<span>1</span> → Instruction Fetch Fault (Execution denied)
   └─ PAN=<span>1</span> → Data Access Fault (Access denied <span>if</span> kernel reads <span>0x0</span>).  
<span>4.</span> System halts exploit via fault.</code></span><small id="shcb-language-6"><span>Code language:</span> <span>PHP</span> <span>(</span><span>php</span><span>)</span></small></pre>


<blockquote>
<p>These hardware protections make the classic scenario of executing shellcode from a NULL page <strong>nonviable</strong> – the attempt would just cause another fault.</p>
</blockquote>



<h3 class="wp-block-heading" id="pointer-authentication-codes-pac">Pointer Authentication Codes (PAC)</h3>



<p>A major enhancement with Apple’s ARM64e architecture is <strong>Pointer Authentication</strong>, introduced on the A12/M1 chips (ARMv8.3-A). Pointer authentication codes add a cryptographic signature to pointer values (such as return addresses and function pointers) verified upon use.</p>





<p>macOS extensively uses PAC in the kernel to protect against pointer corruption​. If a NULL dereference bug is exploited by manipulating a kernel pointer, PAC will likely detect the tampering.</p>


<pre><span><code>   Regular pointer:  0x00007FFFFFFFFFF8  (64-bit address)
                     └────────────────┘ 
                          address
   
   PAC pointer:      0xA23F7FFFFFFFFFF8
                     └────┘└──────────┘
                      │        │        
                      │        └─ original address
                      └─────────── cryptographic signature (PAC)</code></span></pre>


<p>The kernel’s function pointers are signed with secret keys. An attacker’s fabricated pointer will not have a valid signature. The check will fail when the kernel attempts to authenticate the fake pointer before use.</p>



<blockquote>
<p>In effect, PAC thwarts attempts to forge control-flow pointers. This is highly relevant for NULL deref exploits, which historically relied on making the kernel jump to an attacker’s fake function pointer.</p>
</blockquote>



<h3 class="wp-block-heading" id="removal-of-legacy-exploit-vectors"><strong>Removal of Legacy Exploit Vectors</strong></h3>



<p>As mentioned, <strong>macOS no longer supports 32-bit executables</strong> (since macOS 10.15 Catalina), closing the loophole of <a href="https://github.com/spencerdodd/kernelpop/blob/b3467d3c64f9657a822c1f3c0d70769efabebf60/exploits/mac/CVE20164656.py#L621" target="_blank" rel="noreferrer noopener">disabling the <code>__PAGEZERO</code> region​</a>. Additionally, System Integrity Protection (SIP) and Kernel Integrity mechanisms prevent even root users from modifying certain memory or loading unsigned kernel code, indirectly making setting up a NULL page attack more difficult.</p>



<blockquote>
<p>An attacker cannot simply disable these protections without already having kernel privileges.</p>
</blockquote>



<h3 class="wp-block-heading" id="improved-kernel-memory-management-and-checks">Improved Kernel Memory Management and Checks</h3>



<p>Apple has made significant improvements to the XNU kernel’s handling of pointers. Many kernel interfaces now perform stricter validation of pointers. Following high-profile bugs between 2015 and 2016, Apple audited drivers to introduce NULL checks and ensure that pointers are only set to NULL when it is safe to do so after freeing objects. When examining the decompiled code of various drivers’ external methods, many of them are found to have prefixes in their names, which may imply that they are “sanitized” or “secure.” These functions serve as wrappers for the original functions.</p>


<pre aria-describedby="shcb-language-7" data-shcb-language-name="HTML, XML" data-shcb-language-slug="xml"><span><code>For instance: <span>&lt;<span>span</span> <span>style</span>=<span>&#34;background-color: initial; font-family: inherit; font-size: 1em;&#34;</span>&gt;</span>IOMobileFramebufferUserClient::s_set_matrix<span>&lt;/<span>span</span>&gt;</span> wraps IOMobileFramebufferUserClient::set_matrix</code></span><small id="shcb-language-7"><span>Code language:</span> <span>HTML, XML</span> <span>(</span><span>xml</span><span>)</span></small></pre>


<blockquote>
<p>Nevertheless, even after the audit these bugs still exist, but are they still danger?</p>
</blockquote>



<h2 class="wp-block-heading" id="are-null-pointer-dereferences-still-exploitable-on-apple-silicon">Are NULL Pointer Dereferences Still Exploitable on Apple Silicon?</h2>



<p>In modern macOS on Apple Silicon, a NULL pointer dereference in the kernel is <strong>almost certainly not exploitable for code execution</strong>. It will result in a kernel panic (Denial of Service), but as we saw, multiple layers of defense prevent leveraging it for a privilege escalation.</p>



<p>To summarize why exploitation is effectively dead on Apple Silicon macOS:</p>



<ul>
<li><strong>Cannot control memory at NULL:</strong> Unlike a decade ago, an attacker cannot map or place controlled data at address 0 in the relevant address space. The OS and hardware ensure the NULL page is unmapped and inaccessible to user programs​.</li>



<li><strong>Kernel will not execute user memory:</strong> Even if the kernel somehow jumped to address 0 (or any user address), it would hit PXN enforcement and refuse to execute code there, causing a fault​.</li>



<li><strong>Kernel will not read user memory:</strong> The kernel cannot read memory from address 0 (or any user address). It would hit PAN enforcement and refuse to load code from there, causing a fault​.</li>



<li><strong>Pointer authenticity checks:</strong> Pointer authentication defeats forging a pointer to trick the kernel (e.g., a fake function pointer as payload). The attacker would need to bypass PAC, which is non-trivial and typically requires a separate side-channel or info leak attack (e.g., the <a href="https://en.wikipedia.org/wiki/Pacman_(security_vulnerability)" target="_blank" rel="noreferrer noopener">PACMAN vulnerability</a>). The kernel will detect the invalid pointer and crash safely without a PAC bypass.</li>
</ul>



<blockquote>
<p>These mitigations make the exploit chain unrealistic to complete, but lets “theoretize” how it could look.</p>
</blockquote>



<h3 class="wp-block-heading" id="theoretical-exploitation-chain">Theoretical Exploitation Chain</h3>



<p>At minimum, we need five separate vulnerabilities:</p>



<ul>
<li><strong>Page Table Modification:</strong> A vulnerability allowing the modification of kernel page tables to <strong>map the NULL page with writeable permissions</strong>. This alone requires a sophisticated kernel memory corruption primitive specifically targeting page table entries. I have never seen that.</li>



<li><strong>PAC Bypass:</strong> This would require either:
<ul>
<li>Leaking the secret PAC keys (complicated as they are stored in system registers)</li>



<li>Finding an oracle that can generate valid signatures</li>



<li>Exploiting a side-channel attack like PACMAN</li>



<li>Finding a PAC-bypass vulnerability in the kernel implementation</li>
</ul>
</li>



<li><strong>Write Primitive</strong>: Vulnerability to place a payload at address 0.</li>



<li><strong>PXN  Bypass:</strong> Vulnerability to manipulate page table attributes to mark the NULL page <strong>as kernel-accessible</strong> and <strong>executable</strong> (theoretically, the first primitive used for remaping could do that).</li>



<li><strong>NULL Pointer Dereference</strong>: Finally, out bug to dereference NULL and execute our instruction.</li>
</ul>



<blockquote>
<p>This complexity makes NULL pointer dereferences primarily useful only as Denial of Service vulnerabilities in modern Apple Silicon systems.</p>
</blockquote>



<h3 class="wp-block-heading" id="does-apple-still-patch-it">Does Apple Still Patch It?</h3>



<p>Yes, Apple is still fixing such issues and accepting such reports, but it does not always classify them as security issues. I do not know why they do and sometimes do not, but I will discuss this further in the following article. We can see in the <a href="https://support.apple.com/en-us/122068" target="_blank" rel="noreferrer noopener">recent macOS security</a> updates that Apple classifies NULL pointer dereference fixes as Denial of Service fixes, not “arbitrary code execution” issues​:</p>



<figure><img decoding="async" width="1024" height="324" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABAAAAAFEAQMAAACDIt4dAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAD5JREFUGBntwQEBAAAAgqD+r3ZIwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC4F6NEAAHE6+z3AAAAAElFTkSuQmCC" alt="" data-src="https://afine.com/wp-content/uploads/2025/02/image-39-1024x324.png" data-srcset="https://afine.com/wp-content/uploads/2025/02/image-39-1024x324.png 1024w, https://afine.com/wp-content/uploads/2025/02/image-39-300x95.png 300w, https://afine.com/wp-content/uploads/2025/02/image-39-768x243.png 768w, https://afine.com/wp-content/uploads/2025/02/image-39-970x307.png 970w, https://afine.com/wp-content/uploads/2025/02/image-39.png 1483w" data-sizes="auto" data-eio-rwidth="1024" data-eio-rheight="324" data-src-webp="https://afine.com/wp-content/uploads/2025/02/image-39-1024x324.png.webp" data-srcset-webp="https://afine.com/wp-content/uploads/2025/02/image-39-1024x324.png.webp 1024w, https://afine.com/wp-content/uploads/2025/02/image-39-300x95.png.webp 300w, https://afine.com/wp-content/uploads/2025/02/image-39-768x243.png.webp 768w, https://afine.com/wp-content/uploads/2025/02/image-39-970x307.png.webp 970w, https://afine.com/wp-content/uploads/2025/02/image-39.png.webp 1483w"/></figure>



<p>There have been no public reports of a NULL dereference exploited for escalation since macOS Big Sur, which aligns with the expectation that these are no longer a viable attack vector on Apple Silicon.</p>



<blockquote>
<p>Apple’s overall security architecture has closed this chapter of this exploit history.</p>
</blockquote>



<h3 class="wp-block-heading" id="exploitability-checklist-before-reporting-a-null-pointer-dereference">Exploitability Checklist – Before Reporting a NULL Pointer Dereference</h3>



<p>Not every NULL pointer dereference is equal—sometimes the bug’s root cause can be leveraged to redirect a pointer to attacker-controlled kernel memory. Before reporting, verify the following:</p>



<ul>
<li>Check if the pointer is derived from a <strong>heap allocation</strong> and if its source can be manipulated</li>



<li>Test whether you can <strong>spray</strong> or <strong>groom</strong> the <strong>heap</strong> to influence the memory location in question</li>



<li>Determine if the pointer is computed using an <strong>index</strong> or <strong>offset</strong> that might be <strong>user-controllable</strong></li>



<li>Look for <strong>use-after-free</strong> conditions where freed memory could be reallocated with controlled data</li>



<li><strong>Assess</strong> if missing or insufficient <strong>null checks</strong> allow for unintended pointer values</li>



<li>Explore <strong>alternative control flows</strong> that might bypass security checks and lead to pointer corruption</li>
</ul>



<blockquote>
<p>In short, <strong>verify if any user-controlled input influences the pointer value used in the dereference</strong>. Ticking each point from the above list ensures the NULL pointer dereference is indeed NULL.</p>
</blockquote>



<h2 class="wp-block-heading" id="final-words">Final Words</h2>



<p>Although NULL Pointer Dereference is no longer a viable option for Exploit Development, I hope you liked the history behind the creation of mitigations against it and why today it is an unexploitable issue.</p>



<p>If you find this blog post interesting and want to learn more about Cybersecurity in general, I encourage you to visit our <a href="https://afine.com/blog/" target="_blank" rel="noreferrer noopener">AFINE blog</a> regularly for new insights. If you are specifically interested in macOS, bookmark the <a href="https://github.com/Karmaz95/Snake_Apple?tab=readme-ov-file#articles" target="_blank" rel="noreferrer noopener">Snake_Apple</a> repository, where you will find all my articles about macOS.</p>



<blockquote>
<p>I hope you learned something new here!</p>
</blockquote>




                                            </div></div>
  </body>
</html>
