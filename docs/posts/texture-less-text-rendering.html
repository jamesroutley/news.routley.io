<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://poniesandlight.co.uk/reflect/debug_print_text/">Original</a>
    <h1>Texture-less Text Rendering</h1>
    
    <div id="readability-page-1" class="page"><div>
    
  	
<figure>
<img src="https://poniesandlight.co.uk/img/reflect/debug_print_text/look_ma.png" loading="lazy"/>
</figure>
<div>
<p>Sometimes, all you want is to quickly print some text into a Renderpass. But <a href="https://stackoverflow.com/questions/22080881/how-to-render-text-in-modern-opengl-with-glsl">traditionally, drawing text</a> requires you first to render all possible glyphs of a font into an atlas, to bind this atlas as a texture, and then to render glyphs one by one by drawing triangles on screen, with every triangle picking the correct glyph from the font atlas texture.</p>
<p>This is how <a href="https://github.com/ocornut/imgui">imgui</a> does it, how anyone using <a href="https://github.com/nothings/stb/blob/master/stb_truetype.h">stb_truetype</a> does it, and it’s delightfully close to how <a href="https://en.wikipedia.org/wiki/Typesetting">type setting</a> used to be done ages bygone on physical letterpresses.</p>
<figure>
<img loading="lazy" src="https://poniesandlight.co.uk/img/reflect/debug_print_text/upper_case_and_lower_case.jpg" alt="Composing cases of an early letterpress" title="Composing cases of an early letterpress"/>
<figcaption>
    Case in point: Some ancient Letterpress Type Cases (public domain) – <a href="https://babel.hathitrust.org/846c4e7f-3fa3-4275-b53c-3183150e9481">source</a></figcaption>
</figure>
<p>Quaint, correct, but also quite cumbersome.</p>
<p>What if – for quick and dirty debug messaging – there was a simpler way to do this?</p>
<p>Here, I’ll describe a technique for <em>texture-less</em> rendering of debug text. On top of it all, it draws all the text in a single draw call.</p>
<h2 id="the-font-pixels-sans-texture">The Font: Pixels Sans Texture <a href="#the-font-pixels-sans-texture"></a></h2>
<p>How can we get rid of the font atlas texture? We’d need to store a font atlas or something similar <em>directly inside</em> the fragment shader. Obviously, we can’t store <em>bitmaps</em> inside our shaders, but we can store integer constants, which, if you squint hard enough, are nothing but maps of bits. Can we pretend that an integer is a bitmap?</p>
<figure>
<img loading="lazy" src="https://poniesandlight.co.uk/img/reflect/debug_print_text/0x42_as_bitmap.svg" alt="The integer 0x42 as a bitmap" title="The integer 0x42 as a bitmap"/>
<figcaption>
    An 8 bit integer as a bitmap. The value 66, or <code>0x42</code> in hex notation, translates to <code>0b01000010</code> in binary notation. If we assume that every bit is a pixel  on/off value, we get something like this.
</figcaption>
</figure>
<p>We can draw this to the screen using a GLSL fragment shader by mapping a fragment’s <code>xy</code> position to the bit that is covered by it in the “bitmap”. If the bit is set, we draw in the foreground colour. If the bit is not set, we draw in the background colour.</p>

</div>
<div>
    
<div><div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span><span>9
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="glsl"><span><span><span>uint</span> <span>bitmap</span> <span>=</span> <span>0x42</span><span>;</span>
</span></span><span><span><span>vec4</span> <span>col_fg</span> <span>=</span> <span>vec4</span><span>(</span><span>1</span><span>,</span><span>1</span><span>,</span><span>1</span><span>,</span><span>1</span><span>);</span>
</span></span><span><span><span>vec4</span> <span>col_bg</span> <span>=</span> <span>vec4</span><span>(</span><span>0</span><span>,</span><span>0</span><span>,</span><span>0</span><span>,</span><span>1</span><span>);</span>
</span></span><span><span>
</span></span><span><span><span>// vec2 uv is the normalized texture coordinate for the fragment</span>
</span></span><span><span><span>// with the origin top-left</span>
</span></span><span><span><span>uint</span> <span>which_bit</span> <span>=</span> <span>7</span> <span>-</span> <span>min</span><span>(</span><span>7</span><span>,</span><span>floor</span><span>(</span><span>uv</span><span>.</span><span>x</span> <span>*</span> <span>8</span><span>));</span> 
</span></span><span><span>
</span></span><span><span><span>out_color</span> <span>=</span> <span>mix</span><span>(</span><span>col_bg</span><span>,</span> <span>col_fg</span><span>,</span> <span>(</span><span>bitmap</span> <span>&gt;&gt;</span> <span>which_bit</span><span>)</span> <span>&amp;</span> <span>1</span><span>);</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div><p><span>glsl</span>
</p></div><p>Now, one byte will only draw one line of pixels for us. If we want to draw nicer glyphs, we will need more bytes. If we allowed <span>16 bytes</span><span> (that’s 16 lines)</span> per glyph, this would give us an 8x16 pixel canvas to work with. A single <code>uvec4</code>, which is a built-in type in GLSL, covers exactly the correct amount of bytes that we need.</p>
<figure>
<img loading="lazy" src="https://poniesandlight.co.uk/img/reflect/debug_print_text/character_A.svg" alt="The Glyph A encoded as an uvec4" title="The Glyph A encoded as an uvec4"/>
<figcaption>
    The character <code>A</code> encoded in 16 bytes, stored as an <code>uvec4</code>, that’s 4 uints with each 4 bytes.
</figcaption>
</figure>
<p>16 bytes per glyph seems small enough; It should allow us to encode the complete <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a> subset of 96 printable glyphs in all of 1536 bytes of shader <span>memory</span><span>. (We could probably compress this further, but we would lose simplicity and/or readability)</span>.</p>
<h2 id="where-do-we-get-the-bitmaps-from">Where do we get the bitmaps from? <a href="#where-do-we-get-the-bitmaps-from"></a></h2>
<p>Conveniently, the encoding of a font into bitmaps such as described above is very much the definition of the venerable <a href="https://en.wikipedia.org/wiki/PC_Screen_Font">PSF1 format</a>, give or take a few header bytes. We can therefore harvest the glyph pixels from any PSF1 terminal font by opening it in a hex editor such as <a href="https://imhex.werwolv.net/">ImHex</a>, travelling past the header (4 bytes) and the first section of non-printable glyphs (512 bytes), and then exporting the raw data for the next 96 glyphs (1536 bytes) by using “Copy as → C Array”.</p>
<figure>
<img loading="lazy" src="https://poniesandlight.co.uk/img/reflect/debug_print_text/imhex_screenshot.png" alt="A Screenshot of ImHex" title="A Screenshot of ImHex"/>
<figcaption>
    The ImHex hex editor has a really useful feature: you can copy binary data as a c-array.
</figcaption>
</figure>
<p>This will give us a nicely formatted array of chars, which we can easily edit into an array of <code>uint</code>s, which we then group into <code>uvec4</code>s. We need to remember that just concatenating the raw chars into <code>uint</code>s flips the endianness of our <code>uint</code>s, but we can always flip this back when we sample the font data…</p>
<p>Once we’re done, this is how our font bitmap data table looks like in the fragment shader:</p>

</div>
<div>
    
<div><div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="glsl"><span><span><span>const</span> <span>uvec4</span> <span>font_data</span><span>[</span><span>96</span><span>]</span> <span>=</span> <span>{</span>
</span></span><span><span>  <span>{</span> <span>0x00000000</span><span>,</span> <span>0x00000000</span><span>,</span> <span>0x00000000</span><span>,</span> <span>0x00000000</span> <span>},</span> <span>// 0x1e: SPACE</span>
</span></span><span><span>  <span>{</span> <span>0x00000000</span><span>,</span> <span>0x08080808</span><span>,</span> <span>0x08080800</span><span>,</span> <span>0x08080000</span> <span>},</span> <span>// 0x21: &#39;!&#39;</span>
</span></span><span><span>  <span>{</span> <span>0x00002222</span><span>,</span> <span>0x22220000</span><span>,</span> <span>0x00000000</span><span>,</span> <span>0x00000000</span> <span>},</span> <span>// 0x22: &#39;\&#39;</span>
</span></span><span><span>  <span>{</span> <span>0x00000000</span><span>,</span> <span>0x1212127E</span><span>,</span> <span>0x24247E48</span><span>,</span> <span>0x48480000</span> <span>},</span> <span>// 0x23: &#39;#&#39;</span>
</span></span><span><span>  <span>// ... etc ... </span>
</span></span><span><span>
</span></span><span><span>  <span>{</span> <span>0x00000808</span><span>,</span> <span>0x08080808</span><span>,</span> <span>0x08080808</span><span>,</span> <span>0x08080808</span> <span>},</span> <span>// 0x7C: &#39;|&#39;</span>
</span></span><span><span>  <span>{</span> <span>0x00000030</span><span>,</span> <span>0x08081010</span><span>,</span> <span>0x08040810</span><span>,</span> <span>0x10080830</span> <span>},</span> <span>// 0x7D: &#39;}&#39;</span>
</span></span><span><span>  <span>{</span> <span>0x00000031</span><span>,</span> <span>0x49460000</span><span>,</span> <span>0x00000000</span><span>,</span> <span>0x00000000</span> <span>},</span> <span>// 0x7E: &#39;~&#39;</span>
</span></span><span><span>  <span>{</span> <span>0xFC1B26EF</span><span>,</span> <span>0xC8E04320</span><span>,</span> <span>0x8958625E</span><span>,</span> <span>0x79BAEE7E</span> <span>},</span> <span>// 0x7F: BACKSPACE</span>
</span></span><span><span><span>};</span>                                              </span></span></code></pre></td></tr></tbody></table>
</div>
</div><p><span>glsl</span>
</p></div><p>I say table, because the <code>font_data</code> array now stores the bitmaps for 96 character glyphs, indexed by their ASCII value (minus 0x20). This table therefore covers the full printable ASCII range from <code>0x20</code> <kbd>SPACE</kbd> to <code>0x7F</code> <kbd>BACKSPACE</kbd> (inclusive), but in the snippet above I’m showing only 8 of them, to save space.</p>
<p>So far, all this is just so that we don’t have to bind a texture when drawing our text. But how to draw the text itself?</p>
<figure>
<img loading="lazy" src="https://poniesandlight.co.uk/img/reflect/debug_print_text/screenshot_small.png" alt="Text output" title="Text output"/>
<figcaption>
    This is what we want to print at the end of this process
</figcaption>
</figure>
<h2 id="one-draw-call-thats-all">One Draw Call, That’s All. <a href="#one-draw-call-thats-all"></a></h2>
<p>We’re going to use a single <strong>instanced</strong> draw call.</p>

</div>
<div>
    
<p>With instanced drawing, we don’t have to repeatedly issue draw <em>instructions</em>, since we encode the logic into per-instance data. One draw call contains everything we need, provided it uses two attribute streams. The fist stream, per-draw, has just the necessary information to draw a generic quad. And the second stream, per-instance, packs the two pieces of information that change with every instance of such a quad: First, a position offset, so that we know <em>where in screen space</em> to draw the quad. And second, of course, the text that we want to print.</p>
<p>For the position offset we can use one float each for x and y, which leaves two floats for this particular attribute binding <span>unused</span><span> (attribute bindings in GLSL/Vulkan are at minimum the equivalent of 4 floats wide)</span>. We have more than enough space to use one extra float to pack in a font scale parameter, if we like.</p>

</div>
<div>
  
<p>For the text that we want to print, we have a similarly wasteful situation – the smallest basic vertex attribute data type <a href="https://docs.vulkan.org/spec/latest/chapters/fxvertex.html#fxvertex-attrib-location">is usually 32bit wide</a>, and so it makes sense to make best use of this and pack at least 4 characters at a time. If we do this, we must make sure that the message that we want to print has a length divisible by 4. If it was shorter, we need to fill up the difference with zero byte (<code>\0</code>) characters. Conveniently, the zero byte is also used to signal the end of a c-string.</p>
<p>Our per-instance data looks like this:</p>

</div>
<div>
    
<div><div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="cpp"><span><span><span>struct</span> <span>word_data</span> <span>{</span>
</span></span><span><span>  <span>float</span>          <span>pos_and_scale</span><span>[</span> <span>3</span> <span>];</span> <span>// xy position + scale 
</span></span></span><span><span><span></span>  <span>uint32_t</span>       <span>word</span><span>;</span>               <span>// four characters that we want to print
</span></span></span><span><span><span></span><span>};</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div><p><span>cpp</span>
</p></div><p>It’s the application’s responsibility to split up the message into chunks of 4 characters, to convert these four characters into an <code>unit32_t</code>, and to store it into a <code>word_data</code> struct together with the position offset for where on screen to render these four characters. Once a <code>word_data</code> is filled, we append it into an array where we accumulate all the data for our text draw calls. Once we are ready to draw, we can then bind this array as a per-instance binding to our debug text drawing pipeline, and draw all text with a single <span>instanced draw call</span><span>, with the number of instances being the number of quads that we want to draw</span>.</p>
<p>More interesting things happen in the vertex and fragment shader of the debug text drawing pipeline.</p>
<h2 id="vertex-shader">Vertex Shader <a href="#vertex-shader"></a></h2>
<p>Our vertex shader produces three outputs.</p>
<p>First, it writes to <code>gl_Position</code> to place the vertices for our triangles on the screen. This operates in <span> NDC </span><span> = Normalised Device </span> “screen space” Coordinates. We calculate an offset for each vertex using the per-instance <code>pos_and_scale</code> attribute data.</p>
<p>The second output of the vertex shader is the word that we want to render: We just pass though the attribute <code>uint</code> as an output to the fragment shader – but we make sure to use the <code>flat</code> qualifier so that it does not get interpolated.</p>
<p>And then, the vertex shader synthesizes texture coordinates (via <code>gl_VertexIndex</code>). It does so pretty cleverly:</p>
<ul>
<li><code>12 &gt;&gt; gl_VertexIndex &amp; 1</code> will give a sequence <code>0, 0, 1, 1</code>,</li>
<li><code> 9 &gt;&gt; gl_VertexIndex &amp; 1</code> will give a sequence <code>1, 0, 0, 1</code>,</li>
</ul>
<p>This creates a sequence of uv coordinates <code>(0,1), (0,0), (1,0), (1,1)</code> in a branchless way.</p>
<div><div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span><span>25
</span><span>26
</span><span>27
</span><span>28
</span><span>29
</span><span>30
</span><span>31
</span><span>32
</span><span>33
</span><span>34
</span><span>35
</span><span>36
</span><span>37
</span><span>38
</span><span>39
</span><span>40
</span><span>41
</span><span>42
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="glsl"><span><span><span>#version 450 core</span>
</span></span><span><span>
</span></span><span><span><span>#extension GL_ARB_separate_shader_objects : enable</span>
</span></span><span><span><span>#extension GL_ARB_shading_language_420pack : enable</span>
</span></span><span><span>
</span></span><span><span><span>// Inputs </span>
</span></span><span><span><span>// Uniforms - Push Constants</span>
</span></span><span><span><span>layout</span> <span>(</span><span>push_constant</span><span>)</span> <span>uniform</span> <span>Params</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	<span>vec2</span> <span>u_resolution</span><span>;</span> <span>// screen canvas resolution in physical pixels</span>
</span></span><span><span><span>};</span>
</span></span><span><span>
</span></span><span><span><span>// Input Attributes</span>
</span></span><span><span><span>layout</span> <span>(</span><span>location</span> <span>=</span> <span>0</span><span>)</span> <span>in</span> <span>vec3</span> <span>pos</span><span>;</span>      <span>// &#34;vanilla&#34; vertex position attribute - given in pixels</span>
</span></span><span><span><span>layout</span> <span>(</span><span>location</span> <span>=</span> <span>1</span><span>)</span> <span>in</span> <span>uint</span> <span>word</span><span>;</span>     <span>// per-instance: four chars</span>
</span></span><span><span><span>layout</span> <span>(</span><span>location</span> <span>=</span> <span>2</span><span>)</span> <span>in</span> <span>vec3</span> <span>word_pos</span><span>;</span> <span>// per-instance: where to place the word in screen space</span>
</span></span><span><span><span>layout</span> <span>(</span><span>location</span> <span>=</span> <span>3</span><span>)</span> <span>in</span> <span>vec4</span> <span>col_fg</span><span>;</span>   <span>// per-instance: foreground colour</span>
</span></span><span><span><span>layout</span> <span>(</span><span>location</span> <span>=</span> <span>4</span><span>)</span> <span>in</span> <span>vec4</span> <span>col_bg</span><span>;</span>   <span>// per-instance: background colour</span>
</span></span><span><span>
</span></span><span><span><span>// Vertex Outputs </span>
</span></span><span><span><span>struct</span> <span>per_word_data</span> <span>{</span>
</span></span><span><span>	<span>uint</span> <span>msg</span><span>;</span>
</span></span><span><span>	<span>vec4</span> <span>fg_colour</span><span>;</span>
</span></span><span><span>	<span>vec4</span> <span>bg_colour</span><span>;</span>
</span></span><span><span><span>};</span>
</span></span><span><span>
</span></span><span><span><span>out</span> <span>gl_PerVertex</span> <span>{</span> <span>vec4</span> <span>gl_Position</span><span>;</span> <span>};</span>
</span></span><span><span><span>layout</span> <span>(</span><span>location</span> <span>=</span> <span>0</span><span>)</span> <span>out</span> <span>vec2</span> <span>outTexCoord</span><span>;</span>
</span></span><span><span><span>layout</span> <span>(</span><span>location</span> <span>=</span> <span>1</span><span>)</span> <span>flat</span> <span>out</span> <span>per_word_data</span> <span>outMsg</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>void</span> <span>main</span><span>()</span> 
</span></span><span><span><span>{</span>
</span></span><span><span>	<span>outMsg</span><span>.</span><span>msg</span> <span>=</span> <span>word</span><span>;</span>
</span></span><span><span>	<span>outMsg</span><span>.</span><span>fg_colour</span> <span>=</span> <span>col_fg</span><span>;</span>
</span></span><span><span>	<span>outMsg</span><span>.</span><span>bg_colour</span> <span>=</span> <span>col_bg</span><span>;</span>
</span></span><span><span>
</span></span><span><span>	<span>vec2</span> <span>scale_factor</span> <span>=</span> <span>vec2</span><span>(</span><span>1.</span><span>,</span><span>2.</span><span>)</span><span>/</span><span>(</span><span>u_resolution</span><span>);</span>
</span></span><span><span>	<span>outTexCoord</span> <span>=</span> <span>vec2</span><span>((</span><span>12</span> <span>&gt;&gt;</span> <span>gl_VertexIndex</span><span>)</span> <span>&amp;</span><span>1</span><span>,</span> <span>(</span><span>9</span> <span>&gt;&gt;</span> <span>gl_VertexIndex</span> <span>)</span> <span>&amp;</span><span>1</span><span>);</span>
</span></span><span><span>	<span>vec4</span> <span>position</span> <span>=</span> <span>vec4</span><span>(</span><span>0</span><span>,</span><span>0</span><span>,</span><span>0</span><span>,</span><span>1</span><span>);</span>
</span></span><span><span>	<span>position</span><span>.</span><span>xy</span> <span>=</span> <span>vec2</span><span>(</span><span>-</span><span>1</span><span>,</span> <span>-</span><span>1</span><span>)</span> <span>+</span> <span>(</span><span>pos</span><span>.</span><span>xy</span> <span>*</span> <span>word_pos</span><span>.</span><span>z</span> <span>+</span> <span>word_pos</span><span>.</span><span>xy</span><span>)</span> <span>*</span> <span>scale_factor</span><span>;</span>
</span></span><span><span>	<span>gl_Position</span> <span>=</span> <span>position</span><span>;</span>
</span></span><span><span><span>}</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div><p><span>glsl</span>
</p></div><p>If we at this point visualise just the output of the vertex shader, we will get something like this:</p>
<figure>
<img loading="lazy" src="https://poniesandlight.co.uk/img/reflect/debug_print_text/screenshot_small_uv_continuous.png" alt="Quad visualisation with uv coords" title="Quad visualisation with uv coords"/>
<figcaption>
    Visualisation of per-quad <code>outTexCoord</code> uv coords. Note that these are continuous (smooth).
</figcaption>
</figure>
<h2 id="fragment-shader">Fragment Shader <a href="#fragment-shader"></a></h2>

</div>
<div>
  
<p>Our fragment shader needs three pieces of information to render text, two of which it receives from the vertex shader stage:</p>
<ol>
<li>The fragment’s interpolated uv coordinate, <code>uv</code></li>
<li>The character that we want to draw, <code>in_word</code></li>
<li>The font data array, <code>font_data</code></li>
</ol>
<p>To render a glyph, each fragment must map its uv-coordinate to the correct bit of the glyph bitmap. If the bit at the lookup position is set, then render the fragment in the foreground colour, otherwise render it in background colour.</p>
<p>This mapping works like this:</p>
<p>First, we must map the uv coordinates to <span>word </span><span>– <strong>word</strong> not, <em>world</em>! –</span> pixel coordinates. The nice thing about these two coordinate systems is that they both have their origin at the <span>top left</span><span>, so we only need to bother with scaling, and not origin transformation</span>.</p>
<p>We know that our uv coordinates are normalised floats going from <code>vec2(0.f,0.f)</code> to <code>vec2(1.f,1.f)</code>, while our font pixel coordinates are integers, going from <code>uvec2(0,0)</code> to <code>uvec2(7,15)</code>.</p>
<p>We also must find out which one of the four characters in the word to draw.</p>

</div>
<div>
    
<div><div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="glsl"><span><span><span>const</span> <span>uint</span> <span>WORD_LEN</span> <span>=</span> <span>4</span><span>;</span> <span>// 4 characters in a word</span>
</span></span><span><span>
</span></span><span><span><span>// quantize uv coordinate to discrete steps</span>
</span></span><span><span><span>uvec2</span> <span>word_pixel_coord</span> <span>=</span> <span>uvec2</span><span>(</span><span>floor</span><span>(</span><span>uv</span><span>.</span><span>xy</span> <span>*</span> <span>vec2</span><span>(</span> <span>8</span> <span>*</span> <span>WORD_LEN</span><span>,</span> <span>16</span><span>)));</span> 
</span></span><span><span><span>// limit pixel coord range to uvec2(0..31, 0..15)</span>
</span></span><span><span><span>word_pixel_coord</span> <span>=</span> <span>min</span><span>(</span><span>uvec2</span><span>(</span> <span>8</span> <span>*</span> <span>WORD_LEN</span> <span>-</span><span>1</span><span>,</span> <span>16</span> <span>-</span><span>1</span><span>),</span> <span>word_pixel_coord</span><span>);</span>
</span></span><span><span><span>// Find which of the four characters in the word this fragment falls onto</span>
</span></span><span><span><span>uint</span> <span>printable_character</span> <span>=</span> <span>in_word</span> <span>&gt;&gt;</span> <span>(</span><span>WORD_LEN</span> <span>-</span> <span>(</span><span>word_pixel_coord</span><span>.</span><span>x</span> <span>/</span> <span>8</span><span>));</span>
</span></span><span><span><span>// Map fragment coordinate to pixel coordinate inside character bitmap</span>
</span></span><span><span><span>uvec2</span> <span>glyph_pixel_coord</span> <span>=</span> <span>uvec2</span><span>(</span><span>word_pixel_coord</span><span>.</span><span>x</span> <span>%</span> <span>8</span><span>,</span> <span>word_pixel_coord</span><span>.</span><span>y</span><span>);</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div><p><span>glsl</span>
</p></div><figure>
<img loading="lazy" src="https://poniesandlight.co.uk/img/reflect/debug_print_text/screenshot_small_uv.png" alt="Quad visualisation of word_pixel_coord" title="Quad visualisation of word_pixel_coord"/>
<figcaption>
    A visualisation of <code>word_pixel_coord</code> (normalised)
</figcaption>
</figure>
<figure>
<img loading="lazy" src="https://poniesandlight.co.uk/img/reflect/debug_print_text/screenshot_per_char_uv.png" alt="Quad visualisation of glyph_pixel_coord" title="Quad visualisation of glyph_pixel_coord"/>
<figcaption>
    A visualisation of <code>glyph_pixel_coord</code> (normalised)
</figcaption>
</figure>
<p>Remember, to draw a character, we must look up the character in the font bitmap table, where we must find the correct bit to check based on the uv coordinate of the fragment. You will notice that in the first GLSL example above, we were only worried about the <code>.x</code> coordinate. Now, let’s focus on <code>.y</code>, so that we can draw more lines of pixels by looking up the correct line to sample from.</p>
<p>Let’s do this step by step. First, we fetch the character bitmap from our <code>font_data</code> as an <code>uvec4</code>. Then we use the <code>glyph_pixel_coord.y</code> to pick the correct one of 4 <code>uints</code> that make up the glyph. This will give us four lines of pixels.</p>
<div><div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="glsl"><span><span><span>// First, map character ASCII code to an index offset into font_data table. </span>
</span></span><span><span><span>// The first character in the font_data table is 0x20, SPACE.</span>
</span></span><span><span><span>offset</span> <span>=</span> <span>printable_character</span> <span>-</span> <span>0x20</span><span>;</span> 
</span></span><span><span><span>// Then get the bitmap for this glyph</span>
</span></span><span><span><span>uvec4</span> <span>character_bitmap</span> <span>=</span> <span>font_data</span><span>[</span><span>offset</span><span>];</span> 
</span></span><span><span><span>// Find the uint that contains one of the four lines that </span>
</span></span><span><span><span>// are touched by our pixel coordinate</span>
</span></span><span><span><span>uint</span> <span>four_lines</span> <span>=</span> <span>character_bitmap</span><span>[</span><span>glyph_pixel_coord</span><span>.</span><span>y</span> <span>/</span> <span>4</span><span>];</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div><p><span>glsl</span>
</p></div><p>Once we have the <code>uint</code> covering four lines, we must pick the correct line from it.</p>
<p>Note that lines are stored in reverse order because after we used ImHex to lift the bitmap bytes out of the font file, we just concatenated the <code>chars</code> into <code>uint</code>. This means that our bitmap <code>uint</code>s have the wrong endianness; We want to keep it like this though, because it is much less work to just concatenate chars copied form ImHex than to manually convert endianness in a text editor.</p>

</div>
<div>
    
<div><div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="glsl"><span><span><span>uint</span> <span>current_line</span>  <span>=</span> <span>(</span><span>four_lines</span> <span>&gt;&gt;</span> <span>(</span><span>8</span><span>*</span><span>(</span><span>3</span><span>-</span><span>(</span><span>glyph_pixel_coord</span><span>.</span><span>y</span><span>)</span><span>%</span><span>4</span><span>)))</span> <span>&amp;</span> <span>0xff</span><span>;</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div><p><span>glsl</span>
</p></div><p>And, lastly, we must pick the correct bit in the bitmap. Note the <code>7-</code> – this is because bytes are stored with the most significant bit at the highest index. To map this to a left-to-right coordinate system, we must index backwards, again.</p>
<div><div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="glsl"><span><span><span>uint</span> <span>current_pixel</span> <span>=</span> <span>(</span><span>current_line</span> <span>&gt;&gt;</span> <span>(</span><span>7</span><span>-</span><span>glyph_pixel_coord</span><span>.</span><span>x</span><span>))</span> <span>&amp;</span> <span>0x01</span><span>;</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div><p><span>glsl</span>
</p></div><p>We now can use the current pixel to shade our fragment, so that if the pixel is set in the bitmap, we shade our fragment in the foreground colour, and if it is not set, shade our fragment in the background colour:</p>
<div><div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="glsl"><span><span><span>vec3</span> <span>color</span> <span>=</span> <span>mix</span><span>(</span><span>background_colour</span><span>,</span> <span>foreground_colour</span><span>,</span> <span>current_pixel</span><span>);</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div><p><span>glsl</span>
</p></div><figure>
<img loading="lazy" src="https://poniesandlight.co.uk/img/reflect/debug_print_text/screenshot_per_char_uv_overlay.png" alt="Quad visualisation" title="Quad visualisation"/>
<figcaption>
    Text printed with uv coordinates overlaid
</figcaption>
</figure>
<p>What about the fill chars that get inserted if our printable text is too short to be completely divisible by 4? We detect these in the fragment shader: In case were are about to render such a fill character, we should do absolutely nothing, not even draw the background. We can do this by testing <code>printable_character</code>, and issuing a <code>discard</code> in case the printable character is <code>\0</code>.</p>
<h2 id="a-visual-summary">A Visual Summary <a href="#a-visual-summary"></a></h2>
<p>It is said that an image is worth a thousand words. Why not have both? Here is a diagram which summarises the mapping from quad-uv space to glyph bitmap space:</p>
</div>
<figure>
<img src="https://poniesandlight.co.uk/img/reflect/debug_print_text/summary.svg" loading="lazy"/>
<figcaption>
	    <p>Note: Our Fragment position is marked by the blue speck.</p>
</figcaption>
</figure>
<div>
<h2 id="full-implementation--more-source-code">Full Implementation &amp; More Source Code <a href="#full-implementation--more-source-code"></a></h2>
<figure>
<img loading="lazy" src="https://poniesandlight.co.uk/img/island_preview.png" alt="Island preview image" title="Island preview image"/>
<figcaption>
    You can find an implementation of the technique described above in the source code for <a href="https://github.com/tgfrerer/island/tree/wip/modules/le_debug_print_text">le_print_debug_print_text</a>, which is a new <a href="https://poniesandlight.co.uk/tags/island/">Island</a> module that allows you to easily print debug messages to screen. It has some extra nice bits around text processing and caching which, however, would be too wordy to describe here.
</figcaption>
</figure>
<p>Using this technique, it is now possible, from nearly anywhere in an Island project, to call:</p>
<div><div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="cpp"><span><span><span>char</span> <span>const</span> <span>msg_2</span><span>[]</span> <span>=</span> <span>{</span> <span>70</span><span>,</span> <span>111</span><span>,</span> <span>108</span><span>,</span> <span>107</span><span>,</span> <span>115</span><span>,</span> <span>&#39;!&#39;</span><span>,</span> <span>0</span> <span>};</span>
</span></span><span><span><span>le</span><span>::</span><span>DebugPrint</span><span>(</span> <span>&#34;That&#39;s all, %s&#34;</span><span>,</span> <span>msg_2</span> <span>);</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div><p><span>cpp</span>
</p></div><p>And see the following result on screen:

</p><figure>
<img loading="lazy" src="https://poniesandlight.co.uk/img/reflect/debug_print_text/that_s_all_folks.png" alt="Image That&amp;rsquo;s all Folks"/>
</figure>
<h2 id="acknowledgements">Acknowledgements <a href="#acknowledgements"></a></h2>
<ul>
<li>Diagrams drawn with <a href="https://excalidraw.com">Excalidraw</a></li>
<li>Original source data for the pixel font came from <a href="http://www.fial.com/~scott/tamsyn-font/">Tamsyn</a>, a free pixel font by Scott Fial</li>
</ul>


	</div>
	
	
	
		<div>
			<h3>RSS:</h3>
			<p>Find out first about new posts by subscribing to the <a href="https://poniesandlight.co.uk//reflect/feed.xml">RSS Feed</a> <a href="https://poniesandlight.co.uk//reflect/feed.xml" type="application/rss+xml"><svg style="width: 1em; position:relative; bottom:-0.25em;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Pro 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M64 32C28.7 32 0 60.7 0 96V416c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V96c0-35.3-28.7-64-64-64H64zM96 136c0-13.3 10.7-24 24-24c137 0 248 111 248 248c0 13.3-10.7 24-24 24s-24-10.7-24-24c0-110.5-89.5-200-200-200c-13.3 0-24-10.7-24-24zm0 96c0-13.3 10.7-24 24-24c83.9 0 152 68.1 152 152c0 13.3-10.7 24-24 24s-24-10.7-24-24c0-57.4-46.6-104-104-104c-13.3 0-24-10.7-24-24zm64 120c0 17.7-14.3 32-32 32s-32-14.3-32-32s14.3-32 32-32s32 14.3 32 32z"></path></svg></a></p>
		</div>
	
		<p>
			<h3>Further Posts:</h3>
		</p>
		
        </div></div>
  </body>
</html>
