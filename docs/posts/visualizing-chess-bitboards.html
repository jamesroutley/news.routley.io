<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://healeycodes.com/visualizing-chess-bitboards">Original</a>
    <h1>Visualizing Chess Bitboards</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>When simulating board games on a computer, one of the challenges is keeping track of the game pieces. Bitboards are an efficient way to store game state in (usually) 64-bit integers. There are 64 positions on a chess board so we can use each bit as an on/off switch.</p><p>Let&#39;s say I want to describe a board where <code>f5</code> is occupied. For that, we can use the number <code>67108864</code>. In decimal notation, it doesn&#39;t look that much like a chessboard. In hex, we can see that there&#39;s a little more structure: <code>0x0000000004000000</code>.</p><p>For me, it starts to make more sense when representated as a binary number with 64 digits.</p><pre><div><div><p><span>0 0 0 0 0 0 0 0  I&#39;ve added a line break</span></p><p><span>0 0 0 0 0 0 0 0  after every eight numbers</span></p><p><span>0 0 0 0 0 0 0 0</span></p><p><span>0 0 0 0 0 0 0 0</span></p><p><span>0 0 0 0 0 1 0 0  looks kinda like a chessboard, right?</span></p><p><span>0 0 0 0 0 0 0 0</span></p><p><span>0 0 0 0 0 0 0 0</span></p><p><span>0 0 0 0 0 0 0 0</span></p></div></div></pre><p>We can&#39;t pack an <em>entire</em> game&#39;s state into a number (e.g. piece color, piece type, castling rights) so we use groups of numbers.</p><p>We can use <em>bitwise</em> operations on these numbers to manipulate individual bits using operators like <code>AND</code>, <code>OR</code>, <code>XOR</code>, <code>NOT</code>, and bit shifts. These operations are are among the fastest operations a CPU can perform. Bitboards are also cache-friendly since they pack data into fewer memory locations.</p><p>In order to move a piece at <code>f5</code> forwards we can shift the bitboard left by 8 bits.</p><pre><div><div><p><span>pieceOnF5 </span><span>=</span><span> </span><span>0x0000000004000000</span><span>;</span><span></span></p><p><span></span><span>// Move one rank forward (from f5 to f6)</span><span></span></p><p><span>pieceOnF5 </span><span>&lt;&lt;</span><span> </span><span>8</span><span>;</span><span> </span><span>// 0x0000000400000000</span></p></div></div></pre><p>Why 8? Well, if you picture all of a chessboard&#39;s squares lined up in one long row, moving upwards would require you to move 8 places to the left.</p><p>A mask is a bitboard used to isolate, modify, or test specific squares using bitwise operations.</p><p>An example of a mask might be the <code>A</code> file: <code>0x0101010101010101</code>. To check if there are any pieces on the <code>A</code> file, we can use bitwise <code>AND</code>.</p><pre><div><div><p><span>if</span><span> </span><span>(</span><span>pieces </span><span>&amp;</span><span> </span><span>0x0101010101010101</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>// At least one piece on the A file</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>Even though I know a little bit about bitboards, I still find them confusing and unintuitive. I&#39;m also prone to mistakes while working with them.</p><p>I&#39;ve found that visual examples (and interactive debugging tools) can be very helpful. Let&#39;s take a look at how we can generate the initial white pawn attacks.</p><p>Two numbers will probably stick out in the below example; <code>7</code> and <code>9</code>. If you picture that long row of chessboard squares I mentioned before, think about how many squares you&#39;d have to move to be diagonally forwards or backwards from your starting position.</p><div><pre><div><div><p><span>// Initial white pawn attacks</span><span></span></p><p><span></span><span>FILE_A</span><span> </span><span>=</span><span> </span><span>0x0101010101010101</span><span>;</span><span></span></p><p><span></span><span>FILE_H</span><span> </span><span>=</span><span> </span><span>0x8080808080808080</span><span>;</span><span></span></p><p><span>white_pawns </span><span>=</span><span> </span><span>0x000000000000FF00</span><span>;</span><span></span></p><p><span>attacks_left  </span><span>=</span><span> </span><span>(</span><span>white_pawns </span><span>&amp;</span><span> </span><span>~</span><span>FILE_A</span><span>)</span><span> </span><span>&lt;&lt;</span><span> </span><span>7</span><span>;</span><span></span></p><p><span>attacks_right </span><span>=</span><span> </span><span>(</span><span>white_pawns </span><span>&amp;</span><span> </span><span>~</span><span>FILE_H</span><span>)</span><span> </span><span>&lt;&lt;</span><span> </span><span>9</span><span>;</span><span></span></p><p><span>pawn_attacks  </span><span>=</span><span> attacks_left </span><span>|</span><span> attacks_right</span><span>;</span></p></div></div></pre><div><div><p><span>Binary: </span><span>00000001 00000001 00000001 00000001 00000001 00000001 00000001 00000001</span></p><p><span>Set bits: </span><span>none                            </span></p></div></div></div><p>Without bitboards, a program has to perform many more (magnitudes more!) instructions. The equivalent code, without bitwise operations, would look something like this:</p><pre><div><div><p><span>attacks </span><span>=</span><span> </span><span>[</span><span>]</span><span>;</span><span></span></p><p><span></span><span>for</span><span> </span><span>(</span><span>i </span><span>=</span><span> </span><span>0</span><span>;</span><span> i </span><span>&lt;</span><span> </span><span>64</span><span>;</span><span> i</span><span>++</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  piece </span><span>=</span><span> board</span><span>.</span><span>getPiece</span><span>(</span><span>i</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>if</span><span> </span><span>(</span><span>piece </span><span>===</span><span> </span><span>&#34;P&#34;</span><span>)</span><span> </span><span>{</span><span> </span><span>// White pawn</span><span></span></p><p><span>    </span><span>// Check left attack (forward-left)</span><span></span></p><p><span>    </span><span>if</span><span> </span><span>(</span><span>!</span><span>board</span><span>.</span><span>isOnFileA</span><span>(</span><span>i</span><span>)</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>        attacks</span><span>.</span><span>push</span><span>(</span><span>i </span><span>+</span><span> </span><span>7</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    </span><span>// Check right attack (forward-right)</span><span></span></p><p><span>    </span><span>if</span><span> </span><span>(</span><span>!</span><span>board</span><span>.</span><span>isOnFileH</span><span>(</span><span>i</span><span>)</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>        attacks</span><span>.</span><span>push</span><span>(</span><span>i </span><span>+</span><span> </span><span>9</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>And I haven&#39;t included the board class, or the data structures being operated on behind-the-scenes.</p><p>I&#39;ve got one more example where we generate a knight&#39;s attacks. We start with the position of a knight on the board (encoded in a bitboard) and calculate all the psuedo-legal knight attacks. Remember: the result is <em>also</em> a bitboard.</p><p>Inside a chess engine, we would then use more bitwise operations to see if those positions were occupied so we could evaluated the strength of each potential move.</p><p>The &#34;not file&#34; masks here are used to prevent invalid wraparounds. From <code>g5</code>, these masks stop the knight from moving to <code>l6</code> and <code>l4</code> (which aren&#39;t real squares).</p><div><pre><div><div><p><span>// Knight attacks from G5</span><span></span></p><p><span></span><span>KNIGHT_POS</span><span> </span><span>=</span><span> </span><span>0x0000000002000000</span><span>;</span><span></span></p><p><span></span><span>FILE_A</span><span> </span><span>=</span><span> </span><span>0x0101010101010101</span><span>;</span><span></span></p><p><span></span><span>FILE_H</span><span> </span><span>=</span><span> </span><span>0x8080808080808080</span><span>;</span><span></span></p><p><span></span><span>FILE_AB</span><span> </span><span>=</span><span> </span><span>FILE_A</span><span> </span><span>|</span><span> </span><span>(</span><span>FILE_A</span><span> </span><span>&lt;&lt;</span><span> </span><span>1</span><span>)</span><span>;</span><span></span></p><p><span></span><span>FILE_GH</span><span> </span><span>=</span><span> </span><span>FILE_H</span><span> </span><span>|</span><span> </span><span>(</span><span>FILE_H</span><span> </span><span>&gt;&gt;</span><span> </span><span>1</span><span>)</span><span>;</span><span></span></p><p><span>attacks </span><span>=</span><span> </span><span>(</span><span>KNIGHT_POS</span><span> </span><span>&lt;&lt;</span><span> </span><span>17</span><span> </span><span>&amp;</span><span> </span><span>~</span><span>FILE_A</span><span>)</span><span> </span><span>|</span><span></span></p><p><span>  </span><span>(</span><span>KNIGHT_POS</span><span> </span><span>&lt;&lt;</span><span> </span><span>15</span><span> </span><span>&amp;</span><span> </span><span>~</span><span>FILE_H</span><span>)</span><span> </span><span>|</span><span></span></p><p><span>  </span><span>(</span><span>KNIGHT_POS</span><span> </span><span>&lt;&lt;</span><span> </span><span>10</span><span> </span><span>&amp;</span><span> </span><span>~</span><span>FILE_AB</span><span>)</span><span> </span><span>|</span><span></span></p><p><span>  </span><span>(</span><span>KNIGHT_POS</span><span> </span><span>&lt;&lt;</span><span> </span><span>6</span><span> </span><span>&amp;</span><span> </span><span>~</span><span>FILE_GH</span><span>)</span><span> </span><span>|</span><span></span></p><p><span>  </span><span>(</span><span>KNIGHT_POS</span><span> </span><span>&gt;&gt;</span><span> </span><span>17</span><span> </span><span>&amp;</span><span> </span><span>~</span><span>FILE_H</span><span>)</span><span> </span><span>|</span><span></span></p><p><span>  </span><span>(</span><span>KNIGHT_POS</span><span> </span><span>&gt;&gt;</span><span> </span><span>15</span><span> </span><span>&amp;</span><span> </span><span>~</span><span>FILE_A</span><span>)</span><span> </span><span>|</span><span></span></p><p><span>  </span><span>(</span><span>KNIGHT_POS</span><span> </span><span>&gt;&gt;</span><span> </span><span>10</span><span> </span><span>&amp;</span><span> </span><span>~</span><span>FILE_GH</span><span>)</span><span> </span><span>|</span><span></span></p><p><span>  </span><span>(</span><span>KNIGHT_POS</span><span> </span><span>&gt;&gt;</span><span> </span><span>6</span><span> </span><span>&amp;</span><span> </span><span>~</span><span>FILE_AB</span><span>)</span><span>;</span></p></div></div></pre><div><div><p><span>Binary: </span><span>00000000 00000000 00000000 00000000 00000010 00000000 00000000 00000000</span></p><p><span>Set bits: </span><span>none                            </span></p></div></div></div><p>I hope this helps show how bitboards can be the building blocks of any kind of chess computation.</p><p>In practice, chess engines often pre-compute and store attack masks in lookup tables for even better performance, rather than calculating them on the fly like this – as well as other sophisticated techniques like <a href="https://www.chessprogramming.org/Zobrist_Hashing">zobrist hashing</a> and <a href="https://www.chessprogramming.org/Magic_Bitboards">magic bitboards</a>.</p><p>For further reading, I&#39;ve found the <a href="https://www.chessprogramming.org/Bitboards">Chess Programming Wiki</a> and the source code for <code>python-chess</code> (e.g. <a href="https://github.com/niklasf/python-chess/blob/ffa04827e325de5b4d39a67eee3528474b814285/chess/__init__.py#L875">calculating attack masks</a>) to both be very useful.</p><p>I also have an older post which serves as a gentle introduction to chess engines: <a href="https://healeycodes.com/building-my-own-chess-engine">Building My Own Chess Engine</a>.</p></div></div></div>
  </body>
</html>
