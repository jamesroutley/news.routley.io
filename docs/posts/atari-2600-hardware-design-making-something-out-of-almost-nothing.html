<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.bigmessowires.com/2023/01/11/atari-2600-hardware-design-making-something-out-of-almost-nothing/">Original</a>
    <h1>Atari 2600 hardware design: Making something out of almost nothing</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div id="attachment_8178"><p><img src="https://www.bigmessowires.com/wp-content/uploads/2023/01/atari-2600-title.png" alt="" width="800" height="253" srcset="https://www.bigmessowires.com/wp-content/uploads/2023/01/atari-2600-title.png 1600w, https://www.bigmessowires.com/wp-content/uploads/2023/01/atari-2600-title-300x95.png 300w, https://www.bigmessowires.com/wp-content/uploads/2023/01/atari-2600-title-768x243.png 768w, https://www.bigmessowires.com/wp-content/uploads/2023/01/atari-2600-title-1024x324.png 1024w, https://www.bigmessowires.com/wp-content/uploads/2023/01/atari-2600-title-900x285.png 900w" sizes="(max-width: 800px) 100vw, 800px"/></p><p>Atari Combat, 1977</p></div>
<p>The Atari 2600 wasn’t the first home video game console with replaceable games, but it was the first to be widely successful. Introduced in 1977 as the <em>Atari VCS</em> (Video Computer System), and later renamed <em>Atari 2600</em> in 1982, it eventually sold over 30 million units and established a new market that still endures today in the PlayStation and Xbox. Prior to the 2600, most video game systems were either coin-operated machines found in bars, or fixed-function devices limited to a few built-in games like Pong. Atari’s first home system was the beginning of a new age.</p>
<p>This wood-grained block of electronics preoccupied my young mind. I wanted one badly, but never succeeded at convincing my parents. I was eleven years old in 1982 when my friend Fred got an Atari, and I was sick with jealousy:</p>
<div id="attachment_8172"><p><img src="https://www.bigmessowires.com/wp-content/uploads/2023/01/IMG_2897.jpg" alt="" width="600" height="504" srcset="https://www.bigmessowires.com/wp-content/uploads/2023/01/IMG_2897.jpg 1600w, https://www.bigmessowires.com/wp-content/uploads/2023/01/IMG_2897-300x252.jpg 300w, https://www.bigmessowires.com/wp-content/uploads/2023/01/IMG_2897-768x645.jpg 768w, https://www.bigmessowires.com/wp-content/uploads/2023/01/IMG_2897-1024x860.jpg 1024w, https://www.bigmessowires.com/wp-content/uploads/2023/01/IMG_2897-900x756.jpg 900w" sizes="(max-width: 600px) 100vw, 600px"/></p><p>December 16 1982, arrival of Ataria (sic)</p></div>
<p>What a day! Not only did Fred get an Atari system, but I got braces <em>and</em> an Izod Lacoste alligator shirt.</p>

<p>Recently over the holiday break, I became interested in the 2600’s hardware architecture and started reading everything that I could find about it. I knew that it was some kind of 6502-based system, and I’d heard mentions of “racing the beam”, but that’s as far as my knowledge went. I was shocked to discover how primitive the 2600 hardware was, even compared to contemporary 6502 systems like the Apple II, Commodore PET, and even Atari’s own 8-bit computers.</p>
<p>Inside that wood-grained box there were only three digital chips:</p>
<ul>
<li>6507 CPU (pin-reduced version of the 6502)</li>
<li>6532 RIOT</li>
<li>TIA (Atari custom IC)</li>
</ul>
<p>Notably absent from this list was any RAM or ROM! The ROM came from whatever game cartridge was inserted – there was absolutely no built-in I/O helper routines or operating system, so it was up to the game programmer to provide everything. Game cartridges were limited to 4 KB and many early games were only 2 KB. Any of the photos on this page are vastly bigger than that.</p>
<div id="attachment_8177"><p><img src="https://www.bigmessowires.com/wp-content/uploads/2023/01/EI8HiNZWkAIT57B.jpg" alt="" width="800" height="528" srcset="https://www.bigmessowires.com/wp-content/uploads/2023/01/EI8HiNZWkAIT57B.jpg 1193w, https://www.bigmessowires.com/wp-content/uploads/2023/01/EI8HiNZWkAIT57B-300x198.jpg 300w, https://www.bigmessowires.com/wp-content/uploads/2023/01/EI8HiNZWkAIT57B-768x507.jpg 768w, https://www.bigmessowires.com/wp-content/uploads/2023/01/EI8HiNZWkAIT57B-1024x676.jpg 1024w, https://www.bigmessowires.com/wp-content/uploads/2023/01/EI8HiNZWkAIT57B-900x594.jpg 900w" sizes="(max-width: 800px) 100vw, 800px"/></p><p>early version of Atari VCS circuit board</p></div>
<p>RAM was limited to the tiny amount of storage space built-into the 6532 RIOT chip – just 128 bytes. 128 bytes! That is… I don’t even… that is small. Like really, really small. I might have guessed 1 KB or 2 KB RAM, but 128 bytes is just in another category entirely. What’s worse, this tiny amount of RAM had to serve as both the scratchpad/heap and as the stack! Programmers got a few bytes for things like player and item locations, strength, score, and that’s all.</p>
<p>But hold on, because it was even worse than you think. This pin-reduced 6507 eliminated the 6502’s NMI and IRQ pins, so there was no hardware interrupt capability at all. Everything had to be accomplished with software timing and polling. For a real-time system built around the concept of racing the beam, this was just masochism.</p>
<p>And for the final kick in the nuts, there was no framebuffer. There wasn’t even a line buffer. The programmer only had a few TIA registers to play with and nothing more. Most graphics had to be generated by the CPU on the fly, at the very moment that the television’s electron beam was scanning past the pixels of interest. Even the VSYNC signal for the television had to be handled in software. With hardware like this, I’m surprised the Atari 2600 didn’t require a coal-fired steam engine or a wooden crank handle to boot the games! It’s crazy. I love it.</p>

<p>The heart of the 2600 is Atari’s custom-designed TIA chip – the Television Interface Adapter. You can find the <a href="http://www.atariage.com/2600/archives/schematics_tia/index.html">hand-drawn TIA schematics</a> on the web if you’re curious how it works. The TIA internals look very strange to modern eyes, beginning with the extensive use of linear feedback shift registers where you would expect to find binary counters, for things like the horizontal sync counter or the sprite position registers. I’ve seen LFSRs used as random number generators in other 8-bit designs, but never as a general-purpose counter. These LFSRs also use two separate clocks, 180 degrees out of phase, which seems equally strange. Here’s the six bit horizontal sync counter:</p>
<p><img src="https://www.bigmessowires.com/wp-content/uploads/2023/01/TIA_1A_400dpi_1.jpg" alt="" width="800" height="335" srcset="https://www.bigmessowires.com/wp-content/uploads/2023/01/TIA_1A_400dpi_1.jpg 1600w, https://www.bigmessowires.com/wp-content/uploads/2023/01/TIA_1A_400dpi_1-300x125.jpg 300w, https://www.bigmessowires.com/wp-content/uploads/2023/01/TIA_1A_400dpi_1-768x321.jpg 768w, https://www.bigmessowires.com/wp-content/uploads/2023/01/TIA_1A_400dpi_1-1024x428.jpg 1024w, https://www.bigmessowires.com/wp-content/uploads/2023/01/TIA_1A_400dpi_1-900x376.jpg 900w" sizes="(max-width: 800px) 100vw, 800px"/></p>
<p>The chip designers must have had their reasons: maybe LFSRs were cheaper to implement or required fewer transistors than regular binary counters? If you just need a six bit counter, then ultimately it doesn’t really matter if it counts 64 states from 000000 sequentially up to 111111, or if it follows some other random-looking but deterministic sequence of states. Either way you can add logic to check for the terminal state and reset the counter when needed. If anyone has an idea why the TIA’s designers used LFSRs for this stuff, I’d love to hear about it. Fortunately the Atari 2600 programmer is mostly insulated from this LFSR funny business.</p>
<p>So how do games actually draw stuff? The simplest place to begin is with what Atari calls the playfield, and is effectively a background pattern on the screen. The TIA has 20 bits of register state which the programmer can modify, and which is used to create a one-dimensional low-resolution monochrome bitmap on the left half of the scan line. The right half of the line is either a copy of the left, or a mirrored copy. Want something completely different on the right side? Too bad. Want multiple colors? Too bad. The same 20 bits of playfield register state are used on every horizontal scan line, too. Want to display something different on each line? That requires constantly modifying the playfield registers, before each new scan line is drawn. There are only 76 CPU clock cycles during each scan line, and with most CPU instructions requiring 2 to 5 clock cycles, that doesn’t leave much time to do… basically anything.</p>
<p>This playfield behavior explains why so many Atari games have left-right symmetry in their backgrounds, walls, or similar content. Look at this image of <em>Pitfall</em>, and notice how the tree canopy, tree trunks, ground, pit, and underground cave all show left-right symmetry. These are all built from the playfield (plus additional tricks to be described later). The only sprites are Pitfall Harry, the vine he’s swinging from, the rolling log, and the scorpion.</p>
<p><img src="https://www.bigmessowires.com/wp-content/uploads/2023/01/pitfall-alt.png" alt="" width="800" height="517" srcset="https://www.bigmessowires.com/wp-content/uploads/2023/01/pitfall-alt.png 1916w, https://www.bigmessowires.com/wp-content/uploads/2023/01/pitfall-alt-300x194.png 300w, https://www.bigmessowires.com/wp-content/uploads/2023/01/pitfall-alt-768x496.png 768w, https://www.bigmessowires.com/wp-content/uploads/2023/01/pitfall-alt-1024x662.png 1024w, https://www.bigmessowires.com/wp-content/uploads/2023/01/pitfall-alt-900x582.png 900w" sizes="(max-width: 800px) 100vw, 800px"/></p>
<p>What about those sprites? Atari called them players and missiles, but the concept is the same. Players are sprites eight bits wide, and the pixels are smaller than playfield pixels. They can be positioned anywhere on the scan line, but like the playfield, they’re one-dimensional monochrome bitmaps. If the programmer wants 2D sprites (which they certainly do), then the code must constantly modify the player graphics register, updating it before each new scan line is drawn, including setting the register to zero for the areas above and below the player sprite where nothing should be drawn. Does that sound incredibly tedious? You bet! </p>
<p>Missiles are only one bit wide instead of eight, but are otherwise identical to players. The TIA provides two players, two missiles, and a ball that’s like a third missile. If the programmer wants more sprites than this, or wants multi-colored sprites, or anything else that the hardware doesn’t provide, then they’ll need to get fancy by combining multiple players and missiles, or else make lots of precisely-timed updates to the TIA registers to create the illusion of additional sprites and colors.</p>
<p>One common technique was to design games with distinct horizontal bands of activity, like <em>Pitfall</em> here. That allowed the same player sprite to be reused multiple times as the screen was painted from top to bottom. For <em>Pitfall</em>, player 0 might first be used to draw a score digit at the top of the screen. Then the same player 0 hardware resource would be used to draw part of Pitfall Harry, then to draw the rolling log, and finally to draw the scorpion. Since none of these overlapped each other horizontally, there was no conflict as long as the software could update the player graphics and position quickly between scan lines.</p>

<p>Under a one-dimensional hardware system like this one, collision detection would have been extremely difficult if it were left up to the software to provide. The necessary degree of bookkeeping would be too much: checking all the sprites and the playfield for collisions with each other would be virtually impossible with only 76 clock cycles per scan line, on top of all the CPU’s other critical tasks. Fortunately the TIA provides the very cool feature of hardware collision detection, at the pixel level! Any time a non-zero pixel overlaps another non-zero pixel of the playfield, a player, a missile, or the ball, a corresponding collision bit is set in the TIA, which software can later check and clear. With a total of six graphics objects there are (6*5)/2 = 15 possible collisions (an application of the <a href="https://owlcation.com/stem/How-Many-Handshakes-are-Needed-for-a-Room-Ful-of-People">Handshake Problem</a>) to be tracked by the TIA. Nice!</p>
<p>Horizontal positioning of players and missiles is notoriously difficult. Most programmers would expect that the TIA has registers to specify the horizontal position of each sprite, but no. That would be too easy. On the Atari 2600, the horizontal position of a player or missile is set by writing to a special TIA register <em>at the exact moment the electron beam passes the desired position</em>. Think about that for a minute. The specific value that’s written to the register doesn’t matter. The program isn’t telling the TIA “put player 0 at position X”, it’s telling the TIA “put player 0 at… (wait for it) RIGHT HERE!” Thanks to this design, horizontal positioning requires synchronizing a software loop to the start of a scan line, delaying some amount of time dependent on the desired horizontal position, and then writing to the TIA register. Rather than setting a specific value for the horizontal position, the software is actually resetting one of those LFSRs in the TIA. </p>
<p>With the standard technique for this timing-based horizontal positioning, it’s only possible to get a horizontal resolution of five CPU clock cycles, which is equivalent to 15 pixels. To help the programmer get fine-grained control, the TIA provides additional registers that enable each sprite to be adjusted between -8 to +7 pixels from its ordinary position. It’s clumsy, but the combination of timing-based positioning plus fine-grained adjustments enable sprites to be positioned at any horizontal coordinate.</p>
<p>The fine-grained horizontal control involves writing to a TIA register named HMOVE, and its use leads to one of the Atari 2600’s most notorious graphical flaws: an irregular series of black lines on the left side of the screen, obscuring part of the playfield. This is often called the HMOVE comb. Here’s an example from <em>Space Invaders</em>:</p>
<p><img src="https://www.bigmessowires.com/wp-content/uploads/2023/01/space-invaders-1.png" alt="" width="800" height="497" srcset="https://www.bigmessowires.com/wp-content/uploads/2023/01/space-invaders-1.png 1919w, https://www.bigmessowires.com/wp-content/uploads/2023/01/space-invaders-1-300x187.png 300w, https://www.bigmessowires.com/wp-content/uploads/2023/01/space-invaders-1-768x477.png 768w, https://www.bigmessowires.com/wp-content/uploads/2023/01/space-invaders-1-1024x637.png 1024w, https://www.bigmessowires.com/wp-content/uploads/2023/01/space-invaders-1-900x560.png 900w" sizes="(max-width: 800px) 100vw, 800px"/></p>
<p>This is a side-effect of the way the TIA performs fine-grained adjustment of sprite positions, and many games exhibit this problem. Any time HMOVE is written to during a scan line, the horizontal blanking interval will be extended by eight pixels on that line, cutting off the left edge of the line. Is it a bug? An unintended feature? The exact details are much too complex to describe here, but Andrew Towers has written a very thorough explanation of TIA behavior which you’ll find at <a href="http://www.atarihq.com/danb/files/TIA_HW_Notes.txt">http://www.atarihq.com/danb/files/TIA_HW_Notes.txt</a>. See the heading <em>Playing with the HMOVE Registers</em>.</p>
<p>Why do only some games display this HMOVE comb effect, and others apparently don’t? It only appears when games reuse the same sprite at different vertical positions on the screen, which requires adjusting the sprite’s horizontal position mid-frame. <em>Space Invaders</em> does this extensively, but simple games like <em>Combat</em> don’t do this. <em>Combat</em> is limited to the two built-in players and two built-in missiles, with no mid-frame repositioning, and therefore no HMOVE comb. </p>
<p><em>Pitfall</em> takes a different approach, with a solid black bar at the left edge of the screen instead of a comb. This is the result of writing to HMOVE on <em>every</em> scan line, even when it’s not needed. Activision used this technique in many games, apparently having concluded that a solid black bar looked nicer than a partial black comb.</p>
<p>There are many more software tricks necessary for creating a high-quality Atari game. A non-symmetrical playfield or multi-colored playfield can be created by modifying the playfield graphics and color registers at precisely the right times, but it’s not easy! Color registers can also be modified between lines, to provide more total colors on the screen even when the number of colors on a single line is limited. Sprites can be reused and repositioned at different vertical positions, or can even be reused at the same vertical position with careful timing and attention to TIA behavior. Atari 2600 programming is a very deep topic, and it’s a long journey from bouncing ball demos to a high-quality game like <em>Pitfall</em>.</p>

<p>Want to try your hand at writing some Atari game demos? Yes you do, and it’s much easier today than it was in 1977. Start with this <a href="https://cdn.hackaday.io/files/1646277043401568/Atari_2600_Programming_for_Newbies_Revised_Edition.pdf">Atari 2600 Programming for Newbies</a> tutorial written by Andrew Davies. Software is written in 6502 assembly language, and if you’re reading this blog, then there’s a good chance you already know it. To assemble your software, use <a href="https://dasm-assembler.github.io/">DASM</a>, a venerable and feature-filled cross-platform assembler for the 6502 and other 8-bit CPUs. If you’ve got a real Atari 2600 console, you can write your assembled program’s binary image to an EPROM and <a href="https://www.8bitclassics.com/product/atari-2600-2k4k-pc-board/">make your own game cartridge</a>. If that sounds like too much bother, try the <a href="https://www.whimsey.com/z26/">Z26</a> or <a href="https://stella-emu.github.io/">Stella</a> software emulators.   </p>
<p>Did I butcher some technical explanation here, or omit important details? Please let me know! I’m just a beginner on this Atari hardware journey, with much still to learn. Look for my first 2600 game, coming soon?</p>
      
<p><a href="https://www.bigmessowires.com/2023/01/11/atari-2600-hardware-design-making-something-out-of-almost-nothing/#comments">Read 20 comments and join the conversation</a>       
    </p></div></div>
  </body>
</html>
