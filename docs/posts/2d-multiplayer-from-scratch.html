<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://healeycodes.com/2d-multiplayer-from-scratch">Original</a>
    <h1>2D Multiplayer From Scratch</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>I recently built a game prototype for a 2D arena shooter. Here are my notes on some of the patterns I used and the design of the server and client systems.</p><p>The gameplay: players move their characters around a level, shooting bullets at other players. You gain points for hitting other players and lose points for getting hit. You can play it on desktop <a href="https://dm-multiplayer.fly.dev/">here</a>, and view the source code <a href="https://github.com/healeycodes/dm-multiplayer">on GitHub</a>.</p><p>The core problems are managing game objects, client/server synchronization, and drawing the game objects in the browser.</p><p>As game development projects go, the tools I used are quite high up the stack: a garbage-collected language and a web browser to run the client (but no game engine or other libraries).</p><p>The implementation time was roughly 4-5hrs over a few days. Not perfect code, but I think the separate parts fit together quite well.</p><h2 id="managing-game-objects">Managing Game Objects</h2><p>Everything in my game (characters, bullets, and walls) is a game object. These game objects all implement an <a href="https://github.com/healeycodes/dm-multiplayer/blob/feb1d99eda03313a35100be22078a1c6af37a416/main.go#L200"><code>Entity</code> interface</a> which allows them to be represented in the game state and eventually rendered for the player.</p><p>Using this interface, all game objects can be treated generically during the game loop during which the objects change position, collide, or stop existing.</p><p>A game has a level, and a level has entities.</p><pre><div><div><p><span>type</span><span> Level </span><span>struct</span><span> </span><span>{</span><span></span></p><p><span>    width    </span><span>int</span><span></span></p><p><span>    height   </span><span>int</span><span></span></p><p><span>    entities EntityList</span></p><p><span></span><span>}</span></p></div></div></pre><p>When a player connects to the game, a new character object is added to the list of entities.</p><p>Since the game is like a never ending deathmatch, players appear in the middle of the action. Choosing where to place them in the level takes a bit of thinking.</p><p>We don&#39;t want to place them inside another character (they would both be stuck), in a wall (they&#39;d be stuck), or on top of a bullet (seems a bit unfair).</p><p>The character object is randomly placed, and a collision check is performed. If it&#39;s inside another object, another random position is checked, and then we repeat. To avoid blocking the game loop, these retries have a short timeout before a backoff wait.</p><pre><div><div><p><span>func</span><span> </span><span>(</span><span>el </span><span>*</span><span>EntityList</span><span>)</span><span> </span><span>SpawnEntity</span><span>(</span><span>level </span><span>*</span><span>Level</span><span>,</span><span> entity Entity</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    el</span><span>.</span><span>mu</span><span>.</span><span>Lock</span><span>(</span><span>)</span><span></span></p><p><span>    </span><span>defer</span><span> el</span><span>.</span><span>mu</span><span>.</span><span>Unlock</span><span>(</span><span>)</span><span></span></p><p><span>    startTime </span><span>:=</span><span> time</span><span>.</span><span>Now</span><span>(</span><span>)</span><span></span></p><p><span>    </span><span>for</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>// Generate random position within level bounds</span><span></span></p><p><span>        x </span><span>:=</span><span> rand</span><span>.</span><span>Float64</span><span>(</span><span>)</span><span> </span><span>*</span><span> </span><span>float64</span><span>(</span><span>level</span><span>.</span><span>width</span><span>-</span><span>entity</span><span>.</span><span>Width</span><span>(</span><span>)</span><span>)</span><span></span></p><p><span>        y </span><span>:=</span><span> rand</span><span>.</span><span>Float64</span><span>(</span><span>)</span><span> </span><span>*</span><span> </span><span>float64</span><span>(</span><span>level</span><span>.</span><span>height</span><span>-</span><span>entity</span><span>.</span><span>Height</span><span>(</span><span>)</span><span>)</span><span></span></p><p><span>        entity</span><span>.</span><span>SetPosition</span><span>(</span><span>x</span><span>,</span><span> y</span><span>)</span><span></span></p><p><span>        </span><span>// Check for intersection with existing entities</span><span></span></p><p><span>        intersects </span><span>:=</span><span> </span><span>false</span><span></span></p><p><span>        </span><span>for</span><span> </span><span>_</span><span>,</span><span> other </span><span>:=</span><span> </span><span>range</span><span> el</span><span>.</span><span>entities </span><span>{</span><span></span></p><p><span>            </span><span>if</span><span> entity</span><span>.</span><span>Id</span><span>(</span><span>)</span><span> </span><span>!=</span><span> other</span><span>.</span><span>Id</span><span>(</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>                top</span><span>,</span><span> right</span><span>,</span><span> bottom</span><span>,</span><span> left </span><span>:=</span><span> other</span><span>.</span><span>BoundingBox</span><span>(</span><span>)</span><span></span></p><p><span>                entTop</span><span>,</span><span> entRight</span><span>,</span><span> entBottom</span><span>,</span><span> entLeft </span><span>:=</span><span> entity</span><span>.</span><span>BoundingBox</span><span>(</span><span>)</span><span></span></p><p><span>                </span><span>if</span><span> entLeft </span><span>&lt;</span><span> right </span><span>&amp;&amp;</span><span> entRight </span><span>&gt;</span><span> left </span><span>&amp;&amp;</span><span> entTop </span><span>&lt;</span><span> bottom </span><span>&amp;&amp;</span><span> entBottom </span><span>&gt;</span><span> top </span><span>{</span><span></span></p><p><span>                    intersects </span><span>=</span><span> </span><span>true</span><span></span></p><p><span>                    </span><span>break</span><span></span></p><p><span>                </span><span>}</span><span></span></p><p><span>            </span><span>}</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>        </span><span>if</span><span> </span><span>!</span><span>intersects </span><span>{</span><span></span></p><p><span>            </span><span>// Place the entity if no intersection</span><span></span></p><p><span>            el</span><span>.</span><span>entities </span><span>=</span><span> </span><span>append</span><span>(</span><span>el</span><span>.</span><span>entities</span><span>,</span><span> entity</span><span>)</span><span></span></p><p><span>            </span><span>return</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>        </span><span>// Check if 5ms has passed</span><span></span></p><p><span>        </span><span>if</span><span> time</span><span>.</span><span>Since</span><span>(</span><span>startTime</span><span>)</span><span> </span><span>&gt;</span><span> </span><span>5</span><span>*</span><span>time</span><span>.</span><span>Millisecond </span><span>{</span><span></span></p><p><span>            </span><span>// Unlock and wait for 100ms before trying again</span><span></span></p><p><span>            el</span><span>.</span><span>mu</span><span>.</span><span>Unlock</span><span>(</span><span>)</span><span></span></p><p><span>            time</span><span>.</span><span>Sleep</span><span>(</span><span>100</span><span> </span><span>*</span><span> time</span><span>.</span><span>Millisecond</span><span>)</span><span></span></p><p><span>            el</span><span>.</span><span>mu</span><span>.</span><span>Lock</span><span>(</span><span>)</span><span></span></p><p><span>            startTime </span><span>=</span><span> time</span><span>.</span><span>Now</span><span>(</span><span>)</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>This kind of collision checking (for every object, check for a collision with every other object) is a naive approach. It has quadratic time complexity, but it&#39;s the simplest to implement. Performance is not a concern here, as the number of game objects is bounded (&lt;100) and each collision check has a cost on the order of nanoseconds.</p><p>Now that the character object is part of the game, it can be affected by the game loop.</p><p>The Game Programming Patterns book has <a href="https://gameprogrammingpatterns.com/game-loop.html">an entire chapter</a> on game loops. It starts by succinctly describing the intent of this pattern:</p><blockquote><p>Decouple the progression of game time from user input and processor speed.</p></blockquote><p>My game loop iterates over every entity, applies velocity to position, and performs a collision check. This check can trigger the <code>HandleCollision(*Level, Entity) CollisionResult</code> function of the <code>Entity</code> interface.</p><p>Let&#39;s take a look at the mighty game loop in action then.</p><pre><div><div><p><span>func</span><span> </span><span>(</span><span>level </span><span>*</span><span>Level</span><span>)</span><span> </span><span>loop</span><span>(</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    level</span><span>.</span><span>entities</span><span>.</span><span>Iterate</span><span>(</span><span>func</span><span>(</span><span>entity Entity</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>// Apply velocity to position</span><span></span></p><p><span>        newX </span><span>:=</span><span> entity</span><span>.</span><span>X</span><span>(</span><span>)</span><span> </span><span>+</span><span> entity</span><span>.</span><span>VelocityX</span><span>(</span><span>)</span><span></span></p><p><span>        newY </span><span>:=</span><span> entity</span><span>.</span><span>Y</span><span>(</span><span>)</span><span> </span><span>+</span><span> entity</span><span>.</span><span>VelocityY</span><span>(</span><span>)</span><span></span></p><p><span>        </span><span>// Collision checks</span><span></span></p><p><span>        blocked </span><span>:=</span><span> </span><span>false</span><span></span></p><p><span>        level</span><span>.</span><span>entities</span><span>.</span><span>Iterate</span><span>(</span><span>func</span><span>(</span><span>other Entity</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>            </span><span>if</span><span> entity</span><span>.</span><span>Id</span><span>(</span><span>)</span><span> </span><span>!=</span><span> other</span><span>.</span><span>Id</span><span>(</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>                top</span><span>,</span><span> right</span><span>,</span><span> bottom</span><span>,</span><span> left </span><span>:=</span><span> other</span><span>.</span><span>BoundingBox</span><span>(</span><span>)</span><span></span></p><p><span>                </span><span>if</span><span> newX </span><span>&lt;</span><span> right </span><span>&amp;&amp;</span><span> newX</span><span>+</span><span>float64</span><span>(</span><span>entity</span><span>.</span><span>Width</span><span>(</span><span>)</span><span>)</span><span> </span><span>&gt;</span><span> left </span><span>&amp;&amp;</span><span></span></p><p><span>                    newY </span><span>&lt;</span><span> bottom </span><span>&amp;&amp;</span><span> newY</span><span>+</span><span>float64</span><span>(</span><span>entity</span><span>.</span><span>Height</span><span>(</span><span>)</span><span>)</span><span> </span><span>&gt;</span><span> top </span><span>{</span><span></span></p><p><span>                    blocked </span><span>=</span><span> blocked </span><span>||</span><span> entity</span><span>.</span><span>HandleCollision</span><span>(</span><span>level</span><span>,</span><span> other</span><span>)</span><span>.</span><span>Blocked</span></p><p><span>                </span><span>}</span><span></span></p><p><span>            </span><span>}</span><span></span></p><p><span>        </span><span>}</span><span>)</span><span></span></p><p><span>        </span><span>if</span><span> </span><span>!</span><span>blocked </span><span>{</span><span></span></p><p><span>            entity</span><span>.</span><span>SetPosition</span><span>(</span><span>newX</span><span>,</span><span> newY</span><span>)</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>        </span><span>// Apply friction</span><span></span></p><p><span>        entity</span><span>.</span><span>SetVelocity</span><span>(</span><span>entity</span><span>.</span><span>VelocityX</span><span>(</span><span>)</span><span>*</span><span>entity</span><span>.</span><span>Friction</span><span>(</span><span>)</span><span>,</span><span> entity</span><span>.</span><span>VelocityY</span><span>(</span><span>)</span><span>*</span><span>entity</span><span>.</span><span>Friction</span><span>(</span><span>)</span><span>)</span><span></span></p><p><span>    </span><span>}</span><span>)</span><span></span></p><p><span>    </span><span>// When bullets collide,</span><span></span></p><p><span>    </span><span>// they set themselves to inactive</span><span></span></p><p><span>    </span><span>// and they&#39;re cleared up here</span><span></span></p><p><span>    level</span><span>.</span><span>entities</span><span>.</span><span>RemoveInactive</span><span>(</span><span>)</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>We can also take a look at the character object&#39;s collision handler. Here we&#39;re making sure that characters and walls can&#39;t overlap.</p><pre><div><div><p><span>func</span><span> </span><span>(</span><span>c </span><span>*</span><span>Character</span><span>)</span><span> </span><span>HandleCollision</span><span>(</span><span>level </span><span>*</span><span>Level</span><span>,</span><span> entity Entity</span><span>)</span><span> CollisionResult </span><span>{</span><span></span></p><p><span>    </span><span>if</span><span> entity</span><span>.</span><span>Type</span><span>(</span><span>)</span><span> </span><span>==</span><span> CharacterType </span><span>||</span><span> entity</span><span>.</span><span>Type</span><span>(</span><span>)</span><span> </span><span>==</span><span> WallType </span><span>{</span><span></span></p><p><span>        </span><span>return</span><span> CollisionResult</span><span>{</span><span></span></p><p><span>            Blocked</span><span>:</span><span> </span><span>true</span><span>,</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    </span><span>return</span><span> CollisionResult</span><span>{</span><span></span></p><p><span>        Blocked</span><span>:</span><span> </span><span>false</span><span>,</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>When players join or leave the game, it doesn&#39;t cause the game loop to move forward — it drives itself. Even things like player input and bullet spawning happen outside the game loop. Even things like player input and bullet spawning happens outside the game loop. For the prototype, I found that this separation made the flow of game time easier to reason about.</p><h2 id="clientserver-synchronization">Client/Server Synchronization</h2><p>Players join the game by visiting a web page that connects them to the server via WebSocket. This HTML page is served by the game server as an embedded file. The main function is practically:</p><pre><div><div><p><span>func</span><span> </span><span>main</span><span>(</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    level </span><span>:=</span><span> </span><span>&amp;</span><span>Level</span><span>{</span><span></span></p><p><span>        width</span><span>:</span><span>  </span><span>800</span><span>,</span><span></span></p><p><span>        height</span><span>:</span><span> </span><span>800</span><span>,</span><span></span></p><p><span>        entities</span><span>:</span><span> EntityList</span><span>{</span><span></span></p><p><span>            mu</span><span>:</span><span>       sync</span><span>.</span><span>RWMutex</span><span>{</span><span>}</span><span>,</span><span></span></p><p><span>            entities</span><span>:</span><span> </span><span>[</span><span>]</span><span>Entity</span><span>{</span><span>}</span><span>,</span><span></span></p><p><span>        </span><span>}</span><span>,</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    game </span><span>:=</span><span> </span><span>&amp;</span><span>Game</span><span>{</span><span>id</span><span>:</span><span> </span><span>&#34;test&#34;</span><span>,</span><span> level</span><span>:</span><span> level</span><span>}</span><span></span></p><p><span>    </span><span>go</span><span> </span><span>gameLoop</span><span>(</span><span>game</span><span>)</span><span></span></p><p><span>    http</span><span>.</span><span>Handle</span><span>(</span><span>&#34;/&#34;</span><span>,</span><span> http</span><span>.</span><span>FileServer</span><span>(</span><span>http</span><span>.</span><span>FS</span><span>(</span><span>indexHTML</span><span>)</span><span>)</span><span>)</span><span></span></p><p><span>    http</span><span>.</span><span>HandleFunc</span><span>(</span><span>&#34;/ws&#34;</span><span>,</span><span> handleConnections</span><span>)</span><span></span></p><p><span>    http</span><span>.</span><span>ListenAndServe</span><span>(</span><span>&#34;:8080&#34;</span><span>,</span><span> </span><span>nil</span><span>)</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>When a WebSocket connects, the handler on the server reads the control message containing the game id and player name, and then a character object is created.</p><p>Right after this, two long-lived goroutines run. One sends the serialized game objects to the client 60 times per second. The other listens for messages from the client (direction and shoot events).</p><p>When a direction event arrives, the character object&#39;s velocity is altered. When a shoot event arrives, a bullet object is created inside the character with a fixed direction (pointing towards where the player clicked). These changes cause effects during the next tick of the game loop.</p><p>My prototype doesn&#39;t handle reconnection so the character lives as long as the WebSocket is active. When there&#39;s a read or write error on the socket, the long-lived goroutines spawned by the player&#39;s connection are killed, and the character object is removed from the entity list.</p><p>The client is a 150 line <code>index.html</code> file (vanilla JavaScript, no build step, etc). It connects to the game server, receives updates 60 times a second, and draws game objects using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API">Canvas API</a>.</p><p>An update is a JSON-encoded list of game objects, kinda like a whole-world snapshot. It arrives as a socket event.</p><pre><div><div><p><span>socket</span><span>.</span><span>onopen</span><span> </span><span>=</span><span> </span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>const</span><span> name </span><span>=</span><span> </span><span>getLocationName</span><span>(</span><span>)</span><span></span></p><p><span>  </span><span>// When this arrives on the server</span><span></span></p><p><span>  </span><span>// a character game object is created and spawned</span><span></span></p><p><span>  socket</span><span>.</span><span>send</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>{</span><span> </span><span>game</span><span>:</span><span> </span><span>&#39;test&#39;</span><span>,</span><span> name </span><span>}</span><span>)</span><span>)</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span>socket</span><span>.</span><span>onmessage</span><span> </span><span>=</span><span> </span><span>(</span><span>event</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span></p><p><span>  gameLevel </span><span>=</span><span> </span><span>JSON</span><span>.</span><span>parse</span><span>(</span><span>event</span><span>.</span><span>data</span><span>)</span><span></span></p><p><span>  </span><span>// Without a smooth connection, there will be jitter</span><span></span></p><p><span>  </span><span>// similar to a FPS game, good internet is required.</span><span></span></p><p><span>  </span><span>// This prototype has no client smoothing or prediction</span><span></span></p><p><span>  </span><span>draw</span><span>(</span><span>)</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>As I reflect on my prototype code now, I&#39;ve decided that the following code that handles shoot events is <em>wonderful</em>. The player clicked somewhere on the canvas? They&#39;re taking a shot. Let the server know. Easy.</p><pre><div><div><p><span>window</span><span>.</span><span>addEventListener</span><span>(</span><span>&#39;click&#39;</span><span>,</span><span> </span><span>(</span><span>event</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>const</span><span> rect </span><span>=</span><span> canvas</span><span>.</span><span>getBoundingClientRect</span><span>(</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>const</span><span> x </span><span>=</span><span> event</span><span>.</span><span>clientX</span><span> </span><span>-</span><span> rect</span><span>.</span><span>left</span><span>;</span><span></span></p><p><span>  </span><span>const</span><span> y </span><span>=</span><span> event</span><span>.</span><span>clientY</span><span> </span><span>-</span><span> rect</span><span>.</span><span>top</span><span>;</span><span></span></p><p><span>  </span><span>const</span><span> shoot </span><span>=</span><span> </span><span>{</span><span> x</span><span>,</span><span> y </span><span>}</span><span></span></p><p><span>  socket</span><span>.</span><span>send</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>{</span><span> </span><span>type</span><span>:</span><span> </span><span>&#39;shoot&#39;</span><span>,</span><span> shoot </span><span>}</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span></span><span>}</span><span>)</span></p></div></div></pre><p>The keyboard input handling – I&#39;m a bit less happy with.</p><p>Players control their character with arrow keys or W/A/S/D. When they press a key down, an update is sent to the server with the current direction (which may be e.g. <em>left</em> or <em>left+up</em>). To continue moving, players can hold down that key, in which case, direction events are send every half-frame (~8ms) to the server.</p><p>When a player lets go of a key, events may stop being sent to the server (if there was a single key being pressed e.g. <em>left</em>), or the event might continue firing with a new direction (<em>left+up</em> just becomes <em>up</em>).</p><p>This direction event is converted to an (x, y) value, and the server multiplies it by a constant speed to set the character&#39;s velocity.</p><p>Here&#39;s all the keyboard listening code:</p><pre><div><div><p><span>const</span><span> keyState </span><span>=</span><span> </span><span>{</span><span>}</span><span>;</span><span></span></p><p><span></span><span>let</span><span> intervalId </span><span>=</span><span> </span><span>null</span><span>;</span><span></span></p><p><span></span><span>window</span><span>.</span><span>addEventListener</span><span>(</span><span>&#39;keydown&#39;</span><span>,</span><span> </span><span>(</span><span>event</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>// Avoid input delay by sending this ASAP</span><span></span></p><p><span>  </span><span>sendDirection</span><span>(</span><span>)</span><span>;</span><span> </span></p><p><span>  keyState</span><span>[</span><span>event</span><span>.</span><span>key</span><span>]</span><span> </span><span>=</span><span> </span><span>true</span><span>;</span><span></span></p><p><span>  </span><span>if</span><span> </span><span>(</span><span>!</span><span>intervalId</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>      </span><span>// Handle player holding down the key</span><span></span></p><p><span>      intervalId </span><span>=</span><span> </span><span>setInterval</span><span>(</span><span>sendDirection</span><span>,</span><span> </span><span>8</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span></span><span>}</span><span>)</span><span>;</span><span></span></p><p><span></span><span>window</span><span>.</span><span>addEventListener</span><span>(</span><span>&#39;keyup&#39;</span><span>,</span><span> </span><span>(</span><span>event</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span></p><p><span>  keyState</span><span>[</span><span>event</span><span>.</span><span>key</span><span>]</span><span> </span><span>=</span><span> </span><span>false</span><span>;</span><span></span></p><p><span>  </span><span>// If no keys are pressed stop sending updates</span><span></span></p><p><span>  </span><span>if</span><span> </span><span>(</span><span>!</span><span>Object</span><span>.</span><span>values</span><span>(</span><span>keyState</span><span>)</span><span>.</span><span>includes</span><span>(</span><span>true</span><span>)</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>      </span><span>clearInterval</span><span>(</span><span>intervalId</span><span>)</span><span>;</span><span></span></p><p><span>      intervalId </span><span>=</span><span> </span><span>null</span><span>;</span><span></span></p><p><span>      </span><span>// Send one last update to stop movement</span><span></span></p><p><span>      </span><span>sendDirection</span><span>(</span><span>)</span><span>;</span><span> </span></p><p><span>  </span><span>}</span><span></span></p><p><span></span><span>}</span><span>)</span><span>;</span><span></span></p><p><span></span><span>function</span><span> </span><span>sendDirection</span><span>(</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>const</span><span> direction </span><span>=</span><span> </span><span>{</span><span> </span><span>x</span><span>:</span><span> </span><span>0</span><span>,</span><span> </span><span>y</span><span>:</span><span> </span><span>0</span><span> </span><span>}</span><span>;</span><span></span></p><p><span>  </span><span>if</span><span> </span><span>(</span><span>keyState</span><span>[</span><span>&#39;w&#39;</span><span>]</span><span> </span><span>||</span><span> keyState</span><span>[</span><span>&#39;ArrowUp&#39;</span><span>]</span><span>)</span><span> direction</span><span>.</span><span>y</span><span> </span><span>-=</span><span> </span><span>1</span><span>;</span><span></span></p><p><span>  </span><span>if</span><span> </span><span>(</span><span>keyState</span><span>[</span><span>&#39;a&#39;</span><span>]</span><span> </span><span>||</span><span> keyState</span><span>[</span><span>&#39;ArrowLeft&#39;</span><span>]</span><span>)</span><span> direction</span><span>.</span><span>x</span><span> </span><span>-=</span><span> </span><span>1</span><span>;</span><span></span></p><p><span>  </span><span>if</span><span> </span><span>(</span><span>keyState</span><span>[</span><span>&#39;s&#39;</span><span>]</span><span> </span><span>||</span><span> keyState</span><span>[</span><span>&#39;ArrowDown&#39;</span><span>]</span><span>)</span><span> direction</span><span>.</span><span>y</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span><span></span></p><p><span>  </span><span>if</span><span> </span><span>(</span><span>keyState</span><span>[</span><span>&#39;d&#39;</span><span>]</span><span> </span><span>||</span><span> keyState</span><span>[</span><span>&#39;ArrowRight&#39;</span><span>]</span><span>)</span><span> direction</span><span>.</span><span>x</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span><span></span></p><p><span>  socket</span><span>.</span><span>send</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>{</span><span> </span><span>type</span><span>:</span><span> </span><span>&#39;direction&#39;</span><span>,</span><span> direction </span><span>}</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>This kinda &#34;polling update&#34; is how game engines like the Source Engine handle movement updates. It&#39;s great for real-time responsiveness but can lead to extra data being sent.</p><p>For my prototype, I think the code is more complex than necessary. The same responsiveness could probably be achieved by just sending the key up/down event and tracking it on the server without a polling event.</p><h2 id="drawing-game-objects">Drawing Game Objects</h2><p>The art style of the prototype is... the lack of an art style. the lack of an art style. The art is just black and red rectangles. Bordered for the player&#39;s character and bullets, solid for other players and their bullets. When a character is hit, they briefly turn red to register the hit.</p><p>The draw function is triggered whenever a new update arrives at the client (60 times per second).</p><pre><div><div><p><span>function</span><span> </span><span>draw</span><span>(</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>// Clear screen</span><span></span></p><p><span>  ctx</span><span>.</span><span>clearRect</span><span>(</span><span>0</span><span>,</span><span> </span><span>0</span><span>,</span><span> canvas</span><span>.</span><span>width</span><span>,</span><span> canvas</span><span>.</span><span>height</span><span>)</span><span>;</span><span></span></p><p><span>  gameLevel</span><span>.</span><span>entities</span><span>.</span><span>forEach</span><span>(</span><span>entity</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span></p><p><span>      </span><span>if</span><span> </span><span>(</span><span>entity</span><span>.</span><span>you</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>// Check for recent hit</span><span></span></p><p><span>        ctx</span><span>.</span><span>strokeStyle</span><span> </span><span>=</span><span> entity</span><span>.</span><span>lastHit</span><span> </span><span>+</span><span> </span><span>250</span><span> </span><span>&gt;</span><span> gameLevel</span><span>.</span><span>timeMs</span><span> </span><span>?</span><span> </span><span>&#39;red&#39;</span><span> </span><span>:</span><span> </span><span>&#39;black&#39;</span><span>;</span><span></span></p><p><span>        ctx</span><span>.</span><span>lineWidth</span><span> </span><span>=</span><span> </span><span>1</span><span>;</span><span></span></p><p><span>        </span><span>const</span><span> borderWidth </span><span>=</span><span> </span><span>1</span><span>;</span><span></span></p><p><span>        </span><span>// Draw player&#39;s character</span><span></span></p><p><span>        ctx</span><span>.</span><span>strokeRect</span><span>(</span><span></span></p><p><span>          entity</span><span>.</span><span>x</span><span> </span><span>+</span><span> borderWidth </span><span>/</span><span> </span><span>2</span><span>,</span><span></span></p><p><span>          entity</span><span>.</span><span>y</span><span> </span><span>+</span><span> borderWidth </span><span>/</span><span> </span><span>2</span><span>,</span><span></span></p><p><span>          entity</span><span>.</span><span>width</span><span> </span><span>-</span><span> borderWidth</span><span>,</span><span></span></p><p><span>          entity</span><span>.</span><span>height</span><span> </span><span>-</span><span> borderWidth</span></p><p><span>        </span><span>)</span><span>;</span><span></span></p><p><span>      </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>// Check for recent hit</span><span></span></p><p><span>        ctx</span><span>.</span><span>fillStyle</span><span> </span><span>=</span><span> entity</span><span>.</span><span>lastHit</span><span> </span><span>+</span><span> </span><span>250</span><span> </span><span>&gt;</span><span> gameLevel</span><span>.</span><span>timeMs</span><span> </span><span>?</span><span> </span><span>&#39;red&#39;</span><span> </span><span>:</span><span> </span><span>&#39;black&#39;</span><span>;</span><span></span></p><p><span>        </span><span>// Draw other character</span><span></span></p><p><span>        ctx</span><span>.</span><span>fillRect</span><span>(</span><span>entity</span><span>.</span><span>x</span><span>,</span><span> entity</span><span>.</span><span>y</span><span>,</span><span> entity</span><span>.</span><span>width</span><span>,</span><span> entity</span><span>.</span><span>height</span><span>)</span><span>;</span><span></span></p><p><span>      </span><span>}</span><span></span></p><p><span>  </span><span>}</span><span>)</span><span>;</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>Tying the visuals to the server updates requires users to have good internet to avoid jitter. This is similar to FPS games, except FPS games usually display player movements and actions before they are registered on the server. For my prototype, I don&#39;t have any <a href="https://en.wikipedia.org/wiki/Client-side_prediction">client-side prediction</a> to hide the negative effects of high latency.</p><p>For the game to feel responsive, you must be in the same region as the server — if you are, it feels very responsive.</p><h2 id="reflections">Reflections</h2><p>I&#39;ve been trying to get better at iterating on quick game prototypes that I can playtest with my friends (mostly because it&#39;s a lot of fun). I learned a few things with this project that I&#39;m definitely going to apply in the future.</p><p>I found the two types of client→server WebSocket message easy to work with. A control message to connect the player, and then follow up events with a <code>type</code> field. Having a separate goroutines running for each player (one to send updates, one to receive and process events) allowed me to manage less state. Some of my initial ideas that I discarded involved tracking all the connections in a structure and then looping over them.</p><p>Having the server handle as much state as possible made it quicker to get to a stage where I could start iterating. In the beginning, I didn&#39;t have a client, I just logged the game state as an ASCII grid to debug the game objects.</p><p>One thing I found tricky is that the list of entities is read and mutated from different goroutines. I had some crashes early on relating to concurrent access. I fixed the crashes by adding a read/write lock to the EntityList struct. The <code>Iterate</code> method has a read lock, and the <code>Spawn</code> and <code>Remove</code> methods have write locks.</p><p>Oh and people really liked having their name set to city + flag. Initially, I was going to use random names or let players pick their names but allowing people to jump right in and start shooting was way more fun and my friends could identify each other by their cities.</p><p>As for where I&#39;m taking this project next, I&#39;m not sure. My friends enjoyed spam shooting at each other and dodging bullets. I think the netcode is better than the average browser game which helps.</p><p>I&#39;ll either start implementing features (new guns, configurable characters, and weapons!) or research game algorithms like improved collision detection and write about that.</p></div></div></div>
  </body>
</html>
