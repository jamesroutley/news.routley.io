<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bernsteinbear.com/blog/toy-tbaa/?utm_source=rss">Original</a>
    <h1>Type-based alias analysis in the Toy Optimizer</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p><em>Another entry in the <a href="https://pypy.org/categories/toy-optimizer.html">Toy Optimizer series</a></em>.</p>

<p>Last time, we did <a href="https://bernsteinbear.com/blog/toy-load-store/">load-store forwarding</a> in the context
of our Toy Optimizer. We managed to cache the results of both reads from and
writes to the heap—at compile-time!</p>

<p>We were careful to mind object aliasing: we separated our heap information into
alias classes based on what offset the reads/writes referenced. This way, if we
didn’t know if object <code>a</code> and <code>b</code> aliased, we could at least know that
different offsets would never alias (assuming our objects don’t overlap and
memory accesses are on word-sized slots). This is a coarse-grained heuristic.</p>

<p>Fortunately, we often have much more information available at compile-time than
just the offset, so we should use it. I mentioned in a footnote that we could
use type information, for example, to improve our alias analysis. We’ll add
a lightweight form of <a href="https://bernsteinbear.com/assets/img/tbaa.pdf">type-based alias analysis (TBAA)</a>
(PDF) in this post.</p>

<h2 id="representing-types">Representing types</h2>

<p>We return once again to Fil Pizlo land, specifically <a href="https://gist.github.com/pizlonator/cf1e72b8600b1437dda8153ea3fdb963">How I implement SSA
form</a>.
We’re going to be using the hierarchical heap effect representation from the
post in our implementation, but you can use your own type representation if you
have one already.</p>

<p>This representation divides the heap into disjoint regions by type. Consider,
for example, that <code>Array</code> objects and <code>String</code> objects do not overlap. A
<code>LinkedList</code> pointer is never going to alias an <code>Integer</code> pointer. They can
therefore be reasoned about separately.</p>

<p>But sometimes you don’t have perfect type information available. If you have in
your language an <code>Object</code> base class of all objects, then the <code>Object</code> heap
overlaps with, say, the <code>Array</code> heap. So you need some way to represent that
too—just having an enum doesn’t work cleanly.</p>

<p>Here is an example simplified type hierarchy:</p>

<div><div><pre><code>Any
  Object
    Array
    String
  Other
</code></pre></div></div>

<p>Where <code>Other</code> might represent different parts of the runtime’s data structures,
and could be further segmented into <code>GC</code>, <code>Thread</code>, etc.</p>

<p>Fil’s idea is that we can represent each node in that hierarchy with a tuple of
integers <code>[start, end)</code> (inclusive, exclusive) that represent the pre- and
post-order traversals of the tree. Or, if tree traversals are not engraved into
your bones, they represent the range of all the nested objects within them.</p>

<div><div><pre><code>Any [0, 3)
  Object [0, 2)
    Array [0, 1)
    String [1, 2)
  Other [2, 3)
</code></pre></div></div>

<p>Then the “does this write interfere with this read” check—the aliasing
check—is a range overlap query.</p>

<p>Here’s a perhaps over-engineered Python implementation of the range and heap
hierarchy based on the Ruby generator and C++ runtime code from JavaScriptCore:</p>

<div><div><pre><code><span>class</span> <span>HeapRange</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>start</span><span>:</span> <span>int</span><span>,</span> <span>end</span><span>:</span> <span>int</span><span>)</span> <span>-&gt;</span> <span>None</span><span>:</span>
        <span>self</span><span>.</span><span>start</span> <span>=</span> <span>start</span>
        <span>self</span><span>.</span><span>end</span> <span>=</span> <span>end</span>

    <span>def</span> <span>__repr__</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>str</span><span>:</span>
        <span>return</span> <span>f</span><span>&#34;[</span><span>{</span><span>self</span><span>.</span><span>start</span><span>}</span><span>, </span><span>{</span><span>self</span><span>.</span><span>end</span><span>}</span><span>)&#34;</span>

    <span>def</span> <span>is_empty</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>bool</span><span>:</span>
        <span>return</span> <span>self</span><span>.</span><span>start</span> <span>==</span> <span>self</span><span>.</span><span>end</span>

    <span>def</span> <span>overlaps</span><span>(</span><span>self</span><span>,</span> <span>other</span><span>:</span> <span>&#34;HeapRange&#34;</span><span>)</span> <span>-&gt;</span> <span>bool</span><span>:</span>
        <span># Empty ranges interfere with nothing
</span>        <span>if</span> <span>self</span><span>.</span><span>is_empty</span><span>()</span> <span>or</span> <span>other</span><span>.</span><span>is_empty</span><span>():</span>
            <span>return</span> <span>False</span>
        <span>return</span> <span>self</span><span>.</span><span>end</span> <span>&gt;</span> <span>other</span><span>.</span><span>start</span> <span>and</span> <span>other</span><span>.</span><span>end</span> <span>&gt;</span> <span>self</span><span>.</span><span>start</span>


<span>class</span> <span>AbstractHeap</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>name</span><span>:</span> <span>str</span><span>)</span> <span>-&gt;</span> <span>None</span><span>:</span>
        <span>self</span><span>.</span><span>name</span> <span>=</span> <span>name</span>
        <span>self</span><span>.</span><span>parent</span> <span>=</span> <span>None</span>
        <span>self</span><span>.</span><span>children</span> <span>=</span> <span>[]</span>
        <span>self</span><span>.</span><span>range</span> <span>=</span> <span>None</span>

    <span>def</span> <span>add_child</span><span>(</span><span>self</span><span>,</span> <span>name</span><span>:</span> <span>str</span><span>)</span> <span>-&gt;</span> <span>None</span><span>:</span>
        <span>result</span> <span>=</span> <span>AbstractHeap</span><span>(</span><span>name</span><span>)</span>
        <span>result</span><span>.</span><span>parent</span> <span>=</span> <span>self</span>
        <span>self</span><span>.</span><span>children</span><span>.</span><span>append</span><span>(</span><span>result</span><span>)</span>
        <span>return</span> <span>result</span>

    <span>def</span> <span>compute</span><span>(</span><span>self</span><span>,</span> <span>start</span><span>:</span> <span>int</span><span>)</span> <span>-&gt;</span> <span>None</span><span>:</span>
        <span>current</span> <span>=</span> <span>start</span>
        <span>if</span> <span>not</span> <span>self</span><span>.</span><span>children</span><span>:</span>
            <span>self</span><span>.</span><span>range</span> <span>=</span> <span>HeapRange</span><span>(</span><span>start</span><span>,</span> <span>current</span> <span>+</span> <span>1</span><span>)</span>
            <span>return</span>
        <span>for</span> <span>child</span> <span>in</span> <span>self</span><span>.</span><span>children</span><span>:</span>
            <span>child</span><span>.</span><span>compute</span><span>(</span><span>current</span><span>)</span>
            <span>current</span> <span>=</span> <span>child</span><span>.</span><span>range</span><span>.</span><span>end</span>
        <span>self</span><span>.</span><span>range</span> <span>=</span> <span>HeapRange</span><span>(</span><span>start</span><span>,</span> <span>current</span><span>)</span>


<span>Any</span> <span>=</span> <span>AbstractHeap</span><span>(</span><span>&#34;Any&#34;</span><span>)</span>
<span>Object</span> <span>=</span> <span>Any</span><span>.</span><span>add_child</span><span>(</span><span>&#34;Object&#34;</span><span>)</span>
<span>Array</span> <span>=</span> <span>Object</span><span>.</span><span>add_child</span><span>(</span><span>&#34;Array&#34;</span><span>)</span>
<span>String</span> <span>=</span> <span>Object</span><span>.</span><span>add_child</span><span>(</span><span>&#34;String&#34;</span><span>)</span>
<span>Other</span> <span>=</span> <span>Any</span><span>.</span><span>add_child</span><span>(</span><span>&#34;Other&#34;</span><span>)</span>
<span>Any</span><span>.</span><span>compute</span><span>(</span><span>0</span><span>)</span>
</code></pre></div></div>

<p>Where <code>Any.compute(0)</code> kicks off the tree-numbering scheme.</p>

<p>Fil’s implementation also covers a bunch of abstract heaps such as SSAState and
Control because his is used for code motion and whatnot. That can be added on
later but we will not do so in this post.</p>

<p>So there you have it: a type representation. Now we need to use it in our
load-store forwarding.</p>

<h2 id="load-store-forwarding">Load-store forwarding</h2>

<p>Recall that our load-store optimization pass looks like this:</p>

<div><div><pre><code><span>def</span> <span>optimize_load_store</span><span>(</span><span>bb</span><span>:</span> <span>Block</span><span>):</span>
    <span>opt_bb</span> <span>=</span> <span>Block</span><span>()</span>
    <span># Stores things we know about the heap at... compile-time.
</span>    <span># Key: an object and an offset pair acting as a heap address
</span>    <span># Value: a previous SSA value we know exists at that address
</span>    <span>compile_time_heap</span><span>:</span> <span>Dict</span><span>[</span><span>Tuple</span><span>[</span><span>Value</span><span>,</span> <span>int</span><span>],</span> <span>Value</span><span>]</span> <span>=</span> <span>{}</span>
    <span>for</span> <span>op</span> <span>in</span> <span>bb</span><span>:</span>
        <span>if</span> <span>op</span><span>.</span><span>name</span> <span>==</span> <span>&#34;store&#34;</span><span>:</span>
            <span>obj</span> <span>=</span> <span>op</span><span>.</span><span>arg</span><span>(</span><span>0</span><span>)</span>
            <span>offset</span> <span>=</span> <span>get_num</span><span>(</span><span>op</span><span>,</span> <span>1</span><span>)</span>
            <span>store_info</span> <span>=</span> <span>(</span><span>obj</span><span>,</span> <span>offset</span><span>)</span>
            <span>current_value</span> <span>=</span> <span>compile_time_heap</span><span>.</span><span>get</span><span>(</span><span>store_info</span><span>)</span>
            <span>new_value</span> <span>=</span> <span>op</span><span>.</span><span>arg</span><span>(</span><span>2</span><span>)</span>
            <span>if</span> <span>eq_value</span><span>(</span><span>current_value</span><span>,</span> <span>new_value</span><span>):</span>
                <span>continue</span>
            <span>compile_time_heap</span> <span>=</span> <span>{</span>
                <span>load_info</span><span>:</span> <span>value</span>
                <span>for</span> <span>load_info</span><span>,</span> <span>value</span> <span>in</span> <span>compile_time_heap</span><span>.</span><span>items</span><span>()</span>
                <span>if</span> <span>load_info</span><span>[</span><span>1</span><span>]</span> <span>!=</span> <span>offset</span>
            <span>}</span>
            <span>compile_time_heap</span><span>[</span><span>store_info</span><span>]</span> <span>=</span> <span>new_value</span>
        <span>elif</span> <span>op</span><span>.</span><span>name</span> <span>==</span> <span>&#34;load&#34;</span><span>:</span>
            <span>load_info</span> <span>=</span> <span>(</span><span>op</span><span>.</span><span>arg</span><span>(</span><span>0</span><span>),</span> <span>get_num</span><span>(</span><span>op</span><span>,</span> <span>1</span><span>))</span>
            <span>if</span> <span>load_info</span> <span>in</span> <span>compile_time_heap</span><span>:</span>
                <span>op</span><span>.</span><span>make_equal_to</span><span>(</span><span>compile_time_heap</span><span>[</span><span>load_info</span><span>])</span>
                <span>continue</span>
            <span>compile_time_heap</span><span>[</span><span>load_info</span><span>]</span> <span>=</span> <span>op</span>
        <span>opt_bb</span><span>.</span><span>append</span><span>(</span><span>op</span><span>)</span>
    <span>return</span> <span>opt_bb</span>
</code></pre></div></div>

<p>At its core, it iterates over the instructions, keeping a representation of the
heap at compile-time. Reads get cached, writes get cached, and writes also
invalidate the state of compile-time information about fields that may alias.</p>

<p>In this case, our <em>may alias</em> asks only if the offsets overlap. This means that
the following unit test will fail:</p>

<div><div><pre><code><span>def</span> <span>test_store_to_same_offset_different_heaps_does_not_invalidate_load</span><span>():</span>
    <span>bb</span> <span>=</span> <span>Block</span><span>()</span>
    <span>var0</span> <span>=</span> <span>bb</span><span>.</span><span>getarg</span><span>(</span><span>0</span><span>)</span>
    <span>var0</span><span>.</span><span>info</span> <span>=</span> <span>Array</span>
    <span>var1</span> <span>=</span> <span>bb</span><span>.</span><span>getarg</span><span>(</span><span>1</span><span>)</span>
    <span>var1</span><span>.</span><span>info</span> <span>=</span> <span>String</span>
    <span>var2</span> <span>=</span> <span>bb</span><span>.</span><span>store</span><span>(</span><span>var0</span><span>,</span> <span>0</span><span>,</span> <span>3</span><span>)</span>
    <span>var3</span> <span>=</span> <span>bb</span><span>.</span><span>store</span><span>(</span><span>var1</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span>
    <span>var4</span> <span>=</span> <span>bb</span><span>.</span><span>load</span><span>(</span><span>var0</span><span>,</span> <span>0</span><span>)</span>
    <span>bb</span><span>.</span><span>escape</span><span>(</span><span>var4</span><span>)</span>
    <span>opt_bb</span> <span>=</span> <span>optimize_load_store</span><span>(</span><span>bb</span><span>)</span>
    <span>assert</span> <span>(</span>
        <span>bb_to_str</span><span>(</span><span>opt_bb</span><span>)</span>
        <span>==</span> <span>&#34;&#34;&#34;</span><span>\
</span><span>var0 = getarg(0)
var1 = getarg(1)
var2 = store(var0, 0, 3)
var3 = store(var1, 0, 4)
var4 = escape(3)&#34;&#34;&#34;</span>
    <span>)</span>
</code></pre></div></div>

<p>This test is expecting the write to <code>var0</code> to still remain cached even though
we wrote to the same offset in <code>var1</code>—because we have annotated <code>var0</code> as
being an <code>Array</code> and <code>var1</code> as being a <code>String</code>. If we account for type
information in our alias analysis, we can get this test to pass.</p>

<p>After doing a bunch of fussing around with the load-store forwarding (many
rewrites), I eventually got it down to a very short diff:</p>

<div><div><pre><code><span>+def may_alias(left: Value, right: Value) -&gt; bool:
+    return (left.info or Any).range.overlaps((right.info or Any).range)
+
+
</span> def optimize_load_store(bb: Block):
     opt_bb = Block()
     # Stores things we know about the heap at... compile-time.
<span>@@ -138,6 +210,10 @@</span> def optimize_load_store(bb: Block):
                 load_info: value
                 for load_info, value in compile_time_heap.items()
                 if load_info[1] != offset
<span>+                or not may_alias(load_info[0], obj)
</span>             }
             compile_time_heap[store_info] = new_value
</code></pre></div></div>

<p>If we don’t have any type/alias information, we default to “I know nothing”
(<code>Any</code>) for each object. Then we check range overlap.</p>

<p>The boolean logic in <code>optimize_load_store</code> looks a little weird, maybe. But we
can also rewrite (via DeMorgan’s law) as:</p>

<div><div><pre><code><span>{</span>
    <span>...</span> <span>for</span> <span>...</span>
    <span>if</span> <span>not</span> <span>(</span><span>load_info</span><span>[</span><span>1</span><span>]</span> <span>==</span> <span>offset</span>
            <span>and</span> <span>may_alias</span><span>(</span><span>load_info</span><span>[</span><span>0</span><span>],</span> <span>obj</span><span>))</span>
<span>}</span>
</code></pre></div></div>

<p>So, keeping all the cached field state about fields that are known by offset
and by type not to alias. Maybe that is clearer (but not as nice a diff).</p>

<blockquote>
  <p>Note that the type representation is not so important here! You could use a
bitset version of the type information if you want. The important things are
that you can cheaply construct types and check overlap between them.</p>
</blockquote>

<!--
Note that we do not currently have a notion of "must-alias" other than if two
SSA values are equal. Therefore we can't make use of writes to object A for
loads from object B even if A and B must alias.
-->

<p>Nice, now our test passes! We can differentiate between memory accesses on
objects of different types.</p>

<p>But what if we knew more?</p>

<h2 id="object-provenance--allocation-site">Object provenance / allocation site</h2>

<p>Sometimes we know where an object came from. For example, we may have seen it
get allocated in the trace. If we saw an object’s allocation, we know that it
does not alias (for example) any object that was passed in via a parameter. We
can use this kind of information to our advantage.</p>

<p>For example, in the following made up IR snippet:</p>

<div><div><pre><code>trace(arg0):
  v0 = malloc(8)
  v1 = malloc(16)
  ...
</code></pre></div></div>

<p>We know that (among other facts) <code>v0</code> doesn’t alias <code>arg0</code> or <code>v1</code> because we
have seen its allocation site.</p>

<p>I saw this in the old V8 IR Hydrogen’s lightweight alias analysis<sup id="fnref:fork" role="doc-noteref"><a href="#fn:fork" rel="footnote">1</a></sup>:</p>

<div><div><pre><code><span>enum</span> <span>HAliasing</span> <span>{</span>
  <span>kMustAlias</span><span>,</span>
  <span>kMayAlias</span><span>,</span>
  <span>kNoAlias</span>
<span>};</span>

<span>HAliasing</span> <span>Query</span><span>(</span><span>HValue</span><span>*</span> <span>a</span><span>,</span> <span>HValue</span><span>*</span> <span>b</span><span>)</span> <span>{</span>
  <span>// The same SSA value always references the same object.</span>
  <span>if</span> <span>(</span><span>a</span> <span>==</span> <span>b</span><span>)</span> <span>return</span> <span>kMustAlias</span><span>;</span>

  <span>if</span> <span>(</span><span>a</span><span>-&gt;</span><span>IsAllocate</span><span>()</span> <span>||</span> <span>a</span><span>-&gt;</span><span>IsInnerAllocatedObject</span><span>())</span> <span>{</span>
    <span>// Two non-identical allocations can never be aliases.</span>
    <span>if</span> <span>(</span><span>b</span><span>-&gt;</span><span>IsAllocate</span><span>())</span> <span>return</span> <span>kNoAlias</span><span>;</span>
    <span>if</span> <span>(</span><span>b</span><span>-&gt;</span><span>IsInnerAllocatedObject</span><span>())</span> <span>return</span> <span>kNoAlias</span><span>;</span>
    <span>// An allocation can never alias a parameter or a constant.</span>
    <span>if</span> <span>(</span><span>b</span><span>-&gt;</span><span>IsParameter</span><span>())</span> <span>return</span> <span>kNoAlias</span><span>;</span>
    <span>if</span> <span>(</span><span>b</span><span>-&gt;</span><span>IsConstant</span><span>())</span> <span>return</span> <span>kNoAlias</span><span>;</span>
  <span>}</span>
  <span>if</span> <span>(</span><span>b</span><span>-&gt;</span><span>IsAllocate</span><span>()</span> <span>||</span> <span>b</span><span>-&gt;</span><span>IsInnerAllocatedObject</span><span>())</span> <span>{</span>
    <span>// An allocation can never alias a parameter or a constant.</span>
    <span>if</span> <span>(</span><span>a</span><span>-&gt;</span><span>IsParameter</span><span>())</span> <span>return</span> <span>kNoAlias</span><span>;</span>
    <span>if</span> <span>(</span><span>a</span><span>-&gt;</span><span>IsConstant</span><span>())</span> <span>return</span> <span>kNoAlias</span><span>;</span>
  <span>}</span>

  <span>// Constant objects can be distinguished statically.</span>
  <span>if</span> <span>(</span><span>a</span><span>-&gt;</span><span>IsConstant</span><span>()</span> <span>&amp;&amp;</span> <span>b</span><span>-&gt;</span><span>IsConstant</span><span>())</span> <span>{</span>
    <span>return</span> <span>a</span><span>-&gt;</span><span>Equals</span><span>(</span><span>b</span><span>)</span> <span>?</span> <span>kMustAlias</span> <span>:</span> <span>kNoAlias</span><span>;</span>
  <span>}</span>
  <span>return</span> <span>kMayAlias</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>There is plenty of other useful information such as:</p>

<ul>
  <li>If we know at compile-time that object A has 5 at offset 0 and object B has 7
at offset 0, then A and B don’t alias (thanks, CF)
    <ul>
      <li>In the RPython JIT in PyPy, this is used to determine if two user (Python)
objects don’t alias because we know the contents of the user (Python) class
field</li>
    </ul>
  </li>
  <li>Object size (though perhaps that is a special case of the above bullet)</li>
  <li>Field size/type</li>
  <li>Deferring alias checks to run-time
    <ul>
      <li>Have a branch <code>if (a == b) { ... } else { ... }</code></li>
    </ul>
  </li>
  <li>…</li>
</ul>

<p>If you have other fun ones, please write in.</p>

<h2 id="interacting-with-other-instructions">Interacting with other instructions</h2>

<p>We only handle loads and stores in our optimizer. Unfortunately, this means we
may accidentally cache stale information. Consider: what happens if a function
call (or any other opaque instruction) writes into an object we are tracking?</p>

<p>The conservative approach is to invalidate all cached information on a function
call. This is definitely correct, but it’s a bummer for the optimizer. Can we
do anything?</p>

<p>Well, perhaps we are calling a well-known function or a specific IR
instruction. In that case, we can annotate it with effects in the same abstract
heap model: if the instruction does not write, or only writes to some heaps, we
can at least only partially invalidate our heap.</p>

<div><div><pre><code><span>known_builtin_functions</span> <span>=</span> <span>{</span>
  <span>&#34;Array_length&#34;</span><span>:</span> <span>Effects</span><span>(</span><span>reads</span><span>=</span><span>Array</span><span>,</span> <span>writes</span><span>=</span><span>Empty</span><span>()),</span>
  <span>&#34;Object_setShape&#34;</span><span>:</span> <span>Effects</span><span>(</span><span>reads</span><span>=</span><span>Empty</span><span>(),</span> <span>writes</span><span>=</span><span>Object</span><span>),</span>
  <span>&#34;String_setEncoding&#34;</span><span>:</span> <span>Effects</span><span>(</span><span>reads</span><span>=</span><span>Empty</span><span>(),</span> <span>writes</span><span>=</span><span>String</span><span>),</span>
<span>}</span>
</code></pre></div></div>

<p>However, if the function is unknown or otherwise opaque, we need at least more
advanced alias information and perhaps even (partial) escape analysis.</p>

<p>Consider: even if an instruction takes no operands, we have no idea what state
it has access to. If it writes to any object A, we cannot safely cache
information about any other object B unless we know <em>for sure</em> that A and B do
not alias. And we don’t know what the instruction writes to. So we may only
know we can cache information about B because it was allocated locally and has
not escaped.</p>

<h2 id="storing-vs-computing-on-the-fly">Storing vs computing on the fly</h2>

<p>Some runtimes such as ART <a href="https://github.com/LineageOS/android_art/blob/8ce603e0c68899bdfbc9cd4c50dcc65bbf777982/compiler/optimizing/load_store_analysis.h#L395">pre-compute all of their alias information</a> in a bit
matrix. This makes more sense if you are using alias information in a full
control-flow graph, where you might need to iterate over the graph a few times.
In a trace context, you can do a lot in one single pass—no need to make a
matrix.</p>

<h2 id="when-is-this-useful-how-much">When is this useful? How much?</h2>

<p>As usual, this is a toy IR and a toy optimizer, so it’s hard to say how much
faster it makes its toy programs.</p>

<p>In general, though, there is a dial for analysis and optimization that goes
between precision and speed. This is a happy point on that dial, only a tiny
incremental analysis cost bump above offset-only invalidation, but for higher
precision. I like that tradeoff.</p>

<p>Also, it is very useful in JIT compilers where generally the managed language
is a little <a href="https://blog.regehr.org/archives/959">better-behaved than a C-like
language</a>. Somewhere in your IR there
will be a lot of duplicate loads and stores from a strength reduction pass, and
this can clean up the mess.</p>

<!--
## In other languages

Taking address of objects throws a wrench in it

Can't really do it in C, even though UB
-->

<!--
https://github.com/WebKit/WebKit/blob/main/Source/JavaScriptCore/dfg/DFGObjectAllocationSinkingPhase.cpp
-->

<h2 id="wrapping-up">Wrapping up</h2>

<p>Thanks for joining as I work through a small use of type-based alias analysis
for myself. I hope you enjoyed.</p>

<p>See also <a href="https://wingolog.org/archives/2026/02/18/two-mechanisms-for-dynamic-type-checks">two mechanisms for dynamic type
checks</a>
by Andy Wingo. CRuby uses the latter technique described in the article.</p>

<h2 id="thanks">Thanks</h2>

<p>Thank you to <a href="https://www.chrisgregory.me/">Chris Gregory</a> for helpful feedback.</p>


        </div></div>
  </body>
</html>
