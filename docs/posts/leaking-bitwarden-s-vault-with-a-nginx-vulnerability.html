<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://labs.hakaioffsec.com/nginx-alias-traversal/">Original</a>
    <h1>Leaking Bitwarden&#39;s Vault with a Nginx vulnerability</h1>
    
    <div id="readability-page-1" class="page"><section>
        <p>Nginx, a versatile web server pivotal to numerous internet infrastructures, has held a dominant market share since its inception in 2004, with widespread adoption across websites and Docker containers. This article delves into the intricacies of Nginx, focusing on the location and alias directives that are central to how Nginx handles specific URLs. We also explore potential vulnerabilities arising from misconfigurations and demonstrate how they can lead to security exploits, drawing on research presented at the BlackHat 2018 conference by Orange Tsai.</p><p>The guide further illustrates these points through a thorough examination of popular open-source repositories using GitHub Code Search to identify potential Nginx configuration vulnerabilities. Real-world case studies involving Bitwarden and Google&#39;s HPC Toolkit highlight the significant risk of data exposure if these vulnerabilities are not addressed. Additionally, we introduce NavGix, an automated tool designed to detect these vulnerabilities in a black-box manner, providing comprehensive insights into Nginx&#39;s complexities, vulnerabilities, and potential misconfigurations.</p><h2 id="brief-overview-of-nginx">Brief Overview of Nginx</h2><p>Nginx is a versatile web server that can also function as a reverse proxy, load balancer, mail proxy, and HTTP cache. The software was created and publicly released in 2004.</p><p>As per W3Tech&#39;s data, as of June 2022, Nginx holds the highest market share among web servers, with 33.6% of websites on the internet utilizing it. Additionally, according to Docker, Nginx is the most deployed technology in their containers. This significant popularity makes vulnerabilities related to Nginx all the more critical and intriguing.</p><h3 id="location-and-alias-directives">Location and Alias Directives</h3><p>The location directive is a block directive that can contain other directives and is used to define how Nginx should handle requests for specific URLs, they can be defined. </p><p>It is often used in conjunction with the alias directive to map URLs to specific file locations on the server. the directives can be defined in the <code>nginx.conf</code> file or in a separate configuration file.</p><p>The syntax for the location directive is as follows:</p><pre><code>location [modifier] /path/to/URL {
    # other directives
}</code></pre><p>The <code>modifier</code> is optional and can be one of the following:</p><ul><li><code>=</code>: Exact match</li><li><code>~</code>: Case-sensitive regular expression match</li><li><code>~*</code>: Case-insensitive regular expression match</li><li><code>^~</code>: Prefix match (stop searching if this matches)</li></ul><p>Here is an example of how to use the location directive in the <code>nginx.conf</code> file:</p><pre><code>location /assets/ { # defines a location block for requests matching /assets
    
    alias /opt/production/assets/; # maps the request to the assets folder
    
}
</code></pre><h2 id="identifying-misconfigurations">Identifying Misconfigurations</h2><p>At the BlackHat 2018 conference, Orange Tsai presented his research on breaking URL parsers. Among other impressive findings, he demonstrated a technique discovered in a 2016 CTF challenge from HCTF, created by @iaklis.</p><p>For the technique to be applicable, the following conditions must be met:</p><ul><li>The <code>location</code> directive <strong>should not</strong> have a trailing slash in its path;</li><li>An <code>alias</code>directive must be present within the location context, and it <strong>must</strong> end with a slash.</li></ul><figure><img src="https://labs.hakaioffsec.com/content/images/2023/06/alias_vuln_example.png" alt="" loading="lazy" width="1039" height="180" srcset="https://labs.hakaioffsec.com/content/images/size/w600/2023/06/alias_vuln_example.png 600w, https://labs.hakaioffsec.com/content/images/size/w1000/2023/06/alias_vuln_example.png 1000w, https://labs.hakaioffsec.com/content/images/2023/06/alias_vuln_example.png 1039w"/></figure><h3 id="achieving-impact">Achieving Impact </h3><p>In the vulnerable example above, Nginx will match any URLs that start with <code>/img</code> and serve whatever follows that slash with the alias path <code>/var/images/</code> prepended. </p><p>This implies that both a request for <code>/img/profile.jpg</code> and a request for <code>/imgprofile.jpg</code> would return the same file. Because since the alias directive ends with a trailing slash, an additional slash is not necessary after the matched location.</p><figure><img src="https://labs.hakaioffsec.com/content/images/2023/06/image-1.png" alt="" loading="lazy" width="660" height="622" srcset="https://labs.hakaioffsec.com/content/images/size/w600/2023/06/image-1.png 600w, https://labs.hakaioffsec.com/content/images/2023/06/image-1.png 660w"/></figure><p>Taking into account that we can access the target folder through any request URL starting with <code>/img</code>, we can attempt to access the ever-present <code>..</code> directory, thereby reaching the parent directory of the target directory by issuing a request to <code>/img..</code> for the given example. </p><p>If we receive a redirection response from Nginx, we can assume that Nginx has located the directory and is attempting to redirect us to <code>/img../</code>, as it commonly does when accessing a directory.</p><figure><img src="https://labs.hakaioffsec.com/content/images/2023/06/image-2.png" alt="" loading="lazy" width="445" height="283"/><figcaption>And we do!</figcaption></figure><p>Consequently, this implies that any file or child directory within the parent directory of the target folder will be accessible to us, and Nginx will readily serve them. In our lab example, this means we could access all files in the <code>/var/</code> folder, given that the target folder in the configuration is <code>/var/images/</code>. This allows us to utilize simple payloads, such as a GET to, <code>/img../log/nginx/access.log</code> to download a log file located on <code>/var/log/nginx/access.log</code>.</p><figure><img src="https://labs.hakaioffsec.com/content/images/2023/06/image-3.png" alt="" loading="lazy" width="1139" height="351" srcset="https://labs.hakaioffsec.com/content/images/size/w600/2023/06/image-3.png 600w, https://labs.hakaioffsec.com/content/images/size/w1000/2023/06/image-3.png 1000w, https://labs.hakaioffsec.com/content/images/2023/06/image-3.png 1139w" sizes="(min-width: 720px) 720px"/><figcaption>We can even see our previous tests!</figcaption></figure><p>The severity of this vulnerability can fluctuate significantly depending on the project, extending from a negligible impact to a critical one. The degree of its repercussions is primarily determined by whether the exposed directory holds sensitive data that may facilitate additional attacks or result in the disclosure of private information.</p><h3 id="achieving-impact-without-a-slash-on-alias">Achieving Impact Without a Slash on Alias</h3><figure><img src="https://labs.hakaioffsec.com/content/images/2023/06/image-5.png" alt="" loading="lazy" width="1660" height="246" srcset="https://labs.hakaioffsec.com/content/images/size/w600/2023/06/image-5.png 600w, https://labs.hakaioffsec.com/content/images/size/w1000/2023/06/image-5.png 1000w, https://labs.hakaioffsec.com/content/images/size/w1600/2023/06/image-5.png 1600w, https://labs.hakaioffsec.com/content/images/2023/06/image-5.png 1660w" sizes="(min-width: 720px) 720px"/><figcaption>Same vulnerability, but without a trailing slash on alias.</figcaption></figure><p>A question that may arise is whether this vulnerability can still be exploited without the trailing slash on the alias directive. The answer is yes, but it would mean that using traversal sequences to escape the directory would no longer be possible. This is because everything after the matched location is appended to the alias, and appending a <code>..</code> sequence to a path without a trailing slash would only result in a non-existent folder name. e.g <code>/var/images../</code></p><p>However, we can still exploit this misbehavior to access other directories that have a name starting with the target directory name. As a result, we might not be able to access it <code>/var/images/../log/</code>, but we could still access a directory Â <code>/var/images_confidential</code> by making a GET request to <code><a href="http://localhost/img_confidential?ref=labs.hakaioffsec.com">/img_confidential</a></code>. </p><p>In this case, Nginx appends <code>_confidential</code> to the <code>/var/images</code> target path, effectively serving URLs from the combined path of <code>/var/images</code> and <code>_confidential</code> which results in <code>/var/images_confidential</code>.</p><figure><img src="https://labs.hakaioffsec.com/content/images/2023/06/image-4.png" alt="" loading="lazy" width="565" height="275"/></figure><h2 id="hunting-open-source-repositories">Hunting Open-Source Repositories</h2><p>As a starting point in our search for this vulnerability, we chose to explore popular GitHub repositories that displayed this issue. Identifying this specific vulnerability in environments with access to source code becomes significantly more feasible, primarily due to two main factors:</p><ol><li>Detection: Utilizing straightforward code analysis tools, such as regular expression searches, allows us to effectively pinpoint potentially vulnerable Nginx configuration files within these projects.</li><li>Exploitation: Having knowledge of the exact target directory that has been aliased empowers us to set up a local instance, examine the aliased directories using a local shell, and determine which files can be accessed through the vulnerability.</li></ol><h5 id="github-code-search"><strong>GitHub Code Search</strong></h5><p>GitHub Code Search is a feature available on GitHub, the web-based platform for version control and collaboration using Git. This feature enables users to search for code across all public repositories hosted on the platform, making it especially useful for developers seeking examples, libraries, or solutions to specific coding challenges.</p><p>Additionally, GitHub Code Search can be employed to search for snippets of vulnerable code within popular projects. This can be accomplished through a variety of methods, such as simple string matches, regular expressions, path filters, and more. For example, to search for the Nginx Alias Traversal vulnerability, the following regular expression can be used:</p><pre><code>/location \/[_.a-zA-Z0-9-\/]*[^\/][\s]\{[\s\n]*alias \/[_.a-zA-Z0-9-\/]*\/;/</code></pre><p>Upon examining the search results for this query, it becomes evident that a significant number of repositories contain this specific vulnerability.</p><figure><img src="https://labs.hakaioffsec.com/content/images/2023/06/image-6.png" alt="" loading="lazy" width="2000" height="255" srcset="https://labs.hakaioffsec.com/content/images/size/w600/2023/06/image-6.png 600w, https://labs.hakaioffsec.com/content/images/size/w1000/2023/06/image-6.png 1000w, https://labs.hakaioffsec.com/content/images/size/w1600/2023/06/image-6.png 1600w, https://labs.hakaioffsec.com/content/images/size/w2400/2023/06/image-6.png 2400w" sizes="(min-width: 720px) 720px"/></figure><p>Due to the inherent limitations of regular expressions, they may not be ideally suited for matching code syntax. For instance, this particular regular expression will not match vulnerable configuration files containing comments between the directives. However, it serves as a starting point for our analysis.</p><h3 id="case-study-1-leaking-bitwardens-vault-logs-and-certificates">Case Study #1: Leaking Bitwarden&#39;s vault, logs, and certificates.</h3><p>Bitwarden is an open-source password manager that helps users securely store and manage their passwords, credentials, and other sensitive information. It offers features such as password generation, autofill, and synchronization across devices. Bitwarden supports various platforms, including Windows, macOS, Linux, Android, iOS, and web browsers through extensions. Users can access their data through a web vault, desktop apps, mobile apps, or browser extensions. </p><p>Bitwarden also offers <a href="https://github.com/bitwarden/server/?ref=labs.hakaioffsec.com">a self-hosted option</a> for those who want to maintain their own server, which is the one we are going to examine.</p><p>If we search for ways to create a self-hosted instance of the Bitwarden server, one of the presented ways is through the <a href="https://bitwarden.com/help/install-and-deploy-unified-beta/?ref=labs.hakaioffsec.com">Unified docker method</a>, which is a setup made for simplifying the deployment of the platform.</p><figure><img src="https://labs.hakaioffsec.com/content/images/2023/06/image-12.png" alt="" loading="lazy" width="1385" height="276" srcset="https://labs.hakaioffsec.com/content/images/size/w600/2023/06/image-12.png 600w, https://labs.hakaioffsec.com/content/images/size/w1000/2023/06/image-12.png 1000w, https://labs.hakaioffsec.com/content/images/2023/06/image-12.png 1385w" sizes="(min-width: 720px) 720px"/><figcaption>100K+ downloads!</figcaption></figure><figure><img src="https://labs.hakaioffsec.com/content/images/2023/06/image-7.png" alt="" loading="lazy" width="2000" height="1229" srcset="https://labs.hakaioffsec.com/content/images/size/w600/2023/06/image-7.png 600w, https://labs.hakaioffsec.com/content/images/size/w1000/2023/06/image-7.png 1000w, https://labs.hakaioffsec.com/content/images/size/w1600/2023/06/image-7.png 1600w, https://labs.hakaioffsec.com/content/images/size/w2400/2023/06/image-7.png 2400w" sizes="(min-width: 720px) 720px"/></figure><p>Since our regular expression gave a match for Bitwarden&#39;s repository, we started dwelving into the code base searching for potentially vulnerable Nginx configurations, which is when we found the following inside the folder for the unified docker setup. </p><figure><img src="https://labs.hakaioffsec.com/content/images/2023/06/image-9.png" alt="" loading="lazy" width="1778" height="646" srcset="https://labs.hakaioffsec.com/content/images/size/w600/2023/06/image-9.png 600w, https://labs.hakaioffsec.com/content/images/size/w1000/2023/06/image-9.png 1000w, https://labs.hakaioffsec.com/content/images/size/w1600/2023/06/image-9.png 1600w, https://labs.hakaioffsec.com/content/images/2023/06/image-9.png 1778w" sizes="(min-width: 720px) 720px"/></figure><p>If this config is used, then it means all files on /etc/bitwarden/attachments/ will be accessible on the URL /attachments, but looking back at the exploit details, this also means that any files present on /etc/bitwarden/ will be downloadable also.</p><p>But let&#39;s not get ahead of ourselves, we first must assess the impact of the exposure. To do that, we can either explore the code base or fire up a local instance and list the directory with a local shell. </p><p>Looking into the Dockerfile for that image, we find more info about that directory and what files it can contain:</p><figure><pre><code>[...]
ENV BW_DB_FILE=&#34;/etc/bitwarden/vault.db&#34;
[...]</code></pre><figcaption>Dockerfile</figcaption></figure><p>It seems like this environment variable sets where the vault database is saved, and we can see that vault.db is located on /etc/bitwarden.</p><p>Bitwarden only saves the database in that location if the user chooses to use SQLite as a database provider.</p><p>Therefore, if we issue an unauthenticated request to <code>http://&lt;instance&gt;/attachments../vault.db</code>, we will download the entire Bitwarden SQLite3 database.</p><figure><img src="https://labs.hakaioffsec.com/content/images/2023/06/image-13.png" alt="" loading="lazy" width="1486" height="875" srcset="https://labs.hakaioffsec.com/content/images/size/w600/2023/06/image-13.png 600w, https://labs.hakaioffsec.com/content/images/size/w1000/2023/06/image-13.png 1000w, https://labs.hakaioffsec.com/content/images/2023/06/image-13.png 1486w" sizes="(min-width: 720px) 720px"/></figure><p>We can also fetch log files, which have a predictable filename and can all be downloaded by accessing the following paths:</p><ul><li>/attachments../logs/api.log</li><li>/attachments../logs/admin.log</li><li>/attachments../logs/identity.log</li><li>/attachments../logs/notifications.log</li></ul><figure><img src="https://labs.hakaioffsec.com/content/images/2023/06/image-14.png" alt="" loading="lazy" width="1900" height="743" srcset="https://labs.hakaioffsec.com/content/images/size/w600/2023/06/image-14.png 600w, https://labs.hakaioffsec.com/content/images/size/w1000/2023/06/image-14.png 1000w, https://labs.hakaioffsec.com/content/images/size/w1600/2023/06/image-14.png 1600w, https://labs.hakaioffsec.com/content/images/2023/06/image-14.png 1900w" sizes="(min-width: 720px) 720px"/></figure><p>And, of course, the certificate file was also exposed in that folder. To access it, all you would need to do is issue a request to <code>/attachments../identity.pfx</code>.</p><figure><img src="https://labs.hakaioffsec.com/content/images/2023/06/image-15.png" alt="" loading="lazy" width="678" height="331" srcset="https://labs.hakaioffsec.com/content/images/size/w600/2023/06/image-15.png 600w, https://labs.hakaioffsec.com/content/images/2023/06/image-15.png 678w"/></figure><p>The data protection keys were also accessible, but these did not have a predictable filename, therefore, leaking them was not possible.</p><p>This vulnerability has been disclosed to Bitwarden and has since then been fixed. Bitwarden issued a US$6000 bounty, which is the highest bounty they issued on their HackerOne program.</p><h3 id="case-study-2-google-hpc-toolkitleaking-google-cloud-credentials">Case Study #2: Google HPC Toolkit - Leaking Google Cloud Credentials</h3><p>During our foray through GitHub, we chanced upon a software solution developed by Google, known as the Cloud HPC Toolkit. This was introduced in 2022, designed as a robust framework to facilitate the deployment of high-performance computing (HPC) environments on Google Cloud.</p><p>The HPC Toolkit boasts a Django-based web application front-end, granting users the ability to manage their HPC environments conveniently via a web interface.</p><p>Upon scrutinizing the configuration section identified by our regular expression, we discovered that a vulnerable path had indeed been defined. This path was aliased to <code>../hpc-toolkit/community/front-end/website/static/</code>, implying that issuing a request to <code>/static../</code> would provide us with access to the website folder.</p><figure><img src="https://labs.hakaioffsec.com/content/images/2023/06/image-16.png" alt="" loading="lazy" width="535" height="371"/></figure><p>Interestingly, we found that the SQLite database was also exposed within this folder and could be accessed through a specific URL:</p><pre><code>curl http://&lt;frontend URL&gt;/static../db.sqlite3 -O</code></pre><p>Moreover, the Django secret key was accessible at the following location:</p><pre><code>curl http://35.204.135.69/static../.secret_key</code></pre><p>Gaining access to this database is highly critical for the application, as the primary function of the HPC Toolkit appears to be the orchestration of large-scale Google Cloud resources. In the event of a compromise, an attacker could potentially gain control over a victim&#39;s GCP account credentials, which are stored in the SQLite database.</p><pre><code>sqlite&gt; select * from ghpcfe_credential;
1|production key|{
  &#34;type&#34;: &#34;service_account&#34;,
  &#34;project_id&#34;: &#34;andunduaindadaww&#34;,
  &#34;private_key_id&#34;: &#34;3acb9f[... redacted from report ...]7c69&#34;,
  &#34;private_key&#34;: &#34;-----BEGIN PRIVATE KEY-----\nMIIEv[... redacted from report ...] 5Kdkvg=\n-----END PRIVATE KEY-----\n&#34;,
  &#34;client_email&#34;: &#34;adwaw[...].com&#34;,
  &#34;client_id&#34;: &#34;105114036295455180401&#34;,
  &#34;auth_uri&#34;: &#34;https://accounts.google.com/o/oauth2/auth&#34;,
  &#34;token_uri&#34;: &#34;https://oauth2.googleapis.com/token&#34;,
  &#34;auth_provider_x509_cert_url&#34;: &#34;https://www.googleapis.com/oauth2/v1/certs&#34;,
  &#34;client_x509_cert_url&#34;: &#34;https://www.googleapis.com/robot/v1/metadata/x509/adwaw1f13f1f13-tkfe-sa%40andunduaindadaww.iam.gserviceaccount.com&#34;
}|1
sqlite&gt;</code></pre><p>The Google VRP Team recognized our work by awarding us a $500 reward for uncovering this vulnerability. They believed the impact on the application wasn&#39;t severe enough to warrant a larger reward. I toyed with the idea of debating the reward amount with them, but ultimately decided against it. After all, the recognition of our efforts was a reward in itself, and that was more than enough for us.</p><h2 id="navgix-detecting-the-vulnerability-in-a-black-box-manner">NavGix: Detecting the vulnerability in a black-box manner</h2><p>There are several methods to detect this vulnerability without necessitating access to the Nginx configuration file. Initially, potential location aliases can be identified by extracting links from the HTML source-code on the website&#39;s main page. Subsequently, directory traversal can be attempted using the techniques outlined in the earlier sections of this report.</p><p>In the absence of extractable links, it is feasible to perform a minor brute-force attack targeting common aliases. The ensuing list has demonstrated promising results during our testing phase:</p><pre><code>	var dictionary = []string{
		&#34;static&#34;,
		&#34;js&#34;,
		&#34;images&#34;,
		&#34;img&#34;,
		&#34;css&#34;,
		&#34;assets&#34;,
		&#34;media&#34;,
		&#34;lib&#34;,
	}</code></pre><p>An automated tool, <a href="https://github.com/hakaioffsec/navgix?ref=labs.hakaioffsec.com">NavGix</a>, has been created to aid in the enumeration and testing of aliased directories for traversal vulnerabilities. It is publicly available for download and use on its respective <a href="https://github.com/hakaioffsec/navgix?ref=labs.hakaioffsec.com">GitHub</a> page.</p><figure><img src="https://labs.hakaioffsec.com/content/images/2023/06/image-25.png" alt="" loading="lazy" width="956" height="241" srcset="https://labs.hakaioffsec.com/content/images/size/w600/2023/06/image-25.png 600w, https://labs.hakaioffsec.com/content/images/2023/06/image-25.png 956w" sizes="(min-width: 720px) 720px"/><figcaption>Sample usage of navgix</figcaption></figure><p>Upon the identification of a directory susceptible to traversal by NavGix, it becomes possible to employ additional tools to fuzz for other accessible folders or files within the traversed directory. The primary objective here should be to locate files of interest that could potentially provide further impact, such as a configuration file containing secrets, log files, or source-code.</p><h2 id="conclusion">Conclusion</h2><p>Wrapping up, while Nginx is a robust and incredibly versatile tool that fuels a significant portion of the internet, it&#39;s easily susceptible to certain inconsistencies. These potential pitfalls are often a result of misconfigurations, which can inadvertently transform this reliable powerhouse into a possible weak link. Nginx&#39;s approach to security leaves a significant onus on developers to avoid hazardous configurations, underscoring the importance of thorough understanding and cautious implementation.</p><p>Our journey through the world of open-source repositories and real-life case studies like Bitwarden and Google&#39;s HPC Toolkit underlines just how significant these vulnerabilities can be. It&#39;s a sobering reminder that even the most reliable systems can have their Achilles&#39; heel.</p>
    </section></div>
  </body>
</html>
