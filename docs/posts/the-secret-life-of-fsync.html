<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://puzpuzpuz.dev/the-secret-life-of-fsync">Original</a>
    <h1>The secret life of fsync</h1>
    
    <div id="readability-page-1" class="page"><div><section><div><div id="post-content-parent"><div id="post-content-wrapper"><p>Several times I&#39;ve heard opinions that many mass-market SSDs and HDDs don&#39;t provide sufficient durability guarantees and Linux can do nothing with that. Namely, after an <a target="_blank" href="https://man7.org/linux/man-pages/man2/fsync.2.html"><code>fsync</code></a><code>()</code> call recently modified data can still sit in the drive&#39;s volatile write cache and, thus, it may be lost in case of a power failure. If you want any meaningful durability, you should go for enterprise-grade drives that have a battery/capacitor so that they can flush the data to persistent storage on power loss. Is it really so? Let&#39;s find out.</p>
<p>First, let&#39;s check what POSIX.1-2017 <a target="_blank" href="https://pubs.opengroup.org/onlinepubs/9699919799/">specification</a> says about <code>fsync</code>:</p>
<blockquote>
<p>The <em>fsync</em>() function shall request that all data for the open file descriptor named by <em>fildes</em> is to be transferred to the storage device associated with the file described by <em>fildes</em>. The nature of the transfer is implementation-defined.</p>
</blockquote>
<p>The above description is rather vague. If the OS issues operations to write the data to the disk&#39;s volatile cache, that&#39;s a &#34;transfer&#34;, so formally such OS would be POSIX-compliant. The informative section of the spec sheds more light on what a proper <code>fsync</code> implementation should do:</p>
<blockquote>
<p>The <em>fsync</em>() function is intended to force a physical write of data from the buffer cache, and to assure that after a system crash or other failure that all data up to the time of the <em>fsync</em>() call is recorded on the disk. Since the concepts of &#34;buffer cache&#34;, &#34;system crash&#34;, &#34;physical write&#34;, and &#34;non-volatile storage&#34; are not defined here, the wording has to be more abstract.</p>
</blockquote>
<p>OK, that&#39;s much more specific. Once an <code>fsync</code> call is made, the data should become durable in the face of a system crash, e.g. due to a power loss. But is it really something Linux does on an <code>fsync</code>?</p>
<p>As with many other FS-related system calls, most (if not all) file systems have their own implementation of <code>fsync</code>. To keep things simpler, we&#39;re going to check the ext4 implementation in the recent 6.x kernel code base. We should be looking at the <a target="_blank" href="https://github.com/torvalds/linux/blob/62bad54b26db8bc98e28749cd76b2d890edb4258/fs/ext4/fsync.c#L129-L187">`ext4_sync_file()`</a> function which is invoked on an <code>fsync()</code> call. It involves the following steps:</p>
<ol>
<li><p>First, it writes all dirty pages belonging to the file that corresponds to the input file descriptor to the disk. That&#39;s done by the `file_write_and_wait_range()` function. As a result, the data may be sitting in the disk volatile cache, so that&#39;s not what we&#39;re looking for.</p>
</li>
<li><p>Next, it writes the inode&#39;s metadata to the disk. Depending on whether journaling is enabled on the FS or not, it&#39;s done via a specific function, e.g. `ext4_fsync_journal()`. Again, not something we&#39;re in search of.</p>
</li>
<li><p>Finally, if the <code>needs_barrier</code> variable is true, it calls the <code>blkdev_issue_flush()</code> function. That&#39;s probably what we need, isn&#39;t it?</p>
</li>
</ol>
<p>Let&#39;s leave the <code>needs_barrier</code> variable out of the equation for now and check what <code>blkdev_issue_flush()</code> does. This <a target="_blank" href="https://github.com/torvalds/linux/blob/62bad54b26db8bc98e28749cd76b2d890edb4258/block/blk-flush.c#L462-L468">function</a> queues a flush operation to the block device and waits until it&#39;s finished. The operation has the <code>REQ_PREFLUSH</code> bit set among the flags. If we open kernel docs, we&#39;ll find <a target="_blank" href="https://docs.kernel.org/block/writeback_cache_control.html#explicit-cache-flushes">some information</a> on this flag (and not only):</p>
<blockquote>
<p>In addition the REQ_PREFLUSH flag can be set on an otherwise empty bio structure, which causes only an explicit cache flush without any dependent I/O. It is recommend to use the blkdev_issue_flush() helper for a pure cache flush.</p>
</blockquote>
<p>As we expected, the <code>REQ_PREFLUSH</code> flag (as well as the <code>REQ_FUA</code> flag) tells the block device that it should flush its volatile cache to the persistent storage. Drivers for any well-behaved disk with a volatile write cache <a target="_blank" href="https://docs.kernel.org/block/writeback_cache_control.html#implementation-details-for-request-fn-based-block-drivers">should handle</a> this flag properly. Obviously, disks without such cache don&#39;t need to bother with these operations and flags.</p>
<p>Now, what&#39;s the buzz with <code>needs_barrier</code>? In both <a target="_blank" href="https://github.com/torvalds/linux/blob/62bad54b26db8bc98e28749cd76b2d890edb4258/fs/jbd2/journal.c#L638-L670">journaled</a> and <a target="_blank" href="https://github.com/torvalds/linux/blob/62bad54b26db8bc98e28749cd76b2d890edb4258/fs/ext4/fsync.c#L98-L99">non-journaled</a> ext4 code paths, it appears to be nothing more, but an optimization to avoid sending flush requests to the disk multiple times. Note that you can also configure ext4 not to issue flush operations. For example, in non-journaled mode it&#39;s done via EXT4_DEFM_NOBARRIER mount option.</p>
<p>Other file systems have their own specifics, but the overall logic should be close enough to the ext4&#39;s one. So unlike <a target="_blank" href="https://news.ycombinator.com/item?id=30370551">macOS</a>, Linux does its best to transfer the data to persistent storage on <code>fsync</code>. Of course, this doesn&#39;t protect you from a flawed driver implementation written for a cheap no-name drive, but it also means that if you have a decent SSD from a well-known brand, you may be fine without an enterprise-grade disk.</p>
</div></div></div></section></div></div>
  </body>
</html>
