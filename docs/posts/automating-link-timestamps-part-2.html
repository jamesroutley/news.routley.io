<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.fauxtrots.com/blog/link-timestamps">Original</a>
    <h1>Automating link timestamps: Part 2</h1>
    
    <div id="readability-page-1" class="page"><div><!----><p><em>This is a followup to my previous post about
<a href="https://www.journals.uchicago.edu/blog/automated-timestamps">Automating Blog Timestamps</a> and will make much more sense if you read
it first.</em></p>
<p>Last time I wrote a Perl script to add timestamps to new blog posts as they&#39;re committed to the git
repo for this site. But I also have a <a href="https://www.journals.uchicago.edu/links">links page</a><sup><a id="footnote-ref-1" href="#footnote-1" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup><span>Check it out, there&#39;s some cool stuff!</span> that&#39;s set up differently, so the
previous method of adding timestamps wouldn&#39;t work. Instead of each entry having its own file, links
are stored as an array in a YAML file<sup><a id="footnote-ref-2" href="#footnote-2" data-footnote-ref="" aria-describedby="footnote-label">2</a></sup><span>Technically before this they were stored in an array in a JavaScript file, but don&#39;t nitpick.</span>, so we can&#39;t just add the timestamp to the top of a file
when it&#39;s added to the repo. Instead, we need to actually parse the document to see which entries
are new vs pre-existing. This began my descent into hell.</p>
<p>I didn&#39;t want to write a document parser myself, which meant it was time to learn how to find and
use Perl modules. After a bit of searching, it looked like <a href="https://metacpan.org/pod/CPAN">CPAN</a> was
the tool for the job. For some reason setting that up and establishing my environment took a long
time<sup><a id="footnote-ref-3" href="#footnote-3" data-footnote-ref="" aria-describedby="footnote-label">3</a></sup><span>Just leaves more time for <a href="https://xkcd.com/303/">swordfights</a>.</span>, but whatever. First up I actually wanted to use JSON, not YAML. I went down a rabbit hole
trying to use <a href="https://metacpan.org/pod/JSON::PP">JSON::PP</a>, but for some reason I wasn&#39;t able to
read the data and go through it in a loop.<sup><a id="footnote-ref-4" href="#footnote-4" data-footnote-ref="" aria-describedby="footnote-label">4</a></sup><span>This whole process was made more annoying by the fact that Perl apparently doesn&#39;t have a built
    in way to print (the contents of) arrays and hashes. I ended up using
    <a href="https://metacpan.org/pod/Data::Dump">Data::Dump</a> in order to actually see what a hash contained
    instead of <code>HASH(0x5584948e7788)</code>.</span> Apparently my desired data structure (an array of
hashes) isn&#39;t commonly used in perl-land. I probably could have made it work eventually, but at this
point I switched to trying out YAML.</p>
<p>Perl has several YAML parsing libraries<sup><a id="footnote-ref-5" href="#footnote-5" data-footnote-ref="" aria-describedby="footnote-label">5</a></sup><span>Apparently the <a href="https://metacpan.org/pod/YAML">first YAML implementation</a> was in Perl!</span>, but I ended up going with
<a href="https://metacpan.org/pod/YAML::PP">YAML::PP</a>. First I created an instance of the library:</p>
<pre><code>use YAML::PP;
my $ypp = YAML::PP-&gt;new;
</code></pre>
<p>Then added in an elsif to the filetype conditional: <code>elsif ($file =~ /\.yaml$/)</code>. This is where the
trouble really started. Perl has three fundamental variable types which each have their own symbol
prefix: scalar (<code>$foo</code>), array (<code>$bar</code>), and hash (<code>%baz</code>). Figuring out how to use these symbols in
combination with each other was mostly achieved by trial and error, and I&#39;m still not 100% sure on
how it all works. Lets go through it line by line.</p>
<pre><code>my $links = $ypp-&gt;load_file($file);
</code></pre>
<p>This seems fine to begin with, but naively I would expect links to be an array, and thus be prefixed
with an <code>@</code>. However, if you do that you then run into trouble on the next line...</p>
<pre><code>foreach my $link (@$links) {
</code></pre>
<p>We&#39;re setting up a for loop here over the items in <code>$links</code>. Wait, that&#39;s... <code>@$links</code>? My
understanding is that <code>$links</code> is actually an array <em>reference</em>, and by adding the <code>@</code> prefix on
we&#39;re dereferencing it so that we can loop over the values. The current value in each iteration of
the loop is stored in <code>$link</code>. This <em>should</em> be a hash, but it seems that loop variables such as
this are also references, and such have to be defined as scalars.</p>
<pre><code>if (!%{$link}{&#34;createdAt&#34;}) {
</code></pre>
<p>Now we&#39;re checking if the current link hash contains a <code>createdAt</code> key. We again have to dereference
the variable into a hash. If the key isn&#39;t present we assume the link is new and move on to:</p>
<pre><code>$link-&gt;{&#39;createdAt&#39;} = $date;
</code></pre>
<p>Assigning the current timestamp to the hash. After that we dump the array out into the file again.
The first time I got this to work it created a YAML file composed of multiple documents; that is,
each link was separated by a <code>---</code>. Unfortunately that caused the JavaScript YAML parsing library
I&#39;m using<sup><a id="footnote-ref-6" href="#footnote-6" data-footnote-ref="" aria-describedby="footnote-label">6</a></sup><span><a href="https://github.com/figma/vite-plugin-yaml">@modyfi/vite-plugin-yaml</a></span> to not import correctly, so I had to futz around with it until I got to the current
state. Here&#39;s the final result:</p>
<pre><code>use YAML::PP;
my $ypp = YAML::PP-&gt;new;

my $date = time();
my @files = `git diff-index --cached --name-only HEAD`;

foreach my $filename (@files) {
  chomp $filename;
  if ($filename =~ /\.md$/) {

    ... code from previous post ...

  } elsif ($filename =~ /\.yaml$/) {
    my $links = $ypp-&gt;load_file($file); # array of links in file

    foreach my $link (@$links) {
        if (!%{$link}{&#34;createdAt&#34;}) {
            $link-&gt;{&#39;createdAt&#39;} = $date;
        }
    }

    $ypp-&gt;dump_file($file, $links);

    system &#34;git add $file&#34;;
  }
}
</code></pre>
<p>I also had to make a couple changes to my <code>.pre-commit-config.yaml</code> file. First, I added
<code>exclude: (.pre-commit-config.yaml)</code> at the top level so that the script wouldn&#39;t try to add a
timestamp to the config file itself. Next, I changed the <code>types</code> key for this hook to
<code>types_or: [markdown, yaml]</code>.</p>
<p>Overall I&#39;m happy with how this turned out, but I hope that I won&#39;t have to touch this script (or
Perl in general tbh) again for a long time.</p>
<section data-footnotes="">
<h2 id="footnote-label">Footnotes</h2>
<ol>
<li id="footnote-1">
<p>Check it out, there&#39;s some cool stuff! <a href="#footnote-ref-1" data-footnote-backref="" aria-label="Back to reference 1">↩</a></p>
</li>
<li id="footnote-2">
<p>Technically before this they were stored in an array in a JavaScript file, but don&#39;t nitpick. <a href="#footnote-ref-2" data-footnote-backref="" aria-label="Back to reference 2">↩</a></p>
</li>
<li id="footnote-3">
<p>Just leaves more time for <a href="https://xkcd.com/303/">swordfights</a>. <a href="#footnote-ref-3" data-footnote-backref="" aria-label="Back to reference 3">↩</a></p>
</li>
<li id="footnote-4">
<p>This whole process was made more annoying by the fact that Perl apparently doesn&#39;t have a built
in way to print (the contents of) arrays and hashes. I ended up using
<a href="https://metacpan.org/pod/Data::Dump">Data::Dump</a> in order to actually see what a hash contained
instead of <code>HASH(0x5584948e7788)</code>. <a href="#footnote-ref-4" data-footnote-backref="" aria-label="Back to reference 4">↩</a></p>
</li>
<li id="footnote-5">
<p>Apparently the <a href="https://metacpan.org/pod/YAML">first YAML implementation</a> was in Perl! <a href="#footnote-ref-5" data-footnote-backref="" aria-label="Back to reference 5">↩</a></p>
</li>
<li id="footnote-6">
<p><a href="https://github.com/figma/vite-plugin-yaml">@modyfi/vite-plugin-yaml</a> <a href="#footnote-ref-6" data-footnote-backref="" aria-label="Back to reference 6">↩</a></p>
</li>
</ol>
</section>
<!----></div><p>Liked reading my thoughts? Consider leaving a comment below or dropping a tip in my <a href="https://ko-fi.com/fauxtrots">KoFi</a>! No matter what, thanks for reading.</p></div>
  </body>
</html>
