<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://binaryigor.com/modular-monolith-and-microservices-modularity-is-what-truly-matters.html">Original</a>
    <h1>Modular monolith and microservices: Modularity is what matters</h1>
    
    <div id="readability-page-1" class="page"><div>
            <h2 id="modularity">Modularity</h2><p>Modularity is a crucial concept when designing and creating software. Independent of whether our chosen architecture style is to have:</p>
<ol>
<li>single unit of deployment - <em>Monolith</em></li>
<li>many units of deployment - <em>Microservices/Services</em></li>
</ol>
<p><strong>Modularity is a quality that should be treated completely independent of how many deployable units of software we choose to have.</strong> We should aim at splitting our systems into logical, functional modules as independent of each other as possible - in the ideal world, every module should not know anything about any other module and have everything that is needed to serve its functionality. In the real world that is usually not fully possible, but we should have these ideals as our guiding principles and strive for <em><a href="https://codeopinion.com/solid-nope-just-coupling-and-cohesion/">high cohesion and low/loose coupling</a></em>. But, what is a module in that context?</p>
<p><strong>Module is a piece of software - be it one object/class/function or set of objects, classes and functions cooperating with each other - that is responsible for delivering specific functionality or set of closely related functionalities.</strong> Those functionalities should be defined from the user perspective - be it human or machine (other software or module for example). Every module needs to have an input, some kind of public <em>API</em>, that a human or other software can use in order to benefit from its functionalities. But, why do we even care about modularity in the first place, what benefits does it bring to the table? A couple of reasons:</p>
<ul>
<li>Organization - with well-defined modules, it is often very clear/obvious what exactly given system does. It is then also easy to split work and responsibility of people/teams and work on different pieces in parallel, independently of each other</li>
<li>Comprehension - it is significantly easier to understand five small modules rather than having to deal with one big piece where everything is intertwined</li>
<li>Resource utilization - some modules may have completely different resource requirements. For example, one might need to be highly available and used by tens of thousands of users and the other might run some tasks in the background, once in a while, and not be exposed to the outside word - modularization allows to take these factors into account which leads to more optimal resource utilization</li>
<li>Reusability - by giving modules clearly defined responsibilities and public interfaces we can reuse their functionalities</li>
<li>Testability - it is easier to verify that a small/medium module of software works versus having to deal with a one big piece with lots of unclear dependencies. Also, if modules have well-defined boundaries, we very rarely (if at all) need to test interactions between them. We can just verify modules adherence to the <a href="https://binaryigor.com/unit-integration-e2e-contract-x-tests-what-should-we-focus-on.html#contract-tests-reasonable-e2e-tests-alternative">established contract of interaction</a></li>
</ul>

<p>To make all these points clear, let&#39;s work on the example and say that we have a system - <em>Curious Notes to the Interesting Quotes</em> - where users can add notes to famous quotes and sayings. One possible design is to split it into the following modules:</p>
<ul>
<li><em>users</em>: responsible for the creation of new users, managing accounts and authorizing/authenticating them</li>
<li><em>quotes</em>: responsible for the management of quotes by the special, privileged users</li>
<li><em>notes</em>: responsible for adding notes to quotes by the users, also allowing them to edit, delete and like them</li>
</ul>
<p>Modules dependencies:</p>
<ul>
<li><em>users</em> - no dependencies</li>
<li><em>quotes</em> - depends on <em>users</em> for asking whether a certain <em>user</em> is allowed to add/edit/delete quotes</li>
<li><em>notes</em> - depends on <em>users</em> for asking whether a certain <em>user</em> is allowed to add/edit/delete a <em>note</em>, depends on <em>quotes</em> to know whether a particular <em>quote</em> exists</li>
</ul>
<p>These are our modules and their dependencies. <strong>We should treat this logical division mostly independently of our physical architecture choice.</strong> We can have a <em>modular monolith</em> with these three modules as just separate folders or fully isolated and independently versioned packages. We can also go for three <em>(micro)services</em> that communicate over the wire, synchronously or asynchronously. This physical division of a system into one or multiple units of deployment should be a secondary, not primary, factor when it comes to system design. The driving factor should be the understanding of our domain and functional requirements, concepts that we have there and the dependencies that occur between them. Only having sorted this out, we should think about non-functional, performance and resource utilization related factors that might change the implementation details of our initial design.</p>
<h2 id="software-development-in-the-real-world">Software development in the real world</h2><p>Modularity requirements described above are great in the ideal circumstances, when we have complete knowledge about the software that we build and its functional requirements. Sadly, in practice that is often not the case and our knowledge is partial, incomplete. There are two main reasons responsible for this state of affairs:</p>
<ol>
<li>Often, we do not have access to the client that drives requirements or the client/business person/product owner does not have time, but we need to start the development due to time constraints and deadlines. We do not have full knowledge about the details and required features, we know only a subset of them</li>
<li>Sometimes, we model something that is changing all the time, in the startup environment for example, or we consciously experiment a lot and/or not sure about the details of our domain at all yet, because we just started to explore it</li>
</ol>

<h2 id="implementations-of-modularity">Implementations of modularity</h2><p>There are many ways and strategies of implementing modularity in practice. To reiterate once again: good design, which is a good module separation, should not depend on the physical architecture - whether we have one or many units of deployments. We need to understand our domain and functional requirements, think about concepts, boundaries and modules that naturally arise there - especially dependencies between them, because the dependencies often make or break a system. Only when we have taken care of that, or are sure that it will not change <em>that much</em>, we should evaluate how to structure our system physically, at runtime. It means answering the questions like:</p>
<ul>
<li>Should we have one or multiple units of deployment (applications at runtime)? </li>
<li>If one - how complex our modular monolith structure needs to be and what type of constraints (if any) we want to impose on it?</li>
<li>If multiple - what type of constraints (if any) we want to impose on our (micro)services - mainly tech stack, allowed network communication types (synchronous/asynchronous) and timing of this communication (in the foreground/background), how to deal with <a href="https://en.wikipedia.org/wiki/Distributed_transaction">distributed transactions</a> and so forth</li>
</ul>
<p>Let&#39;s then consider different strategies that we can employ based on these and other factors.</p>
<div data-newsletter-sign-up="" data-newsletter-sign-up-placement="POST_MID">
    <p>Enjoying this piece? Get the <span>Binary Log</span> Newsletter - deep and broad dives, discoveries and distilled insights for driven developers who care about the craft:</p>
    <p>
    <span data-email-error="">Valid email is required.</span></p>
    <div>
        <p>No spam, no fluff - pure signal. Unsubscribe anytime.</p>
    </div>
    
    </div>

<h3 id="implementations-of-modularity-simple-modular-monolith-modules-as-folders">Simple Modular Monolith: modules as folders</h3><p>This is the simplest and most straightforward way of modularization. <strong>Here, we just treat folders as separate modules, we do not version them independently and do not have any additional boundaries between them, but we must have a contract/convention of how they are allowed to communicate with each other.</strong> Its biggest advantage - simplicity, can also be its biggest disadvantage. We need to take additional precautions so that our modules boundaries are respected and we do not turn our <em>modular monolith (modulith)</em> into just a <em>monolith</em> - a big pile of mud, hard to understand, test and change. To guard ourselves against such an unfortunate scenario, we should establish and respect some conventions, like:</p>
<ul>
<li>Have a <em>_contracts</em> folder, where we have all common interfaces, models and application events defined</li>
<li>Each module can have a specific folder/file where its public interface is defined. Other parts are considered private and are not allowed to be used</li>
<li>If we have one, shared database - we should use a separate schema for each module or have some reasonable table naming convention. In that way, each module owns its data and is fully responsible for it</li>
</ul>

<pre><code>interface UsersClient {

  boolean canAddQuote(UUID userId);

  boolean canEditQuote(UUID userId, UUID ownerId, UUID quoteId);

  boolean canDeleteQuote(UUID userId, UUID ownerId, UUID quoteId);

  boolean canManageNote(UUID userId, UUID ownerId, UUID noteId);
}

interface QuotesClient {
  boolean quoteExists(UUID quoteId);    
}

record QuoteCreatedEvent(UUID quoteId, UUID ownerId) { }

record QuoteDeletedEvent(UUID quoteId, UUID ownerId) { }
</code></pre>
<p>As we can recall, the <em>quotes</em> module depends on the <em>users</em> module. Using this convention, it would only use the <em>UsersClient</em> interface to communicate with the <em>users</em> module. <em>Users</em> module will implement this interface and this implementation will be injected into the <em>quotes</em> module at runtime, but the <em>quotes</em> module is only aware of the <em>UsersClient</em> interface. In this way, it does not know anything about the <em>users</em> module implementation details, the coupling between these modules is therefore loose. It will be the same for the <em>notes</em> and <em>quotes</em> modules - <em>notes</em> module communicates with <em>quotes</em> only through the <em>QuotesClient</em> interface. Additionally, we can use application events, like the <em>QuoteCreatedEvent</em> shown above to publish messages to other modules. In the <em>users</em> module, we might for example send notifications to users whenever a new quote is created. In the <em>notes</em> module, we might have a mechanism to delete all notes of a quote that just has been deleted.</p>
<p>To restate, <strong>this is the simplest and most nimble implementation of modularization</strong>. If we work alone or in a single team, and/or we are not sure about our domain or the module separation, this is probably the most suitable strategy. If we respect a few aforementioned rules, it will be easy to migrate to more elaborate structures later on. The main drawbacks are:</p>
<ul>
<li>it is relatively easy to cross modules boundaries and do not respect established conventions</li>
<li>we can not have independent deployments of different modules from various git branches, because we do not version them independently and everything is built from one source code repository (if we always deploy from a single master branch after merge, it is not an issue)</li>
</ul>
<p>These drawbacks may be completely acceptable and fine in our specific case. We/our team might be disciplined enough so that established module boundaries are never violated (there are also <a href="https://www.archunit.org/">some tools to guard us from it</a>). Additionally, if we can run and fully test our modular monolith locally - it is probably not needed to have independent deployments of different modules. <strong>If this is the case, choose this strategy and enjoy the not appreciated enough benefits of simplicity!</strong></p>
<h3 id="implementations-of-modularity-modular-monolith-with-independently-deployable-modules">Modular Monolith with Independently Deployable Modules</h3><p>This strategy is a more rigorous version of the modular monolith architecture. <strong>We still have a single unit of deployment, but every module is an independently versioned package</strong> - be it Java jar, NPM package, Go binary or C# assembly. There are a couple of interesting consequences of that additional isolation:</p>
<ul>
<li>every module is versioned independently and can be deployed independently - if we have a private repo of artifacts (packages), where we upload our packages, which is relatively easy to set up</li>
<li>if a given module depends on another module/modules, we need to add it as the dependency to our module, which makes dependencies more transparent</li>
<li>because of this additional isolation, it is harder to cross modules boundaries that should not be crossed - that keeps our architecture in check</li>
<li>to make our modules even more independent we can use different database in each module to decouple them even more (this can be done in <em>simple modular monolith</em> approach also)</li>
<li>if we want to make them even more insulated, we can put every module in a separate git repository</li>
</ul>

<p>As mentioned, if we want to make our modules more decoupled, we can use a different database in each of them. Does it make them more independent than just having separate database schemas or a table naming convention? <strong>Let&#39;s say that we share a single database, but have the following rule: it is only allowed to make transactions within one module, it is not allowed to make transactions across modules. If this is the case, we will not gain that much from having separate databases.</strong> With multiple databases, we have no choice because it is technically not possible to have a transaction between different databases. Usually, if we need to have a transaction that spans over more than one module, it means that something in our design is not right. Still, sometimes a transaction of this type (distributed) is necessary evil. In that case, we need to use patterns from the microservices word - mainly <em><a href="https://microservices.io/patterns/data/transactional-outbox.html">Transactional Outbox Pattern</a></em> to deliver messages reliably and/or <em><a href="https://microservices.io/patterns/data/saga.html">Saga Pattern</a></em> for (unfortunately) distributed transactions - between multiple independent databases. Fortunately, in many cases, we can avoid the latter, by having a smart data reconciliation mechanism in the background. In this approach, some data might be duplicated between modules (their databases), so that they can serve all needed functionality without relying on other modules. Because distributed transactions are hard, I recommend to focus on designing modules in such a way that we do not need to have transactions that span multiple of them. At the very worst, we might need to copy some data from one module to another by sending application events or by doing simple function calls  - we still have a monolith, one unit of deployment and execution after all. <strong>Copying and synchronizing data between modules is simple, as it can be done in the background, independently of normal requests processing</strong> and we have a guarantee that it will succeed eventually, because in the background, we can retry as many times as needed.</p>
<p>This approach is much more scalable than a <em>simple modular monolith</em>. <strong>If we have isolated and independently versioned modules, each one has its own database or we just follow <em>no transactions across modules</em> rule, and possibly even have every module in a separate git repository - many people and teams can work on a single modular monolith in parallel, with minimal or no conflicts at all, and with very limited need for synchronization.</strong> The main thing that we need to share and agree on is some basics of the tech stack - programming language, build system, maybe framework (we can use more than one if we want) and some core libraries.</p>
<h3 id="implementations-of-modularity-microservices-modules-as-applications">Microservices - modules as applications</h3><p>This is the most complex implementation of modularization. <strong>Here, we simply say that each module is, more or less, a separate application, deployed and run independently.</strong> Because of that, the number of our deployment units (applications) is more or less equal to the number of modules. </p>
<p><strong>For this level of separation, we need to pay the highest price - <a href="https://renegadeotter.com/2023/09/10/death-by-a-thousand-microservices.html">complexity</a>.</strong> First is infrastructure. With one, two or three units of deployment - we most likely can just build and deploy our application/applications to a virtual private server or some kind of platform as a service, with the help of a few simple bash and/or python scripts and that is it - simplicity. With microservices, we have many separate applications that most likely will need to communicate through remote network calls - we need to set up an infrastructure which allows for it or pay for such a service (<a href="https://kubernetes.io">Kubernetes</a> is not a simple tool that can be learned in a few hours or days). Additionally, observability - mainly logs, metrics and alerts - of our system will also be much harder to set up and maintain because we need to deal with many independent applications. We no longer will work with plain old function/method calls, but events published to message brokers/queue systems that may fail at any time, and/or synchronous network requests, most often HTTP calls, that may fail at any time, for multiple unrelated reasons. In a nutshell, we enter the complex world of network indeterminism. We now have a truly distributed system and the whole shelves of books have been written about the complexities of such systems - it is not something that we should treat lightly. It is worth pointing out that most people and teams do not appreciate this complexity enough. Having said all of that, sometimes it is justified and brings a number of benefits - if we can handle the complexity.</p>
<p>What are the benefits? Because each module is more or less a separate application, we can use multiple programming languages, based on the needs of this particular module (although it is rarely needed in practice and having multiple tech stacks in a system comes with its own set of tradeoffs). What is more important, different modules can have varying resource utilization requirements. Some of them might need to be available all the time, without any interruptions, and be able to handle high load, while some of them might have modest requirements, and some of them might have needs somewhere in between. <strong>Thanks to the fact that every module is now basically a separate application, we can assign different resources to each module and have it in a different, often dynamic, number of replicas, based on its own unique needs.</strong> It naturally leads to more optimal resource utilization. With the modular monolith approach, if one module needs more resources, we need to scale the whole monolith, because we have a single unit of deployment - this is arguably less optimal (there is <a href="#implementations-of-modularity-modular-monolith-with-helper-services">Monolith++ approach</a>, discussed below, that addresses this issue).</p>
<p>Another important benefit is that we can scale to more teams. With the <em>Modular Monolith with Independently Deployable Modules</em> approach we can definitely scale to a few teams, but probably not to tens or hundreds (but do we need it?). If we expect that type of growth in our organization or already are sitting at this size, we might be justified to use microservices. Because of that, we can arguably also have more independent streams of work at the same time. I would argue that we can achieve a similar level of work parallelism with the modular monolith, it just requires more discipline, but still can be done. What is better, what is justified and whether given tradeoffs are acceptable - depends on the specific case.</p>
<p>To sum it up - <strong>this architecture style should be used only if we really, really need it, as it is the most complex and it can slow us down significantly, if we employ it without valid reasons to do so</strong>. But sometimes, just sometimes, solutions like that are indeed needed.</p>
<h3 id="implementations-of-modularity-constrained-microservices-just-services-microliths">Constrained microservices - just Services/Microliths</h3><p>We can eliminate many, most in fact, problems of microservices by adhering to one, simple rule:</p>
<blockquote>
<p>When serving any external network request, synchronous or asynchronous, service can not make any network calls to other services, synchronous or asynchronous.</p>
</blockquote>
<p>Why this constraint is so powerful?</p>
<ul>
<li>It forces us to split services in such a way that they have all data needed for their functionality, often simplifying and improving design of our system</li>
<li>Services are more reliable, because by the virtue of the above constraint they do not depend on any other service to handle external requests</li>
<li>We do not need to deal with distributed transactions. By the virtue of this constraint, they are not possible</li>
<li>Systems of this kind are also much easier to understand and debug, compared to microservices architecture. We do not make any network requests when serving external requests, so the only thing that can fail is our service. When we make network requests in the background, other services can not make requests to other services when handling our requests, because of the established constraint, so it is easy to trace what and how exactly has failed</li>
</ul>

<p><strong>An interesting hybrid might arise here: we may end up with just a few bigger services, each of them being a <em>modular monolith</em>.</strong> We can then reap the benefits of both strategies - have a few, independently scalable units of deployment, but still without a need to have a complex infrastructure, observability tools and the complexity of network indeterminism that we need to grapple with a pure, unconstrained microservices architecture. </p>
<h3 id="implementations-of-modularity-modular-monolith-with-helper-services">Modular Monolith with Helper Services</h3><p>In this approach, by default, we have a <em>modulith (modular monolith) core</em> and by default we add most of the functionality there, focusing on good modules structure. In rare cases, where <em>some module</em> has different resource or technology requirements, or for any other reasons it differs significantly from our <em>modulith core</em>, we create a separate service out of it, deploy and run it independently. What does it mean? We should mostly apply rules from the <em><a href="#implementations-of-modularity-constrained-microservices-just-services-microliths">microliths</a></em>: network communication is not allowed when serving external requests. In that way, we still have a simple system, but whenever our modular monolith has a distinct module with unique needs, we separate it as a small, independent, single-purpose service to match those needs better. </p>
<h2 id="parallel-work-and-independent-deployments">Parallel work and independent deployments</h2><p>When we work in a team or in a few teams, the ability to have as many independent streams of work as possible is important as it allows for work parallelization. In the context of modularity, <strong>the more modular our system is, the easier it is to split work and responsibilities between different people and teams</strong>. The less coupled, more independent our modules are, the more individuals/teams can modify code of the system in parallel, without conflicts and interruptions. There are two dimensions to consider here:</p>
<ol>
<li>introducing changes to the code base</li>
<li>testing those changes locally and on dev/stage/prod environments, which are generally shared by people and teams</li>
</ol>

<p>What about concurrent testing of multiple, unrelated changes on different environments? It mostly depends on the details of our environments, there are many possible strategies here. What is worth pointing out however, is that by default, microservices/separate services - having many units of deployment - give us this ability almost for free, if we implement them correctly. When we work on a separate service, we can deploy only it and test our changes without affecting currently deployed and being tested changes of other services - as long as our services are <em>fairly independent</em>. It is also possible with the modular monolith: if we have isolated our modules as different packages, versioned independently, and are uploading them to some kind of artifact repository, we can deploy our modular monolith with a new version of the module that we work on, without affecting the other ones. Additionally, if we have a simple modular monolith and a few teams work on it, we can have separate dev and stage environments per team. There are probably many other ways and strategies to allow independent deployments with modular monolith, they just require some additional effort to set up. But as we know, microservices come with unrivaled infrastructure complexity and they are also not ready to be used and to work on by default. What is particularly worth pointing out - <strong>with modular monolith, in most cases, because of the infrastructure simplicity, we can run the whole system locally and test it reliably end-to-end on our own machine, so we might not need to have shared dev and stage environments at all, we can deploy directly to production</strong>.</p>
<h2 id="what-about-the-frontend">What about the Frontend?</h2><p>Thus far, I focused mostly on the backend or systems without a strict frontend/backend distinction when it comes to units of deployment - like more traditional, server-side rendered applications. If we have old school server-side rendering or use <strong><a href="https://binaryigor.com/htmx-simpler-web-based-app-or-system.html">promising HTMX technology</a></strong>, the views are defined in the same modules where our backend is so the problem of modularity is solved (there is no frontend/backend distinction when it comes to the units of deployment). In that approach, our frontend/views are scoped to the modules. Thinking pragmatically though, what about JavaScript focused, Single Page Applications (SPAs) that dominate the market today?</p>
<p><strong>In the Single Page Application approach, we should follow almost the same rules related to modularity as discussed so far.</strong> We can start with a simple modular monolith, by having modules just as separate folders. Similarly, we can have _contracts folder/module that strictly describes how our modules can communicate with each other and what, if any, state they can share. Additionally, we can limit the usage of global styles (<a href="https://tailwindcss.com/docs/reusing-styles">Tailwind</a> approach mostly fixes this) and components and rely mostly on module-scoped styles and components - sharing only the most generic styles and components. Here, universal rules of coupling and cohesion also apply: the more independent and self-contained modules are, the more independent work we can have. With the simple modular monolith strategy, we will not have the ability to independently deploy different modules. Therefore, if modules as folders are not isolated enough for our needs, we can use <a href="https://webpack.js.org/guides/code-splitting/">code splitting</a> or <a href="https://router.vuejs.org/guide/advanced/lazy-loading.html">dynamic imports approach</a> to have multiple independent entry points to our application. <strong>As the last resort, we can have a separate SPA per a few selected routes, having as many html pages as we have SPAs (multiple SPAs approach), or use the <a href="https://martinfowler.com/articles/micro-frontends.html">Micro Frontends</a>.</strong> Both of them give us complete physical isolation of our modules, similar to microliths/microservices ideas discussed above.</p>
<h2 id="closing-thoughts">Closing thoughts</h2><p>We have delved deep into modularity: its importance, its various consequences on our system and its different implementations. More specifically, we have compared having a single unit of deployment, most often called a <em>(modular)monolith</em>, with multiple ones, most often called <em>(micro)services</em>. We also shed some light on the details of various modularity implementations and compared their tradeoffs, because, what is always worth reminding: there is no free lunch, nothing is free of consequences. To reiterate, we went through the following strategies, ordered from simplest to the most complex one:</p>
<ol>
<li>Simple Modular Monolith</li>
<li>Modular Monolith with Isolated and Independently Deployable Modules</li>
<li>Modular Monolith with Helper Services</li>
<li>Constrained Microservices  - <em><a href="https://www.ufried.com/blog/microservices_fallacy_10_microliths/">Microliths</a></em></li>
<li>Microservices</li>
</ol>
<p>We should thoughtfully consider which strategy meets our particular requirements and only then go for it. We can always transition to a more complex approach, so it is better to err on the side of simplicity. <strong>Design and architecture are art in the end, there are no final and absolute solutions, only tradeoffs, so weigh them and choose wisely!</strong></p>

        </div></div>
  </body>
</html>
