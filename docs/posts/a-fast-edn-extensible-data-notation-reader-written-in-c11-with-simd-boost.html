<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/DotFox/edn.c">Original</a>
    <h1>A fast EDN (Extensible Data Notation) reader written in C11 with SIMD boost</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">A fast, zero-copy EDN (Extensible Data Notation) reader written in C11 with SIMD acceleration.</p>
<p dir="auto"><a href="https://github.com/DotFox/edn.c/actions/workflows/ci.yml"><img src="https://github.com/DotFox/edn.c/workflows/CI/badge.svg" alt="CI"/></a>
<a href="https://opensource.org/licenses/MIT" rel="nofollow"><img src="https://camo.githubusercontent.com/08cef40a9105b6526ca22088bc514fbfdbc9aac1ddbf8d4e6c750e3a88a44dca/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4c6963656e73652d4d49542d626c75652e737667" alt="License: MIT" data-canonical-src="https://img.shields.io/badge/License-MIT-blue.svg"/></a></p>

<p dir="auto"><strong><a href="https://github.com/edn-format/edn">EDN (Extensible Data Notation)</a></strong> is a data format similar to JSON, but richer and more extensible. Think of it as &#34;JSON with superpowers&#34;:</p>
<ul dir="auto">
<li><strong>JSON-like foundation</strong>: Maps <code>{:key value}</code>, vectors <code>[1 2 3]</code>, strings, numbers, booleans, null (<code>nil</code>)</li>
<li><strong>Additional built-in types</strong>: Sets <code>#{:a :b}</code>, keywords <code>:keyword</code>, symbols <code>my-symbol</code>, characters <code>\newline</code>, lists <code>(1 2 3)</code></li>
<li><strong>Extensible via tagged literals</strong>: <code>#inst &#34;2024-01-01&#34;</code>, <code>#uuid &#34;...&#34;</code>‚Äîtransform data at parse time with custom readers</li>
<li><strong>Human-friendly</strong>: Comments, flexible whitespace, designed to be readable and writable by both humans and programs</li>
<li><strong>Language-agnostic</strong>: Originally from Clojure, but useful anywhere you need rich, extensible data interchange</li>
</ul>
<p dir="auto"><strong>Why EDN over JSON?</strong> More expressive types (keywords, symbols, sets), native extensibility through tags (no more <code>{&#34;__type&#34;: &#34;Date&#34;, &#34;value&#34;: &#34;...&#34;}</code> hacks), and better support for configuration files and data interchange in functional programming environments.</p>
<p dir="auto"><strong>Learn more:</strong> <a href="https://github.com/edn-format/edn">Official EDN specification</a></p>

<ul dir="auto">
<li><strong>üöÄ Fast</strong>: SIMD-accelerated parsing with NEON (ARM64), SSE4.2 (x86_64) and SIMD128 (WebAssembly) support</li>
<li><strong>üåê WebAssembly</strong>: Full WASM SIMD128 support for high-performance parsing in browsers and Node.js</li>
<li><strong>üíæ Zero-copy</strong>: Minimal allocations, references input data where possible</li>
<li><strong>üéØ Simple API</strong>: Easy-to-use interface with comprehensive type support</li>
<li><strong>üßπ Memory-safe</strong>: Arena allocator for efficient cleanup - single <code>edn_free()</code> call</li>
<li><strong>üîß Zero Dependencies</strong>: Pure C11 with standard library only</li>
<li><strong>‚úÖ Fully Tested</strong>: 340+ tests across 24 test suites</li>
<li><strong>üìñ UTF-8 Native</strong>: All string inputs and outputs are UTF-8 encoded</li>
<li><strong>üè∑Ô∏è Tagged Literals</strong>: Extensible data types with custom reader support</li>
<li><strong>üó∫Ô∏è Map Namespace Syntax</strong>: Clojure-compatible <code>#:ns{...}</code> syntax (optional, disabled by default)</li>
<li><strong>üî§ Extended Characters</strong>: <code>\formfeed</code>, <code>\backspace</code>, and octal <code>\oNNN</code> literals (optional, disabled by default)</li>
<li><strong>üìù Metadata</strong>: Clojure-style metadata <code>^{...}</code> syntax (optional, disabled by default)</li>
<li><strong>üìÑ Text Blocks</strong>: Java-style multi-line text blocks <code>&#34;&#34;&#34;\n...\n&#34;&#34;&#34;</code> (experimental, disabled by default)</li>
<li><strong>üî¢ Ratio Numbers</strong>: Clojure-compatible ratio literals <code>22/7</code> (optional, disabled by default)</li>
<li><strong>üî£ Extended Integers</strong>: Hex (<code>0xFF</code>), octal (<code>0777</code>), binary (<code>2r1010</code>), and arbitrary radix (<code>36rZZ</code>) formats (optional, disabled by default)</li>
<li><strong>üî¢ Underscore in Numeric Literals</strong>: Visual grouping with underscores <code>1_000_000</code>, <code>3.14_15_92</code>, <code>0xDE_AD_BE_EF</code> (optional, disabled by default)</li>
</ul>

<ul dir="auto">
<li><a href="#installation">Installation</a></li>
<li><a href="#quick-start">Quick Start</a></li>
<li><a href="#whitespace-and-control-characters">Whitespace and Control Characters</a></li>
<li><a href="#api-reference">API Reference</a>
<ul dir="auto">
<li><a href="#core-functions">Core Functions</a></li>
<li><a href="#type-system">Type System</a></li>
<li><a href="#scalar-types">Scalar Types</a></li>
<li><a href="#collections">Collections</a></li>
<li><a href="#tagged-literals">Tagged Literals</a></li>
<li><a href="#custom-readers">Custom Readers</a></li>
<li><a href="#map-namespace-syntax">Map Namespace Syntax</a></li>
<li><a href="#extended-character-literals">Extended Character Literals</a></li>
<li><a href="#metadata">Metadata</a></li>
<li><a href="#text-blocks">Text Blocks</a></li>
<li><a href="#ratio-numbers">Ratio Numbers</a></li>
<li><a href="#extended-integer-formats">Extended Integer Formats</a></li>
<li><a href="#underscore-in-numeric-literals">Underscore in Numeric Literals</a></li>
</ul>
</li>
<li><a href="#examples">Examples</a></li>
<li><a href="#building">Building</a></li>
<li><a href="#performance">Performance</a></li>
<li><a href="#contributing">Contributing</a></li>
<li><a href="#license">License</a></li>
</ul>


<ul dir="auto">
<li>C11 compatible compiler (GCC 4.9+, Clang 3.1+, MSVC 2015+)</li>
<li>Make (Unix/macOS) or CMake (Windows/cross-platform)</li>
<li>Supported platforms:
<ul dir="auto">
<li><strong>macOS</strong> (Apple Silicon M1/M2/M3, Intel) - NEON/SSE4.2 SIMD</li>
<li><strong>Linux</strong> (ARM64, x86_64) - NEON/SSE4.2 SIMD</li>
<li><strong>Windows</strong> (x86_64, ARM64) - NEON/SSE4.2 SIMD via MSVC/MinGW/Clang</li>
<li><strong>WebAssembly</strong> - SIMD128 support for browsers and Node.js</li>
</ul>
</li>
</ul>

<p dir="auto"><strong>Unix/macOS/Linux:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="# Clone the repository
git clone https://github.com/DotFox/edn.c.git
cd edn.c

# Build static library (libedn.a)
make

# Run tests to verify build
make test"><pre><span><span>#</span> Clone the repository</span>
git clone https://github.com/DotFox/edn.c.git
<span>cd</span> edn.c

<span><span>#</span> Build static library (libedn.a)</span>
make

<span><span>#</span> Run tests to verify build</span>
make <span>test</span></pre></div>
<p dir="auto"><strong>Windows:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="# Clone the repository
git clone https://github.com/DotFox/edn.c.git
cd edn.c

# Build with CMake (works with MSVC, MinGW, Clang)
.\build.bat

# Or use PowerShell script
.\build.ps1 -Test"><pre><span><span>#</span> Clone the repository</span>
git clone https:<span>//</span><span>github.com</span><span>/</span>DotFox<span>/</span>edn.c.git
cd edn.c

<span><span>#</span> Build with CMake (works with MSVC, MinGW, Clang)</span>
.\<span>build.bat</span>

<span><span>#</span> Or use PowerShell script</span>
.\build.ps1 <span>-</span>Test</pre></div>
<p dir="auto">See <strong><a href="https://github.com/DotFox/edn.c/blob/main/docs/WINDOWS.md">docs/WINDOWS.md</a></strong> for detailed Windows build instructions.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Integrate Into Your Project</h3><a id="user-content-integrate-into-your-project" aria-label="Permalink: Integrate Into Your Project" href="#integrate-into-your-project"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><strong>Option 1: Link static library</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="# Compile your code
gcc -o myapp myapp.c -I/path/to/edn.c/include -L/path/to/edn.c -ledn

# Or add to your Makefile
CFLAGS += -I/path/to/edn.c/include
LDFLAGS += -L/path/to/edn.c -ledn"><pre><span><span>#</span> Compile your code</span>
gcc -o myapp myapp.c -I/path/to/edn.c/include -L/path/to/edn.c -ledn

<span><span>#</span> Or add to your Makefile</span>
CFLAGS += -I/path/to/edn.c/include
LDFLAGS += -L/path/to/edn.c -ledn</pre></div>
<p dir="auto"><strong>Option 2: Include source directly</strong></p>
<p dir="auto">Copy <code>include/edn.h</code> and all files from <code>src/</code> into your project and compile them together.</p>

<div dir="auto" data-snippet-clipboard-copy-content="#include &#34;edn.h&#34;
#include &lt;stdio.h&gt;

int main(void) {
    const char *input = &#34;{:name \&#34;Alice\&#34; :age 30 :languages [:clojure :rust]}&#34;;
    
    // Read EDN string
    edn_result_t result = edn_read(input, 0);
    
    if (result.error != EDN_OK) {
        fprintf(stderr, &#34;Parse error at line %zu, column %zu: %s\n&#34;,
                result.error_line, result.error_column, result.error_message);
        return 1;
    }
    
    // Access the parsed map
    edn_value_t *map = result.value;
    printf(&#34;Parsed map with %zu entries\n&#34;, edn_map_count(map));
    
    // Look up a value by key
    edn_result_t key_result = edn_read(&#34;:name&#34;, 0);
    edn_value_t *name_value = edn_map_lookup(map, key_result.value);
    
    if (name_value != NULL &amp;&amp; edn_type(name_value) == EDN_TYPE_STRING) {
        size_t len;
        const char *name = edn_string_get(name_value, &amp;len);
        printf(&#34;Name: %.*s\n&#34;, (int)len, name);
    }
    
    // Clean up - frees all allocated memory
    edn_free(key_result.value);
    edn_free(map);
    
    return 0;
}"><pre><span>#include</span> <span>&#34;edn.h&#34;</span>
<span>#include</span> <span>&lt;stdio.h&gt;</span>

<span>int</span> <span>main</span>(<span>void</span>) {
    <span>const</span> <span>char</span> <span>*</span><span>input</span> <span>=</span> <span>&#34;{:name \&#34;Alice\&#34; :age 30 :languages [:clojure :rust]}&#34;</span>;
    
    <span>// Read EDN string</span>
    <span>edn_result_t</span> <span>result</span> <span>=</span> <span>edn_read</span>(<span>input</span>, <span>0</span>);
    
    <span>if</span> (<span>result</span>.<span>error</span> <span>!=</span> <span>EDN_OK</span>) {
        <span>fprintf</span>(<span>stderr</span>, <span>&#34;Parse error at line %zu, column %zu: %s\n&#34;</span>,
                <span>result</span>.<span>error_line</span>, <span>result</span>.<span>error_column</span>, <span>result</span>.<span>error_message</span>);
        <span>return</span> <span>1</span>;
    }
    
    <span>// Access the parsed map</span>
    <span>edn_value_t</span> <span>*</span><span>map</span> <span>=</span> <span>result</span>.<span>value</span>;
    <span>printf</span>(<span>&#34;Parsed map with %zu entries\n&#34;</span>, <span>edn_map_count</span>(<span>map</span>));
    
    <span>// Look up a value by key</span>
    <span>edn_result_t</span> <span>key_result</span> <span>=</span> <span>edn_read</span>(<span>&#34;:name&#34;</span>, <span>0</span>);
    <span>edn_value_t</span> <span>*</span><span>name_value</span> <span>=</span> <span>edn_map_lookup</span>(<span>map</span>, <span>key_result</span>.<span>value</span>);
    
    <span>if</span> (<span>name_value</span> <span>!=</span> <span>NULL</span> <span>&amp;&amp;</span> <span>edn_type</span>(<span>name_value</span>) <span>==</span> <span>EDN_TYPE_STRING</span>) {
        <span>size_t</span> <span>len</span>;
        <span>const</span> <span>char</span> <span>*</span><span>name</span> <span>=</span> <span>edn_string_get</span>(<span>name_value</span>, <span>&amp;</span><span>len</span>);
        <span>printf</span>(<span>&#34;Name: %.*s\n&#34;</span>, (<span>int</span>)<span>len</span>, <span>name</span>);
    }
    
    <span>// Clean up - frees all allocated memory</span>
    <span>edn_free</span>(<span>key_result</span>.<span>value</span>);
    <span>edn_free</span>(<span>map</span>);
    
    <span>return</span> <span>0</span>;
}</pre></div>
<p dir="auto"><strong>Output:</strong></p>
<div data-snippet-clipboard-copy-content="Parsed map with 3 entries
Name: Alice"><pre><code>Parsed map with 3 entries
Name: Alice
</code></pre></div>
<div dir="auto"><h2 tabindex="-1" dir="auto">Whitespace and Control Characters</h2><a id="user-content-whitespace-and-control-characters" aria-label="Permalink: Whitespace and Control Characters" href="#whitespace-and-control-characters"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">EDN.C follows Clojure&#39;s exact behavior for whitespace and control character handling:</p>

<p dir="auto">The following characters act as <strong>whitespace delimiters</strong> (separate tokens):</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Character</th>
<th>Hex</th>
<th>Name</th>
<th>Common Use</th>
</tr>
</thead>
<tbody>
<tr>
<td><code> </code></td>
<td>0x20</td>
<td>Space</td>
<td>Standard spacing</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>0x09</td>
<td>Tab</td>
<td>Indentation</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>0x0A</td>
<td>Line Feed (LF)</td>
<td>Unix line ending</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>0x0D</td>
<td>Carriage Return (CR)</td>
<td>Windows line ending</td>
</tr>
<tr>
<td><code>\f</code></td>
<td>0x0C</td>
<td>Form Feed</td>
<td>Page break</td>
</tr>
<tr>
<td><code>\v</code></td>
<td>0x0B</td>
<td>Vertical Tab</td>
<td>Vertical spacing</td>
</tr>
<tr>
<td><code>,</code></td>
<td>0x2C</td>
<td>Comma</td>
<td>Optional separator</td>
</tr>
<tr>
<td>FS</td>
<td>0x1C</td>
<td>File Separator</td>
<td>Data separation</td>
</tr>
<tr>
<td>GS</td>
<td>0x1D</td>
<td>Group Separator</td>
<td>Data separation</td>
</tr>
<tr>
<td>RS</td>
<td>0x1E</td>
<td>Record Separator</td>
<td>Data separation</td>
</tr>
<tr>
<td>US</td>
<td>0x1F</td>
<td>Unit Separator</td>
<td>Data separation</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto"><strong>Examples:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="// All of these parse as vectors with 3 elements:
edn_read(&#34;[1 2 3]&#34;, 0);          // spaces
edn_read(&#34;[1,2,3]&#34;, 0);          // commas
edn_read(&#34;[1\t2\n3]&#34;, 0);        // tabs and newlines
edn_read(&#34;[1\f2\x1C3]&#34;, 0);      // formfeed and file separator"><pre><span>// All of these parse as vectors with 3 elements:</span>
<span>edn_read</span>(<span>&#34;[1 2 3]&#34;</span>, <span>0</span>);          <span>// spaces</span>
<span>edn_read</span>(<span>&#34;[1,2,3]&#34;</span>, <span>0</span>);          <span>// commas</span>
<span>edn_read</span>(<span>&#34;[1\t2\n3]&#34;</span>, <span>0</span>);        <span>// tabs and newlines</span>
<span>edn_read</span>(<span>&#34;[1\f2\x1C3]&#34;</span>, <span>0</span>);      <span>// formfeed and file separator</span></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Control Characters in Identifiers</h3><a id="user-content-control-characters-in-identifiers" aria-label="Permalink: Control Characters in Identifiers" href="#control-characters-in-identifiers"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Control characters <code>0x00-0x1F</code> (except whitespace delimiters) are <strong>valid in identifiers</strong> (symbols and keywords):</p>
<p dir="auto"><strong>Valid identifier characters:</strong></p>
<ul dir="auto">
<li><code>0x00</code> - <code>0x08</code>: NUL, SOH, STX, ETX, EOT, ENQ, ACK, BEL, Backspace</li>
<li><code>0x0E</code> - <code>0x1B</code>: Shift Out through Escape</li>
</ul>
<p dir="auto"><strong>Examples:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="// Backspace in symbol - valid!
edn_result_t r = edn_read(&#34;[\bfoo]&#34;, 0);  // 1-element vector
edn_vector_count(r.value);  // Returns 1
edn_free(r.value);

// Control characters in middle of identifier
const char input[] = {&#39;[&#39;, &#39;f&#39;, &#39;o&#39;, &#39;o&#39;, 0x08, &#39;b&#39;, &#39;a&#39;, &#39;r&#39;, &#39;]&#39;, 0};
r = edn_read(input, sizeof(input) - 1);
edn_vector_count(r.value);  // Returns 1 (symbol: &#34;foo\bbar&#34;)
edn_free(r.value);

// Versus whitespace - separates into 2 elements
edn_result_t r2 = edn_read(&#34;[foo\tbar]&#34;, 0);  // Tab is whitespace
edn_vector_count(r2.value);  // Returns 2 (symbols: &#34;foo&#34; and &#34;bar&#34;)
edn_free(r2.value);"><pre><span>// Backspace in symbol - valid!</span>
<span>edn_result_t</span> <span>r</span> <span>=</span> <span>edn_read</span>(<span>&#34;[\bfoo]&#34;</span>, <span>0</span>);  <span>// 1-element vector</span>
<span>edn_vector_count</span>(<span>r</span>.<span>value</span>);  <span>// Returns 1</span>
<span>edn_free</span>(<span>r</span>.<span>value</span>);

<span>// Control characters in middle of identifier</span>
<span>const</span> <span>char</span> <span>input</span>[] <span>=</span> {<span>&#39;[&#39;</span>, <span>&#39;f&#39;</span>, <span>&#39;o&#39;</span>, <span>&#39;o&#39;</span>, <span>0x08</span>, <span>&#39;b&#39;</span>, <span>&#39;a&#39;</span>, <span>&#39;r&#39;</span>, <span>&#39;]&#39;</span>, <span>0</span>};
<span>r</span> <span>=</span> <span>edn_read</span>(<span>input</span>, <span>sizeof</span>(<span>input</span>) <span>-</span> <span>1</span>);
<span>edn_vector_count</span>(<span>r</span>.<span>value</span>);  <span>// Returns 1 (symbol: &#34;foo\bbar&#34;)</span>
<span>edn_free</span>(<span>r</span>.<span>value</span>);

<span>// Versus whitespace - separates into 2 elements</span>
<span>edn_result_t</span> <span>r2</span> <span>=</span> <span>edn_read</span>(<span>&#34;[foo\tbar]&#34;</span>, <span>0</span>);  <span>// Tab is whitespace</span>
<span>edn_vector_count</span>(<span>r2</span>.<span>value</span>);  <span>// Returns 2 (symbols: &#34;foo&#34; and &#34;bar&#34;)</span>
<span>edn_free</span>(<span>r2</span>.<span>value</span>);</pre></div>
<p dir="auto"><strong>Note on null bytes (<code>0x00</code>):</strong> When using string literals with <code>strlen()</code>, null bytes will truncate the string. Always pass explicit length for data containing null bytes:</p>
<div dir="auto" data-snippet-clipboard-copy-content="const char data[] = {&#39;[&#39;, &#39;a&#39;, 0x00, &#39;b&#39;, &#39;]&#39;, 0};
edn_result_t r = edn_read(data, 5);  // Pass exact length: 5 bytes (excluding terminator)"><pre><span>const</span> <span>char</span> <span>data</span>[] <span>=</span> {<span>&#39;[&#39;</span>, <span>&#39;a&#39;</span>, <span>0x00</span>, <span>&#39;b&#39;</span>, <span>&#39;]&#39;</span>, <span>0</span>};
<span>edn_result_t</span> <span>r</span> <span>=</span> <span>edn_read</span>(<span>data</span>, <span>5</span>);  <span>// Pass exact length: 5 bytes (excluding terminator)</span></pre></div>



<p dir="auto">Read EDN from a UTF-8 string.</p>
<div dir="auto" data-snippet-clipboard-copy-content="edn_result_t edn_read(const char *input, size_t length);"><pre><span>edn_result_t</span> <span>edn_read</span>(<span>const</span> <span>char</span> <span>*</span><span>input</span>, <span>size_t</span> <span>length</span>);</pre></div>
<p dir="auto"><strong>Parameters:</strong></p>
<ul dir="auto">
<li><code>input</code>: UTF-8 encoded string containing EDN data (must remain valid for zero-copy strings)</li>
<li><code>length</code>: Length of input in bytes, or <code>0</code> to use <code>strlen(input)</code></li>
</ul>
<p dir="auto"><strong>Returns:</strong> <code>edn_result_t</code> containing:</p>
<ul dir="auto">
<li><code>value</code>: Parsed EDN value (NULL on error)</li>
<li><code>error</code>: Error code (<code>EDN_OK</code> on success)</li>
<li><code>error_line</code>, <code>error_column</code>: Error location (1-indexed)</li>
<li><code>error_message</code>: Human-readable error description</li>
</ul>
<p dir="auto"><strong>Important:</strong> The returned value must be freed with <code>edn_free()</code>.</p>

<p dir="auto">Free an EDN value and all associated memory.</p>
<div dir="auto" data-snippet-clipboard-copy-content="void edn_free(edn_value_t *value);"><pre><span>void</span> <span>edn_free</span>(<span>edn_value_t</span> <span>*</span><span>value</span>);</pre></div>
<p dir="auto"><strong>Parameters:</strong></p>
<ul dir="auto">
<li><code>value</code>: Value to free (may be NULL)</li>
</ul>
<p dir="auto"><strong>Note:</strong> This frees the entire value tree. Do not call <code>free()</code> on individual values.</p>

<p dir="auto">Get the type of an EDN value.</p>
<div dir="auto" data-snippet-clipboard-copy-content="edn_type_t edn_type(const edn_value_t *value);"><pre><span>edn_type_t</span> <span>edn_type</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>);</pre></div>
<p dir="auto"><strong>Returns:</strong> One of:</p>
<ul dir="auto">
<li><code>EDN_TYPE_NIL</code></li>
<li><code>EDN_TYPE_BOOL</code></li>
<li><code>EDN_TYPE_INT</code> (int64_t)</li>
<li><code>EDN_TYPE_BIGINT</code> (arbitrary precision integer)</li>
<li><code>EDN_TYPE_FLOAT</code> (double)</li>
<li><code>EDN_TYPE_BIGDEC</code> (exact precision decimal)</li>
<li><code>EDN_TYPE_RATIO</code> (rational number, requires <code>RATIO=1</code> build flag)</li>
<li><code>EDN_TYPE_CHARACTER</code> (Unicode codepoint)</li>
<li><code>EDN_TYPE_STRING</code></li>
<li><code>EDN_TYPE_SYMBOL</code></li>
<li><code>EDN_TYPE_KEYWORD</code></li>
<li><code>EDN_TYPE_LIST</code></li>
<li><code>EDN_TYPE_VECTOR</code></li>
<li><code>EDN_TYPE_MAP</code></li>
<li><code>EDN_TYPE_SET</code></li>
<li><code>EDN_TYPE_TAGGED</code></li>
</ul>


<div dir="auto" data-snippet-clipboard-copy-content="typedef enum {
    EDN_OK = 0,                    // Success
    EDN_ERROR_INVALID_SYNTAX,      // Syntax error
    EDN_ERROR_UNEXPECTED_EOF,      // Unexpected end of input
    EDN_ERROR_OUT_OF_MEMORY,       // Allocation failure
    EDN_ERROR_INVALID_UTF8,        // Invalid UTF-8 sequence
    EDN_ERROR_INVALID_NUMBER,      // Malformed number
    EDN_ERROR_INVALID_STRING,      // Malformed string
    EDN_ERROR_INVALID_ESCAPE,      // Invalid escape sequence
    EDN_ERROR_UNMATCHED_DELIMITER, // Mismatched brackets
    EDN_ERROR_UNKNOWN_TAG,         // Unregistered tag (with ERROR mode)
    EDN_ERROR_DUPLICATE_KEY,       // Map has duplicate keys
    EDN_ERROR_DUPLICATE_ELEMENT    // Set has duplicate elements
} edn_error_t;"><pre><span>typedef</span> <span>enum</span> {
    <span>EDN_OK</span> <span>=</span> <span>0</span>,                    <span>// Success</span>
    <span>EDN_ERROR_INVALID_SYNTAX</span>,      <span>// Syntax error</span>
    <span>EDN_ERROR_UNEXPECTED_EOF</span>,      <span>// Unexpected end of input</span>
    <span>EDN_ERROR_OUT_OF_MEMORY</span>,       <span>// Allocation failure</span>
    <span>EDN_ERROR_INVALID_UTF8</span>,        <span>// Invalid UTF-8 sequence</span>
    <span>EDN_ERROR_INVALID_NUMBER</span>,      <span>// Malformed number</span>
    <span>EDN_ERROR_INVALID_STRING</span>,      <span>// Malformed string</span>
    <span>EDN_ERROR_INVALID_ESCAPE</span>,      <span>// Invalid escape sequence</span>
    <span>EDN_ERROR_UNMATCHED_DELIMITER</span>, <span>// Mismatched brackets</span>
    <span>EDN_ERROR_UNKNOWN_TAG</span>,         <span>// Unregistered tag (with ERROR mode)</span>
    <span>EDN_ERROR_DUPLICATE_KEY</span>,       <span>// Map has duplicate keys</span>
    <span>EDN_ERROR_DUPLICATE_ELEMENT</span>    <span>// Set has duplicate elements</span>
} <span>edn_error_t</span>;</pre></div>


<div dir="auto" data-snippet-clipboard-copy-content="const char *edn_string_get(const edn_value_t *value, size_t *length);"><pre><span>const</span> <span>char</span> <span>*</span><span>edn_string_get</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>, <span>size_t</span> <span>*</span><span>length</span>);</pre></div>
<p dir="auto">Get UTF-8 string data. Returns NULL if value is not a string.</p>
<p dir="auto"><strong>Lazy decoding:</strong> For strings without escapes, returns a pointer into the original input (zero-copy). For strings with escapes (<code>\n</code>, <code>\t</code>, <code>\&#34;</code>, etc.), decodes and caches the result on first call.</p>
<p dir="auto"><strong>Example:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="edn_result_t r = edn_read(&#34;\&#34;Hello, world!\&#34;&#34;, 0);
size_t len;
const char *str = edn_string_get(r.value, &amp;len);
printf(&#34;%.*s\n&#34;, (int)len, str);
edn_free(r.value);"><pre><span>edn_result_t</span> <span>r</span> <span>=</span> <span>edn_read</span>(<span>&#34;\&#34;Hello, world!\&#34;&#34;</span>, <span>0</span>);
<span>size_t</span> <span>len</span>;
<span>const</span> <span>char</span> <span>*</span><span>str</span> <span>=</span> <span>edn_string_get</span>(<span>r</span>.<span>value</span>, <span>&amp;</span><span>len</span>);
<span>printf</span>(<span>&#34;%.*s\n&#34;</span>, (<span>int</span>)<span>len</span>, <span>str</span>);
<span>edn_free</span>(<span>r</span>.<span>value</span>);</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="bool edn_is_nil(const edn_value_t *value);"><pre><span>bool</span> <span>edn_is_nil</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>);</pre></div>
<p dir="auto">Check if value is nil. Returns <code>true</code> if value is <code>EDN_TYPE_NIL</code>, <code>false</code> otherwise.</p>
<p dir="auto"><strong>Example:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="edn_result_t r = edn_read(&#34;nil&#34;, 0);
if (edn_is_nil(r.value)) {
    printf(&#34;Value is nil\n&#34;);
}
edn_free(r.value);"><pre><span>edn_result_t</span> <span>r</span> <span>=</span> <span>edn_read</span>(<span>&#34;nil&#34;</span>, <span>0</span>);
<span>if</span> (<span>edn_is_nil</span>(<span>r</span>.<span>value</span>)) {
    <span>printf</span>(<span>&#34;Value is nil\n&#34;</span>);
}
<span>edn_free</span>(<span>r</span>.<span>value</span>);</pre></div>
<div dir="auto" data-snippet-clipboard-copy-content="bool edn_bool_get(const edn_value_t *value, bool *out);"><pre><span>bool</span> <span>edn_bool_get</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>, <span>bool</span> <span>*</span><span>out</span>);</pre></div>
<p dir="auto">Get boolean value. Returns <code>true</code> if value is <code>EDN_TYPE_BOOL</code>, <code>false</code> otherwise.</p>
<p dir="auto"><strong>Example:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="edn_result_t r = edn_read(&#34;true&#34;, 0);
bool val;
if (edn_bool_get(r.value, &amp;val)) {
    printf(&#34;Boolean: %s\n&#34;, val ? &#34;true&#34; : &#34;false&#34;);
}
edn_free(r.value);"><pre><span>edn_result_t</span> <span>r</span> <span>=</span> <span>edn_read</span>(<span>&#34;true&#34;</span>, <span>0</span>);
<span>bool</span> <span>val</span>;
<span>if</span> (<span>edn_bool_get</span>(<span>r</span>.<span>value</span>, <span>&amp;</span><span>val</span>)) {
    <span>printf</span>(<span>&#34;Boolean: %s\n&#34;</span>, <span>val</span> ? <span>&#34;true&#34;</span> : <span>&#34;false&#34;</span>);
}
<span>edn_free</span>(<span>r</span>.<span>value</span>);</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="bool edn_int64_get(const edn_value_t *value, int64_t *out);"><pre><span>bool</span> <span>edn_int64_get</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>, <span>int64_t</span> <span>*</span><span>out</span>);</pre></div>
<p dir="auto">Get int64_t value. Returns <code>true</code> if value is <code>EDN_TYPE_INT</code>, <code>false</code> otherwise.</p>
<p dir="auto"><strong>Example:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="edn_result_t r = edn_read(&#34;42&#34;, 0);
int64_t num;
if (edn_int64_get(r.value, &amp;num)) {
    printf(&#34;Number: %lld\n&#34;, (long long)num);
}
edn_free(r.value);"><pre><span>edn_result_t</span> <span>r</span> <span>=</span> <span>edn_read</span>(<span>&#34;42&#34;</span>, <span>0</span>);
<span>int64_t</span> <span>num</span>;
<span>if</span> (<span>edn_int64_get</span>(<span>r</span>.<span>value</span>, <span>&amp;</span><span>num</span>)) {
    <span>printf</span>(<span>&#34;Number: %lld\n&#34;</span>, (<span>long long</span>)<span>num</span>);
}
<span>edn_free</span>(<span>r</span>.<span>value</span>);</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="const char *edn_bigint_get(const edn_value_t *value, size_t *length,
                           bool *negative, uint8_t *radix);"><pre><span>const</span> <span>char</span> <span>*</span><span>edn_bigint_get</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>, <span>size_t</span> <span>*</span><span>length</span>,
                           <span>bool</span> <span>*</span><span>negative</span>, <span>uint8_t</span> <span>*</span><span>radix</span>);</pre></div>
<p dir="auto">Get big integer digit string for use with external libraries (GMP, OpenSSL BIGNUM, etc.).</p>
<p dir="auto"><strong>Parameters:</strong></p>
<ul dir="auto">
<li><code>value</code>: EDN big integer value</li>
<li><code>length</code>: Output for digit string length (may be NULL)</li>
<li><code>negative</code>: Output for sign flag (may be NULL)</li>
<li><code>radix</code>: Output for number base: 10, 16, 8, or 2 (may be NULL)</li>
</ul>
<p dir="auto"><strong>Returns:</strong> Digit string, or NULL if not a big integer.</p>
<p dir="auto"><strong>Clojure Compatibility:</strong> The <code>N</code> suffix forces BigInt for base-10 integers.</p>
<ul dir="auto">
<li><code>42N</code> ‚Üí BigInt &#34;42&#34; (forced BigInt even though it fits in int64)</li>
<li><code>999999999999999999999999999</code> ‚Üí BigInt (overflow detection)</li>
<li><code>0xDEADBEEFN</code> ‚Üí Long (N is hex digit, not suffix)</li>
</ul>
<p dir="auto"><strong>Example:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="// BigInt from overflow
edn_result_t r = edn_read(&#34;999999999999999999999999999&#34;, 0);
size_t len;
bool neg;
uint8_t radix;
const char *digits = edn_bigint_get(r.value, &amp;len, &amp;neg, &amp;radix);
if (digits) {
    printf(&#34;%s%.*s (base %d)\n&#34;, neg ? &#34;-&#34; : &#34;&#34;, (int)len, digits, radix);
}
edn_free(r.value);

// BigInt with N suffix
edn_result_t r2 = edn_read(&#34;42N&#34;, 0);
digits = edn_bigint_get(r2.value, &amp;len, &amp;neg, &amp;radix);
// digits = &#34;42&#34;, len = 2, use with GMP: mpz_set_str(bigint, digits, radix)
edn_free(r2.value);"><pre><span>// BigInt from overflow</span>
<span>edn_result_t</span> <span>r</span> <span>=</span> <span>edn_read</span>(<span>&#34;999999999999999999999999999&#34;</span>, <span>0</span>);
<span>size_t</span> <span>len</span>;
<span>bool</span> <span>neg</span>;
<span>uint8_t</span> <span>radix</span>;
<span>const</span> <span>char</span> <span>*</span><span>digits</span> <span>=</span> <span>edn_bigint_get</span>(<span>r</span>.<span>value</span>, <span>&amp;</span><span>len</span>, <span>&amp;</span><span>neg</span>, <span>&amp;</span><span>radix</span>);
<span>if</span> (<span>digits</span>) {
    <span>printf</span>(<span>&#34;%s%.*s (base %d)\n&#34;</span>, <span>neg</span> ? <span>&#34;-&#34;</span> : <span>&#34;&#34;</span>, (<span>int</span>)<span>len</span>, <span>digits</span>, <span>radix</span>);
}
<span>edn_free</span>(<span>r</span>.<span>value</span>);

<span>// BigInt with N suffix</span>
<span>edn_result_t</span> <span>r2</span> <span>=</span> <span>edn_read</span>(<span>&#34;42N&#34;</span>, <span>0</span>);
<span>digits</span> <span>=</span> <span>edn_bigint_get</span>(<span>r2</span>.<span>value</span>, <span>&amp;</span><span>len</span>, <span>&amp;</span><span>neg</span>, <span>&amp;</span><span>radix</span>);
<span>// digits = &#34;42&#34;, len = 2, use with GMP: mpz_set_str(bigint, digits, radix)</span>
<span>edn_free</span>(<span>r2</span>.<span>value</span>);</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="bool edn_double_get(const edn_value_t *value, double *out);"><pre><span>bool</span> <span>edn_double_get</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>, <span>double</span> <span>*</span><span>out</span>);</pre></div>
<p dir="auto">Get double value. Returns <code>true</code> if value is <code>EDN_TYPE_FLOAT</code>, <code>false</code> otherwise.</p>
<div dir="auto" data-snippet-clipboard-copy-content="bool edn_number_as_double(const edn_value_t *value, double *out);"><pre><span>bool</span> <span>edn_number_as_double</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>, <span>double</span> <span>*</span><span>out</span>);</pre></div>
<p dir="auto">Convert any numeric type (INT, BIGINT, FLOAT, BIGDEC) to double. May lose precision for large numbers.</p>
<p dir="auto"><strong>Example:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="edn_result_t r = edn_read(&#34;3.14159&#34;, 0);
double num;
if (edn_double_get(r.value, &amp;num)) {
    printf(&#34;Pi: %.5f\n&#34;, num);
}
edn_free(r.value);"><pre><span>edn_result_t</span> <span>r</span> <span>=</span> <span>edn_read</span>(<span>&#34;3.14159&#34;</span>, <span>0</span>);
<span>double</span> <span>num</span>;
<span>if</span> (<span>edn_double_get</span>(<span>r</span>.<span>value</span>, <span>&amp;</span><span>num</span>)) {
    <span>printf</span>(<span>&#34;Pi: %.5f\n&#34;</span>, <span>num</span>);
}
<span>edn_free</span>(<span>r</span>.<span>value</span>);</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="const char *edn_bigdec_get(const edn_value_t *value, size_t *length, bool *negative);"><pre><span>const</span> <span>char</span> <span>*</span><span>edn_bigdec_get</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>, <span>size_t</span> <span>*</span><span>length</span>, <span>bool</span> <span>*</span><span>negative</span>);</pre></div>
<p dir="auto">Get big decimal string for use with external libraries (Java BigDecimal, Python Decimal, etc.).</p>
<p dir="auto"><strong>Parameters:</strong></p>
<ul dir="auto">
<li><code>value</code>: EDN big decimal value</li>
<li><code>length</code>: Output for string length (may be NULL)</li>
<li><code>negative</code>: Output for sign flag (may be NULL)</li>
</ul>
<p dir="auto"><strong>Returns:</strong> Decimal string, or NULL if not a big decimal.</p>
<p dir="auto"><strong>Clojure Compatibility:</strong> The <code>M</code> suffix forces exact precision decimal representation.</p>
<ul dir="auto">
<li><code>42M</code> ‚Üí BigDecimal &#34;42&#34; (integer with M suffix)</li>
<li><code>3.14M</code> ‚Üí BigDecimal &#34;3.14&#34;</li>
<li><code>1.5e10M</code> ‚Üí BigDecimal &#34;1.5e10&#34;</li>
</ul>
<p dir="auto"><strong>Example:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="// BigDecimal from float
edn_result_t r1 = edn_read(&#34;3.14159265358979323846M&#34;, 0);
size_t len;
bool neg;
const char *decimal = edn_bigdec_get(r1.value, &amp;len, &amp;neg);
if (decimal) {
    printf(&#34;%s%.*s\n&#34;, neg ? &#34;-&#34; : &#34;&#34;, (int)len, decimal);
    // Use with: Java BigDecimal(decimal), Python Decimal(decimal), etc.
}
edn_free(r1.value);

// BigDecimal from integer with M suffix
edn_result_t r2 = edn_read(&#34;42M&#34;, 0);
decimal = edn_bigdec_get(r2.value, &amp;len, &amp;neg);
// decimal = &#34;42&#34;, application can convert to BigDecimal
edn_free(r2.value);"><pre><span>// BigDecimal from float</span>
<span>edn_result_t</span> <span>r1</span> <span>=</span> <span>edn_read</span>(<span>&#34;3.14159265358979323846M&#34;</span>, <span>0</span>);
<span>size_t</span> <span>len</span>;
<span>bool</span> <span>neg</span>;
<span>const</span> <span>char</span> <span>*</span><span>decimal</span> <span>=</span> <span>edn_bigdec_get</span>(<span>r1</span>.<span>value</span>, <span>&amp;</span><span>len</span>, <span>&amp;</span><span>neg</span>);
<span>if</span> (<span>decimal</span>) {
    <span>printf</span>(<span>&#34;%s%.*s\n&#34;</span>, <span>neg</span> ? <span>&#34;-&#34;</span> : <span>&#34;&#34;</span>, (<span>int</span>)<span>len</span>, <span>decimal</span>);
    <span>// Use with: Java BigDecimal(decimal), Python Decimal(decimal), etc.</span>
}
<span>edn_free</span>(<span>r1</span>.<span>value</span>);

<span>// BigDecimal from integer with M suffix</span>
<span>edn_result_t</span> <span>r2</span> <span>=</span> <span>edn_read</span>(<span>&#34;42M&#34;</span>, <span>0</span>);
<span>decimal</span> <span>=</span> <span>edn_bigdec_get</span>(<span>r2</span>.<span>value</span>, <span>&amp;</span><span>len</span>, <span>&amp;</span><span>neg</span>);
<span>// decimal = &#34;42&#34;, application can convert to BigDecimal</span>
<span>edn_free</span>(<span>r2</span>.<span>value</span>);</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="bool edn_ratio_get(const edn_value_t *value, int64_t *numerator, int64_t *denominator);"><pre><span>bool</span> <span>edn_ratio_get</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>, <span>int64_t</span> <span>*</span><span>numerator</span>, <span>int64_t</span> <span>*</span><span>denominator</span>);</pre></div>
<p dir="auto">Get ratio numerator and denominator. Returns <code>true</code> if value is <code>EDN_TYPE_RATIO</code>, <code>false</code> otherwise.</p>
<p dir="auto"><strong>Parameters:</strong></p>
<ul dir="auto">
<li><code>value</code>: EDN ratio value</li>
<li><code>numerator</code>: Output for numerator (may be NULL)</li>
<li><code>denominator</code>: Output for denominator (may be NULL)</li>
</ul>
<p dir="auto"><strong>Returns:</strong> <code>true</code> if value is a ratio, <code>false</code> otherwise.</p>
<p dir="auto"><strong>Clojure Compatibility:</strong> Ratios represent exact rational numbers as numerator/denominator pairs.</p>
<ul dir="auto">
<li><code>22/7</code> ‚Üí Ratio with numerator=22, denominator=7</li>
<li><code>-3/4</code> ‚Üí Ratio with numerator=-3, denominator=4 (negative numerator)</li>
<li><code>1/2</code> ‚Üí Ratio with numerator=1, denominator=2</li>
<li><code>3/6</code> ‚Üí Automatically reduced to ratio 1/2</li>
<li><code>10/5</code> ‚Üí Automatically reduced to integer 2 (ratios with denominator 1 become integers)</li>
<li><code>0/5</code> ‚Üí Returns integer 0 (zero numerator always becomes integer 0)</li>
<li><code>0777/3</code> ‚Üí Returns 777/2</li>
<li><code>0777/0777</code> ‚Üí Returns 1</li>
</ul>
<p dir="auto"><strong>Automatic Reduction:</strong>
Ratios are automatically reduced to lowest terms using the Binary GCD algorithm (Stein&#39;s algorithm):</p>
<ul dir="auto">
<li><code>6/9</code> ‚Üí Reduced to <code>2/3</code></li>
<li><code>100/25</code> ‚Üí Reduced to <code>4/1</code> ‚Üí Returns as integer <code>4</code></li>
</ul>
<p dir="auto"><strong>Restrictions:</strong></p>
<ul dir="auto">
<li>Only decimal (base-10) integers supported for both numerator and denominator</li>
<li>Octal (base-8) integers supported keeping compatibility with Clojure where it is <strong>incorrectly</strong> interpreted as decimal integers with leading zeros.</li>
<li>Both numerator and denominator must fit in <code>int64_t</code></li>
<li>Denominator must be positive (negative denominators are rejected)</li>
<li>Denominator cannot be zero</li>
<li>No whitespace allowed around <code>/</code></li>
<li>Hex and binary notations not supported for ratios</li>
</ul>
<p dir="auto"><strong>Example:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="// Parse ratio
edn_result_t r = edn_read(&#34;22/7&#34;, 0);

if (r.error == EDN_OK &amp;&amp; edn_type(r.value) == EDN_TYPE_RATIO) {
    int64_t num, den;
    edn_ratio_get(r.value, &amp;num, &amp;den);
    printf(&#34;Ratio: %lld/%lld\n&#34;, (long long)num, (long long)den);
    // Output: Ratio: 22/7

    // Convert to double for approximation
    double approx;
    edn_number_as_double(r.value, &amp;approx);
    printf(&#34;Approximation: %.10f\n&#34;, approx);
    // Output: Approximation: 3.1428571429
}

edn_free(r.value);

// Automatic reduction
edn_result_t r2 = edn_read(&#34;3/6&#34;, 0);
int64_t num2, den2;
edn_ratio_get(r2.value, &amp;num2, &amp;den2);
// num2 = 1, den2 = 2 (reduced from 3/6)
edn_free(r2.value);

// Reduction to integer
edn_result_t r3 = edn_read(&#34;10/5&#34;, 0);
assert(edn_type(r3.value) == EDN_TYPE_INT);
int64_t int_val;
edn_int64_get(r3.value, &amp;int_val);
// int_val = 2 (10/5 reduced to 2/1, returned as integer)
edn_free(r3.value);

// Negative ratios
edn_result_t r4 = edn_read(&#34;-3/4&#34;, 0);
int64_t num4, den4;
edn_ratio_get(r4.value, &amp;num4, &amp;den4);
// num4 = -3, den4 = 4 (numerator is negative, denominator is positive)
edn_free(r4.value);

// Error: zero denominator
edn_result_t r5 = edn_read(&#34;5/0&#34;, 0);
// r5.error == EDN_ERROR_INVALID_NUMBER
// r5.error_message == &#34;Ratio denominator cannot be zero&#34;

// Error: negative denominator (denominators must be positive)
edn_result_t r6 = edn_read(&#34;3/-4&#34;, 0);
// r6.error == EDN_ERROR_INVALID_NUMBER
// r6.error_message == &#34;Ratio denominator must be positive&#34;

// Error: hex not supported
edn_result_t r7 = edn_read(&#34;0x10/2&#34;, 0);
// Parses 0x10 as int, not as ratio"><pre><span>// Parse ratio</span>
<span>edn_result_t</span> <span>r</span> <span>=</span> <span>edn_read</span>(<span>&#34;22/7&#34;</span>, <span>0</span>);

<span>if</span> (<span>r</span>.<span>error</span> <span>==</span> <span>EDN_OK</span> <span>&amp;&amp;</span> <span>edn_type</span>(<span>r</span>.<span>value</span>) <span>==</span> <span>EDN_TYPE_RATIO</span>) {
    <span>int64_t</span> <span>num</span>, <span>den</span>;
    <span>edn_ratio_get</span>(<span>r</span>.<span>value</span>, <span>&amp;</span><span>num</span>, <span>&amp;</span><span>den</span>);
    <span>printf</span>(<span>&#34;Ratio: %lld/%lld\n&#34;</span>, (<span>long long</span>)<span>num</span>, (<span>long long</span>)<span>den</span>);
    <span>// Output: Ratio: 22/7</span>

    <span>// Convert to double for approximation</span>
    <span>double</span> <span>approx</span>;
    <span>edn_number_as_double</span>(<span>r</span>.<span>value</span>, <span>&amp;</span><span>approx</span>);
    <span>printf</span>(<span>&#34;Approximation: %.10f\n&#34;</span>, <span>approx</span>);
    <span>// Output: Approximation: 3.1428571429</span>
}

<span>edn_free</span>(<span>r</span>.<span>value</span>);

<span>// Automatic reduction</span>
<span>edn_result_t</span> <span>r2</span> <span>=</span> <span>edn_read</span>(<span>&#34;3/6&#34;</span>, <span>0</span>);
<span>int64_t</span> <span>num2</span>, <span>den2</span>;
<span>edn_ratio_get</span>(<span>r2</span>.<span>value</span>, <span>&amp;</span><span>num2</span>, <span>&amp;</span><span>den2</span>);
<span>// num2 = 1, den2 = 2 (reduced from 3/6)</span>
<span>edn_free</span>(<span>r2</span>.<span>value</span>);

<span>// Reduction to integer</span>
<span>edn_result_t</span> <span>r3</span> <span>=</span> <span>edn_read</span>(<span>&#34;10/5&#34;</span>, <span>0</span>);
<span>assert</span>(<span>edn_type</span>(<span>r3</span>.<span>value</span>) <span>==</span> <span>EDN_TYPE_INT</span>);
<span>int64_t</span> <span>int_val</span>;
<span>edn_int64_get</span>(<span>r3</span>.<span>value</span>, <span>&amp;</span><span>int_val</span>);
<span>// int_val = 2 (10/5 reduced to 2/1, returned as integer)</span>
<span>edn_free</span>(<span>r3</span>.<span>value</span>);

<span>// Negative ratios</span>
<span>edn_result_t</span> <span>r4</span> <span>=</span> <span>edn_read</span>(<span>&#34;-3/4&#34;</span>, <span>0</span>);
<span>int64_t</span> <span>num4</span>, <span>den4</span>;
<span>edn_ratio_get</span>(<span>r4</span>.<span>value</span>, <span>&amp;</span><span>num4</span>, <span>&amp;</span><span>den4</span>);
<span>// num4 = -3, den4 = 4 (numerator is negative, denominator is positive)</span>
<span>edn_free</span>(<span>r4</span>.<span>value</span>);

<span>// Error: zero denominator</span>
<span>edn_result_t</span> <span>r5</span> <span>=</span> <span>edn_read</span>(<span>&#34;5/0&#34;</span>, <span>0</span>);
<span>// r5.error == EDN_ERROR_INVALID_NUMBER</span>
<span>// r5.error_message == &#34;Ratio denominator cannot be zero&#34;</span>

<span>// Error: negative denominator (denominators must be positive)</span>
<span>edn_result_t</span> <span>r6</span> <span>=</span> <span>edn_read</span>(<span>&#34;3/-4&#34;</span>, <span>0</span>);
<span>// r6.error == EDN_ERROR_INVALID_NUMBER</span>
<span>// r6.error_message == &#34;Ratio denominator must be positive&#34;</span>

<span>// Error: hex not supported</span>
<span>edn_result_t</span> <span>r7</span> <span>=</span> <span>edn_read</span>(<span>&#34;0x10/2&#34;</span>, <span>0</span>);
<span>// Parses 0x10 as int, not as ratio</span></pre></div>
<p dir="auto"><strong>Build Configuration:</strong></p>
<p dir="auto">This feature is disabled by default. To enable it:</p>
<p dir="auto"><strong>Make:</strong></p>

<p dir="auto"><strong>CMake:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="cmake -DEDN_ENABLE_RATIO=ON ..
make"><pre>cmake -DEDN_ENABLE_RATIO=ON ..
make</pre></div>
<p dir="auto">When disabled (default):</p>
<ul dir="auto">
<li><code>EDN_TYPE_RATIO</code> enum value is not available</li>
<li><code>edn_ratio_get()</code> function is not available</li>
</ul>
<p dir="auto"><strong>Note:</strong> Ratios are a Clojure language feature, not part of the official EDN specification. They&#39;re provided here for compatibility with Clojure&#39;s clojure.edn parser.</p>
<p dir="auto">See <code>test/test_numbers.c</code> for comprehensive ratio test examples.</p>

<p dir="auto">EDN.C supports Clojure-style special integer formats for hexadecimal, octal, binary, and arbitrary radix numbers. These are <strong>disabled by default</strong> as they are not part of the base EDN specification.</p>
<p dir="auto"><strong>Supported formats:</strong></p>
<ul dir="auto">
<li><strong>Hexadecimal</strong>: <code>0xFF</code>, <code>0x2A</code>, <code>-0x10</code> (base-16, prefix <code>0x</code> or <code>0X</code>)</li>
<li><strong>Octal</strong>: <code>0777</code>, <code>052</code>, <code>-0123</code> (base-8, leading zero followed by <code>0-7</code>)</li>
<li><strong>Binary</strong>: <code>2r1010</code>, <code>-2r1111</code> (base-2, radix notation)</li>
<li><strong>Arbitrary radix</strong>: <code>8r77</code>, <code>16rFF</code>, <code>36rZZ</code> (bases 2-36, radix notation <code>NrDDDD</code>)</li>
</ul>
<p dir="auto"><strong>Examples:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="// Hexadecimal
edn_result_t r1 = edn_read(&#34;0xFF&#34;, 0);
int64_t val1;
edn_int64_get(r1.value, &amp;val1);
// val1 = 255
edn_free(r1.value);

// Octal
edn_result_t r2 = edn_read(&#34;0777&#34;, 0);
int64_t val2;
edn_int64_get(r2.value, &amp;val2);
// val2 = 511 (7*64 + 7*8 + 7)
edn_free(r2.value);

// Binary (radix notation)
edn_result_t r3 = edn_read(&#34;2r1010&#34;, 0);
int64_t val3;
edn_int64_get(r3.value, &amp;val3);
// val3 = 10
edn_free(r3.value);

// Base-36 (radix notation)
edn_result_t r4 = edn_read(&#34;36rZZ&#34;, 0);
int64_t val4;
edn_int64_get(r4.value, &amp;val4);
// val4 = 1295 (35*36 + 35)
edn_free(r4.value);

// Negative hex
edn_result_t r5 = edn_read(&#34;-0x10&#34;, 0);
int64_t val5;
edn_int64_get(r5.value, &amp;val5);
// val5 = -16
edn_free(r5.value);"><pre><span>// Hexadecimal</span>
<span>edn_result_t</span> <span>r1</span> <span>=</span> <span>edn_read</span>(<span>&#34;0xFF&#34;</span>, <span>0</span>);
<span>int64_t</span> <span>val1</span>;
<span>edn_int64_get</span>(<span>r1</span>.<span>value</span>, <span>&amp;</span><span>val1</span>);
<span>// val1 = 255</span>
<span>edn_free</span>(<span>r1</span>.<span>value</span>);

<span>// Octal</span>
<span>edn_result_t</span> <span>r2</span> <span>=</span> <span>edn_read</span>(<span>&#34;0777&#34;</span>, <span>0</span>);
<span>int64_t</span> <span>val2</span>;
<span>edn_int64_get</span>(<span>r2</span>.<span>value</span>, <span>&amp;</span><span>val2</span>);
<span>// val2 = 511 (7*64 + 7*8 + 7)</span>
<span>edn_free</span>(<span>r2</span>.<span>value</span>);

<span>// Binary (radix notation)</span>
<span>edn_result_t</span> <span>r3</span> <span>=</span> <span>edn_read</span>(<span>&#34;2r1010&#34;</span>, <span>0</span>);
<span>int64_t</span> <span>val3</span>;
<span>edn_int64_get</span>(<span>r3</span>.<span>value</span>, <span>&amp;</span><span>val3</span>);
<span>// val3 = 10</span>
<span>edn_free</span>(<span>r3</span>.<span>value</span>);

<span>// Base-36 (radix notation)</span>
<span>edn_result_t</span> <span>r4</span> <span>=</span> <span>edn_read</span>(<span>&#34;36rZZ&#34;</span>, <span>0</span>);
<span>int64_t</span> <span>val4</span>;
<span>edn_int64_get</span>(<span>r4</span>.<span>value</span>, <span>&amp;</span><span>val4</span>);
<span>// val4 = 1295 (35*36 + 35)</span>
<span>edn_free</span>(<span>r4</span>.<span>value</span>);

<span>// Negative hex</span>
<span>edn_result_t</span> <span>r5</span> <span>=</span> <span>edn_read</span>(<span>&#34;-0x10&#34;</span>, <span>0</span>);
<span>int64_t</span> <span>val5</span>;
<span>edn_int64_get</span>(<span>r5</span>.<span>value</span>, <span>&amp;</span><span>val5</span>);
<span>// val5 = -16</span>
<span>edn_free</span>(<span>r5</span>.<span>value</span>);</pre></div>
<p dir="auto"><strong>Radix notation:</strong> <code>NrDDDD</code> where:</p>
<ul dir="auto">
<li><code>N</code> is the radix (base) from 2 to 36</li>
<li><code>r</code> is the radix separator</li>
<li><code>DDDD</code> are the digits (0-9, A-Z, case-insensitive for bases &gt; 10)</li>
</ul>
<p dir="auto"><strong>Build Configuration:</strong></p>
<p dir="auto">This feature is disabled by default. To enable it:</p>
<p dir="auto"><strong>Make:</strong></p>

<p dir="auto"><strong>CMake:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="cmake -DEDN_ENABLE_EXTENDED_INTEGERS=ON ..
make"><pre>cmake -DEDN_ENABLE_EXTENDED_INTEGERS=ON ..
make</pre></div>
<p dir="auto">When disabled (default):</p>
<ul dir="auto">
<li>Hexadecimal (<code>0xFF</code>), binary (<code>2r1010</code>), and radix notation (<code>36rZZ</code>) will fail to parse</li>
<li><strong>Leading zeros are forbidden</strong>: Numbers like <code>01</code>, <code>0123</code>, <code>0777</code> are rejected (per EDN spec)</li>
<li>Only <code>0</code> itself, or <code>0.5</code>, <code>0e10</code> (floats starting with zero) are allowed</li>
</ul>
<p dir="auto"><strong>Note:</strong> Extended integer formats are a Clojure language feature, not part of the official EDN specification. They&#39;re provided here for compatibility with Clojure&#39;s reader.</p>
<p dir="auto">See <code>test/test_numbers.c</code> for comprehensive extended integer format test examples.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Underscore in Numeric Literals</h3><a id="user-content-underscore-in-numeric-literals" aria-label="Permalink: Underscore in Numeric Literals" href="#underscore-in-numeric-literals"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">EDN.C supports underscores as visual separators in numeric literals for improved readability. This feature is <strong>disabled by default</strong> as it&#39;s not part of the base EDN specification.</p>
<p dir="auto"><strong>Supported number types:</strong></p>
<ul dir="auto">
<li><strong>Integers</strong>: <code>1_000</code>, <code>1_000_000</code>, <code>4____2</code> ‚Üí <code>1000</code>, <code>1000000</code>, <code>42</code></li>
<li><strong>Floats</strong>: <code>3.14_15_92</code>, <code>1_234.56_78</code> ‚Üí <code>3.141592</code>, <code>1234.5678</code></li>
<li><strong>Scientific notation</strong>: <code>1_500e10</code>, <code>1.5e1_0</code>, <code>1_5.2_5e1_0</code> ‚Üí <code>1500e10</code>, <code>1.5e10</code>, <code>15.25e10</code></li>
<li><strong>BigInt</strong>: <code>1_234_567_890_123_456_789N</code></li>
<li><strong>BigDecimal</strong>: <code>1_234.56_78M</code>, <code>1_5.2_5e1_0M</code></li>
<li><strong>Hexadecimal</strong> (with <code>EXTENDED_INTEGERS=1</code>): <code>0xDE_AD_BE_EF</code> ‚Üí <code>0xDEADBEEF</code></li>
<li><strong>Octal</strong> (with <code>EXTENDED_INTEGERS=1</code>): <code>07_77</code> ‚Üí <code>0777</code></li>
<li><strong>Binary</strong> (with <code>EXTENDED_INTEGERS=1</code>): <code>2r1010_1010</code> ‚Üí <code>170</code></li>
<li><strong>Radix notation</strong> (with <code>EXTENDED_INTEGERS=1</code>): <code>36rZ_Z</code> ‚Üí <code>1295</code></li>
</ul>
<p dir="auto"><strong>Rules:</strong></p>
<ul dir="auto">
<li>Underscores are only allowed <strong>between digits</strong> (not at start, end, or adjacent to special characters)</li>
<li>Multiple consecutive underscores are allowed: <code>4____2</code> is valid</li>
<li>Not allowed adjacent to decimal point: <code>123_.5</code> or <code>123._5</code> are invalid</li>
<li>Not allowed before/after exponent marker: <code>123_e10</code> or <code>123e_10</code> are invalid</li>
<li>Not allowed before suffix: <code>123_N</code> or <code>123.45_M</code> are invalid</li>
<li>Works with negative numbers: <code>-1_234</code> ‚Üí <code>-1234</code></li>
</ul>
<p dir="auto"><strong>Examples:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="// Credit card number formatting
edn_result_t r1 = edn_read(&#34;1234_5678_9012_3456&#34;, 0);
int64_t val1;
edn_int64_get(r1.value, &amp;val1);
// val1 = 1234567890123456
edn_free(r1.value);

// Pi with digit grouping
edn_result_t r2 = edn_read(&#34;3.14_15_92_65_35_89_79&#34;, 0);
double val2;
edn_double_get(r2.value, &amp;val2);
// val2 = 3.141592653589793
edn_free(r2.value);

// Hex bytes (requires EXTENDED_INTEGERS=1)
edn_result_t r3 = edn_read(&#34;0xFF_EC_DE_5E&#34;, 0);
int64_t val3;
edn_int64_get(r3.value, &amp;val3);
// val3 = 0xFFECDE5E
edn_free(r3.value);

// Large numbers with thousands separators
edn_result_t r4 = edn_read(&#34;1_000_000&#34;, 0);
int64_t val4;
edn_int64_get(r4.value, &amp;val4);
// val4 = 1000000
edn_free(r4.value);

// In collections
edn_result_t r5 = edn_read(&#34;[1_000 2_000 3_000]&#34;, 0);
// Three integers: 1000, 2000, 3000
edn_free(r5.value);"><pre><span>// Credit card number formatting</span>
<span>edn_result_t</span> <span>r1</span> <span>=</span> <span>edn_read</span>(<span>&#34;1234_5678_9012_3456&#34;</span>, <span>0</span>);
<span>int64_t</span> <span>val1</span>;
<span>edn_int64_get</span>(<span>r1</span>.<span>value</span>, <span>&amp;</span><span>val1</span>);
<span>// val1 = 1234567890123456</span>
<span>edn_free</span>(<span>r1</span>.<span>value</span>);

<span>// Pi with digit grouping</span>
<span>edn_result_t</span> <span>r2</span> <span>=</span> <span>edn_read</span>(<span>&#34;3.14_15_92_65_35_89_79&#34;</span>, <span>0</span>);
<span>double</span> <span>val2</span>;
<span>edn_double_get</span>(<span>r2</span>.<span>value</span>, <span>&amp;</span><span>val2</span>);
<span>// val2 = 3.141592653589793</span>
<span>edn_free</span>(<span>r2</span>.<span>value</span>);

<span>// Hex bytes (requires EXTENDED_INTEGERS=1)</span>
<span>edn_result_t</span> <span>r3</span> <span>=</span> <span>edn_read</span>(<span>&#34;0xFF_EC_DE_5E&#34;</span>, <span>0</span>);
<span>int64_t</span> <span>val3</span>;
<span>edn_int64_get</span>(<span>r3</span>.<span>value</span>, <span>&amp;</span><span>val3</span>);
<span>// val3 = 0xFFECDE5E</span>
<span>edn_free</span>(<span>r3</span>.<span>value</span>);

<span>// Large numbers with thousands separators</span>
<span>edn_result_t</span> <span>r4</span> <span>=</span> <span>edn_read</span>(<span>&#34;1_000_000&#34;</span>, <span>0</span>);
<span>int64_t</span> <span>val4</span>;
<span>edn_int64_get</span>(<span>r4</span>.<span>value</span>, <span>&amp;</span><span>val4</span>);
<span>// val4 = 1000000</span>
<span>edn_free</span>(<span>r4</span>.<span>value</span>);

<span>// In collections</span>
<span>edn_result_t</span> <span>r5</span> <span>=</span> <span>edn_read</span>(<span>&#34;[1_000 2_000 3_000]&#34;</span>, <span>0</span>);
<span>// Three integers: 1000, 2000, 3000</span>
<span>edn_free</span>(<span>r5</span>.<span>value</span>);</pre></div>
<p dir="auto"><strong>Invalid examples:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="// Underscore at start - parses as symbol
edn_read(&#34;_123&#34;, 0);  // Symbol, not number

// Underscore at end
edn_read(&#34;123_&#34;, 0);  // Error: EDN_ERROR_INVALID_NUMBER

// Adjacent to decimal point
edn_read(&#34;123_.5&#34;, 0);   // Error: EDN_ERROR_INVALID_NUMBER
edn_read(&#34;123._5&#34;, 0);   // Error: EDN_ERROR_INVALID_NUMBER

// Before/after exponent marker
edn_read(&#34;123_e10&#34;, 0);  // Error: EDN_ERROR_INVALID_NUMBER
edn_read(&#34;123e_10&#34;, 0);  // Error: EDN_ERROR_INVALID_NUMBER

// Before suffix
edn_read(&#34;123_N&#34;, 0);    // Error: EDN_ERROR_INVALID_NUMBER
edn_read(&#34;123.45_M&#34;, 0); // Error: EDN_ERROR_INVALID_NUMBER"><pre><span>// Underscore at start - parses as symbol</span>
<span>edn_read</span>(<span>&#34;_123&#34;</span>, <span>0</span>);  <span>// Symbol, not number</span>

<span>// Underscore at end</span>
<span>edn_read</span>(<span>&#34;123_&#34;</span>, <span>0</span>);  <span>// Error: EDN_ERROR_INVALID_NUMBER</span>

<span>// Adjacent to decimal point</span>
<span>edn_read</span>(<span>&#34;123_.5&#34;</span>, <span>0</span>);   <span>// Error: EDN_ERROR_INVALID_NUMBER</span>
<span>edn_read</span>(<span>&#34;123._5&#34;</span>, <span>0</span>);   <span>// Error: EDN_ERROR_INVALID_NUMBER</span>

<span>// Before/after exponent marker</span>
<span>edn_read</span>(<span>&#34;123_e10&#34;</span>, <span>0</span>);  <span>// Error: EDN_ERROR_INVALID_NUMBER</span>
<span>edn_read</span>(<span>&#34;123e_10&#34;</span>, <span>0</span>);  <span>// Error: EDN_ERROR_INVALID_NUMBER</span>

<span>// Before suffix</span>
<span>edn_read</span>(<span>&#34;123_N&#34;</span>, <span>0</span>);    <span>// Error: EDN_ERROR_INVALID_NUMBER</span>
<span>edn_read</span>(<span>&#34;123.45_M&#34;</span>, <span>0</span>); <span>// Error: EDN_ERROR_INVALID_NUMBER</span></pre></div>
<p dir="auto"><strong>Build Configuration:</strong></p>
<p dir="auto">This feature is disabled by default. To enable it:</p>
<p dir="auto"><strong>Make:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="make UNDERSCORE_IN_NUMERIC=1"><pre>make UNDERSCORE_IN_NUMERIC=1</pre></div>
<p dir="auto"><strong>CMake:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="cmake -DEDN_ENABLE_UNDERSCORE_IN_NUMERIC=ON ..
make"><pre>cmake -DEDN_ENABLE_UNDERSCORE_IN_NUMERIC=ON ..
make</pre></div>
<p dir="auto"><strong>Combined with other features:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="# Enable underscores with extended integers and ratios
make UNDERSCORE_IN_NUMERIC=1 EXTENDED_INTEGERS=1 RATIO=1"><pre><span><span>#</span> Enable underscores with extended integers and ratios</span>
make UNDERSCORE_IN_NUMERIC=1 EXTENDED_INTEGERS=1 RATIO=1</pre></div>
<p dir="auto">When disabled (default):</p>
<ul dir="auto">
<li>Numbers with underscores will fail to parse</li>
<li>The scanner will stop at the first underscore, treating it as an invalid number</li>
</ul>
<p dir="auto"><strong>Note:</strong> Underscores in numeric literals are a common feature in modern programming languages (Java, Rust, Python 3.6+, etc.) but are not part of the official EDN specification. This feature is provided for convenience and readability.</p>
<p dir="auto">See <code>test/test_underscore_numeric.c</code> for comprehensive test examples.</p>

<div dir="auto" data-snippet-clipboard-copy-content="bool edn_character_get(const edn_value_t *value, uint32_t *out);"><pre><span>bool</span> <span>edn_character_get</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>, <span>uint32_t</span> <span>*</span><span>out</span>);</pre></div>
<p dir="auto">Get Unicode codepoint. Returns <code>true</code> if value is <code>EDN_TYPE_CHARACTER</code>, <code>false</code> otherwise.</p>
<p dir="auto"><strong>Example:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="// Named characters: \newline, \tab, \space, \return
edn_result_t r1 = edn_read(&#34;\\newline&#34;, 0);
uint32_t cp1;
edn_character_get(r1.value, &amp;cp1);  // cp1 = 0x0A

// Unicode: \uXXXX or literal character
edn_result_t r2 = edn_read(&#34;\\u03B1&#34;, 0);  // Greek alpha
uint32_t cp2;
edn_character_get(r2.value, &amp;cp2);  // cp2 = 0x03B1

edn_free(r1.value);
edn_free(r2.value);"><pre><span>// Named characters: \newline, \tab, \space, \return</span>
<span>edn_result_t</span> <span>r1</span> <span>=</span> <span>edn_read</span>(<span>&#34;\\newline&#34;</span>, <span>0</span>);
<span>uint32_t</span> <span>cp1</span>;
<span>edn_character_get</span>(<span>r1</span>.<span>value</span>, <span>&amp;</span><span>cp1</span>);  <span>// cp1 = 0x0A</span>

<span>// Unicode: \uXXXX or literal character</span>
<span>edn_result_t</span> <span>r2</span> <span>=</span> <span>edn_read</span>(<span>&#34;\\u03B1&#34;</span>, <span>0</span>);  <span>// Greek alpha</span>
<span>uint32_t</span> <span>cp2</span>;
<span>edn_character_get</span>(<span>r2</span>.<span>value</span>, <span>&amp;</span><span>cp2</span>);  <span>// cp2 = 0x03B1</span>

<span>edn_free</span>(<span>r1</span>.<span>value</span>);
<span>edn_free</span>(<span>r2</span>.<span>value</span>);</pre></div>

<p dir="auto">Convenience functions for type checking:</p>
<div dir="auto" data-snippet-clipboard-copy-content="bool edn_is_nil(const edn_value_t *value);
bool edn_is_string(const edn_value_t *value);
bool edn_is_number(const edn_value_t *value);
bool edn_is_integer(const edn_value_t *value);
bool edn_is_collection(const edn_value_t *value);"><pre><span>bool</span> <span>edn_is_nil</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>);
<span>bool</span> <span>edn_is_string</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>);
<span>bool</span> <span>edn_is_number</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>);
<span>bool</span> <span>edn_is_integer</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>);
<span>bool</span> <span>edn_is_collection</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>);</pre></div>
<p dir="auto"><strong>Type predicate details:</strong></p>
<ul dir="auto">
<li><code>edn_is_nil()</code> - Returns <code>true</code> for <code>EDN_TYPE_NIL</code></li>
<li><code>edn_is_string()</code> - Returns <code>true</code> for <code>EDN_TYPE_STRING</code></li>
<li><code>edn_is_number()</code> - Returns <code>true</code> for any numeric type (INT, BIGINT, FLOAT, BIGDEC, RATIO)</li>
<li><code>edn_is_integer()</code> - Returns <code>true</code> for integer types (INT, BIGINT)</li>
<li><code>edn_is_collection()</code> - Returns <code>true</code> for collections (LIST, VECTOR, MAP, SET)</li>
</ul>
<p dir="auto"><strong>Example:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="edn_result_t r = edn_read(&#34;[42 \&#34;hello\&#34; [1 2] {:a 1}]&#34;, 0);

if (edn_is_collection(r.value)) {
    for (size_t i = 0; i &lt; edn_vector_count(r.value); i++) {
        edn_value_t* elem = edn_vector_get(r.value, i);

        if (edn_is_number(elem)) {
            printf(&#34;Found number\n&#34;);
        } else if (edn_is_string(elem)) {
            printf(&#34;Found string\n&#34;);
        } else if (edn_is_collection(elem)) {
            printf(&#34;Found nested collection\n&#34;);
        }
    }
}

edn_free(r.value);"><pre><span>edn_result_t</span> <span>r</span> <span>=</span> <span>edn_read</span>(<span>&#34;[42 \&#34;hello\&#34; [1 2] {:a 1}]&#34;</span>, <span>0</span>);

<span>if</span> (<span>edn_is_collection</span>(<span>r</span>.<span>value</span>)) {
    <span>for</span> (<span>size_t</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>edn_vector_count</span>(<span>r</span>.<span>value</span>); <span>i</span><span>++</span>) {
        <span>edn_value_t</span><span>*</span> <span>elem</span> <span>=</span> <span>edn_vector_get</span>(<span>r</span>.<span>value</span>, <span>i</span>);

        <span>if</span> (<span>edn_is_number</span>(<span>elem</span>)) {
            <span>printf</span>(<span>&#34;Found number\n&#34;</span>);
        } <span>else</span> <span>if</span> (<span>edn_is_string</span>(<span>elem</span>)) {
            <span>printf</span>(<span>&#34;Found string\n&#34;</span>);
        } <span>else</span> <span>if</span> (<span>edn_is_collection</span>(<span>elem</span>)) {
            <span>printf</span>(<span>&#34;Found nested collection\n&#34;</span>);
        }
    }
}

<span>edn_free</span>(<span>r</span>.<span>value</span>);</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="bool edn_string_equals(const edn_value_t *value, const char *str);"><pre><span>bool</span> <span>edn_string_equals</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>, <span>const</span> <span>char</span> <span>*</span><span>str</span>);</pre></div>
<p dir="auto">Compare EDN string with C string for equality. Returns <code>true</code> if equal, <code>false</code> otherwise.</p>
<p dir="auto"><strong>Example:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="edn_result_t r = edn_read(&#34;{:status \&#34;active\&#34;}&#34;, 0);
edn_value_t* status = edn_map_get_keyword(r.value, &#34;status&#34;);

if (edn_string_equals(status, &#34;active&#34;)) {
    printf(&#34;Status is active\n&#34;);
}

edn_free(r.value);"><pre><span>edn_result_t</span> <span>r</span> <span>=</span> <span>edn_read</span>(<span>&#34;{:status \&#34;active\&#34;}&#34;</span>, <span>0</span>);
<span>edn_value_t</span><span>*</span> <span>status</span> <span>=</span> <span>edn_map_get_keyword</span>(<span>r</span>.<span>value</span>, <span>&#34;status&#34;</span>);

<span>if</span> (<span>edn_string_equals</span>(<span>status</span>, <span>&#34;active&#34;</span>)) {
    <span>printf</span>(<span>&#34;Status is active\n&#34;</span>);
}

<span>edn_free</span>(<span>r</span>.<span>value</span>);</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="bool edn_symbol_get(const edn_value_t *value,
                    const char **namespace, size_t *ns_length,
                    const char **name, size_t *name_length);"><pre><span>bool</span> <span>edn_symbol_get</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>,
                    <span>const</span> <span>char</span> <span>*</span><span>*</span><span>namespace</span>, <span>size_t</span> <span>*</span><span>ns_length</span>,
                    <span>const</span> <span>char</span> <span>*</span><span>*</span><span>name</span>, <span>size_t</span> <span>*</span><span>name_length</span>);</pre></div>
<p dir="auto">Get symbol components. Returns <code>true</code> if value is <code>EDN_TYPE_SYMBOL</code>, <code>false</code> otherwise.</p>
<p dir="auto"><strong>Example:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="// Simple symbol
edn_result_t r1 = edn_read(&#34;foo&#34;, 0);
const char *name;
size_t name_len;
edn_symbol_get(r1.value, NULL, NULL, &amp;name, &amp;name_len);
printf(&#34;Symbol: %.*s\n&#34;, (int)name_len, name);

// Namespaced symbol
edn_result_t r2 = edn_read(&#34;clojure.core/map&#34;, 0);
const char *ns, *n;
size_t ns_len, n_len;
edn_symbol_get(r2.value, &amp;ns, &amp;ns_len, &amp;n, &amp;n_len);
printf(&#34;Symbol: %.*s/%.*s\n&#34;, (int)ns_len, ns, (int)n_len, n);

edn_free(r1.value);
edn_free(r2.value);"><pre><span>// Simple symbol</span>
<span>edn_result_t</span> <span>r1</span> <span>=</span> <span>edn_read</span>(<span>&#34;foo&#34;</span>, <span>0</span>);
<span>const</span> <span>char</span> <span>*</span><span>name</span>;
<span>size_t</span> <span>name_len</span>;
<span>edn_symbol_get</span>(<span>r1</span>.<span>value</span>, <span>NULL</span>, <span>NULL</span>, <span>&amp;</span><span>name</span>, <span>&amp;</span><span>name_len</span>);
<span>printf</span>(<span>&#34;Symbol: %.*s\n&#34;</span>, (<span>int</span>)<span>name_len</span>, <span>name</span>);

<span>// Namespaced symbol</span>
<span>edn_result_t</span> <span>r2</span> <span>=</span> <span>edn_read</span>(<span>&#34;clojure.core/map&#34;</span>, <span>0</span>);
<span>const</span> <span>char</span> <span>*</span><span>ns</span>, <span>*</span><span>n</span>;
<span>size_t</span> <span>ns_len</span>, <span>n_len</span>;
<span>edn_symbol_get</span>(<span>r2</span>.<span>value</span>, <span>&amp;</span><span>ns</span>, <span>&amp;</span><span>ns_len</span>, <span>&amp;</span><span>n</span>, <span>&amp;</span><span>n_len</span>);
<span>printf</span>(<span>&#34;Symbol: %.*s/%.*s\n&#34;</span>, (<span>int</span>)<span>ns_len</span>, <span>ns</span>, (<span>int</span>)<span>n_len</span>, <span>n</span>);

<span>edn_free</span>(<span>r1</span>.<span>value</span>);
<span>edn_free</span>(<span>r2</span>.<span>value</span>);</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="bool edn_keyword_get(const edn_value_t *value,
                     const char **namespace, size_t *ns_length,
                     const char **name, size_t *name_length);"><pre><span>bool</span> <span>edn_keyword_get</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>,
                     <span>const</span> <span>char</span> <span>*</span><span>*</span><span>namespace</span>, <span>size_t</span> <span>*</span><span>ns_length</span>,
                     <span>const</span> <span>char</span> <span>*</span><span>*</span><span>name</span>, <span>size_t</span> <span>*</span><span>name_length</span>);</pre></div>
<p dir="auto">Get keyword components. Returns <code>true</code> if value is <code>EDN_TYPE_KEYWORD</code>, <code>false</code> otherwise.</p>
<p dir="auto"><strong>Example:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="edn_result_t r = edn_read(&#34;:name&#34;, 0);
const char *name;
size_t name_len;
edn_keyword_get(r.value, NULL, NULL, &amp;name, &amp;name_len);
printf(&#34;Keyword: :%.*s\n&#34;, (int)name_len, name);
edn_free(r.value);"><pre><span>edn_result_t</span> <span>r</span> <span>=</span> <span>edn_read</span>(<span>&#34;:name&#34;</span>, <span>0</span>);
<span>const</span> <span>char</span> <span>*</span><span>name</span>;
<span>size_t</span> <span>name_len</span>;
<span>edn_keyword_get</span>(<span>r</span>.<span>value</span>, <span>NULL</span>, <span>NULL</span>, <span>&amp;</span><span>name</span>, <span>&amp;</span><span>name_len</span>);
<span>printf</span>(<span>&#34;Keyword: :%.*s\n&#34;</span>, (<span>int</span>)<span>name_len</span>, <span>name</span>);
<span>edn_free</span>(<span>r</span>.<span>value</span>);</pre></div>


<p dir="auto">Ordered sequences: <code>(1 2 3)</code></p>
<div dir="auto" data-snippet-clipboard-copy-content="size_t edn_list_count(const edn_value_t *value);
edn_value_t *edn_list_get(const edn_value_t *value, size_t index);"><pre><span>size_t</span> <span>edn_list_count</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>);
<span>edn_value_t</span> <span>*</span><span>edn_list_get</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>, <span>size_t</span> <span>index</span>);</pre></div>
<p dir="auto"><strong>Example:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="edn_result_t r = edn_read(&#34;(1 2 3)&#34;, 0);
size_t count = edn_list_count(r.value);

for (size_t i = 0; i &lt; count; i++) {
    edn_value_t *elem = edn_list_get(r.value, i);
    int64_t num;
    if (edn_int64_get(elem, &amp;num)) {
        printf(&#34;%lld &#34;, (long long)num);
    }
}
printf(&#34;\n&#34;);
edn_free(r.value);"><pre><span>edn_result_t</span> <span>r</span> <span>=</span> <span>edn_read</span>(<span>&#34;(1 2 3)&#34;</span>, <span>0</span>);
<span>size_t</span> <span>count</span> <span>=</span> <span>edn_list_count</span>(<span>r</span>.<span>value</span>);

<span>for</span> (<span>size_t</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>count</span>; <span>i</span><span>++</span>) {
    <span>edn_value_t</span> <span>*</span><span>elem</span> <span>=</span> <span>edn_list_get</span>(<span>r</span>.<span>value</span>, <span>i</span>);
    <span>int64_t</span> <span>num</span>;
    <span>if</span> (<span>edn_int64_get</span>(<span>elem</span>, <span>&amp;</span><span>num</span>)) {
        <span>printf</span>(<span>&#34;%lld &#34;</span>, (<span>long long</span>)<span>num</span>);
    }
}
<span>printf</span>(<span>&#34;\n&#34;</span>);
<span>edn_free</span>(<span>r</span>.<span>value</span>);</pre></div>

<p dir="auto">Indexed sequences: <code>[1 2 3]</code></p>
<div dir="auto" data-snippet-clipboard-copy-content="size_t edn_vector_count(const edn_value_t *value);
edn_value_t *edn_vector_get(const edn_value_t *value, size_t index);"><pre><span>size_t</span> <span>edn_vector_count</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>);
<span>edn_value_t</span> <span>*</span><span>edn_vector_get</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>, <span>size_t</span> <span>index</span>);</pre></div>
<p dir="auto"><strong>Example:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="edn_result_t r = edn_read(&#34;[\&#34;a\&#34; \&#34;b\&#34; \&#34;c\&#34;]&#34;, 0);
size_t count = edn_vector_count(r.value);

for (size_t i = 0; i &lt; count; i++) {
    edn_value_t *elem = edn_vector_get(r.value, i);
    size_t len;
    const char *str = edn_string_get(elem, &amp;len);
    printf(&#34;[%zu] = %.*s\n&#34;, i, (int)len, str);
}
edn_free(r.value);"><pre><span>edn_result_t</span> <span>r</span> <span>=</span> <span>edn_read</span>(<span>&#34;[\&#34;a\&#34; \&#34;b\&#34; \&#34;c\&#34;]&#34;</span>, <span>0</span>);
<span>size_t</span> <span>count</span> <span>=</span> <span>edn_vector_count</span>(<span>r</span>.<span>value</span>);

<span>for</span> (<span>size_t</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>count</span>; <span>i</span><span>++</span>) {
    <span>edn_value_t</span> <span>*</span><span>elem</span> <span>=</span> <span>edn_vector_get</span>(<span>r</span>.<span>value</span>, <span>i</span>);
    <span>size_t</span> <span>len</span>;
    <span>const</span> <span>char</span> <span>*</span><span>str</span> <span>=</span> <span>edn_string_get</span>(<span>elem</span>, <span>&amp;</span><span>len</span>);
    <span>printf</span>(<span>&#34;[%zu] = %.*s\n&#34;</span>, <span>i</span>, (<span>int</span>)<span>len</span>, <span>str</span>);
}
<span>edn_free</span>(<span>r</span>.<span>value</span>);</pre></div>

<p dir="auto">Unique elements: <code>#{:a :b :c}</code></p>
<div dir="auto" data-snippet-clipboard-copy-content="size_t edn_set_count(const edn_value_t *value);
edn_value_t *edn_set_get(const edn_value_t *value, size_t index);
bool edn_set_contains(const edn_value_t *value, const edn_value_t *element);"><pre><span>size_t</span> <span>edn_set_count</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>);
<span>edn_value_t</span> <span>*</span><span>edn_set_get</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>, <span>size_t</span> <span>index</span>);
<span>bool</span> <span>edn_set_contains</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>, <span>const</span> <span>edn_value_t</span> <span>*</span><span>element</span>);</pre></div>
<p dir="auto"><strong>Note:</strong> Sets reject duplicate elements during parsing. Iteration order is implementation-defined.</p>
<p dir="auto"><strong>Example:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="edn_result_t r = edn_read(&#34;#{:a :b :c}&#34;, 0);
printf(&#34;Set has %zu elements\n&#34;, edn_set_count(r.value));

edn_result_t key = edn_read(&#34;:a&#34;, 0);
if (edn_set_contains(r.value, key.value)) {
    printf(&#34;:a is in set\n&#34;);
}

edn_free(key.value);
edn_free(r.value);"><pre><span>edn_result_t</span> <span>r</span> <span>=</span> <span>edn_read</span>(<span>&#34;#{:a :b :c}&#34;</span>, <span>0</span>);
<span>printf</span>(<span>&#34;Set has %zu elements\n&#34;</span>, <span>edn_set_count</span>(<span>r</span>.<span>value</span>));

<span>edn_result_t</span> <span>key</span> <span>=</span> <span>edn_read</span>(<span>&#34;:a&#34;</span>, <span>0</span>);
<span>if</span> (<span>edn_set_contains</span>(<span>r</span>.<span>value</span>, <span>key</span>.<span>value</span>)) {
    <span>printf</span>(<span>&#34;:a is in set\n&#34;</span>);
}

<span>edn_free</span>(<span>key</span>.<span>value</span>);
<span>edn_free</span>(<span>r</span>.<span>value</span>);</pre></div>

<p dir="auto">Key-value pairs: <code>{:foo 1 :bar 2}</code></p>
<div dir="auto" data-snippet-clipboard-copy-content="size_t edn_map_count(const edn_value_t *value);
edn_value_t *edn_map_get_key(const edn_value_t *value, size_t index);
edn_value_t *edn_map_get_value(const edn_value_t *value, size_t index);
edn_value_t *edn_map_lookup(const edn_value_t *value, const edn_value_t *key);
bool edn_map_contains_key(const edn_value_t *value, const edn_value_t *key);"><pre><span>size_t</span> <span>edn_map_count</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>);
<span>edn_value_t</span> <span>*</span><span>edn_map_get_key</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>, <span>size_t</span> <span>index</span>);
<span>edn_value_t</span> <span>*</span><span>edn_map_get_value</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>, <span>size_t</span> <span>index</span>);
<span>edn_value_t</span> <span>*</span><span>edn_map_lookup</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>, <span>const</span> <span>edn_value_t</span> <span>*</span><span>key</span>);
<span>bool</span> <span>edn_map_contains_key</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>, <span>const</span> <span>edn_value_t</span> <span>*</span><span>key</span>);</pre></div>
<p dir="auto"><strong>Note:</strong> Maps reject duplicate keys during parsing. Iteration order is implementation-defined.</p>
<p dir="auto"><strong>Example:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="edn_result_t r = edn_read(&#34;{:name \&#34;Alice\&#34; :age 30}&#34;, 0);

// Iterate over all entries
size_t count = edn_map_count(r.value);
for (size_t i = 0; i &lt; count; i++) {
    edn_value_t *key = edn_map_get_key(r.value, i);
    edn_value_t *val = edn_map_get_value(r.value, i);
    
    const char *key_name;
    size_t key_len;
    edn_keyword_get(key, NULL, NULL, &amp;key_name, &amp;key_len);
    printf(&#34;:%.*s =&gt; &#34;, (int)key_len, key_name);
    
    if (edn_type(val) == EDN_TYPE_STRING) {
        size_t val_len;
        const char *str = edn_string_get(val, &amp;val_len);
        printf(&#34;\&#34;%.*s\&#34;\n&#34;, (int)val_len, str);
    } else if (edn_type(val) == EDN_TYPE_INT) {
        int64_t num;
        edn_int64_get(val, &amp;num);
        printf(&#34;%lld\n&#34;, (long long)num);
    }
}

// Lookup by key
edn_result_t key = edn_read(&#34;:name&#34;, 0);
edn_value_t *name = edn_map_lookup(r.value, key.value);
if (name != NULL) {
    size_t len;
    const char *str = edn_string_get(name, &amp;len);
    printf(&#34;Name: %.*s\n&#34;, (int)len, str);
}

edn_free(key.value);
edn_free(r.value);"><pre><span>edn_result_t</span> <span>r</span> <span>=</span> <span>edn_read</span>(<span>&#34;{:name \&#34;Alice\&#34; :age 30}&#34;</span>, <span>0</span>);

<span>// Iterate over all entries</span>
<span>size_t</span> <span>count</span> <span>=</span> <span>edn_map_count</span>(<span>r</span>.<span>value</span>);
<span>for</span> (<span>size_t</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>count</span>; <span>i</span><span>++</span>) {
    <span>edn_value_t</span> <span>*</span><span>key</span> <span>=</span> <span>edn_map_get_key</span>(<span>r</span>.<span>value</span>, <span>i</span>);
    <span>edn_value_t</span> <span>*</span><span>val</span> <span>=</span> <span>edn_map_get_value</span>(<span>r</span>.<span>value</span>, <span>i</span>);
    
    <span>const</span> <span>char</span> <span>*</span><span>key_name</span>;
    <span>size_t</span> <span>key_len</span>;
    <span>edn_keyword_get</span>(<span>key</span>, <span>NULL</span>, <span>NULL</span>, <span>&amp;</span><span>key_name</span>, <span>&amp;</span><span>key_len</span>);
    <span>printf</span>(<span>&#34;:%.*s =&gt; &#34;</span>, (<span>int</span>)<span>key_len</span>, <span>key_name</span>);
    
    <span>if</span> (<span>edn_type</span>(<span>val</span>) <span>==</span> <span>EDN_TYPE_STRING</span>) {
        <span>size_t</span> <span>val_len</span>;
        <span>const</span> <span>char</span> <span>*</span><span>str</span> <span>=</span> <span>edn_string_get</span>(<span>val</span>, <span>&amp;</span><span>val_len</span>);
        <span>printf</span>(<span>&#34;\&#34;%.*s\&#34;\n&#34;</span>, (<span>int</span>)<span>val_len</span>, <span>str</span>);
    } <span>else</span> <span>if</span> (<span>edn_type</span>(<span>val</span>) <span>==</span> <span>EDN_TYPE_INT</span>) {
        <span>int64_t</span> <span>num</span>;
        <span>edn_int64_get</span>(<span>val</span>, <span>&amp;</span><span>num</span>);
        <span>printf</span>(<span>&#34;%lld\n&#34;</span>, (<span>long long</span>)<span>num</span>);
    }
}

<span>// Lookup by key</span>
<span>edn_result_t</span> <span>key</span> <span>=</span> <span>edn_read</span>(<span>&#34;:name&#34;</span>, <span>0</span>);
<span>edn_value_t</span> <span>*</span><span>name</span> <span>=</span> <span>edn_map_lookup</span>(<span>r</span>.<span>value</span>, <span>key</span>.<span>value</span>);
<span>if</span> (<span>name</span> <span>!=</span> <span>NULL</span>) {
    <span>size_t</span> <span>len</span>;
    <span>const</span> <span>char</span> <span>*</span><span>str</span> <span>=</span> <span>edn_string_get</span>(<span>name</span>, <span>&amp;</span><span>len</span>);
    <span>printf</span>(<span>&#34;Name: %.*s\n&#34;</span>, (<span>int</span>)<span>len</span>, <span>str</span>);
}

<span>edn_free</span>(<span>key</span>.<span>value</span>);
<span>edn_free</span>(<span>r</span>.<span>value</span>);</pre></div>
<p dir="auto"><strong>Map Convenience Functions:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="edn_value_t *edn_map_get_keyword(const edn_value_t *map, const char *keyword);
edn_value_t *edn_map_get_namespaced_keyword(const edn_value_t *map, const char *namespace, const char *name);
edn_value_t *edn_map_get_string_key(const edn_value_t *map, const char *key);"><pre><span>edn_value_t</span> <span>*</span><span>edn_map_get_keyword</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>map</span>, <span>const</span> <span>char</span> <span>*</span><span>keyword</span>);
<span>edn_value_t</span> <span>*</span><span>edn_map_get_namespaced_keyword</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>map</span>, <span>const</span> <span>char</span> <span>*</span><span>namespace</span>, <span>const</span> <span>char</span> <span>*</span><span>name</span>);
<span>edn_value_t</span> <span>*</span><span>edn_map_get_string_key</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>map</span>, <span>const</span> <span>char</span> <span>*</span><span>key</span>);</pre></div>
<p dir="auto">Convenience wrappers that simplify common map lookup patterns by creating the key internally.</p>
<p dir="auto"><strong>Example:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="edn_result_t r = edn_read(&#34;{:name \&#34;Alice\&#34; :family/name \&#34;Black\&#34; :age 30 \&#34;config\&#34; true}&#34;, 0);

// Keyword lookup
edn_value_t* name = edn_map_get_keyword(r.value, &#34;name&#34;);
if (name &amp;&amp; edn_is_string(name)) {
    // name is &#34;Alice&#34;
}

edn_value_t* name = edn_map_get_namespaced_keyword(r.value, &#34;family&#34;, &#34;name&#34;);
if (name &amp;&amp; edn_is_string(name)) {
    // name is &#34;Black&#34;
}

// String key lookup
edn_value_t* config = edn_map_get_string_key(r.value, &#34;config&#34;);
if (config) {
    bool val;
    edn_bool_get(config, &amp;val);  // val is true
}

edn_free(r.value);"><pre><span>edn_result_t</span> <span>r</span> <span>=</span> <span>edn_read</span>(<span>&#34;{:name \&#34;Alice\&#34; :family/name \&#34;Black\&#34; :age 30 \&#34;config\&#34; true}&#34;</span>, <span>0</span>);

<span>// Keyword lookup</span>
<span>edn_value_t</span><span>*</span> <span>name</span> <span>=</span> <span>edn_map_get_keyword</span>(<span>r</span>.<span>value</span>, <span>&#34;name&#34;</span>);
<span>if</span> (<span>name</span> <span>&amp;&amp;</span> <span>edn_is_string</span>(<span>name</span>)) {
    <span>// name is &#34;Alice&#34;</span>
}

<span>edn_value_t</span><span>*</span> <span>name</span> <span>=</span> <span>edn_map_get_namespaced_keyword</span>(<span>r</span>.<span>value</span>, <span>&#34;family&#34;</span>, <span>&#34;name&#34;</span>);
<span>if</span> (<span>name</span> <span>&amp;&amp;</span> <span>edn_is_string</span>(<span>name</span>)) {
    <span>// name is &#34;Black&#34;</span>
}

<span>// String key lookup</span>
<span>edn_value_t</span><span>*</span> <span>config</span> <span>=</span> <span>edn_map_get_string_key</span>(<span>r</span>.<span>value</span>, <span>&#34;config&#34;</span>);
<span>if</span> (<span>config</span>) {
    <span>bool</span> <span>val</span>;
    <span>edn_bool_get</span>(<span>config</span>, <span>&amp;</span><span>val</span>);  <span>// val is true</span>
}

<span>edn_free</span>(<span>r</span>.<span>value</span>);</pre></div>

<p dir="auto">Tagged literals provide extensibility: <code>#tag value</code></p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Basic Tagged Literal Access</h4><a id="user-content-basic-tagged-literal-access" aria-label="Permalink: Basic Tagged Literal Access" href="#basic-tagged-literal-access"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="bool edn_tagged_get(const edn_value_t *value,
                    const char **tag, size_t *tag_length,
                    edn_value_t **tagged_value);"><pre><span>bool</span> <span>edn_tagged_get</span>(<span>const</span> <span>edn_value_t</span> <span>*</span><span>value</span>,
                    <span>const</span> <span>char</span> <span>*</span><span>*</span><span>tag</span>, <span>size_t</span> <span>*</span><span>tag_length</span>,
                    <span>edn_value_t</span> <span>*</span><span>*</span><span>tagged_value</span>);</pre></div>
<p dir="auto"><strong>Example:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="edn_result_t r = edn_read(&#34;#inst \&#34;2024-01-01T00:00:00Z\&#34;&#34;, 0);

const char *tag;
size_t tag_len;
edn_value_t *wrapped;

if (edn_tagged_get(r.value, &amp;tag, &amp;tag_len, &amp;wrapped)) {
    printf(&#34;Tag: %.*s\n&#34;, (int)tag_len, tag);
    
    size_t str_len;
    const char *str = edn_string_get(wrapped, &amp;str_len);
    printf(&#34;Value: %.*s\n&#34;, (int)str_len, str);
}

edn_free(r.value);"><pre><span>edn_result_t</span> <span>r</span> <span>=</span> <span>edn_read</span>(<span>&#34;#inst \&#34;2024-01-01T00:00:00Z\&#34;&#34;</span>, <span>0</span>);

<span>const</span> <span>char</span> <span>*</span><span>tag</span>;
<span>size_t</span> <span>tag_len</span>;
<span>edn_value_t</span> <span>*</span><span>wrapped</span>;

<span>if</span> (<span>edn_tagged_get</span>(<span>r</span>.<span>value</span>, <span>&amp;</span><span>tag</span>, <span>&amp;</span><span>tag_len</span>, <span>&amp;</span><span>wrapped</span>)) {
    <span>printf</span>(<span>&#34;Tag: %.*s\n&#34;</span>, (<span>int</span>)<span>tag_len</span>, <span>tag</span>);
    
    <span>size_t</span> <span>str_len</span>;
    <span>const</span> <span>char</span> <span>*</span><span>str</span> <span>=</span> <span>edn_string_get</span>(<span>wrapped</span>, <span>&amp;</span><span>str_len</span>);
    <span>printf</span>(<span>&#34;Value: %.*s\n&#34;</span>, (<span>int</span>)<span>str_len</span>, <span>str</span>);
}

<span>edn_free</span>(<span>r</span>.<span>value</span>);</pre></div>

<p dir="auto">Transform tagged literals during parsing with custom reader functions.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Reader Registry Functions</h4><a id="user-content-reader-registry-functions" aria-label="Permalink: Reader Registry Functions" href="#reader-registry-functions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="// Create and destroy registry
edn_reader_registry_t *edn_reader_registry_create(void);
void edn_reader_registry_destroy(edn_reader_registry_t *registry);

// Register/unregister readers
bool edn_reader_register(edn_reader_registry_t *registry,
                         const char *tag, edn_reader_fn reader);
void edn_reader_unregister(edn_reader_registry_t *registry, const char *tag);
edn_reader_fn edn_reader_lookup(const edn_reader_registry_t *registry,
                                const char *tag);"><pre><span>// Create and destroy registry</span>
<span>edn_reader_registry_t</span> <span>*</span><span>edn_reader_registry_create</span>(<span>void</span>);
<span>void</span> <span>edn_reader_registry_destroy</span>(<span>edn_reader_registry_t</span> <span>*</span><span>registry</span>);

<span>// Register/unregister readers</span>
<span>bool</span> <span>edn_reader_register</span>(<span>edn_reader_registry_t</span> <span>*</span><span>registry</span>,
                         <span>const</span> <span>char</span> <span>*</span><span>tag</span>, <span>edn_reader_fn</span> <span>reader</span>);
<span>void</span> <span>edn_reader_unregister</span>(<span>edn_reader_registry_t</span> <span>*</span><span>registry</span>, <span>const</span> <span>char</span> <span>*</span><span>tag</span>);
<span>edn_reader_fn</span> <span>edn_reader_lookup</span>(<span>const</span> <span>edn_reader_registry_t</span> <span>*</span><span>registry</span>,
                                <span>const</span> <span>char</span> <span>*</span><span>tag</span>);</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="typedef edn_value_t *(*edn_reader_fn)(edn_value_t *value,
                                      edn_arena_t *arena,
                                      const char **error_message);"><pre><span>typedef</span> <span>edn_value_t</span> <span>*</span>(<span>*</span><span>edn_reader_fn</span>)(<span>edn_value_t</span> <span>*</span><span>value</span>,
                                      <span>edn_arena_t</span> <span>*</span><span>arena</span>,
                                      <span>const</span> <span>char</span> <span>*</span><span>*</span><span>error_message</span>);</pre></div>
<p dir="auto">A reader function receives the wrapped value and transforms it into a new representation. On error, set <code>error_message</code> to a static string and return NULL.</p>

<div dir="auto" data-snippet-clipboard-copy-content="typedef struct {
    edn_reader_registry_t *reader_registry;  // Optional reader registry
    edn_value_t *eof_value;                  // Optional value to return on EOF
    edn_default_reader_mode_t default_reader_mode;
} edn_parse_options_t;

edn_result_t edn_read_with_options(const char *input, size_t length,
                                    const edn_parse_options_t *options);"><pre><span>typedef</span> <span>struct</span> {
    <span>edn_reader_registry_t</span> <span>*</span><span>reader_registry</span>;  <span>// Optional reader registry</span>
    <span>edn_value_t</span> <span>*</span><span>eof_value</span>;                  <span>// Optional value to return on EOF</span>
    <span>edn_default_reader_mode_t</span> <span>default_reader_mode</span>;
} <span>edn_parse_options_t</span>;

<span>edn_result_t</span> <span>edn_read_with_options</span>(<span>const</span> <span>char</span> <span>*</span><span>input</span>, <span>size_t</span> <span>length</span>,
                                    <span>const</span> <span>edn_parse_options_t</span> <span>*</span><span>options</span>);</pre></div>
<p dir="auto"><strong>Parse options fields:</strong></p>
<ul dir="auto">
<li><code>reader_registry</code>: Optional reader registry for tagged literal transformations</li>
<li><code>eof_value</code>: Optional value to return when EOF is encountered instead of an error</li>
<li><code>default_reader_mode</code>: Behavior for unregistered tags (see below)</li>
</ul>
<p dir="auto"><strong>Default reader modes:</strong></p>
<ul dir="auto">
<li><code>EDN_DEFAULT_READER_PASSTHROUGH</code>: Return <code>EDN_TYPE_TAGGED</code> for unregistered tags (default)</li>
<li><code>EDN_DEFAULT_READER_UNWRAP</code>: Discard tag, return wrapped value</li>
<li><code>EDN_DEFAULT_READER_ERROR</code>: Fail with <code>EDN_ERROR_UNKNOWN_TAG</code></li>
</ul>
<p dir="auto"><strong>EOF Value Handling:</strong></p>
<p dir="auto">By default, when the parser encounters end-of-file (empty input, whitespace-only input, or after <code>#_</code> discard), it returns <code>EDN_ERROR_UNEXPECTED_EOF</code>. You can customize this behavior by providing an <code>eof_value</code> in the parse options:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// First, create an EOF sentinel value
edn_result_t eof_sentinel = edn_read(&#34;:eof&#34;, 0);

// Configure parse options with EOF value
edn_parse_options_t options = {
    .reader_registry = NULL,
    .eof_value = eof_sentinel.value,
    .default_reader_mode = EDN_DEFAULT_READER_PASSTHROUGH
};

// Parse input that results in EOF
edn_result_t result = edn_read_with_options(&#34;   &#34;, 3, &amp;options);

// Instead of EDN_ERROR_UNEXPECTED_EOF, returns EDN_OK with eof_value
if (result.error == EDN_OK) {
    // result.value == eof_sentinel.value
    const char* name;
    edn_keyword_get(result.value, NULL, NULL, &amp;name, NULL);
    // name == &#34;eof&#34;
}

// Clean up
edn_free(eof_sentinel.value);"><pre><span>// First, create an EOF sentinel value</span>
<span>edn_result_t</span> <span>eof_sentinel</span> <span>=</span> <span>edn_read</span>(<span>&#34;:eof&#34;</span>, <span>0</span>);

<span>// Configure parse options with EOF value</span>
<span>edn_parse_options_t</span> <span>options</span> <span>=</span> {
    .<span>reader_registry</span> <span>=</span> <span>NULL</span>,
    .<span>eof_value</span> <span>=</span> <span>eof_sentinel</span>.<span>value</span>,
    .<span>default_reader_mode</span> <span>=</span> <span>EDN_DEFAULT_READER_PASSTHROUGH</span>
};

<span>// Parse input that results in EOF</span>
<span>edn_result_t</span> <span>result</span> <span>=</span> <span>edn_read_with_options</span>(<span>&#34;   &#34;</span>, <span>3</span>, <span>&amp;</span><span>options</span>);

<span>// Instead of EDN_ERROR_UNEXPECTED_EOF, returns EDN_OK with eof_value</span>
<span>if</span> (<span>result</span>.<span>error</span> <span>==</span> <span>EDN_OK</span>) {
    <span>// result.value == eof_sentinel.value</span>
    <span>const</span> <span>char</span><span>*</span> <span>name</span>;
    <span>edn_keyword_get</span>(<span>result</span>.<span>value</span>, <span>NULL</span>, <span>NULL</span>, <span>&amp;</span><span>name</span>, <span>NULL</span>);
    <span>// name == &#34;eof&#34;</span>
}

<span>// Clean up</span>
<span>edn_free</span>(<span>eof_sentinel</span>.<span>value</span>);</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="#include &#34;edn.h&#34;
#include &#34;../src/edn_internal.h&#34;  // For edn_arena_alloc

// Reader that uppercases keywords
static edn_value_t *upper_reader(edn_value_t *value, edn_arena_t *arena,
                                 const char **error_message) {
    if (edn_type(value) != EDN_TYPE_KEYWORD) {
        *error_message = &#34;#upper requires keyword&#34;;
        return NULL;
    }

    const char *name;
    size_t name_len;
    edn_keyword_get(value, NULL, NULL, &amp;name, &amp;name_len);

    // Allocate uppercase name in arena
    char *upper = (char *)edn_arena_alloc(arena, name_len + 1);
    if (!upper) {
        *error_message = &#34;Out of memory&#34;;
        return NULL;
    }

    for (size_t i = 0; i &lt; name_len; i++) {
        char c = name[i];
        upper[i] = (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) ? (c - 32) : c;
    }
    upper[name_len] = &#39;\0&#39;;

    // Create new keyword value
    edn_value_t *result = edn_arena_alloc_value(arena);
    if (!result) {
        *error_message = &#34;Out of memory&#34;;
        return NULL;
    }

    result-&gt;type = EDN_TYPE_KEYWORD;
    result-&gt;as.keyword.name = upper;
    result-&gt;as.keyword.name_length = name_len;
    result-&gt;as.keyword.namespace = NULL;
    result-&gt;as.keyword.ns_length = 0;
    result-&gt;arena = arena;

    return result;
}

int main(void) {
    // Create registry and register reader
    edn_reader_registry_t *registry = edn_reader_registry_create();
    edn_reader_register(registry, &#34;upper&#34;, upper_reader);

    // Parse with custom reader
    edn_parse_options_t opts = {
        .reader_registry = registry,
        .default_reader_mode = EDN_DEFAULT_READER_PASSTHROUGH
    };

    edn_result_t r = edn_read_with_options(&#34;#upper :hello&#34;, 0, &amp;opts);
    if (r.error == EDN_OK) {
        const char *name;
        size_t len;
        edn_keyword_get(r.value, NULL, NULL, &amp;name, &amp;len);
        printf(&#34;:%.*s\n&#34;, (int)len, name);  // Output: :HELLO
    }

    edn_free(r.value);
    edn_reader_registry_destroy(registry);
    return 0;
}"><pre><span>#include</span> <span>&#34;edn.h&#34;</span>
<span>#include</span> <span>&#34;../src/edn_internal.h&#34;</span>  <span>// For edn_arena_alloc</span>

<span>// Reader that uppercases keywords</span>
<span>static</span> <span>edn_value_t</span> <span>*</span><span>upper_reader</span>(<span>edn_value_t</span> <span>*</span><span>value</span>, <span>edn_arena_t</span> <span>*</span><span>arena</span>,
                                 <span>const</span> <span>char</span> <span>*</span><span>*</span><span>error_message</span>) {
    <span>if</span> (<span>edn_type</span>(<span>value</span>) <span>!=</span> <span>EDN_TYPE_KEYWORD</span>) {
        <span>*</span><span>error_message</span> <span>=</span> <span>&#34;#upper requires keyword&#34;</span>;
        <span>return</span> <span>NULL</span>;
    }

    <span>const</span> <span>char</span> <span>*</span><span>name</span>;
    <span>size_t</span> <span>name_len</span>;
    <span>edn_keyword_get</span>(<span>value</span>, <span>NULL</span>, <span>NULL</span>, <span>&amp;</span><span>name</span>, <span>&amp;</span><span>name_len</span>);

    <span>// Allocate uppercase name in arena</span>
    <span>char</span> <span>*</span><span>upper</span> <span>=</span> (<span>char</span> <span>*</span>)<span>edn_arena_alloc</span>(<span>arena</span>, <span>name_len</span> <span>+</span> <span>1</span>);
    <span>if</span> (!<span>upper</span>) {
        <span>*</span><span>error_message</span> <span>=</span> <span>&#34;Out of memory&#34;</span>;
        <span>return</span> <span>NULL</span>;
    }

    <span>for</span> (<span>size_t</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>name_len</span>; <span>i</span><span>++</span>) {
        <span>char</span> <span>c</span> <span>=</span> <span>name</span>[<span>i</span>];
        <span>upper</span>[<span>i</span>] <span>=</span> (<span>c</span> &gt;= <span>&#39;a&#39;</span> <span>&amp;&amp;</span> <span>c</span> &lt;= <span>&#39;z&#39;</span>) ? (<span>c</span> <span>-</span> <span>32</span>) : <span>c</span>;
    }
    <span>upper</span>[<span>name_len</span>] <span>=</span> <span>&#39;\0&#39;</span>;

    <span>// Create new keyword value</span>
    <span>edn_value_t</span> <span>*</span><span>result</span> <span>=</span> <span>edn_arena_alloc_value</span>(<span>arena</span>);
    <span>if</span> (!<span>result</span>) {
        <span>*</span><span>error_message</span> <span>=</span> <span>&#34;Out of memory&#34;</span>;
        <span>return</span> <span>NULL</span>;
    }

    <span>result</span><span>-&gt;</span><span>type</span> <span>=</span> <span>EDN_TYPE_KEYWORD</span>;
    <span>result</span><span>-&gt;</span><span>as</span>.<span>keyword</span>.<span>name</span> <span>=</span> <span>upper</span>;
    <span>result</span><span>-&gt;</span><span>as</span>.<span>keyword</span>.<span>name_length</span> <span>=</span> <span>name_len</span>;
    <span>result</span><span>-&gt;</span><span>as</span>.<span>keyword</span>.<span>namespace</span> <span>=</span> <span>NULL</span>;
    <span>result</span><span>-&gt;</span><span>as</span>.<span>keyword</span>.<span>ns_length</span> <span>=</span> <span>0</span>;
    <span>result</span><span>-&gt;</span><span>arena</span> <span>=</span> <span>arena</span>;

    <span>return</span> <span>result</span>;
}

<span>int</span> <span>main</span>(<span>void</span>) {
    <span>// Create registry and register reader</span>
    <span>edn_reader_registry_t</span> <span>*</span><span>registry</span> <span>=</span> <span>edn_reader_registry_create</span>();
    <span>edn_reader_register</span>(<span>registry</span>, <span>&#34;upper&#34;</span>, <span>upper_reader</span>);

    <span>// Parse with custom reader</span>
    <span>edn_parse_options_t</span> <span>opts</span> <span>=</span> {
        .<span>reader_registry</span> <span>=</span> <span>registry</span>,
        .<span>default_reader_mode</span> <span>=</span> <span>EDN_DEFAULT_READER_PASSTHROUGH</span>
    };

    <span>edn_result_t</span> <span>r</span> <span>=</span> <span>edn_read_with_options</span>(<span>&#34;#upper :hello&#34;</span>, <span>0</span>, <span>&amp;</span><span>opts</span>);
    <span>if</span> (<span>r</span>.<span>error</span> <span>==</span> <span>EDN_OK</span>) {
        <span>const</span> <span>char</span> <span>*</span><span>name</span>;
        <span>size_t</span> <span>len</span>;
        <span>edn_keyword_get</span>(<span>r</span>.<span>value</span>, <span>NULL</span>, <span>NULL</span>, <span>&amp;</span><span>name</span>, <span>&amp;</span><span>len</span>);
        <span>printf</span>(<span>&#34;:%.*s\n&#34;</span>, (<span>int</span>)<span>len</span>, <span>name</span>);  <span>// Output: :HELLO</span>
    }

    <span>edn_free</span>(<span>r</span>.<span>value</span>);
    <span>edn_reader_registry_destroy</span>(<span>registry</span>);
    <span>return</span> <span>0</span>;
}</pre></div>
<p dir="auto">See <code>examples/reader.c</code> for more complete examples including timestamp conversion, vector extraction, and namespaced tags.</p>

<p dir="auto">EDN.C supports Clojure&#39;s map namespace syntax extension, which allows you to specify a namespace that gets automatically applied to all non-namespaced keyword keys in a map.</p>
<p dir="auto"><strong>Syntax:</strong> <code>#:namespace{:key1 val1 :key2 val2}</code></p>
<p dir="auto"><strong>Example:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="edn_result_t result = edn_read(&#34;#:person{:name \&#34;Alice\&#34; :age 30}&#34;, 0);
// Equivalent to: {:person/name &#34;Alice&#34; :person/age 30}

if (result.error == EDN_OK) {
    edn_value_t* map = result.value;
    
    // Keys are automatically namespaced
    edn_value_t* key1 = edn_map_get_key(map, 0);
    const char *ns, *name;
    size_t ns_len, name_len;
    edn_keyword_get(key1, &amp;ns, &amp;ns_len, &amp;name, &amp;name_len);
    
    printf(&#34;:%.*s/%.*s\n&#34;, (int)ns_len, ns, (int)name_len, name);
    // Output: :person/name
    
    edn_free(map);
}"><pre><span>edn_result_t</span> <span>result</span> <span>=</span> <span>edn_read</span>(<span>&#34;#:person{:name \&#34;Alice\&#34; :age 30}&#34;</span>, <span>0</span>);
<span>// Equivalent to: {:person/name &#34;Alice&#34; :person/age 30}</span>

<span>if</span> (<span>result</span>.<span>error</span> <span>==</span> <span>EDN_OK</span>) {
    <span>edn_value_t</span><span>*</span> <span>map</span> <span>=</span> <span>result</span>.<span>value</span>;
    
    <span>// Keys are automatically namespaced</span>
    <span>edn_value_t</span><span>*</span> <span>key1</span> <span>=</span> <span>edn_map_get_key</span>(<span>map</span>, <span>0</span>);
    <span>const</span> <span>char</span> <span>*</span><span>ns</span>, <span>*</span><span>name</span>;
    <span>size_t</span> <span>ns_len</span>, <span>name_len</span>;
    <span>edn_keyword_get</span>(<span>key1</span>, <span>&amp;</span><span>ns</span>, <span>&amp;</span><span>ns_len</span>, <span>&amp;</span><span>name</span>, <span>&amp;</span><span>name_len</span>);
    
    <span>printf</span>(<span>&#34;:%.*s/%.*s\n&#34;</span>, (<span>int</span>)<span>ns_len</span>, <span>ns</span>, (<span>int</span>)<span>name_len</span>, <span>name</span>);
    <span>// Output: :person/name</span>
    
    <span>edn_free</span>(<span>map</span>);
}</pre></div>
<p dir="auto"><strong>Rules:</strong></p>
<ul dir="auto">
<li>Both keyword and symbol keys without an existing namespace are transformed</li>
<li>Keys with existing namespaces are preserved: <code>#:foo{:x 1 :bar/y 2}</code> ‚Üí <code>{:foo/x 1 :bar/y 2}</code></li>
<li>Symbol keys are also namespaced: <code>#:foo{x 1 y 2}</code> ‚Üí <code>{foo/x 1 foo/y 2}</code></li>
<li>Mixed keys work correctly: <code>#:foo{x 1 :y 2}</code> ‚Üí <code>{foo/x 1 :foo/y 2}</code></li>
<li>Non-keyword/non-symbol keys are not transformed: <code>#:foo{&#34;x&#34; 1 :y 2}</code> ‚Üí <code>{&#34;x&#34; 1 :foo/y 2}</code></li>
<li>The namespace keyword cannot itself have a namespace</li>
</ul>
<p dir="auto"><strong>Build Configuration:</strong></p>
<p dir="auto">This feature is disabled by default. To enable it:</p>
<div dir="auto" data-snippet-clipboard-copy-content="make MAP_NAMESPACE_SYNTAX=1"><pre>make MAP_NAMESPACE_SYNTAX=1</pre></div>
<p dir="auto">When disabled (default), <code>#:foo{...}</code> will fail to parse.</p>
<p dir="auto">See <code>examples/example_namespaced_map.c</code> for more details.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Extended Character Literals</h3><a id="user-content-extended-character-literals" aria-label="Permalink: Extended Character Literals" href="#extended-character-literals"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">EDN.C supports optional extended character literal features that are disabled by default for strict EDN compliance.</p>
<p dir="auto"><strong>Extended named characters:</strong></p>
<ul dir="auto">
<li><code>\formfeed</code> - Form feed control character (U+000C)</li>
<li><code>\backspace</code> - Backspace control character (U+0008)</li>
</ul>
<p dir="auto"><strong>Octal escape sequences (Clojure-compatible):</strong></p>
<ul dir="auto">
<li><code>\oN</code> - Where N is 1-3 octal digits (0-7)</li>
<li>If <code>\o</code> is followed by any digit, attempts octal parsing</li>
<li>Digits 8 or 9 cause &#34;Invalid octal escape sequence in character literal&#34; error</li>
<li>Examples:
<ul dir="auto">
<li><code>\o7</code> - Bell character (U+0007)</li>
<li><code>\o12</code> - Line feed (U+000A)</li>
<li><code>\o101</code> - Uppercase &#39;A&#39; (U+0041)</li>
<li><code>\o377</code> - Maximum value (U+00FF / 255)</li>
<li><code>\o</code> alone - Parses as character &#39;o&#39;</li>
<li><code>\o8</code> - Error: Invalid octal character</li>
</ul>
</li>
</ul>
<p dir="auto"><strong>Example:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="edn_result_t result = edn_read(&#34;\\formfeed&#34;, 0);
if (result.error == EDN_OK) {
    uint32_t codepoint;
    edn_character_get(result.value, &amp;codepoint);
    printf(&#34;U+%04X\n&#34;, codepoint);  // Output: U+000C
    edn_free(result.value);
}

// Octal escapes
result = edn_read(&#34;[\\o101 \\o102 \\o103]&#34;, 0);
// Parses as vector [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]"><pre><span>edn_result_t</span> <span>result</span> <span>=</span> <span>edn_read</span>(<span>&#34;\\formfeed&#34;</span>, <span>0</span>);
<span>if</span> (<span>result</span>.<span>error</span> <span>==</span> <span>EDN_OK</span>) {
    <span>uint32_t</span> <span>codepoint</span>;
    <span>edn_character_get</span>(<span>result</span>.<span>value</span>, <span>&amp;</span><span>codepoint</span>);
    <span>printf</span>(<span>&#34;U+%04X\n&#34;</span>, <span>codepoint</span>);  <span>// Output: U+000C</span>
    <span>edn_free</span>(<span>result</span>.<span>value</span>);
}

<span>// Octal escapes</span>
<span>result</span> <span>=</span> <span>edn_read</span>(<span>&#34;[\\o101 \\o102 \\o103]&#34;</span>, <span>0</span>);
<span>// Parses as vector [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</span></pre></div>
<p dir="auto"><strong>Build Configuration:</strong></p>
<p dir="auto">This feature is disabled by default. To enable it:</p>
<p dir="auto"><strong>Make:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="make EXTENDED_CHARACTERS=1"><pre>make EXTENDED_CHARACTERS=1</pre></div>
<p dir="auto"><strong>CMake:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="cmake -DEDN_ENABLE_EXTENDED_CHARACTERS=ON ..
make"><pre>cmake -DEDN_ENABLE_EXTENDED_CHARACTERS=ON ..
make</pre></div>
<p dir="auto">When disabled (default):</p>
<ul dir="auto">
<li><code>\formfeed</code> and <code>\backspace</code> will fail to parse</li>
<li><code>\oNNN</code> will fail to parse</li>
<li>Standard character literals still work: <code>\newline</code>, <code>\tab</code>, <code>\space</code>, <code>\return</code>, <code>\uXXXX</code>, etc.</li>
</ul>
<p dir="auto">See <code>examples/example_extended_characters.c</code> for more details.</p>

<p dir="auto">EDN.C supports Clojure-style metadata syntax, which allows attaching metadata maps to values.</p>
<p dir="auto"><strong>Syntax variants:</strong></p>
<ol dir="auto">
<li><strong>Map metadata</strong>: <code>^{:key val} form</code> - metadata is the map itself</li>
<li><strong>Keyword shorthand</strong>: <code>^:keyword form</code> - expands to <code>{:keyword true}</code></li>
<li><strong>String tag</strong>: <code>^&#34;string&#34; form</code> - expands to <code>{:tag &#34;string&#34;}</code></li>
<li><strong>Symbol tag</strong>: <code>^symbol form</code> - expands to <code>{:tag symbol}</code></li>
<li><strong>Vector param-tags</strong>: <code>^[type1 type2] form</code> - expands to <code>{:param-tags [type1 type2]}</code></li>
</ol>
<p dir="auto"><strong>Chaining</strong>: Multiple metadata can be chained: <code>^meta1 ^meta2 form</code> - metadata maps are merged from right to left.</p>
<p dir="auto"><strong>Example:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &#34;edn.h&#34;
#include &lt;stdio.h&gt;

int main(void) {
    // Parse with keyword shorthand
    edn_result_t result = edn_read(&#34;^:private my-var&#34;, 0);

    if (result.error == EDN_OK) {
        // Check if value has metadata
        if (edn_value_has_meta(result.value)) {
            edn_value_t* meta = edn_value_meta(result.value);

            // Metadata is always a map
            printf(&#34;Metadata entries: %zu\n&#34;, edn_map_count(meta));

            // Look up specific metadata key
            edn_result_t key = edn_read(&#34;:private&#34;, 0);
            edn_value_t* val = edn_map_lookup(meta, key.value);
            // val will be boolean true

            edn_free(key.value);
        }

        edn_free(result.value);
    }

    return 0;
}"><pre><span>#include</span> <span>&#34;edn.h&#34;</span>
<span>#include</span> <span>&lt;stdio.h&gt;</span>

<span>int</span> <span>main</span>(<span>void</span>) {
    <span>// Parse with keyword shorthand</span>
    <span>edn_result_t</span> <span>result</span> <span>=</span> <span>edn_read</span>(<span>&#34;^:private my-var&#34;</span>, <span>0</span>);

    <span>if</span> (<span>result</span>.<span>error</span> <span>==</span> <span>EDN_OK</span>) {
        <span>// Check if value has metadata</span>
        <span>if</span> (<span>edn_value_has_meta</span>(<span>result</span>.<span>value</span>)) {
            <span>edn_value_t</span><span>*</span> <span>meta</span> <span>=</span> <span>edn_value_meta</span>(<span>result</span>.<span>value</span>);

            <span>// Metadata is always a map</span>
            <span>printf</span>(<span>&#34;Metadata entries: %zu\n&#34;</span>, <span>edn_map_count</span>(<span>meta</span>));

            <span>// Look up specific metadata key</span>
            <span>edn_result_t</span> <span>key</span> <span>=</span> <span>edn_read</span>(<span>&#34;:private&#34;</span>, <span>0</span>);
            <span>edn_value_t</span><span>*</span> <span>val</span> <span>=</span> <span>edn_map_lookup</span>(<span>meta</span>, <span>key</span>.<span>value</span>);
            <span>// val will be boolean true</span>

            <span>edn_free</span>(<span>key</span>.<span>value</span>);
        }

        <span>edn_free</span>(<span>result</span>.<span>value</span>);
    }

    <span>return</span> <span>0</span>;
}</pre></div>
<p dir="auto"><strong>More examples:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="// Map metadata
edn_read(&#34;^{:doc \&#34;A function\&#34; :test true} my-fn&#34;, 0);

// String tag
edn_read(&#34;^\&#34;String\&#34; [1 2 3]&#34;, 0);
// Expands to: ^{:tag &#34;String&#34;} [1 2 3]

// Symbol tag
edn_read(&#34;^Vector [1 2 3]&#34;, 0);
// Expands to: ^{:tag Vector} [1 2 3]

// Vector param-tags
edn_read(&#34;^[String long _] my-fn&#34;, 0);
// Expands to: ^{:param-tags [String long _]} my-fn

// Chained metadata
edn_read(&#34;^:private ^:dynamic ^{:doc \&#34;My var\&#34;} x&#34;, 0);
// All metadata merged into one map"><pre><span>// Map metadata</span>
<span>edn_read</span>(<span>&#34;^{:doc \&#34;A function\&#34; :test true} my-fn&#34;</span>, <span>0</span>);

<span>// String tag</span>
<span>edn_read</span>(<span>&#34;^\&#34;String\&#34; [1 2 3]&#34;</span>, <span>0</span>);
<span>// Expands to: ^{:tag &#34;String&#34;} [1 2 3]</span>

<span>// Symbol tag</span>
<span>edn_read</span>(<span>&#34;^Vector [1 2 3]&#34;</span>, <span>0</span>);
<span>// Expands to: ^{:tag Vector} [1 2 3]</span>

<span>// Vector param-tags</span>
<span>edn_read</span>(<span>&#34;^[String long _] my-fn&#34;</span>, <span>0</span>);
<span>// Expands to: ^{:param-tags [String long _]} my-fn</span>

<span>// Chained metadata</span>
<span>edn_read</span>(<span>&#34;^:private ^:dynamic ^{:doc \&#34;My var\&#34;} x&#34;</span>, <span>0</span>);
<span>// All metadata merged into one map</span></pre></div>
<p dir="auto"><strong>Supported value types:</strong></p>
<p dir="auto">Metadata can only be attached to:</p>
<ul dir="auto">
<li>Collections: lists, vectors, maps, sets</li>
<li>Tagged literals</li>
<li>Symbols</li>
</ul>
<p dir="auto"><strong>Note:</strong> Metadata cannot be attached to scalar values (nil, booleans, numbers, strings, keywords).</p>
<p dir="auto"><strong>API:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="// Check if value has metadata
bool edn_value_has_meta(const edn_value_t* value);

// Get metadata map (returns NULL if no metadata)
edn_value_t* edn_value_meta(const edn_value_t* value);"><pre><span>// Check if value has metadata</span>
<span>bool</span> <span>edn_value_has_meta</span>(<span>const</span> <span>edn_value_t</span><span>*</span> <span>value</span>);

<span>// Get metadata map (returns NULL if no metadata)</span>
<span>edn_value_t</span><span>*</span> <span>edn_value_meta</span>(<span>const</span> <span>edn_value_t</span><span>*</span> <span>value</span>);</pre></div>
<p dir="auto"><strong>Build Configuration:</strong></p>
<p dir="auto">This feature is disabled by default. To enable it:</p>
<p dir="auto"><strong>Make:</strong></p>

<p dir="auto"><strong>CMake:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="cmake -DEDN_ENABLE_METADATA=ON ..
make"><pre>cmake -DEDN_ENABLE_METADATA=ON ..
make</pre></div>
<p dir="auto">When disabled (default):</p>
<ul dir="auto">
<li><code>^</code> is treated as a valid character in identifiers (symbols/keywords)</li>
<li><code>^test</code> parses as a symbol named &#34;^test&#34;</li>
<li>Metadata API functions are not available</li>
</ul>
<p dir="auto"><strong>Note:</strong> Metadata is a Clojure language feature, not part of the official EDN specification. It&#39;s provided here for compatibility with Clojure&#39;s reader.</p>
<p dir="auto">See <code>examples/example_metadata.c</code> for more details.</p>

<p dir="auto"><strong>Experimental feature</strong> that adds Java-style multi-line text blocks with automatic indentation stripping to EDN. Requires <code>EDN_ENABLE_TEXT_BLOCKS</code> compilation flag (disabled by default).</p>
<p dir="auto">Text blocks start with three double quotes followed by a newline (<code>&#34;&#34;&#34;\n</code>) and end with three double quotes (<code>&#34;&#34;&#34;</code>):</p>
<div dir="auto" data-snippet-clipboard-copy-content="{:query &#34;&#34;&#34;
    SELECT *
      FROM users
    WHERE age &gt; 21
    &#34;&#34;&#34;}"><pre>{<span>:query</span> <span><span>&#34;</span><span>&#34;</span><span>&#34;</span></span>
<span>    SELECT *</span>
<span>      FROM users</span>
<span>    WHERE age &gt; 21</span>
<span>    <span>&#34;</span><span>&#34;</span><span>&#34;</span></span>}</pre></div>
<p dir="auto"><strong>Features:</strong></p>
<ul dir="auto">
<li>Automatic indentation stripping (common leading whitespace removed)</li>
<li>Closing <code>&#34;&#34;&#34;</code> position determines base indentation level</li>
<li>Closing on own line adds trailing newline, on same line doesn&#39;t</li>
<li>Trailing whitespace automatically removed from each line</li>
<li>Minimal escaping: only <code>\&#34;&#34;&#34;</code> to include literal triple quotes</li>
<li>Returns standard EDN string (no special type needed)</li>
</ul>
<p dir="auto"><strong>Example:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &#34;edn.h&#34;
#include &lt;stdio.h&gt;

int main(void) {
    const char* input =
        &#34;{:sql \&#34;\&#34;\&#34;\n&#34;
        &#34;       SELECT * FROM users\n&#34;
        &#34;       WHERE age &gt; 21\n&#34;
        &#34;       ORDER BY name\n&#34;
        &#34;       \&#34;\&#34;\&#34;&#34;}&#34;;

    edn_result_t result = edn_read(input, 0);

    if (result.error == EDN_OK) {
        edn_result_t key = edn_read(&#34;:sql&#34;, 0);
        edn_value_t* val = edn_map_lookup(result.value, key.value);

        // Text block returns a regular string with indentation stripped
        size_t len;
        const char* sql = edn_string_get(val, &amp;len);
        printf(&#34;%s\n&#34;, sql);
        // Output:
        // SELECT * FROM users
        // WHERE age &gt; 21
        // ORDER BY name

        edn_free(key.value);
        edn_free(result.value);
    }

    return 0;
}"><pre><span>#include</span> <span>&#34;edn.h&#34;</span>
<span>#include</span> <span>&lt;stdio.h&gt;</span>

<span>int</span> <span>main</span>(<span>void</span>) {
    <span>const</span> <span>char</span><span>*</span> <span>input</span> <span>=</span>
        <span>&#34;{:sql \&#34;\&#34;\&#34;\n&#34;</span>
        <span>&#34;       SELECT * FROM users\n&#34;</span>
        <span>&#34;       WHERE age &gt; 21\n&#34;</span>
        <span>&#34;       ORDER BY name\n&#34;</span>
        <span>&#34;       \&#34;\&#34;\&#34;&#34;</span>}&#34;;

    <span>edn_result_t</span> <span>result</span> <span>=</span> <span>edn_read</span>(<span>input</span>, <span>0</span>);

    <span>if</span> (<span>result</span>.<span>error</span> <span>==</span> <span>EDN_OK</span>) {
        <span>edn_result_t</span> <span>key</span> <span>=</span> <span>edn_read</span>(<span>&#34;:sql&#34;</span>, <span>0</span>);
        <span>edn_value_t</span><span>*</span> <span>val</span> <span>=</span> <span>edn_map_lookup</span>(<span>result</span>.<span>value</span>, <span>key</span>.<span>value</span>);

        <span>// Text block returns a regular string with indentation stripped</span>
        <span>size_t</span> <span>len</span>;
        <span>const</span> <span>char</span><span>*</span> <span>sql</span> <span>=</span> <span>edn_string_get</span>(<span>val</span>, <span>&amp;</span><span>len</span>);
        <span>printf</span>(<span>&#34;%s\n&#34;</span>, <span>sql</span>);
        <span>// Output:</span>
        <span>// SELECT * FROM users</span>
        <span>// WHERE age &gt; 21</span>
        <span>// ORDER BY name</span>

        <span>edn_free</span>(<span>key</span>.<span>value</span>);
        <span>edn_free</span>(<span>result</span>.<span>value</span>);
    }

    <span>return</span> <span>0</span>;
}</pre></div>
<p dir="auto"><strong>Indentation Rules (Java JEP 378)</strong>:</p>
<ol dir="auto">
<li>Find minimum indentation across all non-blank lines</li>
<li>Closing <code>&#34;&#34;&#34;</code> position also determines indentation</li>
<li>Strip that amount from each line</li>
<li>If closing <code>&#34;&#34;&#34;</code> is on its own line, add trailing <code>\n</code></li>
</ol>
<div dir="auto" data-snippet-clipboard-copy-content="{:foo &#34;&#34;&#34;
        line1
       line2
      line3
      &#34;&#34;&#34;}"><pre>{<span>:foo</span> <span><span>&#34;</span><span>&#34;</span><span>&#34;</span></span>
<span>        line1</span>
<span>       line2</span>
<span>      line3</span>
<span>      <span>&#34;</span><span>&#34;</span><span>&#34;</span></span>}</pre></div>
<p dir="auto">Result: <code>{:foo &#34;  line1\n line2\nline3\n&#34;}</code> (min indent 6, trailing newline added)</p>
<div dir="auto" data-snippet-clipboard-copy-content="{:foo &#34;&#34;&#34;
        line1
       line2
      line3&#34;&#34;&#34;}"><pre>{<span>:foo</span> <span><span>&#34;</span><span>&#34;</span><span>&#34;</span></span>
<span>        line1</span>
<span>       line2</span>
<span>      line3<span>&#34;</span><span>&#34;</span><span>&#34;</span></span>}</pre></div>
<p dir="auto">Result: <code>{:foo &#34;  line1\n line2\nline3&#34;}</code> (min indent 6, no trailing newline)</p>
<p dir="auto"><strong>Build Configuration:</strong></p>
<p dir="auto">This feature is disabled by default. To enable it:</p>
<p dir="auto"><strong>Make:</strong></p>

<p dir="auto"><strong>CMake:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="cmake -DEDN_ENABLE_TEXT_BLOCKS=ON ..
make"><pre>cmake -DEDN_ENABLE_TEXT_BLOCKS=ON ..
make</pre></div>
<p dir="auto">When disabled (default):</p>
<ul dir="auto">
<li><code>&#34;&#34;&#34;\n</code> pattern is parsed as a regular string</li>
<li>No automatic indentation processing</li>
</ul>
<p dir="auto"><strong>Note:</strong> Text blocks are an experimental feature and not part of the official EDN specification.</p>
<p dir="auto">See <code>examples/example_text_block.c</code> for more examples.</p>


<p dir="auto">EDN.C includes an interactive terminal viewer for exploring EDN data:</p>
<div dir="auto" data-snippet-clipboard-copy-content="# Build the TUI
make tui

# Explore data interactively
./examples/edn_tui data.edn

# Use arrow keys to navigate, Enter/Space to expand/collapse, q to quit"><pre><span><span>#</span> Build the TUI</span>
make tui

<span><span>#</span> Explore data interactively</span>
./examples/edn_tui data.edn

<span><span>#</span> Use arrow keys to navigate, Enter/Space to expand/collapse, q to quit</span></pre></div>

<p dir="auto">EDN.C includes a command-line tool for parsing and pretty-printing EDN files:</p>
<div dir="auto" data-snippet-clipboard-copy-content="# Build the CLI
make cli

# Parse and pretty-print a file
./examples/edn_cli data.edn

# Or from stdin
echo &#39;{:name &#34;Alice&#34; :age 30}&#39; | ./examples/edn_cli"><pre><span><span>#</span> Build the CLI</span>
make cli

<span><span>#</span> Parse and pretty-print a file</span>
./examples/edn_cli data.edn

<span><span>#</span> Or from stdin</span>
<span>echo</span> <span><span>&#39;</span>{:name &#34;Alice&#34; :age 30}<span>&#39;</span></span> <span>|</span> ./examples/edn_cli</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="#include &#34;edn.h&#34;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void print_value(edn_value_t *val, int indent) {
    for (int i = 0; i &lt; indent; i++) printf(&#34;  &#34;);
    
    switch (edn_type(val)) {
        case EDN_TYPE_NIL:
            printf(&#34;nil\n&#34;);
            break;
        case EDN_TYPE_BOOL:
            // Note: Use internal API or add edn_bool_get() to public API
            printf(&#34;bool\n&#34;);
            break;
        case EDN_TYPE_INT: {
            int64_t num;
            edn_int64_get(val, &amp;num);
            printf(&#34;%lld\n&#34;, (long long)num);
            break;
        }
        case EDN_TYPE_FLOAT: {
            double num;
            edn_double_get(val, &amp;num);
            printf(&#34;%g\n&#34;, num);
            break;
        }
        case EDN_TYPE_STRING: {
            size_t len;
            const char *str = edn_string_get(val, &amp;len);
            printf(&#34;\&#34;%.*s\&#34;\n&#34;, (int)len, str);
            break;
        }
        case EDN_TYPE_KEYWORD: {
            const char *name;
            size_t len;
            edn_keyword_get(val, NULL, NULL, &amp;name, &amp;len);
            printf(&#34;:%.*s\n&#34;, (int)len, name);
            break;
        }
        case EDN_TYPE_VECTOR: {
            printf(&#34;[\n&#34;);
            size_t count = edn_vector_count(val);
            for (size_t i = 0; i &lt; count; i++) {
                print_value(edn_vector_get(val, i), indent + 1);
            }
            for (int i = 0; i &lt; indent; i++) printf(&#34;  &#34;);
            printf(&#34;]\n&#34;);
            break;
        }
        case EDN_TYPE_MAP: {
            printf(&#34;{\n&#34;);
            size_t count = edn_map_count(val);
            for (size_t i = 0; i &lt; count; i++) {
                print_value(edn_map_get_key(val, i), indent + 1);
                print_value(edn_map_get_value(val, i), indent + 1);
            }
            for (int i = 0; i &lt; indent; i++) printf(&#34;  &#34;);
            printf(&#34;}\n&#34;);
            break;
        }
        default:
            printf(&#34;&lt;other type&gt;\n&#34;);
    }
}

int main(void) {
    const char *edn = 
        &#34;{:users [{:name \&#34;Alice\&#34; :age 30}\n&#34;
        &#34;         {:name \&#34;Bob\&#34; :age 25}]\n&#34;
        &#34; :status :active}&#34;;
    
    edn_result_t result = edn_read(edn, 0);
    
    if (result.error != EDN_OK) {
        fprintf(stderr, &#34;Error at %zu:%zu - %s\n&#34;,
                result.error_line, result.error_column, result.error_message);
        return 1;
    }
    
    printf(&#34;Parsed EDN structure:\n&#34;);
    print_value(result.value, 0);
    
    edn_free(result.value);
    return 0;
}"><pre><span>#include</span> <span>&#34;edn.h&#34;</span>
<span>#include</span> <span>&lt;stdio.h&gt;</span>
<span>#include</span> <span>&lt;string.h&gt;</span>

<span>void</span> <span>print_value</span>(<span>edn_value_t</span> <span>*</span><span>val</span>, <span>int</span> <span>indent</span>) {
    <span>for</span> (<span>int</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>indent</span>; <span>i</span><span>++</span>) <span>printf</span>(<span>&#34;  &#34;</span>);
    
    <span>switch</span> (<span>edn_type</span>(<span>val</span>)) {
        <span>case</span> <span>EDN_TYPE_NIL</span>:
            <span>printf</span>(<span>&#34;nil\n&#34;</span>);
            <span>break</span>;
        <span>case</span> <span>EDN_TYPE_BOOL</span>:
            <span>// Note: Use internal API or add edn_bool_get() to public API</span>
            <span>printf</span>(<span>&#34;bool\n&#34;</span>);
            <span>break</span>;
        <span>case</span> <span>EDN_TYPE_INT</span>: {
            <span>int64_t</span> <span>num</span>;
            <span>edn_int64_get</span>(<span>val</span>, <span>&amp;</span><span>num</span>);
            <span>printf</span>(<span>&#34;%lld\n&#34;</span>, (<span>long long</span>)<span>num</span>);
            <span>break</span>;
        }
        <span>case</span> <span>EDN_TYPE_FLOAT</span>: {
            <span>double</span> <span>num</span>;
            <span>edn_double_get</span>(<span>val</span>, <span>&amp;</span><span>num</span>);
            <span>printf</span>(<span>&#34;%g\n&#34;</span>, <span>num</span>);
            <span>break</span>;
        }
        <span>case</span> <span>EDN_TYPE_STRING</span>: {
            <span>size_t</span> <span>len</span>;
            <span>const</span> <span>char</span> <span>*</span><span>str</span> <span>=</span> <span>edn_string_get</span>(<span>val</span>, <span>&amp;</span><span>len</span>);
            <span>printf</span>(<span>&#34;\&#34;%.*s\&#34;\n&#34;</span>, (<span>int</span>)<span>len</span>, <span>str</span>);
            <span>break</span>;
        }
        <span>case</span> <span>EDN_TYPE_KEYWORD</span>: {
            <span>const</span> <span>char</span> <span>*</span><span>name</span>;
            <span>size_t</span> <span>len</span>;
            <span>edn_keyword_get</span>(<span>val</span>, <span>NULL</span>, <span>NULL</span>, <span>&amp;</span><span>name</span>, <span>&amp;</span><span>len</span>);
            <span>printf</span>(<span>&#34;:%.*s\n&#34;</span>, (<span>int</span>)<span>len</span>, <span>name</span>);
            <span>break</span>;
        }
        <span>case</span> <span>EDN_TYPE_VECTOR</span>: {
            <span>printf</span>(<span>&#34;[\n&#34;</span>);
            <span>size_t</span> <span>count</span> <span>=</span> <span>edn_vector_count</span>(<span>val</span>);
            <span>for</span> (<span>size_t</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>count</span>; <span>i</span><span>++</span>) {
                <span>print_value</span>(<span>edn_vector_get</span>(<span>val</span>, <span>i</span>), <span>indent</span> <span>+</span> <span>1</span>);
            }
            <span>for</span> (<span>int</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>indent</span>; <span>i</span><span>++</span>) <span>printf</span>(<span>&#34;  &#34;</span>);
            <span>printf</span>(<span>&#34;]\n&#34;</span>);
            <span>break</span>;
        }
        <span>case</span> <span>EDN_TYPE_MAP</span>: {
            <span>printf</span>(<span>&#34;{\n&#34;</span>);
            <span>size_t</span> <span>count</span> <span>=</span> <span>edn_map_count</span>(<span>val</span>);
            <span>for</span> (<span>size_t</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>count</span>; <span>i</span><span>++</span>) {
                <span>print_value</span>(<span>edn_map_get_key</span>(<span>val</span>, <span>i</span>), <span>indent</span> <span>+</span> <span>1</span>);
                <span>print_value</span>(<span>edn_map_get_value</span>(<span>val</span>, <span>i</span>), <span>indent</span> <span>+</span> <span>1</span>);
            }
            <span>for</span> (<span>int</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>indent</span>; <span>i</span><span>++</span>) <span>printf</span>(<span>&#34;  &#34;</span>);
            <span>printf</span>(<span>&#34;}\n&#34;</span>);
            <span>break</span>;
        }
        <span>default</span>:
            <span>printf</span>(<span>&#34;&lt;other type&gt;\n&#34;</span>);
    }
}

<span>int</span> <span>main</span>(<span>void</span>) {
    <span>const</span> <span>char</span> <span>*</span><span>edn</span> <span>=</span> 
        <span>&#34;{:users [{:name \&#34;Alice\&#34; :age 30}\n&#34;</span>
        <span>&#34;         {:name \&#34;Bob\&#34; :age 25}]\n&#34;</span>
        <span>&#34; :status :active}&#34;</span>;
    
    <span>edn_result_t</span> <span>result</span> <span>=</span> <span>edn_read</span>(<span>edn</span>, <span>0</span>);
    
    <span>if</span> (<span>result</span>.<span>error</span> <span>!=</span> <span>EDN_OK</span>) {
        <span>fprintf</span>(<span>stderr</span>, <span>&#34;Error at %zu:%zu - %s\n&#34;</span>,
                <span>result</span>.<span>error_line</span>, <span>result</span>.<span>error_column</span>, <span>result</span>.<span>error_message</span>);
        <span>return</span> <span>1</span>;
    }
    
    <span>printf</span>(<span>&#34;Parsed EDN structure:\n&#34;</span>);
    <span>print_value</span>(<span>result</span>.<span>value</span>, <span>0</span>);
    
    <span>edn_free</span>(<span>result</span>.<span>value</span>);
    <span>return</span> <span>0</span>;
}</pre></div>
<p dir="auto">More examples available in the <code>examples/</code> directory.</p>

<div dir="auto"><h3 tabindex="-1" dir="auto">Standard Build (Unix/macOS/Linux)</h3><a id="user-content-standard-build-unixmacoslinux" aria-label="Permalink: Standard Build (Unix/macOS/Linux)" href="#standard-build-unixmacoslinux"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="# Build library (libedn.a)
make

# Build and run all tests
make test

# Build and run single test
make test/test_numbers
./test/test_numbers

# Build with debug symbols and sanitizers (ASAN/UBSAN)
make DEBUG=1

# Run benchmarks
make bench          # Quick benchmark
make bench-all      # All benchmarks

# Clean build artifacts
make clean

# Show build configuration
make info"><pre><span><span>#</span> Build library (libedn.a)</span>
make

<span><span>#</span> Build and run all tests</span>
make <span>test</span>

<span><span>#</span> Build and run single test</span>
make test/test_numbers
./test/test_numbers

<span><span>#</span> Build with debug symbols and sanitizers (ASAN/UBSAN)</span>
make DEBUG=1

<span><span>#</span> Run benchmarks</span>
make bench          <span><span>#</span> Quick benchmark</span>
make bench-all      <span><span>#</span> All benchmarks</span>

<span><span>#</span> Clean build artifacts</span>
make clean

<span><span>#</span> Show build configuration</span>
make info</pre></div>

<p dir="auto">EDN.C fully supports Windows with MSVC, MinGW, and Clang. Choose your preferred method:</p>
<p dir="auto"><strong>Quick Start (CMake - Recommended):</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="# Using the provided build script
.\build.bat

# Or with PowerShell
.\build.ps1 -Test"><pre><span><span>#</span> Using the provided build script</span>
.\<span>build.bat</span>

<span><span>#</span> Or with PowerShell</span>
.\build.ps1 <span>-</span>Test</pre></div>
<p dir="auto"><strong>Manual CMake Build:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="mkdir build
cd build
cmake .. -DCMAKE_BUILD_TYPE=Release
cmake --build . --config Release
ctest -C Release"><pre>mkdir build
cd build
cmake .<span>.</span> <span>-</span>DCMAKE_BUILD_TYPE<span>=</span>Release
cmake <span>--</span>build <span>.</span> <span>--</span>config Release
ctest <span>-</span>C Release</pre></div>
<p dir="auto"><strong>Visual Studio:</strong></p>
<ul dir="auto">
<li>Open <code>CMakeLists.txt</code> in Visual Studio 2019+</li>
<li>Build ‚Üí Build All (Ctrl+Shift+B)</li>
</ul>
<p dir="auto">For detailed Windows build instructions, see <strong><a href="https://github.com/DotFox/edn.c/blob/main/docs/WINDOWS.md">docs/WINDOWS.md</a></strong>.</p>

<p dir="auto"><strong>Standard options:</strong></p>
<ul dir="auto">
<li><code>DEBUG=1</code> - Enable debug symbols, ASAN, and UBSAN</li>
<li><code>SANITIZE=1</code> - Enable sanitizers without full debug build</li>
<li><code>OPTIMIZE=0</code> - Disable optimizations</li>
<li><code>VERBOSE=1</code> - Show full compiler commands</li>
</ul>
<p dir="auto"><strong>Optional EDN features (disabled by default):</strong></p>
<ul dir="auto">
<li><code>MAP_NAMESPACE_SYNTAX=1</code> - Enable <code>#:ns{...}</code> map namespace syntax</li>
<li><code>EXTENDED_CHARACTERS=1</code> - Enable <code>\formfeed</code>, <code>\backspace</code>, <code>\oNNN</code> octal escapes</li>
<li><code>METADATA=1</code> - Enable Clojure-style metadata <code>^{...}</code> syntax</li>
<li><code>TEXT_BLOCKS=1</code> - Enable Java-style text blocks <code>&#34;&#34;&#34;\n...\n&#34;&#34;&#34;</code></li>
<li><code>RATIO=1</code> - Enable ratio numbers <code>22/7</code></li>
<li><code>EXTENDED_INTEGERS=1</code> - Enable hex (<code>0xFF</code>), octal (<code>0777</code>), binary (<code>2r1010</code>), and radix (<code>36rZZ</code>) formats</li>
<li><code>UNDERSCORE_IN_NUMERIC=1</code> - Enable underscores in numeric literals <code>1_000_000</code></li>
</ul>
<p dir="auto"><strong>Example:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="# Build with metadata and ratio support
make METADATA=1 RATIO=1"><pre><span><span>#</span> Build with metadata and ratio support</span>
make METADATA=1 RATIO=1</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="# Auto-format all C files (run before committing!)
make format

# Check if formatting is needed without modifying
make format-check"><pre><span><span>#</span> Auto-format all C files (run before committing!)</span>
make format

<span><span>#</span> Check if formatting is needed without modifying</span>
make format-check</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="# Generate compile_commands.json for LSP (requires bear or compiledb)
make compile-commands"><pre><span><span>#</span> Generate compile_commands.json for LSP (requires bear or compiledb)</span>
make compile-commands</pre></div>

<p dir="auto">EDN.C is designed for high performance with several optimizations:</p>
<ul dir="auto">
<li><strong>SIMD acceleration</strong>: Vectorized whitespace scanning, comment skipping, and identifier parsing</li>
<li><strong>Zero-copy strings</strong>: String values without escapes point directly into input buffer</li>
<li><strong>Lazy decoding</strong>: Escape sequences decoded only when accessed via <code>edn_string_get()</code></li>
<li><strong>Arena allocation</strong>: Single bulk allocation and deallocation eliminates malloc overhead</li>
<li><strong>Efficient collections</strong>: Maps and sets use sorted arrays with binary search</li>
</ul>
<p dir="auto"><strong>Typical performance on Apple M1</strong> (from microbenchmarks):</p>
<ul dir="auto">
<li>Whitespace skipping: 1-5 ns per operation</li>
<li>Number parsing: 10-30 ns per number</li>
<li>String parsing: 15-50 ns per string</li>
<li>Identifier parsing: 10-25 ns per symbol/keyword</li>
</ul>
<p dir="auto">See <code>bench/</code> directory for detailed benchmarking tools and results.</p>

<p dir="auto"><strong>Current version</strong>: 1.0.0 (Release Candidate)</p>
<p dir="auto">‚úÖ <strong>Complete features:</strong></p>
<ul dir="auto">
<li>Full EDN specification support</li>
<li>All scalar types (nil, bool, int, bigint, float, character, string, symbol, keyword)</li>
<li>All collection types (lists, vectors, maps, sets)</li>
<li>Tagged literals with custom reader support</li>
<li>Discard forms <code>#_</code></li>
<li>Comments (<code>;</code> line comments)</li>
<li>Duplicate detection for maps/sets</li>
<li>Deep structural equality</li>
<li>SIMD optimization for ARM64 (NEON) and x86_64 (SSE4.2)</li>
<li>Cross-platform support (Unix, macOS, Linux, Windows)</li>
<li>Optional Clojure extensions (disabled by default):
<ul dir="auto">
<li>Map namespace syntax <code>#:ns{...}</code></li>
<li>Extended character literals (<code>\formfeed</code>, <code>\backspace</code>, <code>\oNNN</code>)</li>
<li>Metadata <code>^{...}</code> syntax</li>
</ul>
</li>
</ul>
<p dir="auto">‚úÖ <strong>Testing:</strong></p>
<ul dir="auto">
<li>340+ tests across 24 test suites</li>
<li>Memory safety verified with ASAN/UBSAN</li>
<li>Edge case coverage (empty collections, deeply nested structures, Unicode, etc.)</li>
</ul>
<p dir="auto">üìã <strong>Roadmap:</strong></p>
<ul dir="auto">
<li>Performance profiling and further optimization</li>
<li>Extended documentation and tutorials</li>
<li>Streaming/Incremental parsing</li>
<li>Additional SIMD Platform Support:
<ul dir="auto">
<li>32-bit x86 (i386/i686) <code>__i386__, _M_IX86. mostly the same as x86-64</code></li>
<li>32-bit ARM (ARMv7) <code>__arm__, _M_ARM. mostly the same as ARM64 NEON</code></li>
<li>RISC-V Vector Extension (RVV) <code>__riscv, __riscv_vector. uses &lt;riscv_vector.h&gt;</code></li>
</ul>
</li>
<li>Extra features:
<ul dir="auto">
<li>float trailing dot (&#34;1.&#34; =&gt; 1.0, &#34;1.M&#34; =&gt; 1.0M)</li>
<li>octal escape (&#34;&#34;\176&#34;&#34; =&gt; &#34;~&#34;)</li>
</ul>
</li>
</ul>

<p dir="auto">Contributions are welcome! Please:</p>
<ol dir="auto">
<li>Run <code>make format</code> before committing (auto-formats with clang-format)</li>
<li>Ensure all tests pass with <code>make test</code></li>
<li>Add tests for new features</li>
<li>Follow the existing code style (K&amp;R, 4 spaces, C11, see <code>.clang-format</code>)</li>
</ol>

<ul dir="auto">
<li><a href="https://github.com/DotFox/edn.c/blob/main/docs/DESIGN.md">docs/DESIGN.md</a> - Architecture and design philosophy</li>
<li><a href="https://github.com/DotFox/edn.c/blob/main/docs/READER_DESIGN.md">docs/READER_DESIGN.md</a> - Custom reader implementation</li>
</ul>

<p dir="auto">MIT License</p>
<p dir="auto">Copyright (c) 2025 [Kirill Chernyshov]</p>
<p dir="auto">Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &#34;Software&#34;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>
<p dir="auto">The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.</p>
<p dir="auto">THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</p>

<ul dir="auto">
<li>EDN specification: <a href="https://github.com/edn-format/edn">https://github.com/edn-format/edn</a></li>
<li>Inspired by Clojure&#39;s EDN implementation</li>
<li>Benchmark files from <a href="https://github.com/tonsky/fast-edn">fast-edn</a></li>
<li>SWAR (SIMD Within A Register) digit parsing technique from <a href="https://github.com/simdjson/simdjson">simdjson</a></li>
<li>Fast double parsing using Clinger&#39;s algorithm (William D. Clinger, 1990) - &#34;How to Read Floating Point Numbers Accurately&#34;</li>
<li>SIMD optimization patterns from high-performance JSON parsers (simdjson, yyjson)</li>
</ul>
<hr/>
<p dir="auto"><strong>Questions or issues?</strong> Please open an issue on GitHub or consult the documentation in the <code>docs/</code> directory.</p>
</article></div></div>
  </body>
</html>
