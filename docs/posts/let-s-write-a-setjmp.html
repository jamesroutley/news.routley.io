<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nullprogram.com/blog/2023/02/12/">Original</a>
    <h1>Let&#39;s write a setjmp</h1>
    
    <div id="readability-page-1" class="page"><div lang="en">
<article>
  <h2><a href="https://www.blog.jamesgisele.com/blog/2023/02/12/">Let&#39;s write a setjmp</a></h2>
  <time datetime="2023-02-12">
    February 12, 2023
  </time>
  <p>
    nullprogram.com/blog/2023/02/12/
  </p>

  <p>Yesterday I wrote that <a href="https://www.blog.jamesgisele.com/blog/2023/02/11/"><code>setjmp</code> is handy</a> and that it would be nice
to have without linking the C standard library. It’s conceptually simple,
after all. Today let’s explore some differently-portable implementation
possibilities with distinct trade-offs. At the very least it should
illuminate why <code>setjmp</code> sometimes requires the use of <code>volatile</code>.</p>

<p>First, a quick review: <code>setjmp</code> and <code>longjmp</code> are a form of <em>non-local
goto</em>.</p>

<div><div><pre><code><span>typedef</span> <span>void</span> <span>*</span><span>jmp_buf</span><span>[</span><span>N</span><span>];</span>
<span>int</span> <span>setjmp</span><span>(</span><span>jmp_buf</span><span>);</span>
<span>void</span> <span>longjmp</span><span>(</span><span>jmp_buf</span><span>,</span> <span>int</span><span>);</span>
</code></pre></div></div>

<p>Calling <code>setjmp</code> saves the execution context in a <code>jmp_buf</code>, and <code>longjmp</code>
restores this context, returning the thread to this previous point of
execution. This means <code>setjmp</code> returns twice: (1) after saving the
context, and (2) from <code>longjmp</code>. To distinguish these cases, the first
time it returns zero and the second time it returns the value passed to
<code>longjmp</code>.</p>

<p><code>jmp_buf</code> is an array of some platform-specific type and length. I’ll be
using void pointers in this article because it’s a register-sized type
that isn’t behind a typedef. Plus they print nicely in GDB as hexadecimal
addresses which eased in working it out.</p>

<h3 id="using-gcc-intrinsics">Using GCC intrinsics</h3>

<p>Let’s start with the easiest option. <a href="https://gcc.gnu.org/onlinedocs/gcc/Nonlocal-Gotos.html">GCC has two intrinsics</a> doing
all the hard work for us: <code>__builtin_setjmp</code> and <code>__builtin_longjmp</code>. Its
worst case <code>jmp_buf</code> is length 5, but the most popular architectures only
use the first 3 elements. Clang supports these intrinsics as well for GCC
compatibility.</p>

<p>Be mindful that the semantics are slightly different from the standard C
definition, namely that you cannot use <code>longjmp</code> from the same function as
<code>setjmp</code>. It also doesn’t touch the signal mask. However, it’s easier to
use and you don’t need to worry about <code>volatile</code>.</p>

<div><div><pre><code><span>// NOTE to copy-pasters: semantics differ slightly from standard C</span>
<span>typedef</span> <span>void</span> <span>*</span><span>jmp_buf</span><span>[</span><span>5</span><span>];</span>
<span>#define setjmp __builtin_setjmp
#define longjmp __builtin_longjmp
</span></code></pre></div></div>

<p>If you only care about GCC and/or Clang, then that’s it! It works as-is on
every supported target and nothing more is needed. As a bonus, it will be
more efficient than the libc version, though I should hope that won’t
matter in practice. These are so awesome and convenient that I’m already
second-guessing myself: “Do I <em>really</em> need to support other compilers…?”</p>

<h3 id="using-assembly">Using assembly</h3>

<p>If I want to support more compilers I’ll need to write it myself. It’s
also an excuse to dig into the details. The execution context is no more
than an array of saved registers, and <code>longjmp</code> is merely restoring those
registers. One of the registers is the instruction pointer, and setting
the instruction pointer is called a jump.</p>

<p>Since we’re talking about registers, that means assembly. We’ll also need
to know the target’s calling convention, so this really narrows things
down. This implementation will target x86-64, a.k.a x64, Windows, <em>but</em> it
will support MSVC as an additional compiler. So it’s a different kind of
portability. I’ll start with GCC via <a href="https://github.com/skeeto/w64devkit">w64devkit</a> then massage it into
something MSVC can use.</p>

<p>I mentioned before that <code>setjmp</code> returns twice. So to return a second time
we just need to <em>simulate</em> a normal function return. Obviously that
includes restoring the stack pointer like the <code>ret</code> instruction, but it
means preserving all the non-volatile registers a callee is supposed to
preserve. These will all go in the execution context.</p>

<p>The <a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention">x64 calling convention</a> specifies 9 non-volatile <code>rsp</code>, <code>rsp</code>,
<code>rbx</code>, <code>rdi</code>, <code>rsi</code>, <code>r12</code>, <code>r13</code>, <code>r14</code>, and <code>r15</code>. We’ll also need the
instruction pointer, <code>rip</code>, making it 10 total.</p>

<div><div><pre><code><span>typedef</span> <span>void</span> <span>*</span><span>jmp_buf</span><span>[</span><span>10</span><span>];</span>
</code></pre></div></div>

<h4 id="setjmp-assembly">setjmp assembly</h4>

<p>The tricky issue is that we need to save the registers immediately inside
<code>setjmp</code> before the compiler has manipulated them in a function prologue.
That will take more than mere inline assembly. We’ll start with a <em>naked</em>
function, which means that GCC will not create a prologue or epilogue.
However, that means no local variables, and the function body will be
limited to inline assembly, including a <code>ret</code> instruction for the
epilogue.</p>

<div><div><pre><code><span>__attribute__</span><span>((</span><span>naked</span><span>))</span>
<span>int</span> <span>setjmp</span><span>(</span><span>jmp_buf</span> <span>buf</span><span>)</span>
<span>{</span>
    <span>__asm</span><span>(</span>
        <span>// ...</span>
    <span>);</span>
<span>}</span>
</code></pre></div></div>

<p>The x64 calling convention uses <code>rcx</code> for the first pointer argument, so
that’s where we’ll find <code>buf</code>. I’ve arbitrarily decided to store <code>rip</code>
first, then the other registers in order. However, the current value of
<code>rip</code> isn’t the one we need. The <code>rip</code> we need was just pushed on top of
the stack by the caller. I’ll read that off the stack into a scratch
register, <code>rax</code>, and then store it in the first element of <code>buf</code>.</p>

<div><div><pre><code>    <span>mov</span> <span>(</span><span>%</span><span>rsp</span><span>),</span> <span>%</span><span>rax</span>
    <span>mov</span> <span>%</span><span>rax</span><span>,</span>  <span>0</span><span>(</span><span>%</span><span>rcx</span><span>)</span>
</code></pre></div></div>

<p>The stack pointer, <code>rsp</code>, is also indirect since I want the pointer just
before <code>rip</code> was pushed, as it would be just after a <code>ret</code>. I use a <code>lea</code>,
<em>load effective address</em>, to add 8 bytes (recall: stack grows down),
placing the result in a scratch register, then write it into the second
element of <code>buf</code> (i.e. 8 bytes into <code>%rcx</code>).</p>

<div><div><pre><code>    <span>lea</span> <span>8</span><span>(</span><span>%</span><span>rsp</span><span>),</span> <span>%</span><span>rax</span>
    <span>mov</span> <span>%</span><span>rax</span><span>,</span>  <span>8</span><span>(</span><span>%</span><span>rcx</span><span>)</span>
</code></pre></div></div>

<p>Everything else is a matter of elbow grease.</p>

<div><div><pre><code>    <span>mov</span> <span>%</span><span>rbp</span><span>,</span> <span>16</span><span>(</span><span>%</span><span>rcx</span><span>)</span>
    <span>mov</span> <span>%</span><span>rbx</span><span>,</span> <span>24</span><span>(</span><span>%</span><span>rcx</span><span>)</span>
    <span>mov</span> <span>%</span><span>rdi</span><span>,</span> <span>32</span><span>(</span><span>%</span><span>rcx</span><span>)</span>
    <span>mov</span> <span>%</span><span>rsi</span><span>,</span> <span>40</span><span>(</span><span>%</span><span>rcx</span><span>)</span>
    <span>mov</span> <span>%</span><span>r12</span><span>,</span> <span>48</span><span>(</span><span>%</span><span>rcx</span><span>)</span>
    <span>mov</span> <span>%</span><span>r13</span><span>,</span> <span>56</span><span>(</span><span>%</span><span>rcx</span><span>)</span>
    <span>mov</span> <span>%</span><span>r14</span><span>,</span> <span>64</span><span>(</span><span>%</span><span>rcx</span><span>)</span>
    <span>mov</span> <span>%</span><span>r15</span><span>,</span> <span>72</span><span>(</span><span>%</span><span>rcx</span><span>)</span>
</code></pre></div></div>

<p>With all work complete, return zero to the caller.</p>

<div><div><pre><code>    <span>xor</span> <span>%</span><span>eax</span><span>,</span> <span>%</span><span>eax</span>
    <span>ret</span>
</code></pre></div></div>

<p>Putting it altogether, and avoiding a <code>-Wunused-variable</code>:</p>

<div><div><pre><code><span>__attribute__</span><span>((</span><span>naked</span><span>,</span><span>returns_twice</span><span>))</span>
<span>int</span> <span>setjmp</span><span>(</span><span>jmp_buf</span> <span>buf</span><span>)</span>
<span>{</span>
    <span>(</span><span>void</span><span>)</span><span>buf</span><span>;</span>
    <span>__asm</span><span>(</span>
        <span>&#34;mov (%rsp), %rax</span><span>\n</span><span>&#34;</span>
        <span>&#34;mov %rax,  0(%rcx)</span><span>\n</span><span>&#34;</span>
        <span>&#34;lea 8(%rsp), %rax</span><span>\n</span><span>&#34;</span>
        <span>&#34;mov %rax,  8(%rcx)</span><span>\n</span><span>&#34;</span>
        <span>&#34;mov %rbp, 16(%rcx)</span><span>\n</span><span>&#34;</span>
        <span>&#34;mov %rbx, 24(%rcx)</span><span>\n</span><span>&#34;</span>
        <span>&#34;mov %rdi, 32(%rcx)</span><span>\n</span><span>&#34;</span>
        <span>&#34;mov %rsi, 40(%rcx)</span><span>\n</span><span>&#34;</span>
        <span>&#34;mov %r12, 48(%rcx)</span><span>\n</span><span>&#34;</span>
        <span>&#34;mov %r13, 56(%rcx)</span><span>\n</span><span>&#34;</span>
        <span>&#34;mov %r14, 64(%rcx)</span><span>\n</span><span>&#34;</span>
        <span>&#34;mov %r15, 72(%rcx)</span><span>\n</span><span>&#34;</span>
        <span>&#34;xor %eax, %eax</span><span>\n</span><span>&#34;</span>
        <span>&#34;ret</span><span>\n</span><span>&#34;</span>
    <span>);</span>
<span>}</span>
</code></pre></div></div>

<p>Also take note of the <code>returns_twice</code> attribute. It informs GCC of this
function’s unusual nature, saying the function <em>doesn’t</em> preserve most
non-volatile registers, and induces <code>-Wclobbered</code> diagnostics. Technically
this means we could get away with saving only <code>rip</code>, <code>rsp</code>, and <code>rbp</code> —
exactly as <code>__builtin_setjmp</code> does — but we’ll need the others for MSVC
anyway.</p>

<h4 id="longjmp-assembly">longjmp assembly</h4>

<p>In <code>longjmp</code> we need to restore all those registers. For purely aesthetic
reasons I’ve decided to do it in reverse order. Everything but <code>rip</code> is
easy.</p>

<div><div><pre><code>    <span>mov</span> <span>72</span><span>(</span><span>%</span><span>rcx</span><span>),</span> <span>%</span><span>r15</span>
    <span>mov</span> <span>64</span><span>(</span><span>%</span><span>rcx</span><span>),</span> <span>%</span><span>r14</span>
    <span>mov</span> <span>56</span><span>(</span><span>%</span><span>rcx</span><span>),</span> <span>%</span><span>r13</span>
    <span>mov</span> <span>48</span><span>(</span><span>%</span><span>rcx</span><span>),</span> <span>%</span><span>r12</span>
    <span>mov</span> <span>40</span><span>(</span><span>%</span><span>rcx</span><span>),</span> <span>%</span><span>rsi</span>
    <span>mov</span> <span>32</span><span>(</span><span>%</span><span>rcx</span><span>),</span> <span>%</span><span>rdi</span>
    <span>mov</span> <span>24</span><span>(</span><span>%</span><span>rcx</span><span>),</span> <span>%</span><span>rbx</span>
    <span>mov</span> <span>16</span><span>(</span><span>%</span><span>rcx</span><span>),</span> <span>%</span><span>rbp</span>
    <span>mov</span>  <span>8</span><span>(</span><span>%</span><span>rcx</span><span>),</span> <span>%</span><span>rsp</span>
</code></pre></div></div>

<p>The instruction set doesn’t have direct access to <code>rip</code>. It will be a
<code>jmp</code> instead of <code>mov</code>, but before jumping we’ll need to prepare the
return value. The x64 calling convention says the second argument is
passed in <code>rdx</code>, so move that to <code>rax</code>, then <code>jmp</code> to the caller. It’s
only a 32-bit operand, C <code>int</code>, so <code>edx</code> instead of <code>rdx</code>.</p>

<div><div><pre><code>    <span>mov</span> <span>%</span><span>edx</span><span>,</span> <span>%</span><span>eax</span>
    <span>jmp</span> <span>*</span><span>0</span><span>(</span><span>%</span><span>rcx</span><span>)</span>
</code></pre></div></div>

<p>Putting it all together, and adding the <code>noreturn</code> attribute:</p>

<div><div><pre><code><span>__attribute__</span><span>((</span><span>naked</span><span>,</span><span>noreturn</span><span>))</span>
<span>void</span> <span>longjmp</span><span>(</span><span>jmp_buf</span> <span>buf</span><span>,</span> <span>int</span> <span>ret</span><span>)</span>
<span>{</span>
    <span>(</span><span>void</span><span>)</span><span>buf</span><span>;</span>
    <span>(</span><span>void</span><span>)</span><span>ret</span><span>;</span>
    <span>__asm</span><span>(</span>
        <span>&#34;mov 72(%rcx), %r15</span><span>\n</span><span>&#34;</span>
        <span>&#34;mov 64(%rcx), %r14</span><span>\n</span><span>&#34;</span>
        <span>&#34;mov 56(%rcx), %r13</span><span>\n</span><span>&#34;</span>
        <span>&#34;mov 48(%rcx), %r12</span><span>\n</span><span>&#34;</span>
        <span>&#34;mov 40(%rcx), %rsi</span><span>\n</span><span>&#34;</span>
        <span>&#34;mov 32(%rcx), %rdi</span><span>\n</span><span>&#34;</span>
        <span>&#34;mov 24(%rcx), %rbx</span><span>\n</span><span>&#34;</span>
        <span>&#34;mov 16(%rcx), %rbp</span><span>\n</span><span>&#34;</span>
        <span>&#34;mov  8(%rcx), %rsp</span><span>\n</span><span>&#34;</span>
        <span>&#34;mov %edx, %eax</span><span>\n</span><span>&#34;</span>
        <span>&#34;jmp *0(%rcx)</span><span>\n</span><span>&#34;</span>
    <span>);</span>
<span>}</span>
</code></pre></div></div>

<p>The C standard says that if <code>ret</code> is zero then <code>longjmp</code> will return 1
from <code>setjmp</code> instead. I leave that detail as a reader exercise. Otherwise
this is a complete, working <code>setjmp</code>. It works perfectly when I swap it in
for <code>setjmp.h</code> in <a href="https://github.com/skeeto/u-config/blob/master/test_main.c">my u-config test suite</a>.</p>

<h3 id="considering-volatile">Considering volatile</h3>

<p>Now that you’ve seen the guts, let’s talk about <code>volatile</code> and why it’s
necessary. Consider this function, <code>example</code>, which calls a <code>work</code>
function that may return through <code>setjmp</code> (e.g. on failure).</p>

<div><div><pre><code><span>void</span> <span>work</span><span>(</span><span>jmp_buf</span><span>);</span>

<span>int</span> <span>example</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
    <span>int</span> <span>r</span> <span>=</span> <span>0</span><span>;</span>
    <span>jmp_buf</span> <span>buf</span><span>;</span>
    <span>if</span> <span>(</span><span>!</span><span>setjmp</span><span>(</span><span>buf</span><span>))</span> <span>{</span>
        <span>// first return</span>
        <span>r</span> <span>=</span> <span>1</span><span>;</span>
        <span>work</span><span>(</span><span>buf</span><span>);</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>// second return</span>
    <span>}</span>
    <span>return</span> <span>r</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>It stores to <code>r</code> after the first <code>setjmp</code> return, then loads <code>r</code> after the
second <code>setjmp</code> return. However, <code>r</code> may have been stored in the execution
context. Since it’s used across function calls, it would be reasonable to
store this variable in non-volatile register like <code>ebx</code>. If so, it will be
restored to its value at the moment of the first call to <code>setbuf</code>, in
which case the <em>old</em> <code>r</code> would be read after restoration by <code>longjmp</code>. If
it’s not stored in a register, but on the stack, then on the second return
the function will read the latest value out of the stack. In practice, if
<code>work</code> returns through <code>longjmp</code>, this function may return either 0 or 1,
probably determined by the optimization level.</p>

<p>The solution is to qualify <code>r</code> with <code>volatile</code>, which forces the compiler
to store the variable on the stack and never cache it in a register.</p>

<div><div><pre><code>    <span>volatile</span> <span>int</span> <span>r</span> <span>=</span> <span>0</span><span>;</span>
</code></pre></div></div>

<p>Though since our <code>setbuf</code> is marked <code>returns_twice</code>, GCC will never store
<code>r</code> in a register across <code>setjmp</code> calls. This potentially hides a bug in
the program that would occur under some other compilers, but GCC will
(usually) warn about it.</p>

<h3 id="pure-assembly-and-msvc">Pure assembly and MSVC</h3>

<p>MSVC doesn’t understand <code>__attribute__</code> nor the inline assembly, so it
cannot compile these functions. I could compile my <code>setjmp</code> with GCC and
the rest of the program with MSVC, which means I need two compilers.
Instead, I’ll move to pure assembly, assemble with GNU <code>as</code> (TODO: port
to MASM?) so we’ll only need a tiny piece of the GNU toolchain.</p>

<div><div><pre><code>	<span>.global</span> <span>setjmp</span>
<span>setjmp:</span>
        <span>mov</span> <span>(</span><span>%</span><span>rsp</span><span>),</span> <span>%</span><span>rax</span>
	<span>mov</span> <span>%</span><span>rax</span><span>,</span>  <span>0</span><span>(</span><span>%</span><span>rcx</span><span>)</span>
	<span>lea</span> <span>8</span><span>(</span><span>%</span><span>rsp</span><span>),</span> <span>%</span><span>rax</span>
	<span>mov</span> <span>%</span><span>rax</span><span>,</span>  <span>8</span><span>(</span><span>%</span><span>rcx</span><span>)</span>
	<span>mov</span> <span>%</span><span>rbp</span><span>,</span> <span>16</span><span>(</span><span>%</span><span>rcx</span><span>)</span>
	<span>mov</span> <span>%</span><span>rbx</span><span>,</span> <span>24</span><span>(</span><span>%</span><span>rcx</span><span>)</span>
	<span>mov</span> <span>%</span><span>rdi</span><span>,</span> <span>32</span><span>(</span><span>%</span><span>rcx</span><span>)</span>
	<span>mov</span> <span>%</span><span>rsi</span><span>,</span> <span>40</span><span>(</span><span>%</span><span>rcx</span><span>)</span>
	<span>mov</span> <span>%</span><span>r12</span><span>,</span> <span>48</span><span>(</span><span>%</span><span>rcx</span><span>)</span>
	<span>mov</span> <span>%</span><span>r13</span><span>,</span> <span>56</span><span>(</span><span>%</span><span>rcx</span><span>)</span>
	<span>mov</span> <span>%</span><span>r14</span><span>,</span> <span>64</span><span>(</span><span>%</span><span>rcx</span><span>)</span>
	<span>mov</span> <span>%</span><span>r15</span><span>,</span> <span>72</span><span>(</span><span>%</span><span>rcx</span><span>)</span>
	<span>xor</span> <span>%</span><span>eax</span><span>,</span> <span>%</span><span>eax</span>
	<span>ret</span>

	<span>.globl</span> <span>longjmp</span>
<span>longjmp:</span>
	<span>mov</span> <span>72</span><span>(</span><span>%</span><span>rcx</span><span>),</span> <span>%</span><span>r15</span>
	<span>mov</span> <span>64</span><span>(</span><span>%</span><span>rcx</span><span>),</span> <span>%</span><span>r14</span>
	<span>mov</span> <span>56</span><span>(</span><span>%</span><span>rcx</span><span>),</span> <span>%</span><span>r13</span>
	<span>mov</span> <span>48</span><span>(</span><span>%</span><span>rcx</span><span>),</span> <span>%</span><span>r12</span>
	<span>mov</span> <span>40</span><span>(</span><span>%</span><span>rcx</span><span>),</span> <span>%</span><span>rsi</span>
	<span>mov</span> <span>32</span><span>(</span><span>%</span><span>rcx</span><span>),</span> <span>%</span><span>rdi</span>
	<span>mov</span> <span>24</span><span>(</span><span>%</span><span>rcx</span><span>),</span> <span>%</span><span>rbx</span>
	<span>mov</span> <span>16</span><span>(</span><span>%</span><span>rcx</span><span>),</span> <span>%</span><span>rbp</span>
	<span>mov</span>  <span>8</span><span>(</span><span>%</span><span>rcx</span><span>),</span> <span>%</span><span>rsp</span>
	<span>mov</span> <span>%</span><span>edx</span><span>,</span> <span>%</span><span>eax</span>
	<span>jmp</span> <span>*</span><span>0</span><span>(</span><span>%</span><span>rcx</span><span>)</span>
</code></pre></div></div>

<p>Then some declarations in C:</p>

<div><div><pre><code><span>typedef</span> <span>void</span> <span>*</span><span>jmp_buf</span><span>[</span><span>10</span><span>];</span>
<span>int</span> <span>setjmp</span><span>(</span><span>jmp_buf</span><span>);</span>
<span>_Noreturn</span> <span>void</span> <span>longjmp</span><span>(</span><span>jmp_buf</span><span>,</span> <span>int</span><span>);</span>
</code></pre></div></div>

<p>I’ll need to enable C11 for that <code>_Noreturn</code> in MSVC. Assemble, compile,
and link:</p>

<div><div><pre><code>$ as -o setjmp.obj setjmp.s
$ cl /std:c11 program.c setjmp.obj
</code></pre></div></div>

<p>That generally works! If I rename to <code>xsetjmp</code> and <code>xlongjmp</code> to avoid
conflicting with the CRT definitions, drop them into the u-config test
suite in place of <code>setjmp.h</code>, then compile with MSVC, it passes all tests
using my alternate implementation in MSVC as well as GCC. Pretty cool!</p>

<h3 id="takeaway">Takeaway</h3>

<p>I’m not sure if I’ll ever use the assembly, but writing this article led
me to try the GCC intrinsics, and I’m so impressed I’m still thinking
about ways I can use them. My main thought is out-of-memory situations in
arena allocators, using a non-local exit to roll back to a savepoint, even
if just to return an error. This is nicer than either terminating the
program or handling OOM errors on every allocation. Very roughly:</p>

<div><div><pre><code><span>typedef</span> <span>struct</span> <span>{</span>
    <span>size_t</span> <span>cap</span><span>;</span>
    <span>size_t</span> <span>off</span><span>;</span>
    <span>void</span> <span>*</span><span>jmp_buf</span><span>[</span><span>5</span><span>];</span>
<span>}</span> <span>Arena</span><span>;</span>

<span>// Place an arena and savepoint an out-of-memory jump.</span>
<span>#define OOM(a, m, n) __builtin_setjmp((a = place(m, n))-&gt;jmp_buf)
</span>
<span>// Place a new arena at the front of the buffer.</span>
<span>Arena</span> <span>*</span><span>place</span><span>(</span><span>void</span> <span>*</span><span>mem</span><span>,</span> <span>size_t</span> <span>size</span><span>)</span>
<span>{</span>
    <span>assert</span><span>(</span><span>size</span> <span>&gt;=</span> <span>sizeof</span><span>(</span><span>Arena</span><span>));</span>
    <span>Arena</span> <span>*</span><span>a</span> <span>=</span> <span>mem</span><span>;</span>
    <span>a</span><span>-&gt;</span><span>cap</span> <span>=</span> <span>size</span><span>;</span>
    <span>a</span><span>-&gt;</span><span>off</span> <span>=</span> <span>sizeof</span><span>(</span><span>Arena</span><span>);</span>
    <span>return</span> <span>a</span><span>;</span>
<span>}</span>

<span>void</span> <span>*</span><span>alloc</span><span>(</span><span>Arena</span> <span>*</span><span>a</span><span>,</span> <span>size_t</span> <span>size</span><span>)</span>
<span>{</span>
    <span>size_t</span> <span>avail</span> <span>=</span> <span>a</span><span>-&gt;</span><span>cap</span> <span>-</span> <span>a</span><span>-&gt;</span><span>off</span><span>;</span>
    <span>if</span> <span>(</span><span>avail</span> <span>&lt;</span> <span>size</span><span>)</span> <span>{</span>
        <span>__builtin_longjmp</span><span>(</span><span>a</span><span>-&gt;</span><span>jmp_buf</span><span>,</span> <span>1</span><span>);</span>
    <span>}</span>
    <span>void</span> <span>*</span><span>p</span> <span>=</span> <span>(</span><span>char</span> <span>*</span><span>)</span><span>a</span> <span>+</span> <span>a</span><span>-&gt;</span><span>off</span><span>;</span>
    <span>a</span><span>-&gt;</span><span>off</span> <span>+=</span> <span>size</span><span>;</span>
    <span>return</span> <span>p</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Usage would look like:</p>

<div><div><pre><code><span>int</span> <span>compute</span><span>(</span><span>void</span> <span>*</span><span>workmem</span><span>,</span> <span>size_t</span> <span>memsize</span><span>)</span>
<span>{</span>
    <span>Arena</span> <span>*</span><span>arena</span><span>;</span>
    <span>if</span> <span>(</span><span>OOM</span><span>(</span><span>arena</span><span>,</span> <span>workmem</span><span>,</span> <span>memsize</span><span>))</span> <span>{</span>
        <span>// jumps here when out of memory</span>
        <span>return</span> <span>COMPUTE_OOM</span><span>;</span>
    <span>}</span>

    <span>Thing</span> <span>*</span><span>t</span> <span>=</span> <span>PUSHSTRUCT</span><span>(</span><span>arena</span><span>,</span> <span>Thing</span><span>);</span>
    <span>// ...</span>

    <span>return</span> <span>COMPUTE_OK</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>More granular snapshots can be made further down the stack by allocating
subarenas out of the main arena. I have yet to try this out in a practical
program.</p>



  <ul>
    
    <li><a href="https://www.blog.jamesgisele.com/tags/c/">c</a></li>
    
  </ul>
  <ol></ol>

  <div>
    <p>Have a comment on this article? Start a discussion in my
    <a href="https://lists.sr.ht/~skeeto/public-inbox">public inbox</a>
    by sending an email to
    <a href="mailto:~skeeto/public-inbox@lists.sr.ht?Subject=Re%3A%20Let&#39;s%20write%20a%20setjmp">
        ~skeeto/public-inbox@lists.sr.ht
    </a>
    <span>
    [<a href="https://man.sr.ht/lists.sr.ht/etiquette.md">mailing list etiquette</a>]
    </span>,
    or see
    <a href="https://lists.sr.ht/~skeeto/public-inbox?search=Let%27s+write+a+setjmp">existing discussions</a>.
    </p>

    
    
    
  </div>

  <nav>
  
    <div>
      <p><span>«</span>
      <a href="https://www.blog.jamesgisele.com/blog/2023/02/11/">
        My review of the C standard library in practice
      </a>
    </p></div>
  
  
  </nav>
</article>

</div></div>
  </body>
</html>
