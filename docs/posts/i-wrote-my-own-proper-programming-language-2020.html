<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mukulrathi.com/create-your-own-programming-language/intro-to-compiler/">Original</a>
    <h1>I wrote my own “proper” programming language (2020)</h1>
    
    <div id="readability-page-1" class="page"><article><h3>Creating the Bolt Compiler: Part 1</h3><p><h3>May 10, 2020</h3><h3>7 min read</h3></p><div data-gatsby-image-wrapper=""><p><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#39;521&#39; width=&#39;630&#39; xmlns=&#39;http://www.w3.org/2000/svg&#39; version=&#39;1.1&#39;%3E%3C/svg%3E"/></p><picture><source type="image/webp" srcset="/static/67552b3afe850eb6515a639276f98f47/fd7d2/compiler-pipeline.webp 158w,
/static/67552b3afe850eb6515a639276f98f47/ead41/compiler-pipeline.webp 315w,
/static/67552b3afe850eb6515a639276f98f47/00ea0/compiler-pipeline.webp 630w,
/static/67552b3afe850eb6515a639276f98f47/488bb/compiler-pipeline.webp 1260w" sizes="(min-width: 630px) 630px, 100vw"/><img width="630" height="521" data-main-image="" sizes="(min-width: 630px) 630px, 100vw" decoding="async" src="https://mukulrathi.com/static/67552b3afe850eb6515a639276f98f47/40dc4/compiler-pipeline.png" srcset="/static/67552b3afe850eb6515a639276f98f47/21412/compiler-pipeline.png 158w,
/static/67552b3afe850eb6515a639276f98f47/9e413/compiler-pipeline.png 315w,
/static/67552b3afe850eb6515a639276f98f47/40dc4/compiler-pipeline.png 630w,
/static/67552b3afe850eb6515a639276f98f47/150d8/compiler-pipeline.png 1260w" alt=""/></picture></div><nav><h2>Series: Creating the Bolt Compiler</h2><ul><li><strong>Part 1: How I wrote my own &#34;proper&#34; programming language</strong></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul></nav><hr/><p>The diagram above is the compiler for the language Bolt we’ll be building. What do all the stages mean? I have to learn OCaml and C++? Wait I haven’t even heard of OCaml…</p><p><strong>Don’t worry.</strong> When I started this project 6 months ago, I had never built a compiler, nor had I used OCaml or C++ in any serious project. I’ll explain everything in due course.</p><p>In this series of posts we’ll be building a <em>proper</em> programming language. One of the gripes I had when seeing programming language tutorials that created a toy language with only operations like addition and multiplication, was: okay, <em>but what about a real language like Java</em>?</p><p>So that’s what this series aims to fix. The language Bolt I wrote as part of my third year disseration is a Java-style concurrent object-oriented language. Some of the highlights of this series:</p><ul><li>We implement <strong>objects</strong> and classes, with inheritance and method overriding</li><li><strong>Concurrency</strong> (as far as I could tell when writing this, no other programming language tutorial covered this)</li><li><strong>Generics</strong>: being able to write a class of type <code>LinkedList&lt;T&gt;</code> and then instantiating it with <code>LinkedList&lt;int&gt;</code>, <code>LinkedList&lt;Person&gt;</code> and so on.</li><li>An introduction to how types are checked in a compiler</li><li>Compiling to LLVM (this post was #2 on Hacker News!) - LLVM is used by C, C++, Swift, Rust amongst many other languages.</li></ul><p>So I’d encourage you to follow the links in the “Series” overview to learn about these specific features. The remainder of this post will be to convince you why writing your own programming language is worthwhile, and the next post will outline the structure of a compiler.</p><h2 id="why-should-you-write-your-own-programming-language"><a href="#why-should-you-write-your-own-programming-language" aria-label="why should you write your own programming language permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Why should you write your own programming language?</h2><p>The question we should really be asking is <em>why design your own language</em>? Possible answers:</p><ol><li>It’s fun</li><li>It’s cool to have your own programming language</li><li>It’s a good side-project</li></ol><h2 id="mental-models"><a href="#mental-models" aria-label="mental models permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mental Models</h2><p>Whilst all three of these (or none!) might be true, there’s a bigger motivation: having the right <strong>mental models</strong>. See, when you learn your first programming language, you view programming through the lens of that language. Fast forward to your second language, and it seems hard, you have to relearn syntax and this new language does things differently. Using more programming languages, you realise that the languages share common themes. Java and Python have objects, Python and JavaScript don’t require you to write types, the list goes on. Diving further into programming language theory, you read about the language constructs present - Java and Python are <em>object-oriented</em> programming languages and Python and JavaScript are <em>dynamically-typed</em>.</p><p>The programming languages you’ve been using actually build upon the ideas present in older languages that you may not have have heard of. Simula and Smalltalk introduced the concept of object-oriented programming languages. Lisp introduced the concept of dynamic typing. And there are newer research languages coming all the time that introduce new concepts. A more mainstream example: Rust builds <strong>memory-safety</strong> into a low-level systems programming language.</p><p>Building your own language (especially if you’re adding new ideas) helps you think more <strong>critically</strong> about language design, so when you go learn a new language it’s much easier. For example, I had never programmed in Hack before my internship at Facebook last summer, but knowing these programming language concepts made it much easier to pick up.</p><h2 id="what-are-compilers"><a href="#what-are-compilers" aria-label="what are compilers permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What are compilers?</h2><p>So you’ve designed your fancy new language and it is going to revolutionise the world, but there’s one problem. <strong>How do you run it?</strong> That’s the role of a compiler. To explain how compilers work, let’s first flash our minds back to the 19th Century, in the age of the telegraph. Here we have this fancy new telegraph but how do we send messages? <strong>Same problem, different domain.</strong> The telegraph operator needs to take in speech and convert it to Morse code, and tap out the code. The first thing the operator does is make sense of the speech - they split it into words (<strong>lexing</strong>) , and then understand how those words are used in a sentence (<strong>parsing</strong>) - are they part of a noun phrase, a subordinate clause etc. They check if it makes sense by classifying words into categories or <strong>types</strong> (adjective, noun, verb) and check the sentence makes grammatical sense (we can’t use “runs” to describe a noun as it is a verb not a noun). Finally, they translate (<strong>compile</strong>) each word into dots and dashs (Morse code), which is then transmitted along the wire.</p><p>This seems like it labours the point, because so much of this is <em>automatic</em> for humans. Compilers work the same way, except we have to explicitly program computers to do this. The example above describes a simple compiler consisting of 4 stages: lex, parse, type-check and then translate into machine instructions. The operator also needs some additional tools to actually tap out the Morse code; for programming languages, this is the <strong>runtime environment</strong>.</p><p>In practice, the operator likely constructs some shorthand notation that they know how to translate to Morse code. Now rather than converting speech into Morse code directly, they convert the speech into their shorthand, and then convert the shorthand into Morse code. In many practical languages, you can’t just go directly from the source code to the machine code, you have <em>desugaring</em> or <em>lowering</em> stages, where you remove language constructs stage-by-stage (e.g. unrolling for loops) until we’re left with a small set of instructions that can be executed. Desugaring makes later stages much easier, as they operate on a simpler representation. The compiler stages are grouped into frontend, middle-end and backend, where frontend does much of the parsing/type-checking, and middle-end and backend simplify and optimise the code.</p><h3 id="compiler-design-choices"><a href="#compiler-design-choices" aria-label="compiler design choices permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Compiler Design Choices</h3><p>We can actually frame a lot of language and compiler design in terms of the analogy above:</p><p>Does the operator translate words on-the-fly into Morse code as they transmit them, or do they convert the words into Morse code beforehand, and then transmit the Morse code? <strong>Interpreted</strong> languages like Python do the former, whilst ahead-of-time <strong>compiled</strong> languages like C (and Bolt) do the latter. Java actually lies somewhere in between - it uses a <strong>just-in-time</strong> compiler which does most of the work beforehand, translating programs to bytecode and then at runtime compiles bytecode to machine code.</p><p>Now consider a scenario where a new Lorse code came out that was an alternative to Morse code. If the operators are taught how to convert the shorthand to Lorse code, the person speaking doesn’t need to know how that’s done, they get it for free. Likewise, a person speaking a different language just needs to tell the operator how to translate it to the shorthand, and then they get translations into Lorse <em>and</em> Morse code! This is how <strong>LLVM</strong> works. <strong>LLVM IR</strong> (intermediate representation) acts as the stepping stone that lies between the program and the machine code. C, C++, Rust and a whole host of other languages (including Bolt) target LLVM IR, which then compiles code to a variety of machine architectures.</p><p><span>
      <a href="https://mukulrathi.com/static/cf22553f4c173ee4b0dec6bd67e38110/c658e/llvm.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="LLVM Compiler" title="LLVM Compiler" src="https://mukulrathi.com/static/cf22553f4c173ee4b0dec6bd67e38110/a6d36/llvm.png" srcset="/static/cf22553f4c173ee4b0dec6bd67e38110/222b7/llvm.png 163w,/static/cf22553f4c173ee4b0dec6bd67e38110/ff46a/llvm.png 325w,/static/cf22553f4c173ee4b0dec6bd67e38110/a6d36/llvm.png 650w,/static/cf22553f4c173ee4b0dec6bd67e38110/e548f/llvm.png 975w,/static/cf22553f4c173ee4b0dec6bd67e38110/3c492/llvm.png 1300w,/static/cf22553f4c173ee4b0dec6bd67e38110/c658e/llvm.png 2202w" sizes="(max-width: 650px) 100vw, 650px" loading="lazy" decoding="async"/>
  </a>
    </span></p><p>Static vs dynamic typing? In the first case, the operator either checks that the words make grammatical sense before they start tapping. Or, they don’t and then midway through they’re like “huh, this doesn’t make sense” and stop. Dynamic typing can be seen as quicker to experiment in (like Python, JS) but when you send that message you don’t know if the operator will stop midway through (crash).</p><p>I’ve explained it in terms of an imaginary telegraph operator, but any analogy works. Building up this intuition goes a long way in understanding which language features are right for your language: if you’re going to be experimenting, then maybe dynamic typing is better as you can move faster. If you’re using a larger codebase, it’s harder to proof-read it all and you’re more likely to make errors so you probably should shift towards static typing to avoid breaking things.</p><h3 id="types"><a href="#types" aria-label="types permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Types</h3><p>The most interesting part of the compiler (in my opinion) is the type-checker. In our analogy, the operator classified words as parts-of-speech (adjectives, nouns, verbs) then checked if they were used correctly. Types work the same way, we classify program values based on the behaviour we’d like them to have. E.g. <code>int</code> for numbers that can be multiplied together, <code>String</code> for streams of characters that can be concatenated together. The role of the type-checker is to prevent undesirable behaviour from happening - like concatenating <code>int</code>s or multiplying <code>String</code>s together - these operations make no sense so shouldn’t be allowed. With type <em>checking</em>, the programmer annotates values with types, and the compiler checks if they’re correct. With type <em>inference</em>, the compiler both infers and checks the types. We call the rules that check the types <em>typing judgements</em>, and a collection of these (along with the types themselves) forms a type system.</p><p>It turns out actually that there’s a lot more you can do: type systems don’t just check if <code>int</code>s or <code>String</code>s are used correctly. Richer type systems can prove stronger invariants about programs: that they will terminate, access memory safely, or that they do not contain data races. Rust’s type system for example guarantees memory safety and data-race freedom, as well as checking traditional types <code>int</code>s and <code>String</code>s.</p><h2 id="where-does-bolt-fit-in"><a href="#where-does-bolt-fit-in" aria-label="where does bolt fit in permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Where does Bolt fit in?</h2><p>Programming languages still haven’t cracked the problem of writing safe concurrent code. Bolt, like Rust, prevents data races (<a href="https://doc.rust-lang.org/nightly/nomicon/races.html">explained in this Rust doc</a>), but takes a more fine-grained approach to concurrency. Before keyboard warriors come at me on Twitter, I think Rust has done a brilliant job in getting the conversation about this going - whilst Bolt will likely never go mainstream, it’s demonstrating another approach.</p><p>If we look back at the pipeline now, you can see that Bolt contains the lexing, parsing, and desugaring/lowering phases. It also contains a couple of Protobuf serialisation and deserialisation phases: these are purely to convert between OCaml and C++. It targets LLVM IR, and then we link in a couple of runtime libraries (pthreads and libc) and finally we output our <em>object file</em>, a binary containing the machine code.</p><p><span>
      <a href="https://mukulrathi.com/static/67552b3afe850eb6515a639276f98f47/7792f/compiler-pipeline.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="Bolt compiler pipeline" title="Bolt compiler pipeline" src="https://mukulrathi.com/static/67552b3afe850eb6515a639276f98f47/a6d36/compiler-pipeline.png" srcset="/static/67552b3afe850eb6515a639276f98f47/222b7/compiler-pipeline.png 163w,/static/67552b3afe850eb6515a639276f98f47/ff46a/compiler-pipeline.png 325w,/static/67552b3afe850eb6515a639276f98f47/a6d36/compiler-pipeline.png 650w,/static/67552b3afe850eb6515a639276f98f47/e548f/compiler-pipeline.png 975w,/static/67552b3afe850eb6515a639276f98f47/3c492/compiler-pipeline.png 1300w,/static/67552b3afe850eb6515a639276f98f47/7792f/compiler-pipeline.png 1761w" sizes="(max-width: 650px) 100vw, 650px" loading="lazy" decoding="async"/>
  </a>
    </span></p><p>Unlike most compilers though, Bolt has not one but <strong>two</strong> type-checking phases! Bolt has both traditional types and <strong>capabilities</strong>, which are, informally, another set of types to type-check data races. I’ve <a href="https://github.com/mukul-rathi/bolt-dissertation">written up a dissertation</a> that explores this more formally, if you are interested in the theory, if not you can skip the data-race checking posts in this series. We type-check the traditional types first, simplify the language a bit in the desugaring stage, then do the data-race type-checking.</p><h2 id="and-what-about-this-series"><a href="#and-what-about-this-series" aria-label="and what about this series permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>And what about this series?</h2><p>This series can be thought of from two perspectives: firstly, we will be discussing language design and comparing Bolt with Java, C++ and other languages along the way. Secondly, it is a practical step-by-step tutorial on building your own compiler. Unlike many build-your-own-compiler tutorials that tell you how to build a <em>toy</em> language, some of the topics this tutorial looks at form the basis of concurrent object-oriented languages like Java: how classes are implemented, how inheritance works, generic classes, and even how concurrency is implemented under the hood.</p><p>Bolt also doesn’t output toy instructions but instead targets <strong>LLVM IR</strong>. Practically speaking, this means Bolt hooks into the amazing optimisations present in C/C++ compilers. The LLVM API is powerful, but it’s also very hard to navigate the documentation. I spent many long nights reverse-engineering C++ programs - hopefully this series prevents at least one person from going through that pain!</p><p>In the next part, we’ll look at the practical aspects of setting up a compiler project - I’ll walk through the <a href="https://github.com/mukul-rathi/bolt">Bolt repository</a> and explain <em>why</em> we’re using OCaml of all languages for the frontend.</p></article></div>
  </body>
</html>
