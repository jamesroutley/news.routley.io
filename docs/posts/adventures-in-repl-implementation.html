<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tonsky.me/blog/clojure-sublimed-3/">Original</a>
    <h1>Adventures in REPL implementation</h1>
    
    
        
        
        
        
        
        <p>It’s a strange thing to announce, but I wrote <a href="https://github.com/tonsky/Clojure-Sublimed">Clojure plugin for Sublime Text</a>. <a href="https://tonsky.me/blog/sublime-clojure/">Again</a>.</p>

<p>I mean, the previous version worked fine, but it had a few flaws:</p>

<ul>
  <li>REPL depended on syntax highlighting (yikes!),</li>
  <li>the whole implementation was in a single file,</li>
  <li>it was hard to add REPLs.</li>
</ul>

<p>So, let’s do it again, almost from scratch, and right this time!</p>

<h1 id="what-is-repl">What is REPL?</h1>

<p>In a nutshell, REPL consists of three parts: client, server, and communication protocol between them.</p>

<p>Here’s an architectural diagram for you:</p>

<figure><img src="https://tonsky.me/blog/clojure-sublimed-3/architecture.webp" /></figure>

<h1 id="repl-client">REPL Client</h1>

<p>As you can see from the diagram, REPL clients live in a variety of environments dictated by their host: Java for Idea, Python for Sublime Text, JS for VS Code, etc. In my case, it was Sublime Text, so the environment I was stuck with happened to be Python 3.8.</p>

<p>Of course, writing client-server apps is not hard in any language. Unfortunately for us, REPL client needs to be able to read, speak and actually understand Clojure for a few features:</p>

<h2 id="problem-1-automatic-namespace-switching">Problem 1: Automatic namespace switching</h2>

<p>When you go to a file and eval something there, you want it to be run in the context of that file’s namespace. But how to figure out which namespace it is, without parsing Clojure source file?</p>

<p>The level of understanding is non-trivial: there could be multiple namespace declarations, not necessarily at the top of the file:</p>

<figure><img src="https://tonsky.me/blog/clojure-sublimed-3/ns_switching.webp" /></figure>

<p>The declaration itself could be complex, too, containing comments and/or meta tokens before the actual name:</p>

<figure><img src="https://tonsky.me/blog/clojure-sublimed-3/complex_ns.webp" /></figure>

<h2 id="problem-2-form-boundaries">Problem 2: Form boundaries</h2>

<p>I want a shortcut that evals “the topmost form” around my cursor. To do so, I need to know where those boundaries are.</p>

<p>Notice how I don’t explicitly “select” what I want to evaluate. Instead, REPL client finds form boundary for me:</p>

<figure><video autoplay="" muted="" loop="" preload="auto" playsinline="" controls=""><source src="https://tonsky.me/blog/clojure-sublimed-3/form_boundaries.mp4" type="video/mp4" /></video></figure>

<p>This is tricky, too. For the very least, you can count parens, but even then you’d have to be aware of strings.</p>

<p>To make things harder, Clojure also has reader tags <code class="language-plaintext highlighter-rouge">#inst "2023-02-24"</code>, metadata <code class="language-plaintext highlighter-rouge">^bytes b</code> and different weird symbols like <code class="language-plaintext highlighter-rouge">@</code> or <code class="language-plaintext highlighter-rouge">#'</code> that are not wrapped in parens but are still considered to be part of the form.</p>

<p>Bonus points for treating technically second-level forms inside <code class="language-plaintext highlighter-rouge">(comment)</code> as top-level.</p>

<p>All of this requires a really deep understanding of Clojure syntax.</p>

<h2 id="problem-3-indentation-and-pretty-printing">Problem 3: Indentation and pretty-printing</h2>

<p>Clojure Sublimed originally started when I wasn’t happy with what happened when I press “Enter” in Clojure file. Cursor would go to the wrong place, and I (subjectively) was spending too much time correcting it, so I decided to fix that once and for all.</p>

<figure><video autoplay="" muted="" loop="" preload="auto" playsinline="" controls=""><source src="https://tonsky.me/blog/clojure-sublimed-3/indent.mp4" type="video/mp4" /></video></figure>

<p>Indentation is not really a REPL concern, but it’s another part of Clojure Sublimed that requires a model of Clojure code.</p>

<p>Indentation logic re-applied to the whole file is formatting, so I got this one for free (both follow <a href="https://tonsky.me/blog/clojurefmt/">Better Clojure formatting</a> rules).</p>

<figure><video autoplay="" muted="" loop="" preload="auto" playsinline="" controls=""><source src="https://tonsky.me/blog/clojure-sublimed-3/format.mp4" type="video/mp4" /></video></figure>

<p>Finally, there’s a question of pretty printing, which is basically indentation + deciding where to put line breaks. Normally this would be done on Clojure side, but doing it on a client has clear advantages:</p>

<ul>
  <li>you have to send less data when transferring evaluation results (no need to send spaces at the beginning of the line),</li>
  <li>it works for every Clojure REPL the same,</li>
  <li>it can adjust for your current editor configuration instead of some arbitrary server-side number like 80 characters.</li>
</ul>

<figure>
    <img src="https://tonsky.me/blog/clojure-sublimed-3/pretty_print.webp" />
    Wrapping on current window width
</figure>

<p>Another upside is that I can adjust pretty-printing rules to my liking, of course.</p>

<h1 id="clojure-parser-in-python">Clojure parser in Python</h1>

<p>So, client lives inside your code editor and needs to understand Clojure <em>before</em> it starts communicating with it. Meaning, without Clojure runtime. Meaning, we had to parse Clojure in Python!</p>

<p>This is where things get hard because support for libraries, especially native ones, is not great in Sublime Text. Meaning, pure Python implementation!</p>

<p>I was put off by that task for a long time because it felt enormous. In the first Clojure Sublimed version, I deduced this information from syntax highlighting (Sublime Text already parses your source code for highlighting, and you can kind of access the results of that). But this time I wanted to make things right.</p>

<p>And, in fact, it turned out not to be all that bad! Clojure, like any Lisp, <em>is</em> relatively easy to parse. This is the entire grammar:</p>

<figure><img src="https://tonsky.me/blog/clojure-sublimed-3/grammar.webp" /></figure>

<p>Full source at <a href="https://github.com/tonsky/Clojure-Sublimed/blob/master/cs_parser.py">GitHub</a>.</p>

<p>Some notable details below.</p>

<h2 id="parser-cutting-corners">Parser: Cutting Corners</h2>

<p>I cut some corners to write less code and get max performance by e.g. not distinguishing between numbers, keywords, symbols — they are all just tokens. It’s probably not hard to add them, but I don’t really need them for what I do, so they are not there.</p>

<h2 id="parser-performance">Parser: Performance</h2>

<p>I haven’t spent any serious time trying to optimize the parser. In its current state, it can go through clojure.core (enormous 8000 loc file) in 170ms on my M1 Mac.</p>

<p>Clojure itself does the same in roughly 30-50 ms, though, so there’s definitely potential for improvement.</p>

<h2 id="parser-incrementality">Parser: Incrementality</h2>

<p>Should be possible one day :) So far performance is good enough to re-parse on each “enter” keypress.</p>

<h2 id="parser-testing">Parser: Testing</h2>

<p>Parse trees could be quite hard to navigate, and twice as hard to compare.</p>

<p>Parsing also requires <em>a lot</em> of tests to get everything right and to avoid regressions. So having a nice and ergonomic way to write and inspect tests was super important.</p>

<p>I ended up copying test syntax from tree-sitter.</p>

<figure><img src="https://tonsky.me/blog/clojure-sublimed-3/test.webp" /></figure>

<p>Test runner just compares the actual result with the expected one string-wise and if they are different, reports an error in a nice to comprehend table:</p>

<figure><img src="https://tonsky.me/blog/clojure-sublimed-3/failed_test.webp" /></figure>

<p>Having this early on saved me a ton of time and I am 100% happy I made that investment.</p>

<h2 id="parser-error-recovery">Parser: Error recovery</h2>

<p>Parsing valid Clojure code is quite easy. But code in the process of editing is not always correct, even syntactically. That means that our parser has to work around errors somehow!</p>

<p>So I decided to see how people smarter than me do it and found this:</p>

<blockquote>
  <p>In the yacc and bison parser generators, the parser has an ad hoc mechanism to abandon the current statement, discard some parsed phrases and lookahead tokens surrounding the error, and resynchronize the parse at some reliable statement-level delimiter like semicolons or braces.</p>
</blockquote>

<p>So yeah, I guess no beautiful theory on error recovery.</p>

<p>For our purposes, though, it was quite simple: see something that you don’t understand? That must be an error. Most stuff gets consumed as a symbol or a number, though, so these were rare.</p>

<p>We did accept some invalid programs as valid, but that’s okay for our use case: find expression boundaries, throw it over the fence, and let Clojure work out the rest of the details.</p>

<h2 id="parser-accidentally-quadratic">Parser: Accidentally quadratic</h2>

<p>One funny thing happened during testing: I noticed that sometimes the parser was becoming ultra-slow on moderately-sized files. Like, seconds instead of milliseconds. That means I had quadratic behavior somewhere.</p>

<figure><img src="https://tonsky.me/blog/clojure-sublimed-3/algorithm.webp" style="max-width: 540px" /></figure>

<p>And that was indeed the case. The first version of the parser, roughly, was parsing parens/brackets/braces like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Seq(Char("["),
    Repeat(Choice('_gap', '_form')),
    Char("]"))
</code></pre></div></div>

<p>This basically means: if you see an opening bracket, consume forms and whitespace inside as long as you can, and in the end, there must be a closing bracket.</p>

<p>Well, what if it’s not there? That means it wasn’t a <code class="language-plaintext highlighter-rouge">'brackets'</code> form in the first place! This is technically correct, but also means we have to mark the opening bracket as an error and then <em>re-parse everything inside it again</em>. That’s your quadratic behavior right here!</p>

<p>A simple change got rid of this problem:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Seq(Char("["),
    Repeat(Choice('_gap', '_form')),
    Optional(Char("]")))
</code></pre></div></div>

<p>Technically, this accepts incorrect programs. In practice, though, it works exactly as we need for indentation: we only care about opening parens up to the point of the cursor and don’t really care what happens after it.</p>

<h2 id="parser-conclusion">Parser: Conclusion</h2>

<p>Writing the parser was very fun! So many little details to figure out and get right, but in the end, when everything snaps into place, it’s so satisfying!</p>

<p>I also now understand why Lisps were so popular back in the day: they are really made for ease of implementation. Hacking together an entire parser from scratch in a weekend — can you imagine it for something like C++ or Python?</p>

<p>Anyways, if you need Clojure parser in Python, take a peek at <a href="https://github.com/tonsky/Clojure-Sublimed/blob/master/cs_parser.py">my implementation</a> — maybe it’ll help you out!</p>

<h1 id="protocol">Protocol</h1>

<p>Let’s move to the second part of our architecture: the communication channel.</p>

<p>How does a server talk to a client? Die-hard Clojure fans would answer immediately: EDN! But it’s not that simple.</p>

<p>Yes, EDN is the simplest thing for Clojure users. But what about the rest of the world? Don’t forget that on the other side there’s an arbitrary platform and, despite Rich’s best efforts, EDN is not as widespread as we’d like.</p>

<h2 id="just-send-forms">Just send… forms?</h2>

<p>This is what <code class="language-plaintext highlighter-rouge">clojure.core.server/repl</code> does. Basically, it’s the same interactive experience as with command-line REPL, but over a socket:</p>

<figure><video autoplay="" muted="" loop="" preload="auto" playsinline="" controls=""><source src="https://tonsky.me/blog/clojure-sublimed-3/socket_repl.mp4" type="video/mp4" /></video></figure>

<p>Not machine-friendly at all.</p>

<h2 id="half-edn">Half-EDN</h2>

<p>Type in forms, receive EDN-formatted output. <code class="language-plaintext highlighter-rouge">clojure.core.server/io-prepl</code> does that:</p>

<figure><img src="https://tonsky.me/blog/clojure-sublimed-3/prepl.webp" /></figure>

<p>Half machine-friendly and you have to be able to parse EDN.</p>

<h2 id="json--edn">JSON + EDN</h2>

<p>Following the half-EDN example, our protocol doesn’t have to be symmetric, either. If we make ease of implementation our first priority, we can go crazy:</p>

<ul>
  <li>Client sends EDN, which is easy to parse in Clojure,</li>
  <li>Server sends JSON, which could be parsed with Python stdlib.</li>
</ul>

<p>Not elegant, but, you know, gets the job done. In both cases, messages are simple enough to be composed with string concatenation, so we only really care about parsing.</p>

<p>The only problem I have with this solution is that it offends my sense of beauty.</p>

<h2 id="bencode">Bencode</h2>

<p>nREPL also had this problem: a common denominator for multiple clients in all possible languages. Their answer? Bencode.</p>

<p>Bencode is a simple binary encoding developed for BitTorrent. And when I say simple, I mean <em>very</em> simple. Yes, simpler than JSON.</p>

<p>This is the entire Bencode grammar:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>number = '0' / '-'? [1-9][0-9]*
int    = 'i' number 'e'
list   = 'l' value* 'e'
dict   = 'd' (value value)* 'e'
string = length ':' bytes
length = '0' / [1-9][0-9]*
value  = int / list / dict / string
</code></pre></div></div>

<p>And here are some actual messages when communicating with nREPL server:</p>

<figure><img src="https://tonsky.me/blog/clojure-sublimed-3/nrepl.webp" /></figure>

<p>Bencode is not supported out of the box by either Python or Clojure, but implementation easily fits in 200 LoC.</p>

<p>Problem? It’s binary. Unfortunately, you can’t run binary protocols on top of Socket Server, only the text ones. So to be able to use bencode you’ll have to start your own server.</p>

<p>Clojure Sublimed uses bencode for connecting to nREPL servers.</p>

<h2 id="messagepack">MessagePack</h2>

<p>MessagePack is beautiful, exactly as I would’ve designed a compact binary serialization format. Everything is length-prefixed, super-simple to implement and you can support only parts that you actually use.</p>

<p>But it’s binary, so can’t be used on top of Socket Server, and I’m not prepared to write my own REPL server yet.</p>

<p>Consider voting for <a href="https://clojure.atlassian.net/browse/CLJ-2752">this issue</a> and the situation might change! I believe Clojure deserves binary REPLs as much as text-based ones.</p>

<h2 id="edn-both-ways">EDN both ways</h2>

<p>A lucky coincidence saved me here. Remember the first part where I was writing Clojure parser? Guess what? Since EDN is a subset of Clojure, my parser also can parse EDN well enough to understand REPL server responses!</p>

<p>This is what my upgraded Socket Server REPL looks like on the wire:</p>

<figure><img src="https://tonsky.me/blog/clojure-sublimed-3/socket_sublime.webp" /></figure>

<p>Yes, it looks like nREPL over EDN.</p>

<p>No, it’s not exactly nREPL, it’s subtly different (see the server breakdown below), so there can be more chaos.</p>

<p>Did I invent another wheel? Maybe. But it’s a good wheel and it suits my needs well.</p>

<h2 id="a-note-on-message-boundaries">A note on message boundaries</h2>

<p>The tricky part of EDN-on-the-wire? How to separate messages.</p>

<p>Clojure has a streaming parser: it consumes data from socket char-by-char and parses it as it goes until it reads a complete form. That’s why, for example, you can’t evaluate something like <code class="language-plaintext highlighter-rouge">(+ 1 2</code> in the REPL, no matter how many times you press Enter.</p>

<p>But my Python parser wasn’t streaming :( You give it a string, it’ll parse it. But it can’t tell you how much of that string to read from a socket. If only TCP was message-oriented — one can dream!</p>

<p>So the solution was… split on newlines :) Lucky for me, the default Clojure printer escapes newlines in strings, so it can’t occur inside the message.</p>

<p>EDN doesn’t exactly forbid newlines, though, so let’s hope they won’t suddenly start to appear one day.</p>

<h1 id="server">Server</h1>

<p>Finally, the third and final part of our architecture: the server. When I only started learning about Clojure and Lisps, I imagined that REPL is literally that:</p>

<figure><img src="https://tonsky.me/blog/clojure-sublimed-3/repl_naive.webp" /></figure>

<p>Because of that ignorance, it was hard for me to understand why there are different REPL implementations and why you need to “implement” REPL at all.</p>

<p>Let’s go from the simplest case to more complex ones.</p>

<h2 id="naive-repl">Naive REPL</h2>

<p>Funny enough, the function I showed you above works:</p>

<figure><video autoplay="" muted="" loop="" preload="auto" playsinline="" controls=""><source src="https://tonsky.me/blog/clojure-sublimed-3/repl_naive.mp4" type="video/mp4" /></video></figure>

<p>It’s very fragile, though: it’ll die on the first exception.</p>

<p>It also doesn’t do many things which you’ll see more sophisticated REPLs provide.</p>

<h2 id="clojuremainrepl">clojure.main/repl</h2>

<p>This is the REPL you get when you run <code class="language-plaintext highlighter-rouge">clj</code> or <code class="language-plaintext highlighter-rouge">clojure</code> command-line utility.</p>

<p>It works essentially the same, but does a little bit of extra work for you:</p>

<p>First and most notably, it prints a command prompt that displays the current namespace:</p>

<figure><img src="https://tonsky.me/blog/clojure-sublimed-3/repl_main_prompt.webp" /></figure>

<p>Which you can actually customize to your liking:</p>

<figure><img src="https://tonsky.me/blog/clojure-sublimed-3/repl_main_custom_prompt.webp" /></figure>

<p>Then, it catches and prints exceptions, so your REPL doesn’t die when you make a mistake:</p>

<figure><img src="https://tonsky.me/blog/clojure-sublimed-3/repl_main_exception.webp" /></figure>

<p>It also stores the last calculated values in special <code class="language-plaintext highlighter-rouge">*1</code>..<code class="language-plaintext highlighter-rouge">*3</code> dynamic vars and the last exception in <code class="language-plaintext highlighter-rouge">*e</code>. These variables do not exist outside of REPL:</p>

<figure><img src="https://tonsky.me/blog/clojure-sublimed-3/repl_main_dynamic.webp" /></figure>

<p>Another convenience that default REPL does is requiring some stuff from <code class="language-plaintext highlighter-rouge">clojure.repl</code> and <code class="language-plaintext highlighter-rouge">clojure.pprint</code>:</p>

<figure><img src="https://tonsky.me/blog/clojure-sublimed-3/repl_main_requires.webp" /></figure>

<p>Were you wondering where <code class="language-plaintext highlighter-rouge">(doc)</code> in REPL comes from? Now you know.</p>

<p>Finally, it isolates vars like <code class="language-plaintext highlighter-rouge">*ns*</code> or <code class="language-plaintext highlighter-rouge">*warn-on-reflection*</code> so that when you <code class="language-plaintext highlighter-rouge">set!</code> them in your REPL session it doesn’t alter their root bindings.</p>

<p>Quite a bit of nuance, huh? With all that, <code class="language-plaintext highlighter-rouge">clojure.main/repl</code> is still considered very basic. There’s more stuff you can do!</p>

<h2 id="clojurecoreserverrepl">clojure.core.server/repl</h2>

<p>Basically the same as <code class="language-plaintext highlighter-rouge">main/repl</code>, but for the access over the network.</p>

<p>The only difference is output. If your entire program IS the REPL, you don’t have to do anything special with it.</p>

<p>But if you are connecting dynamically to a working program, things get trickier. Where should <code class="language-plaintext highlighter-rouge">(println "Hello")</code> print?</p>

<p>If it prints to stdout of the process, you won’t see it in your REPL. It’ll go to wherever the server process redirects its standard output.</p>

<p>So what Server REPL does is it redefines <code class="language-plaintext highlighter-rouge">*in*</code>/<code class="language-plaintext highlighter-rouge">*out*</code>/<code class="language-plaintext highlighter-rouge">*err*</code> to socket streams instead of process’s stdout and sends to you what <em>you</em> print over the network. Everybody gets their own stdout!</p>

<figure><video autoplay="" muted="" loop="" preload="auto" playsinline="" controls=""><source src="https://tonsky.me/blog/clojure-sublimed-3/repl_server_stdout.mp4" type="video/mp4" /></video></figure>

<p>Really tricky stuff to figure out, but essential to understand if you consider yourself an advanced Clojure REPL user.</p>

<p>The rest is the same. Server REPL literally calls into <code class="language-plaintext highlighter-rouge">main/repl</code> after rebinding <code class="language-plaintext highlighter-rouge">*in*</code>/<code class="language-plaintext highlighter-rouge">*out*</code>/<code class="language-plaintext highlighter-rouge">*err*</code>.</p>

<h2 id="clojurecoreserverio-prepl">clojure.core.server/io-prepl</h2>

<p>pREPL is Clojure team’s answer to nREPL and critique that Clojure Socket REPL is not machine-friendly. It’s basically <code class="language-plaintext highlighter-rouge">server/repl</code> but with EDN-formatted output:</p>

<figure><img src="https://tonsky.me/blog/clojure-sublimed-3/prepl.webp" /></figure>

<p>pREPL consumes raw Clojure forms but outputs EDN-structured data.</p>

<p>In terms of what it does for you, it also formats exceptions (not in a Clojure-aware way, unfortunately) and synchronizes your output so that two threads can’t print simultaneously. But that’s about it.</p>

<p>The main problem with pREPL is that it’s based on EDN and, thus, aimed at Clojure clients first and foremost.</p>

<h2 id="nrepl">nREPL</h2>

<p>nREPL is a third-party server started by Chas Emerick and lately adopted by Bozhidar Batsov. It’s a separate library that you have to add to your project and start the server yourself.</p>

<p>As Rich Hickey put it, ”<a href="https://nextjournal.com/mk/rich-hickey-on-repls">nREPL is not a REPL, it’s remote evaluation API</a>”. He’s not wrong, but I think that’s exactly what tooling authors need: remote eval API, not interactive console.</p>

<p>First, nREPL is machine-friendly both ways. It receives bencode-d data and sends bencode-d data back.</p>

<p>Second, it walks an extra mile for you:</p>

<ul>
  <li>Its <code class="language-plaintext highlighter-rouge">eval</code> optionally accepts file name and position in that file, so that stack traces would contain the correct position.</li>
  <li>It limits the size of the output to a user-provided threshold, saving you from printing infinite sequences which are not rare in Clojure.</li>
  <li>It provides interruption for already executing evals.</li>
  <li>Some of its functions like <code class="language-plaintext highlighter-rouge">lookup</code> and <code class="language-plaintext highlighter-rouge">load-file</code> solve problems that their Clojure alternatives don’t.</li>
  <li>Some are just conveniences like <code class="language-plaintext highlighter-rouge">completions</code>.</li>
  <li>It’s extensible, allowing you to create your own operations.</li>
</ul>

<p>All this stuff is very useful and doesn’t come “naturally” with naive REPL implementations.</p>

<p>The downside? You need to add nREPL server dependency to your app. It also has a noticeable startup cost (~500ms on my machine).</p>

<h2 id="extended-nrepl">Extended nREPL</h2>

<p>Since nREPL is extensible, one can extend it to do even more. That’s what the first version of Clojure Sublimed did and still does. Including:</p>

<ul>
  <li>Formating stack traces in a Clojure-aware way and sending them back with errors:</li>
</ul>

<figure><img src="https://tonsky.me/blog/clojure-sublimed-3/cs_repl_stacktrace.webp" /></figure>

<ul>
  <li>Parallel evaluation and execution time:</li>
</ul>

<figure><video autoplay="" muted="" loop="" preload="auto" playsinline="" controls=""><source src="https://tonsky.me/blog/clojure-sublimed-3/cs_repl_parallel.mp4" type="video/mp4" /></video></figure>

<p>It worked well for me for 1.5 years, but still, you know, nREPL dependency, startup time, NIH syndrome. I wanted to give REPL a shot on my own.</p>

<h2 id="repl-upgraded">REPL, upgraded</h2>

<p>Even the simplest REPL still has the full power of Clojure in it! We can start with something very basic, like <code class="language-plaintext highlighter-rouge">server.repl</code>, send our own server’s code to it first thing after connecting, and then take control over stdin/stdout and start serving our own protocol with our own execution model.</p>

<p>This is called “upgrading” your REPL and that’s how Christophe Grand’s Unrepl works, for example. The beauty of it is zero dependencies: you only need Clojure and nothing more. Everything you need you bring with you.</p>

<p>In our case, it looks like this. First, we send a lot of Clojure code (unformatted, because machine doesn’t care):</p>

<figure><img src="https://tonsky.me/blog/clojure-sublimed-3/socket_snd.webp" /></figure>

<p>Then, we receive this:</p>

<figure><img src="https://tonsky.me/blog/clojure-sublimed-3/socket_rcv.webp" /></figure>

<p>Which basically means “Yes, I’ve heard you”.</p>

<p>This is all happening inside basic <code class="language-plaintext highlighter-rouge">server/repl</code>. It looks messy because it was designed for human consumption (eye-balling), and we don’t even try to interpret it. We just cross our fingers and hope everything we sent works.</p>

<p>At this point, we’re ready to “upgrade” our REPL. This is how we do it:</p>

<figure><img src="https://tonsky.me/blog/clojure-sublimed-3/socket_started.webp" /></figure>

<p><code class="language-plaintext highlighter-rouge">(repl)</code> is a function we defined in our initial payload. <code class="language-plaintext highlighter-rouge">{"tag" "started"}</code> is the first message of our own protocol. I really, really, really hope here that it will not be messed up by other output (printing in Socket Server is not synchronized, and everyone who worked with Clojure REPL in the terminal knows how often it messes up your output).</p>

<p>After the client sees <code class="language-plaintext highlighter-rouge">{"tag" "started"}</code> somewhere in the socket, it considers the upgrade to be finished and now works in our own nREPL-like EDN-based protocol.</p>

<h2 id="clojure-sublimed-repl-server">Clojure Sublimed REPL Server</h2>

<p>Our upgraded Clojure Sublimed REPL does all the same basic stuff that nREPL does. The only practical difference for clients is batch evaluation: send multiple forms together (e.g. when evaluating the whole buffer) and get separate results for each one.</p>

<p>nREPL eval-buffer:</p>

<figure><img src="https://tonsky.me/blog/clojure-sublimed-3/nrepl_batch_eval.webp" /></figure>

<p>Clojure Sublimed eval-buffer:</p>

<figure><img src="https://tonsky.me/blog/clojure-sublimed-3/cs_repl_batch_eval.webp" /></figure>

<p>Under the hood, though, it’s a completely new REPL. It sits on top of Socket Server, yes, but it has its own evaluation model and its own protocol. It’s clean, minimal, fast to load, and works much better with Clojure Sublimed client than nREPL.</p>

<p>I don’t want to release yet separately from Clojure Sublimed (yet?), but, you know, take a peek <a href="https://github.com/tonsky/Clojure-Sublimed/blob/master/src_clojure/clojure_sublimed/socket_repl.clj">at the implementation</a> anyway.</p>

<h2 id="your-own-repl">Your own REPL!</h2>

<p>The original version of Clojure Sublimed (client) was organized quite poorly and adding new REPLs was problematic.</p>

<p>New, refactored Clojure Sublimed was designed to be easy to extend. Out of the box, we ship with these now:</p>

<ul>
  <li>JVM nREPL which installs a few extra middlewares.</li>
  <li>(new) Raw nREPL for non-JVM environments (babashka, etc).</li>
  <li>Shadow-CLJS nREPL which (now) adapts better to shadow-cljs quirks.</li>
  <li>(new) JVM Socket REPL which works on top of bare-bone Clojure Socket Server.</li>
</ul>

<p>And there could be more! If you are interested, let me know, or, better, jump in with a PR! I promise it should be much easier now. I even wrote docstrings <strike>everywhere</strike> at some places :)</p>

<h1 id="conclusion">Conclusion</h1>

<p>So, Clojure Sublimed v3 is out there. To sum up the major differences:</p>

<ul>
  <li>REPL doesn’t depend on syntax highlighting,</li>
  <li>new JVM Socket REPL,</li>
  <li>easier to add new REPLs,</li>
  <li>client-side pretty-printer,</li>
  <li>faster indenter and formatter.</li>
</ul>

<p>As always, you can get the new version in <a href="https://packagecontrol.io/packages/Clojure%20Sublimed">Package Control</a> or on Github:</p>

<figure><a href="https://github.com/tonsky/Clojure-Sublimed"><img src="https://tonsky.me/blog/clojure-sublimed-3/banner.webp" /></a></figure>

<p>Let me know what you think! Issues are open :) And happy Clojur-ing!</p>

<h1 id="you-were-going-to-ask-anyway">You were going to ask anyway</h1>

<p>Color scheme: <a href="https://github.com/tonsky/sublime-color-schemes/">Niki Berkeley</a>.</p>

<p>The font on screenshots: <a href="https://berkeleygraphics.com/typefaces/berkeley-mono/">Berkeley Mono</a>.</p>

        
      
  </body>
</html>
