<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/IBM/import-tracker">Original</a>
    <h1>Python utility for tracking third party dependencies within a library</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto"><code>Import Tracker</code> is a Python package offering a number of capabilities related to tracking and managing optional dependencies in Python projects. Specifically, this project enables developers to:</p>
<ul dir="auto">
<li>
<p dir="auto">Track the dependencies of a python project to map each module within the project to the set of dependencies it relies on. This can be useful for debugging of dependencies in large projects.</p>
</li>
<li>
<p dir="auto">Enable lazy import errors in a python projects to prevent code from crashing when uninstalled imports are imported, but not utilized. This can be helpful in large projects, especially those which incorporate lots of hierarchical wild imports, as importing the top level package of such projects can often bring a lot of heavy dependencies into <code>sys.modules</code>.</p>
</li>
<li>
<p dir="auto">Programmatically determine the <a href="https://setuptools.pypa.io/en/latest/userguide/dependency_management.html#declaring-required-dependency" rel="nofollow"><code>install_requires</code></a> and <a href="https://setuptools.pypa.io/en/latest/userguide/dependency_management.html#optional-dependencies" rel="nofollow"><code>extras_require</code></a> arguments to <code>setuptools.setup</code> where the extras sets are determined by a set of modules that should be optional.</p>
</li>
</ul>
<h2 dir="auto"><a id="user-content-running-import-tracker" aria-hidden="true" href="#running-import-tracker"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Running Import Tracker</h2>
<p dir="auto">To run <code>import_tracker</code> against a project, simply invoke the module&#39;s main:</p>
<div data-snippet-clipboard-copy-content="python3 -m import_tracker --name &lt;my_module&gt;"><pre><code>python3 -m import_tracker --name &lt;my_module&gt;
</code></pre></div>
<p dir="auto">The main supports the following additional arguments:</p>
<ul dir="auto">
<li><code>--package</code>: Allows <code>--name</code> to be a relative import (see <a href="https://docs.python.org/3/library/importlib.html#importlib.import_module" rel="nofollow"><code>importlib.import_module</code></a>)</li>
<li><code>--recursive</code>: Recurse into sub-modules within the given module to produce the full mapping for the given module</li>
<li><code>--num_jobs</code>: When <code>--recurse</code> is given, run the recursive jobs concurrently with the given number of workers (0 implies serial execution)</li>
<li><code>--indent</code>: Indent the output json for pretty printing</li>
<li><code>--log_level</code>: Set the level of logging (up to <code>debug4</code>) to debug unexpected behavior</li>
<li><code>--submodules</code>: List of sub-modules to recurse on (only used when --recursive set)</li>
<li><code>--side_effect_modules</code>: Modules with known import-time side effect which should always be allowed to import</li>
<li><code>--track_import_stack</code>: Store the stack trace of imports belonging to the tracked module
<ul dir="auto">
<li><strong>NOTE</strong>: This is <em>very slow</em> and should be used only when performing specific debugging tasks!</li>
</ul>
</li>
</ul>
<h2 dir="auto"><a id="user-content-integrating-import_tracker-into-a-projects" aria-hidden="true" href="#integrating-import_tracker-into-a-projects"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Integrating <code>import_tracker</code> into a projects</h2>
<p dir="auto">When using <code>import_tracker</code> to implement optional dependencies in a project, there are two steps to take:</p>
<ol dir="auto">
<li>Enable <code>lazy_import_errors</code> for the set of modules that should be managed as optional</li>
<li>Use <code>setup_tools.parse_requirements</code> in <code>setup.py</code> to determine the <code>install_requires</code> and <code>extras_require</code> arguments</li>
</ol>
<p dir="auto">In the following examples, we&#39;ll use a fictitious project with the following structure:</p>
<div data-snippet-clipboard-copy-content="my_module/
├── __init__.py
├── utils.py
└── widgets
    ├── __init__.py
    ├── widget1.py
    └── widget2.py"><pre><code>my_module/
├── __init__.py
├── utils.py
└── widgets
    ├── __init__.py
    ├── widget1.py
    └── widget2.py
</code></pre></div>
<h3 dir="auto"><a id="user-content-enabling-lazy_import_errors" aria-hidden="true" href="#enabling-lazy_import_errors"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Enabling <code>lazy_import_errors</code></h3>
<p dir="auto">The <code>import_tracker.lazy_import_errors</code> function can be invoked directly to enable lazy import errors globally, or used as a context manager to enable them only for a selcted set of modules.</p>
<p dir="auto">To globally enable lazy import errors, <code>my_module/__init__.py</code> would look like the following:</p>
<div data-snippet-clipboard-copy-content="# Globally enable lazy import errors
from import_tracker import lazy_import_errors
lazy_import_errors()

from . import utils, widgets"><pre><span># Globally enable lazy import errors</span>
<span>from</span> <span>import_tracker</span> <span>import</span> <span>lazy_import_errors</span>
<span>lazy_import_errors</span>()

<span>from</span> . <span>import</span> <span>utils</span>, <span>widgets</span></pre></div>
<p dir="auto">Alternately, applying lazy import error semantics only to the <code>widgets</code> would look like the following:</p>
<div data-snippet-clipboard-copy-content="from import_tracker import lazy_import_errors

# Require all downstream imports from utils to exist
from . import utils

# Enable lazy import errors for widgets
with lazy_import_errors():
    from . import widgets"><pre><span>from</span> <span>import_tracker</span> <span>import</span> <span>lazy_import_errors</span>

<span># Require all downstream imports from utils to exist</span>
<span>from</span> . <span>import</span> <span>utils</span>

<span># Enable lazy import errors for widgets</span>
<span>with</span> <span>lazy_import_errors</span>():
    <span>from</span> . <span>import</span> <span>widgets</span></pre></div>
<p dir="auto">When using lazy import errors, there are two ways to customize the error message that is raised when a failed import is used:</p>
<ol dir="auto">
<li>
<ol dir="auto">
<li>The <code>get_extras_modules</code> argument takes a function which returns a <code>Set[str]</code> of the module names that are tracked as extras. If the import error is triggered within a module that is managed as an extras set, the error message is updated to include instructions on which extras set needs to be installed.</li>
</ol>
</li>
<li>
<p dir="auto">The <code>make_error_message</code> argument allows the caller to specify a fully custom error message generation function.</p>
</li>
</ol>
<h3 dir="auto"><a id="user-content-using-setup_toolsparse_requirements" aria-hidden="true" href="#using-setup_toolsparse_requirements"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Using <code>setup_tools.parse_requirements</code></h3>
<p dir="auto">To take advantage of the automatic dependency parsing when building a package, the <code>setup.py</code> would look like the following:</p>
<div data-snippet-clipboard-copy-content="import import_tracker
import os
import setuptools

# Determine the path to the requirements.txt for the project
requirements_file = os.path.join(os.path.dirname(__file__), &#34;requirements.txt&#34;)

# Parse the requirement sets
install_requires, extras_require = import_tracker.setup_tools.parse_requirements(
    requirements_file=requirements_file,
    library_name=&#34;my_module&#34;,
    extras_modules=[
        &#34;my_module.widgets.widget1&#34;,
        &#34;my_module.widgets.widget2&#34;,
    ],
)

# Perform the standard setup call
setuptools.setup(
    name=&#34;my_module&#34;,
    author=&#34;me&#34;,
    version=&#34;1.2.3&#34;,
    license=&#34;MIT&#34;,
    install_requires=install_requires,
    extras_require=extras_require,
    packages=setuptools.find_packages(),
)"><pre><span>import</span> <span>import_tracker</span>
<span>import</span> <span>os</span>
<span>import</span> <span>setuptools</span>

<span># Determine the path to the requirements.txt for the project</span>
<span>requirements_file</span> <span>=</span> <span>os</span>.<span>path</span>.<span>join</span>(<span>os</span>.<span>path</span>.<span>dirname</span>(<span>__file__</span>), <span>&#34;requirements.txt&#34;</span>)

<span># Parse the requirement sets</span>
<span>install_requires</span>, <span>extras_require</span> <span>=</span> <span>import_tracker</span>.<span>setup_tools</span>.<span>parse_requirements</span>(
    <span>requirements_file</span><span>=</span><span>requirements_file</span>,
    <span>library_name</span><span>=</span><span>&#34;my_module&#34;</span>,
    <span>extras_modules</span><span>=</span>[
        <span>&#34;my_module.widgets.widget1&#34;</span>,
        <span>&#34;my_module.widgets.widget2&#34;</span>,
    ],
)

<span># Perform the standard setup call</span>
<span>setuptools</span>.<span>setup</span>(
    <span>name</span><span>=</span><span>&#34;my_module&#34;</span>,
    <span>author</span><span>=</span><span>&#34;me&#34;</span>,
    <span>version</span><span>=</span><span>&#34;1.2.3&#34;</span>,
    <span>license</span><span>=</span><span>&#34;MIT&#34;</span>,
    <span>install_requires</span><span>=</span><span>install_requires</span>,
    <span>extras_require</span><span>=</span><span>extras_require</span>,
    <span>packages</span><span>=</span><span>setuptools</span>.<span>find_packages</span>(),
)</pre></div>
</article>
          </div></div>
  </body>
</html>
