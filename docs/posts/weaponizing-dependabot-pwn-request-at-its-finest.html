<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://boostsecurity.io/blog/weaponizing-dependabot-pwn-request-at-its-finest">Original</a>
    <h1>Weaponizing Dependabot: Pwn Request at its finest</h1>
    
    <div id="readability-page-1" class="page"><div>
  <div>
    
    
    
    

    
    <p><img src="https://boostsecurity.io/hubfs/Gemini_Generated_Image_ptis1yptis1yptis.jpeg" loading="eager" alt="Comic book style illustration of a confused Wild West deputy, GitHub&#39;s Dependabot, about to press an &#39;Auto-Merge&#39; lever on a machine releasing gremlin-like &#39;Vulnerabilities&#39;."/>
      </p>
    


    <p><span id="hs_cos_wrapper_post_body" data-hs-cos-general-type="meta_field" data-hs-cos-type="rich_text"><p><strong>TL;DR</strong>: Your trusty Dependabot (and other GitHub bots) might be an unwitting accomplice. Through &#34;Confused Deputy&#34; attacks, they can be tricked into merging malicious code. This doesn’t stop here. It can escalate to full command injection via crafted branch names and even bypass branch protection rules. Plus, we disclose two new TTPs to build upon previously known techniques.<span></span><!--more--></p>
<h2>Introduction</h2>
<p>Ah, <span><a href="https://docs.github.com/en/code-security/dependabot/dependabot-security-updates/configuring-dependabot-security-updates" rel="noopener" target="_blank">Dependabot</a>!</span> GitHub&#39;s built-in butler, tirelessly checks if your dependencies are fresh and, if not, prepares a PR with the updates. What a lifesaver, right? But, as with any cog in an automated system, there’s always the potential for rust. In this story, it is the <a href="https://cwe.mitre.org/data/definitions/441.html" rel="noopener" target="_blank">deputy confusion</a> attack.</p>
<h2>Meet Dependabot: Your Automated Dependency Butler</h2>
<p>So, how does this magic work? You can boss Dependabot around using a <span>.github/dependabot.yml</span> file (check out the <a href="https://docs.github.com/en/code-security/dependabot/working-with-dependabot/dependabot-options-reference" rel="noopener" target="_blank">Dependabot options reference</a>).</p>
<p>Once active, Dependabot periodically scans your repo, guided by its config file. It also perks up and re-scans whenever you tweak this file or poke it via the <span>https://github.com/&lt;Owner&gt;/&lt;Repo&gt;/network/updates</span> tab.</p>
<p>When Dependabot spots an outdated dependency, it kicks off a workflow (you&#39;ll see &#34;Dependabot Updates&#34; pop up in your Actions tab). Then, it creates a new branch, usually named something like <span>dependabot/&lt;module_type&gt;/&lt;registry&gt;/&lt;package_name&gt;/&lt;new_version&gt;</span>. Finally, it opens a Pull Request to your default branch with all the suggested changes.</p>
<h2>The &#34;Confused Deputy&#34; Problem: Wait, Who Asked You To Do That?</h2>
<p>Now, let&#39;s talk about the <span>Confused Deputy Problem</span>. It&#39;s a classic vulnerability class (<a href="https://cwe.mitre.org/data/definitions/441.html" rel="noopener" target="_blank">CWE-441</a>, if you&#39;re into that sort of thing) where a trusted party (our &#34;deputy&#34;) is tricked by an attacker into performing an action. The deputy thinks it’s doing honest work, but it&#39;s carrying out the attacker&#39;s nefarious plan.</p>
<p>Some workflows are sensitive – they might have special permissions or access to secrets, so many developers added a user check at the beginning of them. Just to make sure it was triggered by a trusted user.</p>
<p>Naturally, folks got a bit tired of manually approving every single Dependabot PR. &#34;It&#39;s just a version update,&#34; they&#39;d say. Others might say: &#34;and we usually just end up blindly merging it anyway!&#34;. So, they created workflows to auto-merge PRs if the creator was Dependabot.</p>
<p><span>Something like this GitHub Actions workflow:</span></p>
<p>Seems safe, doesn&#39;t it? After all, Dependabot is trusted, and an attacker can&#39;t just force it to open a PR on a repo they don&#39;t control… Here&#39;s the trick: <span>github.actor</span> does not always refer to the actual creator of the Pull Request. It&#39;s the user who caused the latest event that triggered the workflow.</p>
<p>So, if an attacker could somehow force Dependabot into making a change that triggers this auto-merge workflow, they can merge their own malicious code.</p>
<p>Now, an attacker can&#39;t directly command Dependabot on a repo they don&#39;t have rights to. So, what can they make Dependabot do? Let&#39;s look at the events Dependabot is able to trigger:</p>
<table>
<tbody>
<tr>
<td>
<p><span><strong><span>Event</span></strong></span></p>
</td>
<td>
<p><span><strong><span>Action</span></strong></span></p>
</td>
<td>
<p><span><strong><span>From fork</span></strong></span></p>
</td>
<td>
<p><span><strong><span>Command</span></strong></span></p>
</td>
</tr>
<tr>
<td>
<p><span>pull_request_target</span><span>, </span><span>pull_request</span></p>
</td>
<td>
<p><span>When creating or updating a pull request.</span></p>
</td>
<td>
<p><span>true</span></p>
</td>
<td>
<p><span>@dependabot recreate</span></p>
</td>
</tr>
<tr>
<td>
<p><span>issue_comment</span></p>
</td>
<td>
<p><span>When showing information.</span></p>
</td>
<td>
<p><span>false</span></p>
</td>
<td>
<p><span>@dependabot show &lt;dependency name&gt; ignore conditions</span></p>
</td>
</tr>
<tr>
<td>
<p><span>push</span></p>
</td>
<td>
<p><span>When pushing to the branch, when merging etc.</span></p>
</td>
<td>
<p><span>false</span></p>
</td>
<td>
<p><span>@dependabot merge</span></p>
</td>
</tr>
<tr>
<td>
<p><span>create</span></p>
</td>
<td>
<p><span>When creating a new branch.</span></p>
</td>
<td>
<p><span>false</span></p>
</td>
<td>N/A</td>
</tr>
<tr>
<td>
<p><span>delete</span></p>
</td>
<td>
<p><span>When deleting a branch.</span></p>
</td>
<td>
<p><span>false</span></p>
</td>
<td>
<p><span>@dependabot close</span></p>
</td>
</tr>
<tr>
<td>
<p><span>workflow_run</span></p>
</td>
<td>
<p><span>It simply gets triggered as a side-effect of another (named) workflow running or completing.</span></p>
</td>
<td>
<p><span>true</span></p>
</td>
<td>Relevant if the parent workflow was triggered using one of the above commands.</td>
</tr>
</tbody>
</table>
<p>The juicy one here is that Dependabot can be forced to update a Pull Request, even one originating from a fork!</p>
<p>Here&#39;s the evil plan:</p>
<ol>
<li><strong>Fork It</strong>: Attacker forks a target repository. This repo has one of those &#34;auto-merge if Dependabot&#34; workflows.</li>
<li><strong>Rig it</strong>: Attacker adds their <span><strong>malicious payload</strong></span> to the <span><strong>Default branch</strong></span> of their fork.</li>
<li><strong>Wake Up, Dependabot!</strong>: Attacker enables Dependabot on their fork and adds an obviously outdated dependency to get its attention (often at the time you fork, this pre-requisite will already be met).</li>
<li><strong>Dependabot Does Its Thing</strong>: Dependabot creates its update branch on the fork. Since this branch is based on the fork&#39;s own Default branch, the now includes the attacker&#39;s payload (<a href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/checking-out-pull-requests-locally#error-failed-to-push-some-refs" rel="noopener" target="_blank">through the refs/pulls/ read-only namespace</a>).</li>
<li><strong>The Bait</strong>: Attacker creates a Pull Request from this weaponized Dependabot branch on their fork, targeting the original (victim) repository.</li>
<li><strong>Firing blanks</strong>: This new PR triggers the auto-merge workflow in the victim repo. However, at this point, <span>github.actor</span> is the attacker, so the if condition fails, and the workflow doesn&#39;t merge anything.</li>
<li><strong>Confused, are you?</strong>: Attacker goes back to the original Pull Request in their fork that Dependabot initially opened and comments: <span>@dependabot recreate</span>.</li>
<li><strong>Dependabot Obeys</strong>: Dependabot goes to work and recreates its branch and force-pushes the changes. This triggers the vulnerable <span>pull_request_target</span> workflow again, but this time with the <span>synchronize</span> event.</li>
<li><strong>Bingo!</strong>: Now, the <span>if: ${<span> <span></span></span>{ github.actor == &#39;dependabot[bot]&#39; }}</span> condition is true! The workflow promptly merges the attacker&#39;s code.</li>
</ol>
<p>And just like that, our attacker has bypassed the user verification using Dependabot as their confused deputy! This technique originally discovered and documented brilliantly by <a href="https://www.linkedin.com/in/%E2%98%80%EF%B8%8F-hugo-vincent-288b21171/" rel="noopener" target="_blank">Hugo Vincent</a> in his seminal article <a href="https://www.synacktiv.com/publications/github-actions-exploitation-dependabot" rel="noopener" target="_blank">GitHub Actions Exploitation: Dependabot</a>, is a crafty way to hack Open Source projects, in a clever and unique way, different from your garden-variety <a href="https://securitylab.github.com/resources/github-actions-preventing-pwn-requests/" rel="noopener" target="_blank">Pwn Requests</a>. It&#39;s not just theoretical either. This kind of exploit was exploited in the December 2024 <a href="https://konghq.com/blog/product-releases/december-2024-unauthorized-kong-ingress-controller-3-4-0-build" rel="noopener" target="_blank">Kong Ingress Controller attack</a> and by using <a href="https://boostsecurity.io/blog/under-the-radar-zero-days-in-open-source-build-pipelines" rel="noopener" target="_blank">BoostSecurity&#39;s own Package Supply infrastructure</a>, we keep finding instances at scale in mission-critical Open Source projects!</p>
<h2>Level Up: Dependabot Deputy Confusion Injection</h2>
<p>So we&#39;ve shown how an attacker can trick Dependabot into merging a branch with bad stuff in it. This is essentially could be considered a variant of Pwn Request without RCE (if you&#39;re not familiar, check out our previous article called <a href="https://boostsecurity.io/blog/exploiting-cicd-with-style-lotp-guide" rel="noopener" target="_blank">Exploiting CI/CD with Style(lint): LOTP Guide</a>). But can we take it further? You bet! Other than untrusted code checkout execution, the other common Build Pipeline exploitation technique is an injection (as seen in <a href="https://boostsecurity.io/blog/opening-pandora-box-supply-chain-insider-threats-in-oss-projects" rel="noopener" target="_blank">Opening Pandora’s box - Supply Chain Insider Threats in Open Source projects</a>). The most common flavour? Injecting by maliciously crafting a Git branch name.</p>
<p>Consider this simplified workflow snippet:</p>
<p>See that <span>${<span> </span>{ github.event.pull_request.head.ref }}</span>? GitHub Actions will replace the content of the <span>head.ref</span> (the branch name the PR is coming from) directly in the <span>run</span> script. If an attacker calls their branch something like <span>$(id)</span>, that command gets executed!</p>
<p>Normally, the <span>head.ref</span> is the attacker-controlled branch name from their fork. But in our Dependabot deputy confusion scenario, Dependabot has a very particular naming scheme for its branches (<span>dependabot/&lt;ecosystem&gt;/...</span>). Try to rename its branch directly, and Dependabot usually gives up and will cease to push to it anymore – which is a pre-requisite for that <span>pull_request_target</span> <span>synchronize</span> trigger.</p>
<p>So, you might think, &#34;Phew, Dependabot deputy confusion is immune to injection Pwn Requests!&#34; <span><span>Wrong! So very wrong! </span></span>BoostSecurity&#39;s research team (plus some clever folks during a Hackathon we organized) uncovered not one, but two unique sneaky ways to achieve this kind of injection - this is a <span>previously undisclosed TTP</span> we&#39;ve had to develop in the fall of 2024 as it was key in several high-profile Bug Bounty responsible disclosures:</p>
<ol>
<li><strong>The Merge Conflict Tango</strong></li>
<li><strong>The <span>@dependabot</span> merge Shuffle with a Custom Default Branch</strong> (Kudos to some clever participants at the <a href="https://montrehack.ca/" rel="noopener" target="_blank">Montréhack</a> hackathon of <a href="https://www.youtube.com/watch?v=HWTzuNH6y_M" rel="noopener" target="_blank">May 2025</a> for coming up with this one as they were playing the second round of our <a href="https://github.com/messypoutine/gravy-overflow/blob/main/.github/workflows/level3.yml" rel="noopener" target="_blank">MessyPoutine CTF</a>!)</li>
</ol>
<h4>Technique 1: The Merge Conflict Tango</h4>
<p>This method lets an attacker rename Dependabot&#39;s branch without breaking its connection to it. It&#39;s a bit of a dance and is definitely unstable, but it is repeatable.</p>
<p>Here are the steps:</p>
<ol>
<li><strong>The Setup</strong>: Fork the target repo (with the vulnerable workflow), enable Dependabot, and get it to create its update PR/branch.</li>
<li><strong>Create Conflict</strong>: On your fork, introduce a file with the same name but different content to both Dependabot&#39;s branch and your fork&#39;s default branch. This manufactures a merge conflict.</li>
<li><strong>Preserve Dependabot&#39;s Work (Sort Of)</strong>: Figure out which file Dependabot originally changed (We can see them in its PR). Revert that specific change on Dependabot&#39;s branch by uploading the original version from the default branch. This is key to stop Dependabot from thinking its job is done and closing its PR later.</li>
<li><strong>Switcheroo</strong>: Change the default branch of your forked repository to Dependabot&#39;s branch.</li>
<li><strong>Resolve This!</strong>: Go to the newly conflicted Pull Request (the one Dependabot made). GitHub&#39;s UI will offer to help you resolve the conflict.</li>
<li><strong>The Magic Button</strong>: Fix the conflict. When you click &#34;Commit merge,&#34; you&#39;ll get a very special dialog: &#34;Commit updates to the ... branch&#34; OR &#34;Create a new branch and commit updates. Your pull request will be updated automatically.&#34;. To be honest, we had never seen this dialog on github.com before we had to develop this TTP (Thanks <a href="https://www.linkedin.com/in/adnanekhan/" rel="noopener" target="_blank">@AdnanKhan</a> for the hint). </li>
<li><strong>Payload Branch</strong>: Choose option #2! Name this new branch with your desired payload (e.g., <span>foo-$(id)-bar</span>).</li>
<li><strong>New PR, Same Story (Almost)</strong>: Create a new Pull Request from this payload-named branch, targeting the original victim repository. This triggers the workflow, but <span>github.actor</span> is still you, the attacker. No execution yet.</li>
<li><strong>The @dependabot recreate</strong>: Comment <span>@dependabot recreate</span> on the original Dependabot Pull Request.</li>
<li><strong>Execution!</strong>: Dependabot will now recreate and force-push its changes to your payload-named branch (because its PR is now pointing there). This triggers <span>pull_request_target</span> with <span>synchronize</span>, <span>github.actor</span> is <span>dependabot[bot]</span>, and your injected branch name gets executed!</li>
</ol>
This technique can be a bit finicky – one wrong step, and you might have to start over, but don&#39;t worry we were able to fully script it. Also, some characters are off-limits for branch names:</span>
    </p>
    

   
    
   <!-- 
<hr class="blog-post__divider" />
-->
    <div>
      <p><img src="" height="150" loading="lazy" alt="Image of Sébastien Graveline"/>
      </p>
      
    </div>
    
    

    

    <div>
      <h2>
        
      </h2>
      <div>
        
  
      <div>
        <p><img src="https://boostsecurity.io/hs-fs/hubfs/Screen%20Shot%202022-11-22%20at%2011.19.21.png?height=175&amp;name=Screen%20Shot%202022-11-22%20at%2011.19.21.png" height="175" loading="lazy" alt=""/>
        </p>
        <div>
          <h3>SLSA dip — It’s Build Time!</h3>
          <div>
            
            <p><img src="https://boostsecurity.io/hs-fs/hubfs/authorimage.jpg?height=70&amp;name=authorimage.jpg" height="70" loading="lazy" alt="Image of BoostSecurity.io"/>
            </p>
            
            <p>
              <h6>BoostSecurity.io</h6>
            </p>
          </div>
          
          <p id="faa8" data-selectable-paragraph="">This article is part of a series about the security of the software supply chain. Each article will...</p>
          <a href="https://boostsecurity.io/blog/slsa-dip-its-build-time">
            <p><span id="hs_cos_wrapper_read_more_button_" data-hs-cos-general-type="widget" data-hs-cos-type="text">Read more</span></p>
          </a>
        </div>
      </div>
    

  
      <div>
        <p><img src="https://boostsecurity.io/hs-fs/hubfs/wolfi-blog.png?height=175&amp;name=wolfi-blog.png" height="175" loading="lazy" alt="Wolfi, whose name was inspired by the world’s smallest octopus"/>
        </p>
        <div>
          <h3>The tale of a Supply Chain near-miss incident</h3>
          <div>
            
            <p><img src="https://boostsecurity.io/hs-fs/hubfs/Imported%20sitepage%20images/TRD05AFBP-U01JB03QZMF-a931fe568735-512.jpeg?height=70&amp;name=TRD05AFBP-U01JB03QZMF-a931fe568735-512.jpeg" height="70" loading="lazy" alt="Image of François Proulx"/>
            </p>
            
            <p>
              <h6>François Proulx</h6>
            </p>
          </div>
          
          <p id="72a4" data-selectable-paragraph=""><span>TL;DR: </span>We disclosed to <a href="https://www.chainguard.dev/" rel="noopener ugc nofollow" target="_blank">Chainguard</a> in December 2023 that one of their GitHub Actions workflow was...</p>
          <a href="https://boostsecurity.io/blog/the-tale-of-a-supply-chain-near-miss-incident">
            <p><span id="hs_cos_wrapper_read_more_button_" data-hs-cos-general-type="widget" data-hs-cos-type="text">Read more</span></p>
          </a>
        </div>
      </div>
    


      </div>
    </div>

  </div>
</div></div>
  </body>
</html>
