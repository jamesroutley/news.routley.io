<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/brightprogrammer/MisraStdC">Original</a>
    <h1>Yet Another TypeSafe and Generic Programming Candidate for C</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><a href="https://github.com/brightprogrammer/MisraStdC/actions/workflows/test-linux.yml"><img src="https://github.com/brightprogrammer/MisraStdC/actions/workflows/test-linux.yml/badge.svg?branch=master" alt="Linux Build"/></a>
<a href="https://github.com/brightprogrammer/MisraStdC/actions/workflows/test-macos.yml"><img src="https://github.com/brightprogrammer/MisraStdC/actions/workflows/test-macos.yml/badge.svg?branch=master" alt="macOS Build"/></a>
<a href="https://github.com/brightprogrammer/MisraStdC/actions/workflows/test-windows-msvc.yml"><img src="https://github.com/brightprogrammer/MisraStdC/actions/workflows/test-windows-msvc.yml/badge.svg?branch=master" alt="Windows Build"/></a></p>
<p dir="auto">A modern C11 library designed to make programming in C less painful and more productive, written in pure C. MisraStdC provides generic containers, string handling, and formatted I/O inspired by higher-level languages while maintaining C&#39;s performance and control.</p>
<blockquote>
<p dir="auto"><strong>Disclaimer:</strong> This library is <strong>not</strong> related to the MISRA C standard or guidelines. The name &#34;MisraStdC&#34; comes from the author&#39;s name, Siddharth Mishra, who is commonly known as &#34;Misra&#34; among friends.</p>
</blockquote>

<ul dir="auto">
<li><a href="#features">Features</a></li>
<li><a href="#requirements">Requirements</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#documentation">Documentation</a></li>
<li><a href="#concepts">Concenpts</a></li>
<li><a href="#examples">Examples</a>
<ul dir="auto">
<li><a href="#vector-container-vec">Vector Container (Vec)</a></li>
<li><a href="#string-operations-str">String Operations (Str)</a></li>
<li><a href="#formatted-io">Formatted I/O</a></li>
<li><a href="#json-parsing-and-writing">JSON Parsing and Writing</a></li>
<li><a href="#working-with-complex-types">Working with Complex Types</a></li>
<li><a href="#parent-child-process">Parent Child Process</a></li>
</ul>
</li>
<li><a href="#format-specifiers">Format Specifiers</a></li>
<li><a href="#contributing">Contributing</a></li>
<li><a href="#license">License</a></li>
</ul>

<ul dir="auto">
<li><strong>Cross-platform compatibility</strong>: Supports MSVC, GCC, and Clang</li>
<li><strong>Type-safe generic containers</strong>:
<ul dir="auto">
<li><code>Vec(T)</code>: Generic vector with strict type checking</li>
<li><code>Str</code>: String handling (specialized <code>Vec(char)</code>)</li>
<li><code>Map(K, V)</code>: Generic key-value hash-map storage (WIP)</li>
<li><code>Int</code>: Custom big integer implementation (WIP)</li>
</ul>
</li>
<li><strong>Rust-style formatted I/O</strong>:
<ul dir="auto">
<li><code>WriteFmt</code>, <code>ReadFmt</code>: Type-safe formatted standard I/O</li>
<li><code>StrWriteFmt</code>, <code>StrReadFmt</code>: Type-safe formatted string operations</li>
</ul>
</li>
<li><strong>JSON parsing and serialization</strong></li>
<li><strong>Memory safety</strong> with proper initialization and cleanup functions</li>
</ul>

<ul dir="auto">
<li>
<p dir="auto"><strong>C11 compatible compiler</strong>:</p>
<ul dir="auto">
<li><strong>GCC</strong>: Version 4.9 or newer</li>
<li><strong>Clang</strong>: Version 3.4 or newer</li>
<li><strong>MSVC</strong>: Visual Studio 2019 or newer</li>
</ul>
</li>
<li>
<p dir="auto"><strong>Build System</strong>:</p>
<ul dir="auto">
<li><a href="https://mesonbuild.com/" rel="nofollow">Meson</a> build system (version 0.60.0 or newer)</li>
<li><a href="https://ninja-build.org/" rel="nofollow">Ninja</a> build tool</li>
</ul>
</li>
</ul>


<div dir="auto" data-snippet-clipboard-copy-content="# Clone the repository with submodules
git clone --recursive https://github.com/brightprogrammer/MisraStdC.git
cd MisraStdC

# Configure the build
meson setup builddir

# Build the library
ninja -C builddir

# Run tests
ninja -C builddir test"><pre><span><span>#</span> Clone the repository with submodules</span>
git clone --recursive https://github.com/brightprogrammer/MisraStdC.git
<span>cd</span> MisraStdC

<span><span>#</span> Configure the build</span>
meson setup builddir

<span><span>#</span> Build the library</span>
ninja -C builddir

<span><span>#</span> Run tests</span>
ninja -C builddir <span>test</span></pre></div>

<p dir="auto">For development with sanitizers (recommended for debugging):</p>
<div dir="auto" data-snippet-clipboard-copy-content="meson setup builddir -Db_sanitize=address,undefined -Db_lundef=false"><pre>meson setup builddir -Db_sanitize=address,undefined -Db_lundef=false</pre></div>

<p dir="auto">Comprehensive API documentation is available at <a href="https://docs.brightprogrammer.in" rel="nofollow">docs.brightprogrammer.in</a>.</p>


<p dir="auto">If an object type provides an <code>Init()</code> method or macro, then that must necessarily be used. Some objects
employ tricks to detect whether object is initialized properly or is corrupted at runtime. These checks
are performed everytime during a function call. While this adds a bit of overhead to the function calls,
it does make sure that everything&#39;s working as expected. There&#39;s no computation involved, and just a few
comparision checks.</p>
<p dir="auto">Similar to initialization, all objects must be deinitialized at the end of their life cycle.</p>

<p dir="auto">There are two types of insertion methods into a container.</p>
<ul dir="auto">
<li>Insertion of l-value</li>
<li>Insertion of r-value</li>
</ul>
<p dir="auto">While the naming is a bit ambiguous, this is what I came up at the time of need. By default
all unmarked functions/macros follow l-value semantics.</p>

<p dir="auto">Functions/macros marked with <em><strong>L</strong></em> suffix follow this behavior. Functions/macros marked with <em><strong>L</strong></em>
will make sure that there will always exist only one copy of data being inserted. If the container you&#39;re
inserting an item to, makes it&#39;s own copy of items, the inserted l-value remains as it is, because
unique ownership is maintained. If however the container does not create it&#39;s own copies, because <code>copy_init</code>
method is not set, then it&#39;ll take ownership by calling <code>memset(lval, 0, sizeof(lval))</code> on given l-value <code>lval</code>.</p>
<p dir="auto">This is to explicitly state that the object must always have single ownership.</p>

<p dir="auto">Unlike l-value insertion, here the functions/macros don&#39;t care about who owns what. You just insert
and forget about ownership. There can be multiple owners, there can be a single one, we believe the user
knows what they&#39;re doing.</p>

<p dir="auto">This strict set of functions/macros to declare ownership transfers in code is to
better annotate the transfer locations. Usually these are not very clear when reading code.
One example use case of l-value semantics is when you&#39;re creating objects in a for-loop in
a temporary variable (for eg: receivng from a stream) and then inserting those directly into a
container for storage.</p>
<p dir="auto">NOTE: The container will take ownership only if no <code>copy_init</code> is set!!</p>


<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;Misra.h&gt;

int compare_ints(const void* a, const void* b) {
    return *(const int*)a - *(const int*)b;
}

int main() {
    // Initialize vector with default alignment
    Vec(int) numbers = VecInit();
    
    // Pre-allocate space for better performance
    VecReserve(&amp;numbers, 10);
    
    // Insert elements (ownership transfer for l-values)
    int val = 42;
    VecInsertL(&amp;numbers, &amp;val, 0);      // val is now owned by vector
    VecInsertR(&amp;numbers, 10, 0);        // Insert at front
    VecInsertR(&amp;numbers, 30, 1);        // Insert in middle
    
    // Access elements safely
    int first = VecAt(&amp;numbers, 0);                // Get by value
    int* first_ptr = VecPtrAt(&amp;numbers, 0);       // Get by pointer
    int last = VecLast(&amp;numbers);                 // Last element
    
    // Batch operations
    int items[] = {15, 25, 35};
    VecInsertRange(&amp;numbers, items, VecLen(&amp;numbers), 3);
    
    // Sort the vector
    VecSort(&amp;numbers, compare_ints);
    
    // Different iteration patterns
    VecForeachIdx(&amp;numbers, val, idx, {
        WriteFmtLn(&#34;[{}] = {}\n&#34;, idx, val);
    });
    
    // Modify elements in-place
    VecForeachPtr(&amp;numbers, ptr, {
        *ptr *= 2;
    });
    
    // Memory management
    VecTryReduceSpace(&amp;numbers);  // Optimize memory usage
    size_t size = VecSize(&amp;numbers);  // Size in bytes
    
    // Batch removal
    VecDeleteRange(&amp;numbers, 1, 2);  // Remove 2 elements starting at index 1
    
    // Clear all elements but keep capacity
    VecClear(&amp;numbers);
    
    // Final cleanup
    VecDeinit(&amp;numbers);
}"><pre><span>#include</span> <span>&lt;Misra.h&gt;</span>

<span>int</span> <span>compare_ints</span>(<span>const</span> <span>void</span><span>*</span> <span>a</span>, <span>const</span> <span>void</span><span>*</span> <span>b</span>) {
    <span>return</span> <span>*</span>(<span>const</span> <span>int</span><span>*</span>)<span>a</span> <span>-</span> <span>*</span>(<span>const</span> <span>int</span><span>*</span>)<span>b</span>;
}

<span>int</span> <span>main</span>() {
    <span>// Initialize vector with default alignment</span>
    <span>Vec</span>(<span>int</span>) <span>numbers</span> <span>=</span> <span>VecInit</span>();
    
    <span>// Pre-allocate space for better performance</span>
    <span>VecReserve</span>(<span>&amp;</span><span>numbers</span>, <span>10</span>);
    
    <span>// Insert elements (ownership transfer for l-values)</span>
    <span>int</span> <span>val</span> <span>=</span> <span>42</span>;
    <span>VecInsertL</span>(<span>&amp;</span><span>numbers</span>, <span>&amp;</span><span>val</span>, <span>0</span>);      <span>// val is now owned by vector</span>
    <span>VecInsertR</span>(<span>&amp;</span><span>numbers</span>, <span>10</span>, <span>0</span>);        <span>// Insert at front</span>
    <span>VecInsertR</span>(<span>&amp;</span><span>numbers</span>, <span>30</span>, <span>1</span>);        <span>// Insert in middle</span>
    
    <span>// Access elements safely</span>
    <span>int</span> <span>first</span> <span>=</span> <span>VecAt</span>(<span>&amp;</span><span>numbers</span>, <span>0</span>);                <span>// Get by value</span>
    <span>int</span><span>*</span> <span>first_ptr</span> <span>=</span> <span>VecPtrAt</span>(<span>&amp;</span><span>numbers</span>, <span>0</span>);       <span>// Get by pointer</span>
    <span>int</span> <span>last</span> <span>=</span> <span>VecLast</span>(<span>&amp;</span><span>numbers</span>);                 <span>// Last element</span>
    
    <span>// Batch operations</span>
    <span>int</span> <span>items</span>[] <span>=</span> {<span>15</span>, <span>25</span>, <span>35</span>};
    <span>VecInsertRange</span>(<span>&amp;</span><span>numbers</span>, <span>items</span>, <span>VecLen</span>(<span>&amp;</span><span>numbers</span>), <span>3</span>);
    
    <span>// Sort the vector</span>
    <span>VecSort</span>(<span>&amp;</span><span>numbers</span>, <span>compare_ints</span>);
    
    <span>// Different iteration patterns</span>
    <span>VecForeachIdx</span>(<span>&amp;</span><span>numbers</span>, <span>val</span>, <span>idx</span>, {
        <span>WriteFmtLn</span>(<span>&#34;[{}] = {}\n&#34;</span>, <span>idx</span>, <span>val</span>);
    });
    
    <span>// Modify elements in-place</span>
    <span>VecForeachPtr</span>(<span>&amp;</span><span>numbers</span>, <span>ptr</span>, {
        <span>*</span><span>ptr</span> *= <span>2</span>;
    });
    
    <span>// Memory management</span>
    <span>VecTryReduceSpace</span>(<span>&amp;</span><span>numbers</span>);  <span>// Optimize memory usage</span>
    <span>size_t</span> <span>size</span> <span>=</span> <span>VecSize</span>(<span>&amp;</span><span>numbers</span>);  <span>// Size in bytes</span>
    
    <span>// Batch removal</span>
    <span>VecDeleteRange</span>(<span>&amp;</span><span>numbers</span>, <span>1</span>, <span>2</span>);  <span>// Remove 2 elements starting at index 1</span>
    
    <span>// Clear all elements but keep capacity</span>
    <span>VecClear</span>(<span>&amp;</span><span>numbers</span>);
    
    <span>// Final cleanup</span>
    <span>VecDeinit</span>(<span>&amp;</span><span>numbers</span>);
}</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;Misra.h&gt;

int main() {
    // Strings are just Vec(char) with special operations
    Str text = StrInit();
    
    // String creation
    Str hello = StrInitFromZstr(&#34;Hello&#34;);
    Str world = StrInitFromCstr(&#34;, World!&#34;, 8);
    
    // Formatted append
    StrAppendf(&amp;text, &#34;%.*s%.*s\n&#34;, 
               (int)hello.length, hello.data,
               (int)world.length, world.data);
    
    // String operations
    bool starts = StrStartsWithZstr(&amp;text, &#34;Hello&#34;);
    bool ends = StrEndsWithZstr(&amp;text, &#34;!\n&#34;);
    
    // Split into vector of strings
    Str csv = StrInitFromZstr(&#34;one,two,three&#34;);
    Strs parts = StrSplit(&amp;csv, &#34;,&#34;);
    
    // Process split results
    VecForeach(&amp;parts, str, {
        WriteFmtLn(&#34;Part: {}\n&#34;, str);
    });
    
    // Cleanup
    StrDeinit(&amp;text);
    StrDeinit(&amp;hello);
    StrDeinit(&amp;world);
    StrDeinit(&amp;csv);
    
    // Cleanup split results
    VecForeachPtr(&amp;parts, str, {
        StrDeinit(str);
    });
    VecDeinit(&amp;parts);
}"><pre><span>#include</span> <span>&lt;Misra.h&gt;</span>

<span>int</span> <span>main</span>() {
    <span>// Strings are just Vec(char) with special operations</span>
    <span>Str</span> <span>text</span> <span>=</span> <span>StrInit</span>();
    
    <span>// String creation</span>
    <span>Str</span> <span>hello</span> <span>=</span> <span>StrInitFromZstr</span>(<span>&#34;Hello&#34;</span>);
    <span>Str</span> <span>world</span> <span>=</span> <span>StrInitFromCstr</span>(<span>&#34;, World!&#34;</span>, <span>8</span>);
    
    <span>// Formatted append</span>
    <span>StrAppendf</span>(<span>&amp;</span><span>text</span>, <span>&#34;%.*s%.*s\n&#34;</span>, 
               (<span>int</span>)<span>hello</span>.<span>length</span>, <span>hello</span>.<span>data</span>,
               (<span>int</span>)<span>world</span>.<span>length</span>, <span>world</span>.<span>data</span>);
    
    <span>// String operations</span>
    <span>bool</span> <span>starts</span> <span>=</span> <span>StrStartsWithZstr</span>(<span>&amp;</span><span>text</span>, <span>&#34;Hello&#34;</span>);
    <span>bool</span> <span>ends</span> <span>=</span> <span>StrEndsWithZstr</span>(<span>&amp;</span><span>text</span>, <span>&#34;!\n&#34;</span>);
    
    <span>// Split into vector of strings</span>
    <span>Str</span> <span>csv</span> <span>=</span> <span>StrInitFromZstr</span>(<span>&#34;one,two,three&#34;</span>);
    <span>Strs</span> <span>parts</span> <span>=</span> <span>StrSplit</span>(<span>&amp;</span><span>csv</span>, <span>&#34;,&#34;</span>);
    
    <span>// Process split results</span>
    <span>VecForeach</span>(<span>&amp;</span><span>parts</span>, <span>str</span>, {
        <span>WriteFmtLn</span>(<span>&#34;Part: {}\n&#34;</span>, <span>str</span>);
    });
    
    <span>// Cleanup</span>
    <span>StrDeinit</span>(<span>&amp;</span><span>text</span>);
    <span>StrDeinit</span>(<span>&amp;</span><span>hello</span>);
    <span>StrDeinit</span>(<span>&amp;</span><span>world</span>);
    <span>StrDeinit</span>(<span>&amp;</span><span>csv</span>);
    
    <span>// Cleanup split results</span>
    <span>VecForeachPtr</span>(<span>&amp;</span><span>parts</span>, <span>str</span>, {
        <span>StrDeinit</span>(<span>str</span>);
    });
    <span>VecDeinit</span>(<span>&amp;</span><span>parts</span>);
}</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;Misra.h&gt;

int main() {
    // String formatting
    Str output = StrInit();
    
    // Basic formatting with direct values
    int count = 42;
    const char* name = &#34;Test&#34;;
    StrWriteFmt(&amp;output, &#34;Count: {}, Name: {}\n&#34;, count, name);  // Pass values directly, not pointers
    
    // Format with alignment and hex
    u32 hex_val = 0xDEADBEEF;
    StrWriteFmt(&amp;output, &#34;Hex: {X}\n&#34;, hex_val);
    
    // Read formatted input
    const char* input = &#34;Count: 42, Name: Test&#34;;
    int read_count;
    Str read_name = StrInit();
    
    // For reading, we pass the variables directly
    StrReadFmt(input, &#34;Count: {}, Name: {}&#34;, read_count, read_name);  // No &amp; operator needed
    
    // Multiple value types
    float pi = 3.14159f;
    u64 big_num = 123456789ULL;
    StrWriteFmt(&amp;output, &#34;Float: {.2f}, Integer: {}, Hex: {x}\n&#34;, pi, big_num, big_num);
    
    // String formatting
    Str hello = StrInitFromZstr(&#34;Hello&#34;);
    StrWriteFmt(&amp;output, &#34;String: {}\n&#34;, hello);  // Pass Str directly
    
    // Cleanup
    StrDeinit(&amp;output);
    StrDeinit(&amp;read_name);
    StrDeinit(&amp;hello);
}"><pre><span>#include</span> <span>&lt;Misra.h&gt;</span>

<span>int</span> <span>main</span>() {
    <span>// String formatting</span>
    <span>Str</span> <span>output</span> <span>=</span> <span>StrInit</span>();
    
    <span>// Basic formatting with direct values</span>
    <span>int</span> <span>count</span> <span>=</span> <span>42</span>;
    <span>const</span> <span>char</span><span>*</span> <span>name</span> <span>=</span> <span>&#34;Test&#34;</span>;
    <span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;Count: {}, Name: {}\n&#34;</span>, <span>count</span>, <span>name</span>);  <span>// Pass values directly, not pointers</span>
    
    <span>// Format with alignment and hex</span>
    <span>u32</span> <span>hex_val</span> <span>=</span> <span>0xDEADBEEF</span>;
    <span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;Hex: {X}\n&#34;</span>, <span>hex_val</span>);
    
    <span>// Read formatted input</span>
    <span>const</span> <span>char</span><span>*</span> <span>input</span> <span>=</span> <span>&#34;Count: 42, Name: Test&#34;</span>;
    <span>int</span> <span>read_count</span>;
    <span>Str</span> <span>read_name</span> <span>=</span> <span>StrInit</span>();
    
    <span>// For reading, we pass the variables directly</span>
    <span>StrReadFmt</span>(<span>input</span>, <span>&#34;Count: {}, Name: {}&#34;</span>, <span>read_count</span>, <span>read_name</span>);  <span>// No &amp; operator needed</span>
    
    <span>// Multiple value types</span>
    <span>float</span> <span>pi</span> <span>=</span> <span>3.14159f</span>;
    <span>u64</span> <span>big_num</span> <span>=</span> <span>123456789ULL</span>;
    <span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;Float: {.2f}, Integer: {}, Hex: {x}\n&#34;</span>, <span>pi</span>, <span>big_num</span>, <span>big_num</span>);
    
    <span>// String formatting</span>
    <span>Str</span> <span>hello</span> <span>=</span> <span>StrInitFromZstr</span>(<span>&#34;Hello&#34;</span>);
    <span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;String: {}\n&#34;</span>, <span>hello</span>);  <span>// Pass Str directly</span>
    
    <span>// Cleanup</span>
    <span>StrDeinit</span>(<span>&amp;</span><span>output</span>);
    <span>StrDeinit</span>(<span>&amp;</span><span>read_name</span>);
    <span>StrDeinit</span>(<span>&amp;</span><span>hello</span>);
}</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;Misra.h&gt;

// Define our data structures
typedef struct Point {
    float x;
    float y;
} Point;

typedef struct Shape {
    Str name;
    Point position;
    Vec(Point) vertices;
    bool filled;
} Shape;

int main() {
    // Example JSON string
    Str json = StrInitFromZstr(
        &#34;{&#34;
        &#34;  \&#34;name\&#34;: \&#34;polygon\&#34;,&#34;
        &#34;  \&#34;position\&#34;: {\&#34;x\&#34;: 10.5, \&#34;y\&#34;: 20.0},&#34;
        &#34;  \&#34;vertices\&#34;: [&#34;
        &#34;    {\&#34;x\&#34;: 0.0, \&#34;y\&#34;: 0.0},&#34;
        &#34;    {\&#34;x\&#34;: 10.0, \&#34;y\&#34;: 0.0},&#34;
        &#34;    {\&#34;x\&#34;: 5.0, \&#34;y\&#34;: 10.0}&#34;
        &#34;  ],&#34;
        &#34;  \&#34;filled\&#34;: true&#34;
        &#34;}&#34;
    );

    // Create our shape object
    Shape shape = {
        .name = StrInit(),
        .vertices = VecInit()
    };

    // Parse JSON into our structure
    StrIter si = StrIterFromStr(&amp;json);
    JR_OBJ(si, {
        // Read string value with key &#34;name&#34;
        JR_STR_KV(si, &#34;name&#34;, shape.name);
        
        // Read nested object with key &#34;position&#34;
        JR_OBJ_KV(si, &#34;position&#34;, {
            JR_FLT_KV(si, &#34;x&#34;, shape.position.x);
            JR_FLT_KV(si, &#34;y&#34;, shape.position.y);
        });
        
        // Read array of objects with key &#34;vertices&#34;
        JR_ARR_KV(si, &#34;vertices&#34;, {
            Point vertex = {0};
            JR_OBJ(si, {
                JR_FLT_KV(si, &#34;x&#34;, vertex.x);
                JR_FLT_KV(si, &#34;y&#34;, vertex.y);
            });
            VecInsertR(&amp;shape.vertices, vertex, VecLen(&amp;shape.vertices));
        });
        
        // Read boolean value with key &#34;filled&#34;
        JR_BOOL_KV(si, &#34;filled&#34;, shape.filled);
    });

    // Modify some values
    shape.position.x += 5.0;
    VecForeachPtr(&amp;shape.vertices, vertex, {
        vertex-&gt;y += 1.0;  // Move all points up by 1
    });

    // Write back to JSON
    StrClear(&amp;json);  // Clear existing content
    JW_OBJ(json, {
        // Write string key-value
        JW_STR_KV(json, &#34;name&#34;, shape.name);
        
        // Write nested object
        JW_OBJ_KV(json, &#34;position&#34;, {
            JW_FLT_KV(json, &#34;x&#34;, shape.position.x);
            JW_FLT_KV(json, &#34;y&#34;, shape.position.y);
        });
        
        // Write array of objects
        JW_ARR_KV(json, &#34;vertices&#34;, shape.vertices, vertex, {
            JW_OBJ(json, {
                JW_FLT_KV(json, &#34;x&#34;, vertex.x);
                JW_FLT_KV(json, &#34;y&#34;, vertex.y);
            });
        });
        
        // Write boolean value
        JW_BOOL_KV(json, &#34;filled&#34;, shape.filled);
    });

    // Print the resulting JSON
    WriteFmtLn(&#34;Modified JSON: {}&#34;, json);

    // Cleanup
    StrDeinit(&amp;shape.name);
    VecDeinit(&amp;shape.vertices);
    StrDeinit(&amp;json);
}"><pre><span>#include</span> <span>&lt;Misra.h&gt;</span>

<span>// Define our data structures</span>
<span>typedef</span> <span>struct</span> <span>Point</span> {
    <span>float</span> <span>x</span>;
    <span>float</span> <span>y</span>;
} <span>Point</span>;

<span>typedef</span> <span>struct</span> <span>Shape</span> {
    <span>Str</span> <span>name</span>;
    <span>Point</span> <span>position</span>;
    <span>Vec</span>(<span>Point</span>) <span>vertices</span>;
    <span>bool</span> <span>filled</span>;
} <span>Shape</span>;

<span>int</span> <span>main</span>() {
    <span>// Example JSON string</span>
    <span>Str</span> <span>json</span> <span>=</span> <span>StrInitFromZstr</span>(
        <span>&#34;{&#34;</span>
        <span>&#34;  \&#34;name\&#34;: \&#34;polygon\&#34;,&#34;</span>
        <span>&#34;  \&#34;position\&#34;: {\&#34;x\&#34;: 10.5, \&#34;y\&#34;: 20.0},&#34;</span>
        <span>&#34;  \&#34;vertices\&#34;: [&#34;</span>
        <span>&#34;    {\&#34;x\&#34;: 0.0, \&#34;y\&#34;: 0.0},&#34;</span>
        <span>&#34;    {\&#34;x\&#34;: 10.0, \&#34;y\&#34;: 0.0},&#34;</span>
        <span>&#34;    {\&#34;x\&#34;: 5.0, \&#34;y\&#34;: 10.0}&#34;</span>
        <span>&#34;  ],&#34;</span>
        <span>&#34;  \&#34;filled\&#34;: true&#34;</span>
        <span>&#34;}&#34;</span>
    );

    <span>// Create our shape object</span>
    <span>Shape</span> <span>shape</span> <span>=</span> {
        .<span>name</span> <span>=</span> <span>StrInit</span>(),
        .<span>vertices</span> <span>=</span> <span>VecInit</span>()
    };

    <span>// Parse JSON into our structure</span>
    <span>StrIter</span> <span>si</span> <span>=</span> <span>StrIterFromStr</span>(<span>&amp;</span><span>json</span>);
    <span>JR_OBJ</span>(<span>si</span>, {
        <span>// Read string value with key &#34;name&#34;</span>
        <span>JR_STR_KV</span>(<span>si</span>, <span>&#34;name&#34;</span>, <span>shape</span>.<span>name</span>);
        
        <span>// Read nested object with key &#34;position&#34;</span>
        <span>JR_OBJ_KV</span>(<span>si</span>, <span>&#34;position&#34;</span>, {
            <span>JR_FLT_KV</span>(<span>si</span>, <span>&#34;x&#34;</span>, <span>shape</span>.<span>position</span>.<span>x</span>);
            <span>JR_FLT_KV</span>(<span>si</span>, <span>&#34;y&#34;</span>, <span>shape</span>.<span>position</span>.<span>y</span>);
        });
        
        <span>// Read array of objects with key &#34;vertices&#34;</span>
        <span>JR_ARR_KV</span>(<span>si</span>, <span>&#34;vertices&#34;</span>, {
            <span>Point</span> <span>vertex</span> <span>=</span> {<span>0</span>};
            <span>JR_OBJ</span>(<span>si</span>, {
                <span>JR_FLT_KV</span>(<span>si</span>, <span>&#34;x&#34;</span>, <span>vertex</span>.<span>x</span>);
                <span>JR_FLT_KV</span>(<span>si</span>, <span>&#34;y&#34;</span>, <span>vertex</span>.<span>y</span>);
            });
            <span>VecInsertR</span>(<span>&amp;</span><span>shape</span>.<span>vertices</span>, <span>vertex</span>, <span>VecLen</span>(<span>&amp;</span><span>shape</span>.<span>vertices</span>));
        });
        
        <span>// Read boolean value with key &#34;filled&#34;</span>
        <span>JR_BOOL_KV</span>(<span>si</span>, <span>&#34;filled&#34;</span>, <span>shape</span>.<span>filled</span>);
    });

    <span>// Modify some values</span>
    <span>shape</span>.<span>position</span>.<span>x</span> <span>+=</span> <span>5.0</span>;
    <span>VecForeachPtr</span>(<span>&amp;</span><span>shape</span>.<span>vertices</span>, <span>vertex</span>, {
        <span>vertex</span><span>-&gt;</span><span>y</span> <span>+=</span> <span>1.0</span>;  <span>// Move all points up by 1</span>
    });

    <span>// Write back to JSON</span>
    <span>StrClear</span>(<span>&amp;</span><span>json</span>);  <span>// Clear existing content</span>
    <span>JW_OBJ</span>(<span>json</span>, {
        <span>// Write string key-value</span>
        <span>JW_STR_KV</span>(<span>json</span>, <span>&#34;name&#34;</span>, <span>shape</span>.<span>name</span>);
        
        <span>// Write nested object</span>
        <span>JW_OBJ_KV</span>(<span>json</span>, <span>&#34;position&#34;</span>, {
            <span>JW_FLT_KV</span>(<span>json</span>, <span>&#34;x&#34;</span>, <span>shape</span>.<span>position</span>.<span>x</span>);
            <span>JW_FLT_KV</span>(<span>json</span>, <span>&#34;y&#34;</span>, <span>shape</span>.<span>position</span>.<span>y</span>);
        });
        
        <span>// Write array of objects</span>
        <span>JW_ARR_KV</span>(<span>json</span>, <span>&#34;vertices&#34;</span>, <span>shape</span>.<span>vertices</span>, <span>vertex</span>, {
            <span>JW_OBJ</span>(<span>json</span>, {
                <span>JW_FLT_KV</span>(<span>json</span>, <span>&#34;x&#34;</span>, <span>vertex</span>.<span>x</span>);
                <span>JW_FLT_KV</span>(<span>json</span>, <span>&#34;y&#34;</span>, <span>vertex</span>.<span>y</span>);
            });
        });
        
        <span>// Write boolean value</span>
        <span>JW_BOOL_KV</span>(<span>json</span>, <span>&#34;filled&#34;</span>, <span>shape</span>.<span>filled</span>);
    });

    <span>// Print the resulting JSON</span>
    <span>WriteFmtLn</span>(<span>&#34;Modified JSON: {}&#34;</span>, <span>json</span>);

    <span>// Cleanup</span>
    <span>StrDeinit</span>(<span>&amp;</span><span>shape</span>.<span>name</span>);
    <span>VecDeinit</span>(<span>&amp;</span><span>shape</span>.<span>vertices</span>);
    <span>StrDeinit</span>(<span>&amp;</span><span>json</span>);
}</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Working with Complex Types</h3><a id="user-content-working-with-complex-types" aria-label="Permalink: Working with Complex Types" href="#working-with-complex-types"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;Misra.h&gt;

// Complex type with owned resources
typedef struct {
    int id;
    Vec(int) data;
} ComplexType;

// Copy initialization for deep copying
bool ComplexTypeCopyInit(ComplexType* dst, const ComplexType* src) {
    dst-&gt;id = src-&gt;id;
    dst-&gt;data = VecInit();
    
    // Copy all elements from source vector
    VecForeachIdx(&amp;src-&gt;data, val, idx, {
        VecInsertR(&amp;dst-&gt;data, val, idx);
    });
    return true;
}

// Proper cleanup of owned resources
void ComplexTypeDeinit(ComplexType* ct) {
    VecDeinit(&amp;ct-&gt;data);
}

int main() {
    // Vector of complex types with resource management
    Vec(ComplexType) objects = VecInitWithDeepCopy(ComplexTypeCopyInit, ComplexTypeDeinit);
    
    // Create and insert items
    ComplexType item = {
        .id = 1,
        .data = VecInit()
    };
    VecInsertR(&amp;item.data, 42, 0);
    VecInsertR(&amp;item.data, 43, 1);
    
    // Insert with ownership transfer
    VecInsertL(&amp;objects, &amp;item, 0);  // item is now owned by vector
    
    // Direct deletion (vector handles cleanup)
    // Since we provided ComplexTypeDeinit during initialization,
    // the vector will automatically call it when deleting items
    VecDelete(&amp;objects, 0);  // ComplexTypeDeinit is called automatically
    
    // Cleanup
    VecDeinit(&amp;objects);     // Calls ComplexTypeDeinit for each remaining element
}"><pre><span>#include</span> <span>&lt;Misra.h&gt;</span>

<span>// Complex type with owned resources</span>
<span>typedef</span> <span>struct</span> {
    <span>int</span> <span>id</span>;
    <span>Vec</span>(<span>int</span>) <span>data</span>;
} <span>ComplexType</span>;

<span>// Copy initialization for deep copying</span>
<span>bool</span> <span>ComplexTypeCopyInit</span>(<span>ComplexType</span><span>*</span> <span>dst</span>, <span>const</span> <span>ComplexType</span><span>*</span> <span>src</span>) {
    <span>dst</span><span>-&gt;</span><span>id</span> <span>=</span> <span>src</span><span>-&gt;</span><span>id</span>;
    <span>dst</span><span>-&gt;</span><span>data</span> <span>=</span> <span>VecInit</span>();
    
    <span>// Copy all elements from source vector</span>
    <span>VecForeachIdx</span>(<span>&amp;</span><span>src</span><span>-&gt;</span><span>data</span>, <span>val</span>, <span>idx</span>, {
        <span>VecInsertR</span>(<span>&amp;</span><span>dst</span><span>-&gt;</span><span>data</span>, <span>val</span>, <span>idx</span>);
    });
    <span>return</span> true;
}

<span>// Proper cleanup of owned resources</span>
<span>void</span> <span>ComplexTypeDeinit</span>(<span>ComplexType</span><span>*</span> <span>ct</span>) {
    <span>VecDeinit</span>(<span>&amp;</span><span>ct</span><span>-&gt;</span><span>data</span>);
}

<span>int</span> <span>main</span>() {
    <span>// Vector of complex types with resource management</span>
    <span>Vec</span>(<span>ComplexType</span>) <span>objects</span> <span>=</span> <span>VecInitWithDeepCopy</span>(<span>ComplexTypeCopyInit</span>, <span>ComplexTypeDeinit</span>);
    
    <span>// Create and insert items</span>
    <span>ComplexType</span> <span>item</span> <span>=</span> {
        .<span>id</span> <span>=</span> <span>1</span>,
        .<span>data</span> <span>=</span> <span>VecInit</span>()
    };
    <span>VecInsertR</span>(<span>&amp;</span><span>item</span>.<span>data</span>, <span>42</span>, <span>0</span>);
    <span>VecInsertR</span>(<span>&amp;</span><span>item</span>.<span>data</span>, <span>43</span>, <span>1</span>);
    
    <span>// Insert with ownership transfer</span>
    <span>VecInsertL</span>(<span>&amp;</span><span>objects</span>, <span>&amp;</span><span>item</span>, <span>0</span>);  <span>// item is now owned by vector</span>
    
    <span>// Direct deletion (vector handles cleanup)</span>
    <span>// Since we provided ComplexTypeDeinit during initialization,</span>
    <span>// the vector will automatically call it when deleting items</span>
    <span>VecDelete</span>(<span>&amp;</span><span>objects</span>, <span>0</span>);  <span>// ComplexTypeDeinit is called automatically</span>
    
    <span>// Cleanup</span>
    <span>VecDeinit</span>(<span>&amp;</span><span>objects</span>);     <span>// Calls ComplexTypeDeinit for each remaining element</span>
}</pre></div>

<p dir="auto">The library also provides a way to create child processes in a cross-platform manner. I&#39;ve
also added a method to write to <code>stdin</code> and read from <code>stdout</code> and <code>stderr</code> for each child process.
Refer to the following example, also present in <code>Bin/SubProcComm.c</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;Misra.h&gt;

// this program was verifed to work when executed with /bin/head
// the prgram writes something to child process and expect&#39;s the same thing echoed back
// so it can be verified that we got the same content
// executed like : Build/SubProcComm /bin/head -n 1
int main(int argc, char** argv, char** envp) {
    // create a new child process
    SysProc* proc = SysProcCreate(argv[1], argv + 1, envp);

    // write something to it&#39;s stdout
    SysProcWriteToStdinFmtLn(proc, &#34;value = {}&#34;, 42);

    // retrieve back the value
    i32 val = 0;
    SysProcReadFromStdoutFmt(proc, &#34;value = {}&#34;, val);

    // write the retrieved value to stdout (parent, not child)
    WriteFmtLn(&#34;got value = {}&#34;, val);

    // wait for program to exit for 1 second
    SysProcWaitFor(proc, 1000);

    // finally terminate
    SysProcDestroy(proc);
}"><pre><span>#include</span> <span>&lt;Misra.h&gt;</span>

<span>// this program was verifed to work when executed with /bin/head</span>
<span>// the prgram writes something to child process and expect&#39;s the same thing echoed back</span>
<span>// so it can be verified that we got the same content</span>
<span>// executed like : Build/SubProcComm /bin/head -n 1</span>
<span>int</span> <span>main</span>(<span>int</span> <span>argc</span>, <span>char</span><span>*</span><span>*</span> <span>argv</span>, <span>char</span><span>*</span><span>*</span> <span>envp</span>) {
    <span>// create a new child process</span>
    <span>SysProc</span><span>*</span> <span>proc</span> <span>=</span> <span>SysProcCreate</span>(<span>argv</span>[<span>1</span>], <span>argv</span> <span>+</span> <span>1</span>, <span>envp</span>);

    <span>// write something to it&#39;s stdout</span>
    <span>SysProcWriteToStdinFmtLn</span>(<span>proc</span>, <span>&#34;value = {}&#34;</span>, <span>42</span>);

    <span>// retrieve back the value</span>
    <span>i32</span> <span>val</span> <span>=</span> <span>0</span>;
    <span>SysProcReadFromStdoutFmt</span>(<span>proc</span>, <span>&#34;value = {}&#34;</span>, <span>val</span>);

    <span>// write the retrieved value to stdout (parent, not child)</span>
    <span>WriteFmtLn</span>(<span>&#34;got value = {}&#34;</span>, <span>val</span>);

    <span>// wait for program to exit for 1 second</span>
    <span>SysProcWaitFor</span>(<span>proc</span>, <span>1000</span>);

    <span>// finally terminate</span>
    <span>SysProcDestroy</span>(<span>proc</span>);
}</pre></div>

<p dir="auto">The library supports Rust-style format strings with placeholders in the form <code>{}</code> or <code>{pecifier}</code>.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Important: Understanding Supported Argument Format</h3><a id="user-content-important-understanding-supported-argument-format" aria-label="Permalink: Important: Understanding Supported Argument Format" href="#important-understanding-supported-argument-format"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The macro-tricks use <code>_Generic</code> for compile-time type specific io dispatching. Here&#39;s what works and what doesn&#39;t:</p>

<div dir="auto" data-snippet-clipboard-copy-content="// String literals (array types like char[6] not handled by _Generic)
StrWriteFmt(&amp;output, &#34;Hello, {}!&#34;, &#34;world&#34;);  // ERROR: char[6] not in _Generic cases

// Any char array types are not handled
char buffer[20] = &#34;Hello&#34;;                    // Type: char[20] 
StrWriteFmt(&amp;output, &#34;Message: {}&#34;, buffer);  // ERROR: char[20] not in _Generic cases

const char name[] = &#34;Alice&#34;;                  // Type: const char[6]
StrWriteFmt(&amp;output, &#34;Name: {}&#34;, name);       // ERROR: const char[6] not in _Generic cases"><pre><span>// String literals (array types like char[6] not handled by _Generic)</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;Hello, {}!&#34;</span>, <span>&#34;world&#34;</span>);  <span>// ERROR: char[6] not in _Generic cases</span>

<span>// Any char array types are not handled</span>
<span>char</span> <span>buffer</span>[<span>20</span>] <span>=</span> <span>&#34;Hello&#34;</span>;                    <span>// Type: char[20] </span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;Message: {}&#34;</span>, <span>buffer</span>);  <span>// ERROR: char[20] not in _Generic cases</span>

<span>const</span> <span>char</span> <span>name</span>[] <span>=</span> <span>&#34;Alice&#34;</span>;                  <span>// Type: const char[6]</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;Name: {}&#34;</span>, <span>name</span>);       <span>// ERROR: const char[6] not in _Generic cases</span></pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="// const char* variables (pointer type matches _Generic case)
const char* title = &#34;Mr.&#34;;
const char* surname = &#34;Smith&#34;;
StrWriteFmt(&amp;output, &#34;{} {}&#34;, title, surname);  // ✅ Works great!

// char* variables (pointer type matches _Generic case)
char* dynamic_str = malloc(50);
strcpy(dynamic_str, &#34;Dynamic&#34;);
StrWriteFmt(&amp;output, &#34;Value: {}&#34;, dynamic_str);      // ✅ Works perfectly!

// Str objects (library&#39;s string type)
Str greeting = StrInitFromZstr(&#34;Welcome&#34;);
StrWriteFmt(&amp;output, &#34;Message: {}&#34;, greeting);

// Primitive types (all handled by _Generic)
int number = 42;
float pi = 3.14f;
StrWriteFmt(&amp;output, &#34;Number: {}, Pi: {.2}&#34;, number, pi);"><pre><span>// const char* variables (pointer type matches _Generic case)</span>
<span>const</span> <span>char</span><span>*</span> <span>title</span> <span>=</span> <span>&#34;Mr.&#34;</span>;
<span>const</span> <span>char</span><span>*</span> <span>surname</span> <span>=</span> <span>&#34;Smith&#34;</span>;
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{} {}&#34;</span>, <span>title</span>, <span>surname</span>);  <span>// ✅ Works great!</span>

<span>// char* variables (pointer type matches _Generic case)</span>
<span>char</span><span>*</span> <span>dynamic_str</span> <span>=</span> <span>malloc</span>(<span>50</span>);
<span>strcpy</span>(<span>dynamic_str</span>, <span>&#34;Dynamic&#34;</span>);
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;Value: {}&#34;</span>, <span>dynamic_str</span>);      <span>// ✅ Works perfectly!</span>

<span>// Str objects (library&#39;s string type)</span>
<span>Str</span> <span>greeting</span> <span>=</span> <span>StrInitFromZstr</span>(<span>&#34;Welcome&#34;</span>);
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;Message: {}&#34;</span>, <span>greeting</span>);

<span>// Primitive types (all handled by _Generic)</span>
<span>int</span> <span>number</span> <span>=</span> <span>42</span>;
<span>float</span> <span>pi</span> <span>=</span> <span>3.14f</span>;
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;Number: {}, Pi: {.2}&#34;</span>, <span>number</span>, <span>pi</span>);</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="// For constant strings, use const char* pointers:
const char* program_name = &#34;MyApp&#34;;      // ✅ const char* works perfectly!
const char* version = &#34;1.0.0&#34;;           // ✅ char* pointer types work!

// For dynamic strings, use Str objects or char* pointers:
Str user_input = StrInit();
StrReadFmt(input_line, &#34;Name: {}&#34;, user_input);

char* allocated = malloc(100);
strcpy(allocated, &#34;Dynamic content&#34;);
StrWriteFmt(&amp;message, &#34;Content: {}&#34;, allocated);     // ✅ char* works!

// For function parameters accepting strings:
void log_message(const char* msg) {                      // ✅ const char* parameter
    StrWriteFmt(&amp;log_output, &#34;[LOG] {}&#34;, msg);       // ✅ Works perfectly!
}

void process_buffer(char* buffer) {                      // ✅ char* parameter  
    StrWriteFmt(&amp;output, &#34;Processing: {}&#34;, buffer);  // ✅ Works great!
}"><pre><span>// For constant strings, use const char* pointers:</span>
<span>const</span> <span>char</span><span>*</span> <span>program_name</span> <span>=</span> <span>&#34;MyApp&#34;</span>;      <span>// ✅ const char* works perfectly!</span>
<span>const</span> <span>char</span><span>*</span> <span>version</span> <span>=</span> <span>&#34;1.0.0&#34;</span>;           <span>// ✅ char* pointer types work!</span>

<span>// For dynamic strings, use Str objects or char* pointers:</span>
<span>Str</span> <span>user_input</span> <span>=</span> <span>StrInit</span>();
<span>StrReadFmt</span>(<span>input_line</span>, <span>&#34;Name: {}&#34;</span>, <span>user_input</span>);

<span>char</span><span>*</span> <span>allocated</span> <span>=</span> <span>malloc</span>(<span>100</span>);
<span>strcpy</span>(<span>allocated</span>, <span>&#34;Dynamic content&#34;</span>);
<span>StrWriteFmt</span>(<span>&amp;</span><span>message</span>, <span>&#34;Content: {}&#34;</span>, <span>allocated</span>);     <span>// ✅ char* works!</span>

<span>// For function parameters accepting strings:</span>
<span>void</span> <span>log_message</span>(<span>const</span> <span>char</span><span>*</span> <span>msg</span>) {                      <span>// ✅ const char* parameter</span>
    <span>StrWriteFmt</span>(<span>&amp;</span><span>log_output</span>, <span>&#34;[LOG] {}&#34;</span>, <span>msg</span>);       <span>// ✅ Works perfectly!</span>
}

<span>void</span> <span>process_buffer</span>(<span>char</span><span>*</span> <span>buffer</span>) {                      <span>// ✅ char* parameter  </span>
    <span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;Processing: {}&#34;</span>, <span>buffer</span>);  <span>// ✅ Works great!</span>
}</pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">🔧 Technical Explanation</h4><a id="user-content--technical-explanation" aria-label="Permalink: 🔧 Technical Explanation" href="#-technical-explanation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The macro-tricks use <code>_Generic</code> which only handles these specific types:</p>
<ul dir="auto">
<li><code>const char*</code> ✅</li>
<li><code>char*</code> ✅</li>
<li><code>Str</code> ✅</li>
<li>Primitive types (<code>int</code>, <code>float</code>, <code>u32</code>, etc.) ✅</li>
</ul>
<p dir="auto">But <strong>NOT</strong> array types like:</p>
<ul dir="auto">
<li><code>char[6]</code> (from <code>&#34;hello&#34;</code>) ❌</li>
<li><code>char[20]</code> (from <code>char buffer[20]</code>) ❌</li>
<li><code>const char[10]</code> (from <code>const char arr[] = &#34;test&#34;</code>) ❌</li>
</ul>
<p dir="auto">The compiler knows these array types perfectly, but <code>_Generic</code> doesn&#39;t have cases for every possible array size.</p>

<p dir="auto">If no specifier is provided (just <code>{}</code>), default formatting is used.</p>

<p dir="auto">Format specifiers can include the following components, which can be combined:</p>

<p dir="auto">Controls text alignment within a field width:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Specifier</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;</code></td>
<td>Left-aligned (pad on the right)</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>Right-aligned (pad on the left) - default</td>
</tr>
<tr>
<td><code>^</code></td>
<td>Center-aligned (pad on both sides)</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">This is also used to control the endianness of raw data read or written.</p>

<p dir="auto">Specifies the minimum field width. The value is padded with spaces if it&#39;s shorter than this width:</p>
<div dir="auto" data-snippet-clipboard-copy-content="{}    // Minimum width of 5 characters, right-aligned
{&lt;5}   // Minimum width of 5 characters, left-aligned
{^5}   // Minimum width of 5 characters, center-aligned"><pre>{}    <span>// Minimum width of 5 characters, right-aligned</span>
{<span>&lt;</span><span>5</span>}   <span>// Minimum width of 5 characters, left-aligned</span>
{^<span>5</span>}   <span>// Minimum width of 5 characters, center-aligned</span></pre></div>

<p dir="auto">The endianness specified is used to convert the read data to native endian after reading
in specified endianness format.</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Specifier</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;</code></td>
<td>Little Endian (Least significant byte first)</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>Big Endian (Most significant byte first, default)</td>
</tr>
<tr>
<td><code>^</code></td>
<td>Native Endian (Same as host endianness)</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">Much like how alignment is specified, width of data read can also be specified in bytes.</p>
<div dir="auto" data-snippet-clipboard-copy-content="{4}    // Read/Write 4 bytes in big endian order.
{&gt;4}   // Read/Write 4 bytes in big endian order.
{&lt;2}   // Read/Write 2 bytes in little endian order.
{^8}   // Read/Write 8 bytes in native endian"><pre>{<span>4</span>}    <span>// Read/Write 4 bytes in big endian order.</span>
{<span>&gt;</span><span>4</span>}   <span>// Read/Write 4 bytes in big endian order.</span>
{<span>&lt;</span><span>2</span>}   <span>// Read/Write 2 bytes in little endian order.</span>
{^<span>8</span>}   <span>// Read/Write 8 bytes in native endian</span></pre></div>

<p dir="auto">Specifies the output format for the value:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Specifier</th>
<th>Description</th>
<th>Example Output</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x</code></td>
<td>Hexadecimal format (lowercase)</td>
<td><code>0xdeadbeef</code></td>
</tr>
<tr>
<td><code>X</code></td>
<td>Hexadecimal format (uppercase)</td>
<td><code>0xDEADBEEF</code></td>
</tr>
<tr>
<td><code>b</code></td>
<td>Binary format</td>
<td><code>0b10100101</code></td>
</tr>
<tr>
<td><code>o</code></td>
<td>Octal format</td>
<td><code>0o777</code></td>
</tr>
<tr>
<td><code>c</code></td>
<td>Character format (preserve case)</td>
<td>Raw character bytes</td>
</tr>
<tr>
<td><code>a</code></td>
<td>Character format (force lowercase)</td>
<td>Converts characters to lowercase</td>
</tr>
<tr>
<td><code>A</code></td>
<td>Character format (force uppercase)</td>
<td>Converts characters to uppercase</td>
</tr>
<tr>
<td><code>r</code></td>
<td>Raw data reading or writing</td>
<td><code>\x7fELF</code> (magic bytes of an elf file)</td>
</tr>
<tr>
<td><code>e</code></td>
<td>Scientific notation (lowercase)</td>
<td><code>1.235e+02</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td>Scientific notation (uppercase)</td>
<td><code>1.235E+02</code></td>
</tr>
<tr>
<td><code>s</code></td>
<td>Read a string in single quotes or double quotes, or a single word</td>
<td><code>&#34;this is a string&#34;</code>, <code>&#39;this as well&#39;</code>, <code>this not a string</code></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>

<p dir="auto">For floating-point values, specifies the number of decimal places:</p>
<div dir="auto" data-snippet-clipboard-copy-content="{.2}   // Two decimal places
{.0}   // No decimal places
{.10}  // Ten decimal places"><pre>{<span>.2</span>}   <span>// Two decimal places</span>
{<span>.0</span>}   <span>// No decimal places</span>
{<span>.10</span>}  <span>// Ten decimal places</span></pre></div>
<p dir="auto">Precision is ignored if specified when reading/writing raw data.</p>


<div dir="auto" data-snippet-clipboard-copy-content="// Correct usage with const char*
const char* greeting = &#34;Hello&#34;;
const char* subject = &#34;world&#34;;
StrWriteFmt(&amp;output, &#34;{}, {}!&#34;, greeting, subject);  // &#34;Hello, world!&#34;

// Escaped braces
StrWriteFmt(&amp;output, &#34;{{Hello}}&#34;);  // &#34;{Hello}&#34;"><pre><span>// Correct usage with const char*</span>
<span>const</span> <span>char</span><span>*</span> <span>greeting</span> <span>=</span> <span>&#34;Hello&#34;</span>;
<span>const</span> <span>char</span><span>*</span> <span>subject</span> <span>=</span> <span>&#34;world&#34;</span>;
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{}, {}!&#34;</span>, <span>greeting</span>, <span>subject</span>);  <span>// &#34;Hello, world!&#34;</span>

<span>// Escaped braces</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{{Hello}}&#34;</span>);  <span>// &#34;{Hello}&#34;</span></pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="const char* str = &#34;Hello&#34;;  // const char* variable

// Basic string
StrWriteFmt(&amp;output, &#34;{}&#34;, str);  // &#34;Hello&#34;

// String with width and alignment
StrWriteFmt(&amp;output, &#34;{&gt;10}&#34;, str);  // &#34;     Hello&#34;
StrWriteFmt(&amp;output, &#34;{&lt;10}&#34;, str);  // &#34;Hello     &#34;
StrWriteFmt(&amp;output, &#34;{^10}&#34;, str);  // &#34;  Hello   &#34;"><pre><span>const</span> <span>char</span><span>*</span> <span>str</span> <span>=</span> <span>&#34;Hello&#34;</span>;  <span>// const char* variable</span>

<span>// Basic string</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{}&#34;</span>, <span>str</span>);  <span>// &#34;Hello&#34;</span>

<span>// String with width and alignment</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{&gt;10}&#34;</span>, <span>str</span>);  <span>// &#34;     Hello&#34;</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{&lt;10}&#34;</span>, <span>str</span>);  <span>// &#34;Hello     &#34;</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{^10}&#34;</span>, <span>str</span>);  <span>// &#34;  Hello   &#34;</span></pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="i32 val = 42;

// Default decimal
StrWriteFmt(&amp;output, &#34;{}&#34;, val);  // &#34;42&#34;

// Hexadecimal
u32 hex_val = 0xDEADBEEF;
StrWriteFmt(&amp;output, &#34;{}&#34;, hex_val);  // &#34;0xdeadbeef&#34;
StrWriteFmt(&amp;output, &#34;{}&#34;, hex_val);  // &#34;0xDEADBEEF&#34;

// Binary
u8 bin_val = 0xA5;  // 10100101 in binary
StrWriteFmt(&amp;output, &#34;{}&#34;, bin_val);  // &#34;0b10100101&#34;

// Octal
u16 oct_val = 0777;
StrWriteFmt(&amp;output, &#34;{}&#34;, oct_val);  // &#34;0o777&#34;

// Width and alignment with numbers
StrWriteFmt(&amp;output, &#34;{}&#34;, val);   // &#34;   42&#34; (right-aligned)
StrWriteFmt(&amp;output, &#34;{&lt;5}&#34;, val);  // &#34;42   &#34; (left-aligned)
StrWriteFmt(&amp;output, &#34;{^5}&#34;, val);  // &#34; 42  &#34; (center-aligned)"><pre><span>i32</span> <span>val</span> <span>=</span> <span>42</span>;

<span>// Default decimal</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{}&#34;</span>, <span>val</span>);  <span>// &#34;42&#34;</span>

<span>// Hexadecimal</span>
<span>u32</span> <span>hex_val</span> <span>=</span> <span>0xDEADBEEF</span>;
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{}&#34;</span>, <span>hex_val</span>);  <span>// &#34;0xdeadbeef&#34;</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{}&#34;</span>, <span>hex_val</span>);  <span>// &#34;0xDEADBEEF&#34;</span>

<span>// Binary</span>
<span>u8</span> <span>bin_val</span> <span>=</span> <span>0xA5</span>;  <span>// 10100101 in binary</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{}&#34;</span>, <span>bin_val</span>);  <span>// &#34;0b10100101&#34;</span>

<span>// Octal</span>
<span>u16</span> <span>oct_val</span> <span>=</span> <span>0777</span>;
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{}&#34;</span>, <span>oct_val</span>);  <span>// &#34;0o777&#34;</span>

<span>// Width and alignment with numbers</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{}&#34;</span>, <span>val</span>);   <span>// &#34;   42&#34; (right-aligned)</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{&lt;5}&#34;</span>, <span>val</span>);  <span>// &#34;42   &#34; (left-aligned)</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{^5}&#34;</span>, <span>val</span>);  <span>// &#34; 42  &#34; (center-aligned)</span></pre></div>

<p dir="auto">The character format specifiers (<code>c</code>, <code>a</code>, <code>A</code>) work with integer types, treating them as character data:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Single character (u8)
u8 upper_char = &#39;M&#39;;
u8 lower_char = &#39;m&#39;;

StrWriteFmt(&amp;output, &#34;{}&#34;, upper_char);  // &#34;M&#34; (preserve case)
StrWriteFmt(&amp;output, &#34;{}&#34;, upper_char);  // &#34;m&#34; (force lowercase)
StrWriteFmt(&amp;output, &#34;{}&#34;, lower_char);  // &#34;M&#34; (force uppercase)

// Multi-byte integers (interpreted as character sequences)
u16 u16_value = (&#39;A&#39; &lt;&lt; 8) | &#39;B&#39;; // &#34;AB&#34; in big-endian
StrWriteFmt(&amp;output, &#34;{}&#34;, u16_value);  // &#34;AB&#34; (preserve case)
StrWriteFmt(&amp;output, &#34;{}&#34;, u16_value);  // &#34;ab&#34; (force lowercase)
StrWriteFmt(&amp;output, &#34;{}&#34;, u16_value);  // &#34;AB&#34; (force uppercase)

// Works with u32 and u64 as well, treating them as byte sequences
u32 u32_value = (&#39;H&#39; &lt;&lt; 24) | (&#39;i&#39; &lt;&lt; 16) | (&#39;!&#39; &lt;&lt; 8) | &#39;!&#39;;
StrWriteFmt(&amp;output, &#34;{}&#34;, u32_value);  // &#34;Hi!!&#34; (preserve case)
StrWriteFmt(&amp;output, &#34;{}&#34;, u32_value);  // &#34;hi!!&#34; (force lowercase)
StrWriteFmt(&amp;output, &#34;{}&#34;, u32_value);  // &#34;HI!!&#34; (force uppercase)"><pre><span>// Single character (u8)</span>
<span>u8</span> <span>upper_char</span> <span>=</span> <span>&#39;M&#39;</span>;
<span>u8</span> <span>lower_char</span> <span>=</span> <span>&#39;m&#39;</span>;

<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{}&#34;</span>, <span>upper_char</span>);  <span>// &#34;M&#34; (preserve case)</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{}&#34;</span>, <span>upper_char</span>);  <span>// &#34;m&#34; (force lowercase)</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{}&#34;</span>, <span>lower_char</span>);  <span>// &#34;M&#34; (force uppercase)</span>

<span>// Multi-byte integers (interpreted as character sequences)</span>
<span>u16</span> <span>u16_value</span> <span>=</span> (<span>&#39;A&#39;</span> &lt;&lt; <span>8</span>) | <span>&#39;B&#39;</span>; <span>// &#34;AB&#34; in big-endian</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{}&#34;</span>, <span>u16_value</span>);  <span>// &#34;AB&#34; (preserve case)</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{}&#34;</span>, <span>u16_value</span>);  <span>// &#34;ab&#34; (force lowercase)</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{}&#34;</span>, <span>u16_value</span>);  <span>// &#34;AB&#34; (force uppercase)</span>

<span>// Works with u32 and u64 as well, treating them as byte sequences</span>
<span>u32</span> <span>u32_value</span> <span>=</span> (<span>&#39;H&#39;</span> &lt;&lt; <span>24</span>) | (<span>&#39;i&#39;</span> &lt;&lt; <span>16</span>) | (<span>&#39;!&#39;</span> &lt;&lt; <span>8</span>) | <span>&#39;!&#39;</span>;
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{}&#34;</span>, <span>u32_value</span>);  <span>// &#34;Hi!!&#34; (preserve case)</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{}&#34;</span>, <span>u32_value</span>);  <span>// &#34;hi!!&#34; (force lowercase)</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{}&#34;</span>, <span>u32_value</span>);  <span>// &#34;HI!!&#34; (force uppercase)</span></pre></div>

<p dir="auto">Character format specifiers also work with strings:</p>
<div dir="auto" data-snippet-clipboard-copy-content="const char* mixed_case = &#34;MiXeD CaSe&#34;;

StrWriteFmt(&amp;output, &#34;{}&#34;, mixed_case);  // &#34;MiXeD CaSe&#34; (preserve case)
StrWriteFmt(&amp;output, &#34;{}&#34;, mixed_case);  // &#34;mixed case&#34; (force lowercase)
StrWriteFmt(&amp;output, &#34;{}&#34;, mixed_case);  // &#34;MIXED CASE&#34; (force uppercase)

// Also works with Str objects
Str s = StrInitFromZstr(&#34;Hello World&#34;);
StrWriteFmt(&amp;output, &#34;{}&#34;, s);  // &#34;hello world&#34;
StrWriteFmt(&amp;output, &#34;{}&#34;, s);  // &#34;HELLO WORLD&#34;"><pre><span>const</span> <span>char</span><span>*</span> <span>mixed_case</span> <span>=</span> <span>&#34;MiXeD CaSe&#34;</span>;

<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{}&#34;</span>, <span>mixed_case</span>);  <span>// &#34;MiXeD CaSe&#34; (preserve case)</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{}&#34;</span>, <span>mixed_case</span>);  <span>// &#34;mixed case&#34; (force lowercase)</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{}&#34;</span>, <span>mixed_case</span>);  <span>// &#34;MIXED CASE&#34; (force uppercase)</span>

<span>// Also works with Str objects</span>
<span>Str</span> <span>s</span> <span>=</span> <span>StrInitFromZstr</span>(<span>&#34;Hello World&#34;</span>);
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{}&#34;</span>, <span>s</span>);  <span>// &#34;hello world&#34;</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{}&#34;</span>, <span>s</span>);  <span>// &#34;HELLO WORLD&#34;</span></pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">Floating-Point Formatting</h4><a id="user-content-floating-point-formatting" aria-label="Permalink: Floating-Point Formatting" href="#floating-point-formatting"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="f64 pi = 3.14159265359;

// Default precision (6 decimal places)
StrWriteFmt(&amp;output, &#34;{}&#34;, pi);  // &#34;3.141593&#34;

// Custom precision
StrWriteFmt(&amp;output, &#34;{.2}&#34;, pi);   // &#34;3.14&#34;
StrWriteFmt(&amp;output, &#34;{.0}&#34;, pi);   // &#34;3&#34;
StrWriteFmt(&amp;output, &#34;{.10}&#34;, pi);  // &#34;3.1415926536&#34;

// Scientific notation
StrWriteFmt(&amp;output, &#34;{}&#34;, 123.456);  // &#34;1.235e+02&#34;
StrWriteFmt(&amp;output, &#34;{}&#34;, 123.456);  // &#34;1.235E+02&#34;

// Custom precision with scientific notation
StrWriteFmt(&amp;output, &#34;{.3e}&#34;, 123.456);  // &#34;1.235e+02&#34;

// Special values
f64 pos_inf = INFINITY;
f64 neg_inf = -INFINITY;
f64 nan_val = NAN;
StrWriteFmt(&amp;output, &#34;{}&#34;, pos_inf);  // &#34;inf&#34;
StrWriteFmt(&amp;output, &#34;{}&#34;, neg_inf);  // &#34;-inf&#34;
StrWriteFmt(&amp;output, &#34;{}&#34;, nan_val);  // &#34;nan&#34;"><pre><span>f64</span> <span>pi</span> <span>=</span> <span>3.14159265359</span>;

<span>// Default precision (6 decimal places)</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{}&#34;</span>, <span>pi</span>);  <span>// &#34;3.141593&#34;</span>

<span>// Custom precision</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{.2}&#34;</span>, <span>pi</span>);   <span>// &#34;3.14&#34;</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{.0}&#34;</span>, <span>pi</span>);   <span>// &#34;3&#34;</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{.10}&#34;</span>, <span>pi</span>);  <span>// &#34;3.1415926536&#34;</span>

<span>// Scientific notation</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{}&#34;</span>, <span>123.456</span>);  <span>// &#34;1.235e+02&#34;</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{}&#34;</span>, <span>123.456</span>);  <span>// &#34;1.235E+02&#34;</span>

<span>// Custom precision with scientific notation</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{.3e}&#34;</span>, <span>123.456</span>);  <span>// &#34;1.235e+02&#34;</span>

<span>// Special values</span>
<span>f64</span> <span>pos_inf</span> <span>=</span> <span>INFINITY</span>;
<span>f64</span> <span>neg_inf</span> <span>=</span> <span>-</span><span>INFINITY</span>;
<span>f64</span> <span>nan_val</span> <span>=</span> <span>NAN</span>;
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{}&#34;</span>, <span>pos_inf</span>);  <span>// &#34;inf&#34;</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{}&#34;</span>, <span>neg_inf</span>);  <span>// &#34;-inf&#34;</span>
<span>StrWriteFmt</span>(<span>&amp;</span><span>output</span>, <span>&#34;{}&#34;</span>, <span>nan_val</span>);  <span>// &#34;nan&#34;</span></pre></div>

<p dir="auto">The library also supports parsing values from strings using the same format specifier syntax:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Reading integers
i32 num = 0;
StrReadFmt(&#34;42&#34;, &#34;{}&#34;, num);  // num = 42

// Reading hexadecimal (auto-detected with 0x prefix)
u32 hex_val = 0;
StrReadFmt(&#34;0xdeadbeef&#34;, &#34;{}&#34;, hex_val);  // hex_val = 0xdeadbeef

// Reading binary (auto-detected with 0b prefix)
i8 bin_val = 0;
StrReadFmt(&#34;0b101010&#34;, &#34;{}&#34;, bin_val);  // bin_val = 42

// Reading octal (auto-detected with 0o prefix)
i32 oct_val = 0;
StrReadFmt(&#34;0o755&#34;, &#34;{}&#34;, oct_val);  // oct_val = 493

// Reading floating point
f64 value = 0.0;
StrReadFmt(&#34;3.14159&#34;, &#34;{}&#34;, value);  // value = 3.14159

// Reading scientific notation
StrReadFmt(&#34;1.23e4&#34;, &#34;{}&#34;, value);  // value = 12300.0

// Reading strings
Str name = StrInit();
StrReadFmt(&#34;Alice&#34;, &#34;{}&#34;, name);  // name = &#34;Alice&#34;

// Reading quoted strings
StrReadFmt(&#34;\&#34;Hello, World!\&#34;&#34;, &#34;{}&#34;, name);  // name = &#34;Hello, World!&#34;

// Reading multiple values
i32 count = 0;
Str user = StrInit();
StrReadFmt(&#34;Count: 42, Name: Alice&#34;, &#34;Count: {}, Name: {}&#34;, count, user);
// count = 42, user = &#34;Alice&#34;"><pre><span>// Reading integers</span>
<span>i32</span> <span>num</span> <span>=</span> <span>0</span>;
<span>StrReadFmt</span>(<span>&#34;42&#34;</span>, <span>&#34;{}&#34;</span>, <span>num</span>);  <span>// num = 42</span>

<span>// Reading hexadecimal (auto-detected with 0x prefix)</span>
<span>u32</span> <span>hex_val</span> <span>=</span> <span>0</span>;
<span>StrReadFmt</span>(<span>&#34;0xdeadbeef&#34;</span>, <span>&#34;{}&#34;</span>, <span>hex_val</span>);  <span>// hex_val = 0xdeadbeef</span>

<span>// Reading binary (auto-detected with 0b prefix)</span>
<span>i8</span> <span>bin_val</span> <span>=</span> <span>0</span>;
<span>StrReadFmt</span>(<span>&#34;0b101010&#34;</span>, <span>&#34;{}&#34;</span>, <span>bin_val</span>);  <span>// bin_val = 42</span>

<span>// Reading octal (auto-detected with 0o prefix)</span>
<span>i32</span> <span>oct_val</span> <span>=</span> <span>0</span>;
<span>StrReadFmt</span>(<span>&#34;0o755&#34;</span>, <span>&#34;{}&#34;</span>, <span>oct_val</span>);  <span>// oct_val = 493</span>

<span>// Reading floating point</span>
<span>f64</span> <span>value</span> <span>=</span> <span>0.0</span>;
<span>StrReadFmt</span>(<span>&#34;3.14159&#34;</span>, <span>&#34;{}&#34;</span>, <span>value</span>);  <span>// value = 3.14159</span>

<span>// Reading scientific notation</span>
<span>StrReadFmt</span>(<span>&#34;1.23e4&#34;</span>, <span>&#34;{}&#34;</span>, <span>value</span>);  <span>// value = 12300.0</span>

<span>// Reading strings</span>
<span>Str</span> <span>name</span> <span>=</span> <span>StrInit</span>();
<span>StrReadFmt</span>(<span>&#34;Alice&#34;</span>, <span>&#34;{}&#34;</span>, <span>name</span>);  <span>// name = &#34;Alice&#34;</span>

<span>// Reading quoted strings</span>
<span>StrReadFmt</span>(<span>&#34;\&#34;Hello, World!\&#34;&#34;</span>, <span>&#34;{}&#34;</span>, <span>name</span>);  <span>// name = &#34;Hello, World!&#34;</span>

<span>// Reading multiple values</span>
<span>i32</span> <span>count</span> <span>=</span> <span>0</span>;
<span>Str</span> <span>user</span> <span>=</span> <span>StrInit</span>();
<span>StrReadFmt</span>(<span>&#34;Count: 42, Name: Alice&#34;</span>, <span>&#34;Count: {}, Name: {}&#34;</span>, <span>count</span>, <span>user</span>);
<span>// count = 42, user = &#34;Alice&#34;</span></pre></div>

<p dir="auto">The library provides several I/O functions for formatted reading and writing:</p>
<ul dir="auto">
<li><code>StrWriteFmt(&amp;str, format, ...)</code>: Append formatted output to a string</li>
<li><code>StrReadFmt(input, format, ...)</code>: Parse values from a string</li>
<li><code>FWriteFmt(file, format, ...)</code>: Write formatted output to a file</li>
<li><code>FWriteFmtLn(file, format, ...)</code>: Write formatted output to a file with a newline</li>
<li><code>FReadFmt(file, format, ...)</code>: Read formatted input from a file</li>
<li><code>WriteFmt(format, ...)</code>: Write formatted output to stdout</li>
<li><code>WriteFmtLn(format, ...)</code>: Write formatted output to stdout with a newline</li>
<li><code>ReadFmt(format, ...)</code>: Read formatted input from stdin</li>
</ul>

<p dir="auto">Contributions are welcome! Please feel free to submit a Pull Request.</p>
<ol dir="auto">
<li>Fork the repository</li>
<li>Create your feature branch (<code>git checkout -b feature/amazing-feature</code>)</li>
<li>Commit your changes (<code>git commit -m &#39;Add some amazing feature&#39;</code>)</li>
<li>Push to the branch (<code>git push origin feature/amazing-feature</code>)</li>
<li>Open a Pull Request</li>
</ol>

<p dir="auto">This project is dedicated to the public domain under the <a href="https://github.com/brightprogrammer/MisraStdC/blob/master/LICENSE.md">Unlicense</a>.</p>
<p dir="auto">This means you are free to:</p>
<ul dir="auto">
<li>Use the code for any purpose</li>
<li>Change the code in any way</li>
<li>Share the code with anyone</li>
<li>Distribute the code</li>
<li>Sell the code or derivative works</li>
</ul>
<p dir="auto">No attribution is required. See the <a href="https://github.com/brightprogrammer/MisraStdC/blob/master/LICENSE.md">LICENSE.md</a> file for details.</p>
</article></div></div>
  </body>
</html>
