<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://melatonin.dev/blog/audio-sparklines/">Original</a>
    <h1>Audio Sparklines</h1>
    
    <div id="readability-page-1" class="page"><article id="post-7">

	<!-- .entry-header -->

	<div>
		
<p><a href="https://github.com/sudara/melatonin_audio_sparklines">Check out the JUCE and lldb implementation on GitHub.</a></p>



<h2>What’s the problem?</h2>



<p>I keep running into situations where I’d like to be able to “see” what my various buffers and blocks of audio look like. </p>



<p>Usually I want to answer one or more of the following:</p>



<ul><li>Is there a signal present?</li><li>Is it sinusoidal?</li><li>How many cycles are there?</li><li>Is all or part of an audio buffer empty?</li><li>Are there discontinuities or values out of bounds?</li></ul>



<p>Ideally, I could peek at the waveform of whatever buffer I’m working with, on the fly. However, I’m not always working in a UI context. For example, I might be writing tests for an audio engine and just trying to figure out what’s even in the buffer.</p>



<p>One can always write a bunch of float values to the console, but humans don’t parse thousands of float values well. Have fun counting those zero crossings…</p>



<h2>Sparklines would be pretty cool…</h2>



<p>I’m a big <a href="https://www.edwardtufte.com/tufte/">Edward Tufte</a> fan. One of the things he champions is “data-intense, design-simple, word-sized graphics” which he calls <a href="https://en.wikipedia.org/wiki/Sparkline">sparklines</a>.</p>



<p>At a glance, they convey general characteristics about a data series. Individual data points are not relevant, only the trend is.</p>



<figure><img loading="lazy" src="https://melatonin.dev/wp-content/uploads/2022/01/640px-Sparkline_dowjones_new.svg_.png" alt="" width="320" height="39"/><figcaption>Example sparkline by <a href="https://commons.wikimedia.org/wiki/File:Sparkline_dowjones_new.svg">Kmf164</a></figcaption></figure>



<h2>Sparklines in Unicode?</h2>



<p>So, uhh… can I make sparkline graphs of my audio buffers with unicode? </p>



<p>Not only does unicode have <a href="https://en.wikipedia.org/wiki/Block_Elements">block elements</a> (▁▂▃▄▅▆▇█) but apparently there are <a href="https://rosettacode.org/wiki/Sparkline_in_unicode">people using these elements to make sparkline bar graphs</a>! </p>



<p>However, block elements are bottom aligned instead of center aligned. So they won’t really work to display an audio waveform.</p>



<h2>Audio Sparklines</h2>



<p>The best solution I found was to pick 7 horizontal line symbols to represent the waveform:</p>



<pre><code>_⎽⎼—⎻⎺‾</code></pre>



<p>Yup, we’re decimating the audio down to 3 bits.</p>



<p>We’ll also add the following features to the sparkline:</p>



<pre><code>0 is a true 0
0(234) shows a chunk of zeros, in this case 234
x represents a zero crossing
E is out of bounds (below -1.0, above 1.0)
I = Inf (Infinity, meaning you&#39;ve divided by zero)
N = NaN (undefined calculation that&#39;s not INF)
S = Subnormal detected</code></pre>



<p>Here’s 2 cycles of a healthy sine wave, with every sample represented:</p>



<pre><code>[0———⎻⎻⎻⎻⎻⎻⎻‾‾‾‾‾‾‾‾⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺‾‾‾‾‾‾‾‾‾⎻⎻⎻⎻⎻⎻⎻———x——⎼⎼⎼⎼⎼⎼⎼⎽⎽⎽⎽⎽⎽⎽⎽⎽____________________________________⎽⎽⎽⎽⎽⎽⎽⎼⎼⎼⎼⎼⎼⎼————x——⎻⎻⎻⎻⎻⎻⎻‾‾‾‾‾‾‾‾⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺‾‾‾‾‾‾‾‾‾⎻⎻⎻⎻⎻⎻⎻———x——⎼⎼⎼⎼⎼⎼⎼⎽⎽⎽⎽⎽⎽⎽⎽⎽____________________________________⎽⎽⎽⎽⎽⎽⎽⎽⎼⎼⎼⎼⎼⎼⎼———]</code></pre>



<p>Cool! It’s bulky and elongated, but allllllllllmost visually parseable…</p>



<h2>Cleaning them up</h2>



<p>To do Tufte right, we need to increase the data density. Collapsing redundant data leaves us with the “trend.” We can also add metadata to notate the scale, both in duration and amplitude.</p>



<pre><code>[0⎻⎺‾⎺⎻x—⎼⎽_⎽⎼—x⎻⎺‾⎺⎻x—⎼⎽_⎽⎼—] 294 samples (-0.999 to 0.999)</code></pre>



<p>This is useful:</p>



<ul><li>We can visually identify 2 healthy cycles.</li><li>We know the first value is zero.</li><li>It looks sinusoidal</li><li>We know there are 294 samples in total</li><li>We know the amplitude ranges from -0.999 to 0.999.</li></ul>



<h2>More complex audio sparkline</h2>



<p>Here’s an example of a block going out of audio bounds (-1.0 to 1.0).</p>



<pre><code>Block is 1 channel, 1024 samples, min -1.76012, max 1.76013, 77.14% filled
[0⎻⎺⎻x—x⎻x—⎼⎽_E_⎽⎼—x⎻⎺‾E‾⎺⎻x—⎼—x⎻⎺⎻x—⎼⎽_E_⎽⎼—0⎻⎺‾E‾⎺⎻x—⎼—x⎻⎺⎻x—⎼⎽_E_⎽⎼—0(234)]</code></pre>



<ul><li><span>This </span><em>looks</em><span> sinusoidal</span></li><li> We can visually see it’s going out of bounds at the positive and negative peaks. The summary tells us we are hitting values of +/- 1.76</li><li>We see a big chunk of <strong>234</strong><span> consecutive zeros at the end of the block</span>.</li></ul>



<h2>Normalizing the sparklines</h2>



<p>To ensure visible trends on quieter segments, we can normalize before displaying.</p>



<p>Before normalization, a quieter signal might look like so:</p>



<pre><code>Block is 1 channel, 128 samples, min -0.0951679, max 0.11609, 50.7812% filled
[—x—0(64)]</code></pre>



<p>This is….cryptic and not info dense. With normalization:</p>



<pre><code>Block is 1 channel, 128 samples, min -0.0951679, max 0.11609, 50.7812% filled
[‾⎺⎻—x—⎼⎽_0(64)]</code></pre>



<p>Now we can see the shape of the waveform and look to the metadata for the scale.</p>



<h2>Sparklines in Tests</h2>



<p>I wrote some <a href="https://github.com/sudara/melatonin_audio_block_test_helpers">custom Catch2 matchers </a>to test JUCE <code>AudioBlocks</code>. They spit out sparklines on test failure:</p>



<pre><code>REQUIRE_THAT(myAudioBlock, isEqualTo (someOtherBlock))
with expansion:

Block is 1 channel, 480 samples, min -0.766242, max 0.289615, 100% filled
[0—⎻—x—⎼⎽_⎽⎼—]
 is equal to 
Block is 1 channel, 480 samples, min -1, max 1, 100% filled
[0—⎻⎺‾⎺⎻—x—⎼⎽_⎽⎼—]</code></pre>



<h2>Sparklines in the Debugger</h2>



<p>The holy grail: Can we dynamically inspect blocks of audio in the debugger?</p>



<p>Answer. Yes. I wrote an <a href="https://github.com/sudara/melatonin_audio_sparklines#teach-lldb-how-to-output-sparklines">lldb python script</a> to summarize and display sparklines for JUCE’s AudioBlocks. </p>



<p>It works in any IDE with an lldb backend, such as Xcode or CLion. </p>



<p>A summary shows up on hover:</p>



<figure><img loading="lazy" width="1556" height="198" src="https://melatonin.dev/wp-content/uploads/2021/10/image-1.jpeg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2021/10/image-1.jpeg 1556w, https://melatonin.dev/wp-content/uploads/2021/10/image-1-600x76.jpeg 600w" sizes="(max-width: 1556px) 100vw, 1556px"/></figure>



<p>Clicking the summary shows you each channel’s sparkline and gives you access to the float values</p>



<figure><img loading="lazy" width="2224" height="556" src="https://melatonin.dev/wp-content/uploads/2021/10/image.jpeg" alt="" srcset="https://melatonin.dev/wp-content/uploads/2021/10/image.jpeg 2224w, https://melatonin.dev/wp-content/uploads/2021/10/image-600x150.jpeg 600w" sizes="(max-width: 2224px) 100vw, 2224px"/></figure>



<h2><em><strong>Voilà</strong></em>!</h2>



<p><a href="https://github.com/sudara/melatonin_audio_sparklines">Check out the JUCE and lldb implementation on GitHub.</a></p>
	</div><!-- .entry-content -->

	<!-- .entry-footer -->

				
</article></div>
  </body>
</html>
