<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fuchsia.dev/fuchsia-src/concepts/fidl/overview">Original</a>
    <h1>Fuchsia IDL Overview</h1>
    
    <div id="readability-page-1" class="page"><div>

    
      
<!-- original source of this page: https://cs.opensource.google/fuchsia/fuchsia/+/main:docs/concepts/fidl/overview.md -->

<!-- The header above is automatically added to this file. Do not modify anything above this line. -->



<p>This document is a high level overview of the Fuchsia Interface Definition
Language (FIDL), which is the language used to describe interprocess
communication (IPC) protocols used by programs running on Fuchsia. This overview
introduces the concepts behind FIDL — developers familiar with these concepts
already can start writing code by following the <a href="https://chanind.github.io/docs/development/languages/fidl/tutorials/overview">tutorials</a>, or
dive deeper by reading the <a href="https://chanind.github.io/docs/reference/fidl/language/language">language</a> or
<a href="https://chanind.github.io/docs/reference/fidl/bindings/overview">bindings</a> references.</p>

<h2 id="what_is_fidl" data-text="What is FIDL?">What is FIDL?</h2>

<p>While &#34;<strong>FIDL</strong>&#34; stands for &#34;Fuchsia Interface Definition Language,&#34; the word
itself can be used to refer to a number of different concepts:</p>

<ul>
<li><a href="https://chanind.github.io/docs/reference/fidl/language/wire-format"><strong>FIDL wire format</strong></a>: the FIDL wire format specifies how FIDL
messages are represented in memory for transmission over IPC</li>
<li><a href="https://chanind.github.io/docs/reference/fidl/language/language"><strong>FIDL language</strong></a>: the FIDL language is the syntax by which
protocols are described in <code translate="no" dir="ltr">.fidl</code> files</li>
<li><a href="https://chanind.github.io/docs/development/languages/fidl/guides"><strong>FIDL compiler</strong></a>: the FIDL compiler generates code for
programs to use and implement protocols</li>
<li><a href="https://chanind.github.io/docs/reference/fidl/bindings/overview"><strong>FIDL bindings</strong></a>: the FIDL bindings are
language-specific runtime support libraries and code generators that provide
APIs for manipulating FIDL data structures and protocols.</li>
</ul>

<p>The main job of FIDL is to allow diverse clients and services to interoperate.
Client diversity is aided by decoupling the implementation of the IPC mechanism
from its definition, and is simplified by automatic code generation.</p>

<p>The FIDL language provides a familiar (though simplified) C-like declaration
syntax that allows the service provider to exactly define their protocols. Basic
data types, like integers, floats, and strings, can be organized into more
complex aggregate structures and unions. Fixed arrays and dynamically sized
vectors can be constructed from both the basic types and the aggregate types,
and these can all be combined into even more complex data structures.</p>

<p>Due to the number of client implementation target languages (C, C++, Rust, Dart,
and so on), we don&#39;t want to burden the developer of the service with providing
a protocol implementation for each and every one.</p>

<p>This is where the FIDL toolchain comes in. The developer of the service creates
just one <code translate="no" dir="ltr">.fidl</code> definition file, which defines the protocol. Using this file,
the FIDL compiler then generates client and server code in any of the supported
target languages.</p>

<p><img src="https://chanind.github.io/fuchsia-src/concepts/fidl/images/fidl_architecture.png" alt="Figure: server written in C++ talks to clients written in multiple
languages"/></p>

<p>In many cases, there will only be one implementation of the server (for example,
the particular service might be implemented in C++), whereas there could be any
number of implementations of the client, in a multitude of languages.</p>

<blockquote>
<p>Note that the Fuchsia operating system has no innate knowledge of FIDL. The
FIDL bindings use a standard channel communication mechanism in Fuchsia. The
FIDL bindings and libraries enforce a set of semantic behavior and persistence
formats on how that channel is used.</p>
</blockquote>

<h3 id="fidl_architecture" data-text="FIDL architecture">FIDL architecture</h3>

<p>From a developer&#39;s point of view, the following are the main components:</p>

<ul>
<li>FIDL definition file — this is a text file (ending in <code translate="no" dir="ltr">.fidl</code> by
convention) that defines the values, and protocols (methods with their
parameters),</li>
<li>client code — generated by the FIDL compiler (<code translate="no" dir="ltr">fidlc</code>) toolchain for
each specific target language, and</li>
<li>server code — also generated by the FIDL compiler toolchain.</li>
</ul>

<p>As a very simple example of a FIDL definition file, consider an &#34;echo&#34; service
— whatever the client sends to the server, the server just echoes back to
the client.</p>

<blockquote>
<p>Line numbers have been added for clarity and are not part of the <code translate="no" dir="ltr">.fidl</code> file.</p>
</blockquote>
<pre translate="no" dir="ltr"><code translate="no" dir="ltr">1   library fidl.examples.echo;
2
3   @discoverable
4   protocol Echo {
5       EchoString(struct {
6           value string:optional;
7       }) -&gt; (struct {
8           response string:optional;
9       });
10  };
</code></pre>
<p>Let&#39;s go through it line by line.</p>

<p><strong>Line 1:</strong> The <code translate="no" dir="ltr">library</code> keyword is used to define a namespace for this
protocol. FIDL protocols in different libraries might have the same name, so the
namespace is used to distinguish amongst them.</p>

<p><strong>Line 3:</strong> The <code translate="no" dir="ltr">@discoverable</code> <a href="https://chanind.github.io/docs/reference/fidl/language/attributes#discoverable"><strong>attribute</strong></a> indicates that the
protocol that follows should be made available for clients to connect to.</p>

<p><strong>Line 4:</strong> The <code translate="no" dir="ltr">protocol</code> keyword introduces the name of the protocol, here
it&#39;s called <code translate="no" dir="ltr">Echo</code>.</p>

<p><strong>Lines 5-9:</strong> The method, its parameters, and return values. There are two unusual
aspects of this line:</p>

<ul>
<li>Note the declaration <code translate="no" dir="ltr">string:optional</code> (for both <code translate="no" dir="ltr">value</code> and <code translate="no" dir="ltr">response</code>). The
<code translate="no" dir="ltr">string</code> part indicates that the parameters are strings (sequences of
characters), while the <code translate="no" dir="ltr">optional</code> constraint indicates that the parameter is
optional.</li>
<li>The parameters are wrapped in a <code translate="no" dir="ltr">struct</code>, which is the top level type
containing the method parameters.</li>
<li>The <code translate="no" dir="ltr">-&gt;</code> part indicates the return, which appears after the method
declaration, not before. Unlike C++ or Java, a method can return multiple
values.</li>
</ul>

<p>The above FIDL file, then, has declared one protocol, called <code translate="no" dir="ltr">Echo</code>, with one
method, called <code translate="no" dir="ltr">EchoString</code>, that takes a nullable string and returns a nullable
string.</p>

<p>The simple example above used just one data type, the <code translate="no" dir="ltr">string</code> as both the input
to the method as well as the output.</p>

<p>The possible FIDL data types are very flexible:</p>
<pre translate="no" dir="ltr"><code translate="no" dir="ltr">type MyRequest = struct {
    serial uint32;
    key string;
    options vector&lt;uint32&gt;;
};
</code></pre>
<p>The above declares a structure called <code translate="no" dir="ltr">MyRequest</code> with three members: an
unsigned 32-bit integer called <code translate="no" dir="ltr">serial</code>, a string called <code translate="no" dir="ltr">key</code>, and a vector of
unsigned 32-bit integers called <code translate="no" dir="ltr">options</code></p>

<h3 id="messaging_models" data-text="Messaging Models">Messaging Models</h3>

<p>In order to understand FIDL&#39;s messaging, we need to break things up into two
layers, and clarify some definitions.</p>

<p>At the bottom (the operating system layer), there&#39;s an asynchronous
communications scheme geared towards independent progress of a <strong>sender</strong> and a
<strong>receiver</strong>:</p>

<ul>
<li><strong>sender</strong> — the party that originates a message,</li>
<li><strong>receiver</strong> — the party that receives a message,</li>
</ul>

<p>Sending a message is a non-blocking operation: the sender sends the message, and
is then free to continue processing, regardless of what the receiver is doing.</p>

<p>A receiver can, if it wants to, block in order to wait for a message.</p>

<p>The top layer implements FIDL messages, and uses the bottom (asynchronous)
layer. It deals with <strong>client</strong>s and <strong>server</strong>s:</p>

<ul>
<li><strong>client</strong> — the party that is making a request (of a server),</li>
<li><strong>server</strong> — the party that is processing a request (on behalf of a
client).</li>
</ul>

<blockquote>
<p>The terms &#34;sender&#34; and &#34;receiver&#34; make sense when we&#39;re discussing the
messages themselves — the underlying communications scheme isn&#39;t
concerned about the roles that we&#39;ve assigned to the parties, just that one is
sending and one is receiving.</p>

<p>The terms &#34;client&#34; and &#34;server&#34; make sense when we&#39;re discussing the roles
that the parties play. In particular, a client can be a sender at one time,
and a receiver at a different time; same for the server.</p>
</blockquote>

<p>Practically speaking, in the context of a client / server interaction, that
means that there are several models:</p>

<ol>
<li><strong>blocking call</strong> — client sends to server, waits for reply</li>
<li><strong>fire and forget</strong> — client sends to server, doesn&#39;t expect reply</li>
<li><strong>callback</strong> or <strong>async call</strong> — client sends to server, but doesn&#39;t
block; a reply is delivered asynchronously some time later</li>
<li><strong>event</strong> — server sends to client, without the client having asked
for data</li>
</ol>

<p>The first is synchronous, the rest are asynchronous. We&#39;ll discuss these in
order.</p>

<h4 id="client_sends_to_server_waits_for_a_reply" data-text="Client sends to server, waits for a reply">Client sends to server, waits for a reply</h4>

<p>This model is the traditional &#34;blocking call&#34; or &#34;function call&#34; available in
most programming languages, except that the invocation is done over a channel,
and thus can fail due to transport level errors.</p>

<p>From the point of view of the client, it consists of a call that blocks, while
the server performs some processing.</p>

<p><img src="https://chanind.github.io/fuchsia-src/concepts/fidl/images/blocking.png" alt="Figure: client and server"/></p>

<p>Here&#39;s a step-by-step description:</p>

<ol>
<li>A client makes a call (optionally containing data) and blocks.</li>
<li>The server receives the client&#39;s call (and optional data), and performs some
amount of processing.</li>
<li>At the server&#39;s discretion, it replies to the client (with optional data).</li>
<li>The server&#39;s reply causes the client to unblock.</li>
</ol>

<p>To implement this synchronous messaging model over an asynchronous messaging
scheme is simple. Recall that both the client-to-server and server-to-client
message transfers are, at the bottom layer in the protocol, asynchronous. The
synchronization happens at the client end, by having the client block until the
server&#39;s message arrives.</p>

<p>Basically, in this model, the client and server have come to an agreement:</p>

<ul>
<li>data flow is initiated by the client,</li>
<li>the client shall have at most only one message outstanding,</li>
<li>the server shall send a message to the client only in response to a client&#39;s
message</li>
<li>the client shall wait for the server&#39;s response before continuing.</li>
</ul>

<p>This blocking model is commonly used where the client needs to get the reply to
its current request before it can continue.</p>

<p>For example, the client may request data from the server, and not be able to do
any other useful processing until that data arrives.</p>

<p>Or, the client may need to perform steps in a specific order, and must therefore
ensure that each step completes before initiating the next one. If an error
occurs, the client may need to perform corrective actions that depend on how far
the operation has proceeded — another reason to be synchronized to the
completion of each step.</p>

<h4 id="fire-and-forget" transformation="converted" data-text="Client sends to server, no reply">Client sends to server, no reply</h4>

<p>This model is also known as &#34;fire and forget.&#34; In it, the client sends the
message to the server. and then carries on with its operation. In contrast to
the blocking model, the client <em>does not</em> block, <em>nor does it expect a
response</em>.</p>

<p>This model is used in cases where the client doesn&#39;t need to (or cannot)
synchronize to the processing of its request.</p>

<p><img src="https://chanind.github.io/fuchsia-src/concepts/fidl/images/faf.png" alt="Figure: Fire and Forget; client sends to server but doesn&#39;t expect
replies"/></p>

<p>The classic example is a logging system. The client sends logging information to
the logging server (circles &#34;1&#34; and &#34;2&#34; in the diagram above), but has no reason
to block. A lot of things can go wrong at the server end:</p>

<ol>
<li>the server is busy and can&#39;t handle the write request at this moment,</li>
<li>the media is full and the server can&#39;t write the data,</li>
<li>the server has encountered a fault,</li>
<li>and so on.</li>
</ol>

<p>However, the client isn&#39;t in a position to do anything about those problems, so
blocking would just create more problems.</p>

<h4 id="client_sends_to_server_but_doesnt_block" data-text="Client sends to server, but doesn&#39;t block">Client sends to server, but doesn&#39;t block</h4>

<p>This model, and the next one (&#34;server sends to client, without client asking for
data&#34;) are similar.</p>

<p>In the present model, the client sends a message to a server, but doesn&#39;t block.
However, the client expects some kind of response from the server, but the key
here is that it&#39;s not <em>synchronous</em> with the request.</p>

<p>This allows great flexibility in the client / server interaction.</p>

<p>While the synchronous model forces the client to wait until the server replies,
the present model frees the client to do something else while the server is
processing the request:</p>

<p><img src="https://chanind.github.io/fuchsia-src/concepts/fidl/images/async.png" alt="Figure: client sends to server but doesn&#39;t block until later"/></p>

<p>The subtle difference in this diagram vs. the similar one above is that after
circle &#34;1&#34; the client is <em>still running</em>. The client chooses when to give up
CPU; it&#39;s not synchronous with the message.</p>

<p>There are actually two sub-cases here — one in which the client gets just
one response, and another in which the client can get multiple responses. (The
one where the client gets zero responses is the &#34;fire and forget&#34; model, which
we discussed earlier.)</p>

<h5 id="single_request_single_response" data-text="Single request, single response">Single request, single response</h5>

<p>The single response case is the closest to the synchronous model: the client
sends a message, and eventually, the server replies. You&#39;d use this model
instead of multi-threading, for example, when you know that the client could be
doing useful work while waiting for the server&#39;s reply.</p>

<h5 id="single_request_multiple_response" data-text="Single request, multiple response">Single request, multiple response</h5>

<p>The multiple response case can be used in a &#34;subscription&#34; model. The client&#39;s
message &#34;primes&#34; the server, for example, requesting notification whenever
something happens.</p>

<p>The client then goes about its business.</p>

<p>Some time later, the server notices that the condition that the client is
interested in has happened, and thus sends the client a message. From a client /
server point of view, this message is a &#34;reply&#34;, with the client receiving it
asynchronously to its request.</p>

<p><img src="https://chanind.github.io/fuchsia-src/concepts/fidl/images/async-multiple.png" alt="Figure: client sends to server, server replies multiple
times"/></p>

<p>There&#39;s no reason why the server couldn&#39;t send another message when another
event of interest occurs; this is the &#34;multiple response&#34; version of the model.
Note that the second (and subsequent) responses are sent <em>without</em> the client
sending any additional messages.</p>

<blockquote>
<p>Note that the client doesn&#39;t <em>need</em> to wait for the server to send it a
message. In the diagram above, we showed the client in the blocked state
before circle &#34;3&#34; — the client could just as well have been running.</p>
</blockquote>

<h4 id="server_sends_to_client_without_client_asking_for_data" data-text="Server sends to client, without client asking for data">Server sends to client, without client asking for data</h4>

<p>This model is also known as the &#34;event&#34; model.</p>

<p><img src="https://chanind.github.io/fuchsia-src/concepts/fidl/images/event.png" alt="Figure: unsolicited messages from a server to a client"/></p>

<p>In it, a client prepares to receive messages from a server, but doesn&#39;t know
when to expect them — the messages are not only asynchronous to the
client, but are also (from a client / server point of view) &#34;unsolicited&#34;, in
that the client didn&#39;t explicitly request them (like it did in the previous
model, above).</p>

<p>The client designates a function (the &#34;event handling function&#34;) to be called
when messages arrive from the server, but otherwise continues about its
business.</p>

<p>At the server&#39;s discretion (circles &#34;1&#34; and &#34;2&#34; in the diagram above), messages
are sent asynchronously to the client, and handled by the client&#39;s designated
function.</p>

<p>Note that the client may already be running when a message is sent (as in circle
&#34;1&#34;), or the client may have nothing to do and be waiting for a message to be
sent (as in circle &#34;2&#34;).</p>

<blockquote>
<p>It is not a requirement that the client be waiting for a message.</p>
</blockquote>

<h4 id="asynchronous_messaging_complexity" data-text="Asynchronous messaging complexity">Asynchronous messaging complexity</h4>

<p>Breaking up asynchronous messaging into the above (somewhat arbitrary)
categories is meant to show typical usage patterns, but isn&#39;t meant to be
exhaustive.</p>

<p>In the most general case of asynchronous messaging, you have zero or more client
messages loosely associated with zero or more server replies. It&#39;s this &#34;loose
association&#34; that adds the complexity in terms of your design process.</p>

<h3 id="ipc_models_in_fidl" data-text="IPC models in FIDL">IPC models in FIDL</h3>

<p>Now that we have an understanding of the IPC models and how they interact with
FIDL&#39;s asynchronous messaging, let&#39;s see how they&#39;re defined.</p>

<p>We&#39;ll add the other models (fire and forget, and async call or event) to the protocol
definition file:</p>
<pre translate="no" dir="ltr"><code translate="no" dir="ltr">1   library fidl.examples.echo;
2
3   @discoverable
4   protocol Echo {
5       EchoString(struct {
6           value string:optional;
7       }) -&gt; (struct {
8           response string:optional;
9       });
10
11      SendString(struct { value string:optional; });
12
13      -&gt;ReceiveString(struct { response string:optional; });
14  };
</code></pre>
<p><strong>Lines 5-9</strong> are the <code translate="no" dir="ltr">EchoString</code> method that we discussed above — it&#39;s a
traditional function call message, where the client calls <code translate="no" dir="ltr">EchoString</code> with an
optional string, and then blocks, waiting for the server to reply with another
optional string.</p>

<p><strong>Line 11</strong> is the <code translate="no" dir="ltr">SendString</code> method. It does not have the <code translate="no" dir="ltr">-&gt;</code> return
declaration — that makes it into a &#34;fire and forget&#34; model (send only),
because we&#39;ve told the FIDL compiler that this particular method does not have a
return associated with it.</p>

<blockquote>
<p>Note that it&#39;s not the lack of return <strong>parameters</strong>, but rather the lack of
return <strong>declaration</strong> that&#39;s the key here — putting &#34;<code translate="no" dir="ltr">-&gt; ()</code>&#34; after
<code translate="no" dir="ltr">SendString</code> would change the meaning from declaring a fire-and-forget style
method to declaring a function call style method that doesn&#39;t have any return
arguments.</p>
</blockquote>

<p><strong>Line 13</strong> is the <code translate="no" dir="ltr">ReceiveString</code> method. It&#39;s a little different — it
doesn&#39;t have the method name in the first part, but rather it&#39;s given after the
<code translate="no" dir="ltr">-&gt;</code> operator. This tells the FIDL compiler that this is an &#34;async call&#34; or
&#34;event&#34; model declaration.</p>

<h3 id="fidl_bindings" data-text="FIDL Bindings">FIDL Bindings</h3>

<p>The FIDL toolchain takes in FIDL protocol and type definitions, like the
examples shown above, and generates code in each target language that can &#34;speak&#34;
these protocols. This generated code is referred to as the FIDL bindings, which
are available in various flavors depending on the language:</p>

<ul>
<li><strong>Native bindings</strong>: designed for highly sensitive contexts such as device
drivers and high-throughput servers, leverage in-place access, avoid memory
allocation, but may require somewhat more awareness of the constraints of
the protocol on the part of the developer.</li>
<li><strong>Idiomatic bindings</strong>: designed to be more developer-friendly by copying
data from the wire format into easier to use data types (such as heap-backed
strings or vectors), but correspondingly somewhat less efficient as a
result.</li>
</ul>

<p>Bindings offer several various ways of invoking protocol methods depending on
the language:</p>

<ul>
<li><strong>Send/receive</strong>: read or write messages directly to a channel, no built-in
wait loop (C)</li>
<li><strong>Callback-based</strong>: received messages are dispatched asynchronously as
callbacks on an event loop (C++, Dart)</li>
<li><strong>Port-based</strong>: received messages are delivered to a port or future (Rust)</li>
<li><strong>Synchronous call</strong>: waits for reply and return it (Go, C++ unit tests)</li>
</ul>

<p>Bindings provide some or all of the following principal operations:</p>

<ul>
<li><strong>Encode</strong>: in-place transform native data structures into the wire format
(coupled with validation)</li>
<li><strong>Decode</strong>: in-place transform wire format data into native data structures
(coupled with validation)</li>
<li><strong>Copy/Move To Idiomatic Form</strong>: copy contents of native data structures
into idiomatic data structures, handles are moved</li>
<li><strong>Copy/Move To Native Form</strong>: copy contents of idiomatic data structures
into native data structures, handles are moved</li>
<li><strong>Clone</strong>: copy native or idiomatic data structures (that do not contain
move-only types)</li>
<li><strong>Call</strong>: invoke protocol method</li>
</ul>

<h4 id="client_implementation" data-text="Client implementation">Client implementation</h4>

<p>Regardless of the target language, the <code translate="no" dir="ltr">fidlc</code> FIDL compiler generates client
code that has the following basic structure.</p>

<p>The first part consists of the administration and background handling, and
consists of:</p>

<ol>
<li>some means of connecting to the server is provided</li>
<li>an asynchronous (&#34;background&#34;) message handling loop is started</li>
<li>async call style and event style methods, if any, are bound to the message
loop</li>
</ol>

<p>The second part consists of implementations of the traditional function call or
fire and forget style methods, as appropriate for the target language.
Generally speaking, this consists of:</p>

<ol>
<li>creating a callable API and declarations</li>
<li>generating code for each API that marshals the data from the call into a FIDL
formatted buffer suitable for transmission to the server</li>
<li>generating code to transmit the data to the server</li>
<li>in the case of function call style calls, generating code to:
<ol>
<li>wait for the response from the server</li>
<li>unmarshal the data from the FIDL formatted buffer, and</li>
<li>return the data via the API function.</li>
</ol></li>
</ol>

<p>Obviously, the exact steps may vary due to language implementation differences,
but that&#39;s the basic outline.</p>

<h4 id="server_implementation" data-text="Server implementation">Server implementation</h4>

<p>The <code translate="no" dir="ltr">fidlc</code> FIDL compiler also generates server code for a given target
language. Just like the client code, this code has a common structure regardless
of the target language. The code:</p>

<ol>
<li>creates an object that clients can connect to,</li>
<li>starts a main processing loop, which:
<ol>
<li>waits for messages</li>
<li>processes messages by calling out to the implementation functions</li>
<li>if specified, issues an asynchronous call back to the client to return
the output</li>
</ol></li>
</ol>

<p>In the next chapters, we&#39;ll see the details of each language&#39;s implementation of
the client and server code.</p>

<h2 id="why_use_fidl" data-text="Why Use FIDL?">Why Use FIDL?</h2>

<p>Fuchsia extensively relies on IPC since most functionality is implemented in
user space outside of the kernel, including privileged components such as device
drivers. Consequently the IPC mechanism must be efficient, deterministic,
robust, and easy to use:</p>

<p><strong>IPC efficiency</strong> pertains to the computational overhead required to generate,
transfer, and consume messages between processes. IPC will be involved in all
aspects of system operation so it must be efficient. The FIDL compiler must
generate tight code without excess indirection or hidden costs. It should be at
least as good as hand-rolled code would be where it matters most.</p>

<p><strong>IPC determinism</strong> pertains to the ability to perform transactions within a
known resource envelope. IPC will be used extensively by critical system
services such as filesystems, which serve many clients and must perform in
predictable ways. The FIDL wire format must offer strong static guarantees such
as ensuring that structure size and layout is invariant thereby alleviating the
need for dynamic memory allocation or complex validation rules.</p>

<p><strong>IPC robustness</strong> pertains to the need to consider IPC as an essential part of
the operating system&#39;s ABI. Maintaining binary stability is crucial. Mechanisms
for protocol evolution must be designed conservatively so as not to violate the
invariants of existing services and their clients, particularly when the need
for determinism is also considered. The FIDL bindings must perform effective,
lightweight, and strict validation.</p>

<p><strong>IPC ease of use</strong> pertains to the fact that IPC protocols are an essential
part of the operating system&#39;s API. It is important to provide good developer
ergonomics for accessing services via IPC. The FIDL code generator removes the
burden of writing IPC bindings by hand. Moreover, the FIDL code generator can
produce different bindings to suit the needs of different audiences and their
idioms.</p>

<h3 id="goals" data-text="Goals">Goals</h3>

<p>FIDL is designed specifically to optimize for these for characteristics. In
particular, the design of FIDL aims to satisfy the following goals:</p>

<h4 id="specificity" data-text="Specificity">Specificity</h4>

<ul>
<li>Describe data structures and protocols used by IPC on Zircon.</li>
<li>Optimized for interprocess communication. Although FIDL is also used for
persisting to disk and for network transfer, its design is not optimized for
these secondary use cases.</li>
<li>Efficiently transport messages consisting of data (bytes) and capabilities
(handles) over Zircon channels between processes running on the same device.</li>
<li>Designed specifically to facilitate effective use of Zircon primitives.
Although FIDL is used on other platforms (e.g. via ffx), its design puts
Fuchsia first.</li>
<li>Offers convenient APIs for creating, sending, receiving, and consuming
messages.</li>
<li>Perform sufficient validation to maintain protocol invariants (but no more
than that).</li>
</ul>

<h4 id="efficiency" data-text="Efficiency">Efficiency</h4>

<ul>
<li>Just as efficient (speed and memory) as using hand-rolled data structures
would be.</li>
<li>Wire format uses uncompressed native datatypes with little-endianness and
correct alignment to support in-place access of message contents.</li>
<li>No dynamic memory allocation is required to produce or to consume messages
when their size is statically known or bounded.</li>
<li>Explicitly handle ownership with move-only semantics.</li>
<li>Data structure packing order is canonical, unambiguous, and has minimum
padding.</li>
<li>Avoid back-patching pointers.</li>
<li>Avoid expensive validation.</li>
<li>Avoid calculations that may overflow.</li>
<li>Leverage pipelining of protocol requests for asynchronous operation.</li>
<li>Structures are fixed size; variable-size data is stored out-of-line.</li>
<li>Structures are not self-described; FIDL files describe their contents.</li>
<li>No versioning of structures, but protocols can be extended with new methods
for evolution.</li>
</ul>

<h4 id="ergonomics" data-text="Ergonomics">Ergonomics</h4>

<ul>
<li>Programming language bindings maintained by Fuchsia team:
<ul>
<li>C, Low-Level C++, High-Level C++, Dart, Go, Rust</li>
</ul></li>
<li>Keeping in mind we might want to support other languages in the future, such
as:
<ul>
<li>Java, JavaScript, etc.</li>
</ul></li>
<li>The bindings and generated code are available in native or idiomatic flavors
depending on the intended application.</li>
<li>Use compile-time code generation to optimize message serialization,
deserialization, and validation.</li>
<li>FIDL syntax is familiar, easily accessible, and programming language
agnostic.</li>
<li>FIDL provides a library system to simplify deployment and use by other
developers.</li>
<li>FIDL expresses the most common data types needed for system APIs; it does
not seek to provide a comprehensive one-to-one mapping of all types offered
by all programming languages.</li>
</ul>

<h2 id="workflow" data-text="Workflow">Workflow</h2>

<p>This section recaps the workflow of authors, publishers, and consumers of IPC
protocols described using FIDL.</p>



<p>The author of a FIDL based protocol creates one or more *<strong>.fidl files</strong> to
describe their data structures, protocols, and methods.</p>

<p>FIDL files are grouped into one or more <strong>FIDL libraries</strong> by the author. Each
library represents a group of logically related functionality with a unique
library name. FIDL files within the same library implicitly have access to all
other declarations within the same library. The order of declarations within the
FIDL files that make up a library is not significant.</p>

<p>FIDL files of one library can access declarations within another FIDL library by
<strong>importing</strong> the other FIDL module. Importing other FIDL libraries makes their
symbols available for use thereby enabling the construction of protocols derived
from them. Imported symbols must be qualified by the library name or by an alias
to prevent namespace collisions.</p>

<h3 id="publishing_fidl" data-text="Publishing FIDL">Publishing FIDL</h3>

<p>The publisher of a FIDL based protocol is responsible for making FIDL libraries
available to consumers. For example, the author may disseminate FIDL libraries
in a public source repository or distribute them as part of an SDK.</p>

<p>Consumers need only point the FIDL compiler at the directory that contains the
FIDL files for a library (and its dependencies) to generate code for that
library. The precise details for how this is done will generally be addressed by
the consumer&#39;s build system.</p>

<h3 id="consuming_fidl" data-text="Consuming FIDL">Consuming FIDL</h3>

<p>The consumer of a FIDL based protocol uses the FIDL compiler to generate code
suitable for use with their language runtime specific bindings. For certain
language runtimes, the consumer may have a choice of a few different flavors of
generated code all of which are interoperable at the wire format level but
perhaps not at the source level.</p>

<p>In the Fuchsia world build environment, generating code from FIDL libraries will
be done automatically for all relevant languages by individual FIDL build
targets for each library.</p>

<p>In the Fuchsia SDK environment, generating code from FIDL libraries will be done
as part of compiling the applications that use them.</p>

<h2 id="getting_started" data-text="Getting Started">Getting Started</h2>

<p>If you&#39;d like to learn more about using FIDL, the Guides section has a number of
<a href="https://chanind.github.io/docs/development/languages/fidl">developer guides</a> and <a href="https://chanind.github.io/docs/development/languages/fidl/tutorials/overview">tutorials</a> that you
can try. If you are developing on Fuchsia and would like to learn about how to
use bindings for an existing FIDL API, you can refer to the <a href="https://chanind.github.io/docs/reference/fidl/bindings/overview">FIDL bindings
reference</a>. Finally, if you would like to learn more about FIDL or
would like to contribute, check out the <a href="https://chanind.github.io/docs/reference/fidl/language/language">FIDL language
reference</a>, or the <a href="https://chanind.github.io/docs/contribute/contributing-to-fidl">contributing doc</a>.</p>

<!-- xrefs -->

<!-- The footer below is automatically added to this file. Do not modify anything below this line. -->



    

    
      <devsite-hats-survey hats-id="5RumxBgfF0d7vXFJcj90X3khBKrh" listnr-id="5048604"></devsite-hats-survey>
    
  </div></div>
  </body>
</html>
