<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://simondobson.org/2024/07/27/my-mental-model-of-setf-was-wrong/">Original</a>
    <h1>My mental model of setf was wrong</h1>
    
    <div id="readability-page-1" class="page"><div id="text-orge971bd2">
<p>
Yes: <code>setf</code> is entirely constructable within “ordinary” Lisp.
</p>

<p>
There are two parts to the construction. Firstly, we need the
name of the method that underlies a particular selector. It <i>looks</i>
like a list – but it’s actually a symbol, constructed by <code>setf</code>
from the locator.
</p>

<p>
We can build our own functions with names like this, although not using <code>defun</code>.
</p>

<div><pre><span></span><span>     </span><span>(</span><span>defvar</span><span> </span><span>*weird-name*</span><span> </span><span>(</span><span>make-symbol</span><span> </span><span>&#34;(1 2 3)&#34;</span><span>))</span>

<span>     </span><span>(</span><span>setf</span><span> </span><span>(</span><span>symbol-function</span><span> </span><span>*weird-name*</span><span>)</span>
<span>           </span><span>(</span><span>lambda</span><span> </span><span>(</span><span>a</span><span>)</span>
<span>             </span><span>(</span><span>print</span><span> </span><span>(</span><span>format</span><span> </span><span>nil</span><span> </span><span>&#34;We did *weird-name* on ~s&#34;</span><span> </span><span>a</span><span>))))</span>

<span>     </span><span>(</span><span>funcall</span><span> </span><span>*weird-name*</span><span> </span><span>&#34;a string&#34;</span><span>)</span>
</pre></div>

<pre>

&#34;We did *weird-name* on \&#34;a string\&#34;&#34;
</pre>


<p>
This defines a function and attaches it to a symbol (whose
print-name looks like a list), and – critically – whose name
can’t be accidentally typed and re-used, because the Lisp reader
won’t accept it as a function name symbol. (We can’t use <code>defun</code>
because it won’t parse <code>(1 2 3)</code> as a symbol name.)
</p>

<p>
For <code>setf</code>, the style of name used for the methods implementing the
different choices is <code>(setf selector)</code> – as a symbol, <i>not</i> a list,
remember – where <i>selector</i> is the symbol at the head of locator list.
</p>

<p>
For the second part of the construction, <code>setf</code> takes the locator,
synthesises the function name symbol using the selector, and
calls a generic function with this name, passing the new value
and the rest of the locator as arguments.
</p>

<p>
So to define a new construct <code>our-setf</code> we might do something like:
</p>

<div><pre><span></span><span>     </span><span>(</span><span>defmacro</span><span> </span><span>our-setf</span><span> </span><span>(</span><span>locator</span><span> </span><span>new-value</span><span>)</span>
<span>       </span><span>(</span><span>let*</span><span> </span><span>((</span><span>selector</span><span> </span><span>(</span><span>car</span><span> </span><span>locator</span><span>))</span>
<span>              </span><span>(</span><span>our-setf-function-name</span><span> </span><span>(</span><span>make-symbol</span><span> </span><span>(</span><span>format</span><span> </span><span>nil</span><span> </span><span>&#34;(our-setf ~a)&#34;</span>
<span>                                                           </span><span>selector</span><span>))))</span>
<span>         </span><span>`</span><span>(</span><span>apply</span><span> </span><span>(</span><span>symbol-function</span><span> </span><span>,</span><span>our-setf-function-name</span><span>)</span>
<span>                 </span><span>(</span><span>cons</span><span> </span><span>,</span><span>new-value</span><span> </span><span>,@</span><span>(</span><span>cdr</span><span> </span><span>locator</span><span>)))))</span>
</pre></div>

<p>
When called as something like <code>(our-setf (head &#39;(1 2 3)) 0)</code> the
macro will code to call a method <code>(our-setf head)</code> (as a symbol),
passing it (<code>0 &#39;(1 2 3))</code> as arguments and allowing the machinery of
generic functions to determine which method is actually called.
We define these methods of the form <code>(our-setf head)</code> and specialise
them as required.
</p>

<p>
(It’s actually a bit more complicated than this because we need
to define a generic function for <code>(our-setf head)</code>. We can’t do
this with <code>defgeneric</code>, for broadly the same reasons as why we
couldn’t use <code>defun</code> above, so we have to go backstage and
programmatically define the generic function. But the idea
remains the same.)
</p>

<hr/>
<p>
After all this, my mental model of <code>setf</code> is a lot clearer – and,
I hope, closer the reality at least. It combines a highly
structured use of macros, synthesised function names, and generic
functions – and no special machinery at all.
</p>

<p>
However, there’s some subtlety at play too, not obvious at first
acquaintance. We don’t want our synthesised function names to
accidentally capture the names of user-supplied code. It’s
possible that using a naming style like <code>setf-car</code> would do just
this, and a program happens to define a function with this name.
But the names <code>setf</code> synthesises aren’t recognised by <code>defun</code> and
<code>defgeneric</code>, and so can’t easily cause capturing – although they
<i>are</i> recognised by <code>defmethod</code>, which lets us define the specialised
methods “as normal” even though the other parts of the process
have to happen backstage.
</p>

<p>
This shows the power of macros and generic functions. It also
shows how deeply the latter are embedded into Lisp. They’re
usually thought of as part of <span>CLOS</span>, but they actually have little
explicit relationship to class and objects at all, and have been
woven all through Lisp to build flexible code structures.
</p>
</div></div>
  </body>
</html>
