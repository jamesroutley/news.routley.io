<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://yosefk.com/blog/i-cant-believe-im-praising-tcl.html">Original</a>
    <h1>I can&#39;t believe I&#39;m praising Tcl (2008)</h1>
    
    <div id="readability-page-1" class="page"><div>
				<p>So the other day I both defined Tcl procedures all by myself and used them interactively, and I liked it, to the point where it felt like some kind of local optimum. This entry is an attempt to cope with the trauma of liking Tcl, by means of rationalizing it. I&#39;ll first tell the story of my fascinating adventures, and then I&#39;ll do the rationalizing (to skip the oh-so-personal first part, go straight for the bullet points).</p>
<p>Here&#39;s what I was doing. I have this board. The board has a chip on it. The chip has several processors in it. There&#39;s a processor in there that is a memory-mapped device, and I talk to it using CPU load/store commands. The CPU is itself a JTAG target, and I talk to it via a probe, issuing those load/store commands. To the probe I talk via USB using an ugly console that can&#39;t even handle the clipboard properly. The console speaks Tcl.</p>
<p>Net result: in order to talk to the memory-mapped processor, I have to speak Tcl. Or I can use a memory view window in a graphical debugger. Except some addresses will change the processor state when read (pop an item from a LIFO, that sort of thing). So no, memory view windows aren&#39;t a good idea – you have to aim for the specific address, not shoot at whole address ranges. Damn, just who thought of defining the hardware in such a stupid way? Why, it was me. Little did I know that I was thereby inflicting Tcl on myself.</p>
<p>Anyway, there&#39;s this bug I have to debug now, and as far as I know it could be in at least three different pieces of software or in two different pieces of hardware, and I don&#39;t like any of the 5 options very much, and I want to find out what it is already. So at the ugly probe console I type things like <code>word 0x1f8cc000</code> (reads the processor status), <code>word 0x1f8cc008 2</code> (halts the execution), <code>word 0x1f8cc020 0x875</code> (places a breakpoint). I get sick and tired of this in about 2 minutes, when the command history is large enough to make the probability of hitting Enter at the wrong auto-completed command annoying. It&#39;s annoying to run the wrong command because if I ruin the processor state, it will take me minutes to reproduce that state, because the program reads input via JTAG, which is as slow as it gets.</p>
<p>So I figure this isn&#39;t the last bug I&#39;m gonna deal with this way, and it&#39;s therefore time for Extending my Environment, equipping myself with the Right Tools for the Job, Tailored to my needs, utilizing the Scripting capabilities of the system. I hate that, I really do. Is there something more distressing than the development of development tools for the mass market of a single developer? Can a programmer have a weakness more pathetic than the tendency to solve easy generic meta-problems when the real, specific problems are too hard? Is there software more disgusting in nature than plug-ins and extensions for a butt-ugly base system? But you know what, I really fail to remember 0x1f8cwhat the breakpoint address is. This story has one hexadecimal value too much for my brain. OK, then. Tcl.</p>
<p>I decided to have one entry point procedure, <code>pmem</code>, that would get a memory-mapped processor id, &#39;cause there are many of them, and then call one of several functions with the right base address, so that <code>pmem 0 pc</code> would do the same as <code>pmem_pc 0x1f8c0000</code>. Well, in Tcl that&#39;s as simple as it gets. Tcl likes to generate and evaluate command strings. More generally, Tcl likes strings. In fact, it likes them more than anything else. In normal programming languages, things are variables and expressions by default. In Tcl, they are strings. <code>abc</code> isn&#39;t a variable reference – it&#39;s a string. <code>$abc</code> is the variable reference. <code>a+b/c</code> isn&#39;t an expression – it&#39;s a string. <code>[expr $a+$b/$c]</code> is the expression. Could you believe that? <code>[expr $a+$b/$c]</code>. Isn&#39;t that ridiculous?</p>
<p>In fact, that was one of my main applications for Tcl: ridiculing it. I remember reading <a href="http://www.amazon.com/exec/obidos/ASIN/0130385603">the huge Tcl/Tk book by Brent Welch</a> with my friend once. There was a power outage and it was past the time when the last UPS squeaked its last squeak. And the book was there &#39;cause the hardware guys use it for scripting their lovecraftian toolchain. We really did have fun. Tears went down my cheeks from laughter. Even people with the usual frightened/mean comments about those geeks who laugh their brains out over a Tcl book  didn&#39;t spoil it. So, ridiculing Tcl, my #1 use for it. The other use is the occasional scripting of the hardware hackers&#39; lovecraftian toolchain. Overall, I don&#39;t use Tcl very much.</p>
<p>The nice thing about Tcl is that it&#39;s still a dynamic language, and reasonably laconic at that, modulo quoting and escaping. So I enter the usual addictive edit/test cycle using <code>tclsh &lt; script</code>. N minutes down the road (I really don&#39;t know what N was), I&#39;ve finished my 2 screenfuls of Tcl and the fun starts. I actually start debugging the goddamn thing.</p>
<p><em>Weeee!</em> <em>HAPPY, HAPPY, JOY, JOY!</em></p>
<p>You have no idea just how happy this made me. Yeah, I know, I&#39;m overreacting. I&#39;ll tell you what: debug various kinds of hardware malfunction for several months, and you&#39;ll be able to identify with the warped notion of value one gains through such process. On second thought, I don&#39;t know if I&#39;d really recommend it. Remember how I told <a href="http://www.yosefk.com/blog/low-level-is-easy.html">low-level programming was easy</a>? It is, fundamentally, but there&#39;s this other angle from which it&#39;s quite a filthy endeavor. I promise to blog about it. I owe it to the people who keep telling me &#34;so low-level is easy?&#34; each time they listen to me swear heartily at a degenerate hardware setup where nothing works no matter what you try. I owe it to myself – me wants to reach a closure here. Why should I tolerate being regularly misquoted at the moments of my deepest professional catharsis?</p>
<p>Aaaanyway, in just N minutes, I bootstrapped myself something not unlike a retarded version of gdb, the way it would work if the symbol table of my program was stripped. But no matter – I have <a href="http://linuxcommand.org/man_pages/addr2line1.html">addr2line</a> for that. And the nice thing about my retarded debugger front-end is that it looks like shell commands: <code>blah blah blah</code>. As opposed to <code>blah(&#34;blah&#34;,&#34;blah&#34;)</code>. And this, folks, is what I think Tcl, being a tool command language, gets right.</p>
<p>I come from the world of pop infix languages (C/Java/Python/Ruby/you name it). Tcl basically freaks me out with its two fundamental choices:</p>
<ul>
<li><strong>Tcl likes literals, not variables.</strong> Tcl: <code>string, $var.</code> Pop infix: <code>&#34;string&#34;, var</code>.</li>
<li><strong>Tcl likes commands, not expressions.</strong> Tcl: <code>doit this that, [expr $this+$that]</code>. Pop infix: <code>doit(&#34;this&#34;,&#34;that&#34;), this+that</code>.</li>
</ul>
<p>So basically, pop infix languages (and I use the term in the most non-judgmental, factual way), pop infix languages are optimized for programming (duh, they are programming languages). Programming is definitions. Define a variable and it will be easy to use it, and computing hairy expressions from variables is also easy. Tcl is optimized for usage. Most of the time, users give simple commands. Command names and literal parameters are easy. If you are a sophisticated user, and you want to do <code>pmem 0 bkpt [expr [pmem 0 pc] + 1]</code>, go ahead and do it. A bit ugly, but on the other hand, simple commands are really, really simple.</p>
<p>And eventually, simple commands become all that matters for the user, because the sophisticated user grows personal shortcuts, which abstract away variables and expressions, so you end up with <code>pmem 0 bkpt nextpc</code> or something. Apparently, <em>flat function calls with literal arguments is what interactive program usage is all about.</em></p>
<p>I&#39;m not saying that I&#39;m going to use Tcl as the extension language of my next self-made lovecraftian toolchain (I was thinking more along the lines of doing that one in D and using D as my scripting language, &#39;cause it compiles fast enough and it&#39;s apparently high-level enough). I haven&#39;t thought enough about this, but the grotesque escaping/quoting in Tcl still freaks me out; I don&#39;t want to <em>program</em> like that. All I&#39;m saying is that I like the <em>interactive</em> part. Specifically:</p>
<ul>
<li>Short code matters a lot; short interactive commands matter <strong>much</strong> more.</li>
<li>An interactive command language must be a real language (loops, functions and all).</li>
<li>Tcl allows for the shortest commands and it&#39;s a real language. I&#39;m <em>fascinated</em>.</li>
</ul>
<p>Allow me to elaborate.</p>
<p><strong>Short code vs short commands</strong></p>
<p>Lots of people have noticed that keeping your code short is extremely important. More surprisingly, many people fail to notice this, probably because &#34;1 line is better than 5&#34; doesn&#39;t sound that convincing. OK, think about 100K lines vs 500K and you&#39;ll get the idea. Oh, there are also those dirty Perl/shell one-liners that make one doubt about this. I&#39;ve known a Bastard Programmer that used 2K bash one-liners as his weapon of choice. OK then, so the actual rule must be &#34;short code is good unless it&#39;s written by a bastard&#34;. But it&#39;s the same core idea.</p>
<p>So we have the Architect type, who loves lots of classes which delegate work to each other, and we have the Enlightened type, who wants to write and read less. And the Enlightened type can rant and rave all day how Python, or Ruby, or Lisp make it oh-so-easy to define data structure literals, or to factor out stuff using meta-programming, or some other thing an Architect just never gets. And I&#39;m all with it.</p>
<p>And then we have interactive shells. And in Python it&#39;s <code>doit(&#34;xx&#34;,&#34;yy&#34;)</code>. And in Lisp it&#39;s <code>(doit &#34;xx&#34; &#34;yy&#34;)</code>, or <code>(doit :xx :yy)</code>, or <code>(doit xx yy)</code> if you make it a macro. And in Ruby it&#39;s <code>doit :xx :yy</code>, if you use symbols and omit parens. And that&#39;s about as good as you can get without using your own parser as in <code>doit &#34;xx yy&#34;</code>, which can suck in the (more rare) case when you do need to evaluate expressions before passing parameters, and doesn&#39;t completely remove overhead. Also note how all these languages use (), which makes you press Shift, instead of [] which doesn&#39;t. Ruby and Perl let you omit (), but it costs in readability. And [] is unanimously reserved for less important stuff than function calls.</p>
<p>The whole point of short code is saving human bandwidth, which is the single thing in a computing environment that doesn&#39;t obey Moore&#39;s law and doesn&#39;t double once in 18 months. Now, which kind of bandwidth is the most valuable? I&#39;ll tell you which. It&#39;s the interactive command bandwidth. That&#39;s because (1) you interact a lot with your tools and (2) this interaction isn&#39;t <em>what</em> you&#39;re trying to do, it&#39;s <em>how</em> you&#39;re trying to do it, so when it isn&#39;t <em>extremely easy</em> it&#39;s distracting and <em>extremely frustrating</em>.</p>
<p>This is why an editor that doesn&#39;t have <strong>short</strong> keyboard shortcuts for frequently used commands is a stupid fucking piece of junk and should go down the toilet right now. This is why a Matlab vector – <code>[1 2 3]</code> – is much better than a Python list – <code>[1,2,3]</code> (ever noticed how the space bar is much easier to hit than a comma, you enlightened dynamic language devotee? Size does matter). And don&#39;t get me started about further wrapping the vector literal for Numeric Python.</p>
<p>The small overhead is tolerable, though sucky, when you program, because you write the piece of code once and while you&#39;re doing it, you&#39;re concentrating on the task and its specifics, like the language syntax. When you&#39;re interacting with a command shell though, it&#39;s a big deal. You&#39;re not writing a program – you&#39;re looking at files, or solving equations, or single-stepping a processor. I have a bug, I&#39;m frigging anxious, I gotta GO GO GO as fast as I can to find out what it is already, and you think now is the time to type parens, commas and quotation marks?! Fuck you! By which I mean to say, short code is important, short commands are a must.</p>
<p>Which is why I never got to like IPython or IDLE. Perhaps Ruby could be better, because of omitting parens and all. Ruby seems to be less inflicted with the language lawyer pseudo-right-thing mindset. But the basic plain vanilla function-call-with-literal-args syntax still doesn&#39;t reach the purity of *sh or Tcl. Well, the shell is an insanely defective programming language, so it&#39;s not even an option for anything non-interactive. But Tcl gets way closer to a programming language. Which brings us to the next issue:</p>
<p><strong>Ad-hoc scripting languages – the sub-Turing tar pit</strong></p>
<p>Many debuggers have scripting languages. gdb has one, and Green Hills MULTI has one. Ad hoc command languages usually get the command-syntax-should-be-easy part right – it&#39;s command arg arg arg… They then get everything else wrong. That is, you usually don&#39;t have any or some of: data structures, loops, conditionals and user-defined functions, option for expression evaluation in all contexts, interface to the host OS, and all the stuff which basically would make the thing a programming language. Or you get all those things in a peculiar, defective form which you haven&#39;t seen anywhere else.</p>
<p>I wish people stopped doing that. I understand why many people do that very well – they don&#39;t know any language which isn&#39;t a 3rd generation one (presumably C++ or Java). They don&#39;t know how scripting works except on a theoretical level. They know how to build a big software system, with objects and relationships between objects and factories of objects and stuff. At the system/outside world boundary they&#39;re helpless though. Outside of the system our objects are gone. There&#39;s this cold, windy, cruel world with users and files and stuff. Gotta have an AbstractInputParser to guard the gates into our nice, warm, little system, um, actually it&#39;s &#34;big&#34;, no, make it &#34;huge&#34; system.</p>
<p>These are the Architects who get mocked by the Enlightened dynamic language lovers. They normally dismiss scripting languages as &#34;not serious&#34;, therefore, when faced with the need to create a command language for their system, they start out with a plan to create a non-serious (a.k.a crippled) language. Even if they wanted to make it a good one, they never thought about the considerations that go into making a good scripting language, nor do they realize how easy/beneficial it is to embed an existing one.</p>
<p>So basically we have 3GL people, who realize that commands should be short (&#34;it&#39;s a simple thing we&#39;re doing here&#34;), but they don&#39;t see that you need a real Turing-complete programming language for the complicated cases. And we have 4GL people, who optimize for the complicated case of programming (&#34;what&#39;s a scripting language – it&#39;s a programming language, dammit!&#34;), and they don&#39;t care about an extra paren or quotation mark.</p>
<p>And then we have Tcl, which makes easy things really easy and scales to handle complicated cases (well, almost, or so I think). And not only does it make plain funcalls easy – it reserves [] for nested funcalls, in the Lispy prefix form of <code>outercall arg [innercall arg arg] arg...</code> [] is better than (). Pressing Shift sucks. And custom keyboard mapping which makes it possible to type parens without pressing Shift is complete idiocy, because you won&#39;t be able to work with anyone&#39;s machine. This shit matters, if you program all day long it does.</p>
<p><strong>Now what?</strong></p>
<p>I don&#39;t know if I&#39;d use Tcl. It&#39;s less of a programming language than your typical pop infix 4GL. For starters, <code>[expr]</code> is a bitch. And then there are &#34;advanced&#34; features, like closures, that I think Tcl lacks. It has its interesting side from a &#34;linguistic&#34; perspective though. It has really few core syntax, making it closer to Lisp and Forth than the above-mentioned pop infix ilk. So you can use Tcl and claim for aristocracy. Of course you&#39;ll only manage to annoy the best programmers this way; the mediocre won&#39;t know what you&#39;re talking about, seeing only that Tcl doesn&#39;t look enough like C to be worth the name of a language.</p>
<p>I&#39;d think a lot before embedding Tcl as a scripting language for my tools, because of linguistic issues and marketing issues (you ought to give them something close enough to C, whether they&#39;re a customer or a roommate). So the practical takeaways for me are modest:</p>
<ol>
<li>I ain&#39;t gonna mock Tcl-scriptable tools no more. I understand what made the authors choose Tcl, and no, it&#39;s not just a bad habit. On a level, they chose probably the best thing available today in terms of ease-of-programming/ease-of-use trade-off (assuming they bundle an interactive command shell). If I need to automate something related to those tools, I&#39;ll delve into it more happily than previously. So much for emotional self-tuning.</li>
<li>I&#39;ll let it sink, and try to figure out whether you have a better trade-off. For example, if Ruby had macros (functions which don&#39;t evaluate their inputs), you could say doit x y without making x and y symbol objects, which forces you to prefix them with a colon. How macros of that sort should work in an infix language escapes me (not that I think that much about it, but still). Anyway, I&#39;ll definitely add Tcl to the list of things I should understand better in order to fight my linguistic ignorance. Being an amateur compiler writer, that seems like one of my duties.</li>
</ol>
							</div></div>
  </body>
</html>
