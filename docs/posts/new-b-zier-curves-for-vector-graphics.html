<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ad8e.pages.dev/curve">Original</a>
    <h1>New Bézier curves for vector graphics</h1>
    
    <div id="readability-page-1" class="page"><div id="main"><h2>Remodeling Béziers</h2>
<p>This article is about how math creates an easier-to-use version of Béziers. We&#39;ll show examples of issues with Béziers, then discuss the issues academically, then derive a curve that fixes the problems (and can draw circles!).</p>
<p>This is a Bézier. You can drag the handles. The green lines represent curvature.</p>

<p>Béziers are a little unintuitive to use, because it&#39;s not always clear where to put the control points, or how long the handles should be. This leads to a lot of trial and error. To see for yourself, use the handles below to align the black and pink curves.</p>

<p><label>Show answer</label></p>
<p>Click &#34;Show answer&#34; when done. You probably got the curve right, but you had to go back and forth between the two handles, iterating the curve. You couldn&#39;t set each handle to the correct position on the first try. (I can&#39;t do it either.)</p>
<p>Here&#39;s another one:</p>

<p><label>Show answer</label></p>
<p>You probably got the curve close, but your handles are way off.</p>
<p>Adjust the middle node:</p>

<p><label>Show answer</label></p>
<p>I don&#39;t know of a reasonable way to guess the right location.</p>
<p>These illustrate the following problems with Béziers:</p>
<ol>
<li>It&#39;s hard to guess the correct handle length on the first try; you have to see the result and adjust iteratively.</li>
<li>The correct value of a handle depends on too many other things. If you move a node or handle, then you have to adjust its handles, then re-adjust the neighboring handles, then re-adjust the first handles, then re-adjust the neighboring handles, etc. You can&#39;t set each handle to the correct value on its own. In mathematics, this means they are &#34;non-orthogonal&#34;.</li>
<li>Widely different inputs can lead to similar outputs, and then you have to adjust neighboring handles a lot. In mathematics, this means the output-to-input map is &#34;poorly conditioned&#34;. This becomes an issue when it is not axis-aligned, like the second example.</li>
<li>There&#39;s no obvious way to figure out where to put nodes.</li>
</ol>
<p>And there are three more problems:</p>
<ol start="5">
<li>Béziers can&#39;t represent circles. If you try to approximate one by hand, it&#39;ll look lopsided.</li>
<li>Deleting existing nodes from a curve creates a mess.</li>
<li>It&#39;s hard to keep curvature continuous across a node; you&#39;d have to stare at curvature combs and fiddle a lot.</li>
</ol>
<p>Mathematics resolves these issues.</p>
<h2>Local and global</h2>
<p>The words &#34;local&#34; and &#34;global&#34; appear in disparate domains in mathematics, like parallel evolution. These concepts are broadly useful.</p>
<p>Small and simple objects are &#34;local&#34;. Large and complex objects are &#34;global&#34;. For example, your house is a global object, and each room is a local object. If you want to know whether the whole house is painted white (a global property), you can check whether each individual room is painted white (a local property). This splits the global task into smaller local tasks.</p>
<p>The key insight is: Local properties are easy, and global properties are hard. Whenever global objects can be decomposed into local objects, it&#39;s more convenient to work with the local objects. This is the backbone of the <a href="https://math.stackexchange.com/questions/34053/list-of-local-to-global-principles">local to global principle</a>.</p>
<p>A curve is determined by a finite number of points on the screen - those points are the artist&#39;s interface. These points should control the curve <em>locally</em>, determining the curve in a small region.</p>
<p>In geometry, the standard local description of a curve is its derivatives, like a Taylor series. (We can safely ignore analyticity, thanks to Stone-Weierstrass.) The zeroth derivative is position - where the curve is. The first derivative is direction - which way the curve points. The second derivative is curvature - how curvy the curve is. These three parameters are easy for humans to understand, and artists don&#39;t use higher derivatives. So the points should control position, direction, and curvature. These three parameters produce a circular arc.</p>
<p>Local control is easy to draw with, because you just need to match behavior at points:</p>
<ul>
<li>You understand what an input point does - it chooses a circular arc for the nearby curve.</li>
<li>It&#39;s easy to position input points - put them where you want to change the curve.</li>
</ul>
<p>This explains the underlying issue with Béziers. Bézier controls are local for position and direction, but not local for curvature. Local position and local direction coincide with the easy tasks - placing the node on the curve and setting the handle direction. Non-local curvature coincides with the hard task - setting handle length. So it&#39;s failure of locality causing the issues.</p>
<h2>Given local behavior, how do we create a global curve?</h2>
<p>The user only inputs a finite number of points. It&#39;s best if the correct curve extends naturally between these points, requiring as few correction points as possible.</p>
<p>Because of locality, a curve between two points is determined solely by these two points, and ignores any points farther away.</p>
<p>Each point specifies either 0, 1, or 2 derivatives. Remember that the 0th derivative is position, the 1st derivative is direction, and the 2nd derivative is curvature. If you specify a higher derivative (like curvature), you specify all its lower derivatives as well (like position and direction). So given two points and a number of derivatives for each point (0 1 2), we have to come up with a curve.</p>
<p>If each point specifies only its position (the derivative numbers are 0 0), the curve is a line.</p>
<p>If one point specifies direction and the other specifies position (derivatives are 1 0), then the curve is a circle.</p>
<p>That&#39;s the easy cases. For the rest, we need math. We specify some possible axioms, then choose which ones to satisfy.</p>
<ol>
<li>Primacy of lines and circles. The desired curves are disproportionately lines and circles. If the points express a line or circle, then the curve is a line or circle.</li>
<li>Affirmation invariance. Adding extra derivatives that agree with the existing curve should keep the curve the same.</li>
<li>Affine transformation. Affine transformation of the points causes affine transformation of the curve. This is important for drawing 3D objects (which most things are). For example, ellipses are circles on a 3D plane, projected down to your 2D surface. They are an affine transformation of a circle.</li>
<li>Subdivision (strong). If we truncate a curve specified by points with N and M derivatives, then the two endpoints of the snipped curve have N and M derivatives.</li>
<li>Subdivision (weak). If we truncate a curve specified by points with N and M derivatives, then the two endpoints of the snipped curve have at most max(N, M) derivatives.</li>
<li>Finite length. Curves don&#39;t travel to infinity. (For example, a parabola does.)</li>
<li>Non-singularity. When the input varies smoothly, the output also varies smoothly.</li>
</ol>
<p>Unfortunately, not all these axioms can be satisfied simultaneously. So we have to make some tradeoffs, just like <a href="https://en.wikipedia.org/wiki/Arrow%27s_impossibility_theorem">Arrow&#39;s impossibility theorem</a>. An example is that axioms 1 + 3 together create the conic sections - whose paths travel to infinity, and hence cannot satisfy axioms 6 or 7.</p>
<p>If both points specify direction (1 1), then a parabola satisfies axioms 3, 4, and 5. It&#39;s equivalent to a quadratic Bézier. The best UI control is the intersection of the handles, which satisfies axiom 7.</p>
<p>An alternative is to choose <code>sin(angle/2)</code> as the weight for a rational quadratic Bézier. This satisfies axioms 1, 2, and 6 (and 7 with the right UI). The curve is always an ellipse. If the directions are perpendicular, then the points are the maximum and minimum curvature points of an ellipse.</p>
<p>If one point specifies direction and curvature, and the other point specifies only position (2 0), then the previous choices are still available: ellipses and parabolas. There&#39;s an additional alternative, where the direction and curvature are mirrored to the other point across the line between them. This satisfies axioms 1, 2, 3, and symmetry.</p>
<p>If one point specifies direction and curvature, and the other point specifies direction (2 1), then we get a uniquely determined conic section, and axioms 1, 2, 3, 4, and 5 are satisfied. These are ellipses, parabolas, and hyperbolas. Curves which travel to infinity should have their handles flipped.</p>
<p>If both points specify direction and curvature (2 2), then the curve is overspecified for a conic, so we have choices to make.</p>
<p>Here&#39;s one possible solution. Blue circles control curvature.</p>

Now blue circular handles control radius:

<p>The handles determine the radius of a circular arc near the point. The in-between is interpolated.</p>
<p>There are better curves; I didn&#39;t look too hard. This one respects axioms 1, 2, 3, and 6. 4 and 5 are probably achievable with a week of work. This one happens to be computationally efficient. It flips when the handles cross parallel, but this flip can be adjusted with more work (letting you represent a whole circle with one point).</p>
<p>This curve is a rational cubic Bézier. You can read it in <code>final3()</code> in the source code, or follow these steps:</p>
<ol>
<li>Affine transform the two input points so that the intersection of their directions creates an isosceles right triangle, with the two points forming the hypotenuse. (Like the first of the two diagrams above.)</li>
<li>Let the curvatures of the points be <code>c</code> and <code>k</code>. Draw a rational cubic Bézier. Let <code>r = √(8c)/3/(c + k)</code>, <code>s = √(8k)/3/(c + k)</code>. The second control point has weight <code>w = 3krr/2 + s</code> and is proportion <code>r/w</code> between the first and second control points. The third control point is calculated symmetrically by exchanging the input points.</li>
<li>Affine transform the curve back to the original position.</li>
</ol>
<p>The old list of problems with Béziers is fixed:</p>
<ol>
<li>The handle length can be set on the first or second try; just match a small arc around the point.</li>
<li>The correct handle length only depends on a small region around the point, not anything else. After it&#39;s set, moving nodes and other handles won&#39;t interfere; it&#39;ll still be correct.</li>
<li>High condition numbers for the inverse map are axis-aligned.</li>
<li>Placing nodes is simple. (Put them at the largest deviations, and on inflection points.)</li>
<li>Circles are easy to draw.</li>
<li>Deleting existing nodes from a curve leaves the curve in good shape.</li>
<li>The curvature is well behaved (the green lines). At a smooth node, the curvature is equal on both sides - no jump discontinuities.</li>
</ol>
<p>Here&#39;s a trick that turns curve-finding from a boring math problem into an interesting geometry problem. The subdivision axiom is secretly reversible:</p>
<ul>
<li>Extension axiom: Any curve has a unique curve that extends it, which produces the original curve when subdivided. This extension continues forever, so the curve must either loop back to itself or approach a singularity. This infinitely-continuing curve is called a &#34;parent curve&#34;.</li>
</ul>
<p>Finding a set of parent curves is a very intuitive process. Each parent curve extends infinitely, ending in loops or singularities, and every curve is just a short snippet of a parent curve. For example, the parent curves for conics are the parabolas and hyperbolas (which extend forever) and the ellipses (which loop). You can try to construct your own parent curves, using these constraints as a guide:</p>
<ol start="0">
<li>Any pair of points, containing the information {position, direction, curvature}, must belong to exactly one parent curve.
<ul>
<li>Since conics create every valid symmetric tuple, your parent curves can have no axis of symmetry unless they are conics.</li>
</ul>
</li>
<li>Parent curves should be useful curves to draw with. So singularities should generally be points at infinity. Spirals aren&#39;t useful, so they are disallowed.</li>
<li>The curves should behave well with inflection points; this is necessary to cover the lack of inflection points with conic sections. So the curve should be non-degenerate when one point has curvature 0.</li>
</ol>
<p>Which curves do you think are elegant or useful? Is there an optimal set of parent curves?</p>
<p>Here are some possible approaches:</p>
<ol>
<li>Try existing classes of curves with nice properties, like cardioids, conic generalizations, or other geometric shapes. See if any of them form parametrized families. <a href="https://en.wikipedia.org/wiki/List_of_curves">Here&#39;s a list.</a></li>
<li>Create parametrized families of curves directly. The interesting case is with singularities at infinity, where curvatures approach 0. Some promising classes are <a href="https://sci-hub.ru/https://doi.org/10.1016/j.cagd.2009.06.003">complex rational Béziers</a>, rational Béziers, and curves on the complex plane. For example, conic sections have a nice polar form.</li>
<li>Eyeball the loop case, where one curvature is zero and the other is not.</li>
</ol>
<h2>Future work</h2>
<p>These control systems can be extended to curves and surfaces in 3D. And to curves on 3D surfaces.</p>
<p>With a suitable UI, animations should be convenient. Conics express the sine wave, which is the physically natural &#34;ease-in-out&#34;, a spring force. They also express the parabola, the physically natural &#34;ease-in&#34;, a constant force (like gravity).</p>
<p>2 2&#39;s curve can be improved. There&#39;s also alternative UIs for the node handles that allow inflection points away from input points.</p>
<p>If you develop drawing software, you can implement these curves. They are easier to learn than Béziers, and are easier to be accurate with. No more staring at curvature combs needed.</p>
<p>Discussion: <a href="https://news.ycombinator.com/item?id=37457051">Hacker News</a>, <a href="https://app.element.io/#/room/#localcurves:matrix.org">Temporary chatroom</a></p>
<p>Author: Kevin Yin</p>
<p>Visualizations are thanks to <a href="https://omrelli.ug/g9/gallery/">G9</a> and took minimal effort.</p>
</div></div>
  </body>
</html>
