<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jamiepalatnik.com/wagtail-space/">Original</a>
    <h1>Wagtail Space</h1>
    
    <div id="readability-page-1" class="page"><div>
        
<p>Go 1.25 introduced a new <a href="https://pkg.go.dev/net/http#CrossOriginProtection"><code>http.CrossOriginProtection</code></a> middleware to the standard library — and it got me wondering:</p>

<p><em>Have we finally reached the point where CSRF attacks can be prevented without relying on a token-based check (like double-submit cookies)? Can we build secure web applications without bringing in third-party packages like <code>justinas/nosurf</code> or <code>gorilla/csrf</code>?</em></p>

<p>And I think the answer now may be a cautious “yes” — so long as a few important conditions are met.</p>

<p>If you want to skip the explanations and just want to see what those conditions are, you can <a href="#summary">click here</a>.</p>

<h2>The http.CrossOriginProtection middleware</h2>

<p>The new <code>http.CrossOriginProtection</code> middleware works by checking the values in a request&#39;s <code>Sec-Fetch-Site</code> and
<code>Origin</code> headers to determine where the request is coming from.
It will automatically reject any <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Methods#safe_idempotent_and_cacheable_request_methods">non-safe</a> requests that are not from the same origin, and will send the client a
<code>403 Forbidden</code> response.</p>

<p>The <code>http.CrossOriginProtection</code> middleware has some limitations, which we&#39;ll discuss in a moment, but it is robust and simple to use, and a great addition to the standard library.</p>



<p>At its simplest, you can use it like this:</p>

<figure>
	<figcaption>File: main.go</figcaption><code><pre>package main

import (
	&#34;fmt&#34;
	&#34;log/slog&#34;
	&#34;net/http&#34;
	&#34;os&#34;
)

func main() {
	mux := http.NewServeMux()
	mux.HandleFunc(&#34;/&#34;, home)

	slog.Info(&#34;starting server on :4000&#34;)

	// Wrap the mux with the http.NewCrossOriginProtection middleware.
	err := http.ListenAndServe(&#34;:4000&#34;, http.NewCrossOriginProtection(mux))
	if err != nil {
		slog.Error(err.Error())
		os.Exit(1)
	}
}

func home(w http.ResponseWriter, r *http.Request) {
	fmt.Fprint(w, &#34;Hello!&#34;)
}
</pre></code></figure>

<p>If you want, it&#39;s also possible to configure the behavior of <code>http.CrossOriginProtection</code>. Configuration options include being able to add trusted origins (from which cross-origin requests are allowed), and the ability to use a custom handler for rejected requests instead of the default <code>403 Forbidden</code> response.</p>

<p>When I&#39;ve wanted to customize the behavior, I&#39;ve been using a pattern like this:</p>

<figure>
	<figcaption>File: main.go</figcaption><code><pre>package main

import (
	&#34;fmt&#34;
	&#34;log/slog&#34;
	&#34;net/http&#34;
	&#34;os&#34;
)

func main() {
	mux := http.NewServeMux()
	mux.HandleFunc(&#34;/&#34;, home)

	slog.Info(&#34;starting server on :4000&#34;)

	err := http.ListenAndServe(&#34;:4000&#34;, preventCSRF(mux))
	if err != nil {
		slog.Error(err.Error())
		os.Exit(1)
	}
}

func preventCSRF(next http.Handler) http.Handler {
	cop := http.NewCrossOriginProtection()

	cop.AddTrustedOrigin(&#34;https://foo.example.com&#34;)

	cop.SetDenyHandler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte(&#34;CSRF check failed&#34;))
	}))

	return cop.Handler(next)
}

func home(w http.ResponseWriter, r *http.Request) {
	fmt.Fprint(w, &#34;Hello!&#34;)
}
</pre></code></figure>

<h2>Limitations</h2>

<p>The big limitation of <code>http.CrossOriginProtection</code> is that it is only effective at blocking requests from modern browsers. Your application will still be vulnerable to CSRF attacks coming from older (generally pre-2020) browsers which do not include at least one of the <code>Sec-Fetch-Site</code> or <code>Origin</code> headers in requests.</p>

<p>Right now, browser support for the <code>Sec-Fetch-Site</code> header is at 92%, and for <code>Origin</code> it is 95%. So — in general — relying on <code>http.CrossOriginProtection</code> is <em>not sufficient</em> as your only protection against CSRF.</p>

<p>It&#39;s also important to note that the <code>Sec-Fetch-Site</code> header is only sent when your application has a &#34;trustworthy origin&#34; — which basically means that your application needs to be using HTTPS in production for <code>http.CrossOriginProtection</code> to work to its full potential.</p>

<p>And you should also be aware that when no <code>Sec-Fetch-Site</code> header is present in a request, and it falls back to comparing the <code>Origin</code> and <code>Host</code> headers, the <code>Host</code> header <em>does not include the scheme</em>. This limitation means that <code>http.CrossOriginProtection</code> will wrongly allow cross-origin requests from <code>http://{host}</code> to <code>https://{host}</code> when there is no <code>Sec-Fetch-Site</code> header present but there is an <code>Origin</code> header. To mitigate this risk, you should ideally configure your application to use <a href="https://https.cio.gov/hsts/">HTTP Strict Transport Security (HSTS)</a>.</p>

<h2>Enforcing TLS 1.3</h2>

<p>Looking into this got me wondering... <em>What if you&#39;re already planning to use HTTPS and enforce TLS 1.3 as the minimum supported TLS version?</em> Could you be confident that all web browsers which support TLS 1.3 also support either the <code>Sec-Fetch-Site</code> or <code>Origin</code> headers?</p>

<p>As far as I can tell from the <a href="https://github.com/mdn/browser-compat-data">MDN compatibility data</a> and tables from <a href="https://caniuse.com/">Can I Use</a>, the answer is &#34;yes&#34; for (almost) all major browsers.</p> 

<p>If you enforce TLS 1.3 as the minimum version:</p>

<ul>
	<li>Older browsers which don&#39;t support TLS 1.3 simply won&#39;t be able to connect to your application.</li>
	<li>For the modern major browsers that do support TLS 1.3 and can connect, you can be confident that at least one of the <code>Sec-Fetch-Site</code> or <code>Origin</code> headers are supported — and therefore <code>http.CrossOriginProtection</code> will work effectively.</li>
</ul>
	
<p>The only exception to this I can see is Firefox v60-69 (2018-2019), which did not support the <code>Sec-Fetch-Site</code> header and did not send the <code>Origin</code> header for <code>POST</code> requests. This means that <code>http.CrossOriginProtection</code> will not work effectively to block requests originating from that browser. <a href="https://caniuse.com/usage-table">Can I Use</a> puts usage of Firefox v60-69 at 0%, so the risk here appears very low — but there are probably some computers somewhere in the world still running it.</p>

<p>Also, we only have this information for the major browsers — Chrome/Chromium, Firefox, Edge, Safari, Opera and Internet Explorer. But of course, other browsers exist. Most of them are forks of Chromium or Firefox and therefore will likely be OK, but there&#39;s no guarantee here and it is hard to quantify the risk.</p>

<p>So if you use HTTPS and enforce TLS 1.3, it&#39;s a huge step forward in making sure that <code>http.CrossOriginProtection</code> can work effectively. However, there remains a non-zero risk that comes from Firefox v60-69 and non-major browsers, so you may want to add some defense-in-depth and utilize <code>SameSite</code> cookies too.</p>

<p>We&#39;ll talk more about <code>SameSite</code> cookies in a moment, but first we need to take a quick detour and discuss the difference between the terms <em>origin</em> and <em>site</em>.</p>

<h2>Cross-site vs cross-origin</h2>

<p>In the world of web specifications and web browsers, <em>cross-site</em> and <em>cross-origin</em> are subtly different things, and in a security context like this it&#39;s important to understand the difference and be exact about what we mean.</p>

<p>I&#39;ll quickly explain.</p>

<p>Two websites have the same origin if they share the exact same scheme, hostname, and port (if present). So <code>https://example.com</code> and <code>https://www.example.com</code> are <em>not</em> the same origin because the hostnames (<code>example.com</code> and <code>www.example.com</code>) are different. A request between them would be cross-origin.</p>

<p>Two websites are &#39;same site&#39; if they share the same scheme and <em>registerable domain</em>.</p>
	


<p>So <code>https://example.com</code>, <code>https://www.example.com</code> and <code>https://login.admin.example.com</code> are all considered to be the same site because the scheme (<code>https</code>) and registerable domain (<code>example.com</code>) are the same. A request between these would <em>not</em> be considered to be cross-site, but it would be cross-origin.</p>



<p>So what are the points that I&#39;m building up to here?</p>

<ol>
	<li><p>Go&#39;s <code>http.CrossOriginProtection</code> middleware is accurately and appropriately named. It blocks <em>cross-origin</em> requests. It&#39;s more strict than it would be if it only blocked cross-site requests, because it also blocks requests from other origins under the same site (i.e. registrable domain).</p>

	<p>This is useful because it helps to prevent a situation where your janky-not-been-updated-in-the-last-decade WordPress blog at <code>https://blog.example.com</code> is compromised and used to launch a request forgery attack at your important <code>https://admin.example.com</code> website.</p></li>

	<li><p>When most people — myself included — casually talk about &#34;CSRF attacks&#34;, what we are referring to most of the time is actually <em>cross-origin</em> request forgery, not just <em>cross-site</em> request forgery. It&#39;s a shame that CSRF is the commonly used and known acronym to describe this family of attacks, because most of the time CORF would be more accurate and appropriate. But hey! That&#39;s the messy world we live in.</p>
	
	<p>For the rest of this post though, I&#39;ll use the term CORF instead of CSRF when that is exactly what I mean.</p></li>
</ol>

<h2>SameSite cookies</h2>

<p>The <a href="https://owasp.org/www-community/SameSite"><code>SameSite</code></a> cookie attribute has generally been supported by web browsers since 2017, and by Go since v1.11. If you set the <code>SameSite=Lax</code> or <code>SameSite=Strict</code> attributes on a cookie, that cookie will only be included in requests to the same site that set it. In turn, that prevents cross-site request forgery attacks (but not cross-origin attacks from within the same site).

</p><p>There is some good news here — all major browsers that support TLS 1.3 also fully support <code>SameSite</code> cookies, with no exceptions that I can see. So if you enforce TLS 1.3, you can be confident that all the major browsers using your application will respect the <code>SameSite</code> attribute.</p>

<p>This means that by using <code>SameSite=Lax</code> or <code>SameSite=Strict</code> on your cookies, you cover off the risk of cross-site request forgeries from Firefox v60-69 that we talked about earlier.</p>


<h2 id="summary">Putting it all together</h2>

<p>If you combine using HTTPS, enforcing TLS 1.3 as the minimum version, using <code>SameSite=Lax</code> or <code>SameSite=Strict</code> cookies appropriately, and using the <code>http.CrossOriginProtection</code> middleware in your application, as far as I can see there are only two unmitigated CSRF/CORF risks from major browsers:</p>

<ol>
	<li>CORF attacks from within the same site (i.e. from another subdomain under your registrable domain) in Firefox v60-69.</li>
	<li>CORF attacks from a HTTP version of your origin, from browsers that do not support the <code>Sec-Fetch-Site</code> header.</li>
</ol>

<p>For the first of these risks, if you don&#39;t have any other websites under your registrable domain, or you&#39;re confident that the websites are secure and uncompromised, then this might be a risk that you&#39;re willing to accept given the extremely low usage of Firefox v60-69.</p>

<p>For the second, if you don&#39;t support HTTP on your origin <em>at all</em> (including redirects) then this isn&#39;t something you need to worry about. Otherwise, you can mitigate the risk by including a HSTS header on your HTTPS responses.</p>

<p>At the start of this article, I said that not using a token-based CSRF check might be OK under certain conditions. So let&#39;s run through what those are:</p>

<ol>
	<li>Your application uses HTTPS and enforces TLS 1.3 as the minimum version. You accept that users with older browsers will not be able to connect to your application at all.</li>
	<li>You follow good-practice and never change important application state in response to requests with the <em>safe</em> methods <code>GET</code>, <code>HEAD</code>, <code>OPTIONS</code> or <code>TRACE</code>.</li>
	<li>You use <em>both</em> the <code>http.CrossOriginProtection</code> middleware and <code>SameSite=Lax</code> or <code>SameSite=Strict</code> cookies. It&#39;s important to still use <code>SameSite</code> cookies for general defense in depth, but more specifically to mitigate CSRF attacks from Firefox v60-69.</li>
	<li>Because of the unprotected risk of a same-site CORF attack from Firefox v60-69, you either don&#39;t have any other websites under your registrable domain, or you&#39;re confident that they&#39;re secure and uncompromised.</li>
	<li>There is either no HTTP version of your application origin at all, or you include a HSTS header on your HTTPS responses.</li>
	<li>Finally, you are willing to accept the difficult-to-quantify risk of CSRF/CORF attacks from non-major browsers that support TLS 1.3 but don&#39;t support the <code>Origin</code> header, <code>Sec-Fetch-Site</code> header or <code>SameSite</code> cookies. Does any such browser exist? I don&#39;t know, and I&#39;m not sure there&#39;s a way to answer that question with 100% confidence. So you&#39;ll need to do your own risk assessment here, and it&#39;s a risk that you probably only want to accept if your application is a low-value target and the impact of a successful CSRF/CORF attack is both isolated and minor.</li>
</ol>

    </div></div>
  </body>
</html>
