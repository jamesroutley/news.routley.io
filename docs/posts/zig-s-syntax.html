<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.openmymind.net/Zigs-weird-syntax/">Original</a>
    <h1>Zig&#39;s (.{}){} Syntax</h1>
    
    <div id="readability-page-1" class="page"><div>
<article>
  
  
  
<p>One of the first pieces of Zig code that you&#39;re likely to see, and write, is this beginner-unfriendly line:</p>

<pre><code><span>var</span> gpa <span>=</span> std<span>.</span>heap<span>.</span><span>GeneralPurposeAllocator</span><span>(</span><span>.</span><span>{</span><span>}</span><span>)</span><span>{</span><span>}</span><span>;</span></code></pre>

<p>While we can reason that we&#39;re creating an allocator, the <code>(.{}){}</code> syntax can seem a bit much. This is a combination of three separate language features: generics, anonymous struct literals and default field values.</p>

<h3 id="generics"><a href="#generics" aria-hidden="true">Generics</a></h3>
<p>One of Zig&#39;s more compelling feature is its advance compile-time (aka comptime) capabilities. This is the ability to have a subset of Zig run at compile-time. Comptime can be used for a number of different things, but the most immediately useful is to implement generic type. To create a generic type, we write a a function which returns a type. For example, if we wanted to create a linked list node, we&#39;d do:</p>

<pre><code><span>fn</span> <span>Node</span><span>(</span>T<span>:</span> <span><span>type</span></span><span>)</span> <span><span>type</span></span> <span>{</span>
    <span>return</span> <span>struct</span> <span>{</span>
        value<span>:</span> <span>T</span><span>,</span>
        next<span>:</span> <span>?</span><span>*</span><span>Node</span><span>(</span>T<span>)</span> <span>=</span> <span>null</span><span>,</span>
    <span>}</span><span>;</span>
<span>}</span></code></pre>

<p>You could optionally (and more explicitly) specify that <code>T</code> is a comptime parameter:</p>

<pre><code><span>fn</span> <span>Node</span><span>(</span><span>comptime</span> T<span>:</span> <span><span>type</span></span><span>)</span> <span><span>type</span></span> <span>{</span>
    
<span>}</span></code></pre>

<p>But this is redundant, because, in Zig, types <strong>always</strong> have to be known at compile time. Now consider these two equivalent ways to create a <code>Node(T)</code>:</p>

<pre><code><span>const</span> IntNode <span>=</span> <span>Node</span><span>(</span><span>i32</span><span>)</span><span>;</span>
<span>const</span> n1 <span>=</span> <span>IntNode</span><span>{</span><span>.</span>value <span>=</span> <span>1</span><span>}</span><span>;</span>

<span>const</span> n2 <span>=</span> <span>Node</span><span>(</span><span>i32</span><span>)</span><span>{</span><span>.</span>value <span>=</span> <span>2</span><span>}</span><span>;</span></code></pre>

<p>Thinking of <code>Node(i32)</code> as a type can take a bit of getting used to, but once you accept that it&#39;s no different than any other struct, the 2nd initialization hopefully makes sense.</p>

<p>While it&#39;s common, there&#39;s no rule that says that the parameters of a generic function have to be types. This is valid:</p>

<pre><code><span>fn</span> <span>Buffer</span><span>(</span><span>comptime</span> size<span>:</span> <span><span>usize</span></span><span>)</span> <span><span>type</span></span> <span>{</span>
    <span>return</span> <span>struct</span> <span>{</span>
        pos<span>:</span> <span><span>usize</span></span><span>,</span>
        buf<span>:</span> <span><span>[</span>size<span>]</span><span>u8</span></span><span>,</span>
    <span>}</span><span>;</span>
<span>}</span></code></pre>

<p>You might do this type of thing for performance reasons - doing things at comptime rather than runtime, or, as we did above, to avoid dynamic allocation. This brings us to the 2nd part of the special syntax.</p>

<h3 id="anonymous_struct_literals"><a href="#anonymous_struct_literals" aria-hidden="true">Anonymous Struct Literals</a></h3>
<p>Zig is good at inferring types. Given the following function:</p>

<pre><code><span>const</span> <span>Config</span> <span>=</span> <span>struct</span> <span>{</span>
    port<span>:</span> <span><span>u16</span></span><span>,</span>
    host<span>:</span> <span><span>[</span><span>]</span><span>const</span> <span>u8</span></span><span>,</span>
<span>}</span><span>;</span>

<span>fn</span> <span>connect</span><span>(</span>config<span>:</span> <span>Config</span><span>)</span> <span><span>!</span><span>void</span></span> <span>{</span>
    
<span>}</span></code></pre>

<p>The following are all equivalent:</p>

<pre><code><span>const</span> c1 <span>=</span> <span>Config</span><span>{</span>
    <span>.</span>port <span>=</span> <span>8000</span><span>,</span>
    <span>.</span>host <span>=</span> <span>&#34;127.0.0.1&#34;</span><span>,</span>
<span>}</span><span>;</span>
<span>try</span> <span>connect</span><span>(</span>c1<span>)</span><span>;</span>



<span>try</span> <span>connect</span><span>(</span><span>Config</span><span>{</span>
    <span>.</span>port <span>=</span> <span>8000</span><span>,</span>
    <span>.</span>host <span>=</span> <span>&#34;127.0.0.1&#34;</span><span>,</span>
<span>}</span><span>)</span><span>;</span>



<span>try</span> <span>connect</span><span>(</span><span>.</span><span>{</span>
    <span>.</span>port <span>=</span> <span>8000</span><span>,</span>
    <span>.</span>host <span>=</span> <span>&#34;127.0.0.1&#34;</span><span>,</span>
<span>}</span><span>)</span><span>;</span></code></pre>

<p>Whenever you see this syntax <code>.{...}</code>, you should imagine the leading dot being replaced with the target type (which Zig will infer). But in the original <code>GeneralPurposeAllocator</code> line, that&#39;s not really what we were doing, is it? We had something more like:</p>

<pre><code><span>try</span> <span>connect</span><span>(</span><span>.</span><span>{</span><span>}</span><span>)</span><span>;</span></code></pre>

<p>It&#39;s the same, but relying on default field values, which is the last bit of magic.</p>

<h3 id="default_field_values"><a href="#default_field_values" aria-hidden="true">Default Field Values</a></h3>
<p>In the above example, in order to create a <code>Config</code>, we <strong>must</strong> specify the <code>port</code> and <code>host</code> fields:</p>

<pre><code><span>const</span> c1 <span>=</span> <span>Config</span><span>{</span><span>.</span>port <span>=</span> <span>8000</span><span>,</span> <span>.</span>host <span>=</span> <span>&#34;127.0.0.1&#34;</span><span>}</span>


<span>const</span> c1<span>:</span> <span>Config</span> <span>=</span> <span>.</span><span>{</span><span>.</span>port <span>=</span> <span>8000</span><span>,</span> <span>.</span>host <span>=</span> <span>&#34;127.0.0.1&#34;</span><span>}</span></code></pre>

<p>Failure to set either (or both) fields will result in a compile-time error. When we declare the structure, we can give fields a default value. For example, we could change our <code>Config</code> struct to:</p>

<pre><code><span>const</span> <span>Config</span> <span>=</span> <span>struct</span> <span>{</span>
    port<span>:</span> <span><span>u16</span></span><span>,</span>
    host<span>:</span> <span><span>[</span><span>]</span><span>const</span> <span>u8</span></span> <span>=</span> <span>&#34;127.0.0.1&#34;</span><span>,</span>
<span>}</span><span>;</span></code></pre>

<p>Now when we create a <code>Config</code>, we can optionally omit the <code>host</code>:

</p><pre><code><span>const</span> c <span>=</span> <span>Config</span><span>{</span><span>.</span>port <span>=</span> <span>8000</span><span>}</span><span>;</span></code></pre>

<p>Which would create a <code>Config</code> with a <code>port</code> equal to <code>8000</code> and a <code>host</code> equal to <code>&#34;127.0.0.1&#34;</code>. We can give every field a default value:</p>

<pre><code><span>const</span> <span>Config</span> <span>=</span> <span>struct</span> <span>{</span>
    port<span>:</span> <span><span>u16</span></span> <span>=</span> <span>8000</span><span>,</span>
    host<span>:</span> <span><span>[</span><span>]</span><span>const</span> <span>u8</span></span> <span>=</span> <span>&#34;127.0.0.1&#34;</span><span>,</span>
<span>}</span><span>;</span></code></pre>

<p>Which means that we can create a <code>Config</code> without specifying any field:</p>

<pre><code><span>const</span> c <span>=</span> <span>Config</span><span>{</span><span>}</span><span>;</span>


<span>const</span> c<span>:</span> <span>Config</span> <span>=</span> <span>.</span><span>{</span><span>}</span><span>;</span></code></pre>

<p>Those empty braces look a lot like the ones we used to create our GeneralPurposeAllocator!</p>

<h3 id="together"><a href="#together" aria-hidden="true">Bringing It Together</a></h3>
<p>Given what we&#39;ve learned, if we look at the original line of code again:</p>

<pre><code><span>var</span> gpa <span>=</span> std<span>.</span>heap<span>.</span><span>GeneralPurposeAllocator</span><span>(</span><span>.</span><span>{</span><span>}</span><span>)</span><span>{</span><span>}</span><span>;</span></code></pre>

<p>We know that <code>GeneralPurposeAllocator</code> is a function that returns a type: it&#39;s a generic. We don&#39;t know the type of parameter it takes, but we do know that we&#39;re using its default parameters. We&#39;re also using defaults to initialize an instance of the type.</p>

<p>If <code>GeneralPurposeAllocator</code> wasn&#39;t a generic, we&#39;d have this:</p>

<pre><code><span>var</span> gpa <span>=</span> <span>std<span>.</span>heap<span>.</span>GeneralPurposeAllocator</span><span>{</span><span>}</span><span>;</span></code></pre>

<p>And we could say that we&#39;re initializing a <code>GeneralPurposeAllocator</code> using its default values. Pretty straightforward. But because <code>GeneralPurposeAllocator</code> is a generic which takes a configuration struct, we end up with two sets of defaults - one which is passed to the generic function and creates the type, and the other that initializes the instance.</p>

<p>Consider this more explicit version:</p>

<pre><code><span>const</span> config <span>=</span> <span>std<span>.</span>heap<span>.</span>GeneralPurposeAllocatorConfig</span><span>{</span><span>}</span><span>;</span>


<span>const</span> GPA <span>=</span> std<span>.</span>heap<span>.</span><span>GeneralPurposeAllocator</span><span>(</span>config<span>)</span><span>;</span>

<span>var</span> gpa <span>=</span> <span>GPA</span><span>{</span><span>}</span><span>;</span></code></pre>

<p>And now lets inline everything:</p>

<pre><code><span>var</span> gpa <span>=</span> std<span>.</span>heap<span>.</span><span>GeneralPurposeAllocator</span><span>(</span><span>std<span>.</span>heap<span>.</span>GeneralPurposeAllocatorConfig</span><span>{</span><span>}</span><span>)</span><span>{</span><span>}</span><span>;</span></code></pre>

<p>Finally we can let Zig infer the type:</p>

<pre><code><span>var</span> gpa <span>=</span> std<span>.</span>heap<span>.</span><span>GeneralPurposeAllocator</span><span>(</span><span>.</span><span>{</span><span>}</span><span>)</span><span>{</span><span>}</span><span>;</span></code></pre>

<p>Hopefully, that helps. I&#39;ve <a href="https://www.openmymind.net/learning_zig/generics/">written more about generics</a> before and, in the next post, we&#39;ll talk about a new Zig feature, declaration literals, which improve the readability of this type of code.</p>

</article>
</div></div>
  </body>
</html>
