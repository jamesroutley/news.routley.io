<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.iroh.computer/blog/iroh-blobs-0-95-new-features">Original</a>
    <h1>Iroh-blobs</h1>
    
    <div id="readability-page-1" class="page"><div data-mdx-content="true"><p>Iroh-blobs 0.95 contains a number of significant new features that are worth explaining in detail. There are several new features that are useful for blobs users and also for iroh users in general.</p>
<p>Let&#39;s start with a feature that is essential for blobs itself, but can also be useful for many other protocols.</p>

<p>There is a new connection pool in <code>util::connection_pool</code>. This is useful whenever you have a protocol that has to talk to a large number of endpoints while keeping an upper bound of concurrent open connections. In blobs, this is used whenever you use the downloader to orchestrate blobs downloads from multiple providers.</p>
<p>Iroh connections are relatively lightweight, but even so you don&#39;t want to keep thousands of them open at the same time. But opening a new connection every time you do a small exchange with a peer is very wasteful. The <code>ConnectionPool</code> gives you an API to deal with these tradeoffs.</p>

<p>Let&#39;s first look at basic usage:</p>

<p><code>get_or_connect</code> will try to get an existing connection from the pool. If there is none, it will create one and store it. The connection will be kept in the pool for a configurable time. Idle connections will be closed as needed. So you can just use this as a drop-in replacement for endpoint.connect and be sure that you won&#39;t ever create an unbounded number of connections.</p>

<p>There are some advanced features that can be configued using non-default options.</p>

<p>You can configure the max number of connections to be retained, the maximum tolerable duration for connection establishment, and the max duration connections are kept when idle.</p>
<p>So far, pretty straightforward. There is an additional option to perform some setup before the connection is handed out to the user. For example, you can reject connections based on the data available at this time from the endpoint and the connection, or wait for the connection to reach a certain state before handing it out.</p>
<p>As an example, you might want to do iroh-blobs transfers only on direct connections in order to get good performance or reduce bandwidth use on the relay. If establishing direct connections is not possible, the connection establishment would time out, and you would never even attempt a transfer from such a node.</p>

<p>The code to await a direct connection will change quite a bit once we have QUIC multipath. But the capability will remain, and we will update the test code to reflect the new API.</p>
<div><svg viewBox="0 0 16 16" aria-hidden="true"><circle cx="8" cy="8" r="8" stroke-width="0"></circle><path fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M6.75 7.75h1.5v3.5"></path><circle cx="8" cy="4" r=".5" fill="none"></circle></svg><div><p>The connection pool is generic enough that it will move to its own crate together with some other iroh utilities. It lives in blobs only until iroh 1.0 is released.</p><p>Until then, just depend on iroh-blobs. Iroh-blobs without persistent storage is a very lightweight dependency.</p></div></div>
<p>One thing to keep in mind when using the connection pool: the connection pool needs the ability to track which connections are currently being used. To do this, the connection pool does not return <code>Connection</code> but <code>ConnectionRef</code>, a struct that derefs to <code>Connection</code> but contains some additional lifetime tracking.</p>
<p>But <code>Connection</code> is <code>Clone</code>, so in principle there is nothing stopping you from cloning the wrapped connection and losing the lifetime tracking. <strong>Don&#39;t do this</strong>. If you work with connections from the pool, you should pass around either a <code>ConnectionRef</code> or a <code>&amp;Connection</code> to make sure the underlying <code>ConnectionRef</code> stays alive.</p>
<p>Incorrect usage of <code>ConnectionRef</code>:</p>

<p>Correct usage of <code>ConnectionRef</code>:</p>

<p>We experimented with a safer callback-based API, but it turned out to be just too inconvenient to use.</p>

<p>Iroh-blobs is a protocol that tries to avoid overabstraction. For example as of now you can only use the BLAKE3 hash function, and we hardcode the chunk group size to a value that should work well for all users.</p>
<p>But sometimes there are cases where a bit of abstraction is needed. There was a user request to be able to use compression with iroh-blobs in <a href="https://www.iroh.computer/sendme">sendme</a>. One way to do this is to compress files before adding them to the blob store. But this has various downsides. It requires you to create a copy of all data before adding it to the blob store, and will also not lead to very good compression rates when dealing with a large number of small files, since each file will have to be compressed in isolation.</p>
<p>It would be better to compress requests and response streams of the entire protocol and expose the resulting protocol under a different ALPN. With this approach the compression algorithm would be able to find redundancies between multiple files when handling a request for multiple blobs.</p>
<p>This was previously impossible since iroh-blobs worked directly with <a href="https://docs.rs/iroh/latest/iroh/endpoint/struct.SendStream.html"><code>iroh::endpoint::SendStream</code></a> and <a href="ttps://docs.rs/iroh/latest/iroh/endpoint/struct.RecvStream.html"><code>iroh::endpoint::RecvStream</code></a>. So we added traits to allow wrapping send and receive stream in a transform such as compression/decompression.</p>
<p>By default, iroh-blobs still works directly with <code>iroh::endpoint::SendStream</code> and <code>iroh::endpoint::RecvStream</code>, so for normal use nothing changes.</p>
<p>The traits are a bit similar to <a href="https://docs.rs/futures/latest/futures/stream/trait.Stream.html">Stream</a> and <a href="https://docs.rs/futures/latest/futures/io/struct.Sink.html">Sink</a>, but with two important additions.</p>
<ul>
<li>
<p>We allow sending and receiving <a href="https://docs.rs/bytes/latest/bytes/struct.Bytes.html">Bytes</a>, since iroh streams work with bytes internally. That way we avoid a copy in the default case.</p>
</li>
<li>
<p>We have methods <a href="https://docs.rs/iroh-blobs/latest/iroh_blobs/util/trait.RecvStream.html#tymethod.stop">stop</a> and <a href="https://docs.rs/iroh-blobs/latest/iroh_blobs/util/trait.SendStream.html#tymethod.reset">reset</a> to close the stream, and on the send stream a method <a href="https://docs.rs/iroh-blobs/latest/iroh_blobs/util/trait.SendStream.html#tymethod.stopped">stopped</a> that returns a future that resolves when the remote side has closed the stream.</p>
</li>
</ul>
<p>Wrapping the entire iroh-blobs protocol into compression is pretty straightforward except for some boilerplate. We have an example <a href="https://github.com/n0-computer/iroh-blobs/blob/f469e50b2c74623f23b84560d4c088e6c0ac6e4b/examples/compression.rs">compression.rs</a> that shows how to do this.</p>
<p>We will have this as an optional feature of <a href="https://www.iroh.computer/sendme">sendme</a> in one of the next releases.</p>
<p>Just like the connection pool, these traits are generally useful whenever you want to derive iroh protocols by wrapping existing protocols, so they will move to a separate crate once iroh 1.0 is released.</p>

<div><svg viewBox="0 0 16 16" aria-hidden="true"><circle cx="8" cy="8" r="8" stroke-width="0"></circle><path fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M6.75 7.75h1.5v3.5"></path><circle cx="8" cy="4" r=".5" fill="none"></circle></svg><p>This change is from iroh-blobs 0.93</p></div>
<p>On the provider side, it is now possible to have very detailed events about what the provider is doing. The provider events are now implemented as an <a href="https://docs.rs/irpc/latest/irpc/">irpc</a> protocol. For each request type you can use an event mask to configure if you want to be notified at all, and if you need the ability to intercept the request, e.g. if you only want to serve certain hashes.</p>
<p>There is an <a href="https://github.com/n0-computer/iroh-blobs/blob/f469e50b2c74623f23b84560d4c088e6c0ac6e4b/examples/limit.rs">example</a> how to use the new provider events to limit by provider node id or hash.</p>
<p>Here is a provider event handler that serves only blobs requests for hashes in a fixed set of allowed hashes:</p>


<p>The next major feature in iroh-blobs will be a minimal version of multiprovider downloads for individual blobs.</p>
<p>As soon as iroh 1.0 is released, several generic parts of iroh-blobs will move to a separate iroh utilities crate.</p><div><p>Iroh is a dial-any-device networking library that just works. Compose from an ecosystem of ready-made protocols to get the features you need, or go fully custom on a clean abstraction over dumb pipes. Iroh is open source, and already running in production on hundreds of thousands of devices.</p></div></div></div>
  </body>
</html>
