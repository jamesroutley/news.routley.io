<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ntietz.com/blog/rust-complain-yaml-errors/?utm_source=atom&amp;utm_medium=feed">Original</a>
    <h1>Making Rust builds fail from YAML config mistakes</h1>
    
    <div id="readability-page-1" class="page"><div><p>I was talking to a friend recently, and zie<sup><a href="#pronoun">1</a></sup> lamented that <a href="https://loco.rs/">a Rust web framework</a> uses YAML for its configuration.
I&#39;m far from one to defend YAML<sup><a href="#trauma">2</a></sup>, but dug in a little to understand zir issues with it: is it the trauma here, or is it something else?
Ultimately, zie wanted something that I also seek in Rust: compile time errors over runtime errors.</p>

<p>My first thought was to use a test to check the configuration.
This winds up pretty straightforward.</p>
<pre data-lang="rust"><code data-lang="rust">use loco_rs::{config::Config, environment::Environment};

#[test]
fn can_load_development_config() {
    let config = Config::new(&amp;Environment::Development);
    assert!(config.is_ok());
}
</code></pre>
<p>We try to load the config from its default location (<code>./config/development.yaml</code>), then we check that it did actually load successfully!</p>
<p>This is a partial solution.
It detects major errors, like malformed YAML files or missing required options.
But it misses the subtle mistakes that can saddle you with a misconfiguration, like misspelling <code>binding</code> as <code>bindimg</code>.
Misspelled optional configs are one of the things that can plague a debugging session.
You think you&#39;ve made a change, but you haven&#39;t, and it&#39;s often hard to notice a misspelling.</p>
<p>Can we solve this, too?</p>
<p>You bet we can.
Kind of.</p>
<p>The naive idea, which doesn&#39;t work well, is to deserialize it into an any-valued type, then round-trip the loaded config as well into one of those, and see if there&#39;s anything extra!
This <em>could</em> work, but you can&#39;t do it without a lot of extra effort, since you can&#39;t use direct equality.
The one you deserialize, serialize, deserialize again, will have some fields that were <em>added</em> when you serialized it since they were loaded as default values.</p>
<p>Instead, we can use <a href="https://github.com/dtolnay/serde-ignored">serde_ignored</a> to detect fields which are ignored during deserialization.
We can adapt the example from the crate&#39;s README and wind up with this test.
Instead of using the built-in loader we have to read the file in from the disk ourselves and render it (the config file is templated), then deserialize it with our nice <code>serde_ignored</code> wrapper.</p>
<pre data-lang="rust"><code data-lang="rust">#[test]
fn no_extra_fields_in_development_config() {
    let filename = &#34;./config/development.yaml&#34;;

    let raw_content = std::fs::read_to_string(filename).unwrap();
    let context = Context::new();
    let rendered_content = Tera::one_off(&amp;raw_content, &amp;context, false).unwrap();

    let deserializer = serde_yaml::Deserializer::from_str(rendered_content.as_str());

    let mut unused_fields = HashSet::new();

    let _config: Config = serde_ignored::deserialize(deserializer, |path| {
        unused_fields.insert(path.to_string());
    })
    .unwrap();

    assert!(
        unused_fields.is_empty(),
        &#34;got unexpected fields: {:?}&#34;,
        unused_fields
    );
}
</code></pre>
<p>And then when we run it, we get what we were looking for.</p>
<pre data-lang="text"><code data-lang="text">running 2 tests
test config::tests::can_load_development_config ... ok
test config::tests::no_extra_fields_in_development_config ... FAILED

failures:

---- config::tests::no_extra_fields_in_development_config stdout ----
thread &#39;config::tests::no_extra_fields_in_development_config&#39; panicked at src/config.rs:31:9:
got unexpected fields: {&#34;server.bindimg&#34;}
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>It tells us that we have an unused field and exactly which one it is.
Now we can fix our typo and go on our way!</p>
<p>This is how I would do it for a real project.
It leaves the config separate from the build so that it can compile even if YAML is messed up, while still giving you guardrails for catching mistakes.
But that&#39;s not where the fun ends, because zie specifically wanted a <em>compile-time</em> error.
Well, Anya, you&#39;re in luck.
I gotchu.</p>

<p>Rust lets you hook into the build system by writing a <code>build.rs</code> file.
It runs before your crate compiles, so you can&#39;t really access what&#39;s in there.
Usually this is used to compile parts that are written in other languages, or for doing code generation.</p>
<p>We can certainly abuse it for this, though!</p>
<p>Let&#39;s check if the YAML is malformed first, then worry about detecting unused fields as well.
First, we&#39;ll add a few dependencies in the <code>build-dependencies</code> section of our <code>Cargo.toml</code> file.
I added <code>loco-rs</code>, <code>serde</code>, <code>serde_yaml</code>, <code>serde_ignored</code>, and <code>tera</code>.
We&#39;ll only need loco and serde to start, but we&#39;ll use the others eventually as well.</p>
<p>Even though these exist already as dependencies (if we&#39;re using Loco), we have to add them as <em>build</em> dependencies so that they&#39;re pulled in early.
This is not a small decision, because it impacts build times, requiring them to be compiled before starting the rest of your build!</p>
<p>After adding those dependencies, we can write a simple script.
We&#39;ll just load the config and, if it fails, we print an error and exit with an error code.</p>
<pre data-lang="rust"><code data-lang="rust">use std::process::exit;

use loco_rs::{config::Config, environment::Environment};

fn main() {
    println!(&#34;cargo::rerun-if-changed=config/development.yaml&#34;);

    let config = Config::new(&amp;Environment::Development);
    if let Err(err) = config {
        println!(&#34;Error while loading the config: {}&#34;, err);
        exit(1);
    }
}
</code></pre>
<p>Now if we run this with malformed configs, we get an error.
Neat!</p>
<pre data-lang="text"><code data-lang="text">&gt; cargo build
   Compiling premove v0.1.0 (/home/nicole/Code/premove-chess)
error: failed to run custom build command for `premove v0.1.0 (/home/nicole/Code/premove-chess)`

Caused by:
  process didn&#39;t exit successfully: `/home/nicole/Code/premove-chess/target/debug/build/premove-f804d605420bf9b9/build-script-build` (exit status: 1)
  --- stdout
  cargo::rerun-if-changed=config/development.yaml
  Error while loading the config: cannot parse `config/development.yaml`: could not find expected &#39;:&#39; at line 168 column 3, while scanning a simple key at line 167 column 1
</code></pre>
<p>We have the same problem as before, though, of only getting <em>some</em> errors.
Let&#39;s copy that over.
But this time, we&#39;ll be a little nicer, and we&#39;ll call unused fields a warning instead of an error<sup><a href="#no-warnings">3</a></sup>.</p>
<p>This looks basically like our test did except that, instead of storing the fields in a set to check for emptiness, we print out a warning each time we hit one.
These are printed in a particular format so that we can tell Cargo they&#39;re warnings to pass along.</p>
<pre data-lang="rust"><code data-lang="rust">use loco_rs::config::Config;
use tera::{Context, Tera};

fn main() {
    println!(&#34;cargo::rerun-if-changed=config/development.yaml&#34;);

    let filename = &#34;./config/development.yaml&#34;;

    let raw_content = std::fs::read_to_string(filename).unwrap();
    let context = Context::new();
    let rendered_content = Tera::one_off(&amp;raw_content, &amp;context, false).unwrap();

    let deserializer = serde_yaml::Deserializer::from_str(rendered_content.as_str());

    let _config: Config = serde_ignored::deserialize(deserializer, |path| {
        println!(&#34;cargo::warning=Unused field in {}: {}&#34;, filename, path.to_string());
    })
    .unwrap();
}
</code></pre>
<p>Now we get this nice little warning if we have an unused field!</p>
<pre data-lang="text"><code data-lang="text">&gt; cargo build
   Compiling premove v0.1.0 (/home/nicole/Code/premove-chess)
warning: premove@0.1.0: Unused field in ./config/development.yaml: server.bindimg
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 6.47s
</code></pre>

<p>This is probably a bad idea and you shouldn&#39;t do it.
The testing approach is <em>much</em> better.</p>
<p>First off, people ignore test failures much less than they ignore warnings.
But if you made unused fields fail the <em>compile step</em>, then you wouldn&#39;t even be able to run any tests at all, which seems like the wrong trade-off to me (since the code itself isn&#39;t wrong).</p>
<p>Then you have the overhead of the build.
If you do this in <code>build.rs</code>, you end up bringing quite a few dependencies into the <code>build-dependencies</code> section.
This seems like a bad idea since you&#39;re adding a lot of overhead to the upfront stage of compilation, and you also risk these drifting out of sync with the rest of your code.
Cargo will reuse them if it <em>can</em>, but it can&#39;t do that if you end up on different versions in build.rs and elsewhere.</p>
<p>But perhaps most important is that this is <em>incredibly opaque</em>.
If you shove important checks into <code>build.rs</code>, people won&#39;t find them as much.
Tests are something we should all be familiar with and using; far fewer of us spelunk into our build systems.
By putting an important check in there, you&#39;re hiding it from most people on the project.</p>
<p>But <em>do</em> think about putting it in your tests.
It&#39;s a nice way to shorten some frustrating debugging sessions.</p>
<hr/>
<div id="pronoun"><p><sup>1</sup></p><p>Zie uses zie/zir/zirs pronouns and has a handy pronunciation guide on <a href="https://annahope.me/">zir homepage</a>.</p>
</div>
<div id="trauma"><p><sup>2</sup></p><p>I&#39;ve been traumatized by the piles of YAML that constitute Kubernetes and Helm configurations.</p>
</div>
<div id="no-warnings"><p><sup>3</sup></p><p>All warnings should be treated as errors in CI, but it&#39;s nice to be able to still, you know, <em>compile things</em> locally while developing even if you dare leave an unused variable for a moment.
Yes, looking at you, Go.</p>
</div>
</div><p>
    If this post was enjoyable or useful for you, <strong>please share it!</strong>
    If you have comments, questions, or feedback, you can email <a href="mailto:me@ntietz.com">my personal email</a>.
    To get new posts and support my work, subscribe to the <a href="https://ntietz.com/newsletter/">newsletter</a>. There is also an <a href="https://ntietz.com/atom.xml">RSS feed</a>.
  </p></div>
  </body>
</html>
