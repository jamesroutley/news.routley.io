<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://justine.lol/ftrace/">Original</a>
    <h1>Logging C Functions</h1>
    
    <div id="readability-page-1" class="page"><p>
May 19<sup>th</sup>, 2022 @ <a href="https://justine.lol/index.html"> justine&#39;s web page</a>

</p>

<p>
One of my favorite features of the
<a href="https://justine.lol/cosmopolitan/">Cosmopolitan Libc</a> runtime is its
<code>--ftrace</code> flag that logs C function calls. It&#39;s the simplest
system for debugging programs I&#39;ve ever used and it surprises me that I
found no evidence of someone having invented it before.

</p><p>
Here&#39;s one of its most important use cases. Have you ever had you
debugger stupified by a NULL function pointer before? Debuggers aren&#39;t
very good at handling this situation. Because once the control flow
jumps to the NULL page, you&#39;d need to find a way to rewind execution
history to figure out how it got there. But if you have function call
logging, you can just look backwards in the log, see what was happening
before, and get a pretty good idea.

</p><p>
For example, here&#39;s what happens if I run a Hello World! program:

</p><pre>$ o//examples/hello.com --ftrace
<strong><span>#     tid   nanoseconds   stack symbol</span></strong>
FUN 32679        91&#39;942     176   &amp;__cxa_atexit
FUN 32679        92&#39;211      80 &amp;atexit
FUN 32679        92&#39;302     144   &amp;__cxa_atexit
FUN 32679        93&#39;386      48 &amp;main
FUN 32679        93&#39;469      96   &amp;puts
FUN 32679        93&#39;575     112     &amp;stdio_unlock
FUN 32679        93&#39;673     224       &amp;fwrite_unlocked
FUN 32679        93&#39;945     112     &amp;stdio_unlock
FUN 32679        94&#39;040     160       &amp;fputc_unlocked
FUN 32679        94&#39;133     256         &amp;fwrite_unlocked
FUN 32679        94&#39;244     352           &amp;write
hello world
FUN 32679        94&#39;605      64 &amp;exit
FUN 32679        94&#39;771     160     &amp;FreeFds
FUN 32679        94&#39;912     144     &amp;fflush_unlocked
FUN 32679        95&#39;006     160       &amp;stdio_unlock
FUN 32679        95&#39;106     208         &amp;fflush_unlocked
FUN 32679        95&#39;214     240           &amp;__fflush_impl
</pre>

<p>
In the above log, you&#39;ll see:

</p><ol>
<li>the process pid (or tid if using threads)
</li><li>the number of nanoseconds elapsed since the program started (you&#39;ll
  notice it takes 91Âµs to load symbol table from the .com.dbg file,
  sort it so it can be binary searched, and then rewrite the binary
  in memory)
</li><li>the current stack usage in bytes
</li><li>the symbol name with depth (by backcounting rbp frames)
</li></ol>

<p>
The nanosecond timestamps are particularly useful for pinpointing
latency issues in programs. One of the biggest blindspots of open source
tools has always been the lack of focus on latency. For example, the
wonderful <code>perf record</code> command on Linux won&#39;t give you this
kind of insight:

</p><pre>FUN 10808        91&#39;065      80 &amp;atexit
FUN 10808        91&#39;242     144   &amp;__cxa_atexit
FUN 10808        92&#39;542      48 &amp;main
FUN 10808        92&#39;638      64   &amp;creat
FUN 10808        92&#39;771     240     &amp;openat
FUN 10808        92&#39;876     320       &amp;sys_openat
FUN 10808       109&#39;805     144   &amp;write
FUN 10808       183&#39;356      80   &amp;fsync
FUN 10808   194&#39;399&#39;931      96   &amp;close
FUN 10808   194&#39;410&#39;030     112     &amp;__releasefd_unlocked
FUN 10808   194&#39;410&#39;962      64 &amp;exit
FUN 10808   194&#39;411&#39;708     112   &amp;__cxa_finalize
FUN 10808   194&#39;412&#39;713     160     &amp;FreeFds
</pre>

<p>
One of the things we&#39;ve been focusing on lately has been making the
Python unit tests go faster. Since we use Python&#39;s unit tests to test
Cosmopolitan Libc. One of the biggest culprits has always been fsync()
at least for those of us who don&#39;t use tmpfs. It would frequently cause
individual tests to lag for as long as thirty seconds. Every other tool
we used for measuring the performance of these tests, all led us astray
suggesting that we focus on the core Python evaluator loop. But all that
was really needed was adding a way to pacify pointless fsync() calls.

</p><p>
The way these logs work, is they apply to functions at the object code
level. For example, if a function gets inlined, then it won&#39;t show up in
the function call trace. Another thing the log does is fold repeated
lines. For example, if you call a pure function in a loop (pure in the
sense that it doesn&#39;t call any additional subroutines) then you&#39;ll only
see one line for it in the log with the cumulative timestamp. For
example, if you were to say:

</p><pre><span>dontinline</span> <span>void</span> <span>Pause</span>(<span>void</span>) {
  <span>asm</span>(<span>&#34;rep nop&#34;</span>);
}

<span>dontinline</span> <span>void</span> <span>DoStuff</span>(<span>void</span>) {
  <span>for</span> (<span>int</span> i = 0; i &lt; 10000; ++i) {
    Pause();
  }
}

<span>int</span> <span>main</span>() {
  DoStuff();
  DoStuff();
  DoStuff();
  DoStuff();
}
</pre>

<p>
Then you would get:

</p><pre>FUN 11650       103&#39;932      80 &amp;atexit
FUN 11650       104&#39;082     144   &amp;__cxa_atexit
FUN 11650       104&#39;402      48 &amp;main
FUN 11650       104&#39;493      72   &amp;DoStuff
FUN 11650       104&#39;571      88     &amp;Pause
FUN 11650     1&#39;084&#39;906      72   &amp;DoStuff
FUN 11650     1&#39;085&#39;073      88     &amp;Pause
FUN 11650     2&#39;054&#39;060      72   &amp;DoStuff
FUN 11650     2&#39;054&#39;174      88     &amp;Pause
FUN 11650     3&#39;154&#39;500      72   &amp;DoStuff
FUN 11650     3&#39;154&#39;599      88     &amp;Pause
FUN 11650     4&#39;172&#39;376      64 &amp;exit
FUN 11650     4&#39;172&#39;511     112   &amp;__cxa_finalize
FUN 11650     4&#39;172&#39;651     160     &amp;FreeFds
</pre>

<p>
In terms of how the flag is interpreted, sometimes it&#39;s useful to be
able to have <code>--ftrace</code> be in the arguments list, possibly
because you&#39;re passing it along to a subprocess you&#39;re executing. In
that case, if you add two additional dashes:

</p><pre>./foo.com ----ftrace
</pre>

<p>
Then <code>&#34;--ftrace&#34;</code> will appear in the <code>argv</code> array
passed to main. Additional slashes can be supplied too, for additional
layers of nesting.

</p><h2>Getting Started</h2>

<p>
Run the following commands on Linux:

</p><pre>curl https://justine.lol/cosmopolitan/cosmopolitan.zip &gt;cosmopolitan.zip
unzip cosmopolitan.zip
<span>echo</span> <span>&#39;int main() { printf(&#34;hello world\n&#34;); }&#39;</span> &gt;hello.c
gcc -g -Os -static -nostdlib -nostdinc -no-pie -fno-pie  \
    -fno-omit-frame-pointer -pg -mnop-mcount             \
    -o hello.com.dbg hello.c -fuse-ld=bfd -Wl,-T,ape.lds \
    -include cosmopolitan.h crt.o ape.o cosmopolitan.a
objcopy -S -O binary hello.com.dbg hello.com
./hello.com --ftrace
</pre>

<h2>How It Works</h2>

<p>
The Cosmopolitan Libc <code>_start()</code> function starts by
<a href="https://github.com/jart/cosmopolitan/blob/c8a2f040584691fb38062cf0d58b729e7881288c/libc/runtime/ftraceinit.greg.c#L35">intercepting
the <code>--ftrace</code> flag</a>. If it exists, then
it <a href="https://github.com/jart/cosmopolitan/blob/c8a2f040584691fb38062cf0d58b729e7881288c/libc/runtime/opensymboltable.greg.c#L109">opens
and sorts of the symbol table</a> from the elf binary. Then
it <a href="https://github.com/jart/cosmopolitan/blob/c8a2f040584691fb38062cf0d58b729e7881288c/libc/runtime/morph.greg.c#L60">changes
the protection of memory</a> so it&#39;s able to iterate over the program&#39;s
memory to <a href="https://github.com/jart/cosmopolitan/blob/master/libc/runtime/hook.greg.c#L106">look for nop instructions it can mutate</a>.
Those NOPs were inserted by GCC. It&#39;s easy to self-modify them in
memory, since they have the same byte length as the CALL instruction.
Think of it like a mini linker. It just relinks the profiling nops. Once
they&#39;ve been rewritten, functions will start calling
<a href="https://github.com/jart/cosmopolitan/blob/c8a2f040584691fb38062cf0d58b729e7881288c/libc/runtime/ftrace-hook.S#L22">ftrace_hook()</a>
which is an assembly function that saves the CPU state to the stack. That means ftrace kind of acts
like an operating system kernel. Once the assembly saved the CPU it can
<a href="https://github.com/jart/cosmopolitan/blob/c8a2f040584691fb38062cf0d58b729e7881288c/libc/runtime/ftracer.c#L108">call
the ftracer() C code</a> that acquires a reentrant mutex and unwinds the
RBP backtrace pointer (via <code>__builtin_frame_address(0)</code>) to
determine the address of the function that called it. Once it has the
address of the function, it passes it along to kprintf() which has
a <a href="https://github.com/jart/cosmopolitan/blob/c8a2f040584691fb38062cf0d58b729e7881288c/libc/intrin/kprintf.greg.c#L519">special <code>%t</code>
syntax</a> for turning numbers into symbols.

</p><p>
GCC has several flags for inserting profiling hooks at the beginning of
functions. Namely <code>-pg</code>, <code>-mfentry</code>,
and <code>-mnop-mcount</code>. The last one is important. Because the
default behavior is to insert a function call to the <code>mcount</code>
function.

</p><pre><span>Pause</span>:	<span>push</span>	<span>%rbp</span>
	<span>mov</span>	<span>%rsp</span>,<span>%rbp</span>
1:	<span>call</span>	mcount
	<span>rep nop</span>
	<span>pop</span>	<span>%rbp</span>
	<span>ret</span>
	<span>.endfn</span>	Pause,globl
</pre>

<p>
Cosmopolitan Libc&#39;s mcount function does nothing, and the cost of
calling an empty function can be as high as 14 cycles of overhead per
function call. However if you can get GCC to insert NOPs instead:

</p><pre><span>Pause</span>:	<span>push</span>	<span>%rbp</span>
	<span>mov</span>	<span>%rsp</span>,<span>%rbp</span>
1:	<span>nopl</span>	0x00(<span>%rax</span>,<span>%rax</span>,1)
	<span>rep nop</span>
	<span>pop</span>	<span>%rbp</span>
	<span>ret</span>
	<span>.endfn</span>	Pause,globl
</pre>

<p>
Then the overhead is negligible on the order of picoseconds. So it&#39;s
worth considering just always having the <code>-pg</code> nops in your
program. Because Cosmopolitan Libc will self-modify your executable at
runtime to turn those NOPs into function calls once you&#39;ve enabled it.
In fact, there&#39;s even a runtime function that lets you insert an
arbitrary hook into your program&#39;s functions:

</p><pre><span>privileged noinstrument</span> <span>void</span> <span>MyTracer</span>(<span>void</span>) {
  kprintf(&#34;hello\n&#34;);
}
<span>int</span> <span>main</span>() {
  __hook(MyTracer, GetSymbolTable());
}
</pre>

<p>
Since there&#39;s multiple profiling hooks that GCC uses depending on the
various combinations of flags, here&#39;s the hooks that <code>__hook</code>
will understand and be able to rewrite:

</p><pre>0f 1f 44 00 00          <span>nopl</span> 0x0(<span>%rax</span>,<span>%rax</span>,1)
67 0f 1f 04 00          <span>nopl</span> (<span>%eax</span>,<span>%eax</span>,1)
66 0F 1F 44 00 00       <span>nopw</span> 0x00(<span>%rax</span>,<span>%rax</span>,1)
67 e8 xx xx xx xx       <span>addr32</span> <span>call</span> mcount
</pre>

<p>
The reason why we need the <code>privileged</code> keyword above is
because some operating systems don&#39;t permit read+write+exec memory. So
when we rewrite the binary to change the NOPs into CALL, much of the
program&#39;s code needs to be disabled. Using the <code>privileged</code>
keyword will cause your function to be relocated to a special part of
the executable that never gets rewritten.

</p><h2>Custom Code Morphing</h2>

<p>
Let&#39;s say you wanted to write your own function that rewrites your
binary at runtime. Intel&#39;s disassembler Xed comes included in the
Cosmopolitan Libc amalgamation distro. So here&#39;s how you would, for
instance, iterate over all the instructions in your program:

</p><pre><span>privileged</span> <span>void</span> <span>RewriteBinary</span>(<span>void</span>) {
  <span>int</span> n, err;
  <span>unsigned char</span> *p;
  <span>struct</span> <span>XedDecodedInst</span> xedd;
  __morph_begin();
  <span>for</span> (p = _ereal; p &lt; __privileged_start; p += n) {
    xed_decoded_inst_zero_set_mode(&amp;xedd, XED_MACHINE_MODE_LONG_64);
    err = xed_instruction_length_decode(&amp;xedd, p, __privileged_start - p);
    if (err == XED_ERROR_NONE) {
      n = xedd.length;
    } <span>else</span> {
      n = 1;
    }
  }
  __morph_end();
}
</pre>

<h2>Measuring Language Complexity</h2>

<p>
The nice thing about Cosmopolitan&#39;s function tracing is that it&#39;s shell
scriptable and fast. Having this debugging information easily plugged
into the shell, means we can do things like study how many function
calls programming language interpreters need to print Hello World.

</p><pre>$ o//tool/plinko/plinko.com &lt;&lt;&lt;&#39;(QUOTE HELLO-WORLD)&#39; --ftrace |&amp; wc -l
819
$ o//third_party/sqlite3/sqlite3.com :memory: &#34;select &#39;hello world&#39;&#34; --ftrace |&amp; wc -l
6253
$ o//third_party/lua/lua.com -e &#39;print(&#34;hello&#34;)&#39; --ftrace |&amp; wc -l
9741
$ o//third_party/quickjs/qjs.com -e &#39;console.log(&#34;hello world&#34;)&#39; --ftrace |&amp; wc -l
42272
$ o//third_party/python/python.com -c &#39;print(&#34;hello world&#34;)&#39; --ftrace |&amp; wc -l
931354
</pre>

<p>
Here&#39;s the function logs if you&#39;re interested in reading them.

</p><pre>-rw-r--r-- 1 501 jart  43K May 19 19:29 <a href="https://justine.lol/ftrace/plinko.txt">plinko.txt</a>
-rw-r--r-- 1 501 jart 397K May 19 19:28 <a href="https://justine.lol/ftrace/sqlite.txt">sqlite.txt</a>
-rw-r--r-- 1 501 jart 751K May 19 19:27 <a href="https://justine.lol/ftrace/lua.txt">lua.txt</a>
-rw-r--r-- 1 501 jart 2.7M May 19 19:27 <a href="https://justine.lol/ftrace/qjs.txt">qjs.txt</a>
-rw-r--r-- 1 501 jart 150M May 19 19:28 <a href="https://justine.lol/ftrace/python.txt">python.txt</a>
</pre>

<p>
We&#39;re also integrating ftrace into all the programming languages that
are included in Cosmopolitan. For example, the <code>cosmo.ftrace</code>
context manager has been quite useful when testing CPython internals, or
writing extensions.

</p><pre><span>import</span> cosmo
<span>with</span> cosmo.ftrace() <span>as</span> F:
    WeirdFunction()
</pre>

<p>
This makes ftrace viable for Python since it&#39;s only enabled temporarily.
Otherwise there&#39;d simply be too many functions logged. If you want to
try using ftrace with Actually Portable Python, then you can build it on
Linux with the following commands:

</p><pre>git clone https://github.com/jart/cosmopolitan
cd cosmopolitan
make -j8 o//third_party/python/python.com
o//third_party/python/python.com
&gt;&gt;: import cosmo
&gt;&gt;: cosmo?
</pre>

<p>
There&#39;s also a prebuilt binary here:

</p><pre>-rwxr-xr-x 1 501 jart 11M May 20 06:25 <a href="https://justine.lol/ftrace/python.com">python.com</a>
</pre>

<h2>System Call Logging</h2>

<p>
While we&#39;re on the topic of tracing, it&#39;s also worth mentioning that
Cosmopolitan Libc bakes a similar <code>--strace</code> flag into
binaries. For example, if we were to trace a program that calls fsync():

</p><pre><span>int</span> <span>main</span>() {
  creat(<span>&#34;foo&#34;</span>, 0644);
  write(3, _base, _end - _base);
  fsync(3);
  close(3);
}
</pre>

<p>
It might show us the following:

</p><pre>SYS     0              5&#39;590 bell system five system call support 97 magnums loaded on gnu/systemd
SYS   384              8&#39;664 mmap(0x700000000000, 131&#39;072, PROT_READ|PROT_WRITE, MAP_STACK|MAP_ANONYMOUS, -1, 0) â 0x700000000000
SYS   384             12&#39;702 getenv(&#34;TERM&#34;) â &#34;dumb&#34;
SYS   384          1&#39;926&#39;421 openat(AT_FDCWD, &#34;o/foo&#34;, O_WRONLY|O_CREAT|O_TRUNC, 0644) â 3
SYS   384          1&#39;973&#39;434 write(3, u&#34;âELFâ»âºâºâÂ Â Â Â Â Â Â Â â»Â &gt;Â âºÂ Â Â â!@Â Â Â Â Â Â âÂ Â Â Â Â Â &#34;..., 131&#39;072) â 131&#39;072
SYS   384         29&#39;834&#39;148 fysnc(3) â 0
SYS   384         29&#39;839&#39;878 close(3) â 0
SYS   384         29&#39;840&#39;030 exit(0)
SYS   384         29&#39;840&#39;324 __cxa_finalize(&amp;407eef, 0)
SYS   384         29&#39;840&#39;445 FreeFds()
SYS   384         29&#39;840&#39;729 _Exit(0)
</pre>

<p>
It&#39;s been an indispensable tool for building Cosmopolitan Libc, since
GDB and LLDB aren&#39;t very reliable when developing across platforms. For
instance, I haven&#39;t been able to figure out how to get a debugger or
system call tracer to work on Mac OS X for the better part of ten years.
So much of the XNU support needed to be written <em>a priori</em> until
this tool came along, which has greatly helped in reducing bugs!

</p><h2>Troubleshooting</h2>

<p>
In the above example, you may have noticed that a number
<code>&amp;407eef</code> was printed in place of a symbol. This is one
of the tradeoffs that needed to be made by Cosmopolitan Libc&#39;s kprintf()
function, which is too mission critical to be able to call into all the
non-privileged code needed to open() + mmap() + etc. the concomitant ELF
.com.dbg binary and load the symbol table. The simple solution for this
is to have your main function call <code>GetSymbolTable()</code>:

</p><pre><span>int</span> <span>main</span>() {
  GetSymbolTable();
  creat(<span>&#34;foo&#34;</span>, 0644);
  write(3, _base, _end - _base);
  fsync(3);
  close(3);
}
</pre>

<p>
Now the symbols should show up:

</p><pre>SYS   401         25&#39;825&#39;348 __cxa_finalize(<strong>&amp;FreeFds</strong>, 0)
</pre>

<h2>Funding</h2>

<p>
  <a href="https://justine.lol/lemuria.png">
    <picture>
      <source srcset="//storage.googleapis.com/justine/sectorlisp2/lemuria.webp" type="image/webp"/>
      <img src="https://storage.googleapis.com/justine/sectorlisp2/lemuria.png" width="850" height="360" alt="[United States of Lemuria - two dollar bill - all debts public and primate]"/>
    </picture>
  </a>

</p><p>
Funding for this blog post was crowdsourced from Justine Tunney&#39;s
<a href="https://github.com/sponsors/jart">GitHub sponsors</a>
and <a href="https://www.patreon.com/jart">Patreon subscribers</a>. Your
support is what makes projects like Cosmopolitan Libc possible. Thank
you.

</p><h2>See Also</h2>

<ul>
<li><a href="https://justine.lol/cosmopolitan/">cosmopolitan libc</a>
</li><li><a href="https://justine.lol/">justine&#39;s web page</a>
</li></ul>

 
</div>
  </body>
</html>
