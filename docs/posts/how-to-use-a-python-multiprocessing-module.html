<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://developers.redhat.com/articles/2023/07/27/how-use-python-multiprocessing-module">Original</a>
    <h1>How to use a Python multiprocessing module</h1>
    
    <div id="readability-page-1" class="page"><div>
			<div>
									
								<div>
					<p>In this article, we will learn how to work with a specific Python class from the <a href="https://docs.python.org/3/library/multiprocessing.html">multiprocessing</a> module, the <a href="https://docs.python.org/3/library/multiprocessing.html#the-process-class">process</a> class. I will give you a quick overview with examples.</p>

<h2>What is a Python multiprocessing module?</h2>

<p>What better way of describing what the module than to pull from the official documentation? <a href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing"><span>Multiprocessing</span></a> is a package that supports spawning processes using an API similar to the <a href="https://docs.python.org/3/library/threading.html#module-threading"><span>threading</span></a> module. The <a href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing"><span>multiprocessing</span></a> package offers both local and remote concurrency, effectively side-stepping the <a href="https://docs.python.org/3/glossary.html#term-global-interpreter-lock"><span>Global Interpreter Lock</span></a> by using subprocesses instead of threads.</p>

<p>The threading module is not the focus of this article, but in summary, the threading module will handle a small segment of code execution (lightweight and with shared memory), while the multiprocessing one will handle a program execution (heavier, and totally isolated).</p>

<p>If you want to learn more about the difference between a process and a thread, read this amazing article by Jong Hyuck Won, <a href="https://medium.com/@denniswon/process-vs-thread-whats-the-difference-23cb30a772c4" target="_blank">Process vs Thread: What’s the difference?</a></p>

<p>In general, the multiprocessing module offers a variety of other classes, functions and utilities that one could use to handle multiple processes executing during your program execution. That module is specially designed to be the main point of interaction if a program needs to apply parallelism in its workflow. We won&#39;t go over all classes and utilities from the multiprocessing module, but rather, we will focus on a very specific class, the <a href="https://docs.python.org/3/library/multiprocessing.html#the-process-class">process</a> class.</p>

<h2>What is the process class?</h2>

<p>In this section, we will try to give a better scope of what a process is, and how you can identify, use and manage processes within Python. As explained in the <a href="https://www.gnu.org/software/libc/manual/html_node/Processes.html">GNU C Library</a>: &#34;Processes are the primitive units for allocation of system resources. Each process has its own address space and (usually) one thread of control. A process executes a program; you can have multiple processes executing the same program, but each process has its own copy of the program within its own address space and executes it independently of the other copies.&#34;</p>

<p>But what does that look like in Python? So far, we have managed to give some descriptions and references to what a process is, the difference between a process and a thread, but we haven&#39;t touched any code so far. Well, let&#39;s change that and do a very simple example of a process in Python:</p>

<pre><code>#!/usr/bin/env python
import os

# A very, very simple process.
if __name__ == &#34;__main__&#34;:
    print(f&#34;Hi! I&#39;m process {os.getpid()}&#34;)
</code></pre>

<p>Which will produce the following output:</p>

<pre><code>[r0x0d@fedora ~]$ python /tmp/tmp.iuW2VAurGG/scratch.py
Hi! I&#39;m process 144112
</code></pre>

<p>As you can see, any running Python script or program is a process of its own.</p>

<h3>Creating a child process from your parent</h3>

<p>And what about spawning different child processes inside your parent process? Well, to do that, we have the aid of the <code>Process</code> class from multiprocessing module, and it looks like this:</p>

<pre><code>#!/usr/bin/env python
import os
import multiprocessing

def child_process():
    print(f&#34;Hi! I&#39;m a child process {os.getpid()}&#34;)

if __name__ == &#34;__main__&#34;:
    print(f&#34;Hi! I&#39;m process {os.getpid()}&#34;)

    # Here we create a new instance of the Process class and assign our
    # `child_process` function to be executed.
    process = multiprocessing.Process(target=child_process)

    # We then start the process
    process.start()

    # And finally, we join the process. This will make our script to hang and
    # wait until the child process is done.
    process.join()
</code></pre>

<p>Which will produce the following output:</p>

<pre><code>[r0x0d@fedora ~]$ python /tmp/tmp.iuW2VAurGG/scratch.py
Hi! I&#39;m process 144078
Hi! I&#39;m a child process 144079
</code></pre>

<p>A very important note about the previous script: if you don&#39;t use the <code>process.join()</code> to wait for your child process to execute and finish, then any other subsequent code that point will actually execute and may become a bit harder to synchronize your workflow.</p>

<p>Consider the following example:</p>

<pre><code>#!/usr/bin/env python
import os
import multiprocessing

def child_process():
    print(f&#34;Hi! I&#39;m a child process {os.getpid()}&#34;)

if __name__ == &#34;__main__&#34;:
    print(f&#34;Hi! I&#39;m process {os.getpid()}&#34;)

    # Here we create a new instance of the Process class and assign our
    # `child_process` function to be executed.
    process = multiprocessing.Process(target=child_process)

    # We then start the process
    process.start()

    # And finally, we join the process. This will make our script to hang and
    # wait until the child process is done.
    #process.join()

    print(&#34;AFTER CHILD EXECUTION! RIGHT?!&#34;)
</code></pre>

<p>This snippet will produce the following output:</p>

<pre><code>[r0x0d@fedora ~]$ python /tmp/tmp.iuW2VAurGG/scratch.py
Hi! I&#39;m process 145489
AFTER CHILD EXECUTION! RIGHT?!
Hi! I&#39;m a child process 145490</code></pre>

<p>Of course, it is not correct to affirm that the above snippet is wrong. It will all depend on how you want to use the module and how your child processes will execute. So use it wisely.</p>

<h3>Creating various child processes from a parent process</h3>

<p>If you want to spawn multiple processes, you can take advantage of for-loops (or any other type of loops). They will let you create as many references to the processes you need, and at a later stage, <code>start/join</code><strong> </strong>them.</p>

<pre><code>#!/usr/bin/env python
import os
import multiprocessing

def child_process(id):
    print(f&#34;Hi! I&#39;m a child process {os.getpid()} with id#{id}&#34;)

if __name__ == &#34;__main__&#34;:
    print(f&#34;Hi! I&#39;m process {os.getpid()}&#34;)
    list_of_processes = []

    # Loop through the number 0 to 10 and create processes for each one of
    # them.
    for i in range(0, 10):
        # Here we create a new instance of the Process class and assign our
        # `child_process` function to be executed. Note the difference now that
        # we are using the `args` parameter now, this means that we can pass
        # down parameters to the function being executed as a child process.
        process = multiprocessing.Process(target=child_process, args=(i,))
        list_of_processes.append(process)

    for process in list_of_processes:
        # We then start the process
        process.start()

        # And finally, we join the process. This will make our script to hang
        # and wait until the child process is done.
        process.join()
</code></pre>

<p>That will produce the following output:</p>

<pre><code>[r0x0d@fedora ~]$ python /tmp/tmp.iuW2VAurGG/scratch.py
Hi! I&#39;m process 146056
Hi! I&#39;m a child process 146057 with id#0
Hi! I&#39;m a child process 146058 with id#1
Hi! I&#39;m a child process 146059 with id#2
Hi! I&#39;m a child process 146060 with id#3
Hi! I&#39;m a child process 146061 with id#4
Hi! I&#39;m a child process 146062 with id#5
Hi! I&#39;m a child process 146063 with id#6
Hi! I&#39;m a child process 146064 with id#7
Hi! I&#39;m a child process 146065 with id#8
Hi! I&#39;m a child process 146066 with id#9</code></pre>

<h3>Communicating data between child process and parent process</h3>

<p>In the previous section, I described the addition of a new parameter to the <code>multiprocessing.Process</code> class constructor, the <code>args</code>. This parameter allows you to pass down values to your child process to be used inside of the function. But do you know how to return data from the child process?</p>

<p>You may be thinking that to return data from the child, one must use the <code>return</code> statement inside of it to actually be able to retrieve the data. A process is wonderful to execute functions in an isolated way, without interfering with shared resources meaning that the normal and usual way that we know about returning data from functions. Here, is not allowed because of its isolation.</p>

<p>Instead, we can use the <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue" target="_blank">queue</a> class, which will provide us an interface to communicate data between the parent process and its child processes. A queue, in this context, is a normal FIFO (First In First Out) that has a built-in mechanism for working with multiprocessing.</p>

<p>Consider the following example:</p>

<pre><code>#!/usr/bin/env python
import os
import multiprocessing

def child_process(queue, number1, number2):
    print(f&#34;Hi! I&#39;m a child process {os.getpid()}. I do calculations.&#34;)
    sum = number1 + number2

    # Putting data into the queue
    queue.put(sum)

if __name__ == &#34;__main__&#34;:
    print(f&#34;Hi! I&#39;m process {os.getpid()}&#34;)

    # Defining a new Queue()
    queue = multiprocessing.Queue()

    # Here we create a new instance of the Process class and assign our
    # `child_process` function to be executed. Note the difference now that
    # we are using the `args` parameter now, this means that we can pass
    # down parameters to the function being executed as a child process.
    process = multiprocessing.Process(target=child_process, args=(queue,1, 2))

    # We then start the process
    process.start()

    # And finally, we join the process. This will make our script to hang and
    # wait until the child process is done.
    process.join()

    # Accessing the result from the queue.
    print(f&#34;Got the result from child process as {queue.get()}&#34;)
</code></pre>

<p>It will give the following output:</p>

<pre><code>[r0x0d@fedora ~]$ python /tmp/tmp.iuW2VAurGG/scratch.py
Hi! I&#39;m process 149002
Hi! I&#39;m a child process 149003. I do calculations.
Got the result from child process as 3
</code></pre>

<h3>Exception handling for the process class</h3>

<p>Handling exceptions is a special and somewhat difficult task that we have to go through from time to time while working with the process module. The reason for that is, by default, any exception that occurs inside a child process will always be handled by the <code>Process</code> class that spawned it.</p>

<p>The code below is raising an <code>Exception</code> with text:</p>

<pre><code>#!/usr/bin/env python
import os
import multiprocessing

def child_process():
    print(f&#34;Hi! I&#39;m a child process {os.getpid()}.&#34;)
    raise Exception(&#34;Oh no! :(&#34;)

if __name__ == &#34;__main__&#34;:
    print(f&#34;Hi! I&#39;m process {os.getpid()}&#34;)

    # Here we create a new instance of the Process class and assign our
    # `child_process` function to be executed. Note the difference now that
    # we are using the `args` parameter now, this means that we can pass
    # down parameters to the function being executed as a child process.
    process = multiprocessing.Process(target=child_process)

    try:
        # We then start the process
        process.start()

        # And finally, we join the process. This will make our script to hang and
        # wait until the child process is done.
        process.join()

        print(&#34;AFTER CHILD EXECUTION! RIGHT?!&#34;)
    except Exception:
        print(&#34;Uhhh... It failed?&#34;)
</code></pre>

<p>This results in:</p>

<pre><code>[r0x0d@fedora ~]$ python /tmp/tmp.iuW2VAurGG/scratch.py
Hi! I&#39;m process 149505
Hi! I&#39;m a child process 149506.
Process Process-1:
Traceback (most recent call last):
  File &#34;/usr/lib64/python3.11/multiprocessing/process.py&#34;, line 314, in _bootstrap
    self.run()
  File &#34;/usr/lib64/python3.11/multiprocessing/process.py&#34;, line 108, in run
    self._target(*self._args, **self._kwargs)
  File &#34;/tmp/tmp.iuW2VAurGG/scratch.py&#34;, line 7, in child_process
    raise Exception(&#34;Oh no! :(&#34;)
Exception: Oh no! :(
AFTER CHILD EXECUTION! RIGHT?!</code></pre>

<p>If you follow up the code, you will be able to notice that there is a <code>print</code> statement carefully placed after the <code>process.join()</code> call to simulate that the parent process is still running, even after an unhandled exception raised in its child.</p>

<p>One way of overcoming this situation is to actually handle the exception inside your child process as follows:</p>

<pre><code>#!/usr/bin/env python
import os
import multiprocessing

def child_process():
    try:
        print(f&#34;Hi! I&#39;m a child process {os.getpid()}.&#34;)
        raise Exception(&#34;Oh no! :(&#34;)
    except Exception:
        print(&#34;Uh, I think it&#39;s fine now...&#34;)

if __name__ == &#34;__main__&#34;:
    print(f&#34;Hi! I&#39;m process {os.getpid()}&#34;)

    # Here we create a new instance of the Process class and assign our
    # `child_process` function to be executed. Note the difference now that
    # we are using the `args` parameter now, this means that we can pass
    # down parameters to the function being executed as a child process.
    process = multiprocessing.Process(target=child_process)

    # We then start the process
    process.start()

    # And finally, we join the process. This will make our script to hang and
    # wait until the child process is done.
    process.join()

    print(&#34;AFTER CHILD EXECUTION! RIGHT?!&#34;)
</code></pre>

<p>Now your exceptions will be handled inside your child process, meaning you can control what will happen to it and what should be done in such cases.</p>

<h2>Final thoughts</h2>

<p>The <code>multiprocessing</code> module is very powerful when working and implementing solutions that will depend on executing in a parallel way, especially if used with the <code>Process</code> class. That adds this amazing possibility to execute any function in its own isolated process.</p>
					
															
				</div>
			</div>
		</div></div>
  </body>
</html>
