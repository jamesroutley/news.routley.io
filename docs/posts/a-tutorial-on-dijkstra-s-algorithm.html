<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eugeneha.ca/articles/tutorial-on-dijkstras-algorithm/">Original</a>
    <h1>A tutorial on Dijkstra&#39;s algorithm</h1>
    
    <div id="readability-page-1" class="page"><div id="text-addendum-economical-iteration-with-generator-functions">
<p>
Say we want to find the weighted distance from <code>a</code> to a particular node <code>b</code>. We can iterate through <code>wt_distances(G, a)</code> until we encounter <code>b</code>:
</p>

<div>
<pre><span>INF</span> = <span>float</span>(<span>&#34;inf&#34;</span>)  <span># Infinity</span>

<span>def</span> <span>wt_distance</span>(<span>G</span>, <span>a</span>, <span>b</span>):
    <span>&#34;&#34;&#34;Find the weighted distance from a to b.&#34;&#34;&#34;</span>
    <span>for</span> <span>x</span>, <span>d</span> <span>in</span> wt_distances(G, a):
        <span>if</span> x == b: <span>return</span> d
    <span>return</span> INF  <span># No path from a to b.</span>
</pre>
</div>

<p>
Though this works, it‚Äôs rather wasteful: calling <code>wt_distances(G, a)</code> computes <i>all</i> weighted distances from <code>a</code>, upfront. In the tale of search and rescue, it‚Äôs as if we continued searching after finding the hiker! Ideally, no further weighted distances should be computed once <code>b</code> is found.
</p>

<p>
Python provides a mechanism to enable more economical iteration: We can use a ‚Äã<a href="https://docs.python.org/3/reference/expressions.html#yieldexpr"><b><code>yield</code></b></a> statement to produce each weighted distance <i>on demand</i>, rather than returning them in bulk. In the code for <code>wt_distances()</code>, replace the line
</p>



<p>
with
</p>



<p>
and scrap <code>D</code> altogether.
</p>

<div>
<pre><span>def</span> <span>wt_distances</span>(<span>G</span>, <span>a</span>):
    <span>&#34;&#34;&#34;Generate finite weighted distances from a to the other nodes of G.&#34;&#34;&#34;</span>
    <span>V</span> = <span>set</span>()
    <span>Q</span> = [(0, a)]
    <span>while</span> Q:
        <span>d</span>, <span>x</span> = heappop(Q)
        <span>if</span> x <span>not</span> <span>in</span> V:
            <span>print</span>(f<span>&#34;Yield (</span>{x}<span>, </span>{d}<span>)&#34;</span>)  <span># Notify when a yield happens.</span>
            <span>yield</span> (x, d)  <span># Yield a weighted distance as soon as it&#39;s found.</span>
            V.add(x)
            heapextend(Q, ((d + w, y) <span>for</span> <span>y</span>, <span>w</span> <span>in</span> G[x].items() <span>if</span> y <span>not</span> <span>in</span> V))
</pre>
</div>

<p>
This alteration transforms <code>wt_distances()</code> from a function to a <b><a href="https://docs.python.org/3/glossary.html#term-generator">generator function</a></b>. Now when we call <code>wt_distances(G, a)</code>, we get an <b><a href="https://docs.python.org/3/glossary.html#term-iterator">iterator</a></b> of weighted distances rather than a list of them. Looping over <code>wt_distances(G, a)</code> only produces as many weighted distances as demanded.
</p>

<p>
Let‚Äôs see that this is indeed happening when we call <code>wt_distances(G, a)</code> from <code>wt_distance(G, a, b)</code>. Consider again the graph
</p>

<p><img width="263" alt="Example graph" src="https://github.com/google-research/example-graph-3.png"/></p><p>
as represented by the dictionary
</p>

<div>
<pre><span>G</span> = {0: {1: 1},
     1: {2: 2, 3: 1, 4: 3},
     2: {4: 2},
     3: {4: 2},
     4: {}}
</pre>
</div>

<p>
A provisional, ad hoc <code>print()</code> was injected in the code for <code>wt_distances()</code> to demonstrate that indeed no further weighted distances are computed once <code>b</code> is found. Running
</p>

<div>
<pre><span>for</span> b <span>in</span> G:
    <span>print</span>(f<span>&#34;wt_distance(G, 0, </span>{b}<span>) is </span>{wt_distance(G, 0, b)}<span>.</span><span>\n</span><span>&#34;</span>)
</pre>
</div>

<p>
produces
</p>

<pre id="org6e2844f">Yield (0, 0)
wt_distance(G, 0, 0) is 0.

Yield (0, 0)
Yield (1, 1)
wt_distance(G, 0, 1) is 1.

Yield (0, 0)
Yield (1, 1)
Yield (3, 2)
Yield (2, 3)
wt_distance(G, 0, 2) is 3.

Yield (0, 0)
Yield (1, 1)
Yield (3, 2)
wt_distance(G, 0, 3) is 2.

Yield (0, 0)
Yield (1, 1)
Yield (3, 2)
Yield (2, 3)
Yield (4, 4)
wt_distance(G, 0, 4) is 4.
</pre>

<p>
In contrast to the first version of <code>wt_distances()</code>, the generator-function version
</p>

<ul>
<li>Avoids superfluous computation‚Äîno need to compute all weighted distances when only a subset is required</li>

<li>Avoids superfluous storage‚Äîno accumulation is forced</li>

<li>Enables precise control flow‚Äîthe consumer of weighted distances controls how many to get</li>
</ul>

<p>
Moreover, we can recover the previous behavior of <code>wt_distances()</code> with the call
</p>



<p>
Thus the generator-function version of <code>wt_distances()</code> is a more flexible yet functionally equivalent replacement of the previous version of <code>wt_distances()</code>.
</p>

<div id="org6b8da0b">
<p>
<b>üë©‚Äçüè≠ Tinker</b> ‚Äî Modify the function <code>shortest_paths()</code> to exploit the improved economy of the generator-function version of <code>wt_distances()</code>. The issue is in the first line of the following function:
</p>

<div>
<pre><span>def</span> <span>shortest_paths</span>(<span>G</span>, <span>a</span>, <span>b</span>):
    <span>&#34;&#34;&#34;Collect the shortest weighted-length paths from a to b.&#34;&#34;&#34;</span>
    <span>d</span> = <span>dict</span>(wt_distances(G, a))  <span># Wasteful!</span>
    ...
</pre>
</div>

<p>
Collecting the iterator <code>wt_distances(G, a)</code> in a dictionary forces <i>all</i> weighted distances to be computed. But, as for <code>wt_distance()</code>, we only need to get weighted distances until we encounter <code>b</code>. Replace/rewrite the first line so that <code>d</code> is a dictionary as before, but with fewer keys.
</p>

<p>
<i>Hint</i>: One possibility is to use a helper generator-function that takes items from an iterator (or <a href="https://docs.python.org/3/glossary.html#term-iterable">iterable</a>) up to and <i>including</i> the first failure of some predicate function.
</p>

<div>
<pre><span>def</span> <span>itakewhile</span>(<span>p</span>, <span>xs</span>):
    <span>&#34;&#34;&#34;Take items x of xs up to and including the first false p(x).&#34;&#34;&#34;</span>
    <span>for</span> x <span>in</span> xs:
        <span>yield</span> x
        <span>if</span> <span>not</span> p(x):
            <span>break</span>
</pre>
</div>

<p>
(The standard-library function <code>itertools.takewhile()</code> is similar. However, it <i>excludes</i> the first failure of the predicate.)
</p>

<p>
<b>üë©‚Äçüè≠ Tinker</b> ‚Äî Complete the following code to write a generator function <code>shortest_paths_gen()</code> that <i>yields</i> shortest paths rather than collecting them.
</p>

<div>
<pre><span>def</span> <span>shortest_paths_gen</span>(<span>G</span>, <span>a</span>, <span>b</span>):
    <span>&#34;&#34;&#34;Generate the shortest weighted-length paths from a to b.&#34;&#34;&#34;</span>
    <span># The previous exercise was about improving the following line.</span>
    <span>d</span> = <span>dict</span>(wt_distances(G, a))
    <span>P</span> = [[b]]  <span># Subpaths are traversed *backwards* from b.</span>
    <span>while</span> P:   <span># Extend subpaths backwards toward a.</span>
        <span>p</span> = P.pop()
        <span>x</span> = p[-1]
        <span>dx</span> = d[x]
        <span>for</span> <span>u</span>, <span>du</span> <span>in</span> d.items():
            <span>if</span> x <span>in</span> G[u] <span>and</span> dx == du + G[u][x]:
                <span># u ‚Üí x is a final edge of a shortest path from a to x,</span>
                <span># so we can extend p toward a.</span>
                <span># When should we yield a path?</span>
                ...
</pre>
</div>

<p>
(<i>Hint</i>: You may need to reverse paths at some point.)
</p>

<p>
Suppose that <code>G</code> is again a dictionary (of dictionaries) representing the following graph:
</p>

<p><img width="263" alt="Example graph" src="https://github.com/google-research/example-graph-3-transparent.png"/></p><p>
Check that <code>shortest_paths_gen(G, 0, 4)</code> yields the two paths from node 0 to node 4:
</p>

<div>
<pre><span>assert</span> <span>sorted</span>(shortest_paths_gen(G, 0, 4)) == [[0, 1, 3, 4], [0, 1, 4]]
</pre>
</div>

<p>
<b>üë©‚Äçüè≠ Tinker</b> ‚Äî Use <code>shortest_paths_gen()</code> to write a function <code>shortest_path()</code> that finds a <i>single</i> shortest path. This is a one-liner:
</p>

<div>
<pre><span>def</span> <span>shortest_path</span>(<span>G</span>, <span>a</span>, <span>b</span>):
    <span>&#34;&#34;&#34;Find a shortest weighted-length path from a to b.&#34;&#34;&#34;</span>
    <span>return</span> <span>next</span>(shortest_paths_gen(G, a, b))
</pre>
</div>

<p>
Here <code>next()</code> gets the first item from the iterator (while simultaneously advancing it).
</p>

<p>
This implementation of <code>shortest_path()</code> is almost correct: calling <code>next(shortest_paths_gen(G, a, b))</code> gets a shortest path, if one exists; otherwise an exception is raised. Can you circumvent this exception and return the correct result? (<i>Hint</i>: <code>try</code>‚Äã/‚Äã<code>except</code> isn‚Äôt your only option. Read the <a href="https://docs.python.org/3/library/functions.html#next">documentation for ‚Äã<code>next</code>‚Äã</a>.)
</p>

</div>
</div></div>
  </body>
</html>
