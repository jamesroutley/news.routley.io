<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://macoy.me/blog/programming/LinkerLoaderIntro">Original</a>
    <h1>Bringing a dynamic environment to C: My linker project</h1>
    
    <div id="readability-page-1" class="page"><article>
<p>I&#39;m writing a linker. It&#39;s an unusual linker. It&#39;s focus is not on producing executable files. Instead, its focus is to facilitate rapid iteration on a program without having to re-link or re-open it after making changes. It is hot-loading of code at an object-file granularity.</p>
<p>I realized from reading Andreas Fredriksson&#39;s <a href="https://deplinenoise.wordpress.com/2012/02/11/hot-runtime-linking/">Hot Runtime Linking</a> (<a href="https://web.archive.org/web/20160506054425/https://deplinenoise.wordpress.com/2012/02/11/hot-runtime-linking/">archive.org</a>) that the dynamism I&#39;ve been wanting in a ahead-of-time compiled environment could be achieved by taking over the linking and loading stages. I made an attempt to support hot-reloading in <a href="https://macoy.me/blog/programming/CakelispIntro">Cakelisp</a>, but it was fragile and limited. Not only was working at the link/load stage a better fit, but it also meant I could hot-reload more than just code written in Cakelisp.</p>
<p>The goal of this linker is to bring a dynamic environment to compiled languages. I&#39;m calling it a &#34;linker/loader&#34; because its purpose isn&#39;t to create an executable like most linkers—its purpose is to link, load, and execute code, and allow doing that on a continuously running process.</p>
<p>By keeping the program running while making changes to it, I believe it will change how you think about the program. If iteration times are extremely low, you are more willing to try experiments. Over long development periods the time saved will add up, and the <a href="https://macoy.me/blog/programming/InterfaceFriction">low friction</a> to making changes will result in a better product.</p>

<p>Hot-reloading in C family languages is typically done via dynamic loading. On Windows, the dynamic loading happens via <code>LoadLibrary</code> on <code>.dll</code> files, while GNU/Linux uses <code>libdl</code> to load <code>.so</code> (&#34;shared object&#34;) files. However, this approach has many limitations:</p>
<ul>
<li>You must structure your project differently such that the reloadable parts are in dynamic libraries. Your build system and potentially your file organization get more complex.</li>
<li>Dynamic library variables aren&#39;t persisted across loads.<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a></li>
<li>Memory management across DLL boundaries can cause <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/potential-errors-passing-crt-objects-across-dll-boundaries?view=msvc-170">issues on Windows</a>. You may need to refactor your code which previously wasn&#39;t split into DLLs.</li>
<li>Different operating systems implement dynamic loading differently. On Windows, you even have to annotate all your code with the cumbersome <code>__declspec(dllexport)</code>, which is painful if you are used to Unix-style implicit exposure.</li>
</ul>
<p>Another alternative is just-in-time (JIT) compilation. The primary qualms I have with JIT systems are:</p>
<ul>
<li>They typically require limited interfaces to JITed code. This means you cannot change any code in the project, only e.g. the &#34;scripts&#34; part of it. It is difficult to get the boundary right between code which can and cannot be dynamically loaded. This is the same issue with using embedded dynamic scripting languages like Lua or Python—how much of your application should be written in them?</li>
<li>JIT compilation requires generating machine code, which is usually a complex process and a large maintenance burden. In practice this means shipping out to a 3rd party library for JIT, and the libraries are typically very large dependencies.<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a></li>
</ul>

<p>The current interface I have in mind is as follows:</p>
<ul>
<li>Compile your project however you want, so long as you produce a bunch of object files or object file archives (and eventually, dynamic libraries).<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a></li>
<li>Rather than using GNU <code>ld</code>, <code>link.exe</code>, etc. to link your objects into an executable, call <code>linker-loader [your list of objects...]</code>.</li>
<li><code>linker-loader</code> will then do one of the following:
<ul>
<li>On the first invocation, it will link and load the objects immediately, then execute the entry-point (<code>_start</code> or <code>main</code> or something you decide). This means your program will start running without having ever been compiled into a single executable.</li>
<li>On subsequent invocations, if the program is still running<a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a>, the linker will only re-link and load object files that have <em>changed</em>. The new invocation of <code>linker-loader</code> will see that the program is still running and instead tell the existing <code>linker-loader</code> process to reload changed objects. This organization alone should save you time because the whole program no longer needs to be re-linked every time you make a change.</li>
<li>The <code>linker-loader</code> will do its best to retain all state across reloads without any special markup on your part. If you make changes it cannot resolve, it will need to prompt you with how you would like to proceed. For example, if the data changes size but you are fine with the old data simply being discarded, it will be able to handle that.</li>
</ul></li>
</ul>
<p>The interface shouldn&#39;t require much up-front work to use with an existing project. Additional work would be necessary to allow the project to self-modify or introspect on its own image, however.</p>

<p>I had many different ideas that resulted in my starting this project:</p>
<ul>
<li>Andreas Fredriksson&#39;s <a href="https://deplinenoise.wordpress.com/2012/02/11/hot-runtime-linking/">Hot Runtime Linking</a> (<a href="https://web.archive.org/web/20160506054425/https://deplinenoise.wordpress.com/2012/02/11/hot-runtime-linking/">archive.org</a>) is where I got the idea to make a linker and loader specifically.</li>
<li>Naughty Dog&#39;s <a href="https://en.wikipedia.org/wiki/Game_Oriented_Assembly_Lisp">Game Oriented Assembly Lisp (GOAL)</a> was a compiled language with a dynamic environment. It was built for the Playstation 2 in 2001. If Andy Gavin could build this functionality then, why can&#39;t we have it today?</li>
<li><a href="https://malleable.systems/">Malleable Systems</a> got me motivated to pursue more &#34;malleability&#34; in my programs. I&#39;m not sure if this project would be the right way to ship this kind of functionality to users, but it&#39;s something I&#39;ll keep in mind while working on it.</li>
<li>My experience with Emacs helped me realize how immensely valuable easy program customization can be. I&#39;m surprised how far ahead Emacs still is on this front, despite being one of the oldest open source projects in history.</li>
<li>Stephen Kell&#39;s <a href="https://www.youtube.com/watch?v=LwicN2u6Dro">Liberating the Smalltalk lurking in C and Unix</a> talk opened my mind to the possibility of bringing more dynamism and introspection to C.</li>
</ul>
<p>The following projects are similar to mine, though do not take exactly the same approach:</p>
<ul>
<li><a href="https://github.com/RuntimeCompiledCPlusPlus/RuntimeCompiledCPlusPlus">Runtime Compiled C++</a> uses marked-up C++ to learn about your code, then compiles and loads it via DLL. See <a href="https://github.com/RuntimeCompiledCPlusPlus/RuntimeCompiledCPlusPlus/wiki/How-it-works">How it works</a>.</li>
<li><a href="https://liveplusplus.tech/">Live++</a> &#34;works at the binary level using .PDB, .EXE, .DLL, .LIB, and .OBJ directly. It extracts and reverses most of the needed information from executable and object files.&#34; This sounds the most similar to my approach. The two major drawbacks to this project to me are A) no GNU/Linux support, which is where I develop my software, and B) it is closed source and proprietary, whereas I&#39;m a believer in Free (as in freedom) Software.</li>
<li><a href="https://docs.microsoft.com/en-us/visualstudio/debugger/edit-and-continue">Visual Studio Edit and Continue</a> is intended to let you live edit any code in your project and magically apply the edit. However, I have never gotten it to work, and none of my coworkers have either. The rumor among us is that it is not well suppported, especially not on large projects like games (which are what I work on professionally).</li>
</ul>

<p>This linker can facilitate program introspection. I plan on having symbols the linker itself provides to the program image that allow the program to inspect its own symbols. This opens the door to a whole variety of interesting things:</p>
<ul>
<li>Call any function in your program in an interactive read-evaluate-print loop</li>
<li>Visualize function compiled sizes</li>
<li>Visualize function references<a href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a></li>
<li>Introspect on program data</li>
<li>…and more things I haven&#39;t thought of yet!</li>
</ul>

<p>I haven&#39;t yet touched the debugging aspect of this. I want certain features in my linker/loader which will necessitate my program image being unique from a normally linked executable. That means I will need to do something custom to help debuggers find the debug symbols from wherever my loader has decided to place the executing code in memory. I&#39;ve only glimpsed at the DWARF debugging info, and it&#39;s pretty complicated.</p>
<p>The intent with this linker/loader was primarily to aid during development, so I have been focused on supporting my primary development architecture, x86-64 (a.k.a. AMD64). Linkers are machine architecture-dependent, so each architecture would need to be added one-by-one once support for them is desired. This doesn&#39;t mean your program would only work on x86-64; it could support a superset of the architectures my linker supports, and you would need to use a different linker to create executables for other architectures.</p>
<p>With my software, I do all initial development on GNU/Linux, then port to Windows after I have proven to myself that the concept is valuable. This means I have not done any work towards <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format">Windows Portable Executable or Common Object File Formats</a>. If I find I can do the things I want on GNU/Linux (which uses ELF format executables), I will port the linker to Windows.</p>
<p>There are complexities around the data sections of the program image that I need to figure out. For example, you should be able to change functions as much as you want while still persisting data across reloads. However, if you change the presence or size of items in data, the linker will need to do some work to try to persist data which hasn&#39;t been affected. This will likely require some help from the debug symbols to determine where things are in data and guess at whether they have changed since last load. I need to do more experimentation before I can find the limitations of this system, but ideally, you can change data without needing to restart the program in many cases.<a href="#fn6" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>

<p>Let me know what you think by emailing me: macoy [at] macoy [dot] me.</p>
<p>You can see the <a href="https://macoy.me/code/macoy/linker-loader">current code here</a>. As of publishing this article, it can load an ELF format object file for x86-64, process the file&#39;s relocations, and call into the object file correctly. It&#39;s not near release; I&#39;ll write a new blog post once that happens.</p>


</article></div>
  </body>
</html>
