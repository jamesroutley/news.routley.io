<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://skilldrick.github.io/easyforth/">Original</a>
    <h1>Easy Forth (2015)</h1>
    
    <div id="readability-page-1" class="page"><section>

        

<h2 id="introduction">Introduction</h2>

<p>This small ebook is here to teach you a programming language called Forth. Forth is a
language unlike most others. It’s not functional <em>or</em> object oriented, it doesn’t
have type-checking, and it basically has zero syntax. It was written in the 70s, but
is still used today for
<a href="http://www.forth.com/resources/apps/more-applications.html">certain applications</a>.</p>

<p>Why would you want to learn such an odd language? Every new programming
language you learn helps you think about problems in new ways. Forth is very
easy to learn, but it requires you to think in a different way than you’re used
to. That makes it a perfect language to broaden your coding horizons.</p>

<p>This book includes a simple implementation of Forth I wrote in JavaScript. It’s by
no means perfect, and is missing a lot of the functionality you’d expect in a real
Forth system. It’s just here to give you an easy way to try out the examples. (If
you’re a Forth expert, please
<a href="https://github.com/skilldrick/easyforth">contribute here</a> and make it better!)</p>

<p>I’m going to assume that you know at least one other programming language, and have
a basic idea of how stacks work as a data structure.</p>

<h2 id="adding-some-numbers">Adding Some Numbers</h2>

<p>The thing that separates Forth from most other languages is its use of the
stack. In Forth, everything revolves around the stack. Any time you type a
number, it gets pushed onto the stack. If you want to add two numbers together,
typing <code>+</code> takes the top two numbers off the stack, adds them, and puts
the result back on the stack.</p>

<p>Let’s take a look at an example. Type (don’t copy-paste) the following into the
interpreter, typing <code>Enter</code> after each line.</p>





<p>Every time you type a line followed by the <code>Enter</code> key, the Forth interpreter
executes that line, and appends the string <code>ok</code> to let you know there were no
errors. You should also notice that as you execute each line, the area at the
top fills up with numbers. That area is our visualization of the stack. It
should look like this:</p>

<p>1 2 3 &lt;- Top</p>

<p>Now, into the same interpreter, type a single <code>+</code> followed by the <code>Enter</code> key. The top two
elements on the stack, <code>2</code> and <code>3</code>, have been replaced by <code>5</code>.</p>

<p>1 5 &lt;- Top</p>

<p>At this point, your editor window should look like this:</p>

<p>1  <span>ok</span>
2  <span>ok</span>
3  <span>ok</span>
+  <span>ok</span>
</p>

<p>Type <code>+</code> again and press <code>Enter</code>, and the top two elements will be replaced by 6. If
you type <code>+</code> one more time, Forth will try to pop the top two elements off the
stack, even though there’s only <em>one</em> element on the stack! This results in a
<code>Stack underflow</code> error:</p>

<p>1  <span>ok</span>
2  <span>ok</span>
3  <span>ok</span>
+  <span>ok</span>
+  <span>ok</span>
+  <span>Stack underflow</span>
</p>

<p>Forth doesn’t force you to type every token as a separate line. Type the
following into the next editor, followed by the <code>Enter</code> key:</p>





<p>The stack should now look like this:</p>

<p>579 &lt;- Top</p>

<p>This style, where the operator appears after the operands, is known as
<a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation">Reverse-Polish
notation</a>. Let’s try
something a bit more complicated, and calculate <code>10 * (5 + 2)</code>. Type the
following into the interpreter:</p>





<p>One of the nice things about Forth is that the order of operations is
completely based on their order in the program. For example, when executing <code>5
2 + 10 *</code>, the interpreter pushes 5 to the stack, then 2, then adds them and
pushes the resulting 7, then pushes 10 to the stack, then multiplies 7 and 10.
Because of this, there’s no need for parentheses to group operators with lower
precedence.</p>

<h3 id="stack-effects">Stack Effects</h3>

<p>Most Forth words affect the stack in some way. Some take values off the stack,
some leave new values on the stack, and some do a mixture of both. These “stack
effects” are commonly represented using comments of the form <code>( before -- after
)</code>. For example, <code>+</code> is <code>( n1 n2 -- sum )</code> - <code>n1</code> and <code>n2</code> are the top two numbers
on the stack, and <code>sum</code> is the value left on the stack.</p>

<h2 id="defining-words">Defining Words</h2>

<p>The syntax of Forth is extremely straightforward. Forth code is interpreted as
a series of space-delimited words. Almost all non-whitespace characters are valid
in words. When the Forth interpreter reads a word, it checks to see if a
definition exists in an internal structure known as the Dictionary. If it is
found, that definition is executed. Otherwise, the word is assumed to be a
number, and it is pushed onto the stack. If the word cannot be converted to a
number, an error occurs.</p>

<p>You can try that out yourself below. Type <code>foo</code> (an unrecognized word)
and press enter.</p>



<p>You should see something like this:</p>

<p>foo  <span>foo ?</span></p>

<p><code>foo ?</code> means that Forth was unable to find a definition for <code>foo</code>, and it
wasn’t a valid number.</p>

<p>We can create our own definition of <code>foo</code> using two special words called <code>:</code>
(colon) and <code>;</code> (semicolon).  <code>:</code> is our way of telling Forth we want to create
a definition. The first word after the <code>:</code> becomes the definition name, and the
rest of the words (until the <code>;</code>) make up the body of the definition. It’s
conventional to include two spaces between the name and the body of the
definition. Try entering the following:</p>

<div><div><pre><code>: foo  100 + ;
1000 foo
foo foo foo
</code></pre></div></div>

<p><strong>Warning:</strong> A common mistake is to miss out the space before the <code>;</code> word. Because Forth
words are space delimited and can contain most characters, <code>+;</code> is a perfectly
valid word and is not parsed as two separate words.</p>



<p>As you’ve hopefully figured out, our <code>foo</code> word simply adds 100 to the value on
top of the stack. It’s not very interesting, but it should give you an idea of
how simple definitions work.</p>

<h2 id="stack-manipulation">Stack Manipulation</h2>

<p>Now we can start taking a look at some of Forth’s predefined words. First,
let’s look at some words for manipulating the elements at the top of the stack.</p>

<h3 id="dup--n----n-n-"><code>dup ( n -- n n )</code></h3>

<p><code>dup</code> is short for “duplicate” – it duplicates the top element of the stack. For example,
try this out:</p>





<p>You should end up with the following stack:</p>

<p>1 2 3 3 &lt;- Top</p>

<h3 id="drop--n----"><code>drop ( n -- )</code></h3>

<p><code>drop</code> simply drops the top element of the stack. Running:</p>



<p>gives you a stack of:</p>

<p>1 2 &lt;- Top</p>



<h3 id="swap--n1-n2----n2-n1-"><code>swap ( n1 n2 -- n2 n1 )</code></h3>

<p><code>swap</code>, as you may have guessed, swaps the top two elements of the stack. For example:</p>



<p>will give you:</p>

<p>1 2 4 3 &lt;- Top</p>



<h3 id="over--n1-n2----n1-n2-n1-"><code>over ( n1 n2 -- n1 n2 n1 )</code></h3>

<p><code>over</code> is a bit less obvious: it takes the second element from the top of the
stack and duplicates it to the top of the stack. Running this:</p>



<p>will result in this:</p>

<p>1 2 3 2 &lt;- Top</p>



<h3 id="rot--n1-n2-n3----n2-n3-n1-"><code>rot ( n1 n2 n3 -- n2 n3 n1 )</code></h3>

<p>Finally, <code>rot</code> “rotates” the top <em>three</em> elements of the stack. The third
element from the top of the stack gets moved to the top of the stack, pushing
the other two elements down.</p>



<p>gives you:</p>

<p>2 3 1 &lt;- Top</p>



<h2 id="generating-output">Generating Output</h2>

<p>Next, let’s look at some words for outputting text to the console.</p>

<h3 id="--n-----period"><code>. ( n -- )</code> (period)</h3>

<p>The simplest output word in Forth is <code>.</code>. You can use <code>.</code> to output the top of
the stack in the output of the current line. For example, try running this
(make sure to include all the spaces!):</p>





<p>You should see this:</p>

<p>1 . 2 . 3 . 4 5 6 . . . <span>1 2 3 6 5 4  ok</span></p>

<p>Going through this in order, we push <code>1</code>, then pop it off and output it. Then
we do the same with <code>2</code> and <code>3</code>. Next we push <code>4</code>, <code>5</code>, and <code>6</code> onto the stack.
We then pop them off and output them one-by-one. That’s why the last three
numbers in the output are reversed: the stack is last in, first out.</p>

<h3 id="emit--c----"><code>emit ( c -- )</code></h3>

<p><code>emit</code> can be used to output numbers as ascii characters. Just like <code>.</code> outputs
the number at the top of the stack, <code>emit</code> outputs that number as an ascii
character. For example:</p>

<div><div><pre><code> 33 119 111 87 emit emit emit emit
</code></pre></div></div>



<p>I won’t give the output here so as to not ruin the surprise. This could also be
written as:</p>

<div><div><pre><code>87 emit 111 emit 119 emit 33 emit
</code></pre></div></div>

<p>Unlike <code>.</code>, <code>emit</code> doesn’t output any space after each character, enabling you
to build up arbitrary strings of output.</p>

<h3 id="cr-----"><code>cr ( -- )</code></h3>

<p><code>cr</code> is short for carriage return – it simply outputs a newline:</p>

<div><div><pre><code>cr 100 . cr 200 . cr 300 .
</code></pre></div></div>



<p>This will output:</p>

<p>cr 100 . cr 200 . cr 300 .<span>
100
200
300  ok</span></p>

<h3 id="-----"><code>.&#34; ( -- )</code></h3>

<p>Finally we have <code>.&#34;</code> – a special word for outputting strings. The <code>.&#34;</code> word works
differently inside definitions to interactive mode. <code>.&#34;</code> marks the beginning of
a string to output, and the end of the string is marked by <code>&#34;</code>. The closing <code>&#34;</code>
isn’t a word, and so doesn’t need to be space-delimited. Here’s an example:</p>

<div><div><pre><code>: say-hello  .&#34; Hello there!&#34; ;
say-hello
</code></pre></div></div>



<p>You should see the following output</p>

<p>say-hello <span>Hello there! ok</span></p>

<p>We can combine <code>.&#34;</code>, <code>.</code>, <code>cr</code>, and <code>emit</code> to build up more complex output:</p>

<div><div><pre><code>: print-stack-top  cr dup .&#34; The top of the stack is &#34; .
  cr .&#34; which looks like &#39;&#34; dup emit .&#34; &#39; in ascii  &#34; ;
48 print-stack-top
</code></pre></div></div>



<p>Running this should give you the following output:</p>

<p>48 print-stack-top <span>
The top of the stack is 48
which looks like &#39;0&#39; in ascii   ok</span></p>

<h2 id="conditionals-and-loops">Conditionals and Loops</h2>

<p>Now onto the fun stuff! Forth, like most other languages, has conditionals and
loops for controlling the flow of your program. To understand how they work,
however, first we need to understand booleans in Forth.</p>

<h3 id="booleans">Booleans</h3>

<p>There’s actually no boolean type in Forth. The number <code>0</code> is treated as false,
and any other number is true, although the canonical true value is <code>-1</code> (all
boolean operators return <code>0</code> or <code>-1</code>).</p>

<p>To test if two numbers are equal, you can use <code>=</code>:</p>



<p>This should output:</p>

<p>3 4 = . <span>0  ok</span>
5 5 = . <span>-1  ok</span></p>



<p>You can use <code>&lt;</code> and <code>&gt;</code> for less than and greater than. <code>&lt;</code> checks to see if the
second item from the top of the stack is less than the top item of the stack, and
vice versa for <code>&gt;</code>:</p>



<p>3 4 &lt; . <span>-1  ok</span>
3 4 &gt; . <span>0  ok</span></p>



<p>The boolean operators And, Or, and Not are available as <code>and</code>, <code>or</code>, and <code>invert</code>:</p>

<div><div><pre><code>3 4 &lt; 20 30 &lt; and .
3 4 &lt; 20 30 &gt; or .
3 4 &lt; invert .
</code></pre></div></div>

<p>The first line is the equivalent of <code>3 &lt; 4 &amp; 20 &lt; 30</code> in a C-based language.
The second line is the equivalent of <code>3 &lt; 4 | 20 &gt; 30</code>. The third line is the
equivalent of <code>!(3 &lt; 4)</code>.</p>

<p><code>and</code>, <code>or</code>, and <code>invert</code> are all bitwise operations. For well-formed flags
(<code>0</code> and <code>-1</code>) they’ll work as expected, but they’ll give incorrect results for
arbitrary numbers.</p>



<h3 id="if-then"><code>if then</code></h3>

<p>Now we can finally get onto conditionals. Conditionals in Forth can only be
used inside definitions. The simplest conditional statement in Forth is <code>if
then</code>, which is equivalent to a standard <code>if</code> statement in most languages.
Here’s an example of a definition using <code>if then</code>. In this example, we’re also
using the <code>mod</code> word, which returns the modulo of the top two numbers on the
stack. In this case, the top number is 5, and the other is whatever was placed
on the stack before calling <code>buzz?</code>. Therefore, <code>5 mod 0 =</code> is a boolean
expression that checks to see if the top of the stack is divisible by 5.</p>

<div><div><pre><code>: buzz?  5 mod 0 = if .&#34; Buzz&#34; then ;
3 buzz?
4 buzz?
5 buzz?
</code></pre></div></div>



<p>This will output:</p>

<p>3 buzz?<span>  ok</span>
4 buzz?<span>  ok</span>
5 buzz?<span> Buzz ok</span></p>

<p>It’s important to note that the <code>then</code> word marks the end of the <code>if</code> statement.
This makes it equivalent to <code>fi</code> in Bash or <code>end</code> in Ruby, for example.</p>

<p>Another important thing to realize is that <code>if</code> consumes the top value on the
stack when it checks to see if it’s true or false.</p>

<h3 id="if-else-then"><code>if else then</code></h3>

<p><code>if else then</code> is equivalent to an <code>if/else</code> statement in most languages. Here’s
an example of its use:</p>

<div><div><pre><code>: is-it-zero?  0 = if .&#34; Yes!&#34; else .&#34; No!&#34; then ;
0 is-it-zero?
1 is-it-zero?
2 is-it-zero?
</code></pre></div></div>



<p>This outputs:</p>

<p>0 is-it-zero?<span> Yes! ok</span>
1 is-it-zero?<span> No! ok</span>
2 is-it-zero?<span> No! ok</span></p>

<p>This time, the if clause (consequent) is everything between <code>if</code> and <code>else</code>,
and the else clause (alternative) is everything between <code>else</code> and <code>then</code>.</p>

<h3 id="do-loop"><code>do loop</code></h3>

<p><code>do loop</code> in Forth most closely resembles a <code>for</code> loop in most C-based languages.
In the body of a <code>do loop</code>, the special word <code>i</code> pushes the current loop index
onto the stack.</p>

<p>The top two values on the stack give the starting value (inclusive) and ending
value (exclusive) for the <code>i</code> value. The starting value is taken from the top
of the stack. Here’s an example:</p>

<div><div><pre><code>: loop-test  10 0 do i . loop ;
loop-test
</code></pre></div></div>



<p>This should output:</p>

<p>loop-test<span> 0 1 2 3 4 5 6 7 8 9  ok</span></p>

<p>The expression <code>10 0 do i . loop</code> is roughly equivalent to:</p>

<div><div><pre><code>for (int i = 0; i &lt; 10; i++) {
  print(i);
}
</code></pre></div></div>

<h3 id="fizz-buzz">Fizz Buzz</h3>

<p>We can write the classic <a href="https://en.wikipedia.org/wiki/Fizz_buzz">Fizz Buzz</a>
program easily using a <code>do loop</code>:</p>

<div><div><pre><code>: fizz?  3 mod 0 = dup if .&#34; Fizz&#34; then ;
: buzz?  5 mod 0 = dup if .&#34; Buzz&#34; then ;
: fizz-buzz?  dup fizz? swap buzz? or invert ;
: do-fizz-buzz  25 1 do cr i fizz-buzz? if i . then loop ;
do-fizz-buzz
</code></pre></div></div>



<p><code>fizz?</code> checks to see if the top of the stack is divisible by 3 using <code>3 mod 0
=</code>. It then uses <code>dup</code> to duplicate this result. The top copy of the value is
consumed by <code>if</code>.  The second copy is left on the stack and acts as the return
value of <code>fizz?</code>.</p>

<p>If the number on top of the stack is divisible by 3, the string <code>&#34;Fizz&#34;</code> will
be output, otherwise there will be no output.</p>

<p><code>buzz?</code> does the same thing but with 5, and outputs the string <code>&#34;Buzz&#34;</code>.</p>

<p><code>fizz-buzz?</code> calls <code>dup</code> to duplicate the value on top of the stack, then calls
<code>fizz?</code>, converting the top copy into a boolean. After this, the top of the
stack consists of the original value, and the boolean returned by <code>fizz?</code>.
<code>swap</code> swaps these, so the original top-of-stack value is back on top, and the
boolean is underneath. Next we call <code>buzz?</code>, which replaces the top-of-stack
value with a boolean flag. Now the top two values on the stack are booleans
representing whether the number was divisible by 3 or 5.  After this, we call
<code>or</code> to see if either of these is true, and <code>invert</code> to negate this value.
Logically, the body of <code>fizz-buzz?</code> is equivalent to:</p>

<div><div><pre><code>!(x % 3 == 0 || x % 5 == 0)
</code></pre></div></div>

<p>Therefore, <code>fizz-buzz?</code> returns a boolean indicating if the argument is not
divisible by 3 or 5, and thus should be printed.  Finally, <code>do-fizz-buzz</code> loops
from 1 to 25, calling <code>fizz-buzz?</code> on <code>i</code>, and outputting <code>i</code> if <code>fizz-buzz?</code>
returns true.</p>

<p>If you’re having trouble figuring out what’s going on inside <code>fizz-buzz?</code>, the
example below might help you to understand how it works. All we’re doing here
is executing each word of the definition of <code>fizz-buzz?</code> on a separate line. As
you execute each line, watch the stack to see how it changes:</p>

<div><div><pre><code>: fizz?  3 mod 0 = dup if .&#34; Fizz&#34; then ;
: buzz?  5 mod 0 = dup if .&#34; Buzz&#34; then ;
4
dup
fizz?
swap
buzz?
or
invert
</code></pre></div></div>



<p>Here’s how each line affects the stack:</p>

<div><div><pre><code>4         4 &lt;- Top
dup       4 4 &lt;- Top
fizz?     4 0 &lt;- Top
swap      0 4 &lt;- Top
buzz?     0 0 &lt;- Top
or        0 &lt;- Top
invert    -1 &lt;- Top
</code></pre></div></div>

<p>Remember, the final value on the stack is the return value of the <code>fizz-buzz?</code>
word. In this case, it’s true, because the number was not divisible by 3 or 5,
and so <em>should</em> be printed.</p>

<p>Here’s the same thing but starting with 5:</p>

<div><div><pre><code>5         5 &lt;- Top
dup       5 5 &lt;- Top
fizz?     5 0 &lt;- Top
swap      0 5 &lt;- Top
buzz?     0 -1 &lt;- Top
or        -1 &lt;- Top
invert    0 &lt;- Top
</code></pre></div></div>

<p>In this case the original top-of-stack value was divisible by 5, so nothing
should be printed.</p>

<h2 id="variables-and-constants">Variables and Constants</h2>

<p>Forth also allows you to save values in variables and constants. Variables allow
you to keep track of changing values without having to store them on the stack.
Constants give you a simple way to refer to a value that won’t change.</p>

<h3 id="variables">Variables</h3>

<p>Because the role of local variables is generally played by the stack, variables
in Forth are used more to store state that may be needed across multiple
words.</p>

<p>Defining variables is simple:</p>



<p>This basically associates a particular memory location with the name <code>balance</code>.
<code>balance</code> is now a word, and all it does is to push its memory location onto the
stack:</p>





<p>You should see the value <code>1000</code> on the stack. This Forth implementation arbitrarily
starts storing variables at the memory location <code>1000</code>.</p>

<p>The word <code>!</code> stores a value at the memory location referenced by a variable, and the
word <code>@</code> fetches the value from a memory location:</p>

<div><div><pre><code>variable balance
123 balance !
balance @
</code></pre></div></div>



<p>This time you should see the value <code>123</code> on the stack. <code>123 balance</code> pushes the
value and the memory location onto the stack, and <code>!</code> stores that value at that
memory location. Likewise, <code>@</code> retrieves the value based on the memory location,
and pushes that value onto the stack. If you’ve used C or C++, you can think of
<code>balance</code> as a pointer that is dereferenced by <code>@</code>.</p>

<p>The word <code>?</code> is defined as <code>@ .</code> and it prints the current value of a variable.
The word <code>+!</code> is used to increase the value of a variable by a certain amount
(like <code>+=</code> in C-based languages).</p>

<div><div><pre><code>variable balance
123 balance !
balance ?
50 balance +!
balance ?
</code></pre></div></div>



<p>Run this code and you should see:</p>

<p>variable balance<span>  ok</span>
123 balance ! <span> ok</span>
balance ? <span>123  ok</span>
50 balance +! <span> ok</span>
balance ? <span>173  ok</span>
</p>

<h3 id="constants">Constants</h3>

<p>If you have a value that doesn’t change, you can store it as a constant. Constants
are defined in one line, like this:</p>



<p>This creates a new constant called <code>answer</code> with the value <code>42</code>. Unlike variables,
constants just represent values, rather than memory locations, so there’s no need
to use <code>@</code>.</p>

<div><div><pre><code>42 constant answer
2 answer *
</code></pre></div></div>



<p>Running this will push the value <code>84</code> on the stack. <code>answer</code> is treated as if it
was the number it represents (just like constants and variables in other languages).</p>

<h2 id="arrays">Arrays</h2>

<p>Forth doesn’t exactly support arrays, but it does allow you to allocate a zone of
contiguous memory, a lot like arrays in C. To allocate this memory, use the <code>allot</code>
word.</p>

<div><div><pre><code>variable numbers
3 cells allot
10 numbers 0 cells + !
20 numbers 1 cells + !
30 numbers 2 cells + !
40 numbers 3 cells + !
</code></pre></div></div>



<p>This example creates a memory location called <code>numbers</code>, and reserves three extra
memory cells after this location, giving a total of four memory cells. (<code>cells</code>
just multiplies by the cell-width, which is 1 in this implementation.)</p>

<p><code>numbers 0 +</code> gives the address of the first cell in the array. <code>10 numbers 0 + !</code>
stores the value <code>10</code> in the first cell of the array.</p>

<p>We can easily write words to simplify array access:</p>

<div><div><pre><code>variable numbers
3 cells allot
: number  ( offset -- addr )  cells numbers + ;

10 0 number !
20 1 number !
30 2 number !
40 3 number !

2 number ?
</code></pre></div></div>



<p><code>number</code> takes an offset into <code>numbers</code> and returns the memory address at that
offset. <code>30 2 number !</code> stores <code>30</code> at offset <code>2</code> in <code>numbers</code>, and <code>2 number ?</code>
prints the value at offset <code>2</code> in <code>numbers</code>.</p>

<h2 id="keyboard-input">Keyboard Input</h2>

<p>Forth has a special word called <code>key</code>, which is used for accepting keyboard input.
When the <code>key</code> word is executed, execution is paused until a key is pressed. Once
a key is pressed, the key code of that key is pushed onto the stack. Try out the
following:</p>





<p>When you run this line, you’ll notice that at first nothing happens. This is because
the interpreter is waiting for your keyboard input. Try hitting the <code>A</code> key, and
you should see the keycode for that key, <code>65</code>, appear as output on the current line.
Now hit <code>B</code>, then <code>C</code>, and you should see the following:</p>

<p>key . key . key . <span>65 66 67  ok</span></p>

<h3 id="printing-keys-with-begin-until">Printing keys with <code>begin until</code></h3>

<p>Forth has another kind of loop called <code>begin until</code>. This works like a <code>while</code>
loop in C-based languages. Every time the word <code>until</code> is hit, the interpreter
checks to see if the top of the stack is non-zero (true). If it is, it jumps
back to the matching <code>begin</code>. If not, execution continues.</p>

<p>Here’s an example of using <code>begin until</code> to print key codes:</p>

<div><div><pre><code>: print-keycode  begin key dup . 32 = until ;
print-keycode
</code></pre></div></div>



<p>This will keep printing key codes until you press space. You should see something like this:</p>

<p>print-keycode <span>80 82 73 78 84 189 75 69 89 67 79 68 69 32  ok</span></p>

<p><code>key</code> waits for key input, then <code>dup</code> duplicates the keycode from <code>key</code>. We
then use <code>.</code> to output the top copy of the keycode, and <code>32 =</code> to check to see
if the keycode is equal to 32. If it is, we break out of the loop, otherwise we
loop back to <code>begin</code>.</p>

<h2 id="snake">Snake!</h2>

<p>Now it’s time to put it all together and make a game! Rather than having you type
all the code, I’ve pre-loaded it into the editor.</p>

<p>Before we look at the code, try playing the game. To start the game, execute the
word <code>start</code>. Then use the arrow keys to move the snake. If you lose, you can run
<code>start</code> again.</p>



<p>Before we delve too deeply into this code, two disclaimers. First, this is terrible
Forth code. I’m by no means a Forth expert, so there’s probably all kinds of things
I’m doing in completely the wrong way. Second, this game uses a few non-standard
techniques in order to interface with JavaScript. I’ll go through these now.</p>

<h3 id="non-standard-additions">Non-Standard Additions</h3>

<h4 id="the-canvas">The Canvas</h4>

<p>You may have noticed that this editor is different from the others: it has an HTML5
Canvas element built in. I’ve created a very simple memory-mapped interface for
drawing onto this canvas. The canvas is split up into 24 x 24 “pixels” which can
be black or white. The first pixel is found at the memory address given by the
variable <code>graphics</code>, and the rest of the pixels are offsets from the variable. So,
for example, to draw a white pixel in the top-left corner you could run</p>





<p>The game uses the following words to draw to the canvas:</p>

<div><div><pre><code>: convert-x-y ( x y -- offset )  24 cells * + ;
: draw ( color x y -- )  convert-x-y graphics + ! ;
: draw-white ( x y -- )  1 rot rot draw ;
: draw-black ( x y -- )  0 rot rot draw ;
</code></pre></div></div>

<p>For example, <code>3 4 draw-white</code> draws a white pixel at the coordinates (3, 4). The
y coordinate is multiplied by 24 to get the row, then the x coordinated is added
to get the column.</p>

<h4 id="non-blocking-keyboard-input">Non-Blocking Keyboard Input</h4>

<p>The Forth word <code>key</code> blocks, so is unsuitable for a game like this. I’ve added
a variable called <code>last-key</code> which always holds the value of the last key to be
pressed. <code>last-key</code> is only updated while the interpreter is running Forth code.</p>

<h4 id="random-number-generation">Random Number Generation</h4>

<p>The Forth standard doesn’t define a way of generating random numbers, so I’ve
added a word called <code>random ( range -- n )</code> that takes a range and returns a
random number from 0 to range - 1. For example, <code>3 random</code> could
return <code>0</code>, <code>1</code>, or <code>2</code>.</p>

<h4 id="sleep--ms----"><code>sleep ( ms -- )</code></h4>

<p>Finally, I’ve added a blocking <code>sleep</code> word that pauses execution for the
number of milliseconds given.</p>

<h3 id="the-game-code">The Game Code</h3>

<p>Now we can work through the code from start to finish.</p>

<h4 id="variables-and-constants-1">Variables and Constants</h4>

<p>The start of the code just sets up some variables and constants:</p>

<div><div><pre><code>variable snake-x-head
500 cells allot

variable snake-y-head
500 cells allot

variable apple-x
variable apple-y

0 constant left
1 constant up
2 constant right
3 constant down

24 constant width
24 constant height

variable direction
variable length
</code></pre></div></div>

<p><code>snake-x-head</code> and <code>snake-y-head</code> are memory locations used to store the x and
y coordinates of the head of the snake. 500 cells of memory are alloted after
these two locations to store the coordinates of the tail of the snake.</p>

<p>Next we define two words for accessing memory locations representing the body
of the snake.</p>

<div><div><pre><code>: snake-x ( offset -- address )
  cells snake-x-head + ;

: snake-y ( offset -- address )
  cells snake-y-head + ;
</code></pre></div></div>

<p>Just like the <code>number</code> word earlier, these two words are used to access
elements in the arrays of snake segments. After this come some words for
drawing to the canvas, described above.</p>

<p>We use constants to refer to the four directions (<code>left</code>, <code>up</code>, <code>right</code>, and
<code>down</code>), and a variable <code>direction</code> to store the current direction.</p>

<h4 id="initialization">Initialization</h4>

<p>After this we initialize everything:</p>

<div><div><pre><code>: draw-walls
  width 0 do
    i 0 draw-black
    i height 1 - draw-black
  loop
  height 0 do
    0 i draw-black
    width 1 - i draw-black
  loop ;

: initialize-snake
  4 length !
  length @ 1 + 0 do
    12 i - i snake-x !
    12 i snake-y !
  loop
  right direction ! ;

: set-apple-position apple-x ! apple-y ! ;

: initialize-apple  4 4 set-apple-position ;

: initialize
  width 0 do
    height 0 do
      j i draw-white
    loop
  loop
  draw-walls
  initialize-snake
  initialize-apple ;
</code></pre></div></div>

<p><code>draw-walls</code> uses two <code>do/loop</code>s to draw the horizontal and vertical walls,
respectively.</p>

<p><code>initialize-snake</code> sets the <code>length</code> variable to <code>4</code>, then loops from <code>0</code> to
<code>length + 1</code> filling in the starting snake positions. The snake positions are
always kept one longer than the length so we can grow the snake easily.</p>

<p><code>set-apple-position</code> and <code>initialize-apple</code> set the initial position of the
apple to (4,4).</p>

<p>Finally, <code>initialize</code> fills everything in white and calls the three
initialization words.</p>

<h4 id="moving-the-snake">Moving the Snake</h4>

<p>Here’s the code for moving the snake based on the current value of <code>direction</code>:</p>

<div><div><pre><code>: move-up  -1 snake-y-head +! ;
: move-left  -1 snake-x-head +! ;
: move-down  1 snake-y-head +! ;
: move-right  1 snake-x-head +! ;

: move-snake-head  direction @
  left over  = if move-left else
  up over    = if move-up else
  right over = if move-right else
  down over  = if move-down
  then then then then drop ;

\ Move each segment of the snake forward by one
: move-snake-tail  0 length @ do
    i snake-x @ i 1 + snake-x !
    i snake-y @ i 1 + snake-y !
  -1 +loop ;
</code></pre></div></div>

<p><code>move-up</code>, <code>move-left</code>, <code>move-down</code>, and <code>move-right</code> just add or subtract one
from the x or y coordinate of the snake head. <code>move-snake-head</code> inspects the
value of <code>direction</code> and calls the appropriate <code>move-*</code> word. This <code>over = if</code>
pattern is an idiomatic way of doing case statements in Forth.</p>

<p><code>move-snake-tail</code> goes through the array of snake positions backwards, copying
each value forward by 1 cell. This is called before we move the snake head, to
move each segment of the snake forward one space. It uses a <code>do/+loop</code>, a
variation of a <code>do/loop</code> that pops the stack on every iteration and adds that
value to the next index, instead of incrementing by 1 each time. So <code>0 length @
do -1 +loop</code> loops from <code>length</code> to <code>0</code> in increments of <code>-1</code>.</p>

<h4 id="keyboard-input-1">Keyboard Input</h4>

<p>The next section of code takes the keyboard input and changes the snake direction
if appropriate.</p>

<div><div><pre><code>: is-horizontal  direction @ dup
  left = swap
  right = or ;

: is-vertical  direction @ dup
  up = swap
  down = or ;

: turn-up     is-horizontal if up direction ! then ;
: turn-left   is-vertical if left direction ! then ;
: turn-down   is-horizontal if down direction ! then ;
: turn-right  is-vertical if right direction ! then ;

: change-direction ( key -- )
  37 over = if turn-left else
  38 over = if turn-up else
  39 over = if turn-right else
  40 over = if turn-down
  then then then then drop ;

: check-input
  last-key @ change-direction
  0 last-key ! ;
</code></pre></div></div>

<p><code>is-horizontal</code> and <code>is-vertical</code> check the current status of the <code>direction</code>
variable to see if it’s a horizontal or vertical direction.</p>

<p>The <code>turn-*</code> words are used to set a new direction, but use <code>is-horizontal</code> and
<code>is-vertical</code> to check the current direction first to see if the new direction
is valid. For example, if the snake is moving horizontally, setting a new
direction of <code>left</code> or <code>right</code> doesn’t make sense.</p>

<p><code>change-direction</code> takes a key and calls the appropriate <code>turn-*</code> word if the
key was one of the arrow keys. <code>check-input</code> does the work of getting the last
key from the <code>last-key</code> pseudo-variable, calling <code>change-direction</code>, then setting
<code>last-key</code> to 0 to indicate that the most recent keypress has been dealt with.</p>

<h4 id="the-apple">The Apple</h4>

<p>The next code is used for checking to see if the apple has been eaten, and if so,
moving it to a new (random) location. Also, if the apple has been eaten we grow
the snake.</p>

<div><div><pre><code>\ get random x or y position within playable area
: random-position ( -- pos )
  width 4 - random 2 + ;

: move-apple
  apple-x @ apple-y @ draw-white
  random-position random-position
  set-apple-position ;

: grow-snake  1 length +! ;

: check-apple ( -- flag )
  snake-x-head @ apple-x @ =
  snake-y-head @ apple-y @ =
  and if
    move-apple
    grow-snake
  then ;
</code></pre></div></div>

<p><code>random-position</code> generates a random x or y coordinate in the range of <code>2</code> to
<code>width - 2</code>. This prevents the apple from ever appearing right next to the wall.</p>

<p><code>move-apple</code> erases the current apple (using <code>draw-white</code>) then creates a new
pair of x/y coordinates for the apple using <code>random-position</code> twice. Finally,
it calls <code>set-apple-position</code> to move the apple to the new coordinates.</p>

<p><code>grow-snake</code> simply adds one to the <code>length</code> variable.</p>

<p><code>check-apple</code> compares the x/y coordinates of the apple and the snake head to
see if they’re the same (using <code>=</code> twice and <code>and</code> to combine the two
booleans). If the coordinates are the same, we call <code>move-apple</code> to move the
apple to a new position and <code>grow-snake</code> to make the snake 1 segment longer.</p>

<h4 id="collision-detection">Collision Detection</h4>

<p>Next we see if the snake has collided with the walls or itself.</p>

<div><div><pre><code>: check-collision ( -- flag )
  \ get current x/y position
  snake-x-head @ snake-y-head @

  \ get color at current position
  convert-x-y graphics + @

  \ leave boolean flag on stack
  0 = ;
</code></pre></div></div>

<p><code>check-collision</code> checks to see if the new snake head position is already black
(this word is called <em>after</em> updating the snake’s position but <em>before</em> drawing
it at the new position). We leave a boolean on the stack to say whether a
collision has occured or not.</p>

<h4 id="drawing-the-snake-and-apple">Drawing the Snake and Apple</h4>

<p>The next two words are responsible for drawing the snake and apple.</p>

<div><div><pre><code>: draw-snake
  length @ 0 do
    i snake-x @ i snake-y @ draw-black
  loop
  length @ snake-x @
  length @ snake-y @
  draw-white ;

: draw-apple
  apple-x @ apple-y @ draw-black ;
</code></pre></div></div>

<p><code>draw-snake</code> loops through each cell in the snake arrays, drawing a black pixel
for each one. After that it draws a white pixel at an offset of <code>length</code>. The
last part of the tail is at <code>length - 1</code> into the array so <code>length</code> holds the
previous last tail segment.</p>

<p><code>draw-apple</code> simply draws a black pixel at the apple’s current location.</p>

<h4 id="the-game-loop">The Game Loop</h4>

<p>The game loop constantly loops until a collision occurs, calling each of the
words defined above in turn.</p>

<div><div><pre><code>: game-loop ( -- )
  begin
    draw-snake
    draw-apple
    100 sleep
    check-input
    move-snake-tail
    move-snake-head
    check-apple
    check-collision
  until
  .&#34; Game Over&#34; ;

: start  initialize game-loop ;
</code></pre></div></div>

<p>The <code>begin/until</code> loop uses the boolean returned by <code>check-collision</code> to see
whether to continue looping or to exit the loop. When the loop is exited the
string <code>&#34;Game Over&#34;</code> is printed. We use <code>100 sleep</code> to pause for 100 ms every
iteration, making the game run at rougly 10 fps.</p>

<p><code>start</code> just calls <code>initialize</code> to reset everything, then kicks off <code>game-loop</code>.
Because all the initialization happens in the <code>initialize</code> word, you can call
<code>start</code> again after game over.</p>

<hr/>

<p>And that’s it! Hopefully all the code in the game made sense. If not, you can
try running individual words to see their effect on the stack and/or on the
variables.</p>

<h2 id="the-end">The End</h2>

<p>Forth is actually much more powerful than what I’ve taught here (and what I
implemented in my interpreter). A true Forth system allows you to modify how
the compiler works and create new defining words, allowing you to completely
customize your environment and create your own languages within Forth.</p>

<p>A great resource for learning the full power of Forth is the short book
<a href="http://www.forth.com/starting-forth/">“Starting Forth”</a> by Leo Brodie. It’s
available for free online and teaches you all the fun stuff I left out. It also
has a good set of exercises for you to test out your knowledge. You’ll need to
download a copy of <a href="http://www.forth.com/swiftforth/dl.html">SwiftForth</a> to run
the code though.</p>


      </section></div>
  </body>
</html>
