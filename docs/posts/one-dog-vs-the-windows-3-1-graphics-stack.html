<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wuffs.org/blog/windows-3x-graphics">Original</a>
    <h1>One Dog vs. the Windows 3.1 Graphics Stack</h1>
    
    <div id="readability-page-1" class="page"><div id="wrapperGrid">
    




    <section id="body">
        
<p>
	<time datetime="2025-01-02T20:31:00+00:00">
		Published 2nd Jan 2025
	</time>
</p>

<p>Wherein I learn too much about VGA hardware and generate some really cool glitch art while I try to fix somebody else&#39;s fix for a video driver that&#39;s older than I am.</p>

<hr/>
<p>I&#39;m a bit of a retro tech enjoyer, but I&#39;m also pretty bad at it -- I don&#39;t have the space or the motivation to try and acquire actual old computers. Playing with 86Box/PCem is pretty fun, but it&#39;s not quite the same.</p>
<p>So, instead, I make do with what I have. And the most ridiculous x86 machine I own is the <em>Asus Eee PC 1000H</em>, a netbook that I got in 2008 when that category was still new and exciting. It&#39;s borderline useless nowadays (it can&#39;t even run most up-to-date Linux distros due to its lack of x86_64 support), so sticking weird and anachronistic OSes on it is one way to keep it relevant!</p>
<p><a rel="lightbox" href="https://wuffs.org/user/pages/02.blog/windows-3x-graphics/640x480.jpg"><img alt="Windows 3.11 on my Eee PC, with a blurry and horizontally stretched screen. Text in Notepad says: &#34;fixedsys is not supposed to be this wide :( and I need more screen space!!!&#34;" src="https://wuffs.org/images/b/1/c/9/2/b1c921a98b56d269d1bab531eca7615c982be6ab-640x480.jpg"/></a></p>
<p>I&#39;d like to write a full-fledged blog post about these adventures at some point, but for now I&#39;m going to focus on one particular side quest: getting acceptable video output out of the 1000H when it&#39;s running <strong>Windows 3.11 for Workgroups</strong>.</p>
<p>By default, Windows 3.x renders using the standard &#34;lowest common denominator&#34; of video: VGA 640x480 at 16 colours. Unfortunately this looks awful on the Eee PC&#39;s beautiful 1024x600 screen, and it&#39;s not even the same aspect ratio.</p>

<p>But how can we do better? The 3.11 installer includes a smattering of drivers for long-obsolete video adapters, but they didn&#39;t have the prescience to support the <em>Intel GMA 950</em> in my netbook. (For shame, Microsoft. <strong>For shame.</strong>)</p>
<p>There&#39;s an included &#39;Super VGA&#39; driver that ostensibly supports up to 1024x768 at 256 colours, but it doesn&#39;t work, for... reasons that we&#39;ll go into, even though you&#39;d think that a 2008 machine would surely be able to do SVGA. If I try to use it, I&#39;ll just get an error and Windows will fail to start.</p>

<p>Nowadays when we hear &#39;VGA&#39; we usually think of the funky little blue analogue connector, or maybe just the 640x480 resolution itself. These are just aspects of VGA, which was a very specific video controller designed by IBM in the 1980s.</p>
<p>&#39;Super VGA&#39; must be a better version, right? Well, yes, and no. As I understand it, at the time, SVGA was just an umbrella term for <em>anything more advanced than plain old VGA</em> - but not a standard in and of itself. So lots of SVGA cards could do better resolutions and colour depths and refresh rates, but each piece of software had to implement support for each individual card.</p>
<p>This leads to the mind-numbing situation we get with the Windows driver. From the readme for <a href="https://winworldpc.com/product/generic-svga-driver-/generic-svga-driver-windows-31">this driver&#39;s standalone release</a>, we get the following list of supported vendors:</p>
<ul>
<li>ATI VGA series, including Wonder, Wonder Plus and Wonder 24XL</li>
<li>Cirrus Logic VGA (6420, 5420 series)</li>
<li>Oak Technology VGA (077 series)</li>
<li>Paradise VGA, including 1024 and Professional</li>
<li>Trident VGA (8900C series), including Trident Impact</li>
<li>Tseng VGA (ET4000 series), including a whole bunch of other cards with the same chips</li>
<li>Video Seven VGA, including FastWrite, 1024i, VRAM and VRAM II</li>
<li>Western Digital VGA</li>
</ul>
<p>Obviously, my mid-2000s Intel video adapter is not among these. There was no real reason for Intel to use the same proprietary extensions as Trident or Oak or Video Seven. So we&#39;re boned, I guess...</p>
<h2>They Should Make A Standard</h2>
<p>Good news! <a href="https://en.wikipedia.org/wiki/VESA_BIOS_Extensions">They did!</a> ... Too bad it came too late to be relevant to Windows 3.x.</p>
<p>VBE (VESA BIOS Extensions) is a generic interface that lets software talk to video adapters and do things that are beyond the capabilities of plain old VGA, and in theory it&#39;s exactly what we need. <em>(And yes, that&#39;s the same VESA that&#39;s responsible for the monitor mounts.)</em></p>
<p>BearWindows has released <a href="https://bearwindows.zcm.com.au/vbe9x.htm">VBE9x</a> and <a href="https://bearwindows.zcm.com.au/vbemp.htm">VBEMP</a> which allow Windows 9x and NT respectively to use VBE, which both work pretty well. There&#39;s no 3.x version though.</p>
<p>There is also <strong>SVGAPatch</strong>, available from <a href="https://www.japheth.de/">japheth.de</a>, which patches Microsoft&#39;s 256-colour Super VGA driver to use VBE. The result is beautiful...</p>
<p><a rel="lightbox" href="https://wuffs.org/user/pages/02.blog/windows-3x-graphics/1024x600.jpg"><img alt="The Eee PC again, but this time, it&#39;s rendering the desktop crisply at the native resolution. I&#39;ve got a failed Minesweeper game open, and a Notepad window where I&#39;ve typed &#34;haha who would try to put a 1993 OS on a machine from 2008, isn&#39;t that silly :thonk: fun fact: the fan on this is louder than the one on my M1 MacBook Pro&#34;" src="https://wuffs.org/user/pages/02.blog/windows-3x-graphics/1024x600.jpg"/></a></p>
<p>...when it works. You see, one of the headline features of early Windows was its compatibility with MS-DOS software. You could just pull up a DOS prompt in a window, and with 3.1&#39;s <em>Enhanced Mode</em>, you even got mostly-seamless multitasking of DOS applications alongside graphical Windows ones. This was a Big Deal™ in those days!</p>
<p>Unfortunately, SVGAPatch doesn&#39;t play nicely with this, and I wanted to figure out why. Entering full-screen mode and then returning to the Windows GUI will leave you with a corrupted screen. In some cases, opening <em>any</em> DOS prompt, even if it&#39;s in windowed mode, will cause it. Here&#39;s what happened when I opened a windowed prompt.</p>
<p><a rel="lightbox" href="https://wuffs.org/user/pages/02.blog/windows-3x-graphics/default_driver.jpg"><img alt="The Eee PC&#39;s screen is showing a red grid of glitched pixels. Absolutely nothing is discernible." src="https://wuffs.org/user/pages/02.blog/windows-3x-graphics/default_driver.jpg"/></a></p>
<p><em>(Hank Hill voice)</em> That prompt ain&#39;t right!</p>
<p>There&#39;s clearly some sort of state management issue; I&#39;ve tried it with DOSBox, 86Box and my Eee PC, and interacting with DOS prompts will reliably break the driver on all three (but in subtly different ways).</p>
<p>So, let’s analyse how this works, with my very limited knowledge of the PC architecture. Can I find the problem, and maybe fix it??</p>
<p><em>Side note:</em> Halfway through working on this I came across <a href="https://github.com/PluMGMK/vbesvga.drv">PluMGMK/vbesvga.drv</a> which is a brand new driver that even supports true colour modes. This is, in all honesty, a far better approach than mine - but I was invested and wanted to see how far I could get with Microsoft&#39;s code.</p>

<p>To grok what’s going on, we need a cursory understanding of how Windows 3.x works in its “Enhanced Mode”, as an OS on top of MS-DOS.</p>
<p>Rather than trying to explain it myself, I’ll link to a 2010 post from Raymond Chen’s blog: <a href="https://devblogs.microsoft.com/oldnewthing/20100517-00/?p=14013">If Windows 3.11 required a 32-bit processor, why was it called a 16-bit operating system?</a> It’s good reading, but this is the most important bit for our purposes:</p>
<blockquote>
<p>With Enhanced mode, there were actually three operating systems running at the same time. The operating system in charge of the show was the 32-bit virtual machine manager which ran in 32-bit protected mode. As you might suspect from its name, the virtual machine manager created virtual machines. Inside the first virtual machine ran… a copy of Standard mode Windows.</p>
</blockquote>
<p>This funky approach is what allowed Windows 3.x to run DOS applications without each app tying up the entire machine.</p>
<h2>The Display Driver Hellscape</h2>
<p>In Windows Setup, you get to tell it what video adapter you&#39;re using. You’d probably assume that this is choosing one driver. Nope!</p>
<p><a rel="lightbox" href="https://wuffs.org/user/pages/02.blog/windows-3x-graphics/setup_000.png"><img alt="Screenshot of Windows 3.11 Setup, where you can pick your display from a long list, including &#34;Super VGA&#34; (multiple resolution and font size variants), &#34;VGA&#34;, &#34;VGA (version 3.0)&#34; and &#34;Video 7&#34; (also with multiple variants)" src="https://wuffs.org/user/pages/02.blog/windows-3x-graphics/setup_000.png"/></a></p>
<p>When you pick an option from this list, it will…</p>
<ul>
<li>Install all the required files from the floppy diskettes (how quaint!)
<ul>
<li>A grabber</li>
<li>A display driver</li>
<li>A virtual display device</li>
<li>Required resources such as fonts</li>
</ul></li>
<li>Modify your <code>SYSTEM.INI</code> to tell Windows to use the specified drivers</li>
<li>Add any other INI entries required</li>
</ul>
<p>The different 256-colour SVGA entries are actually the same underlying drivers, but with different INI entries to set the desired resolution and DPI (96dpi for &#39;small fonts&#39;, 120dpi for &#39;large fonts&#39;).</p>
<hr/>
<p>More critically however, there are three different components here that you could all think of as a sort of driver. As I understand them…</p>
<p>The <strong>Grabber</strong> seems to be responsible for rendering the windowed versions of DOS apps. This is the one I’ve investigated the least.</p>
<p>The <strong>Display Driver</strong> runs inside the main Windows VM, and is responsible for setting up the hardware and rendering the GUI. In fact, in 3.x, each of these included its own implementation of much of GDI (the API for drawing).</p>
<p>The <strong>Virtual Display Device</strong> (VDD) runs as part of the underlying virtual machine manager, and acts somewhat like a multiplexer for the video hardware. If a DOS app is full screen, its commands are directly sent to the ‘real’ VGA adapter; otherwise, they’re emulated by the VDD.</p>
<hr/>
<p>There is a whole lot of nasty state synchronisation logic in the VDD that is likely related to my problems.</p>
<p>Interestingly, however, the SVGAPatch tool doesn’t alter the SVGA VDD at all — it <em>only</em> touches the display driver. Could that be the issue? 🤔</p>
<p>To continue, I’ll need to understand the display driver, the VDD <strong>and</strong> the undocumented patches made by SVGAPatch.</p>
<h2>Gathering Information</h2>
<p>As far as I can tell, this was a bit of a dark art back when 3.x was current, and it’s still rather difficult to find any info about all of these systems.</p>
<p>I learned a lot from this blog post on ‘OS/2 Museum’: <a href="https://www.os2museum.com/wp/windows-3-x-vddvga/">Windows 3.x VDDVGA</a>, and aside from that, I also had the Windows 3.1 DDK (Driver Development Kit), which is <a href="https://winworldpc.com/product/windows-sdk-ddk/windows-31">archived on WinWorld</a>.</p>
<p>The DDK includes the following bits which are relevant to us:</p>
<ul>
<li><strong>Display Driver source</strong>: VGA, IBM 8514, Video 7, 16-colour SVGA</li>
<li><strong>VDD source</strong>: VGA, IBM 8514, Video 7, 16-colour SVGA</li>
<li><strong>Grabber source</strong>: ... Basically all of them</li>
<li>A pitiful amount of written documentation</li>
</ul>
<p>Noticeably absent however are the 256-colour SVGA display driver and its associated VDD. I don’t know if these were included in a later DDK version, or if they just never left Microsoft at all.</p>
<p>I did grab the Windows 95 DDK to see if it contained anything relevant, but it wasn’t particularly useful.</p>
<p>All hope is not lost though, the 3.1 DDK is still helpful. I’m assuming that there are significant amounts of shared code between these drivers. We just need to wade through all the macro-laden assembly.</p>

<h2>Step 1: Load the Code</h2>
<p>Disassembling 16-bit x86 code is pretty weird; I&#39;m still not quite used to segments, as someone who&#39;s primarily looked at PowerPC and ARM code before. Still, it&#39;s doable.</p>
<p>IDA can load all the binaries with no issues, but unfortunately, not in the free version which is arbitrarily restricted to PE files. Ghidra can load the <code>.drv</code> display drivers, but not the VDD as it&#39;s actually a VxD.</p>
<p>I tried <a href="https://github.com/oshogbo/ghidra-lx-loader">oshogbo/ghidra-lx-loader</a> at first to load the VDD in Ghidra, but it fails. Then I tried <a href="https://github.com/yetmorecode/ghidra-lx-loader">yetmorecode/ghidra-lx-loader</a>, which works, but at the time of writing you need to build a PR to get it to work with the latest Ghidra.</p>
<pre><code>$ git clone git@github.com:yetmorecode/ghidra-lx-loader.git
$ git fetch origin pull/7/head:buildfix
$ git switch buildfix
$ GHIDRA_INSTALL_DIR=~/Downloads/ghidra_11.2.1_PUBLIC gradle buildExtension</code></pre>
<p>Once built, go to <em>File &gt; Install Extensions</em> in Ghidra, add the built extension zip file from <code>dist/</code>, and restart Ghidra.</p>

<p>You can now import the <code>vddsvga.386</code> file and it will be detected as a &#39;Linear Executable&#39;. However, it&#39;s nowhere near as seamless as in IDA...</p>
<p>This VxD contains both 32-bit code and 16-bit code, but as far as I can tell, Ghidra expects the entire file to be either one or the other. So if I import the file with the default &#39;language&#39; of 32-bit, it&#39;ll fail to decode the real mode initialisation code in the last segment. OTOH, if I switch it to 16-bit, then it&#39;ll fail to decode the vast majority of the code in the file.</p>
<p>I&#39;m probably missing something due to my lack of familiarity with x86 and its tooling 🤔</p>
<h2>Step 2: Match Things Up</h2>
<p>After loading up <code>svga256.drv</code> (both the original Microsoft version and the SVGAPatch-modified version) and <code>vddsvga.386</code>, I was ready to begin.</p>
<p>I began with the <code>.drv</code> file. Conveniently, this one has a whole bunch of exported functions like <code>GETCHARWIDTH</code>, <code>STRETCHBLT</code> and <code>VIDEOINIT_ATI</code>, so I thought it&#39;d be good to go through these and compare them to the source from the DDK, hopefully getting to name some other functions and global variables in the process.</p>
<p>Since <code>FASTBORDER</code> is the first one in the file, I started looking at that - it corresponds to <code>WIN31/DDK/286/DISPLAY/4PLANE/FB.ASM</code> in the DDK.</p>
<p>This is when I found out just how heavily this source code relies on macros...</p>
<p><a rel="lightbox" href="https://wuffs.org/user/pages/02.blog/windows-3x-graphics/fastborder.png"><img alt="Side-by-side screenshot of FB.ASM in VS Code next to the same routine in Ghidra&#39;s disassembly view. The source contains 24 lines of non-standard macros for defining parameters and local variables, which have been turned into 11 assembly instructions for creating a stack frame." src="https://wuffs.org/user/pages/02.blog/windows-3x-graphics/fastborder.png"/></a></p>
<p>On the left is the DDK&#39;s source for <code>FASTBORDER</code>, and on the right is how it appears in Ghidra (after I&#39;ve manually applied labels and variable/parameter names).</p>
<p>This is using <code>cProc</code> and associated macros, which seems to be a way to make defining C-compatible procedures more ergonomic... but it&#39;s not documented anywhere that I can see.</p>
<p>I can read the source for these macros, but they&#39;re somewhat inscrutable to say the least, with no comments and almost no indentation. A representative code sample:</p>
<pre><code>if ???+?po
if ?chkstk1
push bp
mov bp,sp
else
if ???
enter ???,0
else
push bp
mov bp,sp
endif
endif
endif</code></pre>
<p>For my purposes, I don&#39;t really need to understand this, I just need to know that I can skip past the initialisation guff every time I see it in a <code>cProc</code> procedure.</p>
<p>Likewise, there&#39;s <code>arg</code> and <code>cCall</code> macros used for calling these, but those are fairly self-explanatory:</p>
<pre><code>    arg &lt;lpPDevice,destx,desty,ax,ax,ax,ax,xext,yext,rop,lpPBrush,lpDrawMode&gt;
    cCall   BitBlt</code></pre>
<p>This just pushes all of these arguments onto the stack, and calls the function.</p>
<p>So <code>FASTBORDER</code> is essentially the same in <code>svga256.drv</code> as it is in the VGA driver that I have source for; that&#39;s promising!</p>
<hr/>
<p>The next function is <code>GETCHARWIDTH</code>, which is used to retrieve the widths of characters in a font. This is where I reach a new issue - this function isn&#39;t the same.</p>
<p>Also, just to make my life a bit harder, the proc has 7 parameters but not all of them are used -- meaning that I need to be extra careful about making sure I name them correctly in Ghidra.</p>
<p><a rel="lightbox" href="https://wuffs.org/user/pages/02.blog/windows-3x-graphics/charwidth.png"><img alt="Another side-by-side comparison. The left side shows the heavily commented assembly source in VS Code, and the right side shows the disassembly in Ghidra. One block, referred to as &#34;embolding simulation stuff&#34; in the comments, is missing from the Ghidra side." src="https://wuffs.org/user/pages/02.blog/windows-3x-graphics/charwidth.png"/></a></p>
<p>Turns out, there&#39;s some functionality in the VGA driver that adjusts the width of bold fonts. This does not seem to be present in <code>svga256.drv</code>!</p>
<p>I checked all the other implementations in the DDK&#39;s various drivers, but the VGA one is still the closest match. The Video 7 driver doesn&#39;t include this feature, but there are other differences in the code.</p>

<p>I wondered if this feature was added later, and maybe the SVGA256 driver was forked from an older version. There are some changelog-esque comments in many of these files, but MS don&#39;t seem to have done a great job at keeping them up to date :(</p>
<pre><code>; Created: Thu 30-Apr-1987
; Author:  Walt Moore [waltm]
...
; History:
;  Monday 3-October-1988 13:52   -by-   Ron Gery [rong]
;  moved into fixed code segment for fonts-in-EMS</code></pre>
<p>This is from the header for the VGA driver&#39;s <code>CHARWDTH.ASM</code> file.</p>
<p>It&#39;s very slightly different from the equivalent file in the PC-98 video driver, but both of these have identical dates and history entries, which suggests that I just can&#39;t put much faith into those comments.</p>
<p>Anyway, moving on...</p>
<hr/>
<p>The next export after this was <code>REALIZEOBJECT</code>, which is the Windows GDI function that takes an object (pen, brush or font) and processes it to make it suitable for the driver - for example, choosing the closest available colour to the one requested by the application.</p>
<p>This one gave me a little more grief because it was my first time encountering a jump table, but it was doable. However... the colour handling logic is different, of course!</p>
<p>In the VGA driver&#39;s source, we see this logic with some curiously commented out code:</p>
<pre><code>realize_pen_10:
    xchg    ax,cx           ;Set pen type into CX
    lea si,[si].lopnColor   ;--&gt; RGB color
;   call    convert_index       ; convert the index into DH if the
                                    ; color is actually an index
;   jc  realize_pen_20      ; it was an index

    call    sum_RGB_colors      ;Sum up the color</code></pre>
<p>Whereas in SVGA256, the call to <code>sum_RGB_colors</code> has been replaced by ... a manually-inlined version of it? 🤔</p>
<p>Also, while the initial dispatch code is identical to the VGA driver&#39;s, the implementation of everything from <code>realize_brush</code> onwards is almost identical to the one from the Video 7 driver. Odd.</p>
<hr/>
<p>After this, I realised that looking further at the GDI functions probably wouldn&#39;t be super helpful. It&#39;s helped me to get my bearings in this codebase, but what I <em>really</em> care about is how it interacts with the video adapter.</p>
<h2>Step 3: Initialising the Video Adapter</h2>
<p>I&#39;d previously mentioned that when you select a type of video adapter in <em>Windows Setup</em>, it creates some INI entries in <code>SYSTEM.INI</code>.</p>
<p>If I pick <em>Super VGA (800x600, 256 colours, small fonts)</em>, I get the following entries:</p>
<pre><code>[svga256.drv]
dpi=96
resolution=2</code></pre>
<p>And after booting into Windows, the patched driver automatically adds these extra entries...</p>
<pre><code>svgamode=48
ChipSet=Tseng ET4000
LatchCapable=No</code></pre>
<p>I have no clue what these mean, but luckily, since these are named with nice text strings like <code>ChipSet</code>, it&#39;s very easy to find the code that interacts with them within the driver.</p>
<hr/>
<p>The first one is in a function that, based on its placement, appears to be <code>driver_initialization</code>. I believe this is automatically called by Windows as the very first thing after the driver has been loaded into RAM.</p>
<p>If I look at the VGA driver from the DDK, it&#39;s got some pretty obtuse logic:</p>
<ul>
<li>Construct some flags based on whether we&#39;re on DOS 3.1.0 or higher, and whether we&#39;re on OS/2 or not</li>
<li>Call a <code>dev_initialization</code> function
<ul>
<li>Checks how much video memory is present, and disables a specific <code>BitBlt</code> feature if it&#39;s less than 256KB</li>
</ul></li>
<li>Load the <code>MouseTrails</code> setting from an INI</li>
<li>Mess with the function pointers to <code>ExtTextOut</code> and <code>StrBlt</code> for reasons I don&#39;t fully understand</li>
</ul>
<p>The Video 7 driver is a bit simpler -- it has the same flag logic, and it calls <code>dev_initialization</code> to assert that the driver is running on a 286 CPU or better, but it doesn&#39;t look at any INIs or mess with function pointers.</p>
<hr/>
<p>On the other hand, the SVGA256 driver we&#39;re looking at is <em>trivial</em>.</p>
<p>Translated into pseudo-C just to make it a bit easier to understand:</p>
<pre><code>short ini_resolution = 0;
short ini_dpi = 96;

short driver_initialization(/* args not relevant here */) {
    short r = GetPrivateProfileInt(&#34;svga256.drv&#34;, &#34;resolution&#34;, 0, &#34;system.ini&#34;) &amp; 3;
    if (r != 0) {
        ini_resolution = r;
        ini_dpi = GetPrivateProfileInt(&#34;svga256.drv&#34;, &#34;dpi&#34;, 0, &#34;system.ini&#34;);
        return 1;
    }
    return 0;
}</code></pre>
<p>This function is untouched by SVGAPatch.</p>
<p>So that&#39;s useful... now, where do these get used?</p>
<hr/>
<p>The function directly after it seems to be the equivalent to <code>physical_enable</code>. This is where it truly gets interesting - this is what sets up the VGA adapter!</p>
<p>We can look at this in <code>VGA.ASM</code> in the DDK; this uses assembler directives to generate different code for the VGA driver and for the 16-colour SVGA driver.</p>
<p>The code I see in SVGA256 is obviously an evolution of the latter. Once again I&#39;ll translate it to pseudo-C to make it easier to follow.</p>
<p>However, first I need to go on a slight tangent...</p>
<h3>System calls on the PC</h3>
<p>How do you &#34;reach out&#34; and interact with the OS or the hardware? There are three approaches we see in this driver.</p>
<p>Firstly, Windows functions like <code>SetPalette</code> and <code>WritePrivateProfileString</code> are imported from DLLs, so once you include the boilerplate to tell the assembler/linker about them, you can just call them like you would a function in your own code.</p>
<p>Then we have interrupts, which I&#39;ve represented in this pseudocode using fake functions like <code>vga_enable_refresh()</code>. With these, you set certain registers to specific values (depending on what you want to do), and then use the x86 <code>INT</code> instruction.</p>
<p>I&#39;ve looked them up in <a href="http://www.ctyme.com/rbrown.htm">this beautiful 90s-web adaptation of Ralf Brown&#39;s Interrupt List</a>, which is a very useful resource - I&#39;ve also linked the individual pages below where referenced.</p>
<p><code>INT 10h</code> is the PC&#39;s <a href="http://www.ctyme.com/intr/int-10.htm">standard interrupt</a> for doing anything video-related; the contents of the <code>ax</code> register identify what operation you want to do.</p>
<p><code>INT 2Fh</code> is the <a href="http://www.ctyme.com/intr/int-2f.htm">&#34;Multiplex&#34; operation</a>, which is kind of like a miscellaneous bucket for services installed by MS-DOS, Windows, and other applications like TSRs.</p>
<p>Lastly, you can also just poke hardware registers directly using the <code>IN</code> and <code>OUT</code> x86 instructions. This isn&#39;t used in this particular function, but it&#39;ll show up in plenty of other places, as this is a fundamental part of working with VGA.</p>
<h3>Tearing apart <code>physical_enable</code></h3>
<pre><code>struct int_phys_device {
    BITMAP bitmap;
    char ipd_format, ipd_equipment, ipd_enabled;
};

struct ModeEntry {
    char *chipSetName;
    short mode;
    char *modeString;
    short functionID;
};
struct ModeEntry modes_800x600[] = {
    { &#34;Tseng ET4000&#34;, 48, &#34;48&#34;, 2000 },
    { &#34;Video 7&#34;, 0x8000 | 105, &#34;105&#34;, 2003 },
    { &#34;Trident&#34;, 94, &#34;94&#34;, 2006 },
    { &#34;Oak&#34;, 84, &#34;84&#34;, 2009 },
    { &#34;Western Digital&#34;, 92, &#34;92&#34;, 2012 },
    { &#34;ATI VGA Wonder&#34;, 99, &#34;99&#34;, 2015 },
    { &#34;Cirrus Logic&#34;, 48, &#34;48&#34;, 2018 },
    { &#34;Cirrus Logic 542x&#34;, 92, &#34;92&#34;, 2021 }
};
// ... plus two more for 640x480 and 1024x768
struct ModeTable {
    struct ModeEntry *modes;
    short width, height, _padding;
};
struct ModeTable wModeTable[] = {
    { 0, 0, 0, 0 },
    { modes_640x480, 640, 480, 0 },
    { modes_800x600, 800, 600, 0 },
    { modes_1024x768, 1024, 768, 0 }
};

short ScratchSel;
short wGraphicsMode;
short CurrentWidth, CurrentHeight;
short RequestedMode;
short FunctionID;
char latchCapableFlag;

(int, short) physical_enable(struct int_phys_device *pDevice) {
    // save the original video mode
    // this calls INT 10h with ax=0F00h
    pDevice-&gt;ipd_format = get_current_video_mode();

    ScratchSel = AllocSelector(0);

    short mode = wGraphicsMode;
    if (mode == 0) {
        mode = GetPrivateProfileInt(&#34;svga256.drv&#34;, &#34;svgamode&#34;, 0, &#34;system.ini&#34;);
    }
    short originalMode = mode;

retry:
    if (ini_resolution == 0) {
        // 1020 is the id of a &#34;not specified&#34; error message
        return (0, 1020);
    }
    struct ModeEntry *entry = wModeTable[ini_resolution].modes;
    CurrentWidth = wModeTable[ini_resolution].width;
    CurrentHeight = wModeTable[ini_resolution].height;
    RequestedMode = mode;

    short c;
    if (mode == 0) goto SVGA_Next;
    // if a mode was specified in the INI, search for it
    do {
        c = (entry++)-&gt;mode &amp; 0xFF;
        if (c == 0) goto tryFullSearch;
    } while (c == mode);
tryMode:
    if (SetAndValidateMode(c, (CurrentWidth / 8) - 1, CurrentHeight - 1)) {
        goto SVGA_Success;
    }
SVGA_Next:
    if (RequestedMode != 0) goto tryFullSearch;
    c = (entry++)-&gt;mode;
    if (c != 0) goto tryMode;
    // full scan failed, so the driver can&#39;t work at all
    // 1010 is the ID of the &#34;Failed to initialise&#34; message
    return (0, 1010);
tryFullSearch:
    // failed to find the mode specified in the INI, or it didn&#39;t work
    // so do a scan through all modes again
    mode = 0;
    goto retry;

SVGA_Success:
    // at this point, a mode has been found
    entry--;

    if (entry-&gt;functionID == 2012 &amp;&amp; special_type_2012()) {
        // if certain conditions are met, switch from &#34;Western Digital&#34; to &#34;Cirrus Logic 542x&#34;
        entry += 3;
    } else if (entry-&gt;functionID == 2000 &amp;&amp; special_type_2000()) {
        // switch from &#34;Tseng ET4000&#34; to &#34;Cirrus Logic&#34;
        entry += 6;
    }

    wGraphicsMode = entry-&gt;mode;
    FunctionID = entry-&gt;functionID;

    if (mode != originalMode) {
        WritePrivateProfileString(&#34;svga256.drv&#34;, &#34;svgamode&#34;, entry-&gt;modeString, &#34;system.ini&#34;);
        WritePrivateProfileString(&#34;svga256.drv&#34;, &#34;ChipSet&#34;, entry-&gt;chipSetName, &#34;system.ini&#34;);
    }

    // this calls INT 10h with ax=1201h, bl=36h
    vga_disable_refresh();

    // uses the FunctionID to look up chipset-specific &#39;VideoInit&#39;, &#39;SetBank&#39;
    // and &#39;BltSpecial&#39; functions
    resolve_procs();

    // calls the chipset-specific VideoInit function
    (*ptr_videoinit)();

    latchCapableFlag = checkLatchCapability();
    WritePrivateProfileString(&#34;svga256.drv&#34;, &#34;LatchCapable&#34;, latchCapableFlag ? &#34;Yes&#34; : &#34;No&#34;, &#34;system.ini&#34;);

    enabled_flag = 0xFF;
    SetPalette(0, 256, &amp;adPalette);

    clear_framebuffer();

    // this calls INT 10h with ax=1200h, bl=36h
    vga_enable_refresh();

    // this will be explained later
    call_VDD_Set_Addresses();

    // this calls INT 2Fh with ax=4000h, and will be explained later too
    switch_to_background();

    return (1, 0);
}</code></pre>
<p>So that&#39;s the code, which doesn&#39;t translate super cleanly into pseudo-C, but I&#39;ve tried my best. A high-level overview of what it&#39;s doing:</p>
<ol>
<li>Record the current video mode before we do anything</li>
<li>Check if a <code>svgamode</code> entry exists in <code>SYSTEM.INI</code></li>
<li>If so, call <code>SetAndValidateMode</code> to try that mode</li>
<li>If there was no entry <em>or</em> that mode failed, then go through each supported mode in turn until we find one that works</li>
<li>If we chose the <em>Western Digital</em> mode and some opaque checks succeed, then switch to <em>Cirrus Logic 542x</em></li>
<li>If we chose the <em>Tseng ET4000</em> mode and some other checks succeed, then switch to <em>Cirrus Logic</em></li>
<li>Save the new mode and chipset name to the <code>SYSTEM.INI</code> file</li>
<li>Call some chipset-specific initialisation code</li>
<li>Check the &#39;latch capability&#39;, whatever that means, and write it to the INI as well</li>
<li>Set the Windows palette</li>
<li>Clear the framebuffer</li>
<li>Set up the VDD</li>
</ol>
<p>Now we&#39;re in a good position to ask - how does this interact with SVGAPatch? This code from Microsoft&#39;s driver is written to let them support a few different chipsets. But the point of SVGAPatch is to use the newer VBE standard, and in theory, support any video adapter that&#39;s VBE compliant!</p>
<p>This function itself doesn&#39;t change, but it&#39;s directly adjacent to the stuff that does.</p>
<h2>SVGAPatch&#39;s Secret Sauce</h2>
<p>When you run the patcher, it gives you some output that tells you what it&#39;s changed. Now I know what all the relevant code does.</p>
<pre><code>Segment 3: addr=3AA0, size=917
Segment patched at offset 37E
Segment patched at offset 3D5
Segment patched at offset 42C
Segment patched at offset 481
Segment 11: addr=15240, size=7CD
Segment patched at offset 0</code></pre>
<p>The first 3 patches are setting the &#39;special function ID&#39; for the very first chipset in each of the three lists <em>(one for each supported resolution)</em> to 2000.</p>
<p>The one at offset 481 is completely rewriting the <code>SetAndValidateMode</code> function. Finally, the one in Segment 11 is rewriting the chipset-specific functions with IDs 2000 and 2001.</p>

<p>So what&#39;s going on here? This patch is actually very simple, but pretty smart.</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Original MS code</th>
<th>Replacement from SVGAPatch</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SetAndValidateMode</code></td>
<td>- Use <a href="http://www.ctyme.com/intr/rb-0069.htm">the VGA BIOS</a> to try and set the video mode</td>
<td>Use <a href="http://www.ctyme.com/intr/rb-0275.htm">VBE operation <code>4F02h</code></a> to request an extended video mode depending on the configured resolution</td>
</tr>
<tr>
<td><code>SETBANK_TRIDENT</code></td>
<td>Write a non-standard value to <code>3C4h</code> (the VGA Sequencer Address Register)</td>
<td>Use <a href="http://www.ctyme.com/intr/rb-0278.htm">VBE operation <code>4F05h</code></a> to move the CPU&#39;s window to the video memory</td>
</tr>
<tr>
<td><code>VIDEOINIT_TRIDENT</code></td>
<td>Write to the VGA CRTC&#39;s Offset Register to set the amount of bytes between scan lines</td>
<td>Use <a href="http://www.ctyme.com/intr/rb-0280.htm">VBE operation <code>4F06h</code></a> to set the scan line length in bytes</td>
</tr>
</tbody>
</table>
<p>Finally, to tie this into <code>physical_enable</code>, the new logic ends up being as follows...</p>
<ol>
<li>Scan through all the supported modes in order, calling <code>SetAndValidateMode</code> for each one</li>
<li>The first one will succeed, so it&#39;s picked by default</li>
<li>Since the Function ID was replaced with 2000, the rewritten &#39;TRIDENT&#39; chipset-specific functions are used</li>
<li>Since the chipset name and mode values are now unused, we see the values for the &#39;Tseng ET4000&#39; written to <code>SYSTEM.INI</code>, just because it&#39;s the first one in the list</li>
</ol>
<p>And with that, we&#39;ve solved one piece of the puzzle - how SVGAPatch works. But we&#39;ve still not answered the question: <em>why do DOS prompts cause trouble?</em></p>

<p>It&#39;s time to go down yet another rabbit hole! There is a pretty good explanation of VDDs on the OS/2 Museum blog post that I linked earlier: <a href="https://www.os2museum.com/wp/windows-3-x-vddvga/">Windows 3.x VDDVGA</a></p>
<p>TL;DR: DOS programs are written to expect exclusive access to the computer&#39;s hardware (including the video adapter), and Windows cleverly tricks them into talking to virtualised implementations instead.</p>
<p>The author was writing their own display driver and having trouble with DOS prompts <em>(sound familiar?)</em>, and discovered that certain parts of the VGA registers were changing in unexpected ways when the mode changed inside a windowed DOS prompt ... which in <em>theory</em>, should not affect the real VGA adapter, as the GUI is supposed to have control over it.</p>
<p>They also note that a specific <code>DspDrvr_Addresses</code> function (which is located in the VDD and called from the display driver) doesn&#39;t actually do what the comments say it does, and that our <code>SVGA256.DRV</code> has special behaviour here.</p>
<blockquote>
<p>A corollary is that passing 0FFFFh as the latch byte address to the VDD (something that SVGA256.DRV does) tells VDDVGA.386 that there is no video memory to share. In that situation, VDDVGA.386 does not try any hair-raising schemes to modify the VGA register state behind the display driver’s back.</p>
</blockquote>
<p>Huh. <em>(I&#39;ll pretend I know what that means.)</em></p>

<p>As with the display driver... the Windows DDK gives us the source code for the VGA VDD, but not for the SVGA one that we&#39;re using. So I delved into the SVGA VDD with two goals in mind:</p>
<ol>
<li>Find out what changes Microsoft made in between the VGA VDD and the SVGA VDD
<ul>
<li>Is there chipset-specific behaviour hiding here that needs to be patched for generic VBE support?</li>
</ul></li>
<li>Try and learn what the deal is with <code>DspDrvr_Addresses</code></li>
</ol>
<p>I painstakingly mapped out the functions in the VDD,. The majority of them were unchanged, but I did come across some interesting-looking differences, and I learned a lot about how the system works in the process.</p>
<h2>Tangent: The VDD&#39;s Architecture</h2>
<p>If we look at <code>VDDCTL.ASM</code>, we see a whole set of interesting entry points to the VDD - some of the more notable ones:</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>VDD_Device_Init</code></td>
<td>Set up the System VM (The one that Windows itself runs in)</td>
</tr>
<tr>
<td><code>VDD_Create_VM</code></td>
<td>Set up another VM (for a DOS application)</td>
</tr>
<tr>
<td><code>VDD_Set_Device_Focus</code></td>
<td>Called when the active VM is switching</td>
</tr>
</tbody>
</table>
<p>Just to keep things spicy, there&#39;s also a bunch of external entry points in <code>VDDSVC.ASM</code>, and there&#39;s custom interrupt handlers in <code>VDDINT.ASM</code>.</p>

<p>Anyway, each VM gets its own instance of a big structure called <code>VDD_CB_Struc</code>, which is defined in <code>VDDDEF.INC</code>. This contains a whole lot of stuff, including:</p>
<ul>
<li>Various bitfields with all sorts of flags</li>
<li>A complete mirror of the VGA controller&#39;s state</li>
<li>Details of what video memory has been allocated by this particular VM</li>
</ul>
<p>This whole system is impressively complex! There&#39;s a large <code>VDDOEM.ASM</code> file dedicated entirely to vendor-specific custom code, which is exactly what I was scared of...but we&#39;ll see how far we can get.</p>
<p><code>VDDTIO.ASM</code> has a ton of logic that traps read/write accesses to the various VGA registers. I believe this is used by backgrounded VMs - so the active VM gets direct access, but any VM running in the background will just hit these routines and end up talking to the VDD&#39;s simulated VGA adapter.</p>
<hr/>
<p>Last but not least, but important here: The real-mode initialisation code found in <code>VDD_Real_init</code> has logic to detect various different VGA adapters, and it enables specific flags for them which get stored in the <code>VDD_TFlags</code> bitfield. These flags, in turn, influence other parts of the VDD&#39;s behaviour.</p>
<p>Many of these changes are just to teach the VDD to save, restore and simulate specific registers that only exist on certain adapters.</p>

<p>At this point I was feeling a little unsure about this project. If the VDD&#39;s state tracking requires <em>this</em> much micromanagement of the VGA adapter and its vendor-specific quirks, then I might just be fighting a battle that I can&#39;t win.</p>
<p>But I figured I could keep going and see if I can learn some more.</p>
<h2>What&#39;s the deal with DspDrvr_Addresses?</h2>
<p>There&#39;s a number of APIs provided by the VDD to the grabber. In <code>386/INCLUDE/VMDAVGA.INC</code> we see these interesting definitions for new ones:</p>
<pre><code>; New API&#39;s for 3.1 display drivers
Private_DspDrvr_1   EQU 0Ah
                .errnz Private_DspDrvr_1 - GRB_Unlock_APP - 1
DspDrvr_Version     EQU 0Bh
DspDrvr_Addresses   EQU 0Ch</code></pre>
<p>And if we look inside <code>386/VDDVGA/VDDSVC.ASM</code>, we see how the VGA VDD handles these:</p>
<pre><code>IFDEF DspDrvrRing0Hack
    cmp cl,Private_DspDrvr_1
    je  VDD_Init_DspDrv_Ring0
ENDIF
    cmp cl, DspDrvr_Version
    je  VDD_SVC_Dsp_Version
    cmp cl, DspDrvr_Addresses
    je  VDD_SVC_Set_Addresses</code></pre>
<p><em>Suspicious.</em> The first one seems to only be used by the IBM 8514 display driver, for a specific implementation of <code>BitBlt</code>. The second one just returns a version number. The third one is what we really care about.</p>
<p>Here&#39;s the comments from the VDDVGA implementation:</p>
<pre><code>;******************************************************************************
;
;   VDD_SVC_Set_Addresses
;
;   DESCRIPTION:    This service is called by the display driver BEFORE it
;           does the INT 2Fh to indicate that it knows how to restore
;           its screen.  This service is used to tell us where we
;           can interface with the display driver.
;
;           One of the addresses passed is the location of a byte of
;           video memory that we can safely use to save/restore latches.
;
;           The 2nd address passed is the location of the flag byte
;           used by the display driver to determine the availability
;           and validity of the &#34;save screen bits&#34; area.  The display
;           driver copies portions of the visible screen to non-visible
;           memory to save original contents when dialog boxes or menus
;           area displayed.  Since this is non-visible memory, it is
;           subject to demand paging and be stolen for use by a
;           different VM.  If a page is stolen from the sys VM, then
;           any data that was in the page is lost, because we don&#39;t
;           maintain a copy, so we need to indicate to the display
;           driver that the &#34;save screen bits&#34; area is now invalid.
;
;
;   ENTRY:      EBX = VM Handle
;           EBP = Client stack frame ptr
;           Client_AX = function #
;           Client_BX = offset of address in display segment
;           Client_DX is reserved and must be 0
;           ClientDS:Client_SI -&gt; shadow_mem_status
;
;   EXIT:       Client_AX is returned with a copy of Client_BX to
;           indicate that the service is implemented
;
;   USES:       EAX, ECX, Flags
;
;==============================================================================</code></pre>
<p>Here&#39;s my best pseudo-C translation of the code and its comments, because I don&#39;t want to inflict more x86 assembly on anyone than is absolutely necessary. You deserve better.</p>
<pre><code>extern void VDD_PH_Mem_Set_Sys_Latch_Addr(u32 eax, u8 cl, u8 ch, u32 edx);

void VDD_SVC_Set_Addresses(struct ClientStackFrame *s) {
    struct VDD_CB_Struc *cb = SetVDDPtr();

    u32 latchAddr; // eax
    u8 latchBank; // cl
    u8 firstVisiblePageInFirstBank; // ch
    u32 visiblePagesInFirstBank; // edx

    latchAddr = s-&gt;Client_BX;
    s-&gt;Client_AX = latchAddr &amp; 0xFFFF;

    if (s-&gt;Client_DX
#ifdef TLVGA
        &amp;&amp; (cb-&gt;VDD_TFlags &amp; fVT_TL_ET4000)
#endif
    )
    {
        VT_Flags &amp;= ~fVT_SysVMin2ndBank;
        cb-&gt;VDD_TFlags &amp;= ~fVT_SysVMin2ndBank;

        visiblePagesInFirstBank = 0;
        firstVisiblePageInFirstBank = 0;
        latchBank = s-&gt;Client_CL;
        // Q: display driver put latch byte in different bank?
        if (latchBank == 0) {
            // N: we have to reserve a pg
            visiblePagesInFirstBank++;
            // in the 1st bank
            firstVisiblePageInFirstBank = (latchAddr &gt;&gt; 8) &amp; 0xFF;
            // CH page # to reserve
            firstVisiblePageInFirstBank &gt;&gt;= 4;
        } else {
            // Y: so no pages are required in 1st bank
        }
    } else {
        firstVisiblePageInFirstBank = 0;
        latchBank = 0;
        visiblePagesInFirstBank = (latchAddr &gt;&gt; 12) + 1;
        // this assumes latch page is last visible page
    }
#endif
    cb-&gt;VDD_Flags |= fVDD_DspDrvrAware;
    VDD_PH_Mem_Set_Sys_Latch_Addr(latchAddr, latchBank, firstVisiblePageInFirstBank, visiblePagesInFirstBank);

    Vid_Shadow_Mem_Status_Ptr = (s-&gt;Client_DS &lt;&lt; 16) | s-&gt;Client_SI;
}</code></pre>
<p>So there&#39;s some weirdness going on here. The comment says that <code>DX</code> is reserved and must be 0. Yet, if <code>DX</code> is a non-zero value, this triggers special behaviour that reads from <code>CL</code> (which isn&#39;t even documented as being used)!</p>
<p>And this isn&#39;t used by any of the drivers in the DDK. Weird.</p>
<hr/>
<p>What about the SVGA version? Sadly I don&#39;t have comments for that, but I can at least disassemble the code and do a similar translation.</p>
<pre><code>extern void VDD_PH_Mem_Set_Sys_Latch_Addr(u32 eax, u8 cl, u8 ch, u32 edx);

void VDD_SVC_Set_Addresses(struct ClientStackFrame *s) {
    struct VDD_CB_Struc *cb = SetVDDPtr();

    u32 latchAddr; // eax
    u8 latchBank; // cl
    u8 firstVisiblePageInFirstBank; // ch
    u32 visiblePagesInFirstBank; // edx

    latchAddr = s-&gt;Client_BX;
    s-&gt;Client_AX = latchAddr &amp; 0xFFFF;

    if (s-&gt;Client_DX &amp;&amp; s-&gt;Client_DX == 2) {
        VT_Flags &amp;= ~(fVT_SysVMnot1stBank | fVT_SysVMin2ndBank);
        cb-&gt;VDD_TFlags &amp;= ~(fVT_SysVMnot1stBank | fVT_SysVMin2ndBank);
        VT_Flags |= fVT_0x400;
        cb-&gt;VDD_TFlags |= fVT_0x400;

        FUN_00013f60(&amp;VDD_VM_Mem_Msg_Page_Handler);
        latchBank = 0;
        firstVisiblePageInFirstBank = 0;
        visiblePagesInFirstBank = 16;
    } else if (s-&gt;Client_DX &amp;&amp; (cb-&gt;VDD_TFlags &amp; fVT_TL_ET4000)) {
        VT_Flags &amp;= ~fVT_SysVMin2ndBank;
        cb-&gt;VDD_TFlags &amp;= ~fVT_SysVMin2ndBank;

        visiblePagesInFirstBank = 0;
        firstVisiblePageInFirstBank = 0;
        latchBank = s-&gt;Client_CL;
        // Q: display driver put latch byte in different bank?
        if (latchBank == 0) {
            // N: we have to reserve a pg
            visiblePagesInFirstBank++;
            // in the 1st bank
            firstVisiblePageInFirstBank = (latchAddr &gt;&gt; 8) &amp; 0xFF;
            // CH page # to reserve
            firstVisiblePageInFirstBank &gt;&gt;= 4;
        } else {
            // Y: so no pages are required in 1st bank
        }
        firstVisiblePageInFirstBank = 0;
        latchBank = 0;
        visiblePagesInFirstBank = (latchAddr &gt;&gt; 12) + 1;
        // this assumes latch page is last visible page
    }
#endif
    cb-&gt;VDD_Flags |= fVDD_DspDrvrAware;
    VDD_PH_Mem_Set_Sys_Latch_Addr(latchAddr, latchBank, firstVisiblePageInFirstBank, visiblePagesInFirstBank);

    Vid_Shadow_Mem_Status_Ptr = (s-&gt;Client_DS &lt;&lt; 16) | s-&gt;Client_SI;
}</code></pre>
<p>Broadly the same, but there&#39;s a brand new case for where the reserved field is set to 2. Also, the <code>latchBank</code> value is no longer used; the underlying logic in that file has changed quite a bit in ways I don&#39;t understand.</p>
<p>If I look at the code in the SVGA256 driver, it calls this function with:</p>
<ul>
<li><code>BX</code> (offset of address in display segment) is 0xFFFF</li>
<li><code>DX</code> (reserved field) is 2, for the new behaviour</li>
<li><code>DS:SI</code> (shadow mem status) is a pointer to a byte, which is not used by SVGA256 anywhere else</li>
</ul>
<p>Well, that&#39;s good to know.</p>
<h2>Where do I go from here?</h2>
<p>I hoped that analysing both the driver and the VDD would lead me to something obvious that I could just patch, but this hasn&#39;t really happened. The VGA hardware may be older than I am, but that doesn&#39;t make it simple to understand :(</p>

<p>So I may have to get my paws dirty and do some debugging. Coming back to the OS/2 Museum blog post again, the author writes:</p>
<blockquote>
<p>First I tried to find out what was even happening. Comparing bad/good VGA register state, I soon enough discovered that the sequencer registers contents changed, switching from chained to planar mode. This would not matter if the driver used the linear framebuffer to access video memory, but for good reasons it uses banking and accesses video memory through the A0000h aperture.</p>
</blockquote>
<p>Can I use the same techniques? I don&#39;t really know how to debug things like this, but these issues are fully reproducible in DOSBox, so let&#39;s give it a shot.</p>

<p>I&#39;m using DOSBox-X on my ARM MacBook. The version shipped by Homebrew doesn&#39;t seem to have debugging functionality, so I grabbed new binaries from their website, and now I get a helpful Debug menu.</p>
<p>There is a <em>Video debug overlay</em> option which adds some cool visualisations of the VGA adapter&#39;s state, along with a bit of info.</p>
<p><a rel="lightbox" href="https://wuffs.org/user/pages/02.blog/windows-3x-graphics/dosbox1.png"><img alt="A full-screen DOS prompt in DOSBox. The screen is covered in four swathes of dot characters, and the second line has a bunch of equals signs and letters interspersed with the dots. Debugging info and a visualisation of the active palette is shown by the overlay at the bottom of the window." src="https://wuffs.org/user/pages/02.blog/windows-3x-graphics/dosbox1.png"/></a></p>
<p>If I open a full-screen prompt, press Alt+Enter to return to the <em>(broken)</em> GUI and then press Alt+Enter again to full-screen again, I get this mess. Absolutely cooked.</p>
<p>Comparing the silly little annotations, I see the following state changes:</p>
<table>
<thead>
<tr>
<th>State</th>
<th>Silly little annotations</th>
</tr>
</thead>
<tbody>
<tr>
<td>Functional GUI</td>
<td><code>M_LIN8 G800x600&gt;800x600 @00000+100+Dch4</code></td>
</tr>
<tr>
<td>Functional DOS</td>
<td><code>M_TEXT T80x25&gt;720x400 @00000+050-W</code></td>
</tr>
<tr>
<td>Broken GUI</td>
<td><code>M_VGA G400x600&gt;400x600 @00000+200-Dch4</code></td>
</tr>
<tr>
<td>Broken DOS</td>
<td><code>M_TEXT T80x25&gt;720x400 @00000+250-W</code></td>
</tr>
</tbody>
</table>
<p>What does this mean?? Not a clue.</p>
<p>I can definitely see that the state is going haywire, but I don&#39;t know who&#39;s responsible. Is there something missing in the patched display driver? Is the VDD corrupting the state? Both?</p>
<p>I had one hunch. I&#39;d seen that the VDD has a lot of special behaviours for different cards; is it possible that one of these is unwittingly being activated and playing havoc? Say that the VDD mistakenly thinks I&#39;m using a... oh, I don&#39;t know, &#34;Trident&#34; GPU, and tries to write to a Trident-specific register, but that register address does something else entirely in whatever DOSBox is currently emulating.</p>
<p>This <em>could</em> be an issue... but to know for sure, I&#39;d need to figure out how to see what the value of <code>VT_Flags</code> is.</p>
<h2>Viewing Driver Memory</h2>
<p>The DOSBox Debugger has commands that let me view memory, but I had a problem - I didn&#39;t know <em>where</em> to look! I have no clue how Windows 3.11 maps memory for drivers, or how to even find that out.</p>
<p>My first idea was to just dump the entire system&#39;s memory and do a search for the <code>&#34;VDD     &#34;</code> string which is always present in the VDD&#39;s memory. This would&#39;ve worked, except for the fact that DOSBox-X&#39;s <code>MEMDUMP</code> command only works with logical addresses.</p>
<p>So I wound up with the slightly dirty solution of just recompiling DOSBox-X with that command tweaked. Sure enough, I dumped the first 32MB of physical addresses to a file, and I was able to find the driver&#39;s flags.</p>
<p>But this turned out to be a red herring. None of the vendor-specific flags are set; at least not in DOSBox. Oh well.</p>
<h2>Analysing VGA Registers</h2>
<p>I&#39;ll need to go a bit deeper. As it turns out, there&#39;s a whole set of commands I can use in the DOSBox debugger to print out fine details about the VGA state... basically every register.</p>
<p>I recreated the previous scenario and did this. If I compare all the registers between the &#39;good&#39; and &#39;bad&#39; full-screen DOS prompts, one thing sticks out: the field that DOSBox internally calls <code>scan_len</code>. This is used to calculate how many bytes to advance between each line on the screen. In the &#39;good&#39; state it&#39;s 40, but in the &#39;bad&#39; state it&#39;s 296.</p>
<p>What actually causes this, though??</p>

<p>This field can be updated in a few ways:</p>
<ul>
<li>Writes to the VGA CRTC Offset Register</li>
<li>Writes to the S3 &#34;CR43 Extended Mode&#34; Register</li>
<li>Writes to the S3 &#34;Extended System Control 2&#34; Register</li>
<li>Calls to the VESA Scan Line API <em>(the one used by SVGAPatch&#39;s changes!)</em></li>
</ul>
<p>It gets even stranger if I <em>begin</em> with a windowed DOS prompt and look at the <code>scan_len</code> value. On a &#39;good&#39; GUI, it&#39;s 128, but on a &#39;bad&#39; GUI (after returning to windowed mode), it&#39;s 256.</p>
<p>DOSBox&#39;s implementation of the VESA API calculates <code>scan_len</code> differently based on what it thinks the current video mode is. This is pretty suspicious.</p>
<hr/>
<p>Since I&#39;d already gone ahead and recompiled DOSBox myself, I figured I&#39;d go further and just throw in some logging.</p>
<pre><code>    LOG_MSG(&#34;VESA_ScanLineLength(subcall=%d, val=%d, bytes=%d, pixels=%d, lines=%d)\n&#34;, subcall, val, bytes, pixels, lines);
    LOG_MSG(&#34;  Current Mode: %s\n&#34;, mode_texts[CurMode-&gt;type]);</code></pre>
<p>And this gives me a smoking gun...!</p>
<pre><code>VESA_ScanLineLength(subcall=2, val=1024, bytes=2, pixels=1024, lines=4768)
  Current Mode: M_TEXT</code></pre>
<p>The display driver is calling <a href="http://www.ctyme.com/intr/rb-0280.htm">VBE operation <code>4F06h</code></a> to set the scan line length to 1024 bytes, but DOSBox thinks we&#39;re in text mode, so the resulting field is wrong.</p>
<p>The obvious next step is to add logging for video mode changes. This is a little more annoying than it seems, because there&#39;s a few ways this can occur. To be thorough, I decide to add log messages to all of them.</p>
<p>This finally lets me assemble a crude timeline of events.</p>
<ul>
<li>Start Windows
<ul>
<li><code>M_TEXT</code> -&gt; Mode 12h (640x480 VGA)</li>
<li><code>M_EGA</code> -&gt; Mode 10h (640x350 EGA)</li>
<li><code>M_EGA</code> -&gt; Mode 3 (80x25 text)</li>
<li><code>M_TEXT</code> -&gt; Mode 103h (800x600 SVGA)</li>
<li>ScanLineLength called: 1024 bytes, with the current mode being <code>M_LIN8</code></li>
</ul></li>
<li><strong>So far so good</strong> - we have a working desktop now</li>
<li>I open a full-screen DOS prompt
<ul>
<li><code>M_TEXT</code> -&gt; Mode 3 (80x25 text)</li>
</ul></li>
<li><strong>So far so good</strong> - we have a working prompt, no anomalies</li>
<li>I press Alt+Enter to return to windowed mode
<ul>
<li><code>M_TEXT</code> -&gt; Mode 30h (... what?!)</li>
<li>ScanLineLength called: 1024 bytes, with the current mode being <code>M_TEXT</code></li>
<li>Now the debugger says we&#39;re in mode <code>M_VGA</code>?!</li>
</ul></li>
<li><code>scan_len</code> is now corrupted, along with our display</li>
</ul>

<p>There&#39;s three things going on here that we need to unpack:</p>
<ol>
<li><em>Something</em> is asking for a mode switch to 30h (or decimal 48), which doesn&#39;t work as that is not a supported mode.</li>
<li>The patched display driver tries to set the scanline length, but this corrupts the state because we&#39;re in text mode</li>
<li>Yet we somehow end up in a graphics mode, without a switch?? What???</li>
</ol>
<p>DOSBox has a global variable called <code>CurMode</code> which is updated every time the video mode changes through a call to <code>INT 10h</code> - either with the legacy video mode call from the IBM PC days, or the <em>slightly</em> more modern VESA/VBE API.</p>
<p>On the other hand, the debugger&#39;s <code>VGA MODE</code> command (which is what I&#39;m using to introspect the state) is reading from DOSBox&#39;s <code>vga.mode</code>, which is a more low-level field in the display engine. This is computed from VGA registers.</p>
<p>So... I think this is the fault of the VDD! It&#39;s doing its thing and dutifully saving/restoring registers behind the scenes, but this leaves us out of sync when we try to use the higher-level VBE interface.</p>
<hr/>
<p>What about point 1? Who is trying to set the video mode to the invalid 30h, and why?</p>
<p>Well, this comes back to where we began. SVGAPatch hijacks the entries used by the Microsoft driver for the <em>Tseng ET4000</em> chipset. For a resolution of 800x600, it uses the Tseng-specific mode 30h.</p>
<p>Lo and behold, if we look for calls to <code>INT 10h</code> in our patched display driver, we find a function that calls it.</p>
<p>So the VBE patch really <em>is</em> incomplete after all... 🤔</p>

<p>I didn&#39;t want to just replace this function, I also wanted to understand how it fits into the whole system. So it&#39;s time to analyse how Windows 3.1 tells the driver about screen switches! Thankfully, this code is all present in the DDK&#39;s VGA driver, so that helps a lot.</p>
<h2>Screen Switching</h2>
<p>When the display driver is enabled, the <code>hook_int_2F</code> routine (from <code>SSWITCH.ASM</code>) is called. This gets pointers to a couple of functions from Windows DLLs, and also hooks the handler for <code>INT 2Fh</code>.</p>
<p>Remember, <code>2Fh</code> is the &#39;Multiplex&#39; interrupt, which lots of software can piggyback on. If a program wants to hook it, it has to store the address of the <strong>previous</strong> handler, and then call it for any requests that it didn&#39;t handle. This effectively creates a chain of hooks, eventually ending at whatever default was assigned by MS-DOS on boot.</p>
<p>This driver is no exception. The hook it uses is called <code>screen_switch_hook</code>.</p>

<p>The VGA driver is able to <strong>receive</strong> four commands via <code>INT 2Fh</code>, which are crudely documented as follows in the DDK:</p>
<pre><code>SCREEN_SWITCH_OUT equ   4001h       ;Moving 3xBox to background
SCREEN_SWITCH_IN  equ   4002h       ;Moving 3xBox to foreground
SAVE_DEV_REGS   equ 4005h       ;int 2f code to save registers
RES_DEV_REGS    equ     4006h       ;int 2f code to restore registers</code></pre>
<p>...but interestingly, only the two <code>SCREEN_SWITCH_x</code> commands are supported by the SVGA256 driver.</p>
<p>Anyway, both of these call three routines in order. For the <code>OUT</code> command, it&#39;s <code>pre_switch_to_background</code>, <code>dev_to_background</code>, and then <code>post_switch_to_background</code>. For the <code>IN</code> command, it&#39;s the same, but with <code>_to_foreground</code> routines instead.</p>
<p>All of these are pretty basic, except for <code>dev_to_foreground</code>, which is the one called when you switch back to Windows itself.</p>
<hr/>
<p>In the VGA driver&#39;s code (<code>286/DISPLAY/4PLANE/3XSWITCH.ASM</code>), <code>dev_to_foreground</code> is pretty simple - it calls <code>INT 10h</code> with <code>ax=1002h</code> to <a href="http://www.ctyme.com/intr/rb-0116.htm">reset all the palette registers</a>, then calls <code>init_hw_regs</code> to... set some stuff that I don&#39;t really get.</p>
<p>In the Video 7 driver&#39;s code from the DDK (<code>286/DISPLAY/8PLANE/V7VGA/SRC/3XSWITCH.ASM</code>), it&#39;s a bit spicier:</p>
<ul>
<li>Calls <code>farsetmode</code>, which:
<ul>
<li>Sets the display mode</li>
<li>Enables Video 7 VGA extensions</li>
<li>Sets the line length</li>
</ul></li>
<li>Calls <code>far_set_dacsize</code> to set the DAC mode, whatever that means</li>
<li>Calls <code>setramdac</code> to program the palette</li>
<li>Calls its own version of <code>init_hw_regs</code></li>
<li>Sets <code>enabled_flag</code> to 0xFF</li>
<li>Calls <code>far_set_cursor_addr</code></li>
</ul>
<p>So after looking at these, what do we see in the problematic SVGA256 driver?</p>
<ul>
<li>Calls <code>farsetmode</code>, which:
<ul>
<li>Sets the display mode to 48 (!!)</li>
<li>Calls the chipset-specific VideoInit routine</li>
</ul></li>
<li>Sets <code>enabled_flag</code> to 0xFF</li>
<li>Calls the Windows API&#39;s <code>SetPalette</code> to set the palette</li>
</ul>
<p>Herein lies our problem! There are <strong>two</strong> places where the video mode gets set, and SVGAPatch missed this one. It <em>does</em> call the VideoInit routine, so it uses the patched code to set the scanline length, but without being in the right video mode, it won&#39;t actually give us the right result.</p>
<h2>Can we fix it?</h2>
<p>Hopefully!</p>
<p>The original code just looks like this:</p>
<pre><code>mov ax, [wGraphicsMode]
int 10h
call [ptr_videoinit]
retn</code></pre>
<p>There&#39;s not much room to work with, but luckily, this is right after <code>SetAndValidateMode</code>, a function that was replaced by SVGAPatch with a much shorter version. So, I take the first byte right after the end of the new <code>SetAndValidateMode</code>, and inject some new assembly:</p>
<pre><code>mov cx, [CurrentHeight]
dec cx
call SetAndValidateMode
call ptr_videoinit
retn</code></pre>
<p>Since <code>SetAndValidateMode</code> expects <code>cx</code> to contain the screen height (minus 1), I do that. Then I replace the first instruction of <code>setmode</code> with a simple <code>jmp</code> to my new code.</p>
<p><a rel="lightbox" href="https://wuffs.org/user/pages/02.blog/windows-3x-graphics/dosbox2.png"><img alt="Screenshot showing a functional Windows 3.11 desktop in DOSBox, with a DOS prompt in a window. I&#39;ve typed in &#34;echo I&#39;m in full screen :)&#34;, followed by &#34;echo now I&#39;m in windowed mode!&#34;" src="https://wuffs.org/user/pages/02.blog/windows-3x-graphics/dosbox2.png"/></a></p>
<p>Lo and behold... the GUI no longer gets trashed after entering a full-screen DOS session!</p>
<p>One issue remains, though. If I go from windowed mode to full screen, the dots come back.</p>
<h2>Register Debugging (Again)</h2>
<p>I&#39;ve tried to use my previous trick where I invoke all the DOSBox VGA debug commands to dump the state and I compare them, but this time I&#39;m not getting anything useful.</p>
<p>Why am I getting nonsense? If I enter <code>DP B8000</code> into the DOSBox debugger console to look at the VGA memory, I see that the text is all there - it&#39;s just not showing up!</p>
<p>There is an interesting DOSBox debug feature that lets you enter a command like <code>VGA DS START 2</code> to override the VGA base address, and if I do this, it shifts the garbage around, but it&#39;s still the same garbage.</p>

<p>So then I thought... I know that the driver uses banking, so that it can access more video memory than is available with ye olde VGA. When it needs to read or write something outwith the range it currently sees, it&#39;ll call the SetBank function (which was patched by SVGAPatch) to ask for that window to be moved. Is this the problem?</p>
<p>Turns out, the bank configuration is stored in a separate structure that isn&#39;t covered by any of the debug commands. I add a quick and dirty command to dump these, and recompile DOSBox yet again.</p>
<pre><code>        else if (command == &#34;SVGA&#34;) {
            DEBUG_ShowMsg(&#34;VGA SVGA data: bankMask=%lu read_full=%lu write_full=%lu read=%u write=%u size=%lu&#34;,
            (unsigned long)vga.svga.bankMask,
            (unsigned long)vga.svga.bank_read_full,
            (unsigned long)vga.svga.bank_write_full,
            vga.svga.bank_read,
            vga.svga.bank_write,
            (unsigned long)vga.svga.bank_size
            );
        }</code></pre>
<p>Sure enough, when I return to full screen mode, the VGA adapter is stuck on the wrong bank!</p>
<h2>Can we fix it? Again??</h2>
<p>I&#39;ve now gotten to the point in writing up this post where I&#39;ve written about all the stuff I&#39;ve done, and I haven&#39;t actually attempted to fix this yet. But you know what... screw it, I may as well try.</p>
<p>We&#39;ve seen <code>dev_to_foreground</code>, which called <code>farsetmode</code>, which jumped to <code>setmode</code>, and fixing <em>that</em> made the GUI work. So, what if I modify <code>dev_to_background</code> to reset the bank to 0 as we&#39;re leaving the GUI?</p>
<p>All we&#39;ve got in that routine right now is a simple <code>mov [enabled_flag], 0</code>. I&#39;ve still got a bunch of free space over next to my silly little kludge... but it&#39;s in the wrong segment. If I want to add a new cross-segment call, I&#39;ll need to mess with the executable structure, and I honestly cannot be bothered.</p>

<p>So I spent a while trying to find something in the first segment that I could hack to shreds. Eventually I settled on the implementation of <code>GetDriverResourceID</code>, which is a function that&#39;s only used for the 120dpi (&#34;Large Fonts&#34;) configuration.</p>
<p>First I need to bring it down to its simplest possible form:</p>
<pre><code>push bp
mov bp, sp
mov ax, [bp+0Ah]
pop bp
retf 6</code></pre>
<p>This now leaves me a bit of space to write a new bank resetting routine, which should force the video adapter back to bank 0:</p>
<pre><code>mov [ds:enabled_flag], 0
xor dx, dx
call set_bank_select
retn</code></pre>
<p>And finally, I jump to it from <code>dev_to_background</code>, so that it&#39;ll be called when I leave the GUI.</p>

<p>So with great trepidation, I try to run it, and... the OS doesn&#39;t crash! But it doesn&#39;t fix the issue, either :(</p>
<p>After a bunch of painstaking <code>printf</code> debugging I find out why... DOSBox implements  <a href="http://www.ctyme.com/intr/rb-0278.htm">VBE operation <code>4F05h</code></a> (to set the &#39;bank&#39;) by writing to the VGA CRTC register 0x6A. I&#39;m doing it from <code>dev_to_background</code>, but that routine is called too late - by that point, we&#39;ve already switched away, and the VDD is trapping our writes.</p>
<p>This doesn&#39;t align with what I see in the Windows DDK&#39;s documentation:</p>
<blockquote>
<p>Interrupt 2Fh Function 4001h</p>
<pre><code>mov ax, 4001h   ; Notify Background Switch
int 2fh</code></pre>
<p>Notify Background Switch notifies a VM application that it is being switched to the background. The VM application can carry out any actions, but should do so within 1000ms. This is the amount of time the system waits before switching the application.</p>
</blockquote>
<p>I have two options:</p>
<ol>
<li>I somehow find a way to trigger this earlier in the switching process
<ul>
<li>Would be nice, but I clearly can&#39;t believe the docs, and I don&#39;t really want to try and disassemble more of Windows.</li>
</ul></li>
<li>I teach the VDD to let me pass these writes through, as Microsoft did for all the SVGA adapters they officially supported
<ul>
<li>This would fix it for DOSBox, but that fix would be tied to whichever video adapter it&#39;s emulating. I don&#39;t want that, I&#39;m trying to make the generic VBE patch work better!</li>
<li>It&#39;s unlikely that my Eee PC&#39;s Intel GMA950 <em>also</em> uses CRTC register 0x6A for banks.</li>
</ul></li>
</ol>
<p>At this point, you know what... I think I&#39;m done. It&#39;s almost midnight and I have to return to my day job tomorrow. (The Java™ cannot wait.)</p>

<p>This was a fun little endeavour, and I&#39;ve gotten surprisingly far, but I don&#39;t want to invest much more time into it - it&#39;s just something I wanted to poke at over the holiday season.</p>

<p>You know how brittle this whole setup is? Just for fun, let&#39;s go back to the <em>original</em> SVGA 256-colour driver from Microsoft, and its list of supported cards... and let&#39;s use 86Box to try out a few.</p>
<table>
<thead>
<tr>
<th>Emulated Card</th>
<th>How it worked at 1024x768, 256 colours</th>
</tr>
</thead>
<tbody>
<tr>
<td>ATI VGA Wonder XL</td>
<td>Failed to start Windows <em>(ok, this might just be too new a variant)</em></td>
</tr>
<tr>
<td>Cirrus Logic GD5420 (ISA)</td>
<td>Works! ✅</td>
</tr>
<tr>
<td>Oak OTI-077</td>
<td>Screen corruption when initially opening a windowed DOS prompt, vertical lines when full-screening one</td>
</tr>
<tr>
<td>Paradise PVGA1A</td>
<td>Failed to start Windows</td>
</tr>
<tr>
<td>Trident TVGA 8900D</td>
<td>Screen corruption when full-screening a DOS prompt, but windowed is ok</td>
</tr>
<tr>
<td>Tseng Labs ET4000AX</td>
<td>Works! ✅</td>
</tr>
<tr>
<td>Video 7 VGA 1024i (HT208)</td>
<td>Only works at 640x480, fails to start at any higher resolution</td>
</tr>
</tbody>
</table>
<p>I should caveat this with the fact that 86Box doesn&#39;t have some of the exact same cards, so that might lead to issues, and I don&#39;t know how accurate the emulation is for all of them. Still, this suggests that even the original support was already kind of dodgy - so I won&#39;t be too sad about not being able to make it perfect myself.</p>

<p>I also picked some of the newer cards in 86Box and tried them with my patched version of the patched driver, to see what would happen --</p>
<p><a rel="lightbox" href="https://wuffs.org/user/pages/02.blog/windows-3x-graphics/dosbox3.png"><img alt="A very corrupted Windows 3.11 desktop in 86Box where the background has turned into pink and black stripes, and lots of pixels have been mashed together. You can kinda recognise the shape of Program Manager, but none of the text or icons are actually discernible." src="https://wuffs.org/user/pages/02.blog/windows-3x-graphics/dosbox3.png"/></a></p>
<table>
<thead>
<tr>
<th>Emulated Card</th>
<th>How it worked at 1024x768, 256 colours</th>
</tr>
</thead>
<tbody>
<tr>
<td>Matrox Millennium II</td>
<td>Unbearably laggy. Windowed DOS prompts work, full-screen is broken.</td>
</tr>
<tr>
<td>3dfx Voodoo Banshee</td>
<td>Opening a windowed DOS prompt corrupts the GUI, but switching <em>to</em> and <em>from</em> full-screen works perfectly.</td>
</tr>
<tr>
<td>S3 Trio3D/2X (362)</td>
<td>Beautiful glitch art when Windows first launches (as seen above!), but if you open a DOS prompt and then switch <em>out</em> of full-screen, you get perfect 1024x768. Oh, and full-screen is broken.</td>
</tr>
<tr>
<td>3dfx Voodoo3 3500 SI</td>
<td>Same as the Banshee, but full-screen only works once and then it just breaks on any subsequent Alt+Enters.</td>
</tr>
</tbody>
</table>

<p>Last but not least... I&#39;m sure you&#39;re dying to know, how far did I get with the Eee PC after all this faffery? The GUI works fine. Switching to a full-screen DOS prompt breaks, but in an interestingly different way to DOSBox. While on DOSBox I get text mode with lots of corrupted characters, on the Eee PC I get a broken version of the GUI where some of the colours have disappeared.</p>
<p><a rel="lightbox" href="https://wuffs.org/user/pages/02.blog/windows-3x-graphics/solitaire.jpg"><img alt="Picture of Windows on the Eee PC, with Program Manager and Solitaire open. All the Solitaire cards have turned white and many of the colours on the screen have become white or grey (but the Solitaire green background remains). The top fifth of the screen has vertical lines running across it." src="https://wuffs.org/user/pages/02.blog/windows-3x-graphics/solitaire.jpg"/></a></p>
<p>However, the saving grace is that you can just switch to windowed mode again and it recovers OK.</p>

<p>If you think that looks cool, then here&#39;s a fun one I got when I was messing around with the text mode blue screen that you get when you press Ctrl+Alt+Del - somehow I got it to corrupt the VM&#39;s video memory, and the results stuck around enough to get rendered at glorious 1024x600 by the Grabber.</p>
<p><a rel="lightbox" href="https://wuffs.org/user/pages/02.blog/windows-3x-graphics/glitch_art.jpg"><img alt="Closeup of a MS-DOS prompt on the Eee PC, which is rendering some wacky corrupted data as if it were a real prompt. There are five expanses of colourful horizontal stripes, interspersed with 5-cell-wide columns made out of random characters and symbols." src="https://wuffs.org/user/pages/02.blog/windows-3x-graphics/glitch_art.jpg"/></a></p>
<p>And you know what - glitch art aside... my updated driver may not be <em>perfect</em>, but it&#39;s already a huge improvement over the original SVGAPatch, where simply opening a prompt (even in a window) would break the entire GUI and require me to restart the OS. I&#39;ll take that W. </p>
<p>For anything better than that, I&#39;ll continue to keep an eye on <a href="https://github.com/PluMGMK/vbesvga.drv">PluMGMK/vbesvga.drv</a>, which is being actively developed and written by someone that actually knows what they&#39;re doing when it comes to 16-bit PC dev and video hardware.</p>
<hr/>
<p>I hope you enjoyed this adventure :3 I had fun, but I&#39;m definitely ready to move onto something else now. Maybe I&#39;ll even write the post I originally planned on writing, about how to set up Windows 3.x and 9x on the Eee PC. <em>Maybe.</em></p>
<p>If you liked it, you can subscribe to this blog for more infrequent tech nonsense, or follow me on your favourite microblogging platform (though I don&#39;t actually toot/skeet/<del>tweet</del> about tech all that much).</p>

<hr/>
<p>
		<b>Previous Post:</b> <a href="https://wuffs.org/blog/free-software-needs-to-be-customisable">Free Software that you can&#39;t customise is not truly Free Software</a>
	<br/>
	
	</p>
    </section>


</div></div>
  </body>
</html>
