<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/Articles/1036912/">Original</a>
    <h1>Comparing Rust to Carbon</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>
Safe, ergonomic interoperability between Rust and <span>C/C++</span> was a popular topic at
<a href="https://rustconf.com/">
RustConf 2025</a> in Seattle, Washington. Chandler Carruth gave a presentation
about the different approaches to interoperability in Rust and
<a href="https://docs.carbon-lang.dev/">
Carbon</a>, the
experimental &#34;<span>(C++)++</span>&#34; language.
His ultimate conclusion was that
while Rust&#39;s ability to interface with other languages is expanding over time,
it wouldn&#39;t offer a complete solution to C++ interoperability anytime soon — and so there is room for
Carbon to take a different approach to incrementally upgrading existing C++ projects.
His
<a href="https://chandlerc.blog/slides/2025-rustconf-memory-safety-everywhere/#/">
slides</a> are available for readers wishing to study his example code in more
detail.
</p>

<p>
Many of the audience members seemed aware of Carbon, and so Carruth spent
relatively little time explaining the motivation for the language. In short,
Carbon is a project to create an alternative front-end for C++ that cuts out
some of the language&#39;s more obscure syntax and enables better annotations for
compiler-checked memory safety. Carbon is intended to be completely compatible
with C++, so that existing C++ projects can be rewritten into Carbon on a
file-by-file basis, ideally without changing the compiler or build system at
all. Carbon is not yet usable — the contributors to the project are working on
fleshing out some of the more complex details of the language, for reasons that
Carruth&#39;s talk made clear.
</p>

<p><a href="https://lwn.net/Articles/1037332">
<img src="https://static.lwn.net/images/2025/chandler-carruth-rustconf-small.png" alt="[Chandler Carruth]" title="Chandler Carruth"/>
</a></p><p>
&#34;<q>It&#39;s always a little exciting to talk about a non-Rust programming language
at RustConf,</q>&#34; Carruth began, to general laughter. He has worked in C++ for
many years, and has been working on Carbon since the project started in 2020.
Currently, he is paid for his work on Carbon as part of Google&#39;s languages and
compilers team.
He briefly showed some research from Google indicating that the
majority of the security vulnerabilities it deals with could have been
prevented by memory-safe languages, but he didn&#39;t spend too long on it because
he expected the audience of RustConf to be well-aware of the benefits of memory
safety.
</p>

<p>
The thing is, there is a lot of existing software in the world written in C and
<span>C++</span>. There is no magic wand to make that software go away. Migrating any of it
to memory-safe languages will require those languages to integrate
with the rest of the existing software ecosystem, he said. Interoperability is
not just nice to have — it&#39;s a key part of what makes adopting memory-safe
languages work.
</p>

<p>
Rust already has several tools to make interoperating with <span>C/C++</span> code feasible.
Carruth listed Rust&#39;s native foreign-function interface,
<a href="https://github.com/rust-lang/rust-bindgen?tab=readme-ov-file#bindgen">
bindgen</a> and
<a href="https://github.com/mozilla/cbindgen?tab=readme-ov-file#cbindgen-----">
cbindgen</a>, the
<a href="https://docs.rs/cxx/latest/cxx/">
cxx crate</a>,
and Google&#39;s own
<a href="https://github.com/google/crubit?tab=readme-ov-file#crubit-crust-bidirectional-interop-tool">
Crubit</a>. But he claimed that none of these are really good solutions for
existing C++ software. He defined software as existing on a
spectrum between &#34;greenfield&#34; (new code, not tightly coupled to <span>C++</span>, with strong
abstraction boundaries) and &#34;brownfield&#34; (tightly coupled to existing <span>C++</span>, with
a large API surface). Greenfield software is relatively easy to port to Rust —
it can be moved one module at a time, using existing binding tools. Brownfield
software is a lot harder, because it can&#39;t be easily decomposed, and so the
interface between code written in <span>C++</span> and code written in Rust has to be a lot
more complex and bidirectional.
</p>

<p>
The question, Carruth said, is can Rust ever close the gap? He doesn&#39;t think so
— or, at least, not soon and not without a monumental effort. But Rust is not
the only approach to memory safety. Ideally, existing <span>C++</span> code could be made
memory-safe in place. Lots of people have tried that, but &#34;<q>the <span>C++</span> committee
is probably not going to do it</q>&#34;. There&#39;s no way to successfully add memory
safety to <span>C++</span> as it is, he said.
</p>

<!-- middle-ad -->

<p>
There are several languages that have managed a transition away from a base
language into a more capable, flexible successor language, though:
<a href="https://www.typescriptlang.org/">
TypeScript</a>
is an evolution of JavaScript,
<a href="https://www.swift.org/">
Swift</a> is an evolution of Objective-C,
and <span>C++</span> itself is an evolution of C. Carruth
thinks that Carbon could be a similar evolution of
<span>C++</span> — a path to incremental
migration toward a memory-safe language, prioritizing
the most entrenched brownfield software. Rust is coming at the
problem of memory safety from the greenfield direction, he said, and Carbon is
coming at it from the other side. That makes Rust and Carbon quite different
languages.
</p>

<h4>A closer look</h4>

<p>
The real focus of his talk was on showing where those differences are, and where
he thinks each language can learn from the other. The syntaxes of Rust and Carbon are
&#34;<q>not wildly different</q>&#34;; the differences he wanted to focus on were more
abstract. For example, in Rust, a compilation unit is an entire crate,
potentially composed of several modules. Therefore, it&#39;s allowed for
modules to reference each other in a cyclic way, and that just works.
That isn&#39;t something Carbon can
support because &#34;<q>existing <span>C++</span> code is often oddly dependent</q>&#34; on the ability to
compile individual files separately. So, Carbon inherits <span>C++</span>&#39;s model, complete
with forward declarations, (optional) separate header files, and more complexity
in the linker. This makes Carbon&#39;s model more complex, but that complexity
doesn&#39;t come from nowhere — &#34;<q>it comes from <span>C++</span></q>&#34;.
</p>

<p>
Another example is the difference between traits and classes. Rust traits and
Carbon classes are not that different, syntactically — Carbon just writes
methods inside the struct definition, while Rust writes them separately — but
they have major conceptual differences. Carbon has to handle inheritance,
virtual functions, protected fields, and so on. &#34;<q>This stuff is complexity
that Rust just doesn&#39;t have and doesn&#39;t have to deal with.</q>&#34; Carbon wants to
meet <span>C++</span> APIs where they are, he said.
One can even inherit across the
<span>C++</span>/Carbon boundary.
</p>

<p>
This sort of difference is pervasive, he said, and comes up in all parts of the
language. Operator overloading, generics, and type conversions are all more
complex in Carbon. Why do it this way? Why is all of this additional complexity
worth it? To explain, he showed an example of a hypothetical but not unusual
<span>C++</span>
API:
</p>

<pre>    int EVP_AEAD_CTX_seal_scatter(
	    const EVP_AEAD_CTX *ctx,
	    std::span&lt;uint8_t&gt; out,
	    std::span&lt;uint8_t&gt; out_tag,
	    size_t *out_tag_len,
	    std::span&lt;const uint8_t&gt; nonce,
	    std::span&lt;const uint8_t&gt; in,
	    std::span&lt;const uint8_t&gt; extra_in,
	    std::span&lt;const uint8_t&gt; ad);
</pre>

<p>
The example was adapted from a real function in the
<a href="https://boringssl.googlesource.com/boringssl">
BoringSSL</a> cryptography
library. Each <tt>std::span</tt> is a combination of a pointer and a length.
The main problem with faithfully representing it in Rust is actually
not visible in the code itself; the documentation for this function
explains that <tt>out</tt> must either be the same pointer as <tt>in</tt>, or a
completely non-overlapping piece of memory. When the pointers are the same, the
function encrypts a given plaintext input buffer in place. Otherwise, the
encrypted output is written to the output buffer without disturbing the input
buffer. None of the other pointers are
supposed to alias.
</p>

<p>
Carbon is still a work in progress, but the current plan for expressing APIs
like this in a machine-checkable way is to use &#34;alias sets&#34;. These would be
annotations showing which pointers are permitted to alias each other, and which
ones aren&#39;t. The resulting Carbon code might look like this:
</p>

<pre>	fn EVP_AEAD_CTX_seal_scatter[^inout](
	    ctx: const EVP_AEAD_CTX ^*,
	    out: slice(u8 ^inout),
	    out_tag: slice(u8 ^),
	    out_tag_len: u64 ^*,
	    nonce: slice(const u8 ^),
	    input: slice(const u8 ^inout),
	    extra_input: slice(const u8 ^),
	    ad: slice(const u8 ^)) -&gt; i32;
</pre>

<p>
Here <tt>inout</tt> is a name given to a particular alias set, and used to
annotate <tt>out</tt> and <tt>input</tt>. All of the other pointers in the function
signature don&#39;t have an alias set specified, so the compiler would ensure they
can&#39;t alias.
</p>

<p>
Trying to represent this API in Rust just doesn&#39;t work. The language never lets
mutable references alias each other, so you end up having to have two separate
wrapper functions with different signatures for the in-place case and the
copying case. Rewriting the module that contains this function in Rust would
become a complex process, intermingling the simple translation of the actual
code with the refactoring of the interface.
</p>

<p>
The power of Carbon for interoperability, Carruth said, is that it lets you
decouple these things and do them as small, separate steps. He showed another
example of a <span>C++</span> program that was actually memory-safe, but that wasn&#39;t
compatible with Rust&#39;s lifetime analysis. No computerized analysis of memory
safety
<a href="https://en.wikipedia.org/wiki/Rice%27s_theorem">
can ever be perfect</a>, so Carbon presumably won&#39;t be able
to do much better here — but in Carbon, patterns that the compiler cannot prove
to be memory safe can be turned into a warning
instead of an error.
</p>

<p>
This focus on meeting <span>C++</span> where it is
 makes Carbon a different language.
It ends up being specially tailored to interoperability and gradual migration,
which isn&#39;t free. This makes the language more complex than it could be otherwise,
and Carruth doesn&#39;t think that&#39;s the right tradeoff for every language. But if
the goal is to have memory-safe software throughout the software ecosystem, he
thinks that there needs to be room for Rust and Carbon both. This isn&#39;t a
competition between languages; it&#39;s two different languages working together to
cover the widely divergent needs of different projects.
</p></div></div>
  </body>
</html>
