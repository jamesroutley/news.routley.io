<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mitchellh.com/writing/libghostty-is-coming">Original</a>
    <h1>Libghostty is coming</h1>
    
    <div id="readability-page-1" class="page"><div><p>Over two years ago, in <a href="https://mitchellh.com/writing/ghostty-and-useful-zig-patterns">one of my first public talks about Ghostty</a>,
I shared my vision for <code>libghostty</code>: an embeddable library for any application
to embed their own fully functional, modern, and fast terminal emulator.
Libghostty is finally starting to take shape, and I&#39;m excited to share
more details about my plans for it.</p>
<p>The first libghostty library will be <code>libghostty-vt</code>: a zero-dependency
library that provides an API for parsing terminal sequences and
maintaining terminal state, extracted directly from Ghostty&#39;s real-world proven
core. It doesn&#39;t even require libc!</p>
<div><p><strong>Disclaimer</strong>: This post is predominantly a roadmap update for libghostty and announcing what
will be the first shippable component of it. The Zig API is available for testing now, but the C
API is not ready and will be coming very shortly. In both cases, it is early testing quality and
not ready for general usage.</p></div>
<hr/>
<h2 id="why-libghostty"><a href="#why-libghostty" aria-hidden="true" tabindex="-1"><span></span></a>Why libghostty?</h2>
<p>Let&#39;s start with some background on why I believe libghostty must exist.</p>
<p>There are hundreds of programs that implement some form of terminal emulation.
The most obvious are the actual general purpose terminal emulators like
Ghostty, Kitty, iTerm2, etc. But terminal multiplexers like
<a target="_blank" rel="noopener noreferrer" href="https://github.com/tmux/tmux">tmux</a> or <a target="_blank" rel="noopener noreferrer" href="https://zellij.dev/">zellij</a> are
also full terminal emulators!<sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref="true" aria-describedby="footnote-label">1</a></sup> Editors embed their own terminal
emulators too, such as <a target="_blank" rel="noopener noreferrer" href="https://github.com/JetBrains/jediterm">jediterm</a> for
JetBrains products, <a target="_blank" rel="noopener noreferrer" href="https://xtermjs.org/">Xterm.js</a> for VS Code,
or <a target="_blank" rel="noopener noreferrer" href="https://github.com/zed-industries/zed/blob/a0514af58955a21401b4c10918a45c9c241a4a74/Cargo.toml#L444">Alacritty</a>
in Zed.</p>
<p>In addition to fully functional terminal emulators, many websites and applications
implement read-only terminal emulation to display logs or command output.
For example, <a target="_blank" rel="noopener noreferrer" href="https://github.blog/news-insights/product-news/a-better-logs-experience-with-github-actions/#opening-the-door-to-a-more-colorful-experience">GitHub Actions output</a>
parses simple color sequences (but not much else). And hosting providers
like Vercel or Render implement a simple form of terminal emulation
allowing line clearing and redrawing within build logs as well as
parsing colors.</p>
<p>Many of these implementations are ad-hoc, one-off solutions. They aren&#39;t
using any shared library or codebase.<sup><a href="#user-content-fn-2" id="user-content-fnref-2" data-footnote-ref="true" aria-describedby="footnote-label">2</a></sup> Terminal emulation is a classic
problem that appears simple on the surface but is riddled with unexpected
complexities and edge cases.<sup><a href="#user-content-fn-3" id="user-content-fnref-3" data-footnote-ref="true" aria-describedby="footnote-label">3</a></sup> As a result, most of these implementations
are incomplete, buggy, and slow.<sup><a href="#user-content-fn-4" id="user-content-fnref-4" data-footnote-ref="true" aria-describedby="footnote-label">4</a></sup></p>
<p>Beyond correctness, implementing any form of terminal emulation is a
<em>waste of time</em> for most developers. Terminal emulation is not the core
business of JetBrains, Visual Studio Code, GitHub, Vercel, Render, etc.
It&#39;d benefit them if they could have a stable, reusable solution
that&#39;s consistent everywhere.</p>
<p>My answer to this is libghostty: a cross-platform, minimal dependency
library that exposes a C API so feature-rich, correct, and fast terminal
functionality can be embedded by any application anywhere.</p>
<hr/>
<h2 id="the-beginning-libghostty-vt"><a href="#the-beginning-libghostty-vt" aria-hidden="true" tabindex="-1"><span></span></a>The Beginning: <code>libghostty-vt</code></h2>
<p>The first libghostty library will be <code>libghostty-vt</code>: a zero-dependency
(not even libc) library that provides an API for parsing terminal sequences
and maintaining terminal state such as cursor position, current styles,
text wrapping, and more.</p>
<p>Parsing terminal sequences is the most core functionality of a terminal
emulator, and is required by full terminal emulators like Ghostty down to
simple read-only style-only views such as GitHub Actions or Vercel build output.</p>
<p>The <a target="_blank" rel="noopener noreferrer" href="https://vt100.net/emu/dec_ansi_parser">state diagram</a> might
appear relatively simple at first glance, but an implementation
is unexpectedly challenging to get right. For example,
<a target="_blank" rel="noopener noreferrer" href="https://github.com/JetBrains/jediterm/pull/311">Jediterm doesn&#39;t handle intermediates correctly</a>,
causing the widely supported &#34;change cursor shape&#34; sequence to swallow
a character in every JetBrains editor at the time of this post.</p>
<p>For style-only parsing, many developers skip the full state diagram. Instead,
they do some light web searching, parse simple
ANSI sequences such as <code>\e[31</code> or <code>\e[41m</code>, and claim &#34;color support.&#34;
But style-only sequences are vastly more complex than that, for example they
support RGB which itself can be in <a target="_blank" rel="noopener noreferrer" href="https://github.com/ghostty-org/ghostty/blob/8cb52323e5575877eef44029c153eda006cece80/src/terminal/color.zig#L400-L438">a dozen formats</a>.
And I still haven&#39;t found a single web console that renders
<a target="_blank" rel="noopener noreferrer" href="https://github.com/ghostty-org/ghostty/blob/8cb52323e5575877eef44029c153eda006cece80/src/terminal/Parser.zig#L672-L722">this complex style sequence</a>
correctly.<sup><a href="#user-content-fn-5" id="user-content-fnref-5" data-footnote-ref="true" aria-describedby="footnote-label">5</a></sup></p>
<p><code>libghostty-vt</code> aims to fix all of this.</p>
<p><code>libghostty-vt</code> is extracted from Ghostty and inherits all of the real world
benefits: SIMD-optimized parsing, very good Unicode support, highly optimized
memory usage, a robust fuzzed and Valgrind-tested codebase, excellent feature
compatibility such as parsing Kitty Graphics Protocol or Tmux Control Mode, and more.</p>
<p>All of this is packaged up into a single zero-dependency C API (it doesn&#39;t
even rely on libc), allowing it to be easily embedded into any popular
language ecosystem.</p>
<p>Given the minimal footprint, <code>libghostty-vt</code> will be <strong>widely portable.</strong>
Initial targets will be macOS and Linux for both <code>x86_64</code> and <code>aarch64</code>
architectures, since those are the primary targets for Ghostty the
application. But I plan to expand support to additional targets such as Windows,
embedded devices, and the web via WASM. <code>libghostty</code> will have broader
support than Ghostty the GUI, due to its tighter scope.</p>
<hr/>
<h2 id="the-long-term"><a href="#the-long-term" aria-hidden="true" tabindex="-1"><span></span></a>The Long Term</h2>
<p><code>libghostty-vt</code> is just the beginning. Longer term, we will provide more
<code>libghostty-&lt;x&gt;</code> libs that expose additional functionality such as input
handling (keyboard encoding is a big one), GPU rendering (provide us with
an OpenGL or Metal surface and we&#39;ll take care of the rest), GTK widgets
and Swift frameworks that handle the entire terminal view, and more.</p>
<p>As fundamental pieces stabilize, we will continue to offer more and more
functionality. These will be structured as a family of libraries to minimize
dependency requirements, code size, and overall maintenance complexity.</p>
<hr/>
<h2 id="libghostty-vt-status"><a href="#libghostty-vt-status" aria-hidden="true" tabindex="-1"><span></span></a><code>libghostty-vt</code> Status</h2>
<p>I just merged the pull request
<a target="_blank" rel="noopener noreferrer" href="https://github.com/ghostty-org/ghostty/pull/8840">exposing <code>libghostty-vt</code> as a Zig module</a>.
This PR includes a minimal example program, too. If you&#39;re a Zig developer,
you can start experimenting with <code>libghostty-vt</code> immediately.</p>
<p>The C API isn&#39;t ready yet, but it is what I&#39;m working on <em>right now</em> and
it&#39;ll be available for testing soon. All of the work required is defining the
C API, since the core logic is of course all there and has been used by Ghostty
for years. Plus, the Ghostty macOS app already consumes an
<a target="_blank" rel="noopener noreferrer" href="https://github.com/ghostty-org/ghostty/blob/main/include/ghostty.h">internal-only C API</a>.</p>
<div><p>If you look at the internal-only C header, please ignore the mess. It isn&#39;t a <em>good</em> C API. It is
internal-only and exists to satisfy the needs of the macOS application. This isn&#39;t a generally
consumable libghostty, although it is used by <a target="_blank" rel="noopener noreferrer" href="https://orbstack.dev/">real commercial products
already</a> to embed Ghostty. We&#39;ll take a clean slate approach defining the C
API for wider usage.</p></div>
<p>I plan to version <code>libghostty</code> separately from Ghostty the application.
This blog post marks the public alpha (not promising API stability)
and I&#39;m hoping to motivate some developers to come use it and eventually
write some language bindings once the C API is ready.</p>
<p>I hope to ship a tagged version of <code>libghostty-vt</code> within the next 6 months,
but it&#39;ll all depend on if its ready or not.</p>
<hr/>
<h2 id="looking-for-feedback"><a href="#looking-for-feedback" aria-hidden="true" tabindex="-1"><span></span></a>Looking for Feedback</h2>
<p>We&#39;re at the critical stage of libghostty where we&#39;re designing the API,
and the best way to design an API is with feedback from real consumers.
Ghostty is one consumer, we have some community members working on other
libghostty-consuming projects, but we could use as many as we can get!</p>
<p>If you see a use case in your projects or organization for libghostty,
please <a target="_blank" rel="noopener noreferrer" href="https://discord.gg/ghostty">join the Ghostty Discord</a> and collaborate
with the developers working on this. If you don&#39;t want to join Discord,
email me (email in the footer of this website).</p>
<p>The state of <code>libghostty</code> at this stage could be considered <em>alpha</em>,
so don&#39;t expect a polished, stable experience. We&#39;re looking for hackers
that want to get on the ground early.</p>
<div><p>The &#34;alpha&#34; quality is with respect to the API (functions and types) itself. The core logic is
shared with Ghostty and is extremely stable and proven in the real world.</p></div>
<hr/>
<h2 id="the-next-frontier"><a href="#the-next-frontier" aria-hidden="true" tabindex="-1"><span></span></a>The Next Frontier</h2>
<p>I&#39;m super excited that Ghostty the application has finally reached the
stability where we can start moving towards the <code>libghostty</code> goal.
<code>libghostty</code> is the next frontier for Ghostty and I think it has the
ability to make a far larger impact than Ghostty can as a standalone
application itself.</p>
<p>Don&#39;t worry, there&#39;s plenty of changes for Ghostty the application
and none of this diminishes my excitement or plans for that. Wider
usage of <code>libghostty</code> will result in a more feature rich and stable
Ghostty application, too, since Ghostty itself is a consumer of
<code>libghostty</code>.</p>
<p>Boo. 👻</p>
</div></div>
  </body>
</html>
