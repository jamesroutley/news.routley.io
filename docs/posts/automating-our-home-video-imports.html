<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pierce.dev/notes/automating-our-home-video-imports">Original</a>
    <h1>Automating our home video imports</h1>
    
    <div id="readability-page-1" class="page"><div><p>My mom called me up last week and told me they were going to digitize all our old home videos. Great idea, I told her. Tapes degrade over time and we have a much more <a href="https://pierce.dev/notes/my-personal-backup-strategy/">robust way</a> to backup our digital copies versus physical ones. Plus it was certain to deliver a nice dose of nostalgia before the holidays.</p>
<p>&#34;How much will it cost?&#34; <em>(me thinking somewhere in the ballpark of $750)</em></p>
<p>&#34;Oh they&#39;re having a promo right now - they can do it for around $4000&#34;</p>
<p>$4k! In this economy?<sup><a href="#user-content-fn-2" id="user-content-fnref-2" data-footnote-ref="true" aria-describedby="footnote-label">1</a></sup> No way.</p>
<h2 id="weve-been-down-this-road-before">We&#39;ve been down this road before</h2>
<p>I remember spending a few weekends in high school going through our old tapes, connecting them to my white plastic Macbook and importing them via firewire. I put them on Vimeo and shared the login keys with some extended family that wanted to watch. Pretty janky but they were happy for any quality of memories that were otherwise already forgotten.</p>
<p>But the project never really felt done. Questions lingered in the years since:</p>
<ol>
<li>Did I really archive at the highest quality possible, to the point that I would feel comfortable throwing out the physical tapes.<sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref="true" aria-describedby="footnote-label">2</a></sup> Ideally we should do the closest thing to copying raw bits as possible.</li>
<li>Did I really import everything? Is there a way to sanity check that? Minimally we should have some robust tagging where if we find a new tape in the future we can easily check if it&#39;s already been archived.</li>
<li>The outputs have always been a single long video file. Is it possible to auto-chunk and organize them into the dates where they were actually recorded? Some of these tapes stretched years, which makes random access much more difficult.</li>
</ol>
<h2 id="formats-beautiful-formats">Formats beautiful formats</h2>
<p>We have a host of content from when I was growing up but the bulk is in four main formats: Data CDs+DVDs<sup><a href="#user-content-fn-3" id="user-content-fnref-3" data-footnote-ref="true" aria-describedby="footnote-label">3</a></sup>, Video DVDs, MiniDV tapes, and Hi8 tapes. There&#39;s a longtail of Blueray disks, VHS tapes, and audio tapes. I&#39;m less worried about the latter because the volume is low enough where it becomes feasible to send them to a third party.</p>
<p>Reading our discs is as straightforward as it&#39;s always been.<sup><a href="#user-content-fn-5" id="user-content-fnref-5" data-footnote-ref="true" aria-describedby="footnote-label">4</a></sup> All of the old external CD drives still work with modern operating systems so our only decision is parallelism. We&#39;ll have to buy the same number of external DVD readers as we want to import at the same time. I opted for just one for now.</p>
<p>MiniDV and Hi8 are both cassette tapes, so I was under the initial impression that they were <em>technically</em> the same thing as well<sup><a href="#user-content-fn-4" id="user-content-fnref-4" data-footnote-ref="true" aria-describedby="footnote-label">5</a></sup>. But the image writing techniques couldn&#39;t be more different. MiniDV is a full digital data stream that is written by the tape head as magnetized bites. Hi8 is older and relied on writing analog electrical waveforms to represent the brightness and color of the image. Because digital bytes relied on an encoding protocol it&#39;s also possible to apply <a href="https://en.wikipedia.org/wiki/Error_correction_code" data-snapshot-id="801f5b8351b3673483fdc070de328645" data-snapshot-url="https://en.wikipedia.org/wiki/Error_correction_code" data-snapshot-date="2025-11-05T04:51:50.621Z">error correcting codes</a> to the stream; Hi8 tapes have no such luxury. It&#39;s the effective difference of writing a record versus writing a CD - your ability to play records is more contingent on the hardware sensitivity of your playback machine but even the cheapest CD reader is playing the bytes exactly as they were written in the first place.</p>
<p>The two ways of getting video off these tapes are composite capture and dvlink.</p>
<p>Composite capture relies on the same protocol that lets you connect your camcorder to your TV. They look like USB dongles that connect to the red, yellow, and white analog connectors. Internally they have a video converter that combines those RYW streams into one cohesive picture. If you want to increase the captured quality you can also hook S-Video. It works by separating the luminance (Y) and chrominance (C) signals into two distinct lines instead of combining them into one composite signal, which reduces color bleeding and cross-talk between the brightness and color information.<sup><a href="#user-content-fn-13" id="user-content-fnref-13" data-footnote-ref="true" aria-describedby="footnote-label">6</a></sup> By the time the bytes have reached your computer they&#39;re already encoded in MPEG-2 or H.264, depending on what your specific capture device supports; the analog-to-digital conversion and compression happens entirely within the dongle itself. Composite capture is the most universal since it works with basically any camcorder and you only need to buy one USB adapter, which itself is compatible with a pretty wide amount of software and is almost guaranteed to be future compatible.</p>
<p>dvlink on the other hand is like microFirewire. It was an Apple originated protocol that really caught on within the professional studio ecosystem, since it allowed for higher transfer speeds than other import pipelines. dvlink works by literally reading the byte stream from the tape head and transferring that to your computer. Your camcorder needs to know the dvlink protocol, and your computer needs to know Firewire, to be able to re-encode those bytes into a video container format. But assuming you have the requisite hardware, this is the most lossless way of getting the data from the tape to your software.</p>
<h2 id="lossless-quality">Lossless quality</h2>
<p>I know this is going to take a couple of weeks. That&#39;s a hit I&#39;m willing to take. But I would really rather not do that a second time. So my plan is to archive these tapes as lossless and as close to their original format as possible.</p>
<p>You will <em>literally</em> get the bytes off the tape in the miniDV case. Lossless indeed. In the Hi8 case you&#39;ll be getting a dv feed converted from the analog input. Because camcorder tapeheads are surprisingly high quality<sup><a href="#user-content-fn-11" id="user-content-fnref-11" data-footnote-ref="true" aria-describedby="footnote-label">7</a></sup> this is one of the more accurate analog to dv conversions you can make. This is what it&#39;s actually doing internally:</p>
<ol>
<li>Reading the analog FM signal from tape (Y/C + audio)</li>
<li>Digitizing it internally using an analog-to-digital converter (ADC)</li>
<li>Encoding it in real-time into the DV25 codec (25 Mb/s for MiniDV)</li>
<li>Streaming that compressed digital data over Firewire</li>
</ol>
<p>If you have a Hi8 camera and are following along, make sure you set it explicitly to output DV Out. This was buried in my Sony under <code>Menu &gt; Av/DV Out</code> which was disabled by default. Without it I could see the video stream but couldn&#39;t control its actions from my Mac.</p>
<p>My goal formats for each input:</p>
<ul>
<li>CD/DVDs -&gt; mountable iso (1:1 byte copy)</li>
<li>Tapes -&gt; byte stream from firewire (.dv format)</li>
</ul>
<p>After the files are imported in their raw formats, I can kick off a handbreak or ffmpeg job to convert them to near archival quality in mkv. This gives me a much smaller file size that&#39;s indexable by my media server. But I still plan to keep the originals on my NAS to always be able to re-convert the files if a better transcoding technique comes our way. Eyeballing the number of tapes in the pile should come out to ~1TB of storage overhead for the raw files.</p>
<h2 id="dvrescue">dvrescue</h2>
<p><a href="https://github.com/mipops/dvrescue" data-snapshot-id="bfe65adc755f158328dfe93326762b5b" data-snapshot-url="https://github.com/mipops/dvrescue" data-snapshot-date="2025-11-05T04:51:49.125Z">dvrescue</a> is a utility designed to record dv byte streams from the camera exactly as they are read from the tape. As you might assume from the name it also has support for attempting to recover corrupted frames from the camcorder.<sup><a href="#user-content-fn-6" id="user-content-fnref-6" data-footnote-ref="true" aria-describedby="footnote-label">8</a></sup> It also supports writing commands to the dv protocol, which allows you to remotely control your camcorder from your computer. I always found it pretty magical when iMovie could control a video camera that you connected; this was how they made it happen.</p>
<p>For the most part the utility works great. There were a few issues that I discovered when doing some initial testing.</p>
<ol>
<li>
<p>Issuing a <code>play</code> command from the server would play the video but no audio. Behind the scenes, dvrescue was sending a seek speed=1.0 to the camera. So the tape was rolling at the normal speed and we could see the frames, but this was effectively like seeking 2x during a fastforward where the camcorder reasonably doesn&#39;t want to render chipmunk audio. I switched this by updating <code>VCR_OPE_PLAY_FORWARD</code> from 0x38 → 0x75, which is the actual dvlink command for playing the video. With this it captures both video and audio with one command.</p>
</li>
<li>
<p>Write periodically to disk. By default it buffers all of the dv contents in a user space tmp file, which is okay for most normal capture situations. But in my case I also wanted to pipe the latest frame captured in the dv into a utility to monitor the ripping jobs. So I added a <code>--flush</code> command that lets you specify the megabyte interval that should be periodically flushed.</p>
</li>
<li>
<p>Sometimes the <code>--capture</code> command fails early, within a minute of the recording. This leaves the camcorder playing its footage but the dv file would only have a few mb written to disk. I solved this by having a control loop monitor the capture for completion. Any time it&#39;s done, we analyze the duration of the dv file - if less than 5mins, it automatically rewinds to the beginning and starts to capture again.</p>
</li>
</ol>
<p>Fixes for (1) and (2) are in my <a href="https://github.com/piercefreeman/dvrescue">fork</a>. (3) is in my control utility.</p>
<h2 id="the-pipeline">The Pipeline</h2>
<p><span><span><span><img alt="Screenshot of the autoimport control panel" loading="lazy" width="1200" height="800" decoding="async" data-nimg="1" sizes="(max-width: 768px) 100vw, (max-width: 1200px) 80vw, 1200px" srcset="/notes-images/automating_videos/nextImageExportOptimizer/control_panel-opt-640.WEBP 640w, /notes-images/automating_videos/nextImageExportOptimizer/control_panel-opt-750.WEBP 750w, /notes-images/automating_videos/nextImageExportOptimizer/control_panel-opt-828.WEBP 828w, /notes-images/automating_videos/nextImageExportOptimizer/control_panel-opt-1080.WEBP 1080w, /notes-images/automating_videos/nextImageExportOptimizer/control_panel-opt-1200.WEBP 1200w, /notes-images/automating_videos/nextImageExportOptimizer/control_panel-opt-1920.WEBP 1920w, /notes-images/automating_videos/nextImageExportOptimizer/control_panel-opt-2048.WEBP 2048w, /notes-images/automating_videos/nextImageExportOptimizer/control_panel-opt-3840.WEBP 3840w" src="https://pierce.dev/notes-images/automating_videos/nextImageExportOptimizer/control_panel-opt-3840.WEBP"/></span></span></span></p>
<p>There were too many of these tapes to not have some meaningful automation. I iteratively built up a few utilities with the basic conceit that we need to physically change over the tapes when done. The rest of our pipeline should be fully handled by a supervisor. This program handles consistent filesystem structure, error detection, transcoding, clipping, labeling, and notification upon the completion of each tape.</p>
<p>I originally built a small CLI to help me with some of the importing, but it ended up being more convenient to build the frontend as a webapp instead of a TUI. TUIs still don&#39;t have support for image capture or particularly good OS-level notification support; Chrome has both.</p>
<pre><code>$ uv run autoarchive-web-serve --destination /Volumes/FamilyPhotos/Videos

Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
</code></pre>
<p>The bulk of our logic is handed via asyncio commands sent to the shell to read from OS level utilities. Depending on the output of these commands, we either parse the stdout for regex matches or parse the outputs directly as json.<sup><a href="#user-content-fn-12" id="user-content-fnref-12" data-footnote-ref="true" aria-describedby="footnote-label">9</a></sup> Some of these commands:</p>
<p><strong>Device Discovery:</strong></p>
<ul>
<li><code>system_profiler SPFireWireDataType -json</code> - Poll for connected camcorders</li>
<li><code>diskutil list -plist</code> - Enumerate optical drives</li>
<li><code>diskutil info -plist &lt;device&gt;</code> - Get detailed disk metadata</li>
</ul>
<p><strong>Tape Control:</strong></p>
<ul>
<li><code>dvrescue device://&lt;guid&gt; --status</code> - Check if tape is present</li>
<li><code>dvrescue device://&lt;guid&gt; --cmd rew --foreground</code> - Rewind to beginning</li>
<li><code>dvrescue device://&lt;guid&gt; --capture --merge &lt;output.dv&gt;</code> - Capture tape to file</li>
</ul>
<p><strong>Optical Media:</strong></p>
<ul>
<li><code>drutil status</code> - Query optical drive state</li>
<li><code>diskutil mountDisk &lt;device&gt;</code> - Mount all partitions</li>
<li><code>hdiutil makehybrid -o &lt;output&gt; &lt;source&gt; -iso -udf</code> - Create ISO image</li>
<li><code>diskutil eject &lt;device&gt;</code> - Eject disc when complete</li>
</ul>
<p><strong>Transcoding:</strong></p>
<ul>
<li><code>ffprobe -v error -show_entries format=duration &lt;file&gt;</code> - Get video duration</li>
<li><code>ffmpeg -i &lt;input.dv&gt; -c:v h264_videotoolbox -crf 16 &lt;output.mkv&gt;</code> - Convert DV to archival quality</li>
<li><code>HandBrakeCLI --preset &#34;Production Max&#34; --input &lt;iso&gt; --output &lt;mkv&gt;</code> - Rip DVD content</li>
</ul>
<p>Our frontend is a series of Jinja templates, which I dislike writing by hand but coding LLMs are shockingly proficient in. All the actual logic is in the backend layer - we just issue commands and stream logs via POST requests and SSE.</p>
<p>We scan for all the periodicals connected to the system using <code>system_profiler</code>. This lets us grab all connected DVD readers and camcorders. We lay out each one in a separate log streamer. We include a singleton media converter that owns the handbrake/ffmpeg conversion depending on the type of input file. isos are passed to handbrake and dvs can be piped directly to ffmpeg.</p>
<p>A simple sqlite database in the destination volume on our NAS acts as our job broker. When we start importing a new media file, we write a new row. When the object changes state into a <code>CAPTURE_DONE</code> we poll it by the ffmpeg worker to do the encoding.</p>
<p>We poll every second for updated status from the periodicals, so once a tape is inserted we update the UI to show a <code>Capture</code> button. Clicking the button will rewind the tape and start capturing once it&#39;s completed. When the capturing is completed (1:1 with the length of the tape) it will display a system popover reminding me to change over the tape.</p>
<p><span><span><span><img alt="Screenshot of taking a picture of a tape after import" loading="lazy" width="1200" height="800" decoding="async" data-nimg="1" sizes="(max-width: 768px) 100vw, (max-width: 1200px) 80vw, 1200px" srcset="/notes-images/automating_videos/nextImageExportOptimizer/control_panel_screenshot-opt-640.WEBP 640w, /notes-images/automating_videos/nextImageExportOptimizer/control_panel_screenshot-opt-750.WEBP 750w, /notes-images/automating_videos/nextImageExportOptimizer/control_panel_screenshot-opt-828.WEBP 828w, /notes-images/automating_videos/nextImageExportOptimizer/control_panel_screenshot-opt-1080.WEBP 1080w, /notes-images/automating_videos/nextImageExportOptimizer/control_panel_screenshot-opt-1200.WEBP 1200w, /notes-images/automating_videos/nextImageExportOptimizer/control_panel_screenshot-opt-1920.WEBP 1920w, /notes-images/automating_videos/nextImageExportOptimizer/control_panel_screenshot-opt-2048.WEBP 2048w, /notes-images/automating_videos/nextImageExportOptimizer/control_panel_screenshot-opt-3840.WEBP 3840w" src="https://pierce.dev/notes-images/automating_videos/nextImageExportOptimizer/control_panel_screenshot-opt-3840.WEBP"/></span></span></span></p>
<p>As I pop out the tapes, I get another action button to capture an image of the cassette. Most of these have some kind of hand label of the dates or events that were captured. The UI pops up a simple javascript capture box that lets me connect to my iPhone via <a href="https://support.apple.com/en-us/102546" data-snapshot-id="8b855ad2bff9ac4f4a2f9e6865380444" data-snapshot-url="https://support.apple.com/en-us/102546" data-snapshot-date="2025-11-05T04:51:50.639Z">Continuity Camera</a>.<sup><a href="#user-content-fn-7" id="user-content-fnref-7" data-footnote-ref="true" aria-describedby="footnote-label">10</a></sup></p>
<p>I still capture these images for physical discs. But with isos we have a bit more metadata within the actual bytes than we have as part of tapes. Once capture is complete also do a full scan of the files that are contained within the disc to try and figure out when it was burned in the first place, by looking at the average created date of the files.</p>
<p>With this basic pipeline I got 3x parallelism of importing DVDs, Hi8, and MiniDV tapes at the same time. I entertained some brief fantasies of buying up 5 different camcorders and chugging through this workload in a few days but I held off since working camcorders are about $200 a pop on eBay. We&#39;re trying to keep costs low here, <em>people</em>.</p>
<h2 id="video-quality">Video Quality</h2>
<p>The quality of my converted Hi8 tapes looked pretty consistent, whether from 95 or from 2000. The miniDV tapes had a much higher variance of their quality: some looked like a pixelated blob and others were a lot smoother. You can take a look at a few of these examples - each image is from a different tape.</p>
<div><p><span><img alt="Hi8 Tape Quality" loading="lazy" width="1200" height="800" decoding="async" data-nimg="1" sizes="(max-width: 768px) 100vw, (max-width: 1200px) 80vw, 1200px" srcset="/notes-images/automating_videos/nextImageExportOptimizer/hi8_tape_quality-opt-640.WEBP 640w, /notes-images/automating_videos/nextImageExportOptimizer/hi8_tape_quality-opt-750.WEBP 750w, /notes-images/automating_videos/nextImageExportOptimizer/hi8_tape_quality-opt-828.WEBP 828w, /notes-images/automating_videos/nextImageExportOptimizer/hi8_tape_quality-opt-1080.WEBP 1080w, /notes-images/automating_videos/nextImageExportOptimizer/hi8_tape_quality-opt-1200.WEBP 1200w, /notes-images/automating_videos/nextImageExportOptimizer/hi8_tape_quality-opt-1920.WEBP 1920w, /notes-images/automating_videos/nextImageExportOptimizer/hi8_tape_quality-opt-2048.WEBP 2048w, /notes-images/automating_videos/nextImageExportOptimizer/hi8_tape_quality-opt-3840.WEBP 3840w" src="https://pierce.dev/notes-images/automating_videos/nextImageExportOptimizer/hi8_tape_quality-opt-3840.WEBP"/></span></p><blockquote>
<p>Hi8 Tape Quality</p>
</blockquote><p><span><img alt="MiniDV Tape Quality" loading="lazy" width="1200" height="800" decoding="async" data-nimg="1" sizes="(max-width: 768px) 100vw, (max-width: 1200px) 80vw, 1200px" srcset="/notes-images/automating_videos/nextImageExportOptimizer/minidv_tape_quality-opt-640.WEBP 640w, /notes-images/automating_videos/nextImageExportOptimizer/minidv_tape_quality-opt-750.WEBP 750w, /notes-images/automating_videos/nextImageExportOptimizer/minidv_tape_quality-opt-828.WEBP 828w, /notes-images/automating_videos/nextImageExportOptimizer/minidv_tape_quality-opt-1080.WEBP 1080w, /notes-images/automating_videos/nextImageExportOptimizer/minidv_tape_quality-opt-1200.WEBP 1200w, /notes-images/automating_videos/nextImageExportOptimizer/minidv_tape_quality-opt-1920.WEBP 1920w, /notes-images/automating_videos/nextImageExportOptimizer/minidv_tape_quality-opt-2048.WEBP 2048w, /notes-images/automating_videos/nextImageExportOptimizer/minidv_tape_quality-opt-3840.WEBP 3840w" src="https://pierce.dev/notes-images/automating_videos/nextImageExportOptimizer/minidv_tape_quality-opt-3840.WEBP"/></span>
<span><img alt="MiniDV Tape Quality" loading="lazy" width="1200" height="800" decoding="async" data-nimg="1" sizes="(max-width: 768px) 100vw, (max-width: 1200px) 80vw, 1200px" srcset="/notes-images/automating_videos/nextImageExportOptimizer/minidv_tape_quality_2-opt-640.WEBP 640w, /notes-images/automating_videos/nextImageExportOptimizer/minidv_tape_quality_2-opt-750.WEBP 750w, /notes-images/automating_videos/nextImageExportOptimizer/minidv_tape_quality_2-opt-828.WEBP 828w, /notes-images/automating_videos/nextImageExportOptimizer/minidv_tape_quality_2-opt-1080.WEBP 1080w, /notes-images/automating_videos/nextImageExportOptimizer/minidv_tape_quality_2-opt-1200.WEBP 1200w, /notes-images/automating_videos/nextImageExportOptimizer/minidv_tape_quality_2-opt-1920.WEBP 1920w, /notes-images/automating_videos/nextImageExportOptimizer/minidv_tape_quality_2-opt-2048.WEBP 2048w, /notes-images/automating_videos/nextImageExportOptimizer/minidv_tape_quality_2-opt-3840.WEBP 3840w" src="https://pierce.dev/notes-images/automating_videos/nextImageExportOptimizer/minidv_tape_quality_2-opt-3840.WEBP"/></span></p><blockquote>
<p>MiniDV Tape Quality</p>
</blockquote></div>
<p>As far as I can tell no digital zoom has been applied specifically to the tapes that look bad. All files (both Hi8 and MiniDV) are also the same video size: <code>720x480</code> with yuv411p.</p>
<pre><code>
[dv @ 0x159804080] Estimating duration from bitrate, this may be inaccurate
Input 
  Duration: 00:20:30.80, start: 0.000000, bitrate: 28771 kb/s
  Stream 
  Stream 
  Stream 
</code></pre>
<p>I can&#39;t offer an explanation - other than at some point we had a miniDV recorder whose digital optics conversion was really bad. At record time it just wrote pixelated data to the tape and when we read it back, it stays pixelated. That&#39;s simply all the data we have stored on tape. miniDV makes your original source camera a whole lot more important.</p>
<p>That brings us to interlacing. All dvlink protocol transfers are assumed to be <em>interlaced</em>, so it&#39;s technically streaming 480i instead of 480p footage to your computer. Interlacing came from when cameras didn&#39;t have tape size to write every frame during every timestep<sup><a href="#user-content-fn-14" id="user-content-fnref-14" data-footnote-ref="true" aria-describedby="footnote-label">11</a></sup>. So at each 1/30fps, the camera only writes half of the given horizontal rows to the tape (240 in the case of 480 vertical rows). We just smooth it with the next frame&#39;s worth of the other 240 rows.</p>
<p>This results in the occasional striping you see on old tapes. But generally speaking it&#39;s not very visible to the human eye.</p>
<div><p><span><img alt="" loading="lazy" width="1200" height="800" decoding="async" data-nimg="1" sizes="(max-width: 768px) 100vw, (max-width: 1200px) 80vw, 1200px" srcset="/notes-images/automating_videos/nextImageExportOptimizer/interlaced-opt-640.WEBP 640w, /notes-images/automating_videos/nextImageExportOptimizer/interlaced-opt-750.WEBP 750w, /notes-images/automating_videos/nextImageExportOptimizer/interlaced-opt-828.WEBP 828w, /notes-images/automating_videos/nextImageExportOptimizer/interlaced-opt-1080.WEBP 1080w, /notes-images/automating_videos/nextImageExportOptimizer/interlaced-opt-1200.WEBP 1200w, /notes-images/automating_videos/nextImageExportOptimizer/interlaced-opt-1920.WEBP 1920w, /notes-images/automating_videos/nextImageExportOptimizer/interlaced-opt-2048.WEBP 2048w, /notes-images/automating_videos/nextImageExportOptimizer/interlaced-opt-3840.WEBP 3840w" src="https://pierce.dev/notes-images/automating_videos/nextImageExportOptimizer/interlaced-opt-3840.WEBP"/></span></p><blockquote>
<p>Interlaced, raw .dv</p>
</blockquote></div>
<p>It&#39;s the most apparent during movement. Which intuitively makes sense, because that&#39;s when there will be the biggest delta in rendering from frame to frame. To smooth it out you can use a deinterlace algorithm.</p>
<div><p><span><img alt="" loading="lazy" width="1200" height="800" decoding="async" data-nimg="1" sizes="(max-width: 768px) 100vw, (max-width: 1200px) 80vw, 1200px" srcset="/notes-images/automating_videos/nextImageExportOptimizer/deinterlaced-opt-640.WEBP 640w, /notes-images/automating_videos/nextImageExportOptimizer/deinterlaced-opt-750.WEBP 750w, /notes-images/automating_videos/nextImageExportOptimizer/deinterlaced-opt-828.WEBP 828w, /notes-images/automating_videos/nextImageExportOptimizer/deinterlaced-opt-1080.WEBP 1080w, /notes-images/automating_videos/nextImageExportOptimizer/deinterlaced-opt-1200.WEBP 1200w, /notes-images/automating_videos/nextImageExportOptimizer/deinterlaced-opt-1920.WEBP 1920w, /notes-images/automating_videos/nextImageExportOptimizer/deinterlaced-opt-2048.WEBP 2048w, /notes-images/automating_videos/nextImageExportOptimizer/deinterlaced-opt-3840.WEBP 3840w" src="https://pierce.dev/notes-images/automating_videos/nextImageExportOptimizer/deinterlaced-opt-3840.WEBP"/></span></p><blockquote>
<p>Deinterlaced with yadif (Yet Another DeInterlacing Filter)</p>
</blockquote></div>
<p>The full pixel difference between the two approaches makes it clear this happens mostly at the edges where there is maximal movement:</p>
<p><span><img alt="" loading="lazy" width="1200" height="800" decoding="async" data-nimg="1" sizes="(max-width: 768px) 100vw, (max-width: 1200px) 80vw, 1200px" srcset="/notes-images/automating_videos/nextImageExportOptimizer/interlaced_comparison-opt-640.WEBP 640w, /notes-images/automating_videos/nextImageExportOptimizer/interlaced_comparison-opt-750.WEBP 750w, /notes-images/automating_videos/nextImageExportOptimizer/interlaced_comparison-opt-828.WEBP 828w, /notes-images/automating_videos/nextImageExportOptimizer/interlaced_comparison-opt-1080.WEBP 1080w, /notes-images/automating_videos/nextImageExportOptimizer/interlaced_comparison-opt-1200.WEBP 1200w, /notes-images/automating_videos/nextImageExportOptimizer/interlaced_comparison-opt-1920.WEBP 1920w, /notes-images/automating_videos/nextImageExportOptimizer/interlaced_comparison-opt-2048.WEBP 2048w, /notes-images/automating_videos/nextImageExportOptimizer/interlaced_comparison-opt-3840.WEBP 3840w" src="https://pierce.dev/notes-images/automating_videos/nextImageExportOptimizer/interlaced_comparison-opt-3840.WEBP"/></span></p>

<p>Some miniDV tapes have the original metadata embedded at record time so we can chunk them with full accuracy. These live in the <code>VAUX</code> subcode area on the tape, which stores arbitrary non-frame metadata. This is not part of the compatibility standard: cameras can choose to write clip boundaries or not. About 30% of my tapes had them and 70% did not.</p>
<p>With Hi8 you don&#39;t even have a shot. Since we have a combination of tapes that have the metadata and don&#39;t, we&#39;re going to have to figure out a way to brute force it. Given a single two hour long video file, we need an algorithm that will extract the different clips contained within it. There a bunch of different options here all under the general research area of <em>shot boundary detection</em>.</p>
<ul>
<li><a href="https://github.com/Breakthrough/PySceneDetect" data-snapshot-id="157f481d58d2b7b81ea958905d6833c2" data-snapshot-url="https://github.com/Breakthrough/PySceneDetect" data-snapshot-date="2025-11-05T04:51:50.625Z">PySceneDetect</a></li>
<li><a href="https://github.com/soCzech/TransNetV2" data-snapshot-id="4c5978ec13be45163a0ed042a0486834" data-snapshot-url="https://github.com/soCzech/TransNetV2" data-snapshot-date="2025-11-05T04:51:49.120Z">TransNetV2</a></li>
<li>Using a video LLM to output timebreaks; <a href="https://ai.google.dev/gemini-api/docs/video-understanding" data-snapshot-id="bd76e34e28b3382e82bab4d86a8950db" data-snapshot-url="https://ai.google.dev/gemini-api/docs/video-understanding" data-snapshot-date="2025-11-05T07:24:17.954Z">Gemini 2.5 Pro</a> is the most capable in this area</li>
</ul>
<p>I decided to put them to the test. I took one of my converted videos and downsampled the 22GB dv file into a more reasonable 750MB file lasting 1:45:00. I scrubbed through the video and hand labeled when there was a cut and the camera moved to a different angle or scene.<sup><a href="#user-content-fn-8" id="user-content-fnref-8" data-footnote-ref="true" aria-describedby="footnote-label">12</a></sup></p>
<p>This task is not easy! Even for a person. These are home videos, not cinematic masterpieces. There is a lot of aggressive zooming, some clips are only a few seconds in duration, exposure is inconsistent, etc. Generally speaking I would prefer a chunking algorithm to be overly relaxed with cropping: it&#39;s better to combine multiple similar looking clips in one video file than incorrectly cut a single clip into multiple different ones.</p>
<p>This one ground truth annotation had 131 clips spanning from a few seconds to a few minutes. I implemented a greedy evaluator to align the predictions with our ideal scene cuts:</p>
<ol>
<li>Find the closest ground truth scene cut</li>
<li>If the distance is ≤ tolerance (1.0s default), it&#39;s a match</li>
<li>Each ground truth can only match once (greedy)</li>
<li>Track the temporal error (how far off the prediction was)</li>
</ol>
<p>Here&#39;s how the different approaches broke down:</p>
<table><thead><tr><th>Extractor</th><th>Precision</th><th>Recall</th><th>F1 Score</th><th>Detected</th><th>TP</th><th>FP</th><th>FN</th><th>Mean Error (s)</th></tr></thead><tbody><tr><td>transnetv2</td><td>0.733</td><td>0.811</td><td>0.770</td><td>146</td><td>107</td><td>39</td><td>25</td><td>0.311</td></tr><tr><td>pyscenedetect</td><td>0.159</td><td>0.939</td><td>0.273</td><td>778</td><td>124</td><td>654</td><td>8</td><td>0.359</td></tr><tr><td>gemini (flash)</td><td>0.091</td><td>0.008</td><td>0.014</td><td>11</td><td>1</td><td>10</td><td>131</td><td>0.120</td></tr></tbody></table>
<p>I tried to run this inference pipeline with Gemini 2.5 Pro, since I&#39;ve found it far more accurate in the past - especially for video queries. Unfortunately my videos kept getting flagged by the <code>PROHIBITED_CONTENT</code> automatic filter. Google <a href="https://docs.cloud.google.com/vertex-ai/generative-ai/docs/multimodal/configure-safety-filters" data-snapshot-id="e6f6cc33fd4a508668bf1da69adcf957" data-snapshot-url="https://docs.cloud.google.com/vertex-ai/generative-ai/docs/multimodal/configure-safety-filters" data-snapshot-date="2025-11-05T07:24:17.115Z">describes</a> this error for content &#34;flagged for containing the prohibited contents, usually CSAM.&#34; But even recognizing this was a tape of me as a baby<sup><a href="#user-content-fn-10" id="user-content-fnref-10" data-footnote-ref="true" aria-describedby="footnote-label">13</a></sup>, I couldn&#39;t find what might have been misinterpreted as objectionable. I was minimally in diapers in every scene if not a proper fit when I was out on the town. My guess is they&#39;re optimizing a bit more for recall here than precision.</p>
<p>transnetv2 was remarkably performant, even when just running on my M1 Max. I was a bit surprised that even Gemini Flash was not higher out of the box considering it gets access to both the video and the audio streams.<sup><a href="#user-content-fn-9" id="user-content-fnref-9" data-footnote-ref="true" aria-describedby="footnote-label">14</a></sup> Granted, the underlying Gemini model only gets access to every 1s frame that is sampled from the video - but even relaxing our 1s tolerance tightness does not meaningfully improve the scores. It cuts conservatively, which is reflected in the overall low number of predictions in the detected clip count column.</p>
<p>The results of transnetv2 also qualitatively look great. The cuts are sometimes a bit too liberal given my preferences, but in each cut I could clearly see the camera move enough where the &#34;scene&#34; delineation was ambiguous. The difference between a hard cut and a pan in these moments is really only clear with more context.</p>
<h2 id="clip-labeling">Clip Labeling</h2>
<p>For the above reasons I ruled out using a cloud LLM for scene detection. But it&#39;s still very useful within this overall pipeline for labeling what the scenes are <em>actually about</em>. The ideal tags I&#39;m looking for on each video include the date recorded, the location recorded, a text summary of the scene, and the people involved. My goal is to make it easier to search through our sea of content by person or memory.</p>
<p>You can write a prompt that includes these goals:</p>
<blockquote>
<p>The following home videos can contain an arbitrary amount of people, but will often contain the following individuals:</p>
<ul>
<li>Pierce [included screenshot of baby me]</li>
<li>Mom [included screenshot]</li>
<li>Dad [included screenshot]</li>
<li>Aunt J [included screenshot]</li>
<li>Aunt M [included screenshot]
...</li>
</ul>
<p>Describe what they&#39;re doing in each scene. If the narrator makes reference to what they&#39;re doing, include that in the description. Don&#39;t make anything up - always ground it in what&#39;s happening or what is being described.</p>
</blockquote>
<p>This works where our previous pipeline failed for Gemini Pro, since we&#39;ve already chunked out the scenes using transnetv2. The safety filter might overzealously block a few of these videos from being processed, but the majority of our clips should be able to get a labeling as output.</p>
<p>I was surprised by the ability of the models to generalize a single photo into a tag of people in the scenes. When I spot checked a handful of these videos, the results all checked out. I didn&#39;t rigorously test character recognition accuracy, but I suspect our performance here exceeds conventional facial recognition algorithms: the sources are too noisy for high quality matching <em>plus</em> the audio feed gives a huge advantage to the multimodal models. Often the person recording would call out people in frame by name.</p>
<p><span><img alt="Label 1" loading="lazy" width="1200" height="800" decoding="async" data-nimg="1" sizes="(max-width: 768px) 100vw, (max-width: 1200px) 80vw, 1200px" srcset="/notes-images/automating_videos/nextImageExportOptimizer/label_1-opt-640.WEBP 640w, /notes-images/automating_videos/nextImageExportOptimizer/label_1-opt-750.WEBP 750w, /notes-images/automating_videos/nextImageExportOptimizer/label_1-opt-828.WEBP 828w, /notes-images/automating_videos/nextImageExportOptimizer/label_1-opt-1080.WEBP 1080w, /notes-images/automating_videos/nextImageExportOptimizer/label_1-opt-1200.WEBP 1200w, /notes-images/automating_videos/nextImageExportOptimizer/label_1-opt-1920.WEBP 1920w, /notes-images/automating_videos/nextImageExportOptimizer/label_1-opt-2048.WEBP 2048w, /notes-images/automating_videos/nextImageExportOptimizer/label_1-opt-3840.WEBP 3840w" src="https://pierce.dev/notes-images/automating_videos/nextImageExportOptimizer/label_1-opt-3840.WEBP"/></span></p>
<pre><code><span>{</span>
  <span>&#34;description&#34;</span><span>:</span> <span>&#34;&#34;</span><span>&#34;
  Uncle S and Aunt M, holding Pierce, are at a museum,
  as stated by the narrator. A large airplane can
  be seen hanging from the ceiling.
  &#34;</span><span>&#34;&#34;</span><span>,</span>
  <span>&#34;known_date&#34;</span><span>:</span> <span>&#34;1998-05-31&#34;</span><span>,</span>
  <span>&#34;known_location&#34;</span><span>:</span> <span>&#34;museum&#34;</span>
<span>}</span>
</code></pre>
<p>When combined with the audio, even 1fps can give you a rich sense for what is happening in each scene. I&#39;m particularly excited about the capability of this pipeline to provide more descriptive tagging. Just exactly how that can best be imported into <a href="https://pierce.dev/notes/adding-my-parents-to-tailscale/">Jellyfin</a> is a project I&#39;ll leave for next week.</p>
<h2 id="why-now">Why now</h2>
<p>I&#39;m sure it will always be <em>possible</em> to archive old analog formats. But already in the past 5 years I&#39;m noticing it&#39;s become significantly <em>harder</em> to do so:</p>
<ul>
<li>macOS <a href="https://www.macrumors.com/2025/06/19/macos-tahoe-beta-drops-firewire-support/">drops support</a> for Firewire in Tahoe</li>
<li>Apple stopped selling their Firewire to Thunderbolt2 connector; your only choice is to buy them on eBay for ~$150 - they retailed for under $50</li>
<li>My camcorders still mostly worked but the touch screen on one had already failed; eventually the supply of working components for these is going to shrink</li>
</ul>
<p>As the difficulty increases so does the cost. Eventually I imagine it will reach a point where it simply becomes economically unfeasible to try to go through these motions yourself. I was even lucky that I didn&#39;t upgrade my OS to Tahoe and I&#39;m still on my Sequoia, so I don&#39;t have to find another computer just for the sake of importing these files.</p>
<p>At the same time, the quality of ML models to help process videos after the fact have never been better. They&#39;ve reached a level of accuracy where they make small mistakes but they&#39;re right ~95% of the time. That&#39;s certainly above the bar we need for home categorization where we&#39;re looking for convenience and not perfect filtering.</p>
<p>The intersection of those two factors means that it&#39;s never been a better time to tackle that backlog of home videos. You can get the best quality out of your tapes <em>and</em> you&#39;ll actually be able to make them watchable.</p>
<p>If you start now I bet you can get done by the holidays.</p>
</div></div>
  </body>
</html>
