<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://slinkp.com/python-emacs-lsp-20231229.html">Original</a>
    <h1>Modernizing my Python development setup in Emacs</h1>
    
    <div id="readability-page-1" class="page"><div>
              <p>For some years, I&#39;ve got by with a gradually evolving set of Emacs extensions
and configuration to make me productive and happy while working with Python.
I tend to be slow to adopt new tools once I&#39;ve got something working.
But my <a href="https://slinkp.com/emacs.html" rel="nofollow">old setup</a> was getting pretty crufty, and
there&#39;s so much buzz around LSP that -- rather than yell at the VSCode kids to get
off my lawn -- I wanted to see what I was missing.</p>
<p>As always, my complete emacs config lives <a href="https://github.com/slinkp/dotemacs" rel="nofollow">on my github</a>.</p>
<p>Thanks to the folks in the &#34;tool talk&#34; meeting at <a href="https://recurse.com" rel="nofollow">Recurse</a> for inspiring me to finally do this.</p>
<p>I&#39;m just starting to get comfortable with it, but here&#39;s where I&#39;m at currently:</p>
<h3>LSP</h3>
<p>Emacs has good support for LSP and it was pretty easy to set up.
I use <a href="https://github.com/radian-software/straight.el" rel="nofollow">straight</a> to manage my Emacs packages, so all I had to do was this,
adapted from <a href="https://emacs-lsp.github.io/lsp-mode/page/installation/#use-package" rel="nofollow">the lsp-mode docs</a>:</p>
<div><pre><span></span><code><span>(</span><span>straight-use-package</span><span> </span><span>&#39;lsp-mode</span><span>)</span>
<span>(</span><span>use-package</span><span> </span><span>lsp-ui</span>
<span>  </span><span>:commands</span><span> </span><span>lsp-ui-mode</span>
<span>  </span><span>:straight</span><span> </span><span>t</span><span>)</span>

<span>(</span><span>add-hook</span><span> </span><span>&#39;python-mode-hook</span><span> </span><span>&#39;lsp-deferred</span><span>)</span>
</code></pre></div>

<p>This didn&#39;t actually <em>do</em> anything until I had a language server installed.
That&#39;s where things got thorny...</p>
<h3>Per-buffer environment setup</h3>
<p>Spoiler alert: we&#39;re going to use direnv! Skip to the next section if you&#39;re
not curious about why.</p>
<h4>The long-winded problem</h4>
<p>To run an LSP server, you typically need to install the server in the
environment (eg. for python, something like venv, virtualenv, or pyenv) where
your &#34;project&#34; is being developed/run.  This means running a command such as
<code>pip install python-lsp-server</code> or <code>pip install pyright</code>.</p>
<p>But... what about when you frequently work on multiple projects, each with
their own environment? You don&#39;t want them to clash with each other, or you
might run into trouble such as your language server being unable to find
completions for code you <em>know</em> is in your project - because it&#39;s looking at
the wrong project.</p>
<p>In order to find the right server, emacs needs to <em>activate</em> the right
environment when working on relevant files, so that the PATH environment
variable gets updated and Emacs can find the right server(s) to run.</p>
<p>Over the years, I&#39;ve tried various Emacs extensions that are supposed to
help with working in virtual python environments: <code>pyvenv</code>,
<code>virtualenvwrapper</code>, and the like.
The problem is, they typically make changes to the <em>global</em>
environment for the entire Emacs editing session. This means I couldn&#39;t really
work on multiple projects at once.
And, each one of those Emacs modes is tied to a specific solution such as
<code>virtualenv</code>, which makes it harder to switch between those tools - and doesn&#39;t
help with other languages.</p>
<h4>Solution, part 1: Direnv</h4>
<p><a href="https://direnv.net/" rel="nofollow">direnv</a> is a really neat tool for the shell that supports
automatically updating environment variables when a directory is entered.</p>
<p>For python, this means you can easily activate / deactivate a virtualenv just
by <code>cd</code>ing into / out of a directory. That&#39;s pretty handy regardless of emacs!
I&#39;ve been overdue for a tool like this for a long time.
It does require you to put <code>.envrc</code> files in directories of interest, but they
are easy to write, and it seems worth the trouble.</p>
<p>Direnv has pre-built
<a href="https://direnv.net/man/direnv-stdlib.1.html#codelayout-python3code" rel="nofollow">recipes</a>
for setting up a python 3 virtual env; I&#39;ll probably use that in the future,
but I have often lazily done <code>python3 -m
venv</code> in the root of a project I&#39;m working on, and I found that it was easy to support
my existing projects by dropping in the following <code>.envrc</code> file:</p>
<div><pre><span></span><code><span>test</span><span> </span>-f<span> </span>bin/activate<span> </span><span>&amp;&amp;</span><span> </span><span>source</span><span> </span>bin/activate
</code></pre></div>

<p>Even better, <code>direnv</code> is not at all Python-specific, so I will probably
leverage it when working in other languages too.</p>
<h4>Solution, part 2: Envrc mode</h4>
<p>There is of course an Emacs mode to integrate with direnv:
<a href="https://github.com/purcell/envrc" rel="nofollow">envrc</a>.
The best thing? It&#39;s buffer-local!</p>
<p>This means I can open files in different projects, each with their own virtual
env, and emacs will see different <code>PATH</code> etc. for each file I have open.</p>
<p>This means I can run correctly isolated LSP sessions for each project!</p>
<p>Setting it up turned out to be easy as well:</p>
<div><pre><span></span><code><span>(</span><span>straight-use-package</span><span> </span><span>&#39;envrc</span><span>)</span>
</code></pre></div>

<p>... with one gotcha, you have to do this <em>after all other config</em> (for reasons
explained in the docs):</p>


<h4>Installing the LSP server and related tools for each project</h4>
<p>I haven&#39;t automated this for new projects, but a basic recipe to start a
new Python project would look something like:</p>
<div><pre><span></span><code>mkdir<span> </span>my-new-project
<span>cd</span><span> </span>my-new-project
git<span> </span>init<span> </span>.

<span># Set it up for direnv</span>
<span>echo</span><span> </span><span>&#34;layout python3&#34;</span><span> </span>&gt;<span> </span>.envrc
direnv<span> </span>allow
<span># Congrats, you now have a virtual python 3 environment in .direnv/python-3.11</span>
<span># and it&#39;s active already!</span>
<span># You probably want to git ignore those.</span>

<span># Now we need our python packages:</span>
pip<span> </span>install<span> </span>python-lsp-server<span> </span>pylsp-mypy<span> </span>flake8
</code></pre></div>

<p>It took a bit of trial and error, but now it Just Works.</p>
<h3>What does all this buy you?</h3>
<p>I&#39;m still exploring the features of LSP, but I&#39;m liking these basic IDE-like
features. Some of them I had before via other means, but this is already nicer:</p>
<h4>Find references</h4>
<p>This does what it sounds like. Bound to <code>s-l g r</code>.</p>
<p><img src="https://slinkp.com/emacs/lsp-find-references.gif"/></p>
<h4>Find definition</h4>
<p>Bound to <code>s-l g g</code> by default. On my mac, I have <code>Command</code> as <code>super</code>.</p>
<p>This replaces language-specific mode features such as <code>jedi:goto-definition</code>,
or my  previous favored solution of using Emacs&#39;
<a href="https://www.emacswiki.org/emacs/EmacsTags" rel="nofollow">xref and tags</a> functionality.
Xref was useful because it&#39;s fast in some huge repos I had to work
with. LSP seems better at finding the actual definition; xref often showed me a bunch
of false positives. And, now I never have to generate a TAGS file again, hopefully.</p>
<p>We&#39;ll see how well LSP holds up next time I have to work on a <a href="https://shopify.engineering/shopify-monolith" rel="nofollow">giant
monolith</a> ...</p>
<p>One thing I really miss from xref though; it had a &#34;back&#34; button, AKA
<code>xref-pop-marker-stack</code>, bound to <code>M-,</code> which would take me back where I
was before following the definition. lsp-mode doesn&#39;t seem to have that :-(</p>
<h4>Inline documentation on hover!</h4>
<p>Nice.</p>
<p><img src="https://slinkp.com/emacs/lsp-doc-ui.gif"/></p>
<h4>Style errors / warnings</h4>
<p>I had this without LSP via <a href="https://www.flycheck.org/en/latest/" rel="nofollow">flycheck</a>
but it didn&#39;t always find the right executables; that&#39;s solved now thanks to
direnv, yay, as long as <code>flake8</code> or another compatible linter is installed in the environment.</p>
<p>The way errors are currently displayed inline is a little weird for me, I may look into
how to tweak that, but it&#39;s usable already.</p>
<p><img src="https://slinkp.com/emacs/lsp-errors.gif"/></p>
<h4>Type error hints via MyPy</h4>
<p>These are handy! Just need to have <code>pylsp-mypy</code> installed in the environment.</p>
<p><img src="https://slinkp.com/emacs/lsp-mypy.gif"/></p>
<h4>Reformatting via plugins</h4>
<p>This one tripped me up at first because it turns out they are off by default
<a href="https://emacs-lsp.github.io/lsp-mode/page/lsp-pylsp/#lsp-pylsp-plugins-autopep8-enabled" rel="nofollow">as per the docs</a>.
For pylsp, you have to explicitly enable one of the plugins.
So for example, to use <a href="" rel="nofollow">black</a> for python, install the plugin in your shell:</p>
<div><pre><span></span><code>pip<span> </span>install<span> </span>python-lsp-black
</code></pre></div>

<p>And then configure it in emacs:</p>
<div><pre><span></span><code><span>(</span><span>setq</span><span> </span><span>lsp-pylsp-plugins-black-enabled</span><span> </span><span>&#39;t</span><span>)</span>
</code></pre></div>

<p><img src="https://slinkp.com/emacs/lsp-formatting.gif"/></p>
<h4>Class / method / function breadcrumbs at top of the window.</h4>
<p>I had this without LSP via <a href="https://emacsdocs.org/docs/emacs/Which-Function" rel="nofollow">which function
mode</a>
but I like the breadcrumb style better.</p>
<p><img src="https://slinkp.com/emacs/lsp-breadcrumbs.gif"/></p>
<h3>Debugging?</h3>
<p>I haven&#39;t tried this yet. Will update or write a followup if/when I do.</p>
<h2>References</h2>
<p>Other noteworthy blog posts that inspired me:</p>
<ul>
<li><a href="https://www.bassamsaeed.ca/posts/python-development-in-emacs/" rel="nofollow">https://www.bassamsaeed.ca/posts/python-development-in-emacs/</a></li>
<li><a href="https://taingram.org/blog/emacs-lsp-ide.html" rel="nofollow">https://taingram.org/blog/emacs-lsp-ide.html</a></li>
<li>An opposite approach (no LSP, mostly vanilla): <a href="https://robbmann.io/posts/006_emacs_2_python/" rel="nofollow">https://robbmann.io/posts/006_emacs_2_python/</a></li>
</ul>
            </div></div>
  </body>
</html>
