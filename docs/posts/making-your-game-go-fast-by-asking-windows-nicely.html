<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.anthropicstudios.com/2022/01/13/asking-windows-nicely/">Original</a>
    <h1>Making Your Game Go Fast by Asking Windows Nicely</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <figure>
    <a href="https://www.anthropicstudios.com/assets/posts/2022-01-13-asking-windows-nicely/speed-limit.jpg"><img src="https://www.anthropicstudios.com/assets/posts/2022-01-13-asking-windows-nicely/speed-limit.jpg" alt="a speed limit sign that says &#39;45 fps&#39;"/></a>
    <figcaption><a href="https://www.publicdomainpictures.net/en/view-image.php?image=197252&amp;picture=speed-limit-45">(original)</a></figcaption>
</figure>

<p>Normally, to make your software go faster, it has to do less work.</p>

<p>This usually involves improving your algorithms, skipping work the user won’t see, <a href="https://media.handmade-seattle.com/practical-data-oriented-design/">factoring your target hardware into the design process</a>, or modifying your game’s content.</p>

<p>We’re not talking about any of that today. This post is a list of ways to make your game run faster on Windows–without making any major changes to your game’s content, code, or algorithms.</p>

<p>I employ these optimizations in <a href="https://store.steampowered.com/app/1110620/Way_of_Rhea/?utm_campaign=blog&amp;utm_source=website&amp;utm_content=asking-nicely">Way of Rhea</a>, a puzzle adventure written in a mix of <a href="https://www.rust-lang.org/">Rust</a> and a custom Rust scripting language. While this project is written in Rust, all the optimizations listed here are language independent–where the translation isn’t straightforward I’ve provided both Rust and C++ examples.</p>

<!--more-->


<ul id="markdown-toc">
  <li><a href="#table-of-contents" id="markdown-toc-table-of-contents">Table of Contents</a></li>
  <li><a href="#trick-1-asking-windows-nicely" id="markdown-toc-trick-1-asking-windows-nicely">Trick #1: Asking Windows Nicely</a></li>
  <li><a href="#trick-2-set-your-dpi-correctly" id="markdown-toc-trick-2-set-your-dpi-correctly">Trick #2: Set your DPI Correctly</a>    <ul>
      <li><a href="#setting-your-dpi-awareness" id="markdown-toc-setting-your-dpi-awareness">Setting your “DPI Awareness”</a>        <ul>
          <li><a href="#setting-dpi-awareness-programmatically" id="markdown-toc-setting-dpi-awareness-programmatically">Setting DPI Awareness Programmatically</a></li>
          <li><a href="#setting-dpi-awareness-with-an-application-manifest" id="markdown-toc-setting-dpi-awareness-with-an-application-manifest">Setting DPI Awareness with an Application Manifest</a></li>
        </ul>
      </li>
      <li><a href="#getting-the-scale-factor" id="markdown-toc-getting-the-scale-factor">Getting the Scale Factor</a></li>
      <li><a href="#changing-the-resolution" id="markdown-toc-changing-the-resolution">Changing the Resolution</a></li>
    </ul>
  </li>
  <li><a href="#trick-3-use-the-faster-gpu" id="markdown-toc-trick-3-use-the-faster-gpu">Trick #3: Use the Faster GPU</a>    <ul>
      <li><a href="#hinting-you-want-the-faster-gpu" id="markdown-toc-hinting-you-want-the-faster-gpu">Hinting You Want the Faster GPU</a></li>
      <li><a href="#update-linker-flags-in-rust-without-makefiles" id="markdown-toc-update-linker-flags-in-rust-without-makefiles">Update: Linker Flags in Rust Without Makefiles</a></li>
      <li><a href="#checking-that-it-worked" id="markdown-toc-checking-that-it-worked">Checking That It Worked</a></li>
    </ul>
  </li>
  <li><a href="#other-ideas" id="markdown-toc-other-ideas">Other ideas…</a></li>
</ul>


<figure>
    <a href="https://www.anthropicstudios.com/assets/posts/2022-01-13-asking-windows-nicely/power-cable-cropped.jpg"><img src="https://www.anthropicstudios.com/assets/posts/2022-01-13-asking-windows-nicely/power-cable-cropped.jpg" alt="an unplugged laptop"/></a>
</figure>

<p>One day, while working on some optimizations, I discovered that completely disabling one of Way of Rhea’s subsystems made the game <em>slower</em>. That…didn’t add up. Doing less work should take less time, so I did some investigating.</p>

<p>My initial assumption was that some weird dependency on that subsystem resulted in <em>more</em> work being done when it was absent, but that turned out not to be the case.</p>

<p>When running at 60hz, and especially with a major subsystem disabled, Way of Rhea easily spends the majority of the 16.66ms frame blocking–waiting for the next <a href="https://en.wikipedia.org/wiki/Vertical_blanking_interval">vblank</a>–and apparently this lead Windows to believe that the workload was low priority and should be throttled, increasing both the frame time and frame time variability, causing me to start occasionally <em>missing</em> vblank which is how I noticed the problem in the first place.</p>

<p>You can ask Windows nicely not to do this by linking with <code>PowrProf.dll</code>, and then calling <a href="https://docs.microsoft.com/en-us/windows/win32/api/powersetting/nf-powersetting-powersetactivescheme">this function</a> from <code>powersetting.h</code> as follows:</p>

<div><div><pre><code><span>if</span> <span>(</span><span>PowerSetActiveScheme</span><span>(</span><span>NULL</span><span>,</span> <span>&amp;</span><span>GUID_MIN_POWER_SAVINGS</span><span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
    <span>LOG_WARN</span><span>(</span><span>&#34;PowerSetActiveScheme failed&#34;</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>This solved my odd performance problem, and had a positive impact on my game’s performance when running on battery power.</p>

<div>
    <p><b>Update:</b></p>
    <p>It was pointed out to me that this isn&#39;t just tweaking a heuristic, power schemes can actually be configured by users through Windows Settings. With that in mind, should a game mess with them?</p>
    <p>I&#39;m torn on this, because I want to say no, but on the other hand as a player I had no idea that this was configurable, and now that I know I would never intentionally play a game on balanced mode–you&#39;re not gonna save much battery if you&#39;re running a game, regardless of the mode!</p>
    <p>I&#39;ll check if Microsoft has any guidelines on this, and whether previous games have set a precedent. The ideal solution would involve getting the same effect as calling this API without making a lasting change to the mode. Alternatively, the user could be prompted if they&#39;re not already in high performance mode.</p>
    <p>I&#39;ll replace this note once I&#39;ve reached a conclusion.</p>
</div>

<div>
    <p><b>Aside: How much of a difference should I expect?</b></p>
    <p>I added a debug option to Way of Rhea that toggles between power schemes at runtime, and tested the result on two laptops, both plugged in and on battery power.</p>
    <p>The actual measured frame times vary too much to make a readable table–they depend on how much and when Windows chooses to throttle you–but here are my key takeaways:</p>
    <ul>
        <li>I&#39;ve repeatedly seen replacing the default scheme by calling this API instantly turn 20ms frames into 7ms frames.
            <ul><li>You won&#39;t see this unless you&#39;re currently throttled, though. Throttling occurs most often but not solely when you&#39;re using a laptop running on battery power.</li></ul>
        </li>
        <li>
            <code>GUID_MAX_POWER_SAVINGS</code> is the slowest mode, <code>GUID_MIN_POWER_SAVINGS</code> is the fastest.
            <ul>
                <li><code>GUID_MIN_POWER_SAVINGS</code> and <code>GUID_TYPICAL_POWER_SAVINGS</code> often behave similarly, but not always. You would expect typical to be the default, but this does not seem to be the case (?).</li>
            </ul>
        </li>
        <li>While this API helps, it does not completely turn off throttling.</li>
    </ul>
</div>



<figure>
    <a href="https://www.anthropicstudios.com/assets/posts/2022-01-13-asking-windows-nicely/pixelated.png"><img src="https://www.anthropicstudios.com/assets/posts/2022-01-13-asking-windows-nicely/pixelated.png" alt="a screenshot pixelated beyond recognition"/></a>
</figure>

<p>Your players probably play other games, right? So they probably have a bunch of fancy hardware, like a 4k monitor that they wanna play your game on?</p>

<p>Well, to prevent scaling issues in legacy apps, on high DPI monitors Windows renders all applications at a lower resolution and then upscales them, unless the application explicitly opts out by becoming “DPI aware.”</p>

<p>Not only does this mean your players won’t get to take advantage of their nice monitors, <strong>it also means you have less headroom before vblank because you have to go through <a href="https://raphlinus.github.io/ui/graphics/2020/09/13/compositor-is-evil.html">the compositor</a> for upscaling</strong>, which likely also rules out <a href="https://www.anthropicstudios.com/2021/02/20/fullscreen-exclusive-is-a-lie/">fullscreen exclusivity</a>.</p>



<h2 id="setting-your-dpi-awareness">Setting your “DPI Awareness”</h2>

<p>Every couple versions of Windows, Microsoft introduces an entirely new way of handling DPI to fix issues that they couldn’t possibly have anticipated in previous versions, like users with multiple monitors.</p>

<p>We can either become DPI aware programmatically, or through an “Application Manifest”. I’ll demonstrate both methods here, and leave the choice up to you.</p>

<p><em>For those of you who support Linux via <a href="https://github.com/ValveSoftware/Proton/">Proton</a>, either option is fine–apps run through proton appear to be automatically DPI aware even if you do nothing.</em></p>

<h3 id="setting-dpi-awareness-programmatically">Setting DPI Awareness Programmatically</h3>

<p>From <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setprocessdpiawarenesscontext">Microsoft</a>, emphasis mine:</p>

<blockquote>
  <p>It is recommended that you set the process-default DPI awareness via application manifest. See Setting the default DPI awareness for a process for more information. <strong>Setting the process-default DPI awareness via API call can lead to unexpected application behavior.</strong></p>
</blockquote>

<p>This is probably bullshit. I’ve never seen this API cause a problem, and moreover, if using the DPI API can cause “unexpected application behavior” then why the fuck is there a DPI API in the first place? They didn’t have to write this API, and they sure as hell didn’t have to document it.</p>

<p><a href="https://github.com/glfw/glfw/blob/df8d7bc892937a8b0f7c604c92a9f64f383cf48c/src/win32_init.c#L629">GLFW uses the forbidden APIs</a>, <a href="https://github.com/SFML/SFML/blob/c36a7821eeb87c47a3413a953c7a6baf74ee48f2/src/SFML/Window/Win32/WindowImplWin32.cpp#L86">SFML uses the forbidden APIs</a>, and <a href="https://github.com/libsdl-org/SDL/issues/2119">SDL probably will soon too</a>.</p>

<p>So it’s probably fine. <a href="https://www.anthropicstudios.com/assets/posts/2022-01-13-asking-windows-nicely/garfield.png">If you’re feeling brave</a>, call this function before anything that depends on the DPI to opt yourself into DPI awareness programmatically:</p>

<div><div><pre><code><span>ASSERT</span><span>(</span><span>SetProcessDpiAwarenessContext</span><span>(</span><span>DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2</span><span>));</span>
</code></pre></div></div>

<p><em>This function is part of <code>User32.lib</code>, and is defined in <code>winuser.h</code> which is included in <code>Windows.h</code>.</em></p>

<p>If your monitor is set to anything other than 100% scaling in Windows Settings, you should be able to see the difference visually, and any APIs that output measurements in pixels should now output actual pixels instead of scaled pixels.</p>



<h3 id="setting-dpi-awareness-with-an-application-manifest">Setting DPI Awareness with an Application Manifest</h3>

<p><a href="https://docs.microsoft.com/en-us/windows/win32/sbscs/application-manifests">“Application Manifests”</a> are <a href="https://apenwarr.ca/log/20180914">xml</a> files that define options for your application. They are usually compiled and linked into your executable. Calling C functions to configure your app was too easy, I guess?</p>

<p>If you’re using Visual Studio then you probably already have one of these.</p>

<p>For the rest of us, it turns out that the compilation and linking step is optional, which is great, because it means we don’t need to use Microsoft’s compiler or linker to include a manifest. <a href="https://docs.microsoft.com/en-us/cpp/build/manifest-generation-in-visual-studio?view=msvc-170">From Microsoft</a>:</p>

<blockquote>
  <p>The build system in Visual Studio allows the manifest to be embedded in the final binary application file, or generated as an external file.</p>
</blockquote>

<p>Microsoft <em><a href="https://docs.microsoft.com/en-us/cpp/build/how-to-embed-a-manifest-inside-a-c-cpp-application?view=msvc-170">recommends</a></em> you embed your manifest files in the executable, but this is presumably so users don’t move the exe without bringing the manifest along for the ride, or mess with the contents itself. Most games already have external data folders with the same problem so this isn’t an issue for us.</p>

<p>If your game is located at <code>foo/bar/game.exe</code>, then you just need to create <a href="https://docs.microsoft.com/en-us/windows/win32/sbscs/application-manifests#file-location"><code>foo/bar/game.exe.manifest</code></a> with <a href="https://docs.microsoft.com/en-us/windows/win32/hidpi/setting-the-default-dpi-awareness-for-a-process#setting-default-awareness-with-the-application-manifest">the following content</a>.</p>
<div><div><pre><code><span>&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34; standalone=&#34;yes&#34;?&gt;</span>
<span>&lt;assembly</span> <span>xmlns=</span><span>&#34;urn:schemas-microsoft-com:asm.v1&#34;</span> <span>manifestVersion=</span><span>&#34;1.0&#34;</span> <span>xmlns:asmv3=</span><span>&#34;urn:schemas-microsoft-com:asm.v3&#34;</span><span>&gt;</span>
  <span>&lt;asmv3:application&gt;</span>
    <span>&lt;asmv3:windowsSettings&gt;</span>
      <span>&lt;dpiAware</span> <span>xmlns=</span><span>&#34;http://schemas.microsoft.com/SMI/2005/WindowsSettings&#34;</span><span>&gt;</span>true<span>&lt;/dpiAware&gt;</span>
      <span>&lt;dpiAwareness</span> <span>xmlns=</span><span>&#34;http://schemas.microsoft.com/SMI/2016/WindowsSettings&#34;</span><span>&gt;</span>PerMonitorV2<span>&lt;/dpiAwareness&gt;</span>
    <span>&lt;/asmv3:windowsSettings&gt;</span>
  <span>&lt;/asmv3:application&gt;</span>
<span>&lt;/assembly&gt;</span>
</code></pre></div></div>

<p>This manifest will enable <code>DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2</code> where supported, falling back first to <code>PROCESS_SYSTEM_DPI_AWARE</code>, and then to <code>PROCESS_DPI_UNAWARE</code>. <code>PROCESS_PER_MONITOR_DPI_AWARE</code> is intentionally left off since it requires additional code changes to render the titlebar correctly.</p>

<p>Just like with the programtic route: If your monitor is set to anything other than 100% scaling in Windows Settings, you should be able to see the difference visually, and any APIs that output measurements in pixels should now output actual pixels instead of scaled pixels.</p>

<h2 id="getting-the-scale-factor">Getting the Scale Factor</h2>

<p>This isn’t often relevant for games, but, if you need to check how much things <em>would</em> have been scaled if you weren’t DPI aware, you can call <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getdpiforwindow"><code>GetDpiForWindow</code></a> and <a href="https://docs.microsoft.com/en-us/windows/win32/hidpi/wm-dpichanged#remarks">divide the result by 96</a>.</p>

<h2 id="changing-the-resolution">Changing the Resolution</h2>

<p>If you followed these steps, but your game is running <em>slower</em> now, I didn’t lie to you–you’re just rendering more pixels than you were before. That’s a good thing, you want the option to support the user’s native resolution right?</p>

<p>You probably want the option to render at a lower (or higher!) resolution too.</p>

<p>This should be done by rendering to a framebuffer that the user can resize from the options menu of your game. I don’t recommend messing with the user’s desktop resolution, I’m willing to believe that was worthwhile in the past but in the admittedly informal tests that I’ve done on Windows 10, I’ve seen no benefit and it’s a bad experience for your players. The framebuffer method is also more flexible–you have the option to render your UI at a higher resolution than everything else.</p>

<p>I provide the player with an option called “resolution” that can be set anywhere from 20% to 200%. I think other games call this “render scale”, I guess I could rename it. The framebuffer is set to the given percent of the game window’s current size. AFAICT there’s not advantage to a preset list of supported resolutions unless you’re messing with the monitor itself. Careful with aspect ratios though.</p>



<figure>
    <a href="https://www.anthropicstudios.com/assets/posts/2022-01-13-asking-windows-nicely/graphics-card-vs.jpg"><img src="https://www.anthropicstudios.com/assets/posts/2022-01-13-asking-windows-nicely/graphics-card-vs.jpg" alt="A TI80 next to an intel CPU that has an integrated GPU with versus written between them"/></a>
</figure>

<p>Here’s the scene. Someone buys your game. They bought a laptop with a fancy 3080 or something (because scalpers bought all the standalone cards so <a href="https://www.pcmag.com/news/how-to-beat-the-scalpers-and-score-an-rtx-3000-card-ryzen-5000-chip">how else are you gonna get one</a>), and they wanna run your game on it. <strong>When they boot it up, it launches on their integrated Intel GPU instead of their 3080 and runs super slow.</strong> They don’t know that’s what happened though. To them, your game is just so slow that it can’t even run on their 3080.</p>

<p>Alright that’s no good. If we’re running on a laptop and we don’t explicitly request the faster card, we’ll often end up running on the slower integrated GPU instead. How do we make that request? Well, if you’re running a new graphics API, you may be able to enumerate the available graphics cards and pick the fastest one (or let the user pick it). I haven’t updated to the newer APIs yet, but if you’re on one of them and that’s correct, awesome–problem solved.</p>

<p>But what about all of us still on OpenGL?</p>

<p><strong>Note:</strong> It was pointed out to me that the original version of the above story was unrealistic because GPU switching only works the way I’m describing on laptops, so I’ve updated the story and the paragraph following it to clarify this. I believe this is correct, but I don’t have a good source on it to link to, if you have one <a href="https://www.anthropicstudios.com/cdn-cgi/l/email-protection#375a56445859775659435f4558475e54444342535e58441954585a">feel free to get in touch!</a></p>

<h2 id="hinting-you-want-the-faster-gpu">Hinting You Want the Faster GPU</h2>

<p>You’re gonna have to hint to each graphics card vendor that you want the fast card. You can find the documentation for <a href="https://docs.nvidia.com/gameworks/content/technologies/desktop/optimus.htm">Nvidia here</a>. At one point I also managed to track down AMD’s documentation on this, but I can’t seem to find it anymore.</p>

<p>In case your idea of a fun afternoon doesn’t involve piecing through the Nvidia docs to figure this out on your own, and then hunting down wherever AMD hid their explanation, I’ve written up what I learned from reading the docs and implementing their recommendations myself.</p>

<p><strong>Aside: Testing on AMD GPUs</strong></p>

<p>The NVIDIA docs provide two methods of preferring the NVIDIA card over integrated cards:</p>
<ul>
  <li>Linking with one of a long list of NVIDIA libraries</li>
  <li>Exporting a special symbol</li>
</ul>

<p>The former did not work in my tests, so I’m only demonstrating the latter (+ the AMD equivalent.) First, you need to add this code somewhere in your project:</p>

<p><em>(rust version)</em></p>
<div><div><pre><code><span>#[no_mangle]</span>
<span>pub</span> <span>static</span> <span>NvOptimusEnablement</span><span>:</span> <span>i32</span> <span>=</span> <span>1</span><span>;</span>
<span>#[no_mangle]</span>
<span>pub</span> <span>static</span> <span>AmdPowerXpressRequestHighPerformance</span><span>:</span> <span>i32</span> <span>=</span> <span>1</span><span>;</span>
</code></pre></div></div>

<p><em>(c++ version)</em></p>
<div><div><pre><code><span>extern</span> <span>&#34;C&#34;</span> <span>{</span>
    <span>_declspec</span><span>(</span><span>dllexport</span><span>)</span> <span>DWORD</span> <span>NvOptimusEnablement</span> <span>=</span> <span>0x00000001</span><span>;</span>
    <span>_declspec</span><span>(</span><span>dllexport</span><span>)</span> <span>DWORD</span> <span>AmdPowerXpressRequestHighPerformance</span> <span>=</span> <span>0x00000001</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Next, when you compile, <strong>make sure your compiler exports these variables</strong>.</p>

<p>In some languages this will happen automatically if the proper keywords are provided. In Rust, you need to set the following linker flags to get this to happen. <a href="#update-linker-flags-in-rust-without-makefiles"><del>(I’m unfortunately not aware of any way to set this from <code>Cargo.toml</code>, I ended up creating a Makefile just for this purpose.)</del></a></p>
<div><div><pre><code>cargo.exe rustc <span>--release</span> <span>--</span> <span>-C</span> link-args<span>=</span><span>&#34;/EXPORT:NvOptimusEnablement /EXPORT:AmdPowerXpressRequestHighPerformance&#34;</span>
</code></pre></div></div>

<p>If you’ve done this, then on computers that have an integrated card and a discrete Nvidia or AMD card, the discrete card should be used by default.</p>

<h2 id="update-linker-flags-in-rust-without-makefiles">Update: Linker Flags in Rust Without Makefiles</h2>

<p>Turns out it’s possible to do this with a <code>build.rs</code> script!</p>

<p>Thanks to <a href="https://twitter.com/asajeffrey">@asajeffrey</a> for helping me figure out the correct syntax–a few people suggested this route, but the syntax was harder to get right than you’d think seeing the result! Instead of creating a Makefile, you can create a <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html"><code>build.rs</code></a> script with the following content:</p>

<div><div><pre><code><span>fn</span> <span>main</span><span>()</span> <span>{</span>
    <span>println!</span><span>(</span><span>&#34;cargo:rustc-link-arg=/EXPORT:NvOptimusEnablement&#34;</span><span>);</span>
    <span>println!</span><span>(</span><span>&#34;cargo:rustc-link-arg=/EXPORT:AmdPowerXpressRequestHighPerformance&#34;</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<h2 id="checking-that-it-worked">Checking That It Worked</h2>

<p>How do we know it worked? Your game will, presumably, render faster, but we should also verify that we’re having the intended effect directly.</p>

<p>First, lets check that we successfully exported the symbols. Start a “Developer Command Prompt” (this requires installing Visual Studio), and then enter the following:</p>

<div><div><pre><code>dumpbin /exports <span>$YOUR_GAME</span>.exe
</code></pre></div></div>

<p>Our two exported variables, as well as anything else you exported, should show up in the output.</p>

<p>You can also use this to check if AAA games use this method; in my experience they do.</p>

<p>Next, assuming you have hardware to test with, we can check that the exports are being respected by using <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetString.xhtml"><code>glGetString</code></a> with the following constants:</p>
<ul>
  <li><code>GL_VENDOR</code></li>
  <li><code>GL_RENDERER</code></li>
  <li><code>GL_VERSION</code></li>
  <li><code>GL_SHADING_LANGUAGE_VERSION</code></li>
</ul>

<p>Without this change I get the following:</p>
<div><div><pre><code>vendor: Intel
renderer: Intel<span>(</span>R<span>)</span> UHD Graphics 630
version: 4.1.0 - Build 26.20.100.7261
shading_language_version: 4.10 - Build 26.20.100.7261
</code></pre></div></div>

<p>With the change I get this:</p>
<div><div><pre><code>vendor: NVIDIA Corporation
renderer: NVIDIA GeForce RTX 2060/PCIe/SSE2
version: 4.1.0 NVIDIA 471.68
shading_language_version: 4.10 NVIDIA via Cg compiler
</code></pre></div></div>


<figure>
    <a href="https://www.anthropicstudios.com/assets/posts/2022-01-13-asking-windows-nicely/profiler.png"><img src="https://www.anthropicstudios.com/assets/posts/2022-01-13-asking-windows-nicely/profiler.png" alt="Way of Rhea&#39;s in-game profiler"/></a>
</figure>

<p>Windows is complicated, graphics cards are complicated. There are probably other flags and stuff I don’t know about. Feel free to <a href="https://www.anthropicstudios.com/cdn-cgi/l/email-protection#cfa2aebca0a18faea1bba7bda0bfa6acbcbbbaaba6a0bce1aca0a2">email</a> or <a href="https://twitter.com/masonremaley">Tweet</a> at me if I missed anything!</p>

<p>Here are a couple of other things you could look into:</p>

<ul>
  <li>You could <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setpriorityclass">set your process’ priority class</a>. This is, I believe, equivalent to changing the priority in Task Manager. I saw no benefit when I tried this, so I left it alone.</li>
  <li>You could <a href="https://www.anthropicstudios.com/2021/02/20/fullscreen-exclusive-is-a-lie/">attempt to support fullscreen exclusivity</a>.</li>
  <li>You could ask NVIDIA nicely to go fast. <a href="https://docs.nvidia.com/gameworks/content/gameworkslibrary/coresdk/nvapi/group__gpupstate.html">This documentation</a> claims to allow you to get and set the current performance state, but in the list of functions I only see getters, so I’m not sure if I’m understanding correctly. If you know how <a href="https://www.anthropicstudios.com/cdn-cgi/l/email-protection#b8d5d9cbd7d6f8d9d6ccd0cad7c8d1dbcbcccddcd1d7cb96dbd7d5">email</a> or <a href="https://twitter.com/masonremaley">tweet at</a> me, I’d love to hear from you.</li>
  <li>You could become big enough that <a href="https://www.nvidia.com/download/driverResults.aspx/159420/en-us">Nvidia ships drivers specifically optimized for your game</a>, and try not to think about the long term effects of that dynamic.</li>
</ul>

<hr/>

<p>If you enjoyed this post and want to be notified about future posts, you can <a href="https://www.anthropicstudios.com/newsletter/signup/tech">sign up for my mailing list</a> or <a href="https://twitter.com/masonremaley">follow me on Twitter</a>.</p>

<p>If this article helped you quickly shave a few milliseconds off your frame time, you have my permission to spend the rest of the work day playing <a href="https://store.steampowered.com/app/1110620/Way_of_Rhea/?utm_campaign=blog&amp;utm_source=website&amp;utm_content=asking-nicely">Way of Rhea’s demo</a> with full confidence that Windows will not unnecessarily throttle your experience.</p>

<p>Sharing this article your social platform of choice is always much appreciated.</p>

  </div></div>
  </body>
</html>
