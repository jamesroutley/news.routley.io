<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.symas.com/post/are-you-sure-you-want-to-use-mmap-in-your-dbms">Original</a>
    <h1>Are you sure you want to use MMAP in your DBMS?</h1>
    
    <div id="readability-page-1" class="page"><div data-hook="post-description"><article><div><div><div><div data-rce-version="9.17.4"><div dir="ltr" data-id="content-viewer"><div data-query="container"><div><p id="viewer-7f4st"><span><span>A paper with the above provocative title started making the rounds back in 2022. While we originally discussed it over twitter, and some of our colleagues wrote longer responses on their blogs, we never wrote a long form response before. But since the paper keeps resurfacing from time to time, it seemed like a good idea to address it in depth, once and for all.</span></span></p><p id="viewer-zmpfp100"><span><span>The paper&#39;s abstract gets off to a strident start. &#34;There are, however, severe correctness and performance issues with mmap that are not immediately</span></span></p><p id="viewer-de69j2194"><span><span>apparent. Such problems make it difficult, if not impossible, to use</span></span></p><p id="viewer-ogh4p2196"><span><span>mmap correctly and efficiently in a modern DBMS.&#34; The irony of this statement is that </span><a target="_blank" href="https://lists.openldap.org/hyperkitty/list/openldap-devel@openldap.org/message/XXA2SN6HZ2FXDSE73GYONWKDJHLIB5RT/" rel="noopener noreferrer"><span><span>multiple</span></span></a><span><span> </span></span><a target="_blank" href="https://lists.openldap.org/hyperkitty/list/openldap-devel@openldap.org/message/K5XMXFFGHQOWKB6G2UGHWHW5WVH7X77C/" rel="noopener noreferrer"><span><span>research</span></span></a><span><span> </span></span><a target="_blank" href="https://lists.openldap.org/hyperkitty/list/openldap-devel@openldap.org/thread/YUUKXVYXA347IWW3UKRS6NJHBU4FEE6M/" rel="noopener noreferrer"><span><span>projects</span></span></a><span> have shown that LMDB is one of the only DB engines that consistently proves to have perfectly correct crash-resistance, while other DB engines using more traditional buffer pool management schemes have shown a variety of failure/corruption cases.</span></span></p><p id="viewer-xna6k8740"><span><span>In section 1 the paper&#39;s introduction again makes some ridiculous claims &#34;Unfortunately, mmap has a hidden dark side with many sordid problems that make it undesirable for file I/O in a DBMS. As we describe in this paper, these problems involve both data safety and system performance concerns. We contend that the engineering steps required to overcome them negate the purported simplicity of working with mmap. For these reasons, we believe that mmap adds too much complexity with no commensurate performance benefit and strongly urge DBMS developers to avoid using mmap as a replacement for a traditional buffer pool.&#34;</span></span></p><p id="viewer-pd70m29209"><span><span>LMDB safely addresses all concerns and is still the smallest most reliable database engine in the world, coming in at under 64KB of object code. Meanwhile, taking the traditional approach gives you </span><a target="_blank" href="http://www.lmdb.tech/bench/inmem/" rel="noopener noreferrer"><span><span>DB engines</span></span></a><span> that require orders of magnitude more code just to attempt to be correct, but still failing. Their assessment of complexity and correctness is completely wrong.</span></span></p><div data-breakout="normal"><div id="viewer-qugpz2108"><a href="http://www.lmdb.tech/bench/inmem/" target="_blank" data-hook="link-container"><div data-hook="imageViewer" role="button" tabindex="0"><div id="new-image25675453"><wow-image id="7e1de5_6a4b3be6da8a4be7875bdb45604f41cb~mv2.png" data-image-info="{&#34;containerId&#34;:&#34;new-image25675453&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;isLQIP&#34;:false,&#34;isSEOBot&#34;:true,&#34;imageData&#34;:{&#34;width&#34;:669,&#34;height&#34;:279,&#34;uri&#34;:&#34;7e1de5_6a4b3be6da8a4be7875bdb45604f41cb~mv2.png&#34;,&#34;name&#34;:&#34;&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-bg-effect-name="" data-has-ssr-src=""><img src="https://static.wixstatic.com/media/7e1de5_6a4b3be6da8a4be7875bdb45604f41cb~mv2.png/v1/fill/w_669,h_279,al_c,q_85,enc_auto/7e1de5_6a4b3be6da8a4be7875bdb45604f41cb~mv2.png" alt="" data-pin-url="https://www.symas.com/post/are-you-sure-you-want-to-use-mmap-in-your-dbms" data-pin-media="https://static.wixstatic.com/media/7e1de5_6a4b3be6da8a4be7875bdb45604f41cb~mv2.png/v1/fill/w_803,h_335,al_c,lg_1,q_85/7e1de5_6a4b3be6da8a4be7875bdb45604f41cb~mv2.png"/></wow-image></div></div></a></div></div><p id="viewer-51vpf62510"><span><span>In section 2 their overview of mmap is basically correct. In 2.3 &#34;MMAP Gone Wrong&#34; they list a number of DBMSs that have successfully used mmap (including LMDB) and then they cite a number of well known examples of DBMSs that used mmap and got it wrong, including MongoDB and others. The whole section is difficult to take seriously; they claim it&#39;s nearly impossible to get it right and then give a list of projects that got it right. The ones who got it wrong are irrelevant, because correct solutions clearly exist for all the potential problems.</span></span></p><p id="viewer-vbn9j140166"><span><span>In section 3 &#34;Problems with mmap&#34; we should be getting to the heart of the matter, but I find very little of interest here since LMDB has none of these problems. Their discussion of Shadow Paging that explicitly describes LMDB isn&#39;t even relevant, since by default LMDB doesn&#39;t use a writable mmap. As such their discussion of partial updates and msync doesn&#39;t even apply. These aspects of LMDB&#39;s behavior are well documented, so the fact they get this wrong reflects poorly on their research efforts.</span></span></p><p id="viewer-57bpw194428"><span><span>In section 3.2 &#34;I/O stalls&#34; is again a non-issue; no matter how your DBMS handles I/O internally, synchronously or asynchronously, the calling application can&#39;t make any progress until the I/O completes, and if the data isn&#39;t already in memory then the application must wait.</span></span></p><p id="viewer-uezw3226014"><span><span>In section 3.3 &#34;Error handling&#34; they correctly note &#34;pointer errors might corrupt pages in memory&#34; but that&#39;s why LMDB uses a read-only mmap by default. So again, non-issue. These problems are obvious to anyone contemplating such a design, and the solution is trivial, quite the opposite of the insurmountable, near-impossibility they claim.</span></span></p><p id="viewer-x86aa263695"><span><span>In section 3.4 &#34;Performance issues&#34; - every benchmark shows that LMDB always massively outperforms every other DB engine on reads, so there&#39;s really nothing of substance here either. Page eviction is explicitly not an issue since LMDB uses a read-only mmap. That means all map pages are always clean; whenever memory pressure causes the OS to need to reclaim a page it can just do so immediately without having to evict/flush a page out. (Also the RavenDB blog post directly addressed the other points so I won&#39;t re-tread that ground.)</span></span></p><p id="viewer-c67ou263240"><span><span>Section 4 &#34;Experimental Analysis&#34; really takes the cake - they test using fio, a filesystem benchmarking tool. They don&#39;t actually compare DBMS implementations, so none of their analysis takes into account the complexity and performance costs for a DBMS to </span><span><span>not</span></span><span> use mmap. This is the heart of their paper and its comparisons are completely invalid.</span></span></p><p id="viewer-0bkxi470"><span><span>Section 6 Conclusion is just completely wrong:</span></span></p><p id="viewer-p6v1g12611"><span><span> &#34;When you should not use mmap:&#34;</span></span></p><div data-breakout="normal"><ul><li dir="auto"><p id="viewer-t4nrq14854"><span><span>&#34;you need to perform updates in a transactionally safe fashion&#34; - LMDB&#39;s ACID transactions are 100% perfectly safe. </span></span></p></li><li dir="auto"><p id="viewer-nn7p613949"><span><span>&#34;you need explicit control over what data is in memory&#34; - on a machine with virtual memory, i.e., all modern operating systems, you never have this at application level. </span></span></p></li><li dir="auto"><p id="viewer-nxw8s14433"><span><span>&#34;You care about error handling and need to return correct results&#34; - LMDB always returns correct results.</span></span></p></li><li dir="auto"><p id="viewer-6bs7615006"><span><span>&#34;You require high throughput on fast persistent storage devices&#34; - nothing beats LMDB on fast persistent storage devices </span><a target="_blank" href="http://www.lmdb.tech/bench/optanessd/" rel="noopener noreferrer"><span>http://www.lmdb.tech/bench/optanessd/</span></a></span></p></li></ul></div><p id="viewer-h78q028438"><span><span>&#34;When you should maybe use mmap in your DBMS&#34;</span></span></p><div data-breakout="normal"><ul><li dir="auto"><p id="viewer-jo1iy38406"><span><span>&#34;Your working set (or the entire database) fits in memory and the workload is read-only&#34; - LMDB beats others for DBs much larger than memory, on read/write workloads </span><a target="_blank" href="http://www.lmdb.tech/bench/ondisk/" rel="noopener noreferrer"><span>http://www.lmdb.tech/bench/ondisk/</span></a></span></p></li><li dir="auto"><p id="viewer-3qyq675535"><span><span>&#34;You need to rush a product to the market and do not care about</span><span>
</span><span>data consistency or long-term engineering headaches.&#34; LMDB is an open source project, we don&#39;t care about the market because we don&#39;t have to pay back any vulture capitalists. We took the time to do things right - which actually was a lot faster than doing things the traditional way.</span></span></p></li><li dir="auto"><p id="viewer-2f0dh107859"><span><span>&#34;Otherwise, never.&#34; LOL.</span></span></p></li></ul></div><p id="viewer-2e6pp241018"><span><span>Aside from the tremendous advantage in simplicity and robustness LMDB enjoys, there are other benefits not even touched on here, such as the fact that mmap solely uses the filesystem page cache means you can easily support multi-process concurrency, as well as multi-thread concurrency, without any additional memory overhead. No other DBMS engine can do that.</span></span></p><p id="viewer-ppprp10822"><span><span>For as long as operating systems and database management systems have existed, there has been a rivalry between OS and DBMS developers. The DBMS guys always claim that because they have more intimate knowledge of the intricacies of the application workload, they can fine tune to deliver better performance. But all of that fine tuning comes at a tremendous cost in complexity, and the reality is, on a multiuser machine, they are dead wrong. Even on a dedicated single-user machine, it&#39;s far more complex and expensive for an application to collect all of the measurements and statistics needed to properly profile their workload, than it is to gather that information inside the kernel. But on a multiuser machine, where the DBMS shares the machine with other processes and other applications, it&#39;s impossible. No single process can obtain an accurate view of all system resource usage and demands; in fact it&#39;s the OS&#39;s job to </span><span><span>hide</span></span><span> such details from the application level. When you&#39;re sharing a machine with multiple other tasks, only the OS can ever truly know what&#39;s going on in the I/O susbsystem, in memory pressure, etc. etc.</span></span></p><p id="viewer-kv4zq541377"><span><span>The DBMS folks claim that knowing the intimate details of the workload can allow them to do more efficient caching. With a great deal of work that could be true on a dedicated machine, but on a shared machine, where all of your carefully managed buffers could get paged out at any time to satisfy other demands, the proposition is ludicrous. Also, there really aren&#39;t a lot of ways to beat a Least Recently Used (LRU) caching strategy. There are more efficient implementations (like CLOCK) but the overall strategy remains the same. And again LMDB leverages all of that with zero additional effort, because its B+tree design is naturally optimal with an LRU cache. Even when used with multiple tables, for separate indices and other metadata, because LMDB handles multiple tables as a tree of trees, it means the application doesn&#39;t need to care about which tables are used more frequently than others. They all start from the root of the LMDB B+tree, and an LRU mechanism will naturally sort their accesses out in order of recency.</span></span></p><p id="viewer-9tyki241135"><span><span>Ultimately, the answer to the question &#34;are you sure you want to use mmap in your DBMS?&#34; should be rephrased - do you really want to reimplement everything the OS already does for you? Do you really believe you can do it correctly, better than the OS already does? The DBMS world is littered with projects whose authors believed, incorrectly, that they could.</span></span></p></div></div></div></div></div></div></div></article></div></div>
  </body>
</html>
