<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://render.com/blog/git-organized-a-better-git-flow">Original</a>
    <h1>A Better Git Flow</h1>
    
    <div id="readability-page-1" class="page"><div><p>Imagine this: you’ve been paged to investigate a production incident, and after some digging, you identify the commit with the breaking code. You decide to revert the change:</p>

<p>Unfortunately, in doing so, a new bug is introduced! As it turns out, hidden in that old “broken” commit was some code that another part of the app depended upon, and when you reverted those lines, it left the site once again in a broken state. 🙃 Oh dear.</p>
<p>How can situations like this be avoided? To answer this question, we first need to examine how these types of commits come to be.</p>
<h2 id="a-common-git-flow"><a href="#a-common-git-flow" aria-label="a common git flow permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>A Common Git Flow</h2>
<p>Let’s take a look at a common git flow when building a new feature:</p>
<ol>
<li>Create a new branch off of <code>main</code>.</li>
<li>Create commits as you go to save your work and fix bugs you find along the way.</li>
<li>When the feature is complete, make a pull request.</li>
<li>Merge branch into <code>main</code> once PR is approved.</li>
</ol>
<p>This flow might feel quite familiar to you, and that’s fine. It’s how many of us were taught to work with git. However, <strong>there are two problems with this approach.</strong> The first problem we’ve already discussed is that some commits may contain incomplete work when you simply commit as you go. This makes reverting quite risky.</p>
<p>The second problem is that <strong>it can make reviewing pull requests very tedious.</strong> For example, what if you’ve been asked to review a recent PR in which the author states that, on top of adding a new feature, they fixed an unrelated bug as well. The PR consists of changes across <em>dozens</em> of files. Looking at each commit individually does not illuminate which changes pertain to the bug fix and which are for the new feature. Additionally, you notice some changes that seem <em>unrelated to anything in the description of the PR</em>. Clearly, this will not be a quick review.</p>
<p>Now, as lovely as it would be for each commit to neatly relate to only <em>one</em> change, that’s a tall order to fill when you’re in the midst of development. Tangents and rewrites are just part of the process. Our work is rarely so linear, and our git commits tend to reflect this.</p>
<p>So how can we guarantee that our git history is tidy and easily reviewable while also accepting the somewhat tangential nature of development? By modifying this basic git flow just slightly, we can create a better process that accomplishes just this.</p>
<h2 id="an-improved-git-flow"><a href="#an-improved-git-flow" aria-label="an improved git flow permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>An Improved Git Flow</h2>
<p>The following approach was inspired by my coworker, Dan Wendorf, whose git flow tends to revolve around one core principle: <strong>do the work first, clean up the commits later.</strong> The benefit of this flow is that it separates the <em>engineering</em>  <em>work</em> from the <em>commit writing</em>. In the end, we’ll be left with a sequence of commits that are <em>logically grouped</em>, each relating to one main change in the code, thus cleaning up our git history and paving the way for a quicker PR review.</p>
<p>We can break it down into three steps, as follows.</p>
<h3 id="step-1-make-your-changes"><a href="#step-1-make-your-changes" aria-label="step 1 make your changes permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step 1: Make your changes</h3>
<p>The first step isn’t too different than before. Start by creating a new branch and getting to work on making your changes. Don’t worry too much about writing descriptive commit messages just yet, as these won’t be included in your final PR. For now a simple, “work in progress” or “WIP” message will do, or something that will help you remember what was in that commit like “WIP: Started building new model”. The purpose of these commits are to make sure you don’t lose work and provide some general guideposts along the path of that work.</p>
<div data-language="shell"><pre><code><span><span data-user="root" data-host="localhost"></span><span></span><span></span><span></span><span data-user="root" data-host="localhost"></span><span></span><span></span><span></span><span data-user="root" data-host="localhost"></span><span></span><span></span><span></span><span data-user="root" data-host="localhost"></span></span><span>git</span> checkout -b my-feature-branch

<span>..</span>.make changes<span>..</span>.

<span>git</span> commit -m<span>&#34;WIP&#34;</span>

<span>..</span>.make <span>more</span> changes<span>..</span>.

<span>git</span> commit -m<span>&#34;WIP&#34;</span>

<span>..</span>.make even <span>more</span> changes<span>..</span>.

<span>git</span> commit -m<span>&#34;WIP&#34;</span></code></pre></div>
<p>In this step, it’s <em>okay</em> to leave the codebase in a broken state or to commit half-baked features. This will all get cleaned up later.</p>
<h3 id="step-2-reset"><a href="#step-2-reset" aria-label="step 2 reset permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step 2: Reset</h3>
<p>Once you’ve finished making your changes, it’s time to prepare your work for some “git clean up.” To do this, we’ll run the following command:</p>

<p>Without any extra arguments, <code>git reset</code> won’t change the working tree, so your code won’t change — all the work you’ve done will still be there. But because you’ve reset to an <em>older</em> commit, <code>git status</code> will show all the changes you’ve made since you started building your feature. It will look like you did all the work but never made any of those “WIP” commits earlier.</p>
<div data-language="shell"><pre><code><span><span data-user="root" data-host="localhost"></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span data-user="root" data-host="localhost"></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span>git</span> reset origin/main
Unstaged changes after reset:
M       src/components/Footer/Footer.tsx
M       src/components/Nav/Nav.css
M       src/components/Nav/Nav.tsx
M       src/components/Posts/Post.tsx
M       src/components/Posts/PostList.tsx

<span>git</span> status
On branch feature-branch
Your branch is behind <span>&#39;origin/feature-branch&#39;</span> by <span>3</span> commits, and can be fast-forwarded.
  <span>(</span>use <span>&#34;git pull&#34;</span> to update your <span>local</span> branch<span>)</span>

Changes not staged <span>for</span> commit:
  <span>(</span>use <span>&#34;git add &lt;file&gt;...&#34;</span> to update what will be committed<span>)</span>
  <span>(</span>use <span>&#34;git restore &lt;file&gt;...&#34;</span> to discard changes <span>in</span> working directory<span>)</span>
        modified:   src/components/Footer/Footer.tsx
        modified:   src/components/Nav/Nav.css
        modified:   src/components/Nav/Nav.tsx
        modified:   src/components/Posts/Post.tsx
        modified:   src/components/Posts/PostList.tsx</code></pre></div>
<p><strong>In case you get in over your head here, don’t worry</strong> — you can always bring back your original commits! Every commit you make lives in your <code>.git</code> folder, even after a <code>reset</code>. Even though it might seem like they’ve disappeared, they’re still there, hiding.</p>
<p>If you want to go back to a commit where things weren’t broken, <code>git reflog</code> will show you a timeline of every commit you’ve referenced in your local repository, even across branches. Run <code>git reflog</code> to find the commit you want to return to and then run <code>git reset &lt;commit-sha&gt;</code>. This command will point the HEAD of your current branch to that commit, and you’re back in business!</p>
<p>From here, we’re ready to start making our <em>new</em> commits.</p>
<h3 id="step-3-create-new-logically-grouped-commits"><a href="#step-3-create-new-logically-grouped-commits" aria-label="step 3 create new logically grouped commits permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step 3: Create new, logically-grouped commits</h3>
<p>Now, take a look at all the files you’ve changed. Are there any that you can logically group? For example, all the dependency updates or changes related to a particular model. There’s no “right” way to group files, so use your best judgment here. Add these files to your staging area, and make a commit describing the changes.</p>
<div data-language="shell"><pre><code><span><span data-user="root" data-host="localhost"></span><span data-user="root" data-host="localhost"></span><span data-user="root" data-host="localhost"></span><span></span><span data-user="root" data-host="localhost"></span><span data-user="root" data-host="localhost"></span><span data-user="root" data-host="localhost"></span><span></span><span data-user="root" data-host="localhost"></span><span data-user="root" data-host="localhost"></span></span><span>git</span> <span>add</span> src/components/Nav/Nav.css
<span>git</span> <span>add</span> src/components/Nav/Nav.tsx
<span>git</span> commit -m<span>&#34;Added new styles to navigation&#34;</span>

<span>git</span> <span>add</span> src/components/Posts/Post.tsx
<span>git</span> <span>add</span> src/components/Posts/PostList.tsx
<span>git</span> commit -m<span>&#34;Updated author images on posts&#34;</span>

<span>git</span> <span>add</span> src/components/Footer/Footer.tsx
<span>git</span> commit -m<span>&#34;Fixed responsive bug in footer&#34;</span></code></pre></div>
<p>If you haven’t changed many files, you might not need more than one commit, but we can often make our pull requests much easier to review by splitting up our changes into human-readable, easy-to-follow commits.</p>
<p><strong>What if the same file contains multiple changes that should be grouped separately?</strong> It’s possible to <a href="https://nuclearsquid.com/writings/git-add/" target="_self" rel="nofollow noopener noreferrer">stage <em>part</em> of a file</a> using <code>git add --patch</code> (or <code>git add -p</code>). Some code editors also provide a way to stage a <em>range</em> of changes rather than a whole file.</p>
<p><strong>Be mindful of not leaving your codebase in a broken state during this step.</strong> Remember, a huge reason we’re cleaning up our commits in the first place is so that nothing will break if we ever want to revert our changes. After making one of these new commits, you can <code>git stash</code> the rest of the unstaged changes and test that everything’s still in working order. If you realize you should have included another file in that commit, you can <code>git stash pop</code> to bring back the other changes, <code>git add</code> the missing file, and perform a <code>git commit --amend</code> . This command will replace the last commit with a new one with the same description, including the old commit and the change you just made.</p>
<h3 id="the-final-result"><a href="#the-final-result" aria-label="the final result permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The Final Result</h3>
<p>Once you’ve split your work into logically grouped commits, you’re ready to create your pull request! The final result is a set of changes that your colleague can review one commit at a time in manageable chunks.</p>
<figure>
  <span>
      <span></span>
  <picture>
          <source srcset="/static/2ff2e56697e817870e535964832023c9/e95be/git-flow-logical-organized-commits-pr.webp 245w,
/static/2ff2e56697e817870e535964832023c9/afe91/git-flow-logical-organized-commits-pr.webp 490w,
/static/2ff2e56697e817870e535964832023c9/b2aca/git-flow-logical-organized-commits-pr.webp 980w,
/static/2ff2e56697e817870e535964832023c9/be880/git-flow-logical-organized-commits-pr.webp 1470w,
/static/2ff2e56697e817870e535964832023c9/d6afa/git-flow-logical-organized-commits-pr.webp 1960w,
/static/2ff2e56697e817870e535964832023c9/d6c33/git-flow-logical-organized-commits-pr.webp 2530w" sizes="(max-width: 980px) 100vw, 980px" type="image/webp"/>
          <source srcset="/static/2ff2e56697e817870e535964832023c9/232f7/git-flow-logical-organized-commits-pr.png 245w,
/static/2ff2e56697e817870e535964832023c9/9319d/git-flow-logical-organized-commits-pr.png 490w,
/static/2ff2e56697e817870e535964832023c9/2b72d/git-flow-logical-organized-commits-pr.png 980w,
/static/2ff2e56697e817870e535964832023c9/814a3/git-flow-logical-organized-commits-pr.png 1470w,
/static/2ff2e56697e817870e535964832023c9/baffc/git-flow-logical-organized-commits-pr.png 1960w,
/static/2ff2e56697e817870e535964832023c9/bf71c/git-flow-logical-organized-commits-pr.png 2530w" sizes="(max-width: 980px) 100vw, 980px" type="image/png"/>
          <img src="https://render.com/static/2ff2e56697e817870e535964832023c9/2b72d/git-flow-logical-organized-commits-pr.png" alt="Logically-organized commits in a PR" title="Logically-organized commits in a PR" loading="lazy" decoding="async"/>
        </picture>
    </span>
</figure>
<p>The benefit of this git flow is that it allows for the fluidity of typical development while also providing some much-needed order to maintain the repository’s history.</p></div></div>
  </body>
</html>
