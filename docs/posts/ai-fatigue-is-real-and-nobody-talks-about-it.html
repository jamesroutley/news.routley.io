<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://siddhantkhare.com/writing/ai-fatigue-is-real">Original</a>
    <h1>AI fatigue Is real and nobody talks about it</h1>
    
    <div id="readability-page-1" class="page"><article><!----><p>I shipped more code last quarter than any quarter in my career. I also felt more drained than any quarter in my career. These two facts are not unrelated.</p>
<p>I build AI agent infrastructure for a living. I&#39;m one of the core maintainers of <a href="https://openfga.dev">OpenFGA</a> (CNCF Incubating), I built <a href="https://github.com/Siddhant-K-code/agentic-authz">agentic-authz</a> for agent authorization, I built <a href="https://distill.siddhantkhare.com">Distill</a> for context deduplication, I shipped MCP servers. I&#39;m not someone who dabbles with AI on the side. I&#39;m deep in it. I build the tools that other engineers use to make AI agents work in production.</p>
<p>And yet, I hit a wall. The kind of exhaustion that no amount of tooling or workflow optimization could fix.</p>
<p>If you&#39;re an engineer who uses AI daily - for design reviews, code generation, debugging, documentation, architecture decisions - and you&#39;ve noticed that you&#39;re somehow more tired than before AI existed, this post is for you. You&#39;re not imagining it. You&#39;re not weak. You&#39;re experiencing something real that the industry is aggressively pretending doesn&#39;t exist. And if someone who builds agent infrastructure full-time can burn out on AI, it can happen to anyone.</p>
<p>I want to talk about it honestly. Not the &#34;AI is amazing and here&#39;s my workflow&#34; version. The real version. The one where you stare at your screen at 11pm, surrounded by AI-generated code you still need to review, wondering why the tool that was supposed to save you time has consumed your entire day.</p>
<p><img src="https://siddhantkhare.com/blog/ai-fatigue-is-real/1.png" alt="An overwhelmed engineer surrounded by code, errors, and notifications"/></p>
<h2>The paradox nobody warned us about</h2>
<p>Here&#39;s the thing that broke my brain for a while: AI genuinely makes individual tasks faster. That&#39;s not a lie. What used to take me 3 hours now takes 45 minutes. Drafting a design doc, scaffolding a new service, writing test cases, researching an unfamiliar API. All faster.</p>
<p>But my days got harder. Not easier. Harder.</p>
<p>The reason is simple once you see it, but it took me months to figure out. When each task takes less time, you don&#39;t do fewer tasks. You do more tasks. Your capacity appears to expand, so the work expands to fill it. And then some. Your manager sees you shipping faster, so the expectations adjust. You see yourself shipping faster, so your own expectations adjust. The baseline moves.</p>
<p>Before AI, I might spend a full day on one design problem. I&#39;d sketch on paper, think in the shower, go for a walk, come back with clarity. The pace was slow but the cognitive load was manageable. One problem. One day. Deep focus.</p>
<p>Now? I might touch six different problems in a day. Each one &#34;only takes an hour with AI.&#34; But context-switching between six problems is brutally expensive for the human brain. The AI doesn&#39;t get tired between problems. I do.</p>
<p>This is the paradox: <strong>AI reduces the cost of production but increases the cost of coordination, review, and decision-making. And those costs fall entirely on the human.</strong></p>
<h2>You became a reviewer and you didn&#39;t sign up for it</h2>
<p><img src="https://siddhantkhare.com/blog/ai-fatigue-is-real/3.png" alt="AI dropping code onto a conveyor belt faster than a human can review"/></p>
<p>Before AI, my job was: think about a problem, write code, test it, ship it. I was the creator. The maker. That&#39;s what drew most of us to engineering in the first place - the act of building.</p>
<p>After AI, my job increasingly became: prompt, wait, read output, evaluate output, decide if output is correct, decide if output is safe, decide if output matches the architecture, fix the parts that don&#39;t, re-prompt, repeat. I became a reviewer. A judge. A quality inspector on an assembly line that never stops.</p>
<p>This is a fundamentally different kind of work. Creating is energizing. Reviewing is draining. There&#39;s research on this - the psychological difference between generative tasks and evaluative tasks. Generative work gives you flow states. Evaluative work gives you decision fatigue.</p>
<p>I noticed it first during a week where I was using AI heavily for a new microservice. By Wednesday, I couldn&#39;t make simple decisions anymore. What should this function be named? I didn&#39;t care. Where should this config live? I didn&#39;t care. My brain was full. Not from writing code - from judging code. Hundreds of small judgments, all day, every day.</p>
<p>The cruel irony is that AI-generated code requires more careful review than human-written code. When a colleague writes code, I know their patterns, their strengths, their blind spots. I can skim the parts I trust and focus on the parts I don&#39;t. With AI, every line is suspect. The code looks confident. It compiles. It might even pass tests. But it could be subtly wrong in ways that only surface in production, under load, at 3am.</p>
<p>So you read every line. And reading code you didn&#39;t write, that was generated by a system that doesn&#39;t understand your codebase&#39;s history or your team&#39;s conventions, is exhausting work.</p>
<p>This is also why I think agent security and authorization matter so much. If we can&#39;t review everything AI produces - and we can&#39;t, not at scale - then we need systems that constrain what agents can do in the first place. Least-privilege access, scoped tokens, audit trails. The less you have to worry about &#34;did the AI do something dangerous,&#34; the more cognitive budget you have for the work that actually matters. This isn&#39;t just a security problem. It&#39;s a human sustainability problem.</p>
<h2>The nondeterminism problem</h2>
<p>Engineers are trained on determinism. Same input, same output. That&#39;s the contract. That&#39;s what makes debugging possible. That&#39;s what makes reasoning about systems possible.</p>
<p>AI broke that contract.</p>
<p><img src="https://siddhantkhare.com/blog/ai-fatigue-is-real/4.png" alt="Same prompt, same AI, different results - clean code or spaghetti"/></p>
<p>I had a prompt that worked perfectly on Monday. Generated clean, well-structured code for an API endpoint. I used the same prompt on Tuesday for a similar endpoint. The output was structurally different, used a different error handling pattern, and introduced a dependency I didn&#39;t ask for.</p>
<p>Why? No reason. Or rather, no reason I can access. There&#39;s no stack trace for &#34;the model decided to go a different direction today.&#34; There&#39;s no log that says &#34;temperature sampling chose path B instead of path A.&#34; It just... happened differently.</p>
<p>For someone whose entire career is built on &#34;if it broke, I can find out why,&#34; this is deeply unsettling. Not in a dramatic way. In a slow, grinding, background-anxiety way. You can never fully trust the output. You can never fully relax. Every interaction requires vigilance.</p>
<p>I tried to fight this. I version-controlled my prompts. I built elaborate system messages. I created templates. Some of it helped. None of it solved the fundamental problem: <strong>you are collaborating with a probabilistic system, and your brain is wired for deterministic ones.</strong> That mismatch is a constant, low-grade source of stress.</p>
<p>This frustration is actually what led me to build <a href="https://distill.siddhantkhare.com">Distill</a> - deterministic context deduplication for LLMs. No LLM calls, no embeddings, no probabilistic heuristics. Pure algorithms that clean your context in ~12ms. I wanted at least one part of the AI pipeline to be something I could reason about, debug, and trust. If the model&#39;s output is going to be nondeterministic, the least I can do is make sure the input is clean and predictable.</p>
<p>The engineers I&#39;ve talked to who handle this best are the ones who&#39;ve made peace with it. They treat AI output like a first draft from a smart but unreliable intern. They expect to rewrite 30% of it. They budget time for that rewriting. They don&#39;t get frustrated when the output is wrong because they never expected it to be right. They expected it to be useful. There&#39;s a difference.</p>
<h2>The FOMO treadmill</h2>
<p>Take a breath and try to keep up with just the last few months. Claude Code ships sub-agents, then skills, then an Agent SDK, then Claude Cowork. OpenAI launches Codex CLI, then GPT-5.3-Codex - a model that literally helped code itself. New coding agents announce background mode with hundreds of concurrent autonomous sessions. Google drops Gemini CLI. GitHub adds an MCP Registry. Acquisitions happen weekly. Amazon Q Developer gets agentic upgrades. CrewAI, AutoGen, LangGraph, MetaGPT - pick your agent framework, there&#39;s a new one every week. Google announces A2A (Agent-to-Agent protocol) to compete with Anthropic&#39;s MCP. OpenAI ships its own Swarm framework. Kimi K2.5 drops with agent swarm architecture orchestrating 100 parallel agents. &#34;Vibe coding&#34; becomes a thing. OpenClaw launches a skills marketplace and within one week, researchers find 400+ malicious agent skills uploaded to ClawHub. And somewhere in the middle of all this, someone on LinkedIn posts &#34;if you&#39;re not using AI agents with sub-agent orchestration in 2026, you&#39;re already obsolete.&#34;</p>
<p>That&#39;s not a year. That&#39;s a few months. And I&#39;m leaving stuff out.</p>
<p>I fell into this trap hard. I was spending weekends evaluating new tools. Reading every changelog. Watching every demo. Trying to stay at the frontier because I was terrified of falling behind.</p>
<p>Here&#39;s what that actually looked like: I&#39;d spend Saturday afternoon setting up a new AI coding tool. By Sunday I&#39;d have a basic workflow. By the following Wednesday, someone would post about a different tool that was &#34;way better.&#34; I&#39;d feel a pang of anxiety. By the next weekend, I&#39;d be setting up the new thing. The old thing would sit unused. One coding assistant to the next to the next and back to the first one. Each migration cost me a weekend and gave me maybe a 5% improvement that I couldn&#39;t even measure properly.</p>
<p>Multiply this by every category - coding assistants, chat interfaces, agent frameworks, multi-agent orchestration platforms, MCP servers, context management tools, prompt libraries, swarm architectures, skills marketplaces - and you get a person who is perpetually learning new tools and never getting deep with any of them. The Hacker News front page alone is enough to give you whiplash. One day it&#39;s &#34;Show HN: Autonomous Research Swarm&#34; and the next it&#39;s &#34;Ask HN: How will AI swarms coordinate?&#34; Nobody knows. Everyone&#39;s building anyway.</p>
<p>The worst part is the knowledge decay. I spent two weeks building a sophisticated prompt engineering workflow in early 2025. Carefully crafted system prompts, few-shot examples, chain-of-thought templates. It worked well. Three months later, the model updated, the prompting best practices shifted, and half my templates produced worse results than a simple one-liner. Those two weeks were gone. Not invested. Spent. The same thing happened with my MCP server setup - I built five custom servers (Dev.to publisher, Apple Notes integration, Python and TypeScript sandboxes, more), then the protocol evolved, then the MCP Registry launched on GitHub and suddenly there were thousands of pre-built ones. Some of my custom work became redundant overnight.</p>
<p>The agent framework churn is even worse. I watched teams go from LangChain to CrewAI to AutoGen to custom orchestration in the span of a year. Each migration meant rewriting integrations, relearning APIs, rebuilding workflows. The people who waited and did nothing often ended up in a better position than the people who adopted early and had to migrate twice.</p>
<p>I&#39;ve since adopted a different approach. Instead of chasing every new tool, I go deep on the infrastructure layer underneath them. Tools come and go. The problems they solve don&#39;t. Context efficiency, agent authorization, audit trails, runtime security - these are durable problems regardless of which framework is trending this month. That&#39;s why I built <a href="https://github.com/Siddhant-K-code/agentic-authz">agentic-authz</a> on OpenFGA instead of tying it to any specific agent framework. That&#39;s why Distill works at the context level, not the prompt level. Build on the layer that doesn&#39;t churn.</p>
<p>I still track the landscape closely - you have to when you&#39;re building infrastructure for it. But I track it to understand where the ecosystem is going, not to adopt every new thing. There&#39;s a difference between being informed and being reactive.</p>
<h2>The &#34;just one more prompt&#34; trap</h2>
<p>This one is insidious. You&#39;re trying to get AI to generate something specific. The first output is 70% right. So you refine your prompt. The second output is 75% right but broke something the first one had correct. Third attempt: 80% right but now the structure is different. Fourth attempt: you&#39;ve been at this for 45 minutes and you could have written the thing from scratch in 20.</p>
<p>I call this the prompt spiral. It&#39;s the AI equivalent of yak shaving. You started with a clear goal. Thirty minutes later you&#39;re debugging your prompt instead of debugging your code. You&#39;re optimizing your instructions to a language model instead of solving the actual problem.</p>
<p>The prompt spiral is especially dangerous because it feels productive. You&#39;re iterating. You&#39;re getting closer. Each attempt is slightly better. But the marginal returns are diminishing fast, and you&#39;ve lost sight of the fact that the goal was never &#34;get the AI to produce perfect output.&#34; The goal was to ship the feature.</p>
<p>I now have a hard rule: three attempts. If the AI doesn&#39;t get me to 70% usable in three prompts, I write it myself. No exceptions. This single rule has saved me more time than any prompting technique I&#39;ve ever learned.</p>
<h2>Perfectionism meets probabilistic output</h2>
<p>Engineers tend toward perfectionism. We like clean code. We like tests that pass. We like systems that behave predictably. This is a feature, not a bug - it&#39;s what makes us good at building reliable software.</p>
<p>AI output is never perfect. It&#39;s always &#34;pretty good.&#34; 70-80% there. The variable names are slightly off. The error handling is incomplete. The edge cases are ignored. The abstraction is wrong for your codebase. It works, but it&#39;s not right.</p>
<p>For a perfectionist, this is torture. Because &#34;almost right&#34; is worse than &#34;completely wrong.&#34; Completely wrong, you throw away and start over. Almost right, you spend an hour tweaking. And tweaking AI output is uniquely frustrating because you&#39;re fixing someone else&#39;s design decisions - decisions that were made by a system that doesn&#39;t share your taste, your context, or your standards.</p>
<p>I had to learn to let go. Not of quality - I still care about quality. But of the expectation that AI would produce quality. I now treat every AI output as a rough draft. A starting point. Raw material. I mentally label it &#34;draft&#34; the moment it appears, and that framing change alone reduced my frustration by half.</p>
<p>The engineers who struggle most with AI are often the best engineers. The ones with the highest standards. The ones who notice every imperfection. AI rewards a different skill: the ability to extract value from imperfect output quickly, without getting emotionally invested in making it perfect.</p>
<h2>The thinking atrophy</h2>
<p><img src="https://siddhantkhare.com/blog/ai-fatigue-is-real/5.png" alt="A brain on a couch watching AI, its thinking muscles covered in cobwebs"/></p>
<p>This is the one that scares me most.</p>
<p>I noticed it during a design review meeting. Someone asked me to reason through a concurrency problem on the whiteboard. No laptop. No AI. Just me and a marker. And I struggled. Not because I didn&#39;t know the concepts - I did. But because I hadn&#39;t exercised that muscle in months. I&#39;d been outsourcing my first-draft thinking to AI for so long that my ability to think from scratch had degraded.</p>
<p>It&#39;s like GPS and navigation. Before GPS, you built mental maps. You knew your city. You could reason about routes. After years of GPS, you can&#39;t navigate without it. The skill atrophied because you stopped using it.</p>
<p>The same thing is happening with AI and engineering thinking. When you always ask AI first, you stop building the neural pathways that come from struggling with a problem yourself. The struggle is where learning happens. The confusion is where understanding forms. Skip that, and you get faster output but shallower understanding.</p>
<p>I now deliberately spend the first hour of my day without AI. I think on paper. I sketch architectures by hand. I reason through problems the slow way. It feels inefficient. It is inefficient. But it keeps my thinking sharp, and that sharpness pays dividends for the rest of the day when I do use AI - because I can evaluate its output better when my own reasoning is warmed up.</p>
<h2>The comparison trap</h2>
<p>Social media is full of people who seem to have AI figured out. They post their workflows. Their productivity numbers. Their &#34;I built this entire app in 2 hours with AI&#34; threads. And you look at your own experience - the failed prompts, the wasted time, the code you had to rewrite - and you think: what&#39;s wrong with me?</p>
<p>Nothing is wrong with you. Those threads are highlight reels. Nobody posts &#34;I spent 3 hours trying to get Claude to understand my database schema and eventually gave up and wrote the migration by hand.&#34; Nobody posts &#34;AI-generated code caused a production incident because it silently swallowed an error.&#34; Nobody posts &#34;I&#39;m tired.&#34;</p>
<p>The comparison trap is amplified by the fact that AI skill is hard to measure. With traditional engineering, you can look at someone&#39;s code and roughly gauge their ability. With AI, the output depends on the model, the prompt, the context, the temperature, the phase of the moon. Someone&#39;s impressive demo might not reproduce on your machine with your codebase.</p>
<p>I became much more selective about AI content on social media. I still follow the space closely - I have to, it&#39;s my job. But I shifted from consuming everyone&#39;s hot takes to focusing on people who are actually building and shipping, not just demoing. The ratio of signal to anxiety matters. If a feed is making you feel behind instead of informed, it&#39;s not serving you.</p>
<h2>What actually helped</h2>
<p>I&#39;ll be specific about what changed my relationship with AI from adversarial to sustainable.</p>
<p><strong>Time-boxing AI sessions.</strong> I don&#39;t use AI in an open-ended way anymore. I set a timer. 30 minutes for this task with AI. When the timer goes off, I ship what I have or switch to writing it myself. This prevents the prompt spiral and the perfectionism trap simultaneously.</p>
<p><strong>Separating AI time from thinking time.</strong> Morning is for thinking. Afternoon is for AI-assisted execution. This isn&#39;t rigid - sometimes I break the rule. But having a default structure means my brain gets both exercise and assistance in the right proportions.</p>
<p><strong>Accepting 70% from AI.</strong> I stopped trying to get perfect output. 70% usable is the bar. I&#39;ll fix the rest myself. This acceptance was the single biggest reducer of AI-related frustration in my workflow.</p>
<p><strong>Being strategic about the hype cycle.</strong> I track the AI landscape because I build infrastructure for it. But I stopped adopting every new tool the week it launches. I use one primary coding assistant and know it deeply. I evaluate new tools when they&#39;ve proven themselves over months, not days. Staying informed and staying reactive are different things.</p>
<p><strong>Logging where AI helps and where it doesn&#39;t.</strong> I kept a simple log for two weeks: task, used AI (yes/no), time spent, satisfaction with result. The data was revealing. AI saved me significant time on boilerplate, documentation, and test generation. It cost me time on architecture decisions, complex debugging, and anything requiring deep context about my codebase. Now I know when to reach for it and when not to.</p>
<p><strong>Not reviewing everything AI produces.</strong> This was hard to accept. But if you&#39;re using AI to generate large amounts of code, you physically cannot review every line with the same rigor. I focus my review energy on the parts that matter most - security boundaries, data handling, error paths - and rely on automated tests and static analysis for the rest. Some roughness in non-critical code is acceptable.</p>
<h2>The sustainability question</h2>
<p>The tech industry has a burnout problem that predates AI. AI is making it worse, not better. Not because AI is bad, but because AI removes the natural speed limits that used to protect us.</p>
<p>Before AI, there was a ceiling on how much you could produce in a day. That ceiling was set by typing speed, thinking speed, the time it takes to look things up. It was frustrating sometimes, but it was also a governor. You couldn&#39;t work yourself to death because the work itself imposed limits.</p>
<p>AI removed the governor. Now the only limit is your cognitive endurance. And most people don&#39;t know their cognitive limits until they&#39;ve blown past them.</p>
<p>I burned out in late 2025. Not dramatically - I didn&#39;t quit or have a breakdown. I just stopped caring. Code reviews became rubber stamps. Design decisions became &#34;whatever AI suggests.&#34; I was going through the motions, producing more than ever, feeling less than ever. It took me a month to realize what had happened and another month to recover.</p>
<p>The recovery wasn&#39;t about using less AI. It was about using AI differently. With boundaries. With intention. With the understanding that I am not a machine and I don&#39;t need to keep pace with one. Working at <a href="https://ona.com">Ona</a> helped me see this clearly - when you&#39;re building AI agent infrastructure for enterprise customers, you see the human cost of unsustainable AI workflows at scale. The problems aren&#39;t just personal. They&#39;re systemic. And they need to be solved at the tooling level, not just the individual level.</p>
<p>Ironically, the burnout period is when some of my best work happened. When I stopped trying to use every AI tool and started thinking about what was actually broken, I saw the problems clearly for the first time. Context windows filling up with garbage - that became Distill. Agents with all-or-nothing API key access - that became agentic-authz. The inability to audit what an agent actually did - that&#39;s becoming AgentTrace. The fatigue forced me to stop consuming and start building. Not building more features faster, but building the right things deliberately.</p>
<h2>The real skill</h2>
<p>Here&#39;s what I think the real skill of the AI era is. It&#39;s not prompt engineering. It&#39;s not knowing which model to use. It&#39;s not having the perfect workflow.</p>
<p>It&#39;s knowing when to stop.</p>
<p><img src="https://siddhantkhare.com/blog/ai-fatigue-is-real/6.png" alt="A hand pulling the STOP switch - good enough, ship it, go outside, rest"/></p>
<p>Knowing when the AI output is good enough. Knowing when to write it yourself. Knowing when to close the laptop. Knowing when the marginal improvement isn&#39;t worth the cognitive cost. Knowing that your brain is a finite resource and that protecting it is not laziness - it&#39;s engineering.</p>
<p>We optimize our systems for sustainability. We add circuit breakers. We implement backpressure. We design for graceful degradation. We should do the same for ourselves.</p>
<p>AI is the most powerful tool I&#39;ve ever used. It&#39;s also the most draining. Both things are true. The engineers who thrive in this era won&#39;t be the ones who use AI the most. They&#39;ll be the ones who use it the most wisely.</p>
<p>If you&#39;re tired, it&#39;s not because you&#39;re doing it wrong. It&#39;s because this is genuinely hard. The tool is new, the patterns are still forming, and the industry is pretending that more output equals more value. It doesn&#39;t. Sustainable output does.</p>
<p>I&#39;m still building in this space every day. Agent authorization, context engineering, audit trails, runtime security - the infrastructure that makes AI agents actually work in production. I&#39;m more committed to AI than ever. But I&#39;m committed on my terms, at my pace, building things that matter instead of chasing things that trend.</p>
<p>Take care of your brain. It&#39;s the only one you&#39;ve got, and no AI can replace it.</p>
<hr/>
<p><em>I write about AI agent infrastructure, security, context engineering, and the human side of building with AI. You can find all my writing on my <a href="https://siddhantkhare.com/writing">writing page</a>.</em></p>
<!----></article></div>
  </body>
</html>
