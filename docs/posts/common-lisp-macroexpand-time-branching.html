<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mov.im/?blog/phoe%40movim.eu/f76c3cd8-8d55-409a-9827-c1b345e8e3ad">Original</a>
    <h1>Common Lisp: Macroexpand-time branching</h1>
    
    <div id="readability-page-1" class="page"><section dir="ltr">
    <div>
        
        
            <div><p><a href="https://mov.im/?tag/CommonLisp">#CommonLisp</a> <a href="https://mov.im/?tag/Lisp">#Lisp</a></p><p>Let&#39;s consider the following function:</p><pre><code>(defun make-adder (x huge-p)
  (lambda (y) (+ x y (if huge-p 1000 0))))
</code></pre><p>The result of calling <code>(MAKE-ADDER 10)</code> closes over <code>HUGE-P</code> and makes a runtime check for its value.</p><pre><code>CL-USER&gt; (disassemble (make-adder 10 nil))
; disassembly for (LAMBDA (Y) :IN MAKE-ADDER)
; Size: 65 bytes. Origin: <a href="https://mov.im/?tag/x53730938">#x53730938</a>                          ; (LAMBDA (Y) :IN MAKE-ADDER)
; 38:       488975F8         MOV [RBP-8], RSI
; 3C:       488BD3           MOV RDX, RBX
; 3F:       E8EC012DFF       CALL <a href="https://mov.im/?tag/x52A00B30">#x52A00B30</a>                  ; GENERIC-+
; 44:       488B75F8         MOV RSI, [RBP-8]
; 48:       4881FE17011050   CMP RSI, <a href="https://mov.im/?tag/x50100117">#x50100117</a>              ; NIL
; 4F:       BFD0070000       MOV EDI, 2000
; 54:       B800000000       MOV EAX, 0
; 59:       480F44F8         CMOVEQ RDI, RAX
; 5D:       E8CE012DFF       CALL <a href="https://mov.im/?tag/x52A00B30">#x52A00B30</a>                  ; GENERIC-+
; 62:       488BE5           MOV RSP, RBP
; 65:       F8               CLC
; 66:       5D               POP RBP
; 67:       C3               RET
; 68:       CC10             INT3 16                          ; Invalid argument count trap
; 6A:       6A20             PUSH 32
; 6C:       E8FFFA2CFF       CALL <a href="https://mov.im/?tag/x52A00470">#x52A00470</a>                  ; ALLOC-TRAMP
; 71:       5B               POP RBX
; 72:       E958FFFFFF       JMP <a href="https://mov.im/?tag/x537308CF">#x537308CF</a>
; 77:       CC10             INT3 16                          ; Invalid argument count trap
NIL
</code></pre><p>It would be better for performance if the test was only made once, in <code>MAKE-ADDER</code>, rather than on every call of the adder closure. <code>MAKE-ADDER</code> could then return one of two functions depending on whether the check succeeds.</p><pre><code>(defun make-adder (x huge-p)
  (if huge-p
      (lambda (y) (+ x y 1000))
      (lambda (y) (+ x y 0))))
</code></pre><p>A brief look at the disassembly of this fixed version shows us that we&#39;re right:</p><pre><code>CL-USER&gt; (disassemble (make-adder 10 nil))
; disassembly for (LAMBDA (Y) :IN MAKE-ADDER)
; Size: 21 bytes. Origin: <a href="https://mov.im/?tag/x53730BC7">#x53730BC7</a>                          ; (LAMBDA (Y) :IN MAKE-ADDER)
; C7:       488BD1           MOV RDX, RCX
; CA:       E861FF2CFF       CALL <a href="https://mov.im/?tag/x52A00B30">#x52A00B30</a>                  ; GENERIC-+
; CF:       31FF             XOR EDI, EDI
; D1:       E85AFF2CFF       CALL <a href="https://mov.im/?tag/x52A00B30">#x52A00B30</a>                  ; GENERIC-+
; D6:       488BE5           MOV RSP, RBP
; D9:       F8               CLC
; DA:       5D               POP RBP
; DB:       C3               RET
NIL
</code></pre><p>Still, with more flags than one, this style of writing code is likely to become unwieldy. For three flags, we would need to write something like this for the runtime version:</p><pre><code>(defun make-adder (x huge-p enormous-p humongous-p)
  (lambda (y) (+ x y
                 (if huge-p 1000 0)
                 (if enormous-p 2000 0)
                 (if humongous-p 3000 0))))
</code></pre><p>But it would look like this for the macroexpand-time version:</p><pre><code>(defun make-adder (x huge-p enormous-p humongous-p)
  (if huge-p
      (if enormous-p
          (if humongous-p
              (lambda (y) (+ x y 1000 2000 3000))
              (lambda (y) (+ x y 1000 2000 0)))
          (if humongous-p
              (lambda (y) (+ x y 1000 0 3000))
              (lambda (y) (+ x y 1000 0 0))))
      (if enormous-p
          (if humongous-p
              (lambda (y) (+ x y 0 2000 3000))
              (lambda (y) (+ x y 0 2000 0)))
          (if humongous-p
              (lambda (y) (+ x y 0 0 3000))
              (lambda (y) (+ x y 0 0 0))))))
</code></pre><p>The total number of combinations for <code>n</code> boolean flags is <code>2^n</code>, making it hard to write and maintain code with so many branches. This is where <code>WITH-MACROEXPAND-TIME-BRANCHING</code> comes into play. Using it, we can write our code in a way that looks similar to the runtime-check version:</p><pre><code>(defun make-adder (x huge-p enormous-p humongous-p)
  (with-macroexpand-time-branching (huge-p enormous-p humongous-p)
    (lambda (y) (+ x y
                   (macroexpand-time-if huge-p 1000 0)
                   (macroexpand-time-if enormous-p 2000 0)
                   (macroexpand-time-if humongous-p 3000 0)))))
</code></pre><p>This code gives us the clarity of runtime-checked version and the performance of a macroexpand-time-checked version. A total of eight versions of the body (and therefore, eight possible <code>LAMBDA</code> forms) are generated. At runtime, only one of them is selected, based on the boolean values of the three flags we provided.</p><p>Three conditional operators are provided - <code>MACROEXPAND-TIME-IF</code>, <code>MACROEXPAND-TIME-WHEN</code>, and <code>MACROEXPAND-TIME-UNLESS</code>, mimicking the syntax of, respectively, <code>IF</code>, <code>WHEN</code>, and <code>UNLESS</code>.</p><p>It is possible to use the variable <code>*MACROEXPAND-TIME-BRANCH-BYPASS*</code> for bypassing macroexpand-time branching; this is useful e.g. when trying to read the macroexpansions or when debugging. If that variable is set to true, the behavior of the macroexpander is modified:</p><ul><li><code>WITH-MACROEXPAND-TIME-BRANCHING</code> expands into a <code>PROGN</code> form,</li><li><code>MACROEXPAND-TIME-IF</code> expands into an <code>IF</code> form,</li><li><code>MACROEXPAND-TIME-WHEN</code> expands into a <code>WHEN</code> form,</li><li><code>MACROEXPAND-TIME-UNLESS</code> expands into an <code>UNLESS</code> form.</li></ul><p>Trying to use <code>MACROEXPAND-TIME-IF</code>, <code>MACROEXPAND-TIME-WHEN</code>, or <code>MACROEXPAND-TIME-UNLESS</code> outside the lexical environment established by <code>WITH-MACROEXPAND-TIME-BRANCHES</code> will signal a <code>PROGRAM-ERROR</code>.</p><p>Trying to use a branch name <code>MACROEXPAND-TIME-IF</code>, <code>MACROEXPAND-TIME-WHEN</code>, or <code>MACROEXPAND-TIME-UNLESS</code> that wasn&#39;t declared in <code>WITH-MACROEXPAND-TIME-BRANCHES</code> will signal a <code>PROGRAM-ERROR</code>.</p><hr/><p>Grab the code from <a href="https://github.com/phoe/with-macroexpand-time-branching">GitHub</a>.</p></div>
        
    </div>
</section></div>
  </body>
</html>
