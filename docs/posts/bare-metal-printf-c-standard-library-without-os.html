<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://popovicu.com/posts/bare-metal-printf/">Original</a>
    <h1>Bare metal printf – C standard library without OS</h1>
    
    <div id="readability-page-1" class="page"><article id="article" role="article">
      <p><a href="https://twitter.com/popovicu94?ref_src=twsrc%5Etfw" data-show-count="false">Follow @popovicu94</a></p>
<p>Today we’ll take a look at how we can leverage Newlib to create a compact C standard library for usage on a bare metal system. In a small example, we’ll implement a few UART primitives and pass them on to Newlib which uses them as the building blocks for a full-blown <code>printf</code> functionality. The target platform will be RISC-V, but the concepts should, as usual, be the same for other platforms as well.</p>
<h2 id="table-of-contents">Table of contents</h2>
<details><summary>Open Table of contents</summary>
<ul>
<li>
<p><a href="#software-abstractions-and-c-standard-library">Software abstractions and C standard library</a></p>
</li>
<li>
<p><a href="#c-standard-library-on-bare-metal">C standard library on bare metal</a></p>
<ul>
<li><a href="#newlib-concept">Newlib concept</a></li>
</ul>
</li>
<li>
<p><a href="#cross-compilation-toolchain">Cross-compilation toolchain</a></p>
<ul>
<li><a href="#toolchain-details">Toolchain details</a></li>
<li><a href="#automated-risc-v-toolchain-build">Automated RISC-V toolchain build</a></li>
</ul>
</li>
<li>
<p><a href="#github-link">GitHub link</a></p>
</li>
<li>
<p><a href="#implementing-the-memory-and-uart-building-blocks">Implementing the memory and UART building blocks</a></p>
</li>
<li>
<p><a href="#application-example-input-and-output">Application example: input and output</a></p>
<ul>
<li><a href="#the-gotcha-moment">The ‘gotcha’ moment</a></li>
</ul>
</li>
<li>
<p><a href="#running-the-app">Running the app</a></p>
</li>
<li>
<p><a href="#conclusion">Conclusion</a></p>
</li>
</ul>
</details>
<h2 id="software-abstractions-and-c-standard-library">Software abstractions and C standard library</h2>
<p>When running <code>printf</code> on a typical, fully operational, end-user system (e.g., a Mac or a Linux laptop), we invoke a pretty complex machinery. The application process calls the <code>printf</code> function, which is more often than not dynamically linked, and after a few layers of different C functions, a system call to the operating system kernel is typically invoked. The kernel will route the output through different subsystems: different terminal and pseudo-terminal primitives will be invoked, and at some point, you will also want to visually see the <code>printf</code> output on your screen. That also likely invokes a pretty thick stack of abstractions in order to render the characters on your screen. We won’t even talk about how <code>printf</code> formats the output strings based on the provided templates.</p>
<p>On a bare metal system, however, most of these abstractions are not available at all and the stack is much thinner.</p>

<p>If we’re working on bare metal, we don’t have anything below our C functions supporting us. In the full-blown example above, the process would hand over the output to the kernel through system calls, which are implemented through software interrupts. However, now we don’t have anything to hand over to, yet we want to have something like <code>printf</code> working, ideally outputting to a simple I/O device like UART.</p>
<p>This is where Newlib jumps in. You’re probably familiar with different flavors of C standard library like GNU (<code>glibc</code>), <code>musl</code> and so on, but Newlib should definitely be on your radar if you’d like to enable C standard library on bare metal.</p>
<p>More accurately, the way I think about Newlib is not as a C standard library, but rather as <strong>a kit to build a custom, compact C standard library</strong>.</p>
<h3 id="newlib-concept">Newlib concept</h3>
<p>Rather than requiring you to implement the whole C standard library from scratch, Newlib boils down the implementation to a few very basic primitives with clean interfaces that can be implemented as separate functions, and then other more complex functions like <code>printf</code> and <code>malloc</code> will call these primitives. Just for intuition, we will be implementing primitives like <code>_write</code> which essentially writes a single character to the output stream, and Newlib builds <code>printf</code> on top of that in order to write more complex outputs.</p>
<p>In addition to providing this simple set of primitives to implement, Newlib also gives reasonable pre-cooked implementations as well. In one of the configurations, you can even still target Linux as the underlying platform instead of bare metal, and the provided implementation will do system calls like <code>glibc</code> would do. Also, if you’re going for the absolutely minimal config, Newlib will provide all the primitives in a minimal form where they just return zeroes or raise an error (equivalent to something like raising an unimplemented exception in Python or Java).</p>
<p>Either way, you will implement whatever building blocks you actually care about in your application and the rest would rely on the default implementation.</p>

<p>Let’s switch gears here and talk about the cross-compilation toolchains. Cross-compilation happens when you compile from one platform to another. Intuitively, you can think of something like cross-compiling from an x86_64/Linux platform to ARM64/Mac.</p>
<p>On platforms like Linux, though, things can get a lot more nuanced, as Linux platform doesn’t necessarily mean one flavor of C standard library, so I’d refer to these platforms more accurately as x86_64/Linux/glibc. When you look at platforms from that perspective, even compiling from a platform with one standard library to another on the same x86_64/Linux setup, but with a different C library, you are effectively still cross-compiling. A concrete example would be cross-compiling from x86_64/Linux/glibc to x86_64/Linux/musl.</p>
<p>Furthermore, if you want to be extremely accurate and disciplined (as you should be if you want to build software that doesn’t break!), even building from one version of <code>glibc</code> for another is really cross-compiling. Again, as an example, building from x86_64/Linux/glibc_v1.0 for x86_64/Linux/glibc_v1.1 is cross-compilation.</p>
<p>This can quickly get difficult, at least with the traditional way of building and using compilers (such as GCC, for example); however, those “ancient” ways are still stuck with us for the foreseeable future. I will soon write in more detail about this, and for now, we’ll use a shortcut described below.</p>
<h3 id="toolchain-details">Toolchain details</h3>
<p>We want a toolchain that satisfies two requirements:</p>
<ol>
<li>it builds from our host platform to RISC-V, i.e. it generates RISC-V instructions</li>
<li>it uses the Newlib library when C standard library functionality is invoked</li>
</ol>
<p>If you’re on a typical Linux distribution, you likely have something like GCC (or even clang) installed. When you simply run GCC on a C file without any fancy flags, what happens is that the compiler will simply build for the same platform it runs on. More accurately, the host and the target are the same, and I believe the formal term for this is <em>native compilation</em>. The reason why I bring this up is to ask ourselves what happens when we include something like <code>stdio.h</code> and call something like <code>printf</code>? Where is this <code>.h</code> file really pulled from and where is ultimately the <code>printf</code> implementation found so it can be linked against?</p>
<p>This really depends on <strong>the way your compiler was built</strong>. When you build GCC from source, and you run <code>./configure</code>, you can specify a ton of flags that will drive this behavior. As promised, I will write more about it in the future. For now, let’s keep in mind that most Linux distributions we use in daily lives follow the old UNIX philosophy when it comes to this. For example, my Debian installation has <code>stdio.h</code> in a standard directory at <code>/usr/include</code>. Furthermore, my standard C library (<code>glibc</code>) that can be dynamically linked is at <code>/lib/x86_64-linux-gnu/libc.so</code> (which really points to <code>/lib/x86_64-linux-gnu/libc.so.6</code>). Similarly, there is an <code>.a</code> file in there, but I will assume you know what <code>.so</code> and <code>.a</code> files are for. So, long story short, skipping a lot of details, your native compiler is set up to look for the C library in some of the standard spots, and when it builds for the same platform, it simply picks up the libraries from there.</p>
<p>Therefore, we need to:</p>
<ol>
<li>get the compiler that can generate instructions for the desired platform (machine code)</li>
<li>set up the C standard library for that particular platform somewhere</li>
<li>ensure that the compiler for the target platform knows how to use the library from above</li>
</ol>
<p>From what I’ve seen, when it comes to cross-compilation, this is a fair amount of grungy work that needs to be done. The set up above takes a lot of building time and needs to be done in stages when done properly. A future article will go into details, but for now, as we mentioned before, we’ll go for a shortcut.</p>
<p>Remember for now that we want the includes, <code>.so</code>/<code>.a</code> files at some path, and we want the cross-compiler to look <strong>there</strong> for the C standard library, not at the host’s <code>include</code> and <code>lib</code> directories. In this case since we want to build from something like x86_64 to RISC-V, it’s easy to spot errors, since if we use the host’s libraries, there is no way the wrong architecture would work, but when compiling for the same architecture and a different software platform, host contamination can be a real thing and can lead to very subtle and annoying problems! For example, we want the library code to be searched for at <code>/usr/local/risc_v_stuff/lib</code> instead of <code>/usr/lib</code>.</p>
<h3 id="automated-risc-v-toolchain-build">Automated RISC-V toolchain build</h3>
<p>For this exercise, let’s simply use the <a href="https://github.com/riscv-collab/riscv-gnu-toolchain/">RISC-V toolchain</a>. This project will still build everything from source on our host machine, but the whole annoying orchestration mentioned above, including staging the compilers, will be scripted and automated for us. With a few commands, we’ll kick off the process that will effectively set up something like <code>/usr/local/risc_v_stuff/lib</code>, <code>/usr/local/risc_v_stuff/include</code>, <code>/usr/local/risc_v_stuff/compiler</code> and you’ll be able to invoke <code>/usr/local/risc_v_stuff/compiler/gcc</code> which will know to peek into the right directories for different files and will build the right machine code. Of course, the paths will ultimately be different, but this should be good enough as a concept.</p>
<p>We can start by cloning the Git repository linked above. The instructions say that the <code>--recursive</code> flag is not necessary during cloning and things will be dynamically pulled later, but for whatever reason, this <strong>did not</strong> work on my system. I ended up running a clone with the <code>--recursive</code> flag to avoid issues. It took a lot of time and space though, pulling in gigabytes and gigabytes of source code.</p>
<p>Once the endless clone is done, you can configure the build. This is how I configured it:</p>
<pre is:raw="" tabindex="0"><code><span><span>./configure --prefix=/opt/riscv-newlib --enable-multilib --disable-gdb --with-cmodel=medany</span></span></code></pre>
<p>I strongly encourage you to run <code>./configure --help</code> to see what all the available options are and customize the build. For now, I will explain my parameters:</p>
<ol>
<li><code>prefix</code> is simply where we’ll install the newly built artifacts, such as the cross-compiler, C standard library (Newlib in our case) and so on.</li>
<li><code>enable-multilib</code> will enable builds for different RISC-V setups. As a reminder, RISC-V has a ton of flavors, like <code>RV32I</code>, <code>RV32IMA</code> and so on. Please do note that enabling this flag will make your build <strong>super slow</strong>. If you don’t want to run the build with multilib, then check the help menu to figure out how to build exactly for the fine grained platform that you need.</li>
<li><code>disable-gdb</code>: for whatever reason, building GDB would always fail for me, so I just excluded it from the toolchain. Real engineers debug with <code>printf</code> anyway!</li>
<li><code>with-cmodel</code>: hold on to this one, I will reveal this in a ‘gotcha’ moment; for now, let’s just keep in mind I needed this in order to make the 64-bit RISC-V builds work.</li>
</ol>
<p>Now that your build is configured, you can fire off the build process and leave it cooking for quite some time. One thing that surprised me here is that they didn’t use separate <code>make</code> and <code>make install</code> steps. Everything is done through just <code>make</code>, both the compilation and installation of the artifacts.</p>
<p><strong>Note: I wanted to parallelize the build with <code>-j16</code> as I normally do, but that also somehow broke my build, so I suggest running without this, and yes, I know it takes forever.</strong></p>
<p>I simply ran</p>
<pre is:raw="" tabindex="0"><code><span><span>sudo make</span></span></code></pre>
<p>in order to place the final artifacts in the <code>/opt</code> directory. This whole process is very slow, so make sure you have something else to do while this is working.</p>
<p>Also, you may wonder where Newlib comes in here, when I mentioned that this whole process will automate how we get Newlib available. The answer is that Newlib is simply the default option for building our toolchain here. You can check the GitHub documentation on how to set up your cross-compiler to target a RISC-V <code>glibc</code> or <code>musl</code>, but what I’ve listed above is good enough to get a cross-compiler with Newlib as the target.</p>
<h2 id="github-link">GitHub link</h2>
<p>I have prepared <a href="https://github.com/popovicu/bare-metal-cstdlib">this repository</a> to run our example. The code explanations are below (hopefully they’re not out of sync with the repo itself).</p>
<h2 id="implementing-the-memory-and-uart-building-blocks">Implementing the memory and UART building blocks</h2>
<p>Now that you have a working cross-toolchain targeting RISC-V + Newlib, most of the heavy lifting is done and we can start putting together the Newlib building blocks. Let’s begin with UART, and the first file is <code>uart.h</code>:</p>
<pre is:raw="" tabindex="0"><code><span><span>#ifndef</span><span> </span><span>UART_H</span></span>
<span><span>#define</span><span> </span><span>UART_H</span></span>
<span></span>
<span><span>void</span><span> </span><span>uart_putc</span><span>(</span><span>char</span><span> </span><span>c</span><span>);</span></span>
<span><span>char</span><span> </span><span>uart_getc</span><span>(</span><span>void</span><span>);</span></span>
<span></span>
<span><span>#endif</span></span></code></pre>
<p>This is self-explanatory so far. Let’s see how these functions are implemented:</p>
<pre is:raw="" tabindex="0"><code><span><span>#include</span><span> </span><span>&#34;uart.h&#34;</span></span>
<span></span>
<span><span>// QEMU UART registers - these addresses are for QEMU&#39;s 16550A UART</span></span>
<span><span>#define</span><span> </span><span>UART_BASE</span><span> </span><span>0x</span><span>10000000</span></span>
<span><span>#define</span><span> </span><span>UART_THR</span><span>  (</span><span>*</span><span>(</span><span>volatile</span><span> </span><span>char</span><span> </span><span>*</span><span>)(UART_BASE </span><span>+</span><span> </span><span>0x</span><span>00</span><span>))</span><span> // Transmit Holding Register</span></span>
<span><span>#define</span><span> </span><span>UART_RBR</span><span>  (</span><span>*</span><span>(</span><span>volatile</span><span> </span><span>char</span><span> </span><span>*</span><span>)(UART_BASE </span><span>+</span><span> </span><span>0x</span><span>00</span><span>))</span><span> // Receive Buffer Register</span></span>
<span><span>#define</span><span> </span><span>UART_LSR</span><span>  (</span><span>*</span><span>(</span><span>volatile</span><span> </span><span>char</span><span> </span><span>*</span><span>)(UART_BASE </span><span>+</span><span> </span><span>0x</span><span>05</span><span>))</span><span> // Line Status Register</span></span>
<span></span>
<span><span>#define</span><span> </span><span>UART_LSR_TX_IDLE</span><span>  (</span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>5</span><span>)</span><span> // Transmitter idle</span></span>
<span><span>#define</span><span> </span><span>UART_LSR_RX_READY</span><span> (</span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>0</span><span>)</span><span> // Receiver ready</span></span>
<span></span>
<span><span>void</span><span> </span><span>uart_putc</span><span>(</span><span>char</span><span> c)</span><span> {</span></span>
<span><span>    </span><span>// Wait until transmitter is idle</span></span>
<span><span>    </span><span>while</span><span> ((UART_LSR </span><span>&amp;</span><span> UART_LSR_TX_IDLE) </span><span>==</span><span> </span><span>0</span><span>);</span></span>
<span><span>    UART_THR </span><span>=</span><span> c;</span></span>
<span></span>
<span><span>    </span><span>// Special handling for newline (send CR+LF)</span></span>
<span><span>    </span><span>if</span><span> (c </span><span>==</span><span> </span><span>&#39;</span><span>\n</span><span>&#39;</span><span>) {</span></span>
<span><span>        </span><span>while</span><span> ((UART_LSR </span><span>&amp;</span><span> UART_LSR_TX_IDLE) </span><span>==</span><span> </span><span>0</span><span>);</span></span>
<span><span>        UART_THR </span><span>=</span><span> </span><span>&#39;</span><span>\r</span><span>&#39;</span><span>;</span></span>
<span><span>    }</span></span>
<span><span>}</span></span>
<span></span>
<span><span>char</span><span> </span><span>uart_getc</span><span>(</span><span>void</span><span>) {</span></span>
<span><span>    </span><span>// Wait for data</span></span>
<span><span>    </span><span>while</span><span> ((UART_LSR </span><span>&amp;</span><span> UART_LSR_RX_READY) </span><span>==</span><span> </span><span>0</span><span>);</span></span>
<span><span>    </span><span>return</span><span> UART_RBR;</span></span>
<span><span>}</span></span></code></pre>
<p>The code above was AI-generated, but it’s accurate. And this is it as far as our UART driver is concerned. How does that now work with Newlib?</p>
<p>We switch to the file called <code>syscalls.c</code>. Here, we implement the functions that <code>printf</code> would rely on. We’ll also handle the input as well, just for fun. First, what happens here is we implement the primitives for writing to a file handle. The only file handles we’ll really support here are <code>stdout</code> and <code>stderr</code>. And to be perfectly accurate, there are no files here; we’re just intercepting the C standard library calls that otherwise work with these concepts.</p>
<p>Moving further, we provide super minimal implementations for a few more building blocks. They’re extremely basic, like the <code>_close</code> function, which essentially never allows any file handle to be closed.</p>
<p>The one building block that is very interesting here is <code>_sbrk</code>. This is what gets invoked when the routines for dynamic memory allocation like <code>malloc</code> (needed by the <code>printf</code> family of functions) need to ask the OS (when there is one) to provide more raw memory to the process, that can then be fragmented into smaller logical units by <code>malloc</code>. What happens here is we find the symbol <code>_end</code> defined by the linker, which marks the <code>_end</code> of the static sections (we’ll see how below) and we start using the memory past that address for heap allocations, all the way until we hit the stack. Once we hit the stack, we declare that an error as we have run out of memory.</p>
<pre is:raw="" tabindex="0"><code><span><span>void*</span><span> </span><span>_sbrk</span><span>(</span><span>int</span><span> </span><span>incr</span><span>) {</span></span>
<span><span>    </span><span>extern</span><span> </span><span>char</span><span> _end;</span><span>         // Defined by the linker - start of heap</span></span>
<span><span>    </span><span>extern</span><span> </span><span>char</span><span> _stack_bottom;</span><span> // Defined in our linker script - bottom of stack area</span></span>
<span></span>
<span><span>    </span><span>static</span><span> </span><span>char</span><span> </span><span>*</span><span>heap_end </span><span>=</span><span> </span><span>&amp;</span><span>_end;</span></span>
<span><span>    </span><span>char</span><span> </span><span>*</span><span>prev_heap_end </span><span>=</span><span> heap_end;</span></span>
<span></span>
<span><span>    </span><span>// Calculate safe stack limit - stack grows down from _stack_top towards _stack_bottom</span></span>
<span><span>    </span><span>char</span><span> </span><span>*</span><span>stack_limit </span><span>=</span><span> </span><span>&amp;</span><span>_stack_bottom;</span></span>
<span></span>
<span><span>    </span><span>// Check if heap would grow too close to stack</span></span>
<span><span>    </span><span>if</span><span> (heap_end </span><span>+</span><span> incr </span><span>&gt;</span><span> stack_limit) {</span></span>
<span><span>        errno </span><span>=</span><span> ENOMEM;</span></span>
<span><span>        </span><span>return</span><span> (</span><span>void*</span><span>) </span><span>-</span><span>1</span><span>;</span><span> // Return error</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    heap_end </span><span>+=</span><span> incr;</span></span>
<span><span>    </span><span>return</span><span> (</span><span>void*</span><span>) prev_heap_end;</span></span>
<span><span>}</span></span></code></pre>
<p>Please note that the stack top and bottom here refer to the beginning and the end of the memory block allocated for the stack, not the logical top or bottom of the stack itself from the application perspective.</p>
<h2 id="application-example-input-and-output">Application example: input and output</h2>
<p>We’re now ready to put the actual bare metal application together. If you need a refresher on <a href="https://popovicu.com/posts/bare-metal-programming-risc-v">bare metal programming on RISC-V</a>, check it out again. That article covers the key addresses and the basics of putting a bare-metal linker script together.</p>
<p>The app code itself is very self explanatory:</p>
<pre is:raw="" tabindex="0"><code><span><span>#include</span><span> </span><span>&lt;stdio.h&gt;</span></span>
<span></span>
<span><span>int</span><span> </span><span>main</span><span>(</span><span>void</span><span>) {</span></span>
<span><span>    </span><span>printf</span><span>(</span><span>&#34;Hello from RISC-V UART!</span><span>\n</span><span>&#34;</span><span>);</span></span>
<span></span>
<span><span>    </span><span>char</span><span> </span><span>buffer</span><span>[</span><span>100</span><span>];</span></span>
<span><span>    </span><span>printf</span><span>(</span><span>&#34;Type something: &#34;</span><span>);</span></span>
<span><span>    </span><span>scanf</span><span>(</span><span>&#34;</span><span>%s</span><span>&#34;</span><span>, buffer);</span></span>
<span><span>    </span><span>printf</span><span>(</span><span>&#34;You typed: </span><span>%s</span><span>\n</span><span>&#34;</span><span>, buffer);</span></span>
<span></span>
<span><span>    </span><span>while</span><span> (</span><span>1</span><span>) {}</span></span>
<span></span>
<span><span>    </span><span>return</span><span> </span><span>0</span><span>;</span></span>
<span><span>}</span></span></code></pre>
<p>Please note that when we’re inputting something to this app, we won’t see our key presses echoed. This is because we’re not operating inside some sort of shell environment. The implementation as it is will simply accept the key presses and store them in the internal memory structure. We’ll see what was typed when we hit the final <code>printf</code>.</p>
<p>We now need to also put together a small C runtime. When we develop a binary for an everyday OS, we typically don’t have to think about this, and the compiler will inject the standard startup runtime which takes care of setting up the process for proper execution and passing the control on to the <code>main</code> function.</p>
<p>Our minimalistic runtime will set up the stack pointer register, zero-fill the BSS section per C standard, and then call the <code>main</code> code. Just for good measure, we also leave an infinite loop at the end in case <code>main</code> returns. Again, with a proper OS below our code, a system call would be invoked to properly close the process, and it wouldn’t just loop infinitely.</p>
<pre is:raw="" tabindex="0"><code><span><span>.</span><span>section .text</span><span>.init</span></span>
<span><span>.global _start</span></span>
<span></span>
<span><span>_start:</span></span>
<span><span>    la </span><span>sp</span><span>, _stack_top</span></span>
<span></span>
<span><span>   </span><span> # Clear BSS section - using symbols defined in our linker script</span></span>
<span><span>    la t0, _bss_start</span></span>
<span><span>    la t1, _bss_end</span></span>
<span><span>clear_bss:</span></span>
<span><span>    bgeu t0, t1, bss_done</span></span>
<span><span>    sb zero, </span><span>0</span><span>(t0)</span></span>
<span><span>    addi t0, t0, </span><span>1</span></span>
<span><span>    j clear_bss</span></span>
<span><span>bss_done:</span></span>
<span></span>
<span><span>   </span><span> # Jump to C code</span></span>
<span><span>    </span><span>call</span><span> main</span></span>
<span></span>
<span><span>   </span><span> # In case main returns</span></span>
<span><span>1</span><span>:  j </span><span>1b</span></span></code></pre>
<p>One of the most important parts of our application now is the linker script:</p>
<pre is:raw="" tabindex="0"><code><span><span>OUTPUT_FORMAT(&#34;elf64-littleriscv&#34;)</span></span>
<span><span>OUTPUT_ARCH(&#34;riscv&#34;)</span></span>
<span><span>ENTRY(_start)</span></span>
<span><span></span></span>
<span><span>MEMORY</span></span>
<span><span>{</span></span>
<span><span>  RAM (rwx) : ORIGIN = 0x80000000, LENGTH = 64M</span></span>
<span><span>}</span></span>
<span><span></span></span>
<span><span>SECTIONS</span></span>
<span><span>{</span></span>
<span><span>  /* Code section */</span></span>
<span><span>  .text : {</span></span>
<span><span>    *(.text.init)</span></span>
<span><span>    *(.text)</span></span>
<span><span>  } &gt; RAM</span></span>
<span><span></span></span>
<span><span>  /* Read-only data */</span></span>
<span><span>  .rodata : {</span></span>
<span><span>    *(.rodata)</span></span>
<span><span>  } &gt; RAM</span></span>
<span><span></span></span>
<span><span>  /* Initialized data */</span></span>
<span><span>  .data : {</span></span>
<span><span>    *(.data)</span></span>
<span><span>  } &gt; RAM</span></span>
<span><span></span></span>
<span><span>  /* Small initialized data */</span></span>
<span><span>  .sdata : {</span></span>
<span><span>    *(.sdata)</span></span>
<span><span>  } &gt; RAM</span></span>
<span><span></span></span>
<span><span>  /* BSS section with explicit symbols */</span></span>
<span><span>  .bss : {</span></span>
<span><span>    _bss_start = .;  /* Define BSS start symbol */</span></span>
<span><span>    *(.bss)</span></span>
<span><span>    *(COMMON)</span></span>
<span><span>    . = ALIGN(8);</span></span>
<span><span>    _bss_end = .;    /* Define BSS end symbol */</span></span>
<span><span>  } &gt; RAM</span></span>
<span><span></span></span>
<span><span>  /* Small BSS section */</span></span>
<span><span>  .sbss : {</span></span>
<span><span>    _sbss_start = .;</span></span>
<span><span>    *(.sbss)</span></span>
<span><span>    *(.sbss.*)</span></span>
<span><span>    . = ALIGN(8);</span></span>
<span><span>    _sbss_end = .;</span></span>
<span><span>  } &gt; RAM</span></span>
<span><span></span></span>
<span><span>  /* End marker for heap start */</span></span>
<span><span>  . = ALIGN(8);</span></span>
<span><span>  _end = .; /* Heap starts here and grows upwards */</span></span>
<span><span></span></span>
<span><span>  /* Stack grows downward from the end of RAM */</span></span>
<span><span>  _stack_size = 64K;</span></span>
<span><span>  _stack_top = ORIGIN(RAM) + LENGTH(RAM);</span></span>
<span><span>  _stack_bottom = _stack_top - _stack_size;</span></span>
<span><span></span></span>
<span><span>  /* Ensure we don&#39;t overlap with heap */</span></span>
<span><span>  ASSERT(_end &lt;= _stack_bottom, &#34;Error: Heap collides with stack&#34;)</span></span>
<span><span>}</span></span></code></pre>
<p>Per our previous investigation of bare metal programming for the QEMU VM, we know that the user-provided code will begin executing from <code>0x80000000</code>. Therefore, what we do is put the C runtime code that we previously wrote right there. In other words, our assembly code will be planted right at that memory address. Following our C runtime is the rest of the code, i.e. the <code>text</code> section. In this case, this is the C code we have written plus the C standard library we’re linking into our binary.</p>
<p>After that, we place the other sections like <code>rodata</code>, <code>data</code>, <code>bss</code>, and so on. The linker script will capture the symbols for BSS start and end so it can be zero-filled by the C runtime, as seen above. There’s also a small BSS section, but the C runtime code doesn’t do anything about it, to stay compact, as it’s not used by the application. It probably should be zero-filled as well.</p>
<p>Then, we capture where the small BSS section ends because that also marks the end of our static sections. Following that, we let the growing heap consume everything, up until the stack. The stack occupies the last 64K of memory (and we described RAM as being 64M at the top of the linker script). A few addition and subtraction operations are done to determine where this exactly is, and we do an assert check to make sure there is no collision between the heap and the stack.</p>
<p>The concept is simple: we identify the “void” between the static sections and the stack, and we let the C standard library that we’re putting together via Newlib to maintain the growing heap in there. A real kernel like Linux would do its memory management magic here, handle the virtual addresses and so on, but here we really have one “process” and a simple memory extension operation <code>sbrk</code> is enough for what we want to achieve here.</p>
<h3 id="the-gotcha-moment">The ‘gotcha’ moment</h3>
<p>Now let’s reflect back on the fact that we configured the toolchain to be built with the <code>--with-cmodel=medany</code> flag. What does this flag really control, and why did we need it?</p>
<p>If you read the top of the linker script carefully, we’re building for a 64-bit RISC-V machine. Per QEMU, our instructions will begin at <code>0x80000000</code>, and we decided to simply lay the rest of the code after that. To handle these high values, we need to use the correct machine instructions to handle these high addresses. So our application code likely needs to use the memory address model which can handle any address, and so we build our logic with <code>-mcmodel=medany</code>. To be compatible, our C standard library also needs that.</p>
<p>If we didn’t have the aforementioned flag, the Newlib library would be built with RISC-V instructions that cannot effectively use such high addresses. Remember, the C standard library is pre-built before our application. The build system will simply pick up the machine code from the relevant library directory and link it to your application code. If the addresses do not fit the value range that the instructions support, the linker is not able to make things work.</p>
<p>As I understand, there is a concept of <em>linker relaxation</em>, where the linker itself can make the code modifications, but I don’t think it would help in this case.</p>
<p>I don’t want to spend too much time on this, I hope the explanation above suffices, and if you would like to learn more about this problem, check out <a href="https://github.com/riscvarchive/riscv-gcc/issues/153">this link</a>, where the reporter had linker errors and a solution was offered.</p>
<h2 id="running-the-app">Running the app</h2>
<p>I’ve included a <code>Makefile</code> in the GitHub repo. Check it out to see what exactly is going on there, especially how the cross-compiler is invoked (should be the first line of the file), as well as QEMU for emulation. I will highlight a few things here.</p>
<p>One of the <code>CFLAGS</code> is <code>-specs=nosys.specs</code>. This will drive the toolchain to use the ‘nosys’ flavor of Newlib. This is the most minimal flavor where all the building blocks are just stubs by default that return zeroes or errors.</p>
<p>Linker flags include <code>-nostartfiles</code> which means that we’ll be providing our own minimal C runtime, that we have described above.</p>
<p>The rest of the <code>Makefile</code> should be fairly easy to follow. I strongly suggest using the <code>debug</code> target though. We’ll just go ahead and run:</p>
<pre is:raw="" tabindex="0"><code><span><span>make</span><span> </span><span>debug</span></span></code></pre>
<p>The QEMU process starts, I punch in <code>foo</code> and hit enter, and after getting back my app’s output, I stop QEMU:</p>
<pre is:raw="" tabindex="0"><code><span><span>$</span><span> </span><span>make</span><span> </span><span>debug</span></span>
<span><span>/opt/riscv-newlib/bin/riscv64-unknown-elf-gcc</span><span> </span><span>-march=rv64imac_zicsr</span><span> </span><span>-mabi=lp64</span><span> </span><span>-mcmodel=medany</span><span> </span><span>-specs=nosys.specs</span><span> </span><span>-O2</span><span> </span><span>-g</span><span> </span><span>-Wall</span><span> </span><span>-c</span><span> </span><span>main.c</span><span> </span><span>-o</span><span> </span><span>main.o</span></span>
<span><span>/opt/riscv-newlib/bin/riscv64-unknown-elf-gcc</span><span> </span><span>-march=rv64imac_zicsr</span><span> </span><span>-mabi=lp64</span><span> </span><span>-mcmodel=medany</span><span> </span><span>-specs=nosys.specs</span><span> </span><span>-O2</span><span> </span><span>-g</span><span> </span><span>-Wall</span><span> </span><span>-c</span><span> </span><span>uart.c</span><span> </span><span>-o</span><span> </span><span>uart.o</span></span>
<span><span>/opt/riscv-newlib/bin/riscv64-unknown-elf-gcc</span><span> </span><span>-march=rv64imac_zicsr</span><span> </span><span>-mabi=lp64</span><span> </span><span>-mcmodel=medany</span><span> </span><span>-specs=nosys.specs</span><span> </span><span>-O2</span><span> </span><span>-g</span><span> </span><span>-Wall</span><span> </span><span>-c</span><span> </span><span>syscalls.c</span><span> </span><span>-o</span><span> </span><span>syscalls.o</span></span>
<span><span>/opt/riscv-newlib/bin/riscv64-unknown-elf-gcc</span><span> </span><span>-march=rv64imac_zicsr</span><span> </span><span>-mabi=lp64</span><span> </span><span>-mcmodel=medany</span><span> </span><span>-specs=nosys.specs</span><span> </span><span>-O2</span><span> </span><span>-g</span><span> </span><span>-Wall</span><span> </span><span>-c</span><span> </span><span>startup.S</span><span> </span><span>-o</span><span> </span><span>startup.o</span></span>
<span><span>/opt/riscv-newlib/bin/riscv64-unknown-elf-gcc</span><span> </span><span>-march=rv64imac_zicsr</span><span> </span><span>-mabi=lp64</span><span> </span><span>-mcmodel=medany</span><span> </span><span>-specs=nosys.specs</span><span> </span><span>-O2</span><span> </span><span>-g</span><span> </span><span>-Wall</span><span> </span><span>-T</span><span> </span><span>link.ld</span><span> </span><span>-nostartfiles</span><span>   </span><span>-o</span><span> </span><span>firmware.elf</span><span> </span><span>main.o</span><span> </span><span>uart.o</span><span> </span><span>syscalls.o</span><span> </span><span>startup.o</span></span>
<span><span>/opt/riscv-newlib/lib/gcc/riscv64-unknown-elf/14.2.0/../../../../riscv64-unknown-elf/bin/ld:</span><span> </span><span>warning:</span><span> </span><span>firmware.elf</span><span> </span><span>has</span><span> </span><span>a</span><span> </span><span>LOAD</span><span> </span><span>segment</span><span> </span><span>with</span><span> </span><span>RWX</span><span> </span><span>permissions</span></span>
<span><span>qemu-system-riscv64</span><span> </span><span>-machine</span><span> </span><span>virt</span><span> </span><span>-m</span><span> </span><span>256</span><span> </span><span>-nographic</span><span> </span><span>-bios</span><span> </span><span>firmware.elf</span><span> </span><span>-d</span><span> </span><span>in_asm,cpu_reset</span><span> </span><span>-D</span><span> </span><span>qemu_debug.log</span></span>
<span><span>Hello</span><span> </span><span>from</span><span> </span><span>RISC-V</span><span> </span><span>UART!</span></span>
<span><span>Type</span><span> </span><span>something:</span><span> </span><span>You</span><span> </span><span>typed:</span><span> </span><span>foo</span></span></code></pre>
<p>The reason why I suggest using the <code>debug</code> target is because it drops a file called <code>qemu_debug.log</code>. That file is pretty cool as it shows you a complete trace of what your VM has been through. Naturally, you can inspect all the Newlib code if you want to figure out how <strong>exactly</strong> <code>printf</code> works, but I thought it’s still a pretty nice view of what the RISC-V core actually sees. Since we’re building an <code>ELF</code> file and passing it to <code>QEMU</code>, it’s even able to tell us which function we’re exactly in. It doesn’t have that for the first couple of instructions since we’re, as a reminder, executing the initial hardcoded bootloader, and then our initial C runtime, before jumping into the <code>main</code> function. If the first few instructions before <code>0x80000000</code> confuse you, please check out <a href="https://popovicu.com/posts/risc-v-sbi-and-full-boot-process">RISC-V boot process with SBI</a> to understand what’s going on. Excerpt of my debug log is below:</p>
<pre is:raw="" tabindex="0"><code><span><span>----------------</span></span>
<span><span>IN:</span></span>
<span><span>Priv: 3; Virt: 0</span></span>
<span><span>0x0000000000001000:  00000297          auipc                   t0,0                    # 0x1000</span></span>
<span><span>0x0000000000001004:  02828613          addi                    a2,t0,40</span></span>
<span><span>0x0000000000001008:  f1402573          csrrs                   a0,mhartid,zero</span></span>
<span><span></span></span>
<span><span>----------------</span></span>
<span><span>IN:</span></span>
<span><span>Priv: 3; Virt: 0</span></span>
<span><span>0x000000000000100c:  0202b583          ld                      a1,32(t0)</span></span>
<span><span>0x0000000000001010:  0182b283          ld                      t0,24(t0)</span></span>
<span><span>0x0000000000001014:  00028067          jr                      t0</span></span>
<span><span></span></span>
<span><span>----------------</span></span>
<span><span>IN:</span></span>
<span><span>Priv: 3; Virt: 0</span></span>
<span><span>0x0000000080000000:  04000117          auipc                   sp,67108864             # 0x84000000</span></span>
<span><span>0x0000000080000004:  00010113          mv                      sp,sp</span></span>
<span><span>0x0000000080000008:  00015297          auipc                   t0,86016                # 0x80015008</span></span>
<span><span>0x000000008000000c:  d5828293          addi                    t0,t0,-680</span></span>
<span><span>0x0000000080000010:  00015317          auipc                   t1,86016                # 0x80015010</span></span>
<span><span>0x0000000080000014:  d5030313          addi                    t1,t1,-688</span></span>
<span><span>0x0000000080000018:  0062f663          bleu                    t1,t0,12                # 0x80000024</span></span>
<span><span></span></span>
<span><span>----------------</span></span>
<span><span>IN:</span></span>
<span><span>Priv: 3; Virt: 0</span></span>
<span><span>0x0000000080000024:  0be020ef          jal                     ra,8382                 # 0x800020e2</span></span>
<span><span></span></span>
<span><span>----------------</span></span>
<span><span>IN: main</span></span>
<span><span>Priv: 3; Virt: 0</span></span>
<span><span>0x00000000800020e2:  7119              addi                    sp,sp,-128</span></span>
<span><span>0x00000000800020e4:  00011517          auipc                   a0,69632                # 0x800130e4</span></span>
<span><span>0x00000000800020e8:  db450513          addi                    a0,a0,-588</span></span>
<span><span>0x00000000800020ec:  fc86              sd                      ra,120(sp)</span></span>
<span><span>0x00000000800020ee:  10e000ef          jal                     ra,270                  # 0x800021fc</span></span>
<span><span></span></span>
<span><span>----------------</span></span>
<span><span>IN: puts</span></span>
<span><span>Priv: 3; Virt: 0</span></span>
<span><span>0x00000000800021fc:  85aa              mv                      a1,a0</span></span>
<span><span>0x00000000800021fe:  00012517          auipc                   a0,73728                # 0x800141fe</span></span>
<span><span>0x0000000080002202:  ffa53503          ld                      a0,-6(a0)</span></span>
<span><span>0x0000000080002206:  b7bd              j                       -146                    # 0x80002174</span></span></code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>With this example, we have ported some of the very powerful features over to our bare-metal platform, and we somewhat retained the feeling of coding on top of a proper kernel. We could keep going and enable things like “file” access, memory management and so on.</p>
<p>In fact, what is really interesting here is that the door is now open to use some powerful libraries in our bare-metal code, that are otherwise not necessarily expecting a bare metal environment. Some library could expect to open a file and if the only way it does it is through using the C standard library, we can essentially intercept that API call and without passing the request to the kernel, we can service it in our bare metal code.</p>
<p>And the concept to do this was quite simple: depend on the building blocks that Newlib defines, provide your own implementation that takes precedence over the Newlib defaults, and use the defaults for whatever you don’t care about.</p>
<p>Of course, in absolutely minimal environments, the size of the final software image can be a concern, as well as the amount of instructions we’re injecting, but looking at the <code>ELF</code> file that we build in our project, it’s at <code>220K</code> which doesn’t really sound too bad. Ultimately, however, it is up to you to decide what abstractions you will use in your project. This should be one of the tools in your toolbox that can hopefully save you some time in your development.</p>
<p>Good luck with your hacking!</p>
<p>Please consider following on <a href="https://twitter.com/popovicu94">Twitter/X</a> and <a href="https://www.linkedin.com/in/upopovic/">LinkedIn</a> to stay updated.</p>
    </article></div>
  </body>
</html>
