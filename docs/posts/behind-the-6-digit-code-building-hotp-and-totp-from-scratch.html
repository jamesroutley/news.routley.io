<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.dogac.dev/how-do-one-time-passwords-work/">Original</a>
    <h1>Behind the 6-digit code: Building HOTP and TOTP from scratch</h1>
    
    <div id="readability-page-1" class="page"><div>
              
              <p>A while ago, I have started working on authorization and authentication at work. This taught me a lot about how modern authentication systems work. However I have always thought One-Time Password logins are the most mystical ones. A six-digit code that changes every time and can be used to verify your identity. How does the server know the newly generated one, and how is it really secure? In this post, I will explain what HOTP, TOTP is and how they work by sharing my own implementation from scratch.</p><figure><img src="https://blog.dogac.dev/content/images/2025/04/image-1.png" alt="" loading="lazy" width="1374" height="512" srcset="https://blog.dogac.dev/content/images/size/w600/2025/04/image-1.png 600w, https://blog.dogac.dev/content/images/size/w1000/2025/04/image-1.png 1000w, https://blog.dogac.dev/content/images/2025/04/image-1.png 1374w" sizes="(min-width: 720px) 720px"/><figcaption><span>A sample OTP login code</span></figcaption></figure><p>One-Time Passwords (OTPs) are a widely-used form of authentication. You’ve likely encountered them when using a “Secure Login” app like Google Authenticator, or during a “Forgot Password” flow where a temporary code is sent to your email or phone.</p><p>Unlike traditional passwords, OTPs are only valid for a single use or a limited time window. This greatly reduces the risk of password replay attacks, where someone captures the password used to login and tries to reuse it. </p><figure><img src="https://blog.dogac.dev/content/images/2025/04/image-2.png" alt="" loading="lazy" width="2000" height="1178" srcset="https://blog.dogac.dev/content/images/size/w600/2025/04/image-2.png 600w, https://blog.dogac.dev/content/images/size/w1000/2025/04/image-2.png 1000w, https://blog.dogac.dev/content/images/size/w1600/2025/04/image-2.png 1600w, https://blog.dogac.dev/content/images/2025/04/image-2.png 2000w" sizes="(min-width: 1200px) 1200px"/><figcaption><span>Passwords can be used repeatedly. When leaked, malicious actors can impersonate the user and access critical information.</span></figcaption></figure><p>Like the traditional password authentication approach, the user and the authority (server) still needs to agree on a common secret key. During the regular password authentication, this secret key is directly communicated to the authority. There are many ways of doing this process safely, such as hashing the password or sending it over an encrypted network. However the risk still exists, as the password itself never changes, as long as we use our devices to type our passwords, there is some way those malicious actors can watch and get that information before it reaching the network.</p><p>So instead of using a constant secret key, we can use something dynamic that changes over time. As a simple example, assume when those two people first met, they have set their secretly hidden clocks to a random time together.</p><figure><img src="https://blog.dogac.dev/content/images/2025/04/image-3.png" alt="" loading="lazy" width="2000" height="1563" srcset="https://blog.dogac.dev/content/images/size/w600/2025/04/image-3.png 600w, https://blog.dogac.dev/content/images/size/w1000/2025/04/image-3.png 1000w, https://blog.dogac.dev/content/images/size/w1600/2025/04/image-3.png 1600w, https://blog.dogac.dev/content/images/2025/04/image-3.png 2000w" sizes="(min-width: 1200px) 1200px"/><figcaption><span>Using secret clocks as a basic OTP implementation</span></figcaption></figure><p>Also in some examples like a password recovery, we can use also use a secret clock. This secret clock not shared with the user directly but rather server&#39;s generated one-time password is sent via a trusted medium, such as an email to the user.</p><p><em><strong>Edit</strong>: Several readers have warned me it is much easier to generate random numbers instead. The server has to store number of attempts to make sure it is not brute forced as well.</em></p><p>Obviously a clock on its own is not secure, as in this example Plankton could have predicted the time-shift of the secret clock based on the real time. However for the sake of this example, I wanted to show how copying the &#34;password&#34; is not enough on its own. Let&#39;s take a look at some strategies to build this &#34;secret clock&#34; and make sure it is not possible to predict time just by knowing a single code in some point in time.</p><p>There are two common types of OTP algorithms:</p><ul><li><strong>HOTP (HMAC-based One-Time Password)</strong> – based on a counter that increments every time an OTP is requested.</li><li><strong>TOTP (Time-based One-Time Password)</strong> – based on the current time, typically using 30-second intervals.</li></ul><p>These methods are standardized in <a href="https://www.rfc-editor.org/rfc/rfc4226?ref=blog.dogac.dev" rel="noreferrer">RFC 4226</a> (for HOTP) and <a href="https://www.rfc-editor.org/rfc/rfc6238?ref=blog.dogac.dev" rel="noreferrer">RFC 6238</a> (for TOTP), and are used in many modern 2FA (two-factor authentication) implementations.</p><p>A counter based password method is easier to understand. Imagine two people met and generated a totally random series of numbers. They both start from count 0, as in each attempt, user needs to communicate to the server with the secret key in the given index. However this comes with several problems,</p><ol><li>Clients needs to sync their counter, if there is a skew, they might get temporarily locked out.</li><li>Malicious actors can collect upcoming login codes by phishing the user and those codes can be used for a long time. </li></ol><p>Therefore, instead of storing a counter, we can use the current time as the counter. That&#39;s how TOTP works. Using time makes synchronization easier, as many modern machines already use technologies such as NTP to sync their time and this prevents malicious actors from harvesting codes as their code will be valid for only next 30 seconds or so, not for a long sequence of future login attempts.</p><p>The analogy of two people met and decided on a totally random series of numbers is partially realistic. However it is not feasible to have such a huge list, you potentially need to have millions of secret numbers to support OTPs for a reasonable time. Therefore we should use algorithms that are cryptographically  safe that generate values based on a secret key. It is important that this algorithm is not random, as both user and the authority will hold a copy of this secret key and they should be able to generate the same value given the same time.</p><p>We have introduced HOTP first because the actual implementation of TOTPs are actually HOTP based. Instead of using a static counter, TOTPs use the time as the current counter.  We can write the following formula to find the counter in any given time,</p><p>\[ c(t) = \left\lfloor \frac{t - t_0}{X} \right\rfloor \]</p><p>Here \(t_0\) is the starting time, in most systems this is the default UNIX epoch timestamp, 1 January 1970. \(X\) is the period you want the code to rotate. For example, if you want the login code to change every 30 seconds, X should be 30 seconds.</p><p>In order to generate an HOTP, you need to decide on three things:</p><ol><li>A secret key</li><li>A hash function</li><li>Number of digits you will output</li></ol><p>First, we need to start by hashing our secret key. For example, if we have chosen <code>SHA-1</code> as our hashing algorithm, our output would be only 64 bytes. If secret key is shorted than 64 bytes, we can just pad it with zeroes. Otherwise, given \(K\) is our secret key and \(H\) is our hashing algorithm,</p><p>\[ K_{pad} = H(K)  \] </p><p>Later we do an XOR operation on text with some pre-defined magic constants \(I_{pad}\) and \(O_{pad}\).</p><p>\[ I_{pad} = [\texttt{0x36}, \dots] \newline O_{pad} = [\texttt{0x5c}, \dots] \]</p><p>Those numbers are originally chosen by HMAC designers and any pair where \(I_{pad} \neq O_{pad}\) could have been chosen. Their lenght should be also 64 bytes, same as our hashing algorithm&#39;s digest length. Later we define the famous \( \text{HMAC} \), Hash-based Message Authentication Code, function. It outputs a crypthographic hash calculated using the given key and message.</p><p>\[ \text{HMAC}(K, M) = H(K_{pad} \oplus O_{pad} + H(K_{pad} \oplus I_{pad} + M)) \]</p><p>This cryptographic hash function is secure, so that user can&#39;t infer the secret key \( K_{pad} \) even if they knew \( M \) and the resulting hash.</p><p>Later we will define a new function to generate a 4-byte result. Here is the definition of DT from the original RFC,</p><pre><code>    DT(String) // String = String[0]...String[19]
     Let OffsetBits be the low-order 4 bits of String[19]
     Offset = StToNum(OffsetBits) // 0 &lt;= OffSet &lt;= 15
     Let P = String[OffSet]...String[OffSet+3]
     Return the Last 31 bits of P</code></pre><p>This function allows us to shrink our 20 byte input to 4 bytes dynamically by choosing the bytes offsetted by the number that is represented using the last 4 bits of the input. The outputs of the DT on distinct counter inputs are uniformly and independently distributed.</p><p>Finally, we can define our HOTP function as,</p><p>\[ \text{HOTP}(K,C) = \text{DT}(\text{HMAC}(K,C)) \bmod 10^{\text{digits}} \]</p><p>Here we can replace our counter \( C \) with \( c(t) \) to get a TOTP code.</p><p>There are many online resources with TOTP and HOTPs, however I have struggled to find a website that help me check my implementation as their secret-key representations were not standardized. Thus, I have published my own short demo app to showcase.</p><figure><img src="https://blog.dogac.dev/content/images/2025/04/image-4.png" alt="" loading="lazy" width="1352" height="1458" srcset="https://blog.dogac.dev/content/images/size/w600/2025/04/image-4.png 600w, https://blog.dogac.dev/content/images/size/w1000/2025/04/image-4.png 1000w, https://blog.dogac.dev/content/images/2025/04/image-4.png 1352w" sizes="(min-width: 720px) 720px"/></figure><figure><a href="https://otp.dogac.dev/?ref=blog.dogac.dev"><div><p>OTP Generator</p><p>Test and validate OTP workflows such as TOTP and HOTP.</p><p><img src="https://otp.dogac.dev/favicon.ico" alt=""/></p></div></a></figure><p>I have published this app on my website and also on GitHub, the implementation uses Kotlin.</p><ul><li>Link to the app <a href="https://otp.dogac.dev/?ref=blog.dogac.dev">https://otp.dogac.dev/</a></li><li>Link to the GitHub repository: <a href="https://github.com/dogacel/otp-server?ref=blog.dogac.dev">github.com/Dogacel/otp-server</a></li></ul><p><strong>To recap:</strong> We’ve looked at how HOTP and TOTP work, explored how they&#39;re derived from HMAC, and saw how the server and client can generate matching codes without ever transmitting the password itself.</p><p>Working on this project helped me understand how OTPs work at a much deeper level. What once felt like magic now feels like elegant design.</p>
                <section>
                  
                  <ul>
                      <li>
                        <a href="https://blog.divyendusingh.com/tag/programming/" title="Programming">Programming</a>
                      </li>
                  </ul>
                </section>
            </div></div>
  </body>
</html>
