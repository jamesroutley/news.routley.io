<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://exploring-better-ways.bellroy.com/free-applicatives-the-handle-pattern-and-remote-systems.html">Original</a>
    <h1>Free applicatives, the handle pattern, and remote systems</h1>
    
    <div id="readability-page-1" class="page"><section><p>We recently refactored some gnarly code that manipulated customer and
order records in our enterprise resource planning (ERP) system. That
system had a few idiosyncrasies which complicated this task:</p>
<ul>
<li>Creating new records required referencing other entities by internal
ID, so we had to do a number of lookups before issuing “create
record” requests;</li>
<li>For some entity types, we found it easiest to issue “search” API
calls and extract the required IDs from the returned search
results. This necessitated an extra parsing step between “we have a
successful response” and “we have the ID we’re looking for”; and</li>
<li>Requests are often slow, but the marginal cost of additional
requests in a batch was quite low. This meant that we could expect
some good results from batching related requests together.</li>
</ul>
<p>The benefits of batching led us to seek a solution that permitted
static analysis. Applicative functors have a completely static control
flow, and cannot express computations where one step depends on the
result of a previous step. A well-chosen applicative would let us
analyse the requests we need to send without executing any of them,
batch queries together without worrying about data dependencies, and
then route relevant results to each individual query to parse (if
necessary). Our library users could ignore batching details but still
gain the efficiency benefits of a batch query API.</p>
<p>In this post, we’ll look how we’ve been using handles, what “free
structures” are, how free applicatives elegantly solved some of our
problems interfacing with a remote system, and how they interacted
especially well with the “handle pattern”.</p>
<h2 id="handles-as-bellroy-uses-them">Handles, as Bellroy uses them</h2>
<p>The “<a href="https://jaspervdj.be/posts/2018-03-08-handle-pattern.html">handle pattern</a>”
is a Haskell idiom that is similar to dependency injection in
mainstream languages. Instead of directly writing in the side effects
we want our code to perform, we accept a record of functions that we
call a “handle”. (In an object-oriented language, we’d probably accept
an object that implements an abstract interface instead of a record.)
These handles can group related functions into a single record but
often only contain one:</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>newtype</span> <span>Handle</span> e m <span>=</span> <span>Handle</span> {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span>    performRequest ::</span> <span>ERP.Request</span> <span>-&gt;</span> m (<span>Either</span> e <span>Aeson.Value</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span>-- Plus some other handle-making functions e.g. for testing.</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span>newHandle ::</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span>MonadIO</span> m <span>=&gt;</span> <span>ERP.Credentials</span> <span>-&gt;</span> m (<span>Handle</span> <span>ERP.Error</span> m)</span></code></pre></div>
<p>Functions that consume handles generally look like this:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>someFunction ::</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span>-- When all side effects come from handles,</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span>-- we rarely need anything stronger than `Monad`.</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span>Monad</span> m <span>=&gt;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span>-- First: Any handles we need</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span>FooHandle</span> m <span>-&gt;</span> <span>BarHandle</span> m <span>-&gt;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span>-- Second: Other &#34;normal&#34; arguments</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  <span>Argument1</span> <span>-&gt;</span> <span>..</span> <span>-&gt;</span> <span>ArgumentN</span> <span>-&gt;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  m <span>Result</span></span></code></pre></div>
<p>This idiom is a simpler, library-free alternative to effect system
libraries like
<a href="https://hackage.haskell.org/package/effectful"><code>effectful</code></a>,
<a href="https://hackage.haskell.org/package/bluefin"><code>bluefin</code></a>,
<a href="https://hackage.haskell.org/package/heftia"><code>heftia</code></a> and
<a href="https://hackage.haskell.org/package/polysemy"><code>polysemy</code></a>. We
previously wrote about an
<a href="https://exploring-better-ways.bellroy.com/integrating-effectful-and-persistent.html">experiment with <code>effectful</code></a>,
but we have still not committed to an effect system. Instead, we are
refactoring towards handles as a way to encapsulate our side effects,
and because it should be easy to convert handle-using code to an
effect system if and when we choose one.</p>
<p>Because we have code written against other idioms (e.g. MTL-style
classes), and because we often find it convenient to introduce an
<code>ExceptT e</code> or <code>MaybeT</code> monad transformer in the body of our
functions, we sometimes need to change the monad of a handle that
we’ve been given. We do this by providing a <code>hoistHandle</code> function:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>hoistHandle ::</span> (<span>forall</span> x <span>.</span> f x <span>-&gt;</span> g x) <span>-&gt;</span> <span>Handle</span> f <span>-&gt;</span> <span>Handle</span> g</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>hoistHandle f <span>Handle</span> {performRequest} <span>=</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span>Handle</span> {performRequest <span>=</span> f <span>.</span> performRequest}</span></code></pre></div>
<p>That first argument, <code>forall x . f x -&gt; g x</code>, is worth commenting
on. A <code>forall</code> in a type signature explicitly introduces a type
variable that is provided by the function’s caller. For a simpler
example of how <code>forall</code> works here, let’s look at the <code>map</code> function
on lists, but with explicit <code>forall</code>s:</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>map</span><span> ::</span> <span>forall</span> a b <span>.</span> (a <span>-&gt;</span> b) <span>-&gt;</span> [a] <span>-&gt;</span> [b]</span></code></pre></div>
<p>The caller of <code>map</code> gets to choose the types of <code>a</code> and <code>b</code>, and GHC
is often smart enough to figure this out automatically:</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>-- GHC concludes that it needs to call</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span>-- `map` with `Int` for `a` and `String` for `b`.</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>ghci<span>&gt;</span> <span>map</span> <span>show</span> [<span>1</span>, <span>2</span>, <span>3</span>]</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>[<span>&#34;1&#34;</span>,<span>&#34;2&#34;</span>,<span>&#34;3&#34;</span>]</span></code></pre></div>
<p>In our <code>hoistHandle</code> function, we let the <strong>caller</strong> choose <code>f</code> and
<code>g</code>, but they must provide us a function where <strong>we</strong> are allowed to
choose <code>x</code>. The types force this function to convert <code>f x</code> into <code>g x</code>
in a way that’s blind to what <code>x</code> actually is — guaranteeing that
the conversion only changes structure, not wrapped values. It also
ensures that we can write <code>hoistHandle</code> for a handle containing
multiple functions, because we can choose a different <code>x</code> for each
one.</p>
<h2 id="building-our-applicative">Building our applicative</h2>
<p>We want to build a structure that is essentially a syntax tree of the
operations we want to perform. This means it needs to hold the
requests we want to send, and because we want it to be an applicative,
we’ll add constructors to represent <code>pure</code> and <code>(&lt;*&gt;)</code>:</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Query</span> a <span>where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span>QueryAndParse</span> <span>::</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span>FromJSON</span> x <span>=&gt;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span>ERP.Request</span> <span>-&gt;</span> (x <span>-&gt;</span> <span>Either</span> <span>Text</span> a) <span>-&gt;</span> <span>Query</span> a</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span>-- Extra constructors to hold applicative structure</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  <span>Pure</span><span> ::</span> a <span>-&gt;</span> <span>Query</span> a</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  <span>Ap</span><span> ::</span> <span>Query</span> (a <span>-&gt;</span> b) <span>-&gt;</span> <span>Query</span> a <span>-&gt;</span> <span>Query</span> b</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span>deriving</span> stock <span>instance</span> <span>Functor</span> <span>Query</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>Applicative</span> <span>Query</span> <span>where</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>  <span>pure</span> <span>=</span> <span>Pure</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>  <span>Pure</span> f <span>&lt;*&gt;</span> <span>Pure</span> x <span>=</span> <span>Pure</span> <span>$</span> f x</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>  <span>QueryAndParse</span> req f <span>&lt;*&gt;</span> <span>Pure</span> a <span>=</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    <span>QueryAndParse</span> req <span>$</span> <span>fmap</span> (<span>$</span> a) <span>.</span> f</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>  <span>-- Plus another seven cases, being careful that</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>  <span>-- each case obeys the applicative laws.</span></span></code></pre></div>
<p><code>QueryAndParse</code> is the only data constructor directly relevant to our
problem. It captures the request we want to make against the ERP, a
<code>FromJSON x</code> constraint so we can parse the raw response into some
intermediate type representing an API response, and a function <code>x -&gt; Either Text a</code> to extract just the data we want from that API
response.</p>
<p>This design could work, but it’s a fair amount of boilerplate, and the
next time we want an applicative like this we’d need to repeat most of
it. In the next section, we’ll use a free applicative to separate the
general “applicative” code from the specific “query and parse” code.</p>
<h2 id="what-is-a-free-structure">What is a “free structure”?</h2>
<p>To understand how free applicatives help us with this problem, we need
to have some idea what “freeness” means in this context. The Haskell
community usually talks about taking “the free <code>$class</code> over <code>$type</code>”
as a way to make <code>$type</code> an instance of <code>$class</code>, by adding <em>just
enough</em> structure to construct a lawful instance of <code>$class</code>. Packages
like <a href="https://hackage.haskell.org/package/free"><code>free</code></a> provide
wrapping types that hold values of <code>$type</code> and provide instances of
<code>$class</code>.</p>
<p>Let’s pare our <code>Query</code> type back to something much smaller: a type
representing a single request against our ERP:</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>OneQuery</span> a <span>where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span>QueryAndParse</span> <span>::</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span>FromJSON</span> x <span>=&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span>ERP.Request</span> <span>-&gt;</span> (x <span>-&gt;</span> <span>Either</span> <span>Text</span> a) <span>-&gt;</span> <span>OneQuery</span> a</span></code></pre></div>
<p>We will now re-write <code>Query</code> as the free <code>Applicative</code> over
<code>OneQuery</code>. To make <code>OneQuery</code> into an <code>Applicative</code>, we’ll use the
<code>Ap</code> wrapper from
<a href="https://hackage.haskell.org/package/free-5.2/docs/Control-Applicative-Free.html"><code>Control.Applicative.Free</code></a>.
Here is its interface:</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span>-- `Ap f` is the free applicative over `f`. We never use its</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span>-- constructors directly; instead, we use `liftAp` and the</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span>-- `Applicative` interface (`pure`, `(&lt;*&gt;)`, `liftA2`, etc.)</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Ap</span> f a</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span>-- For *any* `f`, `Ap f` is an applicative.</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>Applicative</span> (<span>Ap</span> f)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span>-- We can turn any `f a` into an `Ap f a`.</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span>liftAp ::</span> f a <span>-&gt;</span> <span>Ap</span> f a</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span>-- If we can turn our `f` into some applicative `g`, then we can turn</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span>-- `Ap f a` into `g a` in a way that respects the Applicative laws:</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span>--</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span>-- runAp _ (pure x) = pure x</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span>-- runAp f (x &lt;*&gt; y) = (runAp f x) &lt;*&gt; (runAp f y)</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span>--</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span>-- Similar to the `forall x. f x -&gt; g x` in `hoistHandle` above,</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a><span>-- this lets us turn each `f x` stored in the `Ap f a` into a</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a><span>-- corresponding `g x`, while remaining ignorant of the specific</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span>-- type `x`.</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a><span>runAp ::</span> <span>Applicative</span> g <span>=&gt;</span> (<span>forall</span> x<span>.</span> f x <span>-&gt;</span> g x) <span>-&gt;</span> <span>Ap</span> f a <span>-&gt;</span> g a</span></code></pre></div>
<p>We’ll skip the implementations because we won’t ever manually recurse
through an <code>Ap f a</code> value; from a modularity perspective, we are only
interested in the abstract interface. We declare <code>Query</code> as the free
applicative over <code>OneQuery</code>, make it a <code>newtype</code> to establish an
abstraction boundary between the query library and its callers, and
use <code>deriving newtype</code> to avoid writing any applicative structure
ourselves:</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>newtype</span> <span>Query</span> a <span>=</span> <span>Query</span> (<span>Free.Ap</span> <span>OneQuery</span> a)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> stock <span>Functor</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> <span>newtype</span> <span>Applicative</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span>-- Helper functions to avoid building `Query` values by hand.</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span>query ::</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  <span>FromJSON</span> a <span>=&gt;</span> <span>ERP.Request</span> <span>-&gt;</span> <span>Query</span> a</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>query _ req <span>=</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>  <span>Query</span> <span>.</span> Free.liftAp <span>$</span> <span>QueryAndParse</span> req <span>Right</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span>queryAndParse ::</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>  <span>FromJSON</span> a <span>=&gt;</span> <span>ERP.Request</span> <span>-&gt;</span> (a <span>-&gt;</span> <span>Either</span> <span>Text</span> b) <span>-&gt;</span> <span>Query</span> b</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>queryAndParse req f <span>=</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>  <span>Query</span> <span>.</span> Free.liftAp <span>$</span> <span>QueryAndParse</span> req f</span></code></pre></div>
<h2 id="building-a-query">Building a <code>Query</code></h2>
<p>From this infrastructure, we can write functions representing
individual queries. These are direct applications of the <code>query</code> and
<code>queryAndParse</code> helpers:</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span>queryLocationId ::</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span>ERP.Location.Name</span> <span>-&gt;</span> <span>Query</span> <span>ERP.Location.Id</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>queryLocationId locationName <span>=</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  query <span>$</span> ERP.lookupLocation locationName</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span>queryOrderId ::</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  <span>ERP.Order.Name</span> <span>-&gt;</span> <span>Query</span> <span>ERP.Order.Id</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>queryOrderId orderName <span>=</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  queryAndParse</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    (ERP.searchOrders orderName) <span>$</span> \<span>case</span> <span>-&gt;</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>      [order] <span>-&gt;</span> <span>Right</span> order</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>      (_<span>:</span>_) <span>-&gt;</span> <span>Left</span> <span>&#34;Multiple Orders in response&#34;</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>      [] <span>-&gt;</span> <span>Left</span> <span>&#34;No Orders in response&#34;</span></span></code></pre></div>
<p>From these functions we can build up complex queries using applicative
operations:</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span>queryOrderAndLocation ::</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span>ERP.Order.Name</span> <span>-&gt;</span> <span>ERP.Location.Name</span> <span>-&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span>Query</span> (<span>ERP.Order.Id</span>, <span>ERP.Location.Id</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>queryOrderAndLocation orderName locationName <span>=</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  liftA2 (,) (queryOrderId orderName) (queryLocationId locationName)</span></code></pre></div>
<h2 id="running-a-query">Running a <code>Query</code></h2>
<p>We can run a <code>Query</code> by using
<a href="https://hackage.haskell.org/package/free-5.2/docs/Control-Applicative-Free.html#v:runAp"><code>runAp</code></a>.
Because we’re in an applicative context and we’re making requests that
don’t alter the remote system, we can run every request and use a
<a href="https://hackage.haskell.org/package/validation-selective"><code>Validation</code></a>
to collect all failures:</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>RunQueryError</span> e <span>=</span> <span>RequestError</span> e <span>|</span> <span>JsonError</span> <span>Text</span> <span>|</span> <span>ParseResultError</span> <span>Text</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span>type</span> <span>RunQueryErrors</span> e <span>=</span> <span>NonEmpty</span> (<span>RunQueryError</span> e)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span>runQuery ::</span> <span>forall</span> e m a<span>.</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span>Monad</span> m <span>=&gt;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  <span>ERP.Handle</span> e m <span>-&gt;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  <span>Query</span> a <span>-&gt;</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  m (<span>Validation</span> (<span>RunQueryErrors</span> e) a)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>runQuery <span>ERP.Handle</span>{performRequest} (<span>Query</span> q) <span>=</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  getCompose <span>$</span> Free.runAp (<span>Compose</span> <span>.</span> go) q</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>  <span>where</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span>    go ::</span> <span>OneQuery</span> x <span>-&gt;</span> m (<span>Validation</span> (<span>RunQueryErrors</span> e) x)</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    go (<span>QueryAndParse</span> req parse) <span>=</span> performRequest req <span>&lt;&amp;&gt;</span> \<span>case</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>      <span>Left</span> reqErr <span>-&gt;</span> <span>Failure</span> <span>.</span> NonEmpty.singleton <span>$</span> <span>RequestError</span> reqErr</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>      <span>Right</span> value <span>-&gt;</span> <span>case</span> Aeson.parseEither Aeson.parseJSON value <span>of</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>        <span>Left</span> jsonErr <span>-&gt;</span> <span>Failure</span> <span>.</span> NonEmpty.singleton <span>.</span> <span>JsonError</span> <span>$</span> Text.pack jsonErr</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>        <span>Right</span> x <span>-&gt;</span> <span>case</span> parse x <span>of</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>          <span>Left</span> parseErr <span>-&gt;</span> <span>Failure</span> <span>.</span> NonEmpty.singleton <span>$</span> <span>ParseResultError</span> parseErr</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>          <span>Right</span> a <span>-&gt;</span> <span>Success</span> a</span></code></pre></div>
<p>The implementation can be mostly derived by following the types, but
we’ll highlight some specifics:</p>
<ul>
<li><p><code>Validation e a</code> is a type that’s structurally isomorphic to
<code>Either e a</code>, but provides an <code>Applicative</code> instance that
accumulates errors:</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span>-- From the validation-selective package.</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>Semigroup</span> e <span>=&gt;</span> <span>Applicative</span> (<span>Validation</span> e) <span>where</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span>pure</span> <span>=</span> <span>Success</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  <span>-- This asymmetric way of writing &lt;*&gt; maximises laziness.</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  <span>Failure</span> e1 <span>&lt;*&gt;</span> b <span>=</span> <span>Failure</span> <span>$</span> <span>case</span> b <span>of</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span>Failure</span> e2 <span>-&gt;</span> e1 <span>&lt;&gt;</span> e2</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span>Success</span> _  <span>-&gt;</span> e1</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>  <span>Success</span> _ <span>&lt;*&gt;</span> <span>Failure</span> e <span>=</span> <span>Failure</span> e</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>  <span>Success</span> f <span>&lt;*&gt;</span> <span>Success</span> a <span>=</span> <span>Success</span> (f a)</span></code></pre></div></li>
<li><p>Since the composition of any two applicatives is itself an
applicative,
<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Functor-Compose.html#t:Compose"><code>Data.Functor.Compose</code></a>
lets us combine the <code>m</code> and <code>Validation e</code> applicatives into
<code>Compose m (Validation e)</code>, which executes actions in <code>m</code> and
accumulates errors — exactly what we want.</p></li>
<li><p>Since we use the <code>Compose</code> constructor to wrap the result of <code>go</code>,
<code>Free.runAp</code> will return a <code>Compose m (Validation e) a</code> which we
must unwrap with <code>getCompose</code>.</p></li>
<li><p>The <code>go</code> function processes a single request held in a <code>OneQuery x</code>,
and <code>Free.runAp</code> uses it to build up the applicative combination of
each result.</p></li>
<li><p>We accept a handle telling us how to contact the ERP. This is the
key location where the handle pattern and the free applicative
interact, giving the library user a lot of power: the handle
parameter frees us from being coupled to any particular monad and
makes it easier to write tests for this code. We’ll see another way
to construct a <code>ERP.Handle</code> very soon.</p></li>
<li><p>The caller of the <code>Query</code> interface has no idea that we’re building
and consuming free structures under the hood. It’s an implementation
detail that doesn’t distort the abstraction boundary at all.</p></li>
</ul>

<p>Now that we can execute queries, let’s explore the main benefit of
free applicatives: the ability to analyse the applicative program
without running it. We can extract a monoidal summary of any free
applicative’s structure via
<a href="https://hackage.haskell.org/package/free-5.2/docs/Control-Applicative-Free.html#v:runAp_"><code>runAp_</code></a>:</p>
<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span>runAp_ ::</span> <span>Monoid</span> m <span>=&gt;</span> (<span>forall</span> x <span>.</span> f x <span>-&gt;</span> m) <span>-&gt;</span> <span>Ap</span> f a <span>-&gt;</span> m</span></code></pre></div>
<p>For an intuition why this is true, consider that the constant functor
<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Functor-Const.html#t:Const"><code>Const r</code></a>
has an <code>Applicative</code> instance whenever <code>r</code> is a monoid, because <code>pure</code>
stores a <code>mempty</code> value and <code>(&lt;*&gt;)</code> combines the held values with
<code>(&lt;&gt;)</code>. For a fun exercise, implement <code>runAp_</code> in terms of <code>runAp</code> and
<code>Const</code>.</p>
<p>We can use <code>runAp_</code> to extract a list of every request a <code>Query a</code>
will send:</p>
<div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span>allRequests ::</span> <span>Query</span> a <span>-&gt;</span> [<span>Request</span>]</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>allRequests (<span>Query</span> q) <span>=</span> ordNub <span>$</span> Free.runAp_ go q</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span>where</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span>    go ::</span> <span>OneQuery</span> x <span>-&gt;</span> [<span>Request</span>]</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    go (<span>QueryAndParse</span> req _) <span>=</span> [req]</span></code></pre></div>
<p>Once we have the list of requests, we can look for ways to optimise
them. De-duplicating the requests with
<a href="https://hackage-content.haskell.org/package/relude-1.2.2.2/docs/Relude-Nub.html#v:ordNub"><code>ordNub</code></a>
is an easy optimisation, but if the remote API supports it, we could
do more advanced optimisations like using a batch request API.</p>
<p>As a simple demonstration, we can perform all the lookup requests in
advance and construct a <code>Map Request Aeson.Value</code>:</p>
<div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span>type</span> <span>SavedRequests</span> <span>=</span> <span>Map</span> <span>Request</span> <span>Aeson.Value</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span>saveRequests ::</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span>forall</span> e m<span>.</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span>Monad</span> m <span>=&gt;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  <span>Handle</span> e m <span>-&gt;</span> [<span>Request</span>] <span>-&gt;</span> m (<span>Either</span> e <span>SavedRequests</span>)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>saveRequests <span>Handle</span>{performRequest} requests <span>=</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>  runExceptT <span>$</span> Map.fromList <span>&lt;$&gt;</span> <span>traverse</span> go requests</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>  <span>where</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span>    go ::</span> <span>Request</span> <span>-&gt;</span> <span>ExceptT</span> e m (<span>Request</span>, <span>Aeson.Value</span>)</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    go req <span>=</span> (req,) <span>&lt;$&gt;</span> <span>ExceptT</span> <span>$</span> performRequest req</span></code></pre></div>
<p>Using a collection of saved results, we can construct a handle that
returns the saved responses instead of performing real requests:</p>
<div id="cb17"><pre><code><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span>newtype</span> <span>UnsavedRequestError</span> <span>=</span> <span>UnsavedRequestError</span> <span>Request</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span>newHandleFromSavedRequests ::</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  (<span>Applicative</span> m) <span>=&gt;</span> <span>SavedRequests</span> <span>-&gt;</span> <span>Handle</span> <span>UnsavedRequestError</span> m</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>newHandleFromSavedRequests requests <span>=</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  <span>Handle</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    { performRequest <span>=</span> \req <span>-&gt;</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>        <span>pure</span> <span>.</span> <span>maybe</span> (<span>Left</span> (<span>UnsavedRequestError</span> req)) <span>Right</span> <span>$</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>          Map.lookup req requests</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>This gives us a great story for testing. Since our <code>runQuery</code> works
with any handle, we can capture some real requests to a file, redact
any sensitive information, and create a pure handle built from saved
requests. We can then use this handle to write test cases that run
real code without performing side-effects.</p>
<p>If this example moved too quickly, or you want to see another
application of free structures, Justin Le has a spectacular post on
<a href="https://blog.jle.im/entry/free-alternative-regexp.html">matching regular expressions using the free <code>Alternative</code></a>.</p>
<h2 id="payoffs-and-limitations">Payoffs and limitations</h2>
<p>What have we achieved? We decided that we wanted an applicative to
describe queries against our remote system. Instead of inventing a
complicated data structure to represent the syntax tree of <code>pure</code> and
<code>(&lt;*&gt;)</code> calls, we defined a type just to hold one request and took the
free applicative over it. We also used the handle pattern to ask for
only the side-effects that we needed. Both patterns are reasonably
easy to implement, and in exchange we got some pretty neat benefits
that would’ve been harder to realise with either technique alone:</p>
<ol>
<li><p>We can analyse a <code>Query</code> without running it, and use the <code>Query</code> to
inform the handle we do eventually use;</p></li>
<li><p>As a special case of (1), library users can code against a
convenient interface and request individual records, but we can
inspect the set of queries before we begin execution and issue
optimised, parallelised, de-duplicated and batched requests in
their place;</p></li>
<li><p>We don’t have to abort at the first failed request — we can
collect and report <em>every</em> problem with a <code>Query</code>; and</p></li>
<li><p>We can record and replay requests, giving us a great testing story
in the style of Ruby’s <a href="https://github.com/vcr/vcr"><code>vcr</code></a> library.</p></li>
</ol>
<p>It’s not all roses, though. We lose a significant amount of expressive
power by giving up the monadic interface. For APIs where we need to
interleave pure queries and side-effecting requests, losing the
<code>Monad</code> instance might be a bridge too far. Chris Penner <a href="https://chrispenner.ca/posts/expressiveness-spectrum#closer-to-the-sweet-spot">suggests
that <code>Selective</code> functors could be closer to the sweet spot</a>,
but then you lose the nice ergonomics of <a href="https://downloads.haskell.org/ghc/latest/docs/users_guide/exts/applicative_do.html#extension-ApplicativeDo"><code>-XApplicativeDo</code></a>.
Chris Done identifies an <a href="https://chrisdone.com/posts/applicative-wired-monad/">“Applicative-wired Monad” pattern</a>
which uses a monad only to plumb together applicative values.</p>
<p>So where does this leave us? The handle pattern has been working well
for us and we plan to continue refactoring code to use handles for the
foreseeable future. In narrow contexts where we want to take advantage
of static analysis, a well-chosen free applicative has given us a
surprising amount of modularity, testability and opportunities for
automatic optimisation. In the function that “runs” the free
applicative, these two idioms interacted in a very satisfying way: the
handle parameter gave us a lot of flexibility without asking library
users to write a lot of boilerplate.</p></section></div>
  </body>
</html>
