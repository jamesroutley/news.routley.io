<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.evalapply.org/posts/mycelium-clj/index.html">Original</a>
    <h1>Riff: A &#34;mycelium-clj&#34; for the Clojure ecosystem?</h1>
    
    <div id="readability-page-1" class="page"><div id="the-very-top"><main id="main"><article id="blog-post"><header><div><p>Riff: A &#34;mycelium-clj&#34; for the Clojure ecosystem?</p><p>In a world of concrete objects, steel frameworks bring sense and order. In a forest of composable tools, libraries and open-ended schemas, it would be the mycelia. A frustrated yet optimistic man muses &#34;Might such a thing come to be?&#34;.</p><hr/></div></header><section><p>A thousand library-flowers bloom, bushes and trees and vines and creepers grow, but if nothing reconnects them, the whole remains diluted and weak and unfathomable and forbidding.</p><p>In a world of concrete objects, steel frameworks bring sense and order.</p><p>In a forest of composable tools and libraries, it is the invisible mycelia.</p><p>I am dreaming of a tool. I want to name it <strong>mycelium-clj</strong>.</p><p>What I can&#39;t tell is if all this boils down to <em>&#34;Oh look, yet another internet rando witlessly reverse-engineered a cheap knock-off of RDF</em> <em>and the semantic web.&#34;.</em> Or if it is something practicable within the little village (relatively speaking) of Clojureland.</p><p>Spitballing ahead!</p><p>While Clojure the language itself is a joy to use, being <em>hosted</em> means it gives us a double edged sword, with reach (yay!), but also the <em>compounded</em> mass of the host ecosystem (Java, Javascript, .net CLR, mobile) <em>and</em> the Clojure-specific ecosystem (REPLs, IDEs, libraries, tools). The more full stack we try to go, the more unwieldy the whole gets.</p><p>For example, the joy of libraries is that you get to choose. The agony of libraries is that you <em><strong>have</strong></em> to choose. So goes for the other chess pieces. All told it gets quite overwhelming quite fast, at least in my experience. Ultimately everyone gives up and uses the &#34;phone a friend&#34; option (if they even have one).</p><p>Yours truly phoned his friends.</p><p>A few weeks ago, I decided to jump into full stack Clojure web development for my &#34;<a href="https://www.recurse.com/blog/185-do-more-than-you-think">Impossible Stuff Day</a>&#34; project at the Recurse Center. For that, I started spinning up all the machinery. And by &#34;all&#34; I mean the whole nine yards—working through the multifarious build tool options, REPL choices, editor options, IDE integration options (editor + build + REPL), package management tools and conventions, library options, project conventions etc. And the spinning up has spun veeeery slowly.</p><p>Now, I am willing to incur the effort and hair loss to find and traverse the vast knowledge graph of all this machinery, only because I am optimistic about the (eventual) payoff.</p><p>As it happens, though, I am not alone in feeling frustrated and confused.</p><p>Whatsapp rants to the aforementioned friends elicited a &#34;Alas, &#39;tis so.&#34;. A bunch of :+1:s and :sweat-smile:s rapidly followed. These veteran Clojurists, each with over a decade of experience running Clojure in production, had felt that &#34;full stack&#34; burn too. Oh the schadenfreude. Woe be the newcomer professional programmer. Pity the hapless absolute beginner.</p><p>As much as I dislike how confusing it has been, I am telling myself it is a sign that the ecosystem bigger and more diverse than most people believe. I am optimistic that much of the gallimaufry can be tamed with good curated documentation and tools, which people seem to be interested in (e.g the <a href="https://www.clojuriststogether.org/news/july-and-august-2023-long-term-project-updates/">recent Clojurists Together &#34;long term funding&#34; round</a> heavily features documentation and tools authors). Hopefully this &#34;ecosystem knowledge and tools&#34; situation will improve in the coming years.</p><p>What is not on that list is a Rails clone as a &#34;killer app&#34;. The idea pops up regularly in this line of discussion. Personal tastes notwithstanding, I think frameworks are at odds with the emergent architecture of Clojureland itself, which falls out of the fact that embraces functional composition <em>with</em> à la carte polymorphism. The Expression Problem solved. Not objects, but also not pure functions alone. Both. Properties of both together engender dynamic networks with open-ended participation.</p><p>If not one framework to rule them all, a cookbook of sorts could be a solution, but it would have to be a living document. Ecosystems change, and the Clojure ecosystem has been changing quite rapidly. Apparently, a capable, stable, backwards compatible language substrate is playground for fantastic creativity and innovation. Plus we also get access to host ecosystem creativity. That&#39;s a <em>lot</em> of change to track!</p><p>Which brings us back to the problem of mechanical knowledge graphs.</p><p>Analogous to the dependency graph resolving core of Clojure cli, a <strong>mycelium-clj</strong> will dynamically construct ecosystem pathways and graphs that you and I can traverse and query as human beings.</p><ul><li>Start at (almost) nothing, and it will show you what&#39;s out there and reveal the interconnections.</li><li>It will source information from disparate sources and make them available in context.</li><li>It will let content writers and maintainers participate in the graph.</li><li>It could be a schema specification with globally namespaced structure, semantics, and open-ended interfaces.</li><li>Maybe it will integrate dependency graphs generated by dev tools. Maybe it will run basis &#34;microformats&#34; style machine-readable metadata. Maybe a shared ontology encoded using EDN (Garden of EDN, anyone?!), that authors can use to add metadata to their projects (books, blog posts, libraries etc.).</li></ul><p>An example <strong>mycelium</strong> session would address general questions like:</p><ul><li>&#34;I want to make a :full-stack :database backed :web application.&#34;. Starting from here it would take you down decision trees. Choose set of capabilities #{primary store, search, cache …, unsure}, set of frontend or backend language choices #{clj, cljs, java, javascript, unsure}, set of transport formats #{json, edn, xml, avro, unsure}, set of build tools #{lein, cli-tools, npm, unsure}. Next, for each it would pull up library options, preferably with import instructions for the chosen build tool, link to the docs, and some quickstart summary. Finally, it would use the build tool to generate a skeleton project with the appropriate config files, directory structure, dependencies, editor hookups etc.</li></ul><p>As well as more specific questions like:</p><ul><li>&#34;I want to make a :full-stack :web-app with :postgres, :elasticsearch, :kafka, :clojure, :cljs, :re-frame, :cli-tools, :reitit, :edn, :clojure-test.&#34; would generate its own decision tree.</li></ul><p>As well as other fanciful stuff on those lines…</p><p>A man can dream, no?</p><figure><img src="https://imgs.xkcd.com/comics/sandboxing_cycle.png" alt=""/><figcaption><a href="https://xkcd.com/2044/">xkcd 2044</a>: &#34;Sandboxing Cycle&#34;. Or, the karmic wheel of unbundling and bundling.</figcaption></figure><p>—</p><p><em>(Narrator: And with that he turned his gaze back to the abyss of his command line, where the crashed clj command remained crashed…)</em></p></section></article></main></div></div>
  </body>
</html>
