<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.righto.com/2023/02/silicon-reverse-engineering-intel-8086.html">Original</a>
    <h1>Silicon reverse-engineering: the Intel 8086 processor&#39;s flag circuitry</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-3839508062709299408" itemprop="description articleBody">


<p>Status flags are a key part of most processors, indicating if an arithmetic result
is negative, zero, or has a carry, for instance.
In this post, I take a close look at the flag circuitry in the Intel 8086 processor (1978), the chip that launched the PC revolution.<span id="fnref:8088"><a href="#fn:8088">1</a></span>
Looking at the silicon die of the 8086 reveals how its flags are implemented.
The 8086&#39;s flag circuitry is surprisingly complicated, full of corner cases and special handling.
Moreover, I found an undocumented zero register that is used by the microcode.</p>
<p>The die photo below shows the 8086 microprocessor under a microscope.
The metal layer on top of the chip is visible, with the silicon and polysilicon mostly hidden underneath.
Around the edges of the die, bond wires connect pads to the chip&#39;s 40 external pins.
I&#39;ve labeled the key functional blocks; the ones that are important to this discussion are darker and will be discussed in detail below.
The Arithmetic/Logic Unit (ALU, lower left) is split in two. The circuitry for the flags is in the middle, giving it access to the ALU&#39;s results
for the low byte and the high byte.
I&#39;ve marked each flag latch in red in the diagram below.
They appear to be randomly scattered, but there are reasons for this layout.</p>
<p><a href="https://static.righto.com/images/8086-flags/die-labeled.jpg"><img alt="The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version." height="588" src="https://static.righto.com/images/8086-flags/die-labeled-w600.jpg" title="The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version." width="600"/></a></p><p>The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.</p>
<h2>Flags and arithmetic operations</h2>
<p>The 8086 supports three types of arithmetic: unsigned arithmetic, signed arithmetic, and BCD (Binary-Coded Decimal) and this is a key to
understanding the flags.
Unsigned arithmetic uses standard binary values: a byte holds an integer value from 0 to 255, while a 16-bit word holds a value from 0 to 65535.
When adding, a carry indicates that the result is too big to fit in a byte or word.
(I&#39;ll use byte operations to keep the examples small; operations on words are similar.)
For instance, suppose you add hex 0x60 + 0x30. The result, 0x90, fits in a byte so there is no carry.
But adding 0x90 + 0x90 yields 0x120. This result doesn&#39;t fit in a byte, so the result is 0x20 with
the carry flag set to 1.
The carry allows additions to be chained together, like doing long decimal addition on paper.
For subtraction, the carry bit indicates a borrow.</p>
<!--
If you use an add-with-carry (ADC) instruction
on the next higher byte, any carry will be automatically added in. Thus, the carry bit allows adding arbitrarily long numbers.
-->

<p>The second type of arithmetic is 2&#39;s complement, which supports negative numbers. In a signed byte, 0x00 to 0x7f represent 0 to 127, while
0x80 to 0xff represent -128 to -1.
If the top bit of a signed value is set, the value is negative; this is what the sign flag indicates.
The clever thing about 2&#39;s complement arithmetic is that the same instructions are used for unsigned arithmetic and 2&#39;s complement
arithmetic. The only thing that changes is the interpretation.
As an example of signed arithmetic, 0xff + 0x05 = 0x04 corresponds to -1 + 5 = 4.
Signed arithmetic can result in overflow, though.
For example, suppose you add 112 + 112: 0x70 + 0x70 = 0xe0. Although that is fine in unsigned arithmetic, in signed arithmetic that result
is unexpectedly -32.
The problem is that the result doesn&#39;t fit in a single signed byte. In this case, the overflow flag is set to indicate that the
result overflowed.
In other words, the carry flag indicates that an unsigned result doesn&#39;t fit in a byte or word, while the overflow flag indicates that a signed
result doesn&#39;t fit.</p>
<p>The third type of arithmetic is BCD (Binary-Coded Decimal), which stores a decimal digit as a 4-bit binary value.
Thus, two digits can be packed into a byte.
For instance, adding 12 + 34 = 46 corresponds to 0x12 + 0x34 = 0x46 with BCD.
After adding or subtracting BCD values, a special instruction is needed to perform any necessary adjustment.<span id="fnref:bcd"><a href="#fn:bcd">2</a></span>
This instruction needs to know if there was
a carry from the lower digit to the upper digit, i.e. a carry from bit 4 to bit 3.
Many systems call this a half-carry, since it is the carry out of a half-byte, but Intel calls it the auxiliary carry flag.</p>
<p>The diagram below summarizes the 8086&#39;s flags.
The overflow, sign, auxiliary carry, and carry flags were discussed above.
The zero flag simply indicates that the result of an operation was zero.
The parity flag counts the number of 1 bits in a result byte and the flag is set if the number of 1 bits is even.
At the left are the three control flags. The trap flag turns on single-stepping mode.
The direction flag controls the direction of string operations.
Finally, the interrupt flag enables interrupts.</p>
<p><a href="https://static.righto.com/images/8086-flags/flag-diagram.jpg"><img alt="The control and status flags in the 8086. Diagram from iAPX 86/88 Users Manual fig 2.9." height="230" src="https://static.righto.com/images/8086-flags/flag-diagram-w400.jpg" title="The control and status flags in the 8086. Diagram from iAPX 86/88 Users Manual fig 2.9." width="400"/></a></p>
<p>The status flags are often used with the <code>CMP</code> (Compare) instruction, which performs a subtraction without storing the result.
Although this may seem pointless, the status flags show the relationship between the values.
For instance, the zero flag will be set if the two values are equal. Other flag combinations indicate &#34;less than&#34;, &#34;greater than&#34;, and other
useful conditions.
Loops and <code>if</code> statements use conditional jump instructions that test these flags.
(I wrote more about 8086 conditional jumps <a href="https://www.righto.com/2023/01/reverse-engineering-conditional-jump.html">here</a>.)</p>
<h2>Microcode and flags</h2>
<p>Most people think of machine instructions as the basic steps that a computer performs.
However, many processors (including the 8086) have another layer of software underneath: microcode.
Instead of building the processor&#39;s control logic out of flip-flops and gates,
microcode replaces much of the control logic with code.
To execute a machine instruction, the computer internally executes several simpler micro-instructions, specified by the microcode.
The main advantage of microcode is that it turns the design of control circuitry into a programming task instead of a difficult logic design task.</p>
<p>An 8086 micro-instruction is encoded into 21 bits as shown below.
Every micro-instruction contains a move from a source register to a destination register, each specified with 5 bits.
The meaning of the remaining bits depends on the type field, which is two or three bits long.
For the current discussion, the most relevant part of the microcode is the Flag bit <code>F</code> at the end, which indicates that the micro-instruction will update the flags.<span id="fnref:not"><a href="#fn:not">3</a></span></p>
<p><a href="https://static.righto.com/images/8086-flags/microcode-format.jpg"><img alt="The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?" height="203" src="https://static.righto.com/images/8086-flags/microcode-format-w700.jpg" title="The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?" width="700"/></a></p>


<p>As an example, the microcode below implements the <code>INC</code> (increment) and <code>DEC</code> (decrement) instructions.
The first micro-instruction moves a word from the register specified by the instruction (indicated by <code>M</code>) to the ALU&#39;s temporary B register.
It sets up the ALU to perform the operation specified by the instruction (indicated by <code>XI</code>), and indicates that the next micro-instruction (<code>NX</code>)
is the last for this machine instruction.
The second micro-instruction moves the ALU result (<code>Σ</code>) to the specified register (<code>M</code>), tells the system to run the next instruction <code>RNI</code>, and
causes the flags (<code>F</code>) to be updated from the ALU result. Thus, the flags are updated with the results of the increment
or decrement.</p>
<pre>   move       action
1 M→tmpb   XI    tmpb, NX
2 Σ→M      RNI   F
</pre>

<p>This microcode is rather generic: it doesn&#39;t explicitly specify the register or the ALU operation.
Instead, the gate logic determines them from the machine instruction.
This illustrates the 8086&#39;s hybrid approach: although the 8086 uses microcode, the microcode is parameterized and much of the instruction functionality is implemented with gate logic.
When the microcode specifies a generic Arithmetic/Logic Unit (ALU) operation, the gate logic determines from the instruction which ALU (Arithmetic/Logic Unit) operation to perform (in this case, increment or decrement).
The gate logic also determines from the instruction bits which register to modify.
Finally, the microcode says to update the flags, but the ALU determines how to update the flags.
This hybrid approach kept
the microcode small enough for 1978 technology; the microcode above supports 16 different increment and decrement instructions.</p>
<p>Microcode can also read or write the flags as a whole, treating the flags as a register. The
first micro-instruction below stores the flags to memory (via the OPerand Register),
while the second micro-instruction below loads the flags from memory.
The first micro-instruction is part of the microcode for <code>PUSHF</code> (push flags to the stack) and interrupt handling. 
The second micro-instruction is used for <code>POPF</code> (pop flags from the stack), the interrupt return code, and the reset code.
Similar micro-instructions are used for <code>LAHF</code> (Load AH from Flags) and <code>SAHF</code> (Store AH to Flags).</p>
<pre>  F→OPR
  OPR→F
</pre>

<p>Microcode can also modify some flags directly with the micro-operations
<code>CCOF</code> (Clear Carry and Overflow Flags),
<code>SCOF</code> (Set Carry and Overflow Flags), and
<code>CITF</code> (Clear Interrupt and Trap Flags).
The first two are used in the microcode for multiplication and division, while the third is used in the interrupt handler.</p>
<p>Finally, some machine instructions are implemented directly in logic and do not use microcode at all.
The <code>CMC</code> (Complement Carry),
<code>CLC</code> (Clear Carry), <code>STC</code> (Set Carry),
<code>CLI</code> (Clear Interrupt), <code>STI</code> (Set Interrupt),
<code>CLD</code> (Clear Direction), and <code>STD</code> (Set Direction) instructions modify the flags directly without running any microcode.
(During instruction decoding, the Group Decode ROM indicates that these instructions are implemented with logic, not microcode.)</p>
<h2>The latch circuit that stores flags</h2>
<p>Each flag is stored in a latch circuit that holds the flag&#39;s value until it is updated.
A typical flag latch has two inputs for updates: the flag value generated by the ALU, and a value from the bus when storing to all the flags.
The latch also has a &#34;hold&#34; input to keep the existing value.
(Some flags, such as carry, have more inputs, as will be described below.)
A multiplexer (built from pass transistors) selects one of the inputs for the latch.</p>
<p><a href="https://static.righto.com/images/8086-flags/latch.jpg"><img alt="A typical latch to hold a flag. The latch is constructed from NMOS transistors and inverters. A &#34;1&#34; input turns on a transistor, letting its input pass through it." height="223" src="https://static.righto.com/images/8086-flags/latch-w450.jpg" title="A typical latch to hold a flag. The latch is constructed from NMOS transistors and inverters. A &#34;1&#34; input turns on a transistor, letting its input pass through it." width="450"/></a></p><p>A typical latch to hold a flag. The latch is constructed from NMOS transistors and inverters. A &#34;1&#34; input turns on a transistor, letting its input pass through it.</p>
<p>The latch is based on pass transistors and two inverters forming a loop.
To see how it works, suppose <code>select 1</code> is high. This turns on the transistor letting the <code>in 1</code> value flow through the transistor and the
first inverter. When <code>clk&#39;</code> is high, the signal will flow through the second inverter and the output.
While <code>hold</code> is high, the output is fed back from the output to the input, causing the latch to &#34;remember&#34; its value.
The latch is controlled by the CPU&#39;s clock and it will only update the output when <code>clk&#39;</code> is high.
While <code>clk&#39;</code> is low, the output will remain unchanged; the capacitance of the wire is enough to provide an input to the second inverter, a bit like dynamic RAM.<span id="fnref:latch"><a href="#fn:latch">4</a></span></p>
<p>The diagram below shows how one of these latches looks on the die. The pinkish regions are doped silicon, while the brownish lines are polysilicon.
A transistor gate is formed where polysilicon crosses over doped silicon. Each inverter consists of two transistors.
The signal flows through the latch in roughly a counterclockwise circle, starting with one of the inputs on the right.</p>
<p><a href="https://static.righto.com/images/8086-flags/latch-die.jpg"><img alt="The latch for the Sign Flag. The metal layer was removed for this image." height="411" src="https://static.righto.com/images/8086-flags/latch-die-w400.jpg" title="The latch for the Sign Flag. The metal layer was removed for this image." width="400"/></a></p><p>The latch for the Sign Flag. The metal layer was removed for this image.</p>
<h2>Implementation of the flags</h2>
<p>In this section, I&#39;ll discuss each flag in detail.
But first, I&#39;ll explain the circuitry common to all the flags.
As explained above, microcode can treat the flags as a register, reading or writing all the flags in parallel.
When the microcode specifies flags as the destination for a move, a signal is generated that I call <code>flags-load</code>.
This signal enables the multiplexer inputs (described above) that connect the ALU bus to the flag latches, loading the bits into the latches.
Conversely, when microcode specifies the flags as the source for a move, a signal is generated that
I call <code>flags-read</code>.<span id="fnref:flag-read"><a href="#fn:flag-read">5</a></span>
This signal connects the outputs of the flag latches to the ALU bus through pass transistors, loading the value of the flags onto the bus.</p>
<!--
The interrupt, trap, and direction flags are updated separately.
Among the arithmetic operations, there are various special cases. Increment and decrement don't affect the carry flag.
Multiplication, division, the BCD operations (AAS, DAS, DAA, AAA) have various effects on the flags.
Logical operations typically set sign, zero, and parity based on the operation while clearing overflow and carry and leaving auxiliary carry undefined.
Shift operations set sign, zero, and parity based on the operation, while the carry is the last bit shifted out and overflow indicates the
value changed sign.
Rotates, on the other hand, only affect carry and overflow.
Several instructions affect flags directly: CLC (clear carry), STC (set carry), CMC (complement carry), CLD (clear direction), STD (set direction),
CLI (clear interrupt), STI (set interrupt).
Interrupts clear the interrupt and trap flags.
-->

<h3>Sign flag</h3>
<p>The sign flag is pretty simple: it stores the top bit of the ALU result, indicating a negative result. For a byte operation, this is bit 7 and for a word operation, bit 15, so some logic selects the right bit based on the instruction.
(This is another example of how logic circuitry looks after the details that microcode ignores.)
The output from the sign flag goes to the condition evaluation circuitry to support conditional jumps, as do the other arithmetic flags. I wrote about that <a href="https://www.righto.com/2023/01/reverse-engineering-conditional-jump.html">recently</a>, so I won&#39;t go into details here.</p>
<p>The six arithmetic status flags are updated by arithmetic operations when the microcode <code>F</code> bit is set.
This bit generates a signal that I call <code>arith-flag-load</code>, indicating that the flags should be updated based on the ALU result.
This signal enables the multiplexer inputs between the ALU circuitry and the flag latches.
There is an inconvenient special case: rotate instructions only update the overflow and carry flags for compatibility with the 8080 processor.<span id="fnref:rotate"><a href="#fn:rotate">6</a></span>
To support this, a rotate instruction blocks the <code>arith-flag-load</code> signal for the sign, parity, zero, and auxiliary carry flags.
Again, this is handled by gates, rather than microcode.</p>
<h3>Zero flag</h3>
<p>The zero flag is also straightforward. It indicates that the result byte or word is all zeros, for a byte or word operation respectively.
An 8-input NOR gate at the top of the flags circuitry determines if the lower byte is all zeros, while an 8-input NOR gate at the bottom of
the flags circuitry tests the upper byte. These NOR gates are spread out and span the width of the ALU, essentially a wire that is pulled low by any result bits that are high.
The zero flag is set based on the low byte or the whole word, for a byte instruction or word instruction respectively.</p>
<p>There is a second zero flag, hidden from the programmer. This zero flag always tests the full 16-bit result, so I&#39;ll call it Z16.
The other key difference is that the Z16 flag is updated on every ALU micro-operation, rather than under the control
of the <code>F</code> bit.
Thus, the Z16 flag can be updated without interfering with the programmer-visible zero flag.
This makes it useful for internal microcode operations, such as loops.</p>
<h3>Parity flag</h3>
<p>The parity flag is conceptually simple, but it is fairly expensive to implement in hardware as it requires exclusive-oring the eight bits of the result byte together.
This is implemented with seven XOR circuits.<span id="fnref:xor"><a href="#fn:xor">7</a></span>
Since each XOR circuit is implemented with two logic gates, the raw parity calculation requires 14 gates.
Only 8-bit parity is supported, even if a word operation is performed.<span id="fnref:parity"><a href="#fn:parity">8</a></span></p>
<p>The schematic below shows how an XOR circuit is implemented. It uses two gates; due to the properties of NMOS transistors, the AND-NOR gate is
implemented as a single gate.
To see how it works, suppose A and B are 0. The first NOR gate will output 1, forcing the output to 0.
If A and B are both 1, the AND gate will force the output to 0. Otherwise the output is 1, providing the XOR function.
The key point is that XOR is fairly costly compared to other logic functions.</p>
<p><a href="https://static.righto.com/images/8086-flags/xor.jpg"><img alt="Schematic of an XOR circuit." height="118" src="https://static.righto.com/images/8086-flags/xor-w350.jpg" title="Schematic of an XOR circuit." width="350"/></a></p><p>Schematic of an XOR circuit.</p>
<h3>Auxiliary carry flag</h3>
<p>The auxiliary carry starts off simple, but is complicated by the decimal adjust instructions.
In most cases, the auxiliary carry is carry-out from bit 3 of the ALU (i.e. the half-carry).
For subtraction, the flag must be inverted to indicate a borrow, so the half-carry is exclusive-or&#39;d with a subtraction signal.</p>
<p>However, the decimal adjust instructions (DAA, DAS, AAA, AAS) use the auxiliary carry and also modify the auxiliary carry when performing
a decimal adjust.
After an addition or subtraction, the decimal adjust instructions produce a correction value if necessary. 
If the lower digit is more than 9 or the auxiliary carry is set, the value 6 is added (or subtracted) from the accumulator.<span id="fnref:daa-9"><a href="#fn:daa-9">9</a></span>
The <code>DAA</code> and <code>AAA</code> instructions also test if a correction of 0x60 is needed for the upper digit.
The correction signals are wired to the ALU bus to generate the correction factor of 0x06, 0x60, or 0x66 for an adjustment ALU operation.
The correction signal for the low digit is stored as the auxiliary carry flag.</p>
<h3>Carry flag</h3>
<p>The carry flag is surprisingly complex, with five inputs to the carry flag input multiplexer.
The first input is the carry value for an ALU operation:<span id="fnref:inc"><a href="#fn:inc">10</a></span> the top bit of the ALU result (bit 7 or 15 for a byte or word operation).
However, for a subtraction the carry is inverted to form the borrow.
But for a <code>DAA</code> or <code>DAS</code> decimal adjust operation, the carry comes from the high-digit correction signal.
And for an <code>AAA</code> or <code>AAS</code> ASCII adjust operation, the carry comes from the low-digit correction signal.
These cases are determined with logic gates and fed into a single multiplexer input.</p>
<p>Another multiplexer input supports the <code>CMC</code> (Complement Carry) instruction by feeding in the current flag value but inverted.
The <code>STC</code> and <code>CLC</code> (Set Carry and Clear Carry) instructions are implemented by feeding the low bit of the instruction into a different multiplexer input.
This input also supports the micro-instructions <code>SCOF</code> (Set Carry, Overflow Flags), <code>CCOF</code> (Clear Carry, Overflow Flags), and <code>RCY</code> (Reset Carry).</p>
<!-- See INC in Intel 64 and IA-32 Architectures Software Developer’s Manual vol 2, 3-506 -->

<p>The rotate and shift instructions have complex interactions with the carry flag, since bits are shifted in and out of the carry flag.
For a shift or rotate, a separate multiplexer input provides the bit for the carry flag latch.
For a right shift or rotate, the lowest bit of the ALU argument is fed into the carry flag.
For a left shift or rotate, the carry out of bit 15 or bit 7 is fed into the carry flag; this was the highest bit for a word or byte operation respectively.</p>
<p>The output from the carry flag is fed into the ALU&#39;s carry-in for the <code>ADC</code> (Add with Carry), <code>SBB</code> (Subtract with Borrow), and <code>RCL</code> (Rotate through Carry, Left) instructions; the carry is inverted for <code>SBB</code> to form the borrow.
For an <code>RCR</code> (Rotate through Carry, Right), the carry is fed into the ALU&#39;s output bit 7 or 15 (for a byte or word operation respectively).</p>
<h3>Overflow flag</h3>
<p>The circuitry for the overflow flag is fairly complicated, as there are multiple cases.
For an arithmetic operation, the overflow flag indicates a signed overflow.
The overflow is computed as the exclusive-or of the carry-in to the top bit and the carry-out from the top bit, selected for a byte or word operation.
(I explained the mathematics behind this <a href="https://www.righto.com/2012/12/the-6502-overflow-flag-explained.html">earlier</a>.)</p>
<p>For a shift or rotate, however, the overflow flag indicates that the shifted value changed sign.
The ALU implements left shifts and rotates by passing bits as carries so the old sign bit is the carry-out from the top bit, while the new sign bit is the carry-in to the top bit. Thus, the standard arithmetic overflow circuit also handles left shifts and rotates.
On the other hand, for a shift or rotate right, the top two bits of the result are exclusive-or&#39;d together to see if they are different: bits 6 and 7 for a byte shift and bits 14 and 15 for a word shift.
(The second-from-the-top bit was the sign bit before the shift.)</p>
<p>Finally, two micro-instructions affect the flag: <code>CCOF</code> (Clear Carry and Overflow Flags) and <code>SCOF</code> (Set Carry and Overflow Flags). 
All these different sources for the overflow flag are combined in logic gates, rather than a complex multiplexer like the carry flag used.</p>
<h3>Direction flag</h3>
<p>The three remaining flags are &#34;control&#34; flags: rather than storing the status of an ALU operation, these flags control the CPU&#39;s behavior.
The direction flag controls the direction of string operations that scan through memory: auto-incrementing or auto-decrementing.
This is implemented by feeding the direction flag into the Constant ROM to determine the increment value applied to the SI and DI registers.
The direction flag is set or cleared through the <code>STD</code> and <code>CLD</code> instructions (Set Direction and Clear Direction).
For these instructions, the low bit of the instruction is passed into the flag to set or clear it as appropriate.</p>
<h3>Interrupt flag</h3>
<p>The output from the interrupt flag goes to the interrupt handling circuitry to enable or disable interrupts.
This flag is set or cleared by a programmer through the <code>STI</code> and <code>CLI</code> instructions.
For the <code>STI</code> and <code>CLI</code> instructions, the low bit of the instruction is passed into the flag to set or clear it as appropriate.
Microcode can clear the interrupt flag and the trap flag (discussed below) with the <code>CITF</code> (Clear Interrupt and Trap Flag) micro-instruction.
This is used in the interrupt handler to disable subsequent interrupts and traps.
The <code>CITF</code> micro-instruction is implemented with a separate input to the flag latch.</p>
<h3>Trap flag</h3>
<p>The trap flag turns on single-stepping for debugging. With the trap flag on, every instruction generates an interrupt.
This flag doesn&#39;t have machine instructions to modify it directly.
Instead, the programmer must mess around with the <code>PUSHF</code> and <code>POPF</code> instructions to put all the flags on the stack and modify the flag bit there
(<a href="https://en.wikipedia.org/wiki/Trap_flag#Setting">details</a>).
Like the interrupt flag, the trap flag has an input to clear it if the <code>CITF</code> micro-instruction is active.</p>
<h2>Layout of the flag circuitry</h2>
<p>The diagram below shows the circuitry for the flags on the die, with the approximate location of each flag indicated.
ALU bits 7 through 0 are above this circuitry and ALU bits 15 through 8 are below.
The zero gates stretch the length of the ALU at the top and bottom, while the parity gates are near the low byte of the ALU.
The flag circuitry appears highly irregular on the die because each flag has different circuitry.
However, the circuitry for a flag is generally near the appropriate bit that receives the flag, so the layout is not as arbitrary as it may seem.
For instance, the sign flag is affected by bit 7 or 15 of the ALU result and is loaded or stored to bit 7, so it is at the left.
The trap and interrupt flags are outside the ALU, to the right of this image.</p>
<p><a href="https://static.righto.com/images/8086-flags/flags-die.jpg"><img alt="Closeup of the circuitry on the die that implements the flags. The metal layer has been removed to show the polysilicon and silicon underneath." height="429" src="https://static.righto.com/images/8086-flags/flags-die-w700.jpg" title="Closeup of the circuitry on the die that implements the flags. The metal layer has been removed to show the polysilicon and silicon underneath." width="700"/></a></p><p>Closeup of the circuitry on the die that implements the flags. The metal layer has been removed to show the polysilicon and silicon underneath.</p>
<h2>The history behind the 8086 flags<span id="fnref:blaauw"><a href="#fn:blaauw">11</a></span></h2>
<p>The <a href="https://bitsavers.org/pdf/datapoint/2200/2200_Programmers_Man_Aug71.pdf">Datapoint 2200</a> (1970) is a desktop computer that was sold as a &#34;programmable terminal&#34;.
Although mostly forgotten now, the Datapoint 2200 is one of the most influential computers ever, as it led to the 8086 processor and thus the modern x86 architecture.
For flags, the Datapoint 2200 had four &#34;control flip-flops&#34;: carry/borrow,<span id="fnref:borrow"><a href="#fn:borrow">12</a></span> zero, sign, and parity.
These were not bits in a register and could not be accessed directly. Instead, conditional jumps, subroutine calls, or subroutine returns could
be performed based on the status of one of these flip-flops.
Because the Datapoint 2200 was used as a terminal, and terminal protocols often used parity, implementing parity in hardware was a useful feature.</p>
<p>But how did the Datapoint 2200 lead to the 8086?
The Datapoint 2200 was created before the microprocessor, so its processor was a large board of TTL chips.
Datapoint asked Intel and Texas Instruments if they could replace this TTL processor with a single chip.
Texas Instruments created the TMX 1795, the first 8-bit microprocessor.
Intel created the 8008 shortly after. Both chips copied the instruction set and architecture of the 2200.
Datapoint didn&#39;t like either chip and stuck with TTL. Texas Instruments couldn&#39;t find a customer for the TMX 1795 and abandoned it. Intel, on the other hand, marketed the 8008 as a general-purpose microprocessor, essentially creating the microprocessor industry.
Since the 8008 copied the Datapoint 2200, it kept the four status flip-flops.</p>
<p>In 1974, Intel created the 8080 microprocessor, an improvement of the 8008.
The 8080 kept the flags from the 8008 and added the auxiliary carry.
Moreover, the flags could be accessed as a byte, making the flags appear like a register.
The 8080 defined specific values for the unused flag bits.
These decisions have persisted into the modern x86 architecture.<span id="fnref:8080"><a href="#fn:8080">13</a></span></p>
<!--
(The `PUSH PSW` and `POP PSW` instructions saved and restored Processor Status Word (i.e. the A register and flags) on the stack.)
-->

<p><a href="https://static.righto.com/images/8086-flags/8080-flags.jpg"><img alt="Structure of the 8080 flags when saved on the stack. From 8080 Assembly Language Programming Manual." height="204" src="https://static.righto.com/images/8086-flags/8080-flags-w400.jpg" title="Structure of the 8080 flags when saved on the stack. From 8080 Assembly Language Programming Manual." width="400"/></a></p>
<p>The 8086 was designed to be backward compatible with the 8080, at least at the assembly language level.<span id="fnref:8080-compat"><a href="#fn:8080-compat">14</a></span>
To support this, the 8086 kept the 8080&#39;s flag byte unchanged, putting additional flags in the high byte, as shown below.
Thus, the selection, layout, and behavior of the 8086 flags (and thus x86) are largely historical accidents going back to
the 8080, 8008, and Datapoint 2200 processors.</p>
<p><a href="https://static.righto.com/images/8086-flags/flag-word.jpg"><img alt="Arrangement of the 8086 flags in the word. The shaded flags match the 8080/8085 flags. Diagram from iAPX 86/88 Users Manual fig 2.10." height="49" src="https://static.righto.com/images/8086-flags/flag-word-w400.jpg" title="Arrangement of the 8086 flags in the word. The shaded flags match the 8080/8085 flags. Diagram from iAPX 86/88 Users Manual fig 2.10." width="400"/></a></p><p>Arrangement of the 8086 flags in the word. The shaded flags match the 8080/8085 flags. Diagram from <a href="http://www.bitsavers.org/components/intel/_dataBooks/1981_iAPX_86_88_Users_Manual.pdf">iAPX 86/88 Users Manual</a> fig 2.10.</p>
<h2>Conclusions</h2>
<p>You might expect flags to be a simple part of a CPU, but the 8086&#39;s flags are surprisingly complex.
About 1/3 of the ALU is devoted to flag computation and storage.
Each flag is implemented with completely different circuitry.
The 8086 is a CISC processor (Complex Instruction Set Computer), where the instruction set is designed to be powerful and to minimize the
gap between machine language and high-level languages.<span id="fnref:cisc"><a href="#fn:cisc">15</a></span>
This can be seen in the implementation of the flags, which are full of special cases to increase their utility with different instructions.<span id="fnref:morse"><a href="#fn:morse">16</a></span>
In contrast, a RISC (Reduced Instruction Set Computer) simplifies the instruction set to make each instruction faster.
This philosophy also affects the flags: for example, the <a href="http://www.bitsavers.org/pdf/acorn/ARM_DDI_0004D_ARM610_Data_Sheet_Aug93.pdf">ARM-1</a> processor (1985) has four arithmetic flags compared to the 8086&#39;s six flags.
The behavior of the ARM flags is simpler, and the ARM doesn&#39;t deal with byte versus word operations.
It also doesn&#39;t have instructions like decimal adjust that have complex flag behavior.
This simplicity is reflected in the simpler and more regular circuitry of the ARM-1 flags, which I reverse-engineered <a href="https://www.righto.com/2016/02/the-arm1-processors-flags-reverse.html">here</a>.</p>
<p>I&#39;ve written multiple <a href="https://www.righto.com/search/label/8086">posts on the 8086</a> so far and
plan to continue reverse-engineering the 8086 die so
follow me on Twitter <a href="https://twitter.com/kenshirriff">@kenshirriff</a> or <a href="http://www.righto.com/feeds/posts/default">RSS</a> for updates.
I&#39;ve also started experimenting with Mastodon recently as <a href="https://oldbytes.space/@kenshirriff">@<span data-cfemail="345b5850564d4051471a4744555751745f515a475c5d46465d5252">[email protected]</span></a>.</p>
<h2>Notes and references</h2>


</div></div>
  </body>
</html>
