<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.d12frosted.io/posts/2025-11-26-emacs-widget-library">Original</a>
    <h1>The Emacs Widget Library: A Critique and Case Study</h1>
    
    <div id="readability-page-1" class="page"><div id="post-content"><p>The Emacs widget library (<code>widget.el</code> and <code>wid-edit.el</code>) has been part of Emacs since 1996, when Per Abrahamsen wrote it to power the Customize interface. Nearly three decades later, it remains the foundation for <code>M-x customize</code> and appears in various packages that need form-like interfaces. It&#39;s also largely unchanged, rarely discussed, and - when you actually try to build something non-trivial with it - surprisingly painful to work with.</p>
<p>This post is a critique born from experience. I&#39;ve built complex UIs using the widget library, including a table widget with editable cells that reflows dynamically. The code lives in <a href="https://github.com/d12frosted/widget-extra">widget-extra</a>, a library I wrote to extend the built-in widget system. It works. It was hard. The process revealed both the library&#39;s hidden power and its fundamental limitations.</p>

<p>Before the critique, credit where it&#39;s due.</p>
<h2><span>#2</span>Deep Integration with Emacs</h2>
<p>Widgets are text. They live in buffers, use overlays and text properties, and work identically in GUI and terminal Emacs. This is philosophically aligned with Emacs&#39;s core principle: everything is a buffer. You can use standard navigation, search the buffer, even run keyboard macros across widget forms.</p>
<h2><span>#2</span>Performance</h2>
<p>A buffer with hundreds of widgets remains snappy. There are no heavy GUI objects, no separate rendering pipeline - just text with properties. The Customize interface, with its deeply nested groups and countless options, demonstrates this well.</p>
<h2><span>#2</span>Type Hierarchy</h2>
<p>The library excels at defining <em>what</em> widgets are. You can create new widget types that inherit from existing ones, override specific behaviours, and build a taxonomy of components. A <code>bounded-int-field</code> can inherit from <code>int-field</code> which inherits from <code>field</code> which inherits from <code>default</code>. This is genuinely powerful for building families of related widgets.</p>
<p>That said, this is a classical inheritance approach, and the game development community moved away from deep inheritance hierarchies years ago. The Entity-Component-System pattern, popularised by Unity and others, favours composition over inheritance: instead of an entity <em>being</em> a subclass of multiple base classes, it <em>has</em> components that define its behaviours. An entity with physics, visuals, and AI isn&#39;t a <code>PhysicsVisualAIEntity</code> subclass - it&#39;s just an entity with three components attached.</p>
<p>The widget library&#39;s type hierarchy works well when your widgets fit neatly into an &#34;is-a&#34; relationship. It becomes awkward when you need a widget that combines multiple orthogonal behaviours - editable, validated, formatted, linked to external state. You end up either creating deep hierarchies or manually composing behaviours through property combinations. Not a fatal flaw, but worth noting that the approach shows its age.</p>
<h2><span>#2</span>A Reasonable Set of Primitives</h2>
<p>The library provides what you&#39;d expect: links, buttons, editable fields, checkboxes, radio buttons, dropdown menus, and editable lists. For a simple configuration screen or a linear questionnaire, widgets work fine.</p>

<p>A confession before I start criticising: I might be wrong about some of this.</p>
<p>The documentation didn&#39;t work for me. The code was hard to navigate. I spent a lot of time confused. If there are better patterns I missed, I&#39;d genuinely like to know - leave a comment or reach out. I&#39;ll happily update this post with corrections.</p>
<p>Also, I should mention: I&#39;m primarily a server developer. I know little about building UIs. This might explain why I kept banging my head against walls that UI people would have walked around. On the other hand, it also means I approached the library without preconceptions, which occasionally has value. Make of that what you will.</p>
<h2><span>#2</span>Hierarchy Without Layout</h2>
<p>Here&#39;s the core confusion: the widget library is excellent at defining widget <em>types</em> (the &#34;what&#34;) but offers almost nothing for widget <em>layout</em> (the &#34;where&#34;).</p>
<p>When you define a new widget type, you&#39;re specifying its behaviour, validation, appearance, and relationship to other types. This is well-supported. But when you want to arrange widgets spatially - put these three in a row, align those labels, create a grid - you&#39;re on your own.</p>
<p>The library&#39;s composition primitives are minimal and poorly explained. You can nest widgets inside other widgets, but there&#39;s no layout engine. You insert text and widgets sequentially into a buffer, calculating positions manually. Want columns? Count characters. Want alignment? Pad with spaces. Want reflow when content changes? Rebuild everything.</p>
<p>This confusion between type hierarchy and spatial composition is never clearly addressed in the documentation, leaving developers to discover it painfully.</p>
<h2><span>#2</span>No State Management</h2>
<p>This is the fundamental architectural gap.</p>
<p>Modern UI development has converged on patterns for managing state: unidirectional data flow, reactive bindings, declarative state containers. The widget library offers none of this. When widget A&#39;s action needs to update widget B, you must:</p>
<ol>
<li>Store references to both widgets in buffer-local variables</li>
<li>Write a <code>:notify</code> callback on widget A</li>
<li>Manually call <code>widget-value-set</code> on widget B</li>
<li>Call <code>widget-setup</code> to re-enable editing</li>
<li>Hope you haven&#39;t broken anything</li>
</ol>
<p>For a form with three interdependent fields, this is tedious. For a form with twenty, it&#39;s a maintenance nightmare. There&#39;s no concept of derived state, no way to declare &#34;this widget&#39;s options depend on that widget&#39;s value,&#34; no subscription mechanism. Everything is imperative side effects, manually threaded through callback functions.</p>
<h2><span>#2</span>No Widget Tree</h2>
<p>Most UI toolkits provide a parent-child hierarchy. This gives you automatic layout propagation, event bubbling, scoped state, and declarative nesting.</p>
<p>The widget library is flat. Widgets are inserted into a buffer sequentially. Yes, composite widgets like <code>editable-list</code> have a <code>:parent</code> property for their items, but this isn&#39;t a general-purpose tree. You cannot nest arbitrary widgets inside a container and treat them as a unit.</p>
<h2><span>#2</span>The Simplicity Paradox</h2>
<p>Here&#39;s the irony: the widget library&#39;s performance comes <em>from</em> the same architectural simplicity that makes it hard to use - not <em>despite</em> it.</p>
<p>Widgets are just text with properties. No widget tree means no tree traversal overhead. No reactive state system means no dependency tracking cost. No layout engine means no layout calculations. The buffer <em>is</em> the UI, rendered by Emacs&#39;s extremely optimised text display machinery.</p>
<p>This is genuinely elegant for the Customize interface, where performance matters and the UI is fundamentally linear. The simplicity is a feature when your requirements match the design.</p>
<p>But that same simplicity becomes a burden when you want interdependent widgets, spatial layouts, or dynamic composition.</p>

<p>Enough critique. Let&#39;s build something and see what we learn.</p>
<p>(This is the part where a proper UI developer would probably reach for an existing solution. As a server developer with more arrogance than sense, I naturally decided to implement everything from scratch.)</p>
<p>All the code shown here is available in <a href="https://github.com/d12frosted/widget-extra">widget-extra</a>, a library I wrote to extend the built-in widget system with additional components: labels, fields, buttons, and layout widgets. You can use it directly or study it as a reference.</p>
<h2><span>#2</span>Warm-up: A Fields Group with Aligned Tags</h2>
<p>Before tackling tables, let&#39;s solve a simpler problem: displaying multiple fields with their tags aligned.</p>
<pre><div><p><code><span>Name:   Boris
</span>Age:    30
<!-- -->Email:  boris@example.com</code></p></div></pre>
<p>The challenge: each field has a tag of different length, but we want the values to line up. The widget library provides no alignment primitives, so we calculate padding manually.</p>
<pre><div><p><code><span>(</span><span>define-widget</span><span> </span><span>&#39;fields-group</span><span> </span><span>&#39;default</span><span>
</span><span>  </span><span>&#34;Group multiple fields with automatic tag alignment.&#34;</span><span>
</span><span>  </span><span>:convert-widget</span><span> </span><span>#&#39;widget-types-convert-widget</span><span>
</span><span>  </span><span>:copy</span><span> </span><span>#&#39;widget-types-copy</span><span>
</span><span>  </span><span>:format</span><span> </span><span>&#34;%v&#34;</span><span>
</span><span>  </span><span>:extra-offset</span><span> </span><span>1</span><span>
</span><span>  </span><span>:value-create</span><span> </span><span>#&#39;widget-fields-group-value-create</span><span>)</span></code></p></div></pre>
<p>The <code>:value-create</code> function measures all tags, finds the maximum length, then adds appropriate padding to each field:</p>
<pre><div><p><code><span>(</span><span>defun</span><span> </span><span>widget-fields-group-value-create</span><span> </span><span>(</span><span>widget</span><span>)</span><span>
</span><span>  </span><span>&#34;Create children with aligned tags.&#34;</span><span>
</span><span>  </span><span>(</span><span>let*</span><span> </span><span>(</span><span>(</span><span>args</span><span> </span><span>(</span><span>widget-get</span><span> widget </span><span>:args</span><span>)</span><span>)</span><span>
</span><span>         </span><span>(</span><span>max-tag-length</span><span> </span><span>(</span><span>seq-max</span><span>
</span><span>                          </span><span>(</span><span>seq-map</span><span>
</span><span>                           </span><span>(</span><span>lambda</span><span> </span><span>(</span><span>x</span><span>)</span><span> </span><span>(</span><span>length</span><span> </span><span>(</span><span>or</span><span> </span><span>(</span><span>widget-get</span><span> x </span><span>:tag</span><span>)</span><span> </span><span>&#34;&#34;</span><span>)</span><span>)</span><span>)</span><span>
</span><span>                           args</span><span>)</span><span>)</span><span>)</span><span>)</span><span>
</span><span>    </span><span>(</span><span>dolist</span><span> </span><span>(</span><span>arg</span><span> args</span><span>)</span><span>
</span><span>      </span><span>(</span><span>widget-fields-group-add-item</span><span> widget arg max-tag-length</span><span>)</span><span>)</span><span>)</span><span>)</span><span>
</span>
<span></span><span>(</span><span>defun</span><span> </span><span>widget-fields-group-add-item</span><span> </span><span>(</span><span>widget</span><span> </span><span>item</span><span> </span><span>max-tag-length</span><span>)</span><span>
</span><span>  </span><span>&#34;Add </span><span>ITEM</span><span> to </span><span>WIDGET</span><span> with padding based on </span><span>MAX-TAG-LENGTH</span><span>.&#34;</span><span>
</span><span>  </span><span>(</span><span>let*</span><span> </span><span>(</span><span>(</span><span>tag</span><span> </span><span>(</span><span>widget-get</span><span> item </span><span>:tag</span><span>)</span><span>)</span><span>
</span><span>         </span><span>(</span><span>tag-length</span><span> </span><span>(</span><span>if</span><span> tag </span><span>(</span><span>length</span><span> tag</span><span>)</span><span> </span><span>0</span><span>)</span><span>)</span><span>
</span><span>         </span><span>(</span><span>offset</span><span> </span><span>(</span><span>+</span><span> </span><span>(</span><span>widget-get</span><span> widget </span><span>:extra-offset</span><span>)</span><span>
</span><span>                    </span><span>(</span><span>-</span><span> max-tag-length tag-length</span><span>)</span><span>)</span><span>)</span><span>
</span><span>         </span><span>(</span><span>format</span><span> </span><span>(</span><span>or</span><span> </span><span>(</span><span>widget-get</span><span> item </span><span>:format</span><span>)</span><span> </span><span>&#34;%T%[%v%]&#34;</span><span>)</span><span>)</span><span>
</span><span>         </span><span>(</span><span>format</span><span> </span><span>(</span><span>if</span><span> </span><span>(</span><span>s-ends-with-p</span><span> </span><span>&#34;\n&#34;</span><span> format</span><span>)</span><span>
</span>                     format
<span>                   </span><span>(</span><span>concat</span><span> format </span><span>&#34;\n&#34;</span><span>)</span><span>)</span><span>)</span><span>)</span><span>
</span><span>    </span><span>(</span><span>widget-put</span><span> item </span><span>:format</span><span> format</span><span>)</span><span>
</span><span>    </span><span>(</span><span>widget-put</span><span> item </span><span>:offset</span><span> offset</span><span>)</span><span>
</span><span>    </span><span>(</span><span>widget-create-child</span><span> widget item</span><span>)</span><span>)</span><span>)</span></code></p></div></pre>
<p>Usage:</p>
<pre><div><p><code><span>(</span><span>widget-create</span><span>
</span><span> </span><span>&#39;fields-group</span><span>
</span><span> </span><span>(</span><span>list</span><span> </span><span>&#39;field</span><span> </span><span>:tag</span><span> </span><span>&#34;Name:&#34;</span><span> </span><span>:value</span><span> </span><span>&#34;Boris&#34;</span><span>)</span><span>
</span><span> </span><span>(</span><span>list</span><span> </span><span>&#39;int-field</span><span> </span><span>:tag</span><span> </span><span>&#34;Age:&#34;</span><span> </span><span>:value</span><span> </span><span>30</span><span>)</span><span>
</span><span> </span><span>(</span><span>list</span><span> </span><span>&#39;field</span><span> </span><span>:tag</span><span> </span><span>&#34;Email:&#34;</span><span> </span><span>:value</span><span> </span><span>&#34;boris@example.com&#34;</span><span>)</span><span>)</span></code></p></div></pre>
<p>This is the pattern: measure first, then render with calculated offsets. No layout engine - just arithmetic and string padding.</p>
<p>Note also that we&#39;re modifying each child&#39;s <code>:offset</code> property before creation. The base <code>field</code> widget (also defined in <code>widget-extra</code>) supports a custom <code>%T</code> format escape that renders the tag with configurable spacing. This kind of cooperation between parent and child widgets requires planning the property protocol in advance.</p>
<h2><span>#2</span>The Hard Part: A Table with Editable Cells</h2>
<p>Now let&#39;s tackle something genuinely difficult.</p>
<p>A table with editable cells sounds simple: rows and columns, maybe some separators, widgets in each cell. But the requirements quickly compound:</p>
<ol>
<li>Columns must align - cells in the same column should have equal width</li>
<li>When a cell&#39;s value changes length, the column must resize</li>
<li>When the table redraws, the cursor must stay in the same logical position</li>
<li>The whole table should be a single widget that can be created and manipulated atomically</li>
</ol>
<p>None of this is provided. All of it is possible.</p>
<h3><span>#3</span>Step 1: Define the Structure</h3>
<p>A table takes rows as arguments. Each row is either a horizontal line or a data row containing widgets:</p>
<pre><div><p><code><span>(</span><span>define-widget</span><span> </span><span>&#39;table</span><span> </span><span>&#39;default</span><span>
</span><span>  </span><span>&#34;</span><span>A</span><span> table widget with rows, columns, and separators.&#34;</span><span>
</span><span>  </span><span>:convert-widget</span><span> </span><span>#&#39;widget-types-convert-widget</span><span>
</span><span>  </span><span>:copy</span><span> </span><span>#&#39;widget-types-copy</span><span>
</span><span>  </span><span>:format</span><span> </span><span>&#34;%v&#34;</span><span>
</span><span>  </span><span>:row-conj</span><span> </span><span>&#34; | &#34;</span><span>
</span><span>  </span><span>:hline-conj</span><span> </span><span>&#34;-+-&#34;</span><span>
</span><span>  </span><span>:hline-content</span><span> ?-
</span><span>  </span><span>:padding</span><span> ?\s
</span><span>  </span><span>:value-create</span><span> </span><span>#&#39;widget-table-value-create</span><span>
</span><span>  </span><span>:notify</span><span> </span><span>#&#39;widget-table-notify</span><span>)</span></code></p></div></pre>
<p>Usage will look like:</p>
<pre><div><p><code><span>(</span><span>widget-create</span><span>
</span><span> </span><span>&#39;table</span><span>
</span><span> </span><span>&#39;(</span><span>row</span><span> </span><span>(</span><span>label</span><span> </span><span>:value</span><span> </span><span>&#34;Name&#34;</span><span>)</span><span> </span><span>(</span><span>label</span><span> </span><span>:value</span><span> </span><span>&#34;Age&#34;</span><span>)</span><span>)</span><span>
</span><span> </span><span>&#39;(</span><span>hline</span><span>)</span><span>
</span><span> </span><span>&#39;(</span><span>row</span><span> </span><span>(</span><span>field</span><span> </span><span>:value</span><span> </span><span>&#34;Boris&#34;</span><span>)</span><span> </span><span>(</span><span>int-field</span><span> </span><span>:value</span><span> </span><span>30</span><span>)</span><span>)</span><span>)</span></code></p></div></pre>
<p>The <code>:value-create</code> function does the heavy lifting. The <code>:notify</code> function handles state changes.</p>
<h3><span>#3</span>Step 2: Calculate Column Widths</h3>
<p>Here&#39;s the first hack: to know how wide each column should be, we need to know how wide each cell&#39;s content is. But widgets don&#39;t have a &#34;width&#34; property - they&#39;re just text that gets inserted.</p>
<p>Solution: create each widget in a temporary buffer, measure the resulting text, then discard it:</p>
<pre><div><p><code><span>(</span><span>let*</span><span> </span><span>(</span><span>(</span><span>args</span><span> </span><span>(</span><span>widget-get</span><span> widget </span><span>:args</span><span>)</span><span>)</span><span>
</span><span>       </span><span>(</span><span>cols</span><span> </span><span>(</span><span>apply</span><span> </span><span>#&#39;max</span><span> </span><span>(</span><span>mapcar</span><span> </span><span>(</span><span>lambda</span><span> </span><span>(</span><span>row</span><span>)</span><span>
</span><span>                                    </span><span>(</span><span>length</span><span> </span><span>(</span><span>widget-get</span><span> row </span><span>:args</span><span>)</span><span>)</span><span>)</span><span>
</span><span>                                  args</span><span>)</span><span>)</span><span>)</span><span>
</span><span>       </span><span>(</span><span>widths</span><span>
</span><span>        </span><span>(</span><span>-&gt;&gt;</span><span> </span><span>(</span><span>-iota</span><span> cols</span><span>)</span><span>
</span><span>             </span><span>;; Transpose: group by column instead of row</span><span>
</span><span>             </span><span>(</span><span>-map</span><span> </span><span>(</span><span>lambda</span><span> </span><span>(</span><span>i</span><span>)</span><span>
</span><span>                     </span><span>(</span><span>-map</span><span> </span><span>(</span><span>-partial</span><span> </span><span>#&#39;nth</span><span> i</span><span>)</span><span>
</span><span>                           </span><span>(</span><span>--map</span><span> </span><span>(</span><span>widget-get</span><span> it </span><span>:args</span><span>)</span><span> args</span><span>)</span><span>)</span><span>)</span><span>)</span><span>
</span><span>             </span><span>;; Measure each cell</span><span>
</span><span>             </span><span>(</span><span>--map-indexed</span><span>
</span><span>              </span><span>(</span><span>--map</span><span> </span><span>(</span><span>when</span><span> it
</span><span>                       </span><span>(</span><span>with-temp-buffer</span><span>
</span><span>                         </span><span>(</span><span>widget-create</span><span> it</span><span>)</span><span>
</span><span>                         </span><span>(</span><span>-</span><span> </span><span>(</span><span>point</span><span>)</span><span> </span><span>1</span><span>)</span><span>)</span><span>)</span><span>
</span><span>                     it</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>
</span><span>  </span><span>;; widths is now a list of lists: ((col0-row0 col0-row1 ...) (col1-row0 ...))</span><span>
</span><span>  ...</span><span>)</span></code></p></div></pre>
<p>This is expensive - we create every widget twice. But it works, and for reasonable table sizes, it&#39;s fast enough. (For better performance, you should reuse the same temporary buffer instead of creating a new one for each cell - but for simplicity of illustration, I&#39;m omitting that optimisation here.)</p>
<h3><span>#3</span>Step 3: Render with Padding</h3>
<p>Now we iterate through rows, rendering each cell with appropriate padding:</p>
<pre><div><p><code><span>(</span><span>defun</span><span> </span><span>widget-table-value-create</span><span> </span><span>(</span><span>widget</span><span>)</span><span>
</span><span>  </span><span>(</span><span>let*</span><span> </span><span>(</span><span>(</span><span>args</span><span> </span><span>(</span><span>widget-get</span><span> widget </span><span>:args</span><span>)</span><span>)</span><span>
</span><span>         </span><span>(</span><span>widths</span><span> </span><span>(</span><span>widget-table--calculate-widths</span><span> widget</span><span>)</span><span>)</span><span>
</span><span>         </span><span>(</span><span>max-widths</span><span> </span><span>(</span><span>-map</span><span> </span><span>#&#39;-max</span><span> widths</span><span>)</span><span>)</span><span>
</span><span>         </span><span>(</span><span>children</span><span>)</span><span>)</span><span>
</span><span>    </span><span>(</span><span>-each-indexed</span><span> args
</span><span>      </span><span>(</span><span>lambda</span><span> </span><span>(</span><span>row-index</span><span> </span><span>row</span><span>)</span><span>
</span><span>        </span><span>(</span><span>pcase</span><span> </span><span>(</span><span>car</span><span> row</span><span>)</span><span>
</span><span>          </span><span>(</span><span>`row
</span><span>           </span><span>(</span><span>widget-insert</span><span> </span><span>(</span><span>widget-get</span><span> widget </span><span>:row-start</span><span>)</span><span>)</span><span>
</span><span>           </span><span>(</span><span>-each-indexed</span><span> </span><span>(</span><span>widget-get</span><span> row </span><span>:args</span><span>)</span><span>
</span><span>             </span><span>(</span><span>lambda</span><span> </span><span>(</span><span>col-index</span><span> </span><span>col</span><span>)</span><span>
</span><span>               </span><span>(</span><span>unless</span><span> </span><span>(</span><span>=</span><span> </span><span>0</span><span> col-index</span><span>)</span><span>
</span><span>                 </span><span>(</span><span>widget-insert</span><span> </span><span>(</span><span>widget-get</span><span> widget </span><span>:row-conj</span><span>)</span><span>)</span><span>)</span><span>
</span><span>               </span><span>(</span><span>let*</span><span> </span><span>(</span><span>(</span><span>w</span><span> </span><span>(</span><span>nth</span><span> row-index </span><span>(</span><span>nth</span><span> col-index widths</span><span>)</span><span>)</span><span>)</span><span>
</span><span>                      </span><span>(</span><span>mw</span><span> </span><span>(</span><span>nth</span><span> col-index max-widths</span><span>)</span><span>)</span><span>
</span><span>                      </span><span>(</span><span>pad</span><span> </span><span>(</span><span>-</span><span> mw w</span><span>)</span><span>)</span><span>
</span><span>                      </span><span>(</span><span>child</span><span> </span><span>(</span><span>widget-create-child</span><span> widget col</span><span>)</span><span>)</span><span>)</span><span>
</span><span>                 </span><span>;; Track position for state management</span><span>
</span><span>                 </span><span>(</span><span>widget-put</span><span> child </span><span>:row-index</span><span> row-index</span><span>)</span><span>
</span><span>                 </span><span>(</span><span>widget-put</span><span> child </span><span>:col-index</span><span> col-index</span><span>)</span><span>
</span><span>                 </span><span>(</span><span>push</span><span> child children</span><span>)</span><span>
</span><span>                 </span><span>;; Add padding to align columns</span><span>
</span><span>                 </span><span>(</span><span>when</span><span> </span><span>(</span><span>&gt;</span><span> pad </span><span>0</span><span>)</span><span>
</span><span>                   </span><span>(</span><span>widget-insert</span><span> </span><span>(</span><span>make-string</span><span> pad ?\s</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>
</span><span>           </span><span>(</span><span>widget-insert</span><span> </span><span>&#34;\n&#34;</span><span>)</span><span>)</span><span>
</span>
<span>          </span><span>(</span><span>`hline
</span><span>           </span><span>;; Draw separator line</span><span>
</span><span>           </span><span>(</span><span>--each</span><span> </span><span>(</span><span>-iota</span><span> </span><span>(</span><span>length</span><span> max-widths</span><span>)</span><span>)</span><span>
</span><span>             </span><span>(</span><span>unless</span><span> </span><span>(</span><span>=</span><span> it </span><span>0</span><span>)</span><span>
</span><span>               </span><span>(</span><span>widget-insert</span><span> </span><span>(</span><span>widget-get</span><span> widget </span><span>:hline-conj</span><span>)</span><span>)</span><span>)</span><span>
</span><span>             </span><span>(</span><span>widget-insert</span><span>
</span><span>              </span><span>(</span><span>make-string</span><span> </span><span>(</span><span>nth</span><span> it max-widths</span><span>)</span><span> ?-</span><span>)</span><span>)</span><span>)</span><span>
</span><span>           </span><span>(</span><span>widget-insert</span><span> </span><span>&#34;\n&#34;</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>
</span>
<span>    </span><span>(</span><span>widget-put</span><span> widget </span><span>:children</span><span> </span><span>(</span><span>reverse</span><span> children</span><span>)</span><span>)</span><span>)</span><span>)</span></code></p></div></pre>
<p>The key insight: we store <code>:row-index</code> and <code>:col-index</code> on each child widget. This lets us find them again after a redraw.</p>
<h3><span>#3</span>Step 4: Handle State Changes (The Hard Part)</h3>
<p>When a cell&#39;s value changes, we need to:</p>
<ol>
<li>Update our internal representation (<code>:args</code>)</li>
<li>Redraw the entire table (column widths may have changed)</li>
<li>Put the cursor back where it was</li>
</ol>
<p>The <code>:notify</code> callback receives the child widget that changed:</p>
<pre><div><p><code><span>(</span><span>defun</span><span> </span><span>widget-table-notify</span><span> </span><span>(</span><span>widget</span><span> </span><span>child</span><span> </span><span>&amp;optional</span><span> </span><span>_event</span><span>)</span><span>
</span><span>  </span><span>(</span><span>let*</span><span> </span><span>(</span><span>(</span><span>row-index</span><span> </span><span>(</span><span>widget-get</span><span> child </span><span>:row-index</span><span>)</span><span>)</span><span>
</span><span>         </span><span>(</span><span>col-index</span><span> </span><span>(</span><span>widget-get</span><span> child </span><span>:col-index</span><span>)</span><span>)</span><span>
</span><span>         </span><span>;; Remember cursor position relative to widget start</span><span>
</span><span>         </span><span>(</span><span>child-from</span><span> </span><span>(</span><span>marker-position</span><span> </span><span>(</span><span>widget-get</span><span> child </span><span>:from</span><span>)</span><span>)</span><span>)</span><span>
</span><span>         </span><span>(</span><span>delta</span><span> </span><span>(</span><span>when</span><span> child-from </span><span>(</span><span>-</span><span> </span><span>(</span><span>point</span><span>)</span><span> child-from</span><span>)</span><span>)</span><span>)</span><span>
</span><span>         </span><span>(</span><span>new-value</span><span> </span><span>(</span><span>widget-value</span><span> child</span><span>)</span><span>)</span><span>)</span><span>
</span>
<span>    </span><span>;; Update the spec in :args with new value</span><span>
</span><span>    </span><span>(</span><span>let*</span><span> </span><span>(</span><span>(</span><span>row</span><span> </span><span>(</span><span>nth</span><span> row-index </span><span>(</span><span>widget-get</span><span> widget </span><span>:args</span><span>)</span><span>)</span><span>)</span><span>
</span><span>           </span><span>(</span><span>original-spec</span><span> </span><span>(</span><span>nth</span><span> col-index </span><span>(</span><span>widget-get</span><span> row </span><span>:args</span><span>)</span><span>)</span><span>)</span><span>
</span><span>           </span><span>(</span><span>updated-spec</span><span> </span><span>(</span><span>widget-table--update-spec-value</span><span>
</span><span>                          original-spec new-value</span><span>)</span><span>)</span><span>)</span><span>
</span><span>      </span><span>(</span><span>widget-put</span><span> widget </span><span>:args</span><span>
</span><span>                  </span><span>(</span><span>--update-at</span><span> row-index
</span><span>                               </span><span>(</span><span>progn</span><span>
</span><span>                                 </span><span>(</span><span>widget-put</span><span> it </span><span>:args</span><span>
</span><span>                                             </span><span>(</span><span>-replace-at</span><span> col-index
</span>                                                          updated-spec
<span>                                                          </span><span>(</span><span>widget-get</span><span> it </span><span>:args</span><span>)</span><span>)</span><span>)</span><span>
</span><span>                                 it</span><span>)</span><span>
</span><span>                               </span><span>(</span><span>widget-get</span><span> widget </span><span>:args</span><span>)</span><span>)</span><span>)</span><span>)</span><span>
</span>
<span>    </span><span>;; Redraw the entire table</span><span>
</span><span>    </span><span>(</span><span>widget-default-value-set</span><span> widget </span><span>(</span><span>widget-get</span><span> widget </span><span>:value</span><span>)</span><span>)</span><span>
</span>
<span>    </span><span>;; Restore cursor position</span><span>
</span><span>    </span><span>(</span><span>when-let</span><span> </span><span>(</span><span>(</span><span>child</span><span> </span><span>(</span><span>--find</span><span> </span><span>(</span><span>and</span><span> </span><span>(</span><span>=</span><span> row-index </span><span>(</span><span>widget-get</span><span> it </span><span>:row-index</span><span>)</span><span>)</span><span>
</span><span>                                   </span><span>(</span><span>=</span><span> col-index </span><span>(</span><span>widget-get</span><span> it </span><span>:col-index</span><span>)</span><span>)</span><span>)</span><span>
</span><span>                              </span><span>(</span><span>widget-get</span><span> widget </span><span>:children</span><span>)</span><span>)</span><span>)</span><span>)</span><span>
</span><span>      </span><span>(</span><span>when</span><span> delta
</span><span>        </span><span>(</span><span>goto-char</span><span> </span><span>(</span><span>+</span><span> </span><span>(</span><span>widget-get</span><span> child </span><span>:from</span><span>)</span><span> delta</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span></code></p></div></pre>
<p>This is the critical piece. We:</p>
<ol>
<li>Capture the cursor&#39;s offset from the widget&#39;s start <em>before</em> redrawing</li>
<li>Modify <code>:args</code> to reflect the new value</li>
<li>Trigger a full redraw via <code>widget-default-value-set</code></li>
<li>Find the same cell again by row/column indices</li>
<li>Restore the cursor to the same offset</li>
</ol>
<p>Without step 5, editing would be maddening - every keystroke would jump the cursor somewhere unexpected.</p>
<h3><span>#3</span>Step 5: Update Specs Without Corruption</h3>
<p>One subtle bug: widget specs in <code>:args</code> are often shared structures. If you modify them directly, you corrupt the original definitions. Deep copy is essential:</p>
<pre><div><p><code><span>(</span><span>defun</span><span> </span><span>widget-table--update-spec-value</span><span> </span><span>(</span><span>spec</span><span> </span><span>new-value</span><span>)</span><span>
</span><span>  </span><span>&#34;Return a copy of widget </span><span>SPEC</span><span> with :value set to </span><span>NEW-VALUE</span><span>.&#34;</span><span>
</span><span>  </span><span>(</span><span>let</span><span> </span><span>(</span><span>(</span><span>copy</span><span> </span><span>(</span><span>copy-tree</span><span> spec</span><span>)</span><span>)</span><span>)</span><span>
</span><span>    </span><span>(</span><span>if</span><span> </span><span>(</span><span>plist-member</span><span> </span><span>(</span><span>cdr</span><span> copy</span><span>)</span><span> </span><span>:value</span><span>)</span><span>
</span><span>        </span><span>(</span><span>plist-put</span><span> </span><span>(</span><span>cdr</span><span> copy</span><span>)</span><span> </span><span>:value</span><span> new-value</span><span>)</span><span>
</span><span>      </span><span>(</span><span>setcdr</span><span> copy </span><span>(</span><span>cons</span><span> </span><span>:value</span><span> </span><span>(</span><span>cons</span><span> new-value </span><span>(</span><span>cdr</span><span> copy</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>
</span><span>    </span><span>;; Special case: menu-choice needs :tag updated too</span><span>
</span><span>    </span><span>(</span><span>when</span><span> </span><span>(</span><span>eq</span><span> </span><span>(</span><span>car</span><span> copy</span><span>)</span><span> </span><span>&#39;menu-choice</span><span>)</span><span>
</span><span>      </span><span>(</span><span>plist-put</span><span> </span><span>(</span><span>cdr</span><span> copy</span><span>)</span><span> </span><span>:tag</span><span> new-value</span><span>)</span><span>)</span><span>
</span><span>    copy</span><span>)</span><span>)</span></code></p></div></pre>
<h2><span>#2</span>The Result</h2>
<p>After all this, we have a table that:</p>
<ul>
<li>Aligns columns automatically</li>
<li>Reflows when cell content changes</li>
<li>Preserves cursor position through redraws</li>
<li>Works with various widget types as cells</li>
</ul>
<pre><div><p><code><span>(</span><span>widget-create</span><span>
</span><span> </span><span>&#39;table</span><span>
</span><span> </span><span>&#39;(</span><span>row</span><span> </span><span>(</span><span>label</span><span> </span><span>:value</span><span> </span><span>&#34;Name&#34;</span><span>)</span><span> </span><span>(</span><span>label</span><span> </span><span>:value</span><span> </span><span>&#34;Score&#34;</span><span>)</span><span>)</span><span>
</span><span> </span><span>&#39;(</span><span>hline</span><span>)</span><span>
</span><span> </span><span>&#39;(</span><span>row</span><span> </span><span>(</span><span>field</span><span> </span><span>:value</span><span> </span><span>&#34;Alice&#34;</span><span>)</span><span> </span><span>(</span><span>int-field</span><span> </span><span>:value</span><span> </span><span>95</span><span>)</span><span>)</span><span>
</span><span> </span><span>&#39;(</span><span>row</span><span> </span><span>(</span><span>field</span><span> </span><span>:value</span><span> </span><span>&#34;Bob&#34;</span><span>)</span><span> </span><span>(</span><span>int-field</span><span> </span><span>:value</span><span> </span><span>87</span><span>)</span><span>)</span><span>)</span></code></p></div></pre>
<p>Renders as:</p>
<pre><div><p><code><span>Name  | Score
</span>------+------
<!-- -->Alice |    95
<!-- -->Bob   |    87</code></p></div></pre>
<p>Edit &#34;Alice&#34; to &#34;Alexandria&#34; and watch the first column widen. The cursor stays in the cell you were editing.</p>
<h2><span>#2</span>What This Teaches Us</h2>
<p>Building this table required:</p>
<ul>
<li><strong>Measuring widgets by creating them in temporary buffers</strong> - there&#39;s no introspection API for &#34;how wide would this be?&#34;</li>
<li><strong>Manual coordinate tracking</strong> - storing row/column indices because there&#39;s no widget tree to traverse</li>
<li><strong>Full redraw on any change</strong> - no incremental updates, no dirty-region tracking</li>
<li><strong>Cursor position surgery</strong> - capturing and restoring offsets because the library doesn&#39;t preserve context through redraws</li>
<li><strong>Deep copying specs</strong> - because shared structures will bite you</li>
</ul>
<p>None of this is documented. All of it is discoverable only by building something and hitting walls.</p>
<p>And yet - it works. The underlying primitives (text properties, overlays, markers) are solid. The performance is good. You can build sophisticated UIs if you&#39;re willing to pay the complexity tax.</p>

<p>For keyboard-driven command menus, Transient (from Magit) has become the standard. It&#39;s well-documented, actively maintained, and designed around a coherent model of transient state.</p>
<p>For complex interactive UIs, there isn&#39;t a clear answer. The widget library occupies an awkward middle ground: too complex for simple needs, too limited for complex ones.</p>

<p>While building Emacs tools for <a href="https://barberry.io">Barberry Garden</a> - my wine tasting management system - I&#39;ve been pushing the widget library to its limits. The <a href="https://github.com/d12frosted/brb">brb</a> package includes event planning interfaces, tasting score entry forms, and various administrative views. Tables with editable cells. Dynamic forms that reconfigure based on selections. Nested groups that expand and collapse.</p>
<p>It works, but the friction is constant. Every feature requires fighting the architecture. The cognitive overhead of manual state management, cursor preservation, and layout calculation adds up.</p>
<p>That &#34;something new&#34; is now a reality: <a href="https://github.com/d12frosted/vui.el">vui.el</a> - a UI layer that uses <code>widget.el</code> under the hood but provides higher-level abstractions. Not a full reactive framework - Emacs doesn&#39;t need that complexity - but a thin system that handles:</p>
<ul>
<li><strong>Declarative composition</strong>: describe what you want, not how to build it</li>
<li><strong>Automatic state propagation</strong>: when this changes, update that</li>
<li><strong>Cursor-aware redraws</strong>: preserve editing context through updates</li>
<li><strong>Layout primitives</strong>: rows, columns, groups that just work</li>
</ul>
<p>The goal isn&#39;t to replace <code>widget.el</code> but to tame it. Keep the performance, hide the ceremony. Respect the fundamental constraints of Emacs UI - the criticality of cursor position, the two-dimensional nature of the buffer. We don&#39;t have a proper DOM and CSS, and that&#39;s actually fine.</p>
<p><a href="https://github.com/d12frosted/vui.el">vui.el</a> is now available on <a href="https://melpa.org/#/vui">MELPA</a>. If you want to get started quickly, check out the <a href="https://www.d12frosted.io/posts/2025-12-01-vui-quickstart">quickstart guide</a>.</p>
<p>The <a href="https://github.com/d12frosted/widget-extra">widget-extra</a> library described in this post remains available - the widgets like labels, fields, buttons, <code>fields-group</code>, <code>table</code>, and more are all still there. But for new projects, I recommend using <code>vui.el</code> instead, as it provides a much more pleasant development experience while building on the same foundations.</p>

<p>The Emacs widget library is more powerful than its documentation suggests and more painful than it should be. The type hierarchy is genuinely elegant. The layout story is essentially absent. State management is your problem.</p>
<p>Its performance comes from simplicity - the same simplicity that makes complex UIs difficult. There&#39;s no free lunch.</p>
<p>If you&#39;re building something simple, widgets work fine. If you&#39;re building something complex, budget time for archaeology. Read the source. Build small experiments. Accept that cursor position preservation will haunt your dreams.</p>
<p>I hope this post serves as a useful introduction to what you&#39;re getting into with <code>widget.el</code> - and perhaps <a href="https://github.com/d12frosted/widget-extra">widget-extra</a> can save you some of the pain I went through. The library isn&#39;t comprehensive documentation of the widget system (that would require a book), but between this walkthrough and the source code, you should have enough to get started.</p>
<p>And when you hit walls - because you will - know that you&#39;re not alone. You&#39;re joining a long tradition of Emacs hackers who got their widgets working and then immediately wanted to forget everything about <code>wid-edit.el</code>.</p></div></div>
  </body>
</html>
