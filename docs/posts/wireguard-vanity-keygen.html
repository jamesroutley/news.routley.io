<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/axllent/wireguard-vanity-keygen">Original</a>
    <h1>WireGuard vanity keygen</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><a href="https://goreportcard.com/report/github.com/axllent/wireguard-vanity-keygen" rel="nofollow"><img src="https://camo.githubusercontent.com/5da45f483a38240433d35b1ea1c7ced007ee5aca15cc7dabee534a47c11bdc29/68747470733a2f2f676f7265706f7274636172642e636f6d2f62616467652f6769746875622e636f6d2f61786c6c656e742f7769726567756172642d76616e6974792d6b657967656e" alt="Go Report Card" data-canonical-src="https://goreportcard.com/badge/github.com/axllent/wireguard-vanity-keygen"/></a></p>
<p dir="auto">A command-line vanity (public) key generator for <a href="https://www.wireguard.com/" rel="nofollow">WireGuard</a>. By default, it only matches the prefix of generated public keys,
and not whether the search matches anywhere in the public key. The concept is based on
<a href="https://github.com/warner/wireguard-vanity-address">wireguard-vanity-address</a>, however I wanted something a little more streamlined.</p>

<ul dir="auto">
<li>Generates compliant <a href="https://cr.yp.to/ecdh.html" rel="nofollow">curve25519</a> private and public keys</li>
<li>Configurable multi-core processing (defaults to all cores)</li>
<li>Optional case sensitive searching</li>
<li>Optional regex searching</li>
<li>Search multiple prefixes at once</li>
<li>Exit after results limit reached (defaults to 1)</li>
<li>Displays probability and estimated runtime based on quick benchmark</li>
</ul>

<div data-snippet-clipboard-copy-content="Usage: wireguard-vanity-keygen [OPTIONS] &lt;SEARCH&gt; [&lt;SEARCH&gt;...]

Options:
  -c, --case-sensitive   case sensitive match (default false)
  -t, --threads int      threads (defaults to all available cores minus 1)
  -l, --limit int        limit results to n (exists after) (default 1)"><pre><code>Usage: wireguard-vanity-keygen [OPTIONS] &lt;SEARCH&gt; [&lt;SEARCH&gt;...]

Options:
  -c, --case-sensitive   case sensitive match (default false)
  -t, --threads int      threads (defaults to all available cores minus 1)
  -l, --limit int        limit results to n (exists after) (default 1)
</code></pre></div>

<div data-snippet-clipboard-copy-content="$ wireguard-vanity-keygen -l 3 test pc1/ &#34;^pc7[+/]&#34;
Calculating speed: 49,950 calculations per second using 4 CPU cores
Case-insensitive search, exiting after 4 results
Probability for &#34;test&#34;: 1 in 2,085,136 (approx 41 seconds per match)
Probability for &#34;pc1/&#34;: 1 in 5,914,624 (approx 1 minute per match)
Cannot calculate probability for the regular expression &#34;^pc7[/+]&#34;

Press Ctrl-c to cancel

private OFVUjUoTNQp94fNPB9GCLzxiJPTbN03rcDPrVd12uFc=   public tEstMXL/3ZzAd2TnVlr1BNs/+eOnKzSHpGUnjspk3kc=
private gInIEDmENYbyuaWR1W/KLfximExwbcCg45W2WOmEc0I=   public TestKmA/XVagDW/JsHBXk5mhYJ6E1N1lAWeIeCttgRs=
private yDQLNiQlfnMGhUBsbLQjoBbuNezyHug31Qa1Ht6cgkw=   public PC1/3oUId241TLYImJLUObR8NNxz4HXzG4z+EazfWxY=
private QIbJgxy83+F/1kdogcF+T04trs+1N9gAr1t5th2tLXM=   public Pc7+h172sx0TfIMikjgszM/B8i8/ghi7qJVOwWQtx0w=
private +CUqn4jcKoL8pw53pD4IzfMKW/IMceDWKcM2W5Dxtn4=   public teStmGXZwiJl9HmfnTSmk83girtiIH8oZEa6PFJ8F1Y=
private EMaUfQvAEABpQV/21ALJP5YtyGerRXAn8u67j2AQzVs=   public pC1/t2x5V99Y1SBqNgPZDPsa6r+L5y3BJ4XUCJMar3g=
private wNuHOKCfoH1emfvijXNBoc/7KjrEXUeof7tSdGWvRFo=   public PC1/jXQosaBad2HePOm/w1KjCZ82eT3qNbfzNDZiwTs=
private gJtn0woDChGvyN2eSdc7mTpAFA/nA6jykJeK5bYYfFA=   public Pc7+UEJSHiWsQ9zkO2q+guqDK4sc3VMDMgJu+h/bOFI=
private IMyPmYm/v0SPmB62hC8l6kfxT3/Lfp7dMioo+SM6T2c=   public Pc7/uVfD/ZftxWBHwYbaudEywUS61biBcpj5Tw830Q4="><pre><code>$ wireguard-vanity-keygen -l 3 test pc1/ &#34;^pc7[+/]&#34;
Calculating speed: 49,950 calculations per second using 4 CPU cores
Case-insensitive search, exiting after 4 results
Probability for &#34;test&#34;: 1 in 2,085,136 (approx 41 seconds per match)
Probability for &#34;pc1/&#34;: 1 in 5,914,624 (approx 1 minute per match)
Cannot calculate probability for the regular expression &#34;^pc7[/+]&#34;

Press Ctrl-c to cancel

private OFVUjUoTNQp94fNPB9GCLzxiJPTbN03rcDPrVd12uFc=   public tEstMXL/3ZzAd2TnVlr1BNs/+eOnKzSHpGUnjspk3kc=
private gInIEDmENYbyuaWR1W/KLfximExwbcCg45W2WOmEc0I=   public TestKmA/XVagDW/JsHBXk5mhYJ6E1N1lAWeIeCttgRs=
private yDQLNiQlfnMGhUBsbLQjoBbuNezyHug31Qa1Ht6cgkw=   public PC1/3oUId241TLYImJLUObR8NNxz4HXzG4z+EazfWxY=
private QIbJgxy83+F/1kdogcF+T04trs+1N9gAr1t5th2tLXM=   public Pc7+h172sx0TfIMikjgszM/B8i8/ghi7qJVOwWQtx0w=
private +CUqn4jcKoL8pw53pD4IzfMKW/IMceDWKcM2W5Dxtn4=   public teStmGXZwiJl9HmfnTSmk83girtiIH8oZEa6PFJ8F1Y=
private EMaUfQvAEABpQV/21ALJP5YtyGerRXAn8u67j2AQzVs=   public pC1/t2x5V99Y1SBqNgPZDPsa6r+L5y3BJ4XUCJMar3g=
private wNuHOKCfoH1emfvijXNBoc/7KjrEXUeof7tSdGWvRFo=   public PC1/jXQosaBad2HePOm/w1KjCZ82eT3qNbfzNDZiwTs=
private gJtn0woDChGvyN2eSdc7mTpAFA/nA6jykJeK5bYYfFA=   public Pc7+UEJSHiWsQ9zkO2q+guqDK4sc3VMDMgJu+h/bOFI=
private IMyPmYm/v0SPmB62hC8l6kfxT3/Lfp7dMioo+SM6T2c=   public Pc7/uVfD/ZftxWBHwYbaudEywUS61biBcpj5Tw830Q4=
</code></pre></div>

<p dir="auto">Download the <a href="https://github.com/axllent/wireguard-vanity-keygen/releases/latest">latest binary release</a> for your system,
or build from source <code>go install github.com/axllent/wireguard-vanity-keygen@latest</code>.</p>

<p dir="auto">To give you a rough idea of how long it will take to generate keys, the following table lists
estimated timings to find a matching key on a system that reported  &#34;<code>Calculating speed: 230,000 calculations per second using 19 CPU cores</code>&#34; when it started:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Length</th>
<th>Case-insensitive</th>
<th>Case-sensitive</th>
</tr>
</thead>
<tbody>
<tr>
<td>3 chars</td>
<td>0 seconds</td>
<td>1 second</td>
</tr>
<tr>
<td>4 chars</td>
<td>9 seconds</td>
<td>1 minute</td>
</tr>
<tr>
<td>5 chars</td>
<td>5 minutes</td>
<td>1.25 hours</td>
</tr>
<tr>
<td>6 chars</td>
<td>4 hours</td>
<td>3.5 days</td>
</tr>
<tr>
<td>7 chars</td>
<td>6 days</td>
<td>7 months</td>
</tr>
<tr>
<td>8 chars</td>
<td>7 months</td>
<td>38 years</td>
</tr>
<tr>
<td>9 chars</td>
<td>22 years</td>
<td>175 years</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">Note that the above timings are for finding a matching key for a single search term.
Passing multiple search terms will not substantially increase the time to find any single term, but the time to find
all search terms is the sum of all the estimated times.
Also, increasing the limit to two (<code>--limit 2</code>) will double the estimated time, three will triple the time, etc.</p>
<p dir="auto">If any search term contains numbers, the timings would fall somewhere between the case-insensitive and case-sensitive columns.</p>
<p dir="auto">Of course, your mileage will differ, depending on the number, and speed, of your CPU cores.</p>

<p dir="auto">Since each additional letter in a search term increases the search time exponentially, searching using a regular expression may
reduce the time considerably. Here are some examples:</p>
<ol dir="auto">
<li><code>.*word.*</code> - find word anywhere in the key (<code>word.*</code> and <code>.*word</code> will also work)</li>
<li><code>^.{0,10}word</code> - find word anywhere in the first 10 letters of the key</li>
<li><code>word1.*word2</code> - find two words, anywhere in the key</li>
<li><code>^[s5][o0][ll]ar</code> - find &#39;solar&#39;, or the visually similar &#39;s01ar`, at the beginning of the key</li>
<li><code>^(best|next)[/+]</code> - find &#39;best&#39;, or the &#39;next&#39; best, at the beginning of the key, with <code>/</code> or <code>+</code> as a delimiter</li>
</ol>
<p dir="auto">A good guide on Go&#39;s regular expression syntax is at <a href="https://pkg.go.dev/regexp/syntax" rel="nofollow">https://pkg.go.dev/regexp/syntax</a>.</p>
<p dir="auto">To include a literal <code>+</code> in your regular expression, preface it with a backslash: <code>^ex\+</code>.</p>
<p dir="auto">NOTE: If your search term contains shell metacharacters, such as <code>|</code>, or <code>^</code>, you will need to quote it.
On Windows, you must use double quotes. For example: <code>&#34;^(a|b)&#34;</code>.</p>
<p dir="auto">NOTE: Complex regular expressions, such as those using escape sequences, flags, or character classes, may never match a key.
To avoid that, consider testing your regex using a tool such as <a href="https://go.dev/play/p/6LJy51Wd08O" rel="nofollow">this one</a> on The Go Playground,
or the same tool on <a href="https://goplay.tools/snippet/6LJy51Wd08O" rel="nofollow">goplay.tools</a>.</p>

<div dir="auto"><h3 tabindex="-1" dir="auto">What characters can I search for?</h3><a id="user-content-what-characters-can-i-search-for" aria-label="Permalink: What characters can I search for?" href="#what-characters-can-i-search-for"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Valid characters include <code>A-Z</code>, <code>a-z</code>, <code>0-9</code>, <code>/</code> and <code>+</code>. There are no other characters in a hash.</p>
<p dir="auto">You can also use regex expressions to search.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Why does <code>test</code> &amp; <code>tes1</code> show different probabilities despite having 4 characters each?</h3><a id="user-content-why-does-test--tes1-show-different-probabilities-despite-having-4-characters-each" aria-label="Permalink: Why does test &amp; tes1 show different probabilities despite having 4 characters each?" href="#why-does-test--tes1-show-different-probabilities-despite-having-4-characters-each"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">With case-insensitive searches (default), a-z have the chance of matching both uppercase and lowercase. A search for &#34;cat&#34; can match <code>Cat</code>, <code>cAT</code> etc.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">How accurate are the estimated times?</h3><a id="user-content-how-accurate-are-the-estimated-times" aria-label="Permalink: How accurate are the estimated times?" href="#how-accurate-are-the-estimated-times"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">They are not (and cannot be) accurate. Keys are completely randomly generated, and the estimate is based on a law of averages.
For instance, you could find a match for a one in a billion chance on the very first hit, or it could take you 5 billion attempts.
It will however give you an indication based on your CPU speed, word count, case sensitivity, and use of numbers or characters.</p>

<p dir="auto">You don&#39;t. I wrote it because I run a WireGuard server, which does not provide any reference as to who the key belongs to (<code>wg</code> on the server).
Using vanity keys, I can at least identify connections. I also wanted to learn more about multi-core processing in Golang.</p>
</article></div></div>
  </body>
</html>
