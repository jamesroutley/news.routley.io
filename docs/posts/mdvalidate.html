<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://404wolf.com/posts/mdvalidate/">Original</a>
    <h1>mdvalidate</h1>
    
    <div id="readability-page-1" class="page"><div> <p>I love markdown. If you know me, you probably know this. But I also like types.
And whatâ€™s more untyped than a raw text document? So I sought to put an end to
this madness.</p>
<p>I like to use Markdown to store information that youâ€™d normally expect to be
structured in a daatabase or JSON, because, well, it looks nice, and itâ€™s just
text. Hereâ€™s what a contact in my contacts folder looks like (itâ€™s just a text
file):</p>
<pre tabindex="0" data-language="md"><code><span><span>Imported with [</span><span>Obsidian Markdown Importer</span><span>](</span><span>https://github.com/404Wolf/obsidian-contact-importer</span><span>)</span></span>
<span></span>
<span><span>---</span></span>
<span></span>
<span><span>![</span><span>Image</span><span>](</span><span>6bf36ff64dfc6d8a.jpeg</span><span>)</span></span>
<span></span>
<span><span>## Phones</span></span>
<span></span>
<span><span>| Type   | Number             |</span></span>
<span><span>| :----- | :----------------- |</span></span>
<span><span>| Backup | </span><span>`c!(917) 246-7875`</span><span> |</span></span>
<span><span>| Misc   | </span><span>`c!(929) 265-7180`</span><span> |</span></span>
<span></span>
<span><span>## Emails</span></span>
<span></span>
<span><span>| Type           | Address                        |</span></span>
<span><span>| :------------- | :----------------------------- |</span></span>
<span><span>| Misc           | </span><span>`c!wolf@404wolf.com`</span><span>           |</span></span>
<span><span>| Misc           | </span><span>`c!wsm32@case.edu`</span><span>             |</span></span>
<span></span>
<span><span>## Socials</span></span>
<span></span>
<span><span>| Type          | Handle        |</span></span>
<span><span>|:--------------|:--------------|</span></span>
<span><span>| GitHub        | </span><span>`c!404wolf`</span><span>   |</span></span>
<span></span>
<span><span>## Links</span></span>
<span></span>
<span><span>| Type     | URL                     |</span></span>
<span><span>| :------- | :---------------------- |</span></span>
<span><span>| HomePage | </span><span>`g!https://404wolf.com`</span><span> |</span></span>
<span></span>
<span><span>## Other</span></span>
<span></span>
<span><span>| Type          | Value         |</span></span>
<span><span>|:--------------|:--------------|</span></span>
<span><span>| Birthday      | </span><span>`g!xxxxxxxx`</span><span>  |</span></span>
<span></span>
<span><span>---</span></span>
<span></span>
<span><span>This is me.</span></span></code></pre>
<p>Itâ€™s Markdown!</p>
<p>Iâ€™m a heavy user of <a href="https://obsidian.md/">Obsidian</a>, a Markdown-first note
taking desktop app where all of your nodes live as a simple hierarchy of Markdown
files.</p>
<p>Storing my contacts this way is great, because I get to use all my favorite
text tools to mess with it. I can use vim binds to edit contacts, search across
them with ripgrep, and more. But they are just loose text. I want to force
them to be <em>structured</em>.</p>
<p>Enter <strong><code>mdvalidate</code></strong>.</p>
<p>With <code>mdvalidate</code>, I now can force my contact documents to be of a specific
shape. <code>mdvalidate</code> lets you define a schema for a Markdown file. For the above
document, the schema would look like:</p>
<pre tabindex="0" data-language="md"><code><span><span>Imported with [</span><span>Obsidian Markdown Importer</span><span>](</span><span>https://github.com/404Wolf/obsidian-contact-importer</span><span>)</span></span>
<span></span>
<span><span>---</span></span>
<span></span>
<span><span>![</span><span>{image_alt:/.*/}</span><span>](</span><span>{image_link:/.*/}</span><span>)</span></span>
<span></span>
<span><span>## Phones</span></span>
<span></span>
<span><span>| Type              | Number              |</span></span>
<span><span>| :---------------- | :------------------ |</span></span>
<span><span>| </span><span>`phone_type:/.*/`</span><span> | </span><span>`phone_number:/.*/`</span><span> |{,}</span></span>
<span></span>
<span><span>## Emails</span></span>
<span></span>
<span><span>| Type                | Address        |</span></span>
<span><span>| :------------------ | :------------- |</span></span>
<span><span>| </span><span>`contact_type:/.*/`</span><span> | </span><span>`contact:/.*/`</span><span> |{,}</span></span>
<span></span>
<span></span>
<span><span>## Socials</span></span>
<span></span>
<span><span>| Type               | Handle        |</span></span>
<span><span>|:-------------------|:--------------|</span></span>
<span><span>| </span><span>`social_type:/.*/`</span><span> | </span><span>`social:/.*/`</span><span> |{,}</span></span>
<span></span>
<span><span>## Links</span></span>
<span></span>
<span><span>| Type             | URL                     |</span></span>
<span><span>| :--------------- | :---------------------- |</span></span>
<span><span>| </span><span>`link_type:/.*/`</span><span> | </span><span>`link_url:/.*/`</span><span>         |{,}</span></span>
<span></span>
<span><span>## Other</span></span>
<span></span>
<span><span>| Type              | Value         |</span></span>
<span><span>|:------------------|:--------------|</span></span>
<span><span>| </span><span>`other_type:/.*/`</span><span> | </span><span>`other_url:/.*/`</span><span> |{,}</span></span>
<span></span>
<span><span>---</span></span>
<span></span>
<span><span>`comments`</span><span>{,}</span></span></code></pre>
<p>And, in a <em>blazingly fast</em> &lt;5ms ğŸ˜‚, I can extract all of the information:</p>
<pre tabindex="0" data-language="bash"><code><span><span>$</span><span> mdv</span><span> examples/cli/schema.md</span><span> examples/cli/input.md</span><span> -</span><span> |</span><span> jq</span></span>
<span><span>&#39;{</span></span>
<span><span>  &#34;comments&#34;: [</span></span>
<span><span>    &#34;This is me.&#34;</span></span>
<span><span>  ],</span></span>
<span><span>  &#34;contact&#34;: [</span></span>
<span><span>    &#34;`c!wolf@404wolf.com`&#34;,</span></span>
<span><span>    &#34;`c!wsm32@case.edu`&#34;</span></span>
<span><span>  ],</span></span>
<span><span>  &#34;contact_type&#34;: [</span></span>
<span><span>    &#34;Misc&#34;,</span></span>
<span><span>    &#34;Misc&#34;</span></span>
<span><span>  ],</span></span>
<span><span>  &#34;image_alt&#34;: &#34;Image&#34;,</span></span>
<span><span>  &#34;image_link&#34;: &#34;6bf36ff64dfc6d8a.jpeg&#34;,</span></span>
<span><span>  &#34;link_type&#34;: [</span></span>
<span><span>    &#34;HomePage&#34;</span></span>
<span><span>  ],</span></span>
<span><span>  &#34;link_url&#34;: [</span></span>
<span><span>    &#34;`g!https://404wolf.com`&#34;</span></span>
<span><span>  ],</span></span>
<span><span>  &#34;other_type&#34;: [</span></span>
<span><span>    &#34;Birthday&#34;</span></span>
<span><span>  ],</span></span>
<span><span>  &#34;other_url&#34;: [</span></span>
<span><span>    &#34;`g!xxxxxxxx`&#34;</span></span>
<span><span>  ],</span></span>
<span><span>  &#34;phone_number&#34;: [</span></span>
<span><span>    &#34;`c!(917) 246-7875`&#34;,</span></span>
<span><span>    &#34;`c!(929) 265-7180`&#34;</span></span>
<span><span>  ],</span></span>
<span><span>  &#34;phone_type&#34;: [</span></span>
<span><span>    &#34;Backup&#34;,</span></span>
<span><span>    &#34;Misc&#34;</span></span>
<span><span>  ],</span></span>
<span><span>  &#34;social&#34;: [</span></span>
<span><span>    &#34;`c!404wolf`&#34;</span></span>
<span><span>  ],</span></span>
<span><span>  &#34;social_type&#34;: [</span></span>
<span><span>    &#34;GitHub&#34;</span></span>
<span><span>  ]</span></span>
<span><span>}&#39;</span></span></code></pre>
<p>So cool!</p>

<p><code>mdvalidate</code> is a tool to validate the <em>shape</em> of Markdown. With <code>mdvalidate</code>,
you write <em>schemas</em> that define a shape of Markdown, and then check real
documents against them.</p>
<p>There are two main components right now, the schema definition language, which
I call <code>mds</code> (Markdown-schema), and a tool to both <em>validate</em> input documents
and <em>extract</em> arbitrary pieces of information from them. Right now, itâ€™s all
packaged into a CLI, but evenutally Iâ€™d like to make it a Rust and Typescript
(wasm) library.</p>
<p>I created <code>mdvalidate</code> because it was something I wanted. I want a way to use
Markdown to store structured data. Itâ€™s prettier and more fun to write than
<code>yaml</code>, you can lay out information in a way that â€œlooks nice,â€ and, itâ€™s just
text, so you should be able to invent a way to store the same types of
information that any other associative markup language like <code>JSON</code>, <code>yaml</code>,
<code>toml</code>, etc can store.</p>
<p>I really couldnâ€™t find any existing tools doing quite what I was looking for.
Thereâ€™s great tools like <a href="https://ast-grep.github.io/">AST grep</a> that can
search across code, including Markdown via Treesitter. But thereâ€™s really no
tool that is specifically meant for ensuring the structure of a Markdown
document, and, in particular, <em>extracting</em> information. So I set out to build
one.</p>
<p>Some important decisions in planning <code>mdvalidate</code> were defining an easy schema
lanugage looks like what it validates, supporting streaming input, and being
careful about expectations. Markdown is a convoluted language that comes in a
million flavors, and Iâ€™m only supporting what I think is the most important
subset for storing â€œdataâ€ in Markdown (so even though tables arenâ€™t
<a href="https://commonmark.org/">CommonMark</a>, theyâ€™re still a must).</p>
<h2 id="mdschema">â€œmdschemaâ€</h2>
<p><code>mdschema</code> is the schema language I desinged for <code>mdvalidate</code>. It is made to
aesthetically <em>look</em> like the type of document that it is validating. Because of
this, you can could take any type of Markdown document you have already that
stores semi-structured data, and turn it into a schema that can match a category
of document.</p>
<p>Letâ€™s look at a very basic example. To start, all â€œmdschemaâ€ files with vanilla
Markdown validate themselves. So</p>

<p>Validates, but produces no output. An input document will validate itself! We
can insert â€œmatchersâ€ into the Markdown, which are inline code spans with
special internal content, to â€œcaptureâ€ text:</p>

<p>And use regular expressions to force the text to be of a specific shape.</p>
<div>  <lion-tabs>   <div slot="panel">  <div> <div> <pre tabindex="0" data-language="markdown"><code><span><span># Hello </span><span>`name:/[A-Z][a-z]+/`</span></span></code></pre> </div>  </div>  </div>    </lion-tabs>  </div>
<p>There is special matcher syntax for various different types of Markdown nodes.</p>
<p>Suppose you store a task list in Markdown:</p>
<div>  <lion-tabs>   <div slot="panel">  <div> <div> <pre tabindex="0" data-language="markdown"><code><span><span># Grocery list</span></span>
<span></span>
<span><span> ## Food items</span></span>
<span><span> -</span><span> `food_item`</span><span>{,}</span></span>
<span></span>
<span><span> ## Cosmetics</span></span>
<span><span> -</span><span> `cosmetic`</span><span>{,}</span></span></code></pre> </div> <div> <pre tabindex="0" data-language="markdown"><code><span><span># Grocery list</span></span>
<span></span>
<span><span> ## Food items</span></span>
<span><span> -</span><span> Apples</span></span>
<span><span> -</span><span> Oranges</span></span>
<span></span>
<span><span> ## Cosmetics</span></span>
<span><span> -</span><span> Shampoo</span></span></code></pre> </div> </div>  </div>  <div slot="panel">  <pre tabindex="0" data-language="json"><code><span><span>{</span></span>
<span><span>  &#34;cosmetic&#34;</span><span>: [</span></span>
<span><span>    [</span></span>
<span><span>      &#34;Shampoo&#34;</span></span>
<span><span>    ]</span></span>
<span><span>  ],</span></span>
<span><span>  &#34;food_item&#34;</span><span>: [</span></span>
<span><span>    [</span></span>
<span><span>      &#34;Apples&#34;</span></span>
<span><span>    ],</span></span>
<span><span>    [</span></span>
<span><span>      &#34;Oranges&#34;</span></span>
<span><span>    ]</span></span>
<span><span>  ]</span></span>
<span><span>}</span></span></code></pre>  </div>  </lion-tabs>  </div>
<p>Notice how â€œnaturalâ€ it is to write up a schema for it.</p>
<p>You use repeating matchers, specifying <code>{,}</code> to say â€œas many list items of this
form as you want.â€</p>
<h2 id="streaming">Streaming</h2>
<p><code>mdvalidate</code> was made with streaming in mind, so you can also use it pipe input
(like LLM output) and validate the shape of its response.</p>
<div><div data-astro-cid-wxxzx3wp=""> <div data-astro-cid-wxxzx3wp="">  <p><img src="https://static.404wolf.com/ai-likes-markdown.png" alt="AI speaks markdown" data-zoom-trigger="zoom-modal-https---static-404wolf-com-ai-likes-markdown-png"/></p>  </div> </div>  </div>
<p>This is pretty cool, because alternatives these days are quite verbose, and it
turns out that <a href="https://community.openai.com/t/markdown-is-15-more-token-efficient-than-json/841742/4">Markdown is pretty token
efficient</a>.
Using Markdown to define a schema for an LLM to â€œfill outâ€ might be a cool new
way to do structured outputs!</p>
<p>For <code>mdvalidate</code> to be useful for this, we need to be able to short circuit.
For example, if we get something like:</p>
<div><pre tabindex="0" data-language="md"><code><span><span># Hello there Wolf!</span></span></code></pre><pre tabindex="0" data-language="md"><code><span><span># Hello t</span></span></code></pre><pre tabindex="0" data-language="md"><code><span><span># Hello tb</span></span></code></pre></div>
<p>We donâ€™t have to keep waiting. We can know that it will not validate and exit
early.</p>
<div><div><video src="https://static.404wolf.com/mdvalidate-stream.mp4" width="640" height="360" controls="" autoplay="" loop=""></video><p>Here we have a simple schema that defines a list of items that have a word,
followed by a number. We have an input with many items, all of which are
valid except one in the middle. I wrote a tiny script that streams the
input file into <code>mdvalidate</code> via stdin, so you can see that once we have
enough info to know the document has an invalid portion, we can exit early.</p></div></div>
<p>This is super handy, since Markdown is the native language of LLMs. With
<code>mdvalidate</code> you can extract text out of an LLM response, terminate it early if
it violates the allowed shape, and be much more token efficient than using many
other techniques like JSON schema.</p>
<p>It turns out streaming is really complicated to implement, and requires
validating trees that arenâ€™t totally well formed yet. So there are probably
some bugs lurking here.</p>

<p><code>mdvalidate</code> is a rust project made with the help of
<a href="https://tree-sitter.github.io/tree-sitter/">treesitter</a> for incremental
parsing and <a href="https://github.com/ikatyang/tree-sitter-markdown">this</a> Markdown
grammar. I chose Treesitter so that streaming support would be possible, since
Treesitter is good at dealing with incomplete trees, and also so that I can
quickly recompute trees without starting from scratch. Iâ€™m also using
<a href="https://docs.rs/ariadne/latest/ariadne/">ariadne</a>, a super cool pretty printer
Rust crate!</p>
<p>The development of <code>mdvalidate</code> is greatly simplified by the fact that the input
and schema both parse as valid markdown, so I didnâ€™t really have to implement
any parsing or lexing logic!</p>
<h2 id="tree-zippers">Tree Zippers</h2>
<p>At a high level, <code>mdvalidate</code> works by taking two abstract syntax trees for an
input markdown file and crawls them at the same time. At different points in the
schema, we should expect different elements in the input.</p>
<details> <summary> What&#39;s an AST? </summary> <div> <p>An AST (abstract syntax tree) is a tree that represents the semantic
relationships between elements in some language.</p><p>For example, code like <code>x = 1 + 2</code> might be represented as:</p><pre tabindex="0" data-language="plaintext"><code><span><span>Module</span></span>
<span><span>â””â”€ Assign</span></span>
<span><span>   â”œâ”€ Name (x)</span></span>
<span><span>   â””â”€ BinOp</span></span>
<span><span>      â”œâ”€ Constant (1)</span></span>
<span><span>      â”œâ”€ Add</span></span>
<span><span>      â””â”€ Constant (2)</span></span></code></pre><p>In Markdown, a document like <code># Hello</code> would have an AST like:</p><pre tabindex="0" data-language="plaintext"><code><span><span>document</span></span>
<span><span>â””â”€ atx_heading</span></span>
<span><span>   â”œâ”€ atx_h1_marker (#)</span></span>
<span><span>   â””â”€ heading_content</span></span>
<span><span>      â””â”€ text (Hello)</span></span></code></pre><p>Fun fact: Zed (editor) uses treesitter, the same incremental parser Iâ€™m using, and lets you preview an AST of your code in the editor live!</p><div data-astro-cid-wxxzx3wp=""> <div data-astro-cid-wxxzx3wp="">  <p><img src="https://static.404Wolf.com/treesitter-in-zed.png" alt="Treesitter in zed" data-zoom-trigger="zoom-modal-https---static-404Wolf-com-treesitter-in-zed-png"/></p>  </div> </div>  <p>To check out the AST for a document in <code>zed</code>, open the run menu
<code>ctrl+shift+p</code> and type <code>dev: open syntax tree view</code>.</p><p><code>zed</code> uses a different treesitter grammer than I am â€” <a href="https://github.com/tree-sitter-grammars/tree-sitter-markdown">this
one</a>.</p> </div> </details>
<p>Consider this:</p>
<p>When we are looking at the input:</p>

<p>These are the actual syntax trees that Treesitter gives us:</p>
<div>  <div> <div> <pre tabindex="0" data-language="markdown"><code><span><span>document</span></span>
<span><span>â””â”€ atx_heading</span></span>
<span><span> â”œâ”€ atx_h1_marker</span></span>
<span><span> â””â”€ heading_content</span></span>
<span><span>    â””â”€ text</span></span></code></pre> </div> <div> <pre tabindex="0" data-language="markdown"><code><span><span>document</span></span>
<span><span>â””â”€ atx_heading</span></span>
<span><span> â”œâ”€ atx_h1_marker</span></span>
<span><span> â””â”€ heading_content</span></span>
<span><span>    â””â”€ text</span></span></code></pre> </div> </div> </div>
<p>In this case, we are doing â€œliteral validationâ€ where we want to make sure that
each node matches exactly with the schema. To start, we put pointers here:</p>
<div>  <div> <div> <pre tabindex="0" data-language="markdown"><code><span><span>document &lt;-- we are here</span></span>
<span><span>â””â”€ atx_heading</span></span>
<span><span> â”œâ”€ atx_h1_marker</span></span>
<span><span> â””â”€ heading_content</span></span>
<span><span>    â””â”€ text</span></span></code></pre> </div> <div> <pre tabindex="0" data-language="markdown"><code><span><span>document &lt;-- we are here</span></span>
<span><span>â””â”€ atx_heading</span></span>
<span><span> â”œâ”€ atx_h1_marker</span></span>
<span><span> â””â”€ heading_content</span></span>
<span><span>    â””â”€ text</span></span></code></pre> </div> </div> </div>
<p>And â€œwalkâ€ the treeâ€¦</p>
<div>  <div> <div> <pre tabindex="0" data-language="markdown"><code><span><span>document &lt;-- matches âœ”</span></span>
<span><span>â””â”€ atx_heading &lt;-- matches âœ”</span></span>
<span><span> â”œâ”€ atx_h1_marker &lt;-- matches âœ”</span></span>
<span><span> â””â”€ heading_content &lt;-- matches âœ”</span></span>
<span><span>    â””â”€ text &lt;-- matches âœ”</span></span></code></pre> </div> <div> <pre tabindex="0" data-language="markdown"><code><span><span>document &lt;-- matches âœ”</span></span>
<span><span>â””â”€ atx_heading &lt;-- matches âœ”</span></span>
<span><span> â”œâ”€ atx_h1_marker &lt;-- matches âœ”</span></span>
<span><span> â””â”€ heading_content &lt;-- matches âœ”</span></span>
<span><span>    â””â”€ text &lt;-- matches âœ”</span></span></code></pre> </div> </div> </div>
<p>Recursing our way down. To know that a document is valid, we need to ensure that
the children are valid, to know that the child <code>heading_content</code> is valid, it
has to be the same kind of heading with the same text content.</p>
<p>I call this method the â€œzipper treeâ€ method, because weâ€™re â€œzippingâ€ our way
down the two ASTs making sure they are the same.</p>
<p>The implementation of this is conceptually simple. We look at the root document
node, iterate over the siblings of the schema and input at the same rate, and
figure out what <em>kind</em> of validator we need to use to compare them. When we get
to more fun cases besides literals, this gets a little more tricky.</p>
<h2 id="matchers">Matchers</h2>
<p>Things get real complicated real fast. <code>mdvalidate</code> has the concept of
â€œmatchers,â€ which are a mechanism to perform â€œcaptures.â€ A matcher has the form
<code>`id:/re/`&lt;extras&gt;</code>, where <code>id</code> is what the capture of the <code>re</code> regex pattern in
the output, and <code>&lt;extras&gt;</code> is for special cases like repeating lists. For
example,</p>
<div>  <lion-tabs>   <div slot="panel">  <div> <div> <pre tabindex="0" data-language="markdown"><code><span><span># Hi </span><span>`name:/[A-Z][a-z]+/`</span></span></code></pre> </div>  </div>  </div>    </lion-tabs>  </div>
<p>â€œextractsâ€ my name from the header of some Markdown document.</p>
<p>If we look at our friend, the Zipper Tree, youâ€™ll find:</p>
<div>  <div> <div> <pre tabindex="0" data-language="markdown"><code><span><span>document</span></span>
<span><span>â””â”€ atx_heading</span></span>
<span><span> â”œâ”€ atx_h1_marker</span></span>
<span><span> â””â”€ heading_content &lt;-- we are here</span></span>
<span><span>    â”œâ”€ text</span></span>
<span><span>    â””â”€ code_span</span></span>
<span><span>       â””â”€ text</span></span></code></pre> </div> <div> <pre tabindex="0" data-language="markdown"><code><span><span>document</span></span>
<span><span>â””â”€ atx_heading</span></span>
<span><span> â”œâ”€ atx_h1_marker</span></span>
<span><span> â””â”€ heading_content &lt;-- we are here</span></span>
<span><span>    â””â”€ text</span></span></code></pre> </div> </div> </div>
<p>And, when we are at the content container for the matcher, we will need to walk
<em>more</em> nodes for the schema than we do the input. This is similar in the case
of â€œrepeated listsâ€ too.</p>
<p>How do we go about implementing this? Abstraction, of course!</p>
<p><code>mdvalidate</code> handles different types of node comparisons by using according
â€œValidators.â€ For the case of matchers, the call stack looks roughly like:</p>
<pre tabindex="0" data-language="ansi"><code><span><span>NodeVsNodeValidator::validate (document vs document)</span></span>
<span><span>â””â”€ NodeVsNodeValidator::validate (heading vs heading)</span></span>
<span><span>   â””â”€ HeadingVsHeadingValidator::validate</span></span>
<span><span>      â””â”€ ContainerVsContainerValidator::validate</span></span>
<span><span>         â””â”€ TextualVsTextualValidator::validate</span></span>
<span><span>           â””â”€ MatcherVsTextualValidator::validate</span></span>
<span><span>            â”œâ”€ Validate prefix &#34;Hi &#34; âœ”</span></span>
<span><span>            â”œâ”€ Match regex /[A-Z][a-z]+/ against &#34;Wolf&#34; âœ”</span></span>
<span><span>            â””â”€ Store capture {name: &#34;Wolf&#34;}</span></span></code></pre>
<p>We start at the document root, recurse into the heading nodes, and then validate
the heading content. Textual containers are collections of inline textual nodes,
like <code>*test*_test_</code> is a paragraph with a italic and subsequent bold node. When
we get to the text content, we find the matcher <code>`name:/[A-Z][a-z]+/`</code>,
validate the prefix â€œHi â€ matches, then apply the regex pattern to extract
â€œWolfâ€ and store it under the id â€œnameâ€. We have to keep careful track of byte
offsets.</p>
<p>Each of these â€œvalidatorâ€ functions returns a validation result, which stores:</p>
<ul>
<li><code>value</code>: The resulting JSON value with all captures we just got</li>
<li><code>errors</code>: A vector of all validation errors encountered</li>
<li><code>farthest_reached_pos</code>: The farthest position reached in both trees</li>
</ul>
<p>As we keep going, we get a stack like:</p>
<pre tabindex="0" data-language="ansi"><code><span><span>---------</span></span>
<span><span>ValidationResult</span></span>
<span><span>  value: {name: &#34;Wolf&#34;, ...},</span></span>
<span><span>  errors: [],</span></span>
<span><span>  farthest_reached_pos: { schema_idx: usize, input_idx: usize }</span></span>
<span><span>---------</span></span>
<span><span>...</span></span>
<span><span>---------</span></span>
<span><span>ValidationResult</span></span>
<span><span>  value: {name: &#34;Wolf&#34;},</span></span>
<span><span>  errors: [],</span></span>
<span><span>  farthest_reached_pos: { schema_idx: usize, input_idx: usize }</span></span>
<span><span>---------</span></span></code></pre>
<p>Along the way, thereâ€™s some complicated cases we have to handle specially when
certain nodes act like other nodes, which the different validators are able to
delagate. For example, you can specify you expect a literal code node in your
input by using a â€!â€ extra, like so</p>

<p>When we run <code>ContainerVsContainerValidator::validate</code>, when we check
that the number of children matches up, we have to consider the number of
children counting <code>`wolf`!</code> as a single node, since the AST looks like</p>
<pre tabindex="0" data-language="ansi"><code><span><span>document</span></span>
<span><span>â””â”€ atx_heading</span></span>
<span><span>   â”œâ”€ atx_h1_marker</span></span>
<span><span>   â””â”€ heading_content</span></span>
<span><span>      â”œâ”€ text</span></span>
<span><span>      â”œâ”€ code_span</span></span>
<span><span>      â”‚  â””â”€ text</span></span>
<span><span>      â””â”€ text</span></span></code></pre>
<p>But if we have</p>

<p>Then we actually donâ€™t â€œcoalesceâ€ the â€!â€.</p>
<details> <summary> You&#39;d think something like counting nodes would be simple! </summary> <div> <p>The actual algorithm I used to figure out how many nodes we expect in the input
for some schema involves counting the nodes in the schema, and then subtracting
the number of nodes we must collapse, by iterating over each node, and for each
node, updating a correction factor using the following decision tree. Then, we
subtract the two to find the number of nodes we expect.</p><pre tabindex="0" data-language="ansi"><code><span><span>we at matcher?</span></span>
<span><span>â”œâ”€â”€ no</span></span>
<span><span>â”‚   â””â”€â”€ next is matcher?</span></span>
<span><span>â”‚       â”œâ”€â”€ no -&gt; collapse 0 nodes</span></span>
<span><span>â”‚       â””â”€â”€ yes</span></span>
<span><span>â”‚           â””â”€â”€ at text?</span></span>
<span><span>â”‚               â”œâ”€â”€ no -&gt; collapse 0 nodes</span></span>
<span><span>â”‚               â””â”€â”€ yes -&gt; next is coalescing</span></span>
<span><span>â”‚                           â”œâ”€â”€ no -&gt; collapse 1 node</span></span>
<span><span>â”‚                           â””â”€â”€ yes -&gt; collapse 0 nodes</span></span>
<span><span>â””â”€â”€ yes</span></span>
<span><span>    â”œâ”€â”€ is coalescing?</span></span>
<span><span>    â”‚   â””â”€â”€ yes</span></span>
<span><span>    â”‚       â””â”€â”€ end is at end?</span></span>
<span><span>    â”‚           â”œâ”€â”€ yes -&gt; collapse 1 node</span></span>
<span><span>    â”‚           â””â”€â”€ no -&gt; non text follows?</span></span>
<span><span>    â”‚                       â”œâ”€â”€ yes -&gt; collapse 1 node</span></span>
<span><span>    â”‚                       â””â”€â”€ no -&gt; collapse 1 node</span></span>
<span><span>    â””â”€â”€ no</span></span>
<span><span>        â””â”€â”€ has extra text?</span></span>
<span><span>            â”œâ”€â”€ yes -&gt; collapse 1 node</span></span>
<span><span>            â””â”€â”€ no -&gt; collapse 0 nodes</span></span></code></pre> </div> </details>
<h2 id="the-walker-abstraction">The Walker Abstraction</h2>
<p>And then we can, in the context of a validator, pick up at the index one of our
callees left off at. In this case, <code>TextualVsTextualValidator::validate</code> will leave us
off at the end of the â€œtextual containerâ€, so thereâ€™s no more work left to be
done.</p>
<p>Treesitter makes dealing with positions like this relatively straightforward.
you can use
<a href="https://docs.rs/tree-sitter/latest/tree_sitter/struct.treecursor.html">treecursor</a>s,
which are mutable and keep state about where they are in the tree.</p>
<p>Using tree cursors usually looks something like this:</p>
<pre tabindex="0" data-language="rs"><code><span><span>let</span><span> tree </span><span>=</span><span> parser</span><span>.</span><span>parse</span><span>(</span><span>&#34;# Hello</span><span>\n</span><span>&#34;</span><span>, </span><span>None</span><span>)</span><span>.</span><span>unwrap</span><span>();</span></span>
<span><span>let</span><span> mut</span><span> cursor</span><span>:</span><span> TreeCursor</span><span> =</span><span> tree</span><span>.</span><span>walk</span><span>();</span></span>
<span></span>
<span><span>// document -&gt; first child</span></span>
<span><span>cursor</span><span>.</span><span>goto_first_child</span><span>();</span></span>
<span><span>println!</span><span>(</span><span>&#34;node kind: {}&#34;</span><span>, cursor</span><span>.</span><span>node</span><span>()</span><span>.</span><span>kind</span><span>());</span></span>
<span></span>
<span><span>// heading -&gt; marker</span></span>
<span><span>cursor</span><span>.</span><span>goto_first_child</span><span>();</span></span>
<span><span>println!</span><span>(</span><span>&#34;node kind: {}&#34;</span><span>, cursor</span><span>.</span><span>node</span><span>()</span><span>.</span><span>kind</span><span>());</span></span>
<span></span>
<span><span>// marker -&gt; heading_content</span></span>
<span><span>cursor</span><span>.</span><span>goto_next_sibling</span><span>();</span></span>
<span><span>println!</span><span>(</span><span>&#34;node kind: {}&#34;</span><span>, cursor</span><span>.</span><span>node</span><span>()</span><span>.</span><span>kind</span><span>());</span></span></code></pre>
<p>All of the <code>validator</code> functions take immutable references to a cursor, which
has stateful information that is immediately useful, and then does validation,
picking up where that cursor is by cloning the cursor into a mutable new one, so
that we donâ€™t mess up the callersâ€™ state in case they choose not to leave off
where we finish.</p>
<p>To make it easier to maintain state, I created an abstraction over the two trees
we are walking called a
<a href="https://github.com/404Wolf/mdvalidate/blob/main/src/mdschema/validation/validator.rs"><code>Validator</code></a>.
This manages the state of where the schema node and input nodes currently last
left off, and makes it easy to load in more input incrementally by â€œrememberingâ€
the previous state.</p>
<pre tabindex="0" data-language="rs"><code><span><span>/// A Validator implementation that uses a zipper tree approach to validate</span></span>
<span><span>/// an input Markdown document against a markdown schema treesitter tree.</span></span>
<span><span>#[derive(</span><span>Debug</span><span>)]</span></span>
<span><span>pub</span><span> struct</span><span> Validator</span><span> {</span></span>
<span><span>    /// The schema tree, which does not change after initialization.</span></span>
<span><span>    schema_tree</span><span>:</span><span> Tree</span><span>,</span></span>
<span><span>    /// The full schema string. Does not change.</span></span>
<span><span>    schema_str</span><span>:</span><span> String</span><span>,</span></span>
<span><span>    /// The current input tree. When read_input is called, this is replaced with a new tree.</span></span>
<span><span>    input_tree</span><span>:</span><span> Tree</span><span>,</span></span>
<span><span>    /// The full input string as last read. Not used internally but useful for</span></span>
<span><span>    /// debugging or reporting.</span></span>
<span><span>    last_input_str</span><span>:</span><span> String</span><span>,</span></span>
<span><span>    /// Whether we have received the end of the input. This means that last</span></span>
<span><span>    /// input tree descendant index is at the end of the input.</span></span>
<span><span>    got_eof</span><span>:</span><span> bool</span><span>,</span></span>
<span><span>    /// Map of matches found so far.</span></span>
<span><span>    matches_so_far</span><span>:</span><span> Value</span><span>,</span></span>
<span><span>    /// Any errors encountered during validation.</span></span>
<span><span>    errors_so_far</span><span>:</span><span> Vec</span><span>&lt;</span><span>ValidationError</span><span>&gt;,</span></span>
<span><span>    /// Our farthest reached position.</span></span>
<span><span>    farthest_reached_pos</span><span>:</span><span> NodePosPair</span><span>,</span></span>
<span><span>}</span></span></code></pre>
<p>The validator has two important methods: <code>read_input</code> and <code>validate</code>.</p>
<details> <summary> `read_input` updates the `input_tree` by applying an &#34;edit.&#34; Treesitter makes this extremely fast for us. </summary> <div> <pre tabindex="0" data-language="rs"><code><span><span>fn</span><span> read_input</span><span>(</span><span>&amp;mut</span><span> self</span><span>, input</span><span>:</span><span> &amp;</span><span>str</span><span>, got_eof</span><span>:</span><span> bool</span><span>) </span><span>-&gt;</span><span> Result</span><span>&lt;(), </span><span>ValidationError</span><span>&gt; {</span></span>
<span><span>    // Update internal state of the last input string</span></span>
<span><span>    self</span><span>.</span><span>state</span><span>.</span><span>set_last_input_str</span><span>(input</span><span>.</span><span>to_string</span><span>());</span></span>
<span></span>
<span><span>    // If we already got EOF, do not accept more input</span></span>
<span><span>    if</span><span> self</span><span>.</span><span>state</span><span>.</span><span>got_eof</span><span>() {</span></span>
<span><span>        return</span><span> Err</span><span>(</span><span>ValidationError</span><span>::</span><span>ParserError</span><span>(</span><span>ParserError</span><span>::</span><span>ReadAfterEOF</span><span>));</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    self</span><span>.</span><span>state</span><span>.</span><span>set_got_eof</span><span>(got_eof);</span></span>
<span></span>
<span><span>    // Calculate the range of new content</span></span>
<span><span>    let</span><span> old_len </span><span>=</span><span> self</span><span>.</span><span>input_tree</span><span>.</span><span>root_node</span><span>()</span><span>.</span><span>byte_range</span><span>()</span><span>.</span><span>end;</span></span>
<span><span>    let</span><span> new_len </span><span>=</span><span> input</span><span>.</span><span>len</span><span>();</span></span>
<span></span>
<span><span>    // Only parse if there&#39;s actually new content</span></span>
<span><span>    if</span><span> new_len </span><span>&lt;=</span><span> old_len {</span></span>
<span><span>        return</span><span> Ok</span><span>(());</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    // Parse incrementally, providing the edit information</span></span>
<span><span>    let</span><span> edit </span><span>=</span><span> InputEdit</span><span> {</span></span>
<span><span>        start_byte</span><span>:</span><span> old_len,</span></span>
<span><span>        old_end_byte</span><span>:</span><span> old_len,</span></span>
<span><span>        new_end_byte</span><span>:</span><span> new_len,</span></span>
<span><span>        start_position</span><span>:</span><span> self</span><span>.</span><span>input_tree</span><span>.</span><span>root_node</span><span>()</span><span>.</span><span>end_position</span><span>(),</span></span>
<span><span>        old_end_position</span><span>:</span><span> self</span><span>.</span><span>input_tree</span><span>.</span><span>root_node</span><span>()</span><span>.</span><span>end_position</span><span>(),</span></span>
<span><span>        new_end_position</span><span>:</span><span> {</span></span>
<span><span>            let</span><span> lookup </span><span>=</span><span> LineColLookup</span><span>::</span><span>new</span><span>(input);</span></span>
<span><span>            let</span><span> (row, col) </span><span>=</span><span> lookup</span><span>.</span><span>get</span><span>(new_len);</span></span>
<span><span>            Point</span><span> { row, column</span><span>:</span><span> col }</span></span>
<span><span>        },</span></span>
<span><span>    };</span></span>
<span></span>
<span><span>    // We need to call edit() to inform the tree about changes in the source text</span></span>
<span><span>    // before reusing it for incremental parsing. This allows tree-sitter to</span></span>
<span><span>    // efficiently reparse only the modified portions of the tree. (it</span></span>
<span><span>    // requires the state to match the new text)</span></span>
<span><span>    self</span><span>.</span><span>input_tree</span><span>.</span><span>edit</span><span>(</span><span>&amp;</span><span>edit); </span><span>// edit doesn&#39;t know about the new text content!</span></span>
<span></span>
<span><span>    let</span><span> mut</span><span> input_parser </span><span>=</span><span> new_markdown_parser</span><span>();</span></span>
<span><span>    match</span><span> input_parser</span><span>.</span><span>parse</span><span>(input, </span><span>Some</span><span>(</span><span>&amp;</span><span>self</span><span>.</span><span>input_tree)) {</span></span>
<span><span>        Some</span><span>(parse) </span><span>=&gt;</span><span> {</span></span>
<span><span>            self</span><span>.</span><span>input_tree </span><span>=</span><span> parse;</span></span>
<span><span>            Ok</span><span>(())</span></span>
<span><span>        }</span></span>
<span><span>        None</span><span> =&gt;</span><span> Err</span><span>(</span><span>ValidationError</span><span>::</span><span>ParserError</span><span>(</span><span>ParserError</span><span>::</span><span>TreesitterError</span><span>)),</span></span>
<span><span>    }</span></span>
<span><span>}</span></span></code></pre> </div> </details>
<details> <summary> And `validate` kicks off the chain, calling NodeVsNodeValidator::validate. </summary> <div> <pre tabindex="0" data-language="rs"><code><span><span>/// Validates the input markdown against the schema by traversing both trees</span></span>
<span><span>/// in parallel to the ends, starting from where we last left off.</span></span>
<span><span>pub</span><span> fn</span><span> validate</span><span>(</span><span>&amp;mut</span><span> self</span><span>) {</span></span>
<span><span>    if</span><span> self</span><span>.</span><span>got_eof</span><span>() {</span></span>
<span><span>        self</span><span>.</span><span>set_farthest_reached_pos</span><span>(</span><span>NodePosPair</span><span>::</span><span>default</span><span>());</span></span>
<span><span>        // Clear errors when revalidating from the beginning at EOF</span></span>
<span><span>        // to avoid duplicate errors from streaming validation</span></span>
<span><span>        self</span><span>.</span><span>errors_so_far</span><span>.</span><span>clear</span><span>();</span></span>
<span><span>        self</span><span>.</span><span>matches_so_far </span><span>=</span><span> Value</span><span>::</span><span>Object</span><span>(</span><span>Map</span><span>::</span><span>new</span><span>());</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    let</span><span> got_eof </span><span>=</span><span> self</span><span>.</span><span>got_eof</span><span>();</span></span>
<span><span>    let</span><span> farthest_reached_pos </span><span>=</span><span> self</span><span>.</span><span>farthest_reached_pos</span><span>();</span></span>
<span><span>    let</span><span> schema_str </span><span>=</span><span> self</span><span>.</span><span>schema_str</span><span>.</span><span>clone</span><span>();</span></span>
<span><span>    let</span><span> input_str </span><span>=</span><span> self</span><span>.</span><span>last_input_str</span><span>.</span><span>clone</span><span>();</span></span>
<span></span>
<span><span>    let</span><span> validation_result </span><span>=</span><span> {</span></span>
<span><span>        let</span><span> mut</span><span> schema_cursor </span><span>=</span><span> self</span><span>.</span><span>schema_tree</span><span>.</span><span>walk</span><span>();</span></span>
<span><span>        let</span><span> mut</span><span> input_cursor </span><span>=</span><span> self</span><span>.</span><span>input_tree</span><span>.</span><span>walk</span><span>();</span></span>
<span></span>
<span><span>        // Go to where we last left off</span></span>
<span><span>        farthest_reached_pos</span><span>.</span><span>walk_cursors_to_pos</span><span>(</span><span>&amp;mut</span><span> schema_cursor, </span><span>&amp;mut</span><span> input_cursor);</span></span>
<span></span>
<span><span>        let</span><span> walker </span><span>=</span><span> ValidatorWalker</span><span>::</span><span>new</span><span>(schema_cursor, </span><span>&amp;</span><span>schema_str, input_cursor, </span><span>&amp;</span><span>input_str);</span></span>
<span><span>        NodeVsNodeValidator</span><span>.</span><span>validate</span><span>(</span><span>&amp;</span><span>walker, got_eof)</span></span>
<span><span>    };</span></span>
<span></span>
<span><span>    self</span><span>.</span><span>push_validation_result</span><span>(validation_result);</span></span>
<span><span>}</span></span></code></pre> </div> </details>
<p>All in all, using <code>mdvalidate</code> as a library is really simple! It looks
something like:</p>
<pre tabindex="0" data-language="rs"><code><span><span>pub</span><span> fn</span><span> process</span><span>&lt;</span><span>R</span><span>:</span><span> Read</span><span>&gt;(</span></span>
<span><span>    schema_str</span><span>:</span><span> &amp;</span><span>String</span><span>,</span></span>
<span><span>    input</span><span>:</span><span> &amp;mut</span><span> R</span><span>,</span></span>
<span><span>    fast_fail</span><span>:</span><span> bool</span><span>,</span></span>
<span><span>) </span><span>-&gt;</span><span> Result</span><span>&lt;((</span><span>Vec</span><span>&lt;</span><span>ValidationError</span><span>&gt;, </span><span>Value</span><span>), </span><span>Validator</span><span>, </span><span>String</span><span>), </span><span>ProcessingError</span><span>&gt; {</span></span>
<span><span>    let</span><span> buffer_size </span><span>=</span><span> get_buffer_size</span><span>();</span></span>
<span></span>
<span><span>    let</span><span> mut</span><span> input_str </span><span>=</span><span> String</span><span>::</span><span>new</span><span>();</span></span>
<span><span>    let</span><span> mut</span><span> buffer </span><span>=</span><span> vec!</span><span>[</span><span>0</span><span>; buffer_size];</span></span>
<span></span>
<span><span>    // Create a new validator from a fragment of an input, and a complete schema</span></span>
<span><span>    let</span><span> mut</span><span> validator </span><span>=</span><span> Validator</span><span>::</span><span>new_incomplete</span><span>(schema_str</span><span>.</span><span>as_str</span><span>(), input_str</span><span>.</span><span>as_str</span><span>())</span></span>
<span><span>        .</span><span>ok_or</span><span>(</span><span>ValidationError</span><span>::</span><span>ValidatorCreationFailed</span><span>)</span><span>?</span><span>;</span></span>
<span></span>
<span><span>    loop</span><span> {</span></span>
<span><span>        let</span><span> bytes_read </span><span>=</span><span> input</span><span>.</span><span>read</span><span>(</span><span>&amp;mut</span><span> buffer)</span><span>?</span><span>;</span></span>
<span></span>
<span><span>        // If we&#39;re done reading, mark EOF</span></span>
<span><span>        if</span><span> bytes_read </span><span>==</span><span> 0</span><span> {</span></span>
<span><span>            validator</span><span>.</span><span>read_final_input</span><span>(</span><span>&amp;</span><span>input_str)</span><span>?</span><span>;</span></span>
<span><span>            validator</span><span>.</span><span>validate</span><span>();</span></span>
<span></span>
<span><span>            break</span><span>;</span></span>
<span><span>        }</span></span>
<span></span>
<span><span>        let</span><span> new_text </span><span>=</span><span> std</span><span>::</span><span>str</span><span>::</span><span>from_utf8</span><span>(</span><span>&amp;</span><span>buffer[</span><span>..</span><span>bytes_read])</span><span>?</span><span>;</span></span>
<span><span>        input_str</span><span>.</span><span>push_str</span><span>(new_text);</span></span>
<span></span>
<span><span>        validator</span><span>.</span><span>read_more_input</span><span>(</span><span>&amp;</span><span>input_str)</span><span>?</span><span>;</span></span>
<span><span>        validator</span><span>.</span><span>validate</span><span>();</span></span>
<span></span>
<span><span>        // Check for fast-fail AFTER validation</span></span>
<span><span>        if</span><span> fast_fail </span><span>&amp;&amp;</span><span> validator</span><span>.</span><span>errors_so_far</span><span>()</span><span>.</span><span>count</span><span>() &gt; </span><span>0</span><span> {</span></span>
<span><span>            break</span><span>;</span></span>
<span><span>        }</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    let</span><span> errors</span><span>:</span><span> Vec</span><span>&lt;_&gt; </span><span>=</span><span> validator</span><span>.</span><span>errors_so_far</span><span>()</span><span>.</span><span>cloned</span><span>()</span><span>.</span><span>collect</span><span>();</span></span>
<span><span>    let</span><span> matches </span><span>=</span><span> validator</span><span>.</span><span>matches_so_far</span><span>()</span><span>.</span><span>clone</span><span>();</span></span>
<span></span>
<span><span>    Ok</span><span>(((errors, matches), validator, input_str))</span></span>
<span><span>}</span></span></code></pre>
<p>The process looks like this:</p>
<div><div><p><span>Validation Flow</span></p><div data-astro-cid-qz3dz2lk=""> <div data-astro-cid-qz3dz2lk=""><svg id="my-svg" width="100%" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="max-width: 652.5px; background-color: transparent;" viewBox="0 0 652.5 918" role="graphics-document document" aria-roledescription="flowchart-v2"><g><marker id="my-svg_flowchart-v2-pointEnd" viewBox="0 0 10 10" refX="5" refY="5" markerUnits="userSpaceOnUse" markerWidth="8" markerHeight="8" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker><marker id="my-svg_flowchart-v2-pointStart" viewBox="0 0 10 10" refX="4.5" refY="5" markerUnits="userSpaceOnUse" markerWidth="8" markerHeight="8" orient="auto"><path d="M 0 5 L 10 10 L 10 0 z" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker><marker id="my-svg_flowchart-v2-circleEnd" viewBox="0 0 10 10" refX="11" refY="5" markerUnits="userSpaceOnUse" markerWidth="11" markerHeight="11" orient="auto"><circle cx="5" cy="5" r="5" style="stroke-width: 1; stroke-dasharray: 1, 0;"></circle></marker><marker id="my-svg_flowchart-v2-circleStart" viewBox="0 0 10 10" refX="-1" refY="5" markerUnits="userSpaceOnUse" markerWidth="11" markerHeight="11" orient="auto"><circle cx="5" cy="5" r="5" style="stroke-width: 1; stroke-dasharray: 1, 0;"></circle></marker><marker id="my-svg_flowchart-v2-crossEnd" viewBox="0 0 11 11" refX="12" refY="5.2" markerUnits="userSpaceOnUse" markerWidth="11" markerHeight="11" orient="auto"><path d="M 1,1 l 9,9 M 10,1 l -9,9" style="stroke-width: 2; stroke-dasharray: 1, 0;"></path></marker><marker id="my-svg_flowchart-v2-crossStart" viewBox="0 0 11 11" refX="-1" refY="5.2" markerUnits="userSpaceOnUse" markerWidth="11" markerHeight="11" orient="auto"><path d="M 1,1 l 9,9 M 10,1 l -9,9" style="stroke-width: 2; stroke-dasharray: 1, 0;"></path></marker><g><g></g><g><path d="M284.75,62L284.75,66.167C284.75,70.333,284.75,78.667,284.75,86.333C284.75,94,284.75,101,284.75,104.5L284.75,108" id="L_User_Read_0" style=";" data-edge="true" data-et="edge" data-id="L_User_Read_0" data-points="W3sieCI6Mjg0Ljc1LCJ5Ijo2Mn0seyJ4IjoyODQuNzUsInkiOjg3fSx7IngiOjI4NC43NSwieSI6MTEyfV0=" marker-end="url(#my-svg_flowchart-v2-pointEnd)"></path><path d="M332.25,44.763L366.5,51.802C400.75,58.842,469.25,72.921,503.5,83.46C537.75,94,537.75,101,537.75,104.5L537.75,108" id="L_User_SchemaTree_0" style=";" data-edge="true" data-et="edge" data-id="L_User_SchemaTree_0" data-points="W3sieCI6MzMyLjI1LCJ5Ijo0NC43NjI4NDU4NDk4MDIzNzV9LHsieCI6NTM3Ljc1LCJ5Ijo4N30seyJ4Ijo1MzcuNzUsInkiOjExMn1d" marker-end="url(#my-svg_flowchart-v2-pointEnd)"></path><path d="M190.899,166L176.416,170.167C161.933,174.333,132.966,182.667,118.483,190.333C104,198,104,205,104,208.5L104,212" id="L_Read_InputCursor_0" style=";" data-edge="true" data-et="edge" data-id="L_Read_InputCursor_0" data-points="W3sieCI6MTkwLjg5OTAzODQ2MTUzODQ1LCJ5IjoxNjZ9LHsieCI6MTA0LCJ5IjoxOTF9LHsieCI6MTA0LCJ5IjoyMTZ9XQ==" marker-end="url(#my-svg_flowchart-v2-pointEnd)"></path><path d="M104,270L104,274.167C104,278.333,104,286.667,113.52,294.747C123.039,302.826,142.078,310.653,151.598,314.566L161.118,318.479" id="L_InputCursor_Sync_0" style=";" data-edge="true" data-et="edge" data-id="L_InputCursor_Sync_0" data-points="W3sieCI6MTA0LCJ5IjoyNzB9LHsieCI6MTA0LCJ5IjoyOTV9LHsieCI6MTY0LjgxNzMwNzY5MjMwNzY4LCJ5IjozMjB9XQ==" marker-end="url(#my-svg_flowchart-v2-pointEnd)"></path><path d="M458.75,161.728L441.792,166.606C424.833,171.485,390.917,181.243,373.958,189.621C357,198,357,205,357,208.5L357,212" id="L_SchemaTree_SchemaCursor_0" style=";" data-edge="true" data-et="edge" data-id="L_SchemaTree_SchemaCursor_0" data-points="W3sieCI6NDU4Ljc1LCJ5IjoxNjEuNzI3NTI0MjA0NzAyNjN9LHsieCI6MzU3LCJ5IjoxOTF9LHsieCI6MzU3LCJ5IjoyMTZ9XQ==" marker-end="url(#my-svg_flowchart-v2-pointEnd)"></path><path d="M357,270L357,274.167C357,278.333,357,286.667,347.48,294.747C337.961,302.826,318.922,310.653,309.402,314.566L299.882,318.479" id="L_SchemaCursor_Sync_0" style=";" data-edge="true" data-et="edge" data-id="L_SchemaCursor_Sync_0" data-points="W3sieCI6MzU3LCJ5IjoyNzB9LHsieCI6MzU3LCJ5IjoyOTV9LHsieCI6Mjk2LjE4MjY5MjMwNzY5MjMsInkiOjMyMH1d" marker-end="url(#my-svg_flowchart-v2-pointEnd)"></path><path d="M230.5,374L230.5,380.167C230.5,386.333,230.5,398.667,230.5,410.333C230.5,422,230.5,433,230.5,438.5L230.5,444" id="L_Sync_ValidateNode_0" style=";" data-edge="true" data-et="edge" data-id="L_Sync_ValidateNode_0" data-points="W3sieCI6MjMwLjUsInkiOjM3NH0seyJ4IjoyMzAuNSwieSI6NDExfSx7IngiOjIzMC41LCJ5Ijo0NDh9XQ==" marker-end="url(#my-svg_flowchart-v2-pointEnd)"></path><path d="M230.5,502L230.5,506.167C230.5,510.333,230.5,518.667,230.5,526.333C230.5,534,230.5,541,230.5,544.5L230.5,548" id="L_ValidateNode_Validate_0" style=";" data-edge="true" data-et="edge" data-id="L_ValidateNode_Validate_0" data-points="W3sieCI6MjMwLjUsInkiOjUwMn0seyJ4IjoyMzAuNSwieSI6NTI3fSx7IngiOjIzMC41LCJ5Ijo1NTJ9XQ==" marker-end="url(#my-svg_flowchart-v2-pointEnd)"></path><path d="M230.5,654L230.5,658.167C230.5,662.333,230.5,670.667,240.536,678.757C250.572,686.848,270.645,694.696,280.681,698.62L290.717,702.543" id="L_Validate_State_0" style=";" data-edge="true" data-et="edge" data-id="L_Validate_State_0" data-points="W3sieCI6MjMwLjUsInkiOjY1NH0seyJ4IjoyMzAuNSwieSI6Njc5fSx7IngiOjI5NC40NDIzMDc2OTIzMDc3LCJ5Ijo3MDR9XQ==" marker-end="url(#my-svg_flowchart-v2-pointEnd)"></path><path d="M316.605,758L302.421,766.167C288.237,774.333,259.868,790.667,245.684,806.333C231.5,822,231.5,837,231.5,844.5L231.5,852" id="L_State_Report_0" style=";" data-edge="true" data-et="edge" data-id="L_State_Report_0" data-points="W3sieCI6MzE2LjYwNTI2MzE1Nzg5NDc0LCJ5Ijo3NTh9LHsieCI6MjMxLjUsInkiOjgwN30seyJ4IjoyMzEuNSwieSI6ODU2fV0=" marker-end="url(#my-svg_flowchart-v2-pointEnd)"></path><path d="M269.336,856L280.78,847.833C292.224,839.667,315.112,823.333,329.084,807.632C343.056,791.931,348.112,776.861,350.64,769.327L353.168,761.792" id="L_Report_State_0" style=";" data-edge="true" data-et="edge" data-id="L_Report_State_0" data-points="W3sieCI6MjY5LjMzNTUyNjMxNTc4OTUsInkiOjg1Nn0seyJ4IjozMzgsInkiOjgwN30seyJ4IjozNTQuNDQwNzg5NDczNjg0MiwieSI6NzU4fV0=" marker-end="url(#my-svg_flowchart-v2-pointEnd)"></path><path d="M446.447,704L459.248,699.833C472.048,695.667,497.649,687.333,510.45,670.5C523.25,653.667,523.25,628.333,523.25,603C523.25,577.667,523.25,552.333,523.25,531C523.25,509.667,523.25,492.333,523.25,473C523.25,453.667,523.25,432.333,523.25,411C523.25,389.667,523.25,368.333,523.25,349C523.25,329.667,523.25,312.333,523.25,295C523.25,277.667,523.25,260.333,523.25,243C523.25,225.667,523.25,208.333,502.235,195.085C481.219,181.836,439.189,172.672,418.173,168.09L397.158,163.508" id="L_State_Read_0" style=";" data-edge="true" data-et="edge" data-id="L_State_Read_0" data-points="W3sieCI6NDQ2LjQ0NzExNTM4NDYxNTM2LCJ5Ijo3MDR9LHsieCI6NTIzLjI1LCJ5Ijo2Nzl9LHsieCI6NTIzLjI1LCJ5Ijo2MDN9LHsieCI6NTIzLjI1LCJ5Ijo1Mjd9LHsieCI6NTIzLjI1LCJ5Ijo0NzV9LHsieCI6NTIzLjI1LCJ5Ijo0MTF9LHsieCI6NTIzLjI1LCJ5IjozNDd9LHsieCI6NTIzLjI1LCJ5IjoyOTV9LHsieCI6NTIzLjI1LCJ5IjoyNDN9LHsieCI6NTIzLjI1LCJ5IjoxOTF9LHsieCI6MzkzLjI1LCJ5IjoxNjIuNjU2MTg0NDg2MzczMTh9XQ==" marker-end="url(#my-svg_flowchart-v2-pointEnd)"></path><path d="M427.803,758L447.252,766.167C466.702,774.333,505.601,790.667,525.05,806.333C544.5,822,544.5,837,544.5,844.5L544.5,852" id="L_State_done_0" style=";" data-edge="true" data-et="edge" data-id="L_State_done_0" data-points="W3sieCI6NDI3LjgwMjYzMTU3ODk0NzQsInkiOjc1OH0seyJ4Ijo1NDQuNSwieSI6ODA3fSx7IngiOjU0NC41LCJ5Ijo4NTZ9XQ==" marker-end="url(#my-svg_flowchart-v2-pointEnd)"></path></g><g><g><g data-id="L_User_Read_0" transform="translate(0, 0)"><foreignObject width="0" height="0"></foreignObject></g></g><g><g data-id="L_User_SchemaTree_0" transform="translate(0, 0)"><foreignObject width="0" height="0"></foreignObject></g></g><g><g data-id="L_Read_InputCursor_0" transform="translate(0, 0)"><foreignObject width="0" height="0"></foreignObject></g></g><g><g data-id="L_InputCursor_Sync_0" transform="translate(0, 0)"><foreignObject width="0" height="0"></foreignObject></g></g><g><g data-id="L_SchemaTree_SchemaCursor_0" transform="translate(0, 0)"><foreignObject width="0" height="0"></foreignObject></g></g><g><g data-id="L_SchemaCursor_Sync_0" transform="translate(0, 0)"><foreignObject width="0" height="0"></foreignObject></g></g><g><g data-id="L_Sync_ValidateNode_0" transform="translate(0, 0)"><foreignObject width="0" height="0"></foreignObject></g></g><g><g data-id="L_ValidateNode_Validate_0" transform="translate(0, 0)"><foreignObject width="0" height="0"></foreignObject></g></g><g><g data-id="L_Validate_State_0" transform="translate(0, 0)"><foreignObject width="0" height="0"></foreignObject></g></g><g><g data-id="L_State_Report_0" transform="translate(0, 0)"><foreignObject width="0" height="0"></foreignObject></g></g><g transform="translate(324.70319, 816.48881)"><g data-id="L_Report_State_0" transform="translate(-86.5, -12)"><foreignObject width="173" height="24"><p><span><p>new Validation Result</p></span></p></foreignObject></g></g><g transform="translate(523.25, 411)"><g data-id="L_State_Read_0" transform="translate(-76.75, -12)"><foreignObject width="153.5" height="24"><p><span><p>wait for more input</p></span></p></foreignObject></g></g><g transform="translate(544.5, 807)"><g data-id="L_State_done_0" transform="translate(-100, -24)"><foreignObject width="200" height="48"><p><span><p>we were told this read was at EOF</p></span></p></foreignObject></g></g></g><g><g id="flowchart-User-0" transform="translate(284.75, 35)"><rect style="" x="-47.5" y="-27" width="95" height="54"></rect><g style="" transform="translate(-17.5, -12)"><rect></rect><foreignObject width="35" height="24"><p><span><p>user</p></span></p></foreignObject></g></g><g id="flowchart-Read-1" transform="translate(284.75, 139)"><rect style="" x="-108.5" y="-27" width="217" height="54"></rect><g style="" transform="translate(-78.5, -12)"><rect></rect><foreignObject width="157" height="24"><p><span><p>read_input(got_eof)</p></span></p></foreignObject></g></g><g id="flowchart-Validate-2" transform="translate(230.5, 603)"><rect style="" x="-130" y="-51" width="260" height="102"></rect><g style="" transform="translate(-100, -36)"><rect></rect><foreignObject width="200" height="72"><p><span><p>many recursive calls until we reach the end of the tree</p></span></p></foreignObject></g></g><g id="flowchart-State-3" transform="translate(363.5, 731)"><rect style="" x="-108" y="-27" width="216" height="54"></rect><g style="" transform="translate(-78, -12)"><rect></rect><foreignObject width="156" height="24"><p><span><p>new validator state</p></span></p></foreignObject></g></g><g id="flowchart-Report-4" transform="translate(231.5, 883)"><rect style="" x="-96" y="-27" width="192" height="54"></rect><g style="" transform="translate(-66, -12)"><rect></rect><foreignObject width="132" height="24"><p><span><p>errors / matches</p></span></p></foreignObject></g></g><g id="flowchart-InputCursor-5" transform="translate(104, 243)"><rect style="" x="-96" y="-27" width="192" height="54"></rect><g style="" transform="translate(-66, -12)"><rect></rect><foreignObject width="132" height="24"><p><span><p>input TreeCursor</p></span></p></foreignObject></g></g><g id="flowchart-SchemaCursor-6" transform="translate(357, 243)"><rect style="" x="-107" y="-27" width="214" height="54"></rect><g style="" transform="translate(-77, -12)"><rect></rect><foreignObject width="154" height="24"><p><span><p>schema TreeCursor</p></span></p></foreignObject></g></g><g id="flowchart-Sync-7" transform="translate(230.5, 347)"><rect style="" x="-126.75" y="-27" width="253.5" height="54"></rect><g style="" transform="translate(-96.75, -12)"><rect></rect><foreignObject width="193.5" height="24"><p><span><p>align cursors to position</p></span></p></foreignObject></g></g><g id="flowchart-ValidateNode-8" transform="translate(230.5, 475)"><rect style="" x="-155.5" y="-27" width="311" height="54"></rect><g style="" transform="translate(-125.5, -12)"><rect></rect><foreignObject width="251" height="24"><p><span><p>NodeVsNodeValidator::validate</p></span></p></foreignObject></g></g><g id="flowchart-SchemaTree-12" transform="translate(537.75, 139)"><rect style="" x="-79" y="-27" width="158" height="54"></rect><g style="" transform="translate(-49, -12)"><rect></rect><foreignObject width="98" height="24"><p><span><p>SchemaTree</p></span></p></foreignObject></g></g><g id="flowchart-done-34" transform="translate(544.5, 883)"><rect style="" x="-50" y="-27" width="100" height="54"></rect><g style="" transform="translate(-20, -12)"><rect></rect><foreignObject width="40" height="24"><p><span><p>done</p></span></p></foreignObject></g></g></g></g></g></svg></div> </div>  <p>Starting with some initial schema and input <em>fragment</em>, we align the cursors to
where we last left off (stored in the validatorâ€™s internal state), validate as
far as we can, and, if we got the EOF signal, report the errors and matches
weâ€™ve found so far, or otherwise update our farthest reached position and wait
for more input. The new validation result is fed back into the validator state for the next cycle.</p></div></div>
<p>Now you have a high level idea of how it works!</p>

<p>Thereâ€™s a lot more to come!</p>
<p>First, thereâ€™s just so much surface area. Itâ€™s kinda insane. So I need to
finish polishing super specific things like streaming input support for tables
with repeating matchers and writing oh so many more tests.</p>
<p>but then the fun roadmap: one of the things iâ€™m most excited about is
generating <strong>json schemas</strong> from â€œmdschemaâ€s, so that you can integrate
<code>mdvalidate</code> with your favorite existing tools.</p>
<p>This means going from something like:</p>
<pre tabindex="0" data-language="md"><code><span><span># Hi </span><span>`name:/[A-Z][a-z]+/`</span></span></code></pre>
<p>to</p>
<pre tabindex="0" data-language="json"><code><span><span>{</span></span>
<span><span>  &#34;$schema&#34;</span><span>: </span><span>&#34;http://json-schema.org/draft-07/schema#&#34;</span><span>,</span></span>
<span><span>  &#34;type&#34;</span><span>: </span><span>&#34;object&#34;</span><span>,</span></span>
<span><span>  &#34;properties&#34;</span><span>: {</span></span>
<span><span>    &#34;name&#34;</span><span>: {</span></span>
<span><span>      &#34;type&#34;</span><span>: </span><span>&#34;string&#34;</span><span>,</span></span>
<span><span>      &#34;pattern&#34;</span><span>: </span><span>&#34;^[A-Z][a-z]+$&#34;</span></span>
<span><span>    }</span></span>
<span><span>  },</span></span>
<span><span>  &#34;required&#34;</span><span>: [</span><span>&#34;name&#34;</span><span>]</span></span>
<span><span>}</span></span></code></pre>
<p>This would let you â€œcompileâ€ your schemas into types that you can use in your
languages to safely validate Markdown schemas into langauge-safe constructs.</p>
<p>I also really want to package <code>mdvalidate</code> into <strong>a language server!</strong> Iâ€™d
really like to be able to edit markdown files and get live validation. Red
squiggles, suggested fixes, etc.</p>
<p>One limitation here for implementing this is that validation assumes that the
input is streamed. With a language server, edits can occur anywhere in the
document, and right now we would need to walk the trees all the way down from
the location of edit to revalidate. But this is probably still relatively fast.</p>
<p>And, in general, more <strong>LLM tinkering</strong>: thereâ€™s a few LLM related things Iâ€™d
like to explore.</p>
<p>Iâ€™d like to <a href="https://platform.openai.com/docs/guides/supervised-fine-tuning">fine tune a
model</a> to
understand MDS natively, and tinkering more with the AI use case. And Iâ€™d like
to try to quantify how much more token efficient Markdown is compared to JSON
schema, and how much better the quality of structured output responses are when
you use Markdown</p>
<p>Implementation wise, one of the annoyances of using Treesitter in Rust has been
that all of the node types are basically just raw, untyped strings. When
working on <code>mdvalidate</code> I came across <a href="https://docs.rs/type-sitter/latest/type_sitter/">a project called
â€œtypesitterâ€</a>, which can
automatically generate types for all of the different Treesitter nodes, which I
would love to eventually transition to.</p>

<p>Okay, now enough about how it works and why I made it.</p>
<p>You can find the repo <strong><a href="https://github.com/404wolf/mdvalidate">here</a></strong> or the docs
<strong><a href="https://404wolf.github.io/mdvalidate/">here</a></strong>!</p>
<p>But definitely note that itâ€™s all a half baked proof of concept. Thereâ€™s a lot
left to do, and a lot of bugs!</p>
<p>If youâ€™re excited about this idea, or have cool use cases, Iâ€™d love to hear!
<a href="mailto:wolf@404wolf.com">Email me</a>!</p>

<p>Shout out to my friend <a href="https://github.com/AlessandroMason">Alessandro</a> for
help pairing on some of the initial development of <code>mdvalidate</code>!</p> </div></div>
  </body>
</html>
