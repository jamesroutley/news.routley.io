<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://paulbutler.org/2025/smuggling-arbitrary-data-through-an-emoji/">Original</a>
    <h1>Smuggling arbitrary data through an emoji</h1>
    
    <div id="readability-page-1" class="page"><div><p>This Hacker News <a href="https://news.ycombinator.com/item?id=42823876">comment by GuB-42</a> intrigued me:</p>
<blockquote>
<p>With ZWJ (Zero Width Joiner) sequences you could in theory encode an unlimited amount of data in a single emoji.</p>
</blockquote>
<p>Is it really possible to encode arbitrary data in a single emoji?</p>
<p><strong>tl;dr:</strong> yes, although I found an approach without ZWJ. In fact, you can encode data in <em>any</em> unicode character. This sentence has a hidden message󠅟󠅘󠄐󠅝󠅩󠄜󠄐󠅩󠅟󠅥󠄐󠅖󠅟󠅥󠅞󠅔󠄐󠅤󠅘󠅕󠄐󠅘󠅙󠅔󠅔󠅕󠅞󠄐󠅝󠅕󠅣󠅣󠅑󠅗󠅕󠄐󠅙󠅞󠄐󠅤󠅘󠅕󠄐󠅤󠅕󠅨󠅤󠄑. (Try pasting it into <a href="https://emoji.paulbutler.org/?mode=decode">this decoder</a>)</p>
<video autoplay="" loop="" muted="" playsinline="" width="100%">
  <source src="screencap.webm" type="video/webm"/>
  Your browser does not support the video tag.
</video>
<h2 id="some-background">Some background</h2>
<p>Unicode represents text as a sequence of <em>codepoints</em>, each of which is basically just a number that the Unicode Consortium has assigned meaning to.
Usually, a specific codepoint is written as <code>U+XXXX</code>, where <code>XXXX</code> is a number represented as uppercase hexadecimal.</p>
<p>For simple latin-alphabet text, there is a one-to-one mapping between Unicode codepoints and characters that appear on-screen. For example,
<code>U+0067</code> represents the character <code>g</code>.</p>
<p>For other writing systems, some on-screen characters may be represented by multiple codepoints. The character की
(in <a href="https://en.wikipedia.org/wiki/Devanagari">Devanagari script</a>) is represented by a consecutive pairing of the codepoints <code>U+0915</code> and <code>U+0940</code>.</p>
<h2 id="variation-selectors">Variation selectors</h2>
<p>Unicode designates 256 codepoints as “variation selectors”, named VS-1 to VS-256. These have no on-screen representation of their own, but are used to modify
the presentation of the preceeding character.</p>
<p>Most unicode characters do not have variations associated with them. Since unicode is an evolving standard and aims to be future-compatible,
variation selectors are supposed to be preserved during transformations, even if their meaning is not known by the code handling them.
So the codepoint <code>U+0067</code> (“g”) followed by <code>U+FE01</code> (VS-2) renders as a lowercase “g”, exactly the same as <code>U+0067</code> alone. But if you copy and paste it, the
variation selector will tag along with it.</p>
<p>Since 256 is exactly enough variations to represent a single byte, this gives us a way to “hide” one byte of data in any other unicode codepoint.</p>
<p>As it turns out, the <a href="https://www.unicode.org/versions/Unicode16.0.0/">Unicode spec</a> does not specifically say anything about sequences
of multiple variation selectors, except to imply that they should be ignored during rendering.</p>
<p><em>See where I’m going with this?</em></p>
<p>We can concatenate a sequence of variation selectors together to represent any arbitrary byte string.</p>
<p>For example, let’s say we want to encode the data <code>[0x68, 0x65, 0x6c, 0x6c, 0x6f]</code>, which represents the text “hello”. We can do this by
converting each byte into a corresponding variation selector, and then concatenating them together.</p>
<p>The variation selectors are broken into two ranges of codepoints: the original set of 16 at
<a href="https://unicode.org/charts/nameslist/n_FE00.html"><code>U+FE00 .. U+FE0F</code></a>, and remaining 240 at <a href="https://unicode.org/charts/nameslist/n_E0100.html"><code>U+E0100 .. U+E01EF</code></a> (ranges inclusive).</p>
<p>To convert from a byte to a variation selector, we can do something like this Rust code:</p>
<div><pre tabindex="0"><code data-lang="rust"><span>fn</span> <span>byte_to_variation_selector</span>(byte: <span>u8</span>) -&gt; <span>char</span> {
    <span>if</span> byte <span>&lt;</span> <span>16</span> {
        char::from_u32(<span>0xFE00</span> <span>+</span> byte <span>as</span> <span>u32</span>).unwrap()
    } <span>else</span> {
        char::from_u32(<span>0xE0100</span> <span>+</span> (byte <span>-</span> <span>16</span>) <span>as</span> <span>u32</span>).unwrap()
    }
}
</code></pre></div><p>To encode a series of bytes, we can concatenate a number of these variation selectors after a base character.</p>
<div><pre tabindex="0"><code data-lang="rust"><span>fn</span> <span>encode</span>(base: <span>char</span>, bytes: <span>&amp;</span>[<span>u8</span>]) -&gt; String {
    <span>let</span> <span>mut</span> result <span>=</span> String::new();
    result.push(base);
    <span>for</span> byte <span>in</span> bytes {
        result.push(byte_to_variation_selector(<span>*</span>byte));
    }
    result
}
</code></pre></div><p>Then to encode the bytes <code>[0x68, 0x65, 0x6c, 0x6c, 0x6f]</code>, we can run:</p>
<div><pre tabindex="0"><code data-lang="rust"><span>fn</span> <span>main</span>() {
    println<span>!</span>(<span>&#34;{}&#34;</span>, encode(<span>&#39;😊&#39;</span>, <span>&amp;</span>[<span>0x68</span>, <span>0x65</span>, <span>0x6c</span>, <span>0x6c</span>, <span>0x6f</span>]));
}
</code></pre></div><p>Which outputs</p>
<pre><code>😊󠅘󠅕󠅜󠅜󠅟
</code></pre><p>It just looks like a regular emoji, but try pasting it into <a href="https://emoji.paulbutler.org/?mode=decode">the decoder</a>.</p>
<p>If we instead use the debug formatter, we see what’s going on:</p>
<div><pre tabindex="0"><code data-lang="rust"><span>fn</span> <span>main</span>() {
    println<span>!</span>(<span>&#34;{:?}&#34;</span>, encode(<span>&#39;😊&#39;</span>, <span>&amp;</span>[<span>0x68</span>, <span>0x65</span>, <span>0x6c</span>, <span>0x6c</span>, <span>0x6f</span>]));
}
</code></pre></div><p>This prints:</p>
<pre><code>&#34;😊\u{e0158}\u{e0155}\u{e015c}\u{e015c}\u{e015f}&#34;
</code></pre><p>This reveals the characters that were “hidden” in the original output.</p>
<h2 id="decoding">Decoding</h2>
<p>Decoding is similarly straightforward.</p>
<div><pre tabindex="0"><code data-lang="rust"><span>fn</span> <span>variation_selector_to_byte</span>(variation_selector: <span>char</span>) -&gt; Option<span>&lt;</span><span>u8</span><span>&gt;</span> {
    <span>let</span> variation_selector <span>=</span> variation_selector <span>as</span> <span>u32</span>;
    <span>if</span> (<span>0xFE00</span>..<span>=</span><span>0xFE0F</span>).contains(<span>&amp;</span>variation_selector) {
        Some((variation_selector <span>-</span> <span>0xFE00</span>) <span>as</span> <span>u8</span>)
    } <span>else</span> <span>if</span> (<span>0xE0100</span>..<span>=</span><span>0xE01EF</span>).contains(<span>&amp;</span>variation_selector) {
        Some((variation_selector <span>-</span> <span>0xE0100</span> <span>+</span> <span>16</span>) <span>as</span> <span>u8</span>)
    } <span>else</span> {
        None
    }
}

<span>fn</span> <span>decode</span>(variation_selectors: <span>&amp;</span><span>str</span>) -&gt; Vec<span>&lt;</span><span>u8</span><span>&gt;</span> {
    <span>let</span> <span>mut</span> result <span>=</span> Vec::new();
    
    <span>for</span> variation_selector <span>in</span> variation_selectors.chars() {
        <span>if</span> <span>let</span> Some(byte) <span>=</span> variation_selector_to_byte(variation_selector) {
            result.push(byte);
        } <span>else</span> <span>if</span> <span>!</span>result.is_empty() {
            <span>return</span> result;
        }
        <span>// note: we ignore non-variation selectors until we have
</span><span></span>        <span>// encountered the first one, as a way of skipping the &#34;base
</span><span></span>        <span>// character&#34;.
</span><span></span>    }

    result
}
</code></pre></div><p>To use it:</p>
<div><pre tabindex="0"><code data-lang="rust"><span>use</span> std::<span>str</span>::from_utf8;

<span>fn</span> <span>main</span>() {
    <span>let</span> result <span>=</span> encode(<span>&#39;😊&#39;</span>, <span>&amp;</span>[<span>0x68</span>, <span>0x65</span>, <span>0x6c</span>, <span>0x6c</span>, <span>0x6f</span>]);
    println<span>!</span>(<span>&#34;{:?}&#34;</span>, from_utf8(<span>&amp;</span>decode(<span>&amp;</span>result)).unwrap()); <span>// &#34;hello&#34;
</span><span></span>}
</code></pre></div><p>Note that the base character does not need to be an emoji – the treatment of variation selectors is the same
with regular characters. It’s just more fun with emoji.</p>
<h2 id="can-this-be-abused">Can this be abused?</h2>
<p>To be clear, this is an abuse of unicode and you shouldn’t do it. If your mind is wandering to practical use cases for this, shut it down.</p>
<p>That said, I can think of a couple of nefarious ways this could be (ab)used:</p>
<h3 id="1-sneaking-data-past-human-content-filters">1. Sneaking data past human content filters</h3>
<p>Since data encoded this way are invisible once rendered, a human moderator or reviewer will not know they are there.</p>
<h3 id="2-watermarking-text">2. Watermarking text</h3>
<p>There are techniques for using subtle variations in text to “watermark” a message, so that if it is sent to a number of people and then
leaked, it’s possible to trace it to the original recipient. Variation selector sequences are a way to do this that survives most copy/pastes
and allows arbitrary data density. You could go so far as to watermark <em>every single character</em> if you wanted to.</p>
</div></div>
  </body>
</html>
