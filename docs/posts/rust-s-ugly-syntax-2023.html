<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matklad.github.io/2023/01/26/rusts-ugly-syntax.html">Original</a>
    <h1>Rust&#39;s Ugly Syntax (2023)</h1>
    
    <div id="readability-page-1" class="page"><div>
  <article>


<p><span>People complain about Rust syntax.</span>
<span>I think that most of the time when people think they have an issue with Rust</span>’<span>s syntax, they actually object to Rust</span>’<span>s semantics.</span>
<span>In this slightly whimsical post, I</span>’<span>ll try to disentangle the two.</span></p>
<p><span>Let</span>’<span>s start with an example of an ugly Rust syntax:</span></p>

<figure>


<pre><code><span><span>pub</span> <span>fn</span> <span>read</span>&lt;P: <span>AsRef</span>&lt;Path&gt;&gt;(path: P) <span>-&gt;</span> io::<span>Result</span>&lt;<span>Vec</span>&lt;<span>u8</span>&gt;&gt; {</span>
<span>  <span>fn</span> <span>inner</span>(path: &amp;Path) <span>-&gt;</span> io::<span>Result</span>&lt;<span>Vec</span>&lt;<span>u8</span>&gt;&gt; {</span>
<span>    <span>let</span> <span>mut </span><span>file</span> = File::<span>open</span>(path)?;</span>
<span>    <span>let</span> <span>mut </span><span>bytes</span> = <span>Vec</span>::<span>new</span>();</span>
<span>    file.<span>read_to_end</span>(&amp;<span>mut</span> bytes)?;</span>
<span>    <span>Ok</span>(bytes)</span>
<span>  }</span>
<span>  <span>inner</span>(path.<span>as_ref</span>())</span>
<span>}</span></code></pre>

</figure>
<p><span>This function reads contents of a given binary file.</span>
<span>This is lifted straight from the standard library, so it is very much not a strawman example.</span>
<span>And, at least to me, it</span>’<span>s definitely not a pretty one!</span></p>
<p><span>Let</span>’<span>s try to imagine what this same function would look like if Rust had a better syntax.</span>
<span>Any resemblance to real programming languages, living or dead, is purely coincidental!</span></p>
<p><span>Let</span>’<span>s start with Rs++:</span></p>

<figure>


<pre><code><span><span>template</span>&lt;std::HasConstReference&lt;std::Path&gt; P&gt;</span>
<span>std::io::outcome&lt;std::vector&lt;<span>uint8_t</span>&gt;&gt;</span>
<span>std::<span>read</span>(P path) {</span>
<span>    <span>return</span> <span>read_</span>(path.<span>as_reference</span>());</span>
<span>}</span>
<span></span>
<span><span>static</span></span>
<span>std::io::outcome&lt;std::vector&lt;<span>uint8_t</span>&gt;&gt;</span>
<span><span>read_</span>(&amp;<span>auto</span> <span>const</span> std::Path path) {</span>
<span>    <span>auto</span> file = <span>try</span> std::File::<span>open</span>(path);</span>
<span>    std::vector bytes;</span>
<span>    <span>try</span> file.<span>read_to_end</span>(&amp;bytes);</span>
<span>    <span>return</span> <span>okey</span>(bytes);</span>
<span>}</span></code></pre>

</figure>
<p><span>A Rhodes variant:</span></p>

<figure>


<pre><code><span><span>public</span> io.Result&lt;ArrayList&lt;Byte&gt;&gt; read&lt;P <span>extends</span> <span>ReferencingFinal</span>&lt;Path&gt;&gt;(</span>
<span>        P path) {</span>
<span>    <span>return</span> myRead(path.get_final_reference());</span>
<span>}</span>
<span></span>
<span><span>private</span> io.Result&lt;ArrayList&lt;Byte&gt;&gt; <span>myRead</span><span>(</span></span>
<span><span>        <span>final</span> reference lifetime <span>var</span> Path path)</span> {</span>
<span>    <span>var</span> <span>file</span> <span>=</span> <span>try</span> File.open(path);</span>
<span>    ArrayList&lt;Byte&gt; bytes = ArrayList.new();</span>
<span>    <span>try</span> file.readToEnd(borrow bytes);</span>
<span>    <span>return</span> Success(bytes);</span>
<span>}</span></code></pre>

</figure>
<p><span>Typical RhodesScript:</span></p>

<figure>


<pre><code><span>public <span>function</span> read&lt;P <span>extends</span> <span>IncludingRef</span>&lt;<span>Path</span>&gt;&gt;(</span>
<span>    <span>path</span>: P,</span>
<span>): io.<span>Result</span>&lt;<span>Array</span>&lt;byte&gt;&gt; {</span>
<span>    <span>return</span> <span>myRead</span>(path.<span>included_ref</span>());</span>
<span>}</span>
<span></span>
<span>private <span>function</span> <span>myRead</span>(<span></span></span>
<span><span>    path: &amp;<span>const</span> Path,</span></span>
<span><span></span>): io.<span>Result</span>&lt;<span>Array</span>&lt;byte&gt;&gt; {</span>
<span>    <span>let</span> file = <span>try</span> <span>File</span>.<span>open</span>(path);</span>
<span>    <span>Array</span>&lt;byte&gt; bytes = <span>Array</span>.<span>new</span>()</span>
<span>    <span>try</span> file.<span>readToEnd</span>(&amp;bytes)</span>
<span>    <span>return</span> <span>Ok</span>(bytes);</span>
<span>}</span></code></pre>

</figure>
<p><span>Rattlesnake:</span></p>

<figure>


<pre><code><span><span>def</span> <span>read</span>[P: Refing[Path]](path: P): io.Result[<span>List</span>[byte]]:</span>
<span>    <span>def</span> <span>inner</span>(<span>path: @Path</span>): io.Result[<span>List</span>[byte]]:</span>
<span>        file := <span>try</span> File.<span>open</span>(path)</span>
<span>        <span>bytes</span> := <span>List</span>.new()</span>
<span>        <span>try</span> file.read_to_end(@: <span>bytes</span>)</span>
<span>        <span>return</span> Ok(<span>bytes</span>)</span>
<span>    <span>return</span> inner(path.ref)</span></code></pre>

</figure>
<p><span>And, to conclude, CrabML:</span></p>

<figure>


<pre><code><span>read :: &#39;p  ref_of =&gt; &#39;p -&gt; u8 vec io.either.t</span>
<span>let read p =</span>
<span>  let</span>
<span>    inner :: &amp;path -&gt; u8 vec.t io.either.t</span>
<span>    inner p =</span>
<span>      let mut file = try (File.open p) in</span>
<span>      let mut bytes = vec.new () in</span>
<span>      try (file.read_to_end (&amp;mut bytes)); Right bytes</span>
<span>  in</span>
<span>    ref_op p |&gt; inner</span>
<span>;;</span></code></pre>

</figure>
<p><span>As a slightly more serious and useful exercise, let</span>’<span>s do the opposite </span>—<span> keep the Rust syntax, but try to simplify semantics until the end result looks presentable.</span></p>
<p><span>Here</span>’<span>s our starting point:</span></p>

<figure>


<pre><code><span><span>pub</span> <span>fn</span> <span>read</span>&lt;P: <span>AsRef</span>&lt;Path&gt;&gt;(path: P) <span>-&gt;</span> io::<span>Result</span>&lt;<span>Vec</span>&lt;<span>u8</span>&gt;&gt; {</span>
<span>  <span>fn</span> <span>inner</span>(path: &amp;Path) <span>-&gt;</span> io::<span>Result</span>&lt;<span>Vec</span>&lt;<span>u8</span>&gt;&gt; {</span>
<span>    <span>let</span> <span>mut </span><span>file</span> = File::<span>open</span>(path)?;</span>
<span>    <span>let</span> <span>mut </span><span>bytes</span> = <span>Vec</span>::<span>new</span>();</span>
<span>    file.<span>read_to_end</span>(&amp;<span>mut</span> bytes)?;</span>
<span>    <span>Ok</span>(bytes)</span>
<span>  }</span>
<span>  <span>inner</span>(path.<span>as_ref</span>())</span>
<span>}</span></code></pre>

</figure>
<p><span>The biggest source of noise here is the nested function.</span>
<span>The motivation for it is somewhat esoteric.</span>
<span>The outer function is generic, while the inner function isn</span>’<span>t.</span>
<span>With the current compilation model, that means that the outer function is compiled together with the user</span>’<span>s code, gets inlined and is optimized down to nothing.</span>
<span>In contrast, the inner function is compiled when the std itself is being compiled, saving time when compiling user</span>’<span>s code.</span>
<span>One way to simplify this (losing a bit of performance) is to say that generic functions are always separately compiled, but accept an extra runtime argument under the hood which describes the physical dimension of input parameters.</span></p>
<p><span>With that, we get</span></p>

<figure>


<pre><code><span><span>pub</span> <span>fn</span> <span>read</span>&lt;P: <span>AsRef</span>&lt;Path&gt;&gt;(path: P) <span>-&gt;</span> io::<span>Result</span>&lt;<span>Vec</span>&lt;<span>u8</span>&gt;&gt; {</span>
<span>  <span>let</span> <span>mut </span><span>file</span> = File::<span>open</span>(path.<span>as_ref</span>())?;</span>
<span>  <span>let</span> <span>mut </span><span>bytes</span> = <span>Vec</span>::<span>new</span>();</span>
<span>  file.<span>read_to_end</span>(&amp;<span>mut</span> bytes)?;</span>
<span>  <span>Ok</span>(bytes)</span>
<span>}</span></code></pre>

</figure>
<p><span>The next noisy element is the </span><code>&lt;P: AsRef&lt;Path&gt;&gt;</code><span> constraint.</span>
<span>It is needed because Rust loves exposing physical layout of bytes in memory as an interface, specifically for cases where that brings performance.</span>
<span>In particular, the meaning of </span><code>Path</code><span> is not that it is some abstract representation of a file path, but that it is just literally a bunch of contiguous bytes in memory.</span>
<span>So we need </span><code>AsRef</code><span> to make this work with </span><em><span>any</span></em><span> abstraction which is capable of representing such a slice of bytes.</span>
<span>But if we don</span>’<span>t care about performance, we can require that all interfaces are fairly abstract and mediated via virtual function calls, rather than direct memory access.</span>
<span>Then we won</span>’<span>t need </span><code>AsRef</code><span>at all:</span></p>

<figure>


<pre><code><span><span>pub</span> <span>fn</span> <span>read</span>(path: &amp;Path) <span>-&gt;</span> io::<span>Result</span>&lt;<span>Vec</span>&lt;<span>u8</span>&gt;&gt; {</span>
<span>  <span>let</span> <span>mut </span><span>file</span> = File::<span>open</span>(path)?;</span>
<span>  <span>let</span> <span>mut </span><span>bytes</span> = <span>Vec</span>::<span>new</span>();</span>
<span>  file.<span>read_to_end</span>(&amp;<span>mut</span> bytes)?;</span>
<span>  <span>Ok</span>(bytes)</span>
<span>}</span></code></pre>

</figure>
<p><span>Having done this, we can actually get rid of </span><code>Vec&lt;u8&gt;</code><span> as well </span>—<span> we can no longer use generics to express efficient growable array of bytes in the language itself.</span>
<span>We</span>’<span>d have to use some opaque </span><code>Bytes</code><span> type provided by the runtime:</span></p>

<figure>


<pre><code><span><span>pub</span> <span>fn</span> <span>read</span>(path: &amp;Path) <span>-&gt;</span> io::<span>Result</span>&lt;Bytes&gt; {</span>
<span>  <span>let</span> <span>mut </span><span>file</span> = File::<span>open</span>(path)?;</span>
<span>  <span>let</span> <span>mut </span><span>bytes</span> = Bytes::<span>new</span>();</span>
<span>  file.<span>read_to_end</span>(&amp;<span>mut</span> bytes)?;</span>
<span>  <span>Ok</span>(bytes)</span>
<span>}</span></code></pre>

</figure>
<p><span>Technically, we are still carrying ownership and borrowing system with us, but, without direct control over memory layout of types, it no longer brings massive performance benefits.</span>
<span>It still helps to avoid GC, prevent iterator invalidation, and statically check that non-thread-safe code isn</span>’<span>t actually used across threads.</span>
<span>Still, we can easily get rid of those &amp;-pretzels if we just switch to GC.</span>
<span>We don</span>’<span>t even need to worry about concurrency much </span>—<span> as our objects are separately allocated and always behind a pointer, we can hand-wave data races away by noticing that operations with pointer-sized things are atomic on x86 anyway.</span></p>

<figure>


<pre><code><span><span>pub</span> <span>fn</span> <span>read</span>(path: Path) <span>-&gt;</span> io::<span>Result</span>&lt;Bytes&gt; {</span>
<span>  <span>let</span> <span>file</span> = File::<span>open</span>(path)?;</span>
<span>  <span>let</span> <span>bytes</span> = Bytes::<span>new</span>();</span>
<span>  file.<span>read_to_end</span>(bytes)?;</span>
<span>  <span>Ok</span>(bytes)</span>
<span>}</span></code></pre>

</figure>
<p><span>Finally, we are being overly pedantic with error handling here </span>—<span> not only we mention a possibility of failure in the return type, we even use </span><code>?</code><span> to highlight any specific expression that might fail.</span>
<span>It would be much simpler to not think about error handling at all, and let some top-level</span></p>

<figure>


<pre><code><span><span>pub</span> <span>fn</span> <span>read</span>(path: Path) <span>-&gt;</span> Bytes {</span>
<span>  <span>let</span> <span>file</span> = File::<span>open</span>(path);</span>
<span>  <span>let</span> <span>bytes</span> = Bytes::<span>new</span>();</span>
<span>  file.<span>read_to_end</span>(bytes);</span>
<span>  bytes</span>
<span>}</span></code></pre>

</figure>
<p><strong><strong><span>Much</span></strong></strong><span> better now!</span></p>
</article>
  </div></div>
  </body>
</html>
