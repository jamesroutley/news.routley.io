<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://engineering.fb.com/2023/10/24/data-infrastructure/automating-dead-code-cleanup/">Original</a>
    <h1>Automating Dead Code Cleanup</h1>
    
    <div id="readability-page-1" class="page"><div>

		<ul>
<li aria-level="1"><span>Meta’s Systematic Code and Asset Removal Framework (SCARF) has a subsystem for identifying and removing dead code.</span></li>
<li aria-level="1"><span>SCARF combines static and dynamic analysis of programs to detect dead code from both a business and programming language perspective.</span></li>
<li aria-level="1"><span>SCARF automatically creates change requests that delete the dead code identified from the program analysis, minimizing developer costs.</span></li>
</ul>
<p><span>In our last blog post on </span><a href="https://engineering.fb.com/2023/10/17/data-infrastructure/automating-product-deprecation-meta/"><span>automatic product deprecation</span></a><span>, we talked about the complexities of product deprecations, and a solution Meta has built called the Systematic Code and Asset Removal Framework (SCARF). As an example, we looked at </span><a href="https://about.fb.com/news/2015/06/introducing-moments/"><span>Moments</span></a><span>, the photo sharing app Meta launched in 2015 and eventually shut down in 2019, and how SCARF can help with the deprecation process through its workflow management capabilities. We discussed how SCARF saves engineering time by identifying the correct order of tasks for cleaning up a product and how it can be blocked from automating the cleanup when there are intersystem dependencies. This naturally leads to the question: How do we automatically unblock SCARF when there is code that references an asset?</span></p>
<h2><span>Dead code removal in SCARF</span></h2>
<p><span>SCARF contains a subsystem that automatically identifies dead code through a combination of static, runtime, and application analysis. It leverages this analysis to submit change requests to remove this code from our systems. This automated dead code removal improves the quality of our systems and also unblocks unused data removal in SCARF when the dead code includes references to data assets that prevent automated data cleanup. </span></p>
<h2><span>Code analysis</span></h2>
<p><span>SCARF’s code analysis subsystem gathers information from a variety of sources. First, a code dependency graph for each language is extracted from our compilers via </span><a href="https://glean.software/"><span>Glean</span></a><span>. This is then augmented with further information, like the usage of API endpoints from operational logs that determine whether an endpoint is used at runtime. Additional examples of domain-specific usage encoded include: </span></p>
<ul>
<li aria-level="1"><span>Script invocations for internal developer tools and system management commands.</span></li>
<li aria-level="1"><span>Template hooks for dynamically rendering pages in the </span><a href="https://instagram-engineering.com/web-service-efficiency-at-instagram-with-python-4976d078e366"><span>Instagram Django backend and URI handler and routing</span></a><span>.</span></li>
<li aria-level="1"><span>Async’s dynamically referenced dispatch methods (</span><a href="https://engineering.fb.com/2020/08/17/production-engineering/async/"><span>Meta’s deferred job execution service</span></a><span>).</span></li>
</ul>
<p><span>SCARF must be capable of introspecting any and all types of dynamic usage in addition to the static dependency graph to make accurate determinations of whether a piece of code is truly safe to remove. These are combined and form an augmented dependency graph.</span></p>
<p><img decoding="async" fetchpriority="high" src="https://engineering.fb.com/wp-content/uploads/2023/10/Automating-Dead-Code-Cleanup-image1.png?w=1024" alt="" width="1024" height="532" srcset="https://engineering.fb.com/wp-content/uploads/2023/10/Automating-Dead-Code-Cleanup-image1.png 1536w, https://engineering.fb.com/wp-content/uploads/2023/10/Automating-Dead-Code-Cleanup-image1.png?resize=916,476 916w, https://engineering.fb.com/wp-content/uploads/2023/10/Automating-Dead-Code-Cleanup-image1.png?resize=768,399 768w, https://engineering.fb.com/wp-content/uploads/2023/10/Automating-Dead-Code-Cleanup-image1.png?resize=1024,532 1024w, https://engineering.fb.com/wp-content/uploads/2023/10/Automating-Dead-Code-Cleanup-image1.png?resize=96,50 96w, https://engineering.fb.com/wp-content/uploads/2023/10/Automating-Dead-Code-Cleanup-image1.png?resize=192,100 192w" sizes="(max-width: 992px) 100vw, 62vw"/></p>
<p><span>SCARF supports multiple programming languages. This is very important, as products at Meta may have client code written in Java, Objective-C, and JavaScript, with server code written in </span><a href="https://hacklang.org/"><span>Hack</span></a><span>, and some backend infrastructure written in </span><a href="https://engineering.fb.com/2023/10/05/developer-tools/python-312-meta-new-features/"><span>Python</span></a><span>. All of these pieces of code should be deleted as they all combine to form the same dependency graph since they are associated via APIs and other known forms of dynamic and language-spanning references. </span></p>
<p><span>SCARF operates at a</span> <span>symbol level as opposed to a file level, which allows for more granular analysis and cleanup. For example, an individual variable that is unused in a function will have its own fully qualified symbol, which allows for more granular cleanup than is possible at the file level. </span></p>
<h2><span>Garbage collection</span></h2>
<p><span>SCARF analyzes the augmented dependency graph to identify unreachable nodes and subgraphs that can be deleted and will automatically generate code change requests to delete the corresponding code on a daily basis. A key benefit of analyzing the complete graph is that we can detect and delete cycles, where different parts of the codebase depend on each other. Deleting entire subgraphs accelerates the deletion of dead code and provides a better experience for the engineers leveraging this automation in their deprecations.</span></p>
<p><span>It’s important that the graph contains the augmented information, as static analysis alone may not reveal links between components created through dynamic references or runtime language features. There is a trade-off, though, in that augmenting the graph with dynamic usage information requires the full processing of the indexed code and the subsequent data analysis pipelines that provide the metrics. This increases the end to end duration of the entire process which can make prototyping new features or capabilities more difficult. </span></p>
<p><span>Earlier versions of SCARF avoided this upfront cost by taking a different approach. It analyzed each discoverable symbol individually and at runtime would run classifiers that queried for static and dynamic references in order to find dead root nodes — pieces of code with no inbound dependencies. This did not require the upfront construction of the complete dependency graph and simplified the process of running the system over small subsets of the codebase. As a result, it was trivial to prototype new classifiers that identified potential dynamic references without requiring time-consuming indexing or data analysis. </span></p>
<p><span>However, this longer end-to-end development cycle led to a dramatic improvement in coverage. The transition from analyzing individual symbols to the entire graph led to a nearly 50% increase in dead code removed from one of Meta’s largest codebases. The new approach improves visibility into the state of our codebases: how much is alive, how much is dead, and how much of that we are removing in any given pass of SCARF.</span></p>
<h2><span>Fine-tuning the dependency graph</span></h2>
<p><span>Many of the dependencies that we index using Glean are for patterns of code invocation which do not necessarily block the deletion of that code. For example, let’s say we had a class </span><span>PhotoRenderer</span><span>, and the only dependency on it was in code like this:</span></p>
<pre><code>if isinstance(renderer, PhotoRenderer):
    return renderer.render_photo()
else:
    return renderer.render_generic()
</code></pre>
<p><span>In this case, the references to PhotoRenderer and </span><span>render_photo()</span><span> can be removed, and the code changed to this:</span></p>
<pre><code>return renderer.render_generic()</code></pre>
<p><span>In this example, the class, PhotoRenderer, was </span><b>inlined</b><span> based on a rule derived from the semantics of Python: if there are no places where the PhotoRenderer class is instantiated, we can be confident that this code cannot take the first branch and it is therefore dead.</span></p>
<p><span>In some cases, we derive these rules based on our application semantics as opposed to language semantics. Imagine this code:</span></p>
<pre><code>uri_dispatch = {
  &#39;/home/&#39;: HomeController,
  &#39;/photos/&#39;: PhotosController,
  ...
}
</code></pre>
<p><span>If we only analyzed a language-level dependency graph, it would be impossible to determine whether or not PhotosController is ever referenced as it can be invoked via this URI dispatch mechanism. However, if we know from our application analysis that the ‘/photos/’ endpoint never receives any requests in production, then we could remove the corresponding entry from this dictionary. </span></p>
<p><span>There’s no inherent way to infer this given Python’s language semantics, but our domain-specific logging and graph augmentation allow us to inform SCARF that this operation is safe.</span></p>
<h2><span>Automating code changes</span></h2>
<p><span>At Meta, we heavily automate changes to code. We built an internal service, called CodemodService, which empowers engineers to deploy configurations to automate code changes at scale. SCARF was the first instance of company-wide, fully automated code changes at Meta, and was built hand-in-hand alongside CodemodService. Today, CodemodService also powers hundreds of other types of automated code changes at Meta, from automating the formatting of code, automatically removing completed experiments, empowering large-scale API migrations, to improving coverage of strong types in partially-typed languages like Python and Hack.</span></p>
<h2><span>Dead code removal at scale</span></h2>
<p><span>SCARF uses CodemodService to create code change requests for engineers to review. These change requests incorporate human-readable descriptions informing engineers about the analysis that determined the targeted code is provably dead. </span></p>
<p><img decoding="async" src="https://engineering.fb.com/wp-content/uploads/2023/10/Automating-Dead-Code-Cleanup-image2.png?w=1024" alt="" width="1024" height="306" srcset="https://engineering.fb.com/wp-content/uploads/2023/10/Automating-Dead-Code-Cleanup-image2.png 1999w, https://engineering.fb.com/wp-content/uploads/2023/10/Automating-Dead-Code-Cleanup-image2.png?resize=916,274 916w, https://engineering.fb.com/wp-content/uploads/2023/10/Automating-Dead-Code-Cleanup-image2.png?resize=768,229 768w, https://engineering.fb.com/wp-content/uploads/2023/10/Automating-Dead-Code-Cleanup-image2.png?resize=1024,306 1024w, https://engineering.fb.com/wp-content/uploads/2023/10/Automating-Dead-Code-Cleanup-image2.png?resize=1536,459 1536w, https://engineering.fb.com/wp-content/uploads/2023/10/Automating-Dead-Code-Cleanup-image2.png?resize=96,29 96w, https://engineering.fb.com/wp-content/uploads/2023/10/Automating-Dead-Code-Cleanup-image2.png?resize=192,57 192w" sizes="(max-width: 992px) 100vw, 62vw"/></p>
<p><span>SCARF has grown to analyze hundreds of millions of lines of code; and five years on, it has automatically deleted more than 100 million lines of code in over 370,000 change requests. False-positives caught by engineers during code review are triaged and used to improve the analysis that SCARF performs and typically reflect new sources of dynamic usage that our augmented graphs must account for. Sometimes these misunderstood dynamic references can lead to incorrect deletion of code, and these deletions can make it to production. Meta has</span><a href="https://engineering.fb.com/2017/08/31/web/rapid-release-at-massive-scale/"><span> other mechanisms in place to catch these problems</span></a><span> and we take such incidents very seriously.</span></p>
<p><span>In some languages, we have such high confidence in our analysis that we can automatically accept and merge the change requests without human intervention to make better use of engineers’ valuable time. </span></p>
<h2><span>Is dead code removal sufficient?</span></h2>
<p><span>SCARF’s automated dead code removal accelerates the process of shutting down and removing the code and data for deprecated products, but it does not solve it fully. Beyond the problems caused by interconnectivity, we are constantly improving our ability to integrate across all languages, systems, and frameworks at Meta. It is difficult to accurately cover every type of usage of code and data that enables our systems to determine what is truly dead. </span></p>
<p><span>Our systems also err on the side of caution, by searching for textual references to code and data through our </span><a href="https://www.facebook.com/watch/?v=1911812842425144"><span>BigGrep system</span></a><span> and not solely relying on the curated graphs produced through Glean and our dynamic usage augmentations. This is a fallback safety mechanism that helps avoid accidentally deleting MySQL tables that are referenced by name in other languages and preventing deletions of dynamically invoked code in languages like Hack, Python, and JavaScript that can call code through string references or use </span><i><span>eval</span></i><span>. This approach can cause false negatives, but avoids false positives. When automating the removal of dead code, those are a more serious problem.</span></p>
<p><span>As mentioned in </span><a href="https://engineering.fb.com/2023/10/17/data-infrastructure/automating-product-deprecation-meta/"><span>our first post</span></a><span> of this series, SCARF provides workflow management features that work together with the dead code subsystem to provide a cohesive experience for fully deprecating products and features. Crucially, our engineers can iterate on code changes faster than our automation! If an engineer understands that a change has rendered a branch of code (and therefore an entire subgraph) unreachable, they can easily incorporate that deletion into their changes without waiting for our infrastructure to index the new code, analyze it, and eventually get around to submitting its automated changes. Engineers sometimes find it more productive to manually delete things rather than waiting to see if the automated systems will clean it up for them later.</span></p>
<p><span>In the next and final blog post in this series, we will look at SCARF’s unused data type  subsystem that Meta has built that, in conjunction with the dead code subsystem, amplifies Meta’s data minimization capabilities by automating the removal of dead and unused assets.</span></p>

		
	</div></div>
  </body>
</html>
