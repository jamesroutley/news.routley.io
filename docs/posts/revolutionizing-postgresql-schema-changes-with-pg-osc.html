<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.mydbops.com/blog/postgresql-schema-changes-with-pg_osc/">Original</a>
    <h1>Revolutionizing PostgreSQL Schema Changes with pg-osc</h1>
    
    <div id="readability-page-1" class="page"><article id="postContent">
                        <p>In the world of PostgreSQL database management, the significance of schema modifications cannot be overstated. Enter <strong>pg_osc, or PostgreSQL Online Schema Change </strong>– an <strong><em>open-source tool</em></strong> designed to revolutionize the execution of schema modifications without imposing substantial downtime or locking the entire database. This tool proves invaluable for making crucial adjustments to the database structure, ranging from adding or removing columns to changing data types and creating or dropping indexes.</p><p>Lets delve into the intricate workings of pg_osc, exploring its benefits, installation via Docker, and real-world examples showcasing its prowess.</p><h2><strong>Key Features of pg_osc</strong></h2><p>At its core, <strong>pg_osc</strong> operates by creating a <a target="_blank" rel="" href="https://www.mydbops.com/blog/postgresql-schema-changes-with-pg_osc/#flow-diagram-of-pg_osc-and-how-it-works-3">shadow table</a> to facilitate alterations to the main table. This involves the meticulous creation of a shadow table mirroring the production table with the desired structural modifications. Subsequently, the tool seamlessly copies content to the shadow table, ensuring no impact or lock on the production table. The final step involves a swift swap between the two tables once all data has been successfully transferred.</p><p>The necessity of pg_osc in PostgreSQL environments becomes apparent when considering its ability to minimize downtime, enable continuous operations during schema changes without blocking concurrent transactions, and optimize overall database performance.</p><h2><strong>Benefits of pg_osc</strong></h2><p>Here are some reasons why we need pg_osc in PostgreSQL:</p><ol><li><p><strong>Minimize downtime:</strong> Traditional schema changes in PostgreSQL, like using <a target="_blank" rel="" href="https://www.postgresql.org/docs/current/sql-altertable.html">ALTER TABLE</a>, can require exclusive locks on the table being modified, which can lead to database downtime for the duration of the operation. pg_osc allows you to make these changes with minimal interruption to database operations.</p></li></ol><ol start="2"><li><p><strong>Avoid blocking:</strong> While a schema change is in progress, concurrent transactions can continue to read and write data to the affected table without being blocked, improving overall database performance and responsiveness.</p></li></ol><ol start="3"><li><p><strong>Performance improvements:</strong> pg_osc is designed to minimize the impact on database performance during schema changes. It can use various strategies to optimize the change process, which can be more efficient than standard ALTER TABLE operations.</p></li><li><p><strong>Safety and reliability: </strong>pg_osc is engineered to ensure the safety and consistency of schema changes, reducing the risk of data corruption or loss during the operation.</p></li></ol><h2><strong>Flow Diagram of pg_osc and How It Works</strong></h2><p>The flow diagram elucidates the seamless operation of pg_osc. The primary table, shadow table, and audit table each play a crucial role in executing schema changes.</p><ul><li><p><strong>Primary table: </strong>The primary table is the target table for executing a possible schema change in a database.</p></li><li><p><strong>Shadow table: </strong>The shadow table is a duplicated version of an existing primary table.</p></li><li><p><strong>Audit table: </strong>An audit table is a table designed to store updates, inserts, or deletes made to a primary table.</p></li></ul><figure><a href="https://www.postgresql.org/docs/current/sql-altertable.html"><img src="https://cdn.bloghunch.com/uploads/ndm1eYzrBUlVKFBK.webp" mediatype="img" alt="PostgreSQL pg_osc" width="800" height="800" dataalign="left" caption="Fig: Flow Diagram of pg_osc" link="https://www.postgresql.org/docs/current/sql-altertable.html" loading="lazy"/></a><figcaption>Fig: Flow Diagram of pg_osc</figcaption></figure><h3><strong>Key Steps in Executing Schema Changes with pg-osc</strong></h3><ul><li><p>Create an audit table to log changes, using triggers for inserts, updates, and deletes on the parent table.</p></li><li><p>Acquire an <a target="_blank" rel="" href="https://www.postgresql.org/docs/16/explicit-locking.html"><strong>ACCESS EXCLUSIVE</strong></a> lock on the parent table to ensure exclusive access for subsequent schema modifications.</p></li><li><p>Develop a new shadow table with the desired schema changes for the transition.</p></li><li><p>Migrate data by copying all rows from the old parent table to the new shadow table.</p></li><li><p>Enhance query performance by building indexes on the new shadow table.</p></li><li><p>Ensure historical consistency by replaying changes from the audit table to the shadow table.</p></li><li><p>Clean up the audit table by deleting rows that have been replayed and are no longer needed.</p></li><li><p>Finalize the transition by acquiring an <strong>ACCESS EXCLUSIVE</strong> Lock when delta changes are minimal.</p></li><li><p>Activate the new structure by swapping table names between the shadow table and the parent table.</p></li><li><p>Safeguard data integrity during schema transition by updating references in other tables (foreign keys) with <strong>NOT VALID</strong> constraints.</p></li><li><p>Optimize query performance by analyzing the new table with the <a target="_blank" rel="" href="https://www.postgresql.org/docs/current/sql-analyze.html"><strong>ANALYZE</strong></a><strong> </strong>operation.</p></li><li><p>Validate <strong>NOT VALID</strong> foreign keys to ensure data integrity after the schema transition.</p></li><li><p>Optionally drop the old parent table if it is no longer needed in the system.</p></li></ul><h2><strong>Installation via Docker</strong></h2><p>Installing pg_osc is simplified through Docker. The command <strong><em>docker pull shayonj/pg-osc:latest</em></strong> fetches the latest version, streamlining the installation process.</p><pre language=""><code>docker pull shayonj/pg-osc:latest</code></pre><h3><strong>Examples with Demo:</strong></h3><ol><li><p><strong>Adding a Column:</strong> Adding a column, such as <strong>member</strong>, to the <strong>team_member</strong> table is demonstrated with the following command:</p><pre language="bash"><code>docker run --network host -it --rm shayonj/pg-osc:latest     pg-online-schema-change perform     --alter-statement &#39;ALTER TABLE team_member ADD COLUMN &#34;member&#34; BOOLEAN DEFAULT TRUE;&#39;     --dbname &#34;postgres&#34; --password &#34;password&#34;     --host &#34;localhost&#34;     --username &#34;postgres&#34;</code></pre><p><strong>Before</strong></p><figure><a href="https://cdn.bloghunch.com/uploads/IpOhBMyUXoOdOtJU.webp" data-fslightbox="https://cdn.bloghunch.com/uploads/IpOhBMyUXoOdOtJU.webp"><img src="https://cdn.bloghunch.com/uploads/IpOhBMyUXoOdOtJU.webp" mediatype="img" alt="pg_osc" width="800" height="187.76859504132233" dataalign="left" caption="Before adding a column" link="" loading="lazy"/></a><figcaption>Before adding a column</figcaption></figure><p><strong>After</strong> (adding column member by using pg-osc)</p><figure><a href="https://cdn.bloghunch.com/uploads/cCIeBTtYTGznzxNw.webp" data-fslightbox="https://cdn.bloghunch.com/uploads/cCIeBTtYTGznzxNw.webp"><img src="https://cdn.bloghunch.com/uploads/cCIeBTtYTGznzxNw.webp" mediatype="img" alt="pg_osc" width="800" height="165.80937972768533" dataalign="left" caption="After adding a column" link="" loading="lazy"/></a><figcaption>After adding a column</figcaption></figure></li><li><p><strong>Renaming a Column:</strong> Renaming a column, for instance, changing <strong>birthdate</strong> to <strong>new_birthdate</strong> in the <strong>team_member</strong> table is showcased as follows:</p><pre language="bash"><code>docker run --network host -it --rm shayonj/pg-osc:latest     pg-online-schema-change perform     --alter-statement &#39;ALTER TABLE team_member RENAME COLUMN birthdate TO new_birthdate;&#39;     --dbname &#34;postgres&#34; --password &#34;password&#34;     --host &#34;localhost&#34;     --username &#34;postgres&#34;      --drop</code></pre><p><strong>Note:-</strong> Here we have used <strong>–drop</strong>, that drops the duplicate table.</p><p><strong>Before</strong></p><figure><a href="https://cdn.bloghunch.com/uploads/r2o0hbPOVCyX9EBm.webp" data-fslightbox="https://cdn.bloghunch.com/uploads/r2o0hbPOVCyX9EBm.webp"><img src="https://cdn.bloghunch.com/uploads/r2o0hbPOVCyX9EBm.webp" mediatype="img" alt="pg_osc" width="800" height="176.1904761904762" dataalign="left" caption="Before renaming a column" link="" loading="lazy"/></a><figcaption>Before renaming a column</figcaption></figure><p><strong>After</strong> (renaming a column by using pg-osc)</p><figure><a href="https://cdn.bloghunch.com/uploads/2LWQTRpvh15yA2vD.webp" data-fslightbox="https://cdn.bloghunch.com/uploads/2LWQTRpvh15yA2vD.webp"><img src="https://cdn.bloghunch.com/uploads/2LWQTRpvh15yA2vD.webp" mediatype="img" alt="pg_osc" width="800" height="164.19213973799125" dataalign="left" caption="After renaming a column" link="" loading="lazy"/></a><figcaption>After renaming a column</figcaption></figure></li><li><p><strong>Multiple Alter Statements:</strong> Demonstrating multiple alter statements involves adding the column <strong>permanent_member</strong>, renaming <strong>username</strong> to <strong>Name</strong>, and dropping the <strong>purchased</strong> column in the member table:</p><pre language="bash"><code>docker run --network host -it --rm shayonj/pg-osc:latest     pg-online-schema-change perform     --alter-statement &#39;ALTER TABLE member ADD COLUMN Permanent_member BOOLEAN DEFAULT TRUE; ALTER TABLE member RENAME COLUMN username TO Name; ALTER TABLE member DROP column purchased;&#39;     --dbname &#34;postgres&#34; --password &#34;password&#34;     --host &#34;localhost&#34;     --username &#34;postgres&#34;      --wait-time-for-lock 4     --kill-backends</code></pre><p><strong>Before executing multiple Alter</strong></p><figure><a href="https://cdn.bloghunch.com/uploads/bWU01A5q4sov1IS3.webp" data-fslightbox="https://cdn.bloghunch.com/uploads/bWU01A5q4sov1IS3.webp"><img src="https://cdn.bloghunch.com/uploads/bWU01A5q4sov1IS3.webp" mediatype="img" alt="pg_osc" width="800" height="132.6278659611993" dataalign="left" caption="Before executing multiple ALTER statements" link="" loading="lazy"/></a><figcaption>Before executing multiple ALTER statements</figcaption></figure><p><strong>After executing multiple Alter</strong></p><figure><a href="https://cdn.bloghunch.com/uploads/zVB0tyQwZpK4Epi7.webp" data-fslightbox="https://cdn.bloghunch.com/uploads/zVB0tyQwZpK4Epi7.webp"><img src="https://cdn.bloghunch.com/uploads/zVB0tyQwZpK4Epi7.webp" mediatype="img" alt="pg_osc" width="800" height="135.52631578947367" dataalign="left" caption="After executing multiple ALTER statements" link="" loading="lazy"/></a><figcaption>After executing multiple ALTER statements</figcaption></figure></li><li><p><strong>Kill Other Processes After 4s:</strong> When working on a busy database table, pg_osc offers the <strong><em>--kill-backends</em></strong> feature to deal with competition for locks.</p><p>When pg-osc attempts to acquire an <strong>ACCESS EXCLUSIVE lock</strong>, it briefly holds and then releases it. If other processes are attempting to acquire the lock, you can configure pg-osc to wait for a specific duration before forcefully stopping those competing processes. This helps manage conflicts and ensures a smoother operation on a table with high activity.</p><p><em>--wait-time-for-lock 4 (wait for 4 seconds)</em></p><p><em>--kill-backends (terminate the backend process after 4 seconds)</em></p><pre language="bash"><code>docker run --network host -it --rm shayonj/pg-osc:latest     pg-online-schema-change perform     --alter-statement &#39;ALTER TABLE member ADD COLUMN Permanent_member BOOLEAN DEFAULT TRUE; ALTER TABLE member RENAME COLUMN username TO Name; ALTER TABLE member DROP column purchased;&#39;     --dbname &#34;postgres&#34; --password &#34;password&#34;     --host &#34;localhost&#34;     --username &#34;postgres&#34;      --wait-time-for-lock 4     --kill-backends </code></pre><p><strong>Before</strong></p><figure><a href="https://cdn.bloghunch.com/uploads/hsqeRSP7lTUMwEYV.webp" data-fslightbox="https://cdn.bloghunch.com/uploads/hsqeRSP7lTUMwEYV.webp"><img src="https://cdn.bloghunch.com/uploads/hsqeRSP7lTUMwEYV.webp" mediatype="img" alt="pg_osc" width="800" height="132.6278659611993" dataalign="left" caption="Before --kill-backends" link="" loading="lazy"/></a><figcaption>Before --kill-backends</figcaption></figure><p><strong>After </strong>(using  --wait-time-for-lock 4,  --kill-backends)</p><figure><a href="https://cdn.bloghunch.com/uploads/4maMfUFqtGa0QTni.webp" data-fslightbox="https://cdn.bloghunch.com/uploads/4maMfUFqtGa0QTni.webp"><img src="https://cdn.bloghunch.com/uploads/4maMfUFqtGa0QTni.webp" mediatype="img" alt="pg_osc" width="800" height="135.52631578947367" dataalign="left" caption="After --kill-backends" link="" loading="lazy"/></a><figcaption>After --kill-backends</figcaption></figure></li></ol><h2><strong>Limitations</strong></h2><ul><li><p>pg-osc does not currently support partitioned tables.</p></li><li><p>For schema changes with pg-osc, a primary key is necessary on the table to uniquely identify rows during the replay of changes.</p></li><li><p>pg-osc obtains an ACCESS EXCLUSIVE lock on the parent table twice during the schema change: first when setting up triggers and creating a shadow table, and next when performing the table swap and updating foreign key references.</p></li><li><p>Adequate disk space is required for the schema change operation due to the nature of duplicating a table.</p></li><li><p>Indexes, constraints, and sequence names are altered and lose their original names during the schema change operation.</p></li></ul><h2><strong>Advanced Features of pg_osc</strong></h2><ul><li><p><strong>pg-osc </strong>ensures data consistency during column changes, supporting additions, drops, or renames without data loss, and maintaining data integrity through schema modifications.</p></li><li><p>It minimizes locks during schema changes, reducing the potential for blocking concurrent transactions and facilitating smoother database modifications.</p></li><li><p>The tool adeptly handles indexes and foreign keys, crucial for data integrity and optimal query performance.</p></li><li><p>Users have the option to either drop or retain old tables after schema changes, providing flexibility in managing historical data according to specific requirements.</p></li><li><p><strong>pg-osc</strong> offers backend management features, including the termination of competing backends, similar to <a target="_blank" rel="" href="https://postgrespro.com/docs/enterprise/15/app-pgrepack"><strong>pg_repack</strong></a>, facilitating the quick setup of shadow tables during schema changes.</p></li><li><p>For accurate data migration, the tool backfills old and new columns as data is copied from the primary to the shadow table, ensuring correctness in the new schema structure.</p></li><li><p>Users can specify a custom copy statement with pg-osc, offering control and customization options during the data migration process.</p></li></ul><p>In conclusion, pg_osc is a vital tool for efficient schema modifications in PostgreSQL, minimizing downtime, avoiding blocking, and ensuring data consistency. Its seamless process, advanced features, and practical examples make it an indispensable solution.</p><p>Consider harnessing the power of pg_osc for optimized PostgreSQL database management. Reach out to explore our Managed PostgreSQL Services and Consulting expertise, ensuring a smooth and efficient database evolution. <a rel="" href="https://www.mydbops.com/contact">Contact Us.</a></p><section>


    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    



    <!-- Container to center the button on the line -->
    



</section>
                    </article></div>
  </body>
</html>
