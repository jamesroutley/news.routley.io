<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bou.ke/blog/rust-ping/">Original</a>
    <h1>Rootless Pings in Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
<div>
  
  <p>Sending a <a href="https://en.wikipedia.org/wiki/Ping_(networking_utility)" target="_blank">ping</a> by creating an ICMP socket normally requires root: you can’t create a raw socket to send ICMP packets without it. The <code>ping</code> command line tool works without root however, how is that possible? It turns out you can create a UDP socket with a protocol flag, which allows you to send the ping rootless. I couldn’t find any simple examples of this online and LLMs are surprisingly bad at this (probably because of the lack of examples). Therefore I posted <a href="https://github.com/bouk/rust-ping-example" target="_blank">an example</a> on GitHub in Rust. The gist of it is this:</p>

<h2 id="1-create-a-udp-socket-with-icmp-protocol">1. Create a UDP socket with ICMP protocol</h2>

<p>Using the <a href="https://crates.io/crates/socket2" target="_blank">socket2</a> crate.</p>

<div><div><pre><code><span>use</span> <span>socket2</span><span>::{</span><span>Domain</span><span>,</span> <span>Protocol</span><span>,</span> <span>Socket</span><span>,</span> <span>Type</span><span>};</span>
<span>use</span> <span>std</span><span>::</span><span>net</span><span>::</span><span>UdpSocket</span><span>;</span>

<span>let</span> <span>socket</span> <span>=</span> <span>Socket</span><span>::</span><span>new</span><span>(</span><span>Domain</span><span>::</span><span>IPV4</span><span>,</span> <span>Type</span><span>::</span><span>DGRAM</span><span>,</span> <span>Some</span><span>(</span><span>Protocol</span><span>::</span><span>ICMPV4</span><span>))</span><span>?</span><span>;</span>
<span>let</span> <span>socket</span><span>:</span> <span>UdpSocket</span> <span>=</span> <span>socket</span><span>.into</span><span>();</span>
</code></pre></div></div>

<h2 id="2-create-and-send-the-ping-packet">2. Create and send the ping packet</h2>

<p>Note that you don’t need to provide an IP header and that Linux and macOS behave differently here: the Linux kernel overrides the identifier and checksum fields, while macOS <em>does</em> use them and the checksum needs to be correct.</p>

<div><div><pre><code><span>let</span> <span>sequence</span><span>:</span> <span>u16</span> <span>=</span> <span>1</span><span>;</span>
<span>let</span> <span>mut</span> <span>packet</span><span>:</span> <span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;</span> <span>=</span> <span>vec!</span><span>[</span>
	<span>8</span><span>,</span> <span>// type: echo request</span>
	<span>0</span><span>,</span> <span>// code: always 0 for echo request</span>
	<span>0</span><span>,</span> <span>0</span><span>,</span> <span>// checksum: calculated by kernel on Linux, required on macOS</span>
	<span>0</span><span>,</span> <span>1</span><span>,</span> <span>// identifier: overwritten by kernel on Linux, not on macOS</span>
	<span>(</span><span>sequence</span> <span>&gt;&gt;</span> <span>8</span><span>)</span> <span>as</span> <span>u8</span><span>,</span> <span>(</span><span>sequence</span> <span>&amp;</span> <span>0xff</span><span>)</span> <span>as</span> <span>u8</span><span>,</span>
	<span>b</span><span>&#39;h&#39;</span><span>,</span> <span>b</span><span>&#39;e&#39;</span><span>,</span> <span>b</span><span>&#39;l&#39;</span><span>,</span> <span>b</span><span>&#39;l&#39;</span><span>,</span> <span>b</span><span>&#39;o&#39;</span><span>,</span> <span>// payload (can be anything)</span>
<span>];</span>

<span>// Checksum is determined by the kernel on Linux, but it&#39;s needed on macOS</span>
<span>let</span> <span>checksum</span> <span>=</span> <span>calculate_checksum</span><span>(</span><span>&amp;</span><span>packet</span><span>);</span>
<span>packet</span><span>[</span><span>2</span><span>]</span> <span>=</span> <span>(</span><span>checksum</span> <span>&gt;&gt;</span> <span>8</span><span>)</span> <span>as</span> <span>u8</span><span>;</span>
<span>packet</span><span>[</span><span>3</span><span>]</span> <span>=</span> <span>(</span><span>checksum</span> <span>&amp;</span> <span>0xff</span><span>)</span> <span>as</span> <span>u8</span><span>;</span>

<span>// Port can be anything, doesn&#39;t matter</span>
<span>socket</span><span>.send_to</span><span>(</span><span>&amp;</span><span>packet</span><span>,</span> <span>&#34;1.1.1.1:0&#34;</span><span>)</span><span>?</span><span>;</span>
</code></pre></div></div>

<h2 id="3-receive-and-interpret-the-response">3. Receive and interpret the response</h2>

<p>Here macOS and Linux are different again: macOS includes the IP header in the response, Linux does not.</p>

<div><div><pre><code><span>let</span> <span>mut</span> <span>buffer</span> <span>=</span> <span>vec!</span><span>[</span><span>0u8</span><span>;</span> <span>64</span><span>];</span>
<span>let</span> <span>(</span><span>size</span><span>,</span> <span>from_addr</span><span>)</span> <span>=</span> <span>socket</span><span>.recv_from</span><span>(</span><span>&amp;</span><span>mut</span> <span>buffer</span><span>)</span><span>?</span><span>;</span>

<span>// On macOS, the IP header is included in the received packet, strip it</span>
<span>#[cfg(target_os</span> <span>=</span> <span>&#34;macos&#34;</span><span>)]</span>
<span>const</span> <span>IP_HEADER_LEN</span><span>:</span> <span>usize</span> <span>=</span> <span>20</span><span>;</span>

<span>// On Linux, the IP header is not included</span>
<span>#[cfg(not(target_os</span> <span>=</span> <span>&#34;macos&#34;</span><span>))]</span>
<span>const</span> <span>IP_HEADER_LEN</span><span>:</span> <span>usize</span> <span>=</span> <span>0</span><span>;</span>

<span>let</span> <span>data</span> <span>=</span> <span>&amp;</span><span>buffer</span><span>[</span><span>IP_HEADER_LEN</span><span>..</span><span>size</span><span>];</span>
<span>let</span> <span>reply_type</span> <span>=</span> <span>data</span><span>[</span><span>0</span><span>];</span> <span>// should be 0</span>
<span>let</span> <span>reply_sequence</span> <span>=</span> <span>((</span><span>data</span><span>[</span><span>6</span><span>]</span> <span>as</span> <span>u16</span><span>)</span> <span>&lt;&lt;</span> <span>8</span><span>)</span> <span>|</span> <span>(</span><span>data</span><span>[</span><span>7</span><span>]</span> <span>as</span> <span>u16</span><span>);</span> <span>// should equal &#39;sequence&#39;</span>
<span>let</span> <span>payload</span> <span>=</span> <span>&amp;</span><span>data</span><span>[</span><span>8</span><span>..</span><span>];</span> <span>// should be b&#34;hello&#34;</span>
</code></pre></div></div>

<p>Of course you can implement latency, loss, periodic pings etc. but that’s left as an exercise to the reader.</p>

  <p><span>Nov 2025</span></p>
</div>
</div></div>
  </body>
</html>
