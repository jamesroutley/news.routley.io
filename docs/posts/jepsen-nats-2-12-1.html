<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jepsen.io/analyses/nats-2.12.1">Original</a>
    <h1>Jepsen: NATS 2.12.1</h1>
    
    <div id="readability-page-1" class="page"><p><a href="https://nats.io/">NATS</a> is a distributed streaming system. Regular NATS streams offer only best-effort delivery, but a subsystem, called JetStream, guarantees messages are delivered at least once. We tested NATS JetStream, version 2.12.1, and found that it lost writes if data files were truncated or corrupted on a minority of nodes. We also found that coordinated power failures, or an OS crash on a single node combined with network delays or process pauses, can cause the loss of committed writes and persistent split-brain. This data loss was caused (at least in part) by choosing to flush writes to disk every two minutes, rather than before acknowledging them. We also include a belated note on data loss due to process crashes in version 2.10.22, which was fixed in 2.10.23. NATS has now documented the risk of its default <code>fsync</code> policy, and the remaining issues remain under investigation. This research was performed independently by Jepsen, without compensation, and conducted in accordance with the <a href="https://jepsen.io/analyses/ethics">Jepsen ethics policy</a>.</p><article>
  <div>

<p><a href="https://nats.io/">NATS</a> is a popular streaming system. Producers <a href="https://docs.nats.io/nats-concepts/core-nats/pubsub">publish messages to streams</a>, and consumers subscribe to those streams, fetching messages from them. Regular NATS streams are allowed to drop messages. However, NATS has a subsystem called <a href="https://docs.nats.io/nats-concepts/jetstream">JetStream</a>, which <a href="https://docs.nats.io/running-a-nats-service/configuration/clustering/jetstream_clustering">uses</a> the <a href="https://raft.github.io/">Raft consensus algorithm</a> to replicate data among nodes. JetStream promises <a href="https://docs.nats.io/nats-concepts/jetstream#exactly-once-semantics">“at least once”</a> delivery: messages may be duplicated, but acknowledged messages<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a> should not be lost.<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a> Moreover, JetStream streams are <a href="https://docs.nats.io/nats-concepts/jetstream#persistent-and-consistent-distributed-storage">totally ordered logs</a>.</p>
<p>JetStream is intended to <a href="https://docs.nats.io/nats-concepts/jetstream">“self-heal and always be available”</a>. The documentation also states that <a href="https://docs.nats.io/nats-concepts/jetstream#persistent-and-consistent-distributed-storage">“the formal consistency model of NATS JetStream is Linearizable”</a>. At most one of these claims can be true: the <a href="https://www.cs.princeton.edu/courses/archive/spr22/cos418/papers/cap.pdf">CAP theorem</a> tells us that <a href="https://jepsen.io/consistency/models/linearizable">Linearizable</a> systems can not be totally available.<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a> In practice, they tend to be available so long as a majority of nodes are non-faulty and communicating. If, say, a single node loses network connectivity, operations must fail on that node. If three out of five nodes crash, all operations must fail.</p>
<p>Indeed, a <a href="https://docs.nats.io/nats-concepts/jetstream#persistent-and-consistent-distributed-storage">later section</a> of the JetStream docs acknowledges this fact, saying that streams with three replicas can tolerate the loss of one server, and those with five can tolerate the simultaneous loss of two.</p>
<blockquote>
<p>Replicas=5 - Can tolerate simultaneous loss of two servers servicing the stream. Mitigates risk at the expense of performance.</p>
</blockquote>
<p>When does NATS guarantee a message will be durable? The <a href="https://docs.nats.io/using-nats/developer/develop_jetstream?q=sync#publish-to-a-stream">JetStream developer docs</a> say that once a JetStream client’s <code>publish</code> request is acknowledged by the server, that message has “been successfully persisted”. The <a href="https://docs.nats.io/running-a-nats-service/configuration/clustering/jetstream_clustering#the-quorum">clustering configuration documentation</a> says:</p>
<blockquote>
<p>In order to ensure data consistency across complete restarts, a quorum of servers is required. A quorum is ½ cluster size + 1. This is the minimum number of nodes to ensure at least one node has the most recent data and state after a catastrophic failure. So for a cluster size of 3, you’ll need at least two JetStream enabled NATS servers available to store new messages. For a cluster size of 5, you’ll need at least 3 NATS servers, and so forth.</p>
</blockquote>
<p>With these guarantees in mind, we set out to test NATS JetStream behavior under a variety of simulated faults.</p>

<p>We designed a <a href="https://github.com/jepsen-io/nats">test suite</a> for NATS JetStream using the <a href="https://github.com/jepsen-io/jepsen">Jepsen testing library</a>, using <a href="https://github.com/nats-io/nats.java">JNATS</a> (the official Java client) at version 2.24.0. Most of our tests ran in Debian 12 containers under LXC; <a href="https://github.com/jepsen-io/nats/tree/4760f97f86350c5c9983478656dbcbcdade33817/antithesis">some tests</a> ran in <a href="https://antithesis.com/">Antithesis</a>, using the official NATS Docker images. In all our tests we created a single JetStream stream with a target replication factor of five. Per NATS’ recommendations, our clusters generally contained three or five nodes. We tested a variety of versions, but the bulk of this work focused on NATS 2.12.1.</p>
<p>The test harness <a href="https://github.com/jepsen-io/nats/blob/4760f97f86350c5c9983478656dbcbcdade33817/src/jepsen/nats/nemesis.clj">injected a variety of faults</a>, including process pauses, crashes, network partitions, and packet loss, as well as single-bit errors and truncation of data files. We limited file corruption to a minority of nodes. We also simulated power failure—a crash with partial amnesia—using the <a href="https://github.com/dsrhaslab/lazyfs">LazyFS</a> filesystem. LazyFS allows Jepsen to drop any writes which have not yet been flushed using a call to (e.g.) <code>fsync</code>.</p>
<p>Our tests did not measure Linearizability or <a href="https://jepsen.io/consistency/models/serializable">Serializability</a>. Instead we ran <a href="https://github.com/jepsen-io/nats/blob/4760f97f86350c5c9983478656dbcbcdade33817/src/jepsen/nats/queue.clj#L238-L266">several producer processes</a>, each bound to a single NATS client, which published globally unique values to a single JetStream stream. Each message included the process number and a sequence number within that process, so message <code>4-0</code> denoted the first <code>publish</code> attempted by process <code>4</code>, message <code>4-1</code> denoted the second, and so on. At the end of the test we ensured all nodes were running, resolved any network partitions or other faults, subscribed to the stream, and <a href="https://github.com/jepsen-io/nats/blob/4760f97f86350c5c9983478656dbcbcdade33817/src/jepsen/nats/queue.clj#L189-L201">attempted to read all acknowledged messages from the the stream</a>. Each reader called <code>fetch</code> until it had observed (at least) the last acknowledged message published by each process, or timed out.</p>
<p>We measured JetStream’s at-least-once semantics <a href="https://github.com/jepsen-io/nats/blob/4760f97f86350c5c9983478656dbcbcdade33817/src/jepsen/nats/queue.clj#L359-L424">based on the union of all published and read messages</a>. We considered a message <em>OK</em> if it was attempted and read. Messages were <em>lost</em> if they were acknowledged as published, but never read by any process. We divided lost messages into three epochs, based on the first and last OK messages written by the same process.<a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a> We called those lost before the first OK message the <em>lost-prefix</em>, those lost after all the last OK message the <em>lost-postfix</em>, and all others the <em>lost-middle</em>. This helped to distinguish between lagging readers and true data loss.</p>
<p>In addition to verifying each acknowledged message was delivered to at least one consumer across all nodes, we also checked the set of messages read by all consumers connected to a specific node. We called it <em>divergence</em>, or <em>split-brain</em>, when an acknowledged message was missing from some nodes but not others.</p>

<p>We begin with a belated note on total data loss in version 2.10.22, then continue with four findings related to data loss and replica divergence in version 2.12.1: two with file corruption, and two with power failures.</p>
<h2 data-number="3.1" id="total-data-loss-on-crash-in-2.10.22-6888"> Total Data Loss on Crash in 2.10.22 (#6888)</h2>
<p>Before discussing version 2.12.1, we present a long-overdue finding from earlier work. In versions 2.10.20 through 2.10.22 (released 2024-10-17), we found that process crashes alone could cause the total loss of a JetStream stream and all its associated data. Subscription requests would return <code>&#34;No matching streams for subject&#34;</code>, and <code>getStreamNames()</code> would return an empty list. These conditions would persist for hours: <a href="https://github.com/user-attachments/files/20133999/20250509T191519.377-0500.zip">in this test run</a>, we waited 10,000 seconds for the cluster to recover, but the stream never returned.</p>
<p>Jepsen reported this issue to NATS as <a href="https://github.com/nats-io/nats-server/issues/6888">#6888</a>, but it appears that NATS had already identified several potential causes for this problem and resolved them. In <a href="https://github.com/nats-io/nats-server/pull/5946">#5946</a>, a cluster-wide crash occurring shortly after a stream was created could cause the loss of the stream. A new leader would be elected with a snapshot which preceded the creation of the stream, and replicate that empty snapshot to followers, causing everyone to delete their copy of the stream. In <a href="https://github.com/nats-io/nats-server/pull/5700">#5700</a>, tests running in <a href="https://antithesis.com/">Antithesis</a> found that out-of-order delivery of snapshot messages could cause streams to be deleted and re-created as well. In <a href="https://github.com/nats-io/nats-server/pull/6061">#6061</a>, process crashes could cause nodes to delete their local Raft state. All of these fixes were released as a part of 2.10.23, and we no longer observed the problem in that version.</p>
<h2 data-number="3.2" id="lost-writes-with-.blk-file-corruption-7549"> Lost Writes With <code>.blk</code> File Corruption (#7549)</h2>
<p>NATS has several checksum mechanisms meant to detect data corruption in on-disk files. However, we found that single-bit errors or truncation of JetStream’s <code>.blk</code> files could cause the cluster to lose large windows of writes. This occurred even when file corruption was limited to just one or two nodes out of five. For instance, <a href="https://s3.amazonaws.com/jepsen.io/analyses/nats-2.12.1/20251116T061217-blk-bitflip.zip">file corruption in this test run</a> caused NATS to lose 679,153 acknowledged writes out of 1,367,069 total, including 201,286 which were missing even though later values written by the same process were later read.</p>
<p><img src="https://jepsen.io/analyses/nats-2.12.1/blk-bitflip-loss.png" alt="A timeseries plot of write loss over time. A large block of writes is lost around sixty seconds, followed by a few which survive, and then the rest of the successfully acknowledged writes are lost as well."/><br/>
</p>
<p>In some cases, file corruption caused the quiet loss of <a href="https://s3.amazonaws.com/jepsen.io/analyses/nats-2.12.1/20251116T030143-blk-bitflip-single-loss.zip">just a single message</a>. In others, writes vanished in large blocks. Even worse, bitflips could cause split-brain, where different nodes returned different sets of messages. In <a href="https://s3.amazonaws.com/jepsen.io/analyses/nats-2.12.1/20251120T093731-blk-bitflip-split-brain.zip">this test</a>, NATS acknowledged a total of 1,479,661 messages. However, single-bit errors in <code>.blk</code> files on nodes <code>n1</code> and <code>n3</code> caused nodes <code>n1</code>, <code>n3</code>, and <code>n5</code> to lose up to 78% of those acknowledged messages. Node <code>n1</code> lost 852,413 messages, and nodes <code>n3</code> and <code>n5</code> lost 1,167,167 messages, despite <code>n5</code>’s data files remaining intact. Messages were lost in prefix, middle, and postfix: the stream, at least on those three nodes, resembled Swiss cheese.</p>
<p>NATS is investigating this issue (<a href="https://github.com/nats-io/nats-server/issues/7549">#7549</a>).</p>
<h2 data-number="3.3" id="total-data-loss-with-snapshot-file-corruption-7556"> Total Data Loss With Snapshot File Corruption (#7556)</h2>
<p>When we truncated or introduced single-bit errors into JetStream’s snapshot files in <code>data/jetstream/$SYS/_js_/</code>, we found that nodes would sometimes decide that a stream had been orphaned, and delete all its data files. This happened even when only a minority of nodes in the cluster experienced file corruption. The cluster would never recover quorum, and the stream remained unavailable for the remainder of the test.</p>
<p>In <a href="https://s3.amazonaws.com/jepsen.io/analyses/nats-2.12.1/20251115T142345-snap-bitflip-quorum-break.zip">this test run</a>, we introduced single-bit errors into snapshots on nodes <code>n3</code> and <code>n5</code>. During the final recovery period, node <code>n3</code> became the metadata leader for the cluster and decided to clean up <code>jepsen-stream</code>, which stored all the test’s messages.</p>
<pre><code>[1010859] 2025/11/15 20:27:02.947432 [INF]
Self is new JetStream cluster metadata leader
[1010859] 2025/11/15 20:27:14.996174 [WRN]
Detected orphaned stream &#39;jepsen &gt;
jepsen-stream&#39;, will cleanup</code></pre>
<p>Nodes <code>n3</code> and <code>n5</code> then deleted all files in the stream directory. This might seem defensible—after all, some of <code>n3</code>’s data files <em>were</em> corrupted. However, <code>n3</code> managed to become the leader of the cluster despite its corrupt state! In general, leader-based consensus systems must be careful to ensure that any node which becomes a leader is aware of majority committed state. Becoming a leader, then opting to delete a stream full of committed data, is particularly troubling.</p>
<p>Although nodes <code>n1</code>, <code>n2</code>, and <code>n4</code> retained their data files, <code>n1</code> struggled to apply snapshots; <code>n4</code> declared that <code>jepsen-stream</code> had no quorum and stalled. Every attempt to subscribe to the stream threw <code>[SUB-90007] No matching streams for subject</code>. Jepsen filed issue <a href="https://github.com/nats-io/nats-server/issues/7556">#7556</a> for this, and the NATS team is looking into it.</p>
<h2 data-number="3.4" id="lazy-fsync-by-default-7564"> Lazy <code>fsync</code> by Default (#7564)</h2>
<p>NATS JetStream promises that once a <code>publish</code> call has been acknowledged, it is “successfully persisted”. This is not exactly true. By default, NATS calls <code>fsync</code> to flush data to disk only once every two minutes, but acknowledges messages immediately. Consequently, recently acknowledged writes are generally <em>not</em> persisted, and could be lost to coordinated power failure, kernel crashes, etc. For instance, simulated power failures in <a href="https://github.com/user-attachments/files/23631053/20251119T075152.133-0600.zip">this test run</a> caused NATS to lose roughly thirty seconds of writes: 131,418 out of 930,005 messages.</p>
<p><img src="https://jepsen.io/analyses/nats-2.12.1/power-loss.png" alt="A timeseries plot of data loss over time. Acknowledged writes are fine for the first 125 seconds, then all acknowledged writes are lost for the remainder of the test."/><br/>
</p>
<p>Because the default flush interval is quite large, even killing a single node at a time is sufficient to cause data loss, so long as nodes fail within a few seconds of each other. In <a href="https://github.com/user-attachments/files/23631363/20251119T085347.396-0600.zip">this run</a>, a series of single-node failures in the first two minutes of the test caused NATS to delete the entire stream, along with all of its messages.</p>
<p>There are only two mentions of this behavior in the NATS documentation. The first is in the <a href="https://docs.nats.io/release-notes/whats_new/whats_new_210">2.10 release notes</a>. The second, <a href="https://docs.nats.io/running-a-nats-service/configuration">buried in the configuration docs</a>, describes the <code>sync_interval</code> option:</p>
<blockquote>
<p>Change the default fsync/sync interval for page cache in the filestore. By default JetStream relies on stream replication in the cluster to guarantee data is available after an OS crash. If you run JetStream without replication or with a replication of just 2 you may want to shorten the fsync/sync interval. You can force an fsync after each messsage [sic] with <code>always</code>, this will slow down the throughput to a few hundred msg/s.</p>
</blockquote>
<p>Consensus protocols often require that nodes sync to disk before acknowledging an operation. For example, the famous 2007 paper <a href="https://www.cs.utexas.edu/~lorenzo/corsi/cs380d/papers/paper2-1.pdf">Paxos Made Live</a> remarks:</p>
<blockquote>
<p>Note that all writes have to be flushed to disk immediately before the system can proceed any further.</p>
</blockquote>
<p>The <a href="https://web.stanford.edu/~ouster/cgi-bin/papers/OngaroPhD.pdf">Raft thesis</a> on which NATS is based is clear that nodes must “flush [new log entries] to their disks” before acknowledging. Section 11.7.3 discusses the possibility of instead writing data to disk asynchronously, and concludes:</p>
<blockquote>
<p>The trade-off is that data loss is possible in catastrophic events. For example, if a majority of the cluster were to restart simultaneously, the cluster would have potentially lost entries and would not be able to form a new view. Raft could be extended in similar ways to support disk-less operation, but we think the risk of availability or data loss usually outweighs the benefits.</p>
</blockquote>
<p>For similar reasons, replicated systems like <a href="https://www.mongodb.com/docs/manual/reference/replica-configuration/#mongodb-rsconf-rsconf.writeConcernMajorityJournalDefault">MongoDB</a>, <a href="https://www.redhat.com/en/blog/a-guide-to-etcd">etcd</a>, <a href="https://docs.tigerbeetle.com/single-page/">TigerBeetle</a>, <a href="https://thinkingaboutdistributedsystems.blogspot.com/2017/09/what-we-can-learn-from-zookeepers.html">Zookeeper</a>, <a href="https://www.redpanda.com/blog/top-performance-considerations-redpanda">Redpanda</a>, and <a href="https://docs.pingcap.com/tidb/stable/release-5.0.0/#configuration-file-parameters">TiDB</a> sync data to disk before acknowledging an operation as committed.</p>
<p>However, some systems do choose to <code>fsync</code> asynchronously. YugabyteDB’s default is <a href="https://docs.yugabyte.com/stable/reference/configuration/yb-master/#durable-wal-write">to acknowledge un-fsynced writes</a>. Liskov and Cowling’s <a href="http://pmg.csail.mit.edu/papers/vr-revisited.pdf">Viewstamped Replication Revisited</a> assumes replicas are “highly unlikely to fail at the same time”—but acknowledges that if they were to fail simultaneously, state would be lost. Apache Kafka <a href="https://jack-vanlightly.com/blog/2023/4/24/why-apache-kafka-doesnt-need-fsync-to-be-safe">makes a similar choice</a>, but claims that it is not vulnerable to coordinated failure because Kafka “doesn’t store unflushed data in its own memory, but in the page cache”. This offers resilience to the Kafka process itself crashing, but not power failure.<a href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a> Jepsen remains skeptical of this approach: as <a href="https://www.usenix.org/system/files/conference/osdi16/osdi16-alagappan.pdf">Alagappan et al.</a> argue, <a href="https://www.usenix.org/system/files/conference/atc13/atc13-cidon.pdf">extensive</a> <a href="https://pages.cs.wisc.edu/~akella/CS838/F15/838-CloudPapers/hdfs.pdf">literature</a> <a href="https://static.googleusercontent.com/media/research.google.com/en//people/jeff/SOCC2010-keynote-slides.pdf">on</a> <a href="https://aws.amazon.com/message/2329B7/">correlated</a> <a href="https://www.datacenterknowledge.com/cloud/lightning-in-belgium-disrupts-google-cloud-services-updated-">failures</a> <a href="https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Ford.pdf">suggests</a> <a href="https://haeberlen.cis.upenn.edu/papers/glacier-nsdi2005.pdf">we</a> <a href="http://issg.cs.duke.edu/publications/disasters-fast04.pdf">should</a> <a href="https://web.archive.org/web/20080108203642/https://radar.oreilly.com/archives/2007/07/365_main_datace.html">continue</a> <a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/45499.pdf">to</a> <a href="https://www.energy.gov/oe/august-2003-blackout">take</a> <a href="https://www.webofscience.com/wos/woscc/full-record/WOS:000245079400017?&amp;SID=USW2EC0C58xDjRHQcDMVJJIWW5emx">this</a> <a href="https://web.archive.org/web/20170519044830/https://www.joyent.com/blog/postmortem-for-outage-of-us-east-1-may-27-2014">risk</a> <a href="https://pace.gatech.edu/2025/04/02/cooling-failure-in-coda-datacenter/">seriously</a>. Heat waves, grid instability, fires, lightning, tornadoes, and floods are not necessarily constrained to a single availability zone.</p>
<p>Jepsen suggests that NATS change the default value for <code>fsync</code> to <code>always</code>, rather than every two minutes. Alternatively, NATS documentation should prominently disclose that JetStream may lose data when nodes experience correlated power failure, or fail in rapid succession (<a href="https://github.com/nats-io/nats-server/issues/7564">#7564</a>).</p>
<h2 data-number="3.5" id="a-single-os-crash-can-cause-split-brain-7567"> A Single OS Crash Can Cause Split-Brain (#7567)</h2>
<p>In response to #7564, NATS engineers <a href="https://github.com/nats-io/nats-server/issues/7564">noted</a> that most production deployments run with each node in a separate availability zone, which reduces the probability of correlated failure. This raises the question: how many power failures (or hardware faults, kernel crashes, etc.) are required to cause data loss? Perhaps surprisingly, in an asynchronous network the answer is “just one”.</p>
<p>To understand why, consider that a system which remains partly available when a minority of nodes are unavailable must allow states in which a committed operation is present—solely in memory—on a bare majority of nodes. For example, in a leader-follower protocol the leader of a three-node cluster may consider a write committed as soon as a single follower has responded: it has two acknowledgements, counting itself. Under normal operation there will usually be some window of committed operations in this state.<a href="#fn6" id="fnref6" role="doc-noteref"><sup>6</sup></a>.</p>

<p>Now imagine that one of those two nodes loses power and restarts. Because the write was stored only in memory, rather than on disk, the acknowledged write is no longer present on that node. There now exist two out of three nodes which do <em>not</em> have the write. Since the system is fault-tolerant, these two nodes must be able to form a quorum and continue processing requests—creating new states of the system in which the acknowledged write never happened.</p>
<p>Strictly speaking, this fault requires nothing more than a single power failure (or HW fault, kernel crash, etc.) and an asynchronous network—one which is allowed to deliver messages arbitrarily late. Whether it occurs in practice depends on the specific messages exchanged by the replication system, which node fails, how long it remains offline, the order of message delivery, and so on. However, one can reliably induce data loss by killing, pausing, or partitioning away a minority of nodes before and after a simulated OS crash.</p>
<p>For example, process pauses and a single simulated power failure in <a href="https://github.com/user-attachments/files/23638240/20251119T155654.398-0600.zip">this test run</a> caused JetStream to lose acknowledged writes for windows roughly on par with <code>sync_interval</code>. Stranger still, the cluster entered a persistent split-brain which continued after all nodes were restarted and the network healed. Consider these two plots of lost writes, based on final reads performed against nodes <code>n1</code> and <code>n5</code> respectively:</p>
<p><img src="https://jepsen.io/analyses/nats-2.12.1/single-kill-split-brain-n1.png" alt="A plot of data loss on n1. A few seconds of writes are lost around 42 seconds."/><br/>
</p>
<p><img src="https://jepsen.io/analyses/nats-2.12.1/single-kill-split-brain-n5.png" alt="A plot of data loss on n5. About six seconds of writes are lost at 58 seconds."/><br/>
</p>
<p>Consumers talking to <code>n1</code> failed to observe a short window of acknowledged messages written around 42 seconds into the test. Meanwhile, consumers talking to <code>n5</code> would miss acknowledged messages written around 58 seconds. Both windows of write loss were on the order of our choice of <code>sync_interval = 10s</code> for this run. In repeated testing, we found that any node in the cluster could lose committed writes, including the node which failed, those which received writes before the failure, and those which received writes afterwards.</p>
<p>The fact that a single power failure can cause data loss is not new. In 2023, RedPanda wrote <a href="https://www.redpanda.com/blog/why-fsync-is-needed-for-data-safety-in-kafka-or-non-byzantine-protocols">a detailed blog post</a> showing that Kafka’s default lazy <code>fsync</code> could lead to data loss under exactly this scenario. However, it is especially concerning that this scenario led to persistent replica divergence, not just data loss! We filed <a href="https://github.com/nats-io/nats-server/issues/7567">#7567</a> for this issue, and the NATS team is investigating.</p>
<table>
<thead>
<tr>
<th>№</th>
<th>Summary</th>
<th>Event Required</th>
<th>Fixed in</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/nats-io/nats-server/issues/6888">#6888</a></td>
<td>Stream deleted on crash in 2.10.22</td>
<td>Crashes</td>
<td>2.10.23</td>
</tr>
<tr>
<td><a href="https://github.com/nats-io/nats-server/issues/7549">#7549</a></td>
<td>Lost writes due to <code>.blk</code> file corruption</td>
<td>Minority truncation or bitflip</td>
<td>Unresolved</td>
</tr>
<tr>
<td><a href="https://github.com/nats-io/nats-server/issues/7556">#7556</a></td>
<td>Stream deleted due to snapshot file corruption</td>
<td>Minority truncation or bitflip</td>
<td>Unresolved</td>
</tr>
<tr>
<td><a href="https://github.com/nats-io/nats-server/issues/7564">#7564</a></td>
<td>Write loss due to lazy <code>fsync</code> policy</td>
<td>Coordinated OS crash</td>
<td>Documented</td>
</tr>
<tr>
<td><a href="https://github.com/nats-io/nats-server/issues/7567">#7567</a></td>
<td>Write loss and split-brain</td>
<td>Single OS crash and pause</td>
<td>Unresolved</td>
</tr>
</tbody>
</table>

<p>In NATS 2.10.22, process crashes could cause JetStream to forget a stream ever existed (#6888). This issue was identified independently by NATS and resolved in version 2.10.23, released on 2024-12-10. We did not observe data loss with simple network partitions, process pauses, or crashes in version 2.12.1.</p>
<p>However, we found that in NATS 2.12.1, file corruption and simulated OS crashes could both lead to data loss and persistent split-brain. Bitflips or truncation of either <code>.blk</code> (#7549) or snapshot (#7556) files, even on a minority of nodes, could cause the loss of single messages, large windows of messages, or even cause some nodes to delete their stream data altogether. Messages could be missing on some nodes and present on others. NATS has multiple checksum mechanisms designed to limit the impact of file corruption; more thorough testing of these mechanisms seems warranted.</p>
<p>By default, NATS only flushes data to disk every two minutes, but acknowledges operations immediately. This approach can lead to the loss of committed writes when several nodes experience a power failure, kernel crash, or hardware fault concurrently—or in rapid succession (#7564). In addition, a single OS crash combined with process crashes, pauses, or network partitions can cause the loss of acknowledged messages and persistent split-brain (#7567). We recommended NATS change the default value of <code>fsync</code> to <code>always</code>, or clearly document these hazards. NATS has <a href="https://github.com/nats-io/nats.docs/pull/896">added new documentation</a> to the <a href="https://docs.nats.io/nats-concepts/jetstream#persistent-and-consistent-distributed-storage">JetStream Concepts page</a>.</p>
<p>This documentation <a href="https://docs.nats.io/nats-concepts/jetstream#goals">also describes</a> several goals for JetStream, including that “[t]he system must self-heal and always be available.” This is impossible: the CAP theorem states that Linearizable systems cannot be totally available in an asynchronous network. In our three and five-node clusters JetStream generally behaved like a typical Raft implementation. Operations proceeded on a majority of connected nodes but isolated nodes were unavailable, and if a majority failed, the system as a whole became unavailable. Jepsen suggests clarifying this part of the documentation.</p>
<p>As always, Jepsen takes an experimental approach to safety verification: we can prove the presence of bugs, but not their absence. While we make extensive efforts to find problems, we cannot prove correctness.</p>
<h2 data-number="4.1" id="lazyfs"> LazyFS</h2>
<p>This work demonstrates that systems which do not exhibit data loss under normal process crashes (e.g. <code>kill -9 &lt;PID&gt;</code>) may lose data or enter split-brain under simulated OS-level crashes. Our tests relied heavily on <a href="https://github.com/dsrhaslab/lazyfs">LazyFS</a>, a project of <a href="https://www.inesctec.pt/en">INESC TEC</a> at the University of Porto.<a href="#fn7" id="fnref7" role="doc-noteref"><sup>7</sup></a> After killing a process, we used LazyFS to simulate the effects of a power failure by dropping writes to the filesystem which had not yet been <code>fsync</code>ed to disk.</p>
<p>While this work focused purely on the loss of unflushed writes, LazyFS can also simulate linear and non-linear torn writes: an anomaly where a storage device persists part, but not all, of written data thanks to (e.g.) IO cache reordering. Our 2024 paper <a href="https://www.vldb.org/pvldb/vol17/p3017-ramos.pdf">When Amnesia Strikes</a> discusses these faults in more detail, highlighting bugs in PostgreSQL, Redis, ZooKeeper, etcd, LevelDB, PebblesDB, and the Lightning Network.</p>
<h2 data-number="4.2" id="future-work"> Future Work</h2>
<p>We designed only a simple workload for NATS which checked for lost records either across all consumers, or across all consumers bound to a single node. We did not check whether single consumers could miss messages, or the order in which they were delivered. We did not check NATS’ claims of Linearizable writes or Serializable operations in general. We also did not evaluate JetStream’s “exactly-once semantics”. All of these could prove fruitful avenues for further tests.</p>
<p>In some tests, we <a href="https://github.com/jepsen-io/nats/blob/4760f97f86350c5c9983478656dbcbcdade33817/src/jepsen/nats/nemesis.clj#L67-L263">added and removed</a> nodes from the cluster. This work <a href="https://github.com/nats-io/nats-server/issues/7545">generated some preliminary results</a>. However, the NATS documentation for membership changes was incorrect and incomplete: it gave <a href="https://github.com/nats-io/nats.docs/pull/893">the wrong command</a> for removing peers, and there appears to be an undocumented but mandatory <a href="https://github.com/nats-io/nats-server/issues/7545#issuecomment-3528168499">health check step</a> for newly-added nodes. As of this writing, Jepsen is unsure how to safely add or remove nodes to a NATS cluster. Consequently, we leave membership changes for future research.</p>
<p><em>Our thanks to <a href="https://www.inesctec.pt/en">INESC TEC</a> and everyone on the LazyFS team, including Maria Ramos, João Azevedo, José Pereira, Tânia Esteves, Ricardo Macedo, and João Paulo. Jepsen is also grateful to Silvia Botros, Kellan Elliott-McCrea, Carla Geisser, Coda Hale, and Marc Hedlund for their expertise regarding datacenter power failures, correlated kernel panics, disk faults, and other causes of OS-level crashes. Finally, our thanks to <a href="https://www.irenekannyo.com/">Irene Kannyo</a> for her editorial support. This research was performed independently by Jepsen, without compensation, and conducted in accordance with the <a href="https://jepsen.io/analyses/ethics">Jepsen ethics policy</a>.</em></p>

  </div>
</article></div>
  </body>
</html>
