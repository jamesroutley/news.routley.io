<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://facebookincubator.github.io/clangir/">Original</a>
    <h1>Clang IR (CIR): A New IR for Clang</h1>
    
    <div id="readability-page-1" class="page"><div>
      
      
      

      

<p>Clang IR (CIR) is a new IR for Clang. The <a href="https://discourse.llvm.org/t/rfc-an-mlir-based-clang-ir-cir/63319">LLVM’s discourse RFC</a> goes in depth about
the project motivation, status and design choices.</p>

<p>The source of truth for CIR is found at
<a href="https://github.com/facebookincubator/clangir">https://github.com/facebookincubator/clangir</a>.</p>

<p>The <a href="https://github.com/facebookincubator/clangir/tree/main">main</a> branch
contains a stack of commits, occasionally rebased on top of LLVM upstream,
tracked in
<a href="https://github.com/facebookincubator/clangir/tree/latest-upstream-llvm">latest-upstream-llvm</a>
branch.</p>

<ul id="markdown-toc">
  <li><a href="#clang-ir-cir" id="markdown-toc-clang-ir-cir">Clang IR (CIR)</a></li>
  <li><a href="#getting-started" id="markdown-toc-getting-started">Getting started</a>    <ul>
      <li><a href="#git-repo" id="markdown-toc-git-repo">Git repo</a></li>
      <li><a href="#remote" id="markdown-toc-remote">Remote</a></li>
    </ul>
  </li>
  <li><a href="#building" id="markdown-toc-building">Building</a>    <ul>
      <li><a href="#running-tests" id="markdown-toc-running-tests">Running tests</a></li>
    </ul>
  </li>
  <li><a href="#how-to-contribute" id="markdown-toc-how-to-contribute">How to contribute</a></li>
  <li><a href="#documentation" id="markdown-toc-documentation">Documentation</a>    <ul>
      <li><a href="#operations" id="markdown-toc-operations">Operations</a>        <ul>
          <li><a href="#ciralloca-mlircirallocaop" id="markdown-toc-ciralloca-mlircirallocaop"><code>cir.alloca</code> (::mlir::cir::AllocaOp)</a>            <ul>
              <li><a href="#attributes" id="markdown-toc-attributes">Attributes:</a></li>
              <li><a href="#results" id="markdown-toc-results">Results:</a></li>
            </ul>
          </li>
          <li><a href="#cirbinop-mlircirbinop" id="markdown-toc-cirbinop-mlircirbinop"><code>cir.binop</code> (::mlir::cir::BinOp)</a>            <ul>
              <li><a href="#attributes-1" id="markdown-toc-attributes-1">Attributes:</a></li>
              <li><a href="#operands" id="markdown-toc-operands">Operands:</a></li>
              <li><a href="#results-1" id="markdown-toc-results-1">Results:</a></li>
            </ul>
          </li>
          <li><a href="#cirbrcond-mlircirbrcondop" id="markdown-toc-cirbrcond-mlircirbrcondop"><code>cir.brcond</code> (::mlir::cir::BrCondOp)</a>            <ul>
              <li><a href="#operands-1" id="markdown-toc-operands-1">Operands:</a></li>
              <li><a href="#successors" id="markdown-toc-successors">Successors:</a></li>
            </ul>
          </li>
          <li><a href="#cirbr-mlircirbrop" id="markdown-toc-cirbr-mlircirbrop"><code>cir.br</code> (::mlir::cir::BrOp)</a>            <ul>
              <li><a href="#operands-2" id="markdown-toc-operands-2">Operands:</a></li>
              <li><a href="#successors-1" id="markdown-toc-successors-1">Successors:</a></li>
            </ul>
          </li>
          <li><a href="#circast-mlircircastop" id="markdown-toc-circast-mlircircastop"><code>cir.cast</code> (::mlir::cir::CastOp)</a>            <ul>
              <li><a href="#attributes-2" id="markdown-toc-attributes-2">Attributes:</a></li>
              <li><a href="#operands-3" id="markdown-toc-operands-3">Operands:</a></li>
              <li><a href="#results-2" id="markdown-toc-results-2">Results:</a></li>
            </ul>
          </li>
          <li><a href="#circmp-mlircircmpop" id="markdown-toc-circmp-mlircircmpop"><code>cir.cmp</code> (::mlir::cir::CmpOp)</a>            <ul>
              <li><a href="#attributes-3" id="markdown-toc-attributes-3">Attributes:</a></li>
              <li><a href="#operands-4" id="markdown-toc-operands-4">Operands:</a></li>
              <li><a href="#results-3" id="markdown-toc-results-3">Results:</a></li>
            </ul>
          </li>
          <li><a href="#circst-mlircirconstantop" id="markdown-toc-circst-mlircirconstantop"><code>cir.cst</code> (::mlir::cir::ConstantOp)</a>            <ul>
              <li><a href="#attributes-4" id="markdown-toc-attributes-4">Attributes:</a></li>
              <li><a href="#results-4" id="markdown-toc-results-4">Results:</a></li>
            </ul>
          </li>
          <li><a href="#cirget_global-mlircirgetglobalop" id="markdown-toc-cirget_global-mlircirgetglobalop"><code>cir.get_global</code> (::mlir::cir::GetGlobalOp)</a>            <ul>
              <li><a href="#attributes-5" id="markdown-toc-attributes-5">Attributes:</a></li>
              <li><a href="#results-5" id="markdown-toc-results-5">Results:</a></li>
            </ul>
          </li>
          <li><a href="#cirglobal-mlircirglobalop" id="markdown-toc-cirglobal-mlircirglobalop"><code>cir.global</code> (::mlir::cir::GlobalOp)</a>            <ul>
              <li><a href="#attributes-6" id="markdown-toc-attributes-6">Attributes:</a></li>
            </ul>
          </li>
          <li><a href="#cirif-mlircirifop" id="markdown-toc-cirif-mlircirifop"><code>cir.if</code> (::mlir::cir::IfOp)</a>            <ul>
              <li><a href="#operands-5" id="markdown-toc-operands-5">Operands:</a></li>
            </ul>
          </li>
          <li><a href="#cirload-mlircirloadop" id="markdown-toc-cirload-mlircirloadop"><code>cir.load</code> (::mlir::cir::LoadOp)</a>            <ul>
              <li><a href="#attributes-7" id="markdown-toc-attributes-7">Attributes:</a></li>
              <li><a href="#operands-6" id="markdown-toc-operands-6">Operands:</a></li>
              <li><a href="#results-6" id="markdown-toc-results-6">Results:</a></li>
            </ul>
          </li>
          <li><a href="#cirloop-mlircirloopop" id="markdown-toc-cirloop-mlircirloopop"><code>cir.loop</code> (::mlir::cir::LoopOp)</a>            <ul>
              <li><a href="#attributes-8" id="markdown-toc-attributes-8">Attributes:</a></li>
            </ul>
          </li>
          <li><a href="#cirptr_stride-mlircirptrstrideop" id="markdown-toc-cirptr_stride-mlircirptrstrideop"><code>cir.ptr_stride</code> (::mlir::cir::PtrStrideOp)</a>            <ul>
              <li><a href="#operands-7" id="markdown-toc-operands-7">Operands:</a></li>
              <li><a href="#results-7" id="markdown-toc-results-7">Results:</a></li>
            </ul>
          </li>
          <li><a href="#cirreturn-mlircirreturnop" id="markdown-toc-cirreturn-mlircirreturnop"><code>cir.return</code> (::mlir::cir::ReturnOp)</a>            <ul>
              <li><a href="#operands-8" id="markdown-toc-operands-8">Operands:</a></li>
            </ul>
          </li>
          <li><a href="#cirscope-mlircirscopeop" id="markdown-toc-cirscope-mlircirscopeop"><code>cir.scope</code> (::mlir::cir::ScopeOp)</a>            <ul>
              <li><a href="#results-8" id="markdown-toc-results-8">Results:</a></li>
            </ul>
          </li>
          <li><a href="#cirstore-mlircirstoreop" id="markdown-toc-cirstore-mlircirstoreop"><code>cir.store</code> (::mlir::cir::StoreOp)</a>            <ul>
              <li><a href="#operands-9" id="markdown-toc-operands-9">Operands:</a></li>
            </ul>
          </li>
          <li><a href="#cirstruct_element_addr-mlircirstructelementaddr" id="markdown-toc-cirstruct_element_addr-mlircirstructelementaddr"><code>cir.struct_element_addr</code> (::mlir::cir::StructElementAddr)</a>            <ul>
              <li><a href="#attributes-9" id="markdown-toc-attributes-9">Attributes:</a></li>
              <li><a href="#operands-10" id="markdown-toc-operands-10">Operands:</a></li>
              <li><a href="#results-9" id="markdown-toc-results-9">Results:</a></li>
            </ul>
          </li>
          <li><a href="#cirswitch-mlircirswitchop" id="markdown-toc-cirswitch-mlircirswitchop"><code>cir.switch</code> (::mlir::cir::SwitchOp)</a>            <ul>
              <li><a href="#attributes-10" id="markdown-toc-attributes-10">Attributes:</a></li>
              <li><a href="#operands-11" id="markdown-toc-operands-11">Operands:</a></li>
            </ul>
          </li>
          <li><a href="#ciryield-mlirciryieldop" id="markdown-toc-ciryield-mlirciryieldop"><code>cir.yield</code> (::mlir::cir::YieldOp)</a>            <ul>
              <li><a href="#attributes-11" id="markdown-toc-attributes-11">Attributes:</a></li>
              <li><a href="#operands-12" id="markdown-toc-operands-12">Operands:</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#passes" id="markdown-toc-passes">Passes</a>        <ul>
          <li><a href="#-cir-lifetime-check-check-lifetime-safety-and-generate-diagnostics" id="markdown-toc--cir-lifetime-check-check-lifetime-safety-and-generate-diagnostics"><code>-cir-lifetime-check</code>: Check lifetime safety and generate diagnostics</a>            <ul>
              <li><a href="#options" id="markdown-toc-options">Options</a></li>
            </ul>
          </li>
          <li><a href="#-cir-merge-cleanups-remove-unnecessary-branches-to-cleanup-blocks" id="markdown-toc--cir-merge-cleanups-remove-unnecessary-branches-to-cleanup-blocks"><code>-cir-merge-cleanups</code>: Remove unnecessary branches to cleanup blocks</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr/>



<h2 id="git-repo">Git repo</h2>

<div><div><pre><code>$ git clone https://github.com/facebookincubator/clangir.git llvm-project
</code></pre></div></div>

<h2 id="remote">Remote</h2>

<p>Alternatively, one can just add remotes:</p>

<div><div><pre><code>$ cd llvm-project
$ git remote add fbi git@github.com:facebookincubator/clangir.git
$ git checkout -b clangir fbi/main
</code></pre></div></div>



<p>In order to enable CIR related functionality, just add <code>mlir</code>
and <code>clang</code> to the CMake list of <em>enabled projects</em> and do a regular
LLVM build.</p>

<div><div><pre><code>... -DLLVM_ENABLE_PROJECTS=&#34;clang;mlir;...&#34; ...
</code></pre></div></div>

<p>See the <a href="https://llvm.org/docs/GettingStarted.html#local-llvm-configuration">steps
here</a> for
general instruction on how to build LLVM.</p>

<p>For example, building and installing CIR enabled clang on macOS could look like:</p>

<div><div><pre><code>CLANG=`xcrun -f clang`
INSTALLDIR=/tmp/install-llvm

$ cd llvm-project/llvm
$ mkdir build-release; cd build-release
$ /Applications/CMake.app/Contents/bin/cmake -GNinja \
 -DCMAKE_BUILD_TYPE=Release \
 -DCMAKE_INSTALL_PREFIX=${INSTALLDIR} \
 -DLLVM_ENABLE_ASSERTIONS=ON \
 -DLLVM_TARGETS_TO_BUILD=&#34;X86&#34; \
 -DLLVM_ENABLE_PROJECTS=&#34;clang;mlir&#34; \
 -DCMAKE_CXX_COMPILER=${CLANG}++ \
 -DCMAKE_C_COMPILER=${CLANG} ../
$ ninja install
</code></pre></div></div>

<p>Check for <code>cir-tool</code> to confirm all is fine:</p>

<div><div><pre><code>$ /tmp/install-llvm/bin/cir-tool --help
</code></pre></div></div>

<h2 id="running-tests">Running tests</h2>

<p>Test are an important part on preventing regressions and covering new feature
functionality. There are multiple ways to run CIR tests.</p>

<p>The more aggresive (slower) one:</p>


<p>CIR specific test targets using ninja:</p>
<div><div><pre><code>$ ninja check-clang-cir
$ ninja check-clang-cir-codegen
</code></pre></div></div>

<p>Using <code>lit</code> from build directory:</p>

<div><div><pre><code>$ cd build
$ ./bin/llvm-lit -a ../clang/test/CIR
</code></pre></div></div>

<hr/>



<p>Any change to the project should be done over github pull requests, anyone is welcome to contribute!</p>

<hr/>



<h2 id="operations">Operations</h2>
<!-- Autogenerated by mlir-tblgen; don't manually edit -->
<h3 id="ciralloca-mlircirallocaop"><code>cir.alloca</code> (::mlir::cir::AllocaOp)</h3>

<p>Defines a scope-local variable</p>

<p>Syntax:</p>

<div><div><pre><code>operation ::= `cir.alloca` $type `,` `cir.ptr` type($addr) `,` `[` $name `,` $init `]` attr-dict
</code></pre></div></div>

<p>The <code>cir.alloca</code> operation defines a scope-local variable.</p>

<p>Initialization style must be one of:</p>
<ul>
  <li>uninitialized</li>
  <li>paraminit: alloca to hold a function argument</li>
  <li>callinit: Call-style initialization (C++98)</li>
  <li>cinit: C-style initialization with assignment</li>
  <li>listinit: Direct list-initialization (C++11)</li>
</ul>

<p>The result type is a pointer to the input’s type.</p>

<p>Example:</p>

<pre><code>// int count = 3;
%0 = cir.alloca i32, !cir.ptr&lt;i32&gt;, [&#34;count&#34;, cinit] {alignment = 4 : i64}

// int *ptr;
%1 = cir.alloca !cir.ptr&lt;i32&gt;, cir.ptr &lt;!cir.ptr&lt;i32&gt;&gt;, [&#34;ptr&#34;, uninitialized] {alignment = 8 : i64}
...
</code></pre>

<h4 id="attributes">Attributes:</h4>

<table>
  <thead>
    <tr>
      <th>Attribute</th>
      <th>MLIR Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>type</code></td>
      <td>::mlir::TypeAttr</td>
      <td>any type attribute</td>
    </tr>
    <tr>
      <td><code>name</code></td>
      <td>::mlir::StringAttr</td>
      <td>string attribute</td>
    </tr>
    <tr>
      <td><code>init</code></td>
      <td>::mlir::cir::InitStyleAttr</td>
      <td>initialization style</td>
    </tr>
    <tr>
      <td><code>alignment</code></td>
      <td>::mlir::IntegerAttr</td>
      <td>64-bit signless integer attribute whose minimum value is 0</td>
    </tr>
  </tbody>
</table>

<h4 id="results">Results:</h4>

<table>
  <thead>
    <tr>
      <th>Result</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>addr</code></td>
      <td>CIR pointer type</td>
    </tr>
  </tbody>
</table>

<h3 id="cirbinop-mlircirbinop"><code>cir.binop</code> (::mlir::cir::BinOp)</h3>

<p>Binary operations (arith and logic)</p>

<p>Syntax:</p>

<div><div><pre><code>operation ::= `cir.binop` `(` $kind `,` $lhs `,` $rhs  `)` `:` type($lhs) attr-dict
</code></pre></div></div>

<p>cir.binop performs the binary operation according to
the specified opcode kind: [mul, div, rem, add, sub, shl,
shr, and, xor, or].</p>

<p>It requires two input operands and has one result, all types
should be the same.</p>

<pre><code>%7 = binop(add, %1, %2) : i32
%7 = binop(mul, %1, %2) : i8
</code></pre>

<p>Traits: SameOperandsAndResultType, SameTypeOperands</p>

<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>

<p>Effects: MemoryEffects::Effect{}</p>

<h4 id="attributes-1">Attributes:</h4>

<table>
  <thead>
    <tr>
      <th>Attribute</th>
      <th>MLIR Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>kind</code></td>
      <td>::mlir::cir::BinOpKindAttr</td>
      <td>binary operation (arith and logic) kind</td>
    </tr>
  </tbody>
</table>

<h4 id="operands">Operands:</h4>

<table>
  <thead>
    <tr>
      <th>Operand</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>lhs</code></td>
      <td>any type</td>
    </tr>
    <tr>
      <td><code>rhs</code></td>
      <td>any type</td>
    </tr>
  </tbody>
</table>

<h4 id="results-1">Results:</h4>

<table>
  <thead>
    <tr>
      <th>Result</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>result</code></td>
      <td>any type</td>
    </tr>
  </tbody>
</table>

<h3 id="cirbrcond-mlircirbrcondop"><code>cir.brcond</code> (::mlir::cir::BrCondOp)</h3>

<p>Conditional branch</p>

<p>Syntax:</p>

<div><div><pre><code>operation ::= `cir.brcond` $cond
              $destTrue (`(` $destOperandsTrue^ `:` type($destOperandsTrue) `)`)?
              `,`
              $destFalse (`(` $destOperandsFalse^ `:` type($destOperandsFalse) `)`)?
              attr-dict
</code></pre></div></div>

<p>The <code>cir.brcond %cond, ^bb0, ^bb1</code> branches to ‘bb0’ block in case
%cond (which must be a !cir.bool type) evaluates to true, otherwise
it branches to ‘bb1’.</p>

<p>Example:</p>

<pre><code>  ...
    cir.brcond %a, ^bb3, ^bb4
  ^bb3:
    cir.return
  ^bb4:
    cir.yield
</code></pre>

<p>Traits: SameVariadicOperandSize, Terminator</p>

<p>Interfaces: BranchOpInterface, NoSideEffect (MemoryEffectOpInterface)</p>

<p>Effects: MemoryEffects::Effect{}</p>

<h4 id="operands-1">Operands:</h4>

<table>
  <thead>
    <tr>
      <th>Operand</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>cond</code></td>
      <td>CIR bool type</td>
    </tr>
    <tr>
      <td><code>destOperandsTrue</code></td>
      <td>any type</td>
    </tr>
    <tr>
      <td><code>destOperandsFalse</code></td>
      <td>any type</td>
    </tr>
  </tbody>
</table>

<h4 id="successors">Successors:</h4>

<table>
  <thead>
    <tr>
      <th>Successor</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>destTrue</code></td>
      <td>any successor</td>
    </tr>
    <tr>
      <td><code>destFalse</code></td>
      <td>any successor</td>
    </tr>
  </tbody>
</table>

<h3 id="cirbr-mlircirbrop"><code>cir.br</code> (::mlir::cir::BrOp)</h3>

<p>Unconditional branch</p>

<p>Syntax:</p>

<div><div><pre><code>operation ::= `cir.br` $dest (`(` $destOperands^ `:` type($destOperands) `)`)? attr-dict
</code></pre></div></div>

<p>The <code>cir.br</code> branches unconditionally to a block. Used to represent C/C++
goto’s and general block branching.</p>

<p>Example:</p>

<pre><code>  ...
    cir.br ^bb3
  ^bb3:
    cir.return
</code></pre>

<p>Traits: Terminator</p>

<p>Interfaces: BranchOpInterface, NoSideEffect (MemoryEffectOpInterface)</p>

<p>Effects: MemoryEffects::Effect{}</p>

<h4 id="operands-2">Operands:</h4>

<table>
  <thead>
    <tr>
      <th>Operand</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>destOperands</code></td>
      <td>any type</td>
    </tr>
  </tbody>
</table>

<h4 id="successors-1">Successors:</h4>

<table>
  <thead>
    <tr>
      <th>Successor</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>dest</code></td>
      <td>any successor</td>
    </tr>
  </tbody>
</table>

<h3 id="circast-mlircircastop"><code>cir.cast</code> (::mlir::cir::CastOp)</h3>

<p>Conversion between values of different types</p>

<p>Syntax:</p>

<div><div><pre><code>operation ::= `cir.cast` `(` $kind `,` $src `:` type($src) `)`
              `,` type($result) attr-dict
</code></pre></div></div>

<p>Apply C/C++ usual conversions rules between values. Currently supported kinds:</p>

<ul>
  <li><code>int_to_bool</code></li>
  <li><code>array_to_ptrdecay</code></li>
  <li><code>integral</code></li>
</ul>

<p>This is effectively a subset of the rules from
<code>llvm-project/clang/include/clang/AST/OperationKinds.def</code>; but note that some
of the conversions aren’t implemented in terms of <code>cir.cast</code>, <code>lvalue-to-rvalue</code>
for instance is modeled as a regular <code>cir.load</code>.</p>

<pre><code>%4 = cir.cast (int_to_bool, %3 : i32), !cir.bool
...
%x = cir.cast(array_to_ptrdecay, %0 : !cir.ptr&lt;!cir.array&lt;i32 x 10&gt;&gt;), !cir.ptr&lt;i32&gt;
</code></pre>

<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>

<p>Effects: MemoryEffects::Effect{}</p>

<h4 id="attributes-2">Attributes:</h4>

<table>
  <thead>
    <tr>
      <th>Attribute</th>
      <th>MLIR Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>kind</code></td>
      <td>::mlir::cir::CastKindAttr</td>
      <td>cast kind</td>
    </tr>
  </tbody>
</table>

<h4 id="operands-3">Operands:</h4>

<table>
  <thead>
    <tr>
      <th>Operand</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>src</code></td>
      <td>any type</td>
    </tr>
  </tbody>
</table>

<h4 id="results-2">Results:</h4>

<table>
  <thead>
    <tr>
      <th>Result</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>result</code></td>
      <td>any type</td>
    </tr>
  </tbody>
</table>

<h3 id="circmp-mlircircmpop"><code>cir.cmp</code> (::mlir::cir::CmpOp)</h3>

<p>Compare values two values and produce a boolean result</p>

<p>Syntax:</p>

<div><div><pre><code>operation ::= `cir.cmp` `(` $kind `,` $lhs `,` $rhs  `)` `:` type($lhs) `,` type($result) attr-dict
</code></pre></div></div>

<p><code>cir.cmp</code> compares two input operands of the same type and produces a
<code>cir.bool</code> result. The kinds of comparison available are:
[lt,gt,ge,eq,ne]</p>

<pre><code>%7 = cir.cmp(gt, %1, %2) : i32, !cir.bool
</code></pre>

<p>Traits: SameTypeOperands</p>

<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>

<p>Effects: MemoryEffects::Effect{}</p>

<h4 id="attributes-3">Attributes:</h4>

<table>
  <thead>
    <tr>
      <th>Attribute</th>
      <th>MLIR Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>kind</code></td>
      <td>::mlir::cir::CmpOpKindAttr</td>
      <td>compare operation kind</td>
    </tr>
  </tbody>
</table>

<h4 id="operands-4">Operands:</h4>

<table>
  <thead>
    <tr>
      <th>Operand</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>lhs</code></td>
      <td>any type</td>
    </tr>
    <tr>
      <td><code>rhs</code></td>
      <td>any type</td>
    </tr>
  </tbody>
</table>

<h4 id="results-3">Results:</h4>

<table>
  <thead>
    <tr>
      <th>Result</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>result</code></td>
      <td>any type</td>
    </tr>
  </tbody>
</table>

<h3 id="circst-mlircirconstantop"><code>cir.cst</code> (::mlir::cir::ConstantOp)</h3>

<p>Defines a CIR constant</p>

<p>Syntax:</p>

<div><div><pre><code>operation ::= `cir.cst` `(` custom&lt;ConstantValue&gt;($value) `)` attr-dict `:` type($res)
</code></pre></div></div>

<p>The <code>cir.cst</code> operation turns a literal into an SSA value. The data is
attached to the operation as an attribute.</p>

<pre><code>  %0 = cir.cst(42 : i32) : i32
  %1 = cir.cst(4.2 : f32) : f32
  %2 = cir.cst(nullptr : !cir.ptr&lt;i32&gt;) : !cir.ptr&lt;i32&gt;
</code></pre>

<p>Traits: ConstantLike</p>

<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>

<p>Effects: MemoryEffects::Effect{}</p>

<h4 id="attributes-4">Attributes:</h4>

<table>
  <thead>
    <tr>
      <th>Attribute</th>
      <th>MLIR Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>value</code></td>
      <td>::mlir::Attribute</td>
      <td>any attribute</td>
    </tr>
  </tbody>
</table>

<h4 id="results-4">Results:</h4>

<table>
  <thead>
    <tr>
      <th>Result</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>res</code></td>
      <td>any type</td>
    </tr>
  </tbody>
</table>

<h3 id="cirget_global-mlircirgetglobalop"><code>cir.get_global</code> (::mlir::cir::GetGlobalOp)</h3>

<p>Get the address of a global variable</p>

<p>Syntax:</p>

<div><div><pre><code>operation ::= `cir.get_global` $name `:` `cir.ptr` type($addr) attr-dict
</code></pre></div></div>

<p>The <code>cir.get_global</code> operation retrieves the address pointing to a
named global variable. If the global variable is marked constant, writing
to the resulting address (such as through a <code>cir.store</code> operation) is
undefined. Resulting type must always be a <code>!cir.ptr&lt;...&gt;</code> type.</p>

<p>Example:</p>

<pre><code>%x = cir.get_global @foo : !cir.ptr&lt;i32&gt;
</code></pre>

<p>Interfaces: NoSideEffect (MemoryEffectOpInterface), SymbolUserOpInterface</p>

<p>Effects: MemoryEffects::Effect{}</p>

<h4 id="attributes-5">Attributes:</h4>

<table>
  <thead>
    <tr>
      <th>Attribute</th>
      <th>MLIR Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>name</code></td>
      <td>::mlir::FlatSymbolRefAttr</td>
      <td>flat symbol reference attribute</td>
    </tr>
  </tbody>
</table>

<h4 id="results-5">Results:</h4>

<table>
  <thead>
    <tr>
      <th>Result</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>addr</code></td>
      <td>CIR pointer type</td>
    </tr>
  </tbody>
</table>

<h3 id="cirglobal-mlircirglobalop"><code>cir.global</code> (::mlir::cir::GlobalOp)</h3>

<p>Declares or defines a global variable</p>

<p>Syntax:</p>

<div><div><pre><code>operation ::= `cir.global` ($sym_visibility^)?
              (`constant` $constant^)?
              $sym_name
              custom&lt;GlobalOpTypeAndInitialValue&gt;($sym_type, $initial_value)
              attr-dict
</code></pre></div></div>

<p>The <code>cir.global</code> operation declares or defines a named global variable.</p>

<p>The backing memory for the variable is allocated statically and is
described by the type of the variable.</p>

<p>The operation is a declaration if no <code>inital_value</code> is
specified, else it is a definition.</p>

<p>The global variable can also be marked constant using the
<code>constant</code> unit attribute. Writing to such constant global variables is
undefined.</p>

<p>Symbol visibility is defined in terms of MLIR’s visibility, and C/C++
linkage types are still TBD.</p>

<p>Example:</p>

<pre><code>// Public and constant variable with initial value.
cir.global public constant @c : i32 = 4;
</code></pre>

<p>Interfaces: Symbol</p>

<h4 id="attributes-6">Attributes:</h4>

<table>
  <thead>
    <tr>
      <th>Attribute</th>
      <th>MLIR Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>sym_name</code></td>
      <td>::mlir::StringAttr</td>
      <td>string attribute</td>
    </tr>
    <tr>
      <td><code>sym_visibility</code></td>
      <td>::mlir::StringAttr</td>
      <td>string attribute</td>
    </tr>
    <tr>
      <td><code>sym_type</code></td>
      <td>::mlir::TypeAttr</td>
      <td>any type attribute</td>
    </tr>
    <tr>
      <td><code>initial_value</code></td>
      <td>::mlir::Attribute</td>
      <td>any attribute</td>
    </tr>
    <tr>
      <td><code>constant</code></td>
      <td>::mlir::UnitAttr</td>
      <td>unit attribute</td>
    </tr>
    <tr>
      <td><code>alignment</code></td>
      <td>::mlir::IntegerAttr</td>
      <td>64-bit signless integer attribute</td>
    </tr>
  </tbody>
</table>

<h3 id="cirif-mlircirifop"><code>cir.if</code> (::mlir::cir::IfOp)</h3>

<p>The if-then-else operation</p>

<p>The <code>cir.if</code> operation represents an if-then-else construct for
conditionally executing two regions of code. The operand is a <code>cir.bool</code>
type.</p>

<p>Examples:</p>

<pre><code>cir.if %b  {
  ...
} else {
  ...
}

cir.if %c  {
  ...
}

cir.if %c  {
  ...
  cir.br ^a
^a:
  cir.yield
}
</code></pre>

<p><code>cir.if</code> defines no values and the ‘else’ can be omitted. <code>cir.yield</code> must
explicitly terminate the region if it has more than one block.</p>

<p>Traits: AutomaticAllocationScope, NoRegionArguments, RecursiveSideEffects</p>

<p>Interfaces: RegionBranchOpInterface</p>

<h4 id="operands-5">Operands:</h4>

<table>
  <thead>
    <tr>
      <th>Operand</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>condition</code></td>
      <td>CIR bool type</td>
    </tr>
  </tbody>
</table>

<h3 id="cirload-mlircirloadop"><code>cir.load</code> (::mlir::cir::LoadOp)</h3>

<p>Load value from memory adddress</p>

<p>Syntax:</p>

<div><div><pre><code>operation ::= `cir.load` (`deref` $isDeref^)? $addr `:` `cir.ptr` type($addr) `,`
              type($result) attr-dict
</code></pre></div></div>

<p><code>cir.load</code> reads a value (lvalue to rvalue conversion) given an address
backed up by a <code>cir.ptr</code> type. A unit attribute <code>deref</code> can be used to
mark the resulting value as used by another operation to dereference
a pointer.</p>

<p>Example:</p>

<pre><code>
// Read from local variable, address in %0.
%1 = cir.load %0 : !cir.ptr&lt;i32&gt;, i32

// Load address from memory at address %0. %3 is used by at least one
// operation that dereferences a pointer.
%3 = cir.load deref %0 : cir.ptr &lt;!cir.ptr&lt;i32&gt;&gt;
</code></pre>

<h4 id="attributes-7">Attributes:</h4>

<table>
  <thead>
    <tr>
      <th>Attribute</th>
      <th>MLIR Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>isDeref</code></td>
      <td>::mlir::UnitAttr</td>
      <td>unit attribute</td>
    </tr>
  </tbody>
</table>

<h4 id="operands-6">Operands:</h4>

<table>
  <thead>
    <tr>
      <th>Operand</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>addr</code></td>
      <td>CIR pointer type</td>
    </tr>
  </tbody>
</table>

<h4 id="results-6">Results:</h4>

<table>
  <thead>
    <tr>
      <th>Result</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>result</code></td>
      <td>any type</td>
    </tr>
  </tbody>
</table>

<h3 id="cirloop-mlircirloopop"><code>cir.loop</code> (::mlir::cir::LoopOp)</h3>

<p>Loop</p>

<p>Syntax:</p>

<div><div><pre><code>operation ::= `cir.loop` $kind
              `(`
              `cond` `:` $cond `,`
              `step` `:` $step
              `)`
              $body
              attr-dict
</code></pre></div></div>

<p><code>cir.loop</code> represents C/C++ loop forms. It defines 3 blocks:</p>
<ul>
  <li><code>cond</code>: region can contain multiple blocks, terminated by regular
<code>cir.yield</code> when control should yield back to the parent, and
<code>cir.yield continue</code> when execution continues to another region.
The region destination depends on the loop form specified.</li>
  <li><code>step</code>: region with one block, containing code to compute the
loop step, must be terminated with <code>cir.yield</code>.</li>
  <li><code>body</code>: region for the loop’s body, can contain an arbitrary
number of blocks.</li>
</ul>

<p>The loop form: <code>for</code>, <code>while</code> and <code>dowhile</code> must also be specified and
each implies the loop regions execution order.</p>

<pre><code>  // while (true) {
  //  i = i + 1;
  // }
  cir.loop while(cond :  {
    cir.yield continue
  }, step :  {
    cir.yield
  })  {
    %3 = cir.load %1 : cir.ptr &lt;i32&gt;, i32
    %4 = cir.cst(1 : i32) : i32
    %5 = cir.binop(add, %3, %4) : i32
    cir.store %5, %1 : i32, cir.ptr &lt;i32&gt;
    cir.yield
  }
</code></pre>

<p>Traits: NoRegionArguments, RecursiveSideEffects</p>

<p>Interfaces: LoopLikeOpInterface, RegionBranchOpInterface</p>

<h4 id="attributes-8">Attributes:</h4>

<table>
  <thead>
    <tr>
      <th>Attribute</th>
      <th>MLIR Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>kind</code></td>
      <td>::mlir::cir::LoopOpKindAttr</td>
      <td>Loop kind</td>
    </tr>
  </tbody>
</table>

<h3 id="cirptr_stride-mlircirptrstrideop"><code>cir.ptr_stride</code> (::mlir::cir::PtrStrideOp)</h3>

<p>Pointer access with stride</p>

<p>Syntax:</p>

<div><div><pre><code>operation ::= `cir.ptr_stride` `(` $base `:` type($base) `,` $stride `:` type($stride) `)`
              `,` type($result) attr-dict
</code></pre></div></div>

<p>Given a base pointer as operand, provides a new pointer after applying
a stride. Currently only used for array subscripts.</p>

<pre><code>%3 = cir.cst(0 : i32) : i32
%4 = cir.ptr_stride(%2 : !cir.ptr&lt;i32&gt;, %3 : i32), !cir.ptr&lt;i32&gt;
</code></pre>

<p>Traits: SameFirstOperandAndResultType</p>

<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>

<p>Effects: MemoryEffects::Effect{}</p>

<h4 id="operands-7">Operands:</h4>

<table>
  <thead>
    <tr>
      <th>Operand</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>base</code></td>
      <td>any type</td>
    </tr>
    <tr>
      <td><code>stride</code></td>
      <td>integer</td>
    </tr>
  </tbody>
</table>

<h4 id="results-7">Results:</h4>

<table>
  <thead>
    <tr>
      <th>Result</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>result</code></td>
      <td>any type</td>
    </tr>
  </tbody>
</table>

<h3 id="cirreturn-mlircirreturnop"><code>cir.return</code> (::mlir::cir::ReturnOp)</h3>

<p>Return from function</p>

<p>Syntax:</p>

<div><div><pre><code>operation ::= `cir.return` ($input^ `:` type($input))? attr-dict
</code></pre></div></div>

<p>The “return” operation represents a return operation within a function.
The operation takes an optional operand and produces no results.
The operand type must match the signature of the function that contains
the operation.</p>

<pre><code>  func @foo() -&gt; i32 {
    ...
    cir.return %0 : i32
  }
</code></pre>

<p>Traits: HasParent&lt;FuncOp, ScopeOp, IfOp, SwitchOp, LoopOp&gt;, Terminator</p>

<h4 id="operands-8">Operands:</h4>

<table>
  <thead>
    <tr>
      <th>Operand</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>input</code></td>
      <td>any type</td>
    </tr>
  </tbody>
</table>

<h3 id="cirscope-mlircirscopeop"><code>cir.scope</code> (::mlir::cir::ScopeOp)</h3>

<p>Represents a C/C++ scope</p>

<p><code>cir.scope</code> contains one region and defines a strict “scope” for all new
values produced within its blocks.</p>

<p>Its region can contain an arbitrary number of blocks but usually defaults
to one. The <code>cir.yield</code> is a required terminator and can be optionally omitted.</p>

<p>A resulting value can also be specificed, though not currently used - together
with <code>cir.yield</code> should be helpful to represent lifetime extension out of short
lived scopes in the future.</p>

<p>Traits: AutomaticAllocationScope, NoRegionArguments, RecursiveSideEffects</p>

<p>Interfaces: RegionBranchOpInterface</p>

<h4 id="results-8">Results:</h4>

<table>
  <thead>
    <tr>
      <th>Result</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>results</code></td>
      <td>any type</td>
    </tr>
  </tbody>
</table>

<h3 id="cirstore-mlircirstoreop"><code>cir.store</code> (::mlir::cir::StoreOp)</h3>

<p>Store value to memory address</p>

<p>Syntax:</p>

<div><div><pre><code>operation ::= `cir.store` $value `,` $addr attr-dict `:` type($value) `,` `cir.ptr` type($addr)
</code></pre></div></div>

<p><code>cir.store</code> stores a value (first operand) to the memory address specified
in the second operand.</p>

<p>Example:</p>

<pre><code>// Store a function argument to local storage, address in %0.
cir.store %arg0, %0 : i32, !cir.ptr&lt;i32&gt;
</code></pre>

<h4 id="operands-9">Operands:</h4>

<table>
  <thead>
    <tr>
      <th>Operand</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>value</code></td>
      <td>any type</td>
    </tr>
    <tr>
      <td><code>addr</code></td>
      <td>CIR pointer type</td>
    </tr>
  </tbody>
</table>

<h3 id="cirstruct_element_addr-mlircirstructelementaddr"><code>cir.struct_element_addr</code> (::mlir::cir::StructElementAddr)</h3>

<p>Get the address of a member of a struct</p>

<p>The <code>cir.struct_element_addr</code> operaration gets the address of a particular
named member from the input struct.</p>

<p>Example:</p>
<pre><code>!22struct2EBar22 = type !cir.struct&lt;&#34;struct.Bar&#34;, i32, i8&gt;
...
%0 = cir.alloca !22struct2EBar22, cir.ptr &lt;!22struct2EBar22&gt;
...
%1 = cir.struct_element_addr %0, &#34;Bar.a&#34;
%2 = cir.load %1 : cir.ptr &lt;int&gt;, int
...
</code></pre>

<h4 id="attributes-9">Attributes:</h4>

<table>
  <thead>
    <tr>
      <th>Attribute</th>
      <th>MLIR Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>member_name</code></td>
      <td>::mlir::StringAttr</td>
      <td>string attribute</td>
    </tr>
  </tbody>
</table>

<h4 id="operands-10">Operands:</h4>

<table>
  <thead>
    <tr>
      <th>Operand</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>struct_addr</code></td>
      <td>CIR pointer type</td>
    </tr>
  </tbody>
</table>

<h4 id="results-9">Results:</h4>

<table>
  <thead>
    <tr>
      <th>Result</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>result</code></td>
      <td>CIR pointer type</td>
    </tr>
  </tbody>
</table>

<h3 id="cirswitch-mlircirswitchop"><code>cir.switch</code> (::mlir::cir::SwitchOp)</h3>

<p>Switch operation</p>

<p>Syntax:</p>

<div><div><pre><code>operation ::= `cir.switch` custom&lt;SwitchOp&gt;(
              $regions, $cases, $condition, type($condition)
              )
              attr-dict
</code></pre></div></div>

<p>The <code>cir.switch</code> operation represents C/C++ switch functionality for
conditionally executing multiple regions of code. The operand to an switch
is an integral condition value.</p>

<p>A variadic list of “case” attribute operands and regions track the possible
control flow within <code>cir.switch</code>. A <code>case</code> must be in one of the following forms:</p>
<ul>
  <li><code>equal, &lt;constant&gt;</code>: equality of the second case operand against the
condition.</li>
  <li><code>anyof, [constant-list]</code>: equals to any of the values in a subsequent
following list.</li>
  <li><code>default</code>: any other value.</li>
</ul>

<p>Each case region must be explicitly terminated.</p>

<p>Examples:</p>

<pre><code>cir.switch (%b : i32) [
  case (equal, 20) {
    ...
    cir.yield break
  },
  case (anyof, [1, 2, 3] : i32) {
    ...
    cir.return ...
  }
  case (default) {
    ...
    cir.yield fallthrough
  }
]
</code></pre>

<p>Traits: AutomaticAllocationScope, NoRegionArguments, RecursiveSideEffects, SameVariadicOperandSize</p>

<p>Interfaces: RegionBranchOpInterface</p>

<h4 id="attributes-10">Attributes:</h4>

<table>
  <thead>
    <tr>
      <th>Attribute</th>
      <th>MLIR Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>cases</code></td>
      <td>::mlir::ArrayAttr</td>
      <td>cir.switch case array attribute</td>
    </tr>
  </tbody>
</table>

<h4 id="operands-11">Operands:</h4>

<table>
  <thead>
    <tr>
      <th>Operand</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>condition</code></td>
      <td>integer</td>
    </tr>
  </tbody>
</table>

<h3 id="ciryield-mlirciryieldop"><code>cir.yield</code> (::mlir::cir::YieldOp)</h3>

<p>Terminate CIR regions</p>

<p>Syntax:</p>

<div><div><pre><code>operation ::= `cir.yield` ($kind^)? ($args^ `:` type($args))? attr-dict
</code></pre></div></div>

<p>The <code>cir.yield</code> operation terminates regions on different CIR operations:
<code>cir.if</code>, <code>cir.scope</code>, <code>cir.switch</code> and <code>cir.loop</code>.</p>

<p>Might yield an SSA value and the semantics of how the values are yielded is
defined by the parent operation. Note: there are currently no uses of
<code>cir.yield</code> with operands - should be helpful to represent lifetime
extension out of short lived scopes in the future.</p>

<p>Optionally, <code>cir.yield</code> can be annotated with extra kind specifiers:</p>
<ul>
  <li><code>break</code>: breaking out of the innermost <code>cir.switch</code> / <code>cir.loop</code> semantics,
cannot be used if not dominated by these parent operations.</li>
  <li><code>fallthrough</code>: execution falls to the next region in <code>cir.switch</code> case list.
Only available inside <code>cir.switch</code> regions.</li>
  <li><code>continue</code>: only allowed under <code>cir.loop</code>, continue execution to the next
loop step.</li>
</ul>

<p>As a general rule, <code>cir.yield</code> must be explicitly used whenever a region has
more than one block and no terminator, or within <code>cir.switch</code> regions not
<code>cir.return</code> terminated.</p>

<p>Example:</p>
<pre><code>cir.if %4 {
  ...
  cir.yield
}

cir.switch (%5) [
  case (equal, 3) {
    ...
    cir.yield fallthrough
  }, ...
]

cir.loop (cond : {...}, step : {...}) {
  ...
  cir.yield continue
}
</code></pre>

<p>Traits: HasParent&lt;IfOp, ScopeOp, SwitchOp, LoopOp&gt;, ReturnLike, Terminator</p>

<h4 id="attributes-11">Attributes:</h4>

<table>
  <thead>
    <tr>
      <th>Attribute</th>
      <th>MLIR Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>kind</code></td>
      <td>::mlir::cir::YieldOpKindAttr</td>
      <td>yield kind</td>
    </tr>
  </tbody>
</table>

<h4 id="operands-12">Operands:</h4>

<table>
  <thead>
    <tr>
      <th>Operand</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>args</code></td>
      <td>any type</td>
    </tr>
  </tbody>
</table>

<h2 id="passes">Passes</h2>
<!-- Autogenerated by mlir-tblgen; don't manually edit -->
<h3 id="-cir-lifetime-check-check-lifetime-safety-and-generate-diagnostics"><code>-cir-lifetime-check</code>: Check lifetime safety and generate diagnostics</h3>
<p>This pass relies on a lifetime analysis pass and uses the diagnostics
mechanism to report to the user. It does not change any code.</p>

<h4 id="options">Options</h4>
<div><div><pre><code>-history : List of history styles to emit as part of diagnostics. Supported styles: {all|null|invalid}
-remarks : List of remark styles to enable as part of diagnostics. Supported styles: {all|pset}
</code></pre></div></div>
<h3 id="-cir-merge-cleanups-remove-unnecessary-branches-to-cleanup-blocks"><code>-cir-merge-cleanups</code>: Remove unnecessary branches to cleanup blocks</h3>
<p>Canonicalize pass is too aggressive for CIR when the pipeline is
used for C/C++ analysis. This pass runs some rewrites for scopes,
merging some blocks and eliminating unnecessary control-flow.</p>


      
      
      
    </div></div>
  </body>
</html>
