<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://joseph.yiasemides.com/posts/what-is-functional-programming">Original</a>
    <h1>What is Functional Programming?</h1>
    
    <div id="readability-page-1" class="page"><div id="post-content">
<p>
What <em>is</em> Functional Programming (FP)?
I didn’t have an answer I was happy with for a long time.
Over the years I discovered that it meant different things to different people, but there was a clear common thread, around which more sophisticated ideas revolved.
So I asked colleagues and folks at the <a href="https://www.recurse.com/">Recurse Center</a> what it meant for them.
I got lots of different answers.
Some of which surprised me.
At the time I settled on “FP is about functions, their inputs, and their outputs”.
That’s it.
Functions consume their inputs and produce an output.
That’s all a Functional Programming Language lets you do.
Specifically, there is no extraneous data.
Only input and output.</p>
<p>
The problem is it’s hard to see how a bigger, more substantial program, is coded that way.
I’d liken it to saying Evolution is about random mutation.
Yes, that’s part of it, but not the whole story.
So much so that it misses the forest for the trees.
Over long stretches of time populations have members with a mutation, some survive, some don’t and if that mutation helped members survive then it’s more likely to live on as descendants inherit that mutation.
That’s a much better description of Evolution.
That’s what I was looking for when it came to FP.
A macroscopic definition or description that fit in with my day to day experience.</p>
<p>
Then, back in 2020, I came across <a href="https://observablehq.com/@visnup/game-of-life#tick">this Game of Life in JS</a>.
If you’re like me, over the years you’ve seen a few examples like these in <a href="https://go.dev/play/p/jibIOKi7wqW">Go</a>, <a href="https://dl.acm.org/doi/pdf/10.5555/273.C1066102">Smalltalk</a> (last page), and <a href="https://dfns.dyalog.com/c_life.htm">APL</a>.
I thought the JS code was amazing!
I’d never seriously considered a set of <code>(x,y)</code> points (living cells) as a representation for <em>Life</em>.
I had always thought of it, and coded it, as a matrix of some sort. <a href="#fn:1" id="fnref:1" title="see footnote">1</a></p>
<p>
Here’s the JS code:</p>

<p>
I got to work reproducing it in Elixir, Phoenix LiveView, and SVG.
I started out from scratch, but I couldn’t get it as neat as the JS code.
So, I copied it into my editor and turned it into Elixir code, construct by construct, so that it resembled the JS original syntactically as much as possible.
Once I had it working I started to rework it into something that felt more like idiomatic functional code in Elixir (to be honest - that first working copy was pretty good).
I’d have never thought it a worthwhile exercise to translate code, construct by construct, from one style to another, but it was.
I reworked the code and a different program unravelled.</p>
<p>
I saw that what was a nested block in JS became nested data in Elixir, nested <code>for</code> loops became nested lists, and nested control structure became nested data-structure.
Variables became functions.
By the end of it I had worked the program into the data.
The difference between Structured Programming (the JS code) and Functional Programming (the Elixir code) became so clear to me.
It’s easy to see this if you compare and contrast the JS above with the Elixir below construct-by-construct.</p>
<p>
Here’s the final code in Elixir:</p>

<p>
The imperative I like to use now is:</p>
<blockquote>
  <p>
Manipulate program data; Don’t manipulate program text. <a href="#fn:2" id="fnref:2" title="see footnote">2</a>  </p>
</blockquote>
<p>
The essence of FP isn’t just about functions, inputs, and outputs.
FP is about representation; Specifically, one representation after the other.
The succession of data; Not a succession of instructions.
A succession of collections; Not a succession of statements.
It’s your application snap-shot by snap-shot; Not step by step.
Now with <em>this</em> idea in mind, it’s much easier to see how a bigger program is coded in a functional style, how it’s pieced together from plain old functions, and just their inputs, and outputs.</p>
<p>
So that was the story of how I found my answer.
In conclusion I want to highlight three learnings:</p>
<ul>
  <li>
    <p>
Representation, as we know, can make a big difference.<a href="#fn:3" id="fnref:3" title="see footnote">3</a>
So goes the adage about data structures being more important than functions, procedures, etc.    </p>
  </li>
  <li>
    <p>
Even after years of looking at a problem; The elegance of the representation above eluded me.
We can miss a great solution over and over again.
Perhaps it’s worth entertaining the seemingly strangest formulations using all the tools at our disposal when we start out.    </p>
  </li>
  <li>
    <p>
Translation can be a valuable way to learn.
I hadn’t thought so because it would detract from getting into the right mindset.
I was wrong.    </p>
  </li>
</ul>
<p>
Some other reading you might enjoy:</p>
<ul>
  <li>
    <p>
<a href="https://codewords.recurse.com/issues/one/an-introduction-to-functional-programming">An introduction to functional programming</a>    </p>
  </li>
  <li>
    <p>
<a href="https://fsharpforfunandprofit.com/posts/designing-with-types-making-illegal-states-unrepresentable/">Making illegal states unrepresentable</a>    </p>
  </li>
  <li>
    <p>
<a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">Parse, don’t validate</a>    </p>
  </li>
</ul>
<div>
  <hr/>
  <ol>
    <li id="fn:1">
<a href="#fnref:1" title="return to article">↩</a>      <p>
That is, an array of arrays, or a list of lists for example.
What we want, in fact, is a sparse array (as my dad pointed out).      </p>
    </li>
    <li id="fn:2">
<a href="#fnref:2" title="return to article">↩</a>      <p>
<a href="https://www.evalapply.org/index.html">Aditya Athalye</a> kindly pointed out that in some languages, like Lisp, data can be code and code can be data and manipulated as such.
That’s not what I mean here.      </p>
    </li>
    <li id="fn:3">
<a href="#fnref:3" title="return to article">↩</a>      <p>
I haven’t compared this code to any of my historical code in Elixir that uses a list of lists, or similar representations, but it did make a difference to how much fun this was!      </p>
    </li>
  </ol>
</div>

  </div></div>
  </body>
</html>
