<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/Articles/917280/">Original</a>
    <h1>The return of lazy imports for Python</h1>
    
    <div id="readability-page-1" class="page"><div>
<center>
           <div><b>Did you know...?</b><p>LWN.net is a subscriber-supported publication; we rely on subscribers
       to keep the entire operation going.  Please help out by <a href="https://lwn.net/subscribe/">buying a subscription</a> and keeping LWN on the
       net.</p></div>
           </center>
           
<p>
Back in September, we <a href="https://lwn.net/Articles/907226/">looked</a> at a Python
Enhancement Proposal (PEP) to add &#34;lazy&#34; imports to the language; the
execution of such an import would be deferred until its symbols were needed
in order to save program-startup time.  While the problem of startup time
for short-running, often command-line-oriented, tools is widely
acknowledged in the Python community, and the idea of deferring imports is
generally popular, there are concerns about the effect of the feature on
the ecosystem as a whole.  Since our article, the PEP has been revised and
discussed further, but the feature was recently rejected by the steering
council (SC) because of those concerns; that has not completely ended the
quest for lazy 
imports, however.
</p>

<h4>Updated PEP</h4>

<p>
In early October, Germán Méndez Bravo <a href="https://discuss.python.org/t/pep-690-lazy-imports-again/19661">started
a new discussion thread</a> to discuss the updates that had been made to <a href="https://pep-previews.readthedocs.io/pep-0690/">PEP 690</a> (&#34;Lazy
Imports&#34;).  He and co-author Carl Meyer &#34;<q>have (hopefully) considered and
addressed each and all of the suggestions in the previous discussion
thread, by either providing rejection reasons or improving the API and
implementation</q>&#34;.  They updated the reference implementation of the
feature, so that interested developers could try it out.
</p>

<p>
Méndez Bravo also posted <a href="https://discuss.python.org/t/pep-690-lazy-imports-again/19661/4">some
benchmark results</a> that he got when testing three different versions of
the interpreter: vanilla CPython, CPython with lazy imports added but
unused, and CPython using lazy imports.  The idea was to <a href="https://github.com/Kronuz/cpython/blob/lazy_imports-pyperformance/lazy_imports-pyperformance/README.md">measure
the impact 
of the feature on the operation of the interpreter</a>, rather than the gains
that might be found for a particular command-line-program use case.  
He <a href="https://discuss.python.org/t/pep-690-lazy-imports-again/19661/12">summarized</a>
the impact as pretty minimal, with the disabled imports having no
measurable impact versus the vanilla interpreter, while the other two
combinations were only 1% slower.
</p>

<p>
SC member Brett Cannon <a href="https://discuss.python.org/t/pep-690-lazy-imports-again/19661/10">had
some &#34;<q>personal feedback</q>&#34;</a> about the updated proposal.  In his
opinion, 
there are too many ways to enable and disable the feature.  In particular,
he <a href="https://discuss.python.org/t/pep-690-lazy-imports-again/19661/14">found</a>
the <a href="https://github.com/python/peps/blob/9cbe5213bce03e73bdf8289f8f30977e8f9c5465/pep-0690.rst#per-module-opt-in"><tt>enable_lazy_imports_in_module()</tt>
API</a> to be &#34;<q>too magical</q>&#34;.  It was <a href="https://discuss.python.org/t/pep-690-lazy-imports-again/19661/13">meant
for </a><a href="https://scipy.org">SciPy</a> use cases, Méndez Bravo said,
so that individual modules could control their imports without impacting
the rest of an application, but Cannon said that since those modules would
already 
need to be modified, they should be changed to do something more explicit.  The
PEP authors seem to have agreed with that, since that call was <a href="https://github.com/python/peps/commit/e5aa080e52c4651a23caee31bc44c9f91ecfa59b">removed</a>
from 
the final version of the PEP.
</p>

<p>
The conversation then languished for a month before
another SC member, Petr Viktorin, <a href="https://discuss.python.org/t/pep-690-lazy-imports-again/19661/18">picked
the conversation back up</a> in mid-November.  Once again, he was speaking
for himself and not the committee; he had concerns about modifying the
Python <tt>dict</tt> object to support the feature.  Because the PEP
specifies that lazy imports are to be transparent, dictionary lookup is
changed to handle lazy objects that represent modules that have not (yet)
actually been imported, as <a href="https://peps.python.org/pep-0690/#implementation">described in the
Implementation section</a> of the PEP.  The <a href="https://peps.python.org/pep-0690/#rationale">Rationale section</a>
explains the intended behavior:
</p><blockquote>
The aim of this feature is to make imports transparently lazy. &#34;Lazy&#34; means
that the import of a module (execution of the module body and addition of
the module object to <tt>sys.modules</tt>) should not occur until the
module (or a 
name imported from it) is actually referenced during
execution. &#34;Transparent&#34; means that besides the delayed import (and
necessarily observable effects of that, such as delayed import side effects
and changes to <tt>sys.modules</tt>), there is no other observable change in
behavior: the imported object is present in the module namespace as normal
and is transparently loaded whenever first used: its status as a &#34;lazy
imported object&#34; is not directly observable from Python or from C extension
code. 
</blockquote>


<p>
The lazy objects are stored in a module&#39;s symbol dictionary
(i.e. <tt>module.__dict__</tt>); in order to ensure that any code that
digs around in the module dictionary cannot expose the lazy objects, the
underlying dictionary code must be changed.  Viktorin was concerned that
the behavior could be an obstacle for dictionary optimizations and features in
the future. Méndez Bravo <a href="https://discuss.python.org/t/pep-690-lazy-imports-again/19661/25">agreed</a>
that there was a bit of complexity added to the dictionary code, but
thought that 
it was manageable—and that doing things that way was better than other
alternatives that had been tried in the <a href="https://github.com/facebookincubator/cinder">Cinder</a> CPython fork
where the lazy imports work began.  Meta was able to achieve up to 70%
reduction in startup times on Python command-line tools using Cinder&#39;s lazy
imports.  
</p>

<h4>PEP rejected</h4>

<p>
On December 2, Gregory P. Smith posted the steering council&#39;s
<a href="https://discuss.python.org/t/pep-690-lazy-imports-again/19661/26">decision</a>
to reject the PEP.  The main reason was the effect that it would have on
the Python user community:
</p>

<blockquote>
But a problem we deem significant when adding lazy imports as a language
feature is that it becomes a split in the community over how imports
work. A need to test code both ways in both traditional and lazy import
setups arises. It creates a divergence between projects who expect and rely
upon import time code execution and those who forbid it. It also introduces
the possibility of unexpected import related exceptions occurring in code
at the time of first use virtually anywhere. Such exceptions could bubble
up from transitive dependency first use in unanticipated places. 
<p>
A world in which Python <i>only</i> supported imports behaving in a lazy manner
would likely be great. But we cannot rewrite history and make that
happen. As we <i>do not</i> envision the Python [language] transitioning to a
world 
where lazy imports are the default, let alone only, import behavior. Thus
introducing this concept would add complexity to our ecosystem. 
</p></blockquote>

<p>
The SC also had some <a href="https://discuss.python.org/t/pep-690-lazy-imports-again/19661/28">concerns
with the implementation</a> described in the PEP, including the changes
needed to the dictionary implementation, but ultimately decided that those
did not matter; the SC would have said &#34;no&#34; even if those problems were
addressed.  To a certain extent, though, the SC rejection opened to the
floodgates to more discussion of the feature.
</p>

<p>
Both <a href="https://discuss.python.org/t/pep-690-lazy-imports-again/19661/29">Guido van Rossum</a> and PEP sponsor <a href="https://discuss.python.org/t/pep-690-lazy-imports-again/19661/32">Barry Warsaw</a>
expressed
disappointment
with the rejection, though both could understand the council&#39;s reasoning
for doing 
so.  Both also noted that the PEP was the best proposal for the feature
that they 
had seen.  As Warsaw put it: &#34;<q>It was the best option so far for solving
a common use case, and one that puts pressure on ecosystems to move away
from Python.</q>&#34; Meyer <a href="https://discuss.python.org/t/pep-690-lazy-imports-again/19661/30">wondered</a>
if there was any appetite for a revised proposal that changed to 
explicitly specifying each use (e.g. <tt>lazy import foo</tt>)
and that created a <tt>dict</tt> subclass to be used for module
dictionaries if they contain lazy imports.  That would address many of the
areas of concern, though it would not really change the
fragmentation issue.
</p>  

<p>
One big question that underlies much of the debate about the feature is
around who should decide whether lazy imports are enabled—or supported.
PEP 690 
envisions application authors enabling lazy imports for the entire
application and opting out of laziness for just the few modules that are
dependent on being eagerly imported.  Back in August, Méndez Bravo <a href="https://discuss.python.org/t/pep-690-lazy-imports/15474/222">described</a>
following that process with code at Instagram (which is where Cinder came
from), where it worked well.
</p>

<p>
But others are not so sure that it is application developers who should be
making 
the determination.  Viktorin <a href="https://discuss.python.org/t/pep-690-lazy-imports-again/19661/39">would
rather see</a> ways for library authors to take advantage of the feature: 
</p><blockquote>
Overall, I think we should make it easier for <i>libraries</i> to use lazy
imports 
themselves, à la SciPy or Mercurial. 
<p>
The current proposal is made for &#34;applications&#34; with tightly controlled set
of dependencies. Those are relatively rare in open-source code, and
closed-source ones don&#39;t have a good way to report bugs that only appear in
a specific setup back to the libraries they&#39;re using. And the libraries
can&#39;t test things themselves very well. 
</p></blockquote>


<p>
Adding explicit <tt>lazy</tt> syntax to the import sites would allow
libraries to slowly 
opt into the feature.  The PEP <a href="https://peps.python.org/pep-0690/#explicit-syntax-for-individual-lazy-imports">rejected</a>
that approach, but he thought the reasons might be specific to the
Meta/Instagram use case. &#34;<q>Porting to explicit lazy imports, library by
library, would take time and effort, but might eventually give better
results ecosystem-wide.</q>&#34; Doing so would also allow the implementation
to avoid some of the problem areas:
</p><blockquote>
With explicit lazy imports, we could get away with rougher side effects,
avoiding too much magic. Dicts could focus on being containers. Code that
needs too much introspection or dynamic features simply wouldn&#39;t opt in. 
</blockquote>


<p>
There is <a href="https://discuss.python.org/t/pep-690-lazy-imports-again/19661/41">concern</a> that library maintainers will be pressured to support lazy
imports of their library, however.  Warsaw wondered if adding explicit
&#34;<tt>eager import</tt>&#34; syntax would help library maintainers avoid
that pressure, but Viktorin <a href="https://discuss.python.org/t/pep-690-lazy-imports-again/19661/49">did
not think</a> it would change anything:
</p><blockquote>
Lazy imports need to be tested, and to be generally useful (outside big
apps with rigid dependency chains), they should be tested in individual
library test suites. There&#39;ll be demand for testing, maintenance, mental
overhead around the fact that your library can be imported in two different
ways. 
</blockquote>


<p>
That is, of course, already the case, since imports can already be deferred
in various ways.  Since there is no direct language support for delaying
imports, however, that leaves it up to the user of a library, which is part
of what Warsaw liked in the PEP:
</p><blockquote>
What I liked about the PEP was that it (at least attempted) to put the
burden on the application developer, which is where I think the majority of
the responsibility lies. For example, if I turned on implicit lazy imports
in my Python CLI, and I found that one of my dependencies can&#39;t be lazily
imported, I think I&#39;d report the issue (or file a PR) to the dependency,
but then I&#39;d just eager-ify the import and my CLI would be none the worse
off. 
</blockquote> 


<p>
But, as Cannon <a href="https://discuss.python.org/t/pep-690-lazy-imports-again/19661/43">noted</a>,
it is important to consider both the application and the library when
looking at doing a lazy import:
</p><blockquote>
The tricky bit with lazy imports as a concept is both the code doing the
import and code being imported are affected. Right now there&#39;s no handshake
in both directions saying both sides of this &#34;transaction&#34; agree that lazy
imports are a good thing. You almost need the code being lazily imported to
opt into the <i>possibility</i>, and then the person doing the importing saying
they want those semantics. 
</blockquote>


<p>
Meyer <a href="https://discuss.python.org/t/pep-690-lazy-imports-again/19661/45">did
not think</a> that having libraries opt into being lazily imported made
sense, however.  If 
<tt>lazy import foo</tt> is shallow, where only <tt>foo</tt> itself is
lazily imported and not any of the imports it contains (unless specified as
<tt>lazy</tt> in 
<tt>foo</tt>), then the feature is &#34;<q>effectively just syntactic (and
maybe performance) sugar for manually inlining the import, which is already
possible and not infrequently done</q>&#34;. The PEP gives an example of the manual
inlining that he mentions:
</p><pre>    # regular import
    import foo

    def func1():
	return foo.bar()

    def func2():
	return foo.baz()

    # manually inlined
    def func1():
	import foo
	return foo.bar()

    def func2():
	import foo
	return foo.baz()
</pre><p>

In the second case, </p><tt>foo</tt><p> will not actually be imported until one of
the functions is called.  At that point, any imports in </p><tt>foo</tt><p> will
be processed (eagerly) as well.
Meyer also <a href="https://discuss.python.org/t/pep-690-lazy-imports-again/19661/46">listed
some reasons</a> why he thinks it makes sense to add the syntactic
sugar. For one, 
manual inlining is verbose (&#34;<q>Sometimes syntactic sugar tastes
sweet</q>&#34;), but also:
</p><blockquote>
Manual inlining invokes the import system every time the function is
called, which has a noticeable cost. The PEP 690 approach reduces this
overhead to zero, after the initial reference that triggers the import. 
</blockquote>


<p>
It is not entirely clear where things go from here.  The discussion has
largely tailed off as of this writing, but it is a feature that
some find useful.  The performance and memory-saving benefits that Méndez
Bravo reported are certainly eye opening.  Finding some way to bring those
benefits to all Python users, without fracturing the
ecosystem, would definitely be welcome.  Perhaps the explicit approach will
gain some more traction—and a PEP of its own—before too long.
</p></div></div>
  </body>
</html>
