<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.hillelwayne.com/post/np-hard/">Original</a>
    <h1>NP-Complete isn&#39;t (always) Hard</h1>
    
    <div id="readability-page-1" class="page"><article lang="en">
    

    
    

    <div>
  

<p>A common assumption I see on the ‘net is that NP-complete problems are impossible to solve. I recently read that dependency management in Python is hard because package resolution is NP-complete. This is true in principle, but the reality is more complicated. When we say “NP-complete is hard” we’re talking about <em>worst-case complexity</em>, and the average-case complexity is often much more tractable. Many industry problems are “well-behaved” and modern SAT solvers can solve them quickly.</p>

<p>Okay I’ve probably lost 40% of my readers by this point so let’s back up and explain “NP-complete” and “SAT solver” and stuff.</p>

<h3 id="terms-terms-terms">Terms terms terms</h3>

<p>(If you’re not familiar with computational complexity and O(n) and what “solvable in polynomial time” means, <a href="https://stackoverflow.com/a/487278">this is a pretty good overview</a>.)</p>

<p><dfn>NP</dfn>
 is the set of all problems that are solvable in polynomial time by a “nondeterministic Turing Machine” (NTM). Very roughly, that’s a TM that, when faced with a choice, can create parallel timelines and try a different choice in each timeline. This is equivalent to the set of all problems that can be <em>verified</em> in polynomial time, which is the definition most non-CS people learn.</p>

<p>All problems in P are also in NP. It’s an open question whether NP problems <em>can’t</em> be solved in deterministic polynomial time,  aka the <a href="https://en.wikipedia.org/wiki/P_versus_NP_problem">P=NP problem</a>. If P!=NP, then some NP problems are harder than others. There’s also an upper bound to “how hard” an NP problem can be. This set of “most difficult” NP programs (which again, <em>might</em> just be P) form the <dfn>NP-complete</dfn>
 complexity class. There are also problems that can’t even be <em>verified</em> in polynomial time. <dfn>NP-hard</dfn>
 is the set of all problems that are NP-complete <em>or harder</em>. People often conflate NP-complete and NP-hard.</p>

<p>The quintessential NP-complete problem is <dfn>Boolean SATisfiability</dfn>
, or SAT. A SAT problem consists of a set of boolean variables and a set of clauses, like this:</p>

<pre><code>A | C
!A | D | !E
B | !D | E | F
…
</code></pre>

<p>The goal is to find an assignment of variables that makes <em>every</em> clause true. Checking an answer is obviously in P: just plug the proposed assignments into the clauses and see if they all pass. We don’t have a polynomial time algorithm for finding assignments, though, and mathematicians are confident there isn’t one. It’s NP-complete. By the <a href="https://en.wikipedia.org/wiki/NP-completeness">Cook-Levin Theorem</a>, any other NP-complete problem can be converted into a SAT problem, and in fact “convert NP-complete problem to SAT” is in P.</p>

<p>That’s a lot of words about why NP-complete <em>is</em> hard, so let’s talk about why it <em>isn’t</em>.</p>

<h3 id="why-it-s-not-hard">Why it’s not hard</h3>

<p>When we talk about computational complexity, we’re almost always talking about worst-case complexity. The <em>hardest-possible</em> SAT problem with 19,203 variables will take twice-ish as long to solve as the <em>hardest-possible</em> SAT problem with 19,202 variables.</p>

<p>However, this says nothing about the <em>average</em> problem. Imagine if 99.99% of SAT problems could be solved instantly, while the remaining 0.01% took exponential time. Then SAT would still be considered NP-complete, even though the “typical” case was trivially solvable.</p>

<p>Of course life isn’t that easy and randomly generated SAT problems tend to be intractable. But a lot of industrial problems map to the subset of SAT problems that <em>are</em> tractable (<em>why</em> this is <a href="https://www.cs.rice.edu/~vardi/papers/SATSolvers21.pdf">is an open question</a>), meaning you can some pretty big gains from making fast SAT solvers. <em>In principle</em>, that’s all you need to realistically solve NP-complete problems. Any NP-complete problem can be converted to SAT, and since most industrial problems are well-behaved, this means that solving NP-complete problems is often quite viable.</p>

<h3 id="walking-the-walk">Walking the walk</h3>

<p>I grabbed one SAT solver, <a href="https://www.labri.fr/perso/lsimon/research/glucose/">Glucose</a>, and tried it on a Sudoku, from my <a href="https://www.hillelwayne.com/post/sudoku/">how to solve Sudoku satire</a>. That has 729 variables with 12,000 clauses, and Glucose could solve it in a tenth of a second.</p>

<p>Next, I downloaded the <a href="http://sat-race-2019.ciirc.cvut.cz/">SAT Race 2019</a> problems and picked out a typical example. <code>CarSequencing-90-02_c18</code> is an example of the “Car Sequencing” problem, which is described and shown to be NP-complete in <a href="https://easychair.org/publications/open/JXzd">this paper</a>. This particular problem has 48,491 variables and 550,000 clauses, so we’d expect it to take about <code>1.4^47762</code> times longer, well above the lifetime of the universe. But Glucose finds a solution in just 25 seconds.</p>

<p>On the other hand, the problem <code>58bits_dimacs</code> (I <em>think</em> it’s an integer factorization problem?) has just 1,019 variables and 23,771 clauses. I let it run overnight and it didn’t finish. Checking the <a href="http://sat-race-2019.ciirc.cvut.cz/index.php?cat=results">scoreboard</a>, only 4 out of 55 SAT solvers were able to solve it in under two hours. That’s closer to a worst-case scenario where the blowup is exponential. RSA is still safe!</p>

<table>
<thead>
<tr>
<th>Problem</th>
<th>Variable Ratio</th>
<th>Clause Rat.</th>
<th>Time Rat.</th>
<th>Time/Var</th>
</tr>
</thead>

<tbody>
<tr>
<td>Sudoku</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>

<tr>
<td>Car Sequencing</td>
<td>66</td>
<td>46</td>
<td>250</td>
<td>4</td>
</tr>

<tr>
<td>58bits</td>
<td>1.4</td>
<td>2</td>
<td>&gt;500,000</td>
<td>&gt;500,000</td>
</tr>
</tbody>
</table>

<h3 id="so-why-aren-t-we-using-sat-solvers">So Why Aren’t We Using SAT Solvers?</h3>

<p>When I started this post, I thought that SAT solvers were widely used in package dependency management. Turns out they’re not! Most dependency resolution uses <a href="https://github.com/dart-lang/pub/blob/master/doc/solver.md">PubGrub</a> or an ad-hoc solver. Why is that?</p>

<p>I have four guesses:</p>

<ol>
<li>Converting problems to SAT is intellectually difficult. I felt real clever when I figured out how to convert Sudoku, but I wouldn’t be able to convert much else without a lot more experience.</li>
<li>Converting problems introduces overhead. SAT clauses are a restrictive format, so you have to add lots of auxiliary booleans to track various aspects of your original problem. And there’s often several ways to convert a problem to SAT with different performance characteristics. The Car Sequencing folk came up with three different conversions, and none were strictly “the best”.</li>
<li>Dedicated solvers can exploit properties in the problem domain that are lost by conversion to SAT. <a href="https://web.mit.edu/15.053/www/AMP-Chapter-09.pdf">Integer Programming</a> is an NP-complete problem but solvers just work with problems directly.</li>
<li>Often you want to pull metadata from the problem, like return which specific dependency requirements conflict. That’s a lot harder to do (if at all possible) after you’ve converted to SAT.</li>
</ol>

<h2 id="further-reading">Further Reading</h2>

<p>If you’re interested in learning more about SAT solvers:</p>

<ul>
<li><a href="https://homes.cs.washington.edu/~emina/blog/2017-06-23-a-primer-on-sat.html">A Primer on Boolean Satisfiability</a></li>
<li><a href="https://sat-smt.codes/SAT_SMT_by_example.pdf">SAT/SMT by Example</a> (pdf)</li>
<li><a href="https://simons.berkeley.edu/talks/using-sat-solvers-prevent-causal-failures-cloud">Using SAT Solvers to Prevent Causal Failures in the Cloud</a></li>
<li><a href="https://satcompetition.github.io/">SAT competitions</a></li>
<li><a href="https://codingnest.com/modern-sat-solvers-fast-neat-underused-part-1-of-n/">Modern SAT solvers: fast, neat and underused</a></li>
</ul>

<p>If you’re interested in learning more about NP-completeness:</p>

<ul>
<li><a href="https://complexityzoo.net/Complexity_Zoo">Complexity zoo</a></li>
<li><a href="https://scottaaronson.blog/?p=1720">The Scientific Case for P≠NP</a></li>
</ul>

<p><em>Thanks to <a href="http://alexkoppel.com/">Alex Koppel</a> and <a href="http://www.jameskoppel.com/">Jimmy Koppel</a> (no relation) for feedback.</em></p>


</div>

    



  </article></div>
  </body>
</html>
