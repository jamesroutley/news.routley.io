<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pvs-studio.com/en/blog/posts/csharp/1074/">Original</a>
    <h1>What&#39;s new in C# 12: overview</h1>
    
    <div id="readability-page-1" class="page"><div>
                <div>
                    <div>
                        <div>
                            
                                <p><img src="https://cdn.pvs-studio.com/media/media/content_author/Volokhovsky_thm_fix_80x80.png" alt="Konstantin Volohovsky"/>
                                </p>
                            
                            
                        </div>
                        
                            
                        
                    </div>

                    
                    

                    

                    
    <p>It&#39;s mid-fall which means a new version of C# is coming soon. It&#39;s time to find out what updates will soon appear in the language. Although C#12 has fewer features than previous versions, it still has some curious ones.</p>
    <p><img data-src="https://cdn.pvs-studio.com/import/docx/blog/1074_csharp12/image1.png?ver=10-20-2023-09-50-12" width="1600" height="902" alt="1074_csharp12/image1.png" src="https://files.pvs-studio.com/media/dot.png"/></p>
    <h2 id="IDC6037C48B2">Primary constructors</h2>
    <p>Here is one of the most notable quality-of-life enhancements — we can create constructor in the class declaration:</p>
    <pre><code>class Point(int posX, int posY)
{
    private int X = posX;
    private int Y = posY;

    public bool IsInArea(int minX, int maxX, int minY, int maxY)
        =&gt; X &lt;= maxX &amp;&amp; X &gt;= minX &amp;&amp; Y &lt;= maxY &amp;&amp; Y &gt;= minY;
}
// ....
var point = new Point(100, 50);
Console.WriteLine(point.IsInArea(30, 150, 50, 150)); // True</code></pre>
    <p>We have to use the constructor — it replaces an empty constructor by default. Moreover, when we add another constructor, we should also add <em>this(....)</em>:</p>
    <pre><code>class Point(int posX, int posY)
{
    private int X = posX;
    private int Y = posY;
    private Color color;

    public Point(int posX, int posY, Color color) : this(posX, posY)
    {
        this.color = color;
    }

    // ....
}</code></pre>
    <p>Hot topic: now, when we use a standard library, the dependency injection syntax may not be so large.</p>
    <p>Instead of several reps of the same thing:</p>
    <pre><code>public class AuthorizeService
{
    private readonly UserRepository _users;
    private readonly PasswordHasher&lt;User&gt; _hasher;

    public AuthorizeService(UserRepository repository,
                            PasswordHasher&lt;User&gt; hasher)
    {
        _users = repository;
        _hasher = hasher;
    }

    // ....
}</code></pre>
    <p>We can make the code more concise:</p>
    <pre><code>public class AuthorizeService(UserRepository repository, 
                              PasswordHasher&lt;User&gt; hasher)
{
    private readonly UserRepository _users = repository;
    private readonly PasswordHasher&lt;User&gt; _hasher = hasher;

    // ....
}</code></pre>
    <p>Once again, the hustle and bustle goes with this feature. Constructor parameters can be captured not only by fields and properties but by anything at all. So, we can do something like that:</p>
    <pre><code>class Point(int posX, int posY)
{
    private int X { get =&gt; posX; }
    private int Y { get =&gt; posY; }
    
    // ....
}</code></pre>
    <p>Or like that:</p>
    <pre><code>class Point(int posX, int posY)
{
    public (int X, int Y) GetPosition()
        =&gt; (posX, posY);

    public void Move(int dx, int dy)
    {
        posX += dx;
        posY += dy;
    }

    // ....
}</code></pre>
    <p>Or even like that:</p>
    <pre><code>class Point(int posX, int posY)
{
    private int X = posX; // CS9124
    private int Y = posY; // CS9124

    public bool IsInArea(int minX, int maxX, int minY, int maxY)
        =&gt; posX &lt;= maxX &amp;&amp; posX &gt;= minX &amp;&amp; posY &lt;= maxY &amp;&amp; posY &gt;= minY;
}</code></pre>
    <p>Yes, now we can not only inadvertently use a field instead of a property, but we can also use the captured parameter of the constructor instead of a property or field. The compiler will flag such an obvious error as the one above with a warning about parameter capture. Although, we can still use it as a field (but not via the <em>this</em> keyword!):</p>
    <pre><code>class Point(int posX, int posY)
{
    public int X { get =&gt; posX; }
    public int Y { get =&gt; posY; }

    public void Move(int dx, int dy)
    {
        posX += dx;
        posY += dy;
    }

    // ....
}</code></pre>
    <p>The analyzer hasn&#39;t issued any warnings. It gets quite interesting when we replace <em>class </em>with <em>record</em> (where this syntax came from):</p>
    <pre><code>record Point(int posX, int posY)
{
    public int X { get; } = posX;
    public int Y { get; } = posY;

    // ....
}
// ....
var point = new Point(10, 20);
Console.WriteLine(point);
// Point { posX = 10, posY = 20, X = 10, Y = 20 }</code></pre>
    <p>With a simple keystroke, we doubled the properties. This error is unlikely to be frequent, but the mere (very) chance of making it is unpleasant.</p>
    <p>The first case has a compiler warning, but for the second one, the developer should take responsibility for the error. In this case, more specialized tools, like static code analyzers, will help you prevent an error. For example, <a href="https://pvs-studio.com/en/pvs-studio/">PVS-Studio</a> has several hundred diagnostic rules for finding code defects in C#. So, our team certainly study this case.</p>
    <p>Overall, the feature seems very useful, but it can easily confuse developers (especially newcomers).</p>
    <h2 id="ID7304E84C07">The terse syntax to work with collections</h2>
    <p>Let&#39;s continue the topic: how to enhance a developer&#39;s quality of life. Now the syntax to create the collection shouldn&#39;t be as cumbersome as before. Let&#39;s thank the collection expressions for that:</p>
    <pre><code>List&lt;char&gt; empty = [];
List&lt;string&gt; names = [&#34;John&#34;, &#34;Mike&#34;, &#34;Bill&#34;];
int[] numbers = [1, 2, 3, 4, 5];</code></pre>
    <p>If you&#39;re experiencing déjà vu — don&#39;t worry. Indeed, there has been a very similar syntax with braces earlier, but it worked only with arrays:</p>
    <pre><code>char[] characters = { &#39;a&#39;, &#39;b&#39;, &#39;c&#39; };
List&lt;char&gt; characters = { &#39;a&#39;, &#39;b&#39;, &#39;c&#39; }; // CS0622</code></pre>
    <p>Multidimensional arrays have also been enhanced (only jagged arrays, though):</p>
    <pre><code>double[][] jagged = [[1.0, 1.5], [2.0, 2.5], [3.0, 3.5, 4.0]];</code></pre>
    <p>The features don&#39;t end with the option to drop the clumsy <em>new</em>. The spread operator &#34;..&#34; makes it possible to concatenate collections:</p>
    <pre><code>Color[] lightPalette = [Color.Orange, Color.Pink, Color.White];
Color[] darkPalette = [Color.Brown, Color.DarkRed, Color.Black];
Color[] mixedPalette = [.. lightPalette,
                        Color.Grey,
                        .. darkPalette];</code></pre>
    <p>You&#39;ll have to manually teach your collection to work with this syntax, but it&#39;s no big deal. Just add a method, that takes <em>ReadOnlySpan </em>and returns an instance of its own class, then add the <em>CollectionBuilder</em> attribute to the class:</p>
    <pre><code>[CollectionBuilder(typeof(IdCache), nameof(Create))]
public class IdCache : IEnumerable&lt;int&gt;
{
    private readonly int[] _cache = new int[50];
    public IEnumerator&lt;int&gt; GetEnumerator()
        =&gt; _cache.AsEnumerable().GetEnumerator();
    IEnumerator IEnumerable.GetEnumerator()
        =&gt; _cache.GetEnumerator();
        
    public static IdCache Create(ReadOnlySpan&lt;int&gt; source)
        =&gt; new IdCache(source);
    public IdCache(ReadOnlySpan&lt;int&gt; source)
    {
        for (var i = 0; i &lt; Math.Min(_cache.Length, source.Length); i++)
            _cache[i] = source[i];
    }
}
// ....
var john = _userRepository.Get(x =&gt; x.UserName == &#34;john&#34;);
var oldUsersIds = _userRepository
    .GetMany(x =&gt; x.RegistrationDate &lt;= DateTime.Parse(&#34;01.01.2020&#34;))
    .Select(x =&gt; x.Id);
IdCache cache = [.. oldUsersIds, john.Id];</code></pre>
    <h2 id="IDE7297010DD">Anonymous function parameters by default</h2>
    <p>C# 12 has introduced another small enhancement for the anonymous functions. Now the lambda parameters can have the value by default:</p>
    <pre><code>var concat = (double x, double y, char delimiter = &#39;,&#39;)
    =&gt; string.Join(delimiter, x.ToString(enUsCulture), y.ToString(enUsCulture));

Console.WriteLine(concat(5.42, 3.17)); // 5.42,3.17
Console.WriteLine(concat(1.0, 9.98, &#39;:&#39;)); // 1:9.98</code></pre>
    <p>In addition, now you can use the <em>params</em> keyword with them:</p>
    <pre><code>var buildCsv = (params User[] users) =&gt;
{
    var sb = new StringBuilder();
    foreach (var user in users)
        sb.AppendLine(string.Join(&#34;,&#34;,
                                  user.FirstName,
                                  user.LastName,
                                  user.Birthday.ToString(&#34;dd.MM.yyyy&#34;)));
    return sb.ToString();
};

// ....
Console.WriteLine(buildCsv(john, mary));
// John,Doe,15.04.1997
// Mary,Sue,28.07.1995</code></pre>
    <h2 id="IDE86848C18C">Alias for any type</h2>
    <p>Starting with C# 12, you can use <em>using</em> to alias any type without limitations. So, if you want to fool around, now you can do it:</p>
    <pre><code>using NullableInt = int?;
using Objects = object[];
using Vector2 = (double X, double Y);
using HappyDebugging = string;</code></pre>
    <p>In many cases, using aliases can play a joke on code (if you&#39;re not working alone :) ). However, there are definitely some helpful use cases. For example, if we had a mess with tuples like this:</p>
    <pre><code>public class Square
{
    // ....
    public (int X, int Y, int Width, int Height) GetBoundaries()
        =&gt; new(X, Y, Width, Height);
    public void SetBoundaries(
        (int X, int Y, int Width, int Height) boundaries) { .... }
}</code></pre>
    <p>We can enhance this code:</p>
    <pre><code>using Boundaries = (int X, int Y, int Width, int Height);
// ....
public class Square
{
    // ....
    public Boundaries GetBoundaries()
        =&gt; new (X, Y, Width, Height);
    public void SetBoundaries(Boundaries boundaries) { .... }
}</code></pre>
    <p>Though, such tuples make us think whether they&#39;re needed or not. However, under certain circumstances (or when we refactor the code), these tuples can enhance readability.</p>
    <p>Please don&#39;t get carried away. If we use the recently added <em>global </em>modifier, we can make the <em>using</em> directive global. This makes it easier to fill everything with tuples (instead of classic data structures).</p>
    <p>I can&#39;t immediately come up with a case where we can use the static analyzer. This means that potential errors will show up later, be subtler, and be harder to find, because there is a problem is in the approach. If you find something interesting, feel free to <a href="https://pvs-studio.com/en/about-feedback/">send</a> code snippets to our team.</p>
    <h2 id="ID7446602B61">The nameof refinement</h2>
    <p>Now the <em>nameof</em> expression can fully capture the instance class members from static methods, initializers, and attributes. There has been a strange limitation before: for example, it allows us to get the name of the class field itself but not its members:</p>
    <pre><code>public class User
{
    [Description($&#34;Address format is {
        nameof(UserAddress.Street)} {nameof(UserAddress.Building)}&#34;)] // CS0120
    Address UserAddress { get; set; }
    // ....
}</code></pre>
    <p>Now there is no such problem, and we can use <em>nameof</em> in all the previously mentioned contexts:</p>
    <pre><code>public class User
{
    [Description($&#34;Address format is {
        nameof(UserAddress.Street)} {nameof(UserAddress.Building)}&#34;)]
    Address UserAddress { get; set; }

    public string AddressFormat { get; } =
           $&#34;{nameof(UserAddress.Street)} {nameof(UserAddress.Building)}&#34;; }

    public static string GetAddressFormat()
        =&gt; $&#34;{nameof(UserAddress.Street)} {nameof(UserAddress.Building)}&#34;;
}</code></pre>
    <h2 id="ID58503668EE">Inline arrays</h2>
    <p>Let&#39;s continue with niche features —useful not to everyone, but still bringing changes to the language. In this case, we&#39;re talking about fixed-size arrays that are placed on the stack in a contiguous memory location. We expect to need them mainly for the AOT compiler and for developers who need to write truly high-performance code. To create such an array, you will need some magic. We need to declare a structure that has a single field that defines the array type. Then, mark it with the <em>InlineArray</em> attribute, which specifies the array size.</p>
    <p>Here&#39;s what it looks like:</p>
    <pre><code>[System.Runtime.CompilerServices.InlineArray(5)]
public struct IntBuffer
{
    private int _element0;
}
// ....
var buf = new IntBuffer();
for (var i = 0; i &lt; 5; i++)
    buf[i] = i;
            
foreach (var e in buf)
    Console.Write(e); // 01234</code></pre>
    <h2 id="ID6DEE8100FD">The code interception</h2>
    <p>The following feature enables us to intercept calls to methods and change their behavior. This feature is available in preview mode with C# 12. The new syntax is appropriate for source generators, so don&#39;t be surprised by its clunkiness:</p>
    <pre><code>var worker = new Worker();
worker.Run(&#34;hello&#34;); // Worker says: hello
worker.Run(&#34;hello&#34;); // Interceptor 1 says: hello
worker.Run(&#34;hello&#34;); // Interceptor 2 says: hello
// ....
class Worker
{
    public void Run(string phrase)
        =&gt; Console.WriteLine($&#34;Worker says: {phrase}&#34;);
}

static class Generated
{
    [InterceptsLocation(&#34;Program.cs&#34;, line: 3, character: 7)]
    public static void Intercept1(this Worker worker, string phrase)
        =&gt; Console.WriteLine($&#34;Interceptor 1 says: {phrase}&#34;);

    [InterceptsLocation(&#34;Program.cs&#34;, line: 4, character: 7)]
    public static void Intercept2(this Worker worker, string phrase)
        =&gt; Console.WriteLine($&#34;Interceptor 2 says: {phrase}&#34;);
}</code></pre>
    <p>We intercept by specifying the <em>InterceptsLocation</em> attribute. It should contain the file name, the string positions, and the character on which the method is called.</p>
    <p>While there&#39;s a benefit to the AOT compiler as well, the focus is on code generation. For example, we can dream of libraries that make working with aspect-oriented programming easier. Unit testing frameworks sound even more tempting — finally, we can stop creating an interface for every class just to mock it in tests. Anyway, the community is very engaged in discussing this topic, which is very pleasant for me.</p>
    <p>In any case, code generators have become an incredibly powerful tool, so the extension of their functionality is wonderful news.</p>
    <h2 id="ID6F8B794F32">Conclusion</h2>
    <p>Although at first glance the list of features doesn&#39;t seem huge (especially if we compare it with previous releases), I&#39;m interested in almost all of them, even if sometimes I have some concerns :). To be honest, I haven&#39;t realized all the changes of the last years, and thoughtfully applied them in real-life circumstances. What do you think about previous updates? Let&#39;s discuss them along with the new C# 12.</p>
    <p>You can learn more about the feature specification in the <a href="https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-12" target="_blank" rel="nofollow">documentation</a>. If you wish to read about the features of the previous C# versions, you can read our previous overview articles here:</p>
<ul>
<li><a href="https://pvs-studio.com/en/blog/posts/csharp/0860/">What&#39;s new in C# 9: overview</a></li>
<li><a href="https://pvs-studio.com/en/blog/posts/csharp/0875/">What&#39;s new in C# 10: overview</a></li>
<li><a href="https://pvs-studio.com/en/blog/posts/csharp/1002/">What&#39;s new in C# 11: overview</a></li>
</ul>
    <p>If you would like to follow me and read about the code quality, subscribe to <a href="https://twitter.com/kvolokhovskii" target="_blank" rel="nofollow">my Twitter</a>, <a href="https://twitter.com/Code_Analysis" target="_blank" rel="nofollow">the PVS-Studio Twitter</a> or the monthly <a href="https://pvs-studio.com/en/subscribe/">digest</a> of our best most recent articles.</p>



                    

                    
                    
                    
                </div>
            </div></div>
  </body>
</html>
