<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.amazingcto.com/simplicity-of-golang-systemd-deployments/">Original</a>
    <h1>The simplicity of single-file Golang deployments</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>I’ve gained some experience with deployments over the last three decades Starting without a VCS, copying files by zip to servers, sharing files by zip and manually tracking changes.</p>
<p>Fast forward some years and we deployed large Java applications with build scripts manually with a release train and release notes. Each release a huge event with coordinating many people in the company. Fast-forward and we were automatically deploying Scala applications from CI bundled in Docker in the startup of my wife.</p>
<p>Last forward and I have deployed a Golang application to a cloud server. The result of the build is one executable. The Go web application had all files like configurations (no credentials), static css and html templates embedded with embedfs (and proxied through a CDN). So no jar or ear files, no npm or pip and no Docker. Just one binary copied to the server, started and monitored with Systemd. Systemd also restarts the app daily to make sure it works properly long term. As Go starts up tremendously fast, and as Systemd is keeping the TCP connections, there is no impact to users.</p>
<p>The build pipleline is simple, deployments are copying a binary file to a server, with Systemd holding connections and restarting the new binary. Systemd is also used to degrade priveliges for the running binary to make it more secure.</p>
<p>Standing here it looks like Docker was invented to manage dependencies for Python, Javascript and Java. It looks strange from a platform that deploys as one single binary.</p>
<p>This one binary feels pure and simple, compared to large NPM or JAR deployments inside a Docker container. It feels manageable and not overwhelmed by complexity. <a href="https://www.radicalsimpli.city/" target="_blank" rel="noreferrer noopener">Radical Simplicity</a></p>
<p>When sharing this on <a href="https://amazingcto.social/@stephan" target="_blank" rel="noreferrer noopener">Mastodon</a>, others chimed in with “yeah, like copy a single file and that’s the command to run”, “I see you are slowly joining the fanclub :)” and “yeah, so nice and simple! I still mostly package in containers for ease of deployment to the cloud, but it’s a pretty thin wrapper.” So I’m not alone with my joy and happyness.</p>
<p>Because the use case is small, we’re using SQLlite - especially the Go version of SQLite. It’s easier to integrate than the C version and easier to your build pipeline, it is just another dependency like every other. Using <a href="https://github.com/superfly/litefs" target="_blank" rel="noreferrer noopener">lifefs</a> for distributing SQLite is on the roadmap.</p>



</div></div>
  </body>
</html>
