<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.veitheller.de/Some_notes_on_architecture_diagrams.html">Original</a>
    <h1>Some notes on architecture diagrams</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>I look at a lot of architecture diagrams. Most of them are not about
systems I personally shepherd, and I have no control over what is
presented to me. But boy, do I have opinions.</p>
<p>In this blog post, I outline some principles I see as immutable,
regardless of system shape, and explain why I hold these beliefs. I
explain what views I—and probably you—need. And finally, we talk a bit
about how to produce them while acknowledging that this is dependent on
which technologies you use.</p>
<p>The point isn’t to generate pretty pictures; in fact, I couldn’t care
less about the layout or color scheme (okay, okay, readability would be
nice). I want truthfulness, not having to memorize a bunch of verbal
addenda and errata when I meet with the architect for the first
time.</p>
<p>The cool thing about these diagrams is that we all want the same
things from them: no matter if you are an architect, an individual
contributor, an auditor, or involved in due diligence, you want to see
data flow, external surface area, network segmentation, data
warehousing, et al. If we do things right, we can use the same diagrams
(or maybe with slight redactions) for onboarding, Architecture Decision
Records, threat modelling and other workshops, and DD and audits.
Wouldn’t that be nice?</p>
<h3 id="some-principles">Some principles</h3>
<p>Below is a quick list of my principles. If you do most of these, we
can be friends (if you don’t, I’ll still be your friend, but I’ll judge
you for your life choices).</p>
<ul>
<li><strong>Generate the data.</strong> The diagram should rely on data,
and the data should be autogenerated. Generate it during CI, export it
from your cloud or hosting provider, do what you need to do to get to
the truth.</li>
<li><strong>Make it text-first.</strong> This makes the diagram diffable
over time. You see what components were added, removed, changed, moved.
It’s awesome.</li>
<li><strong>Timestamp it.</strong> Embed some meta-information (commit
hash, generation time, etc.) in the diagram.</li>
<li><strong>Regenerate it on change.</strong> Whenever the architecture
changes, the diagram has to change. Ideally after CI has run (I always
love to see a <code>doc</code> stage in CI definitions).</li>
<li><strong>Use redactions to make it publishable.</strong> If you want
to share it somewhere, you can redact sensitive information first (easy
when you generate a bunch of data in a sensible format!). This way you
can share it on external documentation or during DDs (thank you!).</li>
<li><strong>Multiple views over the model.</strong> A model can
encapsulate the whole system, but a view cannot. Give me multiple
pictures (see below for a list of views).</li>
</ul>
<p>Now, if we had a tool <a href="https://gtoolkit.com/">that made it
easy and cheap to create views of your system</a>, this would all be so
simple…</p>
<h4 id="some-anti-patterns">Some anti-patterns</h4>
<p>Of course, all principles come with their inverse. Here are some
things I don’t want to see or do:</p>
<ul>
<li><strong>Don’t draw the diagram by hand.</strong> I have no idea how
accurate it truly is, and I always discover some blind spots that erode
trust in the model.</li>
<li><strong>Don’t just commit pictures.</strong> I want the generation
data and metadata, so I can diff things over time.</li>
<li><strong>No one-diagram-to-rule-them-all.</strong> No architecture
can be captured from all angles in one diagram. Generate more than one
(more information in the next section).</li>
<li><strong>Don’t just draw entities.</strong> I need to see data flow
and boundaries to understand the system.</li>
<li><strong>Don’t build it all at once.</strong> I describe a fully
specified system. You don’t need to start with that, though, and you
probably shouldn’t. Start with a simple import from K8s, AWS, or the
like, and iterate from there.</li>
</ul>
<h3 id="the-views-we-both-need">The views we both need</h3>
<p>No matter if we look at the system from the outside or because we
live inside it, we still need the same views. For the purposes of this
blog post, I thought of some snappy names, but I suck at naming, so
you’ll need to go by their description.</p>
<ul>
<li><strong>Context:</strong> external actors, major systems, trust
boundaries.</li>
<li><strong>Container:</strong> services, data stores, queues, external
SaaS.</li>
<li><strong>Component:</strong> internals of the service (for your most
critical services).</li>
<li><strong>Data flow:</strong> data flows, classifications, trust zone
crossings. Think DFD.</li>
<li><strong>Network segmentation:</strong> VPC/VNet, subnets,
SG/NSG/NetworkPolicy edges, ingress/egress points.</li>
<li><strong>Auth flows:</strong> OIDC/OAuth exchanges, token scopes,
service-to-service auth.</li>
<li><strong>Data persistence:</strong> stores, retention, RPO/RTO,
backup/restore, encryption.</li>
<li><strong>Runtime topology:</strong> deployment graph (K8s namespaces,
workloads, ingresses).</li>
</ul>
<p>These first three are essentially the C4 model views, and we just
add some other useful things on top.</p>
<p>I know that some of these are easier to generate than others, and
creating all of these accurately and automatically isn’t always
feasible. This is a best-in-class write-up, and for some systems might
remain aspirational. Try to get as close to it as possible (and then
back off when the asymptotes kick in).</p>
<h5 id="data-sources-and-what-to-generate">Data sources and what to
generate</h5>
<p>Here are some things that might serve as data sources for your
diagrams. These are so specific to technologies used that I won’t even
try to cover all of it. Take these as examples, not as a full list.</p>
<ul>
<li><strong>Infra:</strong> Terraform/Terragrunt plan graphs, cloud
inventory, K8s manifests/resources.</li>
<li><strong>App surface:</strong> OpenAPI/AsyncAPI/gRPC/proto; service
discovery; ingress rules.</li>
<li><strong>Auth:</strong> IdP config (e.g., Keycloak
realms/clients/roles), OPA policies, service RBAC, IAM roles and
rules.</li>
<li><strong>Data:</strong> DB schemas, dbt DAG, lineage
(OpenLineage/Marquez), S3/Bucket inventories.</li>
<li><strong>Runtime:</strong> tracing/telemetry (OpenTelemetry/Jaeger)
to call graphs/sequence diagrams.</li>
<li><strong>Policies:</strong> network policies, security groups,
firewall rules for segmentation views.</li>
</ul>
<p>Hopefully, you won’t need all of these data sources. But whatever you
take, consolidate it into a format of your choice (JSON or YAML are
usually good choices) that is then used by renderers to actually produce
pictures (or Mermaid/PlantUML/whatever diagrams).</p>
<h4 id="a-production-pipeline-sketch">A production pipeline sketch</h4>
<p>I sketched an example GitLab pipeline (full disclosure: I used an LLM
for a lot of this, so you’ll probably have to either fix most of this or
just take it as pseudocode) <a href="https://gist.github.com/hellerve/7c81b5789a3954c437268af7e3948312">in
this gist</a>. It showcases all the steps and generations.</p>
<p>This might seem like a lot (and it is!), but keep in mind that this
is the maximalist approach, and you don’t have to start with the full
package. Start with something simple and work your way up. Build an MVP
in a day and then start iterating (context and data flow are two good
ondes to start with).</p>
<h4 id="metadata-overlays">Metadata overlays</h4>
<p>Some metadata will probably not be captured in these generations. We
either inline the metadata about each service in the diagram, or we link
to the service documentation and/or source inside the diagram.</p>
<p>For each node we need owners, SLAs, data privacy and authZ
information, external dependencies, and so on somewhere. For each edge,
we need protocol, transport, auths, rate, etc. Not all of this should be
inline, it will crowd the diagram. Link to external sources of
information wherever possible.</p>
<h4 id="a-quick-note-on-redactions">A quick note on redactions</h4>
<p>There will be a point in a company’s lifetime when these diagrams
need to be shared externally. Maybe some of them are part of the
external documentation. Maybe they’re being handed over to a potential
buyer or investor.</p>
<p>Some data will then need to be redacted. The nice thing about a data
and model-first approach, though, is that redactions are easy to
implement: they are just filters.</p>
<p>And, since you have multiple views of the system, you can
additionally control sharing by choosing the view. You can throw
out the nitty-gritty like the runtime topology or network segmentation
without any additional work.</p>
<h3 id="fin">Fin</h3>
<p>In this blog post, we looked at how to build useful architecture
diagrams for internal and external use. We talked about principles and
anti-patterns, views and how to create and manage them.</p>
<p>I hope you were able to take something useful away from this blog
post that will elevate the usefulness of your diagrams. They are the
first view into your system, and they are what you’ll see when you close
your eyes to think about your architecture.</p>

      
    </div></div>
  </body>
</html>
