<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://til.simonwillison.net/python/annotated-dataklasses">Original</a>
    <h1>Annotated explanation of David Beazley&#39;s dataklasses</h1>
    
    <div id="readability-page-1" class="page">
<nav>
    <p><a href="https://til.simonwillison.net/">Simon Willisonâ€™s TILs</a></p>
</nav>
<section>



<p>David Beazley <a href="https://twitter.com/dabeaz/status/1472742536649351173" rel="nofollow">on Twitter</a>:</p>
<blockquote>
<p>So, I just published this deliciously evil spin on dataclasses. It&#39;s tiny and the resulting classes import about 15-20 faster than dataclasses.  <a href="https://github.com/dabeaz/dataklasses">https://github.com/dabeaz/dataklasses</a></p>
</blockquote>
<p>I decided to create a heavily annotated version of <a href="https://github.com/dabeaz/dataklasses/blob/78d29d40091eb55d2e0196a9eee9d842b5b82835/dataklasses.py">his original code</a> to figure out for myself how it worked.</p>
<h2>
<a id="user-content-what-this-code-does" href="#what-this-code-does" aria-hidden="true"><span aria-hidden="true"></span></a>What this code does</h2>
<p>It takes this:</p>
<div><pre><span>@<span>dataklass</span></span>
<span>class</span> <span>Coordinates</span>:
    <span>x</span>: <span>int</span>
    <span>y</span>: <span>int</span></pre></div>
<p>And turns it into this:</p>
<div><pre><span>class</span> <span>Coordinates</span>:
    <span>__match_args__</span> <span>=</span> (<span>&#34;x&#34;</span>, <span>&#34;y&#34;</span>)

    <span>def</span> <span>__init__</span>(<span>self</span>, <span>x</span>, <span>y</span>):
        <span>self</span>.<span>x</span> <span>=</span> <span>x</span>
        <span>self</span>.<span>y</span> <span>=</span> <span>y</span>
    
    <span>def</span> <span>__repr__</span>(<span>self</span>):
        <span>return</span> <span>f&#34;Coordinates(<span><span>{</span><span>self</span>.<span>x</span>!r<span>}</span></span>, <span><span>{</span><span>self</span>.<span>y</span>!r<span>}</span></span>)&#34;</span>

    <span>def</span> <span>__eq__</span>(<span>self</span>, <span>other</span>):
        <span>if</span> <span>self</span>.<span>__class__</span> <span>is</span> <span>other</span>.<span>__class__</span>:
            <span>return</span> (<span>self</span>,<span>x</span>, <span>self</span>.<span>y</span>,) <span>==</span> (<span>other</span>.<span>x</span>, <span>other</span>.<span>y</span>,)
        <span>else</span>:
            <span>return</span> <span>NotImplemented</span></pre></div>
<h2>
<a id="user-content-the-key-trick-code-generation" href="#the-key-trick-code-generation" aria-hidden="true"><span aria-hidden="true"></span></a>The key trick: code generation</h2>
<p>The key to understanding how the code works is to understand that it is using code generation. David introspects out the annotated class properties, from the class itself and any superclasses, and then counts how many they are. He then generates methods that look like this:</p>
<div><pre><span>def</span> <span>__init__</span>(<span>self</span>, <span>_0</span>, <span>_1</span>):
    <span>self</span>.<span>_0</span> <span>=</span> <span>_0</span>
    <span>self</span>.<span>_1</span> <span>=</span> <span>_1</span></pre></div>
<p>Then uses the <code>func.__code__.replace(co_names=repl_co_names, co_varnames=repl_co_varnames)</code> method to rename those <code>_0</code> and <code>_1</code> variables back to <code>x</code> and <code>y</code>.</p>
<p>I don&#39;t yet understand why he does this as opposed to generating the code using <code>x</code> and <code>y</code> directly. I&#39;ll update this with an explanation once I find one!</p>
<p>Update: Jacob Kaplan-Moss <a href="https://twitter.com/jacobian/status/1472789373552762884" rel="nofollow">explains it here</a>!</p>
<blockquote>
<p>That&#39;s the absolutely <em>wild</em> trick at the heart of this, and what makes it fast:</p>
<p>the bytecode for <code>__init__(self, x, y)</code> is exactly the same as the bytecode for <code>__init__(self, foo, bar)</code>!</p>
<p>So that means Dave can cache the generated code for for &#34;any <code>__init__</code> function with two args&#34; and then <em>re-use the exact same code</em> for any later 2-arity <code>__init__</code>s!</p>
</blockquote>
<h2>
<a id="user-content-my-annotated-copy" href="#my-annotated-copy" aria-hidden="true"><span aria-hidden="true"></span></a>My annotated copy</h2>
<p>First, including the copyright message as required by the copyright message:</p>
<div><pre><span># dataklasses.py</span>
<span>#</span>
<span>#     https://github.com/dabeaz/dataklasses</span>
<span>#</span>
<span># Author: David Beazley (@dabeaz).</span>
<span>#         http://www.dabeaz.com</span>
<span>#</span>
<span># Copyright (C) 2021-2022.</span>
<span>#</span>
<span># Permission is granted to use, copy, and modify this code in any</span>
<span># manner as long as this copyright message and disclaimer remain in</span>
<span># the source code.  There is no warranty.  Try to use the code for the</span>
<span># greater good.</span></pre></div>
<p>My annotations start here (I also ran it through <a href="https://black.vercel.app/" rel="nofollow">Black</a>).</p>
<div><pre><span>__all__</span> <span>=</span> [<span>&#34;dataklass&#34;</span>]
<span># This ensures &#34;from dataklasses import *&#34; will only import the dataklass symbol</span>

<span>from</span> <span>functools</span> <span>import</span> <span>lru_cache</span>, <span>reduce</span>

<span># This decorator takes a function that returns Python source code and compiles</span>
<span># that into a Python function. So if func(fields) returns the following string:</span>
<span>#</span>
<span># def __init__(self, a):</span>
<span>#     self.a = a</span>
<span>#</span>
<span># The return value will be that compiled function. With some enhancements.</span>
<span>def</span> <span>codegen</span>(<span>func</span>):
    <span># This caches the result so if you pass the same numfields it won&#39;t have to</span>
    <span># carry out the same work twice.</span>
    <span>#</span>
    <span># This is the key performance optimization for this code - it means that</span>
    <span># the same generated code can be reused for any class that has the same</span>
    <span># number of arguments!</span>
    <span>@<span>lru_cache</span></span>
    <span>def</span> <span>make_func_code</span>(<span>numfields</span>):
        <span># numfields in len(fields)</span>
        <span>names</span> <span>=</span> [<span>f&#34;_<span><span>{</span><span>n</span><span>}</span></span>&#34;</span> <span>for</span> <span>n</span> <span>in</span> <span>range</span>(<span>numfields</span>)]
        <span># names is now [&#34;_0&#34;, &#34;_1&#34;, &#34;_2&#34;] depending on numfields</span>
        <span>#</span>
        <span># We call func() with that list of names and exec() the</span>
        <span># returned source code. The third argument to exec() is</span>
        <span># locals() - it&#39;s a dictionary that the exec() function</span>
        <span># will populate with any new symbols.</span>
        <span>#</span>
        <span># We use the d:={} walrus operator here so that we can</span>
        <span># refer to that dictionary by the name d in a moment.</span>
        <span>exec</span>(<span>func</span>(<span>names</span>), <span>globals</span>(), <span>d</span> <span>:=</span> {})
        <span># d.popitem() returns the first (key, value) pair in</span>
        <span># the dictionary. We know that the locals() dictionary</span>
        <span># is only going to have a single symbol in it, because</span>
        <span># we now that the code returned by func(names) only</span>
        <span># defines a single function. So this returns the value</span>
        <span># from the first item in locals(), the function object</span>
        <span>return</span> <span>d</span>.<span>popitem</span>()[<span>1</span>]

    <span># This decorate() is the return value from the decorator,</span>
    <span># which means that the following code:</span>
    <span>#</span>
    <span># @codegen</span>
    <span># def make__init__(fields):</span>
    <span>#     # ...</span>
    <span># Turns make__init__ into the function defined by decorate()</span>
    <span>def</span> <span>decorate</span>(<span>fields</span>):
        <span># As shown above, this uses exec() to compile and return</span>
        <span># a function body created using the generated source code</span>
        <span>func</span> <span>=</span> <span>make_func_code</span>(<span>len</span>(<span>fields</span>))

        <span># But remember: because we cache and reuse method bodies, this has</span>
        <span># ugly _0, _1 parameters and variables that we want to make nicer.</span>

        <span># co_names: tuple of names other than arguments and function locals</span>
        <span>co_names</span> <span>=</span> <span>func</span>.<span>__code__</span>.<span>co_names</span>
        <span># For the Coordinates example, co_names = (&#34;_0&#34;, &#34;_1&#34;)</span>

        <span># co_varnames: tuple of names of arguments and local variables</span>
        <span>co_varnames</span> <span>=</span> <span>func</span>.<span>__code__</span>.<span>co_varnames</span>
        <span># For the Coordinates example, co_varnames = (&#34;self&#34;, &#34;_0&#34;, &#34;_1&#34;)</span>

        <span># We are about to replace co_names and co_varnames with modified</span>
        <span># versions - so we need to create two replacement tuples for them.</span>
        <span>#</span>
        <span># start := co_names.index(&#34;_0&#34;) uses the walrus operator to both</span>
        <span># figure out the 0-based index of the _0 symbol and assign it to s</span>
        <span>#</span>
        <span># We use (*a, *b, *c) to create a new tuple that is the result of</span>
        <span># combining those three input tuples.</span>
        <span>repl_co_names</span> <span>=</span> (
            <span># Slice everything in co_names up to that first _0 symbol</span>
            <span>*</span><span>co_names</span>[: (<span>start</span> <span>:=</span> <span>co_names</span>.<span>index</span>(<span>&#34;_0&#34;</span>))],
            <span># Then insert the fields, which are the annotated class properties</span>
            <span>*</span><span>fields</span>,
            <span># Now everything in co_names following </span>
            <span>*</span><span>co_names</span>[<span>start</span> <span>+</span> <span>len</span>(<span>fields</span>) :],
        )
        <span># For Coordinates this is now (&#34;x&#34;, &#34;y&#34;)</span>

        <span>repl_co_varnames</span> <span>=</span> (
            <span># We only modify co_varnames if _0 is one of them, otherwise</span>
            <span># we leave them unchanged.</span>
            (
                <span>*</span><span>co_varnames</span>[: (<span>start</span> <span>:=</span> <span>co_varnames</span>.<span>index</span>(<span>&#34;_0&#34;</span>))],
                <span>*</span><span>fields</span>,
                <span>*</span><span>co_varnames</span>[<span>start</span> <span>+</span> <span>len</span>(<span>fields</span>) :],
            )
            <span>if</span> <span>&#34;_0&#34;</span> <span>in</span> <span>co_varnames</span>
            <span>else</span> <span>co_varnames</span>
        )
        <span># For Coordinates this is now (&#34;self&#34;, &#34;x&#34;, &#34;y&#34;)</span>

        <span># type(func) returns a Python internal object called &#34;function&#34;</span>
        <span># which is callable and has this function signature:</span>
        <span>#</span>
        <span># function(code, globals, name=None, argdefs=None, closure=None)</span>
        <span>#</span>
        <span># It creates a brand new function object</span>
        <span>return</span> <span>type</span>(<span>func</span>)(
            <span># func.__code__.replace docstring says:</span>
            <span># &#34;Return a copy of the code object with new values for the specified fields&#34;</span>
            <span># So we are rewriting the co_names and co_varnames here</span>
            <span>func</span>.<span>__code__</span>.<span>replace</span>(<span>co_names</span><span>=</span><span>repl_co_names</span>, <span>co_varnames</span><span>=</span><span>repl_co_varnames</span>),
            <span>func</span>.<span>__globals__</span>,
        )

    <span>return</span> <span>decorate</span>


<span>def</span> <span>all_hints</span>(<span>cls</span>):
    <span># This introspects the class to find all of the annotated class members</span>
    <span># In Coordinates case this returns {&#39;x&#39;: &lt;class &#39;int&#39;&gt;, &#39;y&#39;: &lt;class &#39;int&#39;&gt;}</span>
    <span>#</span>
    <span># The &#34;x&#34; to that lambda starts out as that {} empty dictionary and each time</span>
    <span># is the dictionary with new stuff added to it.</span>
    <span>#</span>
    <span># reversed(Coordinates.__mro__) loops through every superclass of the current</span>
    <span># class, starting at &#34;object&#34;.</span>
    <span>#</span>
    <span># So the lambda is called against each superclass in turn, and each time it</span>
    <span># reads the __annotations__ field, if one is available.</span>
    <span>#</span>
    <span># Coordinates.__annotations__ returns {&#39;x&#39;: int, &#39;y&#39;: int}</span>
    <span>#</span>
    <span># dict1 | dict2 in Python returns a new dict that combines the previous two</span>
    <span>#</span>
    <span># So this function returns a combined dictionary of the __annotations__ from</span>
    <span># every class in the superclass hierarchy.</span>
    <span>return</span> <span>reduce</span>(
        <span>lambda</span> <span>x</span>, <span>y</span>: <span>x</span> <span>|</span> <span>getattr</span>(<span>y</span>, <span>&#34;__annotations__&#34;</span>, {}), <span>reversed</span>(<span>cls</span>.<span>__mro__</span>), {}
    )


<span># Next are the functions that generate the different methods. Remember they get passed</span>
<span># fields which is {&#39;x&#39;: &lt;class &#39;int&#39;&gt;, &#39;y&#39;: &lt;class &#39;int&#39;&gt;}</span>
<span>@<span>codegen</span></span>
<span>def</span> <span>make__init__</span>(<span>fields</span>):
    <span># Calling &#34;,&#34;.join(dict) joins just the keys of that dictionary</span>
    <span>code</span> <span>=</span> <span>&#34;def __init__(self, &#34;</span> <span>+</span> <span>&#34;,&#34;</span>.<span>join</span>(<span>fields</span>) <span>+</span> <span>&#34;):<span>\n</span>&#34;</span>
    <span># So here we have:</span>
    <span>#    def __init__(self, x, y):</span>
    <span>return</span> <span>code</span> <span>+</span> <span>&#34;<span>\n</span>&#34;</span>.<span>join</span>(<span>f&#34; self.<span><span>{</span><span>name</span><span>}</span></span> = <span><span>{</span><span>name</span><span>}</span></span><span>\n</span>&#34;</span> <span>for</span> <span>name</span> <span>in</span> <span>fields</span>)
    <span># This adds on:</span>
    <span>#   self.x = x</span>
    <span>#   self.y = y</span>


<span>@<span>codegen</span></span>
<span>def</span> <span>make__repr__</span>(<span>fields</span>):
    <span>return</span> (
        <span>&#34;def __repr__(self):<span>\n</span>&#34;</span>
        <span># type(self).__name__ gives us the class name: &#34;Coordinates&#34;</span>
        <span>&#39; return f&#34;{type(self).__name__}(&#39;</span>
        <span># This gives us {self.x!r}, {self.y!r} which in an f-string</span>
        <span># gives us the __repr__() version of those object properties</span>
        <span>+</span> <span>&#34;, &#34;</span>.<span>join</span>(<span>&#34;{self.&#34;</span> <span>+</span> <span>name</span> <span>+</span> <span>&#34;!r}&#34;</span> <span>for</span> <span>name</span> <span>in</span> <span>fields</span>)
        <span>+</span> <span>&#39;)&#34;<span>\n</span>&#39;</span>
    )
    <span># So this generates:</span>
    <span># def __repr__(self):</span>
    <span>#  return f&#34;Coordinates({self.x!r}, {self.y!r})&#34; </span>


<span>@<span>codegen</span></span>
<span>def</span> <span>make__eq__</span>(<span>fields</span>):
    <span>selfvals</span> <span>=</span> <span>&#34;,&#34;</span>.<span>join</span>(<span>f&#34;self.<span><span>{</span><span>name</span><span>}</span></span>&#34;</span> <span>for</span> <span>name</span> <span>in</span> <span>fields</span>)
    <span>othervals</span> <span>=</span> <span>&#34;,&#34;</span>.<span>join</span>(<span>f&#34;other.<span><span>{</span><span>name</span><span>}</span></span>&#34;</span> <span>for</span> <span>name</span> <span>in</span> <span>fields</span>)
    <span>return</span> (
        <span>&#34;def __eq__(self, other):<span>\n</span>&#34;</span>
        <span>&#34;  if self.__class__ is other.__class__:<span>\n</span>&#34;</span>
        <span>f&#34;    return (<span><span>{</span><span>selfvals</span><span>}</span></span>,) == (<span><span>{</span><span>othervals</span><span>}</span></span>,)<span>\n</span>&#34;</span>
        <span>&#34;  else:<span>\n</span>&#34;</span>
        <span>&#34;    return NotImplemented<span>\n</span>&#34;</span>
    )
    <span># This generates:</span>
    <span># def __eq__(self, other):</span>
    <span>#   if self.__class__ is other.__class__:</span>
    <span>#     return (self,x, self.y,) == (other.x, other.y)</span>
    <span>#   else:</span>
    <span>#     return NotImplemented</span>


<span>@<span>codegen</span></span>
<span>def</span> <span>make__iter__</span>(<span>fields</span>):
    <span>return</span> <span>&#34;def __iter__(self):<span>\n</span>&#34;</span> <span>+</span> <span>&#34;<span>\n</span>&#34;</span>.<span>join</span>(
        <span>f&#34;   yield self.<span><span>{</span><span>name</span><span>}</span></span>&#34;</span> <span>for</span> <span>name</span> <span>in</span> <span>fields</span>
    )


<span>@<span>codegen</span></span>
<span>def</span> <span>make__hash__</span>(<span>fields</span>):
    <span>self_tuple</span> <span>=</span> <span>&#34;(&#34;</span> <span>+</span> <span>&#34;,&#34;</span>.<span>join</span>(<span>f&#34;self.<span><span>{</span><span>name</span><span>}</span></span>&#34;</span> <span>for</span> <span>name</span> <span>in</span> <span>fields</span>) <span>+</span> <span>&#34;,)&#34;</span>
    <span>return</span> <span>&#34;def __hash__(self):<span>\n</span>&#34;</span> <span>f&#34;    return hash(<span><span>{</span><span>self_tuple</span><span>}</span></span>)<span>\n</span>&#34;</span>


<span>def</span> <span>dataklass</span>(<span>cls</span>):
    <span>fields</span> <span>=</span> <span>all_hints</span>(<span>cls</span>)
    <span># fields is now {&#39;x&#39;: &lt;class &#39;int&#39;&gt;, &#39;y&#39;: &lt;class &#39;int&#39;&gt;}</span>
    <span>clsdict</span> <span>=</span> <span>vars</span>(<span>cls</span>)
    <span># clsdict looks like this:</span>
    <span># {&#39;__module__&#39;: &#39;__main__&#39;,</span>
    <span>#  &#39;__annotations__&#39;: {&#39;x&#39;: &lt;class &#39;int&#39;&gt;, &#39;y&#39;: &lt;class &#39;int&#39;&gt;},</span>
    <span>#  &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;Coordinates&#39; objects&gt;,</span>
    <span>#  &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;Coordinates&#39; objects&gt;,</span>
    <span>#  &#39;__doc__&#39;: None}</span>
    <span>#</span>
    <span># The purpose of this function is mainly to add __init__ and</span>
    <span># __repr__ and __eq__ methods, but only if they are not yet defined</span>
    <span>if</span> <span>not</span> <span>&#34;__init__&#34;</span> <span>in</span> <span>clsdict</span>:
        <span>cls</span>.<span>__init__</span> <span>=</span> <span>make__init__</span>(<span>fields</span>)
    <span>if</span> <span>not</span> <span>&#34;__repr__&#34;</span> <span>in</span> <span>clsdict</span>:
        <span>cls</span>.<span>__repr__</span> <span>=</span> <span>make__repr__</span>(<span>fields</span>)
    <span>if</span> <span>not</span> <span>&#34;__eq__&#34;</span> <span>in</span> <span>clsdict</span>:
        <span>cls</span>.<span>__eq__</span> <span>=</span> <span>make__eq__</span>(<span>fields</span>)
    <span># Not sure why these are commented out right now:</span>
    <span># if not &#39;__iter__&#39; in clsdict:  cls.__iter__ = make__iter__(fields)</span>
    <span># if not &#39;__hash__&#39; in clsdict:  cls.__hash__ = make__hash__(fields)</span>
    <span>cls</span>.<span>__match_args__</span> <span>=</span> <span>fields</span>
    <span># This is related to Python structural typing:</span>
    <span># https://www.python.org/dev/peps/pep-0622/#special-attribute-match-args</span>
    <span>return</span> <span>cls</span>


<span># Example use</span>
<span>if</span> <span>__name__</span> <span>==</span> <span>&#34;__main__&#34;</span>:

    <span>@<span>dataklass</span></span>
    <span>class</span> <span>Coordinates</span>:
        <span>x</span>: <span>int</span>
        <span>y</span>: <span>int</span></pre></div>


<p>Created 2021-12-19T20:30:57-08:00, updated 2021-12-19T21:38:45-08:00 Â· <a href="https://github.com/simonw/til/commits/main/python/annotated-dataklasses.md">History</a> Â· <a href="https://github.com/simonw/til/blob/main/python/annotated-dataklasses.md">Edit</a></p>

</section>

</div>
  </body>
</html>
