<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rafalcieslak.wordpress.com/2013/04/02/dynamic-linker-tricks-using-ld_preload-to-cheat-inject-features-and-investigate-programs/">Original</a>
    <h1>Using LD_PRELOAD to cheat, inject features and investigate programs</h1>
    
    <div id="readability-page-1" class="page"><div>
<p><strong>This post assumes some basic C skills.</strong></p>
<p>Linux puts you in full control. This is not always seen from everyone’s perspective, but a power user loves to be in control. I’m going to show you a basic trick that lets you heavily influence the behavior of most applications, which is not only fun, but also, at times, useful.</p>
<h4>A motivational example</h4>
<p>Let us begin with a simple example. Fun first, science later.</p>
<pre title="random_num.c:">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

int main(){
  srand(time(NULL));
  int i = 10;
  while(i--) printf(&#34;%d\n&#34;,rand()%100);
  return 0;
}
</pre>
<p>Simple enough, I believe. I compiled it with no special flags, just</p>
<blockquote>
<pre>gcc random_num.c -o random_num</pre>
</blockquote>
<p>I hope the resulting output is obvious – ten randomly selected numbers 0-99, hopefully different each time you run this program.</p>
<p>Now let’s pretend we don’t really have the source of this executable. Either delete the source file, or move it somewhere – we won’t need it. We will significantly modify this programs behavior, yet without touching it’s source code nor recompiling it.</p>
<p>For this, lets create another simple C file:</p>
<pre title="unrandom.c:">int rand(){
    return 42; //the most random number in the universe
}
</pre>
<p>We’ll compile it into a shared library.</p>
<blockquote>
<pre>gcc -shared -fPIC unrandom.c -o unrandom.so</pre>
</blockquote>
<p>So what we have now is an application that outputs some random data, and a custom library, which implements the rand() function as a constant value of 42.  Now… just run <em>random_num </em>this way, and watch the result:</p>
<blockquote>
<pre>LD_PRELOAD=$PWD/unrandom.so ./random_nums</pre>
</blockquote>
<p>If you are lazy and did not do it yourself (and somehow fail to guess what might have happened), I’ll let you know – the output consists of ten 42’s.</p>

<p><!--more-->This may be even more impressive it you first:</p>
<blockquote>
<pre>export LD_PRELOAD=$PWD/unrandom.so</pre>
</blockquote>
<p>and then run the program normally. An unchanged app run in an apparently usual manner seems to be affected by what we did in our tiny library…</p>
<h6><strong>Wait, what? What did just happen?</strong></h6>
<p>Yup, you are right, our program failed to generate random numbers, because it did not use the “real” rand(), but the one we provided – which returns 42 every time.</p>
<h6><strong>But we *told* it to use the real one. We programmed it to use the real one. Besides, at the time we created that program, the fake rand() did not even exist!</strong></h6>
<p>This is not entirely true. We did not choose which rand() we want our program to use. We told it just to use rand().</p>
<p>When our program is started, certain libraries (that provide functionality needed by the program) are loaded. We can learn which are these using <em>ldd</em>:<em><br/>
</em></p>
<blockquote>
<pre>$ <strong>ldd random_nums</strong>
linux-vdso.so.1 =&gt; (0x00007fff4bdfe000)
libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f48c03ec000)
/lib64/ld-linux-x86-64.so.2 (0x00007f48c07e3000)</pre>
</blockquote>
<p>What you see as the output is the list of libs that are needed by <em>random_nums</em>. This list is built into the executable, and is determined compile time. The exact output might slightly differ on your machine, but a <strong>libc.so</strong> must be there – this is the file which provides core C functionality. That includes the “real” rand().</p>
<p>We can have a peek at what functions does libc provide. I used the following to get a full list:</p>
<blockquote>
<pre>nm -D /lib/libc.so.6</pre>
</blockquote>
<p>The <em>nm</em> command lists symbols found in a binary file. The -D flag tells it to look for dynamic symbols, which makes sense, as libc.so.6 is a dynamic library. The output is very long, but it indeed lists rand() among many other standard functions.</p>
<p>Now what happens when we set up the environmental variable LD_PRELOAD? This variable <strong>forces some libraries to be loaded for a program</strong>. In our case, it loads <em>unrandom.so</em> for <em>random_num</em>, even though the program itself does not ask for it. The following command may be interesting:<em><br/>
</em></p>
<blockquote>
<pre>$ <strong>LD_PRELOAD=$PWD/unrandom.so ldd random_nums</strong>
linux-vdso.so.1 =&gt;  (0x00007fff369dc000)
/some/path/to/unrandom.so (0x00007f262b439000)
libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f262b044000)
/lib64/ld-linux-x86-64.so.2 (0x00007f262b63d000)</pre>
</blockquote>
<p>Note that it lists our custom library. And indeed this is the reason why it’s code get’s executed: <em>random_num</em> calls rand(), but if <em>unrandom.so</em> is loaded it is our library that provides implementation for rand(). Neat, isn’t it?</p>
<h4>Being transparent</h4>
<p>This is not enough. I’d like to be able to inject some code into an application in a similar manner, but in such way that it will be able to function normally. It’s clear if we implemented open() with a simple “<em>return 0;</em>“, the application we would like to hack should malfunction. The point is to be <strong>transparent</strong>, and to actually call the original open:</p>
<pre title="inspect_open.c:">int open(const char *pathname, int flags){
  /* Some evil injected code goes here. */
  return open(pathname,flags); // Here we call the &#34;real&#34; open function, that is provided to us by libc.so
}
</pre>
<p>Hm. Not really. This won’t call the “original” open(…). Obviously, this is an endless recursive call.</p>
<p>How do we access the “real” open function? It is needed to use the programming interface to the dynamic linker. It’s simpler than it sounds. Have a look at this complete example, and then I’ll explain what happens there:</p>
<pre title="inspect_open.c:">#define _GNU_SOURCE
#include &lt;dlfcn.h&gt;

typedef int (*orig_open_f_type)(const char *pathname, int flags);

int open(const char *pathname, int flags, ...)
{
    /* Some evil injected code goes here. */

    orig_open_f_type orig_open;
    orig_open = (orig_open_f_type)dlsym(RTLD_NEXT,&#34;open&#34;);
    return orig_open(pathname,flags);
}

</pre>
<p>The <i>dlfcn.h</i> is needed for <em>dlsym</em> function we use later. That strange <em>#define</em> directive instructs the compiler to enable some non-standard stuff, we need it to enable <em>RTLD_NEXT</em> in <em>dlfcn.h</em>. That typedef is just creating an alias to a complicated pointer-to-function type, with arguments just as the original open – the alias name is <em>orig_open_f_type</em>, which we’ll use later.</p>
<p>The body of our custom open(…) consists of some custom code. The last part of it creates a new function pointer <em>orig_open</em> which will point to the original open(…) function. In order to get the address of that function, we ask <em>dlsym</em> to find for us the next “open” function on dynamic libraries stack. Finally, we call that function (passing the same arguments as were passed to our fake “open”), and return it’s return value as ours.</p>
<p>As the “evil injected code” I simply used:</p>
<pre title="inspect_open.c (fragment):">printf(&#34;The victim used open(...) to access &#39;%s&#39;!!!\n&#34;,pathname); //remember to include stdio.h!
</pre>
<p>To compile it, I needed to slightly adjust compiler flags:</p>
<blockquote>
<pre>gcc -shared -fPIC  inspect_open.c -o inspect_open.so -ldl</pre>
</blockquote>
<p>I had to append <em>-ldl</em>, so that this shared library is linked to <em>libdl</em>, which provides the <em>dlsym</em> function. (Nah, I am not going to create a fake version of <em>dlsym</em>, though this might be fun.)</p>
<p>So what do I have in result? A shared library, which implements the open(…) function so that it behaves <strong>exactly</strong> as the real open(…)… except it has a side effect of <em>printf</em>ing the file path :-)</p>
<p>If you are not convinced this is a powerful trick, it’s the time you tried the following:</p>
<blockquote>
<pre>LD_PRELOAD=$PWD/inspect_open.so gnome-calculator</pre>
</blockquote>
<p>I encourage you to see the result yourself, but basically it lists every file this application accesses. In real time.</p>
<p>I believe it’s not that hard to imagine why this might be useful for debugging or investigating unknown applications. Please note, however, that this particular trick is not quite complete, because <em>open()</em> is not the only function that opens files… For example, there is also <em>open64()</em> in the standard library, and for full investigation you would need to create a fake one too.</p>
<h4><strong>Possible uses</strong></h4>
<p>If you are still with me and enjoyed the above, let me suggest a bunch of ideas of what can be achieved using this trick. Keep in mind that you can do all the above without to source of the affected app!</p>
<ol>
<li><del>Gain root privileges.</del> Not really, don’t even bother, you won’t bypass any security this way. (A quick explanation for pros: no libraries will be preloaded this way if ruid != euid)</li>
<li>Cheat games: <strong>Unrandomize.</strong> This is what I did in the first example. For a fully working case you would need also to implement a custom <em>random()</em>, <em>rand_r()</em><em>, random_r()</em>. Also some apps may be reading from <em>/dev/urandom</em> or so, you might redirect them to <em>/dev/null</em> by running the original <em>open()</em> with a modified file path. Furthermore, some apps may have their own random number generation algorithm, there is little you can do about that (unless: point 10 below). But this looks like an easy exercise for beginners.</li>
<li>Cheat games: <b>Bullet time. </b>Implement all standard time-related functions pretend the time flows two times slower. Or ten times slower. If you correctly calculate new values for time measurement, timed <em>sleep</em> functions, and others, the affected application will believe the time runs slower (or faster, if you wish), and you can experience awesome bullet-time action.</li>
<li>Investigate apps: <strong>List accessed files.</strong> That’s what my second example does, but this could be also pushed further, by recording and monitoring all app’s file I/O.</li>
<li>Investigate apps: <strong>Monitor internet access.</strong> You might do this with Wireshark or similar software, but with this trick you could actually gain control of what an app sends over the web, and not just look, but also affect the exchanged data. Lots of possibilities here, from detecting spyware, to cheating in multiplayer games, or analyzing &amp; reverse-engineering protocols of closed-source applications.</li>
<li>Investigate apps: <strong>Inspect GTK structures.</strong> Why just limit ourselves to standard library? Let’s inject code in all GTK calls, so that we can learn what widgets does an app use, and how are they structured. This might be then rendered either to an image or even to a gtkbuilder file! Super useful if you want to learn how does some app manage its interface!</li>
<li><strong>Sandbox unsafe applications.</strong> If you don’t trust some app and are afraid that it may wish to<em> rm -rf / </em>or do some other unwanted file activities, you might potentially redirect all it’s file IO to e.g. /tmp by appropriately modifying the arguments it passes to all file-related functions (not just <em>open</em>, but also e.g. removing directories etc.). It’s more difficult trick that a chroot, but it gives you more control. It would be only as safe as complete your “wrapper” was, and unless you really know what you’re doing, don’t actually run any malicious software this way.</li>
<li><strong>Implement features.</strong> <a href="http://www.zlibc.linux.lu/index.html">zlibc</a> is an actual library which is run this precise way; it uncompresses files on the go as they are accessed, so that any application can work on compressed data without even realizing it.</li>
<li><strong>Fix bugs. </strong>Another real-life example: some time ago (I am not sure this is still the case) Skype – which is closed-source – had problems capturing video from some certain webcams. Because the source could not be modified as Skype is not free software, this was fixed by preloading a library that would correct these problems with video.</li>
<li>Manually <strong>access application’s own memory</strong>. Do note that you can access all app data this way. This may be not impressive if you are familiar with software like CheatEngine/scanmem/GameConqueror, but they all require root privileges to work. LD_PRELOAD does not. In fact, with a number of clever tricks your injected code might access all app memory, because, in fact, it gets executed by that application itself. You might modify everything this application can. You can probably imagine this allows a lot of low-level hacks… but I’ll post an article about it another time.</li>
</ol>
<p>These are only the ideas I came up with. I bet you can find some too, if you do – share them by commenting!</p>
<hr/>

	</div></div>
  </body>
</html>
