<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.regehr.org/archives/1605">Original</a>
    <h1>How Clang compiles a function (2018)</h1>
    
    <div id="readability-page-1" class="page"><div><p>I’ve been planning on writing a post about how LLVM optimizes a function, but it seems necessary to first write about how Clang translates C or C++ into LLVM. This is going to be fairly high-level:</p>
<ul>
<li>rather than looking at Clang’s internals, I’m going to focus on how Clang’s output relates to its input
</li><li>we’re not going to look at any non-trivial C++ features
</li></ul>
<p>We’ll use this small function that I borrowed from <a href="https://www.cs.cmu.edu/~fp/courses/15411-f13/lectures/17-loopopt.pdf">these excellent lecture notes on loop optimizations</a>:</p>
<pre title="">bool is_sorted(int *a, int n) {
  for (int i = 0; i &lt; n - 1; i++)
    if (a[i] &gt; a[i + 1])
      return false;
  return true;
}
</pre>
<p>Since Clang doesn’t do any optimization, and since LLVM IR was initially designed as a target for C and C++, the translation is going to be relatively easy. I’ll use Clang 6.0.1 (or something near it, since it hasn’t quite been released yet) on x86-64. </p>
<p>The command line is:</p>
<pre>clang++ is_sorted.cpp -O0 -S -emit-llvm
</pre>
<p>In other words: compile the file is_sorted.cpp as C++ and then tell the rest of the LLVM toolchain: don’t optimize, emit assembly, but no actually emit textual LLVM IR instead. Textual IR is bulky and not particularly fast to print or parse; the binary “bitcode” format is always preferred when a human isn’t in the loop. The <a href="https://blog.regehr.org/extra_files/is_sorted.ll.txt">full IR file is here</a>, we’ll be looking at it in parts.</p>
<p>Starting at the top of the file we have:</p>
<pre>; ModuleID = &#39;is_sorted.cpp&#39;
source_filename = &#34;is_sorted.cpp&#34;
target datalayout = &#34;e-m:e-i64:64-f80:128-n8:16:32:64-S128&#34;
target triple = &#34;x86_64-unknown-linux-gnu&#34;
</pre>
<p>Any text between a semicolon and the end of a line is a comment, so the first line does nothing, but if you care, an LLVM “module” is basically a compilation unit: a container for code and data. The second line doesn’t concern us. The third line describes some choices and assumptions made by the compiler; they don’t matter much for this post but you can <a href="https://llvm.org/docs/LangRef.html#data-layout">read more here</a>. The <a href="https://wiki.osdev.org/Target_Triplet">target triple</a> is a gcc-ism that doesn’t concern us here either.</p>
<p>An LLVM function optionally has attributes:</p>
<pre>; Function Attrs: noinline nounwind optnone uwtable
</pre>
<p>Some of them (like these) are supplied by the front end, others get added later by optimization passes. This is just a comment, the actual attributes are specified towards the end of the file. These attributes don’t have anything to do with the meaning of the code, so I’m not going to discuss them, but you can read <a href="https://llvm.org/docs/LangRef.html#function-attributes">read about them here</a> if you’re curious.</p>
<p>Ok, finally on to the function itself:</p>
<pre>define zeroext i1 @_Z9is_sortedPii(i32* %a, i32 %n) #0 {
</pre>
<p>“zeroext” means that the return value of the function (i1, a one-bit integer) should be zero-extended, by the backend, to whatever width the ABI requires. Next comes the mangled name of the function, then its parameter list, which is basically the same as in the C++ code, except that the “int” type has been refined to 32 bits. The #0 connects this function to an <a href="https://llvm.org/docs/LangRef.html#attribute-groups">attribute group</a> near the bottom of the file.</p>
<p>Now on to the first basic block:</p>
<pre>entry:
  %retval = alloca i1, align 1
  %a.addr = alloca i32*, align 8
  %n.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store i32* %a, i32** %a.addr, align 8
  store i32 %n, i32* %n.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond
</pre>
<p>Every LLVM instruction has to live inside a basic block: a collection of instructions that is only entered at the top and only exited at the bottom. The last instruction of a basic block must be a <a href="https://llvm.org/docs/LangRef.html#terminators">terminator instruction</a>: fallthrough is not allowed. Every function must have an entry block that has no predecessors (places to come from) other than the function entry itself. <a href="https://llvm.org/docs/LangRef.html#well-formedness">These properties and others</a> are checked when an IR file is parsed, and can optionally be checked more times during compilation by the “module verifier.” The verifier is useful for debugging situations where a pass emits illegal IR.</p>
<p>The first four instructions in the entry basic block are “alloca”s: stack memory allocations. The first three are for implicit variables created during the compilation, the fourth is for the loop induction variable. Storage allocated like this can only be accessed using load and store instructions. The next three instructions initialize three of the stack slots: a.addr and n.addr are initialized using the values passed into the function as parameters and i is initialized to zero. The return value does not need to be initialized: this will be taken care of later by any code that wasn’t undefined at the C or C++ level. The last instruction is an unconditional branch to the subsequent basic block (we’re not going to worry about it here, but most of these unnecessary jumps can be elided by an LLVM backend).</p>
<p>You might ask: why does Clang allocate stack slots for a and n? Why not just use those values directly? In this function, since a and n are never modified, this strategy would work, but noticing this fact is considered an optimization and thus outside of the job Clang was designed to do. In the general case where a and n might be modified, they must live in memory as opposed to being SSA values, which are — by definition — given a value at only one point in a program. Memory cells live outside of the SSA world and can be modified freely. This may all seem confusing and arbitrary but these design decisions have been found to allow many parts of a compiler to be expressed in natural and efficient ways.</p>
<p>I think of Clang as emitting degenerate SSA code: it meets all the requirements for SSA, but only because basic blocks communicate through memory. Emitting non-degenerate SSA requires some care and some analysis and Clang’s refusal to do these leads to a pleasing separation of concerns. I haven’t seen the measurements but my understanding is that generating a lot of memory operations and then almost immediately optimizing many of them away isn’t a major source of compile-time overhead.</p>
<p>Next let’s look at how to translate a for loop. The general form is:</p>
<pre title="">for (initializer; condition; modifier) {
  body
}
</pre>
<p>This is translated roughly as:</p>
<pre>  initializer
  goto COND
COND:
  if (condition)
    goto BODY
  else
    goto EXIT
BODY:
  body
  modifier
  goto COND
EXIT:
</pre>
<p>Of course this translation isn’t specific to Clang: any C or C++ compiler would do the same.</p>
<p>In our example, the loop initializer has been folded into the entry basic block. The next basic block is the loop condition test:</p>
<pre>for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* %n.addr, align 4
  %sub = sub nsw i32 %1, 1
  %cmp = icmp slt i32 %0, %sub
  br i1 %cmp, label %for.body, label %for.end
</pre>
<p>As a helpful comment, Clang is telling us that this basic block can be reached either from the for.inc or the entry basic block. This block loads i and n from memory, decrements n (the “nsw” flag preserves the C++-level fact that signed overflow is undefined; without this flag an LLVM subtract would have two’s complement semantics), compares the decremented value against i using “signed less than”, and then finally branches either to the for.body basic block or the for.end basic block.</p>
<p>The body of the for loop can only be entered from the for.cond block:</p>
<pre>for.body:
  %2 = load i32*, i32** %a.addr, align 8
  %3 = load i32, i32* %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds i32, i32* %2, i64 %idxprom
  %4 = load i32, i32* %arrayidx, align 4
  %5 = load i32*, i32** %a.addr, align 8
  %6 = load i32, i32* %i, align 4
  %add = add nsw i32 %6, 1
  %idxprom1 = sext i32 %add to i64
  %arrayidx2 = getelementptr inbounds i32, i32* %5, i64 %idxprom1
  %7 = load i32, i32* %arrayidx2, align 4
  %cmp3 = icmp sgt i32 %4, %7
  br i1 %cmp3, label %if.then, label %if.end
</pre>
<p>The first two lines load a and i into SSA registers; i is then widened to 64 bits so it can participate in an address computation. <a href="https://llvm.org/docs/LangRef.html#getelementptr-instruction">getelementptr</a> (gep for short) is LLVM’s famously baroque pointer computation instruction, it even has <a href="https://llvm.org/docs/GetElementPtr.html">its own faq</a>. Unlike a machine language, LLVM does not treat pointers and integers the same way. This facilitates alias analysis and other memory optimizations. The code then goes on to load a[i] and a[i + 1], compare them, and branch based on the result.</p>
<p>The if.then block stores 0 into the stack slot for the function return value and branches unconditionally to the function exit block:</p>
<pre>if.then:
  store i1 false, i1* %retval, align 1
  br label %return
</pre>
<p>The else block is trivial:</p>
<pre>if.end:
  br label %for.inc
</pre>
<p>And the block for adding one to the loop induction variable is easy as well:</p>
<pre>for.inc:
  %8 = load i32, i32* %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond
</pre>
<p>This code branches back up to the loop condition test.</p>
<p>If the loop terminates normally, we want to return true:</p>
<pre>for.end:
  store i1 true, i1* %retval, align 1
  br label %return
</pre>
<p>And finally whatever got stored into the return value stack slot is loaded and returned:</p>
<pre>return:
  %9 = load i1, i1* %retval, align 1
  ret i1 %9
</pre>
<p>There’s a bit more at the bottom of the function but nothing consequential. Ok, this post became longer than I’d intended, the next one will look at what the IR-level optimizations do to this function.</p>
<p>(Thanks to Xi Wang and Alex Rosenberg for sending corrections.)</p>
</div></div>
  </body>
</html>
