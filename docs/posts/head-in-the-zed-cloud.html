<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://maxdeviant.com/posts/2025/head-in-the-zed-cloud/">Original</a>
    <h1>Head in the Zed Cloud</h1>
    
    <div id="readability-page-1" class="page"><div><p>For the past five months I&#39;ve been leading the efforts to rebuild <a href="https://zed.dev/">Zed</a>&#39;s cloud infrastructure.</p><p>Our current backend—known as Collab—has been chugging along since basically the beginning of the company. We use Collab every day to work together on Zed in Zed. However, as Zed continues to grow and attracts more users, we knew that we needed a full reboot of our backend infrastructure to set us up for success for our future endeavors.</p><p>Enter Zed Cloud.</p><p>Like Zed itself, Zed Cloud is built in Rust.</p><p>This time around there is a slight twist: all of this is running on <a href="https://workers.cloudflare.com/">Cloudflare Workers</a>, with our Rust code being compiled down to <a href="https://webassembly.org/">WebAssembly</a> (Wasm).</p><h2 id="why-cloudflare-workers">Why Cloudflare Workers?</h2><p>One of our goals with this rebuild was to reduce the amount of operational effort it takes to maintain our hosted services, so that we can focus more of our time and energy on building Zed itself.</p><p>Cloudflare Workers allow us to easily scale up to meet demand without having to fuss over it too much.</p><p>Additionally, Cloudflare offers an ever-growing amount of managed services that cover anything you might need for a production web service. Here are some of the Cloudflare services we&#39;re using today:</p><ul><li><a href="https://workers.cloudflare.com/product/hyperdrive">Hyperdrive</a> for talking to Postgres</li><li><a href="https://developers.cloudflare.com/kv/">Workers KV</a> for ephemeral storage</li><li><a href="https://developers.cloudflare.com/queues/">Cloudflare Queues</a> for asynchronous job processing</li></ul><h2 id="the-platform">The Platform</h2><p>Another one of our goals with this rebuild was to build a platform that was easy to test. To achieve this, we built our own platform framework on top of the Cloudflare Workers runtime APIs.</p><p>At the heart of this framework is the <code>Platform</code> trait:</p><div><div><pre data-lang="rs"><code data-lang="rs">pub trait Platform: Sized + Clone + &#39;static {
    type Cache: cache::Cache;
    type Clock: Clock;
    type KvStore: KvStore&lt;Self&gt;;
    type ServiceBinding: Fetcher&lt;Self&gt;;
    type DurableObjectNamespace: durable_object::DurableObjectNamespace&lt;Self&gt;;
    type DurableObjectStub: durable_object::DurableObjectStub&lt;Self&gt;;
    type DurableObjectState: durable_object::DurableObjectState&lt;Self&gt;;
    type RateLimiter: rate_limiter::RateLimiter&lt;Self&gt;;
    type SqlStorage: sql::SqlStorage;
    type PostgresConnection&lt;T&gt;: postgres::PostgresConnection&lt;Self, T&gt;;
    type PostgresTransaction&lt;T&gt;: postgres::PostgresTransaction&lt;Self, T&gt;;
    type ExecutionContext: ExecutionContext + Clone + Unpin;
    type Environment: Environment&lt;Self&gt; + Clone + Unpin;
    type ClientWebSocket: websocket::ClientWebSocket;
    type ServerWebSocket: websocket::ServerWebSocket&lt;Self&gt;;
    type WebSocketReceiver: websocket::WebSocketReceiver;
    type WebSocketSender: websocket::WebSocketSender;
    type HttpClient: http_client::HttpClient&lt;Platform = Self&gt;;
    type Queue&lt;T: Serialize + &#39;static&gt;: queue::Queue&lt;Self, T&gt;;
    type RawQueueMessageBatch: queue::RawQueueMessageBatch&lt;Self&gt;;
    type QueueMessageBatch&lt;T: DeserializeOwned + &#39;static&gt;: queue::QueueMessageBatch&lt;Self, T&gt;;
    type QueueMessage&lt;T: DeserializeOwned + &#39;static&gt;: queue::QueueMessage&lt;Self, T&gt;;
    type Rng: Clone + RngCore;

    fn websocket_pair() -&gt; Result&lt;(Self::ClientWebSocket, Self::ServerWebSocket)&gt;;
}
</code></pre></div></div><p>This trait allows us to write our code in a platform-agnostic way while still leveraging all of the functionality that Cloudflare Workers has to offer. Each one of these associated types corresponds to some aspect of the platform that we&#39;ll want to have control over in a test environment.</p><p>For instance, if we have a service that needs to interact with the system clock and a Workers KV store, we would define it like this:</p><div><div><pre data-lang="rs"><code data-lang="rs">pub struct BillingService&lt;P: Platform&gt; {
    clock: P::Clock,
    kv_store: P::KvStore,
}
</code></pre></div></div><h2 id="two-platforms-both-alike-in-dignity">Two platforms, both alike in dignity</h2><p>There are two implementors of the <code>Platform</code> trait: <code>CloudflarePlatform</code> and <code>SimulatedPlatform</code>.</p><h3 id="cloudflareplatform"><code>CloudflarePlatform</code></h3><p><code>CloudflarePlatform</code>—as the name might suggest—is an implementation of the platform on top of the Cloudflare Workers runtime. This implementation targets Wasm and is what we run when developing locally (using <a href="https://developers.cloudflare.com/workers/wrangler/">Wrangler</a>) and in production.</p><p>We have a <code>cloudflare_bindings</code> crate that contains <code>wasm_bindgen</code> bindings to the Cloudflare Workers JS runtime. You can think of <code>CloudflarePlatform</code> as the glue between those bindings and the idiomatic Rust APIs exposed by the <code>Platform</code> trait.</p><h3 id="simulatedplatform"><code>SimulatedPlatform</code></h3><p>The <code>SimulatedPlatform</code> is used when running tests, and allows for simulating almost every part of the system in order to effectively test our code.</p><p>Here&#39;s an example of a test for ingesting a webhook from <a href="https://www.withorb.com/">Orb</a>:</p><div><div><pre data-lang="rs"><code data-lang="rs">#[test]
fn test_orb_webhook_ingestion() {
    Simulator::once(|simulator| async move {
        let test_ctx = OrbWebhooksTestContext::init(&amp;simulator).await?;

        // Some more test setup...

        let request = make_orb_webhook_request(
            HANDLE_ORB_WEBHOOK_URL,
            &amp;webhook_event,
            &#34;2025-09-10T18:16:06.483Z&#34;.parse().unwrap(),
            &amp;test_ctx.config.orb_webhook_signing_secret,
        )?;

        let response = test_ctx.worker.fetch(request).await?;
        assert_eq!(response.status, StatusCode::OK);

        simulator.scheduler.run()?;

        let updated_billing_subscription = BillingSubscriptionRepository
            .find(&amp;test_ctx.app_database, billing_subscription.id)
            .await?;
        assert_eq!(
            updated_billing_subscription.kind,
            Some(app_database::SubscriptionKind::TokenBasedZedPro)
        );
        assert_eq!(
            updated_billing_subscription.orb_subscription_status,
            Some(app_database::OrbSubscriptionStatus::Active)
        );
    })
    .unwrap();
}
</code></pre></div></div><p>In this test we&#39;re able to test the full end-to-end flow of:</p><ol><li>Receiving and validating an incoming webhook event to our webhook ingestion endpoint</li><li>Putting the webhook event into a queue</li><li>Consuming the webhook event in a background worker and processing it</li></ol><p>The call to <code>simulator.scheduler.run()?</code> advances the test simulator, in this case running the pending queue consumers.</p><p>At the center of the <code>SimulatedPlatform</code> is the <a href="https://github.com/zed-industries/zed/tree/main/crates/scheduler"><code>scheduler</code></a>, a crate that powers our in-house async runtime. The scheduler is shared between <a href="https://www.gpui.rs/">GPUI</a>—Zed&#39;s UI framework—and the <code>Simulator</code> used in tests.</p><p>This shared scheduler enables us to write tests that span the client and the server. So we can have a test that starts in a piece of Zed code, flows through Zed Cloud, and then asserts on the state of something in Zed after it receives the response from the backend.</p><h2 id="where-we-re-headed">Where we&#39;re headed</h2><p>The work being done on Zed Cloud now is laying the foundation to support our future work around collaborative coding with <a href="https://zed.dev/blog/sequoia-backs-zed#introducing-deltadb-operation-level-version-control">DeltaDB</a>.</p><p>If you want to work with me on building out Zed Cloud, we are <a href="https://zed.dev/jobs/backend-engineer">currently hiring</a> for this role.</p><p>We&#39;re looking for engineers with experience building and maintaining web APIs and platforms, solid web fundamentals, and who are excited about Rust.</p><p>If you end up applying, you can mention this blog post in your application.</p><p>I look forward to hearing from you!</p></div></div>
  </body>
</html>
