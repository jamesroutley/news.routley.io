<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bytes.zone/posts/modeling-in-flight-requests-in-alloy/">Original</a>
    <h1>Modeling in-flight requests in Alloy</h1>
    
    <div id="readability-page-1" class="page"><article><p><em>Brian Hicks, October 2, 2023</em></p><p>In <a href="https://bytes.zone/projects/learning-alloy/">Alloy</a>, sometimes I want to model clients and servers (or any relationship where two entities are talking.) With network stuff, it&#39;s always possible for a message to not be received, or to be received twice, or out of order, et cetera. I&#39;d like to model that!</p><p>Because I just want to learn the basics here, I&#39;ll try to keep this as simple as possible. So instead of requests and responses or any other protocol, we&#39;ll stick to just messages:</p><pre data-lang="alloy"><code data-lang="alloy"><span>var </span><span>sig</span><span> Message {}
</span><span>
</span><span>var </span><span>sig</span><span> Delivered </span><span>in</span><span> Message {}
</span></code></pre><p>In English, &#34;We have a set of <code>Message</code>s, some of which have been delivered and some of which haven&#39;t. Both sets can change over time.&#34;</p><p>In addition to the things we define in a model like this, we have to think about the world they live in. Here I&#39;m imagining that these messages form a stream going from some node A to another node B—no return messages, though, only one way!</p><p>Next we&#39;ll take care of a little boilerplate: how the system starts (with no messages) and a do-nothing message so our traces can run forever.</p><pre data-lang="alloy"><code data-lang="alloy"><span>pred</span><span> init {
</span><span>  </span><span>no</span><span> Message
</span><span>}
</span><span>
</span><span>pred</span><span> do_nothing {
</span><span>  Message&#39; </span><span>=</span><span> Message
</span><span>  Delivered&#39; </span><span>=</span><span> Delivered
</span><span>}
</span></code></pre><p>(<code>Message&#39;</code> means &#34;<code>Message</code> in the next step.&#34; If this is unfamiliar to you, here&#39;s <a href="https://bytes.zone/posts/modeling-git-internals-in-alloy-part-3-operations-on-blobs-and-trees/">a previous post where I went into more detail about how time works in Alloy</a>.)</p><p>Next we want to send a message:</p><pre data-lang="alloy"><code data-lang="alloy"><span>pred</span><span> send_message {
</span><span>  </span><span>// action: we want exactly `one` new message
</span><span>  </span><span>// without making any other changes to `Messages`
</span><span>  </span><span>one</span><span> m</span><span>:</span><span> Message&#39; </span><span>-</span><span> Message {
</span><span>    Message&#39; </span><span>=</span><span> Message </span><span>+</span><span> m
</span><span>  }
</span><span>
</span><span>  </span><span>// frame (holding everything else still)
</span><span>  Delivered&#39; </span><span>=</span><span> Delivered
</span><span>}
</span></code></pre><p>We can do something similar to model the request being received:</p><pre data-lang="alloy"><code data-lang="alloy"><span>pred</span><span> receive_message {
</span><span>  </span><span>// action: mark exactly one message as delivered.
</span><span>  </span><span>one</span><span> m</span><span>:</span><span> Message </span><span>-</span><span> Delivered {
</span><span>    Delivered&#39; </span><span>=</span><span> Delivered </span><span>+</span><span> m
</span><span>  }
</span><span>
</span><span>  </span><span>// frame
</span><span>  Message&#39; </span><span>=</span><span> Message
</span><span>}
</span></code></pre><p>Note that this can&#39;t be true (that is, can&#39;t happen) if we don&#39;t have at least one message in <code>Message - Delivered</code>, which can read as &#34;The set of <code>Message</code> minus the set of <code>Delivered</code>.&#34;</p><p>Finally, we set up a state machine telling Alloy when each predicate can be true over time:</p><pre data-lang="alloy"><code data-lang="alloy"><span>fact</span><span> traces {
</span><span>  init
</span><span>  always {
</span><span>    do_nothing
</span><span>    </span><span>or</span><span> send_message
</span><span>    </span><span>or</span><span> receive_message
</span><span>  }
</span><span>}
</span></code></pre><p>That works pretty well! If you step through the traces here, you can get instances where messages are delivered out of order, never delivered, etc. We can&#39;t get duplicate messages in this model, but that wouldn&#39;t be the worst thing in the world to add!</p><p>Since this is demonstrating the lack of safety on the network, we can&#39;t add a check like &#34;all messages are eventually delivered&#34;, but we can make assertions that the individual actions are doing what they say they will. For example, we know that if <code>send_message</code> is true then we will always have exactly one new message and no changes to <code>Delivered</code>:</p><pre data-lang="alloy"><code data-lang="alloy"><span>check</span><span> SendMessageNextStepHasExactlyOneNewMessage {
</span><span>  always send_message </span><span>implies one</span><span> Message&#39; </span><span>-</span><span> Message
</span><span>}
</span><span>
</span><span>check</span><span> SendMessageDoesNotChangeDelivered {
</span><span>  always send_message </span><span>implies</span><span> Delivered&#39; </span><span>=</span><span> Delivered
</span><span>}
</span></code></pre><p>I debated including <code>Delivered&#39; = Delivered</code> above, though… it&#39;s a property I care about, but it&#39;s also a frame condition. If you squint and think of this like a unit test, it&#39;s just testing that the implementation is what I expect. But on the other hand, if Alloy allows express my intent this way, where&#39;s the problem?</p><p>We can make similar assertions about <code>receive_message</code>:</p><pre data-lang="alloy"><code data-lang="alloy"><span>check</span><span> ReceiveMessageOnlyMarksMessagesAsDelivered {
</span><span>  always receive_message </span><span>implies one</span><span> Delivered&#39; </span><span>-</span><span> Delivered
</span><span>}
</span><span>
</span><span>check</span><span> ReceiveMessageDoesNotChangeMessages {
</span><span>  always receive_message </span><span>implies</span><span> Message&#39; </span><span>=</span><span> Message
</span><span>}
</span></code></pre><p>(If you&#39;re typing this in by hand and want to go back to just exploring instances, don&#39;t forget you can add a <code>run {}</code> block at the end to generate something more explorable!)</p><p>So with that, we have a fairly nice skeleton to add more network operations onto. For example, imagine that these messages mutated some state. We can now make sure that the state changes are correct in the face of out-of-order or dropped messages. Give it a try and see if you can extend the model to do that!</p></article></div>
  </body>
</html>
