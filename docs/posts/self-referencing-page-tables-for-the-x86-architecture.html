<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://0l.de/blog/2015/01/bachelor-thesis-abstract/">Original</a>
    <h1>Self-referencing Page Tables for the x86-Architecture</h1>
    
    <div id="readability-page-1" class="page"><div> <p>Almost fourteen months ago, I started working on my bachelor thesis.
Although I finished it half a year ago, it’s still part of my work as a student research assistant.</p>
<p>During my initial work, most of the code was written for an internal research kernel.
I’m now happy that we were able to port it to an open source kernel called <em>eduOS</em>: <a href="https://github.com/RWTH-OS/eduOS"> <span> <svg aria-hidden="true" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="--sl-icon-size: 1em;"><path d="M12 .3a12 12 0 0 0-3.8 23.38c.6.12.83-.26.83-.57L9 21.07c-3.34.72-4.04-1.61-4.04-1.61-.55-1.39-1.34-1.76-1.34-1.76-1.08-.74.09-.73.09-.73 1.2.09 1.83 1.24 1.83 1.24 1.08 1.83 2.81 1.3 3.5 1 .1-.78.42-1.31.76-1.61-2.67-.3-5.47-1.33-5.47-5.93 0-1.31.47-2.38 1.24-3.22-.14-.3-.54-1.52.1-3.18 0 0 1-.32 3.3 1.23a11.5 11.5 0 0 1 6 0c2.28-1.55 3.29-1.23 3.29-1.23.64 1.66.24 2.88.12 3.18a4.65 4.65 0 0 1 1.23 3.22c0 4.61-2.8 5.63-5.48 5.92.42.36.81 1.1.81 2.22l-.01 3.29c0 .31.2.69.82.57A12 12 0 0 0 12 .3Z"></path></svg> </span><span>/RWTH-OS/eduOS</span> </a> ).
This minimal operating system is used for practical demo’s and assignments during the <a href="https://www.os.rwth-aachen.de">OS course</a> at my university.
There’s much more I could write about.
So this will probably be another separate blog post.</p>
<p>The motive for this article is an abstract I wrote for the student research competition of the <a href="http://asplos15.bilkent.edu.tr">ASPLOS conference</a> which is held this year in Istanbul, Turkey.
Unfortunately my submission got rejected.
But as a nice side-effect, I’ve now the chance to present my work to an English audience as well:</p>
<center> <a download="" href="https://0l.de/blog/2015/01/bachelor-thesis-abstract/Self-referenced_Page_Tables-Vogel-ASPLOS_SrC.pdf">   <span> <svg aria-hidden="true" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="--sl-icon-size: 1em;"><path d="M8.29 13.29a1 1 0 0 0 0 1.42l3 3a1 1 0 0 0 1.42 0l3-3a1 1 0 0 0-1.42-1.42L13 14.59V3a1 1 0 0 0-2 0v11.59l-1.29-1.3a1 1 0 0 0-1.42 0ZM18 9h-2a1 1 0 0 0 0 2h2a1 1 0 0 1 1 1v7a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1v-7a1 1 0 0 1 1-1h2a1 1 0 0 0 0-2H6a3 3 0 0 0-3 3v7a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3v-7a3 3 0 0 0-3-3Z"></path></svg> </span><b>Download:</b>Extended Abstract
(PDF)  </a>  </center>



<p><a href="mailto:steffen.vogel@rwth-aachen.de">Steffen Vogel</a></p>
<p>Academic advisor: Dr. rer nat. Stefan Lankes Institute for Automation of Complex Power Systems E.ON Energy Research Center, RWTH Aachen University Mathieustr. 10, 52074 Aachen, Germany</p>
<p>This was a submission for ASPLOS Student Research Competition ’15 Istanbul, Turkey<sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup>.</p>

<p>The adoption of 64 bit architectures went along with an extension of the virtual address space (VAS).
To cope with this growth, the memory management unit (MMU) had to be extended as well.
For paging-based systems like Intel’s x86-architecture this was realized by adding more levels of indirection to the page table walk.</p>
<p>This walk translates virtual pages to physical page frames (PF) by performing look-ups in a radix / prefix tree in which every node represents a page table (<a href="#figure1a">Figure 1a</a>).
Since the tables are part of the translation process, they must be referenced by physical page frame numbers (PFN, blue line).
As the operating system is only eligible to access the VAS, it cannot follow the path of a walk.
In order to allow the manipulation of page tables, it must provide:</p>

<figure id="figure1a"> <div><starlight-image-zoom-zoomable> <img src="https://0l.de/_astro/pgt_walk.Bm-Rgxnq_Z1sQTwR.webp" srcset="/_astro/pgt_walk.Bm-Rgxnq_Zky5B4.webp 640w, /_astro/pgt_walk.Bm-Rgxnq_ZIPB4N.webp 750w, /_astro/pgt_walk.Bm-Rgxnq_1JiaE9.webp 828w, /_astro/pgt_walk.Bm-Rgxnq_Z1sQTwR.webp 1037w" alt="Figure 1a: Page table walk in the x86 64 longmode: Traditional, without self-reference" loading="lazy" decoding="async" fetchpriority="auto" sizes="(min-width: 1037px) 1037px, 100vw" data-astro-image="constrained" width="1037" height="442"/>  </starlight-image-zoom-zoomable></div> <figcaption>Figure 1a: Page table walk in the x86 64 longmode: Traditional, without self-reference.</figcaption> </figure>
<ul>
<li>Access to the table entries, by mapping the tables themselves to the VAS.</li>
<li>A mapping between physical references to corresponding locations in the VAS.</li>
</ul>
<p>Additionally, every level of the page table walk increases the complexity of managing these mappings.
They also increase the memory consumption by occupying physical page frames.
It is possible to avoid both drawbacks by the technique described in the following.</p>
<p>In my bachelor thesis, I presented an approach, which is compatible with both the 32 bit and 64 bit version of Intel’s x86-architecture.
This allows for a replacement of two code bases, one for each architecture, by one supporting both.
Thus, results in a shorter, easier comprehensible, and maintainable code.
As foundation for this implementation our teaching OS called “eduOS” was used<sup><a href="#user-content-fn-2" id="user-content-fnref-2" data-footnote-ref="" aria-describedby="footnote-label">2</a></sup>.
“eduOS” supports only the 32 bit protected mode whereas the 64 bit longmode is only implemented for an internal research kernel.</p>
<p>Thanks to the sophisticated design of Intel’s x86 MMU, it is possible to avoid most of the complexity and space requirements by using a little trick.
Adding a self-reference in the root table (PML4 resp. PGD) automatically enables access to all page tables from the VAS without the need for manual mappings as described above (<a href="#figure1b">Figure 1b</a>).
The operating system does not need to manually follow the path of a page table walk, as this task is executed by the MMU for accessing individual tables instead of page frames.</p>

<figure id="figure1b"> <div><starlight-image-zoom-zoomable> <img src="https://0l.de/_astro/pgt_walk_self.COAkTsRX_21BnqG.webp" srcset="/_astro/pgt_walk_self.COAkTsRX_2o3eur.webp 640w, /_astro/pgt_walk_self.COAkTsRX_Z1dbznl.webp 750w, /_astro/pgt_walk_self.COAkTsRX_Zs7Veu.webp 828w, /_astro/pgt_walk_self.COAkTsRX_21BnqG.webp 1051w" alt="Figure 1b: Page table walk in the x86 64 longmode: With self-reference" loading="lazy" decoding="async" fetchpriority="auto" sizes="(min-width: 1051px) 1051px, 100vw" data-astro-image="constrained" width="1051" height="433"/>  </starlight-image-zoom-zoomable></div> <figcaption>Figure 1b: Page table walk in the x86 64 longmode: With self-reference.</figcaption> </figure>
<p>An access to the VAS region covered by a self-reference causes the MMU to look up the root table twice (red line).
Effectively, this shifts the whole page table walk by one level.
Therefore, it stops with the PFN of page tables instead of page frames that are usually translated by the MMU.
Here, both the PML4 and PDPT indexes are used to choose an entry out of the PML4 table.
Therefore, it must be guaranteed that PML4 entries can be interpreted as PDPT entries, too.
This demands for the following requirements:</p>
<ul>
<li>Homogenous coding of paging flags across all paging levels.</li>
<li>Equal table sizes across all paging levels.</li>
</ul>
<p>Fortunately, the x86-architecture complies with this prerequisites as shown in <a href="#figure2">Figure 2</a>.
Green colored flags are coded consistently across all paging levels.
Only PAT, size and global flags have a slightly different meaning for entries in the PGT.
My bachelor thesis shows that these deviations still allow maintaining full control caching and memory protection properties of self-mapped tables.
This includes for common system calls like fork() and kill().</p>

<figure id="figure2"> <div><starlight-image-zoom-zoomable> <img src="https://0l.de/_astro/page_flags.CU4EvCew_Zd6QIk.webp" srcset="/_astro/page_flags.CU4EvCew_Zd6QIk.webp 598w" alt="Figure 2: Similar flags across all paging levels" loading="lazy" decoding="async" fetchpriority="auto" sizes="(min-width: 598px) 598px, 100vw" data-astro-image="constrained" width="598" height="502"/>  </starlight-image-zoom-zoomable></div> <figcaption>Figure 2: Similar flags across all paging levels.</figcaption> </figure>
<p>By repeatedly addressing the self-reference, it is also possible to access tables of the upper levels (PGD to PML4).
<a href="#table1">Table 1</a> shows the resulting virtual addresses of all page tables when using the last (512th) entry of the PML4 table for the self-reference<sup><a href="#user-content-fn-3" id="user-content-fnref-3" data-footnote-ref="" aria-describedby="footnote-label">3</a></sup>.
This grants access to all possible page tables, including those which might not yet exist and may be allocated in the future.
Hence, the self-reference reserves a fixed fraction of the VAS for the page tables.
The size of this region is equal to 256 TiB / 512 = 512 GiB for 64 bit (resp. 4 GiB / 1024 = 4 MiB for 32 bit), which is negligible in comparison to the huge VAS of 248 byte.</p>

<figure id="table1"> <div><starlight-image-zoom-zoomable> <img src="https://0l.de/_astro/self_map_addrs.BlpFwUQl_27K2fx.webp" srcset="/_astro/self_map_addrs.BlpFwUQl_27K2fx.webp 553w" alt="Table 1: Virtual addresses of self-mapped tables" loading="lazy" decoding="async" fetchpriority="auto" sizes="(min-width: 553px) 553px, 100vw" data-astro-image="constrained" width="553" height="212"/>  </starlight-image-zoom-zoomable></div> <figcaption>Table 1: Virtual addresses of self-mapped tables.</figcaption> </figure>
<p>For the manipulation of page table entries two approaches are feasible:</p>
<ul>
<li><strong>Top-down</strong> Use known tree traversals, starting at the root node, which corresponds to the PML4 respectively PGD.</li>
<li><strong>Bottom-up</strong> Use the page fault handler to create new tables on-the-fly, when they are not yet present.</li>
</ul>
<p>But there are also other architectures which satisfy the prerequisites described above.
One of these is the Alpha<sup><a href="#user-content-fn-4" id="user-content-fnref-4" data-footnote-ref="" aria-describedby="footnote-label">4</a></sup> architecture, which suggests a similar approach in the reference manual.
Intel and AMD do not mention the technique in their x86 manuals.
In the field of operating systems, support is far more limited.
There is only a single reference<sup><a href="#user-content-fn-5" id="user-content-fnref-5" data-footnote-ref="" aria-describedby="footnote-label">5</a></sup> dated to 2010 indicating that Microsoft might use a similar approach for its NT kernel.
Linux cannot profit because its paging implementation must support a broad selection of virtual memory architectures of which not all fulfill the requirements mentioned above.</p>
 </div></div>
  </body>
</html>
