<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rachelbythebay.com/w/2024/12/12/pleroma/">Original</a>
    <h1>Please upgrade past Pleroma 2.7.0 (or at least patch it)</h1>
    
    
<p>
Hey there.  Are you one of these &#34;Fediverse&#34; enthusiasts?  Are you hard 
core enough to run an instance of some of this stuff?  Do you run 
Pleroma?  Is it version 2.7.0?  If so, you probably should do something 
about that, like upgrading to 2.7.1 or something.
</p>
<p>
Based on my own investigations into really bad behavior in my web server 
logs, there&#39;s something that got into 2.7.0 that causes dumb things to 
happen.  It goes like this: first, it shows up and does a HEAD.  Then it 
comes back and does a GET, but it sends complete nonsense in the 
headers.  Apache hates it, and it gets a 400.
</p>
<p>
What do I mean by nonsense?  I mean sending things like &#34;etag&#34; *in the 
request*.  Guess what, that&#39;s a server-side header.  Or, sending 
&#34;content-type&#34; &#34;and &#34;content-length&#34; *in the request*.  Again, those are
server-side headers unless you&#39;re sending a body, and why the hell   
would you do that on a GET?
</p>
<p>
I mean, seriously, I had real problems trying to understand this 
behavior.  Who sends that kind of stuff in a request, right?  And why?
</p>
<p>
This is the kind of stuff I was seeing on the inbound side:
</p>
<pre class="terminal">raw_header {
  name: &#34;user-agent&#34;
  value: &#34;Pleroma 2.7.0-1-g7a73c34d; &lt; guilty party removed &gt;&#34;
}
raw_header {
  name: &#34;date&#34;
  value: &#34;Thu, 05 Dec 2024 23:52:38 GMT&#34;
}
raw_header {
  name: &#34;server&#34;
  value: &#34;Apache&#34;
}
raw_header {
  name: &#34;last-modified&#34;
  value: &#34;Tue, 30 Apr 2024 04:03:30 GMT&#34;
}
raw_header {
  name: &#34;etag&#34;
  value: &#34;\&#34;26f7-6174873ecba70\&#34;&#34;
}
raw_header {
  name: &#34;accept-ranges&#34;
  value: &#34;bytes&#34;
}
raw_header {
  name: &#34;content-length&#34;
  value: &#34;9975&#34;
}
raw_header {
  name: &#34;content-type&#34;
  value: &#34;text/html&#34;
}
raw_header {
  name: &#34;Host&#34;
  value: &#34;rachelbythebay.com&#34;
}
</pre>
<p>
Sending date and server?  What what what?
</p>
<p>
Last night, I finally got irked enough to go digging around in their git 
repo, and I think I found a smoking gun.  I don&#39;t know Elixir *at all*, 
so this is probably wrong on multiple levels, but something goofy seems 
to have changed with a commit in July, resulting in this:
</p>
<pre class="terminal">  def rich_media_get(url) do
    headers = [{&#34;user-agent&#34;, Pleroma.Application.user_agent() &lt;&gt; &#34;; Bot&#34;}]

    with {_, {:ok, %Tesla.Env{status: 200, headers: headers}}} &lt;-
           {:head, Pleroma.HTTP.head(url, headers, http_options())},
         {_, :ok} &lt;- {:content_type, check_content_type(headers)},
         {_, :ok} &lt;- {:content_length, check_content_length(headers)},
         {_, {:ok, %Tesla.Env{status: 200, body: body}}} &lt;-
           {:get, Pleroma.HTTP.get(url, headers, http_options())} do
      {:ok, body}
</pre>
<p>
Now, based on my addled sense of comprehension for this stuff, this is 
just a guess, but it sure looks like it&#39;s populating &#34;headers&#34; with a 
user-agent, then fires that off as a HEAD.  Then it takes the *incoming* 
headers, adds them to that, then turns the whole mess around and sends 
it as a GET.
</p>
<p>
Assuming I&#39;m right, that would explain the really bizarre behavior.
</p>
<p>
There was another commit about a month later and the code changed quite 
a bit, including a telling change to NOT send &#34;headers&#34; back out the 
door on the second request:
</p>
<pre class="terminal">  defp head_first(url) do
    with {_, {:ok, %Tesla.Env{status: 200, headers: headers}}} &lt;-
           {:head, Pleroma.HTTP.head(url, req_headers(), http_options())},
         {_, :ok} &lt;- {:content_type, check_content_type(headers)},
         {_, :ok} &lt;- {:content_length, check_content_length(headers)},
         {_, {:ok, %Tesla.Env{status: 200, body: body}}} &lt;-
           {:get, Pleroma.HTTP.get(url, req_headers(), http_options())} do
      {:ok, body}
    end
  end
</pre>
<p>
Now both requests call a function (req_headers) which itself just 
supplies the user-agent as seen before.
</p>
<p>
What&#39;s frustrating is that the commit for this doesn&#39;t explain that it&#39;s 
fixing an inability to fetch previews of links or anything of the sort, 
and so the changelog for 2.7.1 doesn&#39;t say it either.  This means users 
of the thing would have no idea if they should upgrade past 2.7.0.
</p>
<p>
Well, I&#39;m changing that.  This is your notification to upgrade past 
that.  Please stop regurgitating headers at me.  I know my servers are 
named after birds, but they really don&#39;t want to be fed that way.
</p>
<p>
...
</p>
<p>
One small side note for the devs: having version numbers and even git 
commit hashes made it possible to bracket this thing.  Without those in 
the user-agent, I would have been stuck trying to figure it out based on 
the dates the behavior began, and that&#39;s never fun.  The pipeline from 
&#34;git commit&#34; to actual users causing mayhem can be rather long.
</p>
<p>
So, whoever did that, thanks for that.
</p>

  </body>
</html>
