<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hypirion.com/musings/implementing-system-versioned-tables-in-postgres">Original</a>
    <h1>Implementing system-versioned tables in Postgres</h1>
    
    <div id="readability-page-1" class="page"><div id="content"><article>

<p>I like Postgres, but there are things I really wish they would implement. For
example, the <a href="https://en.wikipedia.org/wiki/SQL:2011">SQL:2011</a> spec adds
support for system-versioned tables. Unfortunately, Postgres and SQLite are
basically the only SQL databases that don’t yet support it. While it has been
discussed in length at the <a href="https://www.postgresql.org/message-id/flat/CALAY4q-cXCD0r4OybD%3Dw7Hr7F026ZUY6%3DLMsVPUe6yw_PJpTKQ%40mail.gmail.com">postgreqsl-hackers’ mailing
list</a>,
it seems like the discussion and implementation efforts have been silent in all
of 2023.</p>

<p>Now, there are extensions out there that implement versioning –
<a href="https://clarkdave.net/2015/02/historical-records-with-postgresql-and-temporal-tables-and-sql-2011/"><code>temporal_tables</code></a>
being the most popular I think – but none are supported for managed Postgres
instances on e.g. Azure or AWS. This means that if we want system-versioned
tables, we’re forced to make it ourselves.</p>

<p>I’m not going to spend paragraph after paragraph explaining why I want temporal
tables before we go to the actual implementation, but I’d like to note that I
want to use these tables primarily for user data, generated by users when they
click/type something on a webpage. They can be used for other things, but if you
have time series, want to do event sourcing or online analytical processing, you
should probably pick some technology suited for that task instead of throwing
temporal tables at it.</p>

<p>If you’re only after the end result, feel free to go to my GitHub repository
<a href="https://github.com/hypirion/time-travelling-todo-lists-in-postgres">time-travelling-todo-lists-in-postgres</a>.
It is a todo list app with time-travelling capabilities, using the
implementation described here. There you’ll have information on how to use it
yourself, how to query the past, as well as gotchas and common pitfalls.</p>

<h2 id="the-implementation">The Implementation</h2>

<p>The implementation I’ve decided on consists of two tables for every table I want
version controlled: A snapshot table for the current state, and a history table.</p>

<svg xmlns="http://www.w3.org/2000/svg" width="640" height="192.709" viewBox="0 0 116.798 35.169"><defs><marker id="a" markerHeight="6.155" markerWidth="5.324" orient="auto-start-reverse" preserveAspectRatio="xMidYMid" refX="0" refY="0" style="overflow:visible" viewBox="0 0 5.324 6.155"><path d="m5.77 0-8.65 5V-5Z" style="fill:context-stroke;fill-rule:evenodd;stroke:context-stroke;stroke-width:1pt" transform="scale(.5)"></path></marker></defs><path d="M16.696 27.08h121.376v35.163H16.696z" style="opacity:.5;fill:#fff;stroke:none;stroke-width:.405499;stroke-linecap:round;stroke-dasharray:none" transform="translate(-19.358 -27.08)"></path><path d="M25.568 37.486h28.927v19.196H25.568z" style="opacity:1;fill:none;stroke:#000;stroke-width:.5;stroke-linecap:round;stroke-dasharray:none" transform="translate(-19.358 -27.08)"></path><text xml:space="preserve" x="30.997" y="45.291" style="font-size:4.23333px;line-height:1.25;font-family:&#34;Source Code Pro&#34;;-inkscape-font-specification:&#34;Source Code Pro&#34;;opacity:1;stroke-width:.264583" transform="translate(-19.358 -27.08)"><tspan x="30.997" y="45.291" style="stroke-width:.264583">Snapshot</tspan><tspan x="30.997" y="50.582" style="stroke-width:.264583">Table</tspan></text><path d="M97.797 37.924h28.927V57.12H97.797z" style="opacity:1;fill:none;stroke:#000;stroke-width:.5;stroke-linecap:round;stroke-dasharray:none" transform="translate(-19.358 -27.08)"></path><text xml:space="preserve" x="103.227" y="45.729" style="font-size:4.23333px;line-height:1.25;font-family:&#34;Source Code Pro&#34;;-inkscape-font-specification:&#34;Source Code Pro&#34;;opacity:1;stroke-width:.264583" transform="translate(-19.358 -27.08)"><tspan x="103.227" y="45.729" style="stroke-width:.264583">History</tspan><tspan x="103.227" y="51.021" style="stroke-width:.264583">Table</tspan></text><path d="M54.73 46.259c15.61-4.797 29.775-4.252 42.848.328" style="opacity:1;fill:none;stroke:#000;stroke-width:.5;stroke-linecap:butt;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1;marker-end:url(#a)" transform="translate(-19.358 -27.08)"></path><text xml:space="preserve" x="69.26" y="33.634" style="font-size:3.175px;line-height:1.25;font-family:&#34;Source Code Pro&#34;;-inkscape-font-specification:&#34;Source Code Pro&#34;;opacity:1;stroke-width:.264583" transform="translate(-19.358 -27.08)"><tspan x="69.26" y="33.634" style="font-size:3.175px;stroke-width:.264583">Inserts</tspan><tspan x="69.26" y="37.603" style="font-size:3.175px;stroke-width:.264583">Updates</tspan><tspan x="69.26" y="41.572" style="font-size:3.175px;stroke-width:.264583">Deletes</tspan></text></svg>

<p>The snapshot table is the one used for the current state of the world and is the
one you’ll usually work with: This works exactly like any other mutable in-place
table you’re familiar with. The history table is the one you’ll use when you
want to query through history.</p>

<p>First off, we define the tables:</p>

<div><div><pre><code><span>CREATE</span> <span>TABLE</span> <span>mytable</span> <span>(</span>
  <span>mytable_id</span> <span>UUID</span> <span>PRIMARY</span> <span>KEY</span> <span>DEFAULT</span> <span>gen_random_uuid</span><span>(),</span>
  <span>data</span> <span>TEXT</span> <span>NOT</span> <span>NULL</span>
<span>);</span>

<span>CREATE</span> <span>TABLE</span> <span>mytable_history</span> <span>(</span>
  <span>-- copy these fields, always keep them first</span>
  <span>history_id</span> <span>UUID</span> <span>PRIMARY</span> <span>KEY</span><span>,</span>
  <span>systime</span> <span>TSTZRANGE</span> <span>NOT</span> <span>NULL</span> <span>CHECK</span> <span>(</span><span>NOT</span> <span>ISEMPTY</span><span>(</span><span>systime</span><span>)),</span>

  <span>-- table fields, in the exact same order as in mytable</span>
  <span>mytable_id</span> <span>UUID</span> <span>NOT</span> <span>NULL</span><span>,</span>
  <span>data</span> <span>TEXT</span> <span>NOT</span> <span>NULL</span>
<span>);</span>

<span>ALTER</span> <span>TABLE</span> <span>mytable_history</span>
  <span>ADD</span> <span>CONSTRAINT</span> <span>mytable_history_overlapping_excl</span>
  <span>EXCLUDE</span> <span>USING</span> <span>GIST</span> <span>(</span><span>mytable_id</span> <span>WITH</span> <span>=</span><span>,</span> <span>systime</span> <span>WITH</span> <span>&amp;&amp;</span><span>);</span>
</code></pre></div></div>

<p>The history table contains the exact same fields as the snapshot table, but the
first two columns in the table are a <code>history_id</code> field and the system time
(<code>systime</code>) it was active. <code>lower(systime)</code> is when this version of the record
was initially stored, and <code>upper(systime)</code> is when this record was no longer
valid. When <code>upper(systime)</code> is infinity, the record has not yet been deleted.
The interval can’t be empty obviously, as that wouldn’t match any time interval.</p>

<p>Next, we have a GiST index, which prevents us from having overlapping time
intervals for the same primary key, and also speeds up queries on the history.
You may want to add some more indices on the history table, depending on what
kind of queries you want to do on it.</p>

<p>Then we set up triggers for insert, update and delete:</p>

<div><div><pre><code><span>--</span>
<span>-- insert:</span>
<span>--</span>

<span>CREATE</span> <span>OR</span> <span>REPLACE</span> <span>FUNCTION</span> <span>copy_mytable_inserts_into_history</span><span>()</span>
          <span>RETURNS</span> <span>TRIGGER</span> <span>AS</span> <span>$$</span>
  <span>INSERT</span> <span>INTO</span> <span>mytable_history</span>
    <span>SELECT</span> <span>gen_random_uuid</span><span>(),</span> <span>tstzrange</span><span>(</span><span>NOW</span><span>(),</span> <span>NULL</span><span>),</span> <span>NEW</span><span>.</span><span>*</span><span>;</span>
  <span>RETURN</span> <span>NEW</span><span>;</span>
<span>$$</span> <span>LANGUAGE</span> <span>plpgsql</span><span>;</span>

<span>CREATE</span> <span>TRIGGER</span> <span>mytable_history_insert_trigger</span>
<span>AFTER</span> <span>INSERT</span> <span>ON</span> <span>mytable</span>
    <span>FOR</span> <span>EACH</span> <span>ROW</span>
    <span>EXECUTE</span> <span>PROCEDURE</span> <span>copy_mytable_inserts_into_history</span><span>();</span>

<span>--</span>
<span>-- update:</span>
<span>--</span>

<span>CREATE</span> <span>OR</span> <span>REPLACE</span> <span>FUNCTION</span> <span>copy_mytable_updates_into_history</span><span>()</span>
          <span>RETURNS</span> <span>TRIGGER</span> <span>AS</span> <span>$$</span>
  <span>-- ignore changes inside the same tx</span>
  <span>DELETE</span> <span>FROM</span> <span>mytable_history</span>
    <span>WHERE</span> <span>mytable_id</span> <span>=</span> <span>NEW</span><span>.</span><span>mytable_id</span>
      <span>AND</span> <span>lower</span><span>(</span><span>systime</span><span>)</span> <span>=</span> <span>NOW</span><span>()</span>
      <span>AND</span> <span>upper_inf</span><span>(</span><span>systime</span><span>);</span>
  <span>-- close current row</span>
  <span>-- (if any, may be deleted by previous line)</span>
  <span>UPDATE</span> <span>mytable_history</span>
    <span>SET</span> <span>systime</span> <span>=</span> <span>tstzrange</span><span>(</span><span>lower</span><span>(</span><span>systime</span><span>),</span> <span>NOW</span><span>())</span>
    <span>WHERE</span> <span>mytable_id</span> <span>=</span> <span>NEW</span><span>.</span><span>mytable_id</span>
      <span>AND</span> <span>systime</span> <span>@&gt;</span> <span>NOW</span><span>();</span>
  <span>-- insert new row</span>
  <span>INSERT</span> <span>INTO</span> <span>mytable_history</span>
    <span>SELECT</span> <span>gen_random_uuid</span><span>(),</span> <span>tstzrange</span><span>(</span><span>NOW</span><span>(),</span> <span>NULL</span><span>),</span> <span>NEW</span><span>.</span><span>*</span><span>;</span>
  <span>RETURN</span> <span>NEW</span><span>;</span>
<span>$$</span> <span>LANGUAGE</span> <span>plpgsql</span><span>;</span>

<span>CREATE</span> <span>TRIGGER</span> <span>mytable_history_update_trigger</span>
<span>AFTER</span> <span>UPDATE</span> <span>ON</span> <span>mytable</span>
    <span>FOR</span> <span>EACH</span> <span>ROW</span>
    <span>WHEN</span> <span>(</span><span>OLD</span><span>.</span><span>*</span> <span>IS</span> <span>DISTINCT</span> <span>FROM</span> <span>NEW</span><span>.</span><span>*</span><span>)</span>
    <span>-- ^ to avoid updates on &#34;noop calls&#34;, as best as possible</span>
    <span>EXECUTE</span> <span>PROCEDURE</span> <span>copy_mytable_updates_into_history</span><span>();</span>

<span>--</span>
<span>-- delete:</span>
<span>--</span>

<span>CREATE</span> <span>OR</span> <span>REPLACE</span> <span>FUNCTION</span> <span>copy_mytable_deletes_into_history</span><span>()</span>
          <span>RETURNS</span> <span>TRIGGER</span> <span>AS</span> <span>$$</span>
  <span>-- close current row</span>
  <span>-- note: updates and then deletes for same id</span>
  <span>-- in same tx will fail</span>
  <span>UPDATE</span> <span>mytable_history</span>
    <span>SET</span> <span>systime</span> <span>=</span> <span>tstzrange</span><span>(</span><span>lower</span><span>(</span><span>systime</span><span>),</span> <span>NOW</span><span>())</span>
    <span>WHERE</span> <span>mytable_id</span> <span>=</span> <span>OLD</span><span>.</span><span>mytable_id</span>
      <span>AND</span> <span>systime</span> <span>@&gt;</span> <span>NOW</span><span>();</span>
  <span>RETURN</span> <span>OLD</span><span>;</span>
<span>$$</span> <span>LANGUAGE</span> <span>plpgsql</span><span>;</span>


<span>CREATE</span> <span>TRIGGER</span> <span>mytable_history_delete_trigger</span>
<span>AFTER</span> <span>DELETE</span> <span>ON</span> <span>mytable</span>
    <span>FOR</span> <span>EACH</span> <span>ROW</span>
    <span>EXECUTE</span> <span>PROCEDURE</span> <span>copy_mytable_deletes_into_history</span><span>();</span>
</code></pre></div></div>

<p>This is… long, to put it mildly, so let’s go through some common tricks all
the three triggers (ab)use, and then go over some design decisions I’ve decided
on for updates and deletes. We’ll get around to shortening it at the end.</p>

<h3 id="column-order-matters">Column Order Matters</h3>

<p>Whenever we insert new data into the history table, it will always be on this
form:</p>

<div><div><pre><code><span>INSERT</span> <span>INTO</span> <span>mytable_history</span>
  <span>SELECT</span> <span>gen_random_uuid</span><span>(),</span> <span>tstzrange</span><span>(</span><span>NOW</span><span>(),</span> <span>NULL</span><span>),</span> <span>NEW</span><span>.</span><span>*</span><span>;</span>
</code></pre></div></div>

<p>There are two parts of Postgres we abuse here. If we look at <a href="https://www.postgresql.org/docs/16/sql-insert.html">the docs for
INSERT</a>, we’ll see the
following paragraph:</p>

<blockquote>
  <p>The target column names can be listed in any order. If no list of column names
is given at all, the default is all the columns of the table in their declared
order; or the first <strong><em>N</em></strong> column names, if there are only <strong><em>N</em></strong> columns
supplied by the <code>VALUES</code> clause or <strong><em><code>query</code></em></strong>. The values supplied by the
<code>VALUES</code> clause or <strong><em><code>query</code></em></strong> are associated with the explicit or implicit
column list left-to-right.</p>
</blockquote>

<p>The other is that <code>NEW.*</code> expands in the exact same order. In our case, <code>NEW.*</code>
will expand into <code>NEW.mytable_id, NEW.data</code>, and that means it fits perfectly
with the rows of <code>mytable_history</code>:</p>

<div><div><pre><code><span>INSERT</span> <span>INTO</span> <span>mytable_history</span>
  <span>SELECT</span> <span>gen_random_uuid</span><span>(),</span> <span>tstzrange</span><span>(</span><span>NOW</span><span>(),</span> <span>NULL</span><span>),</span>
         <span>NEW</span><span>.</span><span>mytable_id</span><span>,</span> <span>NEW</span><span>.</span><span>data</span><span>;</span>
</code></pre></div></div>

<p>This is pretty clever, but it’s also hacky. For this to work, there are two
things you have to get right:</p>

<ul>
  <li>Column order MUST be identical after the <code>history_id</code> and <code>systime</code> columns.</li>
  <li>Whenever you add new columns, you MUST add them in the same order to both
tables.</li>
</ul>

<p>If you don’t do so, you will end up with broken inserts in the history table.
Those will at best give you an error, but they can also silently corrupt your
data.</p>

<p>I don’t like that, but there’s a reason why I don’t do</p>

<div><div><pre><code><span>INSERT</span> <span>INTO</span> <span>mytable_history</span>
  <span>(</span><span>history_id</span><span>,</span> <span>systime</span><span>,</span> <span>mytable_id</span><span>,</span> <span>data</span><span>)</span>
<span>SELECT</span> <span>gen_random_uuid</span><span>(),</span> <span>tstzrange</span><span>(</span><span>NOW</span><span>(),</span> <span>NULL</span><span>),</span>
       <span>NEW</span><span>.</span><span>mytable_id</span><span>,</span> <span>NEW</span><span>.</span><span>data</span><span>;</span>
</code></pre></div></div>

<p>and that’s because it creates <strong>a lot</strong> of effort when you want to remove,
rename or add a new column to the table. By omitting the list of target column
names and expanding <code>NEW.*</code>, the query will automatically work whenever I decide
to add, update or remove columns – provided I do it for both tables.</p>

<h3 id="on-system-time">On System Time</h3>

<p>If you haven’t worked with Postgres ranges before, the range queries may look a
bit cryptic. The Postgres docs have an excellent description of <a href="https://www.postgresql.org/docs/16/rangetypes.html">range
types</a> and <a href="https://www.postgresql.org/docs/16/functions-range.html">range
functions</a>, which
should cover essentially everything related to them. I don’t use much of it
though, so since I guess you don’t want to go through it all, I’ll just list up
what the different parts do.</p>

<p>The expression</p>



<p>creates the timestamptz range <code>[a, b)</code>: from <em>a</em>, up to and excluding <em>b</em>. If
either <em>a</em> or <em>b</em> are <code>NULL</code>, then they are infinitely far in the past or
future, respectively.</p>

<p><code>lower(x)</code> returns the lower bound of the range, and <code>upper_inf(x)</code> returns
true if the upper bound is infinite.</p>

<p>Finally, <code>systime @&gt; NOW()</code> checks if <code>systime</code> contains <code>NOW()</code> – you can
think of it as <code>a &lt;= NOW() AND NOW() &lt; b</code>.</p>

<p>The reason for using ranges isn’t primarily because I want to use these
functions, but rather because the GiST index ensures no overlap and makes me
less worried that my queries will be super slow by accident.</p>

<h3 id="inserts">Inserts</h3>

<p>With those two things described, inserts are more or less described in their
entirety: We insert the row into the history table, saying it’s valid from the
transaction start time until forever.</p>

<h3 id="updates">Updates</h3>

<p>The update trigger looks like this:</p>

<div><div><pre><code><span>-- ignore changes inside the same tx</span>
<span>DELETE</span> <span>FROM</span> <span>mytable_history</span>
  <span>WHERE</span> <span>mytable_id</span> <span>=</span> <span>NEW</span><span>.</span><span>mytable_id</span>
    <span>AND</span> <span>lower</span><span>(</span><span>systime</span><span>)</span> <span>=</span> <span>NOW</span><span>()</span>
    <span>AND</span> <span>upper_inf</span><span>(</span><span>systime</span><span>);</span>
<span>-- close current row</span>
<span>UPDATE</span> <span>mytable_history</span>
  <span>SET</span> <span>systime</span> <span>=</span> <span>tstzrange</span><span>(</span><span>lower</span><span>(</span><span>systime</span><span>),</span> <span>NOW</span><span>())</span>
  <span>WHERE</span> <span>mytable_id</span> <span>=</span> <span>NEW</span><span>.</span><span>mytable_id</span>
    <span>AND</span> <span>systime</span> <span>@&gt;</span> <span>NOW</span><span>();</span>
<span>-- insert new row</span>
<span>INSERT</span> <span>INTO</span> <span>mytable_history</span>
  <span>SELECT</span> <span>gen_random_uuid</span><span>(),</span> <span>tstzrange</span><span>(</span><span>NOW</span><span>(),</span> <span>null</span><span>),</span> <span>NEW</span><span>.</span><span>*</span><span>;</span>
</code></pre></div></div>

<p>It is set up so that multiple updates in the same transaction will only produce
a single history row. That’s intentional, because otherwise ordering would be
harder to implement.</p>

<p>If you need multiple versions in the same transaction, you’ll have to replace
the half-open interval (the default <code>[)</code>) with a closed one (<code>[]</code>). If not,
you’ll end up with empty intervals, which aren’t tied to any timestamps. But now
you have to handle identical states at a single timestamp, as multiple records
can get the <code>[NOW(), NOW()]</code> interval. If the ordering matters in that case,
you’ll have to add another ordering ID to get rows back in the inserted order.</p>

<p>I don’t need that, it’s complicated, and I don’t think it makes sense to have
multiple states at a single point in time anyway. If you need that, you’re
probably interested in an event table or something else instead.</p>

<h3 id="deletions">Deletions</h3>

<div><div><pre><code><span>-- close current row</span>
<span>-- note: updates and then deletes for same id</span>
<span>-- in same tx will fail</span>
<span>UPDATE</span> <span>mytable_history</span>
  <span>SET</span> <span>systime</span> <span>=</span> <span>tstzrange</span><span>(</span><span>lower</span><span>(</span><span>systime</span><span>),</span> <span>NOW</span><span>())</span>
  <span>WHERE</span> <span>mytable_id</span> <span>=</span> <span>OLD</span><span>.</span><span>mytable_id</span>
    <span>AND</span> <span>systime</span> <span>@&gt;</span> <span>NOW</span><span>();</span>
</code></pre></div></div>

<p>When it comes to atomicity, deletions are somewhat of an outlier. If you update
and then delete something in the same transaction, what should you do? And uh..
why would you do that in the first place?</p>

<p>“Update and delete” seems quite handy if you want to write down who deleted the
object, in which case the deletion will look like this:</p>

<div><div><pre><code><span>UPDATE</span> <span>mytable</span>
  <span>SET</span> <span>deleted_by</span> <span>=</span> <span>$</span><span>{</span><span>deleted_by</span><span>}</span>
<span>WHERE</span> <span>mytable_id</span> <span>=</span> <span>$</span><span>{</span><span>mytable_id</span><span>};</span>

<span>DELETE</span> <span>FROM</span> <span>mytable</span>
<span>WHERE</span> <span>mytable_id</span> <span>=</span> <span>$</span><span>{</span><span>mytable_id</span><span>};</span>
</code></pre></div></div>

<p>… however, it leaves you with an annoying record: The “delete” record, which
isn’t really part of the history, but only contains some information about the
deletion itself.</p>

<p>I think it’s better to make a little bit of effort for these, even if you don’t
have an immediate need for a changelog/audit log: Store the deletion information
in a table. You could create one for all tables, or just one for everything
depending on how lazy you are:</p>

<div><div><pre><code><span>CREATE</span> <span>TABLE</span> <span>delete_log</span> <span>(</span>
  <span>delete_log_id</span> <span>UUID</span> <span>PRIMARY</span> <span>KEY</span> <span>DEFAULT</span> <span>gen_random_uuid</span><span>(),</span>
  <span>table_name</span> <span>TEXT</span> <span>NOT</span> <span>NULL</span><span>,</span>
  <span>resource_id</span> <span>UUID</span> <span>NOT</span> <span>NULL</span><span>,</span>
  <span>deleted_at</span> <span>TIMESTAMPTZ</span> <span>NOT</span> <span>NULL</span> <span>DEFAULT</span> <span>NOW</span><span>(),</span>
  <span>deleted_by</span> <span>UUID</span> <span>NOT</span> <span>NULL</span> <span>REFERENCES</span> <span>users</span><span>(</span><span>user_id</span><span>)</span>
<span>);</span>

<span>-- then delete as follows</span>

<span>INSERT</span> <span>INTO</span> <span>delete_log</span> <span>(</span><span>table_name</span><span>,</span> <span>resource_id</span><span>,</span> <span>deleted_by</span><span>)</span>
<span>VALUES</span> <span>(</span><span>&#39;mytable&#39;</span><span>,</span> <span>$</span><span>{</span><span>mytable_id</span><span>},</span> <span>$</span><span>{</span><span>deleted_by</span><span>});</span>

<span>DELETE</span> <span>FROM</span> <span>mytable</span>
<span>WHERE</span> <span>mytable_id</span> <span>=</span> <span>$</span><span>{</span><span>mytable_id</span><span>};</span>
</code></pre></div></div>

<p>I can’t make a trigger out of this easily (or maybe not at all), because
<code>deleted_by</code> is information we’ll have to pass down into the database somehow.</p>

<h2 id="annoying-conflicts">Annoying Conflicts</h2>

<p>While the triggers themselves don’t impact what you can and cannot do, the GiST
index will blow up most attempts at concurrently updating the same item:</p>

<div><div><pre><code><span>ALTER</span> <span>TABLE</span> <span>mytable_history</span>
  <span>ADD</span> <span>CONSTRAINT</span> <span>mytable_history_overlapping_excl</span>
  <span>EXCLUDE</span> <span>USING</span> <span>GIST</span> <span>(</span><span>mytable_id</span> <span>WITH</span> <span>=</span><span>,</span> <span>systime</span> <span>WITH</span> <span>&amp;&amp;</span><span>);</span>
</code></pre></div></div>

<p>This will even fail if you do <code>SELECT .. FOR UPDATE</code>. When you have two
transactions A and B coming in, if the transaction with the most recent <code>NOW()</code>
timestamp gets the lock first, the second transaction will fail because
<code>systime</code> ends up as an empty interval.</p>

<p>It’s annoying, but not a big deal for me at least. The tables where I need
history usually never need write concurrency on the same ID. And if they do,
it’s not hard to add a retry loop around the writes… though of course, it
adds a pitfall you need to be aware of.</p>

<p>Trying to fix this by using <code>CLOCK_TIMESTAMP()</code> instead of <code>NOW()</code> will only
make things worse in my opinion. If you desire to insert multiple items at the
same time, usually none of them will have the same timestamp. That makes certain
queries on the history table technically wrong:</p>

<p>Imagine you have a list and list element table, and a user creates a new list
with 10 elements. With <code>CLOCK_TIMESTAMP()</code>, you now end up with 11 different
timestamps: One for the list root, and 10 for each list element. If you wondered
what the list looked like when it was first created, you’d first have to fetch
the list root. Then you have to fetch all elements that were in the list, say,
as of 1 second after it was created, to be relatively sure all the list elements
are also returned. But any attempt at recreating the state at some arbitrary
time in the past may end up with partial/corrupt results. For that reason, I
highly recommend avoiding this, and rather using some other method to persist
history if you really need it.</p>

<h2 id="alternatives">Alternatives</h2>

<p>A trigger-based model seems to me like the best one if you have to use Postgres,
but there are some alternatives you may want to consider.</p>

<h3 id="do-you-need-the-history">Do You Need The History?</h3>

<p>There is added complexity here, and there is an increased chance of transactions
failing because of overlapping timestamps that you can’t really prevent. That
begs the question: Do you really need the history?</p>

<p>My “controversial” opinion is that, in this day and age, I feel the true
question is really a matter of whether you can afford it performance-wise, and
not whether it’s too complex. This particular implementation of persisting
history is probably not very fast, but it is conceptually simple: Whenever you
do something to a table, that action is stored in a history table. The original
table is intentionally identical to what you’re used to. If you really don’t
like the potential GiST conflicts, you can relax the constraints to get
identical behaviour to what you’re used to. In that case, the only difference is
the insert/delete/update performance.</p>

<p>Yes, there are many cases where it’s clearly bonkers to retain the history, but
I also think many people assume storing the history is costlier than it actually
is<sup id="fnref:small-systems" role="doc-noteref"><a href="#fn:small-systems" rel="footnote">1</a></sup>. If you’re not sure, try it and see how it goes. Since your
original table will be untouched, it’s not hard to roll back.</p>

<p>For me, there are two reasons I think you should consider it, even if you have
no immediate plans to expose this to your users:</p>

<p>First, there will be a time when a specific customer needs their data rolled
back to an earlier version. That could either be because of accidental deletes,
rogue actors, or even a bad deployment that corrupted data for certain
customers. While this doesn’t replace backups by a long shot, it’s a lot faster
and easier to do</p>

<div><div><pre><code><span>BEGIN</span><span>;</span>

<span>DELETE</span> <span>FROM</span> <span>mytable</span>
<span>WHERE</span> <span>company_id</span> <span>=</span> <span>$</span><span>{</span><span>company_id</span><span>};</span>

<span>INSERT</span> <span>INTO</span> <span>mytable</span> <span>(</span><span>your</span><span>,</span> <span>fields</span><span>,</span> <span>here</span><span>)</span>
<span>SELECT</span> <span>h</span><span>.</span><span>your</span><span>,</span> <span>h</span><span>.</span><span>field</span><span>,</span> <span>h</span><span>.</span><span>here</span>
<span>FROM</span> <span>mytable_history</span> <span>h</span>
<span>WHERE</span> <span>h</span><span>.</span><span>company_id</span> <span>=</span> <span>$</span><span>{</span><span>company_id</span><span>}</span>
  <span>AND</span> <span>h</span><span>.</span><span>systime</span> <span>@&gt;</span> <span>$</span><span>{</span><span>backup_time</span><span>};</span>

<span>COMMIT</span><span>;</span>
</code></pre></div></div>

<p>It will of course end up being a little more complex than that in practice,
depending on the data model and how fine-grained you want to be. But it’s less
effort than setting up the backup server, bridging it with a foreign data
wrapper, and then finally doing the inserts in exactly the same manner as above,
before cleaning up the backup server afterwards.</p>

<p>There are other cases too, like debugging a transient issue one of your
users had. I could go on, but it feels like repeating the sales pitch for
<a href="https://www.datomic.com/">Datomic</a>.</p>

<p>The second reason relates to the gut reaction of saying “We don’t need it”: If
you don’t have time travel abilities readily available, you can’t explore and
play with them. This, in turn, means you won’t really think of them when
developing new functionality for your customers. At the risk of sounding like a
techbro: I think it stifles innovation. Do you <em>really</em> think there’s no value
for it somewhere in your system in the future?</p>

<p>Yeah, yeah, this sounds a lot like future-proofing. To be clear, YAGNI isn’t
wrong, but I only think it only applies when there’s either</p>

<ul>
  <li>significant overhead (either in terms of implementation complexity or
system performance)</li>
  <li>something that can be retroactively implemented (i.e. no data loss)</li>
</ul>

<p>and system-versioned tables are neither.</p>

<p>… well, uh, let me clarify here. The current implementation I’ve shown you
requires a lot of work when you make new tables. Which is a good transition to
my next point:</p>

<h3 id="use-a-database-suited-for-the-task">Use a Database Suited for the Task</h3>

<p>Writing all of these long triggers yourself just because Postgres doesn’t
support it is a bit stupid. If you want an open-source alternative, perhaps
MariaDB isn’t too bad? It supports
<a href="https://mariadb.com/kb/en/system-versioned-tables/">SQL:2011</a> and even has
support for bitemporality if you want to go even further.</p>

<p>Of course, I’d be amiss if I didn’t mention <a href="https://www.datomic.com/">Datomic</a>.
It is a great database, although not open-source, and language support is rather
limited (only Java/Clojure officially). For the ones in Microsoft land, <a href="https://learn.microsoft.com/en-us/sql/relational-databases/tables/temporal-tables?view=sql-server-ver16">SQL
Server</a>
has great support for SQL:2011 as well, from what I gather.</p>

<p>As mentioned, this is aimed at user data generated by someone clicking or typing
around on a webpage, mutating some content of theirs. But for IoT data, you’d
like some other tool than temporal tables, and if you’re big enough, you
probably want to use an OLAP database for OLAP stuff.</p>

<h2 id="sloppy-paste-or-eldritch-horrors">Sloppy-Paste or Eldritch Horrors</h2>

<p>I am stuck with Postgres, both because that’s what I already got, but also
because I heavily use PostGIS. Migrating away is simply not an option, so I have
to make do with what I have.</p>

<p>What I like about the trigger solution is that it is – aside from the column
expansion hack – not terribly hard to understand. The problem is that it’s very
verbose, and after being burnt from a couple of copy-paste mistakes in the past,
I’d rather have a single trigger for every table if possible.</p>

<p>It is possible… though it does not look pretty. Here’s what the update trigger
looks like after we make the history table and ID field into input parameters:</p>

<div><div><pre><code><span>CREATE</span> <span>FUNCTION</span> <span>copy_updates_into_history</span><span>()</span> <span>RETURNS</span> <span>TRIGGER</span> <span>AS</span> <span>$$</span>
<span>DECLARE</span>
  <span>history_table</span> <span>TEXT</span> <span>:</span><span>=</span> <span>quote_ident</span><span>(</span><span>tg_argv</span><span>[</span><span>0</span><span>]);</span>
  <span>id_field</span> <span>TEXT</span> <span>:</span><span>=</span> <span>quote_ident</span><span>(</span><span>tg_argv</span><span>[</span><span>1</span><span>]);</span>
<span>BEGIN</span>
  <span>-- ignore changes inside the same tx</span>
  <span>EXECUTE</span> <span>&#39;DELETE FROM &#39;</span> <span>||</span> <span>history_table</span> <span>||</span>
    <span>&#39; WHERE &#39;</span> <span>||</span> <span>id_field</span> <span>||</span> <span>&#39; = $1.&#39;</span> <span>||</span> <span>id_field</span> <span>||</span>
    <span>&#39; AND lower(systime) = NOW()&#39;</span> <span>||</span>
    <span>&#39; AND upper_inf(systime)&#39;</span> <span>USING</span> <span>NEW</span><span>;</span>
  <span>-- close current row</span>
  <span>-- (if any, may be deleted by previous line)</span>
  <span>EXECUTE</span> <span>&#39;UPDATE &#39;</span> <span>||</span> <span>history_table</span> <span>||</span>
    <span>&#39; SET systime = tstzrange(lower(systime), NOW())&#39;</span>
    <span>&#39; WHERE &#39;</span> <span>||</span> <span>id_field</span> <span>||</span> <span>&#39; = $1.&#39;</span> <span>||</span> <span>id_field</span> <span>||</span>
    <span>&#39; AND systime @&gt; NOW()&#39;</span> <span>USING</span> <span>NEW</span><span>;</span>
  <span>-- insert new row</span>
  <span>EXECUTE</span> <span>&#39;INSERT INTO &#39;</span> <span>||</span> <span>history_table</span> <span>||</span>
    <span>&#39; SELECT gen_random_uuid(), tstzrange(NOW(), null), $1.*&#39;</span>
    <span>USING</span> <span>NEW</span><span>;</span>
  <span>RETURN</span> <span>NEW</span><span>;</span>
<span>END</span><span>;</span>
<span>$$</span> <span>LANGUAGE</span> <span>plpgsql</span><span>;</span>
</code></pre></div></div>

<p>(The insert and update triggers are similar, so I won’t go over them here.)</p>

<p>To factor out the history table and ID field, we have to use
<a href="https://www.postgresql.org/docs/16/plpgsql-statements.html#PLPGSQL-STATEMENTS-EXECUTING-DYN"><code>EXECUTE</code></a>,
which makes the entire thing feel even more hacky. It looks ugly, and if you’re
not familiar with <code>EXECUTE</code> or the previously mentioned column expansion magic,
it may feel outright eldritch. However, I think this is better than the first
attempt at the trigger implementation for one big reason. And that is best shown
by using it in practice:</p>

<div><div><pre><code><span>CREATE</span> <span>TRIGGER</span> <span>mytable_history_update_trigger</span>
<span>AFTER</span> <span>UPDATE</span> <span>ON</span> <span>mytable</span>
    <span>FOR</span> <span>EACH</span> <span>ROW</span>
    <span>WHEN</span> <span>(</span><span>OLD</span><span>.</span><span>*</span> <span>IS</span> <span>DISTINCT</span> <span>FROM</span> <span>NEW</span><span>.</span><span>*</span><span>)</span>
    <span>-- ^ to avoid updates on &#34;noop calls&#34;, as best as possible</span>
    <span>EXECUTE</span> <span>PROCEDURE</span>
      <span>copy_updates_into_history</span><span>(</span><span>&#39;mytable_history&#39;</span><span>,</span> <span>&#39;mytable_id&#39;</span><span>);</span>
</code></pre></div></div>

<p>This is much less verbose to use if you want to retain history for multiple
tables!</p>

<p>While it’s true that the query can’t be type-checked ahead of time, the original
trigger won’t be either. <em>We have to run them to verify that they don’t refer to
wrong tables or ids</em>. If that’s the case, then we should pick the alternative
that reduces the chance of a sloppy search-replace.</p>

<p>And this new implementation does that! This trigger has the history table and
the ID field in only two locations – the input arguments, whereas the original
trigger implementation had them spread out all around in 7 different locations.
Also, let’s face it: copy-pasting some big triggers for every single table we
want system versioned just wouldn’t feel right.</p>

<h2 id="summary">Summary</h2>

<p>The full implementation is over in the
<a href="https://github.com/hypirion/time-travelling-todo-lists-in-postgres">time-travelling-todo-lists-in-postgres</a>
repository, and the triggers are in the migration file <a href="https://github.com/hypirion/time-travelling-todo-lists-in-postgres/blob/main/migrations/001_history_triggers.up.sql"><code>migrations/001_history_triggers.up.sql</code></a>.</p>

<p>As I mentioned, this isn’t perfect: You have some big pitfalls related to table
modifications, it adds a risk of having concurrent updates break, and other databases
should have a much better implementation than my three triggers. It’s probably
not suitable for large databases either.</p>

<p>But if you’re stuck with Postgres, I think this is fine. However, I think you
should be aware of how the implementation works in detail, as there are a couple
of ways to shoot yourself in the foot. And if you’ve come this far down, you
hopefully do!</p>


</article>
</div></div>
  </body>
</html>
