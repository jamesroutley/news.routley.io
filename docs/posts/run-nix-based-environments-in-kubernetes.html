<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://flox.dev/kubernetes/">Original</a>
    <h1>Run Nix Based Environments in Kubernetes</h1>
    
    <div id="readability-page-1" class="page"><div id="__next"><main><section><div><p>No more image rebuilds. Run the same immutable declarative environment across local dev → CI → production Kubernetes clusters: on x86 <em>and</em> ARM. Get faster deployments, SBOMs-by-default, and atomic rollbacks.</p><p><a href="https://hub.flox.dev"><span></span><span></span>Sign up for free →</a></p></div></section><section><h2>Why Go Uncontained</h2><ul><li><span aria-hidden="true"><img alt="" loading="lazy" width="32" height="32" decoding="async" data-nimg="1" src="https://flox.dev/images/kubernetes/features/no-image-builds.svg"/></span><h3>Skip registry round trips</h3><p>Pull declarative Flox environments at runtime; each node downloads only required hash-pinned packages—push/pull the environment definition, not the payload; end multi-gigabyte round trips.</p></li><li><span aria-hidden="true"><img alt="" loading="lazy" width="32" height="32" decoding="async" data-nimg="1" src="https://flox.dev/images/kubernetes/features/speed.svg"/></span><h3>Predictable starts</h3><p>Node-local, hash-addressed, pre-warmed caches mean no multi-gig pulls and fast, predictable startup.</p></li><li><span aria-hidden="true"><img alt="" loading="lazy" width="32" height="32" decoding="async" data-nimg="1" src="https://flox.dev/images/kubernetes/features/reproducibility.svg"/></span><h3>Reproducibility</h3><p>Run the same cryptographically hashed environment across dev, CI, and prod clusters; zero drift, atomic rollbacks.</p></li><li><span aria-hidden="true"><img alt="" loading="lazy" width="32" height="32" decoding="async" data-nimg="1" src="https://flox.dev/images/kubernetes/features/security.svg"/></span><h3>Built‑in security</h3><p>Smaller attack surface, SBOMs and provenance by default.</p></li><li><span aria-hidden="true"><img alt="" loading="lazy" width="32" height="32" decoding="async" data-nimg="1" src="https://flox.dev/images/kubernetes/features/operational-simplicity.svg"/></span><h3>Operational simplicity</h3><p>Keep the primitives you know—Kubernetes stays Kubernetes. A Flox-maintained <code>containerd</code> shim with a <code>RuntimeClass</code> lets pods run closer to the metal, with a smaller footprint that’s faster to deploy.</p></li></ul></section><section><div><blockquote><p>“Like Kata or gVisor extend CRI for isolation, Flox uses CRI to deliver<strong> Nix‑style reproducibility</strong>—so you run only the software you actually need.”</p></blockquote><div><p><img alt="Kelsey Hightower" width="83" height="83" decoding="async" data-nimg="1" src="https://flox.dev/images/kubernetes/testimonial/kelsey-hightower.jpeg"/></p></div></div></section><div><section><section><div><div><p>800→0 MB</p><p>Base image elimination</p></div><div><p>5→2</p><p>Pipeline stages eliminated</p></div></div></section></section><section><div><div><p><img alt="" aria-hidden="true" loading="lazy" width="28" height="28" decoding="async" data-nimg="1" src="https://flox.dev/images/kubernetes/use-cases/zap-fast.svg"/></p><h2>Uncontained</h2></div><div><div><p><img alt="" loading="lazy" width="24" height="24" decoding="async" data-nimg="1" src="https://flox.dev/images/kubernetes/use-cases/sparkles.svg"/></p><div><h3>AI/ML Teams</h3><p>Define AI/ML models as hash-pinned, declarative environments. Zero‑copy model serving: load once, reuse across pods. Hot-swap models with just one edit. Run the same env across dev, CI, and prod.</p></div></div><div><p><img alt="" loading="lazy" width="24" height="24" decoding="async" data-nimg="1" src="https://flox.dev/images/kubernetes/use-cases/beaker.svg"/></p><div><h3>Data Science</h3><p>Enable Jupyter-first data science across the SDLC. Add packages as you explore; when ready, deploy the same locked, hash-addressed environment in Jupyter on Kubernetes, batch jobs (training/ETL pipelines), and services (model serving/APIs). No image rebuilds required.</p></div></div><div><p><img alt="" loading="lazy" width="24" height="24" decoding="async" data-nimg="1" src="https://flox.dev/images/kubernetes/use-cases/command-line.svg"/></p><div><h3>Platform Engineering / SRE</h3><p>Eliminate image rebuilds and registry pulls with immutable Flox environments. Deploy faster, without cold starts. Roll back atomically. Run one declarative environment definition across Kubernetes on x86 and ARM.</p></div></div><div><p><img alt="" loading="lazy" width="24" height="24" decoding="async" data-nimg="1" src="https://flox.dev/images/kubernetes/use-cases/shield-check.svg"/></p><div><h3>Security Engineering</h3><p>Shrink your attack surface, get SBOMs by default, roll back atomically—no mutable images or registry exposure. Deploy only exact, versioned dependencies. Compliance? It’s built-in.</p></div></div><div><p><img alt="" loading="lazy" width="24" height="24" decoding="async" data-nimg="1" src="https://flox.dev/images/kubernetes/use-cases/cog-6-tooth.svg"/></p><div><h3>Software Engineering</h3><p>One declarative environment runs across laptops, CI, and prod clusters—no image drift. Edit and redeploy in seconds; no build-push-pull cycle. Test locally against exactly what runs in prod.</p></div></div><div><p><img alt="" loading="lazy" width="24" height="24" decoding="async" data-nimg="1" src="https://flox.dev/images/kubernetes/use-cases/presentation-bar-chart.svg"/></p><div><h3>Data Engineering</h3><p>Reproducible pipelines without custom images. Run Spark, dbt, and CLI stacks in the same hash-addressed environment across dev, CI, and prod clusters. Faster deployments, predictable runs.</p></div></div></div></div></section></div><section><h2>How It Works</h2><p>From definition to running workloads</p><ul><li><p><img alt="" loading="lazy" width="262" height="266" decoding="async" data-nimg="1" src="https://flox.dev/images/kubernetes/how-it-works/define.svg"/></p><h3>Define and publish the environment.</h3></li><li><p><img alt="" loading="lazy" width="262" height="266" decoding="async" data-nimg="1" src="https://flox.dev/images/kubernetes/how-it-works/references-manifests.svg"/></p><h3>Reference it in Kubernetes manifests.</h3></li><li><p><img alt="" loading="lazy" width="262" height="266" decoding="async" data-nimg="1" src="https://flox.dev/images/kubernetes/how-it-works/run-anywhere.svg"/></p><h3>Deploy faster, no images required.</h3></li></ul></section><section></section><section></section><section><section><div><p><h2>Frequently asked questions</h2></p><div><div><div><div><p>A <a href="https://kubernetes.io/docs/concepts/architecture/cri/" target="_blank" rel="noopener noreferrer">CRI</a>-level containerd runtime shim that still runs standard containers inside pods. At startup, the shim activates a Flox environment inside the container. CI/CD stays the same—but instead of shipping image layers, you specify the name of a declarative Flox environment (immutable, Nix-backed). Pods read only the required, input-addressed packages from a node-local cache—so no multi-gigabyte image pulls.</p></div></div><div><div><div><p>You replace build-push-pull image pipelines with a declarative Flox environment, the dependencies of which resolve to hash-addressed packages that live in an immutable, node-local store. Organizations can run their own private, signed binary caches, enabling them to build or mirror packages inside their networks, generate SBOMs and attestations (see <strong>SBOM</strong>s, below), and point security scanners at that cache. At runtime, nodes fetch only hash-addressed artifacts, so existing provenance, approval, and CVE workflows carry over.</p><p>In sum: organizations shift from shipping <em>snapshots</em> (container images) to shipping <em>recipes</em> (declarative environments); recipes yield <strong>SBOMs-by-default</strong>, single-edit A/B and atomic rollbacks, faster CVE triaging, and other operational benefits. For developers, AI/ML engineers, and other practitioners, Flox environments run as subshells, <em>not</em> containers, so developers can work directly on their local systems, with free access to all resources. Flox development environments are co-located with Git repos, so PRs always update code <em>and</em> runtime together. The same environment travels across the SDLC: local dev → CI → production Kubernetes clusters.</p></div></div></div><div><div><div><p>Build and test locally using the same exact packages you use for deployments. Declaratively define all runtime dependencies, variables, services, build recipes, and system constraints. Push changes to FloxHub with <strong><code>flox push</code></strong>. Your Kubernetes Pod specifications reference Flox environments and pull these automatically from <a href="https://flox.dev/docs/concepts/floxhub/" target="_blank" rel="noopener noreferrer">FloxHub</a> at runtime. There are no images to rebuild and push, no layers to pull. Flox maps all dependencies to read-only, node-local store paths; these get mounted into containers at runtime.</p><p>You can easily build, package, and publish <em>your own custom software</em> to your private Flox catalog of packages. Use custom packages with your Kubernetes workloads by installing them to your FloxHub-hosted environments. When pods start, Flox mounts all packages directly from each node’s input-addressed cache into the container, wiring up paths and libraries automatically.</p></div></div></div><div><div><p>Open your private <a href="https://flox.dev/docs/concepts/floxhub/" target="_blank" rel="noopener noreferrer">FloxHub</a>, navigate to an environment’s <strong>Generations</strong> tab, select the target generation, and click <strong>Switch</strong>. All subsequent deployments of that environment will use the selected generation. If you prefer to pin the generation in your Pod specification, append the generation number to the environment reference—for example, <strong><code><owner>/<environment>:<generation_number></generation_number></environment></owner></code></strong>. Everything is immutable and atomic—no image layer edits and no rebuild/push/pull loop.</p></div></div><div><div><p>Yes—and your pipelines will typically get simpler. Keep Argo/Helm/Tekton/GitHub Actions; change <em>what</em> you ship (i.e., a declarative environment pinned to an SHA256 hash), not <em>how</em> you deploy. Most iterations drop build → push → pull entirely.</p></div></div><div><div><p>No. Kubernetes still runs containers. The Flox runtime activates the environment at startup (you can use a tiny placeholder container image). You use the Kubernetes primitives you’re familiar with, along with all Kubernetes orchestration, networking, policy, and admission controls.</p></div></div><div><div><p>Flox makes it easy for teams to recreate the exact production runtime for debugging, maintenance, or audits—anywhere, on any machine: you debug <em>the same environment that runs in the Kubernetes cluster</em>—locally or in a debug pod. No guessing what’s inside an image layer. Plus reproducible behavior at runtime makes issues faster to reproduce and fix.</p></div></div><div><div><div><p>Very. In Flox (powered by Nix), SBOMs are always derived from the input-addressed build graph—not a post-hoc file scan. Every dependency is a concrete <strong><code>/nix/store/<hash>-pkg</hash></code></strong> path, the hash of which covers all build inputs (sources, patches, flags, and transitive deps). This means you get both <strong>build-time</strong> <em>and</em> <strong>runtime</strong> SBOMs automatically: the build-time SBOM captures the toolchains/SDKs used to produce built artifacts; the runtime SBOM captures the realized closure. Most scanners only infer <em>runtime</em> after the fact; Flox gives you <em>both</em>, with no opt-in step. Because environments resolve to immutable store paths (and can be constrained per system), SBOMs stay exact for macOS and Linux, x86 and ARM.</p><p>This improves security work: CVE matching yields fewer false positives, and provenance is attestable. You can generate an attestation that includes the SBOM and either the Flox environment generation (<strong><code><owner>/<environment>:<generation_number></generation_number></environment></owner></code></strong>) or the realized closure’s digest—i.e., the cryptographic fingerprint of the exact set of <strong><code>/nix/store/<hash>-pkg</hash></code></strong> paths the environment resolves to on a given system. (Change any input and the digest changes.) Because your Deployment references the same value, your Kubernetes admission policy can verify the match before rollout. Nix’s input-addressed provenance makes that identifier deterministic across dev, CI, and prod, so your SBOM↔environment↔deployment check is enforceable end-to-end.</p></div></div></div></div></div></div></section></section></main></div></div>
  </body>
</html>
