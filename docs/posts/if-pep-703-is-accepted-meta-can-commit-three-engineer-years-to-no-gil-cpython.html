<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://discuss.python.org/t/a-fast-free-threading-python/27903/99">Original</a>
    <h1>If PEP 703 is accepted, Meta can commit three engineer-years to no-GIL CPython</h1>
    
    <div id="readability-page-1" class="page"><div itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
      <meta itemprop="headline" content="A fast, free threading Python"/>
        <meta itemprop="articleSection" content="Ideas"/>
      <meta itemprop="keywords" content=""/>
      

          <div id="post_80" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            
            <div itemprop="text">
              
<p>This will work as long as you give it an initial empty <code>Counter</code> to start with (otherwise it starts with <code>0</code> and complains)</p>
            </div>

            

            

          </div>
          <div id="post_81" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://discuss.python.org/u/Rosuav"><span itemprop="name">Rosuav</span></a>
                (Chris Angelico)
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2023-06-26T15:35:51Z">
                    June 26, 2023,  3:35pm
                  </time>
                  <meta itemprop="dateModified" content="2023-06-26T15:35:51Z"/>
              <span itemprop="position">81</span>
              </span>
            </p></div>
            <div itemprop="text">
              
<p>Ah thanks. Anyhow, the idea is to minimize the work done in the single-threaded “gather” phase at the end, by having each thread individually count in a lock-free way.</p>
            </div>

            

            

          </div>
          <div id="post_82" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://discuss.python.org/u/lieryan"><span itemprop="name">lieryan</span></a>
                (Lie Ryan)
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2023-06-26T16:20:39Z">
                    June 26, 2023,  4:20pm
                  </time>
                  <meta itemprop="dateModified" content="2023-06-26T16:28:05Z"/>
              <span itemprop="position">82</span>
              </span>
            </p></div>
            <div itemprop="text">
              
<p>I don’t think that is true. If free threading is possible, the cat will be out of the bag, even developers that only cares about single threaded work will still be affected by threading issues. If a library starts a thread in the background for whatever reason, they can cause threading issue in my code even though I never subscribed for having threading problems.</p>
<p>Many libraries that had async-to-sync bridges spawns threads to simulate async tasks. Django, FastAPI, SQLAlchemy is just a few off the top of my head. And then there’s tools like IPython that starts a couple background threads for who knows what reasons.</p>
<p>Multithreading has a reputation for being hard. But really, I think they are considered hard <strong>because</strong> of the existence of free threading. Languages like Rust that doesn’t have free threading (or to be more precise, it has an almost free threading with some severe restrictions) actually fared better at making multithreading a lot easier to use.</p>
<p>The arena-based threading with subinterpreters I had mentioned earlier would be that similar sort of that almost-free threading with forced discipline.</p>
<p>One way to think of arena-based threading is that it’s basically like a dynamic/runtime borrow checker, enforcing acquisition of the arena locks before working with any objects owned by the arena. I think it can even be flexible enough to allow future experimentation with non standard arenas that have different borrowing rules.</p>
            </div>

            

            

          </div>
          <div id="post_83" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://discuss.python.org/u/lunixbochs"><span itemprop="name">lunixbochs</span></a>
                (Ryan Hileman)
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2023-06-26T16:25:27Z">
                    June 26, 2023,  4:25pm
                  </time>
                  <meta itemprop="dateModified" content="2023-06-26T16:25:27Z"/>
              <span itemprop="position">83</span>
              </span>
            </p></div>
            <div itemprop="text">
              
<p>There are language-level tools like golang’s race condition detector, thread sanitizer, etc, which take the common mistakes and test for them. It’s also possible someone could implement something like a borrow checker or thread safety heuristics on top of python’s type system, e.g. with passthrough types along the lines of Mutable / Immutable / Shared / Local, and auditing nonlocal variable access or object types passed into threads.</p>

<p>This wouldn’t be the case with my proposal to make threads take a voluntary lock by default. In a sense, you could leave something like the GIL in place, but make it safe to release for specific threads while accessing python code/objects.</p>
            </div>

            

            

          </div>
          <div id="post_84" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            
            <div itemprop="text">
              
<p>I don’t think anyone has demonstrated how this would happen, and I’d view it as a fundamental flaw in the implementation if it could.</p>
<p>I’m not saying it’s impossible, but I think it would be useful to have specific examples–even if only theoretical–before it’s considered a significant problem.</p>
            </div>

            

            

          </div>
          <div id="post_85" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://discuss.python.org/u/lunixbochs"><span itemprop="name">lunixbochs</span></a>
                (Ryan Hileman)
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2023-06-26T16:33:27Z">
                    June 26, 2023,  4:33pm
                  </time>
                  <meta itemprop="dateModified" content="2023-06-26T16:33:27Z"/>
              <span itemprop="position">85</span>
              </span>
            </p></div>
            <div itemprop="text">
              
<p>I guess this is a bit too open ended. I think the thread in question can only interact with your code unintentionally if you happen to share a resource with that thread in an unsafe way, furthermore to be scary it would need to be an unsafe way that isn’t possible today. Even with the GIL another thread can already do a lot of things, like mess with your file descriptors, stdout, signals. And threads sharing access to any variable is already inconsistent for non-atomic ops at the Python level.</p>
            </div>

            

            

          </div>
          <div id="post_86" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://discuss.python.org/u/smontanaro"><span itemprop="name">smontanaro</span></a>
                (Skip Montanaro)
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2023-06-26T17:01:58Z">
                    June 26, 2023,  5:01pm
                  </time>
                  <meta itemprop="dateModified" content="2023-06-26T17:01:58Z"/>
              <span itemprop="position">86</span>
              </span>
            </p></div>
            <div itemprop="text">
              
<p>Can you provide a (hypothetical?) example?</p>
            </div>

            

            

          </div>
          <div id="post_87" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://discuss.python.org/u/Eclips4"><span itemprop="name">Eclips4</span></a>
                (Kirill Podoprigora)
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2023-06-26T17:13:12Z">
                    June 26, 2023,  5:13pm
                  </time>
                  <meta itemprop="dateModified" content="2023-06-26T17:13:12Z"/>
              <span itemprop="position">87</span>
              </span>
            </p></div>
            <p>Yep, CPython can switch threads in the middle of these two operations. So, there’s a problem.</p>

            

            

          </div>
          <div id="post_88" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://discuss.python.org/u/ntessore"><span itemprop="name">ntessore</span></a>
                (Nicolas Tessore)
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2023-06-26T21:16:35Z">
                    June 26, 2023,  9:16pm
                  </time>
                  <meta itemprop="dateModified" content="2023-06-26T21:16:35Z"/>
              <span itemprop="position">88</span>
              </span>
            </p></div>
            <div itemprop="text">
              <p>Again, of course.  But I understood that <a href="https://discuss.python.org/u/pf_moore">@pf_moore</a> made the very fine point that due to specialisations we are discussing here (e.g. <code>BINARY_SUBSCR_DICT</code>), and hence the GIL, things which are nominally not thread-safe are effectively so in current CPython, because they are specialised to a single native instruction. And this, I think, only needs an explicit specification for whether or not such operations are to be considered effectively “atomic” or not. Otherwise, yes, these are just undiscovered bugs, currently protected by a CPython implementation detail.</p>



            </div>

            

            

          </div>
          <div id="post_89" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://discuss.python.org/u/tjreedy"><span itemprop="name">tjreedy</span></a>
                (Terry Jan Reedy)
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2023-06-26T22:13:25Z">
                    June 26, 2023, 10:13pm
                  </time>
                  <meta itemprop="dateModified" content="2023-06-26T22:13:25Z"/>
              <span itemprop="position">89</span>
              </span>
            </p></div>
            <div itemprop="text">
              
<p>… of a library starting a background thread.  Not exactly a library, but idlelib.run has</p>
<pre><code>    sockthread = threading.Thread(target=manage_socket,
                                  name=&#39;SockThread&#39;,
                                  args=((LOCALHOST, port),))
</code></pre>
<p>as a result of which <code>threading.activecount()</code> and <code>theading.enumerate()</code> returns are greater when running on IDLE.  Someone once asked why the difference on Stackoverflow.   (I have not idea whether no-gil will require any change to <code>manage_socket</code> or that chance of user code having a problem.)</p>
            </div>

            

            

          </div>
          <div id="post_90" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://discuss.python.org/u/ppolewicz"><span itemprop="name">ppolewicz</span></a>
                (Pawel Polewicz)
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2023-06-26T22:13:51Z">
                    June 26, 2023, 10:13pm
                  </time>
                  <meta itemprop="dateModified" content="2023-06-26T22:13:51Z"/>
              <span itemprop="position">90</span>
              </span>
            </p></div>
            <div itemprop="text">
              <pre><code>import threading

THREAD_COUNT = 3
BY_HOW_MUCH = 1_000_000


class Incrementor:
    def __init__(self):
        self.c = 0

def incr(incrementor, by_how_much):
    for i in range(by_how_much):
        incrementor.c += 1

incrementor = Incrementor()

threads = [
    threading.Thread(target=incr, args=(incrementor, BY_HOW_MUCH))
    for i in range(THREAD_COUNT)
]

for t in threads:
    t.start()

for t in threads:
    t.join()

print(incrementor.c)

</code></pre>
<p>prints 3 million when ran it on 3.10. Does it mean you can rely on <code>+=</code> being atomic when writing Python code? No! If you run it on 3.9 it prints between 1.5 and 2 million. Soon a Faster CPython team member can swoop in and change (not break!) it again.</p>
<p>BTW if Java and .net developers can have free threads, then so can we.</p>
            </div>

            

            

          </div>
          <div id="post_91" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://discuss.python.org/u/h-vetinari"><span itemprop="name">h-vetinari</span></a>
                (H. Vetinari)
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2023-06-26T23:08:41Z">
                    June 26, 2023, 11:08pm
                  </time>
                  <meta itemprop="dateModified" content="2023-06-26T23:08:41Z"/>
              <span itemprop="position">91</span>
              </span>
            </p></div>
            <div itemprop="text">
              
<p>The word “can” here translates to (potentially) decades of work, which was the case for Java:</p>

<p>Yes we “can” (and likely should), but it requires serious commitment, and off-hand “others do it too” is not helpful here.</p>
<p>In the context Java and threading, it’s worth noting how threads commonly need quite a lot of developer-facing infrastructure (e.g. thread pools) that’s probably very hard to make beginner-friendly / “Pythonic”, and that they’re on a similarly large multi-{year,person} effort to move from free threads to virtual threads under <a href="https://openjdk.org/projects/loom/" rel="noopener nofollow ugc">Project “Loom”</a> (where – arguably – the boundaries to async programming start getting blurred), and encapsulating a lot of that in simpler interfaces through <a href="https://openjdk.org/jeps/453" rel="noopener nofollow ugc">“structured concurrency”</a>, which we have already (at least through <code>trio</code>).</p>
<p>All that to say: if we argue “Java can”, then we should also look at where those choices have led them, and what they consider as “moving forward” from there. But realistically, we’re very far from an apples-to-apples comparison in any case, and it’s better to leave that rhetorical tool hanging in the shed.</p>



            </div>

            

            

          </div>
          <div id="post_92" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://discuss.python.org/u/ppolewicz"><span itemprop="name">ppolewicz</span></a>
                (Pawel Polewicz)
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2023-06-27T04:39:41Z">
                    June 27, 2023,  4:39am
                  </time>
                  <meta itemprop="dateModified" content="2023-06-27T07:13:02Z"/>
              <span itemprop="position">92</span>
              </span>
            </p></div>
            <div itemprop="text">
              <p>I meant it from the user perspective, referring to “maybe PEP-684 is better, because it’s safer” part of the discussion. For years Python was “parallel, but…” and now adding subinterpreters will help, but it won’t solve the entire problem.</p>
<p>PEP-703 on the other hand, goes pretty much all the way (though stop-the-world GC may still be a limitation) for those willing to learn how to use it and for those who already have experience with threads from other languages. Python “popularity” will increase with projects choosing it for a multicore program when it will become an option.</p>
<p>Will some users hurt themselves with free threading? I’ve been tracking nogil for a long while now and from what I’ve seen, for someone who writes threadsafe code already (but not native extensions) it will be really hard to run into trouble.</p>
            </div>

            

            

          </div>
          <div id="post_93" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://discuss.python.org/u/bluss"><span itemprop="name">bluss</span></a>
                (bluss)
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2023-06-27T19:25:35Z">
                    June 27, 2023,  7:25pm
                  </time>
                  <meta itemprop="dateModified" content="2023-06-27T19:30:00Z"/>
              <span itemprop="position">93</span>
              </span>
            </p></div>
            <div itemprop="text">
              <p>There are some multithreading traps inside glibc (relevant for Linux) that are unfortunate and sort of perennial issues (not just in Python!). <a href="http://rachelbythebay.com/w/2017/01/30/env/" rel="noopener nofollow ugc">For example getenv and setenv</a>; glibc maintains that multithreaded programs must not use setenv, it’s not thread safe.</p>
<p>A library could start a thread, and the library wants to and would use C getenv in this thread (getenv is allowed according to glibc in a multithreaded program, following the usual logic).</p>
<p>(Does this issue exist in Python already today? Is there some mitigating factor that I don’t know about? How do subinterpreters deal with this? It would be great if C getenv/setenv had a major revision to be somewhat compatible with threading.)</p>
            </div>

            

            

          </div>
          <div id="post_94" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://discuss.python.org/u/ings"><span itemprop="name">ings</span></a>
                (Christoph)
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2023-06-27T20:19:25Z">
                    June 27, 2023,  8:19pm
                  </time>
                  <meta itemprop="dateModified" content="2023-06-27T20:19:25Z"/>
              <span itemprop="position">94</span>
              </span>
            </p></div>
            <div itemprop="text">
              <p>I just want to throw in a use case which has not yet been discussed here and in the discussions of PEP 703: GUI toolkits.</p>
<p>GUI toolkits are naturally using threads and therefore an approach where free threading is replaced by a different concept like sub interpreters or multiprocessing is problematic in the design &amp; architecture of GUI applications written in python (because the toolkits being exposed in python are not aware of such concepts and most likely offer plain threading for offloading computational workload from the GUI). I’m a user of the PySide (Qt for python) project, and the PySide devs did struggle with the GIL as explained here <a href="https://www.qt.io/blog/qt-for-python-5.15.0-is-out" rel="noopener nofollow ugc">Qt for Python 5.15.0 is out!</a> (and also the links inside the document).</p>
<p>The problem of when it’s better to release or not to release the GIL in the C extensions of GUI toolkits is not straightforward, sometimes counter-intuitive (at least to me) and often there is a compromise involved depending on most common use cases but with drawbacks for other use cases.</p>
<p>Moreover, when creating GUI applications in python, you start struggling with the GIL when you have huge workloads happening in the background. My use case is a computer vision GUI which acts as a monitor and development environment for remote embedded systems. It is similar to what <a href="https://discuss.python.org/u/lunixbochs">@lunixbochs</a> reported for the realtime audio use case - keeping latencies and stutters on an acceptable level is unnecessarily difficult when you have to fight against the GIL mechanism.</p>
            </div>

            

            

          </div>
          <div id="post_95" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://discuss.python.org/u/smontanaro"><span itemprop="name">smontanaro</span></a>
                (Skip Montanaro)
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2023-06-27T20:34:59Z">
                    June 27, 2023,  8:34pm
                  </time>
                  <meta itemprop="dateModified" content="2023-06-27T20:34:59Z"/>
              <span itemprop="position">95</span>
              </span>
            </p></div>
            <div itemprop="text">
              
<p>Wouldn’t this be a potential problem today? “Not thread-safe” doesn’t mean “not thread-safe only when used in a free-threaded environment.”</p>
<p>I’m not trying to be difficult, maybe a bit pedantic. The presence of the GIL can obscure threading bugs or make them rear their ugly heads less often, but it doesn’t make code thread-safe. <a href="https://discuss.python.org/u/colesbury">@colesbury</a>’s work to remove the GIL has done a lot to remove places in the interpreter, stdlib, and some third-party libraries that relied on the GIL (knowingly or not). Most (all? almost all?) of that work will have been in C code, not Python code.</p>
            </div>

            

            

          </div>
          <div id="post_96" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://discuss.python.org/u/bluss"><span itemprop="name">bluss</span></a>
                (bluss)
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2023-06-28T20:06:44Z">
                    June 28, 2023,  8:06pm
                  </time>
                  <meta itemprop="dateModified" content="2023-06-28T20:06:44Z"/>
              <span itemprop="position">96</span>
              </span>
            </p></div>
            <div itemprop="text">
              
<p>I think it could be a problem today, don’t know, I have the same question. I’m here to be curious.</p>
<p>Again as an interesting anecdotal data point here is a port of that troublesome C code to Python: <a href="https://gist.github.com/bluss/a3d2ad94d55382f682897ee1efae6d74" rel="noopener nofollow ugc">mtenv.py</a></p>
<ul>
<li>Using Python 3.11.3 this program loops for a long time without problem</li>
<li>I compiled and used nogil-3.12 commit 4526c07caee8f2e (current tip of the repo)</li>
</ul>
<p>This is a reduced example. It doesn’t look like a normal Python program, it has a strange shape so that it can reproduce a crash easily. But the fundamental elements can occur in normal Python programs - various C calls that libraries use that use getenv - let’s say mktime to use the example from that blog post - and for setenv we have plain interface to it in <code>os</code> (<code>os.getenv</code> is <em>not</em> a plain interface to C <code>getenv</code>).</p>
            </div>

            

            

          </div>
          <div id="post_97" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            
            <p>Yes, it is a problem today, without free threading. getenv + setenv thread safety is a problem for Python applications I run at work. We had to do a bunch of whackamole to work around segfaults resulting from extension libraries using getenv + setenv (for a while we gave up and used a terrible <code>LD_PRELOAD</code> hack)</p>

            

            

          </div>
          <div id="post_98" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://discuss.python.org/u/gpshead"><span itemprop="name">gpshead</span></a>
                (Gregory P. Smith)
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2023-07-07T23:46:24Z">
                    July 7, 2023, 11:46pm
                  </time>
                  <meta itemprop="dateModified" content="2023-07-07T23:46:24Z"/>
              <span itemprop="position">98</span>
              </span>
            </p></div>
            <div itemprop="text">
              
<p>&amp;</p>

<p>At the high level this is the kind of thing I’d <strong>love someone to try creating</strong> for per-subinterpreter-GIL use! This is also quite hard, but I assume there are interested folks out there.</p>
<p>Intuitively I <em>expect</em> this winds up being the same problem that needs to be solved for free threading <em>(which PEP-703 appears to do)</em>: our pure reference counting model is the most significant reason we have a GIL - in order to share objects between multiple threads you need to make the reference counts work without that single lock.</p>
<p>Someone really needs to try creating explicitly shared objects implementation for CPython and subinterpreters to prove or disprove it’s actual utility. In the absence of that, I wouldn’t point to it and suggest it is a <em>better</em> solution. I consider it an open avenue of future work. <em>(Even if we get free threading, performant explicit sharing would be something I expect many would appreciate having.)</em></p>
            </div>

            

            

          </div>
          <div id="post_99" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://discuss.python.org/u/carljm"><span itemprop="name">carljm</span></a>
                (Carl Meyer)
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2023-07-07T23:53:54Z">
                    July 7, 2023, 11:53pm
                  </time>
                  <meta itemprop="dateModified" content="2023-07-07T23:53:54Z"/>
              <span itemprop="position">99</span>
              </span>
            </p></div>
            <div itemprop="text">
              
<p>We’ve had a chance to discuss this internally with the right people. Our team believes in the value that nogil will provide, and we are committed to working collaboratively to improve Python for everyone.</p>
<p>If PEP 703 is accepted, Meta can commit to support in the form of three engineer-years (from engineers experienced working in CPython internals) between the acceptance of PEP 703 and the end of 2025, to collaborate with the core dev team on landing the PEP 703 implementation smoothly in CPython and on ongoing improvements to the compatibility and performance of nogil CPython.</p>
            </div>

            

            

          </div>
    </div></div>
  </body>
</html>
