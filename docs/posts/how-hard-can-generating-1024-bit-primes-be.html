<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://glitchcomet.com/articles/1024-bit-primes/">Original</a>
    <h1>How hard can generating 1024-bit primes be?</h1>
    
    <div id="readability-page-1" class="page"><article>
        <header>
            <p>
                <time datetime="2023-01-12">
                    January 12, 2023
                    
                </time>
            </p>
            <hr/>
            
        </header>
        <p>Prime numbers are fascinating!</p>
<p>On the one hand they are easy to explain, they are just numbers that have no factors other than one and themselves, but on the other hand they contain endless complexity. They show up in numerous places, ranging from mathematical concepts and conjectures to interesting looking visualizations and cryptography, underpinning many internet standards and security protocols we use everyday.</p>
<p>Despite my fascination with primes I never really explored them in detail. So, I thought I would challenge myself, and what better way to explore primes than to use my interest in coding to generate prime numbers!</p>
<h2>The Challenge</h2>
<p>But what kind of prime should I generate? Finding the one billionth prime is too easy, and getting on the <a href="https://primes.utm.edu/largest.html">leaderboard</a> of the <a href="https://en.wikipedia.org/wiki/Largest_known_prime_number">largest known primes</a> is way beyond what I think I can achieve in my first attempt. Combining primes with my interest in cryptography I came up with this -</p>
<div>
    <p>In addition to the challenge, I also set up some rules for myself:</p>
<ul>
<li>The code has to be written from scratch - otherwise you could just <code>openssl prime -generate -bits 1024</code> and be done! &#34;from scratch&#34; here just means no external dependencies.  </li>
<li>No fancy external hardware or cloud - so you can&#39;t just throw additional computing power at the problem. I will use my laptop with an AMD Ryzen 7 CPU and 16gb RAM.  </li>
<li>Generate the primes in &#34;reasonable&#34; time - deliberately left vague so that I optimize a little but not get caught in a over-optimization spiral.  </li>
</ul>
</div>

<p>For the language I picked Rust, mainly because I happened to be learning it recently and this challenge looked like it would be good practice. I feel Rust is low level enough to play around with deeper concepts while being high level enough that the code snippets are relatively easy to understand. I won&#39;t be using any of the more complex features of rust because I am not familiar with them yet.</p>
<p>With all that out of the way, let&#39;s get started!</p>
<h2>16 bits, the easy bit!</h2>
<p>My plan is to slowly build up to 1024 bits, so I started at 16 bits as a bit of a warm up. In theory, the process to generate any N-bit primes is easy - </p>
<div><pre><span></span><code><span>while</span><span> </span><span>true</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>number</span><span> </span><span>=</span><span> </span><span>&lt;&lt;</span><span>random</span><span> </span><span>N</span><span>-</span><span>bit</span><span> </span><span>integer</span><span>&gt;&gt;</span>
<span>    </span><span>if</span><span> </span><span>is_prime</span><span>(</span><span>number</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>break</span>
<span>    </span><span>}</span>
<span>}</span>
</code></pre></div>

<p>Just keep generating new random N-bit numbers until one that passes the primality test is found. Even before I can tackle primality tests though I have my first hurdle, where do I get my random numbers from? Rust has an excellent crate (aka library/package) called <a href="https://docs.rs/rand/latest/rand/">rand</a> that can almost be considered part of the standard library. But before I break my &#34;no dependencies&#34; rule right at the start I thought I should at least try to do it myself. </p>
<p>I remember hearing about <code>/dev/urandom</code> from somewhere, and upon further research it turns out this would fit my use case perfectly. The Linux kernel has a built-in <em>Cryptographically Secure Pseudo Random Number Generator</em> (CSPRNG) which can be accessed by reading from the pseudo device file <code>/dev/urandom</code>. It collects 
<span><span>e</span><span>n</span><span>t</span><span>r</span><span>o</span><span>p</span><span>y</span></span>
 from the user&#39;s environment and uses it to periodically seed a deterministic stream cipher called <a href="https://en.wikipedia.org/wiki/Salsa20#ChaCha20_adoption">ChaCha20</a> (fun name!), which can then generate some &#34;true&#34; random bits. I was hesitant to use this at first but <a href="https://sockpuppet.org/blog/2014/02/25/safely-generate-random-numbers/">a certain article</a> convinced me otherwise.</p>
<p>This is the implementation I came up with - </p>
<div><pre><span></span><code><span>// rng.rs</span>
<span>use</span><span> </span><span>std</span>::<span>fs</span>::<span>File</span><span>;</span>
<span>use</span><span> </span><span>std</span>::<span>io</span>::<span>Read</span><span>;</span>

<span>fn</span> <span>insert_random_bytes</span><span>(</span><span>mut</span><span> </span><span>bytes</span>: <span>&amp;</span><span>mut</span><span>[</span><span>u8</span><span>])</span><span> </span>-&gt; <span>std</span>::<span>io</span>::<span>Result</span><span>&lt;</span><span>()</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>File</span>::<span>open</span><span>(</span><span>&#34;/dev/urandom&#34;</span><span>)</span><span>?</span><span>.</span><span>read_exact</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>bytes</span><span>)</span><span>?</span><span>;</span>
<span>    </span><span>Ok</span><span>(())</span>
<span>}</span>

<span>fn</span> <span>u16</span><span>()</span><span> </span>-&gt; <span>u16</span> <span>{</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>bytes</span><span> </span><span>=</span><span> </span><span>[</span><span>0</span><span>u8</span><span>;</span><span> </span><span>2</span><span>];</span>
<span>    </span><span>insert_random_bytes</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>bytes</span><span>).</span><span>expect</span><span>(</span><span>&#34;Cannot access /dev/urandom&#34;</span><span>);</span>
<span>    </span><span>u16</span>::<span>from_le_bytes</span><span>(</span><span>bytes</span><span>)</span>
<span>}</span>
</code></pre></div>

<p>Note: expressions without a semicolon placed at the end of rust functions act as the function&#39;s return value.</p>
<p><code>insert_random_bytes()</code> takes in a mutable array of bytes as input and fills it with the output from <code>/dev/urandom</code>. The <code>u16()</code> function creates a buffer of 2 bytes (16 bits), fills the buffer with random bits and then creates a <code>u16</code> integer from those bits, with <code>u16</code> in rust representing an unsigned 16-bit integer. <code>u16()</code> is then used like this - </p>
<div><pre><span></span><code><span>fn</span> <span>run</span><span>()</span><span> </span><span>{</span>
<span>    </span><span>println!</span><span>(</span><span>&#34;random no - {}&#34;</span><span>,</span><span> </span><span>rng</span>::<span>u16</span><span>()</span><span> </span><span>|</span><span> </span><span>0b1000000000000001</span><span>);</span>
<span>}</span>
</code></pre></div>

<p>The random number returned is OR-ed with <code>0b1000000000000001</code> to set its first and last bit to <code>1</code>. The last bit set to 1 makes it an odd number and the first bit set to 1 ensures that it is a sufficiently large number which covers the entire range of bits I need. </p>
<p>Here&#39;s it generating a few 16-bit random numbers -</p>
<div><pre><span></span><code>random no - 36111
random no - 52205
random no - 45689
random no - 33631
</code></pre></div>

<p>Now that I have my very own random number generator let&#39;s quickly finish out 16-bit primes. First, a fancy enum to store our results - </p>
<div><pre><span></span><code><span>enum</span> <span>PrimeResult</span><span> </span><span>{</span>
<span>    </span><span>Prime</span><span>,</span>
<span>    </span><span>Composite</span><span>,</span>
<span>}</span>
</code></pre></div>

<p>Then, a basic primality test called <a href="https://en.wikipedia.org/wiki/Trial_division">trial division</a> to check if a number is prime. It loops from <code>3</code> to <code>sqrt(num)</code> and checks if any of them is a factor of <code>num</code> - </p>
<div><pre><span></span><code><span>fn</span> <span>trial_division_simple</span><span>(</span><span>n</span>: <span>u16</span><span>)</span><span> </span>-&gt; <span>PrimeResult</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>root_n</span><span> </span><span>=</span><span> </span><span>(</span><span>n</span><span> </span><span>as</span><span> </span><span>f64</span><span>).</span><span>sqrt</span><span>()</span><span> </span><span>as</span><span> </span><span>u16</span><span>;</span>
<span>    </span><span>for</span><span> </span><span>x</span><span> </span><span>in</span><span> </span><span>3</span><span>..</span><span>root_n</span><span> </span><span>{</span>
<span>        </span><span>if</span><span> </span><span>n</span><span> </span><span>%</span><span> </span><span>x</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span>
<span>            </span><span>return</span><span> </span><span>PrimeResult</span>::<span>Composite</span><span>;</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>    </span><span>PrimeResult</span>::<span>Prime</span>
<span>}</span>
</code></pre></div>

<p>And a basic loop to finish it off - </p>
<div><pre><span></span><code><span>fn</span> <span>run</span><span>()</span><span> </span><span>{</span>
<span>    </span><span>loop</span><span> </span><span>{</span>
<span>        </span><span>let</span><span> </span><span>num</span><span> </span><span>=</span><span> </span><span>rng</span>::<span>u16</span><span>()</span><span> </span><span>|</span><span> </span><span>0b1000000000000001</span><span>;</span>
<span>        </span><span>if</span><span> </span><span>trial_division_simple</span><span>(</span><span>num</span><span>)</span><span> </span><span>==</span><span> </span><span>PrimeResult</span>::<span>Prime</span><span> </span><span>{</span>
<span>            </span><span>println!</span><span>(</span><span>&#34;Prime found: {num}&#34;</span><span>);</span>
<span>            </span><span>break</span><span>;</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>}</span>
</code></pre></div>

<div><pre><span></span><code>➜ time cargo run --release 
Prime found: 44809
cargo run --release  0.03s user 0.01s system 99% cpu 0.038 total
</code></pre></div>

<p>This works nicely and on average takes ~40ms to generate 16-bit primes. To confirm that my primes are actually prime, I am using a cool online tester written in WebAssembly (<a href="https://www.alpertron.com.ar/ECM.HTM">hosted here</a>) along with this OpenSSL command - <code>openssl prime &lt;number&gt;</code>.</p>
<p>With this, we have refreshed some basic concepts and warm up is done. Now it&#39;s time to move on to the next step!</p>
<h2>64 bits, 4 times the bits!</h2>
<p>After 16 bits I jumped straight to 64-bit numbers. 64-bit architecture is common nowadays on most modern hardware and with 64 bits we are well into the 20 digit numbers range (for context, 1 trillion is 13 digits). Would the simple trial division algorithm be able to handle such large numbers?</p>
<div><pre><span></span><code>➜ time cargo run --release 
Prime found: 14288847644715868907
cargo run --release  30.27s user 0.02s system 99% cpu 30.294 total
</code></pre></div>

<p>It does, kinda. 30 seconds to generate a 64-bit prime does not look great but this is not trial division&#39;s full potential. In this section, I will try to push it to its limits.</p>
<p>First, here&#39;s a more optimized version of trial division - </p>
<div><pre><span></span><code><span>fn</span> <span>trial_division</span><span>(</span><span>n</span>: <span>u64</span><span>,</span><span> </span><span>start</span>: <span>u64</span><span>)</span><span> </span>-&gt; <span>PrimeResult</span><span> </span><span>{</span>
<span>    </span><span>// assumption: n &gt; 3 and start &gt; 3</span>
<span>    </span><span>let</span><span> </span><span>root_n</span><span> </span><span>=</span><span> </span><span>(</span><span>n</span><span> </span><span>as</span><span> </span><span>f64</span><span>).</span><span>sqrt</span><span>()</span><span> </span><span>as</span><span> </span><span>u64</span><span>;</span>
<span>    </span><span>for</span><span> </span><span>x</span><span> </span><span>in</span><span> </span><span>(</span><span>start</span><span>..</span><span>(</span><span>root_n</span><span> </span><span>+</span><span> </span><span>1</span><span>)).</span><span>step_by</span><span>(</span><span>6</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>if</span><span> </span><span>n</span><span> </span><span>%</span><span> </span><span>x</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>||</span><span> </span><span>n</span><span> </span><span>%</span><span> </span><span>(</span><span>x</span><span> </span><span>+</span><span> </span><span>2</span><span>)</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span>
<span>            </span><span>return</span><span> </span><span>PrimeResult</span>::<span>Composite</span><span>;</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>    </span><span>PrimeResult</span>::<span>Prime</span>
<span>}</span>
</code></pre></div>

<div>
    <p>Changes:</p>
<ul>
<li>It also accepts a <code>start</code> parameter for where to start the loop from.</li>
<li>The loop steps forward by 6 instead of 1.</li>
<li>Check <code>n % (x + 2) == 0</code> in addition to <code>n % x == 0</code>.</li>
</ul>
</div>

<p>Basically, it only considers factors between <code>start</code> and <code>sqrt(n)</code> that are of the form 6k+1, to quote <a href="https://en.wikipedia.org/wiki/Primality_test#Simple_methods">Wikipedia</a> - </p>
<blockquote>
<p>This is because all integers can be expressed as (6k+i), where i = −1, 0, 1, 2, 3, or 4. Note that 2 divides (6k+0), (6k+2), and (6k+4) and 3 divides (6k+3). So, a more efficient method is to test whether n is divisible by 2 or 3, then to check through all numbers of the form 6k±1 ≤ √n. This is 3 times faster than testing all numbers up to √n. </p>
</blockquote>
<p>Next, a function to generate a list of small primes using this improved trial division - </p>
<div><pre><span></span><code><span>fn</span> <span>generate_small_primes</span><span>&lt;</span><span>const</span><span> </span><span>N</span>: <span>usize</span><span>&gt;</span><span>()</span><span> </span>-&gt; <span>[</span><span>u64</span><span>;</span><span> </span><span>N</span><span>]</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>primes</span>: <span>[</span><span>u64</span><span>;</span><span> </span><span>N</span><span>]</span><span> </span><span>=</span><span> </span><span>[</span><span>0</span><span>;</span><span> </span><span>N</span><span>];</span>
<span>    </span><span>primes</span><span>[</span><span>0</span><span>]</span><span> </span><span>=</span><span> </span><span>2</span><span>;</span>
<span>    </span><span>primes</span><span>[</span><span>1</span><span>]</span><span> </span><span>=</span><span> </span><span>3</span><span>;</span>

<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>n</span>: <span>u64</span> <span>=</span><span> </span><span>3</span><span>;</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>nth</span>: <span>u64</span> <span>=</span><span> </span><span>2</span><span>;</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>i</span>: <span>usize</span> <span>=</span><span> </span><span>2</span><span>;</span>
<span>    </span><span>let</span><span> </span><span>limit</span><span> </span><span>=</span><span> </span><span>N</span><span> </span><span>as</span><span> </span><span>u64</span><span>;</span>

<span>    </span><span>loop</span><span> </span><span>{</span>
<span>        </span><span>n</span><span> </span><span>+=</span><span> </span><span>2</span><span>;</span>
<span>        </span><span>if</span><span> </span><span>trial_division</span><span>(</span><span>n</span><span>,</span><span> </span><span>5</span><span>)</span><span> </span><span>==</span><span> </span><span>PrimeResult</span>::<span>Prime</span><span> </span><span>{</span>
<span>            </span><span>primes</span><span>[</span><span>i</span><span>]</span><span> </span><span>=</span><span> </span><span>n</span><span>;</span>
<span>            </span><span>i</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span>
<span>            </span><span>nth</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span>
<span>            </span><span>if</span><span> </span><span>nth</span><span> </span><span>==</span><span> </span><span>limit</span><span> </span><span>{</span>
<span>                </span><span>return</span><span> </span><span>primes</span>
<span>            </span><span>}</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>}</span>
</code></pre></div>

<p>Add another possible state to our result - </p>
<div><pre><span></span><code><span>enum</span> <span>PrimeResult</span><span> </span><span>{</span>
<span>    </span><span>Prime</span><span>,</span>
<span>    </span><span>Composite</span><span>,</span>
<span>    </span><span>Unknown</span><span>,</span><span>   </span><span>// &lt;----- new</span>
<span>}</span>
</code></pre></div>

<p>And then use the list of small primes to do a pre-check for easily divisible numbers before reverting to trial division -</p>
<div><pre><span></span><code><span>fn</span> <span>primes_64bit</span><span>()</span><span> </span><span>{</span>
<span>    </span><span>const</span><span> </span><span>N</span>: <span>usize</span> <span>=</span><span> </span><span>10000</span><span>;</span>
<span>    </span><span>let</span><span> </span><span>start</span><span> </span><span>=</span><span> </span><span>(</span><span>N</span><span> </span><span>+</span><span> </span><span>1</span><span>)</span><span> </span><span>as</span><span> </span><span>u64</span><span>;</span>
<span>    </span><span>let</span><span> </span><span>primes</span><span> </span><span>=</span><span> </span><span>utils</span>::<span>generate_small_primes</span>::<span>&lt;</span><span>N</span><span>&gt;</span><span>();</span>

<span>    </span><span>loop</span><span> </span><span>{</span>
<span>        </span><span>let</span><span> </span><span>num</span><span> </span><span>=</span><span> </span><span>rng</span>::<span>u64</span><span>()</span><span> </span><span>|</span><span> </span><span>0x8000000000000001</span><span>u64</span><span>;</span>
<span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>PrimeResult</span>::<span>Unknown</span><span>;</span>

<span>        </span><span>for</span><span> </span><span>i</span><span> </span><span>in</span><span> </span><span>0</span><span>..</span><span>N</span><span> </span><span>{</span>
<span>            </span><span>if</span><span> </span><span>num</span><span> </span><span>%</span><span> </span><span>primes</span><span>[</span><span>i</span><span>]</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span>
<span>                </span><span>result</span><span> </span><span>=</span><span> </span><span>PrimeResult</span>::<span>Composite</span><span>;</span>
<span>                </span><span>break</span><span>;</span>
<span>            </span><span>}</span>
<span>        </span><span>}</span>

<span>        </span><span>if</span><span> </span><span>result</span><span> </span><span>==</span><span> </span><span>PrimeResult</span>::<span>Unknown</span><span> </span><span>{</span>
<span>            </span><span>result</span><span> </span><span>=</span><span> </span><span>algos</span>::<span>trial_division</span><span>(</span><span>num</span><span>,</span><span> </span><span>start</span><span>)</span>
<span>        </span><span>}</span>

<span>        </span><span>if</span><span> </span><span>result</span><span> </span><span>==</span><span> </span><span>PrimeResult</span>::<span>Prime</span><span> </span><span>{</span>
<span>            </span><span>println!</span><span>(</span><span>&#34;Prime found: {num}&#34;</span><span>);</span>
<span>            </span><span>break</span><span>;</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>}</span>
</code></pre></div>

<p>After all that work, here&#39;s the result -</p>
<div><pre><span></span><code>➜ time cargo run --release 
Prime found: 12589778476493955313
cargo run --release  6.40s user 0.01s system 99% cpu 6.414 total
</code></pre></div>

<p>That&#39;s a nice improvement from the 30 seconds it took previously. There&#39;s still some optimization potential left on the table, but if it takes 6 seconds for just 64-bit numbers then it&#39;s clear that this cannot scale to 1024-bit numbers.</p>
<p>With this, we have to leave behind the safe cozy lands of deterministic algorithms and enter the realm of uncertainty with probabilistic algorithms!</p>
<h2>128 bits, with a bit of a twist!</h2>
<p>This is where things start to get interesting. At first, I found the concept of probabilistic primality tests strange and tried to look for deterministic algorithms that could handle huge numbers. I did find two - <a href="https://en.wikipedia.org/wiki/Adleman%E2%80%93Pomerance%E2%80%93Rumely_primality_test">APR-CL</a> and <a href="https://en.wikipedia.org/wiki/Elliptic_curve_primality">ECPP</a>. Both of these are so mathematically complex that I could not make sense of their research papers at all, and there isn&#39;t much accessible information about them on the internet for someone like me who is bad at math. </p>
<p>After taking a look at discussions online, OpenSSL&#39;s <a href="https://github.com/openssl/openssl/blob/master/crypto/bn/bn_prime.c">source code</a> and recommendations by <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf">NIST</a>, I realized that almost everyone including RSA uses probabilistic algorithms. The catch is that if implemented properly, these algorithms have an extremely low error rate which is negligible. From this point on all algorithms that show up will not &#34;prove&#34; that a number is prime, but will say that it is a &#34;probable prime&#34; with a certain accuracy. The first of these algorithms I explored was <em>Fermat&#39;s Little Theorem</em>.</p>
<h3>Fermat&#39;s Little Theorem</h3>
<p>This <a href="https://en.wikipedia.org//wiki/Fermat&#39;s_little_theorem">theorem</a> by Fermat states: If <span>p</span> is prime and <span>a</span> is any integer not divisible by <span>p</span>, then the number <span>a<sup>p-1</sup></span> is divisible by <span>p</span>. The same thing can be expressed in modular arithmetic as:</p>
<p><span>
a<sup>p-1</sup> = 1 (mod p)
</span></p>
<p>We can pick different values for <span>a</span> where <span>a &lt; p</span>, so by definition <span>a</span> would not be divisible by <span>p</span>, and in theory plugging those values into this relation would tell us whether <span>p</span> is prime or not. </p>
<p>All we have to do is implement this relation in code, beginning with <span>a<sup>p-1</sup></span> and <span>a = 2</span> -</p>
<div><pre><span></span><code><span>fn</span> <span>run</span><span>()</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>num</span><span> </span><span>=</span><span> </span><span>rng</span>::<span>u128</span><span>()</span><span> </span><span>|</span><span> </span><span>0x80000000000000000000000000000001</span><span>u128</span><span>;</span>
<span>    </span><span>let</span><span> </span><span>base</span><span> </span><span>=</span><span> </span><span>2</span><span>u128</span><span>;</span>
<span>    </span><span>println!</span><span>(</span><span>&#34;{}&#34;</span><span>,</span><span> </span><span>base</span><span>.</span><span>pow</span><span>(</span><span>num</span><span> </span><span>-</span><span> </span><span>1</span><span>);</span>
<span>}</span>
</code></pre></div>

<div><pre><span></span><code>➜ cargo run
...
error[E0308]: mismatched types
   --&gt; src/lib.rs:71:29
    |
71  |     println!(&#34;{}&#34;, base.pow(num - 1);
    |                         --- ^^^^^^^ expected `u32`, found `u128`
    |                         |
    |                         arguments to this function are incorrect
</code></pre></div>

<p>It took me a minute to realize that this was not an error on my part. The <code>pow()</code> function intentionally takes in a u32, as raising u128 to any higher power would already overflow the u128! Fortunately, our relation above is in modular arithmetic which means we can take the modulus at each step instead of at the end keeping the result less than u128.</p>
<p>basically,</p>
<p><span>
a × b (mod m) = [ a (mod m) × b (mod m) ]  (mod m)
</span></p>
<p>and so -</p>
<p><span>
a<sup>p-1</sup> (mod p) = ((((a × a (mod p)) × a (mod p)) × a (mod p)) × ...... p - 1 times )
</span></p>
<p>The algorithm to implement this is called <em>modular exponentiation</em>. I implemented it by directly following the <a href="https://en.wikipedia.org/wiki/Modular_exponentiation#Pseudocode">pseudocode from Wikipedia</a>, using the version that implements &#34;exponentiation by squaring&#34; for a more efficient algorithm.</p>
<p>Here goes attempt #2 -</p>
<div><pre><span></span><code><span>fn</span> <span>run</span><span>()</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>num</span><span> </span><span>=</span><span> </span><span>rng</span>::<span>u128</span><span>()</span><span> </span><span>|</span><span> </span><span>0x80000000000000000000000000000001</span><span>u128</span><span>;</span>
<span>    </span><span>let</span><span> </span><span>base</span><span> </span><span>=</span><span> </span><span>rng</span>::<span>u128_range</span><span>(</span><span>2</span><span>,</span><span> </span><span>num</span><span> </span><span>-</span><span> </span><span>1</span><span>);</span>
<span>    </span><span>println!</span><span>(</span><span>&#34;{}&#34;</span><span>,</span><span> </span><span>mod_exp</span><span>(</span><span>base</span><span>,</span><span> </span><span>num</span><span> </span><span>-</span><span> </span><span>1</span><span>,</span><span> </span><span>num</span><span>));</span>
<span>}</span>
</code></pre></div>

<div><pre><span></span><code>➜ cargo run                 
...
thread &#39;main&#39; panicked at &#39;attempt to multiply with overflow&#39;, src/utils.rs:38:16
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre></div>

<p>Oh well.</p>
<p>Another thing I didn&#39;t realize is that even the multiplication of two u128 can easily become too large for a u128 to store. Defeated for now, I decided to move ahead by storing only 64-bit numbers inside the u128s. Roughly speaking the most amount of space needed for multiplication of two N-bit numbers is 2N, hence the decision to store 64-bit numbers inside u128. This idea of allocating twice the amount of bits needed will show up later too. Interestingly, the previous 64-bit step with trial division had no multiplications which is why it did not run into this issue.</p>
<p>Adding another possible state to the enum - </p>
<div><pre><span></span><code><span>enum</span> <span>PrimeResult</span><span> </span><span>{</span>
<span>    </span><span>Prime</span><span>,</span>
<span>    </span><span>Composite</span><span>,</span>
<span>    </span><span>Unknown</span><span>,</span>
<span>    </span><span>ProbablePrime</span><span>,</span><span>   </span><span>// &lt;----- new</span>
<span>}</span>
</code></pre></div>

<p>And here&#39;s the Fermat test implementation. It just runs the equation <code>k</code> times with random bases -</p>
<div><pre><span></span><code><span>fn</span> <span>fermat_test</span><span>(</span><span>num</span>: <span>u128</span><span>,</span><span> </span><span>k</span>: <span>usize</span><span>)</span><span> </span>-&gt; <span>PrimeResult</span><span> </span><span>{</span>
<span>    </span><span>for</span><span> </span><span>_</span><span> </span><span>in</span><span> </span><span>0</span><span>..</span><span>k</span><span> </span><span>{</span>
<span>        </span><span>let</span><span> </span><span>base</span><span> </span><span>=</span><span> </span><span>rng</span>::<span>u128_range</span><span>(</span><span>2</span><span>,</span><span> </span><span>num</span><span> </span><span>-</span><span> </span><span>1</span><span>);</span>
<span>        </span><span>if</span><span> </span><span>mod_exp</span><span>(</span><span>base</span><span>,</span><span> </span><span>num</span><span> </span><span>-</span><span> </span><span>1</span><span>,</span><span> </span><span>num</span><span>)</span><span> </span><span>!=</span><span> </span><span>1</span><span> </span><span>{</span>
<span>            </span><span>return</span><span> </span><span>PrimeResult</span>::<span>Composite</span><span>;</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>    </span><span>PrimeResult</span>::<span>ProbablePrime</span><span>;</span>
<span>}</span>
</code></pre></div>

<p>An interesting implementation detail here, the function <code>rng::u128_range()</code> implies that it uniformly selects a random u128 from between <code>2</code> and <code>num - 1</code> but I found it more practical to directly return a random number that&#39;s a few bytes shorter than <code>num</code>. This greatly simplifies the logic while still giving us a mostly random sufficiently large number between <code>2</code> and <code>num - 1</code>. Moving forward this trick will be used whenever random values from a range are needed.</p>
<p>Here&#39;s the full test! - </p>
<div><pre><span></span><code><span>fn</span> <span>primes_128bit</span><span>()</span><span> </span>-&gt; <span>u128</span> <span>{</span>
<span>    </span><span>loop</span><span> </span><span>{</span>
<span>        </span><span>let</span><span> </span><span>num</span><span> </span><span>=</span><span> </span><span>(</span><span>rng</span>::<span>u64</span><span>()</span><span> </span><span>|</span><span> </span><span>0x8000000000000001</span><span>u64</span><span>)</span><span> </span><span>as</span><span> </span><span>u128</span><span>;</span>
<span>        </span><span>if</span><span> </span><span>fermat_test</span><span>(</span><span>num</span><span>,</span><span> </span><span>10</span><span>)</span><span> </span><span>==</span><span> </span><span>PrimeResult</span>::<span>ProbablePrime</span><span> </span><span>{</span>
<span>            </span><span>return</span><span> </span><span>num</span><span>;</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>}</span>
</code></pre></div>

<div><pre><span></span><code>➜ time cargo run --release 
Prime found: 9944209443870115157
cargo run --release  0.03s user 0.01s system 99% cpu 0.033 total
</code></pre></div>

<p>That&#39;s quite a bit faster than the ~6sec runs we were getting previously for 64 bits, but the fact that it uses a &#34;probable prime&#34; result might already tell you there&#39;s a catch. The flaw in Fermat&#39;s Little Theorem is - &#34;pseudoprimes&#34;. The relation defined by Fermat&#39;s Little Theorem is true for all primes but is also additionally true for some composites. If the RNG generates one of these special composites, the code would say it is prime even when its not. These composites, also called &#34;Fermat Pseudoprimes&#34;, are rare but still numerous enough that we cannot rely on the accuracy of Fermat&#39;s test.</p>
<h3>Miller-Rabin Primality Test</h3>
<p>The <a href="https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test">Miller-Rabin</a> test is an improved probabilistic primality test that works on the same principles as Fermat&#39;s test, but is much stronger and more practical to use due to a few key differences. For one, in this test no composite number is a strong pseudoprime for all bases at the same time in contrast to Fermat&#39;s where such composites exist (called the Carmichael numbers). Miller-Rabin also has a substantially better error rate that can be called &#34;insignificant&#34; in most cases. In fact when looking around for what other people use, like OpenSSL&#39;s <a href="https://github.com/openssl/openssl/blob/master/crypto/bn/bn_prime.c">source code</a> and recommendations by <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf">NIST</a> mentioned at the start, many sources recommend or are already using Miller-Rabin!</p>
<p>The math behind Miller-Rabin is not that important for implementing the algorithm itself, but nevertheless I will try to summarize what I understood. Feel free to skip it and jump directly to the code.</p>
<p>The relation we looked at in Fermat&#39;s test was:  </p>
<p><span>a<sup>n-1</sup> = 1 (mod n)</span>,  if <span>n</span> is prime        (1)</p>
<div>
    <p>A more general form of <span>a<sup>n-1</sup></span> can be written as <span>a<sup>2<sup>s</sup> × d</sup></span>, where:</p>
<ul>
<li><span>d</span> = An odd number left after factoring out all powers of 2 from <span>n</span>.  </li>
<li><span>s</span> = The power of 2 as the factor of <span>n</span>.  </li>
</ul>
</div>

<p>which implies:  </p>
<p><span>n - 1 = 2<sup>s</sup> × d</span>       (2)</p>
<div>
    <p>Combining (1) and (2), we can say <span>n</span> is a strong probable prime if one of these conditions is true:</p>
<ul>
<li><span>a<sup>d</sup> = 1 (mod n)</span>.</li>
<li><span>a<sup>2<sup>r</sup> × d</sup> = n - 1 (mod n)</span> for some <span>0 &lt;= r &lt; s</span>.</li>
</ul>
</div>

<p>Note: <span>n - 1 (mod n)</span> is equivalent to <span>-1 (mod n)</span>. It is left in the expanded form as I am working with unsigned ints and don&#39;t have a way to represent -1.</p>
<p>Essentially, instead of doing a single test on <span>a<sup>n-1</sup></span> it is doing multiple tests - starting with <span>a<sup>2<sup>0</sup> × d</sup></span> which is <span>a<sup>d</sup></span>, then <span>a<sup>2<sup>1</sup> × d</sup></span>, <span>a<sup>2<sup>2</sup> × d</sup></span>, <span>a<sup>2<sup>3</sup> × d</sup></span> and so on until it reaches <span>n</span> at <span>a<sup>2<sup>s</sup> × d</sup></span>.</p>
<p>Here&#39;s my implementation, derived by combining the above math with the basic <a href="https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test#Miller%E2%80%93Rabin_test">pseudocode</a> described on Wikipedia - </p>
<div><pre><span></span><code><span>fn</span> <span>miller_rabin_test</span><span>(</span><span>n</span>: <span>u128</span><span>,</span><span> </span><span>k</span>: <span>usize</span><span>)</span><span> </span>-&gt; <span>PrimeResult</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>s</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>d</span><span> </span><span>=</span><span> </span><span>n</span><span> </span><span>-</span><span> </span><span>1</span><span>;</span>
<span>    </span><span>while</span><span> </span><span>d</span><span> </span><span>%</span><span> </span><span>2</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span>
<span>        </span><span>d</span><span> </span><span>=</span><span> </span><span>d</span><span> </span><span>/</span><span> </span><span>2</span><span>;</span>
<span>        </span><span>s</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span>
<span>    </span><span>}</span>

<span>    </span><span>&#39;</span><span>main_loop</span>: <span>for</span><span> </span><span>_</span><span> </span><span>in</span><span> </span><span>0</span><span>..</span><span>k</span><span> </span><span>{</span>
<span>        </span><span>let</span><span> </span><span>base</span><span> </span><span>=</span><span> </span><span>rng</span>::<span>u128_range</span><span>(</span><span>2</span><span>,</span><span> </span><span>n</span><span> </span><span>-</span><span> </span><span>2</span><span>);</span>

<span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>x</span><span> </span><span>=</span><span> </span><span>utils</span>::<span>mod_exp</span><span>(</span><span>base</span><span>,</span><span> </span><span>d</span><span>,</span><span> </span><span>n</span><span>);</span>
<span>        </span><span>if</span><span> </span><span>x</span><span> </span><span>==</span><span> </span><span>1</span><span> </span><span>||</span><span> </span><span>x</span><span> </span><span>==</span><span> </span><span>n</span><span> </span><span>-</span><span> </span><span>1</span><span> </span><span>{</span><span> </span><span>continue</span><span> </span><span>&#39;main_loop</span><span>;</span><span> </span><span>}</span>

<span>        </span><span>for</span><span> </span><span>_</span><span> </span><span>in</span><span> </span><span>0</span><span>..</span><span>(</span><span>s</span><span> </span><span>-</span><span> </span><span>1</span><span>)</span><span> </span><span>{</span>
<span>            </span><span>x</span><span> </span><span>=</span><span> </span><span>utils</span>::<span>mod_exp</span><span>(</span><span>x</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>n</span><span>);</span>
<span>            </span><span>if</span><span> </span><span>x</span><span> </span><span>==</span><span> </span><span>n</span><span> </span><span>-</span><span> </span><span>1</span><span> </span><span>{</span><span> </span><span>continue</span><span> </span><span>&#39;main_loop</span><span>;</span><span> </span><span>}</span>
<span>        </span><span>}</span>

<span>        </span><span>return</span><span> </span><span>PrimeResult</span>::<span>Composite</span><span>;</span>
<span>    </span><span>}</span>

<span>    </span><span>PrimeResult</span>::<span>ProbablePrime</span>
<span>}</span>
</code></pre></div>

<p>The first while loop factors out powers of 2, converting <span>n-1</span> to <span>2<sup>s</sup> × d</span>. Then &#34;main_loop&#34; does all the tests mentioned above, squaring <code>x</code> (raising power by 2) and testing until it reaches <span>2<sup>s-1</sup></span>.</p>
<p>And, the usual loop to find primes - </p>
<div><pre><span></span><code><span>fn</span> <span>primes_128bit</span><span>()</span><span> </span>-&gt; <span>u128</span> <span>{</span>
<span>    </span><span>loop</span><span> </span><span>{</span>
<span>        </span><span>let</span><span> </span><span>num</span><span> </span><span>=</span><span> </span><span>(</span><span>rng</span>::<span>u64</span><span>()</span><span> </span><span>|</span><span> </span><span>0x8000000000000001</span><span>u64</span><span>)</span><span> </span><span>as</span><span> </span><span>u128</span><span>;</span>
<span>        </span><span>if</span><span> </span><span>miller_rabin_test</span><span>(</span><span>num</span><span>,</span><span> </span><span>10</span><span>)</span><span> </span><span>==</span><span> </span><span>PrimeResult</span>::<span>ProbablePrime</span><span> </span><span>{</span>
<span>            </span><span>return</span><span> </span><span>num</span><span>;</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>}</span>
</code></pre></div>

<div><pre><span></span><code>➜ time cargo run --release 
Prime found: 15333511742700010117
cargo run --release  0.03s user 0.01s system 99% cpu 0.042 total
</code></pre></div>

<p>It is as fast as Fermat&#39;s test but what about the &#34;probable prime&#34; thing here? Miller-Rabin&#39;s worst case error is bound to <span>4<sup>-k</sup></span>, but for large values of <span>n</span>, the error on average is much smaller like <span>8<sup>-k</sup></span>. What&#39;s the chance that a Miller-Rabin test with <span>k = 10</span> returns a composite?</p>
<div><pre><span></span><code>➜ python3 -c &#34;print(f&#39;chance of error = {8 ** -10 :.15f}%&#39;)&#34;
chance of error = 0.000000000931323%
</code></pre></div>

<p>That is good enough for me :). For context that probability is exactly the same as the probability of getting all heads in 30 consecutive coin tosses (<span>2<sup>-30</sup></span>). In real cryptographic use you have to be a bit more cautious though in how the random bases are picked and <a href="https://www.youtube.com/watch?v=OohldLXyVpc">assume adversarial conditions</a>.</p>
<p>Finally, we have a way to generate random numbers and we have a primality test that is fast and efficient enough to work on big numbers. The only things missing are the big numbers themselves, so let&#39;s venture even deeper...</p>
<h2>1024 bits, A bit of a detour?</h2>
<p>At this point it is obvious that we cannot go further than 64 bits by just using rust&#39;s built-in integer datatypes. What we need is a &#34;bigint&#34;, or an implementation of <a href="https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic">arbitrary precision arithmetic</a> usually called &#34;bigint&#34; or &#34;bignum&#34; in most languages. The sensible thing to do would be to import a bigint crate for rust and be done, but I am the one who gave myself the constraint of no external dependencies so I am going to follow it.</p>
<p>I guess it&#39;s time to build a BigInt :P</p>
<p>&#34;Build a BigInt&#34; is not the answer to &#34;how to generate big primes?&#34;, but there won&#39;t be any big primes (or composites for that matter) without a BigInt behind them, so we are going to take a bit of a detour and figure out how BigInt works.</p>
<h3>Attempt #1 - BigInt as digits</h3>
<p>After a quick skim of the Wikipedia page for arbitrary precision arithmetic and a brief research session, I found out there are a few ways to go about this. The easiest method was to store all the digits of your big number in an array and so that&#39;s what I tried for attempt #1.</p>
<p>At first it starts out really simple. The number is represented as just a list of digits, so implementing addition and multiplication is also easy and I copied the basic pen and paper methods that we learn in middle school into code. Once I reached division I realized that this is not going to be that simple, and after a few failed attempts I gave up. If you want a challenge, pause and try to think how you might implement the pen and paper long division algorithm in code.</p>
<h3>Attempt #2 - BigInt as binary</h3>
<p>After my failed attempt #1, I thought - why not store the numbers in binary? Or more specifically, why not store the number as a list of 0s and 1s? And so began my second attempt.</p>
<p>This was my very simple BigInt, just an array of bool values - </p>
<div><pre><span></span><code><span>const</span><span> </span><span>N</span>: <span>usize</span> <span>=</span><span> </span><span>2048</span><span>;</span>

<span>struct</span> <span>BigInt</span><span> </span><span>{</span>
<span>    </span><span>bits</span>: <span>[</span><span>bool</span><span>;</span><span> </span><span>N</span><span>]</span>
<span>}</span>
</code></pre></div>

<p>The actual size is 2048 instead of 1024 because as we saw earlier multiplying two N-bit numbers needs at most 2N bits of space.</p>
<p>Next we need some arithmetic. I still remember a few fragments of my <em>logic and microprocessor</em> class from university so what I did was basically implement a <a href="https://en.wikipedia.org/wiki/Adder_(electronics)#Full_adder">Full Adder</a> in code to handle addition and subtraction. This is what addition looked like - </p>
<div><pre><span></span><code><span>fn</span> <span>bigint_add</span><span>(</span><span>own</span>: <span>&amp;</span><span>[</span><span>bool</span><span>],</span><span> </span><span>other</span>: <span>&amp;</span><span>[</span><span>bool</span><span>])</span><span> </span>-&gt; <span>[</span><span>bool</span><span>;</span><span> </span><span>N</span><span>]</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>bits</span><span> </span><span>=</span><span> </span><span>[</span><span>false</span><span>;</span><span> </span><span>N</span><span>];</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>carry</span><span> </span><span>=</span><span> </span><span>false</span><span>;</span>

<span>    </span><span>for</span><span> </span><span>(</span><span>i</span><span>,</span><span> </span><span>(</span><span>d1</span><span>,</span><span> </span><span>d2</span><span>))</span><span> </span><span>in</span><span> </span><span>own</span><span>.</span><span>iter</span><span>().</span><span>zip</span><span>(</span><span>other</span><span>.</span><span>iter</span><span>()).</span><span>enumerate</span><span>()</span><span> </span><span>{</span>
<span>        </span><span>bits</span><span>[</span><span>i</span><span>]</span><span> </span><span>=</span><span> </span><span>d1</span><span> </span><span>^</span><span> </span><span>d2</span><span> </span><span>^</span><span> </span><span>carry</span><span>;</span>
<span>        </span><span>carry</span><span> </span><span>=</span><span> </span><span>(</span><span>d1</span><span> </span><span>&amp;</span><span> </span><span>d2</span><span>)</span><span> </span><span>|</span><span> </span><span>(</span><span>carry</span><span> </span><span>&amp;</span><span> </span><span>(</span><span>d1</span><span> </span><span>^</span><span> </span><span>d2</span><span>));</span>
<span>    </span><span>}</span>

<span>    </span><span>if</span><span> </span><span>carry</span><span> </span><span>{</span><span> </span><span>panic!</span><span>(</span><span>&#34;Attempt to add with overflow&#34;</span><span>);</span><span> </span><span>}</span>
<span>    </span><span>bits</span>
<span>}</span>


<span>impl</span><span> </span><span>Add</span><span> </span><span>for</span><span> </span><span>BigInt</span><span> </span><span>{</span>
<span>    </span><span>type</span> <span>Output</span><span> </span><span>=</span><span> </span><span>Self</span><span>;</span>
<span>    </span><span>fn</span> <span>add</span><span>(</span><span>self</span><span>,</span><span> </span><span>other</span>: <span>Self</span><span>)</span><span> </span>-&gt; <span>Self</span><span> </span><span>{</span>
<span>        </span><span>Self</span><span> </span><span>{</span><span> </span><span>bits</span>: <span>bigint_add</span><span>(</span><span>&amp;</span><span>self</span><span>.</span><span>bits</span><span>,</span><span> </span><span>&amp;</span><span>other</span><span>.</span><span>bits</span><span>)</span><span> </span><span>}</span>
<span>    </span><span>}</span>
<span>}</span>

<span>impl</span><span> </span><span>AddAssign</span><span> </span><span>for</span><span> </span><span>BigInt</span><span> </span><span>{</span>
<span>    </span><span>fn</span> <span>add_assign</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>,</span><span> </span><span>other</span>: <span>Self</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>self</span><span>.</span><span>bits</span><span> </span><span>=</span><span> </span><span>bigint_add</span><span>(</span><span>&amp;</span><span>self</span><span>.</span><span>bits</span><span>,</span><span> </span><span>&amp;</span><span>other</span><span>.</span><span>bits</span><span>);</span>
<span>    </span><span>}</span>
<span>}</span>
</code></pre></div>

<p>Note: Here I am using the <code>Add</code> and <code>AddAssign</code> traits from rust to override the <code>+</code> and <code>+=</code> operators for my BigInt type and will do the same for all other operators too.</p>
<p>Next I implemented the shift left (<code>&lt;&lt;</code>) and shift right (<code>&gt;&gt;</code>) operators. These just shift the entire list of bits left or right by the given amount, throwing away any overflow.</p>
<div><pre><span></span><code><span>fn</span> <span>bigint_shl</span><span>(</span><span>own</span>: <span>&amp;</span><span>[</span><span>bool</span><span>],</span><span> </span><span>amount</span>: <span>usize</span><span>)</span><span> </span>-&gt; <span>[</span><span>bool</span><span>;</span><span> </span><span>N</span><span>]</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>bits</span><span> </span><span>=</span><span> </span><span>[</span><span>false</span><span>;</span><span> </span><span>N</span><span>];</span>
<span>    </span><span>if</span><span> </span><span>amount</span><span> </span><span>&gt;</span><span> </span><span>N</span><span> </span><span>{</span><span> </span><span>return</span><span> </span><span>bits</span><span>;</span><span> </span><span>}</span>

<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>amount</span><span>;</span>
<span>    </span><span>for</span><span> </span><span>bit</span><span> </span><span>in</span><span> </span><span>own</span><span>.</span><span>iter</span><span>().</span><span>take</span><span>(</span><span>N</span><span> </span><span>-</span><span> </span><span>amount</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>bits</span><span>[</span><span>i</span><span>]</span><span> </span><span>=</span><span> </span><span>*</span><span>bit</span><span>;</span>
<span>        </span><span>i</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span>
<span>    </span><span>}</span>
<span>    </span><span>bits</span>
<span>}</span>

<span>fn</span> <span>bigint_shr</span><span>(</span><span>own</span>: <span>&amp;</span><span>[</span><span>bool</span><span>],</span><span> </span><span>amount</span>: <span>usize</span><span>)</span><span> </span>-&gt; <span>[</span><span>bool</span><span>;</span><span> </span><span>N</span><span>]</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>bits</span><span> </span><span>=</span><span> </span><span>[</span><span>false</span><span>;</span><span> </span><span>N</span><span>];</span>
<span>    </span><span>if</span><span> </span><span>amount</span><span> </span><span>&gt;</span><span> </span><span>N</span><span> </span><span>{</span><span> </span><span>return</span><span> </span><span>bits</span><span>;</span><span> </span><span>}</span>

<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span>
<span>    </span><span>for</span><span> </span><span>bit</span><span> </span><span>in</span><span> </span><span>own</span><span>.</span><span>iter</span><span>().</span><span>skip</span><span>(</span><span>amount</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>bits</span><span>[</span><span>i</span><span>]</span><span> </span><span>=</span><span> </span><span>*</span><span>bit</span><span>;</span>
<span>        </span><span>i</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span>
<span>    </span><span>}</span>
<span>    </span><span>bits</span>
<span>}</span>
</code></pre></div>

<p>Onward to multiplication. A really good thing about working in binary is that multiplication becomes very easy. Binary can only be 0 or 1, so no matter how long a number is, the only two results of its multiplication with a bit can be either 0 or itself. This reduces the classic multiplication algorithm to a much simpler one called &#34;<a href="https://users.utcluj.ro/~baruch/book_ssce/SSCE-Shift-Mult.pdf">shift-and-add</a>&#34; and now it can use the newly implemented &#34;shift&#34; and &#34;add&#34; -</p>
<div><pre><span></span><code><span>fn</span> <span>bigint_mul</span><span>(</span><span>own</span>: <span>&amp;</span><span>[</span><span>bool</span><span>],</span><span> </span><span>other</span>: <span>&amp;</span><span>[</span><span>bool</span><span>])</span><span> </span>-&gt; <span>[</span><span>bool</span><span>;</span><span> </span><span>N</span><span>]</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>BigInt</span>::<span>zero</span><span>();</span>
<span>    </span><span>let</span><span> </span><span>n1</span><span> </span><span>=</span><span> </span><span>BigInt</span>::<span>from</span><span>(</span><span>own</span><span>);</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>current</span><span>;</span>

<span>    </span><span>for</span><span> </span><span>(</span><span>shift</span><span>,</span><span> </span><span>d2</span><span>)</span><span> </span><span>in</span><span> </span><span>other</span><span>.</span><span>iter</span><span>().</span><span>enumerate</span><span>()</span><span> </span><span>{</span>
<span>        </span><span>if</span><span> </span><span>!</span><span>(</span><span>*</span><span>d2</span><span>)</span><span> </span><span>{</span><span> </span><span>continue</span><span>;</span><span> </span><span>}</span>

<span>        </span><span>for</span><span> </span><span>i</span><span> </span><span>in</span><span> </span><span>(</span><span>N</span><span> </span><span>-</span><span> </span><span>shift</span><span>)</span><span>..</span><span>N</span><span> </span><span>{</span>
<span>            </span><span>if</span><span> </span><span>own</span><span>[</span><span>i</span><span>]</span><span> </span><span>{</span><span> </span><span>panic!</span><span>(</span><span>&#34;Attempt to multiply with overflow&#34;</span><span>);</span><span> </span><span>}</span>
<span>        </span><span>}</span>

<span>        </span><span>current</span><span> </span><span>=</span><span> </span><span>n1</span><span> </span><span>&lt;&lt;</span><span> </span><span>shift</span><span>;</span>
<span>        </span><span>result</span><span> </span><span>+=</span><span> </span><span>current</span><span>;</span>
<span>    </span><span>}</span>

<span>    </span><span>result</span><span>.</span><span>bits</span>
<span>}</span>
</code></pre></div>

<p>Finally we arrive at division, and the reason why I decided to go with binary, because <a href="https://users.utcluj.ro/~baruch/book_ssce/SSCE-Basic-Division.pdf">binary long division</a> also simplifies the problem quite a lot. Unlike long division with 0-9 digits, the digits of the quotient can only be 1 or 0 in binary which means the intermediate subtractions use either the divisor or 0. This is similar to the &#34;shift-and-add&#34; algorithm above and can be implemented with just <a href="https://courses.cs.vt.edu/~cs1104/BuildingBlocks/divide.030.html">&#34;shift&#34; and &#34;sub&#34;</a> -  </p>
<div><pre><span></span><code><span>fn</span> <span>bigint_div</span><span>(</span><span>own_bits</span>: <span>&amp;</span><span>[</span><span>bool</span><span>],</span><span> </span><span>other_bits</span>: <span>&amp;</span><span>[</span><span>bool</span><span>])</span><span> </span>-&gt; <span>([</span><span>bool</span><span>;</span><span> </span><span>N</span><span>],</span><span> </span><span>[</span><span>bool</span><span>;</span><span> </span><span>N</span><span>])</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>quotient</span><span> </span><span>=</span><span> </span><span>BigInt</span>::<span>zero</span><span>();</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>dividend</span><span> </span><span>=</span><span> </span><span>BigInt</span>::<span>from</span><span>(</span><span>own_bits</span><span>);</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>remainder</span><span> </span><span>=</span><span> </span><span>BigInt</span>::<span>zero</span><span>();</span>
<span>    </span><span>let</span><span> </span><span>divisor</span><span> </span><span>=</span><span> </span><span>BigInt</span>::<span>from</span><span>(</span><span>other_bits</span><span>);</span>

<span>    </span><span>if</span><span> </span><span>divisor</span><span> </span><span>==</span><span> </span><span>BigInt</span>::<span>zero</span><span>()</span><span> </span><span>{</span>
<span>        </span><span>panic!</span><span>(</span><span>&#34;Attempt to divide by zero&#34;</span><span>);</span>
<span>    </span><span>}</span>

<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>no_of_bits</span><span> </span><span>=</span><span> </span><span>N</span><span>;</span>
<span>    </span><span>while</span><span> </span><span>!</span><span>dividend</span><span>.</span><span>bits</span><span>[</span><span>N</span><span> </span><span>-</span><span> </span><span>1</span><span>]</span><span> </span><span>{</span>
<span>        </span><span>dividend</span><span> </span><span>&lt;&lt;=</span><span> </span><span>1</span><span>;</span>
<span>        </span><span>no_of_bits</span><span> </span><span>-=</span><span> </span><span>1</span><span>;</span>
<span>    </span><span>}</span>

<span>    </span><span>for</span><span> </span><span>i</span><span> </span><span>in</span><span> </span><span>0</span><span>..</span><span>no_of_bits</span><span> </span><span>{</span>
<span>        </span><span>remainder</span><span> </span><span>&lt;&lt;=</span><span> </span><span>1</span><span>;</span>
<span>        </span><span>remainder</span><span>.</span><span>bits</span><span>[</span><span>0</span><span>]</span><span> </span><span>=</span><span> </span><span>dividend</span><span>.</span><span>bits</span><span>[</span><span>N</span><span> </span><span>-</span><span> </span><span>1</span><span> </span><span>-</span><span> </span><span>i</span><span>];</span>

<span>        </span><span>quotient</span><span> </span><span>&lt;&lt;=</span><span> </span><span>1</span><span>;</span>
<span>        </span><span>if</span><span> </span><span>remainder</span><span> </span><span>&gt;=</span><span> </span><span>divisor</span><span> </span><span>{</span>
<span>            </span><span>remainder</span><span> </span><span>-=</span><span> </span><span>divisor</span><span>;</span>
<span>            </span><span>quotient</span><span>.</span><span>bits</span><span>[</span><span>0</span><span>]</span><span> </span><span>=</span><span> </span><span>true</span><span>;</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>

<span>    </span><span>(</span><span>quotient</span><span>.</span><span>bits</span><span>,</span><span> </span><span>remainder</span><span>.</span><span>bits</span><span>)</span>
<span>}</span>
</code></pre></div>

<p>After doing some testing to confirm the arithmetic works as expected I switched over all <code>u128</code>s in <code>miller_rabin_test()</code> and <code>mod_exp()</code> over to my BigInt, changed the RNG to fill 1024 bits, and ran the code. It didn&#39;t finish in a few minutes and it was getting late at night, so I left it running and went to sleep. The next day I woke up to this - </p>
<div>
    <div><pre><span></span><code>➜ time cargo run --release
Prime found: 1100001101000111101111110011001111000010011111010110100010101011111110100010001100001101110101100100100110011110101100001000110010100011100101001010100110010110001101110111001110100110000001010111100000110111100010010010100110101011101010100101000100111110000001100000000011101111010100100101001111111100010010000110101010101000101010000011011110111101100011000010111011010000110101100111001101011000000001000100011001011100100000011110011011000000101000010001010001010010001101111100110001000011100110111100000010100000011101011100101101110100010111110000110000010111110000110101001110100100110101011101100111000100010110101001101110100111100010000000110000001001011100100100101001110100101100110110001001101110010100011011011110111100010011111011101010100010111010110101101010011110010111100100110111010111100101111111110010100101010111100111010001010101011100001000100101001111110101100101011100100001101111000100000001111100001001001010100101101111010000101001111111010110111111011101010100111011100111100001010101011101
cargo run --release  1959.67s user 0.09s system 99% cpu 32:44.90 total
</code></pre></div>
</div>

<p>Or expressed in base-10 - </p>
<div>
    <div><pre><span></span><code>137130462909417371581865483489043797725909059024661411704723085022816692663284008207826785132470756353352621332808019668785759110990576815741502628035997147255459016128105305451010585699069674494217365521467940783164171729442866016775055913991624626502191730619275815532321664270492537447637102633611801007453
</code></pre></div>
</div>

<p>This is the first 1024-bit prime number I found! I have solved the challenge! </p>
<p>But there was just one small issue - the runtime counter showed that it took ~30mins to find that prime. Although technically I have solved the challenge and also understood how to do it, taking 30 minutes per prime is not what I would call &#34;reasonable time&#34; especially when OpenSSL takes 30ms to do the same thing! The &#34;reasonable time&#34; limitation was part of the constraints because I want to learn both the skill of making it work and making it efficient :).</p>
<h3>Attempt #3 - BigInt as bytes</h3>
<p>The binary implementation I came up with in attempt #2 was immensely valuable. Not only did it give me my first 1024-bit prime, it was also an implementation that was proven to work correctly and I can test any further changes against it. This helped a lot with speeding up my experimentation and gave me the confidence to try some of the more difficult things.</p>
<p>When I started looking into why binary was so slow, the first thing I found was that in an array of <code>bool</code>, each <code>bool</code> would occupy a byte in memory  and not a single bit as I thought it might. This <a href="https://stackoverflow.com/a/48882542">stackoverflow answer</a> has the reasons why. This meant my <code>bool</code> array of size 2048 was not using 2048 bits of memory as I had assumed, but 2048 <em>bytes</em>! That&#39;s 2kb of memory just to store a single number. My binary implementation was probably spending almost all of its time waiting to read or write numbers from RAM due to L1 cache misses. I did not know at the time how to actually test this, but I thought let&#39;s try a more memory efficient version anyway and see if it improves things.</p>
<p>The natural path to follow would then be, why not store the bits as <em>byte sized chunks</em> instead of individual bits in a list. It could store all 2048 bits in an array of 256 bytes. Surprisingly, addition/subtraction and multiplication worked with this new format without any major changes to the algorithms. Instead of adding bit by bit and using an extra bit as carry, it would now add byte by byte using an extra byte as carry. I switched multiplication from &#34;shift-and-add&#34; back to the pen and paper algorithm I initially had for digits, but using bytes in place of 0-9 digits, and it worked without any modifications too. For division I added a few extra lines of code to treat the list of byte chunks as a single list of bits and the rest remained unchanged. </p>
<p>With all these improvements, I got my second 1024-bit prime at 4min 43sec. Nice improvement over the original binary, but still not enough.</p>
<h3>Attempt #4 - BigInt as u64 chunks</h3>
<p>While doing more research on arbitrary precision arithmetic trying to find other ways to optimize I made an interesting discovery. There is a reason why my arithmetic algorithms in attempt #3 worked directly with bytes instead of bits. What I had unknowingly implemented was a digit based BigInt similar to what I tried in attempt #1, but using &#34;high radix&#34; digits. Attempt #1 used base-10 digits, 0 to 9, what us humans are comfortable with, but a computer can work in any base you want it to use. You&#39;ve probably heard of base-16 (or hexadecimal) where the digits are 0-9 and A-F, or even base-64 which consists of all alphanumeric characters as the digits. My code from attempt #3 was effectively using base-255, with each byte acting as a single &#34;digit&#34;. </p>
<p>For example, here&#39;s the same number expressed in different bases -</p>
<div><pre><span></span><code>base-10:    3,095,627                          (7 digits)
base-16:    2F3C4B                             (6 digits)
base-64:    LzxL                               (4 digits)
base-255:   00101111 00111100 01001011         (3 digits)
</code></pre></div>

<p>(If you are wondering how I got the base-255 version, it is literally the binary representation of 3,095,627 split into 3 bytes.)</p>
<p>The funny thing is, I had read about this multiple times and dismissed it each time as being &#34;too complex a concept for me to understand&#34;, but after implementing it accidentally it finally clicked in my mind. Once I understood it the next logical thing to realize was that there&#39;s no reason for it to be limited to byte sized digits and I can push it as far as it would go.</p>
<p>So here&#39;s what my latest BigInt looks like -</p>
<div><pre><span></span><code><span>const</span><span> </span><span>N</span>: <span>usize</span> <span>=</span><span> </span><span>2048</span><span> </span><span>/</span><span> </span><span>64</span><span>;</span>

<span>struct</span> <span>BigInt</span><span> </span><span>{</span>
<span>    </span><span>chunks</span>: <span>[</span><span>u64</span><span>;</span><span> </span><span>N</span><span>]</span>
<span>}</span>
</code></pre></div>

<p>It uses a array of 32 u64 chunks to store upto 2048 bits. As usual it goes to twice the size we need so it has enough room to store the multiplication result of 2 BigInts. Similarly, the highest it can go for each individual &#34;digit&#34; is u64 as it would need to use a u128 to store the multiplication result of two individual &#34;digits&#34;. The rest of the code remained mostly unchanged from attempt #3 with a few small changes, like changing the carry variable to u64 instead of a byte. At this point, the BigInt is using base-(2<sup>64</sup>-1) or base-18446744073709551615 (🤯) and it only needs 16 &#34;digits&#34; to represent a number that uses 309 digits in base-10!</p>
<p>This now takes roughly 60-90 seconds to generate 1024-bit primes, which is a vast improvement over binary but still not fast enough.</p>
<h3>Attempt #5 - BigInt as u64 chunks, but better</h3>
<p>At this point I decided to run some simple benchmarks to try to find out what was slowing us down. Here&#39;s the results:</p>
<table>
<thead>
<tr>
<th></th>
<th>binary</th>
<th>u64 chunks</th>
</tr>
</thead>
<tbody>
<tr>
<td>a + b and a - b</td>
<td>5537.35ns</td>
<td>123.57ns</td>
</tr>
<tr>
<td>a * b</td>
<td>1292283.14ns</td>
<td>842.32ns</td>
</tr>
<tr>
<td>a / b and a % b</td>
<td>733446.76ns</td>
<td>44440.12ns</td>
</tr>
<tr>
<td>a &lt;&lt; b and a &gt;&gt; b</td>
<td>276.85ns</td>
<td>140.88ns</td>
</tr>
<tr>
<td>a &lt; b and a &gt; b</td>
<td>2506.02ns</td>
<td>58.91ns</td>
</tr>
</tbody>
</table>
<p>(All times average of 1000 runs measured in nanoseconds)</p>

<p>This shows the significant progress made since binary, and rest of attempt #5 is going to be a list of things I did to make it even faster.</p>
<h4>Division</h4>
<p>The biggest thing that jumps out from the benchmarks is: division. Even though everything else has improved a lot, division is still using the same algorithm that it used in binary, still doing long division a single bit at a time. I have always seen people complain about division being slow, now I know why. Division really is a harder problem to solve compared to addition or multiplication.</p>
<p>I saw multiple articles and sources pointing to a book - <em><a href="https://archive.org/details/handbookofapplie0000mene">Handbook of Applied Cryptography</a></em> when looking for better algorithms. I found it on the Internet Archive, made an account, and borrowed it for 14 days. This is what I found on page 598:</p>
<p><img src="https://dubroy.com/blog/page_598.png"/></p>
<p>Page 598, <em>Handbook of Applied Cryptography</em></p>

<p>On the one hand it&#39;s talking about &#34;radix b representation&#34; and by now I had done enough to understand that it was referencing the same &#34;high radix digits&#34; concept I had discovered earlier. On the other hand I understood nothing else at all and the book doesn&#39;t make it any easier as it didn&#39;t include any text explaining this algorithm. After staring at this page for 3 days straight and numerous failed attempts, I managed to write a working implementation. What I understood is that it is doing long division on base-N numbers, using the first 3 &#34;digits&#34; of the dividend and the first 2 &#34;digits&#34; of the divisor to estimate the current quotient &#34;digit&#34; in a loop until it finds the correct value, but I am not comfortable enough with <a href="https://mathsanew.com/articles/implementing_large_integers_division.pdf">the math behind it</a> yet to explain it here. I have also heard that a very similar algorithm appears in <em><a href="https://en.wikipedia.org/wiki/The_Art_of_Computer_Programming">The Art of Computer Programming</a></em>, but there was no easy way to quickly refer it other than buying a copy, which I would get around to doing eventually.</p>
<p>Spending the effort to figure this out did pay off though, it saves about 40,000ns (40μs) <strong><em>per division</em></strong>, and there are quite a lot of division and modulus operations that happen for a single run of Miller-Rabin and 1000s of Miller-Rabin runs before a prime is found. An additional optimization I did was to check if the divisor is a single &#34;digit&#34; (a single u64 chunk) and then directly do long division using u128 to catch any overflows. This skips the costly algorithm entirely and is another one of those cases that frequently appear in Miller-Rabin.</p>
<div><pre><span></span><code><span>fn</span> <span>bigint_div</span><span>(</span><span>mut</span><span> </span><span>dividend</span>: <span>BigInt</span><span>,</span><span> </span><span>mut</span><span> </span><span>divisor</span>: <span>BigInt</span><span>)</span><span> </span>-&gt; <span>(</span><span>BigInt</span><span>,</span><span> </span><span>BigInt</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>if</span><span> </span><span>divisor</span><span>.</span><span>is_zero</span><span>()</span><span> </span><span>{</span><span> </span><span>panic!</span><span>(</span><span>&#34;Attempt to divide by zero&#34;</span><span>);</span><span> </span><span>}</span>
<span>    </span><span>if</span><span> </span><span>dividend</span><span> </span><span>&lt;</span><span> </span><span>divisor</span><span> </span><span>{</span><span> </span><span>return</span><span> </span><span>(</span><span>BigInt</span>::<span>zero</span><span>(),</span><span> </span><span>dividend</span><span>)</span><span> </span><span>}</span>

<span>    </span><span>// x = dividend</span>
<span>    </span><span>// y = divisor</span>
<span>    </span><span>// b = 64 (size of a &#34;digit&#34;)</span>

<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>quotient</span><span> </span><span>=</span><span> </span><span>BigInt</span>::<span>zero</span><span>();</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>lambda</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span>

<span>    </span><span>let</span><span> </span><span>t</span><span> </span><span>=</span><span> </span><span>divisor</span><span>.</span><span>size</span><span>();</span>

<span>    </span><span>if</span><span> </span><span>divisor</span><span>.</span><span>chunks</span><span>[</span><span>t</span><span>]</span><span> </span><span>&lt;</span><span> </span><span>u64</span>::<span>MAX</span><span> </span><span>/</span><span> </span><span>2</span><span> </span><span>{</span>
<span>        </span><span>while</span><span> </span><span>divisor</span><span>.</span><span>chunks</span><span>[</span><span>t</span><span>]</span><span> </span><span>&lt;&lt;</span><span> </span><span>lambda</span><span> </span><span>&lt;</span><span> </span><span>u64</span>::<span>MAX</span><span> </span><span>/</span><span> </span><span>2</span><span> </span><span>{</span>
<span>            </span><span>lambda</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span>
<span>        </span><span>}</span>
<span>        </span><span>divisor</span><span> </span><span>&lt;&lt;=</span><span> </span><span>lambda</span><span>;</span>
<span>        </span><span>dividend</span><span> </span><span>&lt;&lt;=</span><span> </span><span>lambda</span><span>;</span>
<span>    </span><span>}</span>

<span>    </span><span>let</span><span> </span><span>n</span><span> </span><span>=</span><span> </span><span>dividend</span><span>.</span><span>size</span><span>();</span>

<span>    </span><span>// if y has only 1 &#34;digit&#34;, then do long division directly</span>
<span>    </span><span>if</span><span> </span><span>t</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span>
<span>        </span><span>let</span><span> </span><span>divisor_digit</span><span> </span><span>=</span><span> </span><span>divisor</span><span>.</span><span>chunks</span><span>[</span><span>0</span><span>]</span><span> </span><span>as</span><span> </span><span>u128</span><span>;</span>
<span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>remainder</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span>
<span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>current</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span>

<span>        </span><span>for</span><span> </span><span>(</span><span>i</span><span>,</span><span> </span><span>chunk</span><span>)</span><span> </span><span>in</span><span> </span><span>dividend</span><span>.</span><span>chunks</span><span>.</span><span>iter</span><span>().</span><span>enumerate</span><span>().</span><span>rev</span><span>().</span><span>skip</span><span>(</span><span>N</span><span> </span><span>-</span><span> </span><span>n</span><span> </span><span>-</span><span> </span><span>1</span><span>)</span><span> </span><span>{</span>
<span>            </span><span>current</span><span> </span><span>=</span><span> </span><span>(</span><span>remainder</span><span> </span><span>&lt;&lt;</span><span> </span><span>64</span><span>)</span><span> </span><span>+</span><span> </span><span>*</span><span>chunk</span><span> </span><span>as</span><span> </span><span>u128</span><span>;</span>
<span>            </span><span>quotient</span><span>.</span><span>chunks</span><span>[</span><span>i</span><span>]</span><span> </span><span>=</span><span> </span><span>(</span><span>current</span><span> </span><span>/</span><span> </span><span>divisor_digit</span><span>)</span><span> </span><span>as</span><span> </span><span>u64</span><span>;</span>
<span>            </span><span>remainder</span><span> </span><span>=</span><span> </span><span>current</span><span> </span><span>%</span><span> </span><span>divisor_digit</span><span>;</span>
<span>        </span><span>}</span>
<span>        </span><span>return</span><span> </span><span>(</span><span>quotient</span><span>,</span><span> </span><span>BigInt</span>::<span>from</span><span>(</span><span>remainder</span><span> </span><span>&gt;&gt;</span><span> </span><span>lambda</span><span>));</span>
<span>    </span><span>}</span>

<span>    </span><span>// step 2, align and then subtract y from x until x &gt;= aligned</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>aligned</span><span> </span><span>=</span><span> </span><span>divisor</span><span>.</span><span>clone</span><span>();</span>
<span>    </span><span>for</span><span> </span><span>_</span><span> </span><span>in</span><span> </span><span>0</span><span>..</span><span>(</span><span>n</span><span> </span><span>-</span><span> </span><span>t</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>aligned</span><span> </span><span>&lt;&lt;=</span><span> </span><span>64</span><span>;</span>
<span>    </span><span>}</span>

<span>    </span><span>while</span><span> </span><span>dividend</span><span> </span><span>&gt;=</span><span> </span><span>aligned</span><span> </span><span>{</span>
<span>        </span><span>quotient</span><span>.</span><span>chunks</span><span>[</span><span>n</span><span> </span><span>-</span><span> </span><span>t</span><span>]</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span>
<span>        </span><span>dividend</span><span> </span><span>-=</span><span> </span><span>aligned</span><span>;</span>
<span>    </span><span>}</span>

<span>    </span><span>let</span><span> </span><span>one</span><span> </span><span>=</span><span> </span><span>BigInt</span>::<span>from</span><span>(</span><span>1</span><span>);</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>x_3digit</span><span>;</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>y_2digit</span><span>;</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>q_u128</span><span>;</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>q_digit</span><span>;</span>

<span>    </span><span>// step 3</span>
<span>    </span><span>for</span><span> </span><span>i</span><span> </span><span>in</span><span> </span><span>((</span><span>t</span><span> </span><span>+</span><span> </span><span>1</span><span>)</span><span>..=</span><span>n</span><span>).</span><span>rev</span><span>()</span><span> </span><span>{</span>

<span>        </span><span>q_digit</span><span> </span><span>=</span><span> </span><span>BigInt</span>::<span>zero</span><span>();</span>

<span>        </span><span>// step 3.1</span>
<span>        </span><span>if</span><span> </span><span>dividend</span><span>.</span><span>chunks</span><span>[</span><span>i</span><span>]</span><span> </span><span>==</span><span> </span><span>divisor</span><span>.</span><span>chunks</span><span>[</span><span>t</span><span>]</span><span> </span><span>{</span>
<span>            </span><span>q_digit</span><span>.</span><span>chunks</span><span>[</span><span>0</span><span>]</span><span> </span><span>=</span><span> </span><span>u64</span>::<span>MAX</span><span> </span><span>-</span><span> </span><span>1</span><span>;</span>
<span>        </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span>
<span>            </span><span>q_u128</span><span> </span><span>=</span><span> </span><span>(</span><span>dividend</span><span>.</span><span>chunks</span><span>[</span><span>i</span><span>]</span><span> </span><span>as</span><span> </span><span>u128</span><span>)</span><span> </span><span>&lt;&lt;</span><span> </span><span>64</span><span>;</span>
<span>            </span><span>q_u128</span><span> </span><span>+=</span><span> </span><span>dividend</span><span>.</span><span>chunks</span><span>[</span><span>i</span><span> </span><span>-</span><span> </span><span>1</span><span>]</span><span> </span><span>as</span><span> </span><span>u128</span><span>;</span>
<span>            </span><span>q_digit</span><span> </span><span>=</span><span> </span><span>BigInt</span>::<span>from</span><span>(</span><span>q_u128</span><span> </span><span>/</span><span> </span><span>divisor</span><span>.</span><span>chunks</span><span>[</span><span>t</span><span>]</span><span> </span><span>as</span><span> </span><span>u128</span><span>);</span>
<span>        </span><span>}</span>

<span>        </span><span>// precalc 3digit x and 2digit y</span>
<span>        </span><span>x_3digit</span><span> </span><span>=</span><span> </span><span>BigInt</span>::<span>zero</span><span>();</span>
<span>        </span><span>x_3digit</span><span>.</span><span>chunks</span><span>[</span><span>2</span><span>]</span><span> </span><span>=</span><span> </span><span>dividend</span><span>.</span><span>chunks</span><span>[</span><span>i</span><span>];</span>
<span>        </span><span>x_3digit</span><span>.</span><span>chunks</span><span>[</span><span>1</span><span>]</span><span> </span><span>=</span><span> </span><span>dividend</span><span>.</span><span>chunks</span><span>[</span><span>i</span><span> </span><span>-</span><span> </span><span>1</span><span>];</span>
<span>        </span><span>x_3digit</span><span>.</span><span>chunks</span><span>[</span><span>0</span><span>]</span><span> </span><span>=</span><span> </span><span>dividend</span><span>.</span><span>chunks</span><span>[</span><span>i</span><span> </span><span>-</span><span> </span><span>2</span><span>];</span>

<span>        </span><span>y_2digit</span><span> </span><span>=</span><span> </span><span>BigInt</span>::<span>zero</span><span>();</span>
<span>        </span><span>y_2digit</span><span>.</span><span>chunks</span><span>[</span><span>1</span><span>]</span><span> </span><span>=</span><span> </span><span>divisor</span><span>.</span><span>chunks</span><span>[</span><span>t</span><span>];</span>
<span>        </span><span>y_2digit</span><span>.</span><span>chunks</span><span>[</span><span>0</span><span>]</span><span> </span><span>=</span><span> </span><span>divisor</span><span>.</span><span>chunks</span><span>[</span><span>t</span><span> </span><span>-</span><span> </span><span>1</span><span>];</span>

<span>        </span><span>// step 3.2</span>
<span>        </span><span>while</span><span> </span><span>q_digit</span><span> </span><span>*</span><span> </span><span>y_2digit</span><span> </span><span>&gt;</span><span> </span><span>x_3digit</span><span> </span><span>{</span>
<span>            </span><span>q_digit</span><span> </span><span>-=</span><span> </span><span>one</span><span>;</span>
<span>        </span><span>}</span>

<span>        </span><span>// move quotient &#34;digit&#34; from temp bigint to its place in quotient</span>
<span>        </span><span>quotient</span><span>.</span><span>chunks</span><span>[</span><span>i</span><span> </span><span>-</span><span> </span><span>t</span><span> </span><span>-</span><span> </span><span>1</span><span>]</span><span> </span><span>=</span><span> </span><span>q_digit</span><span>.</span><span>chunks</span><span>[</span><span>0</span><span>];</span>

<span>        </span><span>// precalc shifted y</span>
<span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>y_shifted</span><span> </span><span>=</span><span> </span><span>divisor</span><span>.</span><span>clone</span><span>();</span>
<span>        </span><span>for</span><span> </span><span>_</span><span> </span><span>in</span><span> </span><span>0</span><span>..</span><span>(</span><span>i</span><span> </span><span>-</span><span> </span><span>t</span><span> </span><span>-</span><span> </span><span>1</span><span>)</span><span> </span><span>{</span>
<span>            </span><span>y_shifted</span><span> </span><span>&lt;&lt;=</span><span> </span><span>64</span><span>;</span>
<span>        </span><span>}</span>

<span>        </span><span>// step 3.3 and 3.4</span>
<span>        </span><span>if</span><span> </span><span>dividend</span><span> </span><span>&gt;=</span><span> </span><span>q_digit</span><span> </span><span>*</span><span> </span><span>y_shifted</span><span> </span><span>{</span>
<span>            </span><span>dividend</span><span> </span><span>-=</span><span> </span><span>q_digit</span><span> </span><span>*</span><span> </span><span>y_shifted</span><span>;</span>
<span>        </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span>
<span>            </span><span>dividend</span><span> </span><span>+=</span><span> </span><span>y_shifted</span><span>;</span>
<span>            </span><span>dividend</span><span> </span><span>-=</span><span> </span><span>q_digit</span><span> </span><span>*</span><span> </span><span>y_shifted</span><span>;</span>
<span>            </span><span>quotient</span><span>.</span><span>chunks</span><span>[</span><span>i</span><span> </span><span>-</span><span> </span><span>t</span><span> </span><span>-</span><span> </span><span>1</span><span>]</span><span> </span><span>-=</span><span> </span><span>1</span><span>;</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>

<span>    </span><span>// rewind shifts by lambda to get actual remainder</span>
<span>    </span><span>dividend</span><span> </span><span>&gt;&gt;=</span><span> </span><span>lambda</span><span>;</span>

<span>    </span><span>(</span><span>quotient</span><span>,</span><span> </span><span>dividend</span><span>)</span>
<span>}</span>
</code></pre></div>

<h4>Multiplication</h4>
<p>Next I looked at multiplication, the second biggest thing in the benchmarks. I had implemented essentially the same algorithm as the book, so no gains there. Rearranging the loop calculations cleverly to eliminate an extra BigInt I was using to store the intermediate results gave a 2x improvement to runtime. </p>
<p>Since I had already added a function to calculate the size (number of occupied chunks) for division, I used the same function here to only run the loops for non-zero chunks and also added extra checks to skip loop iteration if one of the chunks is zero. Although this adds complexity and branching inside the loops, it still helps improve performance as most of the time BigInt is supposed to store 1024 bits or less and thus be half empty. This gave another 2x improvement.</p>
<p>I could have gone to the <a href="https://mathsanew.com/articles/implementing_large_integers_multiplication.pdf">Karatsuba</a> algorithm or even <a href="https://gmplib.org/manual/Multiplication-Algorithms">fast Fourier transforms (FFT)</a> which theoretically would give even better performance, but actually implementing it for a BigInt that I am building myself was too complex and my current multiplication was now fast enough that I did not pursue this path.</p>
<div><pre><span></span><code><span>fn</span> <span>bigint_mul</span><span>(</span><span>own</span>: <span>BigInt</span><span>,</span><span> </span><span>other</span>: <span>BigInt</span><span>)</span><span> </span>-&gt; <span>BigInt</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>BigInt</span>::<span>zero</span><span>();</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>intermediate</span><span>;</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>carry</span><span>;</span>

<span>    </span><span>let</span><span> </span><span>t</span><span> </span><span>=</span><span> </span><span>own</span><span>.</span><span>size</span><span>();</span>
<span>    </span><span>let</span><span> </span><span>n</span><span> </span><span>=</span><span> </span><span>other</span><span>.</span><span>size</span><span>();</span>
<span>    </span><span>if</span><span> </span><span>t</span><span> </span><span>+</span><span> </span><span>n</span><span> </span><span>+</span><span> </span><span>1</span><span> </span><span>&gt;=</span><span> </span><span>N</span><span> </span><span>{</span><span> </span><span>panic!</span><span>(</span><span>&#34;Attempt to multiply with overflow&#34;</span><span>);</span><span> </span><span>}</span>

<span>    </span><span>for</span><span> </span><span>(</span><span>j</span><span>,</span><span> </span><span>chunk2</span><span>)</span><span> </span><span>in</span><span> </span><span>other</span><span>.</span><span>chunks</span><span>.</span><span>iter</span><span>().</span><span>take</span><span>(</span><span>n</span><span> </span><span>+</span><span> </span><span>1</span><span>).</span><span>enumerate</span><span>()</span><span> </span><span>{</span>
<span>        </span><span>if</span><span> </span><span>*</span><span>chunk2</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span><span> </span><span>continue</span><span>;</span><span> </span><span>}</span>
<span>        </span><span>carry</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span>

<span>        </span><span>for</span><span> </span><span>(</span><span>i</span><span>,</span><span> </span><span>chunk1</span><span>)</span><span> </span><span>in</span><span> </span><span>own</span><span>.</span><span>chunks</span><span>.</span><span>iter</span><span>().</span><span>take</span><span>(</span><span>t</span><span> </span><span>+</span><span> </span><span>1</span><span>).</span><span>enumerate</span><span>()</span><span> </span><span>{</span>
<span>            </span><span>if</span><span> </span><span>*</span><span>chunk1</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>&amp;&amp;</span><span> </span><span>carry</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span><span> </span><span>continue</span><span>;</span><span> </span><span>}</span>

<span>            </span><span>intermediate</span><span> </span><span>=</span><span> </span><span>((</span><span>*</span><span>chunk1</span><span> </span><span>as</span><span> </span><span>u128</span><span>)</span><span> </span><span>*</span><span> </span><span>(</span><span>*</span><span>chunk2</span><span> </span><span>as</span><span> </span><span>u128</span><span>))</span><span> </span><span>+</span><span> </span><span>carry</span><span>;</span>
<span>            </span><span>intermediate</span><span> </span><span>+=</span><span> </span><span>result</span><span>.</span><span>chunks</span><span>[</span><span>i</span><span> </span><span>+</span><span> </span><span>j</span><span>]</span><span> </span><span>as</span><span> </span><span>u128</span><span>;</span>
<span>            </span><span>result</span><span>.</span><span>chunks</span><span>[</span><span>i</span><span> </span><span>+</span><span> </span><span>j</span><span>]</span><span> </span><span>=</span><span> </span><span>intermediate</span><span> </span><span>as</span><span> </span><span>u64</span><span>;</span>
<span>            </span><span>carry</span><span> </span><span>=</span><span> </span><span>intermediate</span><span> </span><span>&gt;&gt;</span><span> </span><span>64</span><span>;</span>
<span>        </span><span>}</span>
<span>        </span><span>result</span><span>.</span><span>chunks</span><span>[</span><span>t</span><span> </span><span>+</span><span> </span><span>j</span><span> </span><span>+</span><span> </span><span>1</span><span>]</span><span> </span><span>+=</span><span> </span><span>carry</span><span> </span><span>as</span><span> </span><span>u64</span><span>;</span>
<span>    </span><span>}</span>
<span>    </span><span>result</span>
<span>}</span>
</code></pre></div>

<h4>Addition and Subtraction</h4>
<p>These are already super fast, I was surprised to see even my custom implementation already runs relatively close to the time it takes rust to add two native u128. I tried a few things but (as expected) I was not as clever as the compiler and whatever magic it does under the hood.</p>
<div><pre><span></span><code><span>fn</span> <span>bigint_add</span><span>(</span><span>own</span>: <span>BigInt</span><span>,</span><span> </span><span>other</span>: <span>BigInt</span><span>)</span><span> </span>-&gt; <span>BigInt</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>sum</span><span>;</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>carry</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>sum_overflow</span><span>;</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>carry_overflow</span><span>;</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>BigInt</span>::<span>zero</span><span>();</span>

<span>    </span><span>let</span><span> </span><span>own_iter</span><span> </span><span>=</span><span> </span><span>own</span><span>.</span><span>chunks</span><span>.</span><span>iter</span><span>();</span>
<span>    </span><span>let</span><span> </span><span>other_iter</span><span> </span><span>=</span><span> </span><span>other</span><span>.</span><span>chunks</span><span>.</span><span>iter</span><span>();</span>

<span>    </span><span>for</span><span> </span><span>(</span><span>i</span><span>,</span><span> </span><span>(</span><span>chunk1</span><span>,</span><span> </span><span>chunk2</span><span>))</span><span> </span><span>in</span><span> </span><span>own_iter</span><span>.</span><span>zip</span><span>(</span><span>other_iter</span><span>).</span><span>enumerate</span><span>()</span><span> </span><span>{</span>
<span>        </span><span>(</span><span>sum</span><span>,</span><span> </span><span>sum_overflow</span><span>)</span><span> </span><span>=</span><span> </span><span>chunk1</span><span>.</span><span>overflowing_add</span><span>(</span><span>*</span><span>chunk2</span><span>);</span>
<span>        </span><span>(</span><span>sum</span><span>,</span><span> </span><span>carry_overflow</span><span>)</span><span> </span><span>=</span><span> </span><span>sum</span><span>.</span><span>overflowing_add</span><span>(</span><span>carry</span><span>);</span>
<span>        </span><span>result</span><span>.</span><span>chunks</span><span>[</span><span>i</span><span>]</span><span> </span><span>=</span><span> </span><span>sum</span><span>;</span>
<span>        </span><span>carry</span><span> </span><span>=</span><span> </span><span>sum_overflow</span><span> </span><span>as</span><span> </span><span>u64</span><span> </span><span>+</span><span> </span><span>carry_overflow</span><span> </span><span>as</span><span> </span><span>u64</span><span>;</span>
<span>    </span><span>}</span>

<span>    </span><span>if</span><span> </span><span>carry</span><span> </span><span>!=</span><span> </span><span>0</span><span> </span><span>{</span><span> </span><span>panic!</span><span>(</span><span>&#34;Attempt to add with overflow&#34;</span><span>);</span><span> </span><span>}</span>
<span>    </span><span>result</span>
<span>}</span>
</code></pre></div>

<h4>Miller-Rabin</h4>
<p>There were a bunch of optimizations that I found I could do in my implementation of Miller-Rabin. Here&#39;s what it looked like initially -</p>
<div><pre><span></span><code><span> 1</span><span>fn</span> <span>miller_rabin_test</span><span>(</span><span>n</span>: <span>BigInt</span><span>,</span><span> </span><span>k</span>: <span>usize</span><span>)</span><span> </span>-&gt; <span>PrimeResult</span><span> </span><span>{</span>
<span> 2</span><span>    </span><span>let</span><span> </span><span>zero</span><span> </span><span>=</span><span> </span><span>BigInt</span>::<span>zero</span><span>();</span>
<span> 3</span><span>    </span><span>let</span><span> </span><span>one</span><span> </span><span>=</span><span> </span><span>BigInt</span>::<span>from</span><span>(</span><span>1</span><span>);</span>
<span> 4</span><span>    </span><span>let</span><span> </span><span>two</span><span> </span><span>=</span><span> </span><span>BigInt</span>::<span>from</span><span>(</span><span>2</span><span>);</span>
<span> 5</span>
<span> 6</span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>s</span><span> </span><span>=</span><span> </span><span>zero</span><span>;</span>
<span> 7</span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>d</span><span> </span><span>=</span><span> </span><span>n</span><span> </span><span>-</span><span> </span><span>one</span><span>;</span>
<span> 8</span><span>    </span><span>while</span><span> </span><span>d</span><span> </span><span>%</span><span> </span><span>two</span><span> </span><span>==</span><span> </span><span>zero</span><span> </span><span>{</span>
<span> 9</span><span>        </span><span>d</span><span> </span><span>=</span><span> </span><span>d</span><span> </span><span>/</span><span> </span><span>two</span><span>;</span>
<span>10</span><span>        </span><span>s</span><span> </span><span>+=</span><span> </span><span>one</span><span>;</span>
<span>11</span><span>    </span><span>}</span>
<span>12</span>
<span>13</span><span>    </span><span>&#39;</span><span>main_loop</span>: <span>for</span><span> </span><span>_</span><span> </span><span>in</span><span> </span><span>0</span><span>..</span><span>k</span><span> </span><span>{</span>
<span>14</span><span>        </span><span>let</span><span> </span><span>base</span><span> </span><span>=</span><span> </span><span>&lt;&lt;</span><span>rng</span><span> </span><span>omitted</span><span>&gt;&gt;</span><span>;</span>
<span>15</span><span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>x</span><span> </span><span>=</span><span> </span><span>mod_exp</span><span>(</span><span>base</span><span>,</span><span> </span><span>d</span><span>,</span><span> </span><span>n</span><span>);</span>
<span>16</span><span>        </span><span>if</span><span> </span><span>x</span><span> </span><span>==</span><span> </span><span>one</span><span> </span><span>||</span><span> </span><span>x</span><span> </span><span>==</span><span> </span><span>n</span><span> </span><span>-</span><span> </span><span>one</span><span> </span><span>{</span><span> </span><span>continue</span><span> </span><span>&#39;main_loop</span><span>;</span><span> </span><span>}</span>
<span>17</span>
<span>18</span><span>        </span><span>while</span><span> </span><span>s</span><span> </span><span>&gt;</span><span> </span><span>zero</span><span> </span><span>{</span>
<span>19</span><span>            </span><span>x</span><span> </span><span>=</span><span> </span><span>mod_exp</span><span>(</span><span>x</span><span>,</span><span> </span><span>two</span><span>,</span><span> </span><span>n</span><span>);</span>
<span>20</span><span>            </span><span>if</span><span> </span><span>x</span><span> </span><span>==</span><span> </span><span>n</span><span> </span><span>-</span><span> </span><span>one</span><span> </span><span>{</span><span> </span><span>continue</span><span> </span><span>&#39;main_loop</span><span>;</span><span> </span><span>}</span>
<span>21</span><span>            </span><span>s</span><span> </span><span>-=</span><span> </span><span>one</span><span>;</span>
<span>22</span><span>        </span><span>}</span>
<span>23</span><span>        </span><span>return</span><span> </span><span>PrimeResult</span>::<span>Composite</span><span>;</span>
<span>24</span><span>    </span><span>}</span>
<span>25</span>
<span>26</span><span>    </span><span>PrimeResult</span>::<span>ProbablePrime</span>
<span>27</span><span>}</span>
</code></pre></div>

<div>
    <p>And here some of the major optimizations I did:</p>
<ul>
<li>The <code>mod_exp()</code> call on line 19 is no longer required as BigInt has enough memory to do <code>x = (x * x) % n</code> directly.</li>
<li>On line 15 <code>mod_exp()</code> was replaced by an simplified inline version which saved a lot of function call overhead.</li>
<li>The BigInt representation of &#34;2&#34; on line 4 was created just to do the even check on line 8. I wrote a simple <code>num.is_even()</code> function that only needs to check if the last bit is <code>0</code> or <code>1</code>, and so removed a bunch of extra costly divisions and an extra BigInt allocation.</li>
<li>Similarly, the division on line 9 can be replaced with a <code>d &gt;&gt;= 1</code> shift operation. In this case replacing another bunch of costly divisions with shifts is actually very beneficial compared to native code where this change is usually not worth it.</li>
<li>There are a lot of <code>+= one</code> and <code>-= one</code> (where <code>one</code> is BigInt representation of &#34;1&#34;), I added special <code>num.increase()</code> and <code>num.decrease()</code> which for almost all cases would just do a u64 addition/subtraction on the last &#34;digit&#34;, and only go to the full BigInt addition/subtraction if the last &#34;digit&#34; was either <code>0</code> or <code>u64::max</code>, meaning the rare cases where it actually needs the BigInt to handle the overflow from adding or subtracting 1.</li>
</ul>
</div>

<p>All of these and other changes not listed above individually account for just microseconds or even nanoseconds of advantage, but when they are run multiple times inside a loop inside thousands of Miller-Rabin tests it all adds up to a nice improvement in runtime. At least that is what I thought before I benchmarked them, and <code>is_even()</code> plus <code>d &gt;&gt;=1</code> easily outclass everything else give a whopping 70,000ns advantage <em>each</em>! Here&#39;s the final improved Miller-Rabin - </p>
<div><pre><span></span><code><span>fn</span> <span>miller_rabin_test</span><span>(</span><span>n</span>: <span>BigInt</span><span>,</span><span> </span><span>k</span>: <span>usize</span><span>)</span><span> </span>-&gt; <span>PrimeResult</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>zero</span><span> </span><span>=</span><span> </span><span>BigInt</span>::<span>zero</span><span>();</span>
<span>    </span><span>let</span><span> </span><span>one</span><span> </span><span>=</span><span> </span><span>BigInt</span>::<span>from</span><span>(</span><span>1</span><span>);</span>
<span>    </span><span>let</span><span> </span><span>n_minus_1</span><span> </span><span>=</span><span> </span><span>n</span><span>.</span><span>decrease</span><span>();</span>

<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>d</span><span> </span><span>=</span><span> </span><span>n_minus_1</span><span>;</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>s</span><span> </span><span>=</span><span> </span><span>zero</span><span>;</span>
<span>    </span><span>while</span><span> </span><span>d</span><span>.</span><span>is_even</span><span>()</span><span> </span><span>{</span>
<span>        </span><span>d</span><span> </span><span>&gt;&gt;=</span><span> </span><span>1</span><span>;</span>
<span>        </span><span>s</span><span> </span><span>=</span><span> </span><span>s</span><span>.</span><span>increase</span><span>();</span>
<span>    </span><span>}</span>

<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>bytes</span><span> </span><span>=</span><span> </span><span>[</span><span>0</span><span>;</span><span> </span><span>(</span><span>1024</span><span> </span><span>/</span><span> </span><span>16</span><span>)];</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>x</span><span>;</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>base</span><span>;</span>
<span>    </span><span>&#39;</span><span>main_loop</span>: <span>for</span><span> </span><span>_</span><span> </span><span>in</span><span> </span><span>0</span><span>..</span><span>k</span><span> </span><span>{</span>
<span>        </span><span>rng</span>::<span>insert_random_bytes</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>bytes</span><span>).</span><span>unwrap</span><span>();</span>
<span>        </span><span>base</span><span> </span><span>=</span><span> </span><span>BigInt</span>::<span>from</span><span>(</span><span>bytes</span><span>.</span><span>as_slice</span><span>());</span>

<span>        </span><span>x</span><span> </span><span>=</span><span> </span><span>one</span><span>;</span>
<span>        </span><span>while</span><span> </span><span>!</span><span>d</span><span>.</span><span>is_zero</span><span>()</span><span> </span><span>{</span>
<span>            </span><span>if</span><span> </span><span>!</span><span>d</span><span>.</span><span>is_even</span><span>()</span><span> </span><span>{</span><span> </span><span>x</span><span> </span><span>=</span><span> </span><span>(</span><span>x</span><span> </span><span>*</span><span> </span><span>base</span><span>)</span><span> </span><span>%</span><span> </span><span>n</span><span>;</span><span> </span><span>}</span>
<span>            </span><span>d</span><span> </span><span>=</span><span> </span><span>d</span><span> </span><span>&gt;&gt;</span><span> </span><span>1</span><span>;</span>
<span>            </span><span>base</span><span> </span><span>=</span><span> </span><span>(</span><span>base</span><span> </span><span>*</span><span> </span><span>base</span><span>)</span><span> </span><span>%</span><span> </span><span>n</span><span>;</span>
<span>        </span><span>}</span>
<span>        </span><span>if</span><span> </span><span>x</span><span> </span><span>==</span><span> </span><span>one</span><span> </span><span>||</span><span> </span><span>x</span><span> </span><span>==</span><span> </span><span>n_minus_1</span><span> </span><span>{</span><span> </span><span>continue</span><span> </span><span>&#39;main_loop</span><span>;</span><span> </span><span>}</span>

<span>        </span><span>while</span><span> </span><span>!</span><span>s</span><span>.</span><span>is_zero</span><span>()</span><span> </span><span>{</span>
<span>            </span><span>x</span><span> </span><span>=</span><span> </span><span>(</span><span>x</span><span> </span><span>*</span><span> </span><span>x</span><span>)</span><span> </span><span>%</span><span> </span><span>n</span><span>;</span>
<span>            </span><span>if</span><span> </span><span>x</span><span> </span><span>==</span><span> </span><span>n_minus_1</span><span> </span><span>{</span><span> </span><span>continue</span><span> </span><span>&#39;main_loop</span><span>;</span><span> </span><span>}</span>
<span>            </span><span>s</span><span> </span><span>=</span><span> </span><span>s</span><span>.</span><span>decrease</span><span>();</span>
<span>        </span><span>}</span>

<span>        </span><span>return</span><span> </span><span>PrimeResult</span>::<span>Composite</span><span>;</span>
<span>    </span><span>}</span>
<span>    </span><span>PrimeResult</span>::<span>ProbablePrime</span>
<span>}</span>
</code></pre></div>

<h4>Primality testing logic</h4>
<p>I modified the logic for testing primes with changes inspired by step 2 (64-bit primes) to add an additional trial division check at the start, using a precomputed list of the first 5000 small primes. This was infeasible for the majority of the time I was working on BigInt as trial division uses a lot of divisions, which were extremely slow. The trick to make it work is that all first 5000 small primes are small enough that they fit inside a single &#34;digit&#34; (a single u64 chunk). This means all divisions inside trial division would fall into the special case I just added, where it can perform the entire division using long division and u128 and skip the costly BigInt division algorithm. The same trial division function can also be used to generate the initial list of the first 5000 small primes. Optimizing trial division at step 2 did have some use after all! </p>
<p>Another change to the logic is that instead of reading <code>/dev/urandom</code> for each iteration of the loop and generating a new random number to test, it just adds 2 to the first random number to get the next candidate. Since the last bit is modified to be <code>1</code> we know it&#39;s an odd number, which means adding 2 would take it to the next odd number. This can be further optimized by adding a dedicated function <code>num.increase_by_2()</code> which like <code>num.increase()</code> will only do the full BigInt addition for the overflow case, and otherwise would just do a u64 addition. </p>
<p>And finally, this is one of those problems that can be called &#34;<a href="https://en.wikipedia.org/wiki/Embarrassingly_parallel">embarrassingly parallel</a>&#34; because there is no shared memory and no need to have any synchronization between threads. Instead of asking one CPU thread to find primes why not ask all 16 CPU threads and the fastest one wins!</p>
<p><span>- - -</span></p>
<p>Here are the same benchmarks after these optimizations:</p>
<table>
<thead>
<tr>
<th></th>
<th>binary</th>
<th>u64 chunks</th>
<th>u64 chunks but better</th>
</tr>
</thead>
<tbody>
<tr>
<td>a + b and a - b</td>
<td>5537.35ns</td>
<td>123.57ns</td>
<td>123.62ns</td>
</tr>
<tr>
<td>a * b</td>
<td>1292283.14ns</td>
<td>842.32ns</td>
<td>295.04ns</td>
</tr>
<tr>
<td>a / b and a % b</td>
<td>733446.76ns</td>
<td>44440.12ns</td>
<td>831.77ns</td>
</tr>
<tr>
<td>a &lt;&lt; b and a &gt;&gt; b</td>
<td>276.85ns</td>
<td>140.88ns</td>
<td>126.04ns</td>
</tr>
<tr>
<td>a &lt; b and a &gt; b</td>
<td>2506.02ns</td>
<td>58.91ns</td>
<td>58.50ns</td>
</tr>
<tr>
<td>a / 2 (or a &lt;&lt; 1)</td>
<td>2638289.48ns</td>
<td>75121.58ns</td>
<td>60.89ns</td>
</tr>
<tr>
<td>a % 2 == 0 (or a.is_even())</td>
<td>2447553.14ns</td>
<td>78400.87ns</td>
<td>21.65ns</td>
</tr>
<tr>
<td>a - 1 (or a.decrease())</td>
<td>6179.48ns</td>
<td>103.15ns</td>
<td>67.54ns</td>
</tr>
</tbody>
</table>
<p>(All times average of 1000 runs measured in nanoseconds)</p>

<h2>1024 bits, quite a bit faster!</h2>
<p>Finally, we arrive at the conclusion to this very long article. Let&#39;s combine everything together into a function to generate 1024-bit primes - </p>
<div><pre><span></span><code><span>fn</span> <span>primes_1024bit</span><span>()</span><span> </span>-&gt; <span>BigInt</span><span> </span><span>{</span>
<span>    </span><span>const</span><span> </span><span>P</span>: <span>usize</span> <span>=</span><span> </span><span>1000</span><span>;</span>
<span>    </span><span>let</span><span> </span><span>primes</span><span> </span><span>=</span><span> </span><span>utils</span>::<span>generate_small_primes</span>::<span>&lt;</span><span>P</span><span>&gt;</span><span>();</span>

<span>    </span><span>let</span><span> </span><span>zero</span><span> </span><span>=</span><span> </span><span>BigInt</span>::<span>zero</span><span>();</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>small_prime</span><span> </span><span>=</span><span> </span><span>BigInt</span>::<span>zero</span><span>();</span>

<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>bytes</span><span> </span><span>=</span><span> </span><span>[</span><span>0</span><span>u8</span><span>;</span><span> </span><span>1024</span><span> </span><span>/</span><span> </span><span>8</span><span>];</span>
<span>    </span><span>rng</span>::<span>insert_random_bytes</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>bytes</span><span>).</span><span>expect</span><span>(</span><span>&#34;Cannot access /dev/urandom&#34;</span><span>);</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>num</span><span> </span><span>=</span><span> </span><span>BigInt</span>::<span>from</span><span>(</span><span>bytes</span><span>.</span><span>as_slice</span><span>())</span>

<span>    </span><span>num</span><span>.</span><span>chunks</span><span>[(</span><span>1024</span><span> </span><span>/</span><span> </span><span>64</span><span>)</span><span> </span><span>-</span><span> </span><span>1</span><span>]</span><span> </span><span>|=</span><span> </span><span>0x8000000000000000</span><span>u64</span><span>;</span>
<span>    </span><span>num</span><span>.</span><span>chunks</span><span>[</span><span>0</span><span>]</span><span> </span><span>|=</span><span> </span><span>1</span><span>;</span>

<span>    </span><span>&#39;</span><span>prime_loop</span>: <span>loop</span><span> </span><span>{</span>
<span>        </span><span>num</span><span> </span><span>=</span><span> </span><span>num</span><span>.</span><span>increase_by_2</span><span>();</span>

<span>        </span><span>for</span><span> </span><span>i</span><span> </span><span>in</span><span> </span><span>0</span><span>..</span><span>P</span><span> </span><span>{</span>
<span>            </span><span>small_prime</span><span>.</span><span>chunks</span><span>[</span><span>0</span><span>]</span><span> </span><span>=</span><span> </span><span>primes</span><span>[</span><span>i</span><span>];</span>
<span>            </span><span>if</span><span> </span><span>num</span><span> </span><span>%</span><span> </span><span>small_prime</span><span> </span><span>==</span><span> </span><span>zero</span><span> </span><span>{</span>
<span>                </span><span>continue</span><span> </span><span>&#39;prime_loop</span><span>;</span>
<span>            </span><span>}</span>
<span>        </span><span>}</span>

<span>        </span><span>if</span><span> </span><span>miller_rabin_test</span><span>(</span><span>num</span><span>,</span><span> </span><span>10</span><span>)</span><span> </span><span>==</span><span> </span><span>PrimeResult</span>::<span>ProbablePrime</span><span> </span><span>{</span>
<span>            </span><span>return</span><span> </span><span>num</span><span>;</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>}</span>
</code></pre></div>

<p>Call the above function in parallel threads - </p>
<div><pre><span></span><code><span>fn</span> <span>run</span><span>()</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>(</span><span>tx</span><span>,</span><span> </span><span>rx</span><span>)</span><span> </span><span>=</span><span> </span><span>std</span>::<span>sync</span>::<span>mpsc</span>::<span>channel</span><span>();</span>

<span>    </span><span>for</span><span> </span><span>_</span><span> </span><span>in</span><span> </span><span>0</span><span>..</span><span>16</span><span> </span><span>{</span>
<span>        </span><span>let</span><span> </span><span>thread_tx</span><span> </span><span>=</span><span> </span><span>tx</span><span>.</span><span>clone</span><span>();</span>
<span>        </span><span>std</span>::<span>thread</span>::<span>spawn</span><span>(</span><span>move</span><span> </span><span>||</span><span> </span><span>{</span>
<span>            </span><span>thread_tx</span><span>.</span><span>send</span><span>(</span><span>primes_1024bit</span><span>()).</span><span>unwrap</span><span>();</span>
<span>        </span><span>});</span>
<span>    </span><span>}</span>

<span>    </span><span>let</span><span> </span><span>prime</span><span> </span><span>=</span><span> </span><span>rx</span><span>.</span><span>recv</span><span>().</span><span>unwrap</span><span>();</span>
<span>    </span><span>prime</span><span>.</span><span>print_decimal</span><span>();</span>
<span>}</span>
</code></pre></div>

<p>And here are the results! - </p>
<div>
    <div><pre><span></span><code>➜ time cargo run --release
133639768604208228777408136159783586754136713880762782100572086187859339703910900715674773943439684405153138260262492990850200027881950953138966616704637409705491165541761840874200485820151419486204300434469857557841532664407934654743999891926036532834796558113864177048787433702650711105375897281079281724197
cargo run --release  0.58s user 0.01s system 690% cpu 0.086 total
</code></pre></div>
</div>



<div><pre><span></span><code>➜ perf stat -r100 ./target/release/primes

--- outputs omitted ---

Performance counter stats for &#39;./target/release/primes&#39; (100 runs):

    --- other stats omitted ---

    0.04109 +- 0.00307 seconds time elapsed  ( +-  7.48% )
</code></pre></div>






    </article></div>
  </body>
</html>
