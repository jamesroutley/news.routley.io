<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ntietz.com/blog/rust-references-vs-pointers/">Original</a>
    <h1>What&#39;s the difference between references and pointers in Rust?</h1>
    
    <div id="readability-page-1" class="page"><div>
  <article>
    

    <p><strong>Monday, February  6, 2023</strong></p>

    <p>I&#39;ve been working on writing a <a href="https://yet-another-rust-resource.pages.dev/">Rust training course</a>, and one of the things I struggled with explaining in there was the difference between references and pointers.</p>
<p>Ultimately, the underlying representation is <strong>the same</strong>: both hold an address for some memory.
The difference between them is ultimately in semantics.</p>
<p>References have some <a href="https://doc.rust-lang.org/nomicon/references.html">rules</a> enforced by the compiler.
Specifically, they cannot outlive what they refer to (the &#34;referent&#34;), and mutable references cannot be aliased.
Other than that, references behave a lot like the variables they point to.
They have a type, and you can interact with that type to read it or (with mutable references) modify it.</p>
<p>On the other hand, pointers are semantically more about the address.
This means that when we interact with them, we&#39;ll be modifying the address (things like <code>add</code> will do pointer offsets instead of adding to the underlying value).
When we print them, we don&#39;t print the underlying valueâ€”in fact, we cannot get to the underlying value at all without the <code>unsafe</code> keyword.
Instead, we print out the address.</p>
<p>We can see this with a simple program.</p>
<pre><code><span>fn </span><span>main</span><span>() {
    </span><span>let</span><span> x</span><span>: </span><span>u32 </span><span>= </span><span>10</span><span>;
    </span><span>let</span><span> ref_x</span><span>: </span><span>&amp;</span><span>u32 </span><span>= &amp;</span><span>x</span><span>;
    </span><span>let</span><span> pointer_x</span><span>: </span><span>*const u32 </span><span>= &amp;</span><span>x</span><span>;

    </span><span>println!</span><span>(</span><span>&#34;x: </span><span>{x}</span><span>&#34;</span><span>)</span><span>;
    </span><span>println!</span><span>(</span><span>&#34;ref_x: </span><span>{}</span><span>&#34;</span><span>,</span><span> ref_x)</span><span>;
    </span><span>println!</span><span>(</span><span>&#34;pointer_x: </span><span>{:?}</span><span>&#34;</span><span>,</span><span> pointer_x)</span><span>;
</span><span>}
</span></code></pre>
<p>First, we create an unsigned 32-bit integer and give it a value.
Then we create a reference to the same value, and we&#39;ll also create a pointer to it.
And then we try to print this out.</p>
<p>When we execute this, we get this output:</p>
<pre><code><span>x: 10
ref_x: 10
pointer_x: 0x7ffd046a6444
</span></code></pre>
<p>When we interact with the variable directly or the reference, we get the underlying value.
But with the pointer, we get the address!</p>
<p>You can still access the underlying values with pointers, but you have to use <code>unsafe</code> to do so.
To see why, we can just try to dereference a raw pointer without <code>unsafe</code> and get an error message:</p>
<pre><code><span>error[</span><span>E0133</span><span>]</span><span>:</span><span> dereference of raw pointer is </span><span>unsafe</span><span> and requires </span><span>unsafe</span><span> function or block
  </span><span>-</span><span>-&gt;</span><span> src</span><span>/</span><span>main</span><span>.</span><span>rs</span><span>:</span><span>10</span><span>:</span><span>32
   </span><span>|
</span><span>10 </span><span>|     </span><span>println!</span><span>(</span><span>&#34;*pointer_x: </span><span>{}</span><span>&#34;</span><span>, </span><span>*</span><span>pointer_x)</span><span>;
   </span><span>|                                ^^^^^^^^^^ dereference of raw </span><span>pointer
   </span><span>|
   </span><span>=</span><span> note</span><span>:</span><span> raw pointers may be null</span><span>,</span><span> dangling or unaligned</span><span>;</span><span> they can violate aliasing rules and cause data races</span><span>:</span><span> all of these are undefined behavior
   </span><span>=</span><span> note</span><span>:</span><span> this error originates </span><span>in</span><span> the </span><span>macro</span><span> `$crate</span><span>::</span><span>format_args_nl` which comes from the expansion of the </span><span>macro</span><span> `println` (</span><span>in</span><span> Nightly builds</span><span>,</span><span> run with </span><span>-</span><span>Z </span><span>macro</span><span>-</span><span>backtrace </span><span>for</span><span> more info)
</span></code></pre>
<p>The important bit is in the note:</p>
<blockquote>
<p>note: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior</p>
</blockquote>
<p>And indeed, if we wrap it in <code>unsafe</code>, it will work:</p>
<pre><code><span>println!</span><span>(</span><span>&#34;*pointer_x: </span><span>{}</span><span>&#34;</span><span>, </span><span>unsafe </span><span>{ </span><span>*</span><span>pointer_x } )</span><span>;
</span></code></pre>
<p>Using references is safe.
The compiler will check that you don&#39;t alias the same mutable variable multiple times, ensuring you don&#39;t have data races.
It will ensure that any references do not outlive the memory they refer to.
You have to verify all those things yourself with raw pointers, so it&#39;s unsafe.</p>
<p>So that&#39;s the difference between references and pointers in Rust: <strong>they have the same underlying data, but different constraints and semantics with the compiler</strong>.</p>

  </article>

  <hr/>
  <p>
    If this post was enjoyable or useful for you, <strong>please share it!</strong>
    If you have comments, questions, or feedback, please email <a href="mailto:~ntietz/public-inbox@lists.sr.ht">my public inbox</a> or <a href="mailto:me@ntietz.com">my personal email</a>.
    To get new posts, please use my <a href="https://ntietz.com/atom.xml">RSS feed</a>.
  </p>
  
</div></div>
  </body>
</html>
