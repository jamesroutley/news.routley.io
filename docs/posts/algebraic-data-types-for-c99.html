<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/Hirrolot/datatype99">Original</a>
    <h1>Algebraic Data Types for C99</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><div dir="auto">
  <p><a href="https://github.com/Hirrolot/datatype99/blob/master/examples/binary_tree.c"><img src="https://github.com/Hirrolot/datatype99/raw/master/images/preview.png" width="600"/></a></p>
  <p><a href="https://github.com/Hirrolot/datatype99/actions">
    <img src="https://github.com/Hirrolot/datatype99/workflows/C/C++%20CI/badge.svg"/>
  </a>
  <a href="https://lists.sr.ht/~hirrolot/metalang99" rel="nofollow">
    <img src="https://camo.githubusercontent.com/c386c579e5acb1bee827aaea93d933bcd3e41e9d19098d9d9f9bd7f02e982dda/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6d61696c696e672532306c6973742d6c697374732e73722e68742d6f72616e6765" data-canonical-src="https://img.shields.io/badge/mailing%20list-lists.sr.ht-orange"/>
  </a></p><p dir="auto">Safe, intuitive <a href="https://en.wikipedia.org/wiki/Algebraic_data_type" rel="nofollow">algebraic data types</a> with exhaustive pattern matching &amp; compile-time introspection facilities. No external tools required, pure C99.</p>
</div>

<ul dir="auto">
<li>
<p dir="auto"><strong>Type-safe.</strong> Such things as improperly typed variants, non-exhaustive pattern matching, and invalid field access are caught at compile-time.</p>
</li>
<li>
<p dir="auto"><strong>Portable.</strong> Everything you need is a standard-conforming C99 compiler; neither the standard library, nor compiler/platform-specific functionality or VLA are required.</p>
</li>
<li>
<p dir="auto"><strong>Predictable.</strong> Datatype99 comes with formal <a href="#semantics">code generation semantics</a>, meaning that the generated data layout is guaranteed to always be the same.</p>
</li>
<li>
<p dir="auto"><strong>Comprehensible errors.</strong> Datatype99 is <a href="#q-what-about-compile-time-errors">resilient to bad code</a>.</p>
</li>
<li>
<p dir="auto"><strong>Battle-tested.</strong> Datatype99 is used at <a href="https://openipc.org/" rel="nofollow">OpenIPC</a> to develop real-time streaming software for IP cameras; this includes an <a href="https://github.com/OpenIPC/smolrtsp/">RTSP 1.0 implementation</a> along with ~50k lines of private code.</p>
</li>
</ul>

<p dir="auto">Datatype99 consists of one header file <code>datatype99.h</code> and one dependency <a href="https://github.com/Hirrolot/metalang99">Metalang99</a>. To use it in your project, you need to:</p>
<ol dir="auto">
<li>Add <code>datatype99</code> and <code>metalang99/include</code> to your include directories.</li>
<li>Specify <a href="https://gcc.gnu.org/onlinedocs/gcc/Preprocessor-Options.html" rel="nofollow"><code>-ftrack-macro-expansion=0</code></a> (GCC) or <a href="https://clang.llvm.org/docs/ClangCommandLineReference.html#cmdoption-clang-fmacro-backtrace-limit" rel="nofollow"><code>-fmacro-backtrace-limit=1</code></a> (Clang) to avoid useless macro expansion errors.</li>
</ol>
<p dir="auto">If you use CMake, the recommended way is <a href="https://cmake.org/cmake/help/latest/module/FetchContent.html" rel="nofollow"><code>FetchContent</code></a>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="include(FetchContent)

FetchContent_Declare(
    datatype99
    URL https://github.com/Hirrolot/datatype99/archive/refs/tags/v1.2.3.tar.gz # v1.2.3
)

FetchContent_MakeAvailable(datatype99)

target_link_libraries(MyProject datatype99)

# Disable full macro expansion backtraces for Metalang99.
if(CMAKE_C_COMPILER_ID STREQUAL &#34;Clang&#34;)
  target_compile_options(MyProject PRIVATE -fmacro-backtrace-limit=1)
elseif(CMAKE_C_COMPILER_ID STREQUAL &#34;GNU&#34;)
  target_compile_options(MyProject PRIVATE -ftrack-macro-expansion=0)
endif()"><pre><span>include</span>(FetchContent)

FetchContent_Declare(
    datatype99
    URL https://github.com/Hirrolot/datatype99/archive/refs/tags/v1.2.3.tar.gz <span><span>#</span> v1.2.3</span>
)

FetchContent_MakeAvailable(datatype99)

<span>target_link_libraries</span>(MyProject datatype99)

<span><span>#</span> Disable full macro expansion backtraces for Metalang99.</span>
<span>if</span>(CMAKE_C_COMPILER_ID <span>STREQUAL</span> <span>&#34;Clang&#34;</span>)
  <span>target_compile_options</span>(MyProject <span>PRIVATE</span> -fmacro-backtrace-limit=1)
<span>elseif</span>(CMAKE_C_COMPILER_ID <span>STREQUAL</span> <span>&#34;GNU&#34;</span>)
  <span>target_compile_options</span>(MyProject <span>PRIVATE</span> -ftrack-macro-expansion=0)
<span>endif</span>()</pre></div>
<p dir="auto">(By default, <code>datatype99/CMakeLists.txt</code> downloads Metalang99 <a href="https://github.com/Hirrolot/metalang99/releases/tag/v1.13.2">v1.13.2</a> from the GitHub releases; if you want to override this behaviour, you can do so by invoking <a href="https://cmake.org/cmake/help/latest/module/FetchContent.html#command:fetchcontent_declare" rel="nofollow"><code>FetchContent_Declare</code></a> earlier.)</p>
<p dir="auto">Optionally, you can <a href="https://en.wikipedia.org/wiki/Precompiled_header" rel="nofollow">precompile headers</a> in your project that rely on Datatype99. This will decrease compilation time, because the headers will not be compiled each time they are included.</p>
<p dir="auto">Happy hacking!</p>

<p dir="auto">Put simply, Datatype99 is just a syntax sugar over <a href="https://en.wikipedia.org/wiki/Tagged_union" rel="nofollow">tagged unions</a>; the only difference is that it is more safe and concise. For example, to represent a binary tree, you would normally write something like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="typedef struct {
    struct BinaryTree *lhs;
    int x;
    struct BinaryTree *rhs;
} BinaryTreeNode;

typedef struct {
    enum { Leaf, Node } tag;
    union {
        int leaf;
        BinaryTreeNode node;
    } data;
} BinaryTree;"><pre><span>typedef</span> <span>struct</span> {
    <span>struct</span> <span>BinaryTree</span> <span>*</span><span>lhs</span>;
    <span>int</span> <span>x</span>;
    <span>struct</span> <span>BinaryTree</span> <span>*</span><span>rhs</span>;
} <span>BinaryTreeNode</span>;

<span>typedef</span> <span>struct</span> {
    <span>enum</span> { <span>Leaf</span>, <span>Node</span> } <span>tag</span>;
    <span>union</span> {
        <span>int</span> <span>leaf</span>;
        <span>BinaryTreeNode</span> <span>node</span>;
    } <span>data</span>;
} <span>BinaryTree</span>;</pre></div>
<p dir="auto">To avoid this boilerplate, you can use Datatype99:</p>
<div dir="auto" data-snippet-clipboard-copy-content="datatype(
    BinaryTree,
    (Leaf, int),
    (Node, BinaryTree *, int, BinaryTree *)
);"><pre><span>datatype</span>(
    <span>BinaryTree</span>,
    (<span>Leaf</span>, <span>int</span>),
    (<span>Node</span>, <span>BinaryTree</span> <span>*</span><span></span>, <span>int</span>, <span>BinaryTree</span> <span>*</span>)
);</pre></div>
<p dir="auto">Say you want to sum all nodes and leafs in your binary tree. Then you may write something like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="int sum(const BinaryTree *tree) {
    switch (tree-&gt;tag) {
    case Leaf:
        return tree-&gt;data.leaf;
    case Node:
        return sum(tree-&gt;data.node.lhs) + tree-&gt;data.node.x + sum(tree-&gt;data.node.rhs);
    }

    // Invalid input (no such variant).
    return -1;
}"><pre><span>int</span> <span>sum</span>(<span>const</span> <span>BinaryTree</span> <span>*</span><span>tree</span>) {
    <span>switch</span> (<span>tree</span><span>-&gt;</span><span>tag</span>) {
    <span>case</span> <span>Leaf</span>:
        <span>return</span> <span>tree</span><span>-&gt;</span><span>data</span>.<span>leaf</span>;
    <span>case</span> <span>Node</span>:
        <span>return</span> <span>sum</span>(<span>tree</span><span>-&gt;</span><span>data</span>.<span>node</span>.<span>lhs</span>) <span>+</span> <span>tree</span><span>-&gt;</span><span>data</span>.<span>node</span>.<span>x</span> <span>+</span> <span>sum</span>(<span>tree</span><span>-&gt;</span><span>data</span>.<span>node</span>.<span>rhs</span>);
    }

    <span>// Invalid input (no such variant).</span>
    <span>return</span> <span>-1</span>;
}</pre></div>
<p dir="auto">... but what if you accidentally access <code>tree-&gt;data.node</code> after <code>case Leaf:</code>? Your compiler would not warn you, thus resulting in a business logic bug.</p>
<p dir="auto">With Datatype99, you can rewrite <code>sum</code> as follows, using a technique called <em>pattern matching</em>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="int sum(const BinaryTree *tree) {
    match(*tree) {
        of(Leaf, x) return *x;
        of(Node, lhs, x, rhs) return sum(*lhs) + *x + sum(*rhs);
    }

    // Invalid input (no such variant).
    return -1;
}"><pre><span>int</span> <span>sum</span>(<span>const</span> <span>BinaryTree</span> <span>*</span><span>tree</span>) {
    <span>match</span>(<span>*</span><span>tree</span>) {
        <span>of</span>(<span>Leaf</span>, <span>x</span>) <span>return</span> <span>*</span><span>x</span>;
        <span>of</span>(<span>Node</span>, <span>lhs</span>, <span>x</span>, <span>rhs</span>) <span>return</span> <span>sum</span>(<span>*</span><span>lhs</span>) <span>+</span> <span>*</span><span>x</span> <span>+</span> <span>sum</span>(<span>*</span><span>rhs</span>);
    }

    <span>// Invalid input (no such variant).</span>
    <span>return</span> <span>-1</span>;
}</pre></div>
<p dir="auto"><code>of</code> gives you variables called <em>bindings</em>: <code>x</code>, <code>lhs</code>, or <code>rhs</code>. This design has a few neat aspects:</p>
<ul dir="auto">
<li><strong>Compile-time safety.</strong> The bindings of <code>Node</code> are invisible after <code>of(Leaf, x)</code> and vice versa, so compilation will fail to proceed if you access them inappropriately.</li>
<li><strong>Flexibility.</strong> Bindings have pointer types so that you can mutate them, thereby mutating the whole <code>tree</code>; in order to obtain a value, you can dereference them, as shown in the example: <code>return *x;</code>.</li>
</ul>
<p dir="auto">The last thing unmentioned is how you construct variants. Internally, Datatype99 generates <code>inline static</code> functions called <em>value constructors</em>; you can use them as follows:</p>
<div dir="auto" data-snippet-clipboard-copy-content="BinaryTree leaf5 = Leaf(5);
BinaryTree leaf7 = Leaf(7);
BinaryTree node = Node(&amp;leaf5, 123, &amp;leaf7);"><pre><span>BinaryTree</span> <span>leaf5</span> <span>=</span> <span>Leaf</span>(<span>5</span>);
<span>BinaryTree</span> <span>leaf7</span> <span>=</span> <span>Leaf</span>(<span>7</span>);
<span>BinaryTree</span> <span>node</span> <span>=</span> <span>Node</span>(<span>&amp;</span><span>leaf5</span>, <span>123</span>, <span>&amp;</span><span>leaf7</span>);</pre></div>
<p dir="auto">Finally, just a few brief notes about pattern matching:</p>
<ul dir="auto">
<li>To match the default case, write <code>otherwise { ... }</code> at the end of <code>match</code>.</li>
<li>To ignore a binding, write <code>_</code>: <code>of(Foo, a, b, _, d)</code>.</li>
<li><strong>PLEASE</strong>, <a href="#top-level-breakcontinue">do <strong>not</strong> use top-level <code>break</code>/<code>continue</code></a> inside statements provided to <code>of</code> and <code>ifLet</code>; use <code>goto</code> labels instead.</li>
</ul>
<p dir="auto">Congratulations, this is all you need to know to write most of the stuff! If you feel fancy, you can also introspect your types at compile-time; see <a href="https://github.com/Hirrolot/datatype99/blob/master/examples/derive"><code>examples/derive/</code></a> for the examples.</p>

<p dir="auto">Having a well-defined semantics of the macros, you can write an FFI which is quite common in C.</p>

<div dir="auto" data-snippet-clipboard-copy-content="&lt;datatype&gt;      ::= &#34;datatype(&#34; [ &lt;derive-clause&gt; &#34;,&#34; ] &lt;datatype-name&gt; { &#34;,&#34; &lt;variant&gt; }+ &#34;)&#34; ;
&lt;record&gt;        ::= &#34;record(&#34;   [ &lt;derive-clause&gt; &#34;,&#34; ] &lt;record-name&gt;   { &#34;,&#34; &lt;field&gt;   }* &#34;)&#34; ;
&lt;datatype-name&gt; ::= &lt;ident&gt; ;
&lt;record-name&gt;   ::= &lt;ident&gt; ;

&lt;variant&gt;       ::= &#34;(&#34; &lt;variant-name&gt; { &#34;,&#34; &lt;type&gt; }* &#34;)&#34; ;
&lt;field&gt;         ::= &#34;(&#34; &lt;type&gt; &#34;,&#34; &lt;field-name&gt; &#34;)&#34; ;
&lt;variant-name&gt;  ::= &lt;ident&gt; ;
&lt;field-name&gt;    ::= &lt;ident&gt; ;

&lt;derive-clause&gt; ::= &#34;derive(&#34; &lt;deriver-name&gt; { &#34;,&#34; &lt;deriver-name&gt; }* &#34;)&#34; ;
&lt;deriver-name&gt;  ::= &lt;ident&gt; ;

&lt;match&gt;         ::= &#34;match(&#34; &lt;lvalue&gt; &#34;) {&#34; { &lt;of&gt; }* [ &lt;otherwise&gt; ] &#34;}&#34; ;
&lt;matches&gt;       ::= &#34;MATCHES(&#34; &lt;expr&gt; &#34;,&#34; &lt;ident&gt; &#34;)&#34; ;
&lt;if-let&gt;        ::= &#34;ifLet(&#34; &lt;lvalue&gt; &#34;,&#34; &lt;variant-name&gt; &#34;,&#34; &lt;ident&gt; { &#34;,&#34; &lt;ident&gt; }* &#34;)&#34; &lt;stmt&gt; ;
&lt;of&gt;            ::= &#34;of(&#34; &lt;variant-name&gt; { &#34;,&#34; &lt;ident&gt; }* &#34;)&#34; &lt;stmt&gt; ;
&lt;otherwise&gt;     ::= &#34;otherwise&#34; &lt;stmt&gt; ;"><pre><span>&lt;datatype&gt;</span>      <span>::=</span> <span><span>&#34;</span>datatype(<span>&#34;</span></span> [ &lt;<span>derive-clause</span>&gt; <span><span>&#34;</span>,<span>&#34;</span></span> ] &lt;<span>datatype-name</span>&gt; { <span><span>&#34;</span>,<span>&#34;</span></span> &lt;<span>variant</span>&gt; }<span>+</span> <span><span>&#34;</span>)<span>&#34;</span></span> ;
<span>&lt;record&gt;</span>        <span>::=</span> <span><span>&#34;</span>record(<span>&#34;</span></span>   [ &lt;<span>derive-clause</span>&gt; <span><span>&#34;</span>,<span>&#34;</span></span> ] &lt;<span>record-name</span>&gt;   { <span><span>&#34;</span>,<span>&#34;</span></span> &lt;<span>field</span>&gt;   }<span>*</span> <span><span>&#34;</span>)<span>&#34;</span></span> ;
<span>&lt;datatype-name&gt;</span> <span>::=</span> &lt;<span>ident</span>&gt; ;
<span>&lt;record-name&gt;</span>   <span>::=</span> &lt;<span>ident</span>&gt; ;
<span></span>
<span>&lt;variant&gt;</span>       <span>::=</span> <span><span>&#34;</span>(<span>&#34;</span></span> &lt;<span>variant-name</span>&gt; { <span><span>&#34;</span>,<span>&#34;</span></span> &lt;<span>type</span>&gt; }<span>*</span> <span><span>&#34;</span>)<span>&#34;</span></span> ;
<span>&lt;field&gt;</span>         <span>::=</span> <span><span>&#34;</span>(<span>&#34;</span></span> &lt;<span>type</span>&gt; <span><span>&#34;</span>,<span>&#34;</span></span> &lt;<span>field-name</span>&gt; <span><span>&#34;</span>)<span>&#34;</span></span> ;
<span>&lt;variant-name&gt;</span>  <span>::=</span> &lt;<span>ident</span>&gt; ;
<span>&lt;field-name&gt;</span>    <span>::=</span> &lt;<span>ident</span>&gt; ;
<span></span>
<span>&lt;derive-clause&gt;</span> <span>::=</span> <span><span>&#34;</span>derive(<span>&#34;</span></span> &lt;<span>deriver-name</span>&gt; { <span><span>&#34;</span>,<span>&#34;</span></span> &lt;<span>deriver-name</span>&gt; }<span>*</span> <span><span>&#34;</span>)<span>&#34;</span></span> ;
<span>&lt;deriver-name&gt;</span>  <span>::=</span> &lt;<span>ident</span>&gt; ;
<span></span>
<span>&lt;match&gt;</span>         <span>::=</span> <span><span>&#34;</span>match(<span>&#34;</span></span> &lt;<span>lvalue</span>&gt; <span><span>&#34;</span>) {<span>&#34;</span></span> { &lt;<span>of</span>&gt; }<span>*</span> [ &lt;<span>otherwise</span>&gt; ] <span><span>&#34;</span>}<span>&#34;</span></span> ;
<span>&lt;matches&gt;</span>       <span>::=</span> <span><span>&#34;</span>MATCHES(<span>&#34;</span></span> &lt;<span>expr</span>&gt; <span><span>&#34;</span>,<span>&#34;</span></span> &lt;<span>ident</span>&gt; <span><span>&#34;</span>)<span>&#34;</span></span> ;
<span>&lt;if-let&gt;</span>        <span>::=</span> <span><span>&#34;</span>ifLet(<span>&#34;</span></span> &lt;<span>lvalue</span>&gt; <span><span>&#34;</span>,<span>&#34;</span></span> &lt;<span>variant-name</span>&gt; <span><span>&#34;</span>,<span>&#34;</span></span> &lt;<span>ident</span>&gt; { <span><span>&#34;</span>,<span>&#34;</span></span> &lt;<span>ident</span>&gt; }<span>*</span> <span><span>&#34;</span>)<span>&#34;</span></span> &lt;<span>stmt</span>&gt; ;
<span>&lt;of&gt;</span>            <span>::=</span> <span><span>&#34;</span>of(<span>&#34;</span></span> &lt;<span>variant-name</span>&gt; { <span><span>&#34;</span>,<span>&#34;</span></span> &lt;<span>ident</span>&gt; }<span>*</span> <span><span>&#34;</span>)<span>&#34;</span></span> &lt;<span>stmt</span>&gt; ;
<span>&lt;otherwise&gt;</span>     <span>::=</span> <span><span>&#34;</span>otherwise<span>&#34;</span></span> &lt;<span>stmt</span>&gt; ;</pre></div>
<details>
  <summary>Note: shortened vs. postfixed versions</summary>
<p dir="auto">Each listed identifier in the above grammar corresponds to a macro name defined by default -- these are called <em>shortened versions</em>. On the other hand, there are also <em>postfixed versions</em> (<code>match99</code>, <code>of99</code>, <code>derive99</code>, etc.), which are defined unconditionally. If you want to avoid name clashes caused by shortened versions, define <code>DATATYPE99_NO_ALIASES</code> before including <code>datatype99.h</code>. Library headers are strongly advised to use the postfixed macros, but without resorting to <code>DATATYPE99_NO_ALIASES</code>.</p>
</details>

<p dir="auto">(It might be helpful to look at the <a href="https://godbolt.org/z/rebxMxW43" rel="nofollow">generated data layout</a> of <a href="https://github.com/Hirrolot/datatype99/blob/master/examples/binary_tree.c"><code>examples/binary_tree.c</code></a>.)</p>

<ol dir="auto">
<li>Before everything, the following type definition is generated:</li>
</ol>
<div data-snippet-clipboard-copy-content="typedef struct &lt;datatype-name&gt; &lt;datatype-name&gt;;"><pre><code>typedef struct &lt;datatype-name&gt; &lt;datatype-name&gt;;
</code></pre></div>
<ol start="2" dir="auto">
<li>For each non-empty variant, the following type definition is generated (the metavariable <code>&lt;type&gt;</code> ranges over a corresponding variant&#39;s types):</li>
</ol>
<div data-snippet-clipboard-copy-content="typedef struct &lt;datatype-name&gt;&lt;variant-name&gt; {
    &lt;type&gt;0 _0;
    ...
    &lt;type&gt;N _N;
} &lt;datatype-name&gt;&lt;variant-name&gt;;"><pre><code>typedef struct &lt;datatype-name&gt;&lt;variant-name&gt; {
    &lt;type&gt;0 _0;
    ...
    &lt;type&gt;N _N;
} &lt;datatype-name&gt;&lt;variant-name&gt;;
</code></pre></div>
<ol start="3" dir="auto">
<li>For each non-empty variant, the following type definitions to types of each field of <code>&lt;datatype-name&gt;&lt;variant-name&gt;</code> are generated:</li>
</ol>
<div data-snippet-clipboard-copy-content="typedef &lt;type&gt;0 &lt;variant-name&gt;_0;
...
typedef &lt;type&gt;N &lt;variant-name&gt;_N;"><pre><code>typedef &lt;type&gt;0 &lt;variant-name&gt;_0;
...
typedef &lt;type&gt;N &lt;variant-name&gt;_N;
</code></pre></div>
<ol start="4" dir="auto">
<li>For each variant, the following type definition to a corresponding sum type is generated:</li>
</ol>
<div data-snippet-clipboard-copy-content="typedef struct &lt;datatype-name&gt; &lt;variant-name&gt;SumT;"><pre><code>typedef struct &lt;datatype-name&gt; &lt;variant-name&gt;SumT;
</code></pre></div>
<ol start="5" dir="auto">
<li>For each sum type, the following tagged union is generated (inside the union, only fields to structures of non-empty variants are generated):</li>
</ol>
<div data-snippet-clipboard-copy-content="typedef enum &lt;datatype-name&gt;Tag {
    &lt;variant-name&gt;0Tag, ..., &lt;variant-name&gt;NTag
} &lt;datatype-name&gt;Tag;

typedef union &lt;datatype-name&gt;Variants {
    char dummy;

    &lt;datatype-name&gt;&lt;variant-name&gt;0 &lt;variant-name&gt;0;
    ...
    &lt;datatype-name&gt;&lt;variant-name&gt;N &lt;variant-name&gt;N;
} &lt;datatype-name&gt;Variants;

struct &lt;datatype-name&gt; {
    &lt;datatype-name&gt;Tag tag;
    &lt;datatype-name&gt;Variants data;
};"><pre><code>typedef enum &lt;datatype-name&gt;Tag {
    &lt;variant-name&gt;0Tag, ..., &lt;variant-name&gt;NTag
} &lt;datatype-name&gt;Tag;

typedef union &lt;datatype-name&gt;Variants {
    char dummy;

    &lt;datatype-name&gt;&lt;variant-name&gt;0 &lt;variant-name&gt;0;
    ...
    &lt;datatype-name&gt;&lt;variant-name&gt;N &lt;variant-name&gt;N;
} &lt;datatype-name&gt;Variants;

struct &lt;datatype-name&gt; {
    &lt;datatype-name&gt;Tag tag;
    &lt;datatype-name&gt;Variants data;
};
</code></pre></div>
<details>
  <summary>Note on char dummy;</summary>
<p dir="auto"><code>char dummy;</code> is needed to make the union contain at least one item, according to the standard, even if all variants are empty. Such a <code>datatype</code> would enforce strict type checking unlike plain C <code>enum</code>s.</p>
</details>
<ol start="6" dir="auto">
<li>For each variant, the following function called a <em>value constructor</em> is generated:</li>
</ol>
<div data-snippet-clipboard-copy-content="inline static &lt;datatype-name&gt; &lt;variant-name&gt;(/* ... */) { /* ... */ }"><pre><code>inline static &lt;datatype-name&gt; &lt;variant-name&gt;(/* ... */) { /* ... */ }
</code></pre></div>
<p dir="auto">If the variant has no parameters, this function will take <code>void</code> and initialise <code>.data.dummy</code> to <code>&#39;\0&#39;</code>; otherwise, it will take the corresponding variant parameters and initialise the result value as expected.</p>
<ol start="7" dir="auto">
<li>Now, when a sum type is fully generated, the derivation process takes place. Each deriver taken from <code>derive(...)</code> is invoked sequentially, from left to right, as</li>
</ol>
<div data-snippet-clipboard-copy-content="ML99_call(DATATYPE99_DERIVE_##&lt;deriver-name&gt;I, v(&lt;datatype-name&gt;), variants...)"><pre><code>ML99_call(DATATYPE99_DERIVE_##&lt;deriver-name&gt;I, v(&lt;datatype-name&gt;), variants...)
</code></pre></div>
<p dir="auto">where</p>
<ul dir="auto">
<li><code>&lt;deriver-name&gt;I</code> corresponds to a <a href="https://metalang99.readthedocs.io/en/latest/#definitions" rel="nofollow">Metalang99-compliant</a> macro of the form <code>#define DATATYPE99_DERIVE_##&lt;deriver-name&gt;I_IMPL(name, variants) /* ... */</code>.</li>
<li><code>variants...</code> is a <a href="https://metalang99.readthedocs.io/en/latest/list.html" rel="nofollow">list</a> of variants represented as two-place <a href="https://metalang99.readthedocs.io/en/latest/tuple.html" rel="nofollow">tuples</a>: <code>(&lt;variant-name&gt;, types...)</code>, where
<ul dir="auto">
<li><code>types...</code> is a <a href="https://metalang99.readthedocs.io/en/latest/list.html" rel="nofollow">list</a> of types of the corresponding variant.</li>
</ul>
</li>
</ul>
<p dir="auto">Put simply, a deriver is meant to generate something global for a sum type, like interface implementations or almost any other stuff. In terms of Rust, you can think of it as of the <a href="https://doc.rust-lang.org/reference/attributes/derive.html" rel="nofollow"><code>derive</code> attribute</a>.</p>

<p dir="auto"><code>record</code> represents a <em>record type</em>: it is simply a <code>struct</code> for which the derivation process is defined.</p>
<ol dir="auto">
<li>The following structure is generated:</li>
</ol>
<div data-snippet-clipboard-copy-content="typedef struct &lt;record-name&gt; {
    // Only if &lt;record-name&gt; has no fields:
    char dummy;

    &lt;type&gt;0 &lt;field-name&gt;0;
    ...
    &lt;type&gt;N &lt;field-name&gt;N;
} &lt;record-name&gt;;"><pre><code>typedef struct &lt;record-name&gt; {
    // Only if &lt;record-name&gt; has no fields:
    char dummy;

    &lt;type&gt;0 &lt;field-name&gt;0;
    ...
    &lt;type&gt;N &lt;field-name&gt;N;
} &lt;record-name&gt;;
</code></pre></div>
<details>
  <summary>Note on char dummy;</summary>
<p dir="auto"><code>char dummy;</code> is needed to make the structure contain at least one item, according to the standard. Such <code>record(Foo)</code> can be used to implement interfaces for it (see <a href="https://github.com/Hirrolot/interface99">Interface99</a>).</p>
</details>
<ol start="2" dir="auto">
<li>Each deriver taken from <code>derive(...)</code> is invoked sequentially, from left to right, as</li>
</ol>
<div data-snippet-clipboard-copy-content="ML99_call(DATATYPE99_RECORD_DERIVE_##&lt;deriver-name&gt;I, v(&lt;record-name&gt;), fields...)"><pre><code>ML99_call(DATATYPE99_RECORD_DERIVE_##&lt;deriver-name&gt;I, v(&lt;record-name&gt;), fields...)
</code></pre></div>
<p dir="auto">where</p>
<ul dir="auto">
<li><code>&lt;deriver-name&gt;I</code> corresponds to a <a href="https://metalang99.readthedocs.io/en/latest/#definitions" rel="nofollow">Metalang99-compliant</a> macro of the form <code>#define DATATYPE99_RECORD_DERIVE_##&lt;deriver-name&gt;I_IMPL(name, fields) /* ... */</code>.</li>
<li><code>fields...</code> is a <a href="https://metalang99.readthedocs.io/en/latest/list.html" rel="nofollow">list</a> of fields represented as two-place <a href="https://metalang99.readthedocs.io/en/latest/tuple.html" rel="nofollow">tuples</a>: <code>(&lt;type&gt;, &lt;field-name&gt;)</code>. If a record contains no fields, the list would consist only of <code>(char, dummy)</code>.</li>
</ul>

<p dir="auto"><code>match</code> has the expected semantics: it sequentially tries to match the given instance of a sum type against the given variants, and, if a match has succeeded, it executes the corresponding statement and moves down to the next instruction (<code>match(val) { ... } next-instruction;</code>). If all the matches have failed, it executes the statement after <code>otherwise</code> and moves down to the next instruction.</p>
<p dir="auto">A complete <code>match</code> construct results in a single C statement.</p>

<p dir="auto"><code>of</code> accepts a matched variant name as a first argument and the rest of arguments comprise a comma-separated list of bindings.</p>
<ul dir="auto">
<li>A binding equal to <code>_</code> is ignored.</li>
<li>A binding <strong>not</strong> equal to <code>_</code> stands for a pointer to a corresponding data of the variant (e.g., let there be <code>(Foo, T1, T2)</code> and <code>of(Foo, x, y)</code>, then <code>x</code> has the type <code>T1 *</code> and <code>y</code> is <code>T2 *</code>).</li>
</ul>
<p dir="auto">There can be more than one <code>_</code> binding, however, non-<code>_</code> bindings must be distinct.</p>
<p dir="auto">To match an empty variant, write <code>of(Bar)</code>.</p>

<p dir="auto"><code>MATCHES</code> just tests an instance of a sum type for a given variant. If the given instance corresponds to the given variant, it expands to truthfulness, otherwise it expands to falsehood.</p>

<p dir="auto"><strong>DEPRECATED</strong>: use <a href="#MATCHES"><code>MATCHES</code></a> instead.</p>

<p dir="auto"><code>ifLet</code> tries to match the given instance of a sum type against the given variant, and, if a match has succeeded, it executes the corresponding statement.</p>
<p dir="auto">Think of <code>ifLet(&lt;expr&gt;, &lt;variant-name&gt;, vars...) { /* ... */ }</code> as of an abbreviation of</p>
<div data-snippet-clipboard-copy-content="match(&lt;expr&gt;) {
    of(&lt;variant-name&gt;, vars...) { /* ... */ }
    otherwise {}
}"><pre><code>match(&lt;expr&gt;) {
    of(&lt;variant-name&gt;, vars...) { /* ... */ }
    otherwise {}
}
</code></pre></div>
<p dir="auto">A complete <code>ifLet</code> construct results in a single C statement.</p>

<p dir="auto">The unit type <code>UnitT99</code> represents the type of a single value, <code>unit_v99</code> (it should not be assigned to anything else). These are defined as follows:</p>
<div dir="auto" data-snippet-clipboard-copy-content="typedef char UnitT99;
static const UnitT99 unit_v99 = &#39;\0&#39;;"><pre><span>typedef</span> <span>char</span> <span>UnitT99</span>;
<span>static</span> <span>const</span> <span>UnitT99</span> <span>unit_v99</span> <span>=</span> <span>&#39;\0&#39;</span>;</pre></div>
<p dir="auto">If <code>DATATYPE99_NO_ALIASES</code> remains undefined prior to <code>#include &lt;datatype99.h&gt;</code>, <code>UnitT99</code> and <code>unit_v99</code> are also accessible through object-like macros <code>UnitT</code> &amp; <code>unit_v</code>.</p>

<p dir="auto">You can pass named arguments to a deriver; these are called <em>derive helper attributes</em>. They must be specified as object-like macros of the form:</p>
<div data-snippet-clipboard-copy-content="#define &lt;variant-name&gt;_&lt;namespace&gt;_&lt;attribute-name&gt; attr(/* attribute value */)"><pre><code>#define &lt;variant-name&gt;_&lt;namespace&gt;_&lt;attribute-name&gt; attr(/* attribute value */)
</code></pre></div>
<p dir="auto">where <code>&lt;namespace&gt;</code> is either <code>&lt;datatype-name&gt;</code>/<code>&lt;record-name&gt;</code> or <code>&lt;variant-name&gt;</code>/<code>&lt;field-name&gt;</code> for <code>datatype</code>/<code>record</code>-specific and variant/field-specific attributes, respectively.</p>
<p dir="auto">To manipulate derive helper attributes, there are a few predefined macros:</p>
<ul dir="auto">
<li>
<p dir="auto"><code>DATATYPE99_attrIsPresent</code>/<code>DATATYPE99_ATTR_IS_PRESENT</code></p>
<p dir="auto">Accepts an attribute name and checks if it is present or not. It can be used to check the presence of an optional attribute.</p>
</li>
<li>
<p dir="auto"><code>DATATYPE99_attrValue</code>/<code>DATATYPE99_ATTR_VALUE</code></p>
<p dir="auto">Accepts an attribute name extracts its value. A provided attribute <strong>must</strong> be present.</p>
</li>
<li>
<p dir="auto"><code>DATATYPE99_assertAttrIsPresent</code></p>
<p dir="auto">Accepts an attribute name and emits a fatal error if the attribute is not present, otherwise results in emptiness. It can be used for mandatory attributes.</p>
</li>
</ul>
<p dir="auto">(The naming convention here is the same <a href="https://metalang99.readthedocs.io/en/latest/#naming-conventions" rel="nofollow">as of Metalang99</a>.)</p>

<ul dir="auto">
<li>
<p dir="auto">The macros <code>DATATYPE99_MAJOR</code>, <code>DATATYPE99_MINOR</code>, <code>DATATYPE99_PATCH</code>, <code>DATATYPE99_VERSION_COMPATIBLE(x, y, z)</code>, and <code>DATATYPE99_VERSION_EQ(x, y, z)</code> have the <a href="https://metalang99.readthedocs.io/en/latest/#version-manipulation-macros" rel="nofollow">same semantics as of Metalang99</a>.</p>
</li>
<li>
<p dir="auto">For each macro using <code>ML99_EVAL</code>, Datatype99 provides its <a href="https://metalang99.readthedocs.io/en/latest/#definitions" rel="nofollow">Metalang99-compliant</a> counterpart which can be used inside derivers and other Metalang99-compliant macros:</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Macro</th>
<th>Metalang99-compliant counterpart</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>datatype</code></td>
<td><code>DATATYPE99_datatype</code></td>
</tr>
<tr>
<td><code>record</code></td>
<td><code>DATATYPE99_record</code></td>
</tr>
<tr>
<td><code>of</code></td>
<td><code>DATATYPE99_of</code></td>
</tr>
<tr>
<td><code>ifLet</code></td>
<td><code>DATATYPE99_ifLet</code></td>
</tr>
</tbody>
</table>
<p dir="auto">(An <a href="https://hirrolot.gitbook.io/metalang99/partial-application" rel="nofollow">arity specifier</a> and <a href="https://metalang99.readthedocs.io/en/latest/#definitions" rel="nofollow">desugaring macro</a> are provided for each of the above macros.)</p>
<ul dir="auto">
<li>There is a built-in deriver <code>dummy</code> which generates nothing. It is defined both for record and sum types.</li>
</ul>


<p dir="auto">If you use <a href="https://clang.llvm.org/docs/ClangFormatStyleOptions.html" rel="nofollow">Clang-Format</a>, cancel formatting for a <code>datatype</code> definition using <code>// clang-format off</code> &amp; <code>// clang-format on</code> to make it look prettier, as in the examples.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto"><code>#undef</code> derive helper attributes</h3><a id="user-content-undef-derive-helper-attributes" aria-label="Permalink: #undef derive helper attributes" href="#undef-derive-helper-attributes"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Always <code>#undef</code> derive helper attributes after a corresponding <code>datatype</code> definition not to pollute your namespace.</p>

<p dir="auto">If the meaning of variant parameters is not clear from the context, give them descriptive names. This can be achieved in several ways:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// 1. Define type aliases to variant parameters.
typedef double XCoordinate;
typedef double YCoordinate;

typedef double Width;
typedef double Height;

datatype(
    Shape,
    (Point, XCoordinate, YCoordinate),
    (Rectangle, Width, Height)
);

// 2. Define separate structures.
typedef struct {
    double x, y;
} Point;

typedef struct {
    double width, height;
} Rectangle;

datatype(
    Shape,
    (MkPoint, Point),
    (MkRectangle, Rectangle)
);"><pre><span>// 1. Define type aliases to variant parameters.</span>
<span>typedef</span> <span>double</span> <span>XCoordinate</span>;
<span>typedef</span> <span>double</span> <span>YCoordinate</span>;

<span>typedef</span> <span>double</span> <span>Width</span>;
<span>typedef</span> <span>double</span> <span>Height</span>;

<span>datatype</span>(
    <span>Shape</span>,
    (<span>Point</span>, <span>XCoordinate</span>, <span>YCoordinate</span>),
    (<span>Rectangle</span>, <span>Width</span>, <span>Height</span>)
);

<span>// 2. Define separate structures.</span>
<span>typedef</span> <span>struct</span> {
    <span>double</span> <span>x</span>, <span>y</span>;
} <span>Point</span>;

<span>typedef</span> <span>struct</span> {
    <span>double</span> <span>width</span>, <span>height</span>;
} <span>Rectangle</span>;

<span>datatype</span>(
    <span>Shape</span>,
    (<span>MkPoint</span>, <span>Point</span>),
    (<span>MkRectangle</span>, <span>Rectangle</span>)
);</pre></div>
<p dir="auto">Comparison:</p>
<ul dir="auto">
<li>The former option has more concise syntax: <code>MkPoint(x, y)</code> instead of <code>MkPoint((Point){x, y})</code>.</li>
<li>The latter option is more appropriate when the structures are to be used separately from the containing sum type.</li>
<li>The latter option allows for more graduate control over the data layout: you can accompain the structures with compiler-specific attributes, alignment properties like <code>__attribute__ ((__packed__))</code>, etc.</li>
</ul>


<p dir="auto">Do <strong>not</strong> use <code>break</code>/<code>continue</code> inside a statement provided to <code>of</code>/<code>ifLet</code> but outside of any <code>for</code>/<code>while</code> loops in that statement. For example, this code is fine:</p>
<div dir="auto" data-snippet-clipboard-copy-content="match(x) {
    of(Foo, a, b, c) {
        for (int i = 0; i &lt; 10; i++) {
            continue;
        }
    }
}"><pre><span>match</span>(<span>x</span>) {
    <span>of</span>(<span>Foo</span>, <span>a</span>, <span>b</span>, <span>c</span>) {
        <span>for</span> (<span>int</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>10</span>; <span>i</span><span>++</span>) {
            <span>continue</span>;
        }
    }
}</pre></div>
<p dir="auto">But this code is <strong>not</strong> fine:</p>
<div dir="auto" data-snippet-clipboard-copy-content="for (int i = 0; i &lt; 10; i++) {
    match(x) {
        of(Foo, a, b, c) {
            if (a == 7) { break; }
            continue;
        }
    }
}"><pre><span>for</span> (<span>int</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>10</span>; <span>i</span><span>++</span>) {
    <span>match</span>(<span>x</span>) {
        <span>of</span>(<span>Foo</span>, <span>a</span>, <span>b</span>, <span>c</span>) {
            <span>if</span> (<span>a</span> <span>==</span> <span>7</span>) { <span>break</span>; }
            <span>continue</span>;
        }
    }
}</pre></div>
<p dir="auto">To make it valid, you can rewrite it as follows:</p>
<div dir="auto" data-snippet-clipboard-copy-content="for (int i = 0; i &lt; 10; i++) {
    match(x) {
        of(Foo, a, b, c) {
            if (a == 7) { goto my_break; }
            goto my_continue;
        }
    }

    // Datatype99 prohibits top-level `break`/`continue`.
    my_continue:;
}
my_break:;"><pre><span>for</span> (<span>int</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>10</span>; <span>i</span><span>++</span>) {
    <span>match</span>(<span>x</span>) {
        <span>of</span>(<span>Foo</span>, <span>a</span>, <span>b</span>, <span>c</span>) {
            <span>if</span> (<span>a</span> <span>==</span> <span>7</span>) { goto my_break; }
            goto my_continue;
        }
    }

    <span>// Datatype99 prohibits top-level `break`/`continue`.</span>
    my_continue:;
}
my_break:;</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Array as a variant parameter</h3><a id="user-content-array-as-a-variant-parameter" aria-label="Permalink: Array as a variant parameter" href="#array-as-a-variant-parameter"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">To specify an array as a variant parameter, you must put it into a separate <code>struct</code>; see <a href="https://github.com/Hirrolot/datatype99/blob/master/examples/array_in_variant.c"><code>examples/array_in_variant.c</code></a>.</p>

<p dir="auto">Bindings introduced by <code>of</code> are <strong>always</strong> mutable, so make sure you do <strong>not</strong> mutate them if the value passed to <code>match</code> is qualified as <code>const</code>.</p>

<p dir="auto">Thanks to Rust and ML for their implementations of sum types.</p>

<ul dir="auto">
<li><a href="https://hirrolot.github.io/posts/pretty-printable-enumerations-in-pure-c.html" rel="nofollow"><em>Pretty-Printable Enumerations in Pure C</em></a> by Hirrolot.</li>
<li><a href="https://hirrolot.github.io/posts/whats-the-point-of-the-c-preprocessor-actually.html" rel="nofollow"><em>What’s the Point of the C Preprocessor, Actually?</em></a> by Hirrolot.</li>
<li><a href="https://hirrolot.github.io/posts/macros-on-steroids-or-how-can-pure-c-benefit-from-metaprogramming.html" rel="nofollow"><em>Macros on Steroids, Or: How Can Pure C Benefit From Metaprogramming</em></a> by Hirrolot.</li>
<li><a href="https://hirrolot.github.io/posts/extend-your-language-dont-alter-it.html" rel="nofollow"><em>Extend Your Language, Don’t Alter It</em></a> by Hirrolot.</li>
<li><a href="https://hirrolot.github.io/posts/compiling-algebraic-data-types-in-pure-c99.html" rel="nofollow"><em>Compiling Algebraic Data Types in Pure C99</em></a> by Hirrolot.</li>
<li><a href="https://www.reddit.com/r/ProgrammingLanguages/comments/nc1o18/comparing_algebraic_data_types_rust_and_datatype99/" rel="nofollow"><em>Comparing Rust and Datatype99</em></a> by Hirrolot.</li>
<li><a href="https://hirrolot.github.io/posts/compile-time-introspection-of-sum-types-in-pure-c99.html" rel="nofollow"><em>Compile-Time Introspection of Sum Types in Pure C99</em></a> by Hirrolot.</li>
<li><a href="https://hirrolot.github.io/posts/unleashing-sum-types-in-pure-c99.html" rel="nofollow"><em>Unleashing Sum Types in Pure C99</em></a> by Hirrolot.</li>
</ul>

<ol dir="auto">
<li>Update <code>DATATYPE99_MAJOR</code>, <code>DATATYPE99_MINOR</code>, and <code>DATATYPE99_PATCH</code> in <code>datatype99.h</code>.</li>
<li>Update <code>CHANGELOG.md</code>.</li>
<li>Release the project in <a href="https://github.com/Hirrolot/datatype99/releases">GitHub Releases</a>.</li>
</ol>

<div dir="auto"><h3 tabindex="-1" dir="auto">Q: Why use C instead of Rust/Zig/whatever else?</h3><a id="user-content-q-why-use-c-instead-of-rustzigwhatever-else" aria-label="Permalink: Q: Why use C instead of Rust/Zig/whatever else?" href="#q-why-use-c-instead-of-rustzigwhatever-else"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">A: There is a lot of software written in plain C that can benefit from Datatype99; C is #1 programming language as of 2020, <a href="https://jaxenter.com/c-programming-may-2020-171598.html" rel="nofollow">according to TIOBE</a>. People use C due to technical and social reasons:</p>
<ul dir="auto">
<li>
<p dir="auto">Datatype99 can be seamlessly integrated into existing codebases written in pure C -- just <code>#include &lt;datatype99.h&gt;</code> and you are ready to go. On the other hand, other languages force you to separate native C files from their sources, which is clearly less convenient.</p>
</li>
<li>
<p dir="auto">In some environments, developers strick to pure C for historical reasons (e.g., embedded devices, Linux and other operating systems).</p>
</li>
<li>
<p dir="auto">C has a stable ABI which is vital for some projects (e.g., plugin systems such as <a href="https://github.com/metacall/core">MetaCall</a>).</p>
</li>
<li>
<p dir="auto">C is a mature language with a complete specification and a plenitude of libraries. Rust has no complete specification, and <a href="https://ziglang.org/" rel="nofollow">Zig</a> is not yet production-ready. I know a few stories when these two languages were rejected for new projects, and I can understand this decision.</p>
</li>
<li>
<p dir="auto">Historically, C has been targeting nearly all platforms. This is not the case with Rust, which depends on LLVM as for now.</p>
</li>
<li>
<p dir="auto">Your company obligates you to use C.</p>
</li>
<li>
<p dir="auto">Etc.</p>
</li>
</ul>
<p dir="auto">See also:</p>
<ul dir="auto">
<li><a href="https://drewdevault.com/2019/03/25/Rust-is-not-a-good-C-replacement.html" rel="nofollow"><em>&#34;Rust is not a good C replacement&#34;</em></a> by Drew DeVault.</li>
</ul>
<p dir="auto">Overall, if you can afford a more modern/high-level language, I encourage you to do so instead of using old C. However, many people do not have this possibility (or it would be too costly).</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Q: Why not third-party code generators?</h3><a id="user-content-q-why-not-third-party-code-generators" aria-label="Permalink: Q: Why not third-party code generators?" href="#q-why-not-third-party-code-generators"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">A: See <a href="https://github.com/Hirrolot/metalang99#q-why-not-third-party-code-generators">Metalang99&#39;s README &gt;&gt;</a>.</p>

<p dir="auto">A: In short, <code>datatype</code> expands to a tagged union with value constructors; <code>match</code> expands to a switch statement. To generate all this stuff, <a href="https://github.com/Hirrolot/metalang99">Metalang99</a> is used, a preprocessor metaprogramming library.</p>
<p dir="auto">More on it in <a href="https://hirrolot.github.io/posts/compiling-algebraic-data-types-in-pure-c99.html" rel="nofollow"><em>&#34;Compiling Algebraic Data Types in Pure C99&#34;</em></a>.</p>

<p dir="auto">A: Yes, C++11 and onwards is supported.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Q: What is the difference between Datatype99 and Metalang99?</h3><a id="user-content-q-what-is-the-difference-between-datatype99-and-metalang99" aria-label="Permalink: Q: What is the difference between Datatype99 and Metalang99?" href="#q-what-is-the-difference-between-datatype99-and-metalang99"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">A: <a href="https://github.com/Hirrolot/metalang99">Metalang99</a> is a functional language for metaprogramming, whereas Datatype99 is an implementation of algebraic data types written in this language.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Q: What about compile-time errors?</h3><a id="user-content-q-what-about-compile-time-errors" aria-label="Permalink: Q: What about compile-time errors?" href="#q-what-about-compile-time-errors"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">A: Some kinds of syntactic errors are detected by the library itself:</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Error: <code>Bar(int)</code> instead of <code>(Bar, int)</code></h4><a id="user-content-error-barint-instead-of-bar-int" aria-label="Permalink: Error: Bar(int) instead of (Bar, int)" href="#error-barint-instead-of-bar-int"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">[<code>playground.c</code>]</p>
<div dir="auto" data-snippet-clipboard-copy-content="datatype(A, (Foo, int), Bar(int));"><pre><span>datatype</span>(<span>A</span>, (<span>Foo</span>, <span>int</span>), <span>Bar</span>(<span>int</span>));</pre></div>
<p dir="auto">[<code>/bin/sh</code>]</p>
<div data-snippet-clipboard-copy-content="$ gcc playground.c -Imetalang99/include -Idatatype99 -ftrack-macro-expansion=0
playground.c:3:1: error: static assertion failed: &#34;ML99_assertIsTuple: Bar(int) must be (x1, ..., xN)&#34;
    3 | datatype(A, (Foo, int), Bar(int));
      | ^~~~~~~~"><pre><code>$ gcc playground.c -Imetalang99/include -Idatatype99 -ftrack-macro-expansion=0
playground.c:3:1: error: static assertion failed: &#34;ML99_assertIsTuple: Bar(int) must be (x1, ..., xN)&#34;
    3 | datatype(A, (Foo, int), Bar(int));
      | ^~~~~~~~
</code></pre></div>
<hr/>

<p dir="auto">[<code>playground.c</code>]</p>
<div dir="auto" data-snippet-clipboard-copy-content="datatype(A, (Foo, int) (Bar, int));"><pre><span>datatype</span>(<span>A</span>, (<span>Foo</span>, <span>int</span>) (<span>Bar</span>, <span>int</span>));</pre></div>
<p dir="auto">[<code>/bin/sh</code>]</p>
<div data-snippet-clipboard-copy-content="$ gcc playground.c -Imetalang99/include -Idatatype99 -ftrack-macro-expansion=0
playground.c:3:1: error: static assertion failed: &#34;ML99_assertIsTuple: (Foo, int) (Bar, int) must be (x1, ..., xN), did you miss a comma?&#34;
    3 | datatype(A, (Foo, int) (Bar, int));
      | ^~~~~~~~"><pre><code>$ gcc playground.c -Imetalang99/include -Idatatype99 -ftrack-macro-expansion=0
playground.c:3:1: error: static assertion failed: &#34;ML99_assertIsTuple: (Foo, int) (Bar, int) must be (x1, ..., xN), did you miss a comma?&#34;
    3 | datatype(A, (Foo, int) (Bar, int));
      | ^~~~~~~~
</code></pre></div>
<hr/>
<div dir="auto"><h4 tabindex="-1" dir="auto">Error: Trailing comma is prohibited</h4><a id="user-content-error-trailing-comma-is-prohibited" aria-label="Permalink: Error: Trailing comma is prohibited" href="#error-trailing-comma-is-prohibited"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">[<code>playground.c</code>]</p>
<div dir="auto" data-snippet-clipboard-copy-content="datatype(A, (Foo, int), (Bar, int), /* trailing comma is prohibited */);"><pre><span>datatype</span>(<span>A</span>, (<span>Foo</span>, <span>int</span>), (<span>Bar</span>, <span>int</span>), <span>/* trailing comma is prohibited */</span><span></span>);</pre></div>
<p dir="auto">[<code>/bin/sh</code>]</p>
<div data-snippet-clipboard-copy-content="$ gcc playground.c -Imetalang99/include -Idatatype99 -ftrack-macro-expansion=0
playground.c:3:1: error: static assertion failed: &#34;ML99_assertIsTuple: must be (x1, ..., xN)&#34;
    3 | datatype(A, (Foo, int), (Bar, int), /* trailing comma is prohibited */);
      | ^~~~~~~~"><pre><code>$ gcc playground.c -Imetalang99/include -Idatatype99 -ftrack-macro-expansion=0
playground.c:3:1: error: static assertion failed: &#34;ML99_assertIsTuple: must be (x1, ..., xN)&#34;
    3 | datatype(A, (Foo, int), (Bar, int), /* trailing comma is prohibited */);
      | ^~~~~~~~
</code></pre></div>
<p dir="auto">(For better diagnostics, use the latest Metalang99.)</p>
<p dir="auto">The others are understandable as well:</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Error: unknown type name specified in <code>datatype</code></h4><a id="user-content-error-unknown-type-name-specified-in-datatype" aria-label="Permalink: Error: unknown type name specified in datatype" href="#error-unknown-type-name-specified-in-datatype"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">[<code>playground.c</code>]</p>
<div dir="auto" data-snippet-clipboard-copy-content="datatype(Foo, (FooA, NonExistingType));"><pre><span>datatype</span>(<span>Foo</span>, (<span>FooA</span>, <span>NonExistingType</span>));</pre></div>
<p dir="auto">[<code>/bin/sh</code>]</p>
<div data-snippet-clipboard-copy-content="playground.c:3:1: error: unknown type name ‘NonExistingType’
    3 | datatype(
      | ^~~~~~~~
playground.c:3:1: error: unknown type name ‘NonExistingType’
playground.c:3:1: error: unknown type name ‘NonExistingType’"><pre><code>playground.c:3:1: error: unknown type name ‘NonExistingType’
    3 | datatype(
      | ^~~~~~~~
playground.c:3:1: error: unknown type name ‘NonExistingType’
playground.c:3:1: error: unknown type name ‘NonExistingType’
</code></pre></div>
<hr/>
<div dir="auto"><h4 tabindex="-1" dir="auto">Error: non-exhaustive <code>match</code></h4><a id="user-content-error-non-exhaustive-match" aria-label="Permalink: Error: non-exhaustive match" href="#error-non-exhaustive-match"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">[<code>playground.c</code>]</p>
<div dir="auto" data-snippet-clipboard-copy-content="match(*tree) {
    of(Leaf, x) return *x;
    // of(Node, lhs, x, rhs) return sum(*lhs) + *x + sum(*rhs);
}"><pre><span>match</span>(<span>*</span><span>tree</span>) {
    <span>of</span>(<span>Leaf</span>, <span>x</span>) <span>return</span> <span>*</span><span>x</span>;
    <span>// of(Node, lhs, x, rhs) return sum(*lhs) + *x + sum(*rhs);</span>
}</pre></div>
<p dir="auto">[<code>/bin/sh</code>]</p>
<div data-snippet-clipboard-copy-content="playground.c: In function ‘sum’:
playground.c:6:5: warning: enumeration value ‘NodeTag’ not handled in switch [-Wswitch]
    6 |     match(*tree) {
      |     ^~~~~"><pre><code>playground.c: In function ‘sum’:
playground.c:6:5: warning: enumeration value ‘NodeTag’ not handled in switch [-Wswitch]
    6 |     match(*tree) {
      |     ^~~~~
</code></pre></div>
<hr/>
<div dir="auto"><h4 tabindex="-1" dir="auto">Error: excess binders in <code>of</code></h4><a id="user-content-error-excess-binders-in-of" aria-label="Permalink: Error: excess binders in of" href="#error-excess-binders-in-of"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">[<code>playground.c</code>]</p>
<div dir="auto" data-snippet-clipboard-copy-content="match(*tree) {
    of(Leaf, x, excess) return *x;
    of(Node, lhs, x, rhs) return sum(*lhs) + *x + sum(*rhs);
}"><pre><span>match</span>(<span>*</span><span>tree</span>) {
    <span>of</span>(<span>Leaf</span>, <span>x</span>, <span>excess</span>) <span>return</span> <span>*</span><span>x</span>;
    <span>of</span>(<span>Node</span>, <span>lhs</span>, <span>x</span>, <span>rhs</span>) <span>return</span> <span>sum</span>(<span>*</span><span>lhs</span>) <span>+</span> <span>*</span><span>x</span> <span>+</span> <span>sum</span>(<span>*</span><span>rhs</span>);
}</pre></div>
<p dir="auto">[<code>/bin/sh</code>]</p>
<div data-snippet-clipboard-copy-content="playground.c: In function ‘sum’:
playground.c:15:9: error: unknown type name ‘Leaf_1’; did you mean ‘Leaf_0’?
   15 |         of(Leaf, x, excess) return *x;
      |         ^~
      |         Leaf_0
playground.c:15:9: error: ‘BinaryTreeLeaf’ has no member named ‘_1’; did you mean ‘_0’?
   15 |         of(Leaf, x, excess) return *x;
      |         ^~
      |         _0"><pre><code>playground.c: In function ‘sum’:
playground.c:15:9: error: unknown type name ‘Leaf_1’; did you mean ‘Leaf_0’?
   15 |         of(Leaf, x, excess) return *x;
      |         ^~
      |         Leaf_0
playground.c:15:9: error: ‘BinaryTreeLeaf’ has no member named ‘_1’; did you mean ‘_0’?
   15 |         of(Leaf, x, excess) return *x;
      |         ^~
      |         _0
</code></pre></div>
<hr/>
<div dir="auto"><h4 tabindex="-1" dir="auto">Error: improperly typed variant arguments</h4><a id="user-content-error-improperly-typed-variant-arguments" aria-label="Permalink: Error: improperly typed variant arguments" href="#error-improperly-typed-variant-arguments"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">[<code>playground.c</code>]</p>
<div dir="auto" data-snippet-clipboard-copy-content="BinaryTree tree = Leaf(&#34;hello world&#34;);"><pre><span>BinaryTree</span> <span>tree</span> <span>=</span> <span>Leaf</span>(<span>&#34;hello world&#34;</span>);</pre></div>
<p dir="auto">[<code>/bin/sh</code>]</p>
<div data-snippet-clipboard-copy-content="playground.c: In function ‘main’:
playground.c:18:28: warning: passing argument 1 of ‘Leaf’ makes integer from pointer without a cast [-Wint-conversion]
   18 |     BinaryTree tree = Leaf(&#34;hello world&#34;);
      |                            ^~~~~~~~~~~~~
      |                            |
      |                            char *
playground.c:6:1: note: expected ‘int’ but argument is of type ‘char *’
    6 | datatype(
      | ^~~~~~~~"><pre><code>playground.c: In function ‘main’:
playground.c:18:28: warning: passing argument 1 of ‘Leaf’ makes integer from pointer without a cast [-Wint-conversion]
   18 |     BinaryTree tree = Leaf(&#34;hello world&#34;);
      |                            ^~~~~~~~~~~~~
      |                            |
      |                            char *
playground.c:6:1: note: expected ‘int’ but argument is of type ‘char *’
    6 | datatype(
      | ^~~~~~~~
</code></pre></div>
<hr/>
<div dir="auto"><h4 tabindex="-1" dir="auto">Error: an undereferenced binder</h4><a id="user-content-error-an-undereferenced-binder" aria-label="Permalink: Error: an undereferenced binder" href="#error-an-undereferenced-binder"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">[<code>playground.c</code>]</p>
<div dir="auto" data-snippet-clipboard-copy-content="int sum(const BinaryTree *tree) {
    match(*tree) {
        of(Leaf, x) return x; // x is int *
        of(Node, lhs, x, rhs) return sum(*lhs) + *x + sum(*rhs);
    }
}"><pre><span>int</span> <span>sum</span>(<span>const</span> <span>BinaryTree</span> <span>*</span><span>tree</span>) {
    <span>match</span>(<span>*</span><span>tree</span>) {
        <span>of</span>(<span>Leaf</span>, <span>x</span>) <span>return</span> <span>x</span>; <span>// x is int *</span>
        <span>of</span>(<span>Node</span>, <span>lhs</span>, <span>x</span>, <span>rhs</span>) <span>return</span> <span>sum</span>(<span>*</span><span>lhs</span>) <span>+</span> <span>*</span><span>x</span> <span>+</span> <span>sum</span>(<span>*</span><span>rhs</span>);
    }
}</pre></div>
<p dir="auto">[<code>/bin/sh</code>]</p>
<div data-snippet-clipboard-copy-content="playground.c: In function ‘sum’:
playground.c:17:28: warning: returning ‘Leaf_0 *’ {aka ‘int *’} from a function with return type ‘int’ makes integer from pointer without a cast [-Wint-conversion]
   17 |         of(Leaf, x) return x; // x is int *
      |                            ^"><pre><code>playground.c: In function ‘sum’:
playground.c:17:28: warning: returning ‘Leaf_0 *’ {aka ‘int *’} from a function with return type ‘int’ makes integer from pointer without a cast [-Wint-conversion]
   17 |         of(Leaf, x) return x; // x is int *
      |                            ^
</code></pre></div>
<hr/>
<p dir="auto">From my experience, nearly 95% of errors make sense.</p>
<p dir="auto">If an error is not comprehensible at all, try to look at generated code (<code>-E</code>). Hopefully, the <a href="#semantics">code generation semantics</a> is formally defined so normally you will not see something unexpected.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Q: What about IDE support?</h3><a id="user-content-q-what-about-ide-support" aria-label="Permalink: Q: What about IDE support?" href="#q-what-about-ide-support"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Hirrolot/datatype99/blob/master/images/suggestion.png"><img src="https://github.com/Hirrolot/datatype99/raw/master/images/suggestion.png" width="600px"/></a></p>
<p dir="auto">A: VS Code automatically enables suggestions of generated types but, of course, it does not support macro syntax highlighting.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Q: Which compilers are tested?</h3><a id="user-content-q-which-compilers-are-tested" aria-label="Permalink: Q: Which compilers are tested?" href="#q-which-compilers-are-tested"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">A: Datatype99 is known to work on these compilers:</p>
<ul dir="auto">
<li>GCC</li>
<li>Clang</li>
<li>MSVC</li>
<li>TCC</li>
</ul>

<div dir="auto"><h3 tabindex="-1" dir="auto"><code>warning: control reaches end of non-void function [-Wreturn-type]</code></h3><a id="user-content-warning-control-reaches-end-of-non-void-function--wreturn-type" aria-label="Permalink: warning: control reaches end of non-void function [-Wreturn-type]" href="#warning-control-reaches-end-of-non-void-function--wreturn-type"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This warning happens when you try to return control from within a <code>match</code> statement, and your compiler thinks that not all hypothetical variants are handled. For example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="datatype(MyType, (Foo), (Bar));

int handle(MyType val) {
    match(val) {
        of(Foo) return 5;
        of(Bar) return 7;
    }
}"><pre><span>datatype</span>(<span>MyType</span>, (<span>Foo</span>), (<span>Bar</span>));

<span>int</span> <span>handle</span>(<span>MyType</span> <span>val</span>) {
    <span>match</span>(<span>val</span>) {
        <span>of</span>(<span>Foo</span>) <span>return</span> <span>5</span>;
        <span>of</span>(<span>Bar</span>) <span>return</span> <span>7</span>;
    }
}</pre></div>
<p dir="auto">The above code may seem perfect at first glance, but in fact, it is not. The reason is this: <code>match(val)</code> boils down to <code>switch(val.tag)</code> under the hood, with <code>val.tag</code> being an ordinary C enumeration consisting of the variants <code>Foo</code> and <code>Bar</code>. But what if a caller provides us with neither <code>Foo</code> nor <code>Bar</code>, but with something like <code>42</code> (not a valid variant)? Since <code>enum</code> is merely another way to give integers names, a compiler would not complain on the <em>caller</em> site. However, on the <em>callee</em> site, we would have the warning:</p>
<div data-snippet-clipboard-copy-content="test.c: In function ‘handle’:
test.c:10:1: warning: control reaches end of non-void function [-Wreturn-type]
   10 | }
      | ^"><pre><code>test.c: In function ‘handle’:
test.c:10:1: warning: control reaches end of non-void function [-Wreturn-type]
   10 | }
      | ^
</code></pre></div>
<p dir="auto">The solution is to either panic or return some error-signaling code, like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="int handle(MyType val) {
    match(val) {
        of(Foo) return 5;
        of(Bar) return 7;
    }

    // Invalid input (no such variant).
    return -1;
}"><pre><span>int</span> <span>handle</span>(<span>MyType</span> <span>val</span>) {
    <span>match</span>(<span>val</span>) {
        <span>of</span>(<span>Foo</span>) <span>return</span> <span>5</span>;
        <span>of</span>(<span>Bar</span>) <span>return</span> <span>7</span>;
    }

    <span>// Invalid input (no such variant).</span>
    <span>return</span> <span>-1</span>;
}</pre></div>
<p dir="auto">See <a href="https://github.com/Hirrolot/datatype99/issues/9" data-hovercard-type="issue" data-hovercard-url="/Hirrolot/datatype99/issues/9/hovercard">issue #9</a>.</p>
</article></div></div>
  </body>
</html>
