<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.demofox.org/2017/11/26/dissecting-tiny-clouds/">Original</a>
    <h1>Dissecting &#34;Tiny Clouds&#34; shadertoy (2017)</h1>
    
    <div id="readability-page-1" class="page"><div>
				<p>There is an amazing shadertoy called ‚ÄúTiny Clouds‚Äù by stubbe (twitter: <a target="_blank" href="https://twitter.com/Stubbesaurus">@Stubbesaurus</a>) which flies you through nearly photorealistic clouds in only 10 lines of code / 280 characters (2 old sized tweets or 1 new larger sized tweet).</p>
<p>The code is a bit dense, so I wanted to take some time to understand it and share the explanation for anyone else who was interested.  Rune (the author) kindly answered a couple questions for me as well. Thanks Rune!</p>
<p>Link: <a target="_blank" href="https://www.shadertoy.com/view/lsBfDz">[SH17A] Tiny Clouds</a>  (Check out this link, it looks even more amazing in motion)</p>
<p><img src="https://blog.demofox.org/wp-content/uploads/2017/11/tinyclouds.png?w=800"/></p>
<p>Here is the code in full. The texture in iChannel0 is just a white noise texture that is bilinearly sampled.</p>
<pre title="">#define T texture(iChannel0,(s*p.zw+ceil(s*p.x))/2e2).y/(s+=s)*4.
void mainImage(out vec4 O,vec2 x){
    vec4 p,d=vec4(.8,0,x/iResolution.y-.8),c=vec4(.6,.7,d);
    O=c-d.w;
    for(float f,s,t=2e2+sin(dot(x,x));--t&gt;0.;p=.05*t*d)
        p.xz+=iTime,
        s=2.,
        f=p.w+1.-T-T-T-T,
    	f&lt;0.?O+=(O-1.-f*c.zyxw)*f*.4:O;
}
</pre>
<p>BTW this shadertoy is a shrunken &amp; reinterpreted version of a larger, more feature rich shadertoy by iq: <a target="_blank" href="https://www.shadertoy.com/view/XslGRr">Clouds</a></p>
<p>Before diving into the details of the code, here is how it works in short:</p>
<ul>
<li>Every pixel does a ray march from far to near. It does it backwards to make for simpler alpha blending math.</li>
<li>At every ray step, it samples FBM data (fractal brownian motion) to figure out if the current position is below the surface of the cloud or above it.</li>
<li>If below, it alpha blends the pixel color with the cloud color at that point, using the vertical distance into the cloud as the cloud density.</li>
</ul>
<p>Pretty reasonable and simple ‚Äì and it would have to be, to look so good in so few characters!  Let‚Äôs dig into the code.</p>
<pre title="">#define T texture(iChannel0,(s*p.zw+ceil(s*p.x))/2e2).y/(s+=s)*4.
void mainImage(out vec4 O,vec2 x){
    vec4 p,d=vec4(.8,0,x/iResolution.y-.8),c=vec4(.6,.7,d);
    O=c-d.w;
    for(float f,s,t=2e2+sin(dot(x,x));--t&gt;0.;p=.05*t*d)
        p.xz+=iTime,
        s=2.,
        f=p.w+1.-T-T-T-T,
    	f&lt;0.?O+=(O-1.-f*c.zyxw)*f*.4:O;
}
</pre>
<p>Line 1 is a define that we‚Äôll come back to and line 2 is just a minimal definition of the mainImage function.</p>
<pre title="">#define T texture(iChannel0,(s*p.zw+ceil(s*p.x))/2e2).y/(s+=s)*4.
void mainImage(out vec4 O,vec2 x){
    vec4 p,d=vec4(.8,0,x/iResolution.y-.8),c=vec4(.6,.7,d);
    O=c-d.w;
    for(float f,s,t=2e2+sin(dot(x,x));--t&gt;0.;p=.05*t*d)
        p.xz+=iTime,
        s=2.,
        f=p.w+1.-T-T-T-T,
    	f&lt;0.?O+=(O-1.-f*c.zyxw)*f*.4:O;
}
</pre>
<p>On line 3 several variables are declared:</p>
<ul>
<li><strong>p</strong> ‚Äì this is the variable that holds the position of the ray during the ray march.  It isn‚Äôt initialized here, but that‚Äôs ok because the position is calculated each step in the loop.  It is interesting to see that the y component of p is never used.  p.x is actually depth into the screen, p.z is the screen x axis, and p.w is the screen y axis (aka the up axis).  I believe that the axis choices and the fact that the y component is never used is purely to make the code smaller.</li>
<li><strong>d</strong> ‚Äì this is the direction that the ray for this pixel travels in. It uses the same axis conventions as p, and the y component is also never used (except implicitly for calculating p.y, which is never used). 0.8 is subtracted from d.z and d.w (the screen x and screen y axes).  Interestingly that makes the screen x axis 0 nearly centered on the screen.  It also points the screen y axis downward a bit, putting the 0 value near the top of the screen to make the camera look more downward at the clouds.</li>
<li><strong>c</strong> ‚Äì this is the color of the sky, which is a nice sky blue. It‚Äôs initialized with constants in x and y, and then d is used for z and w.  d.xy goes into c.zw.  That gives c the 0.8 value in the z field. I‚Äôm sure it was done this way because it‚Äôs fewer characters to initialize using ‚Äúd‚Äù compared to ‚Äú.8,0.‚Äù for the same effect.  Note that c.w is used to calculate O.w (O.a) but that the alpha channel of the output pixel value is currently ignored by shadertoy, so this is a meaningless by product of the code, not a desired feature.</li>
</ul>
<pre title="">#define T texture(iChannel0,(s*p.zw+ceil(s*p.x))/2e2).y/(s+=s)*4.
void mainImage(out vec4 O,vec2 x){
    vec4 p,d=vec4(.8,0,x/iResolution.y-.8),c=vec4(.6,.7,d);
    O=c-d.w;
    for(float f,s,t=2e2+sin(dot(x,x));--t&gt;0.;p=.05*t*d)
        p.xz+=iTime,
        s=2.,
        f=p.w+1.-T-T-T-T,
    	f&lt;0.?O+=(O-1.-f*c.zyxw)*f*.4:O;
}
</pre>
<p>Line 4 initializes the output pixel color to be the sky color (c), but then subtracts d.w which is the pixel‚Äôs ray march direction on the screen y axis.  This has a nice effect of making a nice sky blue gradient.</p>
<p>To see this in action, here we set O to c:</p>
<p>Here we set O to c-d.w:</p>
<p>It gets darker blue towards the top ‚Äì where d.w is positive ‚Äì because a positive number is being subtracted from the sky color.  The color values get smaller.</p>
<p>It gets lighter towards the bottom ‚Äì where d.w is negative ‚Äì because a negative number is being subtracted from the sky color.  The color values get larger.</p>
<pre title="">#define T texture(iChannel0,(s*p.zw+ceil(s*p.x))/2e2).y/(s+=s)*4.
void mainImage(out vec4 O,vec2 x){
    vec4 p,d=vec4(.8,0,x/iResolution.y-.8),c=vec4(.6,.7,d);
    O=c-d.w;
    for(float f,s,t=2e2+sin(dot(x,x));--t&gt;0.;p=.05*t*d)
        p.xz+=iTime,
        s=2.,
        f=p.w+1.-T-T-T-T,
    	f&lt;0.?O+=(O-1.-f*c.zyxw)*f*.4:O;
}
</pre>
<p>On line 5, the for loop for ray marching starts. A few things happen here:</p>
<ul>
<li><strong>f is declared</strong> ‚Äì f is the signed vertical distance from the current point in space to the cloud.  If negative, it means that the point is inside the cloud.  If positive, it means that the point is outside (above) the cloud.  It isn‚Äôt initialized here, but it‚Äôs calculated each iteration of the loop so that‚Äôs fine.</li>
<li><strong>s is declared</strong> ‚Äì s is a scale value for use with the FBM data. FBMs work by sampling multiple octaves of data.  You scale up the position and scale down the value for each octave. s is that scale value, used for both purposes.  This isn‚Äôt initialized but is calculated each frame so that‚Äôs fine.</li>
<li><strong>t is declared and initialized</strong> ‚Äì t (aka ray march step index) is initialized to 2e2 aka 200. It was done this way because ‚Äú2e2‚Äù is smaller than ‚Äú200.‚Äù by one character. Note that the for loop takes t from 200 to 0. The ray marching happens back to front to simplify alpha blending.  The sin(dot(x,x)) part I want to talk about briefly below.</li>
<li><strong>p is calculated</strong> ‚Äì p (aka the position in the current step of the ray march) is calculated, and this happens every step of the loop.  p is t (time) multiplied by the direction of the ray for this pixel, and multiplied by .05 to scale it down.</li>
</ul>
<p>The reason that sin(dot(x,x)) is added to the ‚Äúray time‚Äù is because the ray is marching through voxelized data (boxes).  Unlike boxes, clouds are supposed to look organic, and not geometric.  A way to fight the problem of the data looking boxy is to add a little noise to each ray to break up the geometric pattern.  You can either literally add some noise to the result, or do what this shader does, which is add some noise to the starting position of the ray so that neighboring rays will cross the box (voxel) boundaries at different times and will look noisy instead of geometric.</p>
<p>I can‚Äôt see a difference when removing this from the shader, and other people have said the same.  Rune says in the comments that it‚Äôd be on the chopping block for sure if he needed to shave off some more characters.  He reached his 280 character goal, so no there is no need to remove it.</p>
<p>For what it‚Äôs worth, here is that expression visualized in the blue channel. the -1 to +1 is mapped to 0 to 1 by multiplying it by a half and adding a half:</p>
<p><img src="https://blog.demofox.org/wp-content/uploads/2017/11/sindot.png?w=800"/></p>
<pre title="">#define T texture(iChannel0,(s*p.zw+ceil(s*p.x))/2e2).y/(s+=s)*4.
void mainImage(out vec4 O,vec2 x){
    vec4 p,d=vec4(.8,0,x/iResolution.y-.8),c=vec4(.6,.7,d);
    O=c-d.w;
    for(float f,s,t=2e2+sin(dot(x,x));--t&gt;0.;p=.05*t*d)
        p.xz+=iTime,
        s=2.,
        f=p.w+1.-T-T-T-T,
    	f&lt;0.?O+=(O-1.-f*c.zyxw)*f*.4:O;
}
</pre>
<p>Line 6 adds the current time to p.x and p.z.  Remember that the x component is the axis pointing into the screen and the z component is the screen space x axis, so this line of code moves the camera forward and to the right over time.</p>
<p>If you are wondering why the lines in the for loop end in a comma instead of a semicolon, the reason is because if a semicolon was used instead, the for loop would require two more characters: ‚Äú{‚Äù and ‚Äú}‚Äù to show where the scope of the loop started and ended.  Ending the lines with commas mean it‚Äôs one long statement, so the single line version of a for loop can be used. An interesting trick üòõ</p>
<pre title="">#define T texture(iChannel0,(s*p.zw+ceil(s*p.x))/2e2).y/(s+=s)*4.
void mainImage(out vec4 O,vec2 x){
    vec4 p,d=vec4(.8,0,x/iResolution.y-.8),c=vec4(.6,.7,d);
    O=c-d.w;
    for(float f,s,t=2e2+sin(dot(x,x));--t&gt;0.;p=.05*t*d)
        p.xz+=iTime,
        s=2.,
        f=p.w+1.-T-T-T-T,
    	f&lt;0.?O+=(O-1.-f*c.zyxw)*f*.4:O;
}
</pre>
<p>Line 7 sets / initializes s to 2.  Remember that s is used as the octave scale for sample position and resulting value.  That will come into play in the next line.</p>
<pre title="">#define T texture(iChannel0,(s*p.zw+ceil(s*p.x))/2e2).y/(s+=s)*4.
void mainImage(out vec4 O,vec2 x){
    vec4 p,d=vec4(.8,0,x/iResolution.y-.8),c=vec4(.6,.7,d);
    O=c-d.w;
    for(float f,s,t=2e2+sin(dot(x,x));--t&gt;0.;p=.05*t*d)
        p.xz+=iTime,
        s=2.,
        f=p.w+1.-T-T-T-T,
    	f&lt;0.?O+=(O-1.-f*c.zyxw)*f*.4:O;
}
</pre>
<p>First let‚Äôs look at line 1, which is the ‚ÄúT‚Äù macro.</p>
<p>That macro samples the texture (which is just white noise) at a position described by the current ray position in the ray march.  the s variable is used to scale up the position, and it‚Äôs also used to scale down the noise value at that position.  The same position involves p.zw which is the screen space x and y axis respectively, but also includes p.x which is the axis pointing into the screen.  This maps a 3d coordinate to a 2d texture location.  I have tried making the shader sample a 3d white noise texture instead of doing this and get what looks to be the same quality results.</p>
<p>The macro also multiplies s by 2 each sample, so that the next sample will sample the next octave.</p>
<p>An interesting part of this texture coordinate conversion from 3d to 2d though is that the x component is ceil‚Äôd(the axis that goes into the screen).  I‚Äôm not sure if there is any logic to this other than it‚Äôs a way to transform the 3d coordinates into a 2d one for the texture lookup. </p>
<p>Below is what it looks like without the ceil in the macro for s*p.x. It stretches the noise in a weird way.</p>
<p><img src="https://blog.demofox.org/wp-content/uploads/2017/11/cloudswhispy.png?w=800"/></p>
<p>The uv coordinates sampled are divided by 2e2 (which is 200, but again, fewer characters than ‚Äú200.‚Äù). I believe this value of 200 matches the number of ray march steps intentionally, so that the ray marches across the entire texture (with wrap around) each time.</p>
<p>Line 8 uses this macro.  We set f to be p.w, which is the ray‚Äôs height. 1 is added to the height which moves the camera up one unit.  Lastly, the T macro is used to subtract 4 octaves of noise from f.</p>
<p>The result of this is that f gives us a signed distance to the cloud on the vertical axis.  In other words, f tells us how far above or below the surface of the clouds we are.  A positive value means the position is above the clouds, and a negative value means the position is below the clouds.</p>
<pre title="">#define T texture(iChannel0,(s*p.zw+ceil(s*p.x))/2e2).y/(s+=s)*4.
void mainImage(out vec4 O,vec2 x){
    vec4 p,d=vec4(.8,0,x/iResolution.y-.8),c=vec4(.6,.7,d);
    O=c-d.w;
    for(float f,s,t=2e2+sin(dot(x,x));--t&gt;0.;p=.05*t*d)
        p.xz+=iTime,
        s=2.,
        f=p.w+1.-T-T-T-T,
    	f&lt;0.?O+=(O-1.-f*c.zyxw)*f*.4:O;
}
</pre>
<p>Line 10 is the close of the function, so line 9 is the last meaningful line of code.</p>
<p>This line of code says:</p>
<ul>
<li>If f less than zero (‚ÄúIf the point is inside the cloud‚Äù)</li>
<li>Then add ‚Äúsome formula‚Äù to the pixel color (more info on that in a moment)</li>
<li>Else, ‚ÄúO‚Äù. This is a dummy statement with no side effects that is there to satisfy the ternary operator syntax with a minimal number of characters.</li>
</ul>
<p>I was looking at that formula for a while, trying to figure it out. I was thinking maybe it was something like a cheaper function fitting of some more complex light scattering / absorption function.</p>
<p>I asked Rune and he explained it. All it‚Äôs doing is doing an alpha blend (a lerp) from the current pixel color to the color of the cloud at this position.  If you do the lerp mathematically, expand the function and combine terms, you get the above.  Here‚Äôs his explanation from twitter (<a href="https://twitter.com/Atrix256/status/933930136579145729" target="_blank">link to twitter thread</a>):</p>
<p><em><strong>Alpha blending between accumulated color (O) and incoming cloud color (1+f*c.zyxw). Note density (f) is negative:</strong></em></p><p><em><strong>Remember the marching is from far to near which simplifies the calculations quite a bit. If the marching was reversed then you would also need to keep track of an accumulated density.<br/>
</strong></em></p>
<p>One obvious question then would be: why is ‚Äú1+f*c.zyxw‚Äù the cloud color of the current sample?</p>
<p>One thing that helps clear that up is that f is negative. if you make ‚Äúf‚Äù mean ‚Äúdensity‚Äù and flip it‚Äôs sign, the equation becomes: ‚Äú1-density*c.zyxw‚Äù</p>
<p>We can then realize that ‚Äú1‚Äù when interpreted as a vec4 is the color white, and that c is the sky color.  We can also throw out the w since we (and shadertoy) don‚Äôt care about the alpha channel.  We can also replace x,y,z with r,g,b.  That makes the equation become: ‚Äúwhite-density*skycolor.bgr‚Äù</p>
<p>In that equation, when density is 0, all we are left with is white.  As density increases, the color gets darker.</p>
<p>The colors are the reversed sky color, because the sky color is (0.6, 0.7, 0.8).  if we used the sky color instead of the reversed sky color, you can see that blue would drop away faster than green, which would drop away faster than red.  If you do that, the clouds turn a reddish color like you can see here:</p>
<p><img src="https://blog.demofox.org/wp-content/uploads/2017/11/cloundsred.png?w=800"/></p>
<p>I‚Äôm not an expert in atmospheric rendering (check links at the bottom for more info on that!), but it looks more natural and correct for it to do the reverse.  What we really want is for red to drop off the quickest, then green, then blue.  I believe a more correct thing to do would be to subtract sky color from 1.0 and use that color to multiply density by.  However, reversing the color channels works fine in this case, so no need to spend the extra characters!</p>
<p>Another obvious question might be: why is the amount of lerp ‚Äú-f*.4‚Äù?</p>
<p>It probably looks strange to see a negative value in a lerp amount, but remembering that f is negative when it‚Äôs inside a cloud means that it‚Äôs a positive value, multiplied by 0.4 to make it smaller.  It‚Äôs just scaling the density a bit.</p>
<h2>Other Notes</h2>
<p>Using bilinear interpolation of the texture makes a big difference.  If you switch the texture to using nearest neighbor point sampling you get something like this which looks very boxy.  It looks even more boxy when it‚Äôs in motion.</p>
<p><img src="https://blog.demofox.org/wp-content/uploads/2017/11/boxclouds.png?w=800"/></p>
<p>One thing I wanted to try when understanding this shader was to try to replace the white noise texture lookup with a white noise function.  It does indeed work as you can see below, but it got noticeably slower on my machine doing that.  I‚Äôm so used to things being texture bound that getting rid of texture reads is usually a win.  I didn‚Äôt stop to think that in this situation all that was happening was compute and no texture reads.  In a more fully featured renderer, you may indeed find yourself texture read bound, and moving it out of a texture read could help speed things up ‚Äì profile and see!  It‚Äôs worth noting that to get proper results you need to discretize your noise function into a grid and use bilinear interpolation between the values ‚Äì mimicing what the texture read does.  Check my unpacked version of the shader in the links section for more details!</p>
<p><img src="https://blog.demofox.org/wp-content/uploads/2017/11/cloudscompute.png?w=800"/></p>
<p>Something kind of fun is that you can replace the white noise texture with other textures.  The results seem to be pretty good usually! Below is where i made the shadertoy use the ‚ÄúAbstract1‚Äù image as a source.  The clouds got a lot more soft.</p>
<p><img src="https://blog.demofox.org/wp-content/uploads/2017/11/cloudssoft.png?w=800"/></p>
<p>Thanks for reading. Anything that I got wrong or missed, please let me and the other readers know!</p>
<h2>Links</h2>
<p>Here is my unpacked version of the shader, which includes the option to use a white noise function instead of a white noise texture: <a href="https://www.shadertoy.com/view/4tlBz8" target="_blank">Tiny Clouds: Unpacked &amp; No Tex</a></p>
<p>Here are two great links for more information on how to render atmospheric and volumetric effects:</p>
<p><a target="_blank" href="https://www.alanzucconi.com/2017/10/10/atmospheric-scattering-1/">Volumetric Atmospheric Scattering</a></p>
<p><a target="_blank" href="http://shaderbits.com/blog/creating-volumetric-ray-marcher">Creating a Volumetric Ray Marcher</a></p>
			</div></div>
  </body>
</html>
