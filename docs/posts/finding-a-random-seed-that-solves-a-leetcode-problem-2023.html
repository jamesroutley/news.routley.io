<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mcognetta.github.io/posts/leetcode-random-seed/">Original</a>
    <h1>Finding a random seed that solves a LeetCode problem (2023)</h1>
    
    <div id="readability-page-1" class="page"><div> <div> <p>A side hobby of mine is solving LeetCode questions in unintended ways – most often via convoluted one-liners. Such a style of self-imposed constraints make the questions more fun and forces me to think outside of the box for solutions, invoking the feeling of &#34;necessity is the mother of invention&#34;.</p> <p>A recent LeetCode daily challenge was as follows (slightly simplified for clarity):</p> <blockquote> <p>Given a list of <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span> unique bitstrings, each of length <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span>, generate a new length-<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span> bitstring that is not in the list.</p> </blockquote> <p>For example, given a list <code>[&#34;010&#34;, &#34;110&#34;, &#34;111&#34;]</code>, a possible solution could be <code>&#34;001&#34;</code>. The LeetCode problem has a large test suite (of 183 test cases), with <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">1 \le k \le 16</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>1</span><span></span><span>≤</span><span></span></span><span><span></span><span>k</span><span></span><span>≤</span><span></span></span><span><span></span><span>1</span><span>6</span></span></span></span>, and the exact problem statement can be found <a href="https://leetcode.com/problems/find-unique-binary-string/">here</a>.</p> <p>I solved this by finding a random seed such that <em>randomly generated bitstrings</em> solved all the test cases. Here&#39;s the code:</p> <pre><code><span>class</span> <span>Solution</span>:
    <span>def</span> <span>findDifferentBinaryString</span>(<span>self, nums: <span>List</span>[<span>str</span>]</span>) -&gt; <span>str</span>:
        random.seed((<span>69299878</span> + <span>sum</span>(<span>ord</span>(c)*(i*j+<span>111</span>) <span>for</span> (i, n) <span>in</span> <span>enumerate</span>(nums) <span>for</span> (j, c) <span>in</span> <span>enumerate</span>(n))) % <span>999999999</span>)
        <span>return</span> <span>&#39;&#39;</span>.join(random.choice(<span>&#39;01&#39;</span>) <span>for</span> _ <span>in</span> nums)</code></pre> <p>Feel free to try this solution yourself (it should work unless LeetCode has updated their test suite, please let me know if that is the case).</p> <p>Here&#39;s how I did it.</p> <h2 id="background"><a href="#background">Background</a></h2> <p>There are a number of ways to solve this problem, with the most elegant solution being derived from <a href="https://en.wikipedia.org/wiki/Cantor%27s_diagonal_argument">Cantor&#39;s diagonalization argument</a>. Roughly, for each bitstring, choose a unique index and use the opposite of that value for that index of the output string. In code, it would be implemented as:</p> <pre><code><span>def</span> <span>find_new_string_cantor</span>(<span>bitstrings</span>):
    <span>return</span> <span>&#39;&#39;</span>.join(<span>&#39;0&#39;</span> <span>if</span> n[i] == <span>&#39;1&#39;</span> <span>else</span> <span>&#39;1&#39;</span> <span>for</span> (i, n) <span>in</span> <span>enumerate</span>(bitstrings))</code></pre> <p>As for random generation, the first thing to note is how did I know this would even be remotely possible? Surely the odds of randomly getting each correct are so low that I would never be able to find a solution before getting banned by LeetCode for too many repeated submissions. Solving it this way is akin to flipping 183 (biased) coins and getting 183 heads (the chances of that being <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mfrac><mn>1</mn><mn>2</mn></mfrac><mn>183</mn></msup><mo>≈</mo><mn>8.16</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>56</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\frac{1}{2}^{183} \approx 8.16\times 10^{-56}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span></span><span><span><span><span><span><span></span><span><span><span>2</span></span></span></span><span><span></span><span></span></span><span><span></span><span><span><span>1</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span></span><span><span><span><span><span><span></span><span><span><span>1</span><span>8</span><span>3</span></span></span></span></span></span></span></span></span><span></span><span>≈</span><span></span></span><span><span></span><span>8</span><span>.</span><span>1</span><span>6</span><span></span><span>×</span><span></span></span><span><span></span><span>1</span><span><span>0</span><span><span><span><span><span><span></span><span><span><span>−</span><span>5</span><span>6</span></span></span></span></span></span></span></span></span></span></span></span> with a regular coin). Fortunately for us, the word <em>biased</em> is doing a lot of work in this sentence, and the actual odds for a realistic test set are much better.</p> <p>Suppose we have chosen some <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span>. There are <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>2</span><span><span><span><span><span><span></span><span><span>k</span></span></span></span></span></span></span></span></span></span></span> possible bitstrings of length <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span>, while our list of bitstrings only contains <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span> elements. That means, picking a length <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span> bitstring <em>at random</em> has only a <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>k</mi><msup><mn>2</mn><mi>k</mi></msup></mfrac></mrow><annotation encoding="application/x-tex">\frac{k}{2^k}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span></span><span><span><span><span><span><span></span><span><span><span><span>2</span><span><span><span><span><span><span></span><span><span>k</span></span></span></span></span></span></span></span></span></span></span><span><span></span><span></span></span><span><span></span><span><span><span>k</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span></span></span></span></span> chance of already being in the list. This number goes to zero very quickly, as evidenced in the following table:</p> <table><tbody><tr><th>k</th><th>2^k</th><th>k / 2^k</th><th>k</th><th>2^k</th><th>k / 2^k</th></tr><tr><td>1</td><td>2</td><td>0.5</td><td>9</td><td>512</td><td>0.01758</td></tr><tr><td>2</td><td>4</td><td>0.5</td><td>10</td><td>1024</td><td>0.00977</td></tr><tr><td>3</td><td>8</td><td>0.375</td><td>11</td><td>2048</td><td>0.00537</td></tr><tr><td>4</td><td>16</td><td>0.25</td><td>12</td><td>4096</td><td>0.00293</td></tr><tr><td>5</td><td>32</td><td>0.15625</td><td>13</td><td>8192</td><td>0.00159</td></tr><tr><td>6</td><td>64</td><td>0.09375</td><td>14</td><td>16384</td><td>0.00085</td></tr><tr><td>7</td><td>128</td><td>0.05469</td><td>15</td><td>32768</td><td>0.00045</td></tr><tr><td>8</td><td>256</td><td>0.03125</td><td>16</td><td>65536</td><td>0.00024</td></tr></tbody></table> <p>And, for each <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span>, there are <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><msup><mn>2</mn><mi>k</mi></msup><mi>k</mi></mfrac><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">{2^k \choose k}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span>(</span></span><span><span><span><span><span><span></span><span><span><span>k</span></span></span></span><span><span></span><span><span><span><span>2</span><span><span><span><span><span><span></span><span><span>k</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span>)</span></span></span></span></span></span></span> possible ways to select <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span> bitstrings. For large <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span>, this number grows very quickly, but for smaller <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span> it is a little more manageable. For example, for <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k = 2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span><span></span><span>=</span><span></span></span><span><span></span><span>2</span></span></span></span> there are just <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mn>4</mn><mn>2</mn></mfrac><mo fence="true">)</mo></mrow><mo>=</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">{4 \choose 2} = 6</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span>(</span></span><span><span><span><span><span><span></span><span><span><span>2</span></span></span></span><span><span></span><span><span><span>4</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span>)</span></span></span></span><span></span><span>=</span><span></span></span><span><span></span><span>6</span></span></span></span> possible inputs. Since the probability of randomly generating a valid answer for a <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k=2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span><span></span><span>=</span><span></span></span><span><span></span><span>2</span></span></span></span> input is <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span></span><span><span><span><span><span><span></span><span><span><span>2</span></span></span></span><span><span></span><span></span></span><span><span></span><span><span><span>1</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span></span></span></span></span>, randomly selecting a bitstring for each of the length <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>2</span></span></span></span> inputs would work <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><msup><mn>2</mn><mn>6</mn></msup></mfrac><mo>=</mo></mrow><annotation encoding="application/x-tex">\frac{1}{2^6} =</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span></span><span><span><span><span><span><span></span><span><span><span><span>2</span><span><span><span><span><span><span></span><span><span>6</span></span></span></span></span></span></span></span></span></span></span><span><span></span><span></span></span><span><span></span><span><span><span>1</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span></span><span></span><span>=</span></span></span></span> 1 out of 64 times. </p> <p>As <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span> gets larger, even including a large number of test cases doesn&#39;t significantly reduce the probability of randomly succeeding in all trials. Even given 100 examples of <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">k = 10</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span><span></span><span>=</span><span></span></span><span><span></span><span>1</span><span>0</span></span></span></span> test cases, you would expect to solve all of them via random chance more than <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>30</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">30\%</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>3</span><span>0</span><span>%</span></span></span></span> of the time, since <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mfrac><mn>10</mn><msup><mn>2</mn><mn>10</mn></msup></mfrac><msup><mo stretchy="false">)</mo><mn>100</mn></msup><mo>≈</mo><mn>0.375</mn></mrow><annotation encoding="application/x-tex">(1 - \frac{10}{2^{10}})^{100} \approx 0.375</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>(</span><span>1</span><span></span><span>−</span><span></span></span><span><span></span><span><span></span><span><span><span><span><span><span></span><span><span><span><span>2</span><span><span><span><span><span><span></span><span><span><span>1</span><span>0</span></span></span></span></span></span></span></span></span></span></span></span><span><span></span><span></span></span><span><span></span><span><span><span>1</span><span>0</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span></span><span><span>)</span><span><span><span><span><span><span></span><span><span><span>1</span><span>0</span><span>0</span></span></span></span></span></span></span></span></span><span></span><span>≈</span><span></span></span><span><span></span><span>0</span><span>.</span><span>3</span><span>7</span><span>5</span></span></span></span>.</p> <p>This understanding of the likelihood of randomly solving large test sets is what gave me confidence that an appropriate seed could be found in a reasonable amount of time.</p> <h2 id="implementation"><a href="#implementation">Implementation</a></h2> <p>One important aspect of the implementation is that the random seed must depend on the input somehow. The reason is that, for example, if all <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>6</span></span></span></span> length <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k=2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span><span></span><span>=</span><span></span></span><span><span></span><span>2</span></span></span></span> inputs were present in the test suite, then there is no static seed that could possibly solve them all simultaneously, as the static seed would produce the same output for any input, and this output must be present in some of the input lists.</p> <p>My first attempt to construct a seed from the input was to use Python&#39;s builtin <code>hash</code> to map the input to a scalar, like <code>sum(hash(b) for b in bitstrings)</code>. However, in Python3+, hashing is not deterministic across restarting the interpreter so I had to come up with a different hash function that I knew would be deterministic. Fortunately, the quality of the hash doesn&#39;t really matter much in this case, so I chose a simple one that forms a hash by computing a value from each bitstring&#39;s characters and their position in the array: <code>sum(ord(c)*j*i for (i, b) in enumerate(bitstrings) for (j, c) in enumerate(b))</code>.</p> <p>The documentation on Python&#39;s random seed details was a little bit vague, and since I didn&#39;t know the exact details of the seed but was certain that it could take at least a 32-bit seed, I picked a modulus <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>999999999</mn></mrow><annotation encoding="application/x-tex">999999999</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>9</span><span>9</span><span>9</span><span>9</span><span>9</span><span>9</span><span>9</span><span>9</span><span>9</span></span></span></span>, which is under <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>2</span><span><span><span><span><span><span></span><span><span><span>3</span><span>2</span></span></span></span></span></span></span></span></span></span></span></span>, but still large enough that I expected to find a valid seed.</p> <p>The reason I was confident that this modulus was large enough that I was likely to find a valid seed stems from the following heuristic. I was fairly confident that all possible <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">k = \{1, 2\}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span><span></span><span>=</span><span></span></span><span><span></span><span>{</span><span>1</span><span>,</span><span></span><span>2</span><span>}</span></span></span></span> cases and a large number of <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mo stretchy="false">{</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">k = \{3, 4\}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span><span></span><span>=</span><span></span></span><span><span></span><span>{</span><span>3</span><span>,</span><span></span><span>4</span><span>}</span></span></span></span> cases would be present in the test suite, and then I figured that they would just randomly populate it with larger-value-of-<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span> test cases. Since I know the probabilities of randomly solving any given test case, I just calculated the probability of randomly solving a random size-183 test suite made up of test cases as described above. This came out to have <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>≈</mo><mn>2.9</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>8</mn></mrow></msup></mrow><annotation encoding="application/x-tex">p \approx 2.9\times 10^{-8}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>p</span><span></span><span>≈</span><span></span></span><span><span></span><span>2</span><span>.</span><span>9</span><span></span><span>×</span><span></span></span><span><span></span><span>1</span><span><span>0</span><span><span><span><span><span><span></span><span><span><span>−</span><span>8</span></span></span></span></span></span></span></span></span></span></span></span>, which means we should expect there to be about 30 suitable seeds in the range <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>999999999</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0, 999999999)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>[</span><span>0</span><span>,</span><span></span><span>9</span><span>9</span><span>9</span><span>9</span><span>9</span><span>9</span><span>9</span><span>9</span><span>9</span><span>)</span></span></span></span>. </p> <p>Lastly, I made a small tweak to the general hash function. I added an additive term of <code>+ 111</code> to ensure that it never returned 0 for any part of the input. In theory this was to prevent collisions (otherwise, the entire first bitstring, and the first bit of the other bitstrings would be ignored), but I discovered later that it really didn&#39;t do a great job and there were some easy cases that could have been avoided. </p> <p>Then, I added an additive variable term to the hash, so that I could easily vary the hash function for brute forcing.</p> <p>At the end, I had:</p> <pre><code><span>def</span> <span>find_new_string</span>(<span>bitstrings, seed_value</span>):
    random.seed((seed_value + <span>sum</span>(<span>ord</span>(c)*(i*j+<span>111</span>) <span>for</span> (i, n) <span>in</span> <span>enumerate</span>(nums) <span>for</span> (j, c) <span>in</span> <span>enumerate</span>(n))) % <span>999999999</span>)
    <span>return</span> <span>&#39;&#39;</span>.join(random.choice(<span>&#39;01&#39;</span>) <span>for</span> _ <span>in</span> nums)</code></pre> <p>I then simply collected a series of test cases and ran the following script:</p> <pre><code>good_seeds = []
<span>for</span> i <span>in</span> <span>range</span>(<span>100_000_000</span>):
    <span>if</span> <span>all</span>(find_new_string(bitstrings, i) <span>not</span> <span>in</span> bitstrings <span>for</span> bitstrings <span>in</span> test_suite): good_seeds.append(i)</code></pre> <p>When I had a collection of good seeds, I tested them on LeetCode and, if one failed, I added the failing test to my test suite and resumed my search. I eventually found the additive factor that allowed me to pass all the tests. In total, it took 42 tries for me to get the correct seed once I had nailed down the hash function structure.</p> <p>I think this search could have been sped up in several ways. The main way is that I am pretty sure that there were some duplicates in the test suite, but with their order permuted (e.g., <code>[&#34;00&#34;, &#34;11&#34;]</code> vs <code>[&#34;11&#34;, &#34;00&#34;]</code>). These inputs would hash to different values for the seed, meaning they made the problem a bit harder (especially if they were small <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span>). Sorting them before applying the hash would have resolved this issue. I also think a better hash function could have been used. For example, Python&#39;s seed can apparently take in a string, so it would have been possible for me to simply seed the hash function with the concatenation of all of the bitstrings. I think this is the biggest area that could have prevented me from solving the problem, since we expected only ~30 valid seeds in the interval that I used in the hash function, any hash collisions could have easily made it so that we would not find any valid seeds unless we increased the modulus.</p>  </div> </div></div>
  </body>
</html>
