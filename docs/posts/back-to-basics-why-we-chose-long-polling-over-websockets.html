<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.inferable.ai/blog/posts/postgres-nodejs-longpolling.mdx">Original</a>
    <h1>Back to basics: Why we chose long-polling over websockets</h1>
    
    <div id="readability-page-1" class="page"><div><section><div><div><div><header><div><div><p>Learn how we implemented real-time updates using Node.js, TypeScript, and PostgreSQL with HTTP long polling. A practical guide to building scalable real-time systems without WebSockets.</p><div><p><span>Nadeesha Cabral</span></p><p><span>â€¢</span><time datetime="04-01-2025">04-01-2025</time></p></div></div></div></header><p>Like many teams building real-time systems with Node.js and TypeScript, we&#39;ve been exploring ways to handle real-time updates at scale. Our system handles hundreds of worker nodes constantly polling our PostgreSQL-backed control plane for new jobs (tool calls issued by agents), while agents themselves continuously pull for execution and chat state updates. What started as an exploration into WebSockets led us to a surprisingly effective &#34;old-school&#34; solution: HTTP long polling with Postgres.</p>
<h2>The Challenge: Real-time Updates at Scale</h2>
<p>Our Node.js/TypeScript backend faced two main challenges:</p>
<ol>
<li><strong>Worker Node Updates</strong>: Hundreds of worker nodes running our Node.js / Golang / C# SDKs needed to know about new jobs as soon as they were available, requiring a querying strategy that didn&#39;t bring down our Postgres database</li>
<li><strong>Agent State Synchronization</strong>: Agents required real-time updates about execution and chat state, which we needed to stream efficiently.</li>
</ol>
<h2>Long Polling vs WebSockets: A Refresher</h2>
<h3>How Long Polling Works</h3>
<pre>sequenceDiagram
    participant Client
    participant Server
    participant Database
    
    Client-&gt;&gt;Server: Request new data
    
    alt Data available immediately
        Server-&gt;&gt;Database: Check for data
        Database--&gt;&gt;Server: Return data
        Server--&gt;&gt;Client: Return response immediately
    else No data available
        Server-&gt;&gt;Database: Check for data
        Database--&gt;&gt;Server: No data
        Note over Server: Hold connection
        loop Check periodically
            Server-&gt;&gt;Database: Poll for new data
            Database--&gt;&gt;Server: New data arrives
        end
        Server--&gt;&gt;Client: Return response
    end
    Client-&gt;&gt;Server: Next request begins
</pre>
<p>The key difference between approaches can be understood with a simple train analogy:</p>
<p>Short polling is like a train that departs strictly according to a timetable - it leaves the station at fixed intervals regardless of whether there are passengers or not. WebSockets, on the other hand, are like having a dedicated train line always ready to transport passengers.</p>
<p>Long polling? It&#39;s like a train that waits at the station until at least one passenger boards before departing. If no passengers show up within a certain time (TTL), only then does it leave empty. This approach gives you the best of both worlds - immediate departure when there&#39;s data (passengers) and efficient resource usage when there&#39;s not.</p>
<p>In technical terms:</p>
<ol>
<li>With short polling, the server responds immediately whether there&#39;s data or not</li>
<li>With long polling, the server holds the connection open until either:<!-- -->
<ul>
<li>New data becomes available</li>
<li>A timeout is reached (TTL)</li>
</ul>
</li>
</ol>
<h2>Our Implementation Deep Dive</h2>
<p>Let&#39;s break down our Node.js implementation:</p>
<pre><code><span>export</span> <span>const</span> <span>getJobStatusSync</span> = <span>async</span> (<span>{
  jobId,
  owner,
  ttl = <span>60_000</span>,
}: {
  jobId: <span>string</span>;
  owner: { clusterId: <span>string</span> };
  ttl?: <span>number</span>;
}</span>) =&gt; {
  <span>let</span> <span>jobResult</span>: {
    <span>service</span>: <span>string</span>;
    <span>status</span>: <span>&#34;pending&#34;</span> | <span>&#34;running&#34;</span> | <span>&#34;success&#34;</span> | <span>&#34;failure&#34;</span> | <span>&#34;stalled&#34;</span>;
    <span>result</span>: <span>string</span> | <span>null</span>;
    <span>resultType</span>: <span>ResultType</span> | <span>null</span>;
  } | <span>undefined</span>;

  <span>const</span> start = <span>Date</span>.<span>now</span>();
</code></pre>
<p>The function accepts:</p>
<ul>
<li><code>jobId</code>: Unique identifier for the job we&#39;re tracking</li>
<li><code>owner.clusterId</code>: Cluster identifier for multi-tenancy</li>
<li><code>ttl</code>: Time-to-live in milliseconds (defaults to 60 seconds)</li>
</ul>
<h3>The Polling Loop</h3>
<pre><code>  <span>do</span> {
    <span>const</span> [job] = <span>await</span> data.<span>db</span>
      .<span>select</span>({
        <span>service</span>: data.<span>jobs</span>.<span>service</span>,
        <span>status</span>: data.<span>jobs</span>.<span>status</span>,
        <span>result</span>: data.<span>jobs</span>.<span>result</span>,
        <span>resultType</span>: data.<span>jobs</span>.<span>result_type</span>,
      })
      .<span>from</span>(data.<span>jobs</span>)
      .<span>where</span>(<span>and</span>(<span>eq</span>(data.<span>jobs</span>.<span>id</span>, jobId), <span>eq</span>(data.<span>jobs</span>.<span>cluster_id</span>, owner.<span>clusterId</span>)));

    <span>if</span> (!job) {
      <span>throw</span> <span>new</span> <span>NotFoundError</span>(<span>`Job <span>${jobId}</span> not found`</span>);
    }

    <span>if</span> (job.<span>status</span> === <span>&#34;success&#34;</span> || job.<span>status</span> === <span>&#34;failure&#34;</span>) {
      jobResult = job;
    } <span>else</span> {
      <span>await</span> <span>new</span> <span>Promise</span>(<span><span>resolve</span> =&gt;</span> <span>setTimeout</span>(resolve, <span>500</span>));
    }
  } <span>while</span> (!jobResult &amp;&amp; <span>Date</span>.<span>now</span>() - start &lt; ttl);
</code></pre>
<p>Key aspects:</p>
<ol>
<li>The loop continues until either:<!-- -->
<ul>
<li>We get a final status (<code>success</code> or <code>failure</code>)</li>
<li>We hit the TTL timeout</li>
</ul>
</li>
<li>We use a 500ms delay between checks to prevent hammering the database</li>
<li>Database query is optimized with proper indexes on <code>id</code> and <code>cluster_id</code></li>
</ol>
<h3>Error Handling and Response</h3>
<pre><code>  <span>if</span> (jobResult) {
    <span>return</span> jobResult;
  } <span>else</span> {
    <span>throw</span> <span>new</span> <span>JobPollTimeoutError</span>(<span>`Call did not resolve within <span>${ttl}</span>ms`</span>);
  }
</code></pre>
<p>The function concludes by:</p>
<ol>
<li>Throwing a timeout error if no result was found</li>
<li>Returning the job result if successful</li>
</ol>
<h2>Database Optimization</h2>
<p>For this pattern to work efficiently, proper Postgres indexing needs to be implemented:</p>
<pre><code><span>CREATE</span> INDEX idx_jobs_status <span>ON</span> jobs(id, cluster_id);
<span>CREATE</span> INDEX idx_jobs_lookup <span>ON</span> jobs(status) <span>WHERE</span> status <span>IN</span> (<span>&#39;success&#39;</span>, <span>&#39;failure&#39;</span>);
</code></pre>
<p>This ensures our frequent polling queries are fast and don&#39;t put unnecessary load on the database.</p>
<h2>The Hidden Benefits of Long Polling</h2>
<p>One of the most compelling aspects of long polling is what you don&#39;t have to build. Here&#39;s what we avoided:</p>
<h3><strong>Observability Remains Unchanged</strong></h3>
<p>One of the biggest wins is that we don&#39;t need to modify our observability stack for WebSockets. All our standard HTTP metrics just work out of the box, and our existing logging patterns do exactly what we need. There&#39;s no need to figure out new ways to monitor persistent connections or implement additional logging for WebSocket state.</p>
<h3><strong>Authentication Simplicity</strong></h3>
<p>We completely avoid the headache of implementing a new authentication mechanism for incoming WebSocket connections. We just keep using our standard HTTP authentication that we already have in place. All our existing security patterns continue to work exactly as they always have.</p>
<p>When we implemented Websockets earlier, this became extremely gnarly due to the RBAC restrictions we had to honor. Basically, we needed to be really careful about what data we push to the connected clients, and the privilege escalation that happens when a client moves from one cluster to another.</p>
<h3><strong>Infrastructure Compatibility</strong></h3>
<p>Corporate firewalls blocking WebSocket connections was one of our other worries. Some  of our users are behind firewalls, and we don&#39;t need the IT headache of getting them to open up WebSockets.</p>
<p>Not our problem. We don&#39;t need any special proxy configurations or complex infrastructure setups. Our standard load balancer configuration works fine without any modifications. The entire stack just keeps humming along as it always has.</p>
<h3><strong>Operational Simplicity</strong></h3>
<p>We never have to worry about server restarts dropping WebSocket connections. There&#39;s no connection state to manage or maintain. When something goes wrong (and something always goes wrong), it&#39;s much easier to debug and troubleshoot because we&#39;re just dealing with standard HTTP requests and responses.</p>
<p>We use Cloudflare for our edge, and that means our existing configuration rules and DDoS protection didn&#39;t need any changing.</p>
<h3><strong>Client Implementation</strong></h3>
<p>The client-side code stays remarkably simple. It works with any HTTP client, no special WebSocket libraries needed. Even better, reconnection handling comes for free with basic retry logic. The entire client implementation can often be just a few lines of code.</p>
<h2>Why Not ElectricSQL?</h2>
<p>While exploring solutions, we looked at <a href="https://electric-sql.com/blog/2024/07/17/electric-next">ElectricSQL</a>, which synchronizes Postgres data to the frontend. They make an interesting case for long polling over WebSockets:</p>
<blockquote>
<p>&#34;Switching to an HTTP protocol may at first seem like a regression or a strange fit. Web sockets are built on top of HTTP specifically to serve the kind of realtime data stream that Electric provides. However, they are also more stateful and harder to cache.&#34;</p>
</blockquote>
<p>In fact, we actually recommend ElectricSQL if you don&#39;t need extreme control or low-level constructs to handle real-time updates. It&#39;s a solid, battle-tested solution that handles many edge cases and provides a great developer experience.</p>
<h3>Why We Chose Raw Long Polling</h3>
<p>The message delivery mechanism is a core part of our product - it&#39;s not just an implementation detail, it&#39;s central to what we do. You can&#39;t afford to have something as fundamental as message delivery abstracted away in a third-party library, no matter how good that library might be.</p>
<p>Our specific use case required:</p>
<ol>
<li><strong>Core Product Control</strong>: Full control over our message delivery mechanism - it&#39;s not just infrastructure, it&#39;s our product</li>
<li><strong>Zero External Dependencies</strong>: We needed our stack to be as simple as possible for self-hosting</li>
<li><strong>Close to the Metal</strong>: Direct control over the polling mechanism and connection handling</li>
<li><strong>Maximum Control</strong>: Ability to fine-tune every aspect of the implementation, including implementing dynamic polling intervals</li>
<li><strong>Simplicity</strong>: Making it easy for users to understand and modify the codebase</li>
</ol>
<p>For us, staying close to the metal with a simple HTTP long polling implementation was the right choice. But if you don&#39;t need this level of control, ElectricSQL provides a more feature-rich solution that could save you significant development time.</p>
<h2>Application Layer Best Practices</h2>
<p>When implementing long polling, there are several critical practices to follow to ensure reliable operation:</p>
<h3><strong>Mandatory TTL Implementation</strong></h3>
<p>You must implement a Time-To-Live (TTL) for your HTTP connections. Without this, you&#39;ll inevitably run into connection reset errors. Your polling logic should always return within this TTL, no matter what.</p>
<pre><code><span>const</span> <span>getJobStatus</span> = <span>async</span> (<span>jobId: <span>string</span>, ttl = <span>60_000</span></span>) =&gt; {
  <span>const</span> start = <span>Date</span>.<span>now</span>();
  
  
  <span>while</span> (<span>Date</span>.<span>now</span>() - start &lt; ttl) {
    
  }
  
  <span>return</span> <span>null</span>; 
}
</code></pre>
<h3><strong>Client-Configurable TTL with Server Limits</strong></h3>
<p>While clients should be able to specify their desired TTL, the server must enforce a maximum limit:</p>
<pre><code><span>const</span> <span>MAX_TTL</span> = <span>120_000</span>; 

<span>const</span> <span>getJobStatus</span> = <span>async</span> (<span>jobId: <span>string</span>, clientTtl: <span>number</span></span>) =&gt; {
  <span>const</span> ttl = <span>Math</span>.<span>min</span>(clientTtl, <span>MAX_TTL</span>);
  
}
</code></pre>
<h3><strong>Infrastructure-Aware TTL Settings</strong></h3>
<p>Your maximum TTL must stay under the minimum HTTP connection timeout across your entire infrastructure stack:</p>
<ul>
<li>Application server timeouts</li>
<li>Client timeouts</li>
<li>Load balancer timeouts</li>
<li>Edge server timeouts</li>
<li>Proxy timeouts</li>
</ul>
<p>For example, if your edge server has a 30-second timeout, your max TTL should be comfortably under this, say 25 seconds.</p>
<h3><strong>Sensible Database Polling Intervals</strong></h3>
<p>As shown in our implementation, include a reasonable wait time between database polls. We use a 500ms interval:</p>
<pre><code><span>await</span> <span>new</span> <span>Promise</span>(<span><span>resolve</span> =&gt;</span> <span>setTimeout</span>(resolve, <span>500</span>));
</code></pre>
<p>This prevents hammering your database while still providing reasonably quick updates.</p>
<h3><strong>Optional: Exponential Backoff</strong></h3>
<p>While not implemented in our current system, you can implement exponential backoff for more efficient resource usage:</p>
<pre><code><span>const</span> <span>getJobStatus</span> = <span>async</span> (<span>jobId: <span>string</span>, ttl = <span>60_000</span></span>) =&gt; {
  <span>const</span> start = <span>Date</span>.<span>now</span>();
  <span>let</span> waitTime = <span>100</span>; 
  
  <span>while</span> (<span>Date</span>.<span>now</span>() - start &lt; ttl) {
    <span>const</span> result = <span>await</span> <span>checkJob</span>(jobId);
    
    <span>if</span> (result) <span>return</span> result;
    
    
    waitTime = <span>Math</span>.<span>min</span>(waitTime * <span>2</span>, <span>2000</span>);
    <span>await</span> <span>new</span> <span>Promise</span>(<span><span>resolve</span> =&gt;</span> <span>setTimeout</span>(resolve, waitTime));
  }
  
  <span>return</span> <span>null</span>;
}
</code></pre>
<p>This approach means:</p>
<ul>
<li>Active requests (those likely to get data soon) terminate quickly</li>
<li>Inactive requests gradually increase their polling interval</li>
<li>System resources are used more efficiently</li>
</ul>
<h2>A Case for WebSockets: The Other Side of the Story</h2>
<p>While we&#39;ve found long polling to be a great solution for our needs, it&#39;s not the only option. WebSockets are not inherently bad. They just require a lot of love and attention.</p>
<p>The challenges we mentioned aren&#39;t insurmountable - they just require proper engineering attention:</p>
<ul>
<li>
<p><strong>Observability</strong>: WebSockets are more stateful, so you need to implement additional logging and monitoring for persistent connections.</p>
</li>
<li>
<p><strong>Authentication</strong>: You need to implement a new authentication mechanism for incoming WebSocket connections.</p>
</li>
<li>
<p><strong>Infrastructure</strong>: You need to configure your infrastructure to support WebSockets, including load balancers and firewalls.</p>
</li>
<li>
<p><strong>Operations</strong>: You need to manage WebSocket connections and reconnections, including handling connection timeouts and errors.</p>
</li>
<li>
<p><strong>Client Implementation</strong>: You need to implement a client-side WebSocket library, including handling reconnections and state management.</p>
</li>
</ul></div></div></div></section></div></div>
  </body>
</html>
