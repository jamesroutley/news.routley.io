<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://typesanitizer.com/blog/go-experience-report.html">Original</a>
    <h1>Experience Report: 6 months of Go</h1>
    
    <div id="readability-page-1" class="page"><article>
          <section>
	          
<p>I’ve been working at Sourcegraph for about 6 months now.
During that time, I’ve mostly been writing Go,
in the context of server-side development.
I also gave a <a href="https://youtu.be/RIoG8BlOulE">lightning talk</a>
on reading the Go spec at GopherCon.</p>
<p>During this time, I’ve been making notes of speed bumps
I’ve run into, as well as things I’ve liked about Go.
This post is an expanded version of those notes.
I’ve tried my best to keep away from abstract examples,
and focus on actual things I’ve run into myself.</p>
<p>For context, I’ve previously written C++ for ~2.5 years
in a professional capacity. Other languages I’ve written
a fair bit of code in (recent first) include
TypeScript, Rust, Haskell, Swift, OCaml, Python and Mathematica.
My personal preference skews towards ML-like languages.
I also prefer APIs that try to make data valid-by-construction,
and make illegal states unrepresentable.
That said, I understand that not everyone cares about
these to the extent that I do (some care more, many care less,
and that’s OK).</p>
<h2 id="disclaimers">Disclaimers</h2>
<h3 id="negativity-bias">Negativity bias</h3>
<p>I’m not free from
<a href="https://en.wikipedia.org/wiki/Negativity_bias">negativity bias</a>.
It’s much easier to identify what is wrong rather than what is right.
That’s part of the reason why this post has many more negative
points rather than positive points.
The other reason is that I’m coming in to Go with a set of baseline
expectations from other (largely statically-typed) languages.
I’ve tried my best to come in with an open mind.</p>
<h3 id="a-holistic-view">A holistic view</h3>
<p>Certain internet commenters share the belief that one should
separate out discussions of the language itself from related
stuff like the standard library, tooling etc.
IMO, that is not terribly useful in most cases.
The end-to-end experience is what matters.
A programming language is not merely an abstract entity
to be studied under a microscope
but rather a tool to be used and exercised in context.
This post deliberately juxtaposes my experience with
the language, tooling, package ecosystem and community.</p>
<h3 id="why-even-write-this">Why even write this</h3>
<ol type="1">
<li>I use Go at work and I’m hoping that this post can spark
a conversation around language and compiler improvements.</li>
<li>If you’re developing a new programming language, I’m
hoping you read this and come away with a better understanding
on what you should and should not copy from Go.</li>
</ol>
<p>This isn’t written for catharsis. If anything, I’ve become
more depressed in the process of writing this post.</p>
<p>Okay, enough explanation and disclaimers.<span><label for="sn-0">⊕</label><span>Can you tell I’m reading Twitter, Reddit and Hacker News too much?</span></span>
Let’s go.</p>
<h2 id="positives">Positives</h2>
<h3 id="speedy-compile-times">Speedy compile times</h3>
<p>I knew that Go had a reputation for fast compilation,
so I wasn’t too surprised by this,
but it’s hard to overstate the productivity impact
of fast compile times.
At work, we have a nice automatic reloading system
which recompiles the relevant binaries,
kills the service processes,
and spins up new ones.
This speeds up iteration quite a bit.
The best part is that it doesn’t really matter
how deep in the dependency tree I change
something. The other day, I changed one of
the core logging functions, which forced
recompilation of nearly all binaries.
And yet, everything was recompiled and reloaded
within 10 seconds.</p>
<p>And that’s not where it ends;
it looks like there is ongoing experimental work
on an <a href="https://github.com/despiteallobjections/amigo">even faster toolchain for Go</a>.</p>
<p>With C++, incremental compilation can be fast
if you’re only changing a C++ file,
but linking on macOS with ld64 is relatively slow,
and changing code in headers throws a wrench into the gears.</p>
<p>Changing pervasively used structures in C++ or Rust
can cause recompilation that takes over a minute.
That is enough time to get distracted by something else, like Slack.</p>
<h3 id="good-built-in-profiling-support">Good built-in profiling support</h3>
<p>Go comes with built-in sampling profiler called <a href="https://github.com/google/pprof">pprof</a>
(not to be confused with the Linux profiling tool <code>perf</code>).
Using it, you can investigate CPU usage, memory usage
(these are the main two bits I’ve used) as well as
mutex contention, goroutines etc.</p>
<p>After a profile is recorded, you can visualize the output
as a call graph with weighted edges
or a flamegraph (for the CPU profile)
or in other formats.
This provides a good out-of-the-box experience.</p>
<p>Is it the most sophisticated profiling tool? No, it isn’t.
However, it’s a good tool for rough investigations
where you’re trying to get a high level picture
of where your application is spending time.</p>
<h3 id="default-optimization-mode-strikes-a-good-balance-between-debuggability-and-performance">Default optimization mode strikes a good balance between debuggability and performance</h3>
<p>Using a debugger with a Go binary largely works well.
For example, examining local variables works more often
than not, which does not necessarily hold for C++ code
built with optimizations.</p>
<p>This is one of the positives examples of design decisions
acting as a forcing function to make things better.
My understanding is that Go deliberately eschews configurability
(e.g. a C++ compiler usually has tons of flags to control optimizations)
in favor of a “just works” solution.
Having this design constraint means that balancing
debuggability while maintain performance is important.</p>
<p>This is something that I think many compilers get wrong,
including Rust, where the default mode (debug) has
a very large performance gap from release.<span><label for="sn-1"></label><span>My untested guess is that other languages could do
a better job here by at least running a basic register
allocator that: (1) actually uses registers instead of
<a href="https://godbolt.org/z/1476EsoT4">spilling everything to the stack</a>
(watchpoints are arguably less useful in memory-safe languages,
so it’s probably an OK default)
and (2) Is less aggressive about shrinking live
ranges and reusing registers compared to the
one used for release builds.</span></span></p>
<p>Swift gets this right to an extent with mandatory inlining,
but I feel like Go probably strikes the best balance
of all the languages I’ve tried.</p>
<p>Of course, Go’s solution isn’t perfect.
I do wish there were some way of controlling things better
for performance-sensitive code.
However, for most code that isn’t performance-sensitive,
Go’s default hits the sweet spot.</p>
<h3 id="goland-is-really-nice-to-use">GoLand is really nice to use</h3>
<p>At work, I mostly use GoLand for developing Go.</p>
<p>It’s nice that common functionality like
Find Usages, Rename Symbol, Annotate with Git Blame
just work out of the box, without needing to configure any plugins.
The View Call Hierarchy functionality also works okay,
but not very well in the presence of interfaces.</p>
<p>GoLand can also optionally fold away <code>if err != nil</code> bodies,
which vertically compresses the code, making it easier to scan.
The concise visualization for <code>fmt.Sprintf</code> and similar calls is also a nice touch,
since Go lacks string interpolation.</p>
<p>The syntax highlighting allows for separate colors for mutable
global variables, as well as <code>nil</code>, which is good.
My current theme highlights those in red, drawing attention.</p>
<p>Performance-wise, GoLand feels a bit snappier than VS Code.</p>
<h3 id="golangci-lint-is-helpful">golangci-lint is helpful</h3>
<p><a href="https://golangci-lint.run/usage/linters"><code>golangci-lint</code></a> is a collection
of checks, with a mix of stylistic checks, lightweight “lint”-style checks
and more non-local “static analyzer”-style checks.</p>
<p>We have a bunch of these <a href="https://github.com/sourcegraph/sourcegraph/blob/main/.golangci.yml">enabled in CI</a>,
and I run the tool locally as well before pushing changes.</p>
<p>Overall, the checks we have enabled seem to be useful in catching issues,
especially minor ones left after tweaking some code in a hurry but forgetting to clean it up.</p>
<h3 id="playground-and-runnable-examples">Playground and runnable examples</h3>
<p>Go’s <a href="https://go.dev/play/">online playground</a> is useful for quickly testing out small code examples.
I generally prefer using it over writing small snippets locally in a standalone file,
since I can easily share playground links with colleagues if needed.</p>
<p>On a related note, a bunch of the Go documentation has runnable examples
(i.e. embedded pre-populated playgrounds), which is a nice touch.</p>
<h2 id="negatives">Negatives</h2>
<blockquote>
<p>People keep saying learning programming languages makes you a better
programmer. It really doesn’t. It makes you [better] up to a point.
Then it makes you bitter and dissatisfied because you’ll never
be able to port those ideas to your day job.</p>
<p>– Aditya Sriram (<span data-cites="deech">@deech</span>) (<a href="https://youtu.be/zt0OQb1DBko?t=1863">source</a>)</p>
</blockquote>
<h3 id="undesirable-semantics-for-common-operations">Undesirable semantics for common operations</h3>
<ul>
<li>The loop iteration variable is reused across iterations,
so capturing it by reference (the default for closures) is likely to lead to bugs.
Thankfully, this one can be caught by linters to some extent.</li>
<li><code>defer</code> inside a block executes not at the end of the block,
but at the end of the enclosing function.</li>
<li><code>defer</code> <a href="https://twitter.com/typesanitizer/status/1461859034684788739?s=20&amp;t=0hmR6mIYqwC7u_dxgWm9fg">evaluates sub-expressions eagerly</a>.</li>
</ul>
<h3 id="interrupting-flow">Interrupting flow</h3>
<p>When I was using the Go layer in Spacemacs, the errors on unused imports were quite annoying.<span><label for="sn-2">⊕</label><span>Maybe I didn’t have the Go layer configured correctly to clean up imports?</span></span>
Thankfully, this isn’t a problem with GoLand.</p>
<p>Errors on unused variables are annoying as well.
Unfortunately, GoLand doesn’t automatically mark these with <code>_</code> assignments
(maybe this is configurable?).
This is particularly bothersome when fiddling with tests,
or when temporarily commenting out code paths,
such as when working with code that is unfamiliar.</p>
<p>In most languages, these would be warnings, not hard errors.
However, these aren’t warnings in Go, because Go doesn’t have any warnings at all.
The <a href="https://go.dev/doc/faq#unused_variables_and_imports">official reasoning</a>
for the No Warnings Policy includes this incredible zinger:</p>
<blockquote>
<p>First, if it’s worth complaining about, it’s worth fixing in the code. (And if it’s not worth fixing, it’s not worth mentioning.)</p>
</blockquote>
<p>Every time I re-read this line, it makes me slightly more upset.</p>
<p>There is a time and place for things. 🤌
This is true both for code and for life more generally.
Not everything that should be done needs to be done right here right now.</p>
<p>Imagine trying to learn a musical instrument
and being berated at every time
you play the wrong note.
That’s not a way to teach;
it’s a way of asserting dominance.</p>
<p>If your friend is crying because they failed an exam,
that’s not the time to tell them, “You should’ve studied XYZ more thoroughly.”
Do they need to hear that? They probably do,
but when they’re crying you should console them.
Later, when they’ve calmed down and are trying to figure out
what went wrong, that’s when you can give them advice.</p>
<p>😮‍💨</p>
<h3 id="cannot-make-a-type-in-a-foreign-package-implement-an-interface">Cannot make a type in a foreign package implement an interface</h3>
<p>In Go, you can only add methods to a type defined in the same package.
Non-empty interfaces require adding methods to types.
So you can’t make a type in a dependency implement an interface in your package.</p>
<p>I understand part of the reason why the limitation is in place.
The problem is that Go currently doesn’t have any syntax
to disambiguate if such functionality is added and multiple packages
add identically named methods to a type.
But that’s a solvable problem; it’s not rocket science.</p>
<p>For example, Swift is very relaxed about this.
In Swift, if you import a library A with type T
and import another library B with protocol P,
even if neither A nor B know about each other,
you can make T conform to P.<span><label for="sn-3"></label><span>Except if both A and B are compiled with library evolution,
in which case you get a warning.</span></span></p>
<p>Rust is currently somewhat more restrictive than Swift,
but it lets you add trait methods to a foreign type
if the trait is locally defined. However, Rust is
<a href="http://smallcultfollowing.com/babysteps//blog/2022/04/17/coherence-and-crate-level-where-clauses/">currently exploring</a>
if it can be more flexible.</p>
<p>While making things fully flexible is problematic –
for example, having distinct implementations for a type + interface
pair at runtime would be bad –
it would be good if the current restriction was at least
relaxed to some extent.</p>
<h3 id="no-sum-types-with-exhaustive-pattern-matching">No sum types with exhaustive pattern matching</h3>
<p>I was going to share some examples about how sum types
would’ve be really useful for work.
Instead, how about not just my own work, but everybody’s work?</p>
<p>I tried a search for a code pattern often seen due to the lack
of exhaustive pattern-matching in Go:</p>
<pre><code>default:
        panic(&#34;unreachable&#34;)</code></pre>
<p>That’s <a href="https://sourcegraph.com/search?q=context:global+lang:Go+default:%5Cn%5Cs%2Bpanic%5C%28%22unreachable%22%5C%29+count:all&amp;patternType=regexp">38.7k hits in the source code across GitHub etc.</a> as of Apr 29 2022.
I’ll grant you: some of these must be type switches,
which cannot be exhaustive anyways.
However, I’m sure I’m missing out on many more switches
that ought to be exhaustive but aren’t checked by this query
because they have a different panic message.</p>
<p>Given the size of the evidence above, I’m going to skip the example.</p>
<h3 id="no-overloading-for-common-operations">No overloading for common operations</h3>
<p>Go has a <code>range</code> construct. It works for arrays, slices and maps.
Did you write your own hash table type and want to iterate over it?
Well, too bad, you can’t have the nice <code>range</code> syntax.
Or did you want to access elements from that map?
Well, again, too bad, you can’t have the nice <code>[...]</code> syntax.</p>
<p>Having these (and many other) operations be special-cased to types
in the standard library makes the experience of using
custom data structures more cumbersome than it needs to be.</p>
<p>This isn’t just an abstract problem. At work, we have some <code>map</code>
and <code>set</code> types which are small-size optimized. The code that uses
these is needlessly verbose because of the lack of syntax overloading.</p>
<h3 id="no-standard-set-type">No standard set type</h3>
<p>The standard library has a large number of modules,
but lacks a set type for some reason.
Yes, one can use <code>map[T]struct{}</code>, but that feels needlessly cumbersome.
(Yes, I know I can use a third-party package…)</p>
<p>Given that Go 1.18 added support for generics, I hope that commonly useful collection types
like sets will be added to the standard library in upcoming versions of Go.</p>
<h3 id="no-anonymous-interface-compositions">No anonymous interface compositions</h3>
<p>The Go standard library defines a bunch of interfaces
which are essentially just compositions of other interfaces.
For example, the <code>io</code> package contains:</p>
<ul>
<li><code>ReadCloser</code></li>
<li><code>ReadSeeker</code></li>
<li><code>ReadWriter</code></li>
<li><code>ReadSeekCloser</code></li>
<li><code>ReadWriteCloser</code><span><label for="sn-4">⊕</label><span>Yes, there’s no <code>WriteSeekCloser</code> or <code>ReadWriteSeekCloser</code>.</span></span></li>
<li><code>ReadWriteSeeker</code></li>
<li><code>WriteCloser</code></li>
<li><code>WriteSeeker</code></li>
</ul>
<p>The way these work is that you have a definition with “embedded interfaces”:</p>
<pre><code>type ReadSeeker interface {
	Reader
	Seeker
}</code></pre>
<p>And any type that satisfies the embedded interfaces will also satisfy
the <code>ReadSeeker</code> interface.</p>
<p>The problem with this approach is that if you want to use a pair of interfaces
to describe an API somewhere, you need to define a new combined interface.
Defining that new interface isn’t a lot of work, it’s just that it seems
like pointless busywork.
Maybe I’m missing some reason why this limitation exists…</p>
<p>In contrast, Swift allows composing protocol types with <code>&amp;</code>
(e.g. <a href="https://developer.apple.com/documentation/swift/codable">Codable</a> which allows for serialization and deserialization)
and Rust allows trait combinations with <code>+</code>.</p>
<p>Now that Go 1.18 has added support for generics with constraints,
I suspect that this problem will come up more often
as more generic code is written.
So maybe this will be fixed in the future?</p>
<p><strong>CORRECTION:</strong> A colleague <a href="https://twitter.com/Strum355/status/1520443112698658818?s=20&amp;t=wBdcHgqiAAFYCyO6jDqe3Q">pointed out</a>
that you can directly do something like:</p>
<pre><code>func f(x interface {
	io.Reader
	io.Seeker
}) {}</code></pre>
<p>without defining the type separately. This is consistent
with how anonymous structs can be used. However, I’m not
a fan of this syntax; it feels very verbose given that
<code>gofmt</code> will splat the different fields across different lines.
It would be nicer if you could write it in a more compact way.</p>
<h3 id="naming-conventions">Naming conventions</h3>
<p>The names for symbols in the Go standard library,
as well as the various tooling flags leave a lot to be desired.
Broadly, the problems fall into three buckets:</p>
<ul>
<li>Using short names without good reason, such as for
infrequently used public symbols.
C used to have short names because linkers couldn’t cope with
symbols longer than 8 characters.
That restriction no longer applies though.</li>
<li>Naming being very different from other languages,
without good reason.</li>
<li>Names being misleading, in that the actual behavior does
more or less than what you’d expect just by looking at the name.</li>
</ul>
<p>Here are some examples:</p>
<ul>
<li><p><code>fmt.Println(...)</code> in addition to putting a newline at the end,
also puts spaces in between arguments.</p></li>
<li><p><code>filepath.Clean()</code> is not called <code>filepath.Canonicalize()</code>
or <code>filepath.Normalize()</code>. Moreover, “clean” seems to imply
that something is “dirty” which is being fixed, but filepaths
with some <code>.</code> and <code>..</code> can hardly be called “dirty.”</p></li>
<li><p><code>filepath.Join(...)</code> doesn’t just concatenate paths,
optionally putting a separator in between,
but also calls <code>filepath.Clean(...)</code> on the result.</p></li>
<li><p>The <code>tar</code> package has a header type called <code>tar.TypeReg</code>,
where <code>Reg</code> is short for “regular file”, and a header type called
<code>tar.TypeLink</code> for hard links. However, some other header types do
use full names, such as <code>tar.TypeSymlink</code>.</p></li>
<li><p><code>exec.LookPath(file string)</code> searches for an executable named
<code>file</code> in directories named by the <code>PATH</code> environment variable.
<code>PATH</code> ought to be capitalized according to the case conventions
followed elsewhere, and the immediate verb after in the doc comment
is “search” (~ “find”). So why not have the declaration be one of:</p>
<pre><code>FindInPATH(executableName string)
OR
FindExecutableInPATH(name string)</code></pre>
<p>instead of <code>LookPath</code>? IME, “find” is a much more common verb prefix
for function names compared to “look” (usually used as “lookup”).</p></li>
<li><p><code>go mod tidy</code>: the verb “tidy” to me means that it will
potentially rearrange stuff but not add/delete things.
Moreover, it sounds like an optional thing.
Well, that’s not what <code>go mod tidy</code> does.
It downloads dependencies, adds them to the <code>go.mod</code>
file, and also removes unused dependencies from the <code>go.mod</code> file.</p></li>
<li><p>All of <code>go get</code>’s flags <code>[-d] [-t] [-u] [-v]</code> do not have
corresponding longer versions.</p></li>
<li><p>The canonical Go package for describing Go modules
is called <a href="https://pkg.go.dev/golang.org/x/mod/module"><code>module</code></a>,
and it has a type called <a href="https://github.com/golang/go/blob/master/src/cmd/vendor/golang.org/x/mod/module/module.go#L110-L125"><code>Version</code></a>
defined as:</p>
<pre><code>type Version struct {
  Path string
  Version string
}</code></pre>
<p>So this type will be referred to as <code>module.Version</code>
by code outside this package. However, if you haven’t seen
the type’s definition, it is easy to mistakenly think
that the type describes <em>only</em> a version. But it has a <code>Path</code> too!</p>
<p>Why not name this type <code>WithVersion</code> or <code>Dependency</code> or
<code>ID</code>? That way, the likelihood of misunderstanding would be reduced.</p></li>
<li><p>This one hasn’t affected me personally yet, but it deserves a special mention.
<a href="https://github.com/golang/go/tree/master/src/cmd/compile#introduction-to-the-go-compiler">The default Go compiler is called <code>gc</code></a>.</p>
<blockquote>
<p>It should be clarified that the name “gc” stands for “Go compiler”, and has little to do with uppercase “GC”, which stands for garbage collection.</p>
</blockquote>
<p>I have not done any git spelunking to figure out if this was meant
as a shitpost-style naming thing (“hohoho, all ill-formed Go code
is garbage”) or if it was done to save a single ‘o’ character somewhere
or something else.</p></li>
</ul>
<h3 id="odd-choice-of-terminology">Odd choice of terminology</h3>
<p>Go documentation often uses non-standard terminology in situations
where well-established terminology exists. Some examples:</p>
<ul>
<li>The <code>regex</code> package repeatedly uses “submatch” and “parenthesized subexpression”
in its docs, even though the <a href="https://trends.google.com/trends/explore?q=submatch,capture%20group,parenthesized%20subexpression">more common term</a>
is “capture group” (which is mentioned just once).</li>
<li>The documentation for the <code>strings</code> package repeatedly uses
“Unicode letters” instead of the more standard term “codepoints.”</li>
<li>Special character sequences like <code>%s</code> in format strings are called “verbs”,
even though “format specifiers” is the more common term of art in other languages.</li>
</ul>
<h3 id="struct-layout-is-based-on-declaration-order">Struct layout is based on declaration order</h3>
<p>Go does struct layout of fields based on declaration order.<span><label for="sn-5"></label><span>At least, for monomorphic structs. I have not checked how it works with generic structs.</span></span></p>
<p>This has two unfortunate side effects.
First, a bunch of code is needlessly less efficient that it needs to be.
Second, if you do care about efficiency in certain parts,
you need to do the layout “by hand”,
potentially needing to put conceptually related fields further apart
to reduce memory footprint.</p>
<h3 id="poor-compiler-diagnostics">Poor compiler diagnostics</h3>
<p>In terms of diagnostics, the Go compiler has a lot of room for improvement.
It’s not even as good as Clang, let alone Rustc.</p>
<p>In most (all?) cases, it does not make any attempt whatsoever
to provide textual hints on how to fix the code. Some examples:</p>
<ul>
<li>If you make a typo in a type name,
there won’t be any suggestion on how to fix it.</li>
<li>If you write a type name without the package qualifier,
there won’t be any suggestion on which package it comes from.</li>
<li>If you shadow a package name with a local variable
(not hard to do accidentally since package names are lowercase,
especially with package names like <code>bytes</code>),
there’s no hint when trying to access a function from the package
(which gets interpreted as a field access on the local).</li>
</ul>
<p>I’m not even talking about IDE-integrated fix-its here,
where the suggestion manifests as an action that edits the code.
Writing textual suggestions is much simpler.
Why not do that at least?</p>
<p>It’s unfortunate that the compiler diagnostics have not seen more attention.
One of the reasons why Go was designed to be simple was to
be able to <a href="https://www.youtube.com/watch?v=uwajp0g-bY4">on-board junior developers quickly</a>.
Surely, more useful compiler diagnostics are important
to get junior developers get unstuck quickly?</p>
<p>I’ve had this running hypothesis for a while now,
that diagnostics are one of those compiler areas which:</p>
<ul>
<li>Are consistently under-invested in, even when people claim to value that area.</li>
<li>Fundamentally requires people who <em>deeply care</em> about diagnostics
to make a difference in the long term.</li>
</ul>
<p>As one data point, when I worked on Swiftc (mid 2019 - late 2021),
there wasn’t a single person dedicated to working on diagnostics.
There were people working on type-checker performance,
and those helped surface existing diagnostics in some situations
which would previously time out.
Different people did fix diagnostic bugs from time to time.
But it wasn’t someone’s job to do it.
From the outside, it seems like Go is in a similar boat. 😬</p>
<h3 id="odd-doc-conventions">Odd doc conventions</h3>
<p>Go has a convention that doc comments must begin with the name of the entity
they describe. English is not my first language,
and even I can tell that this makes function documentation read in a bizarre way.
Consider an example:
[^edit]</p>
<pre><code>// DecompressTarball decompresses the tarball r and saves the output in outDir.
//
// &lt;other stuff&gt;
func DecompressTarball(r io.Reader, outDir string) error</code></pre>
<p>(<strong>EDIT</strong>: In an earlier version of this post, this function was previously not exported, which was unintentional.
I’ve fixed the spelling from <code>decompressTarball</code> to <code>DecompressTarball</code>.)</p>
<p>You have needless repetition: “decompress” and “tarball” both appear twice
in the first line without good reason.</p>
<p>No other language that I know of follows this style.
If someone is looking at the documentation for a symbol,
they already have the symbol name available. So why repeat it?</p>
<h3 id="limited-markup-support-in-godoc">Limited markup support in godoc</h3>
<p>godoc only supports a few markup features.
In contrast, both Rust and Swift support a superset of CommonMark.
Less popular languages like OCaml and Haskell have Odoc and Haddock
respectively, which are also quite featureful.</p>
<p>There have been some improvements recently on this front,
with support for <a href="https://github.com/golang/proposal/blob/master/design/51082-godocfmt.md">headings, lists and links</a>.
It’s kinda’ surprising that it took over 10 years to add support
for these though! Given that link support is so new,
the number of links in the existing docs is quite low.</p>
<p>According the RFC linked above, to avoid “space-counting subtleties like Markdown”,
the list syntax doesn’t support nested lists.
I don’t know of any other programming language which has
a standard documentation tool that doesn’t support nested lists.</p>
<p>Also, embedding images is not supported because the
“complexity is in direct conflict with the primary goal”
where the primary goal is to
“prioritize readability, avoiding syntactic ceremony and complexity.”</p>
<p>I hope that more of these limitations are removed over time.</p>
<h3 id="documentation-in-some-cases-is-not-well-organized">Documentation in some cases is not well-organized</h3>
<p>As an example, the pprof docs are scattered in multiple places:</p>
<ul>
<li>The official <a href="https://github.com/google/pprof/blob/master/doc/README.md">pprof README</a> has some docs.
The “Fetching profiles” section (which covers how to record a profile)
is near the bottom whereas information
about analysis is near the top. This doesn’t make much sense to me;
one first needs to record a profile before being able to analyse it.</li>
<li>The <a href="https://pkg.go.dev/net/http/pprof">net/http/pprof package docs</a> covers some things.</li>
<li>The <a href="https://pkg.go.dev/runtime/pprof">runtime/pprof package docs</a> cover some more things.
It starts out with a long code example.
After that, it casually mentions that the package <code>net/http/pprof</code> also exists,
without giving a clear recommendation on
when <code>runtime/pprof</code> should be used over <code>net/http/pprof</code>.</li>
</ul>
<h3 id="struct-initialization-syntax">Struct initialization syntax</h3>
<p>Go supports two related syntaxes for struct initialization:</p>
<ul>
<li>Positional: Lower readability,<span><label for="sn-6"></label><span>Ameliorated by using an editor with inlay hints, such as GoLand.</span></span> but you get a compiler error if you miss a field.</li>
<li>With field names: Higher readability, but unspecified fields are zero-initialized.</li>
</ul>
<p>So you need to pick readability xor completeness. Too bad if you want both!</p>
<p>Because of these factors, you probably want to maintain the following discipline:</p>
<ul>
<li>Use positional initialization for locally-defined structs and use an
editor with inlay hints. This way, you’ll get a compiler error when you
add a field.</li>
<li>Use field names when initializing a third-party struct, so that
your code doesn’t break if upstream adds a field in the future.</li>
</ul>
<h3 id="pre-main-initialization-and-global-mutable-state-are-common">Pre-main initialization and global mutable state are common</h3>
<p>We had a “fun” bug at work, where my colleague moved a couple of definitions
from one package to another, and that broke a bunch of tests.
He spent a bunch of time investigating this before the issue was resolved.
How did this problem come up?</p>
<p>The tests was doing some stuff with timezones.
The old package that the function was in imported some other package,
which had an <code>init</code> function<span><label for="sn-7"></label><span>For people unfamiliar with Go, an <code>init</code> function runs before main,
and is not explicitly called.
This functionality is similar to global constructors in C++,
except that the relative order is more well-defined.</span></span> that modified the current timezone,
which is a global variable.
The new package that the function was moved to did not import the
timezone-modifying package.</p>
<p>The problem with <code>init</code> functions is that the
dependencies across them are not clear.</p>
<p>Instead, a more explicit design that would be more helpful IMO
would be making <code>init</code> functions “must use.” A library would
have two options:</p>
<ol type="1">
<li>Call the <code>init</code> function of an imported package from your own
<code>init</code> function.</li>
<li>Discard the imported package’s <code>init</code> function with <code>_</code>.</li>
</ol>
<p>An executable would have the same restriction, with the additional
requirement that the executable’s own <code>init</code> function must be
discarded by assigning to <code>_</code> or called as the very first statement of <code>main</code>.</p>
<p>Is that a perfect design? No.
For one thing, under such a scheme, adding an <code>init</code> function to a library which didn’t have
one before becomes a breaking change.
However, a design along these lines would make it much easier to debug
and understand issues related to <code>init</code> functions.</p>
<h3 id="conflating-useful-default-values-with-useful-zero-values">Conflating useful default values with useful zero values</h3>
<p>Go has a built-in notion of zero values for all types,
which is defined recursively as one might expect.
Integers use <code>0</code>, floats use <code>0.0</code>, strings use <code>&#34;&#34;</code>, pointers, functions, slices and maps use <code>nil</code>
– you get the idea.</p>
<p>Moreover, it is possible to safely create zero values of user-defined types
even when there is no explicit API to do so:</p>
<ul>
<li>The default JSON marshaling functionality will happily construct zero values of types
if the field is missing (making it not possible to distinguish missing keys
vs keys explicitly mapped to the zero value, without a bunch of extra work).</li>
<li>A receive from a closed channel returns the zero value.</li>
<li>Slices can be zero-initialized.</li>
</ul>
<p>This means that if you maintain a library which contains a type
whose zero value isn’t meaningful (and not constructible through the library’s API),
your two options are:</p>
<ul>
<li>Your library’s functions assume that zero values are never passed in. So if
some unfortunate programmer passes in a zero value to one of your functions,
chances are that their program will go wrong in a hard to debug manner
(and they might even file an issue on your library’s issue tracker!).</li>
<li>Your library’s functions are defensive in checking for zero values and throw an
error or panic on getting one. This incurs overhead for all library users.</li>
</ul>
<p>Billion dollar mistakes<span><label for="sn-8"></label><span>A GitHub search for issues mentioning <a href="https://github.com/search?q=type%3Aissue+invalid+memory+address+or+nil+pointer+dereference">nil dereference errors</a> gives 24k hits as of Apr 29 2022.</span></span> and defensive programming aside,
somewhat oddly, zero values are considered good in Go!
In his talk <a href="https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=385s">Go Proverbs</a>,
Rob Pike suggests “Make the zero value useful” as a guideline.
He gives examples of how the standard library uses this principle to good effect.</p>
<p>What Pike doesn’t mention is that it’s much easier to have meaningful zero values
for abstract structures, such as those found in a standard library,
as compared to narrow domain specific types, such as those in an application.</p>
<p>The other problem is that the zero value is entirely determined by the language
and not by your code! If you have a struct with a pair of string fields,
the zero value of that struct has two empty strings. You can’t change that.</p>
<p>On the other hand, in (say) Rust, you can:</p>
<ul>
<li>Choose to derive the <code>Default</code> trait</li>
<li>Implement the <code>Default</code> trait manually</li>
<li>Choose not to implement the <code>Default</code> trait, because maybe there is no good default.</li>
</ul>
<p>You have options.</p>
<p>In essence, because Go conflates the notion of “default values” and
“zero values”, it ends up emphasizing the wrong concept.</p>
<h3 id="serialization">Serialization</h3>
<p>As I mentioned earlier,
the default deserialization setup which zero-initializes fields
makes it impossible to distinguish fields that are unset
from those which are set to the zero value (without doing a bunch of extra work).</p>
<p>Additionally, if you accidentally add struct tags to private
fields (incorrectly assuming that is enough to serialize/deserialize them),
you will silently get the wrong result (with zero values)
instead of a runtime error.</p>
<h3 id="inconsistent-behavior">Inconsistent behavior</h3>
<h4 id="nil">nil</h4>
<p><code>nil</code> is sometimes equivalent to an empty collection
but sometimes causes a runtime crash.</p>
<pre><code>var a []int // initialized to nil
_ = append(a, 1) // OK
var m map[int]int // initialized to nil
m[0] = 0 // panic: nil dereference</code></pre>
<p>It’s not super clear to me whether there is some systematic rule
governing when <code>nil</code> causes a crash when using a built-in operation.
Are crashes specific to write contexts and non-crashes
specific to read-only contexts? I don’t know.</p>
<h4 id="substitution">Substitution</h4>
<pre><code>x := &#34;&#34;
_ = &amp;x // OK
_ = &amp;&#34;&#34; // invalid operation: cannot take address of &#34;&#34; (untyped string constant)</code></pre>
<p>Is this disallowed because there are two possible reasonable behaviors here
(pointer to static vs non-static data)? I don’t know.</p>
<pre><code>// type S struct {}

_ = &amp;S{} // OK
f := func() S { return S{} }
_ = &amp;f() // invalid operation: cannot take address of f() (value of type S)</code></pre>
<p>Such a restriction would make sense in the context of a language
with manual memory management like C or C++,
where creating a reference to a temporary from a function call
would increase the risk of use-after-free.
However, Go has a GC so I don’t get why this is disallowed.</p>
<h4 id="literals">Literals</h4>
<pre><code>a := [][]int{ {0, 1} } // OK, no []int needed inside

type S struct { s []int }
b := S { []int{0, 1} } // OK
c := S { {0, 1} } // error: missing type in composite literal</code></pre>
<p>From a type-checking perspective,
the type of the literal should be available in the type-checking context
based on the first field of <code>S</code>,
so it’s not clear why specifying <code>[]int</code> is needed for the literal.
Clearly, there are situations in which omitting the type of a composite
literal is permitted. So why not allow omitting it here too?</p>
<pre><code>func f(_ []int) { }
func g() { f([]int{0, 1}) } // OK
func h() { f({0, 1}) } // syntax error: unexpected {, expecting expression</code></pre>
<p>This seems even more strange; instead of giving a
“missing type in composite literal” error, it gives a syntax error.</p>
<p>The oddness around literals and lack of builtin support for sets
means that working with <code>map</code> based sets requires
sometimes spelling out <code>struct{}{}</code>, which feels like too many
characters for describing a whole lot of nothing.</p>
<h4 id="make">make</h4>
<p>Initialization with <code>make</code> behaves differently for maps and slices:</p>
<pre><code>m := make(map[int]int, 10) // capacity = 10, length = 0
a := make([]int,       10) // capacity = 10, length = 10 (zero initialization)
b := make([]int,    0, 10) // capacity = 10, length = 0</code></pre>
<p>So not only is there an inconsistency, the more common operation
has a longer spelling.</p>
<p>Inconsistency and extra keystrokes aside, I think this creates
a greater risk of bugs when code is being changed.
One of the common situations where you want to allocate a slice
of a known capacity comes with a code pattern like:<span><label for="sn-9"></label><span>Let’s ignore the fact that the zero initialization is likely
just wasting cycles because the memory is immediately going to
be overwritten.</span></span></p>
<pre><code>buf := make([]T, length)
for &lt;...&gt; {
  // set elements of buf one-by-one
}</code></pre>
<p>The shorter <code>make</code> form here is a footgun waiting to be tripped on.
The problem is that if the loop body grows long
and someone adds a <code>break</code> or <code>continue</code> clause,
they may miss realizing that they need to modify the <code>make</code> too.
That way, the slice will have a bunch of zero values
which is quite likely undesirable.<span><label for="sn-10"></label><span>Ask me how much time I spent on a bug caused by this failure mode.
<img src="https://media2.giphy.com/media/6Q3M4BIK0lX44/giphy.gif?cid=790b7611f0d35a11f4a8de3d4644cc30926da13dda7cb592&amp;rid=giphy.gif&amp;ct=g" alt="boy crying"/></span></span></p>
<p>Instead, if there were a separate <code>make_zeroed</code> built-in:</p>
<ul>
<li>The common usage would have the shorter spelling.</li>
<li>This footgun wouldn’t exist.</li>
<li>The behavior of <code>make</code> would be more consistent.</li>
</ul>
<h3 id="public-identifiers-in-tests-are-not-available-to-other-tests">Public identifiers in tests are not available to other tests</h3>
<p>This is probably best explained with a diagram.</p>
<p><img src="https://typesanitizer.com/blog/assets/test-import.png"/></p>
<p>There are two packages <code>a</code> and <code>b</code>, and <code>b</code> imports <code>a</code>.
Thanks to this import, <code>b</code> has access to the public API from <code>a.go</code>.</p>
<p><code>a_test.go</code> is a testing-only file, and has access to private APIs from <code>a.go</code>. Similarly for <code>b_test.go</code>.</p>
<p>However, importing <code>a</code> in <code>b_test.go</code> doesn’t provide access to the public APIs
in <code>a_test.go</code>. This means that if you want to export functionality
to help downstream modules test stuff involving types defined in your package,
you need to expose them as public APIs from your package.</p>
<p>Why not allow <code>b_test.go</code> to use public APIs from <code>a_test.go</code>?
That would make it easier to reuse test code.</p>
<h3 id="keep-chugging-along-in-the-face-of-logic-errors">Keep chugging along in the face of logic errors</h3>
<p>In some cases, Go will not panic in the presence of logic errors.
Couple of examples that come to mind:</p>
<ul>
<li><code>fmt.Sprintf</code> will happily insert <code>(MISSING)</code> if a format specifier (such as <code>%s</code>)
does not have a corresponding argument.</li>
<li>Sends and receives to a <code>nil</code> channel block forever.</li>
</ul>
<p>If there were panics due to these, you could detect the problem more quickly.</p>
<h3 id="language-simplicity-is-put-on-a-pedestal">Language simplicity is put on a pedestal</h3>
<p>If you watch talks about the design of Go,
or on best practices how to write Go code,
simplicity and readability are recurring themes.
These come up so often as design justifications
that I had to mention it here.</p>
<p>For example, YouTube recently recommended a 2015 talk to me titled
<a href="https://youtu.be/rFejpH_tAHM?t=310">“Simplicity is Complicated”</a>, by Rob Pike.
Here’s some of the content from one of the slides,
which I think broadly encapsulates what I’ve seen echoed elsewhere too.</p>
<blockquote>
<p>The code is harder to understand simply because it is using a more complex language.</p>
<p>Preferable to have just one way, or at least fewer, simpler ways.</p>
<p>Features add complexity. We want simplicity.</p>
<p>Features hurt readability. We want readability.</p>
<p>Readability is paramount.</p>
</blockquote>
<p>I empathize with the sentiment to an extent.
There’s a limit to how gnarly type errors (as an example)
you can get if you don’t have generics, which were only added recently.
Fewer gnarly type errors, other things being equal,
make for a better developer experience.</p>
<p>However, the “other things being equal” is an important caveat.
Given how language features have knock-on effects,
most often, other things are not equal.
If language simplicity is achieved at the cost of refactorability,
debuggability or higher risk of crashes in production
– then maybe it should not be put on a pedestal
but rather treated as a guiding principle that is sometimes useful.</p>
<p>More succinctly, <em>simplicity is a means to an end, rather than an end in itself</em>.</p>
<p>As an example of “simplicity” in one case making a bunch of other things more complicated,
here is an actual message I sent in the work Slack some time back:</p>
<blockquote>
<p>Some obstacles I’ve faced quite a few times when reading our code [using pointers] include:</p>
<ul>
<li>It’s not clear if a value that is passed via pointer is intended to be mutated or not.
(const-ness / mutability) (maybe it’s passed via pointer just because the size of the struct is large?)</li>
<li>It’s not clear if a value that is passed via pointer may be <code>nil</code>
or not in practice (particularly true for pointer fields in structs) (nullability)</li>
<li>(Less common) It’s not clear if the caller is free to continue using the point if the callee
is intended to “consume” the value (borrowing / ownership)</li>
</ul>
<p>In Rust (as an example), these would all be distinct types <code>&amp;T</code> (borrowed immutable/shared)
<code>&amp;mut T</code> (borrowed mutable/unique), <code>Box&lt;T&gt;</code> (owned mutable/unique), with potentially an
<code>Option&lt;&gt;</code> wrapper if <code>None</code> (~ <code>nil</code>) is allowed.</p>
<p>Anyone else also run into this kind of problem when reading code?</p>
<p>I’m not sure what a good solution to this looks like (maybe we can have some coding conventions
around pointers in our Go style guide?), but I’m curious if other people have strategies for
figuring this out faster, or perhaps are following some unwritten conventions in different
parts of the codebase.</p>
</blockquote>
<p>Here are the responses:</p>
<ul>
<li>This is also a frequent headache for me. Here are some conventions
which I follow to avoid this problem: &lt;…&gt; (+3)</li>
<li>[In addition to the above] If for any reason, the mutation is done in the original object,
docstring must make it clear.</li>
<li>Yep … it almost feels like picking up a bunch of random folklore
traditions that make no sense. Joking aside, I understand that Go
tries to be super minimal, but the problems Varun has described
are totally real. The solution relies on conventions, which are hard
(close to impossible?) to guarantee. &lt;…&gt;</li>
</ul>
<p>So it’s not just me who has this problem, it’s other people too.
And all of these people responding have more experience
(both Go and otherwise) than I do.</p>
<h3 id="miscellaneous-papercuts">Miscellaneous papercuts</h3>
<ul>
<li><p>AFAIK, godoc markup doesn’t support inline code (backticks in Markdown).
This means that for system fonts which make distinguishing between
I (uppercase i) and l (lowercase L) hard, reading function names
in running text can be a little cumbersome, as they are rendered
in non-monospace fonts.
Monospace fonts are usually better at distinguishing these characters IME.</p>
<p>Normally, this doesn’t matter for English text, since the letter
is clear from context, but it is a little tricky for function names
specifically because Go function names frequently do not use full words.</p></li>
<li><p>The <code>flag</code> module in the standard library, which is commonly used for argument parsing,
outputs help text to stderr instead of stdout,
even when the user has explicitly requested the help text.
This means that for every Go binary that you are using,
you almost certainly need an extra <code>2&gt;&amp;1</code> redirection
when piping the output of <code>--help</code> to a pager.</p></li>
<li><p>I once accidentally ran <code>go test cmd</code> (we have a <code>cmd</code> directory at the root of our repo at work)
and that started running the compiler’s tests.</p>
<pre><code>ok      cmd/addr2line   2.998s
ok      cmd/api 5.510s
?       cmd/asm [no test files]
?       cmd/asm/internal/arch   [no test files]
ok      cmd/asm/internal/asm    1.411s
?       cmd/asm/internal/flags  [no test files]
ok      cmd/asm/internal/lex    0.008s
?       cmd/buildid     [no test files]
?       cmd/cgo [no test files]
?       cmd/compile     [no test files]
?       cmd/compile/internal/abi        [no test files]
?       cmd/compile/internal/amd64      [no test files]
?       cmd/compile/internal/arm        [no test files]
?       cmd/compile/internal/arm64      [no test files]</code></pre>
<p>I don’t understand why this is a desirable default.
Most Unix commands that I know of do not behave differently
when passing a path as <code>./X</code> vs <code>X</code>,
so it’s unclear why <code>go test</code> behaves this way.</p></li>
</ul>
<h2 id="closing-thoughts">Closing thoughts</h2>
<p>When I was working on the first iteration of this section,
I was not really sure what to close with.
I’d come up with some joke hypotheses:</p>
<ul>
<li>Go as reified mental scar tissue, resulting from injuries sustained by
maintaining Java and C++ code at Google.</li>
<li>Go as an <a href="https://en.wikipedia.org/wiki/Absurdism">absurdist</a> programming language,
which forces the programmer to reconcile the contradiction
between their desire to seek a set of consistent design principles
behind the language, with their inability to find them.</li>
<li>Go as a programming language from a timeline <a href="https://steins-gate.fandom.com/wiki/Timeline">other than the Steins;Gate timeline</a>.</li>
</ul>
<p>As you can probably tell, it wasn’t really going anywhere good.</p>
<p>Later, while I was doing background research around previous posts on Go,
and people’s responses to them, <a href="https://old.reddit.com/r/golang/comments/fay90i/i_want_off_mr_golangs_wild_ride/fj1s370/">one comment stood out to me</a>:</p>
<blockquote>
<p>I think Go follows the <a href="https://en.m.wikipedia.org/wiki/Worse_is_better">Worse Is Better</a> principle.
Which could explain why simplicity was chosen above correctness and completeness.</p>
</blockquote>
<p>To be clear, “Worse is Better” sounds quite pejorative. I’m not endorsing the term.
It’s also called “New Jersey style” which I guess sounds less pejorative (unless you’re from New York).
Exact names aside, the description on the Wikipedia page is illuminating,
so I’m copying it below:</p>
<blockquote>
<p>a model of software design and implementation which has the characteristics (in approximately descending order of importance):</p>
<p><strong>Simplicity</strong>:
The design must be simple, both in implementation and interface. It is more important for the implementation to be simple than the interface. Simplicity is the most important consideration in a design.</p>
<p><strong>Correctness</strong>:
The design should be correct in all observable aspects. It is slightly better to be simple than correct.</p>
<p><strong>Consistency</strong>:
The design must not be overly inconsistent. Consistency can be sacrificed for simplicity in some cases, but it is better to drop those parts of the design that deal with less common circumstances than to introduce either complexity or inconsistency in the implementation.</p>
<p><strong>Completeness</strong>:
The design must cover as many important situations as is practical. All reasonably expected cases should be covered. Completeness can be sacrificed in favor of any other quality. In fact, completeness must be sacrificed whenever implementation simplicity is jeopardized. Consistency can be sacrificed to achieve completeness if simplicity is retained; especially worthless is consistency of interface.</p>
</blockquote>
<p>This is contrasted with the “MIT approach”:</p>
<blockquote>
<p><strong>Simplicity</strong>:
The design must be simple, both in implementation and interface. It is more important for the interface to be simple than the implementation.</p>
<p><strong>Correctness</strong>:
The design must be correct in all observable aspects. Incorrectness is simply not allowed.</p>
<p><strong>Consistency</strong>:
The design must be consistent. A design is allowed to be slightly less simple and less complete to avoid inconsistency. Consistency is as important as correctness.</p>
<p><strong>Completeness</strong>:
The design must cover as many important situations as is practical. All reasonably expected cases must be covered. Simplicity is not allowed to overly reduce completeness.</p>
</blockquote>
<p>When I read this page, I felt a light bulb go off in my head.<span><label for="sn-11">⊕</label><span>To be clear, I’m not saying that Go follows the New Jersey style exactly,
or that Swift/Rust follow the MIT approach exactly.
However, in broad strokes, I do think those two approaches are somewhat fitting descriptions.</span></span>
This is probably the point where I progressed from the bargaining
stage of the Kübler-Ross cycle I was on.</p>
<p>One of the things I realized that I was refusing to internalize was
that the Go team prioritizes keeping <em>implementation complexity</em> down
a LOT more than folk implementing other mainstream languages that I know of.</p>
<p>To half of my brain, this statement seems absurd at face value.
That half indignantly insists,
“Of course, complexity should be moved into the language as much as possible
if it makes things better for language users! There are many more language users
than implementors!”
I suspect this is partly an outcome of and partly a cause for why I ended
up working on Swift.</p>
<p>The Swift toolchain goes to ridiculous extents
to offload complexity from Swift developers.
From an entire compiler subsystem for first-class Objective-C interop,
to the sophisticated handling for strings,
to a type-checker that needs to handle people trying to constantly push its limits
with all sorts of <del>nonsense</del> interesting APIs,
Swift takes on a LOT of complexity.
Juggling this complexity imposes a serious mental cost for people working on Swift.
So I sympathize with the desire to keep the implementation as simple as can be.
I get it.</p>
<p>At the same time, I think for me, the MIT approach is so much more closer
to how I think about software design and correctness,
that even though I can “get” the New Jersey style in the abstract,
it’s very difficult for me to internalize it.
There is a serious cognitive effort that is needed
to overcome the impedance mismatch
between a conception of “how things ought to work”
and the reality of “how things actually work.”</p>
<p>This reminds me, if you haven’t seen Bryan Cantrill’s discussion on
<a href="https://youtu.be/2wZ1pCpJUIM?t=128">Software as a reflection of Values</a>,
you should probably do that. I should also probably rewatch it,
and hopefully advance to the acceptance stage.
Or maybe it doesn’t matter; I will likely be working a lot more
with TypeScript and other languages over the next few months,
so it is unlikely that I will post more long-form Go stuff after this.</p>
<p>In the meantime, please be nice to each other.</p>
          </section>
        </article></div>
  </body>
</html>
