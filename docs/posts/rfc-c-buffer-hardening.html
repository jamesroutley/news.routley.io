<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://discourse.llvm.org/t/rfc-c-buffer-hardening/65734">Original</a>
    <h1>RFC: C&#43;&#43; Buffer Hardening</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
          
<p>We aim to improve security of critical C++ codebases. In order to do that we plan to work on two ideas.</p>
<ol>
<li>Hardened C++ Standard Library</li>
<li>C++ Safe Buffers Programming Model and Adoption Tooling</li>
</ol>
<p>Hardened libc++ aims to make C++ Standard Library interfaces generally more secure.</p>
<p>C++ Safe Buffers Programming Model together with Hardened libc++ provide runtime mitigation of out-of-bounds memory access. The adoption tooling will automatize code migration to this new programming model.</p>
<h2>
<a name="hardened-c-standard-library-2" href="#hardened-c-standard-library-2"></a>Hardened C++ Standard Library</h2>
<p>by Louis Dionne (<a href="https://discourse.llvm.org/u/ldionne">@ldionne</a>)</p>
<p>We plan to implement a hardened mode of libc++ in which several cases of undefined behavior are caught and turned into assertion failures instead. For example, accessing a <code>std::span</code> or a <code>std::vector</code> outside of its bounds would abort the program, and so would accessing an empty <code>std::optional</code>. This can be done while staying Standards-conforming because undefined behavior implies that the library can do whatever it wants, which includes aborting.</p>
<p>These additional runtime checks will be grouped into various categories that can be controlled separately. The intent is that a vendor shipping libc++ on their platform can decide to pick which checks to enable in the library that they ship (if at all), depending on their desired level of safety. To reiterate, the end goal is for the shipped library to enable these checks in production — this is not a “debug only” feature, although it will eventually replace the long-broken “Debug mode”.</p>
<p>Indeed, the current libc++ “Debug mode” has several issues that explain why it has never been shipped by some vendors: it is slow, it requires a global database with a lock, and it is ABI-affecting despite the fact that its original design was done entirely to avoid that. Finally, we also realized recently that the current “Debug mode” was fundamentally incompatible with constexpr, which makes it non viable going forward.</p>
<p>Instead, we will explicitly allow some of the new checks to affect the ABI, which will make it possible to implement them more efficiently. For example, we may need to slightly tweak the representation of some data structures to include additional information to inform the checks. Categories of checks that are ABI-affecting will only be controllable by vendors at the time of configuring the library, while other checks will be controllable by users in their own code. ABI-affecting checks will also be encoded in the mangled names of library entities to reduce the risk for accidental mismatches.</p>
<p>Finally, libc++ already implements some of this proposal. Indeed, we recently introduced a <a href="https://libcxx.llvm.org/UsingLibcxx.html#enabling-the-safe-libc-mode" rel="noopener nofollow ugc">safe mode</a> where one can enable the most basic category of checks, i.e. those that do not have an effect on the ABI or on the complexity of operations. The assertion handler can also be customized to meet the needs of various users, similarly to how <code>operator new</code> can be customized via weak linking.</p>
<h2>
<a name="c-safe-buffers-3" href="#c-safe-buffers-3"></a>C++ Safe Buffers</h2>
<p>by</p>
<h3>
<a name="programming-model-4" href="#programming-model-4"></a>Programming Model</h3>
<p>We plan to introduce Safe Buffers Programming Model under which any pointer arithmetic is considered unsafe and clang warns about it. While this can be potentially useful for security-critical C projects its main application are C++ codebases in which pointer arithmetic can be transformed to use Hardened libc++ facilities such as <code>std::array</code>, <code>std::vector</code> and <code>std::span</code> that will be bounds-checked at runtime and potential exploits turned into traps.</p>
<p>Our plan is to emit a warning every time an unsafe operation is performed on a raw pointer (largely similar to clang-tidy checks for bounds safety such as <a href="https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/pro-bounds-pointer-arithmetic.html" rel="noopener nofollow ugc">clang-tidy - cppcoreguidelines-pro-bounds-pointer-arithmetic — Extra Clang Tools 16.0.0git documentation</a>).</p>
<p>We plan the warnings to be directly in the compiler, being off-by-default (most likely outside of -Wall as well). This allows us to reach all maintainers of the targeted projects without forcing them to use other clang tools or to regress their build times. In particular, we expect our users to keep the warnings enabled even after they’ve updated all their code, to avoid regressing back to the old ways in the new code. This way these warnings basically form a <em>hardened language mode</em>. That said, we plan to have most of our machinery live in libAnalysis, from which it can be accessed by arbitrary tools or generalized to other use cases.</p>
<p>We are not addressing temporal memory safety violations such as use-after-free / lifetime bugs.</p>
<h3>
<a name="adoption-tooling-5" href="#adoption-tooling-5"></a>Adoption Tooling</h3>
<p>In C++ mode we will also emit fixits that replace one or more variables of raw pointer type with standard containers. Such fixits would also update other uses of these variables if a standard container isn’t an exact drop-in replacement of a raw pointer; for example, <code>if(array_pointer)</code> may be converted to <code>if(span.data())</code>.</p>
<p>The fixits are targeting not only local variables but also <em>parameter</em> variables of pointer type. When we suggest replacing a parameter variable with, say, a <code>std::span</code>, the fixit would keep the old prototype as an overload but mark it deprecated with a custom attribute. Calls to functions wearing that attribute will be treated as unsafe operations in other functions which would in turn cause us to emit a warning at the call site. This way our fixes can spread across function boundaries or even across translation unit boundaries.</p>
<p>We plan to produce a reasonable fixit in the majority of cases to ease adoption. This means that we’re considering <em>fairly sophisticated and novel machinery</em> that analyzes all uses of one or more related variables to discover which container is appropriate and what other code changes will be necessary. We also <em>do not promise that the fixit is going to compile;</em> in some cases we plan to leave placeholders for the user to fill in, such as the size parameter for <code>std::span</code>. Later we may try to improve our machinery to discover the size of the span automatically but we believe that even without that feature the fixits are going to save our users a lot of time.</p>
<h3>
<a name="static-analyzer-checker-6" href="#static-analyzer-checker-6"></a>Static Analyzer Checker</h3>
<p>We are also considering a path-sensitive clang static analyzer checker that warns if <code>std::span</code> is constructed from a container that has smaller size than specified in the span’s constructor. Such checker is self-contained and useful on its own, if everything goes well it’ll be enabled by default for all users. But it will play nicely with this project as it’ll protect the users from accidentally introducing new bugs while refactoring their code.</p>
<p>Comments and suggestions are welcome!</p>
        </div></div>
  </body>
</html>
