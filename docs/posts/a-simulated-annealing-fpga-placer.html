<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stefanabikaram.com/writing/fpga-sa-placer/">Original</a>
    <h1>A Simulated Annealing FPGA Placer</h1>
    
    <div id="readability-page-1" class="page"><div>
            
<p><img src="https://stefanabikaram.com/img/fpga-sa-placer/placer_animation_2.gif" alt="Initial Placement"/>
<img src="https://stefanabikaram.com/img/fpga-sa-placer/placer_animation_4.gif" alt="Initial Placement"/>
<img src="https://stefanabikaram.com/img/fpga-sa-placer/placer_animation_8.gif" alt="Initial Placement"/>
<img src="https://stefanabikaram.com/img/fpga-sa-placer/placer_animation_16.gif" alt="Initial Placement"/>
<img src="https://stefanabikaram.com/img/fpga-sa-placer/placer_animation_32.gif" alt="Initial Placement"/>
<img src="https://stefanabikaram.com/img/fpga-sa-placer/placer_animation_64.gif" alt="Initial Placement"/>
<img src="https://stefanabikaram.com/img/fpga-sa-placer/placer_animation_128.gif" alt="Initial Placement"/>
<img src="https://stefanabikaram.com/img/fpga-sa-placer/placer_animation_256.gif" alt="Initial Placement"/>
</p>
<p>This is about my journey in exploring FPGA placement algorithms as deeply as I can and sharing that with others in the simplest way I can. In the process, I also implemented a really simple toy FPGA placer in Rust. This topic is rarely explained in a clear way all in one place with references and a working implementation due to the topic being too niche yet highly fascinating. This is the motivation for me attempting to write as introductory of a post as I could make it, although still way longer than I hoped. Please note that almost every sentence in this post has additional context, detail, explanation, and complexity not addressed in this post for brevity, so I am most likely aware of many of the details you may point out that I have omitted, simplified, or modified.</p>
<p>I have recently been looking into FPGA placement and routing algorithms as part of my Ph.D. work to use deep learning to model and solve FPGA place-and-route problems directly. In the process, I also delved into the VPR codebase and more recent papers about electrostatic placement and routing tools, such as DreamPlace and the classic PathFinder negotiated congestion router paper. In the process, I was able to slowly pull apart the published research, trace back paper references, and build a mental understanding of the technical details and the history of research on the topic, an all-too-familiar process I have gone through during my Ph.D. It sure would be nice if there was something like this post that could have helped me get started.</p>
<p>I figured since I was already beginning to muck around in this topic area, I might as well have some fun on the side while learning Rust. It turned out to be a nice fit since the implementation of these algorithms is just as critical as the algorithm itself. Data structures and performance are critical since real place-and-route tools work on huge data structures such as netlist graphs and solve equally large and complex black-box optimization problems. Along the way, I don&#39;t want to make any silly, hard-to-debug errors as well, such as loose memory management (like you might in C/C++) or type errors (like you might in Python). Rust is advertised as a language that excels at these things by design, so I put it to the test. I recently wanted to learn Rust and needed to learn Rust. I wanted to learn Rust since we started to see if it would have any benefits in any of the research projects we are working on in my Ph.D. lab. Another student in our lab found great success breaking up parts of a project written in Python using Rust and the PyO3 library. Needing to learn Rust is a bit less cool since I need to know it for work.</p>
<p>In any case, I thought it would be fun to learn Rust by writing a toy simulated annealing FPGA placer.</p>
<p>If you already know what FPGA placement is and the different kinds of FPGA placement approaches and want to jump to the part about my implementation, you can skip to the section &#34;<a href="#my-simulated-annealing-fpga-placer">My Simulated Annealing FPGA Placer</a>&#34;, &#34;<a href="#results-and-visualizations">Results and Visualizations</a>&#34;, and &#34;<a href="#source-code-and-reproducibility">Source Code and Reproducibility</a>&#34;.</p>
<h2 id="what-is-an-fpga-placer%3F" tabindex="-1">What is an FPGA placer?</h2>
<p>FPGA placement is very direct to formulate once you can be patient and build a simplified version of the problem.</p>
<p>I have a netlist graph that represents a circuit where the nodes are different circuit elements and the edges are wires. I also have an FPGA layout which is a 2D grid of spots where I can put a node. Each spot can only hold one circuit element and each spot can only hold one type of circuit element. In my toy prototype, there are only 4 types of circuit elements: CLBs, BRAM, DSP, and IO. Each node in the graph is one of these types and each spot on the FPGA layout can only fit one of these types. For example, some spots on the FPGA layout are only for IOs where I can place IO nodes from my graph on those spots.</p>
<p>Typically, we know that the FPGA layout will have more spots than needed to fit all the nodes in the graph. If this were not the case, we would not be able to fit all the nodes in the graph on the FPGA layout, and we could just stop there and tell the user that the FPGA layout is too small or their netlist is too big.</p>
<p>The goal of a placer is to map every node in your netlist to its own spot on the FPGA layout. If that were it, we could just list all the spots a node can go in and place it on the first available spot. We can then do this for all nodes until we are done.</p>
<p>In reality, after placement, we need to route the placed nodes together on the FPGA according to their edges in the netlist graph. A router will use the output solution generated by a placer to then route signals using the FPGA routing resources between placed nodes on the FPGA. If we randomly place two nodes far apart that are connected in the netlist graph, we will have to route a long wire between them. This is not good for several reasons, including timing and congestion. For this reason, we end up wanting to do this placement while minimizing the &#34;distance&#34; of placed nodes in the FPGA layout that are connected. This last minimizing objective is what makes placement a non-trivial problem.</p>
<h2 id="how-to-solve-fpga-placement%3F" tabindex="-1">How to solve FPGA placement?</h2>
<h3 id="mix-integer-linear-optimization" tabindex="-1">Mix-Integer Linear Optimization</h3>
<p>Given the set of nodes we need to place, the spots they can be placed in, constraints for 1-1 mapping, and constraints for mapping based on the node type, it is pretty cut-and-dry to formulate this problem as a mixed-integer optimization problem which has been studied for many years with solvers at the ready for us to use. The only thing is that we would have to formulate the wire length objective as a linear equation. Luckily, we can just use Manhattan or grid distance to do this (you can use absolute value in the objective of a linear optimization problem under certain cases with certain modeling transformations, including this case). The final objective is the sum of all grid distances between all pairs of placed nodes on the 2D FPGA layout, where the pairs map to all edges in the netlist graph.</p>
<p>This approach sounds nice, but in reality, is not scalable. Let&#39;s say we have an FPGA grid of <mjx-container jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="19.232ex" height="1.946ex" role="img" focusable="false" viewBox="0 -666 8500.7 860" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><use data-c="31" xlink:href="#MJX-TEX-N-31"></use><use data-c="30" xlink:href="#MJX-TEX-N-30" transform="translate(500,0)"></use><use data-c="30" xlink:href="#MJX-TEX-N-30" transform="translate(1000,0)"></use></g><g data-mml-node="mo" transform="translate(1722.2,0)"><use data-c="D7" xlink:href="#MJX-TEX-N-D7"></use></g><g data-mml-node="mn" transform="translate(2722.4,0)"><use data-c="31" xlink:href="#MJX-TEX-N-31"></use><use data-c="30" xlink:href="#MJX-TEX-N-30" transform="translate(500,0)"></use><use data-c="30" xlink:href="#MJX-TEX-N-30" transform="translate(1000,0)"></use></g><g data-mml-node="mo" transform="translate(4500.2,0)"><use data-c="3D" xlink:href="#MJX-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(5556,0)"><use data-c="31" xlink:href="#MJX-TEX-N-31"></use><use data-c="30" xlink:href="#MJX-TEX-N-30" transform="translate(500,0)"></use></g><g data-mml-node="mo" transform="translate(6556,0)"><use data-c="2C" xlink:href="#MJX-TEX-N-2C"></use></g><g data-mml-node="mn" transform="translate(7000.7,0)"><use data-c="30" xlink:href="#MJX-TEX-N-30"></use><use data-c="30" xlink:href="#MJX-TEX-N-30" transform="translate(500,0)"></use><use data-c="30" xlink:href="#MJX-TEX-N-30" transform="translate(1000,0)"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>100</mn><mo>Ã—</mo><mn>100</mn><mo>=</mo><mn>10</mn><mo>,</mo><mn>000</mn></math></mjx-assistive-mml></mjx-container> CLB spots, and we have a <mjx-container jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="5.531ex" height="1.946ex" role="img" focusable="false" viewBox="0 -666 2444.7 860" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><use data-c="35" xlink:href="#MJX-TEX-N-35"></use></g><g data-mml-node="mo" transform="translate(500,0)"><use data-c="2C" xlink:href="#MJX-TEX-N-2C"></use></g><g data-mml-node="mn" transform="translate(944.7,0)"><use data-c="30" xlink:href="#MJX-TEX-N-30"></use><use data-c="30" xlink:href="#MJX-TEX-N-30" transform="translate(500,0)"></use><use data-c="30" xlink:href="#MJX-TEX-N-30" transform="translate(1000,0)"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>5</mn><mo>,</mo><mn>000</mn></math></mjx-assistive-mml></mjx-container>-node netlist of all CLBs to place. We would need an optimization variable that represents a node being placed in each spot. This would result in a <mjx-container jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="30.923ex" height="1.946ex" role="img" focusable="false" viewBox="0 -666 13667.8 860" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><use data-c="31" xlink:href="#MJX-TEX-N-31"></use><use data-c="30" xlink:href="#MJX-TEX-N-30" transform="translate(500,0)"></use><use data-c="30" xlink:href="#MJX-TEX-N-30" transform="translate(1000,0)"></use></g><g data-mml-node="mo" transform="translate(1722.2,0)"><use data-c="D7" xlink:href="#MJX-TEX-N-D7"></use></g><g data-mml-node="mn" transform="translate(2722.4,0)"><use data-c="31" xlink:href="#MJX-TEX-N-31"></use><use data-c="30" xlink:href="#MJX-TEX-N-30" transform="translate(500,0)"></use><use data-c="30" xlink:href="#MJX-TEX-N-30" transform="translate(1000,0)"></use></g><g data-mml-node="mo" transform="translate(4444.7,0)"><use data-c="D7" xlink:href="#MJX-TEX-N-D7"></use></g><g data-mml-node="mn" transform="translate(5444.9,0)"><use data-c="35" xlink:href="#MJX-TEX-N-35"></use><use data-c="30" xlink:href="#MJX-TEX-N-30" transform="translate(500,0)"></use><use data-c="30" xlink:href="#MJX-TEX-N-30" transform="translate(1000,0)"></use><use data-c="30" xlink:href="#MJX-TEX-N-30" transform="translate(1500,0)"></use></g><g data-mml-node="mo" transform="translate(7722.7,0)"><use data-c="3D" xlink:href="#MJX-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(8778.4,0)"><use data-c="35" xlink:href="#MJX-TEX-N-35"></use><use data-c="30" xlink:href="#MJX-TEX-N-30" transform="translate(500,0)"></use></g><g data-mml-node="mo" transform="translate(9778.4,0)"><use data-c="2C" xlink:href="#MJX-TEX-N-2C"></use></g><g data-mml-node="mn" transform="translate(10223.1,0)"><use data-c="30" xlink:href="#MJX-TEX-N-30"></use><use data-c="30" xlink:href="#MJX-TEX-N-30" transform="translate(500,0)"></use><use data-c="30" xlink:href="#MJX-TEX-N-30" transform="translate(1000,0)"></use></g><g data-mml-node="mo" transform="translate(11723.1,0)"><use data-c="2C" xlink:href="#MJX-TEX-N-2C"></use></g><g data-mml-node="mn" transform="translate(12167.8,0)"><use data-c="30" xlink:href="#MJX-TEX-N-30"></use><use data-c="30" xlink:href="#MJX-TEX-N-30" transform="translate(500,0)"></use><use data-c="30" xlink:href="#MJX-TEX-N-30" transform="translate(1000,0)"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>100</mn><mo>Ã—</mo><mn>100</mn><mo>Ã—</mo><mn>5000</mn><mo>=</mo><mn>50</mn><mo>,</mo><mn>000</mn><mo>,</mo><mn>000</mn></math></mjx-assistive-mml></mjx-container> variable optimization problem. Real FPGAs and netlists are much larger than this. Therefore, the runtime of the solver is certainly not going to be great, and solvers will not be able to handle real-world sized problems. We could possibly make this more tractable by looking at non-linear formulation and relaxations of the problem that are not completely black-box to the solvers, but I have not gone down this rabbit hole yet.</p>
<h3 id="analytic-and-electrostatic-placement" tabindex="-1">Analytic and Electrostatic Placement</h3>
<p>Analytic placement is a neat and practical solution to FPGA placement.</p>
<p>It originates from the idea of replacing both the objective function of wirelength and the constraints of non-overlapping placement using equivalent continuous formulations. It relaxes the fixed constraint nature of the FPGA problem to the continuous domain where locations and distances can be continuous values. By doing so, we can define the objective as a sum of distances of all the nodes using a distance function like Euclidean distance, or new functions like squared distance (<mjx-container jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.528ex" height="1.887ex" role="img" focusable="false" viewBox="0 -833.9 1117.6 833.9" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><use data-c="1D43F" xlink:href="#MJX-TEX-I-1D43F"></use></g><g data-mml-node="mn" transform="translate(714,363) scale(0.707)"><use data-c="32" xlink:href="#MJX-TEX-N-32"></use></g></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>L</mi><mn>2</mn></msup></math></mjx-assistive-mml></mjx-container> space), and formulate the non-overlapping constraint as another objective function that models the density, &#34;overlappingness&#34;, or &#34;close-togetherness&#34; of nodes (there are different ways to model this density component, but that is another rabbit hole to explore). This objective is referred to as the density penalty or density function.</p>
<p>To then solve placement, you optimize a new objective function which is equal to the wire length objective function plus some density function with a weight lambda. Lambda here controls the strength of the density function which you can control through the optimization to enforce legal placement or &#34;spreading out&#34; of nodes. Since this is a continuous problem, we can use a gradient-based optimization method to solve it, which has also been studied for a long time and has many solvers ready to use.</p>
<p>Up to this point, many in the field would broadly consider this approach to be an &#34;analytical placer&#34;. However, we can take this one step further and make it an electrostatic placer. It models the entire system as an electrostatic system where the nodes are equivalent to positive charges, and the density function is equivalent to the electric potential. From here, you can then drive the particles to a location that minimizes the electric potential using the electric field itself as the gradient which &#34;pushes&#34; the nodes in the desired direction to spread out and settle into a final location.</p>
<p>With this approach, there are algorithmic components mixed in. An electrostatic placer can be used to get good enough continuous placement solutions but with some overlap or not fully aligned to the exact grid locations of the FPGA. We must then use a legalizer to &#34;snap&#34; the nodes to spots on the FPGA grid.</p>
<p>I won&#39;t go into much more detail, but there are many papers on both analytical and electrostatic placement and more are currently still being published on the topic. To the best of my understanding, electrostatic placement is the state of the art for at least ASIC placement and FPGA placement (I think, based on current academic publications and my educated guessing).</p>
<h3 id="simulated-annealing" tabindex="-1">Simulated Annealing</h3>
<p>Compared to the previously described approaches for placement, simulated annealing (SA) takes more of a top-down black-box approach to the problem. In fact, simulated annealing is a misnomer as you don&#39;t really need the &#34;annealing&#34; part to make it work for the FPGA placement problem.</p>
<p>In a traditional optimization context, simulated annealing models a problem as a system with a given current solution. Then we can jump to another solution and see if that solution is better. If the new solution is better, then we can pick that as our new current solution.</p>
<p>Now my use of the word &#34;jump&#34; is very loose. A simple thing to do is jump around randomly to other solutions and see if I can find anything better. However, the smarter idea and core of simulated annealing is to assign possible solutions to probabilities. Nearby solutions with small jumps are more likely to be picked than jumps to faraway solutions. At the beginning of the optimization, faraway solutions are defined as more probable, allowing us to jump around all over the place. But as time goes on, we can make faraway jumps less probable and make the jumps we take more likely to be close solutions. This is the &#34;annealing&#34; part of simulated annealing, whose name is derived from the physical process of annealing, repeatedly heating and cooling, metal.</p>
<p>In the context of FPGA placement, we can model the &#34;current solution&#34; as a valid placement solution of all nodes, and a &#34;jump&#34; as making a change to the current placement solution. This change can be picked from a set of actions such as swapping the location of two random nodes of the same type or moving a random node to another valid location. The objective is still the sum of the wirelengths of all the edges of nodes in the placed solution. We can then evaluate whether to accept or reject a move based on whether that move decreases the value of our objective function. In other words, a move creates a new solution with a lower objective function value than the current solution, we accept that move and keep going with new moves. If the move creates a new solution with a higher objective function value than the current solution, we reject that move, keep the current solution, and try another move.</p>
<p>The annealing part comes in when determining how far to move a node or how far away the two nodes we pick to swap are. At first, you might want to make moves or swaps over large distances or you might want to accept some percent of moves that don&#39;t improve the objective, but as time goes on, you want to make smaller moves and be less likely to select moves that don&#39;t improve the objective. This is the &#34;annealing&#34; part of simulated annealing in the context of FPGA placement. In this example, we have a linear annealing schedule with a higher &#34;temperature&#34; at the beginning and a lower &#34;temperature&#34; at the end. Temperature in this case is linked to the probability of accepting a move that does not improve the objective function or making moves that are further away.</p>
<p>However, as it turns out, you technically don&#39;t need this annealing part to make FPGA placement work. You can just randomly try different moves and accept or reject them based on whether they improve the objective function. This is what I did in my toy implementation of an FPGA placer just to keep it simple.</p>
<p>VTR/VPR is a popular academic FPGA EDA flow (with synthesis, packing, placement, and routing) that uses simulated annealing for its FPGA placer. They (the VPR authors) have many papers that talk about the details of their implementation, such as the actions they use and how they schedule the annealing part. They also have a more complex set of moves and ways to pick moves between nodes within a certain distance of each other. In more recent times, they have also explored using simple reinforcement learning techniques to learn how to pick which moves to make at each step.</p>
<h2 id="my-simulated-annealing-fpga-placer" tabindex="-1">My Simulated Annealing FPGA Placer</h2>
<h3 id="specifications" tabindex="-1">Specifications</h3>
<p>My placer includes several components and simplifications to the problem:</p>
<ul>
<li>I consider only four types of nodes to place: <code>CLB</code>, <code>BRAM</code>, <code>DSP</code>, and <code>IO</code>.</li>
<li>My netlist graph contains nodes and edges:
<ul>
<li>Each node is one of the four types.</li>
<li>Each edge represents a connection between two nodes, meaning they will need to be routed together later.</li>
</ul>
</li>
<li>My FPGA layout is a 2D grid of spots:
<ul>
<li>Each spot can hold only one node.</li>
<li>Each spot is designated for a specific type.</li>
<li>Each node can be placed only on a spot that matches its type.</li>
<li>An FPGA layout spot can also be of a special type, <code>EMPTY</code>, which means no node can be placed there.</li>
</ul>
</li>
<li>My simulated annealing solver is simple and does not include annealing:
<ul>
<li>There are three types of moves:
<ul>
<li>Swap two nodes of the same type.</li>
<li>Move a node to a random spot of the same type.</li>
<li>Move a node to a spot of the same type that is close to the centroid of all the nodes in the netlist graph.</li>
</ul>
</li>
<li>The objective function is the sum of the wire lengths of all the edges in the netlist graph.
<ul>
<li>The distance between two nodes is the Manhattan distance between the spots they are placed on.</li>
</ul>
</li>
<li>I accept a move if it improves the objective function.</li>
<li>For any step, I can try <code>n_neighbors</code> different random moves on the current solution and pick the best one.</li>
<li>A random initial placement must be provided to the placer to start with.</li>
</ul>
</li>
</ul>
<h3 id="netlist-graph" tabindex="-1">Netlist Graph</h3>
<p>Initially, I wanted to model the netlist as a directed hypergraph. In the truest definition, circuits are really directed hypergraphs since one output can split off and go to multiple inputs. The wire that connects a single output to many inputs is the edge and encompasses all nodes.</p>
<p>However, I ended up not using hypergraphs in the final prototype for two reasons.</p>
<p>First, to do things properly, I needed to handle the extra complexity of nodes with ports and edges between nodes but only to certain ports. In digital circuits, a component such as a 4-input LUT will have 5 ports for wires to go &#34;in to&#34; and &#34;out of&#34; the component. You could model the component as a node, but then an edge actually connects to a port on the node rather than the entire node. Deciding how to model this can get a bit complex, and I did not want to think too hard about it.</p>
<p>Second, there were no directed hypergraph libraries or at least the existing hypergraph libraries were not well documented enough to find the directed versions or missing features I would expect a graph library to have. I looked into <code>hypergraph</code> and <code>mhgl</code>, but as mentioned, there was no support for directed hypergraphs.</p>
<p>The reason I wanted to support directed hypergraphs is that I also wanted to possibly model signal direction in the future. For example, I want the output pin of a 4-input LUT to be the source and the downstream node input pins to be the sink in the hyperedge. I&#39;m not sure this makes a difference for this toy placement problem, but I wanted to keep this in mind if I extended my prototype to also include a router. I wrote a very crude directed hypergraph module with a bad implementation, so I ended up not using it.</p>
<p>I settled on modeling the netlist as a directed graph of abstract nodes with the 4 node types I decided on in my specifications.</p>
<pre tabindex="0"><code><span><span>#[derive(</span><span>Clone</span><span>, </span><span>Hash</span><span>, </span><span>PartialEq</span><span>, </span><span>Eq</span><span>, </span><span>Debug</span><span>, </span><span>Copy</span><span>)]</span></span>
<span><span>pub</span><span> </span><span>enum</span><span> </span><span>MacroType</span><span> {</span></span>
<span><span>    </span><span>CLB</span><span>,</span></span>
<span><span>    </span><span>DSP</span><span>,</span></span>
<span><span>    </span><span>BRAM</span><span>,</span></span>
<span><span>    </span><span>IO</span><span>,</span></span>
<span><span>}</span></span>
<span></span>
<span><span>#[derive(</span><span>Clone</span><span>, </span><span>Hash</span><span>, </span><span>PartialEq</span><span>, </span><span>Eq</span><span>, </span><span>Debug</span><span>, </span><span>Copy</span><span>)]</span></span>
<span><span>pub</span><span> </span><span>struct</span><span> </span><span>NetlistNode</span><span> {</span></span>
<span><span>    </span><span>pub</span><span> id</span><span>:</span><span> </span><span>u32</span><span>,</span></span>
<span><span>    </span><span>pub</span><span> macro_type</span><span>:</span><span> </span><span>MacroType</span><span>,</span></span>
<span><span>}</span></span>
<span></span>
<span><span>#[derive(</span><span>Debug</span><span>, </span><span>Clone</span><span>)]</span></span>
<span><span>pub</span><span> </span><span>struct</span><span> </span><span>NetlistGraph</span><span> {</span></span>
<span><span>    </span><span>pub</span><span> graph</span><span>:</span><span> </span><span>petgraph</span><span>::</span><span>graph</span><span>::</span><span>DiGraph</span><span>&lt;</span><span>NetlistNode</span><span>, ()&gt;,</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>I used the <code>petagraph</code> library for the graph itself. This is where I first encountered the Rust type system in a delightful way, via generics. I am able to pass a node type parameter to a Petagraph DiGraph struct, and it will now automatically enforce that type and code completion in my editor to that type when accessing nodes in the graph. I was so used to Python that it felt really cool to see it in action using Rust, even considering the fact that I use Mypy and type hints in Python.</p>
<p>I also implemented some simpler helper functions to obtain a summary of nodes.</p>
<pre tabindex="0"><code><span><span>impl</span><span> </span><span>NetlistGraph</span><span> {</span></span>
<span><span>    </span><span>fn</span><span> </span><span>new</span><span>() </span><span>-&gt;</span><span> </span><span>NetlistGraph</span><span> {</span></span>
<span><span>        </span><span>NetlistGraph</span><span> {</span></span>
<span><span>            graph</span><span>:</span><span> </span><span>petgraph</span><span>::</span><span>graph</span><span>::</span><span>DiGraph</span><span>::</span><span>new</span><span>(),</span></span>
<span><span>        }</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    </span><span>pub</span><span> </span><span>fn</span><span> </span><span>all_nodes</span><span>(</span><span>&amp;</span><span>self</span><span>) </span><span>-&gt;</span><span> </span><span>Vec</span><span>&lt;</span><span>NetlistNode</span><span>&gt; {</span></span>
<span><span>        </span><span>...</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    </span><span>pub</span><span> </span><span>fn</span><span> </span><span>count_summary</span><span>(</span><span>&amp;</span><span>self</span><span>) </span><span>-&gt;</span><span> </span><span>FxHashMap</span><span>&lt;</span><span>MacroType</span><span>, </span><span>u32</span><span>&gt; {</span></span>
<span><span>        </span><span>...</span></span>
<span><span>    }</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>In addition, I used <code>rustworkx-core</code> for random netlists graph generation to build to test the placer later on. The <code>build_simple_netlist</code> function builds an ErdÅ‘s-RÃ©nyi random graph. You can parameterize this kind of random graph with the number of nodes and the probability of an edge between two nodes.</p>
<p>This won&#39;t model the properties of real netlist graphs but will be good enough to at least test the placer. In real netlists, you might have highly connected clusters of nodes that represent different hardware modules in your design. These modules are connected via buses of wires and composed together. However, even this high-level &#34;module hierarchy&#34; graph structure is modified and optimized into a new graph after synthesis and technology mapping.</p>
<p>I have omitted some of the non-essential parts of the code for this.</p>
<pre tabindex="0"><code><span><span>pub</span><span> </span><span>fn</span><span> </span><span>build_simple_netlist</span><span>(n_nodes</span><span>:</span><span> </span><span>u32</span><span>, n_io</span><span>:</span><span> </span><span>u32</span><span>, n_bram</span><span>:</span><span> </span><span>u32</span><span>) </span><span>-&gt;</span><span> </span><span>NetlistGraph</span><span> {</span></span>
<span><span>    </span><span>let</span><span> </span><span>mut</span><span> netlist </span><span>=</span><span> </span><span>NetlistGraph</span><span> {</span></span>
<span><span>        graph</span><span>:</span><span> </span><span>gnp_random_graph</span><span>(</span></span>
<span><span>            n_nodes </span><span>as</span><span> </span><span>usize</span><span>,</span></span>
<span><span>            </span><span>0.02</span><span>,</span></span>
<span><span>            </span><span>None</span><span>,</span></span>
<span><span>            </span><span>||</span><span> </span><span>NetlistNode</span><span> {</span></span>
<span><span>                id</span><span>:</span><span> </span><span>rand</span><span>::</span><span>thread_rng</span><span>()</span><span>.</span><span>gen</span><span>(),</span></span>
<span><span>                macro_type</span><span>:</span><span> </span><span>MacroType</span><span>::</span><span>CLB</span><span>,</span></span>
<span><span>            },</span></span>
<span><span>            </span><span>||</span><span> (),</span></span>
<span><span>        )</span></span>
<span><span>        </span><span>.</span><span>unwrap</span><span>(),</span></span>
<span><span>    };</span></span>
<span></span>
<span><span>    // pick n_io random clbs and change their type to io</span></span>
<span><span>    // use choose_multiple to avoid duplicates</span></span>
<span><span>    </span><span>...</span></span>
<span></span>
<span><span>    // pick n_bram random clbs and change their type to bram</span></span>
<span><span>    // use choose_multiple to avoid duplicates</span></span>
<span><span>    </span><span>...</span></span>
<span></span>
<span><span>    // connect any disconnected nodes</span></span>
<span><span>    </span><span>...</span></span>
<span></span>
<span><span>    netlist</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<h3 id="fpga-layout" tabindex="-1">FPGA Layout</h3>
<p>I modeled the FPGA layout as an <code>FPGALayout</code> type which contains a hashmap of <code>FPGALayoutCoordinate</code> types to <code>FPGALayoutType</code>. This way I can query the locations of nodes in the FPGA layout by their coordinates which would not be as eddicent as a giant 2D array or vector of vectors.</p>
<p>Additionally, I store the width and height of the FPGA layout that work with some helper functions to query any point in the layout with special logic to return <code>FPGALayoutType::EMPTY</code> if the coordinate is not in the hashmap or <code>None</code> if the coordinate is out of bounds.</p>
<p>There are also some helper functions to set different patterns of <code>FPGALayoutType</code> in the layout, such as <code>config_corners</code>, <code>config_border</code>, and <code>config_repeat</code>. These make things like setting all the outer edges of the FPGA layout to <code>FPGALayoutType::IO</code> or setting a repeating pattern of spaced <code>FPGALayoutType::BRAM</code> columns easy.</p>
<pre tabindex="0"><code><span><span>#[derive(</span><span>Clone</span><span>, </span><span>Hash</span><span>, </span><span>PartialEq</span><span>, </span><span>Eq</span><span>, </span><span>Debug</span><span>, </span><span>Copy</span><span>)]</span></span>
<span><span>pub</span><span> </span><span>enum</span><span> </span><span>MacroType</span><span> {</span></span>
<span><span>    </span><span>CLB</span><span>,</span></span>
<span><span>    </span><span>DSP</span><span>,</span></span>
<span><span>    </span><span>BRAM</span><span>,</span></span>
<span><span>    </span><span>IO</span><span>,</span></span>
<span><span>}</span></span>
<span></span>
<span><span>#[derive(</span><span>Clone</span><span>, </span><span>Hash</span><span>, </span><span>PartialEq</span><span>, </span><span>Eq</span><span>, </span><span>Debug</span><span>)]</span></span>
<span><span>pub</span><span> </span><span>enum</span><span> </span><span>FPGALayoutType</span><span> {</span></span>
<span><span>    </span><span>MacroType</span><span>(</span><span>MacroType</span><span>),</span></span>
<span><span>    </span><span>EMPTY</span><span>,</span></span>
<span><span>}</span></span>
<span></span>
<span><span>#[derive(</span><span>Eq</span><span>, </span><span>Hash</span><span>, </span><span>PartialEq</span><span>, </span><span>Clone</span><span>, </span><span>Copy</span><span>, </span><span>Debug</span><span>)]</span></span>
<span><span>pub</span><span> </span><span>struct</span><span> </span><span>FPGALayoutCoordinate</span><span> {</span></span>
<span><span>    </span><span>pub</span><span> x</span><span>:</span><span> </span><span>u32</span><span>,</span></span>
<span><span>    </span><span>pub</span><span> y</span><span>:</span><span> </span><span>u32</span><span>,</span></span>
<span><span>}</span></span>
<span></span>
<span><span>impl</span><span> </span><span>FPGALayoutCoordinate</span><span> {</span></span>
<span><span>    </span><span>pub</span><span> </span><span>fn</span><span> </span><span>new</span><span>(x</span><span>:</span><span> </span><span>u32</span><span>, y</span><span>:</span><span> </span><span>u32</span><span>) </span><span>-&gt;</span><span> </span><span>FPGALayoutCoordinate</span><span> {</span></span>
<span><span>        </span><span>FPGALayoutCoordinate</span><span> { x, y }</span></span>
<span><span>    }</span></span>
<span><span>}</span></span>
<span></span>
<span><span>#[derive(</span><span>Debug</span><span>, </span><span>Clone</span><span>)]</span></span>
<span><span>pub</span><span> </span><span>struct</span><span> </span><span>FPGALayout</span><span> {</span></span>
<span><span>    </span><span>pub</span><span> map</span><span>:</span><span> </span><span>FxHashMap</span><span>&lt;</span><span>FPGALayoutCoordinate</span><span>, </span><span>FPGALayoutType</span><span>&gt;,</span></span>
<span><span>    </span><span>pub</span><span> width</span><span>:</span><span> </span><span>u32</span><span>,</span></span>
<span><span>    </span><span>pub</span><span> height</span><span>:</span><span> </span><span>u32</span><span>,</span></span>
<span><span>}</span></span>
<span></span>
<span><span>impl</span><span> </span><span>FPGALayout</span><span> {</span></span>
<span><span>    </span><span>pub</span><span> </span><span>fn</span><span> </span><span>new</span><span>(width</span><span>:</span><span> </span><span>u32</span><span>, height</span><span>:</span><span> </span><span>u32</span><span>) </span><span>-&gt;</span><span> </span><span>FPGALayout</span><span> {</span></span>
<span><span>        </span><span>FPGALayout</span><span> {</span></span>
<span><span>            map</span><span>:</span><span> </span><span>FxHashMap</span><span>::</span><span>default</span><span>(),</span></span>
<span><span>            width,</span></span>
<span><span>            height,</span></span>
<span><span>        }</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    </span><span>pub</span><span> </span><span>fn</span><span> </span><span>config_corners</span><span>(</span><span>&amp;mut</span><span> </span><span>self</span><span>, layout_type</span><span>:</span><span> </span><span>FPGALayoutType</span><span>) {</span></span>
<span><span>        </span><span>...</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    </span><span>pub</span><span> </span><span>fn</span><span> </span><span>config_border</span><span>(</span><span>&amp;mut</span><span> </span><span>self</span><span>, layout_type</span><span>:</span><span> </span><span>FPGALayoutType</span><span>) {</span></span>
<span><span>        </span><span>...</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    </span><span>pub</span><span> </span><span>fn</span><span> </span><span>config_repeat</span><span>(</span></span>
<span><span>        </span><span>&amp;mut</span><span> </span><span>self</span><span>,</span></span>
<span><span>        x</span><span>:</span><span> </span><span>u32</span><span>,</span></span>
<span><span>        y</span><span>:</span><span> </span><span>u32</span><span>,</span></span>
<span><span>        width</span><span>:</span><span> </span><span>u32</span><span>,</span></span>
<span><span>        height</span><span>:</span><span> </span><span>u32</span><span>,</span></span>
<span><span>        step_x</span><span>:</span><span> </span><span>u32</span><span>,</span></span>
<span><span>        step_y</span><span>:</span><span> </span><span>u32</span><span>,</span></span>
<span><span>        layout_type</span><span>:</span><span> </span><span>FPGALayoutType</span><span>,</span></span>
<span><span>    ) {</span></span>
<span><span>        </span><span>...</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    </span><span>pub</span><span> </span><span>fn</span><span> </span><span>valid</span><span>(</span><span>&amp;mut</span><span> </span><span>self</span><span>) </span><span>-&gt;</span><span> </span><span>bool</span><span> {</span></span>
<span><span>        </span><span>...</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    </span><span>pub</span><span> </span><span>fn</span><span> </span><span>get</span><span>(</span><span>&amp;</span><span>self</span><span>, coordinate</span><span>:</span><span> </span><span>&amp;</span><span>FPGALayoutCoordinate</span><span>) </span><span>-&gt;</span><span> </span><span>Option</span><span>&lt;</span><span>FPGALayoutType</span><span>&gt; {</span></span>
<span><span>        </span><span>if</span><span> coordinate</span><span>.</span><span>x </span><span>&gt;=</span><span> </span><span>self</span><span>.</span><span>width </span><span>||</span><span> coordinate</span><span>.</span><span>y </span><span>&gt;=</span><span> </span><span>self</span><span>.</span><span>height {</span></span>
<span><span>            </span><span>return</span><span> </span><span>None</span><span>;</span></span>
<span><span>        }</span></span>
<span><span>        </span><span>if</span><span> </span><span>!</span><span>self</span><span>.</span><span>map</span><span>.</span><span>contains_key</span><span>(coordinate) {</span></span>
<span><span>            </span><span>return</span><span> </span><span>Some</span><span>(</span><span>FPGALayoutType</span><span>::</span><span>EMPTY</span><span>);</span></span>
<span><span>        }</span></span>
<span><span>        </span><span>self</span><span>.</span><span>map</span><span>.</span><span>get</span><span>(coordinate)</span><span>.</span><span>cloned</span><span>()</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    </span><span>pub</span><span> </span><span>fn</span><span> </span><span>count_summary</span><span>(</span><span>&amp;</span><span>self</span><span>) </span><span>-&gt;</span><span> </span><span>FxHashMap</span><span>&lt;</span><span>FPGALayoutType</span><span>, </span><span>u32</span><span>&gt; {</span></span>
<span><span>        </span><span>...</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    </span><span>pub</span><span> </span><span>fn</span><span> </span><span>render_summary</span><span>(</span><span>&amp;mut</span><span> </span><span>self</span><span>) </span><span>-&gt;</span><span> </span><span>String</span><span> {</span></span>
<span><span>        </span><span>...</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    </span><span>pub</span><span> </span><span>fn</span><span> </span><span>render_ascii</span><span>(</span><span>&amp;</span><span>self</span><span>) </span><span>-&gt;</span><span> </span><span>String</span><span> {</span></span>
<span><span>        </span><span>...</span></span>
<span><span>    }</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>There is also a simple helper function to generate a simple test FPGA layout with, IOs on the outer edges (except for the corners), CLBs filled in the middle, and BRAMs in the middle every 10 columns.</p>
<pre tabindex="0"><code><span><span>pub</span><span> </span><span>fn</span><span> </span><span>build_simple_fpga_layout</span><span>(width</span><span>:</span><span> </span><span>u32</span><span>, height</span><span>:</span><span> </span><span>u32</span><span>) </span><span>-&gt;</span><span> </span><span>FPGALayout</span><span> {</span></span>
<span><span>    </span><span>let</span><span> </span><span>mut</span><span> layout </span><span>=</span><span> </span><span>FPGALayout</span><span>::</span><span>new</span><span>(width, height);</span></span>
<span></span>
<span><span>    layout</span><span>.</span><span>config_border</span><span>(</span><span>FPGALayoutType</span><span>::</span><span>MacroType</span><span>(</span><span>MacroType</span><span>::</span><span>IO</span><span>));</span></span>
<span><span>    layout</span><span>.</span><span>config_corners</span><span>(</span><span>FPGALayoutType</span><span>::</span><span>EMPTY</span><span>);</span></span>
<span><span>    layout</span><span>.</span><span>config_repeat</span><span>(</span></span>
<span><span>        </span><span>1</span><span>,</span></span>
<span><span>        </span><span>1</span><span>,</span></span>
<span><span>        width </span><span>-</span><span> </span><span>2</span><span>,</span></span>
<span><span>        height </span><span>-</span><span> </span><span>2</span><span>,</span></span>
<span><span>        </span><span>1</span><span>,</span></span>
<span><span>        </span><span>1</span><span>,</span></span>
<span><span>        </span><span>FPGALayoutType</span><span>::</span><span>MacroType</span><span>(</span><span>MacroType</span><span>::</span><span>CLB</span><span>),</span></span>
<span><span>    );</span></span>
<span></span>
<span><span>    // evey 10 columns should be BRAM</span></span>
<span><span>    layout</span><span>.</span><span>config_repeat</span><span>(</span></span>
<span><span>        </span><span>10</span><span>,</span></span>
<span><span>        </span><span>1</span><span>,</span></span>
<span><span>        width </span><span>-</span><span> </span><span>2</span><span>,</span></span>
<span><span>        height </span><span>-</span><span> </span><span>2</span><span>,</span></span>
<span><span>        </span><span>10</span><span>,</span></span>
<span><span>        </span><span>1</span><span>,</span></span>
<span><span>        </span><span>FPGALayoutType</span><span>::</span><span>MacroType</span><span>(</span><span>MacroType</span><span>::</span><span>BRAM</span><span>),</span></span>
<span><span>    );</span></span>
<span></span>
<span><span>    </span><span>assert!</span><span>(layout</span><span>.</span><span>valid</span><span>());</span></span>
<span></span>
<span><span>    layout</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<h3 id="the-placement-solution" tabindex="-1">The Placement Solution</h3>
<p>I decided to model the solution as a <code>PlacementSolution</code> type that holds a reference to a netlist graph, a reference to an FPGA layout, and a hashmap of <code>NetlistNode</code> to <code>FPGALayoutCoordinate</code>. The actual core of the solution lies in the hashmap since that tells you where each node in the netlist is placed on the FPGA layout.</p>
<pre tabindex="0"><code><span><span>#[derive(</span><span>Debug</span><span>, </span><span>Clone</span><span>)]</span></span>
<span><span>pub</span><span> </span><span>struct</span><span> </span><span>PlacementSolution</span><span>&lt;&#39;</span><span>a</span><span>&gt; {</span></span>
<span><span>    </span><span>pub</span><span> layout</span><span>:</span><span> </span><span>&amp;</span><span>&#39;</span><span>a</span><span> </span><span>FPGALayout</span><span>,</span></span>
<span><span>    </span><span>pub</span><span> netlist</span><span>:</span><span> </span><span>&amp;</span><span>&#39;</span><span>a</span><span> </span><span>NetlistGraph</span><span>,</span></span>
<span><span>    </span><span>pub</span><span> solution_map</span><span>:</span><span> </span><span>FxHashMap</span><span>&lt;</span><span>NetlistNode</span><span>, </span><span>FPGALayoutCoordinate</span><span>&gt;,</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>Rather than showing the full implementation for this type, I will show selected parts of the implementation that are relevant to the placer.</p>
<p>First is the placement actions and action functions.</p>
<pre tabindex="0"><code><span><span>#[derive(</span><span>Debug</span><span>, </span><span>Clone</span><span>, </span><span>Copy</span><span>)]</span></span>
<span><span>pub</span><span> </span><span>enum</span><span> </span><span>PlacementAction</span><span> {</span></span>
<span><span>    </span><span>MOVE</span><span>,</span></span>
<span><span>    </span><span>SWAP</span><span>,</span></span>
<span><span>    </span><span>MOVE_DIRECTED</span><span>,</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>The simplest action is to move a node to a random empty valid location.</p>
<pre tabindex="0"><code><span><span>pub</span><span> </span><span>fn</span><span> </span><span>action_move</span><span>(</span><span>&amp;mut</span><span> </span><span>self</span><span>) {</span></span>
<span><span>    </span><span>let</span><span> </span><span>mut</span><span> rng </span><span>=</span><span> </span><span>rand</span><span>::</span><span>thread_rng</span><span>();</span></span>
<span></span>
<span><span>    // Randomly select a node</span></span>
<span><span>    </span><span>let</span><span> node </span><span>=</span><span> </span><span>match</span><span> </span><span>self</span><span>.</span><span>netlist</span><span>.</span><span>all_nodes</span><span>()</span><span>.</span><span>choose</span><span>(</span><span>&amp;mut</span><span> rng) {</span></span>
<span><span>        </span><span>Some</span><span>(n) </span><span>=&gt;</span><span> n</span><span>.</span><span>clone</span><span>(),</span></span>
<span><span>        </span><span>None</span><span> </span><span>=&gt;</span><span> </span><span>return</span><span>,</span></span>
<span><span>    };</span></span>
<span></span>
<span><span>    // Get possible sites</span></span>
<span><span>    </span><span>let</span><span> possible_sites </span><span>=</span><span> </span><span>self</span><span>.</span><span>get_possible_sites</span><span>(node</span><span>.</span><span>macro_type);</span></span>
<span></span>
<span><span>    // Return if there are no possible sites</span></span>
<span><span>    </span><span>if</span><span> possible_sites</span><span>.</span><span>is_empty</span><span>() {</span></span>
<span><span>        </span><span>return</span><span>;</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    // Randomly select a location</span></span>
<span><span>    </span><span>let</span><span> location </span><span>=</span><span> </span><span>match</span><span> possible_sites</span><span>.</span><span>choose</span><span>(</span><span>&amp;mut</span><span> rng) {</span></span>
<span><span>        </span><span>Some</span><span>(l) </span><span>=&gt;</span><span> l</span><span>.</span><span>clone</span><span>(),</span></span>
<span><span>        </span><span>None</span><span> </span><span>=&gt;</span><span> </span><span>return</span><span>,</span></span>
<span><span>    };</span></span>
<span></span>
<span><span>    </span><span>self</span><span>.</span><span>solution_map</span><span>.</span><span>insert</span><span>(node, location);</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>The next action is to swap the locations of two nodes of the same type.</p>
<pre tabindex="0"><code><span><span>pub</span><span> </span><span>fn</span><span> </span><span>action_swap</span><span>(</span><span>&amp;mut</span><span> </span><span>self</span><span>) {</span></span>
<span><span>    </span><span>let</span><span> </span><span>mut</span><span> rng </span><span>=</span><span> </span><span>rand</span><span>::</span><span>thread_rng</span><span>();</span></span>
<span></span>
<span><span>    // Randomly select a node</span></span>
<span><span>    </span><span>let</span><span> node_a </span><span>=</span><span> </span><span>match</span><span> </span><span>self</span><span>.</span><span>netlist</span><span>.</span><span>all_nodes</span><span>()</span><span>.</span><span>choose</span><span>(</span><span>&amp;mut</span><span> rng) {</span></span>
<span><span>        </span><span>Some</span><span>(n) </span><span>=&gt;</span><span> n</span><span>.</span><span>clone</span><span>(),</span></span>
<span><span>        </span><span>None</span><span> </span><span>=&gt;</span><span> </span><span>return</span><span>,</span></span>
<span><span>    };</span></span>
<span></span>
<span><span>    // Filter nodes of the same type</span></span>
<span><span>    </span><span>let</span><span> nodes_same_type</span><span>:</span><span> </span><span>Vec</span><span>&lt;</span><span>NetlistNode</span><span>&gt; </span><span>=</span><span> </span><span>self</span></span>
<span><span>        </span><span>.</span><span>netlist</span></span>
<span><span>        </span><span>.</span><span>all_nodes</span><span>()</span></span>
<span><span>        </span><span>.</span><span>iter</span><span>()</span></span>
<span><span>        </span><span>.</span><span>filter</span><span>(</span><span>|&amp;&amp;</span><span>node</span><span>|</span><span> node</span><span>.</span><span>macro_type </span><span>==</span><span> node_a</span><span>.</span><span>macro_type)</span></span>
<span><span>        </span><span>.</span><span>cloned</span><span>()</span></span>
<span><span>        </span><span>.</span><span>collect</span><span>();</span></span>
<span></span>
<span><span>    // If no nodes of the same type, return</span></span>
<span><span>    </span><span>if</span><span> nodes_same_type</span><span>.</span><span>is_empty</span><span>() {</span></span>
<span><span>        </span><span>return</span><span>;</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    // Randomly select another node (node_b) of the same type</span></span>
<span><span>    </span><span>let</span><span> node_b </span><span>=</span><span> </span><span>match</span><span> nodes_same_type</span><span>.</span><span>choose</span><span>(</span><span>&amp;mut</span><span> rng) {</span></span>
<span><span>        </span><span>Some</span><span>(n) </span><span>=&gt;</span><span> n</span><span>.</span><span>clone</span><span>(),</span></span>
<span><span>        </span><span>None</span><span> </span><span>=&gt;</span><span> </span><span>return</span><span>,</span></span>
<span><span>    };</span></span>
<span></span>
<span><span>    // Clone the locations first to avoid borrowing issues</span></span>
<span><span>    </span><span>let</span><span> loc_a </span><span>=</span><span> </span><span>self</span><span>.</span><span>solution_map</span><span>.</span><span>get</span><span>(</span><span>&amp;</span><span>node_a)</span><span>.</span><span>cloned</span><span>();</span></span>
<span><span>    </span><span>let</span><span> loc_b </span><span>=</span><span> </span><span>self</span><span>.</span><span>solution_map</span><span>.</span><span>get</span><span>(</span><span>&amp;</span><span>node_b)</span><span>.</span><span>cloned</span><span>();</span></span>
<span></span>
<span><span>    // Perform the swap</span></span>
<span><span>    </span><span>if</span><span> </span><span>let</span><span> (</span><span>Some</span><span>(loc_a), </span><span>Some</span><span>(loc_b)) </span><span>=</span><span> (loc_a, loc_b) {</span></span>
<span><span>        </span><span>self</span><span>.</span><span>solution_map</span><span>.</span><span>insert</span><span>(node_a, loc_b);</span></span>
<span><span>        </span><span>self</span><span>.</span><span>solution_map</span><span>.</span><span>insert</span><span>(node_b, loc_a);</span></span>
<span><span>    }</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>The last action is to move a node to a location that is close to the centroid of all the nodes in the netlist graph. This is a bit more involved since I need to calculate the centroid and then find the closest valid location to the centroid. This is also an expensive move making the runtime of the placer slower. However, the move can help the placer converge to a better solution faster since moving nodes to the centroid will quickly lower the objective function value in big jumps, up to a certain point in the optimization process.</p>
<pre tabindex="0"><code><span><span>pub</span><span> </span><span>fn</span><span> </span><span>action_move_directed</span><span>(</span><span>&amp;mut</span><span> </span><span>self</span><span>) {</span></span>
<span><span>    </span><span>let</span><span> node_count </span><span>=</span><span> </span><span>self</span><span>.</span><span>netlist</span><span>.</span><span>graph</span><span>.</span><span>node_count</span><span>() </span><span>as</span><span> </span><span>u32</span><span>;</span></span>
<span></span>
<span><span>    </span><span>if</span><span> node_count </span><span>==</span><span> </span><span>0</span><span> {</span></span>
<span><span>        </span><span>panic!</span><span>(</span><span>&#34;No nodes in netlist; cannot compute mean for MOVE_DIRECTED&#34;</span><span>);</span></span>
<span><span>    }</span></span>
<span><span>    </span><span>let</span><span> x_mean </span><span>=</span><span> </span><span>self</span></span>
<span><span>        </span><span>.</span><span>netlist</span></span>
<span><span>        </span><span>.</span><span>all_nodes</span><span>()</span></span>
<span><span>        </span><span>.</span><span>iter</span><span>()</span></span>
<span><span>        </span><span>.</span><span>map</span><span>(</span><span>|</span><span>node</span><span>|</span><span> </span><span>self</span><span>.</span><span>solution_map</span><span>.</span><span>get</span><span>(node)</span><span>.</span><span>unwrap</span><span>()</span><span>.</span><span>x)</span></span>
<span><span>        </span><span>.</span><span>sum</span><span>::</span><span>&lt;</span><span>u32</span><span>&gt;()</span></span>
<span><span>        </span><span>/</span><span> node_count;</span></span>
<span></span>
<span><span>    </span><span>let</span><span> y_mean </span><span>=</span><span> </span><span>self</span></span>
<span><span>        </span><span>.</span><span>netlist</span></span>
<span><span>        </span><span>.</span><span>all_nodes</span><span>()</span></span>
<span><span>        </span><span>.</span><span>iter</span><span>()</span></span>
<span><span>        </span><span>.</span><span>map</span><span>(</span><span>|</span><span>node</span><span>|</span><span> </span><span>self</span><span>.</span><span>solution_map</span><span>.</span><span>get</span><span>(node)</span><span>.</span><span>unwrap</span><span>()</span><span>.</span><span>y)</span></span>
<span><span>        </span><span>.</span><span>sum</span><span>::</span><span>&lt;</span><span>u32</span><span>&gt;()</span></span>
<span><span>        </span><span>/</span><span> node_count;</span></span>
<span></span>
<span><span>    </span><span>let</span><span> </span><span>mut</span><span> rng </span><span>=</span><span> </span><span>rand</span><span>::</span><span>thread_rng</span><span>();</span></span>
<span></span>
<span><span>    // pick a random node</span></span>
<span><span>    </span><span>let</span><span> node</span><span>:</span><span> </span><span>NetlistNode</span><span> </span><span>=</span><span> </span><span>self</span><span>.</span><span>netlist</span><span>.</span><span>all_nodes</span><span>()[rng</span><span>.</span><span>gen_range</span><span>(</span><span>0</span><span>..</span><span>node_count </span><span>as</span><span> </span><span>usize</span><span>)];</span></span>
<span></span>
<span><span>    </span><span>let</span><span> valid_locations </span><span>=</span><span> </span><span>self</span><span>.</span><span>get_possible_sites</span><span>(node</span><span>.</span><span>macro_type);</span></span>
<span><span>    </span><span>let</span><span> valid_closest_location </span><span>=</span><span> valid_locations</span></span>
<span><span>        </span><span>.</span><span>iter</span><span>()</span></span>
<span><span>        </span><span>.</span><span>min_by</span><span>(</span><span>|</span><span>a, b</span><span>|</span><span> {</span></span>
<span><span>            </span><span>let</span><span> a_distance </span><span>=</span></span>
<span><span>                (a</span><span>.</span><span>x </span><span>as</span><span> </span><span>i32</span><span> </span><span>-</span><span> x_mean </span><span>as</span><span> </span><span>i32</span><span>)</span><span>.</span><span>abs</span><span>() </span><span>+</span><span> (a</span><span>.</span><span>y </span><span>as</span><span> </span><span>i32</span><span> </span><span>-</span><span> y_mean </span><span>as</span><span> </span><span>i32</span><span>)</span><span>.</span><span>abs</span><span>();</span></span>
<span><span>            </span><span>let</span><span> b_distance </span><span>=</span></span>
<span><span>                (b</span><span>.</span><span>x </span><span>as</span><span> </span><span>i32</span><span> </span><span>-</span><span> x_mean </span><span>as</span><span> </span><span>i32</span><span>)</span><span>.</span><span>abs</span><span>() </span><span>+</span><span> (b</span><span>.</span><span>y </span><span>as</span><span> </span><span>i32</span><span> </span><span>-</span><span> y_mean </span><span>as</span><span> </span><span>i32</span><span>)</span><span>.</span><span>abs</span><span>();</span></span>
<span><span>            a_distance</span><span>.</span><span>cmp</span><span>(</span><span>&amp;</span><span>b_distance)</span></span>
<span><span>        })</span></span>
<span><span>        </span><span>.</span><span>unwrap</span><span>();</span></span>
<span></span>
<span><span>    // if the new location is futher away from the mean than the current location, return</span></span>
<span><span>    </span><span>let</span><span> current_location </span><span>=</span><span> </span><span>self</span><span>.</span><span>solution_map</span><span>.</span><span>get</span><span>(</span><span>&amp;</span><span>node)</span><span>.</span><span>unwrap</span><span>();</span></span>
<span><span>    </span><span>let</span><span> current_distance </span><span>=</span><span> (current_location</span><span>.</span><span>x </span><span>as</span><span> </span><span>i32</span><span> </span><span>-</span><span> x_mean </span><span>as</span><span> </span><span>i32</span><span>)</span><span>.</span><span>abs</span><span>()</span></span>
<span><span>        </span><span>+</span><span> (current_location</span><span>.</span><span>y </span><span>as</span><span> </span><span>i32</span><span> </span><span>-</span><span> y_mean </span><span>as</span><span> </span><span>i32</span><span>)</span><span>.</span><span>abs</span><span>();</span></span>
<span><span>    </span><span>let</span><span> new_distance </span><span>=</span><span> (valid_closest_location</span><span>.</span><span>x </span><span>as</span><span> </span><span>i32</span><span> </span><span>-</span><span> x_mean </span><span>as</span><span> </span><span>i32</span><span>)</span><span>.</span><span>abs</span><span>()</span></span>
<span><span>        </span><span>+</span><span> (valid_closest_location</span><span>.</span><span>y </span><span>as</span><span> </span><span>i32</span><span> </span><span>-</span><span> y_mean </span><span>as</span><span> </span><span>i32</span><span>)</span><span>.</span><span>abs</span><span>();</span></span>
<span><span>    </span><span>if</span><span> new_distance </span><span>&gt;</span><span> current_distance {</span></span>
<span><span>        </span><span>return</span><span>;</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    </span><span>self</span><span>.</span><span>solution_map</span></span>
<span><span>        </span><span>.</span><span>insert</span><span>(node, valid_closest_location</span><span>.</span><span>clone</span><span>());</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>You can then dispatch these actions using another helper function.</p>
<pre tabindex="0"><code><span><span>pub</span><span> </span><span>fn</span><span> </span><span>action</span><span>(</span><span>&amp;mut</span><span> </span><span>self</span><span>, action</span><span>:</span><span> </span><span>PlacementAction</span><span>) {</span></span>
<span><span>    </span><span>match</span><span> action {</span></span>
<span><span>        </span><span>PlacementAction</span><span>::</span><span>MOVE</span><span> </span><span>=&gt;</span><span> </span><span>self</span><span>.</span><span>action_move</span><span>(),</span></span>
<span><span>        </span><span>PlacementAction</span><span>::</span><span>SWAP</span><span> </span><span>=&gt;</span><span> </span><span>self</span><span>.</span><span>action_swap</span><span>(),</span></span>
<span><span>        </span><span>PlacementAction</span><span>::</span><span>MOVE_DIRECTED</span><span> </span><span>=&gt;</span><span> </span><span>self</span><span>.</span><span>action_move_directed</span><span>(),</span></span>
<span><span>    }</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>Another key aspect of the placer is the objective function. I have mentioned things such as using distance functions for wire lengths and summing all edges in the netlist graph. I&#39;m going to take a brief detour to talk more about objective functions for place-and-route.</p>
<p>Traditionally, a &#34;net&#34; is what is usually referred to as a hyperedge in a hypergraph. For the abstract &#34;connection&#34; from an output pin of one node to all the input pins of other nodes, it can be called a net. Nets are motivated as an abstraction since you might physically draw one bending and branching rectilinear metal path in a chip to connect all the pins of a net, hence acting as one abstract &#34;net&#34;.</p>
<p>The individual connections from one output pin to one input pin are what I consider an &#34;edge&#34;. This maps directly to the edges in a graph when talking about abstract graphs in mathematics. I can turn a net into a set of edges by just enumerating all source-to-sink connections in the net hyperedge.</p>
<p>In general, a single &#34;net&#34; contains multiple &#34;edges&#34;, and, technically, for placement, the directedness of these &#34;nets&#34; and &#34;edges&#34; don&#39;t matter (at least in the simple toy placement problem I have introduced).</p>
<p>Some objective functions are net-level objectives. One popular net-level objective is Half-Perimeter Wirelength (HPWL), where HPWL is equal to half the length of the perimeter of the encompassing rectangular bounding box of the net:</p>
<p><mjx-container jax="SVG" display="true"><svg style="vertical-align: -1.75ex;" xmlns="http://www.w3.org/2000/svg" width="50.636ex" height="3.447ex" role="img" focusable="false" viewBox="0 -750 22381.2 1523.7" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D43B" xlink:href="#MJX-TEX-I-1D43B"></use></g><g data-mml-node="mi" transform="translate(888,0)"><use data-c="1D443" xlink:href="#MJX-TEX-I-1D443"></use></g><g data-mml-node="mi" transform="translate(1639,0)"><use data-c="1D44A" xlink:href="#MJX-TEX-I-1D44A"></use></g><g data-mml-node="msub" transform="translate(2687,0)"><g data-mml-node="mi"><use data-c="1D43F" xlink:href="#MJX-TEX-I-1D43F"></use></g><g data-mml-node="mi" transform="translate(714,-150) scale(0.707)"><use data-c="1D452" xlink:href="#MJX-TEX-I-1D452"></use></g></g><g data-mml-node="mo" transform="translate(4058.3,0)"><use data-c="3D" xlink:href="#MJX-TEX-N-3D"></use></g><g data-mml-node="munder" transform="translate(5114.1,0)"><g data-mml-node="mo"><use data-c="6D" xlink:href="#MJX-TEX-N-6D"></use><use data-c="61" xlink:href="#MJX-TEX-N-61" transform="translate(833,0)"></use><use data-c="78" xlink:href="#MJX-TEX-N-78" transform="translate(1333,0)"></use></g><g data-mml-node="TeXAtom" transform="translate(360.6,-645.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="1D456" xlink:href="#MJX-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(345,0)"><use data-c="2208" xlink:href="#MJX-TEX-N-2208"></use></g><g data-mml-node="mi" transform="translate(1012,0)"><use data-c="1D45B" xlink:href="#MJX-TEX-I-1D45B"></use></g></g></g><g data-mml-node="mo" transform="translate(6975.1,0)"><use data-c="28" xlink:href="#MJX-TEX-N-28"></use></g><g data-mml-node="msub" transform="translate(7364.1,0)"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-TEX-I-1D465"></use></g><g data-mml-node="mi" transform="translate(605,-150) scale(0.707)"><use data-c="1D456" xlink:href="#MJX-TEX-I-1D456"></use></g></g><g data-mml-node="mo" transform="translate(8263,0)"><use data-c="29" xlink:href="#MJX-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(8874.2,0)"><use data-c="2212" xlink:href="#MJX-TEX-N-2212"></use></g><g data-mml-node="munder" transform="translate(9874.5,0)"><g data-mml-node="mo"><use data-c="6D" xlink:href="#MJX-TEX-N-6D"></use><use data-c="69" xlink:href="#MJX-TEX-N-69" transform="translate(833,0)"></use><use data-c="6E" xlink:href="#MJX-TEX-N-6E" transform="translate(1111,0)"></use></g><g data-mml-node="TeXAtom" transform="translate(263.6,-634.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="1D456" xlink:href="#MJX-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(345,0)"><use data-c="2208" xlink:href="#MJX-TEX-N-2208"></use></g><g data-mml-node="mi" transform="translate(1012,0)"><use data-c="1D45B" xlink:href="#MJX-TEX-I-1D45B"></use></g></g></g><g data-mml-node="mo" transform="translate(11541.5,0)"><use data-c="28" xlink:href="#MJX-TEX-N-28"></use></g><g data-mml-node="msub" transform="translate(11930.5,0)"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-TEX-I-1D465"></use></g><g data-mml-node="mi" transform="translate(605,-150) scale(0.707)"><use data-c="1D456" xlink:href="#MJX-TEX-I-1D456"></use></g></g><g data-mml-node="mo" transform="translate(12829.4,0)"><use data-c="29" xlink:href="#MJX-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(13440.6,0)"><use data-c="2B" xlink:href="#MJX-TEX-N-2B"></use></g><g data-mml-node="munder" transform="translate(14440.9,0)"><g data-mml-node="mo"><use data-c="6D" xlink:href="#MJX-TEX-N-6D"></use><use data-c="61" xlink:href="#MJX-TEX-N-61" transform="translate(833,0)"></use><use data-c="78" xlink:href="#MJX-TEX-N-78" transform="translate(1333,0)"></use></g><g data-mml-node="TeXAtom" transform="translate(360.6,-645.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="1D456" xlink:href="#MJX-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(345,0)"><use data-c="2208" xlink:href="#MJX-TEX-N-2208"></use></g><g data-mml-node="mi" transform="translate(1012,0)"><use data-c="1D45B" xlink:href="#MJX-TEX-I-1D45B"></use></g></g></g><g data-mml-node="mo" transform="translate(16301.9,0)"><use data-c="28" xlink:href="#MJX-TEX-N-28"></use></g><g data-mml-node="msub" transform="translate(16690.9,0)"><g data-mml-node="mi"><use data-c="1D466" xlink:href="#MJX-TEX-I-1D466"></use></g><g data-mml-node="mi" transform="translate(523,-150) scale(0.707)"><use data-c="1D456" xlink:href="#MJX-TEX-I-1D456"></use></g></g><g data-mml-node="mo" transform="translate(17507.8,0)"><use data-c="29" xlink:href="#MJX-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(18119,0)"><use data-c="2212" xlink:href="#MJX-TEX-N-2212"></use></g><g data-mml-node="munder" transform="translate(19119.3,0)"><g data-mml-node="mo"><use data-c="6D" xlink:href="#MJX-TEX-N-6D"></use><use data-c="69" xlink:href="#MJX-TEX-N-69" transform="translate(833,0)"></use><use data-c="6E" xlink:href="#MJX-TEX-N-6E" transform="translate(1111,0)"></use></g><g data-mml-node="TeXAtom" transform="translate(263.6,-634.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="1D456" xlink:href="#MJX-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(345,0)"><use data-c="2208" xlink:href="#MJX-TEX-N-2208"></use></g><g data-mml-node="mi" transform="translate(1012,0)"><use data-c="1D45B" xlink:href="#MJX-TEX-I-1D45B"></use></g></g></g><g data-mml-node="mo" transform="translate(20786.3,0)"><use data-c="28" xlink:href="#MJX-TEX-N-28"></use></g><g data-mml-node="msub" transform="translate(21175.3,0)"><g data-mml-node="mi"><use data-c="1D466" xlink:href="#MJX-TEX-I-1D466"></use></g><g data-mml-node="mi" transform="translate(523,-150) scale(0.707)"><use data-c="1D456" xlink:href="#MJX-TEX-I-1D456"></use></g></g><g data-mml-node="mo" transform="translate(21992.2,0)"><use data-c="29" xlink:href="#MJX-TEX-N-29"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>H</mi><mi>P</mi><mi>W</mi><msub><mi>L</mi><mi>e</mi></msub><mo>=</mo><munder><mo data-mjx-texclass="OP" movablelimits="true">max</mo><mrow data-mjx-texclass="ORD"><mi>i</mi><mo>âˆˆ</mo><mi>n</mi></mrow></munder><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>âˆ’</mo><munder><mo data-mjx-texclass="OP" movablelimits="true">min</mo><mrow data-mjx-texclass="ORD"><mi>i</mi><mo>âˆˆ</mo><mi>n</mi></mrow></munder><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>+</mo><munder><mo data-mjx-texclass="OP" movablelimits="true">max</mo><mrow data-mjx-texclass="ORD"><mi>i</mi><mo>âˆˆ</mo><mi>n</mi></mrow></munder><mo stretchy="false">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>âˆ’</mo><munder><mo data-mjx-texclass="OP" movablelimits="true">min</mo><mrow data-mjx-texclass="ORD"><mi>i</mi><mo>âˆˆ</mo><mi>n</mi></mrow></munder><mo stretchy="false">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container></p>
<p>where <mjx-container jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-TEX-I-1D45B"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></mjx-assistive-mml></mjx-container> is a net, <mjx-container jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewBox="0 -661 345 672" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D456" xlink:href="#MJX-TEX-I-1D456"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>i</mi></math></mjx-assistive-mml></mjx-container> is a node in the net, and <mjx-container jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.034ex" height="1.357ex" role="img" focusable="false" viewBox="0 -442 899 599.8" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-TEX-I-1D465"></use></g><g data-mml-node="mi" transform="translate(605,-150) scale(0.707)"><use data-c="1D456" xlink:href="#MJX-TEX-I-1D456"></use></g></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mi>i</mi></msub></math></mjx-assistive-mml></mjx-container> and <mjx-container jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.848ex" height="1.464ex" role="img" focusable="false" viewBox="0 -442 817 647" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><use data-c="1D466" xlink:href="#MJX-TEX-I-1D466"></use></g><g data-mml-node="mi" transform="translate(523,-150) scale(0.707)"><use data-c="1D456" xlink:href="#MJX-TEX-I-1D456"></use></g></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>y</mi><mi>i</mi></msub></math></mjx-assistive-mml></mjx-container> are the x and y coordinates of node <mjx-container jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewBox="0 -661 345 672" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D456" xlink:href="#MJX-TEX-I-1D456"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>i</mi></math></mjx-assistive-mml></mjx-container>. There are many proposed ways to relax the min and max functions to make this continuous, differentiable, and/or some version of convex as well as other related net-level objectives.</p>
<p>Assuming we just split all nets into edges, there are many net-level objectives, the simplest class of which are just distance functions in Euclidean space. Manhattan distance, aka &#34;linear&#34; wirelength model, is meant to model the optimal physical rectilinear routing of wires in a chip. This is formulated as <mjx-container jax="SVG"><svg style="vertical-align: -0.666ex;" xmlns="http://www.w3.org/2000/svg" width="13.791ex" height="2.361ex" role="img" focusable="false" viewBox="0 -749.5 6095.6 1043.7" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><use data-c="1D451" xlink:href="#MJX-TEX-I-1D451"></use></g><g data-mml-node="TeXAtom" transform="translate(553,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="1D456" xlink:href="#MJX-TEX-I-1D456"></use></g><g data-mml-node="mi" transform="translate(345,0)"><use data-c="1D457" xlink:href="#MJX-TEX-I-1D457"></use></g></g></g><g data-mml-node="mo" transform="translate(1416.1,0)"><use data-c="3D" xlink:href="#MJX-TEX-N-3D"></use></g><g data-mml-node="mo" transform="translate(2471.8,0) translate(0 -0.5)"><use data-c="7C" xlink:href="#MJX-TEX-N-7C"></use></g><g data-mml-node="msub" transform="translate(2749.8,0)"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-TEX-I-1D465"></use></g><g data-mml-node="mi" transform="translate(605,-150) scale(0.707)"><use data-c="1D456" xlink:href="#MJX-TEX-I-1D456"></use></g></g><g data-mml-node="mo" transform="translate(3871,0)"><use data-c="2212" xlink:href="#MJX-TEX-N-2212"></use></g><g data-mml-node="msub" transform="translate(4871.2,0)"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-TEX-I-1D465"></use></g><g data-mml-node="mi" transform="translate(605,-150) scale(0.707)"><use data-c="1D457" xlink:href="#MJX-TEX-I-1D457"></use></g></g><g data-mml-node="mo" transform="translate(5817.6,0) translate(0 -0.5)"><use data-c="7C" xlink:href="#MJX-TEX-N-7C"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>d</mi><mrow data-mjx-texclass="ORD"><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mo data-mjx-texclass="ORD" stretchy="false">|</mo><msub><mi>x</mi><mi>i</mi></msub><mo>âˆ’</mo><msub><mi>x</mi><mi>j</mi></msub><mo data-mjx-texclass="ORD" stretchy="false">|</mo></math></mjx-assistive-mml></mjx-container> and the objective as <mjx-container jax="SVG"><svg style="vertical-align: -0.71ex;" xmlns="http://www.w3.org/2000/svg" width="35.896ex" height="2.406ex" role="img" focusable="false" viewBox="0 -750 15866.1 1063.6" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="munder"><g data-mml-node="mo"><use data-c="2211" xlink:href="#MJX-TEX-SO-2211"></use></g><g data-mml-node="TeXAtom" transform="translate(1089,-285.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="1D452" xlink:href="#MJX-TEX-I-1D452"></use></g><g data-mml-node="mo" transform="translate(466,0)"><use data-c="2208" xlink:href="#MJX-TEX-N-2208"></use></g><g data-mml-node="mi" transform="translate(1133,0)"><use data-c="1D438" xlink:href="#MJX-TEX-I-1D438"></use></g></g></g><g data-mml-node="msub" transform="translate(2647,0)"><g data-mml-node="mi"><use data-c="1D451" xlink:href="#MJX-TEX-I-1D451"></use></g><g data-mml-node="mi" transform="translate(553,-150) scale(0.707)"><use data-c="1D452" xlink:href="#MJX-TEX-I-1D452"></use></g></g><g data-mml-node="mo" transform="translate(3857.3,0)"><use data-c="3D" xlink:href="#MJX-TEX-N-3D"></use></g><g data-mml-node="munder" transform="translate(4913.1,0)"><g data-mml-node="mo"><use data-c="2211" xlink:href="#MJX-TEX-SO-2211"></use></g><g data-mml-node="TeXAtom" transform="translate(1089,-285.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="1D452" xlink:href="#MJX-TEX-I-1D452"></use></g><g data-mml-node="mo" transform="translate(466,0)"><use data-c="2208" xlink:href="#MJX-TEX-N-2208"></use></g><g data-mml-node="mi" transform="translate(1133,0)"><use data-c="1D438" xlink:href="#MJX-TEX-I-1D438"></use></g></g></g><g data-mml-node="mo" transform="translate(7560.2,0) translate(0 -0.5)"><use data-c="7C" xlink:href="#MJX-TEX-N-7C"></use></g><g data-mml-node="msub" transform="translate(7838.2,0)"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-TEX-I-1D465"></use></g><g data-mml-node="mi" transform="translate(605,-150) scale(0.707)"><use data-c="1D456" xlink:href="#MJX-TEX-I-1D456"></use></g></g><g data-mml-node="mo" transform="translate(8959.3,0)"><use data-c="2212" xlink:href="#MJX-TEX-N-2212"></use></g><g data-mml-node="msub" transform="translate(9959.6,0)"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-TEX-I-1D465"></use></g><g data-mml-node="mi" transform="translate(605,-150) scale(0.707)"><use data-c="1D457" xlink:href="#MJX-TEX-I-1D457"></use></g></g><g data-mml-node="mo" transform="translate(10905.9,0) translate(0 -0.5)"><use data-c="7C" xlink:href="#MJX-TEX-N-7C"></use></g><g data-mml-node="mo" transform="translate(11406.1,0)"><use data-c="2B" xlink:href="#MJX-TEX-N-2B"></use></g><g data-mml-node="mo" transform="translate(12406.3,0) translate(0 -0.5)"><use data-c="7C" xlink:href="#MJX-TEX-N-7C"></use></g><g data-mml-node="msub" transform="translate(12684.3,0)"><g data-mml-node="mi"><use data-c="1D466" xlink:href="#MJX-TEX-I-1D466"></use></g><g data-mml-node="mi" transform="translate(523,-150) scale(0.707)"><use data-c="1D456" xlink:href="#MJX-TEX-I-1D456"></use></g></g><g data-mml-node="mo" transform="translate(13723.5,0)"><use data-c="2212" xlink:href="#MJX-TEX-N-2212"></use></g><g data-mml-node="msub" transform="translate(14723.7,0)"><g data-mml-node="mi"><use data-c="1D466" xlink:href="#MJX-TEX-I-1D466"></use></g><g data-mml-node="mi" transform="translate(523,-150) scale(0.707)"><use data-c="1D457" xlink:href="#MJX-TEX-I-1D457"></use></g></g><g data-mml-node="mo" transform="translate(15588.1,0) translate(0 -0.5)"><use data-c="7C" xlink:href="#MJX-TEX-N-7C"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><munder><mo data-mjx-texclass="OP">âˆ‘</mo><mrow data-mjx-texclass="ORD"><mi>e</mi><mo>âˆˆ</mo><mi>E</mi></mrow></munder><msub><mi>d</mi><mi>e</mi></msub><mo>=</mo><munder><mo data-mjx-texclass="OP">âˆ‘</mo><mrow data-mjx-texclass="ORD"><mi>e</mi><mo>âˆˆ</mo><mi>E</mi></mrow></munder><mo data-mjx-texclass="ORD" stretchy="false">|</mo><msub><mi>x</mi><mi>i</mi></msub><mo>âˆ’</mo><msub><mi>x</mi><mi>j</mi></msub><mo data-mjx-texclass="ORD" stretchy="false">|</mo><mo>+</mo><mo data-mjx-texclass="ORD" stretchy="false">|</mo><msub><mi>y</mi><mi>i</mi></msub><mo>âˆ’</mo><msub><mi>y</mi><mi>j</mi></msub><mo data-mjx-texclass="ORD" stretchy="false">|</mo></math></mjx-assistive-mml></mjx-container>.</p>
<p>However, a more popular metric is the square distance, or the &#34;quadratic&#34; wirelength model. This is formulated as <mjx-container jax="SVG"><svg style="vertical-align: -0.666ex;" xmlns="http://www.w3.org/2000/svg" width="15.281ex" height="2.552ex" role="img" focusable="false" viewBox="0 -833.9 6754.1 1128.2" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><use data-c="1D451" xlink:href="#MJX-TEX-I-1D451"></use></g><g data-mml-node="TeXAtom" transform="translate(553,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="1D456" xlink:href="#MJX-TEX-I-1D456"></use></g><g data-mml-node="mi" transform="translate(345,0)"><use data-c="1D457" xlink:href="#MJX-TEX-I-1D457"></use></g></g></g><g data-mml-node="mo" transform="translate(1416.1,0)"><use data-c="3D" xlink:href="#MJX-TEX-N-3D"></use></g><g data-mml-node="mo" transform="translate(2471.8,0)"><use data-c="28" xlink:href="#MJX-TEX-N-28"></use></g><g data-mml-node="msub" transform="translate(2860.8,0)"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-TEX-I-1D465"></use></g><g data-mml-node="mi" transform="translate(605,-150) scale(0.707)"><use data-c="1D456" xlink:href="#MJX-TEX-I-1D456"></use></g></g><g data-mml-node="mo" transform="translate(3982,0)"><use data-c="2212" xlink:href="#MJX-TEX-N-2212"></use></g><g data-mml-node="msub" transform="translate(4982.2,0)"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-TEX-I-1D465"></use></g><g data-mml-node="mi" transform="translate(605,-150) scale(0.707)"><use data-c="1D457" xlink:href="#MJX-TEX-I-1D457"></use></g></g><g data-mml-node="msup" transform="translate(5928.6,0)"><g data-mml-node="mo"><use data-c="29" xlink:href="#MJX-TEX-N-29"></use></g><g data-mml-node="mn" transform="translate(422,363) scale(0.707)"><use data-c="32" xlink:href="#MJX-TEX-N-32"></use></g></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>d</mi><mrow data-mjx-texclass="ORD"><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>âˆ’</mo><msub><mi>x</mi><mi>j</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></math></mjx-assistive-mml></mjx-container> and the objective as <mjx-container jax="SVG"><svg style="vertical-align: -0.71ex;" xmlns="http://www.w3.org/2000/svg" width="38.499ex" height="2.596ex" role="img" focusable="false" viewBox="0 -833.9 17016.5 1147.6" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="munder"><g data-mml-node="mo"><use data-c="2211" xlink:href="#MJX-TEX-SO-2211"></use></g><g data-mml-node="TeXAtom" transform="translate(1089,-285.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="1D452" xlink:href="#MJX-TEX-I-1D452"></use></g><g data-mml-node="mo" transform="translate(466,0)"><use data-c="2208" xlink:href="#MJX-TEX-N-2208"></use></g><g data-mml-node="mi" transform="translate(1133,0)"><use data-c="1D438" xlink:href="#MJX-TEX-I-1D438"></use></g></g></g><g data-mml-node="msub" transform="translate(2647,0)"><g data-mml-node="mi"><use data-c="1D451" xlink:href="#MJX-TEX-I-1D451"></use></g><g data-mml-node="mi" transform="translate(553,-150) scale(0.707)"><use data-c="1D452" xlink:href="#MJX-TEX-I-1D452"></use></g></g><g data-mml-node="mo" transform="translate(3857.3,0)"><use data-c="3D" xlink:href="#MJX-TEX-N-3D"></use></g><g data-mml-node="munder" transform="translate(4913.1,0)"><g data-mml-node="mo"><use data-c="2211" xlink:href="#MJX-TEX-SO-2211"></use></g><g data-mml-node="TeXAtom" transform="translate(1089,-285.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="1D452" xlink:href="#MJX-TEX-I-1D452"></use></g><g data-mml-node="mo" transform="translate(466,0)"><use data-c="2208" xlink:href="#MJX-TEX-N-2208"></use></g><g data-mml-node="mi" transform="translate(1133,0)"><use data-c="1D438" xlink:href="#MJX-TEX-I-1D438"></use></g></g></g><g data-mml-node="mo" transform="translate(7393.5,0)"><use data-c="28" xlink:href="#MJX-TEX-N-28"></use></g><g data-mml-node="msub" transform="translate(7782.5,0)"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-TEX-I-1D465"></use></g><g data-mml-node="mi" transform="translate(605,-150) scale(0.707)"><use data-c="1D456" xlink:href="#MJX-TEX-I-1D456"></use></g></g><g data-mml-node="mo" transform="translate(8903.7,0)"><use data-c="2212" xlink:href="#MJX-TEX-N-2212"></use></g><g data-mml-node="msub" transform="translate(9903.9,0)"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-TEX-I-1D465"></use></g><g data-mml-node="mi" transform="translate(605,-150) scale(0.707)"><use data-c="1D457" xlink:href="#MJX-TEX-I-1D457"></use></g></g><g data-mml-node="msup" transform="translate(10850.2,0)"><g data-mml-node="mo"><use data-c="29" xlink:href="#MJX-TEX-N-29"></use></g><g data-mml-node="mn" transform="translate(422,363) scale(0.707)"><use data-c="32" xlink:href="#MJX-TEX-N-32"></use></g></g><g data-mml-node="mo" transform="translate(11898,0)"><use data-c="2B" xlink:href="#MJX-TEX-N-2B"></use></g><g data-mml-node="mo" transform="translate(12898.2,0)"><use data-c="28" xlink:href="#MJX-TEX-N-28"></use></g><g data-mml-node="msub" transform="translate(13287.2,0)"><g data-mml-node="mi"><use data-c="1D466" xlink:href="#MJX-TEX-I-1D466"></use></g><g data-mml-node="mi" transform="translate(523,-150) scale(0.707)"><use data-c="1D456" xlink:href="#MJX-TEX-I-1D456"></use></g></g><g data-mml-node="mo" transform="translate(14326.4,0)"><use data-c="2212" xlink:href="#MJX-TEX-N-2212"></use></g><g data-mml-node="msub" transform="translate(15326.6,0)"><g data-mml-node="mi"><use data-c="1D466" xlink:href="#MJX-TEX-I-1D466"></use></g><g data-mml-node="mi" transform="translate(523,-150) scale(0.707)"><use data-c="1D457" xlink:href="#MJX-TEX-I-1D457"></use></g></g><g data-mml-node="msup" transform="translate(16190.9,0)"><g data-mml-node="mo"><use data-c="29" xlink:href="#MJX-TEX-N-29"></use></g><g data-mml-node="mn" transform="translate(422,363) scale(0.707)"><use data-c="32" xlink:href="#MJX-TEX-N-32"></use></g></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><munder><mo data-mjx-texclass="OP">âˆ‘</mo><mrow data-mjx-texclass="ORD"><mi>e</mi><mo>âˆˆ</mo><mi>E</mi></mrow></munder><msub><mi>d</mi><mi>e</mi></msub><mo>=</mo><munder><mo data-mjx-texclass="OP">âˆ‘</mo><mrow data-mjx-texclass="ORD"><mi>e</mi><mo>âˆˆ</mo><mi>E</mi></mrow></munder><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>âˆ’</mo><msub><mi>x</mi><mi>j</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>âˆ’</mo><msub><mi>y</mi><mi>j</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></math></mjx-assistive-mml></mjx-container>.</p>
<p>In my toy placer, I use the linear wirelength model in my objective function since I am modeling everything as just edges and not nets. The naming of cost_bb is a bit of a misnomer since I am not computing anything related to the bounding box of the net. I am just summing the Manhattan distance of all edges in the netlist graph.</p>
<pre tabindex="0"><code><span><span>pub</span><span> </span><span>fn</span><span> </span><span>cost_bb</span><span>(</span><span>&amp;</span><span>self</span><span>) </span><span>-&gt;</span><span> </span><span>f32</span><span> {</span></span>
<span><span>    </span><span>let</span><span> </span><span>mut</span><span> cost </span><span>=</span><span> </span><span>0.0</span><span>;</span></span>
<span></span>
<span><span>    </span><span>for</span><span> edge </span><span>in</span><span> </span><span>self</span><span>.</span><span>netlist</span><span>.</span><span>graph</span><span>.</span><span>edge_references</span><span>() {</span></span>
<span><span>        </span><span>let</span><span> source_idx </span><span>=</span><span> edge</span><span>.</span><span>source</span><span>();</span></span>
<span><span>        </span><span>let</span><span> target_idx </span><span>=</span><span> edge</span><span>.</span><span>target</span><span>();</span></span>
<span></span>
<span><span>        </span><span>let</span><span> source </span><span>=</span><span> </span><span>self</span><span>.</span><span>netlist</span><span>.</span><span>graph</span><span>.</span><span>node_weight</span><span>(source_idx)</span><span>.</span><span>unwrap</span><span>();</span></span>
<span><span>        </span><span>let</span><span> target </span><span>=</span><span> </span><span>self</span><span>.</span><span>netlist</span><span>.</span><span>graph</span><span>.</span><span>node_weight</span><span>(target_idx)</span><span>.</span><span>unwrap</span><span>();</span></span>
<span></span>
<span><span>        </span><span>let</span><span> source_location </span><span>=</span><span> </span><span>self</span><span>.</span><span>solution_map</span><span>.</span><span>get</span><span>(source)</span><span>.</span><span>unwrap</span><span>();</span></span>
<span><span>        </span><span>let</span><span> target_location </span><span>=</span><span> </span><span>self</span><span>.</span><span>solution_map</span><span>.</span><span>get</span><span>(target)</span><span>.</span><span>unwrap</span><span>();</span></span>
<span></span>
<span><span>        </span><span>let</span><span> x_distance </span><span>=</span><span> (source_location</span><span>.</span><span>x </span><span>as</span><span> </span><span>i32</span><span> </span><span>-</span><span> target_location</span><span>.</span><span>x </span><span>as</span><span> </span><span>i32</span><span>)</span><span>.</span><span>abs</span><span>();</span></span>
<span><span>        </span><span>let</span><span> y_distance </span><span>=</span><span> (source_location</span><span>.</span><span>y </span><span>as</span><span> </span><span>i32</span><span> </span><span>-</span><span> target_location</span><span>.</span><span>y </span><span>as</span><span> </span><span>i32</span><span>)</span><span>.</span><span>abs</span><span>();</span></span>
<span></span>
<span><span>        </span><span>let</span><span> distance </span><span>=</span><span> x_distance </span><span>+</span><span> y_distance;</span></span>
<span><span>        cost </span><span>+=</span><span> distance </span><span>as</span><span> </span><span>f32</span><span>;</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    cost</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>I also include two independent helper functions to generate initial placement solutions: a random placement approach, <code>gen_random_placement</code>, and a greedy placement approach, <code>gen_greedy_placement</code>. The greedy placement approach places a node in the first available spot in the top left direction of the FPGA layout. This allows an initial solution to have all nodes placed next to each other, but likely harder to optimize more compactly, compared to an initial solution where nodes are placed further apart on average, but easier to optimize.</p>
<p>There are additional functions in the <code>PlacementSolution</code> implementation, including a <code>render_svg</code> function to make all the visualizations in this post, along with a <code>Renderer</code> type with a <code>render_to_video</code> function in the implementation that calls <code>imagemagick</code> and <code>ffmpeg</code> to render a video and GIFs of the optimization process.</p>
<h2 id="the-placer" tabindex="-1">The Placer</h2>
<p>The last component is the actual placer, which is surprisingly simple and compact to implement as a single function. This implementation explores multiple parallel moves at each step and picks the best move taken at that step. I also use <code>rayon</code>&#39;s <code>par_iter</code> feature to parallelize the exploration of moves at each step. This is a simple way to speed up the optimization process but might require some tuning since there might be some overhead in parallelizing the exploration of moves.</p>
<p>Ideally, there is a non-trivial tradeoff between the number of total steps taken and the number of parallel actions explored at each step. More actions-per-step results in it being more likely to find a better move at that single step, but more steps in total means more likely to reach a stable optimal solution, all with the tradeoff of total runtime. Maybe at different points in time during the optimization process, one would want to tune the number of parallel actions explored at each step. This is something I want to explore in the future and ties back directly to the &#34;annealing&#34; aspect of traditional simulated annealing. Changing the value of the number of actions explored at each step is what is referred to as building an annealing schedule, which also has parallels to picking learning rate schedules in deep learning.</p>
<pre tabindex="0"><code><span><span>pub</span><span> </span><span>struct</span><span> </span><span>PlacerOutput</span><span>&lt;&#39;</span><span>a</span><span>&gt; {</span></span>
<span><span>    </span><span>pub</span><span> initial_solution</span><span>:</span><span> </span><span>PlacementSolution</span><span>&lt;&#39;</span><span>a</span><span>&gt;,</span></span>
<span><span>    </span><span>pub</span><span> final_solution</span><span>:</span><span> </span><span>PlacementSolution</span><span>&lt;&#39;</span><span>a</span><span>&gt;,</span></span>
<span><span>    </span><span>pub</span><span> x_steps</span><span>:</span><span> </span><span>Vec</span><span>&lt;</span><span>u32</span><span>&gt;,</span></span>
<span><span>    </span><span>pub</span><span> y_cost</span><span>:</span><span> </span><span>Vec</span><span>&lt;</span><span>f32</span><span>&gt;,</span></span>
<span><span>    </span><span>pub</span><span> renderer</span><span>:</span><span> </span><span>Option</span><span>&lt;</span><span>Renderer</span><span>&gt;,</span></span>
<span><span>}</span></span>
<span></span>
<span><span>pub</span><span> </span><span>fn</span><span> </span><span>fast_sa_placer</span><span>(</span></span>
<span><span>    initial_solution</span><span>:</span><span> </span><span>PlacementSolution</span><span>,</span></span>
<span><span>    n_steps</span><span>:</span><span> </span><span>u32</span><span>,</span></span>
<span><span>    n_neighbors</span><span>:</span><span> </span><span>usize</span><span>,</span><span> // number of neighbors to explore at each step</span></span>
<span><span>    verbose</span><span>:</span><span> </span><span>bool</span><span>,</span></span>
<span><span>    render</span><span>:</span><span> </span><span>bool</span><span>,</span></span>
<span><span>) </span><span>-&gt;</span><span> </span><span>PlacerOutput</span><span> {</span></span>
<span><span>    </span><span>let</span><span> </span><span>mut</span><span> renderer </span><span>=</span><span> </span><span>Renderer</span><span>::</span><span>new</span><span>();</span></span>
<span></span>
<span><span>    </span><span>let</span><span> </span><span>mut</span><span> current_solution </span><span>=</span><span> initial_solution</span><span>.</span><span>clone</span><span>();</span></span>
<span></span>
<span><span>    </span><span>let</span><span> </span><span>mut</span><span> rng </span><span>=</span><span> </span><span>rand</span><span>::</span><span>thread_rng</span><span>();</span></span>
<span><span>    </span><span>let</span><span> actions</span><span>:</span><span> </span><span>&amp;</span><span>[</span><span>PlacementAction</span><span>] </span><span>=</span><span> </span><span>&amp;</span><span>[</span></span>
<span><span>        </span><span>PlacementAction</span><span>::</span><span>Move</span><span>,</span></span>
<span><span>        </span><span>PlacementAction</span><span>::</span><span>Swap</span><span>,</span></span>
<span><span>        </span><span>PlacementAction</span><span>::</span><span>MoveDirected</span><span>,</span></span>
<span><span>    ];</span></span>
<span></span>
<span><span>    </span><span>let</span><span> </span><span>mut</span><span> x_steps </span><span>=</span><span> </span><span>Vec</span><span>::</span><span>new</span><span>();</span></span>
<span><span>    </span><span>let</span><span> </span><span>mut</span><span> y_cost </span><span>=</span><span> </span><span>Vec</span><span>::</span><span>new</span><span>();</span></span>
<span></span>
<span><span>    </span><span>for</span><span> _i </span><span>in</span><span> </span><span>0</span><span>..</span><span>n_steps {</span></span>
<span><span>        x_steps</span><span>.</span><span>push</span><span>(_i);</span></span>
<span><span>        y_cost</span><span>.</span><span>push</span><span>(current_solution</span><span>.</span><span>cost_bb</span><span>());</span></span>
<span><span>        </span><span>if</span><span> render {</span></span>
<span><span>            renderer</span><span>.</span><span>add_frame</span><span>(current_solution</span><span>.</span><span>render_svg</span><span>());</span></span>
<span><span>        }</span></span>
<span></span>
<span><span>        // randomly select actions</span></span>
<span><span>        </span><span>let</span><span> actions</span><span>:</span><span> </span><span>Vec</span><span>&lt;_&gt; </span><span>=</span><span> actions</span><span>.</span><span>choose_multiple</span><span>(</span><span>&amp;mut</span><span> rng, n_neighbors)</span><span>.</span><span>collect</span><span>();</span></span>
<span></span>
<span><span>        </span><span>let</span><span> new_solutions</span><span>:</span><span> </span><span>Vec</span><span>&lt;_&gt; </span><span>=</span><span> actions</span></span>
<span><span>            </span><span>.</span><span>into_par_iter</span><span>()</span></span>
<span><span>            </span><span>.</span><span>map</span><span>(</span><span>|</span><span>action</span><span>|</span><span> {</span></span>
<span><span>                </span><span>let</span><span> </span><span>mut</span><span> new_solution </span><span>=</span><span> current_solution</span><span>.</span><span>clone</span><span>();</span></span>
<span><span>                new_solution</span><span>.</span><span>action</span><span>(</span><span>*</span><span>action);</span></span>
<span><span>                new_solution</span></span>
<span><span>            })</span></span>
<span><span>            </span><span>.</span><span>collect</span><span>();</span></span>
<span></span>
<span><span>        </span><span>let</span><span> best_solution </span><span>=</span><span> new_solutions</span></span>
<span><span>            </span><span>.</span><span>iter</span><span>()</span></span>
<span><span>            </span><span>.</span><span>min_by</span><span>(</span><span>|</span><span>sol1, sol2</span><span>|</span><span> {</span></span>
<span><span>                (sol1</span><span>.</span><span>cost_bb</span><span>() </span><span>-</span><span> current_solution</span><span>.</span><span>cost_bb</span><span>())</span></span>
<span><span>                    </span><span>.</span><span>partial_cmp</span><span>(</span><span>&amp;</span><span>(sol2</span><span>.</span><span>cost_bb</span><span>() </span><span>-</span><span> current_solution</span><span>.</span><span>cost_bb</span><span>()))</span></span>
<span><span>                    </span><span>.</span><span>unwrap</span><span>()</span></span>
<span><span>            })</span></span>
<span><span>            </span><span>.</span><span>unwrap</span><span>();</span></span>
<span></span>
<span><span>        </span><span>let</span><span> best_delta </span><span>=</span><span> best_solution</span><span>.</span><span>cost_bb</span><span>() </span><span>-</span><span> current_solution</span><span>.</span><span>cost_bb</span><span>();</span></span>
<span><span>        </span><span>let</span><span> </span><span>mut</span><span> delta </span><span>=</span><span> </span><span>0.0</span><span>;</span></span>
<span><span>        </span><span>if</span><span> best_delta </span><span>&lt;</span><span> </span><span>0.0</span><span> {</span></span>
<span><span>            current_solution </span><span>=</span><span> best_solution</span><span>.</span><span>clone</span><span>();</span></span>
<span><span>            delta </span><span>=</span><span> best_delta;</span></span>
<span><span>        }</span></span>
<span></span>
<span><span>        </span><span>if</span><span> verbose {</span></span>
<span><span>            </span><span>if</span><span> _i </span><span>%</span><span> </span><span>10</span><span> </span><span>==</span><span> </span><span>0</span><span> {</span></span>
<span><span>                </span><span>println!</span><span>(</span><span>&#34;Current Itteration: {:?}&#34;</span><span>, _i);</span></span>
<span><span>                </span><span>println!</span><span>(</span><span>&#34;Delta Cost: {:?}&#34;</span><span>, delta);</span></span>
<span><span>                </span><span>println!</span><span>(</span><span>&#34;Current Cost: {:?}&#34;</span><span>, current_solution</span><span>.</span><span>cost_bb</span><span>());</span></span>
<span><span>            }</span></span>
<span><span>        }</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    </span><span>if</span><span> render {</span></span>
<span><span>        renderer</span><span>.</span><span>add_frame</span><span>(current_solution</span><span>.</span><span>render_svg</span><span>());</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    </span><span>PlacerOutput</span><span> {</span></span>
<span><span>        initial_solution</span><span>:</span><span> initial_solution</span><span>.</span><span>clone</span><span>(),</span></span>
<span><span>        final_solution</span><span>:</span><span> current_solution</span><span>.</span><span>clone</span><span>(),</span></span>
<span><span>        x_steps</span><span>:</span><span> x_steps,</span></span>
<span><span>        y_cost</span><span>:</span><span> y_cost,</span></span>
<span><span>        renderer</span><span>:</span><span> </span><span>if</span><span> render { </span><span>Some</span><span>(renderer) } </span><span>else</span><span> { </span><span>None</span><span> },</span></span>
<span><span>    }</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<h2 id="results-and-visualizations" tabindex="-1">Results and Visualizations</h2>
<p>To put it all together, I tested the placer as follows:</p>
<ul>
<li>A netlist with <code>300 nodes</code>, <code>30 IOs</code>, <code>100 BRAMs</code>, and the <code>rest as CLBs</code>.</li>
<li>An FPGA layout with a <code>width of 64</code> and <code>height of 64</code>, with <code>IOs on the outer edges</code>, <code>CLBs in the middle</code>, and <code>BRAMs every 10 columns</code>.</li>
<li>Each placer ran for <code>1000 steps</code>.</li>
<li>Run different trials of the placer with different values for <code>n_neighbors = [1, 4, 8, 16, 32, 64, 128, 256]</code>; each trial uses the same initial placement solution.</li>
</ul>
<p>It works! The random initial placement and final placement solution using <code>n_neighbors = 32</code> is shown below.</p>
<div>
<p><img src="https://stefanabikaram.com/img/fpga-sa-placer/initial_solution.png" alt="Initial Placement" width="100%"/>
<img src="https://stefanabikaram.com/img/fpga-sa-placer/final_solution_32.png" alt="Final Placement using n_neighbors=32" width="100%"/></p><p><b>Random Initial Placement</b></p>
<p><b>Final Placement Using <code>n_neighbors = 32</code></b></p>
</div>
<p>Below is a video of the optimization process for this specific placement run, rendering every 20th step at 30 FPS.</p>

<p>The most notable aspect of this placer is that it tends to heavily rely on the directed move action to move nodes to the centroid of the netlist graph. I guess that starting from a random initial solution, these moves tend to be the most effective at lowering the objective function value. As time goes on and more nodes are placed in the center, this biases the directed moves to move nodes where all the nodes are in the middle. Random moves and swap moves, however, are still valuable for the placer to explore to optimize the placement of IOs since they are limited to the outer edges of the FPGA layout, and also BRAM since they have large jumps between the BRAM columns.</p>
<p>To also explore how the number of parallel neighbors explored at each step affects the optimization process. The results are shown below with the figure created using <code>gnuplot</code>.</p>
<div>
<p><img src="https://stefanabikaram.com/img/fpga-sa-placer/fpga_placer_history.png" alt="Parallel Neighbors" width="100%"/></p><p><b>Exploring Placer Runs with Different Number of Parallel Neighbors</b></p>
</div>
<p>Intuitively, the placer run with the most number of neighbors explored in parallel is not the best at optimizing the placement objective function over the entire run. However, it seems that you want to search with 4 or more parallel neighbors as searching for 1 or 2 parallel neighbors is certainly not as effective.</p>
<p>It seems that there may be diminishing and then decreasing final objective values as you increase the number of parallel neighbors to search, but it is not yet clear to me what the optimal value is for parallel search at each step and what is going on here. This result is also very specific to the netlist and FPGA layout I used to test the placer. More diverse and comprehensive experiments are needed to draw more general conclusions.</p>
<h2 id="source-code-and-reproducibility" tabindex="-1">Source Code and Reproducibility</h2>
<p>You can find all the source code for this project here: <a href="https://github.com/stefanpie/sa-placer">https://github.com/stefanpie/sa-placer</a>. This will let you dive into more details of the implementation that I omitted from this post as well as mess around with the code yourself and try different ideas. The generated data files (CSVs) and rendered visualizations (PNGs, MP4s, GIFs) are also in the repository.</p>
<h2 id="conclusion" tabindex="-1">Conclusion</h2>
<p>There is not much more to say about the actual toy placer itself, but after this project, I do have some thoughts on EDA algorithms and EDA research that I think are important to say out loud.</p>
<p>It turned out that the ideas presented in journal and conference papers are much easier to understand once you can distill the core ideas and start from first principles. However, a lot of the published technical material on EDA is not very accessible or too surface level. I have found that textbooks and high-quality published course materials are good resources to break past the surface-level content. Furthermore, accessible and good quality (non-&#34;research&#34; quality) source code for advanced EDA algorithms are also hard to come by.</p>
<p>After using Rust for EDA, I have higher hopes and higher standards for better EDA software. I think there are huge gaps in performance in modern EDA tools and algorithms that, with some more investment in the software engineering and algorithms side of things, can be bridged. After using Rust, I think it is one of the best candidates for this kind of data structure and algorithm-heavy software with high standards for correctness and reliability.</p>
<p>Ideally, I would like to live in a world where it takes less than a minute to fully synthesize, place, and route a large modern FPGA design for a large modern FPGA device, something like a fast &#34;prototype&#34; flow that meets relaxed timing constraints. I think after this project, I can now see some glimmer of hope for this future.</p>




        </div></div>
  </body>
</html>
