<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.fleksy.com/blog/how-swipe-typing-works/">Original</a>
    <h1>How Swipe Typing Works</h1>
    
    <div id="readability-page-1" class="page"><div>

			
<article id="post-3528">
  
  <div>

		<div data-hide-featured-media="1">
      
        <div>
<figure><img width="1024" height="576" src="https://www.fleksy.com/wp-content/uploads/2022/04/how-swipe-typing-works-1024x576.png" alt="" srcset="https://www.fleksy.com/wp-content/uploads/2022/04/how-swipe-typing-works-1024x576.png 1024w, https://www.fleksy.com/wp-content/uploads/2022/04/how-swipe-typing-works-300x169.png 300w, https://www.fleksy.com/wp-content/uploads/2022/04/how-swipe-typing-works-768x432.png 768w, https://www.fleksy.com/wp-content/uploads/2022/04/how-swipe-typing-works-1536x864.png 1536w, https://www.fleksy.com/wp-content/uploads/2022/04/how-swipe-typing-works.png 1920w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>The main function of a software keyboard is to show the most common keys in any given language and translate each “touch input” into an “expected word”. The way a keyboard presents the keys is called a layout and, nowadays, even the simplest keyboard you can download support several layouts per language (ex. QWERTY, AZERTY, QWERTZ, …). </p>



<p>Today, it is paramount that a mobile keyboard should be fast, CPU efficient and with its memory usage under control in order to prevent an inevitable eviction by the mobile operating system (OS).</p>



<div><figure><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1649233993179/BjkZCkg1w.jpg" alt="qwerty.jpg"/></figure></div>



<p>Nowadays, the minimum input method supported by a software keyboard is “tap typing”, where one user can tap the keys corresponding to the characters of a word. Next to these common virtual keyboard, you can find more advanced keyboards that support “swipe typing”, where users swipe their finger across the keyboard.</p>



<p>Let me share these 2 different input methods.</p>



<h2 id="heading-tap-typing">Tap typing</h2>



<p>For “tap typing”, the user is subject the following challenge: while trying to touch the desired keys, the keyboard needs to guess what are the most probable sequence of characters. This process, based on one or several dictionaries, uses autocorrection on-device models to prevent undesired lags in the input experience.</p>



<div><figure><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1649234011468/Rw7JL8hsh.jpg" alt="happe.jpg"/></figure></div>



<div><figure><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1649234023147/j6vYBOomE.jpg" alt="happen.jpg"/></figure></div>



<p>Usually, this “decoding process” suggests several word candidates to the user ordered by a probabilistic scoring method. This score is usually calculated by a spatial probability model (how far each point is from each desired key) and a language model. In such case, a threshold is applied to determine the probability of an “out of vocabulary” (OOV) word, presented to the user as a good decoding candidate.</p>



<h2 id="heading-swipe-typing">Swipe typing</h2>



<p>In the case of “swipe typing”, the user touches the first letter of a word and continues “swiping” or “moving” his finger from one letter to the other. When the user lifts his finger, several decoding candidates are shown to the user, each ordered by a score.</p>



<div><figure><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1649234113488/uZlWFVHwD.jpg" alt="swipe_happen.jpg"/></figure></div>



<div><figure><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1649234125889/biZIiXyQw.jpg" alt="swipe_happen_end.jpg"/></figure></div>



<p>In this case, the score is calculated by a spatial probability model where each point of the swipe is taken into account. </p>



<p>To decide which words are the best fit to decode, we use a beam search algorithm with an aggressive pruning of invalid search paths. For us, an invalid search path is a path of points with a decoding probability lower than the threshold calculated using real data from our users. These search paths are built using one or several dictionaries of valid words in what’s called a “Directed Acyclic Graph” (DAG) optimized data structure. </p>



<p>Since a normal language dictionary can contain tens of thousands of words, our method takes this into account in order to instantly prune the invalid search paths, saving Memory and CPU consumption.</p>



<h3 id="heading-pseudo-code">Pseudo code</h3>



<p>The following is the pseudo-code for our algorithm:COPY</p>



<pre><code lang="python">new_path = path()
beam = empty_beam()

# Add alignment search path to all the possible first letters
for starting_letter in starting_letters:
    beam = add_alignment_search_paths(starting_letter,
                                        beam,
                                        new_path,
                                        point)

for point in swipe_path[1:]:
    next_beam = empty_beam()

    for search_path in current_beam:
        # Add alignment search path for the same letter
        next_beam = add_alignment_search_paths(search_path.prev_letter(), 
                                            next_beam,
                                            search_path,point)

        # Add transition search path for the same letter
        next_beam = add_transition_search_paths(next_beam,
                                        search_path, 
                                        search_path.prev_letter(),
                                        search_path.prev_point(),
                                        point)

        if search_path.isAlignment():
            # Add transition search path for all the possible next letters
            next_letters = get_next_letters_from_path(search_path)

            for letter in next_letter:
                next_beam = add_transition_earch_paths(next_beam,
                                                search_path,
                                                letter,
                                                search_path.prev_point(), 
                                                point)

        curr_beam = next_beam
        curr_beam.sort_by_prob()
        curr_beam = curr_beam.truncate(beam_size)

return curr_beam.truncate(max_candidates)
</code></pre>







<h3 id="heading-key-aligments-and-key-transitions">Key aligments and key transitions</h3>



<p>The functions add_alignment_search_paths and add_transition_search_paths are responsible of adding a new search path to the current beam. This new search path added next to the beam contains the current path in the DAG (a word prefix) with the accumulated probability for this path. Search paths with the same prefix can’t exist. Only the one with the best score is kept.</p>



<p>For add_alignment_search_paths, it is a function that calculates what is the probability for the point and its alignment to a specified key (letter). This probability is calculated by using a gaussian probabily density function (GDPF) applied to the distance between the specified point and the center of the specified key. The gdpf parameters have been adapted to specific dimensions and users typing habits.</p>



<p>For add_transition_search_path, it is a function that calculates what is the probability for the point as a transition from a previous point to a specified key (letter). This probability is calculated using a GDPF applied to the angle between the vectors pp-&gt;cp and pp-&gt;k, where pp is the previous point, cp the current point considered and pk the centre of a specified key.</p>



<p>When all the points of the swipe path have been consumed, the algorithm then scores the remaining candidates with a ngram language model.</p>



<h3 id="heading-example-of-application">Example of application</h3>



<p>In this example we apply the pseudo-code’s invention to a real case sceneario: swipe typing the word <strong>“happen”</strong>.</p>



<h4 id="heading-prerequisites"><strong>Prerequisites</strong></h4>



<p>For this example, we assume that we currently have a simple dictionary including the following contents:</p>



<ul><li>gas</li><li>happen</li><li>happem</li></ul>



<p>We then use a simple unigram language model where we have the probability of each word to occur:</p>



<ul><li>gas: 0.3</li><li>happen: 0.5</li><li>happem: 0.2</li></ul>



<h4 id="heading-example-swipe-path"><strong>Example swipe path</strong></h4>



<p>The swipe path that belongs to the word “happen”, which needs to be decoded, is shown in the following illustration:</p>



<div><figure><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1649234143052/ppoce30t8.png" alt="swipe_path.png"/></figure></div>



<p>For clarity, we can label each point belonging to the swipe path with its order. As you can see, the distance between points depend solely on the speed of the user and the decoder should be robust to the swipe typing habits:</p>



<div><figure><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1649234154646/DKzSH6Nmi.png" alt="swipe_path_with_numbers.png"/></figure></div>



<h4 id="heading-pseudo-code-walkthrough"><strong>Pseudo-code walkthrough</strong></h4>



<p>Following the pseudo-code we start with the starting point of the swipe type (point 1). COPY</p>



<pre><code lang="python">
for starting_letter in starting_letters:

    beam = add_alignment_search_paths(starting_letter,
                                        beam,
                                        new_path,
                                        point)
</code></pre>



<p>We can consider the variable ‘starting_letters’ as all distinct letters that start a word existing in the dictionary. In the dictionary for this example, these letters will be “G” and “H”.</p>



<p>The function “add_alignment_search_paths” will add as search paths to all alignments to the ‘starting_letters’. As we have 2 possible starting letters, we’ll have in the current list of candidates (current beam) the following search paths. The score for each search path is the probability of the point ‘1’ being aligned to the center of the key ‘h’ or the key ‘g’.</p>



<p><strong>current_beam</strong></p>



<ol><li>letter:’h’, score: 0.9, prev_point: 1, type: alignment</li><li>letter: ‘g’, score: 0.2, prev_point: 1, type: alignment</li></ol>



<p><em>N.B.: The scores or probabilities shown in this example are simplified for making the example easier to understand.</em></p>



<p>We then enter in the main loop that will go through all points of the swipe path, starting with the point labeled as ‘2’. Each point will build a new beam based on the current beam. In our example, the first iteration of this loop will have a beam with the two previous search paths.COPY</p>



<pre><code lang="python">for point in swipe_path[1:]:
    next_beam = empty_beam()
    for search_path in current_beam:
</code></pre>



<p>For each search path in the current beam, we need to add a new search path with a possible alignment with the same letter of the search path as well as a transition to the same letter. For simplicity, we need to process all the search paths at the same time. COPY</p>



<pre><code lang="python"># Add alignment search path for the same letter
next_beam = add_alignment_search_paths(search_path.prev_letter(),
                                    next_beam,
                                    search_path,
                                    point)

# Add transition search path for the same letter
next_beam = add_transition_search_paths(next_beam,
                                        search_path,
                                        search_path.prev_letter(),
                                        search_path.prev_point(),
                                        point)
</code></pre>



<p><strong>next_beam</strong></p>



<ol><li>prefix:’h’, score: 0.45, prev_point: 2, type: alignment</li><li>prefix:’g’, score: 0.4, prev_point: 2, type: alignment</li><li>(discarded) prefix:’hh’, score: 0.9, prev_point: 2, type: transition</li><li>(discarded) prefix:’gg’, score: 0.9, prev_point: 2, type: transition</li></ol>



<p>Search paths 3 and 4 are discarded as there are no words starting with ‘hh’ or ‘gg’. Discarded prefixes won’t be shown in the future.</p>



<p>Then we add all possible transitions to another letter (based on the dictionary):COPY</p>



<pre><code lang="python">if search_path.isAlignment():
    # Add transition search path for all the possible next letters
    next_letters = get_next_letters_from_path(search_path)

    for letter in next_letter:    
    next_beam = add_transition_earch_paths(next_beam,
                                            search_path,
                                            letter,
                                            search_path.prev_point(),
                                            point)
</code></pre>



<p>The function ‘get_next_letters_from_path’ will return the letter ‘a’, as it is the only candidate to follow ‘g’ or ‘h’ inside our dictionary:</p>



<p><strong>next_beam</strong></p>



<ol><li>prefix:’h’, score: 0.45, prev_point: 2, type: alignment</li><li>prefix:’g’, score: 0.4, prev_point: 2, type: alignment</li><li>prefix:’ha’, score: 0.8, prev_point: 1, prev_letter: ‘h’, type: transition</li><li>prefix:’ga’, score: 0.5, prev_point: 1, prev_letter: ‘g’, type: transition</li></ol>



<p>Then, we need to sort the remaining search paths by score and only keep the beam_size. This will be the next beam we’ll process in the next iteration:COPY</p>



<pre><code lang="python">curr_beam = next_beam
curr_beam.sort_by_prob()
curr_beam = curr_beam.truncate(beam_size)
</code></pre>



<p><strong>curr_beam</strong></p>



<ol><li>prefix:’ha’, score: 0.8, prev_point: 1, prev_letter: ‘h’, type: transition</li><li>prefix:’ga’, score: 0.5, prev_point: 1, prev_letter: ‘g’, type: transition</li><li>prefix:’h’, score: 0.45, prev_point: 2, type: alignment</li><li>prefix:’g’, score: 0.4, prev_point: 2, type: alignment</li></ol>



<p>We can follow the same process with the rest of the points. We’ll show the point processed and the resulting beam:</p>



<p><strong>Point 3 curr_beam</strong></p>



<ol><li>prefix:’ha’, score: 0.8, prev_point: 1, prev_letter: ‘h’, type: transition</li><li>prefix:’ga’, score: 0.5, prev_point: 1, prev_letter: ‘g’, type: transition</li><li>prefix:’g’, score: 0.3, prev_point: 2, type: alignment</li><li>prefix:’h’, score: 0.2, prev_point: 2, type: alignment</li></ol>



<p>(take into account that some prefixes can be discared if the score is too small)</p>



<p><strong>Point 4 curr_beam</strong></p>



<ol><li>prefix:’ha’, score: 0.7, prev_point: 1, prev_letter: ‘h’, type: transition</li><li>prefix:’ga’, score: 0.4, prev_point: 1, prev_letter: ‘g’, type: transition</li></ol>



<p><strong>Point 5 curr_beam</strong></p>



<ol><li>prefix:’ha’, score: 0.8, prev_point: 1, prev_letter: ‘h’, type: transition</li><li>prefix:’ga’, score: 0.5, prev_point: 1, prev_letter: ‘g’, type: transition</li></ol>



<p><strong>Point 6 curr_beam</strong></p>



<ol><li>prefix:’hap’, score: 0.8, prev_point: 5, prev_letter: ‘a’, type: transition</li><li>prefix:’gas’, score: 0.4, prev_point: 5, prev_letter: ‘a’, type: transition</li><li>prefix:’ha’, score: 0.3, prev_point: 6, type: alignment</li><li>prefix:’ga’, score: 0.2, prev_point: 6, type: alignment</li></ol>



<p><strong>Point 7 curr_beam</strong></p>



<ol><li>prefix:’hap’, score: 0.7, prev_point: 5, prev_letter: ‘a’, type: transition</li><li>(discarded) prefix:’gas’, score: 0.1, prev_point: 5, prev_letter: ‘a’, type: transition</li></ol>



<p>(word “gas” is going to be discarded as point 6 and point 7 are leaving the ‘s’ letter)</p>



<p>We continue the same processing until we reach the last point (point 19) with the following curr_beam:</p>



<p><strong>Point 19 curr_beam</strong></p>



<ol><li>prefix:’happem’, score: 0.8, prev_point: 19, type: alignment</li><li>prefix:’happen’, score: 0.7, prev_point: 19, type: alignment</li></ol>



<p>As this is the final step, we have two candidates that we need to score with the probability coming from language model:</p>



<ul><li>0.8 <em>Plm(happem) = 0.8 </em>0.2 = 0.16</li><li>0.7 <em>Plm(happen) = 0.7 </em>0.5 = 0.35</li></ul>



<p>So, the final decoding candidates will be:</p>



<ol><li>prefix:’happen’, score: 0.35, prev_point: 19, type: alignment</li><li>prefix:’happem’, score: 0.16, prev_point: 19, type: alignment</li></ol>



<h2 id="heading-comparision-with-other-methods">Comparision with other methods</h2>



<p>Our swipe typing decoding uses only geometrical information. This approach uses far less CPU than other methods where speed is privileged. Thanks to the usage of all points inside the swipe path as well as the score calculation of each search path, our method is much more resilient to abnormal movements from the users’ finger.</p>



<p>As a fact, other methods don’t use every swipe path points and use instead some heuristics to decide which points are the best fit for a swipe trajectory. This is not required in our case.</p>



<h2 id="heading-future-work">Future work</h2>



<p>The parameters used by the algorithm (like the beam size and the pruning thresholds) have been calculated using cross validation with swipe data from real users in different languages. In the future, this data can definitely be used to further refine other languages as well to optimize the performance for continuous swipe decoding.</p>



<p>We have plans to use a DAWG (directed acyclic word graph) in order to easily accommodate OOV words using the DAGW as a character-based language model during the decoding process. This will allow us to improve the pruning method even more.</p>



<h2 id="heading-experiments">Experiments</h2>



<p>Our experiments shows that our methods are better in terms of flexibility, speed and memory consumption. In fact, it is a leap in performance compared with using Deep Learning techniques like recurrent neural networks or, transformer models like the Connectionist Temporal Classification (CTC) beam search. </p>



<p>Previous work on our side using such models have shown an increase of 10x in memory consumption and CPU usage, with only one layout per language. With such results, we fully abandoned using these “new techniques” to more proven and reliable ones.</p>
<div data-heateor-sss-href="https://www.fleksy.com/blog/how-swipe-typing-works/"><p>Did you like it? Spread the word:</p></div></div>        
      </div><!--/post-content-->
      
    </div><!--/inner-wrap-->
    
</article>
		</div></div>
  </body>
</html>
