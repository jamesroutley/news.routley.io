<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tonsky.me/blog/clj-reload/">Original</a>
    <h1>New Library: clj-reload</h1>
    
    
<h1 id="the-problem">The problem</h1>
<p>Do you love interactive development? Although Clojure is set up perfectly for that, evaluating buffers one at a time can only get you so far.</p>
<p>Once you start dealing with the state, you get data dependencies, and with them, evaluation order starts to matter, and now you change one line but have to re-eval half of your application to see the change.</p>
<p>But how do you know which half?</p>
<h1 id="the-solution">The solution</h1>
<p>Clj-reload to the rescue!</p>
<p>Clj-reload scans your source dir, figures out the dependencies, tracks file modification times, and when you are finally ready to reload, it carefully unloads and loads back only the namespaces that you touched and the ones that depend on those. In the correct dependency order, too.</p>
<p>Let’s do a simple example.</p>
<p>a.clj:</p>
<pre><code data-lang="clojure">(ns a
  (:require b))</code></pre>
<p>b.clj:</p>
<pre><code data-lang="clojure">(ns b
  (:require c))</code></pre>
<p>c.clj:</p>
<pre><code data-lang="clojure">(ns c)</code></pre>
<p>Imagine you change something in <code>b.clj</code> and want to see these changes in your current REPL. What do you do?</p>
<p>If you call</p>
<pre><code data-lang="clojure">(clj-reload.core/reload)</code></pre>
<p>it will notice that</p>
<ul>
  <li><code>b.clj</code> was changed,</li>
  <li><code>a.clj</code> depends on <code>b.clj</code>,</li>
  <li>there’s <code>c.clj</code> but it doesn’t depend on <code>a.clj</code> or <code>b.clj</code> and wasn’t changed.</li>
</ul>
<p>Then the following will happen:</p>
<pre><code>Unloading a
Unloading b
Loading b
Loading a</code></pre>
<p>So:</p>
<ul>
  <li><code>c</code> wasn’t touched — no reason to,</li>
  <li><code>b</code> was reloaded because it was changed,</li>
  <li><code>a</code> was loaded <em>after</em> the new version of <code>b</code> was in place. Any dependencies <code>a</code> had will now point to the new versions of <code>b</code>.</li>
</ul>
<p>That’s the core proposition of <code>clj-reload</code>.</p>
<h1 id="usage">Usage</h1>
<p>Here, I recorded a short video:</p>
<figure>
  <iframe width="635" height="477" src="https://www.youtube-nocookie.com/embed/Kg3Uvjz0Us0" frameborder="0" allow="autoplay; encrypted-media; picture-in-picture" allowfullscreen=""></iframe>
</figure>
<p>But if you prefer text, then start with:</p>
<pre><code data-lang="clojure">(require &#x27;[clj-reload.core :as reload])

(reload/init
  {:dirs [&quot;src&quot; &quot;dev&quot; &quot;test&quot;]})</code></pre>
<p><code>:dirs</code> are relative to the working directory.</p>
<p>Use:</p>
<pre><code data-lang="clojure">(reload/reload)
; =&gt; {:unloaded [a b c], :loaded [c b a]}</code></pre>
<p><code>reload</code> can be called multiple times. If reload fails, fix the error and call <code>reload</code> again.</p>
<p>Works best if assigned to a shortcut in your editor.</p>
<h1 id="usage-return-value">Usage: Return value</h1>
<p><code>reload</code> returns a map of namespaces that were reloaded:</p>
<pre><code data-lang="clojure">{:unloaded [&lt;symbol&gt; ...]
 :loaded   [&lt;symbol&gt; ...]}</code></pre>
<p>By default, <code>reload</code> throws if it can’t load a namespace. You can change it to return exception instead:</p>
<pre><code data-lang="clojure">(reload/reload {:throw false})

; =&gt; {:unloaded  [a b c]
;     :loaded    [c b]
;     :failed    b
;     :exception &lt;Throwable&gt;}</code></pre>
<h1 id="usage-choose-what-to-reload">Usage: Choose what to reload</h1>
<p>By default, clj-reload will only reload namespaces that were both:</p>
<ul>
  <li>Already loaded</li>
  <li>Changed on disk</li>
</ul>
<p>If you pass <code>:only :loaded</code> option to <code>reload</code>, it will reload all currently loaded namespaces, no matter if they were changed or not.</p>
<p>If you pass <code>:only :all</code> option to <code>reload</code>, it will reload all namespaces it can find in the specified <code>:dirs</code>, no matter whether loaded or changed.</p>
<h1 id="usage-skipping-reload">Usage: Skipping reload</h1>
<p>Some namespaces contain state you always want to persist between reloads. E.g. running web-server, UI window, etc. To prevent these namespaces from reloading, add them to <code>:no-reload</code> during <code>init</code>:</p>
<pre><code data-lang="clojure">(reload/init
  {:dirs ...
   :no-reload &#x27;#{user myapp.state ...}})</code></pre>
<h1 id="usage-unload-hooks">Usage: Unload hooks</h1>
<p>Sometimes your namespace contains stateful resource that requires proper shutdown before unloading. For example, if you have a running web server defined in a namespace and you unload that namespace, it will just keep running in the background.</p>
<p>To work around that, define an unload hook:</p>
<pre><code data-lang="clojure">(def my-server
  (server/start app {:port 8080}))

(defn before-ns-unload []
  (server/stop my-server))</code></pre>
<p><code>before-ns-unload</code> is the default name for the unload hook. If a function with that name exists in a namespace, it will be called before unloading.</p>
<p>You can change the name (or set it to <code>nil</code>) during <code>init</code>:</p>
<pre><code data-lang="clojure">(reload/init
  {:dirs [...]
   :unload-hook &#x27;my-unload})</code></pre>
<p>This is a huge improvement over <code>tools.namespace</code>. <code>tools.namespace</code> doesn’t report which namespaces it’s going to reload, so your only option is to stop everything before reload and start everything after, no matter what actually changed.</p>
<h1 id="usage-keeping-vars-between-reloads">Usage: Keeping vars between reloads</h1>
<p>One of the main innovations of <code>clj-reload</code> is that it can keep selected variables between reloads.</p>
<p>To do so, just add <code>^:clj-reload/keep</code> to the form:</p>
<pre><code data-lang="clojure">(ns test)

(defonce x
  (rand-int 1000))

^:clj-reload/keep
(def y
  (rand-int 1000))

^:clj-reload/keep
(defrecord Z [])</code></pre>
<p>and then reload:</p>
<pre><code data-lang="clojure">(let [x test/x
      y test/y
      z (test/-&gt;Z)]
  
  (reload/reload)
  
  (let [x&#x27; test/x
        y&#x27; test/y
        z&#x27; (test/-&gt;Z)]
    (is (= x x&#x27;))
    (is (= y y&#x27;))
    (is (identical? (class z) (class z&#x27;)))))</code></pre>
<p>Here’s how it works:</p>
<ul>
  <li><code>defonce</code> works out of the box. No need to do anything.</li>
  <li><code>def</code>/<code>defn</code>/<code>deftype</code>/<code>defrecord</code>/<code>defprotocol</code> can be annotated with <code>^:clj-reload/keep</code> and can be persistet too.</li>
  <li>Project-specific forms can be added by extending <code>clj-reload.core/keep-methods</code> multimethod.</li>
</ul>
<p>Why is this important? With <code>tools.namespace</code> you will structure your code in a way that will work with its reload implementation. For example, you’d probably move persistent state and protocols into separate namespaces, not because logic dictates it, but because reload library will not work otherwise.</p>
<p><code>clj-reload</code> allows you to structure the code the way business logic dictates it, without the need to adapt to developer workflow.</p>
<p>Simply put: the fact that you use <code>clj-reload</code> during development does not spill into your production code.</p>
<h1 id="comparison-evaluating-buffer">Comparison: Evaluating buffer</h1>
<p>The simplest way to reload Clojure code is just re-evaluating an entire buffer.</p>
<p>It works for simple cases but fails to account for dependencies. If something depends on your buffer, it won’t see these changes.</p>
<p>The second pitfall is removing/renaming vars or functions. If you had:</p>
<pre><code data-lang="clojure">(def a 1)

(def b (+ a 1))</code></pre>
<p>and then change it to just</p>
<pre><code data-lang="clojure">(def b (+ a 1))</code></pre>
<p>it will still compile! New code is evaluated “on top” of the old one, without unloading the old one first. The definition of <code>a</code> will persist in the namespace and let <code>b</code> compile.</p>
<p>It might be really hard to spot these errors during long development sessions.</p>
<h1 id="comparison-require--reload-all">Comparison: <code>(require ... :reload-all)</code></h1>
<p>Clojure has <code>:reload</code> and <code>:reload-all</code> options for <code>require</code>. They do track upstream dependencies, but that’s about it.</p>
<p>In our original example, if we do</p>
<pre><code data-lang="clojure">(require &#x27;a :reload-all)</code></pre>
<p>it will load both <code>b</code> and <code>c</code>. This is excessive (<code>b</code> or <code>c</code> might not have changed), doesn’t keep track of downstream dependencies (if we reload <code>b</code>, it will not trigger <code>a</code>, only <code>c</code>) and it also “evals on top”, same as with buffer eval.</p>
<h1 id="comparison-toolsnamespace">Comparison: tools.namespace</h1>
<p><a href="https://github.com/clojure/tools.namespace">tools.namespace</a> is a tool originally written by Stuart Sierra to work around the same problems. It’s a fantastic tool and the main inspiration for <code>clj-reload</code>. I’ve been using it for years and loving it, until I realized I wanted more.</p>
<p>So the main proposition of both <code>tools.namespace</code> and <code>clj-reload</code> is the same: they will track file modification times and reload namespaces in the correct topological order.</p>
<p>This is how <code>clj-reload</code> is different:</p>
<ul>
  <li><code>tools.namespace</code> reloads every namespace it can find. <code>clj-reload</code> only reloads the ones that were already loaded. This allows you to have broken/experimental/auxiliary files lie around without breaking your workflow <a href="https://clojure.atlassian.net/browse/TNS-65">TNS-65</a></li>
  <li>First reload in <code>tools.namespace</code> always reloads everything. In <code>clj-reload</code>, even the very first reload only reloads files that were actually changed <a href="https://clojure.atlassian.net/browse/TNS-62">TNS-62</a></li>
  <li><code>clj-reload</code> supports namespaces split across multiple files (like <code>core_deftype.clj</code>, <code>core_defprint.clj</code> in Clojure) <a href="https://clojure.atlassian.net/browse/TNS-64">TNS-64</a></li>
  <li><code>clj-reload</code> can see dependencies in top-level standalone <code>require</code> and <code>use</code> forms <a href="https://clojure.atlassian.net/browse/TNS-64">TNS-64</a></li>
  <li><code>clj-reload</code> supports load and unload hooks per namespace <a href="https://clojure.atlassian.net/browse/TNS-63">TNS-63</a></li>
  <li><code>clj-reload</code> can specify exclusions during configuration, without polluting the source code of those namespaces.</li>
  <li><code>clj-reload</code> can keep individual vars around and restore previous values after reload. E.g. <code>defonce</code> doesn’t really work with <code>tools.namespace</code>, but it does with <code>clj-reload</code>.</li>
  <li><code>clj-reload</code> has 2× smaller codebase and 0 runtime dependencies.</li>
  <li><code>clj-reload</code> doesn’t support ClojureScript. Patches welcome.</li>
</ul>
<h1 id="thats-it">That’s it!</h1>
<p>Clj-reload grew from my personal needs on Humble UI project. But I hope other people will find it useful, too.</p>
<p>Let me know what works for you and what doesn’t! I’ll try to at least be on par with <code>tools.namespace</code>.</p>
<p>And of course, here’s the link:</p>
<figure>
<a href="https://github.com/tonsky/clj-reload"><img src="https://tonsky.me/blog/clj-reload/banner@2x.webp"></a></figure>


  </body>
</html>
