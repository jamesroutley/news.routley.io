<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://socket.dev/blog/social-engineering-campaign-npm-malware">Original</a>
    <h1>Social engineering campaign targeting tech employees spreads through NPM malware</h1>
    
    <div id="readability-page-1" class="page"><article>
    

    <p><strong>Monday, July 24, 2023</strong></p>

    <p>Last Wednesday just before 3pm, I went pack up my laptop to get ready to drive 7 hours to visit my family in Ohio.
Fedora had some updates to apply and when it went to come back on after those, I saw the words no one wants to see:</p>
<blockquote>
<p>Default Boot Device Missing or Boot Failed. </p>
</blockquote>
<p>Panic sets in, because this is my main machine and it&#39;s not coming on.
I tried a few things but long story short, it&#39;s dead as a doornail.
After we got in that night, I confirmed that the SSD was dead and the motherboard was fine.
I guess that&#39;s good.</p>
<p>The next day I got to start the recovery process.
Well, when life gives you lemons, make <del>lemonade</del> ✨ content ✨.
My recovery process was pretty smooth, and this post talks about how I setup machines to make it painless to setup a new one.
I&#39;ll cover backups and restoration first, then my dev environment setup, then some odds and ends that make life easier.</p>

<p>Fortunately when my SSD died, I had relatively recent backups.
I use <a href="https://restic.readthedocs.io/en/stable/">restic</a> and have had a great experience with it.
My backups are stored, encrypted, on Backblaze B2, and I run them manually<sup><a href="#1">1</a></sup> each week.</p>
<p>The only stuff I worry about backing up is files in my home directory.
Anything outside of that on my personal machines is disposable, and programs are installed separately in my dev environment setup (next section).
Doing it this way means when I need to recover from a dead machine, I can easily pull down all the files I care about and be back up and running in just how long that download takes.</p>
<p>The script I use weekly is straightforward:</p>
<pre data-lang="bash"><code data-lang="bash">#!/bin/bash

source env.sh
sudo -E restic -r b2:$BUCKET:$REPO --verbose backup --exclude-caches --exclude-file=./.restic-exclude /home/nicole

</code></pre>
<p><code>env.sh</code> is another script which looks like this:</p>
<pre data-lang="bash"><code data-lang="bash">#!/bin/bash

export BUCKET=XXX
export REPO=XXX
export B2_ACCOUNT_ID=XXX
export B2_ACCOUNT_KEY=XXX
export RESTIC_PASSWORD=XXX
</code></pre>
<p>This is a bash script instead of something like a .env file so that I can use it without <em>any</em> dependencies on the system.
The goal here is disaster recovery where no tools are available yet on the new system.</p>
<p>The main backup script runs a restic command, which we can break down piece by piece:</p>
<ul>
<li><code>sudo -E</code> runs as root while inheriting the environment variables, so it will get the B2_ACCOUNT_ID and whatnot from env.sh</li>
<li><code>restic -r &lt;location&gt; --verbose backup &lt;options&gt; /home/nicole</code> does the backup itself, with some more options added on to exclude caches and whatnot, and then specify my home directory</li>
</ul>
<p>That&#39;s all there is to it!</p>
<p>To restore, I created a temporary directory and ran:</p>
<pre data-lang="bash"><code data-lang="bash">restic -r &lt;location&gt; --verbose=3 restore -t Restored/ &lt;snapshot-hash&gt;
</code></pre>
<p>It was fairly straightforward, but took a long time.
My one gripe with restic is that restores <em>cannot be resumed</em> if interrupted.
Mine was interrupted because I&#39;d set a low threshold on daily spend limit for my B2 bucket, which I hit when 3/4 done downloading my restore.
I had to then wait for a new cap to take effect, then redo the entire restore on a relatively slow internet connection.
It worked, but wouldn&#39;t be tenable if I had a flaky internet connection.</p>
<p>If you don&#39;t have backups setup, make sure you do so!
It makes the whole disaster recovery process less stressful knowing that my data <em>is</em> able to be restored.
Also make sure you regularly test your backups; I&#39;d not done a restore before this one, and now I know to work it into my routine.</p>

<p>Every developer has their own way of setting up their local environment.
Some people do it manually each time, making each machine a bespoke experience.
Others go full bore and use devops automation tooling, like Ansible, to manage their dev machines.
I&#39;m somewhere in the middle with managed chaos.</p>
<p>My <a href="https://git.sr.ht/~ntietz/config">config repo</a> is open source (AGPL) and is the same repo I&#39;ve used to store my config files for all my dev machines since 2011.
Its organization has changed a bit as I&#39;ve evolved how I do things, but now it comes down to a couple of bash scripts and a pile of config files that I link into the right spots.</p>
<p>The bash scripts are straightforward. I start with a bootstrap script and then run a config script.</p>
<p>The job of the bootstrap script is to install the essential programs that I need for daily life as a software engineer.
I used to make this full of conditionals so that I could rerun it.
Now the one I use (<code>fedora_bootstrap.sh</code> in the repo) is mostly just a couple of <code>dnf</code> installs, installing rustup, and installing other tools like tmuxinator.
This one changes <em>each</em> time I run it; I keep it simple and tweak it based on what I want on each machine.
It&#39;s easier to just edit it each time than make a more complicated config system, although the itch is there... convince me!</p>
<p>The second script is the meat of the actual config work for all my scripts.
The config files (or &#34;dotfiles&#34; in dev parlance) are stored in their respective directories.
Neovim configuration is in <code>./nvim/</code>, my bashrc and profile are in <code>./bash/</code>, etc.
To install these, I have a <code>config.sh</code> script which uses <a href="https://www.gnu.org/software/stow/">stow</a> to link them into my home directory:</p>
<pre data-lang="bash"><code data-lang="bash">#!/bin/bash

stow -t ~ bash
stow -t ~ git
stow -t ~ tmux
stow -t ~ nvim
stow -t ~ editorconfig
stow -t ~/.config/ tmuxinator
</code></pre>
<p>And like that, the config files are all in place!</p>
<p>After setting those up, I have to go through and do things like install my neovim plugins.
This is a manual process but a very easy one (run <code>:PlugUpdate</code> once), so I haven&#39;t had the urge to automate it yet since I don&#39;t have to do this very often.
It could be neat, though, especially to do it in an idempotent way!</p>
<p>That&#39;s really all I have to it.
Since my setup is pretty light, and it&#39;s all in git, I check out the repo and do this stuff.
It&#39;s very empowering to be able to quickly, effortlessly spin up a new dev environment!</p>

<p>Now there are also some other programs I setup that aren&#39;t explicitly my dev environment (I wouldn&#39;t install these on a remote server) but which are handy for my quality of life when working on projects.</p>
<p>The first program I love here is <a href="https://extensions.gnome.org/extension/4548/tactile/">Tactile</a>, which is a Gnome extension that lets you easily resize windows to certain portions of the screen.
I like the idea of tiling window managers but I&#39;ve never managed to switch to one and I like to do minimal configuration on my machines.
So this is a nice middle ground.
It lets me use Gnome but easily resize things and tile them.</p>
<p>Next up is an email and calendar client.
I am prone to getting distracted by every little thing, so having a dedicated mail client (currently Thunderbird) lets me refer to emails and my calendar without the pit of distractions that is a web browser.</p>
<p>I also use Obsidian for note-taking on my personal projects, so that gets installed as well.
I use it in a fairly naive way, keeping daily notes and having a poorly organized personal wiki, but it works well and gives me a place to organize a chaotic mess of thoughts.
Can&#39;t do without it now!</p>
<p>And of course, my password manager (currently 1Password) also has to be installed.
This is essential for everything in life now.
If you don&#39;t use one, get one.
It makes you more secure <em>and</em> makes things more convenient.</p>
<p>Oh, final thing: I set <a href="https://dtinth.github.io/comic-mono-font/">Comic Mono</a> as my terminal font, and Ayu Light as the color scheme.
These are manual processes which I should automate someday.
I started using the font as a joke but unironically love it and believe it&#39;s the best coding font out there.
I&#39;m reasonably happy with Ayu Light as the color scheme but would welcome suggestions for other light mode color schemes!</p>
<hr/>
<p>If you do anything differently, I&#39;d love to hear about what you do and why!
I could also write about my specific choices of dev tools (nvim and which plugins, bash over zsh, tmux, etc.) if anyone is interested.</p>
<p>Now that this disaster recovery is done, I&#39;m going to get back to, shall we say, my regularly scheduled <em>programming</em>.</p>
<hr/>


  </article><p>
    If this post was enjoyable or useful for you, <strong>please share it!</strong>
    If you have comments, questions, or feedback, you can email <a href="mailto:me@ntietz.com">my personal email</a>.
    To get new posts, subscribe to the <a href="https://ntietz.com/newsletter/">newsletter</a> or use the <a href="https://ntietz.com/atom.xml">RSS feed</a>.
  </p></div>
  </body>
</html>
