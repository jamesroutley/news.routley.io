<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://codesimple.blog/2019/02/16/events-fat-or-thin/">Original</a>
    <h1>Events: Fat or Thin?</h1>
    
    <div id="readability-page-1" class="page"><article id="post-2223">
	<!-- .entry-header -->

	<div>
		
<p>When it comes to the events, the big debate is about the contents of its body. Martin Fowler has written a great <a href="https://martinfowler.com/articles/201701-event-driven.html">post</a> on this topic.</p>



<p>Some devs argue that events should carry the complete load with it, I am calling them <strong>Fat Events</strong> (Event Carried State Transfer) in this blog.And then we have others who believe that events should be lightweight and containing minimum details, hence I call them <strong>Thin Events</strong> (Event Notification). In Thin Events, subscriber of the event is expected to request the required data after receiving the event.</p>



<p>Like every other dilemma in choosing suitable design patterns, this is a hard question to answer and it depends on various things. Lets compare them:</p>



<ul>
<li>Thin Events add coupling which is one of concerns we wanted to address by using events. It forces the event subscriber to call the publisher APIs to get more details. This means a subscriber cannot do its job if the publisher is down. In case of a bulk execution, it can adversely impact the APIs it will be calling. In contrast, Fat Events remove that dependency  and lead to a better decoupling of the systems. </li>



<li>The data in any event could be outdated by the time it is processed. This impacts both sides in quite opposite ways. Thin Events shine when the real-time information is crucial at the time of processing while Fat Events work better where sequential or point-in-time processing is required. </li>



<li>Deciding the contents for an event is the part where Thin Events win, simply because it will only contain the bare minimum details for the subscriber to call back if required. But for Fat Events, we will have to think about the event body. We want to carry enough for all the subscribers but it comes at an expense: the publisher model would be coupled to the contract. It also adds an unnecessary dependency to consider in case you want to remove some data from the domain.</li>
</ul>



<p><strong>Thin Events do not cut it for me</strong></p>



<p>From my experience so far, I think Thin Events does not offer anything that Fat Events cannot. As with Fat Events, the subscriber can also choose to call back the API if needed. In fact, I tried to think of an example where calling back the publisher is the only way to get the real time information but in those cases it felt like the bounded contexts are not cut right. However, in certain circumstances the use case may not allow putting the payload on the events if the published on uncontrolled/unprotected or low bandwidth infrastructure. In those cases event can carry a reference (URI) back to the change (e.g. resource, entity, event etc.).</p>



<p><strong>So are Fat Events the answer?</strong></p>



<p>It depends, though carrying the complete object graph with every event is not a good idea. Loosely coupled bounded contexts are meant to be highly cohesive to act as a whole, so when you create event of a domain model, the question is how far you go in the object graph i.e. to an aggregate, or a bounded contexts or includes entities outside bounded context as well. We have to be very careful, as noticed above, it tightly couple the event contents to your domain model. So we don’t want thin events then how fat our event should be?</p>



<p>There are two further options, event body based on the event purpose (Delta Event) or the aggregate it represents (Aggregate Event).</p>



<p><strong>Delta Events</strong></p>



<p>I am not sure if ‘Delta Events’ is a known term for this, but it is the best name I could think to describe the event contents. The basic concept is to make events carry ‘just enough details’ to describe the change in addition to the identity (Id) of the entities changed. Delta events work even better with the Event Sourcing because they are like a log of what has happened, which is the basic foundation of the Event Sourcing.</p>



<p>So in Delta Events, the contents can consist of:</p>



<ul>
<li>Public Id of the primary entity, that event is broadcast for.</li>



<li>Fields that have changed in the event.</li>
</ul>



<p>e.g. <strong>AccountDebited</strong></p>


<div><pre title="">{
    AccountHolderUserId: &lt;Account holder Id&gt;
    FromAccountNumber: &#34;&lt;Account Number that is debited from&gt;&#34;
    ToAccountNumber: &#34;&lt;Account Number that money is credited to&gt;&#34;
    Description: &#34;Description of transaction&#34;
    AmountDebited:  &#34;&lt;Amount that is debited from the account&gt;&#34;
    Balance: &#34;&lt;Balance remaining after this transaction&gt;&#34;
    TransactionId: &#34;&lt;To correlate with the parent transaction&gt;&#34;
}
</pre></div>


<p>The event above carries the complete details to explain what has happened along with the public Id of the entities involved. </p>



<p><strong>Aggregate Event</strong></p>



<p>We can make it a Fat Event and carry the additional content such as the Account holder name for the systems which may need that information e.g. notification, reporting, etc. But unfortunately, that will couple publisher domain unnecessarily to that data it does not need. So to work out the right content for the event, we will apply two key principles:</p>



<p><a href="https://en.wikipedia.org/wiki/Domain-driven_design">Domain-Driven Design</a>: Scope the event body to the aggregate level. As Martin Fowlers explains in his <a href="https://martinfowler.com/bliki/DDD_Aggregate.html">post</a>, aggregate is the smallest unit of consistency in Domain-Driven Design. </p>



<blockquote>
<p>A DDD aggregate is a cluster of domain objects that can be treated as a single unit. </p>
</blockquote>



<p><a rel="noreferrer noopener" href="https://queue.acm.org/detail.cfm?id=3415014" target="_blank">Data On The Outside</a>: Events are an external interface of our system. So they fall into the “Data On the Outside” category explained in an excellent paper “<a rel="noreferrer noopener" href="http://cidrdb.org/cidr2005/papers/P12.pdf" target="_blank">Data on the Outside versus Data on the Inside</a>” by Pet Helland. Applying the constraints of sharing data outside the bounded context, we will send a complete snapshot of the aggregate, including the fields that didn’t change as part of the event. This allows the consumer to keep the point-in-time reference of the state. I have unpacked this concept in my other post: <a href="https://codesimple.blog/2021/03/14/events-on-the-outside-vs-events-on-the-inside/" rel="nofollow">https://codesimple.blog/2021/03/14/events-on-the-outside-vs-events-on-the-inside/</a></p>



<p>By following these principles, the body of the event contains the model for the aggregate (i.e. transaction) and a sequence number to highlight the point in time reference to the state of the aggregate.</p>



<p>e.g. <strong>AccountDebited</strong></p>


<div><pre title="">{
    Sequence: Timestamp / Sequence Number,
    Transaction: {  
        TransactionId: &#34;&lt;To correlate with the parent transaction&gt;&#34;,
        FromAccountNumber: &#34;&lt;Account Number that is debited from&gt;&#34;,
        ToAccountNumber: &#34;&lt;Account Number that money is credited to&gt;&#34;,
        Description: &#34;Description of transaction&#34;,
        Amount:  &#34;&lt;Amount that is debited from the account&gt;&#34;,
        Balance: &#34;&lt;Balance remaining after this transaction&gt;&#34;
    }
}
</pre></div>






<p><strong>How does the subscriber get the missing pieces?</strong></p>



<p>In both above event types, there can be some related information that is not present in the event body e.g. references to entities of other bounded context such as account holder name. It depends on the situation, for a new subscriber you may want to listen to the other events in the system and build a database of the subscriber’s domain. </p>



<p>Let’s assume we have a Notification domain that will send an SMS to the account holder whose account will be debited if the amount to debit is above $100.00.  SMS body would be like:</p>



<blockquote>
<p>Hi &lt;First Name&gt; &lt;Last Name&gt;,</p>



<p>Your account number &lt;account number&gt; is debited. Transaction details:</p>



<p>Amount: $&lt;amount&gt;</p>



<p>Remaining Balance: $&lt;remaining balance&gt;</p>



<p>Description: $:&lt;Transaction description&gt;</p>
</blockquote>



<p>For the sake of an example, lets assume our system is cut into the following sub domains:</p>



<ul>
<li>User Profile: Maintains account holder details such as Name, Address, Mobile Number and Email etc.</li>



<li>Notification: Maintain user preferences about receiving notifications and sending notifications.</li>



<li>Accounts: Maintain ledger of debits and credits of accounts</li>
</ul>



<figure><img src="https://yuml.me/4caccc7f.png" alt=""/></figure>



<p>To send the SMS, we have almost all the details in the event body except the account holder name and mobile number of the recipient. In our imaginary system, it is the user profile domain that has those details instead of the accounting domain, that is broadcasting the event. There are two things that can happen here:</p>



<p>Notification domain can call the User Profile to get more details before sending the SMS. So now we always get the up to date contact details of the user but at the cost of run time dependency. If User Profile system is down for any reason, it would break the notification system as well.</p>



<p>OR</p>



<p>We can make the notification system listen to the events from the User Profile system as well to maintain a local database of its recipients (translated from account holders) along with their notification preferences.  e.g.</p>



<ul>
<li>UserProfileAdded</li>



<li>UserProfileUpdated</li>
</ul>



<p>I prefer the later option to keep the system decoupled and avoid run time dependency. The workflow will be like this:</p>



<figure><img data-attachment-id="2228" data-permalink="https://codesimple.blog/image/" data-orig-file="https://satjinderdotcom.files.wordpress.com/2019/03/image.png" data-orig-size="1011,689" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image" data-image-description="" data-image-caption="" data-medium-file="https://satjinderdotcom.files.wordpress.com/2019/03/image.png?w=300" data-large-file="https://satjinderdotcom.files.wordpress.com/2019/03/image.png?w=900" src="https://satjinderdotcom.files.wordpress.com/2019/03/image.png" alt=""/></figure>



<p>The subscriber will build the store as they go, but still there can be scenarios where they don’t have this data:</p>



<ol>
<li>New Subscriber</li>



<li>An event lost for some reason – not sent, not delivered, delivered but failed etc.</li>
</ol>



<p>For the first scenario you can start with some data migration to give it a seed data, but for the second case data migration may not work. I have dealt with this situation by introducing a snapshot builder. </p>



<p><strong>Snapshot Builder:</strong></p>



<p>If subscriber does not know about the entity it has received in the event, it would call the relevant systems and build a snapshot. This can be quite  handy in scenarios where occasionally the subscriber needs to sync its data (translated from other domains) with the original owner of the data. </p>



<figure><img data-attachment-id="2235" data-permalink="https://codesimple.blog/snapshotbuilder/" data-orig-file="https://satjinderdotcom.files.wordpress.com/2019/03/snapshotbuilder.png" data-orig-size="967,460" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="snapshotbuilder" data-image-description="" data-image-caption="" data-medium-file="https://satjinderdotcom.files.wordpress.com/2019/03/snapshotbuilder.png?w=300" data-large-file="https://satjinderdotcom.files.wordpress.com/2019/03/snapshotbuilder.png?w=900" src="https://satjinderdotcom.files.wordpress.com/2019/03/snapshotbuilder.png" alt=""/></figure>



<p>I hope you find this post useful, if not the complete approach, it may give you some options to consider when thinking about the event contents.</p>
			</div><!-- .entry-content -->

	<!-- .entry-footer -->
</article></div>
  </body>
</html>
