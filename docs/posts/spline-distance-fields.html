<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zone.dog/braindump/spline_fields/">Original</a>
    <h1>Spline Distance Fields</h1>
    
    <div id="readability-page-1" class="page">ï»¿

  
    <title>Spline Distance Fields</title>
    <meta charset="utf-8"/>
    
  
  
    
    <p>
      December 31th, 2024
    </p>
    <h2 id="problem">Problem</h2>
    <p>
      Earlier this year I decided to put my main project Tangerine on hold
      indefinitely and began prototyping
      <a href="https://github.com/aeva/star-machine">a new renderer</a>
      in an <a href="https://en.wikipedia.org/wiki/C_Sharp_(programming_language)">unfamiliar language</a>
      using a <a href="https://github.com/libsdl-org/SDL/pull/9312">totally new graphics API</a>
      with the goal of overcoming all of Tangerine&#39;s technical shortcomings.
      The new renderer is an eccentric CPU ray tracer called Star Machine that
      boasts the ability to <em>effortlessly</em> push 4k frames at 120hz or
      better <em>irrespective of scene complexity</em>, a custom coordinate
      system that limits the play space to roughly <em>940.7 astronomical
      units</em> with a constant world resolution of 15 micrometers, and a
      <em>truly unique</em> visual style.  To prove out the underlying theories and
      help me prioritize what to work on, I am also developing a time trial
      racing game called
      <a href="https://mastodon.gamedev.place/@aeva/113104448301517076">Rainy Road</a>.
    </p>
    <p>
      At this time of writing, Rainy Road lacks a way to render terrain.  These
      are my requirements for its terrain rendering system:
    </p>
    <ol>
      <li>
        Some terrain features (roads specifically) must be defined as splines.
      </li>
      <li>
        Terrain features must be composable, allowing for map sections to be
        rapidly swapped out at runtime.
      </li>
      <li>
        The system must be useful for procedural object placement.
      </li>
      <li>
        Terrain data must be fast to process into rendering intermediaries.
      </li>
      <li>
        Terrain data must be very compact.  An implicit representation is
        preferred if possible.
      </li>
      <li>
        Iterating on designing level sections must be quick and easy.
      </li>
      <li>
        I&#39;d like to use existing tools where possible.
      </li>
      <li>
        I&#39;m not interested in using proprietary tools for this project.
      </li>
    </ol>
    <p>
      A quick survey of existing terrain editing tools revealed that virtually
      all general purpose terrain editors violate at least one of these
      constraints, and unsurprisingly I did not find any terrain tools
      available targeting my particular niche.
    </p>
    <p>
      The next most obvious course of action is to use low resolution
      heightmaps with a good noise function to give it the illusion of being
      continous.  I&#39;ve seen games (which are now 20+ years old now) use this
      technique to great effect, so I consider this to be pretty low risk.
      Additionally, I figure I can use Blender to rapidly iterate on variations
      of this technique, and once I am satisfied it can function as the level
      editor.
    </p>
    <p>
      My experimentation in Blender (and lots of great feedback from internet
      people experienced on the subject) quickly revealed that reasoning about
      landscapes and roads in isolation from one another &#34;adds skill&#34; a bit
      more than I would like, and so I see this as a good opportunity to
      develop structured workflows and supporting tools to take me to the
      places I want to go.
    </p>
    <h2 id="solution">Solution</h2>
    <p>
      This particular conceptual brick in the washing machine has led me to
      deeply internalizing what I now know to be a fundamental law of design
      and composition that applies <em>universally</em>:
    </p>
    <p>
      <a href="https://en.wikipedia.org/wiki/Tobler%27s_first_law_of_geography">
        <strong><em>Everything Affects Everything</em></strong>
      </a>
    </p>
    <p>
      In the real world roads are built along whatever happens to be the most
      circumstantially optimal route through the world they are to exist
      within.  The landscape (among other things) affects the decision of
      where to put a road, and in turn the road changes the landscape.
    </p>
    <p>
      If we know where some things <em>must</em> be, then we can infer what
      surrounds those thing.  We can eschew the input height map entirely, and
      instead generate the terrain from only points and splines, possibly in
      real time.
    </p>
    <p>
      It turns out there&#39;s
      <a href="https://en.wikipedia.org/wiki/Spatial_analysis">a whole field of math about this stuff</a>
      already that I didn&#39;t even know existed until after developing the
      spline distance fields technique and posting about it on Mastodon, and
      at this time of writing, I have not yet explored it in any significant
      depth.
    </p>
    <p>
      According to my journal, on September 20th of 2024 I realized I could
      generate plausible terrain surfaces entirely from splines that describe
      the important terrain features (rivers, roads, rails, cliffs, etc).  In
      its simplest form each point in space has a corresponding closent point
      on the closest spline.  That closest-point-on-closest-spline (along with
      its corresponding binormal vector) defines a plane that determines the
      local elevation relative to your original arbitrary point in space.  This
      effectively is a method of extruding splines within a constraining
      volume of space that suspiciously resembles a voronoi diagram (because it
      secretly is one, but don&#39;t worry about that).
    </p>
    <p>
      Things get a bit dicey for sampling points that are close to the boundary
      of a spline field, but as I wrote in my journal, these inbetween spaces
      should simply be &#34;interpolated somehow&#34;.  I call this the &#34;liminality
      problem&#34;.  This can appear similar to subduction and obduction in real
      life, and so this quality may be reasonably considered a useful feature
      if it can be handled intentionally.  However, in most cases you will want
      your spline zones to flow together seamlessly, and so this article only
      describes a method that sweeps the problem under the rug.
    </p>
    <p>
      <a href="https://mastodon.gamedev.place/@aeva/113174121732654836">The next day</a>
      I put this idea to the test, and this is what I got:
    </p>
    <p>
      <img src="https://zone.dog/braindump/spline_fields/spline_field_a.png"/>
    </p>
    <p>
      Applying what I learned from making that first test, I produce this
      second attempt right away:
    </p>
    <p>
      <img src="https://zone.dog/braindump/spline_fields/spline_field_b.png"/>
    </p>
    <p>
      <a href="https://mastodon.gamedev.place/@aeva/113179963448228702">The following day</a>
      I pushed the technique further to experiment with procedural object
      placement and test out road generation.  This is what I came up with:
    </p>
    <p>
      <img src="https://zone.dog/braindump/spline_fields/spline_field_c.png"/>
    </p>
    <p>
      This is <em>exactly</em> the sort of thing I&#39;ve been searching for.
    </p>
    <p>
      This technique is still an area of active experimentation and research
      for me:
    </p>
    <ul>
        <li>
          This technique can be modified to describe
          <a href="https://mastodon.gamedev.place/@aeva/113303633154607005">freeform 3D surfaces</a>
          instead of heightmaps.
        </li>
        <li>
          Exploring alternative
          <a href="https://mastodon.gamedev.place/@aeva/113320880275563952">interpolation strategies</a>.
        </li>
        <li>
          Whether or not
          <a href="https://mastodon.gamedev.place/@aeva/113344090802658027">sparse point clouds</a>
          are better than heightmaps as a rendering intermediary for Star Machine.
        </li>
        <li>
          Actually sitting down and implementing this in Star Machine.
        </li>
      </ul>
    
    <p>
      Unfortunately due to my yearly struggle with
      <a href="https://en.wikipedia.org/wiki/Seasonal_affective_disorder">Father Winter</a>
      and a very stressful ongoing dispute with my health insurance, I&#39;ve
      stalled out on this research project for the time being.
    </p>
    <p>
      Until the rains of spring heal my soul and wash away the pain,
    </p>
    
    <p>
      <img src="https://zone.dog/braindump/spline_fields/the_important_part.png"/>
    </p>
    <p>
      The above pseudo code outlines the entire technique.  If this tells you
      everything you need to know to implement it, great!  Be sure to at least
      take a quick look through the <a href="#appendix_b">pretty pictures</a>
      at the end of this post before you close the browser tab.
      Or don&#39;t!  Nobody is paying anyone to hold on to your attention.  You are
      free!  I don&#39;t even know if anyone is even reading this because I don&#39;t
      collect any analytics at all.
    </p>
    <p>
      Now, for everyone who wasn&#39;t born with perfect knowledge of everything,
      the next section of this post walks through how the <em>normal</em>,
      <em>tangent</em>, and <em>binormal</em> vectors work for splines in
      Blender; and the section after that steps through a real working
      implementation of this technique.  Example source files are also
      provided for you to use in any way you like.
    </p>

    <h2 id="relevant_spline_math">Relevant Spline Math</h2>
    <p>
      Blender&#39;s Geometry Nodes system provides a variety of useful high level
      functions for working with Blender&#39;s curve and point cloud primitives, so
      we&#39;re going to use those where possible.  This leaves a few bits of math
      to review  that are important to our implementation.  If you already know
      how to calculate a binormal vector, breeze on over to
      <a href="#generating_the_heightmap">the next section</a>.
    </p>
    <p>
      The first thing we need is the ability to define a plane for any given
      point on a spline.  For our purposes we&#39;ll use a point in space and the
      direction that is perpendicular to the plane (aka &#34;the surface normal&#34; of
      the plane).  In terms of spline parameters, these vectors are called the
      <em>position</em> and the <em>binormal</em>.  Blender does not provide
      the spline&#39;s <em>binormal</em>, but it is very easy to calculate it from
      the spline&#39;s <em>normal</em> and <em>tangent</em> vectors which Blender
      does provide.
    </p>
    <p>
      <strong><em>I cannot stress this enough</em></strong> the thing we want
      here is the thing you&#39;re probably used to calling &#34;the surface normal&#34;,
      <strong>but</strong>âfor
      <a href="https://en.wikipedia.org/wiki/Frenet%E2%80%93Serret_formulas#Definitions">reasons</a>
      I am <em>not</em> responsible forâthe thing we want is instead called the
      &#34;<strong>binormal</strong>&#34; here and the thing that is called the &#34;normal&#34;
      is instead a different thing.  Why did the mathematicians do this to us?!
    </p>
    <p>
      Blender&#39;s splines always define a <em>tangent</em> and <em>normal</em>
      vector for all control points and all interpolated points.  These are
      &#34;unit vectors&#34;, which means they always have a length of one, and they
      encode a direction.  The <em>binormal</em> is the cross product of these
      two vectors, which I&#39;ll illustrate in a little bit.
    </p>
    <h3 id="the_tangent_vector">The Tangent Vector</h3>
    <p>
      The <em>tangent</em> vector is a unit vector that grazes the point on the
      curve.  This vector rests on the surface of the plane we want to
      describe.  This is what it looks like:
    </p>
    <p>
      <img src="https://zone.dog/braindump/spline_fields/tangents.png"/>
    </p>
    <h3 id="the_normal_vector">The Normal Vector</h3>
    <p>
      The <em>normal</em> vector perpendicular to the <em>tangent</em> vector,
      and also rests on the surface of the plane we want to describe.  This is
      what it looks like:
    </p>
    <p>
      <img src="https://zone.dog/braindump/spline_fields/normals.png"/>
    </p>
    <h3 id="calculating_the_binormal">Calculating the Binormal</h3>
    <p>
      To calculate the <em>binormal</em>, take the cross product of the
      <em>normal</em> and <em>tangent</em>, like so:
    </p>
    <p>
      <img src="https://zone.dog/braindump/spline_fields/binormals.png"/>
    </p>

    <h2 id="generating_the_heightmap">Generating the Heightmap</h2>
    <p>
      With the spline&#39;s <em>binormal</em> in hand, now it is time to generate
      the height map.  Here&#39;s the eagle eye view:
    </p>
    <p>
      <img src="https://zone.dog/braindump/spline_fields/the_big_picture.png"/>
    </p>
    <p>
      I find it works best to keep the splines in their own collection.  This
      way the geometry node graph can read alll of the splines from it in one
      go, and you don&#39;t need to change any code to add more splines to your
      terrain.  Only one geometry nodes modifier is required to implement this
      technique, and that placed on an empty mesh.
    </p>
    <p>
      Let&#39;s examine the <strike>spaghetti</strike> program:
    </p>

    <h3 id="curves_to_surfels">Curves to Surfels</h3>
    <p>
      You may have already noticed this, but the curves are just a useful
      editing interface that is immediately discarded.
    </p>
    <p>
      What we&#39;re actually doing is using the curves to generate a set of
      primitives called surfels, and then using the surfels to extrapolate the
      surface of the terrain.  In this particular case, a surfel is defined as
      being a point in space with an associated <strike>normal</strike>
      <em>binormal</em> vector.  Maybe I should have named this technique
      &#34;<em>surfel distance fields</em>&#34;.
    </p>
    <p>
      Since our heightmap starts as a flat subdivided plane, we&#39;ll get the best
      results if we project the surfels onto the XY plane before sampling them
      so that Blender&#39;s sampling functions behave the way we expect them to.
      We still need the original position, so we just capture that attribute to
      snapshot it before flattening.
    </p>
    <p>
      <img src="https://zone.dog/braindump/spline_fields/overview_part_1.png"/>
    </p>

    <h3 id="surfel_sampling">Surfel Sampling</h3>
    <p>
      Next we create the geometry that will be deformed into our terrain.  For
      this we use the <em>Grid</em> node.  <strong>The density of the grid
      affects interpolation behavior</strong>.  The mesh generation method
      described in this page takes the &#34;sweep the error under the rug&#34;
      strategy.  <em>If your vertex density is too high, you will get abrupt
      changes in elevation between locations that belong to different
      curves.</em>  Likewise, if your vertex density is too low, your landscape
      will be soft and featureless.
    </p>
    <p>
      To sample the nearest surfel parameters, use the <em>Sample Nearest</em>
      node to find the index of the nearest surfel to a given vertex on the
      grid.  Then use the <em>Sample Index</em> node to translate that index
      into the parameters we want.  If you&#39;re not familiar with geometry
      nodes&#39;s
      <a href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/fields.html">fields</a>
      concept, the following graph section will look confusing.
    </p>
    <p>
      The <em>Capture Attribute</em> at the end of this part of the program is
      not strictly necessary, but I&#39;ve added it in hopes of making the data
      flow a little clearer.
    </p>
    <p>
      <img src="https://zone.dog/braindump/spline_fields/overview_part_2.png"/>
    </p>

    <h3 id="generate_the_heightmap">Generate the Heightmap</h3>
    <p>
      I&#39;ve mentioned a plane function many times now, and here it finally is!
      The graph section below starts by finding the distance of each point on
      the undeformed heightmap to the closest surfel.  The function for this is
      the <em>signed distance</em> from an arbitrary point in space to the
      nearest point on a plane.  The term &#34;<em>signed distance</em>&#34; means the
      distance can be a negative value, which usually indicates that the
      evaluated point was under the surface of the plane.
    </p>
    <p>
      However, that would imply that a negation would be needed in my code
      below, <em>which is curiously absent</em>.  The reason for this is I
      screwed up the math somewhere here in such a way that inverts the
      polarity of the result.  This elides the need for the negation.  The
      result appears to be correct though.  Please pretend that I am smart and
      meant to do this.  Someone smart once told me that every shipped game
      contains an even number of sign errors.
    </p>
    <p>
      Moving on, once you have the planar distance in hand, I find that bluring
      it a few iterations helps to smooth out any liminality problems, much
      like adjusting the vertex density.  This is not an exact science, but
      generally if you adjust the number of blur iterations or the number of
      verticies, you also have to adjust the other.
    </p>
    <p>
      Finally, we use the blurred distance field value as an position offset
      along the Z axis, and that gets us the deformed terrain mesh.
    </p>
    <p>
      <img src="https://zone.dog/braindump/spline_fields/overview_part_3.png"/>
    </p>

    <h3 id="tada"><em>Tada!</em></h3>
    <p>
      <img src="https://zone.dog/braindump/spline_fields/result.png"/>
    </p>

    
    <p>
      Here are the blend files for the examples shown above:
    </p>
    <ul>
      <li><a href="https://zone.dog/braindump/spline_fields/spline_vectors.blend">Spline Vector Illustrations</a></li>
      <li><a href="https://zone.dog/braindump/spline_fields/spline_distance_fields.blend">Full Spline Distance Field Implementation</a></li>
    </ul>
    <p>
      These example files are made available to you to use for whatever you
      like via your choice of
      <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a> or
      <a href="https://creativecommons.org/licenses/by/4.0/">CC-BY</a>.
    </p>
    <p>
      If you do choose to provide attribution for some reason, credit me as
      &#34;Aeva Palecek&#34; and link to this article if it is reasonable to do so.
    </p>

    
    <h2 id="promising_prototype">Promising Prototype Provokes Preproduction Perturbation</h2>
    <p>
      I put one of my early prototypes into the hands of my dear friend
      <a href="https://bsky.app/profile/bmprager.bsky.social">Bitmap</a> and 30
      minutes later she sent me this message:
    </p>
    <p>
      <img src="https://zone.dog/braindump/spline_fields/unlimited_power_a.png"/>
    </p>
    <p>
      And the next day she sent me this:
    </p>
    <p>
      <img src="https://zone.dog/braindump/spline_fields/unlimited_power_b.png"/></p>
    <p>
      This caused quite a stir for the game production she&#39;s part of, as they
      ended up completely throwing out the Godot terrain tool they were using
      in favor of switching to a new workflow built around the prototype I gave
      her.  I&#39;m equal parts honored and deeply terrified by this development.
    </p>
    <p>
      Bitmap <strike>fucking <em>hates</em></strike> tends to bounce off of
      conventional digital sculpting tools like z-brush and Blender&#39;s sculpt
      mode.  Her artistic background is primarily as a 2D illustrator, and
      she&#39;s found that the way she reasons about form and space is generally
      incompatible with those kinds of tools.
    </p>
    <p>
      I&#39;m very eager to see what things she will create now that she can simply
      <em>draw the terrain</em>.
    </p>
    <p>
      I asked Bitmap and The Director if there were any recent(ish) screenshots
      that would also be ok for me to share in this blog post, and they
      provided me with a treasure trove of gorgeous preproduction progress
      photographs which I&#39;ve included all of below except for the one The Director
      asked me not to:
    </p>
    <p>
      <img src="https://zone.dog/braindump/spline_fields/bmp_a.png"/>
    </p>
    <p>
      <img src="https://zone.dog/braindump/spline_fields/bmp_b.png"/>
    </p>
    <p>
      <img src="https://zone.dog/braindump/spline_fields/bmp_c.png"/>
    </p>
    <p>
      <img src="https://zone.dog/braindump/spline_fields/bmp_d.png"/>
    </p>
    <p>
      <img src="https://zone.dog/braindump/spline_fields/bmp_e.png"/>
    </p>
    <p>
      You may be wondering where all of that nice multitexturing in these
      screenshots fits into this technique.  Bitmap provides a set of flat
      subdivided quads with UVs already prepared, and the tool I provided
      deforms them.  Weight painting is used to control how the textures are
      combined.
    </p>
    <h2 id="sculptor">Sculptor: Non-Destructive 3D Modeling in Godot</h2>
    <p>
      My colleague <a href="https://mastodon.gamedev.place/@dbat">Dbat</a> has
      been hard at working building a procedural modeling tool in Godot called
      <a href="https://codeberg.org/dbat/godot-sculptor">Sculptor</a>.
      Sculptor is a non-destructive 3D sculpting tool that works by deforming
      meshes that have been generated via
      <a href="https://en.wikipedia.org/wiki/Constructive_solid_geometry">CSG</a>.
    </p>
    <p>
      To do this, Dbat has developed an advanced version of the spline distance
      fields technique that enables you to create freeform meshes instead of
      height maps.  Their technique uses ray tracing to iteratively deform
      meshes towards the implicit surface described by the input curves.
      Sculptor exposes parameters that allow you to control the projected shape
      and influence of each curve on the mesh deformation process.  Way cool!
    </p>
    <p>
      Dbat&#39;s technique would pair very nicely with an adaptive tessellation
      system.
    </p>
    <p>
      <img src="https://zone.dog/braindump/spline_fields/sculptor_a.png"/>
    </p>
    <p>
      <img src="https://zone.dog/braindump/spline_fields/sculptor_b.png"/>
    </p>
    <p>
      <img src="https://zone.dog/braindump/spline_fields/sculptor_c.png"/>
    </p>
    <h2 id="Inverse_distance_weighting">Inverse Distance Weighting Variant</h2>
    <p>
      Math wizard <a href="https://mathstodon.xyz/@Danpiker">Danpiker</a>
      <a href="https://mathstodon.xyz/@Danpiker/113191759673781705">wisely pointed out to me</a>
      that the spline distance fields technique is very compatible with
      <a href="https://en.wikipedia.org/wiki/Inverse_distance_weighting">Inverse Distance Weighting</a>.
      Shortly after, Danpiker put together
      <a href="https://mathstodon.xyz/@Danpiker/113192150280297469">this awesome animated demo</a>
      of exactly that.  Here&#39;s a still frame from the demo:
    </p>
    <p>
      <img src="https://zone.dog/braindump/spline_fields/danpiker_inverse_distance_weighting.png"/>
    </p>
    <p>
      Inverse Distance Weighting solves the liminality problem, and produces a
      <em>very</em> slick look.  You can very the degree of influence by
      adjusting the exponents in the equation.
    </p>
    <p>
      I&#39;ve found inverse distance weighting to be a bit tricky to implement
      efficiently in geometry nodes, however the introduction of the
      <em>for-each</em> nodes in Blender 4.3 improves things a bit.
    </p>
    <p>
      Personally, I find the smoothing effect is maybe a bit too effective at
      smoothing things out, as it tends to erase the earthy look I&#39;m going for.
      However, I suspect this is easily overcome with a good displacement map.
    </p>
    <h2 id="closing_thoughts">Closing Thoughts</h2>
    <p>
      I like splines!
    </p>
    <h2 id="future_work">Future Work</h2>
    <p>
      I do not know what the future holds.  Let us brave it together.
    </p>
    </div>
  </body>
</html>
