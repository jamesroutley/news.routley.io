<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hypirion.com/musings/use-python-for-scripting">Original</a>
    <h1>Using Python for Scripting</h1>
    
    <div id="readability-page-1" class="page"><div id="content"><article>



<p>We all like to use the simplest tool that solves our problem, but it’s
not always optimal in the long run, nor when you want to run it on
multiple machines.</p>

<p>Say, for example, that you have a shell script that builds your project.
You want to ensure you can call the script from different folders, so
the first thing you want to do is to find the root of the project and
make that the working directory:</p>

<div><div><pre><code><span>SCRIPT_PATH</span><span>=</span><span>&#34;</span><span>$(</span><span>readlink</span> <span>-f</span> <span>&#34;</span><span>$0</span><span>&#34;</span><span>)</span><span>&#34;</span>
<span>PROJECT_ROOT</span><span>=</span><span>&#34;</span><span>$(</span><span>dirname</span> <span>&#34;</span><span>${</span><span>SCRIPT_PATH</span><span>}</span><span>&#34;</span><span>)</span><span>&#34;</span>
<span>cd</span> <span>&#34;</span><span>${</span><span>PROJECT_ROOT</span><span>}</span><span>&#34;</span>
</code></pre></div></div>

<p>After that, because you have <a href="https://apenwarr.ca/log/20181113">a bug</a>
with some build artefacts being stale <em>and</em> cached, you want to remove
all the artefacts you’ve built before. That ensures we don’t have any
old crap left from an earlier build:</p>

<div><div><pre><code>find build gen <span>-type</span> f <span>\(</span> <span>-name</span> <span>&#39;*.o&#39;</span> <span>-o</span> <span>-name</span> <span>&#39;*.a&#39;</span> <span>\)</span> <span>-print0</span> <span>\</span>
  | xargs <span>-0</span> <span>-r</span> <span>rm</span>
</code></pre></div></div>

<p>Of course, we want a build signature for the release, so we put the
build date and git commit into a version file:</p>

<div><div><pre><code><span>BUILD_DATE</span><span>=</span><span>&#34;</span><span>$(</span><span>date</span> <span>-d</span> <span>&#39;now&#39;</span> +%F<span>)</span><span>&#34;</span>

<span>cp </span>version.template build/version.txt

<span>sed</span> <span>-i</span> <span>&#34;s/@VERSION@/</span><span>${</span><span>COMMIT_TAG</span><span>:-</span><span>dev</span><span>}</span><span>/&#34;</span> build/version.txt
<span>sed</span> <span>-i</span> <span>&#34;s/@BUILD_DATE@/</span><span>${</span><span>BUILD_DATE</span><span>}</span><span>/&#34;</span> build/version.txt
</code></pre></div></div>

<p>Finally, we build the project with whatever build command(s) the
project relies on.</p>

<p>There are several issues here. For me, this script will work great.
But for a Mac user, all these steps will fail! The calls to
<code>readlink</code>, <code>find</code>, <code>xargs</code>, <code>date</code> and <code>sed</code> all depend on
functionality that’s provided by the GNU versions (Linux) of these
programs, and they don’t exist or don’t work the same way in the BSD
versions (Mac). Similarly, there are a bunch of arguments that work on
Mac and not on Linux.</p>

<p>There are ways around all of these problems, but they aren’t elegant.
And if you’re only familiar with either Mac or Linux, you’ll often be
surprised when the tool doesn’t work on the other OS. This is probably
most annoying for Mac users who want to modify a script running on a
CI machine, but I can confirm that it’s not fun to start on a new
project where your first task is to fix the development script to make
it work on Linux.</p>

<h2 id="python-to-the-rescue">Python to the Rescue</h2>

<p>As the title suggests, Python 3 (hereafter just Python) is a very good
alternative to complicated shell scripts. There are four reasons for
that:</p>

<ol>
  <li>Python is installed on pretty much every machine</li>
  <li>Many developers are familiar with Python (to some extent)</li>
  <li>Python has a big and standardised standard library</li>
  <li>Python code is easier to read after the fact</li>
</ol>

<h3 id="well-known-and-already-installed">Well-known and Already Installed</h3>

<p>The most important argument in my eyes is that Python 3 is installed
on basically every machine out there.</p>

<p>In addition, we all “know” Python. Maybe we haven’t used it in big
projects, but we have all used it at some point – or something that
looks like it. That makes it much easier to get into.</p>

<h3 id="standardised-standard-library">Standardised Standard Library</h3>

<p>As long as you stick to the standard library, Python will work the
same on all the machines you run your script on. The reference
implementation, CPython, is the one that 99.8% of developers have
installed and are using. The other 0.2% know what they’re doing, but
I’d still be surprised if they experience differences: All the
implementations I know of work hard to have semantically equivalent
behaviour to the reference implementation.</p>

<p>The only thing you need to be aware of is which version of Python
you’re relying on. In practice, only relatively new packages may cause
issues; if some machines are using an older Python version, some
methods or packages may not be available. For common usage in
scripts, that doesn’t happen often.</p>

<p>And backwards compatibility is something Python takes seriously – as
all big languages should. <a href="https://peps.python.org/pep-0387">PEP 387</a>
gives guidance on how breaking changes are introduced, and that
seldom happens. But if something’s not deprecated, your code will run
just fine for at least 5 years without any issues.</p>

<p>Of course, you want to know ahead of time if you’re using code that is
deprecated and may go away in the future. If you add</p>

<div><div><pre><code><span>import</span> <span>warnings</span>
<span>warnings</span><span>.</span><span>simplefilter</span><span>(</span><span>&#34;</span><span>default</span><span>&#34;</span><span>,</span> <span>DeprecationWarning</span><span>)</span>
</code></pre></div></div>

<p>at the top of your script, you’ll get deprecation warnings for
functions you run in your code, and usually some good tips on how to
migrate away.</p>

<p>As an example, <code>datetime.utcnow()</code> was deprecated in version 3.12,
and the warning you get if you turn on <code>DeprecationWarning</code> is that
you should replace it with <code>datetime.now(timezone.utc)</code> instead. Note
that this is likely a “soft deprecation” that will never disappear
from the standard library. But if the maintainers do decide to remove
it, then PEP 387 states it’ll (most likely) happen in 2028 at the
earliest.</p>

<h3 id="big-standard-library">Big Standard Library</h3>

<p>Together with the fact that the standard library is there and won’t go
away, the biggest reason to use Python is that it is big. You can do
all the actions I mentioned above with the standard library, and a ton
of other things as well.</p>

<p>Need to read/write JSON or XML? No problem. Need to fetch some data
from the Internet? There’s an HTTP client built in<sup id="fnref:curl-vs-fetch" role="doc-noteref"><a href="#fn:curl-vs-fetch" rel="footnote">1</a></sup>.
You have access to good time types, good data structures, even a
sqlite3 package if you need it.</p>

<p>Aside from specific build tools like <code>protoc</code>, <code>openapi</code> or the
compiler for the languages/frameworks you use, it’s hard to think of
something you can easily do in a shell script that you can’t also do
easily in Python.</p>

<h3 id="easier-to-read">Easier to Read</h3>

<p>I don’t like people saying “language X is easier to read than Y”,
especially if the languages have roughly the same semantics. Those
arguments/comments are usually a long-winded way of saying “I can read
X better because I have used it more often”.</p>

<p>But there’s a bit more weight behind claiming that Python is easier to
read than shell scripts. First and foremost, if you don’t use either
of them that often, it’s much harder to recall and understand the data
types and string operations in a shell script than in Python. For
example, here’s the way you capitalise a list of strings in Bash:</p>

<div><div><pre><code><span>morning_greetings</span><span>=(</span><span>&#39;hi&#39;</span> <span>&#39;hello&#39;</span> <span>&#39;good morning&#39;</span><span>)</span>
<span>energetic_morning_greetings</span><span>=()</span>

<span>for </span>s <span>in</span> <span>&#34;</span><span>${</span><span>morning_greetings</span><span>[@]</span><span>}</span><span>&#34;</span><span>;</span> <span>do
  </span>energetic_morning_greetings+<span>=(</span> <span>&#34;</span><span>${</span><span>s</span><span>^^</span><span>}</span><span>!&#34;</span> <span>)</span>
<span>done</span>
</code></pre></div></div>

<p>If you don’t use Bash often, then <code>&#34;${morning_greetings[@]}&#34;</code> won’t
tell you much, and it’s not obvious why it’s written that way. When
you attempt to write it, it’s easy to forget the exact incantation,
and you will silently introduce bugs if you forget some of the parts.
If you forget the <code>[@]</code> part, you’ll only get back the first element.
And if you forget the double quotes, then “good morning” is turned
into two elements, not one. And what is <code>${s^^}</code> really doing?</p>

<p>By the way, don’t add a comma after the elements in the list, because</p>

<div><div><pre><code><span>morning_greetings</span><span>=(</span><span>&#39;hi&#39;</span>, <span>&#39;hello&#39;</span>, <span>&#39;good morning&#39;</span><span>)</span>
</code></pre></div></div>

<p>is the list with the items <code>&#39;hi,&#39;</code>, <code>&#39;hello,&#39;</code> and <code>&#39;good morning&#39;</code>.</p>

<p>Finally, it should be noted that this doesn’t work in ZSH, and if
you’re using ZSH, you probably are a bit more of a terminal enthusiast
than the average person. And if the enthusiasts can’t use this in
their favourite shell, it’s less likely that they will use it in the
scripts they make.</p>

<p>As you can see, there are tons of mistakes you’re likely to make if
you’re not using Bash often.</p>

<p>The equivalent in Python is this:</p>

<div><div><pre><code><span>morning_greetings</span> <span>=</span> <span>[</span><span>&#39;</span><span>hi</span><span>&#39;</span><span>,</span> <span>&#39;</span><span>hello</span><span>&#39;</span><span>,</span> <span>&#39;</span><span>good morning</span><span>&#39;</span><span>]</span>
<span>energetic_morning_greetings</span> <span>=</span> \
   <span>[</span><span>s</span><span>.</span><span>upper</span><span>()</span> <span>+</span> <span>&#39;</span><span>!</span><span>&#39;</span> <span>for</span> <span>s</span> <span>in</span> <span>morning_greetings</span><span>]</span>
</code></pre></div></div>

<p>This isn’t necessarily easier to grasp the first time you see it: The
list comprehension <code>[x for y in z]</code> isn’t immediately understandable.
But when you know how it works, then <code>s.upper()</code> is easier to
understand than <code>${s^^}</code>.</p>

<p>That’s one of the reasons that makes it more accurate to say that
Python is easier to read: Methods have human-readable names in Python.
And while there’s a pattern for Bash’s string operations, it’s still
easier for a rusty developer to grasp what <code>s.removesuffix(&#39;.com&#39;)</code> is
doing, compared to <code>${s%.com}</code>… or what <code>len(morning_greetings)</code> is
doing compared to <code>${#morning_greetings[@]}</code>.</p>

<p>The other thing that gives greater weight to this argument is that
Python has a larger vocabulary, which means you don’t have to make as
many custom functions or use as many weird workarounds. Sure,
<code>morning_greetings.pop(1)</code> isn’t very easy to understand at first glance
(it removes the element at index 1), but after that, it makes sense.
But since Bash doesn’t have a similar method, you’re forced to do
things like this:</p>

<div><div><pre><code><span>unset</span> <span>&#39;morning_greetings[1]&#39;</span>
<span>arr</span><span>=(</span> <span>&#34;</span><span>${</span><span>morning_greetings</span><span>[@]</span><span>}</span><span>&#34;</span> <span>)</span>
</code></pre></div></div>

<p>and that is certainly not easy to understand, and even worse, there’s
no docstring to look up to grok what it does.</p>

<h2 id="dont-throw-the-baby-out-with-the-bathwater">Don’t Throw the Baby Out with the Bathwater</h2>

<p>All of these reasons to use Python come up when your script grows to a
certain size, or you’re doing things that are hard or unreadable in
Bash. And from experience, when the script’s already in Bash, you
won’t even consider rewriting it in Python.</p>

<p>As with all things, there’s obviously no need to port a straightforward
10-20 line Bash script. But if you struggle to comprehend what the
heck’s going on next time you’re editing the script, don’t forget that
Python’s a good alternative.</p>

<hr/>

<p><small>This was originally a post written in Norwegian, which you can
read <a href="https://www.kodemaker.no/blogg/2025-12-03-bruk-python-for-skripting/">at
Kodemaker’s blog</a>.</small></p>





</article>
</div></div>
  </body>
</html>
