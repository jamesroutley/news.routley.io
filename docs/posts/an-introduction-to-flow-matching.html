<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mlg.eng.cam.ac.uk/blog/2024/01/20/flow-matching.html">Original</a>
    <h1>An Introduction to Flow Matching</h1>
    
    <div id="readability-page-1" class="page"><div>
                <main>
                    <article>
    <img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/representative.gif" alt="Representative image"/>
        
    
    <p>
        
        
            <a href="https://mlg.eng.cam.ac.uk/blog/posts-by-tag#diffusion+model">diffusion model</a>
        
            <a href="https://mlg.eng.cam.ac.uk/blog/posts-by-tag#generative+modelling">generative modelling</a>
        
            <a href="https://mlg.eng.cam.ac.uk/blog/posts-by-tag#normalising+flows">normalising flows</a>
        
    </p>

    By <a href="https://retiredparkingguard.com/about.html">Tor Fjelde</a>, <a href="https://mlg.eng.cam.ac.uk/blog/2024/01/20/www.emilemathieu.fr">Emile Mathieu</a>, <a href="https://vdutor.github.io/">Vincent Dutordoir</a>

    

\[\require{physics}
\require{color}
\newcommand{\hlorange}[1]{\colorbox{orange}{$\displaystyle#1$}}
\newcommand{\hlblue}[1]{\colorbox{blue}{$\displaystyle#1$}}
\definecolor{Highlight1}{RGB}{76,114,176}
\definecolor{Highlight2}{RGB}{85,168,104}
\definecolor{Highlight3}{RGB}{196,78,82}
\definecolor{Highlight4}{RGB}{129,114,179}
\definecolor{Highlight5}{RGB}{204,185,116}
\def\hlone#1{\color{Highlight1} #1}
\def\hltwo#1{\color{Highlight2} #1}
\def\hlthree#1{\color{Highlight3} #1}
\def\hlfour#1{\color{Highlight4} #1}
\def\hlfive#1{\color{Highlight5} #1}
\def\hlsix#1{\color{Highlight6} #1}
\def\R{\mathbb{R}}
\def\E{\mathbb{E}}
\def\P{\mathbb{P}}
\def\L{\mathcal{L}}
\def\N{\mathrm{N}}
\def\I{\mathrm{I}}
\def\Id{\mathrm{Id}}
\def\good{\color{green}{\checkmark}}
\def\bad{\color{red}{\times}}
\def\forward#1{\overset{\rightarrow}{#1}}
\def\backward#1{\overset{\leftarrow}{#1}}
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\div}{\mathrm{div}}
\DeclareMathOperator*{\det}{\mathrm{det}}
\def\sigmamin{\sigma_{\mathrm{min}}}
\newcommand{\hlred}[1]{\colorbox{red}{$\displaystyle#1$}}
\newcommand{\hlyellow}[1]{\colorbox{yellow}{$\displaystyle#1$}}
\newcommand{\hlorange}[1]{\colorbox{orange}{$\displaystyle#1$}}
\newcommand{\hlblue}[1]{\colorbox{blue}{$\displaystyle#1$}}
\newcommand{\hlgreen}[1]{\colorbox{green}{$\displaystyle#1$}}
\nonumber\]



<ol id="markdown-toc">
  <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li>
  <li><a href="#normalising-flows" id="markdown-toc-normalising-flows">Normalising Flows</a>    <ol>
      <li><a href="#learning-flow-parameters-by-maximum-likelihood" id="markdown-toc-learning-flow-parameters-by-maximum-likelihood">Learning flow parameters by maximum likelihood</a></li>
      <li><a href="#residual-flow" id="markdown-toc-residual-flow">Residual flow</a></li>
      <li><a href="#continuous-time-limit" id="markdown-toc-continuous-time-limit">Continuous time limit</a></li>
    </ol>
  </li>
  <li><a href="#flow-matching" id="markdown-toc-flow-matching">Flow matching</a>    <ol>
      <li><a href="#conditional-flows" id="markdown-toc-conditional-flows">Conditional Flows</a></li>
      <li><a href="#gaussian-probability-paths" id="markdown-toc-gaussian-probability-paths">Gaussian probability paths</a></li>
      <li><a href="#but-is-cfm-really-all-rainbows-and-unicorns" id="markdown-toc-but-is-cfm-really-all-rainbows-and-unicorns">But is CFM really all rainbows and unicorns?</a></li>
      <li><a href="#coupling" id="markdown-toc-coupling">Coupling</a></li>
    </ol>
  </li>
  <li><a href="#quick-summary" id="markdown-toc-quick-summary">Quick Summary</a></li>
  <li><a href="#citation" id="markdown-toc-citation">Citation</a></li>
  <li><a href="#acknowledgments" id="markdown-toc-acknowledgments">Acknowledgments</a></li>
  <li><a href="#references" id="markdown-toc-references">References</a></li>
</ol>



<p><em>Flow matching (FM)</em> is a recent generative modelling paradigm which has rapidly been gaining popularity in the deep probabilistic ML community. Flow matching combines aspects from <em>Continuous Normalising Flows (CNFs)</em> and <em>Diffusion Models (DMs)</em>, alleviating key issues both methods have. In this blogpost we’ll cover the main ideas and unique properties of FM models starting from the basics.</p>

<h2 id="generative-modelling">Generative Modelling</h2>

<p>Let’s assume we have data samples $x_1, x_2, \ldots, x_n$ from a distribution of interest $q_1(x)$, which density is unknown. We’re interested in using these samples to learn a probabilistic model approximating $q_1$. In particular, we want efficient generation of new samples (approximately ) distributed from $q_1$. This task is referred to as <strong>generative modelling</strong>.</p>

<p>The advancement in generative modelling methods over the past decade has been nothing short of revolutionary. In 2012, Restricted Boltzmann Machines, then the leading generative model, were <a href="https://physics.bu.edu/~pankajm/ML-Notebooks/HTML/NB17_CXVI_RBM_mnist.html">just about able to generate MNIST digits</a>. Today, state-of-the-art methods are capable of generating high-quality <a href="https://openai.com/dall-e-3">images</a>, <a href="https://deepmind.google/discover/blog/transforming-the-future-of-music-creation/">audio</a> and <a href="https://arxiv.org/pdf/2305.14671.pdf">language</a>, as well as model complex <a href="https://www.nature.com/articles/s41586-023-06415-8">biological</a> and <a href="https://deepmind.google/discover/blog/nowcasting-the-next-hour-of-rain/">physical</a> systems. Unsurprisingly, these methods are now venturing into <a href="https://imagen.research.google/video/">video generation</a>.</p>

<div>
  <div>
<div>

      <div>

        <div>
    <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/diffusion_protein.jpg" alt="Protein generated by RFDiffusion (Watson et al., 2023)." id="figure-Figure1"/></p><p>
            Figure 1: Protein generated by RFDiffusion (Watson et al., 2023).
        </p>
    
</div>

      </div>
      <div>

        <div>
    <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/dalle_potatoes.jpeg" alt="Image from DALL-E 3 (Betker et al., 2023)." id="figure-Figure2"/></p><p>
            Figure 2: Image from DALL-E 3 (Betker et al., 2023).
        </p>
    
</div>

      </div>

    </div>
</div>
</div>

<h2 id="outline">Outline</h2>

<p>Flow Matching (FM) models are in nature most closely related to (Continuous) Normalising Flows (CNFs).  Therefore, we start this blogpost by briefly recapping the core concepts behind CNFs. We then continue by discussing the difficulties of CNFs and how FM models address them.</p>



<p>Let $\phi: \mathbb{R}^d \rightarrow \mathbb{R}^d$ be a continuously differentiable function which transforms elements of $\mathbb{R}^d$, with a continously differentiable inverse $\phi^{-1}: \mathbb{R}^d \to \mathbb{R}^d$.
Let $q_0(x)$ be a density on $\mathbb{R}^d$ and let $p_1(\cdot)$ be the density induced by the following sampling procedure</p>

\[\begin{equation*}
\begin{split}
x &amp;\sim q_0 \\
y &amp;= \phi(x),
\end{split}
\end{equation*}\]

<p>which corresponds to transforming the samples of $q_0$ by the mapping $\phi$.
Using the change-of-variable rule we can compute the density of $p_1$ as</p>

\[\begin{align}
\label{eq:changevar}
p_1(y) &amp;= q_0(\phi^{-1}(y)) \abs{\det\left[\frac{\partial \phi^{-1}}{\partial y}(y)\right]} \\
\label{eq:changevar-alt}
 &amp;= \frac{q_0(x)}{\abs{\det\left[\frac{\partial \phi}{\partial x}(x)\right]}} \quad \text{with } x = \phi^{-1}(y)
\end{align}\]

<p>where the last equality can be seen from the fact that $\phi \circ \phi^{-1} = \Id$ and a simple application of the chain rule<sup id="fnref:chainrule" role="doc-noteref"><a href="#fn:chainrule" rel="footnote">1</a></sup>.
The quantity $\frac{\partial \phi^{-1}}{\partial y}$ is the Jacobian of the inverse map. It is a matrix of size $d\times d$ containing $J_{ij} = \frac{d\phi^{-1}_i}{dx_j}$.
Depending on the task at hand, evaluation of likelihood or sampling, the formulation in $\eqref{eq:changevar}$ or $\eqref{eq:changevar-alt}$ is preferred (Friedman, 1987; Chen &amp; Gopinath, 2000).</p>

<details id="example-1d-gaussian-by-linear-map">
  <summary>Example: Transformation of 1D Gaussian variables by linear map</summary>

  <div>

    <p>Suppose $\phi$ is a linear function of the form</p><p>

\[\phi(x) = ax+b\]

    </p><p>with scalar coefficients $a,b\in\mathbb{R}$, and $p$ to be Gaussian with mean $\mu$ and variance $\sigma^2$, i.e.</p><p>

\[p = \mathcal{N}(\mu, \sigma^2).\]

    </p><p>We know from linearity of Gaussians that the induced $q$ will also be Gaussian distribution but with mean $a\mu+b$ and variance $a^2 \sigma^2$, i.e.</p><p>

\[q = \mathcal{N}(a \mu + b, a^2 \sigma^2).\]

    </p><p>More interestingly, though, is to verify that we obtain the same solution by applying the change-of-variable formula.
The inverse map is given by</p><p>

\[\phi^{-1}(y) \mapsto \frac{y-b}{a}\]

    </p><p>and it’s derivative w.r.t. $y$ is thus $1/a$ assuming scalar inputs. We thus obtain</p><p>

\[\begin{align*}
q(y) &amp;= p\bigg(\frac{y-b}{a}\bigg) \frac{1}{a} \\
&amp;= \mathcal{N}\bigg(\frac{y-b}{a}; \mu, \sigma^2\bigg) \frac{1}{a}\\
&amp;= \frac{1}{\sqrt{2\pi\sigma^2}}\exp \bigg(-\frac{(y/a -b/a-\mu)^2}{2\sigma^2} \bigg)\frac{1}{a}\\
&amp;= \frac{1}{\sqrt{2\pi(a\sigma)^2}}\exp \bigg(-\frac{1}{a^2}\frac{(y-(a\mu+b))^2}{2\sigma^2} \bigg) \\
&amp;= \mathcal{N}\big(y; a\mu+b,a^2\sigma^2\big).
\end{align*}\]

    </p><p>We have thus verified that the change-of-variables formula can be used to compute the density of a Gaussian variable tranformed by a linear mapping.</p>

    <p>Often, to simplify notation, we will use the ‘push-forward’ operator $[\phi]_{\#}$ to denote the change in density of applying an invertible map $\phi$ to an input density. That is</p><p>

\[q(y) = ([\phi]_{\#} p)(y) = p\big(\phi^{-1}(y)\big) \det\left[\frac{\partial \phi^{-1}}{\partial y}(y)\right].\]

    </p><p>If we make the choice of $a = 1$ and $b = \mu$, then we get $\mathcal{N}(\mu, 1)$, as can be seen in the <a href="#figure-heatmap-colored-trajs">figure</a> below.</p>

    <!-- > [name=Emile] Same plot but without without the solid line (i.e. jumping). -->

    <div>
      <div>
<div>

          
          <div>
    <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/simple-gaussian-without-trajs.png" alt="$\phi_t(x_0)$ for three samples $x_0 \sim p_0 = \mathcal{N}(0, 1)$ coloured according to $p_0(x_0)$." id="figure-heatmap-colored-trajs"/></p><p>
            Figure 3: $\phi_t(x_0)$ for three samples $x_0 \sim p_0 = \mathcal{N}(0, 1)$ coloured according to $p_0(x_0)$.
        </p>
    
</div>

        </div>

</div>
    </div>

  </div>

</details>

<p>Transforming a base distribution $q_0$ into another $p_1$ via a transformation $\phi$ is interesting, yet its direct application in generative modelling is limited. In generative modelling, the aim is to approximate a distribution using only the available samples. Therefore, this task requires the transformation $\phi$ to map samples from a “simple” distribution, such as $\mathcal{N}(0,I)$, to approximately the data distribution. However, a straightforward linear transformation, as in the previous example, is inadequate due to the highly non-Gaussian nature of the data distribution. This brings us to a neural network as a flexible transformation $\phi_\theta$. The key task then becomes optimising the neural net’s parameters $\theta$.</p>

<h3 id="learning-flow-parameters-by-maximum-likelihood">Learning flow parameters by maximum likelihood</h3>

<p>Let’s denote the induced parametric density by the flow $\phi_\theta$ as $p_1 \triangleq [\phi_\theta]_{\#}p_0$.</p>

<p>A natural optimisation objective for learning the parameters $\theta \in \Theta$ is to consider maximising the probability of the data under the model:</p>

\[\begin{equation*}
\textrm{argmax}_{\theta}\ \ \mathbb{E}_{x\sim \mathcal{D}} [\log p_1(x)].
\end{equation*}\]

<p>Parameterising $\phi_\theta$ as a deep neural network leads to several constraints:</p>
<ul>
  <li>How do we enforce <strong>invertibility</strong>?</li>
  <li>How do we compute its <strong>inverse</strong>?</li>
  <li>How do we compute the <strong>jacobian</strong> efficiently?</li>
</ul>

<p>Designing flows $\phi$ therefore requires trading-off expressivity (of the flow and thus of the probabilistic model) with the above mentioned considerations so that the flow can be trained efficiently.</p>

<h3 id="residual-flow">Residual flow</h3>

<p>In particular, computing the determinant of the Jacobian is in general very
expensive (as it would require $d$ automatic differentation passes in the flow) so we impose structure in $\phi$<sup id="fnref:jac_structure" role="doc-noteref"><a href="#fn:jac_structure" rel="footnote">2</a></sup>.</p>

<p><strong>Full-rank residual</strong> (Behrmann et al., 2019; Chen et al., 2010)</p>

<p>Expressive flows relying on a residual connection have been proposed as an interesting middle-ground between expressivity and efficient determinant estimation. They take the form:</p>

\[\begin{equation}
\label{eq:full_rank_res}
\phi_k(x) = x + \delta ~u_k(x),
\end{equation}\]

<p>where unbiased estimate of the log likelihood can be obtained<sup id="fnref:residual_flow" role="doc-noteref"><a href="#fn:residual_flow" rel="footnote">3</a></sup>.
As opposed to auto-regressive flows (Huang et al., 2018, Larochelle and Murray, 2011, Papamakarios et al., 2017), and low-rank residual normalising flows (Van Den Berg et al. 2018), the update in \eqref{eq:full_rank_res} has <em>full rank</em> Jacobian, typically leading to more expressive transformations.</p>

<div>
  <div>
<div>

      <div>
    <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/jac-structure.png" alt="Jacobian structure of different normalising flows." id="figure-jac-structure.png"/></p><p>
            Figure 4: Jacobian structure of different normalising flows.
        </p>
    
</div>

    </div>
</div>
</div>

<p>We can also compose such flows to get a new flow:</p>

\[\begin{equation*}
\phi = \phi_K \circ \ldots \circ \phi_2 \circ \phi_1.
\end{equation*}\]

<p>This can be a useful way to construct move expressive flow!
The model’s log-likelihood is then given by summing each flow’s contribution</p>

\[\begin{equation*}
\log q(y) = \log p(\phi^{-1}(y)) + \sum_{k=1}^K \log \det\left[\frac{\partial \phi_k^{-1}}{\partial x_{k+1}}(x_{k+1})\right]
\end{equation*}\]

<p>with $x_k = \phi_K^{-1} \circ \ldots \circ \phi^{-1}_{k} (y)$.</p>

<h3 id="continuous-time-limit">Continuous time limit</h3>
<p>As mentioned previously, residual flows are transformations of the form
$\phi(x) = x + \delta \ u(x)$
for some $\delta &gt; 0$ and Lipschitz residual connection $u$. We can re-arrange this to get</p>

\[\begin{equation*}
\frac{\phi(x) - x}{\delta} = u(x)
\end{equation*}\]

<p>which is looking awfully similar to $u$ being a derivative. In fact, letting $\delta = 1/K$ and taking the limit $K \rightarrow \infty$ under certain conditions<sup id="fnref:ODE_conditions" role="doc-noteref"><a href="#fn:ODE_conditions" rel="footnote">4</a></sup>, a composition of residual flows $\phi_K \circ \cdots \circ \phi_2 \circ \phi_1$ is given by an ordinary differential equation (ODE):</p>

\[\begin{equation*}
\frac{\dd x_t}{\dd t} = \lim_{\delta \rightarrow 0} \frac{x_{t+\delta} - x_t}{\delta} = \frac{\phi_t(x_t) - x_t}{\delta} = u_t(x_t)
\end{equation*}\]

<p>where the <em>flow</em> of the ODE $\phi_t: [0,1]\times\mathbb{R}^d\rightarrow\mathbb{R}^d$ is defined such that</p>

\[\begin{equation*}
\frac{d\phi_t}{dt} = u_t(\phi_t(x_0)).
\end{equation*}\]

<!--  -->
<p>That is, $\phi_t$ maps initial condition $x_0$ to the ODE solution at time $t$:</p>

\[\begin{equation*}
x_t \triangleq \phi_t(x_0) = x_0 + \int_{0}^t u_s(x_s) \dd{s} .
\end{equation*}\]

<h4 id="continuous-change-in-variables">Continuous change-in-variables</h4>

<p>Of course, this only defines the map $\phi_t(x)$; for this to be a useful normalising flow, we still need to compute the log-abs-determinant of the Jacobian!</p>

<p>As it turns out, the density induced by $\phi_t$ (or equivalently $u_t$) can be computed via the following equation<sup id="fnref:FPE" role="doc-noteref"><a href="#fn:FPE" rel="footnote">5</a></sup></p>

\[\begin{equation*}
\frac{\partial}{\partial_t} p_t(x_t) 
= - (\nabla \cdot (u_t p_t))(x_t).
\end{equation*}\]

<!-- for some initial distribution $p_0$. -->
<p>This statement on the time-evolution of $p_t$ is generally known as the <em>Transport Equation</em>. We refer to $p_t$ as the probability path induced by $u_t$.</p>

<!-- We can also rewrite this in log-space[^log_pdf]  -->
<p>Computing the <em>total</em> derivative (as $x_t$ also depends on $t$) in log-space yields<sup id="fnref:log_pdf" role="doc-noteref"><a href="#fn:log_pdf" rel="footnote">6</a></sup></p>

\[\begin{equation*}
\frac{\dd}{\dd t} \log p_t(x_t) = - (\nabla \cdot u_t)(x_t)
\end{equation*}\]

<p>resulting in the log density</p>

\[\begin{equation*}
\log p_t(x) = \log p_0(x_0) - \int_0^t (\nabla \cdot u_s)(x_s) \dd{s}.
\end{equation*}\]

<p>Parameterising a vector field neural network $u_\theta: \mathbb{R}_+ \times \mathbb{R^d} \rightarrow \mathbb{R^d}$ therefore induces a parametric log-density</p>

\[\log p_\theta(x) \triangleq \log p_1(x) = \log p_0(x_0) - \int_0^1 (\nabla \cdot u_\theta)(x_t) \dd t.\]

<p>In practice, to compute $\log p_t$ one can either solve both the time evolution of $x_t$ and its log density $\log p_t$ jointly</p>

\[\begin{equation*}
\frac{\dd}{\dd t} \Biggl( \begin{aligned} x_t \ \quad \\ \log p_t(x_t) \end{aligned} \Biggr) = \Biggl( \begin{aligned} u_\theta(t, x_t) \quad \\ - \div u_\theta(t, x_t) \end{aligned} \Biggr),
\end{equation*}\]

<p>or solve only for $x_t$ and then use quadrature methods to estimate $\log p_t(x_t)$.</p>

<p>Feeding this (joint) vector field to an adaptive step-size ODE solver allows us to control both the error in the sample $x_t$ and the error in the $\log p_t(x)$.</p>

<p>One may legitimately wonder why should we bother with such <em>time-continuous</em> flows versus <em>discrete</em> residual flows. There are a couple of benefits:</p>
<ol>
  <li>CNFs can be seen as an automatic way of choosing the number of residual flows $K$ to use, which would otherwise be a hyperparameter we would have to tune. In the time-continuous setting, we can choose an error threshold $\epsilon$ and the adapative solver would give us a the discretisation step size $\delta$, effectively yielding $K = 1/\delta$ steps. Using an explicit first order solver, each step is of the form $x \leftarrow x + \delta \ u_\theta(t_k, x)$, akin to a residual flow, where the residual connection parameters $\theta$ are <em>shared</em> for each discretisation step, since $u_\theta$ is amortised over $t$, instead of having a different $\theta_k$ for each layer.</li>
  <li>In residual flows, during training we need to ensure that $u_\theta$ is $1 / \delta$ Lipschitz; otherwise the resulting flow will not be invertible and thus not a valid normalising flow. With CNFs, we still require the vector field $u_\theta(t, x)$ to be Lipschitz in $x$, <em>but</em> we don’t have to worry about exactly what this Lipschitz constant is, which is obviously much easier to satisfy and enforce in. the neural architecture.
<!-- , as an adaptive ODE solver will automatically choose a suitable step size $\delta$ for us. --></li>
</ol>

<!-- > [name=Tor] Regarding "residual connection parameters $\theta$ are *shared* for each discretisation step", there is nothing stopping us from having the paameters depend on $t$ in a way that recovers the behavior we would see in a discrete case, no? -->

<p>Now that you know why CNFs are cool, let’s have a look at what such a flow would be for a simple example.</p>

<details id="example-gaussian-to-gaussian">
  <summary>
Example: Gaussian to a Gaussian (1D)
</summary>

  <div>
    <p>Let’s come back to our earlier example of mapping a 1D Gaussian to another one with different mean.
In contrast to previously where we derived a ‘one-shot’ (i.e. <em>discrete</em>) flow bridging between the two Gaussians, we now aim to derive a time-<em>continuous flow</em> $\phi_t$ which would correspond to the time integrating a vector field $u_t$.</p>

    <!-- Before digging into how exactly we achieve this, it is useful to consider an example of the above correspondance $\phi(t, x) \longleftrightarrow u(t, x)$ can be determined in closed-form. Let's consider the simple scenario we saw earlier where we want to bridge -->
    <p>We have the following two distributions</p><p>

\[\begin{equation*}
p_0 = \mathcal{N}(0, 1) \quad \text{and} \quad p_1 = \mathcal{N}(\mu, 1).
\end{equation*}\]

    </p><!-- i.e two simple Gaussians but with different means. -->

    <!-- It's not difficult to see how we can achieve this with a simple linear transformation, e.g. -->
    <p>It’s not difficult to see that we can continuously bridge between these with a simple linear transformation</p><p>

\[\begin{equation*}
\phi(t, x_0) = x_0 + \mu t
\end{equation*}\]

    </p><p>which is visualized in the figure below.</p>

    <div>
      <div>
<div>

          <div>
    <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/heatmap-colored-trajs.png" alt="$\phi_t(x_0)$ for a few samples $x_0 \sim p_0 = \mathcal{N}(0, 1)$ coloured according to $p_0(x_0)$." id="figure-heatmap-colored-trajs.png"/></p><p>
            Figure 5: $\phi_t(x_0)$ for a few samples $x_0 \sim p_0 = \mathcal{N}(0, 1)$ coloured according to $p_0(x_0)$.
        </p>
    
</div>

        </div>

</div>
    </div>

    <p>By linearity, we know that every marginal $p_t$ is a Gaussian, and so</p><p>

\[\begin{equation*}
\mathbb{E}_{p_0}[\phi_t(x_0)] = \mu t
\end{equation*}\]

    </p><p>which, in particular, implies that $\mathbb{E}_{p_0}[\phi_1(x_0)] = \mu = \mathbb{E}_{p_1}[x_1]$. Similarly, we have</p><p>

\[\begin{equation*}
\mathrm{Var}_{p_0}[\phi_t(x_0)] = 1 \quad \implies \quad \mathrm{Var}_{p_0}[\phi_1(x_0)] = 1 = \mathrm{Var}_{p_1}[x_1]
\end{equation*}\]

    </p><p>Hence we have a probability path $p_t = \mathcal{N}(\mu t, 1)$ bridging $p_0$ and $p_1$.</p>

    <div>
      <div>
<div>

          <div>
    <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/heatmap-colored.png" alt="Probability path $p_t = \mathcal{N}(\mu t, 1)$ from $p_0 = \mathcal{N}(0, 1)$ to $p_1 = \mathcal{N}(\mu, 1)$." id="figure-heatmap-colored.png"/></p><p>
            Figure 6: Probability path $p_t = \mathcal{N}(\mu t, 1)$ from $p_0 = \mathcal{N}(0, 1)$ to $p_1 = \mathcal{N}(\mu, 1)$.
        </p>
    
</div>

        </div>


</div>
    </div>

    <!-- > [name=emilem] Would be nice to ideally shorten what follows. -->

    <p>Now let’s determine what the vector field $u_t(x)$ would be in this case. As mentioned earlier, $u(t, x)$ should satisfy the following</p><p>

\[\begin{equation*}
\dv{\phi_t}{t}(x_0) = u_t \big( \phi_t(x_0) \big).
\end{equation*}\]

    </p><p>Since we have already specified $\phi$, we can plug it in on the left hand side to get</p><p>

\[\begin{equation*}
\dv{\phi_t}{t}(x_0) = \dv{t} \big( x_0 + \mu t \big) = \mu
\end{equation*}\]

    </p><p>which gives us</p><p>

\[\begin{equation*}
\mu = u_t \big( x_0 + \mu t \big).
\end{equation*}\]

    </p><p>The above needs to hold for <em>all</em> $t \in [0, 1]$, and so it’s not too difficult to see that one such solution is the constant vector field</p><p>

\[\begin{equation*}
u_t(x) = \mu.
\end{equation*}\]

    </p><p>We could of course have gone the other way, i.e. define the $u_t$ such that $p_0 \overset{u_t}{\longleftrightarrow} p_1$ and derive the corresponding $\phi_t$ by solving the ODE.</p>

  </div>

</details>

<h4 id="training-cnfs">Training CNFs</h4>

<p>Similarly to any flows, CNFs can be trained by maximum log-likelihood</p>

\[\mathcal{L}(\theta) = \mathbb{E}_{x\sim q_1} [\log p_1(x)],\]

<p>where the expectation is taken over the data distribution and $p_1$ is the parameteric distribution.
This involves integrating the time-evolution of samples $x_t$ and log-likelihood $\log p_t$, both terms being a function of the parametric vector field $u_{\theta}(t, x)$. This requires</p>

<ul>
  <li>⚠️ Expensive numerical ODE simulations at training time!</li>
  <li>⚠️ Estimators for the divergence to scale nicely with high dimension. <sup id="fnref:hutchinson" role="doc-noteref"><a href="#fn:hutchinson" rel="footnote">7</a></sup></li>
</ul>

<p>CNFs are very expressive as they parametrise a large class of flows, and therefore of probability distribution. Yet training can be <em>extremely</em> slow due to the ODE integration at each iteration. One may wonder whether a ‘simulation-free’, i.e. <em>not</em> requiring any integration, training procedure exists for training these CNFs.</p>

<!-- > [name=Tor] Should add a citation for the "large class of flows" claim. -->



<p>And that is exactly where Flow Matching (FM) comes in!</p>

<!--- 
Here comes flow matching achieving exactly this, 
-->
<p>Flow matching is a simulation-free way to train CNF models where we directly formulate a regression objective w.r.t. the parametric vector field $u_\theta$ of the form
<!-- \label{eq:fm-objective} --></p>

\[\begin{equation*}
\mathcal{L}(\theta)_{} = \mathbb{E}_{t \sim \mathcal{U}[0, 1]} \mathbb{E}_{x \sim p_t}\left[\|
u_\theta(t, x) - u(t, x) \|^2 \right].
\end{equation*}\]

<p>In the equation above, $u(t, x)$ would be a vector field inducing a <em>probability path</em> (or bridge) $p_t$ interpolating the reference $p_0$ to $p_1$, i.e.</p>

\[\begin{equation*}
\log p_1(x) = \log p_0 - \int_0^1 (\nabla \cdot u_t)(x_t) \dd{t}.
\end{equation*}\]

<!-- $$
\begin{equation*}
\pdv{p_t(x)}{t} = - \nabla \cdot \big( u_t(x) p_t(x) \big),
\end{equation*}
$$ -->

<p>In words: we’re just performing regression on $u_t(x)$ for all $t \in [0, 1]$.</p>

<p>Of course, this requires knowledge of a <em>valid</em> $u(t, x)$, and if we already have access to $u_t$, there’s no point in learning an approximation $u_{\theta}(t, x)$ in the first place! But as we will see in the next section, we can leverage this formulation to construct a useful target for $u_{\theta}(t, x)$ witout having to compute explicitly $u(t, x)$.</p>

<p>This is where <em>Conditional</em> Flow Matching (CMF) comes to the rescue.</p>

<details open="true">
  <summary>
Non-uniqueness of vector field
</summary>

  <p>We say <em>a valid</em> $u_t$ because there is no <em>unique</em> vector field $u_t$; there are indeed many valid choices for $u_t$ inducing maps $p_0 \overset{\phi}{\longleftrightarrow} p_1$ as illustrated in the <a href="#figure-forward_samples-one-color-1">figure</a> below. As we will see in what follows, in practice we have to pick a particular target $u_t$, which has practical implications.</p>

  <div>
    <div>
<div>
        <div>

          <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/forward_samples-one-color-1.png" alt="" id="figure-forward_samples-one-color-1"/>
    
</p>

          <!-- $$
\phi_t(x_0, x_1) = (1 - t) x_0 + t x_1
$$ -->

        </div>
        <div>

          <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/forward_samples-one-color-2.png" alt="" id="figure-forward_samples-one-color-2.png"/>
    
</p>

          <!-- $$
\phi_t(x_0, x_1) = \cos(\pi t / 2) x_0 + \sin (\pi t / 2) x_1
$$ -->

        </div>
      </div>


</div>
  </div>

  <div>
    <div>
<div>
        <div>

          <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/forward_samples-one-color-3.png" alt="" id="figure-forward_samples_ot-one-color.png"/>
    
</p>

        </div>
        <div>

          <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/forward_samples_ot-one-color.png" alt="" id="figure-forward_samples-one-color-3.png"/>
    
</p>

        </div>
      </div>
<p>

Figure 7: <em>Different paths with the same endpoints marginals<sup id="fnref:interpolation" role="doc-noteref"><a href="#fn:interpolation" rel="footnote">8</a></sup>.</em>

</p>
</div>
  </div>

</details>

<!-- > [name=Tor Erlend Fjelde] TODO: add footnote on details. -->

<h3 id="conditional-flows">Conditional Flows</h3>

<p>First, let’s remind ourselves that the transport equation relates a vector field $u_t$ to (the time evolution of) a probability path $p_t$</p>

\[\begin{equation*}
\pdv{p_t(x)}{t} = - \nabla \cdot \big( u_t(x) p_t(x) \big),
\end{equation*}\]

<p>thus constructing $p_t$ or $u_t$ is <em>equivalent</em>.
One key idea (Lipman et al., 2023 and Albergo &amp; Vanden-Eijnden, 2022) is to express the probability path as a marginal over a joint involving a latent variable $z$: 
$p_t(x_t) = \int p(z) ~p_{t\mid z}(x_t\mid z) \textrm{d}z$.
The $p_{t\mid z}(x_t\mid z)$ term being a <strong>conditional probability path</strong>, satisfying some boundary conditions at $t=0$ and $t=1$ so that $p_t$ be a valid path interpolating between $q_0$ and $q_1$.
In addition, as opposed to the marginal $p_t$ , the conditional $p_{t\mid1}$ could be available in closed-form.</p>

<p>In particular, as we have access to data samples $x_1 \sim q_1$, it sounds pretty reasonable to condition on $z=x_1$, leading to the following marignal probabilithy path</p>

\[\begin{equation*}
p_t(x_t) = \int q_1(x_1) ~p_{t\mid 1}(x_t\mid x_1) \dd{x_1}.
\end{equation*}\]

<!-- would interpolate between $p_{t=0} = q_0$ and $p_{t=1}=\delta_{x_1}$.  -->
<p>In this setting, the conditional probability path $p_{t\mid 1}$ need to satisfy the boundary conditions</p>

\[\begin{equation*}
p_0(x \mid x_1) = p_0 \quad \text{and} \quad p_1(x \mid x_1) = \mathcal{N}(x; x_1, \sigmamin^2 I) \xrightarrow[\sigmamin \rightarrow 0]{} \delta_{x_1}(x)
\end{equation*}\]

<p>with $\sigmamin &gt; 0$ small, and for whatever reference $p_0$ we choose, typically something “simple” like $p_0(x) = \mathcal{N}(x; 0, I)$, as illustrated in the <a href="#figure-heatmap_with_cond_traj-v3">figure</a> below.</p>

<div>
  <div>

    <div>
    <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/heatmap_with_cond_traj-v3.png" alt="Two conditional flows $\phi_t(x \mid x_1)$ for two univariate Gaussians." id="figure-heatmap_with_cond_traj-v3"/></p><p>
            Figure 8: Two conditional flows $\phi_t(x \mid x_1)$ for two univariate Gaussians.
        </p>
    
</div>

  </div>
</div>

<p>The conditional probability path also satisfies the transport equation with the <strong>conditional vector field</strong> $u_t(x \mid x_1)$:</p>

\[\begin{equation}
\label{eq:continuity-cond}
\pdv{p_t(x \mid x_1)}{t} = - \nabla \cdot \big( u_t(x \mid x_1) p_t(x \mid x_1) \big).
\end{equation}\]

<!-- Lipman et al. (2023) introduced the notion of **Conditional Flow Matching (CFM)** by noticing that the *conditional* vector field $u_t(x \mid x_1)$, which satisfies the transport equation for the conditional density $p_t(x \mid x_1)$
\label{eq:continuity-cond-2}
$$
\begin{equation*}
\pdv{p_t(x \mid x_1)}{t} = - \nabla \cdot \big( u_t(x \mid x_1) p_t(x \mid x_1) \big),
\end{equation*}
$$
 -->
<p>Lipman et al. (2023) introduced the notion of <strong>Conditional Flow Matching (CFM)</strong> by noticing that this <em>conditional</em> vector field $u_t(x \mid x_1)$
can express the <em>marginal</em> vector $u_t(x)$ of interest via the conditional probability path $p_{t\mid 1}(x_t\mid x_1)$ as</p>

\[\begin{equation}
\label{eq:cf-from-cond-vf}
\begin{split}
  u_t(x) &amp;= \mathbb{E}_{x_1 \sim p_{1 \mid t}} \left[ u_t(x \mid x_1) \right] \\
  &amp;= \int u_t(x \mid x_1) \frac{p_t(x \mid x_1) q_1(x_1)}{p_t(x)} \dd{x}_1.
\end{split}
\end{equation}\]

<!-- That is, we have an unbiased estimator the marginal vector field $u_t$ that we want to learn by sampling $x_1$ from $p_{1 \mid t}(x_1 \mid x)$ and evaluating $u_t(x \mid x_1)$. -->

<p>To see why this $u_t$ the same the vector field as the one defined earlier, i.e. the one generating the (marginal) pribability path $p_t$, we need to show that the expression above for the marginal vector field $u_t(x)$ satisfies the transport equation</p>

\[\begin{equation*}
\pdv{\hlthree{p_t(x)}}{t} = - \nabla \cdot \big( \hltwo{u_t(x)} \hlthree{p_t(x)} \big).
\end{equation*}\]

<p>Writing out the left-hand side, we have</p>

\[\begin{equation*}
\begin{split}
  \pdv{\hlthree{p_t(x)}}{t} &amp;= \pdv{t} \int p_t(x \mid x_1) q(x_1) \dd{x_1} \\
  &amp;= \int \hlone{\pdv{t} \big( p_t(x \mid x_1) \big)} q(x_1) \dd{x_1} \\
  &amp;= - \int \hlone{\nabla \cdot \big( u_t(x \mid x_1) p_t(x \mid x_1) \big)} q(x_1) \dd{x_1} \\
  &amp;= - \int \hlfour{\nabla} \cdot \big( u_t(x \mid x_1) p_t(x \mid x_1) q(x_1) \big) \dd{x_1} \\
  &amp;= - \hlfour{\nabla} \cdot \int u_t(x \mid x_1) p_t(x \mid x_1) q(x_1) \dd{x_1} \\
  &amp;= - \nabla \cdot \bigg( \int u_t(x \mid x_1) \frac{p_t(x \mid x_1) q(x_1)}{\hlthree{p_t(x)}} {\hlthree{p_t(x)}} \dd{x_1} \bigg) \\
  &amp;= - \nabla \cdot \bigg( {\hltwo{\int u_t(x \mid x_1) \frac{p_t(x \mid x_1) q(x_1)}{p_t(x)} \dd{x_1}}} \ {\hlthree{p_t(x)}} \bigg) \\
  &amp;= - \nabla \cdot \big( \hltwo{u_t(x)} {\hlthree{p_t(x)}} \big)
\end{split}
\end{equation*}\]

<p>where in the $\hlone{\text{first highlighted step}}$ we used \eqref{eq:continuity-cond} and in the $\hltwo{\text{last highlighted step}}$ we used the expression of $u_t(x)$ in \eqref{eq:cf-from-cond-vf}.</p>

<p>The relation between $\phi_t(x_0)$, $\phi_t(x_0 \mid x_1)$ and their induced densities are illustrated in the <a href="#figure-flow-matching-diagram">Figure 9</a> below. And since $\phi_t(x_0)$ and $\phi_t(x_0 \mid x_1)$ are solutions corresponding to the vector fields $u_t(x)$ and $u_t(x \mid x_1)$ with $x(0) = x_0$, <a href="#figure-flow-matching-diagram">Figure 9</a> is equivalent to <a href="#figure-flow-matching-diagram-2">Figure 10</a>, but note the difference in the expectation taken to go from $u_t(x_0 \mid x_1) \longrightarrow u_t(x_0)$ compared to $\phi_t(x_0 \mid x_1) \longrightarrow \phi_t(x_0)$.</p>

<div>
  <div>
<div>

      <div>
    <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/flow-matching-diagram.png" alt="Diagram illustrating the relation between the paths $\phi_t(x_0)$, $\phi_t(x_0 \mid x_1)$, and their induced marginal and conditional densities." id="figure-flow-matching-diagram"/></p><p>
            Figure 9: Diagram illustrating the relation between the paths $\phi_t(x_0)$, $\phi_t(x_0 \mid x_1)$, and their induced marginal and conditional densities.
        </p>
    
</div>

    </div>
</div>
</div>

<div>
  <div>
<div>

      <div>
    <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/flow-matching-diagram-2.png" alt="Diagram illustrating the relation between the vector fields $u_t(x_0)$, $u_t(x_0 \mid x_1)$, and their induced marginal and conditional densities." id="figure-flow-matching-diagram-2"/></p><p>
            Figure 10: Diagram illustrating the relation between the vector fields $u_t(x_0)$, $u_t(x_0 \mid x_1)$, and their induced marginal and conditional densities.
        </p>
    
</div>

    </div>
</div>
</div>

<details open="true">
  <summary>
Gaussian to Gaussian (2D) using a conditional flow
</summary>

  <div>

    <p>Let’s try to gain some intuition behind \eqref{eq:cf-from-cond-vf} and the relation between $u_t(x)$ and $u_t(x \mid x_1)$.
We do so by looking at the following scenario</p>

    <!-- Suppose we have some data samples $\big( x_1^{(i)} \big)_{i = 1}^n$ from our target $p_1$.
For any point $x$ in our domain, we can produce an unbiased estimate of $u_t(x)$ by
$$
\begin{split}
u_t \big( x \big) &= \mathbb{E}_{x_1 \sim p_1} \left[ u_t \big( x \mid x_1 \big) \frac{p_t(x \mid x_1)}{p_t(x)} \right] \\
&\approx \frac{1}{n} \sum_{i = 1}^n u_t \big( x \mid x_1^{(i)} \big) \frac{p_t(x \mid x_1^{(i)})}{p_t(x)}.
\end{split}
$$
assuming we could compute the weights $\frac{p_t(x \mid x_1^{(i)})}{p_t(x)}$, we could use importance sampling (IS) to estimate $u_t(x)$ from $u_t(x \mid x_1)$ and samples from $p_1$. In effect, the IS weight $\frac{p_t(x \mid x_1^{(i)})}{p_t(x)}$ tells us how important the sample $x_1^{(i)}$ is for estimating $u_t(x)$.
To gain some intuition as to what this estimator looks like, let's look the following scenario
 --><p>

\[\begin{equation}
\tag{G-to-G}
\label{eq:g2g}
\begin{split}
p_0 = \mathcal{N}([-\mu, 0], I) \quad &amp; \text{and} \quad p_1 = \mathcal{N}([+\mu, 0], I) \\
\text{with} \quad \phi_t(x_0 \mid x_1) &amp;= (1 - t) x_0 + t x_1
\end{split}
\end{equation}\]

    </p><p>with $\mu = 10$ unless otherwise specified. We’re effectively transforming a Gaussian to another Gaussian using a simple time-linear map, as illustrated in the following figure.</p>

    <div>
      <div>
<div>

          <div>
    <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/g2g-cond-paths-one-color.png" alt="Example conditional paths $\phi_t(x_0 \mid x_1)$ of \eqref{eq:g2g} with $\mu = 10$." id="figure-g2g-cond-paths-one-color"/></p><p>
            Figure 11: Example conditional paths $\phi_t(x_0 \mid x_1)$ of \eqref{eq:g2g} with $\mu = 10$.
        </p>
    
</div>

        </div>
</div>
    </div>

    <p>In the end, we’re really just interested in learning the <em>marginal</em> paths $\phi_t(x_0)$ for initial points $x_0$ that are probable under $p_0$, which we can then use to generate samples $x_1 = \phi_1(x_0)$. In this simple example, we can obain closed-form expressions for $\phi_t(x_0)$ corresponding to the conditional paths $\phi_t(x_0 \mid x_1)$ of \eqref{eq:g2g}, as visualised below.</p>

    <div>
      <div>
<div>

          <div>
    <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/g2g-forward_samples-one-color.png" alt="Example marginal paths $\phi_t(x_0)$ of \eqref{eq:g2g} with $\mu = 10$." id="figure-g2g-marginal-paths-one-color"/></p><p>
            Figure 12: Example marginal paths $\phi_t(x_0)$ of \eqref{eq:g2g} with $\mu = 10$.
        </p>
    
</div>

        </div>
</div>
    </div>

    <p>With that in mind, let’s pick a random initial point $x_0$ from $p_0$, and then compare a MC estimator for $u_t(x_0)$ at different values of $t$ along the path $\phi_t(x_0)$, i.e. we’ll be looking at
<!-- $$
u_t \big( \phi_t(x_0) \big) \approx \frac{1}{n} \sum_{i = 1}^n u_t \big( \phi_t(x_0) \mid x_1^{(i)} \big) \frac{p_t(\phi_t(x_0) \mid x_1^{(i)})}{p_t(\phi_t(x_0))} \quad \text{with } x_1^{(i)} \sim p_1.
$$ --></p><p>

\[\begin{equation*}
\begin{split}
u_t \big( \phi_t(x_0) \big) 
&amp;= \E_{p_{1 \mid t}}\left[u_t \big( \phi_t(x_0) \mid x_1 \big)\right] \\
&amp;\approx \frac{1}{n} \sum_{i = 1}^n u_t \big( \phi_t(x_0) \mid x_1^{(i)} \big) \ \text{with } x_1^{(i)} \sim p_{1 \mid t}(x_1 \mid \phi_t(x_0)).
\end{split}
\end{equation*}\]

    </p><p>In practice we don’t have access to the posterior \(p_{1 \mid t}(x_1 \mid x_t)\), but in this specific setting we do have closed-form expressions for everything (Albergo &amp; Vanden-Eijnden, 2022), and so we can visualise the marginal vector field \(u_t\big( \phi_t(x_0)\big)\) and the conditional vector fields \(u_t \big( \phi_t(x_0) \mid x_1^{(i)} \big)\) for all our “data” samples \(x_1^{(i)}\) and see how they compare.
This is shown in the figure below.</p>

    <div>
      <div>

<div>

          <div>

            <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/g2g-vector-field-samples-with-traj-single-2.png" alt="" id="figure-g2g-vector-field-samples-with-traj-single-2.png"/>
    
</p>

          </div>

          <div>

            <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/g2g-vector-field-samples-with-traj-single-1.png" alt="" id="figure-g2g-vector-field-samples-with-traj-single-1.png"/>
    
</p>

          </div>

        </div>

<p>
Figure 13: Marginal vector field $u_t(x)$ vs. conditional vector field $u_t(x \mid x_1)$ for samples $x_1 \sim p_1$. Here $p_0 = p_1 = \mathcal{N}(0, 1)$ and the two trajectories are according to the marginal vector field $u_t(x)$. Samples $x_1$ transparency is given by the IS weight $p_t(x \mid x_1) / p_t(x)$.
</p>

</div>
    </div>

    <!-- From the above figures, we can immediately see how for small $t$, i.e. near 0, the IS weights for the different data points $x_1^{(i)}$ are basically all the same, but as $t$ increases and get closer to 1 the estimator is dominated by only a few data samples. -->
    <p>From the above figures, we can immediately see how for small $t$, i.e. near 0, the posterior $p_{1 \mid t}(x_1 \mid x_t)$ is quite scattered so the marginalisation giving $u_t$ involves many equally likely data samples $x_1$. In contrast, when $t$ increases and get closer to 1, $p_{1 \mid t}(x_1 \mid x_t)$ gets quite concentrated over much fewer samples $x_1$.</p>

  </div>

</details>

<p>Moreover, equipped with the knowledge of \eqref{eq:cf-from-cond-vf}, we can replace</p>

\[\begin{align}
\mathcal{L}_{\mathrm{FM}}(\theta) = \mathbb{E}_{t \sim \mathcal{U}[0, 1], x \sim p_t}\left[\|
u_\theta(t, x) - u(t, x) \|^2 \right],
\end{align}\]

<p>where  $u_t(x) = \mathbb{E}_{x_1 \sim p_{1 \mid t}} \left[ u_t(x \mid x_1) \right]$, 
with an equivalent loss regressing the <em>conditional</em> vector field $u_t(x \mid x_1)$ and marginalising $x_1$ instead:</p>

\[\begin{equation*}
\mathcal{L}_{\mathrm{CFM}}(\theta) = \mathbb{E}_{t \sim \mathcal{U}[0, 1], x_1 \sim q, x_t \sim p_t(x \mid x_1)}\left[\|
u_\theta(t, x) - u_t(x \mid x_1) \|^2 \right].
\end{equation*}\]

<p>These losses are equivalent in the sense that</p>

\[\begin{equation*}
\nabla_\theta \mathcal{L}_{\mathrm{FM}}(\theta) = \nabla_\theta \mathcal{L}_{\mathrm{CFM}}(\theta),
\end{equation*}\]

<p>which implies that we can use \({\mathcal{L}}_{\text{CFM}}\) instead to train the parametric vector field $u_{\theta}$.
The defer the full proof to the footnote<sup id="fnref:CFM" role="doc-noteref"><a href="#fn:CFM" rel="footnote">9</a></sup>, but show the key idea below.
By developing the squared norm in both losses, we can easily show that the squared terms are equal or independent of $\theta$.
Let’s develop inner product term for \({\mathcal{L}}_{\text{FM}}\) and show that it is equal to the inner product of \({\mathcal{L}}_{\text{CFM}}\):</p>

\[\begin{align}
\mathbb{E}_{x \sim p_t} ~\langle u_\theta(t, x), \hltwo{u_t(x)} \rangle 
&amp;= \int \langle u_\theta(t, x), \hltwo{\int} u_t(x \mid x_1) \hltwo{\frac{p_t(x \mid x_1)q(x_1)}{p_t(x)} dx_1} \rangle p_t(x) \mathrm{d} x \\
&amp;= \int \langle u_\theta(t, x), \int u_t(x \mid x_1) p_t(x \mid x_1)q(x_1) dx_1 \rangle \dd{x} \\
&amp;= \int \int \langle u_\theta(t, x), u_t(x \mid x_1) \rangle p_t(x \mid x_1)q(x_1) dx_1 \dd{x} \\
&amp;= \mathbb{E}_{q_1(x_1) p(x \mid x_1)} ~\langle u_\theta(t, x), u_t(x \mid x_1) \rangle
\end{align}\]

<p>where in the $\hltwo{\text{first highlighted step}}$ we used the expression of $u_t(x)$ in \eqref{eq:cf-from-cond-vf}.</p>

<!-- > [name=emilem] The following paragraph is key, perhaps it can be improved? -->

<p>The benefit of the CFM loss being that once we define the conditional probability path $p_t(x \mid x_1)$, we can construct an unbiased Monte Carlo estimator of the objective using samples $\big( x_1^{(i)} \big)_{i = 1}^n$ from the data target $q_1$!</p>

<p>This estimator can be efficiently computed as it involves an expectation over the joint $q_1(x_1)p_t(x \mid x_1)$ 
, of the conditional vector field $u_t (x \mid x_1)$ both being available as opposed to the marginal vector field $u_t$ which involves an expectation over the posterior $p_{1 \mid t}(x_1 \mid x)$.</p>

<!-- We also restrict to conditional paths whose vector field $u_t(x \mid x_1)$ is "simple enough" so that we can compute it in closed form. But, as we'll see, this is not too difficult to achieve. -->

<p>We note that, as opposed to the log-likelihood maximisation loss of CNFs which does not put any preference over which vector field $u_t$ can be learned, the CFM loss does specify one via the choice of a conditional vector field, which will be regressed by the neural vector field $u_\theta$.</p>

<!--

To do so we construct a _probability path_ $p_t$ which interpolates between the reference (i.e. noise) distribution $q_0$ and the data distribution $q_1$, i.e. $p_{t=0}=q_0$ and $p_{t=1}=q_1 * \mathrm{N}(0, \sigma^2)$.

Lipman et al. (2023) achieves this by constructing $p_t$ as mixture of simpler probability paths: $p_t \triangleq \int p_t(\cdot \mid x_1) q_1(x_1) \dd{x}_1$, via a _conditional probability path_ $p_t(\cdot \mid x_1)$ satisfying $p_1(\cdot \mid x_1)=\mathrm{N}(x_1, \sigma^2) \xrightarrow[\sigma \rightarrow 0]{} \delta_{x_1}$ and $p_0(\cdot \mid x_1)=p_0$.

As a result both endpoints constraint are satisfied since ones recovers
- at $t=1$ the data distribution $p_1(x) = \int p_1(x \mid x_1) q_1(x_1) \dd{x}_1 = \int \mathrm{N}(x_1, \sigma^2) q_1(x_1) \dd{x}_1 \xrightarrow[\sigma \rightarrow 0]{} q_1(x)$
- at $t=0$ the reference distribution $p_0(x) = \int p_0(x \mid x_1) q_1(x_1) \dd{x}_1 = \int q_0(x) q_1(x_1) \dd{x}_1 = q_0(x)$.

<div markdown="1" style="display: flex; margin-top:-0px; margin-bottom:-0px;">
<div markdown="1" style="margin: auto;">

![cond_ut](https://hackmd.io/_uploads/HyLrNEWSa.jpg =200x)
</div>
</div>

We have defined a probability path $p_t$ in terms of conditional probability path $p_t(\cdot \mid x_1)$, yet how do we define the latter?
We know that the transport equation $\frac{\partial}{\partial_t} p_t(x_t) = - (\nabla \cdot (u_t p_t))(x_t)$ relates a vector field (i.e. vector field) to a propability path $p_t$ (given an initial value $p_{t=0} = q_0$).
As such it is sufficient to construct a _conditional vector field_ $u_t(\cdot \mid x_1)$ which induces a conditional probability path $p_t(\cdot \mid x_1)$ with the right boundary conditions.

-->

<h3 id="gaussian-probability-paths">Gaussian probability paths</h3>
<p>Let’s now look at practical example of conditional vector field and the corresponding probability path. Suppose we want conditional vector field which generates a path of Gaussians, i.e.</p>

\[\begin{equation*}
p_t(x \mid x_1) = \mathcal{N}(x; \mu_t(x_1), \sigma_t(x_1)^2 \mathrm{I})
\end{equation*}\]

<p>for some mean $\mu_t(x_1)$ and standard deviation $\sigma_t(x_1)$.</p>

<!-- This means one can sample $x_t \mid x_1 ~ p_t(\cdot \mid x_1)$ as $x_t = \phi(x_0 \mid x_1)$ with $\phi(x \mid x_1) = \sigma_t(x_1) x + \mu_t(x_1)$ and $x_0 \sim \mathcal{N}(0, \mathrm{I})$. -->
<!--  -->
<p>One conditional vector field inducing the above-defined conditional probability path is given by the following expression:</p>

\[\begin{equation}
\label{eq:gaussian-path}
u_t(x \mid x_1) = \frac{\dot{\sigma_t}(x_1)}{\sigma_t(x_1)} (x - \mu_t(x_1)) + \dot{\mu_t}(x_1)
\end{equation}\]

<p>as shown in the proof below.</p>

<details>
<summary>Proof</summary>

We have

$$
\begin{equation*}
\phi_t(x \mid x_1) = \mu_t(x_1) + \sigma_t(x_1) x
\end{equation*}
$$

and we want to determine $u_t(x \mid x_1)$ such that

$$
\begin{equation*}
\frac{\dd}{\dd t} \phi_t(x) = u_t \big( \phi_t(x) \mid x_1 \big)
\end{equation*}
$$

First note that the LHS is

$$
\begin{equation*}
\begin{split}
\frac{\dd{}}{\dd{} t} \phi_t(x) &amp;= \frac{\dd{}}{\dd{} t} \bigg( \mu_t(x_1) + \sigma_t(x_1) x \bigg) \\
&amp;= \dot{\mu_t}(x_1) + \dot{\sigma_t}(x_1) x
\end{split}
\end{equation*}
$$

so we have

$$
\begin{equation*}
\dot{\mu_t}(x_1) + \dot{\sigma_t}(x_1) x = u_1 \big( \phi_t(x \mid x_1) \mid x_1 \big)
\end{equation*}
$$

Suppose that $u_1$ is of the form

$$
\begin{equation*}
u_1\big( \phi_t(x) \mid x_1\big) = h\big(t, \phi_t(x), x_1\big) \dot{\mu_t}(x_1) + g\big(t, \phi_t(x), x_1\big) \dot{\sigma_t}(x_1)
\end{equation*}
$$

for some functions $h$ and $g$.
Reading of the components from the previous equation, we then see that we require

$$
\begin{equation*}
h\big(t, \phi_t(x), x_1\big) = 1 \quad \text{and} \quad
g(t, \phi_t(x), x_1) = x
\end{equation*}
$$

The simplest solution to the above is then just

$$
\begin{equation*}
h(t, x, x_1) = 1
\end{equation*}
$$

i.e. constant function, and

$$
\begin{equation*}
g(t, x, x_1) = \phi_t^{-1}(x) = \frac{x - \mu_t(x_1)}{\sigma_t(x_1)}
\end{equation*}
$$

such that

$$
\begin{equation*}
g\big(t, \phi_t(x), x_1) = \phi_t^{-1} \big( \phi_t(x) \big) = x
\end{equation*}
$$

resulting in

$$
\begin{equation*}
u_t \big( x \mid x_1 \big) = \dot{\mu_t}(x_1) + \dot{\sigma_t}(x_1) \bigg( \frac{x - \mu_t(x_1)}{\sigma_t(x_1)} \bigg)
\end{equation*}
$$

as claimed.

</details>

<!-- Example begin -->
<details id="example-linear-interpolation" open="true">
  <summary>
Example: Linear interpolation
</summary>

  <div>

    <p>A simple choice for the mean $\mu_t(x_1)$ and std. $\sigma_t(x_1)$ is the linear interpolation for both, i.e.</p><p>

\[\begin{align*}
\hlone{\mu_t(x_1)} &amp;\triangleq t x_1 \quad &amp;\text{and} \quad \hlthree{\sigma_t(x_1)} &amp;\triangleq (1 - t) + t \sigmamin \\
\hltwo{\dot{\mu}_t(x_1)} &amp;\triangleq x_1 \quad &amp;\text{and} \quad \hlfour{\dot{\sigma}_t(x_1)} &amp;\triangleq -1 + \sigmamin
\end{align*}\]

    </p><p>so that</p><p>

\[\begin{equation*}
\big( {\hlone{\mu_0(x_1)}} + {\hlthree{\sigma_0(x_1)}} x_1 \big) \sim p_0 \quad \text{and} \quad \big( {\hlone{\mu_1(x_1)}} + {\hlthree{\sigma_1(x_1)}} x_1 \big) \sim \mathcal{N}(x_1, \sigmamin^2 I)
\end{equation*}\]

    </p><!-- and so -->
    <!-- $$ -->
    <!-- p_t(x \mid x_1) = \mathcal{N}\big(x; t x_1, (1 - t) + t \sigmamin \big) -->
    <!-- $$ -->

    <p>In addition, letting $p_0 = \mathcal{N}([-\mu, 0], I)$ and $p_1 = \mathcal{N}([+\mu, 0], I)$ for some $\mu &gt; 0$, we’re back to the \ref{eq:g2g} example from earlier.</p>

    <p>We can then plug this choice of $\mu_t(x_1)$ and $\sigma_t(x_1)$ into \eqref{eq:gaussian-path} to obtain the conditional vector field, writing $\hlthree{\sigma_t(x_1)} = 1 - (1 - \sigmamin) t$ to make our lives simpler,</p><p>

\[\begin{equation*}
\begin{split}
u_t(x \mid x_1) &amp;= \frac{\hlfour{- (1 - \sigmamin)}}{\hlthree{1 - (1 - \sigmamin) t}} (x - \hlone{t x_1}) + \hltwo{x_1} \\
&amp;= \frac{1}{(1 - t) + t \sigmamin} \bigg( - (1 - \sigmamin) (x - t x_1) + \big(1 - (1 - \sigmamin) t \big) x_1 \bigg) \\
&amp;= \frac{1}{(1 - t) + t \sigmamin} \bigg( - (1 - \sigmamin) x + x_1 \bigg) \\
&amp;= \frac{x_1 - (1 - \sigmamin) x}{1 - (1 - \sigmamin) t}.
\end{split}
\end{equation*}\]

    </p><p>Below you can see the difference between $\phi_t(x_0)$ (top figure) and $\phi_t(x_0 \mid x_1)$ (bottom figure) for pairs $(x_0, x_1)$ with $x_0 \sim p_0$ and $x_1 = \phi_t(x_0)$. The paths are coloured by the sign of the 2nd vector component of $x_0$ to more clearly highlight the difference between the marginal and conditional flows.</p>

    <div>
      <div>
<div>

          <div>

            <div>
    <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/g2g-vector-field-samples-cond.png" alt="Realizations of paths from $p_0$ to $p_1$ following conditional vector fields $u_t(x \mid x_1)$. Paths are highlighted by the sign of the 2nd vector component at time $t=1$." id="figure-g2g-vector-field-samples-cond.png"/></p><p>
            Figure 14: Realizations of paths from $p_0$ to $p_1$ following conditional vector fields $u_t(x \mid x_1)$. Paths are highlighted by the sign of the 2nd vector component at time $t=1$.
        </p>
    
</div>

          </div>

          <div>

            <div>
    <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/g2g-forward_samples.png" alt="Paths from $p_0$ to $p_1$ following the true marginal vector field $u_t(x)$. Paths are highlighted by the sign of the 2nd vector component." id="figure-g2g-forward_samples.png"/></p><p>
            Figure 15: Paths from $p_0$ to $p_1$ following the true marginal vector field $u_t(x)$. Paths are highlighted by the sign of the 2nd vector component.
        </p>
    
</div>

          </div>

        </div>
</div>
    </div>

  </div>

</details>

<!-- Example end -->

<!-- 
<div markdown="1" class="my-success my-box">
The _conditional_ vector field is the OT map!
</div>
<div markdown="1" class="my-warning my-box">
Does not guarantee that the _marginal_ vector field is the OT map!
</div>
-->

<!-- 

## Gaussian probability paths (Cont'd)

:::danger
remove diffusion vf
</div>
### (conditional) diffusion vf
- $dx_t = -\frac{1}{2}\sqrt{\beta(t)} x_t \dd{t} + \beta(t) \dd{B}_t$
- $\alpha_t = e^{-\frac{1}{2}\int_0^t \beta(s) \dd{s}}$
- $\mu_t = \alpha_{1-t} x_1$ and $\sigma_t^2 = 1 - \alpha_{1-t}^2$
- $u_t(x \mid x_1) = -\frac{\sigma'_{1-t}}{\sigma_{1-t}}(x - x_1)$

### (conditional) OT vf
- $\mu_t = t x_1$ and $\sigma_t = 1 - t = (1 - (1 - \sigma_{\min})t$
- $u_t(x \mid x_1) = \frac{1}{1 - t}(x_1 - x) = \frac{1}{1 - (1 - \sigma_\min)t}(x_1 - (1 - \sigma_\min)x)$
<div markdown="1" class="my-warning my-box">
Does not guarantee that the _marginal_ vector field is the OT map!
</div>

-->

<h3 id="but-is-cfm-really-all-rainbows-and-unicorns">But is CFM really all rainbows and unicorns?</h3>

<!-- > [name=emilem] Perhaps this is a bit dramatic as FM already works well witout mini batch OT? -->

<p>Unfortunately not, no. There are two issues arising from <em>crossing conditional paths</em>. We will explain this just after, but now we stress that this lead to</p>
<ol>
  <li>Non-straight marginal paths $\Rightarrow$ ODE hard to integrate $\Rightarrow$ slow sampling at inference.</li>
  <li>Many possible $x_1$ for a noised $x_t$ $\Rightarrow$ high CFM loss variance $\Rightarrow$ slow training convergence.</li>
</ol>

<p>To get a better understanding of what these two points above, let’s revisit the \ref{eq:g2g} example once more. As we see in the figures below, realizations of the conditional vector field $u_t(x \mid x_1)$, i.e. sampling from the process</p>

\[\begin{equation*}
\begin{split}
x_1 &amp; \sim q \\
x_t &amp; \triangleq \phi_t(x \mid x_1)
\end{split}
\end{equation*}\]

<p>result in paths that are quite different from the marginal paths as illustrated in the figures below.</p>

<!-- > [name=emilem]  Gausian to gausian example instead -->

<div>
  <div>
<div>

      <div>
<div>

          <div>
    <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/g2g-vector-field-samples-cond.png" alt="Realizations of conditional paths from $p_0 = p_1 = \mathcal{N}(0, 1)$ for two different $x_1^{(i)}, x_1^{(2)} \sim q$ with conditional vector field given by $u_t(x \mid x_1) = (1 - t) x + t x_1$." id="figure-.png"/></p><p>
            Figure 16: Realizations of conditional paths from $p_0 = p_1 = \mathcal{N}(0, 1)$ for two different $x_1^{(i)}, x_1^{(2)} \sim q$ with conditional vector field given by $u_t(x \mid x_1) = (1 - t) x + t x_1$.
        </p>
    
</div>

          <!-- ![forward_samples](https://hackmd.io/_uploads/r1skZ4CI6.png) -->

        </div>
</div>

      <div>
<div>

          <div>
    <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/g2g-forward_samples.png" alt="Paths from $p_0$ to $p_1$ following the true marginal vector field $u_t(x)$. Paths are highlighted by the sign of the 2nd vector component." id="figure-.png"/></p><p>
            Figure 17: Paths from $p_0$ to $p_1$ following the true marginal vector field $u_t(x)$. Paths are highlighted by the sign of the 2nd vector component.
        </p>
    
</div>

          <!-- ![forward_samples](https://hackmd.io/_uploads/H1hVWVAUa.png) -->

        </div>
</div>

    </div>
</div>
</div>

<p>In particular, we can see that the marginal paths $\phi_t(x)$ <em>do not cross</em>; this is indeed just the uniqueness property of ODE solutions. A realization of the conditional vector field $u_t(x \mid x_1)$ also exhibits the “non-crossing paths” property, similar to the marginal flows $\phi_t(x)$, however paths $\phi_t(x \mid x_1)$ corresponding to <em>different</em> realizations $x_1 \sim q_1$ may intersect, as highlighted in the figure above.</p>

<!-- > [name=emilem] I like this bit but would the argument be more straightforward if $\hlone{x_t^{(1)}} = \hlone{x_t^{(2)}}$ ? -->

<p>Consider two highlighted paths in the visualization of $u_t(x \mid x_1)$, with data samples $\hlone{x_1^{(1)}}$ and $\hlthree{x_1^{(2)}}$. When learning a parameterized vector field $u_{\theta}(t, x)$ via stochastic gradient descent (SGD), we approximate the CFM loss as:</p>

\[\mathcal{L}_{\mathrm{CFM}}(\theta) \approx \frac{1}{2} \norm{u_{\theta}(t, \hlone{x_t^{(1)}}) - u(t, \hlone{x_t^{(1)}} \mid \hlone{x_1^{(1)}})} + \frac{1}{2} \norm{u_{\theta}(t, \hlthree{x_t^{(2)}}) - u(t, \hlthree{x_t^{(2)}} \mid \hlthree{x_1^{(2)}})}\]

<p>where $t \sim \mathcal{U}[0, 1]$, $\hlone{x_1^{(1)}}, \hlthree{x_1^{(2)}} \sim q_1$, and $\hlone{x_t^{(1)}} \sim p_t(\cdot \mid \hlone{x_1^{(1)}}), \hlthree{x_t^{(2)}} \sim p_t(\cdot \mid \hlthree{x_1^{(2)}})$. We compute the gradient with respect to $\theta$ for a gradient step.</p>

<p>In such a scenario, we’re attempting to align $u_{\theta}(t, x)$ with two different vector fields whose corresponding paths are impossible under the marginal vector field $u(t, x)$ that we’re trying to learn! This fact can lead to increased variance in the gradient estimate, and thus slower convergence.</p>

<p>In slightly more complex scenarios, the situation becomes even more striking. Below we see a nice example from Liu et al. (2022) where our reference and target are two different mixture of Gaussians in 2D differing only by the sign of the mean in the x-component. Specifically,</p>

\[\begin{equation}
\tag{MoG-to-MoG}
\label{eq:mog2mog}
\begin{split}
p_{\hlone{0}} &amp;= (1 / 2)\mathcal{N}([{\hlone{-\mu}}, -\mu], I) + (1 / 2) \mathcal{N}([{\hlone{-\mu}}, +\mu], I) \\
\text{and} \quad p_{\hltwo{1}} &amp;= (1 / 2) \mathcal{N}([{\hltwo{+\mu}}, -\mu], I) + (1 / 2) \mathcal{N}([{\hltwo{+\mu}}, +\mu], I) \\
\text{with} \quad \phi_t(x_0 \mid x_1) &amp;= (1 - t) x_0 + t x_1
\end{split}
\end{equation}\]

<p>where we set $\mu = 10$, unless otherwise specified.</p>

<div>
  <div>
<div>

      <div>

        <div>
    <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/vector-field-samples-cond.png" alt="Realizations of conditional paths following conditional vector field $u_t(x \mid x_1)$ from \eqref{eq:mog2mog}. Paths are highlighted by the sign of the 2nd vector component." id="figure-vector-field-samples-cond.png"/></p><p>
            Figure 18: Realizations of conditional paths following conditional vector field $u_t(x \mid x_1)$ from \eqref{eq:mog2mog}. Paths are highlighted by the sign of the 2nd vector component.
        </p>
    
</div>

        <!-- ![vector-field-samples-cond](https://hackmd.io/_uploads/SyG9OF_IT.png) -->
      </div>

      <div>

        <div>
    <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/vector-field-samples-marginal.png" alt="Realizations of marginal paths following the marginal vector field $u_t(x)$ from \eqref{eq:mog2mog}. Paths are highlighted by the sign of the 2nd vector component." id="figure-vector-field-samples-marginal.png"/></p><p>
            Figure 19: Realizations of marginal paths following the marginal vector field $u_t(x)$ from \eqref{eq:mog2mog}. Paths are highlighted by the sign of the 2nd vector component.
        </p>
    
</div>

        <!-- ![forward_samples](https://hackmd.io/_uploads/SJusOFuL6.png) -->
      </div>

    </div>
</div>
</div>

<p>Here we see that marginal paths (bottom figure) end up looking <em>very</em> different from the conditional paths (top figure). Indeed, at training time paths may intersect, whilst at sampling time they cannot (due to the uniqueness of the ODE solution). As such we see on the bottom plot that some (marginal) paths are quite curved and would therefore require a greater number of discretisation steps from the ODE solver during inference.</p>

<p>We can also see how this leads to a significant variance of the CFM loss estimate for $t \approx 0.5$ in the figure below.
More generally, samples from the reference distribution which are arbitrarily close to eachothers can be associated with either target modes, leading to high variance in the vector field regression loss.</p>

<div>
  <div>
<div>

      <div>

        <div>
    <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/vector-field-samples-with-traj.png" alt="Realizations of conditional paths $\phi_t(x_0 \mid x_1)$ following the conditional vector field $u_t(x \mid x_1)$ for \eqref{eq:mog2mog}." id="figure-vector-field-samples-with-traj.png"/></p><p>
            Figure 20: Realizations of conditional paths $\phi_t(x_0 \mid x_1)$ following the conditional vector field $u_t(x \mid x_1)$ for \eqref{eq:mog2mog}.
        </p>
    
</div>

        <!-- ![vector-field-samples-with-traj](https://hackmd.io/_uploads/B1Vuz4ALa.png) -->

      </div>

      <div>

        <div>
    <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/variance_cond_vector_field.png" alt="Variance of conditional vector field over $p_{1 \mid t}$ for both blue and red trajectories for \eqref{eq:mog2mog}." id="figure-variance_cond_vector_field.png"/></p><p>
            Figure 21: Variance of conditional vector field over $p_{1 \mid t}$ for both blue and red trajectories for \eqref{eq:mog2mog}.
        </p>
    
</div>

        <!-- ![variance_cond_vector_field](https://hackmd.io/_uploads/r1XcxLmPa.png) -->

      </div>

    </div>
</div>
</div>

<p>An intuitive solution would be to associate data samples with reference samples which are close instead of some arbitrary pairing.
We’ll detail this idea next via the concept of couplings and optimal transport.
<!-- To alleviate this issue, we'll turn to couplings and optimal transport. --></p>

<!-- 
#### Crossing paths

Let's observe in the following plot, the toy setting where both the data and noise distribution are bimodal mixtures. On the LHS, we can see possible linear interpolations between samples $x_1,x_0 \sim q(x_1,x_0) = q_1(x_1) q_0(x_0)$, as given by the conditional vector field. On the RHS we see different paths from the learnt flow $\dd x_t = u_\theta(t, x_t) \dd t$. For a well defined ODE--assuming continuous and Lipschitz vector field, solutions exist and are unique, and as such paths _cannot cross each other_ at any time $t$.
As a consequence the paths are different at training and inference time.
There are two immediate consequences:
1. At inference time, the paths aren't as 'straight' as they were if closer modes where 'matched' together, leading to an unnecessarily high number of discretisation steps (for a given error threshold).
2. At training time, noise samples which are arbitrarily close by can be associated with either data modes, and as such lead to high variance in the vector field regression loss.


<div markdown="1" class="my-center">
<div>
<div markdown="1" class="my-side-by-side">
<div markdown="1" class="my-image-container">

![forward_samples](https://hackmd.io/_uploads/SyG9OF_IT.png)
*Interpolation path $\phi(x_t \mid x_0,x_1)$*.

</div>
<div markdown="1" class="my-image-container">

![forward_samples](https://hackmd.io/_uploads/SJusOFuL6.png)
*Inference path $\phi(x_t \mid x_0)$*.

</div>
</div>
<div>

Figure: *Independent coupling $q(x_0, x_1) = q(x_0)q(x_1)$.*

</div>
</div>
</div>

<!--  -->
<!-- <div markdown="1" style="display: flex; margin-top:-10px; margin-bottom:-10px;">
<div markdown="1" style="margin: auto;">

![cond_ut](https://hackmd.io/_uploads/H1_jkEjB6.jpg =400x)
</div>
</div>
 -->

<h3 id="coupling">Coupling</h3>

<p>So far we have constructed the vector field $u_t$ by conditioning and marginalising over data points $x_1$. This is referred as a <em>one-sided conditioning</em>, where the probability path is constructed by marginalising over $z=x_1$:</p>

\[p_t(x_t) = \int p_t(x_t \mid z) q(z) \dd{z} = \int p_t(x_t \mid x_1) q(x_1) \dd{x_1}\]

<p>e.g. 
\(p(x_t  \mid  x_1) = \mathcal{N}(x_t \mid x_1, (1-t)^2)\).</p>

<div>
  <div>
<div>

      <div>
    <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/albergo_one_sided.jpg" alt="One sided interpolation. Source: Figure (2) in Albergo &amp; Vanden-Eijnden (2022)." id="figure-albergo_one_sided.jpg"/></p><p>
            Figure 22: One sided interpolation. Source: Figure (2) in Albergo &amp; Vanden-Eijnden (2022).
        </p>
    
</div>

    </div>
</div>
</div>

<p>Yet, more generally, we can consider conditioning and marginalising over latent variables $z$, and minimising the following loss:</p>

\[\mathcal{L}_{\mathrm{CFM}}(\theta) = \mathbb{E}_{(t,z,x_t) \sim \mathcal{U}[0,1] q(z) p(\cdot \mid z)}[\| u_\theta(t, x_t) - u_t(x_t \mid z)\|^2].\]

<p>As suggested in Liu et al. (2023), Tong et al. (2023), Albergo &amp; Vanden-Eijnden (2022) and Pooladian et al. (2023) one can condition on <em>both</em> endpoints $z=(x_1, x_0)$ of the process, referred as <em>two-sided conditioning</em>. The marginal probability path is defined as:</p>

\[p_t(x_t) = \int p_t(x_t \mid z) q(z) \dd{z} = \int p_t(x_t \mid x_1, x_0) q(x_1, x_0) \dd{x_1} \dd{x_0}.\]

<p>The following boundary condition on $p_t(x_t \mid x_1, x_0)$: $p_0(\cdot \mid x_1, x_0)=\delta_{x_0}$ and $p_1(\cdot \mid x_1, x_0) = \delta_{x_1}$ is required so that the marginal has the proper conditions $p_0 = q_0$ and $p_1 = q_1$.</p>

<p>For instance, a deterministic linear interpolation gives $p(x_t \mid x_0, x_1) = \delta_{(1-t)} x_0 + t x_1(x_t)$ and the simplest choice regarding the coupling $z = (x_1, x_0)$ is the consider independent samples: $q(x_1, x_0) = q_1(x_1) q_0(x_0)$.</p>

<div>
  <div>
<div>

      <div>
    <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/albergo_two_sided.jpg" alt="Two sided interpolation. Source: Figure (2) in Albergo &amp; Vanden-Eijnden (2022)." id="figure-albergo_two_sided.jpg"/></p><p>
            Figure 23: Two sided interpolation. Source: Figure (2) in Albergo &amp; Vanden-Eijnden (2022).
        </p>
    
</div>

    </div>
</div>
</div>

<p>One main advantage being that this allows for non Gaussian reference distribution $q_0$.
Choosing a standard normal as noise distribution $q(x_0) = \mathcal{N}(0, \mathrm{I})$ we recover the same <em>one-sided</em> conditional probability path as earlier:</p>

\[p(x_t \mid x_1) = \int p(x_t \mid x_0, x_1) q(x_0) \dd{x_0} = \mathcal{N}(x_t \mid tx_1, (1-t)^2).\]

<!-- - $p(x_0, x_1) = p(x_0) p(x_1)$
    - $p(x_0) = \N(0, \Id)$
    - $p(x_0)$ non Gaussian
 -->

<h4 id="optimal-transport-ot-coupling">Optimal Transport (OT) coupling</h4>

<!-- [Liu et al., 2022, Tong et al., 2023] suggest to alleviate this by using a **joint coupling** $q(x_1, x_0) \neq q_1(x_1) q_0(x_0)$ which correlates pairs $(x_1, x_0)$. -->
<p>Now let’s go back to the idea of <em>not</em> using an independent coupling (i.e. pairing) but instead to correlate pairs $(x_1, x_0)$ with a joint $q(x_1, x_0) \neq q_1(x_1) q_0(x_0)$.
Tong et al. (2023) and Pooladian et al. (2023) suggest using the <em>optimal transport coupling</em></p>

\[\begin{equation}
\tag{OT}
\label{eq:ot}
q(x_1, x_0) = \pi(x_1, x_0) \in \arg\inf_{\pi \in \Pi} \int \|x_1 - x_0\|_2^2 \mathrm{d} \pi(x_1, x_0)
\end{equation}\]

<p>which minimises the optimal transport (i.e. Wasserstein) cost (Monge, 1781, Peyré and Cuturi 2020).
The OT coupling $\pi$ associates samples $x_0$ and $x_1$ such that the total distance is minimised.
<!-- This prevents the crossing paths behaviour that we highlighted earlier, as permuting samples would yield non crossing paths which would have a lower total distance cost, and as such the coupling yielding to crossing paths cannot be the OT coupling. --></p>

<p>This OT coupling is illustrated in the right hand side of the figure below, adapted from Tong et al. (2023). In contrast to the middle figure which an independent coupling, the OT one does not have paths that cross. This leads to lower training variance and faster sampling<sup id="fnref:OT" role="doc-noteref"><a href="#fn:OT" rel="footnote">10</a></sup>.</p>

<div>
  <div>
<div>

      <div>

        <div>
    <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/trajectory-marginals-vertical.png" alt="One-sided conditioning (Lipman et al., 2022)" id="figure-trajectory-marginals-vertical.png"/></p><p>
            Figure 24: One-sided conditioning (Lipman et al., 2022)
        </p>
    
</div>

      </div>

      <div>

        <div>
    <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/trajectory-marginals-vertical-cond.png" alt="Two-sided conditioning (Tong et al., 2023)" id="figure-trajectory-marginals-vertical-cond.png"/></p><p>
            Figure 25: Two-sided conditioning (Tong et al., 2023)
        </p>
    
</div>

      </div>

      <div>

        <div>
    <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/trajectory-marginals-vertical-ot.png" alt="OT coupling (Tong et al., 2023)" id="figure-trajectory-marginals-vertical-ot.png"/></p><p>
            Figure 26: OT coupling (Tong et al., 2023)
        </p>
    
</div>

      </div>

    </div>
</div>
</div>

<!--
|     |     |     |
| :-: | :-: | :-: |
|  <sub><sup>One sided</sup></sub>   |  <sub><sup>Two sided</sup></sub>   |   <sub><sup>OT</sup></sub>  |
| <img src="https://hackmd.io/_uploads/HyLrNEWSa.jpg" width="60%"> | <img src="https://hackmd.io/_uploads/S10jNNZH6.jpg" width="60%"> | <img src="https://hackmd.io/_uploads/rJ7nENbrp.jpg" width="60%"> |
 -->

<p>In practice, we cannot compute the optimal coupling $\pi$ between $x_1 \sim q_1$ and $x_0 \sim q_0$, as algorithms solving this problem are only known for finite distributions.
In fact, finding a map from $q_0$ to $q_1$ is the generative modelling problem that we are trying to solve in the first place!</p>

<p>Tong et al. (2023) and Pooladian et al. (2023) propose to approximate the OT coupling $\pi$ by computing such optimal coupling only over each mini-batch of data and noise samples, coined <strong>mini-batch OT</strong> (Fatras et al., 2020). This is scalable as for finite collection of samples the OT problem can be computed with quadratic complexity via the Sinkhorn algorithm (Peyre and Cuturi, 2020). This results in a <em>joint</em> distribution $\gamma(i, j)$ over “inputs” \(\big(x_0^{(i)}\big)_{i=1,\dots,B}\) and “outputs” \(\big(x_1^{(j)}\big)_{j=1,\dots,B}\) such that the expected distance is (approximately) minimised.  Finally, to construct a mini-batch from this $\gamma$ which we can subsequently use for training, we can either compute the expectation wrt. $\gamma(i, j)$ by considering all $n^2$ pairs (in practice, this can often boil down to only needing to consider $n$ disjoint pairs<sup id="fnref:mini-batch-ot-deterministic-vs-stochastic" role="doc-noteref"><a href="#fn:mini-batch-ot-deterministic-vs-stochastic" rel="footnote">11</a></sup>) or sample a new collection of training pairs $(x_0^{(i’)}, x_1^{(j’)})$ with $(i’, j’) \sim \gamma$<sup id="fnref:mini-batch-ot-sampling-size" role="doc-noteref"><a href="#fn:mini-batch-ot-sampling-size" rel="footnote">12</a></sup>.</p>

<p>For example, we can apply this to the \eqref{eq:g2g} example from before, which almost completely removes the crossing paths behaviour described earlier, as can be seen in the figure below.</p>

<div>
  <div>

<div>

      <div>

        <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/g2g-cond-paths-one-color.png" alt="" id="figure-g2g-cond-paths-one-color--ot"/>
    
</p>

      </div>

      <div>

        <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/g2g-cond-paths-one-color-ot.png" alt="" id="figure-g2g-cond-paths-one-color-ot--ot"/>
    
</p>

      </div>

    </div>

<p>
Figure 27: \eqref{eq:g2g} with uniformly sampled pairings (left) and with OT pairings (right).
</p>

</div>
</div>

<p>We also observe similar behavior when applying this the more complex example \eqref{eq:mog2mog}, as can be seen in the figure below.</p>

<div>
  <div>

<div>

      <div>

        <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/mog2mog-cond-paths-one-color.png" alt="" id="figure-g2g-cond-paths-one-color--ot"/>
    
</p>

      </div>

      <div>

        <p><img src="https://mlg.eng.cam.ac.uk/blog/assets/images/flow-matching/mog2mog-cond-paths-one-color-ot.png" alt="" id="figure-g2g-cond-paths-one-color-ot--ot"/>
    
</p>

      </div>

    </div>

<p>
Figure 28: \eqref{eq:mog2mog} with uniformly sampled pairings (left) and with OT pairings (right).
</p>

</div>
</div>

<p>All in all, making use of mini-batch OT seems to be a strict improvement over the uniform sampling approach to constructing the mini-batch in the above examples and has been shown to improve practical performance in a wide range of applications (Tong et al., 2023; Klein et al., 2023).</p>

<p>It’s worth noting that in \eqref{eq:ot} we only considered choosing the coupling $\gamma(i, j)$ such that we minimize the expected squared Euclidean distance. This works well in the examples \eqref{eq:g2g} and \eqref{eq:mog2mog}, but we could also replace squared Euclidean distance with some other distance metric when constructing the coupling $\gamma(i, j)$. For example, if we were modeling molecules using CNFs, it might also make sense to pick $(i, j)$ such that $x_0^{(i)}$ and $x_1^{(j)}$ are also rotationally aligned as is done in the work of Klein et al. (2023).</p>

<!-- > [name=Tor] Should probably have some plots or something from the paper here to demonstrate that minibtach OT is worth it. -->
<!-- > [name=emilem] I agree, I'd suggest  -->



<!-- > [name=Tor] Maybe we should have a slightly more informal tone here? And
> - Maybe mention some open-source impls if people want to get started (unless we cook up something) on their own? -->

<p>In short, we’ve shown that flow matching is an efficient approach to training continuous normalising flows (CNFs), by directly regressing over the vector field instead of explicitly training by maximum likelihood.
This is enabled by constructing the target vector field as the marginalisation of simple conditional vector fields which (marginally) interpolate between the reference and data distribution, but crucially for which we can evaluate and integrate over time.
A neural network parameterising the vector field can then be trained by regressing over these conditional vector fields.
Similarly to CNFs, sampled can be obtained at inference time by solving the ODE associated with the neural vector field.</p>

<!-- which bridge between a noise refence distribution and a target data distribution, and as such constructs a generative model. -->

<p>In this post we have not talked about diffusion (i.e. score based) models on purpose as they are not necessary for understanding flow matching.
Yet these are deeply related and even exactly the same in some setting.
We are planning to explore these connections, along with generalisations in a follow-up post!</p>



<p>Please cite us as:</p>

<div><div><pre><code>@misc{mathieu2024flow,
  title   = &#34;An Introduction to Flow Matching&#34;,
  author  = &#34;Fjelde, Tor and Mathieu, Emile and Dutordoir, Vincent&#34;,
  journal = &#34;https://mlg.eng.cam.ac.uk/blog/&#34;,
  year    = &#34;2024&#34;,
  month   = &#34;January&#34;,
  url     = &#34;https://mlg.eng.cam.ac.uk/blog/2024/01/20/flow-matching.html&#34;
}
</code></pre></div></div>



<p>We deeply thank Michael Albergo, Valentin Debortoli and James Thornton for giving insightful feedback!</p>



<ul>
  <li>
    <p>Albergo, Michael S. &amp; Vanden-Eijnden, Eric (2023) <a href="https://openreview.net/pdf?id=li7qeBbCR1t">Building Normalizing Flows with Stochastic Interpolants</a>.</p>
  </li>
  <li>
    <p>Behrmann, Jens and Grathwohl, Will and Chen, Ricky T. Q. and Duvenaud, David and Jacobsen, Joern-Henrik (2019). <a href="https://proceedings.mlr.press/v97/behrmann19a.html">Invertible Residual Networks</a>.</p>
  </li>
  <li>
    <p>Betker, James, Gabriel Goh, Li Jing, TimBrooks, Jianfeng Wang, Linjie Li, LongOuyang, JuntangZhuang, JoyceLee, YufeiGuo, WesamManassra, PrafullaDhariwal, CaseyChu, YunxinJiao and Aditya Ramesh (2023). <a href="https://cdn.openai.com/papers/dall-e-3.pdf">Improving Image Generation with Better Captions</a>.</p>
  </li>
  <li>
    <p>Chen &amp; Gopinath (2000). <a href="https://proceedings.neurips.cc/paper_files/paper/2000/file/3c947bc2f7ff007b86a9428b74654de5-Paper.pdf">Gaussianization</a>.</p>
  </li>
  <li>
    <p>Chen &amp; Lipman (2023). <a href="http://arxiv.org/abs/2302.03660v2">Riemannian Flow Matching on General Geometries</a>.</p>
  </li>
  <li>
    <p>Chen, Ricky T. Q. and Behrmann, Jens and Duvenaud, David K and Jacobsen, Joern-Henrik (2019). <a href="http://arxiv.org/abs/1906.02735">Residual flows for invertible generative modeling</a>.</p>
  </li>
  <li>
    <p>De Bortoli, Mathieu &amp; Hutchinson et al. (2022). <a href="http://arxiv.org/abs/2202.02763v3">Riemannian Score-Based Generative Modelling</a>.</p>
  </li>
  <li>
    <p>Dupont, Doucet &amp; Teh (2019). <a href="http://arxiv.org/abs/1904.01681v3">Augmented Neural Odes</a>.</p>
  </li>
  <li>
    <p>Friedman (1987). <a href="https://www.jstor.org/stable/pdf/2289161.pdf">Exploratory projection pursuit</a>.</p>
  </li>
  <li>
    <p>George Papamakarios, Theo Pavlakou, Iain Murray (2018). <a href="https://proceedings.neurips.cc/paper/2017/file/6c1da886822c67822bcf3679d04369fa-Paper.pdf">Masked Autoregressive Flow for Density Estimation</a>.</p>
  </li>
  <li>
    <p>Huang, Chin-Wei and Krueger, David and Lacoste, Alexandre and Courville, Aaron (2018). <a href="http://arxiv.org/abs/1804.00779">Neural Autoregressive Flows</a>.</p>
  </li>
  <li>
    <p>Klein, Krämer &amp; Noé (2023). <a href="http://arxiv.org/abs/2306.15030v2">Equivariant Flow Matching</a>.</p>
  </li>
  <li>
    <p>Lipman, Yaron and Chen, Ricky T. Q. and Ben-Hamu, Heli and Nickel, Maximilian and Le, Matt (2022). <a href="http://arxiv.org/abs/2210.02747">Flow Matching for Generative Modeling</a>.</p>
  </li>
  <li>
    <p>Liu, Xingchao and Gong, Chengyue and Liu, Qiang (2022). <a href="http://arxiv.org/abs/2209.03003">Flow Straight and Fast: Learning to Generate and Transfer Data with Rectified Flow</a>.</p>
  </li>
  <li>
    <p>Monge, Gaspard (1781). Mémoire Sur La Théorie Des Déblais et Des Remblais.</p>
  </li>
  <li>
    <p>Peyré, Gabriel and Cuturi, Marco (2020). <a href="http://arxiv.org/abs/1803.00567">Computational Optimal Transport</a>.</p>
  </li>
  <li>
    <p>Pooladian, Aram-Alexandre and {Ben-Hamu}, Heli and {Domingo-Enrich}, Carles and Amos, Brandon and Lipman, Yaron and Chen, Ricky T. Q. (2023). <a href="http://arxiv.org/abs/2304.14772">Multisample Flow Matching: Straightening Flows With Minibatch Couplings</a>.</p>
  </li>
  <li>
    <p>Song, Sohl-Dickstein &amp; Kingma et al. (2020). <a href="http://arxiv.org/abs/2011.13456v2">Score-Based Generative Modeling Through Stochastic Differential Equations</a>.</p>
  </li>
  <li>
    <p>Tong, Alexander and Malkin, Nikolay and Fatras, Kilian and Atanackovic, Lazar and Zhang, Yanlei and Huguet, Guillaume and Wolf, Guy and Bengio, Yoshua (2023). <a href="http://arxiv.org/abs/2307.03672">Simulation-Free Schrodinger Bridges via Score and Flow Matching</a>.</p>
  </li>
  <li>
    <p>Tong, Malkin &amp; Huguet et al. (2023). <a href="http://arxiv.org/abs/2302.00482v2">Improving and Generalizing Flow-Based Generative Models With Minibatch Optimal Transport</a>.</p>
  </li>
  <li>
    <p>Watson, Joseph L. and Juergens, David and Bennett, Nathaniel R. and Trippe, Brian L. and Yim, Jason and Eisenach, Helen E. and Ahern, Woody and Borst, Andrew J. and Ragotte, Robert J. and Milles, Lukas F. and Wicky, Basile I. M. and Hanikel, Nikita and Pellock, Samuel J. and Courbet, Alexis and Sheffler, William and Wang, Jue and Venkatesh, Preetham and Sappington, Isaac and Torres, Susana V{&#39;a}zquez and Lauko, Anna and De Bortoli, Valentin and Mathieu, Emile and Ovchinnikov, Sergey and Barzilay, Regina and Jaakkola, Tommi S. and DiMaio, Frank and Baek, Minkyung and Baker, David (2023). <a href="https://www.nature.com/articles/s41586-023-06415-8">De Novo Design of Protein Structure and Function with RFdiffusion</a>.</p>
  </li>
</ul>




    
        <nav>
            
                
            
            
        </nav>
    

    <date>
        Published on 20 January 2024.
        
    </date>

    
        
        
        
        
    
</article>

                </main>
            </div></div>
  </body>
</html>
