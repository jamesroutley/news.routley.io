<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://medium.com/tezedge/prevent-the-loss-of-baking-rewards-with-the-6-times-faster-and-more-stable-tezedge-context-storage-ade5714228b5">Original</a>
    <h1>A six-fold improvement in the Merkle tree storage for Tezos</h1>
    
    <div id="readability-page-1" class="page"><section><div><div><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/0*mFRpkOkWzeM1O_m2" width="700" height="667" role="presentation"/></p></div><figcaption>I/O graph comparison of the Octez v11 context storage (upper) and the TezEdge v1.15 context storage (lower). Notice the improvement in reads and writes per second, as well as the lack of spikes in performance.</figcaption></figure><p id="1939">Improving the storage is one of the most effective ways of improving a blockchain node’s overall performance. Blockchain nodes must regularly and continuously access the storage that contains the <em>blockchain state</em> (also known in Tezos as the <em>context</em>). The speed at which a node can access this storage affects block application time — a slower storage module will slow down block application, thus constituting a bottleneck for the overall speed and stability of the node.</p><p id="c2a7">If the storage is not available for some reason, then the application of blocks cannot proceed and the node ‘freezes’. When such freezes happen (which can last many minutes), the node gets stuck until the storage has finished performing its maintenance tasks. If block application takes more than 30 seconds (the time currently allowed for block creation, also known as the <em>block time</em>), then the baker might not be able to bake the block and they can lose their reward for baking or endorsing.</p><p id="60c0">Until now TezEdge supported two different implementations of the context storage, the Octez v11 implementation, and our own Rust-based implementation of a garbage-collected in-memory storage that only keeps the data from the latest 7 cycles.</p><p id="3bd4">Now there is a third option. We’ve developed a persisted context storage that saves the entire Tezos blockchain state on-disk and we have named it the TezEdge v1.15 context storage. This has translated into a major improvement in performance when compared to the Octez v11 implementation:</p><ol><li id="477c">The TezEdge v1.15 context storage performs a little over half as much reads (input) and less than a third of writes (outputs) into the disk compared to the Octez v11 implementation. It also has minimum variance, meaning that there are no spikes in reads/writes. You can jump to the section titled <strong>Advanced tracing tool for context storage</strong> to see the full details.</li><li id="97b1">Additionally, our implementation does not suffer from the aforementioned freezes. This increases the probability of being able to successfully bake or endorse a block and obtain the reward.</li></ol><p id="4f90">The next version of <a href="https://forum.tezosagora.org/t/tezos-storage-irmin-january-2022/4336" rel="noopener ugc nofollow" target="_blank">Octez (v13)</a> will feature an improved storage implementation that addresses the issues we have discussed in this article. We are looking forward to working the team behind Octez to publish an updated version of our benchmarks once it is released.</p><p id="a79a">If we want to perform any kind of work with a Tezos node, we need to first bootstrap it, meaning that we need to re-process every block of operations, starting with the genesis block and finishing with the block at the head of the chain.</p><p id="b473">We launched two instances of the TezEdge node while using 16GB of RAM and allowing a maximum storage bandwidth of 300MB/s for both. The only difference between the two instances was that one used our new and improved TezEdge v1.15 storage, while the other used the Octez v11 storage.</p><p id="9e6b">Bootstrapping a node is limited by two constraints: the Tezos economic protocol and the storage of the node that is being bootstrapped. The <strong>TezEdge v1.15 storage</strong> required <strong>44,131 seconds</strong> to complete the processing of over 2 million blocks (95.1% bootstrapped). Meanwhile, the <strong>Octez v11 storage</strong> needed <strong>295,756 seconds</strong> to perform just 75.4% of the storage part of the bootstrapping (1.6 million)</p><p id="6db0"><strong>Octez v11 storage statistics</strong></p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/0*ov4TKTpDyJLOro-v" width="700" height="337" role="presentation"/></p></div></figure><p id="889c"><a href="http://irmin-ram-16gb-io-300mb.storage.tezedge.com/#/resources/storage" rel="noopener ugc nofollow" target="_blank">http://irmin-ram-16gb-io-300mb.storage.tezedge.com/#/resources/storage</a></p><p id="c3c9"><strong>TezEdge v1.15 storage statistics</strong></p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/0*DVGi8vkhLbJsjAIQ" width="700" height="337" role="presentation"/></p></div></figure><p id="451a"><a href="http://rust-ram-16gb-io-300mb.storage.tezedge.com/#/resources/storage" rel="noopener ugc nofollow" target="_blank">http://rust-ram-16gb-io-300mb.storage.tezedge.com/#/resources/storage</a></p><p id="246b">On the right side of the <code>STORAGE</code> tab you can find the full statistics. Scroll down to the bottom to find the total time, which is the important value here. It is much less in the new TezEdge v1.15 storage, mostly thanks due to its avoidance of freezes. Additionally, one of the reasons the Octez v11 storage implementation spends so much on reads is that it also needs to wait for merges</p><p id="7857">Since our project is developing a Tezos node shell, our focus is on every module that is a part of it. This includes the storage, and optimizing it greatly affects the speed of bootstrapping. The reason why our storage performs so well is that we not only reduced the size of the data necessary for bootstrapping, but we also sped up the rate at which it is processed.</p><p id="8bcb">In the TezEdge v1.15 context storage, our data files are <em>append-only</em>, meaning new data can be appended to the storage, but existing data is immutable. Ordinarily, finding values within an unordered data file is done via a linear scan (sequentially checking each value in the list until a match is found or the whole list has been searched). However, such scans tend to be quite expensive for large datasets. Databases usually avoid that by using <em>indexes</em>.</p><p id="23c4">Database indexes are special lookup tables consisting of two columns. The first column is the search key, and the second one is the data pointer. The keys are the values you want to search and retrieve from your database table, and the pointer or reference stores the disk block address in the database for that specific search key. The key fields are sorted so that it accelerates the data retrieval operation for all your queries.</p><p id="2bd2">These indexes often are just a sequence of ordered entries, but new entries are added in random order. This means that from time to time, you need to sort the index. This type of maintenance work takes some time, and in some cases, will leave the storage unavailable until it is complete.</p><p id="8714">In the current Octez v11 context storage (Irmin 2.9 for Octez v11) , there is an index that can be used to address any stored object by its hash. This index can grow very big (larger than 70GB for a node containing all the mainnet history right now), which makes its maintenance very costly.</p><p id="8a63">The indexes we use in the TezEdge v1.15 only store references to the commits special objects in the storage that contain information about specific versions of the Merkle tree that represents the blockchain state, making them much smaller. They are small enough to be completely loaded and sorted in-memory when the node starts — for instance, the commit index, which is our main one, has less than 100 MB. Such small indexes do not require regular maintenance — the on-disk indexes do not have to be sorted. For this reason, the TezEdge v1.15 storage is not susceptible to freezes. Additionally, storing the indexes in-memory improves performance.</p><p id="58f8">This works because in Tezos, the storage objects are never addressed directly, but instead are reached by traversing a <a rel="noopener" href="https://medium.com/tezedge/a-deep-dive-into-the-tezos-storage-how-the-blockchain-state-is-stored-in-the-tezedge-node-3166cbd06ca2">Merkle tree</a> that begins at the commit object. In addition to this, objects in the tree always reference other objects by their offsets in the database file, not by their hash. This avoids one costly indirection when trying to find objects in the store.</p><p id="e614">The next version of the Octez context storage (Irmin 3.0) will also implement a solution to the big indexes problem similar to what we described here.</p><p id="39e7">Since blocks in Tezos have to be baked within 30 seconds, bakers may lose out on the baking or endorsement reward if a call (such as a commit) takes too much time. This tends to happen when the storage suffers from the spikes we discussed earlier in the article.</p><p id="98e8">This is why our primary goal is to reduce the latency of calls — so that no individual call causes bakers to lose their reward by taking too much time. Our secondary goal is to reduce the total time these calls take so that the node’s storage performs better.</p><p id="c60b">We’ve developed an advanced tracing tool for calls made in the storage. We can use this tool to compare storage implementations and we can even select any past or current protocol.</p><p id="f072"><strong>Advanced tracing tool for context storage</strong></p><p id="2670">To check out the tracing tool, go to this link:</p><p id="481c"><a href="https://tezedge.com/#/resources/storage" rel="noopener ugc nofollow" target="_blank">https://tezedge.com/#/resources/storage</a></p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/0*FCO4hWWJen_HRqmg" width="700" height="315" role="presentation"/></p></div></figure><p id="4804">From the top downwards, underneath the highlighted <code>STORAGE</code> tab, you can first see that the Current context is <code>irmin</code>, meaning that the statistics displayed are for the Octez v11 context storage.</p><p id="48ff">Underneath that is a list of all Tezos protocols. Let’s select Hangzhou, the latest protocol, because that is what bakers are currently using.</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/0*aEZKgvTZw5kGihkL" width="700" height="315" role="presentation"/></p></div></figure><p id="0179">From left to right, first, we see the name for the type of action, this graph is for all <code>COMMIT</code> calls.</p><p id="f45b">Then we see the total number of <code>COMMIT</code> calls made, which is 253k (253,000).</p><p id="7276">The total time of all these calls is 45,130.93 seconds.</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/0*jpIdbxN_Pd7FowAQ" width="700" height="307" role="presentation"/></p></div></figure><p id="b3c3">The y axis represents the total time of all <code>COMMIT</code> calls.</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/0*YvVB32tCeJA6w9X2" width="700" height="307" role="presentation"/></p></div></figure><p id="3b5a">The x axis represents the duration of COMMIT actions</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/0*QGVuZprvIGMaWfVS" width="700" height="307" role="presentation"/></p></div></figure><p id="a6f7">The graph is organized into vertical rows of blocks. Each vertical row represents calls made within a specific range of time as described in the x axis titled <code>Duration of call</code>.</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/0*w4Yv7cNd5fU6xLdc" width="700" height="390" role="presentation"/></p></div></figure><p id="1290">Hovering the cursor above a vertical row displays a tooltip that shows:</p><ul><li id="0c89">How many calls were made within that range</li><li id="870b">Their mean (average) duration</li><li id="a42c">Their maximum duration</li><li id="8e67">The total time of these calls</li></ul><p id="3fb7">The grey squares denote that the calls have an adequate duration. Orange squares denote durations that are longer than usual, and red squares denote that the duration is too long and will pose a risk to baking rewards.</p><p id="4838"><strong>Large call latencies may lead to lost baking and endorsement rewards</strong></p><p id="8c74">In this screenshot, we can see that there are 82 calls that are in the &gt;100 second range. Since block creation has a 30 second constraint, such a large number of &gt;100s calls will prevent blocks from being applied, which means baking and endorsement rewards will be lost.</p><p id="ba83">As described previously, we have not only significantly sped up the rate at which the data is read and written, but we have also reduced the amount of data that has to be read from or written into the node’s hard disk.</p><p id="d1e2">Reducing the amount of data that has to be written and read is particularly valuable for major baking services who use enterprise-level SSDs in the servers on which they run their nodes.</p><p id="ab01">SSDs have a limited lifespan that is further shortened by storing data onto them, with the reduction in lifespan being proportionate to the volume of data stored. Therefore reducing the amount of data that has to be written onto the hard disks used in baking allows them to last longer.</p><p id="9d93">This will become even more important in the future as the size of blockchain data and the requirements for storage will exponentially grow.</p><p id="8217">We’ve launched two instances of the TezEdge node, one using the Octez v11 storage implementation while the other uses the new TezEdge v1.15 context storage. You can view each instance via the in-browser TezEdge explorer:</p><p id="9996"><em>For the Octez v11 storage implementation storage context, go to this link:</em></p><pre><span id="ec94"><a href="http://irmin-ram-16gb-io-300mb.storage.tezedge.com/#/resources/system" rel="noopener ugc nofollow" target="_blank">http://irmin-ram-16gb-io-300mb.storage.tezedge.com/#/resources/system</a></span></pre><p id="8817"><em>For the new and improved TezEdge v1.15 persisted storage context, go to this link:</em></p><pre><span id="c759"><a href="http://rust-ram-16gb-io-300mb.storage.tezedge.com/#/resources/system" rel="noopener ugc nofollow" target="_blank">http://rust-ram-16gb-io-300mb.storage.tezedge.com/#/resources/system</a></span></pre><p id="6844"><em>Please note that at the time this article was written:</em></p><ul><li id="c153">The node running with the <strong>the Octez v11 context storage used by Octez</strong> has processed <strong>1620147 blocks</strong> and has applied <strong>75.4%</strong> of operations.</li><li id="99f0">The node running with the <strong>TezEdge v1.15 context storage</strong> has processed <strong>2039622 blocks</strong> and applied <strong>95.1%</strong> of operations</li></ul><p id="be3b">Although the system overview tab begins with a graph for CPU and then RAM, in this article, we begin with a comparison of <code>STORAGE I/O</code>, because this is the most important graph in terms of the storage’s overall performance, and how much it affects successful baking and endorsing.</p><p id="52a6"><strong>Octez v11 Storage I/O</strong></p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/0*zB1A1Plcocvlt5K5" width="700" height="332" role="presentation"/></p></div></figure><p id="1245"><strong>TezEdge v1.15 Storage I/O</strong></p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/0*Yw-ied7-wJCnIaOh" width="700" height="326" role="presentation"/></p></div></figure><p id="5a2c"><em>Please note that here the cursor is intentionally placed on a spike in both graphs. Additionally, the y axis of the Octez v11 storage chart stops at 400MB while the TezEdge v1.15 storage stops at 200MB.</em></p><p id="6819">The<strong> </strong>input/output of the TezEdge v1.15 storage is significantly lower than that of the old version of the storage. The important values here are:</p><ul><li id="191c"><code>Validators — read per second</code>, which in the TezEdge v1.15 storage is a bit more than half of what it is in the Octez v11 storage, and</li><li id="01e6"><code>Validators — written per second</code>, which is less than a third of what it is in the Octez v11 storage.</li></ul><p id="aa0a">While there are a few spikes, they are much less frequent and they never reach the same heights as those in the graph from the Octez v11 storage. The cause of such spikes in Octez v11 storage implementation is the merging of the index, which grows bigger as more blocks are processed.</p><p id="519f"><strong>Octez v11 storage RAM usage</strong></p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/0*brwzfSE6M2odcdYy" width="700" height="247" role="presentation"/></p></div></figure><p id="8872"><strong>TezEdge v1.15 RAM usage</strong></p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/0*qjIqHfgStmUo-rUS" width="700" height="246" role="presentation"/></p></div></figure><p id="7b65">The value to watch here is the green line marked as <code>VALIDATORS</code>. Here you can see that the new TezEdge v1.15 storage uses less memory and it also has much less variance — it does not go through ‘spikes’, sudden rises in the use of memory, which, as you can see in the first graph, are very frequent in the Octez v11 storage implementation.</p><p id="6856">Please note that the large spike in the TezEdge v1.15 RAM graph is caused by the update to protocol 011 Hangzhou. This included a major restructuring of the context tree, which is a very expensive operation. While the new representation of the context tree is better, it takes a while to migrate the past version’s tree to the new one.</p><p id="79b8"><strong>Octez v11 storage duration of commits and checkouts</strong></p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/0*NgPpTP_IXoMtkM3d" width="700" height="337" role="presentation"/></p></div></figure><p id="4300"><strong>TezEdge v1.15 duration of commits and checkouts</strong></p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/0*JdHkLadP1xErQ1Fh" width="700" height="334" role="presentation"/></p></div></figure><p id="03ad">Here we can see that the <code>COMMIT</code> time is faster in the TezEdge v1.15 storage. This is because, during the previously-discussed storage freezes in the Octez v11 storage, actions slow down considerably. Freezes are caused by index maintenance tasks, which do not happen in the TezEdge v1.15 storage. These freezes lead to spikes in latency, which means certain calls can take too long and cause bakers to miss out on their reward for baking or endorsing.</p><p id="e43f"><strong>Octez v11 storage duration of MEM and FIND actions for smart contracts</strong></p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/0*zweIPse55xn_Vren" width="700" height="299" role="presentation"/></p></div></figure><p id="7c5b"><strong>TezEdge v1.15 duration of MEM, MEMTREE and FIND actions</strong></p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/0*OCmLzBZC2ZQejiOE" width="700" height="301" role="presentation"/></p></div></figure><p id="e37b">Similarly to <code>COMMIT</code> and <code>CHECKOUT</code>, the actions <code>MEM</code>, <code>MEM TREE</code> and <code>FIND</code> as well as several others in this row are significantly slower in the Octez v11 storage.</p><p id="eac8">You can see the improvement in the performance of the TezEdge v1.15 storage by running two instances of the TezEdge Explorer, one for the node with the Octez v11 storage implementation and the other for the node with the TezEdge v1.15 storage implementation.</p><p id="e4ce">1. First, you need to clone this repo.</p><pre><span id="d5c0">git clone<a href="https://github.com/simplestaking/tezedge.git" rel="noopener ugc nofollow" target="_blank"> </a><a href="https://github.com/tezedge/tezedge.git" rel="noopener ugc nofollow" target="_blank">https://github.com/tezedge/tezedge.git</a></span></pre><p id="f6f6">2. Then change into the cloned directory</p><pre><span id="976d">cd tezedge</span></pre><p id="2e7e">3. Run docker by typing these commands:</p><p id="ab07">a) To test with <strong>Octez v11 context storage</strong> (Irmin 2.9):</p><pre><span id="0bcf">docker-compose -f docker-compose.storage.irmin.yml pull</span><span id="1cb5">docker-compose -f docker-compose.storage.irmin.yml up</span></pre><p id="0ec3">And visit <a href="http://localhost:8181" rel="noopener ugc nofollow" target="_blank">http://localhost:8181</a> in your browser.</p><p id="fc00">b) To test with <strong>TezEdge’s v1.15 persistent context storage</strong>:</p><pre><span id="4bc1">docker-compose -f docker-compose.storage.persistent.yml pull</span><span id="7be0">docker-compose -f docker-compose.storage.persistent.yml up</span></pre><p id="fe72">And visit <a href="http://localhost:8383" rel="noopener ugc nofollow" target="_blank">http://localhost:8383</a> in your browser.</p><p id="c76b">In our next release, users will be able to load the in-memory storage that we described in our <a rel="noopener" href="https://medium.com/tezedge/optimizing-inter-process-communication-between-the-tezedge-context-storage-and-the-tezos-economic-f0574153773c">past article</a> from a persisted version, which means you won’t have to start processing the entire chain from the beginning each time you start the node. We will also include support for making <a href="https://tezos.gitlab.io/user/snapshots.html" rel="noopener ugc nofollow" target="_blank">snapshots</a> of the Tezos blockchain for quicker bootstrapping. However, please note that our snapshots are not compatible with Octez snapshots.</p><p id="b7a5">We hope you have enjoyed our article about the new and improved storage. Feel free to contact me by <a href="mailto:jurajselep@viablesystems.io" rel="noopener ugc nofollow" target="_blank">email</a>, I look forward to receiving your questions, comments and suggestions. To read more about Tezos and the TezEdge node, please visit our <a href="https://docs.tezedge.com/" rel="noopener ugc nofollow" target="_blank">documentation</a>, subscribe to our <a href="https://medium.com/tezedge" rel="noopener">Medium</a>, follow us on <a href="https://twitter.com/tezedge" rel="noopener ugc nofollow" target="_blank">Twitter</a> or visit our <a href="https://github.com/tezedge" rel="noopener ugc nofollow" target="_blank">GitHub</a>.</p></div></div></section></div>
  </body>
</html>
