<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ambrook.com/blog/building-a-cross-platform-web-and-mobile-app-from-the-ground-up">Original</a>
    <h1>Building a Cross-Platform Web and Mobile App from the Ground Up</h1>
    
    <div id="readability-page-1" class="page"><article><section></section><section><div><section><div><p>&#34;Why can&#39;t we just write this code once and have it just work across Web, Android and iOS?&#34; As a mobile engineer who has spent both a significant portion of his career copying the exact same product from iOS to Android, I’ve asked myself this question many times.</p><p>At Ambrook, we’re lucky to have the opportunity to approach the challenge of supporting multiple platforms without the constraints of legacy engineering decisions. As a result, we’ve been able to share code across web and mobile, allowing all of our entire engineering team (currently four engineers) to contribute with little overhead.</p><p>Ambrook is building a suite of financial tools for farmers that needs to be consistent and fully-featured across desktop and mobile. So that farmers can use our tools in the field, they must work well on slower internet connections and while offline. As an early stage company, we are prioritizing rapid delivery of new features as we get feedback from our users.</p><h2>The Project</h2><p>When I first joined the Ambrook team, I was tasked with figuring out how to translate our existing web app to mobile. The web app was written in Typescript using React DOM and Next.js, which made it a tempting target to try using React Native. If successful, using React Native would mean that we could share code between platforms, greatly reducing both the cost of copying existing features and (more importantly) the cost of every new feature we’d need to build going forward.</p><p>At the same time, we wanted to be humble about the reasons why other companies have struggled to adopt cross-platform technologies. ​​A common issue that we avoided is the need to work with existing native product code, a requirement that can significantly negate the productivity advantages of using a cross-platform framework.</p><p>There were three main questions that we set out to address from the beginning:</p><ol><li><p>Can we define best practices and patterns around cleanly separating presentation and business logic to allow for the inevitable UI divergence between platforms?</p></li><li><p>Do third-party libraries exist that cover common app needs (ex. navigation, API access, graphing), and do they work well across platforms?</p></li><li><p>Does working cross-platform significantly speed up development time compared to just writing the code twice? Is the system easy for someone familiar with our existing codebase to be productive in?</p></li></ol><p>We decided to leverage React Native as a compatibility layer between the shared business logic from our existing React (Web) codebase and platform-specific APIs. React Native allows us to bridge the differences between the UI APIs on each platform: DOM on Web, UIKit on iOS, and Android&#39;s View system. We chose to adopt this cross-platform approach because it lets us share business logic between platforms, leverage high quality open source libraries, and rapidly develop and QA new changes to the app.</p></div></section></div></section><section><div><div><div><figure><div><figure><img src="https://cdn.sanity.io/images/h6kk644c/production/e0570db284838ca0af7d549bd5cbe489850af4a2-1732x1344.png"/></figure><p><hr/><figcaption>We decided to leverage React Native as a compatibility layer between the shared business logic from our existing React (Web) codebase and platform-specific APIs.</figcaption></p></div></figure></div></div></div></section><section><div><section><div><h2>Sharing Business Logic</h2><p>One of the main benefits of our cross-platform strategy is that we are able to share business logic between web and mobile. In fact, <strong>all major screens in our app share the same business logic</strong> across platforms; it was easier to adapt the existing Typescript-based business logic to be platform agnostic than to rewrite the same business logic multiple times.</p><p>An area where we chose not to share code is in the UI layer above the business logic. The guiding principle that we used was to share as much code as practical (business logic and some views) while allowing for some level of divergence to allow for native-feeling UIs and to use the APIs and technologies that felt best for each platform.</p><p>On the web front, this means using CSS-based media queries to create a responsive website and using CSS for things like sticky headers. On mobile, we add support for pull to refresh and double tapping on the navigation bar to scroll to the top of a screen. For both platforms, the lowest level components (like buttons, forms, etc.) are implemented separately as part of our design system, which we talked about in a <a href="https://ambrook.com/blog/how-engineers-design-full-stack-design-systems-at-ambrook">previous post</a>.</p><h2>Leveraging Open Source Libraries</h2><p>By using React Native, we&#39;re also able to tap into a rich open source ecosystem that has largely removed the need for us to write platform specific native code. Our experience has been that most common app use cases have mature, well-maintained libraries.</p><p>Some of our favorite libraries in use are:</p><ul><li><p><a href="https://www.apollographql.com/docs/react/?ref=ambrook" target="_blank" rel="noopener noreferrer">Apollo Client</a>, a GraphQL client implementation with support for optimistic mutations, cache normalization and persistence, and client-side state. Apollo scales well from a limited persistence web environment to an offline, stateful mobile environment.</p></li><li><p><a href="https://formidable.com/open-source/victory/docs/victory-chart/?ref=ambrook" target="_blank" rel="noopener noreferrer">Victory</a>, a charting library with support for many different chart types.</p></li><li><p><a href="https://reactnavigation.org/?ref=ambrook" target="_blank" rel="noopener noreferrer">React Navigation</a>, a mobile navigation library with support for tabbed navigation, modals, and navigation stacks. It also has first class URL handling, which makes bridging the gap with web very simple: just use URL-based navigation everywhere.</p></li></ul></div></section></div></section><section><div><div><div><figure><div><figure><img src="https://cdn.sanity.io/images/h6kk644c/production/039146b9f93560e816faa36ea6f3358e12e73c7d-1788x820.png"/></figure><p><hr/><figcaption>Using Victory as a charting library allows us to render nearly identical charts across different platforms with minimal effort.</figcaption></p></div></figure></div></div></div></section><section><div><section><div><h2>Rapid Local Development</h2><p>Making a small code change and having it be reflected on device can take anywhere from a few seconds to several minutes in the largest apps. Reducing this incremental build time pays dividends beyond simple time savings. As the iteration time gets shorter, we’re able to both make more rapid and isolated code changes, greatly enhancing comprehension of the code that those changes are being applied to.</p><p>Both our web app (via Next.js) and our mobile app (via React Native) support <a href="https://reactnative.dev/docs/fast-refresh?ref=ambrook" target="_blank" rel="noopener noreferrer">Fast Refresh</a>, allowing changes to components to be reflected in a matter of seconds without losing either app or individual component state. Fast Refresh has been indispensable. When I’m not sure of how a UI will look, I can save small changes several times in a row, tweaking one layout property until everything looks right. Frequently, I keep a browser window and simulator open side by side to reflect live changes on two platforms simultaneously.</p><h2>Rapid QA on Pull Requests</h2><p>As an early-stage company, we frequently ship new features and fixes to our app. In order to prevent new bugs from being introduced during this process, we made it easy for developers to manually test changes as a normal part of their review flow.</p><p>On web, we deploy every open pull request to a unique Google Cloud Run URL so that opening the new version of the app is a single click away.</p></div></section></div></section><section><div><div><div><figure><div><figure><img src="https://cdn.sanity.io/images/h6kk644c/production/7cf15440903ce3d649af81c9992c8693f279595f-1498x324.png"/></figure></div></figure></div></div></div></section><section><div><section><p>On mobile, we generate a QR code that can be scanned by a phone running the Ambrook app to download and run the latest Javascript bundle live on the phone. Native code changes can&#39;t be previewed using this system, but it’s worked well for us because most of our changes do not involve native code. The technical approach used here is similar to that of Shopify&#39;s React Native app, which they&#39;ve described in <a href="https://shopify.engineering/tophatting-react-native?ref=ambrook" target="_blank" rel="noopener noreferrer">this blog post</a>.<em></em></p></section></div></section><section><div><div><div><figure><div><figure><img src="https://cdn.sanity.io/images/h6kk644c/production/017333511530bdbf61ae6a76791063990ea6a09f-1502x926.png"/></figure><p><hr/><figcaption>Thanks to Expo for powering the experience shown here.</figcaption></p></div></figure></div></div></div></section><section><div><section><div><h2>Our Takeaways</h2><p>For Ambrook, building a cross-platform web and mobile app from a single codebase has saved us significant time and effort. Other teams considering a similar approach can take a few points away from our experience:</p><ul><li><p>You can expect near-full sharing of business logic between platforms, but having divergent UIs (either at a design system level or at an entire screen level) may be most practical and preferable to create an app that feels native on each platform.</p></li><li><p>Open source libraries currently cover most common app needs and effectively abstract away platform differences, removing the need to write native code for feature development.</p></li><li><p>The developer experience improvements in React Native (Fast Refresh and QA via QR codes) are significant and would be difficult to accomplish in native due to its use of statically compiled languages.</p></li></ul><p>Finally, as a quick catch-all, a few bonus recommendations for adopting our stack:</p><ul><li><p>We found it very helpful to use <a href="https://github.com/infinitered/ignite?ref=ambrook" target="_blank" rel="noopener noreferrer">boilerplate</a> <a href="https://github.com/mcnamee/react-native-starter-kit?ref=ambrook" target="_blank" rel="noopener noreferrer">apps</a> when starting, both to understand solutions for common issues (global state management, i18n, etc) and to reduce initial setup time.</p></li><li><p>Although most engineers on this stack don’t need to know about the underlying iOS / Android systems, you’ll still need someone with a working knowledge of the native build systems and IDEs in practice to debug build and configuration issues. This is something that <a href="https://docs.expo.dev/guides/config-plugins/?ref=ambrook" target="_blank" rel="noopener noreferrer">the Expo community is working on</a>.</p></li><li><p>Not all React libraries work well across both native and web, so you’ll need to be deliberate when choosing which to use.</p></li></ul><h2>Conclusion</h2><p>Thanks to our lack of legacy code, we’ve been able to pick the best of breed tools for our situation: React Native on Mobile and React/Next.js on Web. This technology is instrumental in our ability to rapidly and efficiently iterate on our mission of helping to make farmers more profitable and sustainable.</p></div></section></div></section></article></div>
  </body>
</html>
