<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.schmizz.net/disaggregated-wal">Original</a>
    <h1>The disaggregated write-ahead log (2023)</h1>
    
    <div id="readability-page-1" class="page"><div id="post-content-parent"><div id="post-content-wrapper"><p>The traditional way replicated systems are architected is to physically co-locate the <a target="_blank" href="https://en.wikipedia.org/wiki/Write-ahead_logging">write-ahead log</a> (WAL) on the nodes where the state is being maintained. Then a consensus protocol like Paxos or Raft is used to make sure the log on each replica agrees. With many classical databases that have been around a while, instead of consensus there may be a configuration-driven primary/backup scheme.</p>
<p>This converged approach is not <em>that</em> different logically even with the physical decoupling of compute and storage as pioneered by hyperscalers. At Google, locally attached disks are rarely relied upon – you must use Colossus, the current generation of the <a target="_blank" href="https://research.google/pubs/pub51/">Google File System</a> and &#34;<a target="_blank" href="https://cloud.google.com/blog/products/storage-data-transfer/a-peek-behind-colossus-googles-file-system">the secret scaling superpower behind Google&#39;s storage infrastructure</a>&#34;. All the data systems used internally at Google and those made available as cloud services like Bigtable and Spanner store logs <em>and</em> state in Colossus.</p>
<p>Colossus is a <strong>zonal service</strong>, so these systems still need to implement replication protocols to make them resilient to a single zone or region&#39;s unavailability. This is apparent if you have dealt with <a target="_blank" href="https://cloud.google.com/bigtable/docs/replication-settings">Bigtable replication</a>, which is async between zonal clusters. Other services like <a target="_blank" href="https://cloud.google.com/spanner/docs/instance-configurations">Spanner</a> offer a higher-level perspective of a regional or multi-regional deployment.</p>
<p>AWS went in a rather different direction. This <a target="_blank" href="https://www.youtube.com/watch?v=QVvFVwyElLY&amp;t=2650s">2014 re:Invent talk</a> describes their evolution with distributed systems that had led them to embrace a <em>transactional journal</em> primitive. It is a <strong>multi-zone replicated service</strong>, and now &#34;powers some of the biggest AWS databases and retail services such as DynamoDB, Amazon S3, Amazon QLDB, Amazon SWS, Amazon SNS, and many others&#34; (<a target="_blank" href="https://www.linkedin.com/pulse/day-life-thomas-price/">source</a>).</p>
<p>As a building block, this represents incredible leverage for AWS. <a target="_blank" href="https://aws.amazon.com/memorydb/">MemoryDB</a> which debuted in 2021 stands out to me. You get a highly durable Redis usable as a primary data store, for a pretty small write latency tradeoff of single-digit milliseconds. Meanwhile, Redis Labs has a <a target="_blank" href="https://github.com/RedisLabs/redisraft">Raft module</a> which is still experimental. How did AWS do it? See for yourself:</p>
<p><a target="_blank" href="https://aws.amazon.com/memorydb/"><img loading="lazy" src="https://d1.awsstatic.com/product-page-diagram_Amazon-MemoryDB-for-Redis.38339d976bd9b151350f496469d4d54b21173523.png" alt="AWS MemoryDB WAL data flow"/></a></p>
<p>Outside of AWS, Meta engineers in their blog on <a target="_blank" href="https://engineering.fb.com/2023/05/16/data-infrastructure/mysql-raft-meta/">using Raft for MySQL replication</a> speculate a follow-up: &#34;Another idea that we are considering is to disentangle the log from the state machine (the database) into a disaggregated log setup. This will allow the team to manage the concerns of the log and replication separately from the concerns of the database storage and SQL execution engine.&#34;</p>
<p>At sub-hyper-scale too, we can find examples of systems successfully leveraging disaggregated WALs:</p>
<ul>
<li><p><a target="_blank" href="https://go.fauna.com/guide/architectural-overview">Fauna</a>, the serverless document-relational hybrid database, runs a <a target="_blank" href="https://blog.acolyer.org/2019/03/29/calvin-fast-distributed-transactions-for-partitioned-database-systems/">Calvin-inspired</a> transaction protocol on top of a partitioned replicated log, delivering strict serializability with multi-region replication.</p>
</li>
<li><p><a target="_blank" href="https://pulsar.apache.org/docs/3.1.x/concepts-architecture-overview/">Pulsar</a> and <a target="_blank" href="https://cncf.pravega.io/docs/latest/pravega-concepts/#architecture">Pravega</a> are streaming data solutions relying on <a target="_blank" href="https://bookkeeper.apache.org/">BookKeeper</a> for record storage, together with <a target="_blank" href="https://zookeeper.apache.org/">ZooKeeper</a> to coordinate since BK eschews ordering.</p>
</li>
<li><p><a target="_blank" href="https://neon.tech/docs/introduction/architecture-overview">Neon</a>, the serverless Postgres system inspired by AWS Aurora (of <a target="_blank" href="https://www.amazon.science/publications/amazon-aurora-design-considerations-for-high-throughput-cloud-native-relational-databases">&#34;the log is the database&#34;</a>), built a multi-tenant WAL service called Safekeeper and have shared insights on their <a target="_blank" href="https://neon.tech/blog/paxos">choice of Paxos</a> for it.</p>
</li>
</ul>
<p><a target="_blank" href="https://neon.tech/blog/paxos"><img loading="lazy" src="https://neon.tech/_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2022%2F08%2Fdiagram-3.jpeg&amp;w=3840&amp;q=85" alt="Neon&#39;s WAL data flow"/></a></p>
<p>Even though pretty much every distributed data system stands to benefit from replicated logs being a commodity, the only commodity in that diagram today is object storage. The scope of <a target="_blank" href="https://wesmckinney.com/blog/looking-back-15-years/#conclusions-and-looking-ahead">composable data systems</a> needs to extend to replicated logs on this journey of the &#34;Great Decoupling&#34;, lest it turn into the &#34;Great Divide&#34; between the building blocks available to hyperscalers vs outsiders.</p>
<p>S3 revolutionized how slow immutable data is stored and accessed, where is the counterpart for fast data streams? S3 has been called the <a target="_blank" href="https://www.youtube.com/watch?v=vLlSoHqTTN8&amp;t=149s">gold standard for serverless</a>, and has even been proposed as the <a target="_blank" href="https://medium.com/innovationendeavors/s3-as-the-universal-infrastructure-backend-a104a8cc6991">universal infrastructure backend</a>. I agree on the former, and on the latter I would argue that object stores are not comprehensive enough, as they do not solve for cheap small writes, low latency IO, or coordination requirements.</p>
<p>I believe that if distributed systems hackers had the equivalent of S3 for logs – truly serverless API, single-digit-milliseconds to tail and append, for a practically unlimited number of them with bottomless storage and elastic throughput – we would unlock a ton of design innovation.</p>
<p>Maybe it can even be called S2, the Stream Store. Hypothetical S2 can take care of replicating within and between regions and even across clouds, so long as you pay the speed of light tax. Hypothetical S2 does a bit more to simplify the layers above – it makes <a target="_blank" href="https://maheshba.bitbucket.io/blog/2023/05/06/Leadership.html">leadership above the log</a> convenient with leases and fenced writes.</p>
<p>Building a durable execution engine? There&#39;s your fast side effect journal.</p>
<p>Distributed transactions? Use a coordinator log for <a target="_blank" href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol">2PC</a>.</p>
<p>Need to quickly acknowledge writes while preparing index chunks persisted in S3? S2 can be your trimmable, durable buffer.</p>
<p>Unifying streaming and queuing, disklessly? Pulsar charted the path, let&#39;s take it to the next level without the JVM clusters.</p>
<p>Ingestion pipeline for a multi-tenant data store? Granular streams seem perfect, model a log per tenant-use-case.</p>
<p>Event sourcing? S2 for the log and S3 for state snapshots.</p>
<p>What would S2 enable for you? It&#39;s okay to dream!</p>
<hr/>
<p><em>Working on making S2 not be hypothetical –</em> <a target="_blank" href="https://forms.gle/WdkTFaKDyCagpfS87"><em>join the waitlist</em></a> <em>to stay in the loop.</em></p>
<p><em>Proprietary systems are described based on public info,</em> <a target="_blank" href="mailto:shikhar@bandar.io"><em>let me know</em></a> <em>if I got something wrong and I&#39;d be happy to fix it!</em></p>
</div></div></div>
  </body>
</html>
