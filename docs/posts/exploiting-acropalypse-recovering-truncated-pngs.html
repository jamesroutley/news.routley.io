<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.da.vidbuchanan.co.uk/blog/exploiting-acropalypse.html">Original</a>
    <h1>Exploiting aCropalypse: Recovering truncated PNGs</h1>
    
    <div id="readability-page-1" class="page"><section>
			
<p><em>By David Buchanan, 18<sup>th</sup> of March 2023</em></p>
<p>This article assumes you’ve already heard about the aCropalypse vulnerability, aka CVE-2023-21036. If not, go read about it <a href="https://acropalypse.info/">here</a> (oops, this page doesn&#39;t exist yet. Read this <a href="https://twitter.com/ItsSimonTime/status/1636857478263750656">tweet</a> in the meantime).</p>
<p>For me, it all started with the following conversation:</p>
<blockquote>
<p><strong>Simon</strong> — 2023-01-02 15:16</p>
<p>can you decompress a zlib stream which is missing the first say 0x10000 bytes</p>
</blockquote>
<blockquote>
<p><strong>nicolás</strong> — 2023-01-02 15:22</p>
<p>I doubt it because you could have gigabytes of data that all depend on data referenced from the first few bytes</p>
</blockquote>
<blockquote>
<p><strong>Simon</strong> — 2023-01-02 15:24</p>
<p>if it is possible i&#39;ve found a massive security flaw</p>
</blockquote>
<blockquote>
<p><strong>Retr0id</strong> — 2023-01-02 15:27</p>
<p>possible but hard</p>
</blockquote>
<blockquote>
<p><strong>Simon</strong> — 2023-01-02 15:27</p>
<p>can i dm you about this</p>
</blockquote>
<blockquote>
<p><strong>Retr0id</strong> — 2023-01-02 15:27</p>
<p>sure</p>
</blockquote>
<p>At this point in time, Simon was asking the question in an abstract sense, so as not to give away the nature of the vulnerability.</p>
<p>Nicolás’ and my initial responses were both correct, in the <em>general</em> case.</p>
<p>Zlib uses DEFLATE compression, which itself makes use of <a href="https://en.wikipedia.org/wiki/LZ77_and_LZ78">LZ77</a> and <a href="https://en.wikipedia.org/wiki/Huffman_coding">Huffman Coding</a> techniques. Nicolas’ answer is based on the fact that LZ77 works by replacing repeated data with backreferences to a previous occurrence. If you’re missing that prior data, then you’ll never be able to resolve backreferences to it.</p>
<p>My answer was based on the fact that zlib streams can use dynamic Huffman coding, where a custom Huffman tree is defined at the start of a block. This tree is used to encode symbols for the rest of that block. It&#39;s near-impossible to decompress Huffman-coded data without knowing the tree used—almost like trying to decrypt an encrypted message without knowing the key.</p>
<p>These two issues make it sound like an impossible problem to solve in the general case, and that’s true! However, we’re not dealing with the general case here—there’s a specific scenario. You already know the scenario because you read the title of this post, but I found out when Simon explained it to me privately:</p>
<blockquote>
<p><strong>SimonTime</strong> — 2023-01-02 15:28</p>
<p>so basically the pixel 7 pro, when you crop and save a screenshot, overwrites the image with the new version, but leaves the rest of the original file in its place</p>
</blockquote>
<blockquote>
<p><strong>Retr0id</strong> — 2023-01-02 15:28</p>
<p>ohhhhhhh wow</p>
</blockquote>
<blockquote>
<p><strong>SimonTime</strong> — 2023-01-02 15:28</p>
<p>so if you were to take a screenshot of an app which shows your address on screen, then crop it, if you could recover the information somehow that&#39;s a big deal</p>
</blockquote>
<blockquote>
<p><strong>Retr0id</strong> — 2023-01-02 15:29</p>
<p>yeah that does sound pretty big</p>
</blockquote>
<blockquote>
<p><strong>SimonTime</strong> — 2023-01-02 15:29</p>
<p>i&#39;ll send you some samples</p>
</blockquote>
<p>At this point in time, I had all sorts of cryptanalysis-adjacent ideas swirling around in my head. If we knew what some sub-section of the screenshot was supposed to look like (due to having the cropped version), that would act as a &#34;known plaintext&#34;. By modelling Huffman coding as a cryptographic cipher, with the unknown Huffman tree as the key, we might be able to crack it.</p>
<p>I started analysing the sample screenshots using a janky zlib-parsing Python script I had lying around (I&#39;m working on a low-level zlib manipulation tool, watch this space!). I found that the data was indeed compressed using dynamic Huffman coding, but that the Huffman tree was re-specified every ~16KB or so. This was <em>excellent</em> news because it meant I didn&#39;t have to solve the &#34;Huffman coding cryptanalysis&#34; problem, and could instead solve the much simpler-in-practice problem of &#34;find the start of a dynamic-Huffman-coded zlib block&#34;. How do we do that?</p>
<h2>The Algorithm</h2>
<p>After all that complexity, the algorithm I came up with is deceptively simple. It can be summarised with the following pseudocode:</p>

<pre>for each bit-offset:
    if it doesn&#39;t look like the start of a dynamic huffman block:
        skip this offset

    try decompressing from that offset:
        if the decompressed data looks plausible:
            return decompressed data!
    catch decompression errors:
        continue
</pre>
<p>We need to deal with bit-offsets as opposed to byte-offsets because zlib is a bit-oriented format, and a new block could start at any bit offset within a byte. Perhaps unsurprisingly, the zlib library does not have built-in support for starting from a specific bit offset. To solve this, my Python implementation precomputes a list of 8 bytestrings, each with the bits shifted by n bits. In a loop, those bytestrings are sliced up and passed into zlib as needed.</p>
<p>Another thing to consider is that zlib has a &#34;window size&#34; of up to 32KB. This means that compressed data can make backreferences to any of the previous 32K bytes - for example, &#34;look back 1312 bytes and make a copy of the subsequent 42 bytes&#34;. If the stream we&#39;re decompressing tries to make backreferences to before the &#34;start&#34; of the stream, zlib will error out (i.e. the problem Nicolás was describing earlier). To work around this, I pre-initialised zlib&#39;s state with 32KB of the ascii character &#39;X&#39;. This was an arbitrary choice, but it&#39;s convenient because it means that any of these &#34;made up&#34; byte values will show up as a uniform grey colour in the final PNG.</p>
<p>Theoretically, an image could be made up almost entirely of back-references to missing data, but <em>in practice</em> most images aren’t like this. We can get an intelligible result most of the time, even if we are missing <em>some</em> back-referenced data.</p>
<p>There&#39;s a couple of PNG-related details still left to consider, primarily how to parse the zlib stream out of the truncated PNG, and how to turn the recovered decompressed data into something viewable. This is all fairly trivial stuff, if you&#39;ve read my <a href="https://www.da.vidbuchanan.co.uk/blog/hello-png.html">&#34;Hello, PNG!&#34;</a> blog post recently.</p>
<p>After a few hours of fiddling around, I had a <a href="https://gist.github.com/DavidBuchanan314/93de9d07f7fab494bcdf17c2bd6cef02">working PoC</a>. By this time Simon was asleep (yay timezones), so I was left on my own to freak out over the implications of the code I&#39;d just written:</p>
<blockquote>
<p><strong>Retr0id</strong> — 2023-01-02 21:11</p>
<p>holy fuck this is bad</p>
</blockquote>
<p>If it were in my lexicon at the time, I might&#39;ve said &#34;holy fucking bingle&#34;.</p>
<p>Simon has ported my PoC to C and compiled it to WASM, so you can use it on the web <a href="https://acropalypse.app/">here</a> to test if your image files are vulnerable (all image processing is done client-side).</p>
<h2>Personal Impact</h2>
<p>Although I’m currently an iPhone user, I used to use a Pixel 3XL. I’m also a heavy Discord user, and in the past I’d shared plenty of cropped screenshots through the Discord app.</p>
<p>I wrote a script to scrape my own message history to look for vulnerable images. There were lots of them, although most didn’t leak any particularly private information.</p>
<p>The worst instance was when I posted a cropped screenshot of an eBay order confirmation email, showing the product I’d just bought. Through the exploit, I was able to un-crop that screenshot, revealing my full postal address (which was also present in the email). That’s pretty bad!</p>
<h2>Root Cause Analysis</h2>
<p>The bug lies in closed-source Google-proprietary code so it&#39;s a bit hard to inspect, but after some patch-diffing I concluded that the root cause was due to this horrible bit of API &#34;design&#34;: <a href="https://issuetracker.google.com/issues/180526528">https://issuetracker.google.com/issues/180526528</a>.</p>
<p>Google was passing <code>&#34;w&#34;</code> to a call to <code>parseMode()</code>, when they should&#39;ve been passing <code>&#34;wt&#34;</code> (the t stands for truncation). This is an easy mistake, since similar APIs (like POSIX <a href="https://man7.org/linux/man-pages/man3/fopen.3.html">fopen</a>) will truncate by default when you simply pass <code>&#34;w&#34;</code>. Not only that, but previous Android releases had <code>parseMode(&#34;w&#34;)</code> truncate by default too! This change wasn&#39;t even documented until some time after the aforementioned <a href="https://issuetracker.google.com/issues/180526528">bug report</a> was made.</p>
<p>The end result is that the image file is opened <em>without</em> the <code>O_TRUNC</code> flag, so that when the cropped image is written, the original image is not truncated. If the new image file is smaller, the end of the original is left behind.</p>
<p>IMHO, the takeaway here is that API footguns should be treated as security vulnerabilities.</p>

		</section></div>
  </body>
</html>
