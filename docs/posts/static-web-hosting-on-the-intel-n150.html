<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://it-notes.dragas.net/2025/11/19/static-web-hosting-intel-n150-freebsd-smartos-netbsd-openbsd-linux/">Original</a>
    <h1>Static Web Hosting on the Intel N150</h1>
    
    <div id="readability-page-1" class="page"><div><div role="main" itemprop="articleBody"><blockquote><p><strong>Update</strong>: This post has been updated to include <strong>Docker</strong> benchmarks and a comparison of container overhead versus FreeBSD Jails and illumos Zones.</p></blockquote><p>I often get very specific infrastructure requests from clients. Most of the time it is some form of hosting. My job is usually to suggest and implement the setup that fits their goals, skills and long term plans. </p><p>If there are competent technicians on the other side, and they are willing to learn or already comfortable with Unix style systems, my first choices are usually one of the BSDs or an illumos distribution. If they need a control panel, or they already have a lot of experience with a particular stack that will clearly help them, I will happily use Linux and it usually delivers solid, reliable results. </p><p>Every now and then someone asks the question I like the least: </p><blockquote><p>“But how does it <em>perform</em> compared to X or Y?” </p></blockquote><p>I have never been a big fan of benchmarks. At best they capture a very specific workload on a very specific setup. They are almost never a perfect reflection of what will happen in the real world. </p><p>For example, I discovered that idle bhyve VMs seem to use fewer resources when the host is illumos than when the host is FreeBSD. It looks strange at first sight, but the illumos people are clearly working very hard on this, and the result is a very capable and efficient platform. </p><p>Despite my skepticism, from time to time I enjoy running some comparative tests. I already did it with <a href="https://it-notes.dragas.net/2024/06/10/proxmox-vs-freebsd-which-virtualization-host-performs-better/">Proxmox KVM versus FreeBSD bhyve</a>, and I also <a href="https://it-notes.dragas.net/2025/09/19/freebsd-vs-smartos-whos-faster-for-jails-zones-bhyve/">compared Jails, Zones, bhyve and KVM</a> on the same Intel N150 box. That led to the FreeBSD vs SmartOS article where I focused on CPU and memory performance on this small mini PC. </p><p>This time I wanted to do something simpler, but also closer to what I see every day: <strong>static web hosting.</strong> </p><p>Instead of synthetic CPU or I/O tests, I wanted to measure how different operating systems behave when they serve a small static site with nginx, both over HTTP and HTTPS. </p><p>This is <strong>not</strong> meant to be a super rigorous benchmark. I used the default nginx packages, almost default configuration, and did not tune any OS specific kernel settings. In my experience, careful tuning of kernel and network parameters can easily move numbers by several tens of percentage points. The problem is that very few people actually spend time chasing such optimizations. Much more often, once a limit is reached, someone yells “we need mooooar powaaaar” while the real fix would be to tune the existing stack a bit.</p><p>So the question I want to answer here is more modest and more practical:</p><blockquote><p>With default nginx and a small static site, how much does the choice of host OS really matter on this Intel N150 mini PC?</p></blockquote><p><em>Spoiler</em>: less than people think, at least for plain HTTP. Things get more interesting once TLS enters the picture.</p><hr/><blockquote><p><strong>Disclaimer</strong></p></blockquote><hr/><h2>Test setup</h2><p>The hardware is the same Intel N150 mini PC I used in my previous tests: a small, low power box that still has enough cores to be interesting for lab and small production workloads. </p><p>On it, I installed several operating systems and environments, always on the bare metal, not nested inside each other. On each OS I installed nginx from the official packages. </p><h3>Software under test</h3><p>On the host: </p><p><strong>SmartOS</strong>, with:</p><p><strong>FreeBSD</strong> 14.3-RELEASE:</p><p><strong>OpenBSD</strong> 7.8:</p><p><strong>NetBSD</strong> 10.1:</p><p><strong>Debian</strong> 13.2:</p><p><strong>Alpine Linux</strong> 3.22:</p><p>I also tried to include <strong>DragonFlyBSD</strong>, but the NIC in this box is not supported. Using a different NIC just for one OS would have made the comparison meaningless, so I excluded it. </p><h3>nginx configuration</h3><p>In all environments: </p><ul><li>nginx was installed from the system packages </li><li><code>worker_processes</code> was set to <code>auto</code> </li><li>the web root contained the same static content </li></ul><p>The important part is that I used <strong>exactly the same <code>nginx.conf</code> file for all operating systems and all combinations in this article</strong>. I copied the same configuration file verbatim to every host, jail and zone. The only changes were the IP address and file paths where needed, for example for the TLS certificate and key. </p><p>The static content was a default build of the example site generated by <a href="https://bssg.dragas.net/"><strong>BSSG</strong>, my Bash static site generator</a>. The web root was the same logical structure on every OS and container type. </p><p>There is no OS specific tuning in the configuration and no kernel level tweaks. This is very close to a “package install plus minimal config” situation. </p><h3>TLS configuration</h3><p>For HTTPS I used a very simple configuration, identical on every host. </p><p>Self signed certificate created with: </p><pre><code>openssl req -x509 -newkey rsa:4096 -nodes -keyout server.key -out server.crt -days 365 -subj &#34;/CN=localhost&#34;  
</code></pre><p>Example nginx <code>server</code> block for HTTPS (simplified): </p><pre><code>server {  
listen 443 ssl http2;  
listen [::]:443 ssl http2;  

server_name _;  

ssl_certificate /etc/nginx/ssl/server.crt;  
ssl_certificate_key /etc/nginx/ssl/server.key;  

root /var/www/html;  
index index.html index.htm;  

location / {  
try_files $uri $uri/ =404;  
}  
}  
</code></pre><p>The HTTP virtual host is also the same everywhere, with the root pointing to the BSSG example site. </p><h3>Load generator</h3><p>The tests were run from my workstation on the same LAN: </p><ul><li>client host: a mini PC machine connected at 2.5 Gbit/s </li><li>switch: 2.5 Gbit/s </li><li>test tool: <code>wrk</code> </li></ul><p>For each target host I ran: </p><ul><li><code>wrk -t4 -c50 -d10s http://IP</code> </li><li><code>wrk -t4 -c10 -d10s http://IP</code> </li><li><code>wrk -t4 -c50 -d10s https://IP</code> </li><li><code>wrk -t4 -c10 -d10s https://IP</code> </li></ul><p>Each scenario was executed multiple times to reduce noise; the numbers below are medians (or very close to them) from the runs.</p><h2>The contenders</h2><p>To keep things readable, I will refer to each setup as follows: </p><ul><li><strong>SmartOS Debian LX</strong> → SmartOS host, Debian 12 LX zone </li><li><strong>SmartOS Alpine LX</strong> → SmartOS host, Alpine 3.22 LX zone </li><li><strong>SmartOS Native</strong> → SmartOS host, native zone </li><li><strong>FreeBSD Jail</strong> → FreeBSD 14.3-RELEASE, nginx in a jail </li><li><strong>OpenBSD Host</strong> → OpenBSD 7.8, nginx on the host </li><li><strong>NetBSD Host</strong> → NetBSD 10.1, nginx on the host </li><li><strong>Debian Host</strong> → Debian 13.2, nginx on the host </li><li><strong>Alpine Host</strong> → Alpine 3.22, nginx on the host </li><li><strong>Docker Container</strong> → Alpine host, Debian 13 Docker container</li></ul><p>Everything uses the same nginx configuration file and the same static site. </p><h2>Static HTTP results</h2><p>Let us start with plain HTTP, since this removes TLS from the picture and focuses on the kernel, network stack and nginx itself. </p><h3>HTTP, 4 threads, 50 concurrent connections</h3><p>Approximate median <code>wrk</code> results: </p><table><thead><tr><th>Environment</th><th>HTTP 50 connections</th></tr></thead><tbody><tr><td>SmartOS Debian LX</td><td>~46.2 k</td></tr><tr><td>SmartOS Alpine LX</td><td>~49.2 k</td></tr><tr><td>SmartOS Native</td><td>~63.7 k</td></tr><tr><td>FreeBSD Jail</td><td>~63.9 k</td></tr><tr><td>OpenBSD Host</td><td>~64.1 k</td></tr><tr><td>NetBSD Host</td><td>~64.0 k</td></tr><tr><td>Debian Host</td><td>~63.8 k</td></tr><tr><td>Alpine Host</td><td>~63.9 k</td></tr><tr><td>Docker Container</td><td>~63.7 k</td></tr></tbody></table><p>Two things stand out: </p><ol><li>All the native or jail/container setups on the hosts that are not LX zones cluster around 63 to 64k requests per second. </li><li>The two SmartOS LX zones sit slightly lower, in the 46 to 49k range, which is still very respectable for this hardware. </li></ol><p>In other words, as long as you are on the host or in something very close to it (FreeBSD jail, SmartOS native zone, NetBSD, OpenBSD, Linux on bare metal), static HTTP on nginx will happily max out around 64k requests per second with this small Intel N150 CPU. </p><p>The Debian and Alpine LX zones on SmartOS are a bit slower, but not dramatically so. They still deliver close to 50k requests per second and, in a real world scenario, you would probably saturate the network or the client long before hitting those numbers. </p><h3>HTTP, 4 threads, 10 concurrent connections</h3><p>With fewer concurrent connections, absolute throughput drops, but the relative picture is similar: </p><ul><li>SmartOS Native around 44k </li><li>NetBSD and Alpine Host around 34 to 35k </li><li>FreeBSD, Debian, OpenBSD around 31 to 33k </li><li>The Docker Container sits slightly lower at ~30.2k req/s, showing a small overhead from the networking layer </li><li>The SmartOS LX zones sit slightly below, around 35 to 37k req/s </li></ul><p>The important conclusion is simple: </p><blockquote><p>For plain HTTP static hosting, once nginx is installed and correctly configured, the choice between these operating systems makes very little difference on this hardware. Zones and jails add negligible overhead, LX zones add a small one. </p></blockquote><p>If you are only serving static content over HTTP, your choice of OS should be driven by other factors: ecosystem, tooling, update strategy, your own expertise and preference. </p><h2>Static HTTPS results</h2><p>TLS is where things start to diverge more clearly and where CPU utilization becomes interesting. </p><h3>HTTPS, 4 threads, 50 concurrent connections</h3><p>Approximate medians: </p><table><thead><tr><th>Environment</th><th>HTTPS 50 connections</th><th>CPU notes at 50 HTTPS connections</th></tr></thead><tbody><tr><td>SmartOS Debian LX</td><td>~51.4 k</td><td>CPU saturated</td></tr><tr><td>SmartOS Alpine LX</td><td>~40.4 k</td><td>CPU saturated</td></tr><tr><td>SmartOS Native</td><td>~52.8 k</td><td>CPU saturated</td></tr><tr><td>FreeBSD Jail</td><td>~62.9 k</td><td>around 60% CPU idle</td></tr><tr><td>OpenBSD Host</td><td>~39.7 k</td><td>CPU saturated</td></tr><tr><td>NetBSD Host</td><td>~40.4 k</td><td>CPU saturated</td></tr><tr><td>Debian Host</td><td>~62.8 k</td><td>about 20% CPU idle</td></tr><tr><td>Alpine Host</td><td>~62.4 k</td><td>small idle headroom, around 7% idle</td></tr><tr><td>Docker Container</td><td>~62.7 k</td><td>CPU saturated</td></tr></tbody></table><p>These numbers tell a more nuanced story. </p><ol><li><p><strong>FreeBSD, Debian and Alpine on bare metal form a “fast TLS” group.</strong></p></li><li><p><strong>FreeBSD does this while using significantly less CPU.</strong></p></li><li><p><strong>Debian and Alpine are close in throughput, but push the CPU harder.</strong></p></li><li><p><strong>SmartOS, NetBSD and OpenBSD form a “good but heavier” TLS group.</strong></p></li></ol><h3>HTTPS, 4 threads, 10 concurrent connections</h3><p>With lower concurrency: </p><ul><li>FreeBSD, Debian and Alpine still sit in roughly the 29 to 31k req/s range </li><li>SmartOS Native and LX zones are in the mid to high 30k range </li><li>The Docker Container drops slightly to ~27.8k req/s </li><li>NetBSD and OpenBSD sit around 26 to 27k req/s </li></ul><p>The relative pattern is the same: for this TLS workload, FreeBSD and modern Linux distributions on bare metal appear to make better use of the cryptographic capabilities of the CPU, delivering higher throughput or more headroom or both. </p><h2>What TLS seems to highlight</h2><p>The HTTPS tests point to something that is not about nginx itself, but about the TLS stack and how well it can exploit the hardware. </p><p>On this Intel N150, my feeling is: </p><ul><li>FreeBSD, with the userland and crypto stack I am running, is very efficient at TLS here. It delivers the highest throughput while keeping plenty of CPU in reserve. </li><li>Debian and Alpine, with their recent kernels and libraries, are also strong performers, close to FreeBSD in throughput, but with less idle CPU. </li><li>NetBSD, OpenBSD and SmartOS (native and LX) are still perfectly capable of serving a lot of HTTPS traffic, but they have to work harder to keep up and they hit 100% CPU much earlier. </li></ul><p>This matches what I see in day to day operations: TLS performance is often less about “nginx vs something else” and more about the combination of: </p><ul><li>the TLS library version and configuration </li><li>how well the OS uses the CPU crypto instructions </li><li>kernel level details in the network and crypto paths </li></ul><p>I suspect the differences here are mostly due to how each system combines its TLS stack (OpenSSL, LibreSSL and friends), its kernel and its hardware acceleration support. It would take a deeper dive into profiling and configuration knobs to attribute the gaps precisely. </p><p>In any case, on this specific mini PC, if I had to pick a platform to handle a large amount of HTTPS static traffic, FreeBSD, Debian and Alpine would be my first candidates, in that order. </p><h2>Zones, jails, containers and Docker: overhead in practice</h2><p>Another interesting part of the story is the overhead introduced by different isolation technologies. </p><p>From these tests and the <a href="https://it-notes.dragas.net/2025/09/19/freebsd-vs-smartos-whos-faster-for-jails-zones-bhyve/">previous virtualization article on the same N150 machine</a>, the picture is consistent: </p><ul><li><p><strong>FreeBSD jails behave almost like bare metal and are significantly more efficient than Docker.</strong></p></li><li><p><strong>SmartOS native zones are also very close to the metal.</strong></p></li><li><p><strong>SmartOS LX zones introduce a noticeable but modest overhead.</strong></p></li><li><p><strong>Docker on Linux performs efficiently but eats the margins.</strong> I ran an additional test using a Debian 13 Docker container running on the Alpine Linux host. At peak load (50 connections), the throughput was impressive and virtually identical to bare metal: ~63.7k req/s for HTTP and ~62.7k req/s for HTTPS. However, there is a clear cost. First, while the bare metal host maintained a small CPU buffer (~7% idle) during the HTTPS test, Docker <strong>saturated the CPU to 100%</strong>. Second, at lower concurrency (10 connections), the overhead became visible. The Docker container scored ~30.2k req/s for HTTP and ~27.8k req/s for HTTPS, slightly trailing the ~31-34k and ~29-31k range of the bare metal counterparts. The abstraction layers (NAT, bridging, namespaces) are extremely efficient, but they are not completely free.</p></li></ul><p>This leads to a clear conclusion on efficiency: <strong>FreeBSD Jails provide the highest throughput with the lowest CPU cost.</strong> LX zones and Docker containers can match the speed (or come close), but they burn significantly more CPU cycles to do so.</p><h2>What this means for real workloads</h2><p>It is easy to get lost in tables and percentages, so let us go back to the initial question. </p><blockquote><p>A client wants static hosting.</p></blockquote><p>For <strong>plain HTTP</strong> on this hardware, with nginx and the same configuration: </p><ul><li>Not really.</li></ul><p>For <strong>HTTPS</strong>: </p><ul><li>Yes, it starts to matter a bit more. </li><li>FreeBSD stands out for how relaxed the CPU is under high TLS load. </li><li>Debian and Alpine are very close in throughput, with more CPU used but still with some headroom. </li><li>SmartOS, NetBSD and OpenBSD can still push a lot of HTTPS traffic, but they reach 100% CPU earlier and stabilize at lower request rates. </li></ul><p>Does this mean you should always choose FreeBSD or Debian or Alpine for static HTTPS hosting? </p><p>Not necessarily. </p><p>In real deployments, the bottleneck is rarely the TLS performance of a single node serving a small static site. Network throughput, storage, logging, reverse proxies, CDNs and application layers all play a role. </p><p>However, knowing that FreeBSD and current Linux distributions can squeeze more out of a small CPU under TLS is useful when you are: </p><ul><li>sizing hardware for small VPS nodes that must serve many HTTPS requests </li><li>planning to consolidate multiple services on a low power box </li><li>deciding whether you can afford to keep some CPU aside for other tasks (cache, background jobs, monitoring, and so on) </li></ul><p>As always, the right answer depends on the complete picture: your skills, your tooling, your backups, your monitoring, the rest of your stack, and your tolerance for troubleshooting when things go sideways. </p><h2>Final thoughts</h2><p>From these small tests, my main takeaways are: </p><ol><li><p><strong>Static HTTP is basically solved on all these platforms.</strong></p></li><li><p><strong>TLS performance is where the OS and crypto stack start to matter.</strong></p></li><li><p><strong>Jails and native zones are essentially free, LX zones cost a bit more.</strong></p></li><li><p><strong>Benchmarks are only part of the story.</strong></p></li></ol><p>I will not choose an operating system for a client just because a benchmark looks nicer. These numbers are one of the many inputs I consider. What matters most is always the combination of reliability, security, maintainability and the human beings who will have to operate the</p><p>Still, it is nice to know that if you put a tiny Intel N150 in front of a static site and you pick FreeBSD or a modern Linux distribution for HTTPS, you are giving that little CPU a fair chance to shine.</p></div></div></div>
  </body>
</html>
