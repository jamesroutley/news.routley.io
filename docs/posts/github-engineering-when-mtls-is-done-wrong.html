<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.blog/2023-08-17-mtls-when-certificate-authentication-is-done-wrong/">Original</a>
    <h1>GitHub Engineering: When mTLS Is Done Wrong</h1>
    
    <div id="readability-page-1" class="page"><div>
  <div>
    


<main role="main" id="post-73738">
  
<p>Although <a href="https://en.wikipedia.org/wiki/X.509">X.509</a> certificates have been here for a while, they have become more popular for client authentication in zero-trust networks in recent years. Mutual TLS, or authentication based on X.509 certificates in general, brings advantages compared to passwords or tokens, but you get increased complexity in return.</p>
<p>In this post, I’ll deep dive into some interesting attacks on mTLS authentication. We won’t bother you with heavy crypto stuff, but instead we’ll have a look at implementation vulnerabilities and how developers can make their mTLS systems vulnerable to user impersonation, privilege escalation, and information leakages.</p>
<p>We will present some CVEs we found in popular open-source identity servers and ways to exploit them. Finally, we’ll explain how these vulnerabilities can be spotted in source code and how to fix them.</p>
<p>This blog post is based on work that I recently presented at <a href="https://www.blackhat.com/us-23/briefings/schedule/#mtls-when-certificate-authentication-is-done-wrong-33203">Black Hat USA</a> and <a href="https://media.defcon.org/DEF%20CON%2031/DEF%20CON%2031%20presentations/Michael%20Stepankin%20-%20mTLS%20when%20certificate%20authentication%20done%20wrong.pdf">DEF CON</a>.</p>
<h2 id="introduction-what-is-mutual-tls">Introduction: What is mutual TLS?<a href="#introduction-what-is-mutual-tls" aria-label="Introduction: What is mutual TLS?"></a></h2>
<p>Website certificates are a very widely recognized technology, even to people who don’t work in the tech industry, thanks to the padlock icon used by web browsers. Whenever we connect to Gmail or GitHub, our browser checks the certificate provided by the server to make sure it’s truly the service we want to talk to. Fewer people know that the same technology can be used to authenticate clients: the TLS protocol is also designed to be able to verify the client using public and private key cryptography.</p>
<p>It happens on the handshake level, even before any application data is transmitted:</p>
<p><img decoding="async" fetchpriority="high" src="https://github.blog/wp-content/uploads/2023/08/mtls-1.png?w=1024&amp;resize=1024%2C597" alt="Excerpt from RFC 5246: &#34;Figure 1. Message flow for a full handshake&#34;" width="1024" height="597" srcset="https://github.blog/wp-content/uploads/2023/08/mtls-1.png?w=1600 1600w, https://github.blog/wp-content/uploads/2023/08/mtls-1.png?w=300 300w, https://github.blog/wp-content/uploads/2023/08/mtls-1.png?w=768 768w, https://github.blog/wp-content/uploads/2023/08/mtls-1.png?w=1024&amp;resize=1024%2C597 1024w, https://github.blog/wp-content/uploads/2023/08/mtls-1.png?w=1536 1536w" sizes="(max-width: 1000px) 100vw, 1000px" loading="lazy" data-recalc-dims="1"/></p>
<p>If configured to do so, a server can ask a client to provide a security certificate in the X.509 format. This certificate is just a blob of binary data that contain information about the client, such as its name, public key, issuer, and other fields:</p>
<pre><code>$ openssl x509 -text -in client.crt
Certificate:
    Data:
        Version: 1 (0x0)
        Serial Number:
            d6:2a:25:e3:89:22:4d:1b
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: CN=localhost            //used to locate issuers certificate
        Validity
            Not Before: Jun 13 14:34:28 2023 GMT
            Not After : Jul 13 14:34:28 2023 GMT
        Subject: CN=client          //aka &#34;user name&#34;
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                RSA Public-Key: (2048 bit)
                Modulus:
                    00:9c:7c:b4:e5:e9:3d:c1:70:9c:9d:18:2f:e8:a0:
</code></pre>
<p>The server checks that this certificate is signed by one of the trusted authorities. This is a bit similar to checking the signature of a JWT token. Next, the client sends a “Certificate verify” message encrypted with the private key, so that the server can verify that the client actually has the private key.</p>
<h3 id="how-certificates-are-validated">How certificates are validated<a href="#how-certificates-are-validated" aria-label="How certificates are validated"></a></h3>
<p>“Certificate validation” commonly refers to the PKIX certificate validation process defined in <a href="https://www.rfc-editor.org/rfc/rfc5280">RFC 5280</a>.</p>
<p>In short, in order to validate the certificate, the server constructs a certification path (also known as a certificate chain) from the target certificate to a trust anchor. The trust anchor is a self-signed root certificate that is inherently trusted by the validator. The end entity certificate is often signed by an intermediate CA, which is also signed by another intermediate certificate or directly by a trust anchor.</p>
<p><img decoding="async" src="https://github.blog/wp-content/uploads/2023/08/mtls-2.png?w=1024&amp;resize=1024%2C518" alt="Diagram of certificate chain with three links: Client certificate, Intermediate CA, Root Certificate Authority" width="1024" height="518" srcset="https://github.blog/wp-content/uploads/2023/08/mtls-2.png?w=1600 1600w, https://github.blog/wp-content/uploads/2023/08/mtls-2.png?w=300 300w, https://github.blog/wp-content/uploads/2023/08/mtls-2.png?w=768 768w, https://github.blog/wp-content/uploads/2023/08/mtls-2.png?w=1024&amp;resize=1024%2C518 1024w, https://github.blog/wp-content/uploads/2023/08/mtls-2.png?w=1536 1536w" sizes="(max-width: 1000px) 100vw, 1000px" loading="lazy" data-recalc-dims="1"/></p>
<p>Then, for each certificate in the chain, the validator checks the signature, validity period, allowed algorithms and key lengths, key usage, and other properties. There are also a number of optional certificate extensions: if they are included in the certificate, they can be checked as well. This process is quite complicated, so every language or library implements it differently.</p>
<p>Note: in my research I mostly looked at how mTLS is implemented in applications written in Java, but it is likely that the ideas and attacks below apply to other languages as well.</p>
<h3 id="mtls-in-a-java-web-application-an-example">mTLS in a Java web application, an example<a href="#mtls-in-a-java-web-application-an-example" aria-label="mTLS in a Java web application, an example"></a></h3>
<p>Let’s see how to use mTLS in a Java web application. The bare minimum configuration is to enable it in the application settings and specify the location of all trusted root certificates, like this:</p>
<pre><code>$ cat application.properties

…
server.ssl.client-auth=need
server.ssl.trust-store=/etc/spring/server-truststore.p12
server.ssl.trust-store-password=changeit
</code></pre>
<p>From the client, such as curl, you need to specify which certificate is sent to the server. The rest of the application code, such as request mappings, is exactly the same as for a normal web application.</p>
<pre><code>$ curl -k -v –cert client.pem http://localhost/hello
</code></pre>
<p>This setup works for very simple mTLS configurations, when there is only a single root certificate, and all client certificates are signed by it. You can find this example in various articles on the web and it’s quite secure due to its simplicity. Let’s quickly break down its pros and cons.</p>
<h4 id="pros">Pros:<a href="#pros" aria-label="Pros:"></a></h4>
<ul>
<li>Speed: Authorization happens only during TLS handshake, all subsequent “keep-alive” HTTP requests are considered authenticated, saving CPU time.</li>
<li>Storage: Similar to JWT, the server does not store all client certificates, only the root certificate.</li>
</ul>
<h4 id="cons">Cons:<a href="#cons" aria-label="Cons:"></a></h4>
<ul>
<li>No granular control: if mTLS is enabled, all requests have to be authenticated, even to <code>/static/style.css</code>.</li>
<li>Any certificate signed by a trusted CA can be used to access this HTTP service. Even if the certificate is issued for another purpose, it still can potentially be used for TLS authentication.</li>
<li>No host verification by default: client certificates can be accepted from any IP.</li>
<li>Certificate issuance process needs to be implemented separately.</li>
<li>Certificates expire, so need to be rotated frequently.</li>
</ul>
<p>As you can see, this approach brings some advantages and disadvantages compared to traditional authentication methods, such as password or tokens.</p>
<h3 id="previous-attacks">Previous attacks<a href="#previous-attacks" aria-label="Previous attacks"></a></h3>
<p>Before we dive into the attack section, I’ll briefly mention some previous well-known attacks on certificate parsing and validation:</p>
<ul>
<li>Obviously, the security of the authentication system depends on the strength of the signature. If we can somehow forge the content of the certificate, but keep the same signature, we can completely break the authentication process. </li>
<li>Since the X.509 format is quite complex, just parsing these data structures can lead to buffer and heap overflows. </li>
<li>Lack of basic constraints checking. The end-entity certificates should not be used to sign additional certificates.</li>
</ul>
<h3 id="my-approach">My approach<a href="#my-approach" aria-label="My approach"></a></h3>
<p>In Java, most of these attacks are already mitigated in APIs provided by the JDK. Weak algorithms are intentionally not allowed. Fuzzing of certificate parsing in Java also did not look productive to me, as the vast majority of PKIX code is implemented in memory-safe Java, instead of using native libraries. I had to take a different approach, so I decided to have a deep look at how mTLS is used from the source code perspective. Since the certificate validation process is quite complex, I suspected that someone might implement it in a weird way. After several weeks, it yielded me some interesting vulnerabilities in popular open source projects.</p>
<p>So, let’s move on to the attack’s section.</p>

<p>In real-life applications, developers often need to access the certificate presented during the TLS handshake. For example, they might need it for authorization purposes, such as checking the current username. In Java, there are two common ways how to access it:</p>
<pre><code>X509Certificate[] certificates = sslSession.getPeerCertificates();  

// another way
X509Certificate[] certificates = request.getAttribute(&#34;javax.servlet.request.X509Certificate&#34;);
</code></pre>
<p>Interestingly, this API returns an array of certificates presented by the client, not a single one. Why? Perhaps because TLS specification defines that clients may send a full chain of certificates, from end-entity to the root CA.</p>
<p>So, I decided to take a look at how different applications use this API. The most common approach I’ve seen is to take only the first certificate from the array and consider it as the client certificate. This is correct, as mTLS RFC explicitly says that the sender’s certificate MUST come first in the list.</p>
<pre><code>//way 1 is good
String user = certificates[0].getSubjectX500Principal().getName();
</code></pre>
<p>At the same time, I discovered some rare cases when applications disregard this rule and iterate over the array trying to find a certificate that matches some criteria.</p>
<pre><code>//way 2 is dangerous
for (X509Certificate cert : certificates) {
   if (isClientCertificate(cert)) {
      user = cert.getSubjectX500Principal().getName();
   }
}
</code></pre>
<p>This is dangerous, as the underlying TLS library in Java only verifies the first certificate in the list. Moreover, it does not require the chain to be sent in a strict order.</p>
<h3 id="example-cve-2023-2422-improper-certificate-validation-in-keycloak">Example: CVE-2023-2422 improper certificate validation in KeyCloak<a href="#example-cve-2023-2422-improper-certificate-validation-in-keycloak" aria-label="Example: CVE-2023-2422 improper certificate validation in KeyCloak"></a></h3>
<p>One of these examples was a vulnerability I discovered in Keycloak. Keycloak is a popular authorization server that supports OAuth, SAML, and other authorization methods, as well as mutual TLS.</p>
<p>Keycloak iterates over all certificates in the array, searching for the one that matches the client_id form parameter. As soon as it finds a matching certificate, it implicitly trusts it, assuming that its signature has already been checked during the TLS handshake:</p>
<pre><code>X509Certificate[] certs = null;
ClientModel client = null;
try { 
    certs = provider.getCertificateChain(context.getHttpRequest());
    String client_id = null;
    ...
    if (formData != null) {
        client_id = formData.getFirst(OAuth2Constants.CLIENT_ID);
    }
    …
    matchedCertificate = Arrays.stream(certs)
        .map(certificate -&gt; certificate.getSubjectDN().getName())
        .filter(subjectdn -&gt; subjectDNPattern.matcher(subjectdn).matches())
        .findFirst();
</code></pre>
<p>In reality, a client can send as many certificates as they want, and the server only verifies the first one.</p>
<p>A potential attacker can exploit this behavior to authenticate under a different username. It is possible to send a list of certificates, where the first one contains one username and is properly chained to a root CA. But the last certificate in the array might be self signed and belong to a different user. The client does not even need to provide a valid private key for it.</p>
<p><img decoding="async" src="https://github.blog/wp-content/uploads/2023/08/mtls-3.png?w=1024&amp;resize=1024%2C582" alt="Diagram of a certificate list in which the first client certificate is signed by a CA, but the second is self-signed." width="1024" height="582" srcset="https://github.blog/wp-content/uploads/2023/08/mtls-3.png?w=1600 1600w, https://github.blog/wp-content/uploads/2023/08/mtls-3.png?w=300 300w, https://github.blog/wp-content/uploads/2023/08/mtls-3.png?w=768 768w, https://github.blog/wp-content/uploads/2023/08/mtls-3.png?w=1024&amp;resize=1024%2C582 1024w, https://github.blog/wp-content/uploads/2023/08/mtls-3.png?w=1536 1536w" sizes="(max-width: 1000px) 100vw, 1000px" loading="lazy" data-recalc-dims="1"/></p>
<p>Speaking about the exploitation, there are a number of endpoints in Keycloak that support mTLS authentication, but we need one that does not require any additional factors, such as tokens or secrets. “client-management/register-node” is a good example, as it mutates the user’s data. We can normally use this api with mTLS in the following way:</p>
<pre><code>$ cat client1.crt client1.key &gt; chain1.pem
$ curl --tlsv1.2 --tls-max 1.2 --cert chain1.pem -v -i -s -k &#34;https://127.0.0.1:8443/realms/master/clients-managements/register-node?client_id=client1&#34; -d &#34;client_cluster_host=http://127.0.0.1:1213/&#34;
</code></pre>
<p>To demonstrate the vulnerability, we generate a new self signed certificate using openssl and add it to the end of the array.</p>
<pre><code>$ openssl req -newkey rsa:2048 -nodes -x509 -subj /CN=client2 -out client2-fake.crt
$ cat client1.crt client1.key client2-fake.crt client1.key &gt; chain2.pem
$ curl --tlsv1.2 --tls-max 1.2 --cert chain2.pem -v -i -s -k &#34;https://127.0.0.1:8443/realms/master/clients-managements/register-node?client_id=client2&#34; -d &#34;client_cluster_host=http://127.0.0.1:1213/&#34;
</code></pre>
<p>When we send the second curl request, Keycloak performs this action on behalf of the user specified in <code>client2-fake.crt</code>, instead of <code>client1.crt</code>. Therefore, we can mutate data on the server for any client that supports mTLS.</p>
<p>How to fix that? Easy: just use the first certificate from the array. That’s exactly how Keycloak patched this vulnerability. This CVE is a good example of how developers provide methods and interfaces that can be misunderstood or used incorrectly.</p>

<p>Another common scenario for mTLS deployments is when the TLS connection is terminated on a reverse proxy. In this case, the reverse proxy often checks the certificate and forwards it to a backend server as an additional header. Here is a typical nginx configuration to enable mTLS:</p>
<pre><code>$ cat nginx.conf

http {
    server {
        server_name example.com;
        listen 443 ssl;
        …
        ssl_client_certificate /etc/nginx/ca.pem;
        ssl_verify_client on;

        location / {
            proxy_pass http://host.internal:80;
            proxy_set_header ssl-client-cert $ssl_client_cert;
        }
    }
</code></pre>
<p>I’ve seen a number of systems like that, and in most cases the backend servers behind nginx do not perform additional validation, just trusting the reverse proxy. This behavior is not directly exploitable, but it’s not ideal either. Why? Well, first of all, it means that any server in the local network can make a request with this header, so this network segment needs to be carefully isolated from any traffic coming from outside. Additionally, if the backend or reverse proxy is affected by request smuggling or header injection, its exploitation becomes trivial. Over the past few years, we’ve seen a lot of request and header smuggling vulnerabilities, including the latest CVEs in <a href="https://github.com/netty/netty/security/advisories/GHSA-wm47-8v5p-wjpj">Netty</a> and <a href="https://github.com/advisories/GHSA-cggh-pq45-6h9x">Nodejs</a>. Be careful when implementing these scenarios and check the certificate’s signature on all servers if possible.</p>
<h2 id="chapter-2-follow-the-chain-where-does-it-lead-you">Chapter 2: “Follow the chain, where does it lead you?”<a href="#chapter-2-follow-the-chain-where-does-it-lead-you" aria-label="Chapter 2: “Follow the chain, where does it lead you?”"></a></h2>
<p><img decoding="async" loading="lazy" src="https://github.blog/wp-content/uploads/2023/08/mtls-4.png?w=1024&amp;resize=1024%2C744" alt="Excerpt from RFC 4158: &#34;Figure 1 - Sample Hierarchical PKI&#34;" width="1024" height="744" srcset="https://github.blog/wp-content/uploads/2023/08/mtls-4.png?w=1434 1434w, https://github.blog/wp-content/uploads/2023/08/mtls-4.png?w=300 300w, https://github.blog/wp-content/uploads/2023/08/mtls-4.png?w=768 768w, https://github.blog/wp-content/uploads/2023/08/mtls-4.png?w=1024&amp;resize=1024%2C744 1024w" sizes="(max-width: 1000px) 100vw, 1000px" data-recalc-dims="1"/></p>
<p>In large systems, servers may not store all root and intermediate certificates locally, but use external storage instead. <a href="https://datatracker.ietf.org/doc/html/rfc4387">RFC 4387</a> explains the concept of a certificate store: an interface you can use to lazily access certificates during chain validation. These stores are implemented over different protocols, such as HTTP, LDAP, FTP, or SQL queries.</p>
<p><a href="https://www.rfc-editor.org/rfc/rfc3280.html#section-5.2">RFC 3280 defines</a> some X.509 certificate extensions that can contain information about where to find the issuer and CA certificates. For instance, the Authority Information Access (AIA) extension contains a URL pointing to the Issuer’s certificate. If this extension is used for validation, there is a high chance that you can exploit it to perform an SSRF attack. Also, Subject, Issuer, Serial, and their alternative names can be used to construct SQL or LDAP queries, creating opportunities for injection attacks.</p>
<p><img decoding="async" loading="lazy" src="https://github.blog/wp-content/uploads/2023/08/mtls-5.png?w=1024&amp;resize=1024%2C729" alt="Client certificate with an AIA extension, containing a link to http://example.com" width="1024" height="729" srcset="https://github.blog/wp-content/uploads/2023/08/mtls-5.png?w=1290 1290w, https://github.blog/wp-content/uploads/2023/08/mtls-5.png?w=300 300w, https://github.blog/wp-content/uploads/2023/08/mtls-5.png?w=768 768w, https://github.blog/wp-content/uploads/2023/08/mtls-5.png?w=1024&amp;resize=1024%2C729 1024w" sizes="(max-width: 1000px) 100vw, 1000px" data-recalc-dims="1"/></p>
<p>When certificate stores are in use, you should think of these values as “untrusted user input” or “Insertion points,” similar to those we have in Burp Suite’s Intruder. And what attackers will really love is that all of these values can be used in queries <em>before</em> the signature is checked.</p>
<h3 id="example-cve-2023-33201-ldap-injection-in-bouncy-castle">Example: CVE-2023-33201 LDAP injection in Bouncy Castle<a href="#example-cve-2023-33201-ldap-injection-in-bouncy-castle" aria-label="Example: CVE-2023-33201 LDAP injection in Bouncy Castle"></a></h3>
<p>To demonstrate an example of this vulnerability, we’ll use <a href="https://github.com/bcgit/bc-java/blob/main/prov/src/main/java/org/bouncycastle/jce/provider/X509LDAPCertStoreSpi.java">LDAPCertStore</a> from the Bouncy Castle library. Bouncy Castle is one of the most popular libraries for certificate validation in Java. Here is an example of how you can use this store to build and validate a certificate chain.</p>
<pre><code>PKIXBuilderParameters pkixParams = new PKIXBuilderParameters(keystore, selector);

//setup additional LDAP store
X509LDAPCertStoreParameters CertStoreParameters = new X509LDAPCertStoreParameters.Builder(&#34;ldap://127.0.0.1:1389&#34;, &#34;CN=certificates&#34;).build();
CertStore certStore = CertStore.getInstance(&#34;LDAP&#34;, CertStoreParameters, &#34;BC&#34;);
pkixParams.addCertStore(certStore);

// Build and verify the certification chain
try {
   CertPathBuilder builder = CertPathBuilder.getInstance(&#34;PKIX&#34;, &#34;BC&#34;);
   PKIXCertPathBuilderResult result =
           (PKIXCertPathBuilderResult) builder.build(pkixParams);
</code></pre>
<p>Under the hood, Bouncy Castle uses the Subject field from the certificate to build an LDAP query. The Subject field is inserted in the filter, without—you guessed it—any escaping.</p>
<p><img decoding="async" loading="lazy" src="https://github.blog/wp-content/uploads/2023/08/mtls-6.png?w=1024&amp;resize=1024%2C470" alt="Client certificate containing the text &#34;Subject: CN=Client*)(userPassword=123&#34;" width="1024" height="470" srcset="https://github.blog/wp-content/uploads/2023/08/mtls-6.png?w=1600 1600w, https://github.blog/wp-content/uploads/2023/08/mtls-6.png?w=300 300w, https://github.blog/wp-content/uploads/2023/08/mtls-6.png?w=768 768w, https://github.blog/wp-content/uploads/2023/08/mtls-6.png?w=1024&amp;resize=1024%2C470 1024w, https://github.blog/wp-content/uploads/2023/08/mtls-6.png?w=1536 1536w" sizes="(max-width: 1000px) 100vw, 1000px" data-recalc-dims="1"/></p>
<p>So, if the Subject contains any special characters, it can change the syntax of the query. In most cases, this can be exploited as a blind ldap query injection. Therefore, it might be possible to use this vulnerability to extract other fields from the LDAP directory. The exploitability depends on many factors, including whether the application exposes any errors or not, and it also depends on the structure of the LDAP directory.</p>
<p>In general, whenever you incorporate user-supplied data into an LDAP query, special characters should be properly filtered. That’s exactly how this CVE has been patched in the Bouncy Castle code.</p>
<h2 id="chapter-3-certificate-revocation-and-its-unintended-uses">Chapter 3: Certificate revocation and its unintended uses<a href="#chapter-3-certificate-revocation-and-its-unintended-uses" aria-label="Chapter 3: Certificate revocation and its unintended uses"></a></h2>
<p>Similar to Json web tokens, the beauty of certificate chains is that they can be trusted just based on their signature. But what happens if we need to revoke a certificate, so it can no longer be used?</p>
<p>The PKIX specification (<a href="https://www.rfc-editor.org/rfc/rfc4387.html">RFC 4387</a>) addresses this problem by proposing a special store for revoked certificates, accessible via HTTP or LDAP protocols. Many developers believe that revocation checking is absolutely necessary, whereas others urge to avoid it for performance reasons or only use offline revocation lists.</p>
<p>Generally speaking, the store location can be hardcoded into the application or taken from the certificate itself. There are two certificate extensions used for that: Authority Information Access OSCP URL and CRL Distribution points.</p>
<p><img decoding="async" loading="lazy" src="https://github.blog/wp-content/uploads/2023/08/mtls-7.png?w=816&amp;resize=816%2C500" alt="Client certificate containing URLs in its AIA OSCL and CRL Distribution points." width="816" height="500" srcset="https://github.blog/wp-content/uploads/2023/08/mtls-7.png?w=816&amp;resize=816%2C500 816w, https://github.blog/wp-content/uploads/2023/08/mtls-7.png?w=300 300w, https://github.blog/wp-content/uploads/2023/08/mtls-7.png?w=768 768w" sizes="(max-width: 816px) 100vw, 816px" data-recalc-dims="1"/></p>
<p>Looking at it from the hackers point of view, I think it’s <em>incredible</em> that the location of the revocation server can be taken from the certificate. So, if the application takes URLs relying on AIA or CRLDP extension to make a revocation check, it can be abused for SSRF attacks.</p>
<p>Sadly for attackers, this normally happens after the signature checks, but in some cases it’s still exploitable.</p>
<p>Moreover, LDAP is also supported, at least in Java. You probably heard that, in Java, unmarshaling an LDAP lookup response can lead to a remote code execution. A few years back, <a href="https://github.com/mbechler">Moritz Bechler</a> reported this problem  and remote code execution via revocation has since been patched in the JDK. You can check out <a href="https://mbechler.github.io/2018/01/20/Java-CVE-2018-2633/">his blog post</a> for more details.</p>
<p>In my research, I decided to check if the Bouncy Castle library is also affected. It turns out that Bouncy Castle can be configured to use the CRLDP extension and make calls to an LDAP server. At the same time, Bouncy Castle only fetches a specific attribute from the LDAP response and does not support references. So, remote code execution is not possible there. HTTP SSRF is still viable though.</p>
<pre><code>private static Collection getCrlsFromLDAP(CertificateFactory certFact, URI distributionPoint) throws IOException, CRLException
{
    Map&lt;String, String&gt; env = new Hashtable&lt;String, String&gt;();

    env.put(Context.INITIAL_CONTEXT_FACTORY, &#34;com.sun.jndi.ldap.LdapCtxFactory&#34;);
    env.put(Context.PROVIDER_URL, distributionPoint.toString());

    byte[] val = null;
    try
    {
        DirContext ctx = new InitialDirContext((Hashtable)env);
        Attributes avals = ctx.getAttributes(&#34;&#34;);
        Attribute aval = avals.get(&#34;certificateRevocationList;binary&#34;);
        val = (byte[])aval.get();
    }
</code></pre>
<h3 id="example-cve-2023-28857-credentials-leak-in-apereo-cas">Example: CVE-2023-28857 credentials leak in Apereo CAS<a href="#example-cve-2023-28857-credentials-leak-in-apereo-cas" aria-label="Example: CVE-2023-28857 credentials leak in Apereo CAS"></a></h3>
<p>I also had a quick look at open source projects that support mTLS and perform revocation checking. One of these projects was Apereo CAS. It’s another popular authentication server that is highly configurable. Administrators of Apereo CAS can enable the revocation check using an external LDAP server by specifying its address and password in the settings:</p>
<pre><code>cas.authn.x509.crl-fetcher=ldap
cas.authn.x509.ldap.ldap-url=ldap://example.com:1389/
cas.authn.x509.ldap.bind-dn=admin
cas.authn.x509.ldap.bind-credential=s3cr3taaaaa
</code></pre>
<p>If these settings are applied, Apereo CAS performs the revocation check for the certificate, fetching the address from the certificate’s CRLDP extension.</p>
<pre><code>/**
* Validate the X509Certificate received.
*
* @param cert the cert
* @throws GeneralSecurityException the general security exception
*/
private void validate(final X509Certificate cert) throws GeneralSecurityException {
   cert.checkValidity();
   this.revocationChecker.check(cert);

   val pathLength = cert.getBasicConstraints();
   if (pathLength &lt; 0) {
       if (!isCertificateAllowed(cert)) {
           val msg = &#34;Certificate subject does not match pattern &#34; + this.regExSubjectDnPattern.pattern();
           LOGGER.error(msg);
</code></pre>
<p>I was afraid that this could lead to remote code execution, but it turns out that Apereo CAS uses a custom library for LDAP connection, which does not support external codebases or object factories needed for RCE.</p>
<p>When I tested this in Apereo CAS, I noticed one interesting behavior. The server prefers the LDAP URL located <strong>inside the certificate</strong>, instead of the one that is configured in settings. At the same time, Apereo CAS still sends the password from the settings. I quickly set up a testing environment and sent a self-signed certificate in the header. My self-signed certificate had a CRLDP extension with the LDAP URL pointing to a netcat listener. After sending this request to Apereo CAS, I received a request to my netcat listener with the username and password leaked.</p>
<p><img decoding="async" loading="lazy" src="https://github.blog/wp-content/uploads/2023/08/mtls-8.png?w=1024&amp;resize=1024%2C673" alt="Pair of screenshots: the first contains a POST request to Apereo CAS and the second is a terminal running netcat." width="1024" height="673" srcset="https://github.blog/wp-content/uploads/2023/08/mtls-8.png?w=1150 1150w, https://github.blog/wp-content/uploads/2023/08/mtls-8.png?w=300 300w, https://github.blog/wp-content/uploads/2023/08/mtls-8.png?w=768 768w, https://github.blog/wp-content/uploads/2023/08/mtls-8.png?w=1024&amp;resize=1024%2C673 1024w" sizes="(max-width: 1000px) 100vw, 1000px" data-recalc-dims="1"/></p>
<p>After reporting this vulnerability, the application developers issued a fix within just one day. They patched it by clearing the login and password used for LDAP connection if the URL is taken from the CRLDP. Therefore, the password leak is no longer possible. Nevertheless, I would say that using URLs from the CRLDP extension is still dangerous, as it broadens the attack surface.</p>
<h2 id="summary">Summary<a href="#summary" aria-label="Summary"></a></h2>
<p>If you’re developing an mTLS system or performing a security assessment, I suggest:</p>
<ol>
<li>Pay attention when extracting usernames from the mTLS chain, as the servers only verify the first certificate in the chain.</li>
<li>Use Certificate Stores with caution, as it can lead to LDAP and SQL injections.</li>
<li>Certificate revocation can lead to SSRF or even to RCE in the worst case. So, do the revocation check only after all other checks and do not rely on URLs taken from the certificate extensions.</li>
</ol>

      
  </main>


  </div>
</div></div>
  </body>
</html>
