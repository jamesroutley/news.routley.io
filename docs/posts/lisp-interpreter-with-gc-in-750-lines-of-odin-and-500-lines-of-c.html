<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/krig/LISP">Original</a>
    <h1>Lisp interpreter with GC in &lt;750 lines of Odin (and &lt;500 lines of C)</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">A tribute to:</p>
<blockquote>
<p dir="auto">Recursive Functions of Symbolic Expressions
and Their Computation by Machine, Part I</p>
</blockquote>
<p dir="auto">(as found in <code>paper/recursive.pdf</code>)</p>
<p dir="auto">A micro-subset of scheme / the original LISP in a single C file: <code>komplott.c</code></p>

<p dir="auto">The LISP interpreter translated to <a href="https://odin-lang.org" rel="nofollow">Odin</a> in
<code>komplodin.odin</code>. More lines of code, but I am less familiar with the
language and am translating directly from C, so there are probably ways
to make it a cleaner solution.</p>
<p dir="auto">When I posted this to lobste.rs, gingerBill (creator of Odin) was kind
enough to make a more direct translation of the C code into Odin, which
can be viewed in this
<a href="https://gist.github.com/gingerBill/622bf4dd5208e12076213a41053259cb">gist: komplott.odin</a>.</p>
<p dir="auto">Since the lobste.rs posting, I have tweaked the Odin version a bit more,
and so it differs from the C version quite a bit in the implementation
details. I&#39;ve tried to keep the output and functionality of the two
programs the same though.</p>

<ul dir="auto">
<li>
<p dir="auto">Single file implementation.</p>
</li>
<li>
<p dir="auto">Less than 500 lines of code (~600 lines for the Odin version)</p>
</li>
<li>
<p dir="auto">Scheme-compliant enough for the test programs to be executable by
GNU Guile (not sure if this is true anymore)</p>
</li>
<li>
<p dir="auto">Copying semi-space garbage collector based on Cheney&#39;s Algorithm.</p>
<p dir="auto">For more details on how it works, Andy Wingo has a great post
about this kind of garbage collector on
<a href="https://www.wingolog.org/archives/2022/12/10/a-simple-semi-space-collector" rel="nofollow">his blog (wingolog)</a>.</p>
</li>
<li>
<p dir="auto">Limited tail call optimization (not true TCO; see <code>tests/true-tco.scm</code>).</p>
</li>
<li>
<p dir="auto">Near-zero error handling.</p>
</li>
<li>
<p dir="auto">Zero thread safety or security.</p>
</li>
</ul>
<p dir="auto"><em>Also includes:</em></p>

<p dir="auto">An implementation of the core of LISP 1.5 from 1962</p>

<ul dir="auto">
<li>
<p dir="auto">To build the <code>komplott</code> executable, run <code>make komplott</code>. The only dependency
aside from <code>make</code> is <code>gcc</code>.</p>
</li>
<li>
<p dir="auto">To build the Odin version (<code>komplodin</code>), run <code>make komplodin</code>. This depends on
the Odin compiler.</p>
</li>
<li>
<p dir="auto">To run the LISP 1.5 interpreter and a couple of test cases, run <code>make test</code>.</p>
</li>
</ul>

<p dir="auto">The version presented in the README is slightly tweaked from the one
that can be found in <code>tests/lisp15.scm</code> in order to more closely
resemble early LISP rather than scheme: <code>#t</code> and <code>#f</code> are written as
<code>t</code> and <code>nil</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="
(define pairlis (lambda (x y a)
                  (cond ((null? x) a)
                        (t (cons (cons (car x) (car y))
                                 (pairlis (cdr x) (cdr y) a))))))

(define assoc (lambda (x a)
                (cond ((equal? (caar a) x) (car a))
                      (t (assoc x (cdr a))))))

(define atom? (lambda (x)
                (cond
                 ((null? x) t)
                 ((atom? x) t)
                 (t nil))))

(define evcon (lambda (c a)
                (cond
                 ((eval (caar c) a) (eval (cadar c) a))
                 (t (evcon (cdr c) a)))))

(define evlis (lambda (m a)
                (cond
                 ((null? m) nil)
                 (t (cons (eval (car m) a)
                             (evlis (cdr m) a))))))

(define apply (lambda (fun x a)
                (cond
                 ((atom? fun)
                  (cond
                   ((equal? fun (quote CAR)) (caar x))
                   ((equal? fun (quote CDR)) (cdar x))
                   ((equal? fun (quote CONS)) (cons (car x) (cadr x)))
                   ((equal? fun (quote ATOM)) (atom? (car x)))
                   ((equal? fun (quote EQ)) (equal? (car x) (cadr x)))
                   (t (apply (eval fun a) x a))))

                 ((equal? (car fun) (quote LAMBDA))
                  (eval (caddr fun) (pairlis (cadr fun) x a)))

                 ((equal? (car fun) (quote LABEL))
                  (apply
                   (caddr fun)
                   x
                   (cons
                    (cons (cadr fun) (caddr fun))
                    a))))))

(define eval (lambda (e a)
               (cond
                ((atom? e) (cdr (assoc e a)))
                ((atom? (car e))
                 (cond
                  ((equal? (car e) (quote QUOTE)) (cadr e))
                  ((equal? (car e) (quote COND)) (evcon (cdr e) a))
                  (t (apply (car e) (evlis (cdr e) a) a))))
                (t (apply (car e) (evlis (cdr e) a) a)))))

(define evalquote (lambda (fn x) (apply fn x (quote ()))))
"><pre>(define <span>pairlis</span> (<span>lambda</span> (x y a)
                  (<span>cond</span> ((null? x) a)
                        (<span>t</span> (<span>cons</span> (<span>cons</span> (<span>car</span> x) (<span>car</span> y))
                                 (<span>pairlis</span> (<span>cdr</span> x) (<span>cdr</span> y) a))))))

(define <span>assoc</span> (<span>lambda</span> (x a)
                (<span>cond</span> ((equal? (<span>caar</span> a) x) (<span>car</span> a))
                      (<span>t</span> (<span>assoc</span> x (<span>cdr</span> a))))))

(define atom? (<span>lambda</span> (x)
                (<span>cond</span>
                 ((null? x) <span>t</span>)
                 ((atom? x) <span>t</span>)
                 (<span>t</span> <span>nil</span>))))

(define evcon (<span>lambda</span> (c a)
                (<span>cond</span>
                 ((<span>eval</span> (<span>caar</span> c) a) (<span>eval</span> (<span>cadar</span> c) a))
                 (<span>t</span> (evcon (<span>cdr</span> c) a)))))

(define evlis (<span>lambda</span> (m a)
                (<span>cond</span>
                 ((null? m) <span>nil</span>)
                 (<span>t</span> (<span>cons</span> (<span>eval</span> (<span>car</span> m) a)
                             (evlis (<span>cdr</span> m) a))))))

(define <span>apply</span> (<span>lambda</span> (fun x a)
                (<span>cond</span>
                 ((atom? fun)
                  (<span>cond</span>
                   ((equal? fun (<span>quote</span> <span>CAR</span>)) (<span>caar</span> x))
                   ((equal? fun (<span>quote</span> <span>CDR</span>)) (<span>cdar</span> x))
                   ((equal? fun (<span>quote</span> <span>CONS</span>)) (<span>cons</span> (<span>car</span> x) (<span>cadr</span> x)))
                   ((equal? fun (<span>quote</span> <span>ATOM</span>)) (atom? (<span>car</span> x)))
                   ((equal? fun (<span>quote</span> <span>EQ</span>)) (equal? (<span>car</span> x) (<span>cadr</span> x)))
                   (<span>t</span> (<span>apply</span> (<span>eval</span> fun a) x a))))

                 ((equal? (<span>car</span> fun) (<span>quote</span> <span>LAMBDA</span>))
                  (<span>eval</span> (<span>caddr</span> fun) (<span>pairlis</span> (<span>cadr</span> fun) x a)))

                 ((equal? (<span>car</span> fun) (<span>quote</span> LABEL))
                  (<span>apply</span>
                   (<span>caddr</span> fun)
                   x
                   (<span>cons</span>
                    (<span>cons</span> (<span>cadr</span> fun) (<span>caddr</span> fun))
                    a))))))

(define <span>eval</span> (<span>lambda</span> (e a)
               (<span>cond</span>
                ((atom? e) (<span>cdr</span> (<span>assoc</span> e a)))
                ((atom? (<span>car</span> e))
                 (<span>cond</span>
                  ((equal? (<span>car</span> e) (<span>quote</span> QUOTE)) (<span>cadr</span> e))
                  ((equal? (<span>car</span> e) (<span>quote</span> <span>COND</span>)) (evcon (<span>cdr</span> e) a))
                  (<span>t</span> (<span>apply</span> (<span>car</span> e) (evlis (<span>cdr</span> e) a) a))))
                (<span>t</span> (<span>apply</span> (<span>car</span> e) (evlis (<span>cdr</span> e) a) a)))))

(define evalquote (<span>lambda</span> (fn x) (<span>apply</span> fn x (<span>quote</span> ()))))
</pre></div>
<p dir="auto">Here is an example of actual LISP 1.5 code:</p>
<div dir="auto" data-snippet-clipboard-copy-content="((LABEL MAPCAR
        (LAMBDA (FN SEQ)
                (COND
                  ((EQ NIL SEQ) NIL)
                  (T (CONS (FN (CAR SEQ))
                           (MAPCAR FN (CDR SEQ)))))))
 DUP LST)

; where
; DUP -&gt; (LAMBDA (X) (CONS X X))
; LST -&gt; (A B C)"><pre>((LABEL <span>MAPCAR</span>
        (<span>LAMBDA</span> (FN SEQ)
                (<span>COND</span>
                  ((<span>EQ</span> <span>NIL</span> SEQ) <span>NIL</span>)
                  (<span>T</span> (<span>CONS</span> (FN (<span>CAR</span> SEQ))
                           (<span>MAPCAR</span> FN (<span>CDR</span> SEQ)))))))
 DUP LST)

<span><span>;</span> where</span>
<span><span>;</span> DUP -&gt; (LAMBDA (X) (CONS X X))</span>
<span><span>;</span> LST -&gt; (A B C)</span></pre></div>
<blockquote>
<p dir="auto">To prevent reading from continuing indefinitely, each packet should end
with STOP followed by a large number of right parentheses. An unpaired right parenthesis
will cause a read error and terminate reading.</p>
</blockquote>
<p dir="auto"><code>STOP )))))))))))))))))</code></p>
</article></div></div>
  </body>
</html>
