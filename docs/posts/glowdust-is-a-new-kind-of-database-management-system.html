<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://codeberg.org/glowdust/glowdust">Original</a>
    <h1>Glowdust is a new kind of database management system</h1>
    
    <div id="readability-page-1" class="page"><div>
	
	<div>
		
		<div>
			
				<h3 id="user-content-_if-you-want-to-see-the-language-asap-go-to-the-quick-introduction-quick_intro-_" dir="auto"><em>If you want to see the language ASAP, go to <a href="#user-content-quick_intro" rel="nofollow">the quick introduction</a></em></h3>

<p dir="auto">Glowdust is a new kind of Database Management System. It uses <em><em>functions</em></em> as a model for storing data and comes with
a query language build from the ground up to use familiar programming concepts. The aim is to create a DBMS design
that blurs the boundary between algorithm and data, to reduce the burden of building and deploying applications.</p>
<p dir="auto">However, Glowdust doesn&#39;t aspire to be a replacement for all other DBMSs. Instead, it is meant to be a platform for
exploring new ideas, experimenting with language and system design and figuring out what the next wave of
database systems can and should look like - how to do data management for a decentralized, distributed web, after the
era of huge cloud providers comes to an end. Glowdust&#39;s success comes from inspiring degrowth in software.</p>
<p dir="auto">For this reason, Glowdust also tries to innovate with its architecture. It is made of three distinct layers -
a language frontend, a bytecode Virtual Machine and an I/O layer. Together they make up a full DBMS,
but each can also be used standalone to reap its benefits in a different application.
For example, someone can implement the Glowdust language on top of a different
DBMS by using the language compiler and transpiling to a different query language. Or they can implement their own
query language by compiling to the Glowdust VM.</p>
<p dir="auto">This is very aspirational, and the implementation currently is more tightly coupled than desired. As the project
progresses, the boundaries will become clearer and functionality will be implemented that will eventually lead to
these pieces being separate offerings.</p>
<p dir="auto">Users of Glowdust are expected to be individual programmers or small teams that need a simple way to store and retrieve data,
with an interface that looks very much like a programming language. By having functions as the main data structure,
queries can be written easily, with clear, understandable semantics.</p>
<p dir="auto">The intention for Glowdust is to create a DBMS server that can do few things but do them extremely well.
It is meant to be fully ACID, with snapshot isolation, and be ridiculously fast by being designed from the
ground up for modern hardware like NVMe drives, computational storage and CXL.
It is also intended to be extremely reliable and very easy to operate.</p>
<p dir="auto">It is currently under heavy development and none of its intended goals are achieved.
Focus at the moment is on the query language syntax and semantics and no optimizations have been made anywhere.
There is a rudimentary storage layer but it&#39;s not reliable or performant and is just a proof of concept to
ensure semantics are possible to maintain across the stack.</p>
<p dir="auto">The main way to interact and experiment with the system is via its included command line interface.
It is a simple REPL that operates against an in memory store that lives as long as the process.
It is obviously not meant as a production <em>anything</em>, but just as a means to experiment and get familiar with the language.</p>
<p dir="auto">Glowdust is written in Rust, is open source and licensed under the GPLv3. It was created in September of 2023 by Chris Gioran.</p>

<p dir="auto"><em>This section is meant to give a quick example of what Glowdust looks like. If you haven&#39;t read the rest of the guide
then maybe not everything makes sense, but you should understand what the result should look like.</em></p>
<p dir="auto">Let&#39;s assume we have a set of temperature measurements, taken each hour. This can be represented as a function
from hour of the day to degrees, like so</p>
<pre><code>define temperature() = {}
temperature(12) = 11
temperature(13) = 11
temperature(14) = 10
temperature(15) = 10
temperature(16) = 10
temperature(17) = 10
temperature(18) = 9
temperature(19) = 8
</code></pre><p dir="auto">Similarly, let&#39;s add a mapping from time of day to millimeters of rain</p>
<pre><code>define precipitation() = {}
precipitation(12) = 12
precipitation(13) = 4
precipitation(14) = 10
precipitation(15) = 1
precipitation(16) = 0
precipitation(17) = 2
precipitation(18) = 1
precipitation(19) = 0
</code></pre><p dir="auto"><em>N.B. Units would be represented as types, but these are not currently supported.</em></p>
<p dir="auto">Here is a query that prints the temperature in the hours where it rained</p>
<pre><code>match precipitation(hour) -&gt; (rain),
{
    rain &gt; 0
},
temperature(hour) -&gt; (temp),
{
    return temp
}
</code></pre><p dir="auto">The query is made up of 4 parts.</p>
<ul dir="auto">
<li>The first, <code>precipitation(hour) -&gt; (rain)</code> is a value generator. It will iterate
over all key/value pairings of the <code>precipitation</code> function and bind them to the <code>hour</code> and <code>rain</code> variables.</li>
</ul>
<p dir="auto">For each such mapping, the rest of the query is executed.</p>
<ul dir="auto">
<li>Next we have</li>
</ul>
<pre><code>{
   rain &gt; 0
}
</code></pre><p dir="auto">a block which executes a predicate expression. If this predicate is <code>true</code> for the current value of <code>rain</code>, then the
rest of the query is executed, otherwise the next generator value is processed.</p>
<ul dir="auto">
<li>
<p dir="auto">What follows is <code>temperature(hour) -&gt; (temp)</code>. This may look like a value generator as <code>precipitation(hour)</code> was, but
in fact it is a function call - the reason is that the <code>hour</code> variable
has already been bound to a value from the <code>precipitation</code> generator.
Glowdust will call the <code>temperature</code> function with the current value for <code>hour</code> and if a result is returned it will be mapped to
<code>temp</code>, otherwise execution is short circuited and the next generator value is retrieved.</p>
</li>
<li>
<p dir="auto">Finally, we have another block</p>
</li>
</ul>
<pre><code>{
    return temp
}
</code></pre><p dir="auto">that prints the value of the <code>temp</code> value.</p>
<p dir="auto">The result is a print out of</p>
<pre><code>&lt;&lt;
[11]
[10]
[10]
[9]
[11]
[10]
</code></pre><p dir="auto">or some permutation, since ordering is not yet supported.</p>
<p dir="auto">This shows the basic execution workflow for a Glowdust query.</p>
<ul dir="auto">
<li>Data is stored as functions (aka value mappings) and value generators can be created from them</li>
<li>Values are bound to variables</li>
<li>These variables travel down a processing chain that can exercise predicates or transform the values for subsequent steps</li>
</ul>
<p dir="auto">This is the core idea behind Glowdust. The rest of this guide is about the ways functions can be defined, overloaded,
how predicates can be created and the semantics of various operations.</p>

<p dir="auto">Currently there are no provided builds for Glowdust, so you have to build it yourself from source. It is written in
<a href="https://www.rust-lang.org/" rel="nofollow">Rust</a>, so you will need <a href="https://www.rust-lang.org/tools/install" rel="nofollow">a functioning Rust toolchain</a>.</p>
<p dir="auto"><strong>NOTE</strong>: Glowdust uses unstable Rust features, so you will need Rust <code>nightly</code> to compile it.</p>
<p dir="auto">After you&#39;ve installed Rust, go ahead and enable nightly with</p>
<pre><code>rustup toolchain install nightly
</code></pre><p dir="auto">and then, before the compilation step below, just set the project to always use <code>nightly</code></p>
<pre><code><span>cd</span> glowdust
rustup override <span>set</span> nightly
</code></pre><p dir="auto">You can find more information in <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html#rustup-and-the-role-of-rust-nightly" rel="nofollow">the Rust book</a></p>
<p dir="auto">One you have Rust set up, clone the Glowdust repository with</p>
<pre><code>git clone https://codeberg.org/glowdust/glowdust
</code></pre><p dir="auto">and compile and run the command line application</p>
<pre><code>cd glowdust
cargo run glowdust
</code></pre><p dir="auto">(remember to set it up so it uses Rust nightly)</p>
<p dir="auto">you will be greeted with a <code>&gt;&gt;</code> prompt where you can enter input. Go ahead, play around a bit.</p>
<p dir="auto">Glowdust allows for basic variable declaration and assignment</p>
<pre><code>a = 1
</code></pre><p dir="auto">and you can print values</p>
<pre><code>print(a)
</code></pre><pre><code>&lt;&lt; 1
</code></pre><p dir="auto">or do basic arithmetic</p>
<pre><code>print(a + a * 3)
</code></pre><pre><code>&lt;&lt; 4
</code></pre><p dir="auto">You have access to your command history with the <code>up</code> and <code>down</code> arrow keys and you can edit your
commands just like in your shell.</p>
<p dir="auto">Exiting Glowdust happens with <code>Ctrl-D</code> or with the <code>:quit</code> command:</p>
<pre><code>&gt;&gt; :quit
$
</code></pre><p dir="auto">In fact, <code>:</code> allows you access to some administrative commands in Glowdust REPL. We just saw <code>:quit</code>,
but there is also <code>:reset</code> for removing all defined variables and their values (but leaves functions in place) and
<code>:log {warn|error|debug}</code> for adjusting the log output level (defaults to error on startup).</p>

<p dir="auto">Now that we have a REPL that we can execute commands in, let&#39;s see what it means to store data as functions.</p>
<p dir="auto">A function, in the general sense, is a mapping from one set of values to another.
Programmers tend to think of functions as a sequence of steps that calculate an output for a given input,
but there are cases where a function cannot be <em>computed</em> but still be <em>well defined</em>.</p>
<p dir="auto">For example, consider the following dataset, which is part of a historical record of temperature values for the city I
live in, on November 2nd 2023.</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>Temperature (°C)</th>
</tr>
</thead>
<tbody>
<tr>
<td>12:00</td>
<td>11</td>
</tr>
<tr>
<td>13:00</td>
<td>11</td>
</tr>
<tr>
<td>14:00</td>
<td>10</td>
</tr>
<tr>
<td>15:00</td>
<td>10</td>
</tr>
<tr>
<td>16:00</td>
<td>10</td>
</tr>
<tr>
<td>17:00</td>
<td>10</td>
</tr>
<tr>
<td>18:00</td>
<td>9</td>
</tr>
<tr>
<td>19:00</td>
<td>8</td>
</tr>
</tbody>
</table>
<h2 id="user-content-basic-data-input-and-output" dir="auto">Basic data input and output</h2>
<p dir="auto">By using the Glowdust REPL, you can insert this dataset with the following commands:</p>
<pre><code>define temperature() = {}
temperature(12) = 11
temperature(13) = 11
temperature(14) = 10
temperature(15) = 10
temperature(16) = 10
temperature(17) = 10
temperature(18) = 9
temperature(19) = 8
</code></pre><p dir="auto">The <code>define</code> line introduces the <code>temperature</code> symbol in Glowdust so values for it can be added.
Ignore the weird curly brackets for now.</p>
<p dir="auto">It is impossible(ok, not impossible, just inconvenient) to create a formula for this type of historical sensor data.
At the same time, it is possible to treat it as a function that maps time to temperature, provided we confine our
queries to the <code>time</code> values that actually appear in the table.</p>
<p dir="auto">For example, we can call the function <code>temperature</code> like so</p>
<pre><code>print(temperature(15))
</code></pre><pre><code>&lt;&lt; 10
</code></pre><p dir="auto">Of course, <code>temperature</code> is not defined at every possible <code>time</code> value.
For such values, Glowdust defaults to returning no value</p>
<pre><code>print(temperature(20))
</code></pre><pre><code>&lt;&lt; ()
</code></pre><p dir="auto">and it should be possible to define new values, for which assignment works just fine</p>
<pre><code>temperature(20) = 9
print(temperature(20))
</code></pre><pre><code>&lt;&lt; 9
</code></pre><p dir="auto">just as it does for altering existing values</p>
<pre><code>temperature(20) = 8
print(temperature(20))
</code></pre><pre><code>&lt;&lt; 8
</code></pre><p dir="auto">To round off the set of features, Glowdust lets you query your data by using match statements.
For example, we can print at which times the temperature was 10°C</p>
<pre><code>match temperature(x) -&gt; 10, println(x)
</code></pre><pre><code>&lt;&lt; 
14
15
16
17
</code></pre><p dir="auto">Or we can find all the temperature values</p>
<pre><code>match temperature(x) -&gt; y, println(y)
</code></pre><pre><code>&lt;&lt; 
10
10
8
8
9
11
10
11
10
</code></pre><p dir="auto">The <a href="#user-content-queries-1" rel="nofollow">section on queries</a> is dedicated to how queries work, but before that let&#39;s take
a tour of function basics.</p>

<p dir="auto">To start with, you can look at Glowdust as a rudimentary scripting language that lets you do the
very basic stuff like declare variables, add them together, print them and so on.</p>
<p dir="auto">For example, here&#39;s how you declare a variable <code>a</code>, set its value to <code>1</code> and print<sup id="fnref:user-content-print"><a href="#fn:user-content-print" rel="nofollow">1</a></sup> it.</p>
<pre><code>a = 1
print(a)
</code></pre><pre><code>&lt;&lt; 1
</code></pre><p dir="auto">Note that it is an error<sup id="fnref:user-content-too_much_info"><a href="#fn:user-content-too_much_info" rel="nofollow">2</a></sup> to declare variables without also setting a value</p>
<pre><code>b
</code></pre><pre><code>&lt;&lt; Encountered error Compile error At position line: 1, position: 1, variable 1 is not initialized yet, 
produced at file src/compiler/parser/ast_walker.rs, line 103
</code></pre><p dir="auto">Glowdust supports signed integers, booleans, strings and tuples of these values.</p>
<pre><code>a = &#34;A string&#34;
b = -42
c = true
tuple = (a, b, c)
print(tuple)
</code></pre><pre><code>&lt;&lt; (&#34;A string&#34;, -42, true)
</code></pre><p dir="auto">Nested tuples and empty tuples are also permitted</p>
<pre><code>empty = ()
container = (empty, empty)
print(container)
</code></pre><pre><code>&lt;&lt; ((), ())
</code></pre><p dir="auto">Currently, variables can hold values of different types, but that is temporary.
Glowdust is intended to be a strictly typed language supporting at least floating
point values, characters, byte arrays and user defined types.</p>
<p dir="auto">The usual arithmetic (<code>+</code>, <code>-</code>, <code>*</code> and <code>/</code>) and logical (<code>||</code>, <code>&amp;&amp;</code>, <code>!</code>)
operators are supported, with the only overload being string concatenation for <code>+</code>.</p>
<pre><code>print(1 + 2)
</code></pre><pre><code>&lt;&lt; 3
</code></pre><pre><code>first = &#34;a string&#34;
second = &#34; &#34;
third = &#34;addition&#34; 
print(first + second + third)
</code></pre><pre><code>&lt;&lt; &#34;a string addition&#34;
</code></pre><pre><code>print(true || false)
</code></pre><pre><code>&lt;&lt; true
</code></pre><h2 id="user-content-functions" dir="auto">Functions</h2>
<h3 id="user-content-function-values" dir="auto">Function values</h3>
<p dir="auto">As we saw <a href="#user-content-motivation" rel="nofollow">earlier</a>, Glowdust is built around datasets represented as functions, so let&#39;s see how they are represented.</p>
<p dir="auto">Functions are fundamentally made up of</p>
<ol dir="auto">
<li>a name,</li>
<li>value mappings and</li>
<li>definition bodies.<sup id="fnref:user-content-model_changes"><a href="#fn:user-content-model_changes" rel="nofollow">3</a></sup></li>
</ol>
<p dir="auto">The only mandatory element is the name, and that&#39;s what a <code>define</code> statement is for</p>
<pre><code>define cat() = {}
</code></pre><p dir="auto">This introduces the function <code>cat</code> as a symbol in Glowdust. Defined like this,
there are no value mappings for it, but we can add them with an assignment.</p>
<pre><code>cat(100) = (&#34;Greebo&#34;, 1990, &#34;grey&#34;)
cat(101) = (&#34;Zen&#34;, 2018, &#34;b&amp;w&#34;)
cat(102) = (&#34;Maurice&#34;, 2001, &#34;yellow&#34;)

print( cat(100) )
</code></pre><pre><code>&lt;&lt; (&#34;Greebo&#34;, 1990, &#34;grey&#34;)
</code></pre><p dir="auto">This creates 3 value mappings and assumes we decided to represent cat data as a <code>(name, year of birth, hair color)</code> tuple.<sup id="fnref:user-content-no_schema"><a href="#fn:user-content-no_schema" rel="nofollow">4</a></sup></p>
<p dir="auto">and Glowdust will happily store these values for you. As of this writing,
what the behavior <em>should</em> be under these circumstances is still under investigation.</p>
<p dir="auto">There is also no support for naming function arguments or value tuple fields - you cannot currently tell
Glowdust that the first field of <code>(&#34;Zen&#34;, 2018, &#34;b&amp;w&#34;)</code> is called <code>name</code> and refer to it. This is work in progress.</p>
<h3 id="user-content-adding-definitions-to-functions-model_changes" dir="auto">Adding definitions to functions<sup id="fnref:user-content-model_changes"><a href="#fn:user-content-model_changes" rel="nofollow">3</a></sup></h3>
<p dir="auto">In the temperature example from before, we saw a case where a dataset represents a function that cannot be computed.
On the flip side of that, there are cases where a function cannot be stored as a mapping and needs to be computed.
Glowdust allows this through definition bodies. Consider an <code>add(int, int)</code><sup id="fnref:user-content-binding"><a href="#fn:user-content-binding" rel="nofollow">5</a></sup> function.
It&#39;s not practical to implement it as a map, which is why Glowdust supports function bodies like so:</p>
<pre><code>define add(a, b) = { a + b }
print( add(1, 2) )
</code></pre><pre><code>&lt;&lt; 3
</code></pre><p dir="auto">Obviously <code>add()</code> can still be thought of as a map lookup for every possible pair of values,
but now we have a concise definition.</p>
<p dir="auto">A Glowdust function body can contain any valid Glowdust script except</p>
<ol dir="auto">
<li>function definitions and</li>
<li>match statements<sup id="fnref:user-content-exception"><a href="#fn:user-content-exception" rel="nofollow">6</a></sup>.</li>
</ol>
<p dir="auto">It is also possible to overload function definitions on the number of arguments (and eventually, their types)</p>
<pre><code>define add(a, b, c) = { add(a, b) + c }
print( add(1, 2, 3) )
</code></pre><pre><code>&lt;&lt; 6
</code></pre><p dir="auto">What may be less familiar is the ability to overload based on argument <em>values</em>.
A function definition can have constant values in the formal arguments,
which will be matched at call time and the corresponding definition will be used.
For example, we can use this ability to create an idiomatic <code>if</code> function:</p>
<pre><code>define if(true, a, b) = {a}
define if(false, a, b) = {b}
print ( if(1 == 2, &#34;equal&#34;, &#34;not equal&#34;) )
</code></pre><pre><code>&lt;&lt; &#34;not equal&#34;
</code></pre><pre><code>print( if(true, &#34;TRUE&#34;, &#34;FALSE&#34;) )
</code></pre><pre><code>&lt;&lt; &#34;TRUE&#34;
</code></pre><p dir="auto">Note: Value overloads take precedence when choosing which definition to use, but again, see <sup id="fnref:user-content-model_changes"><a href="#fn:user-content-model_changes" rel="nofollow">3</a></sup></p>
<p dir="auto">Finally, all of these features can be combined to create an implementation of a list structure in Glowdust</p>
<pre><code>define count() = {}
define position() = {}

count(&#34;myList&#34;) = 0

define if(true, a, b) = { a }
define if(false, a, b) = { b }

define set(list, index, value) = {
    position(list, index) = value
    count(list) = count(list) + if(index &gt; count(list) - 1, 1, 0)
}

set(&#34;myList&#34;, 0, &#34;zero&#34;)
set(&#34;myList&#34;, 1, &#34;one&#34;)
set(&#34;myList&#34;, 2, &#34;two&#34;)
set(&#34;myList&#34;, 2, &#34;two&#34;)
myCount = count(&#34;myList&#34;)
zero = position(&#34;myList&#34;, 0)
one = position(&#34;myList&#34;, 1)
two = position(&#34;myList&#34;, 2)
</code></pre><pre><code>print(position(&#34;myList&#34;, 2))
</code></pre><pre><code>&lt;&lt; &#34;two&#34;
</code></pre><pre><code>print(count(&#34;myList&#34;))
</code></pre><pre><code>&lt;&lt; 3
</code></pre><p dir="auto">All definitions and value pairings in this example are stored in Glowdust and can be queried and modified as normal.
The function model implemented by Glowdust allows you to think of everything as function calls,
even though this program does nothing but look up values.</p>

<h2 id="user-content-single-function-queries" dir="auto">Single function queries</h2>
<p dir="auto">So far we have focused on how to define and call functions. In this chapter we will turn our attention to
querying the contents of functions using Glowdust&#39;s <code>match</code> statement.</p>
<p dir="auto">First, let&#39;s finish building up the Cat dataset so we have something to query. We already saw three entries:</p>
<pre><code>define cat() = {}
cat(100) = (&#34;Greebo&#34;, 1990, &#34;grey&#34;)
cat(101) = (&#34;Zen&#34;, 2001, &#34;black and white&#34;)
cat(102) = (&#34;Maurice&#34;, 2001, &#34;yellow&#34;)
</code></pre><p dir="auto">As a reminder, Glowdust doesn&#39;t yet support schema objects, so we need to manually keep track
of what each tuple position means. In this case, <code>cat</code> is a function from an integer ID
to a triplet of name, year of birth and color.</p>
<p dir="auto">Let&#39;s add a few more</p>
<pre><code>cat(103) = (&#34;Cheshire&#34;, 1865, &#34;not all there&#34;)
cat(104) = (&#34;Demeter&#34;, 1939, &#34;black and gold&#34;)
</code></pre><p dir="auto">We can also use our imagination and come up with some books that would be suitable for individuals of the feline disposition</p>
<pre><code>define book() = {}
book(&#34;1291-291&#34;) = (102, &#34;Giving chase: Rats, birds and other playmates&#34;, 1996, &#34;hardcover&#34;)
book(&#34;3721-253&#34;) = (103, &#34;Through the looking glass - A life behind a window&#34;, 2001, &#34;paperback&#34;)
book(&#34;2442-444&#34;) = (104, &#34;31 cute ways to ask for food&#34;, 1999, &#34;hardcover&#34;)
book(&#34;8387-588&#34;) = (104, &#34;The cat in the box&#34;, 2010, &#34;hardcover&#34;)
book(&#34;5945-304&#34;) = (100, &#34;If I fits I sits, and other nursery rhymes&#34;, 2022, &#34;paperback&#34;)
book(&#34;0532-868&#34;) = (101, &#34;Staring contents 101 - The meow and the why&#34;, 2011, &#34;paperback&#34;)
book(&#34;6623-332&#34;) = (103, &#34;Fireworks, vacuum cleaners and other horror stories&#34;, 1981, &#34;paperback&#34;)
book(&#34;4795-260&#34;) = (101, &#34;Is this carpet expensive? Advanced puking techniques&#34;, 2013, &#34;hardcover&#34;)
</code></pre><p dir="auto">The <code>book</code> function takes a string representing the ISBN of the book and returns a tuple
of author id, the title, publication year and format.</p>
<p dir="auto"><code>book(isbn: String) -&gt; (author_id: Integer, title: String, year: Integer, format: String)</code></p>
<p dir="auto">N.B.: You may also have noticed that some of these books were written before their author&#39;s birth. Whether this is a case of
academic shenanigans or an instance of time travel is beyond the scope of this README.</p>
<p dir="auto">We can start with simple queries, asking for information from a single function.
An example would be to get the names of all authors<sup id="fnref:user-content-result_order"><a href="#fn:user-content-result_order" rel="nofollow">7</a></sup></p>
<pre><code>match cat(cat_id) -&gt; (name, birth_year, color), return name, birth_year, color
</code></pre><pre><code>&lt;&lt;
[&#34;Greebo&#34;, 1990, &#34;grey&#34;]
[&#34;Cheshire&#34;, 1865, &#34;not all there&#34;]
[&#34;Zen&#34;, 2001, &#34;black and white&#34;]
[&#34;Maurice&#34;, 2001, &#34;yellow&#34;]
[&#34;Demeter&#34;, 1939, &#34;black and gold&#34;]
</code></pre><p dir="auto">We can already see some of basic features of queries in Glowdust.</p>
<p dir="auto">Queries start with the <code>match</code> keyword and are made up of a comma separated list of <em>function patterns</em>.</p>
<p dir="auto">A function pattern is a function name (<code>cat</code> in this example), followed by a
tuple of variables that correspond to the arguments of the function (<code>cat_id</code>).
In the example above, the sole function pattern is <code>cat(cat_id)</code>.
The function pattern can be optionally followed by an <code>-&gt;</code>, called the <em>pass operator</em>
and another pattern tuple with variables that will be bound to the result values.
Again, in the example you can see that the result binding tuple is <code>(name, birth_year, color)</code>.</p>
<p dir="auto">Glowdust will iterate over all mappings of the function, bind variables to values
according to their position and return them as a sequence of value tuples.</p>
<p dir="auto">We also see the <code>return</code> keyword in action. <code>return</code> can appear as a standalone atom or in a block, followed
by a comma separated list of expressions. In both cases the effect is the same: If the block or atom are executed,
the expressions are evaluated and returned as a row to the <code>Sink</code>.</p>
<p dir="auto">The difference between <code>return</code> and <code>print</code>/<code>println</code> that we have used so far is not relevant for the CLI, since they
both print the value to the console. However, when used in an application, Glowdust&#39;s <code>return</code> clause is the mechanism
for returning values to the driving code. For more information see the <code>glowdust::runtime::sink::Sink</code> trait and its use.</p>
<h3 id="user-content-note" dir="auto">NOTE</h3>
<hr/>
<p dir="auto"><em>There is currently ambiguity in the <code>return</code> syntax. When it appears as an atom, the list of expressions to produce
is unclear if it should be parsed as atoms or return expressions. For the moment, it will be greedily interpreted as
return expressions, so if it is used as the last atom in a query, it should work normally. This will be fixed in a future release.</em></p>
<hr/>
<p dir="auto">You can also use constant expressions in place of variables for your patterns<sup id="fnref:user-content-predicates"><a href="#fn:user-content-predicates" rel="nofollow">8</a></sup>.
Doing so matches only function mappings that have the specified value in the given position.
For example, here is how you can find all paperback format books</p>
<pre><code>match book(isbn) -&gt; (author_id, title, year, &#34;paperback&#34;), return author_id, title, year
</code></pre><pre><code>&lt;&lt;
[101, &#34;Staring contents 101 - The meow and the why&#34;, 2011]
[103, &#34;Through the looking glass - A life behind a window&#34;, 2001]
[103, &#34;Fireworks, vacuum cleaners and other horror stories&#34;, 1981]
[100, &#34;If I fits I sits, and other nursery rhymes&#34;, 2022]
</code></pre><p dir="auto">The important take away from this section is that queries work by iterating over the dataset of a function,
binding each row&#39;s values to variables based on position.
This is the core concept in Glowdust and how we can build up more complicated
queries by joining various functions together.</p>
<h2 id="user-content-joining-functions" dir="auto">Joining functions</h2>
<p dir="auto">Let&#39;s bring the <code>book</code> function into the mix and try to create a more complicated query. For example, we can print
the names of the authors that have <code>hardcover</code> books:</p>
<pre><code>match cat(cat_id) -&gt; (name, year, color), book(isbn) -&gt; (cat_id, title, pub_year, &#34;hardcover&#34;), return name
</code></pre><pre><code>&lt;&lt;
[&#34;Zen&#34;]
[&#34;Maurice&#34;]
[&#34;Demeter&#34;]
[&#34;Demeter&#34;]
</code></pre><p dir="auto">The new feature at play here is the bound <code>cat_id</code> variable. As the <code>cat</code> function maps over its values, it binds the
<code>cat_id</code> variable, and subsequent query elements will match the current value and proceed if true. In other words,
this is a nested loop that does a join on the <code>cat_id</code> variable.</p>
<p dir="auto">We can use the same method for self joins:</p>
<pre><code>match cat(id1) -&gt; (name1, year, color1), cat(id2) -&gt; (name2, year, color2), return name1, name2
</code></pre><pre><code>&lt;&lt;
[&#34;Greebo&#34;, &#34;Greebo&#34;]
[&#34;Cheshire&#34;, &#34;Cheshire&#34;]
[&#34;Zen&#34;, &#34;Zen&#34;]
[&#34;Zen&#34;, &#34;Maurice&#34;]
[&#34;Maurice&#34;, &#34;Zen&#34;]
[&#34;Maurice&#34;, &#34;Maurice&#34;]
[&#34;Demeter&#34;, &#34;Demeter&#34;]
</code></pre><p dir="auto">Which gives us all the pairs of authors that have the same birth year. Of course, every author has a birth year the
same with itself, so we can filter these out with an inequality filter:</p>
<pre><code>match cat(id1) -&gt; (name1, year, color1), cat(id2) -&gt; (name2, year, color2), {name1 != name2}, return name1, name2
</code></pre><pre><code>&lt;&lt;
[&#34;Zen&#34;, &#34;Maurice&#34;]
[&#34;Maurice&#34;, &#34;Zen&#34;]
</code></pre><h2 id="user-content-discarding-values" dir="auto">Discarding values</h2>
<p dir="auto">The previous two examples required us to get a bit creative with the variable names. Specifically, the variables <code>id1</code>,
<code>id2</code>, <code>color1</code> and <code>color2</code> were irrelevant to the query, but we still had to make sure they were unique, otherwise
they would impose an equijoin on their values, which we didn&#39;t want.</p>
<p dir="auto">This problem comes up often when writing Glowdust queries and, while it is a fun exercise to come up with
unique variable names and remember which ones we have used already in the query, it can get tiresome after a while.</p>
<p dir="auto">So, Glowdust supports a special <em>discard</em> variable name, with the identifier <code>_</code> (the underscore character). Whenever
<code>_</code> is used as a variable name in a query, that position is considered an unbound variable and the value will be
discarded.</p>
<p dir="auto">Look at how we can rewrite the previous query with this in hand:</p>
<pre><code>match cat(_) -&gt; (name1, year, _), cat(_) -&gt; (name2, year, _), {name1 != name2}, return name1, name2
</code></pre><pre><code>&lt;&lt;
[&#34;Zen&#34;, &#34;Maurice&#34;]
[&#34;Maurice&#34;, &#34;Zen&#34;]
</code></pre><p dir="auto">Much more readable, wouldn&#39;t you say? Not only is it easier to write, but when you read it you can immediately see
which values are important and which you can just ignore.</p>
<h2 id="user-content-statement-blocks-and-the-operator-temporary_feature" dir="auto">Statement blocks and the <code>!!</code> operator<sup id="fnref:user-content-temporary_feature"><a href="#fn:user-content-temporary_feature" rel="nofollow">9</a></sup></h2>
<p dir="auto">The blocks we have seen in queries so far have consisted of one expression only. That expression is interpreted
as a boolean value and acts as a guard for the rest of the query. But what if we want to do a computation or
introduce side effects (for example, database updates or function calls) in a query, without affecting the flow
of execution?</p>
<p dir="auto">This is where statement blocks come in. Statement blocks are query blocks like the filter we saw above, but made up
of statements and ending in <code>!!</code>. The <code>!!</code> operator indicates that you actually intend for this block to not have a value
and you didn&#39;t accidentally forget to add a return expression.</p>
<p dir="auto">Here&#39;s the previous example, but with an expression and a <code>!!</code> - note the different result:</p>
<pre><code>match cat(_) -&gt; (name1, year, _), cat(_) -&gt; (name2, year, _), {name1 != name2; !!}, return name1, name2
</code></pre><pre><code>&lt;&lt;
[&#34;Cheshire&#34;, &#34;Cheshire&#34;]
[&#34;Greebo&#34;, &#34;Greebo&#34;]
[&#34;Zen&#34;, &#34;Zen&#34;]
[&#34;Zen&#34;, &#34;Maurice&#34;]
[&#34;Maurice&#34;, &#34;Zen&#34;]
[&#34;Maurice&#34;, &#34;Maurice&#34;]
[&#34;Demeter&#34;, &#34;Demeter&#34;]
</code></pre><p dir="auto">As expected, the block doesn&#39;t act as a filter anymore. Note that if you omit the <code>!!</code> at the end of the block, it will
draw a compile time error. This way, you can be sure that you haven&#39;t accidentally mistyped a filter into a statement
block and wonder why your results are all wrong. How convenient!!</p>
<p dir="auto">And here&#39;s a statement block in action.</p>
<p dir="auto">First, let&#39;s define a <code>result_count</code> function to hold a count for each name</p>
<pre><code>define result_count(any) = {0}
</code></pre><p dir="auto">and let&#39;s update it in the block</p>
<pre><code>match cat(_) -&gt; (name1, year, _), cat(_) -&gt; (name2, year, _), {result_count(name1) = result_count(name1) + 1; !!}, return name1, name2
</code></pre><pre><code>&lt;&lt;
[&#34;Maurice&#34;, &#34;Maurice&#34;]
[&#34;Maurice&#34;, &#34;Zen&#34;]
[&#34;Cheshire&#34;, &#34;Cheshire&#34;]
[&#34;Greebo&#34;, &#34;Greebo&#34;]
[&#34;Zen&#34;, &#34;Maurice&#34;]
[&#34;Zen&#34;, &#34;Zen&#34;]
[&#34;Demeter&#34;, &#34;Demeter&#34;]
</code></pre><p dir="auto">we got the exact same result as before, but now, check this out:</p>
<pre><code>print(result_count(&#34;Maurice&#34;))
</code></pre><pre><code>&lt;&lt;
2
</code></pre><p dir="auto">and</p>
<pre><code>print(result_count(&#34;Greebo&#34;))
</code></pre><pre><code>&lt;&lt;
1
</code></pre><p dir="auto">exactly as you would expect.</p>
<div>
<hr/>
<ol>
<li id="fn:user-content-print">
<p dir="auto">print is a built in function, not a language primitive. However, it currently depends on a special
bytecode, because native functions are not yet supported.
You can use <code>println</code> if you want to have a newline appended at the end of your output. <a href="#fnref:user-content-print" rel="nofollow">↩︎</a></p>
</li>
<li id="fn:user-content-too_much_info">
<p dir="auto">As you can see, errors are quite verbose and full of debugging info.
These will be removed as Glowdust matures, but please be patient for now. <a href="#fnref:user-content-too_much_info" rel="nofollow">↩︎</a></p>
</li>
<li id="fn:user-content-model_changes">
<p dir="auto">This is up for redesign. It&#39;s not clear if it is a good idea for a function to have both
definitions and mappings. It is cool, and it could be useful, but it seems as a can of worms best left unopened. <a href="#fnref:user-content-model_changes" rel="nofollow">↩︎</a></p>
</li>
<li id="fn:user-content-no_schema">
<p dir="auto">Currently there is no schema enforcement for function definitions and value mappings,
which means there is nothing stopping you from adding mappings to <code>cat</code> that do not follow this schema.
For example, you can write <code>cat(true) = false</code> and it will work. It will also mess up the arity calculations and queries
will stop working, so it&#39;s better if you don&#39;t do that. <a href="#fnref:user-content-no_schema" rel="nofollow">↩︎</a></p>
</li>
<li id="fn:user-content-binding">
<p dir="auto">As you&#39;d expect, the formal arguments of the definition are available in
the body and they get bound at call time to actual values.
Since Glowdust currently doesn&#39;t enforce types, passing the wrong value will result in a runtime error. <a href="#fnref:user-content-binding" rel="nofollow">↩︎</a></p>
</li>
<li id="fn:user-content-exception">
<p dir="auto">Allowing nested function definitions is not in scope.
Allowing match statements in function bodies is on the roadmap. <a href="#fnref:user-content-exception" rel="nofollow">↩︎</a></p>
</li>
<li id="fn:user-content-result_order">
<p dir="auto">The order in which results are printed is not fixed. <a href="#fnref:user-content-result_order" rel="nofollow">↩︎</a></p>
</li>
<li id="fn:user-content-predicates">
<p dir="auto">You probably recognise this as an equality predicate.
That is indeed the case, but equality predicates expressed like this in Glowdust are syntactic
sugar for a more expressive way of creating predicates. We&#39;ll get back to this topic in the next chapter. <a href="#fnref:user-content-predicates" rel="nofollow">↩︎</a></p>
</li>
<li id="fn:user-content-temporary_feature">
<p dir="auto">This is not a very reasonably, pretty, or functional feature. It is however convenient in defining
semantics as the language evolves and useful for experimentation. This should be expected to go away soon. <a href="#fnref:user-content-temporary_feature" rel="nofollow">↩︎</a></p>
</li>
</ol>
</div>

			
		</div>
	</div>
</div></div>
  </body>
</html>
