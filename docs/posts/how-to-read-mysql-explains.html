<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://planetscale.com/blog/how-read-mysql-explains">Original</a>
    <h1>How to Read MySQL EXPLAINs</h1>
    
    <div id="readability-page-1" class="page"><article><header></header><section><div><p>In the MySQL world, <code>EXPLAIN</code> is a keyword used to gain information about query execution. This blog post will demonstrate how to utilize MySQL <code>EXPLAIN</code> to remedy problematic queries.</p>
<p>On the Technical Solutions team here at PlanetScale, we frequently talk with users who seek advice regarding query performance. Although creating an <code>EXPLAIN</code> plan is relatively simple, the output isn’t exactly intuitive. It’s essential to understand its features and how to leverage it best to achieve performance goals.</p>
<h2 id=""><a href="#"><code>EXPLAIN</code> vs. <code>EXPLAIN ANALYZE</code><span aria-label="Permalink to [object Object], vs. ,[object Object]" role="complementary">#</span></a></h2>
<p>When you prepend the <code>EXPLAIN</code> keyword to the beginning of a query, it explains how the database executes that query and the estimated costs. By leveraging this internal MySQL tool, you can observe the following:</p>
<ul>
<li><strong>The ID of the query</strong> — The column always contains a number, which identifies the <code>SELECT</code> to which the row belongs.</li>
<li><strong>The <code>SELECT_TYPE</code></strong> — If you are running a <code>SELECT</code>, MySQL divides <code>SELECT</code> queries into simple and primary (complex) types, as described in the table below.</li>
</ul>
<table><thead><tr><th><code>SELECT_TYPE</code> VALUE</th><th>Definition</th></tr></thead><tbody><tr><td><code>SIMPLE</code></td><td>The query contains no subqueries or <code>UNION</code>s</td></tr><tr><td><code>PRIMARY</code> (complex)</td><td>Complex types can be grouped into three broad classes: simple subqueries, derived tables (subqueries in the <code>FROM</code> clause), and <code>UNION</code>s.</td></tr><tr><td><code>DELETE</code></td><td>If you are explaining a <code>DELETE</code>, the <code>select_type</code> will be <code>DELETE</code></td></tr></tbody></table>
<ul>
<li><strong>The table on which your query was running</strong></li>
<li><strong>Partitions accessed by your query</strong></li>
<li><strong>Types of JOINs used (if any)</strong> — Please keep in mind that this column gets populated even on queries that don’t have joins.</li>
<li><strong>Indexes from which MySQL could choose</strong></li>
<li><strong>Indexes MySQL actually used</strong></li>
<li><strong>The length of the index chosen by MySQL</strong> — When MySQL chooses a composite index, the length field is the only way you can determine how many columns from that composite index are in use.</li>
<li><strong>The number of rows accessed by the query</strong> — When designing indexes inside of your database instances, keep an eye on the rows column too. This column displays how many rows MySQL accessed to complete a request, which can be useful when designing indexes. The fewer rows your query accesses, the faster your queries will be.</li>
<li><strong>Columns compared to the index</strong></li>
<li><strong>The percentage of rows filtered by a specified condition</strong> — This column shows a pessimistic estimate of the percentage of rows that will satisfy some condition on the table, such as a <code>WHERE</code> clause or a join condition. If you multiply the rows column by this percentage, you will see the number of rows MySQL estimates it will join with the previous tables in the query plan.</li>
<li><strong>Any extra information relevant to the query</strong></li>
</ul>
<p>To recap, by using <code>EXPLAIN</code>, you get the list of things expected to happen.</p>
<h3>What is <code>EXPLAIN ANALYZE</code></h3>
<p>In MySQL 8.0.18, <code>EXPLAIN ANALYZE</code> was introduced, a new concept built on top of the regular <code>EXPLAIN</code> query plan inspection tool. In addition to the query plan and estimated costs, which a normal <code>EXPLAIN</code> will print, <code>EXPLAIN ANALYZE</code> also prints the <em>actual</em> costs of individual iterators in the execution plan.</p>
<div><p><strong>Warning</strong></p><p><code>EXPLAIN ANALYZE</code> actually runs the query, so if you don’t want to run the query against your live database, do not
use <code>EXPLAIN ANALYZE</code>.</p></div>
<p>For each iterator, the following information is provided:</p>
<ul>
<li>Estimated execution cost (the cost model does not account for some iterators, so they aren’t included in the estimate)</li>
<li>Estimated number of returned rows</li>
<li>Time to return first row</li>
<li>Time spent executing this iterator (including child iterators, but not parent iterators), in milliseconds. When there are multiple loops, this figure shows the average time per loop.</li>
<li>Number of rows returned by the iterator</li>
<li>Number of loops</li>
</ul>
<p><img alt="MySQL EXPLAIN ANALYZE" sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw" srcset="/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fmysql-explain-analyze.png&amp;w=256&amp;q=75 256w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fmysql-explain-analyze.png&amp;w=384&amp;q=75 384w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fmysql-explain-analyze.png&amp;w=640&amp;q=75 640w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fmysql-explain-analyze.png&amp;w=768&amp;q=75 768w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fmysql-explain-analyze.png&amp;w=1024&amp;q=75 1024w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fmysql-explain-analyze.png&amp;w=1280&amp;q=75 1280w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fmysql-explain-analyze.png&amp;w=1536&amp;q=75 1536w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fmysql-explain-analyze.png&amp;w=3840&amp;q=75 3840w" src="https://thomasbroadley.com/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fmysql-explain-analyze.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="fill" loading="lazy"/></p><p>If you use <code>EXPLAIN ANALYZE</code> before a statement, you get both the estimation of what the planner expected (<em>highlighted in yellow above</em>) and what actually happened when the query was run (<em>highlighted in green above</em>).</p>
<h2 id=""><a href="#"><code>EXPLAIN ANALYZE</code> formats<span aria-label="Permalink to [object Object], formats" role="complementary">#</span></a></h2>
<p><code>EXPLAIN ANALYZE</code> can be used with <a href="https://dev.mysql.com/doc/refman/8.0/en/select.html"><code>SELECT</code></a> statements, multi-table <a href="https://dev.mysql.com/doc/refman/8.0/en/update.html"><code>UPDATE</code></a> statements, <a href="https://dev.mysql.com/doc/refman/8.0/en/delete.html"><code>DELETE</code></a> statements, and <a href="https://dev.mysql.com/doc/refman/8.0/en/table.html"><code>TABLE</code></a> statements.</p>
<p>It automatically selects <code>FORMAT=tree</code> and executes the query (with no output to the user). It focuses on how the query is executed in terms of the relationship between parts of the query and the order in which the parts are executed.</p>
<p>In this case, <code>EXPLAIN</code> output is organized into a series of nodes. At the lowest level, the nodes scan the tables or search indexes. Higher-level nodes take the operations from the lower-level nodes and operate on them.</p>
<p>Although the MySQL CLI can print <code>EXPLAIN</code> results in table, tabbed, vertical format, or as pretty or raw JSON output, raw JSON format is not supported for <code>EXPLAIN ANALYZE</code> today.</p>
<h2 id=""><a href="#">When to use MySQL <code>EXPLAIN</code> or <code>EXPLAIN ANALYZE</code><span aria-label="Permalink to When to use MySQL ,[object Object], or ,[object Object]" role="complementary">#</span></a></h2>
<p><code>EXPLAIN</code> queries can (and should) be used when you are unsure whether your query is performing efficiently. So, if you think you have indexed and partitioned your tables properly, but your queries still refuse to run as fast as you want them to, it might be time to tell them to <code>EXPLAIN</code> themselves. Once you tell your queries to <code>EXPLAIN</code> themselves, the output you should keep an eye on will depend on what you want to optimize.</p>
<ul>
<li>
<p><strong>Keys, possible keys, and key lengths</strong>: When working with indexes in MySQL, keep an eye on the <code>possible_keys</code>, <code>key</code>, and <code>key_len</code> columns. The <code>possible_keys</code> column tells us what indexes MySQL could potentially use. The <code>key</code> column tells us what index was chosen. And the <code>key_len</code> column tells us the length of the selected key (index). This information can be handy for designing our indexes, deciding what index to use on a specific workload, and dealing with index-related challenges like choosing an appropriate length for a covering index.</p>
</li>
<li>
<p><strong>Fulltext index + <code>JOIN</code></strong>: If you want to ensure that your queries are participating in <code>JOIN</code> operations when using a <code>FULLTEXT</code> index, keep an eye out for the <code>select_type</code> column — the value of this column should be fulltext.</p>
</li>
<li>
<p><strong>Partitions</strong>: If you have added partitions to your table and want to ensure that partitions are used by the query, observe the partition column. If your MySQL instance is using partitions, in most cases, MySQL deals with all of the queries itself, and you do not have to take any further action, but if you want your queries to use specific partitions, you could use queries like <code>SELECT \* FROM TABLE_NAME PARTITION(p1,p2)</code>.</p>
</li>
</ul>
<p>We already have some great resources about indexing best practices:</p>
<ul>
<li><a href="https://thomasbroadley.com/blog/indexing-json-in-mysql">Indexing JSON in MySQL</a></li>
<li><a href="https://thomasbroadley.com/blog/what-are-the-disadvantages-of-database-indexes">What are the disadvantages of database indexes?</a></li>
<li><a href="https://thomasbroadley.com/courses/mysql-for-developers/indexes/introduction-to-indexes">MySQL for Developers video course: Indexes</a></li>
<li><a href="https://thomasbroadley.com/blog/how-do-database-indexes-work">How do database indexes work</a></li>
</ul>
<h2 id=""><a href="#"><code>EXPLAIN</code> limitations<span aria-label="Permalink to [object Object], limitations" role="complementary">#</span></a></h2>
<p><code>EXPLAIN</code> is an approximation. Sometimes it’s a good approximation, but at other times, it can be very far from the truth. Let&#39;s look at some of the limitations:</p>
<ul>
<li><code>EXPLAIN</code> doesn’t tell you anything about how triggers, stored functions, or UDFs will affect your query.</li>
<li>It doesn’t work for stored procedures.</li>
<li>It doesn’t tell you about the optimization MySQL does during query execution.</li>
<li>Some of the statistics it shows are estimates and can be very inaccurate.</li>
<li>It doesn’t distinguish between some things with the same name. For example, it uses “filesort” for in-memory sorts and on-disk sorts, and it displays “Using temporary” for temporary tables on disk and in memory.</li>
</ul>
<p>Note: PlanetScale does not support Triggers, Stored Procedures, and UDFs. More information can be found in the <a href="https://thomasbroadley.com/docs/reference/mysql-compatibility">MySQL compatibility docs</a>.</p>
<h3><code>SHOW Warnings</code> statement</h3>
<p>One thing worth noting: If the query you used with <code>EXPLAIN</code> does not parse correctly, you can type <code>SHOW WARNINGS;</code> into your MySQL query editor to show information about the last statement that was run and was not diagnostic. While it cannot give a proper query execution plan like <code>EXPLAIN</code>, it might give hints about the query fragments it could process.</p>
<p><code>SHOW WARNINGS;</code> includes special markers which can deliver useful information, such as:</p>
<ul>
<li><code>&lt;index_lookup&gt;(query fragment)</code>: An index lookup would happen if the query had been properly parsed.</li>
<li><code>&lt;if&gt;(condition, expr1, expr2)</code>: An if condition is occurring in this specific part of the query.</li>
<li><code>&lt;primary_index_lookup&gt;(query fragment)</code>: An index lookup would be happening via primary key.</li>
<li><code>&lt;temporary table&gt;</code>: An internal table would be created here for saving temporary results — for example, in subqueries prior to joins.</li>
</ul>
<h2 id=""><a href="#">MySQL <code>EXPLAIN</code> join types<span aria-label="Permalink to MySQL ,[object Object], join types" role="complementary">#</span></a></h2>
<p>The MySQL manual says this column shows the <a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-join-types">“join type”</a>, which explains how tables are joined, but it’s really more accurate to say the &#34;access type&#34;. In other words, this “type” column lets us know how MySQL has decided to find rows in the table. Below are the most important access methods, from best to worst, in terms of performance:</p>
<table><thead><tr><th></th><th>Type value</th><th>Definition</th></tr></thead><tbody><tr><td><img alt="good performance indicator" srcset="/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fgreen-flag.png&amp;w=64&amp;q=75 1x, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fgreen-flag.png&amp;w=128&amp;q=75 2x" src="https://thomasbroadley.com/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fgreen-flag.png&amp;w=128&amp;q=75" width="50" height="50" decoding="async" data-nimg="1" loading="lazy"/></td><td><code>NULL</code></td><td>This access method means MySQL can resolve the query during the optimization phase and will not even access the table or index during the execution stage.</td></tr><tr><td><img alt="good performance indicator" srcset="/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fgreen-flag.png&amp;w=64&amp;q=75 1x, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fgreen-flag.png&amp;w=128&amp;q=75 2x" src="https://thomasbroadley.com/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fgreen-flag.png&amp;w=128&amp;q=75" width="50" height="50" decoding="async" data-nimg="1" loading="lazy"/></td><td><code>system</code></td><td>The table is empty or has one row.</td></tr><tr><td><img alt="good performance indicator" srcset="/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fgreen-flag.png&amp;w=64&amp;q=75 1x, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fgreen-flag.png&amp;w=128&amp;q=75 2x" src="https://thomasbroadley.com/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fgreen-flag.png&amp;w=128&amp;q=75" width="50" height="50" decoding="async" data-nimg="1" loading="lazy"/></td><td><code>const</code></td><td>The value of the column can be treated as a constant (there is one row matching the query) </td></tr><tr><td><img alt="good performance indicator" srcset="/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fgreen-flag.png&amp;w=64&amp;q=75 1x, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fgreen-flag.png&amp;w=128&amp;q=75 2x" src="https://thomasbroadley.com/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fgreen-flag.png&amp;w=128&amp;q=75" width="50" height="50" decoding="async" data-nimg="1" loading="lazy"/></td><td><code>eq_ref</code></td><td>The index is clustered and is being used by the operation (either the index is a <code>PRIMARY KEY</code> or <code>UNIQUE INDEX</code> with all key columns defined as <code>NOT NULL</code>)</td></tr><tr><td><img alt="good performance indicator" srcset="/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fgreen-flag.png&amp;w=64&amp;q=75 1x, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fgreen-flag.png&amp;w=128&amp;q=75 2x" src="https://thomasbroadley.com/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fgreen-flag.png&amp;w=128&amp;q=75" width="50" height="50" decoding="async" data-nimg="1" loading="lazy"/></td><td><code>ref</code></td><td>The indexed column was accessed using an equality operator </td></tr><tr><td><img alt="ok performance indicator" srcset="/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fyellow-flag.png&amp;w=64&amp;q=75 1x, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fyellow-flag.png&amp;w=128&amp;q=75 2x" src="https://thomasbroadley.com/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fyellow-flag.png&amp;w=128&amp;q=75" width="50" height="50" decoding="async" data-nimg="1" loading="lazy"/></td><td><code>fulltext</code></td><td>Operation (<code>JOIN</code>) is using the table’s fulltext index</td></tr><tr><td><img alt="ok performance indicator" srcset="/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fyellow-flag.png&amp;w=64&amp;q=75 1x, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fyellow-flag.png&amp;w=128&amp;q=75 2x" src="https://thomasbroadley.com/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fyellow-flag.png&amp;w=128&amp;q=75" width="50" height="50" decoding="async" data-nimg="1" loading="lazy"/></td><td><code>index</code></td><td>The entire index is scanned to find a match for the query </td></tr><tr><td><img alt="ok performance indicator" srcset="/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fyellow-flag.png&amp;w=64&amp;q=75 1x, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fyellow-flag.png&amp;w=128&amp;q=75 2x" src="https://thomasbroadley.com/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fyellow-flag.png&amp;w=128&amp;q=75" width="50" height="50" decoding="async" data-nimg="1" loading="lazy"/></td><td><code>range</code></td><td>A range scan is a limited index scan. It begins at some point in the index and returns rows that match a range of values. </td></tr><tr><td><img alt="bad performance indicator" srcset="/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fred-flag.png&amp;w=64&amp;q=75 1x, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fred-flag.png&amp;w=128&amp;q=75 2x" src="https://thomasbroadley.com/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fred-flag.png&amp;w=128&amp;q=75" width="50" height="50" decoding="async" data-nimg="1" loading="lazy"/></td><td><code>all</code></td><td>MySQL scans the entire table to satisfy the query</td></tr></tbody></table>
<blockquote>
<p>Note: Green flags indicate better performance, yellow flag indicates okay performance, and red flag indicates bad performance.</p>
</blockquote>
<p>There are also a few other types that you might want to be aware of:</p>
<ul>
<li>
<p><strong>index_merge</strong>: This join type indicates that the Index Merge optimization is used. In this case, the key column in the output row contains a list of indexes used. It indicates a query can make limited use of multiple indexes on a single table.</p>
</li>
<li>
<p><strong>unique_subquery</strong>: This type replaces <a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_eq_ref"><code>eq_ref</code></a> for some <code>IN</code> subqueries of the following form:</p>
<div data-rehype-pretty-code-fragment=""><div><pre><code><span><span>value</span><span> </span><span>IN</span><span> (</span><span>SELECT</span><span> primary_key </span><span>FROM</span><span> single_table </span><span>WHERE</span><span> some_expr)</span></span></code></pre></div></div>
</li>
<li>
<p><strong>index_subquery</strong>: This join type is similar to <a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_unique_subquery">unique_subquery</a>. It replaces <code>IN</code> subqueries, but it works for nonunique indexes in subqueries.</p>
</li>
</ul>
<h2 id=""><a href="#">The <code>EXTRA</code> column in MySQL <code>EXPLAIN</code><span aria-label="Permalink to The ,[object Object], column in MySQL ,[object Object]" role="complementary">#</span></a></h2>
<p>The <code>EXTRA</code> column in a MySQL <code>EXPLAIN</code> output contains extra information that doesn’t fit into other columns. The most important values you might frequently run into are as follows:</p>
<table><thead><tr><th><code>EXTRA</code> column value</th><th>Definition</th></tr></thead><tbody><tr><td>Using index</td><td>Indicates that MySQL will use a covering index to avoid accessing the table.</td></tr><tr><td>Using where</td><td>The MySQL server will post-filter rows after the storage engine retrieves them.</td></tr><tr><td>Using temporary</td><td>MySQL will use a temporary table while sorting the query’s result</td></tr><tr><td>Using filesort</td><td>MySQL will use an external sort to order the results, instead of reading the rows from the table in index order. MySQL has two filesort algorithms. Either type can be done in memory or on disk. EXPLAIN doesn’t tell you which type of filesort MySQL will use, and it doesn’t tell you whether the sort will be done in memory or on disk.</td></tr><tr><td>“Range checked for each record”</td><td>(index map:N). This value means there’s no good index, and the indexes will be reevaluated for each row in a join. N is a bitmap of the indexes shown in possible_keys and is redundant.</td></tr><tr><td>Using index condition</td><td>Tables are read by accessing index tuples and testing them first to determine whether to read full table rows.</td></tr><tr><td>Backward index scan</td><td>MySQL uses a descending index to complete the query</td></tr><tr><td>const row not found</td><td>The queried table was empty</td></tr><tr><td>Distinct</td><td>MySQL is scouring the database for any distinct values that might appear in the column</td></tr><tr><td>No tables used</td><td>The query has no <code>FROM</code> clause</td></tr><tr><td>Using index for group-by</td><td>MySQL was able to use a certain index to optimize <code>GROUP BY</code> operations</td></tr></tbody></table>
<h2 id=""><a href="#">Hands-on example of how to use MySQL <code>EXPLAIN</code><span aria-label="Permalink to Hands-on example of how to use MySQL ,[object Object]" role="complementary">#</span></a></h2>
<p>In this section, we will explore one way you can utilize MySQL <code>EXPLAIN</code> for query optimizations. To start, I created a database in PlanetScale and seeded it using the <a href="https://dev.mysql.com/doc/employee/en/">MySQL Employees Sample Database</a>.</p>
<div><p><strong>Tip</strong></p><div><p>PlanetScale is a serverless, hosted MySQL database platform that makes it easy to spin up a database, connect to your application, and get running quickly. With PlanetScale, you can <a href="https://thomasbroadley.com/docs/concepts/branching">create branches to test schema changes</a> before deploying to production. This development environment, paired with some of our other tools, like <a href="https://thomasbroadley.com/docs/concepts/query-insights">Insights for query monitoring</a>, gives you a great way to test and debug queries, leading to better performance and faster application.</p><p><a href="https://auth.planetscale.com/sign-up">Sign up for a free account</a>.</p></div></div>
<p><img alt="Employees schema" sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw" srcset="/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Femployees-schema.png&amp;w=256&amp;q=75 256w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Femployees-schema.png&amp;w=384&amp;q=75 384w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Femployees-schema.png&amp;w=640&amp;q=75 640w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Femployees-schema.png&amp;w=768&amp;q=75 768w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Femployees-schema.png&amp;w=1024&amp;q=75 1024w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Femployees-schema.png&amp;w=1280&amp;q=75 1280w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Femployees-schema.png&amp;w=1536&amp;q=75 1536w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Femployees-schema.png&amp;w=3840&amp;q=75 3840w" src="https://thomasbroadley.com/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Femployees-schema.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="fill" loading="lazy"/></p><h3>Confirm that the database is created and seeded</h3>
<p>Now that we have our database let’s run some queries.</p>
<p>First, we’ll want to confirm that our tables are in PlanetScale. We can do this by running <code>SHOW TABLES;</code> in the <a href="https://thomasbroadley.com/features/cli">PlanetScale CLI</a> or web UI. For this example, I will be utilizing our web UI.</p>
<p><img alt="Running show tables in the Web UI" sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw" srcset="/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Frunning-show-tables-web-ui.png&amp;w=256&amp;q=75 256w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Frunning-show-tables-web-ui.png&amp;w=384&amp;q=75 384w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Frunning-show-tables-web-ui.png&amp;w=640&amp;q=75 640w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Frunning-show-tables-web-ui.png&amp;w=768&amp;q=75 768w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Frunning-show-tables-web-ui.png&amp;w=1024&amp;q=75 1024w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Frunning-show-tables-web-ui.png&amp;w=1280&amp;q=75 1280w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Frunning-show-tables-web-ui.png&amp;w=1536&amp;q=75 1536w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Frunning-show-tables-web-ui.png&amp;w=3840&amp;q=75 3840w" src="https://thomasbroadley.com/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Frunning-show-tables-web-ui.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="fill" loading="lazy"/></p><h3>Run the initial query</h3>
<p>Using a multi-column index coupled with MySQL <code>EXPLAIN</code>, we will provide a way to store values for multiple columns in a single index, allowing the database engine to more quickly and efficiently execute queries using the set of columns together.</p>
<p>Queries that are great candidates for performance optimization often use multiple conditions in the <code>WHERE</code> filtering clause. An example of this kind of query is asking the database to find a person by both their first and last name:</p>
<div data-rehype-pretty-code-fragment=""><div><pre><code><span><span> </span><span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> employees </span><span>WHERE</span><span> last_name </span><span>=</span><span> </span><span>&#39;Puppo&#39;</span><span> </span><span>AND</span><span> first_name </span><span>=</span><span> </span><span>&#39;Kendra&#39;</span><span>;</span></span></code></pre></div></div>
<p><img alt="Select * from employees" sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw" srcset="/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fselect-from-employees2.png&amp;w=256&amp;q=75 256w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fselect-from-employees2.png&amp;w=384&amp;q=75 384w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fselect-from-employees2.png&amp;w=640&amp;q=75 640w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fselect-from-employees2.png&amp;w=768&amp;q=75 768w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fselect-from-employees2.png&amp;w=1024&amp;q=75 1024w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fselect-from-employees2.png&amp;w=1280&amp;q=75 1280w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fselect-from-employees2.png&amp;w=1536&amp;q=75 1536w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fselect-from-employees2.png&amp;w=3840&amp;q=75 3840w" src="https://thomasbroadley.com/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fselect-from-employees2.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="fill" loading="lazy"/></p><p>Okay, so we know that this result isn’t ideal because it’s scanning 299,202 rows to complete the request, as shown under <code>rows</code> in the screenshot above. How do we go about optimizing it? We have a few different routes we can take, but only one is ideal for cost and performance.</p>
<h3>Optimization approach 1: Create two individual indexes</h3>
<p>For our first approach, let&#39;s create two individual indexes — one on the <code>last_name</code> column and another on the <code>first_name</code> column.</p>
<p>This may seem like an ideal route at first, but there&#39;s a problem.</p>
<p>If you create two separate indexes in this way, MySQL knows how to find all employees named <code>Puppo</code>. It also knows how to find all employees named <code>Kendra</code>. However, it doesn&#39;t know how to find people named <code>Kendra Puppo</code>.</p>
<p>Some other things to keep in mind:</p>
<ul>
<li>MySQL has choices available when dealing with multiple disjointed indexes and a query asking for more than one filtering condition.</li>
<li>MySQL supports <a href="https://dev.mysql.com/doc/refman/8.0/en/index-merge-optimization.html">Index Merge optimizations</a> to use multiple indexes jointly when running a query. However, this limitation is a good rule of thumb when building indexes. MySQL may decide not to use multiple indexes; even if it does, in many scenarios, they won’t serve the purpose as well as a dedicated index.</li>
</ul>
<h3>Optimization approach 2: Use a multi-column index</h3>
<p>Because of the issues with the first approach, we know we need to find a way to use indexes that consider many columns in this second approach. We can do this with a multi-column index.</p>
<p>You can imagine this as a phone book placed inside another. First, you look up the last name <code>Puppo</code>, leading you to the second catalog for all the people named <code>Kendra</code>, organized alphabetically by first names, which you can use to find <code>Kendra</code> quickly.</p>
<p>In MySQL, to create a multi-column index for last names and first names in the <code>employees</code> table, execute the following:</p>
<div data-rehype-pretty-code-fragment=""><div><pre><code><span><span>CREATE</span><span> </span><span>INDEX</span><span> </span><span>fullnames</span><span> </span><span>ON</span><span> employees(last_name, first_name);</span></span></code></pre></div></div>
<p><img alt="Create index" sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw" srcset="/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fcreate-index.png&amp;w=256&amp;q=75 256w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fcreate-index.png&amp;w=384&amp;q=75 384w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fcreate-index.png&amp;w=640&amp;q=75 640w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fcreate-index.png&amp;w=768&amp;q=75 768w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fcreate-index.png&amp;w=1024&amp;q=75 1024w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fcreate-index.png&amp;w=1280&amp;q=75 1280w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fcreate-index.png&amp;w=1536&amp;q=75 1536w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fcreate-index.png&amp;w=3840&amp;q=75 3840w" src="https://thomasbroadley.com/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fcreate-index.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="fill" loading="lazy"/></p><p>Now that we have successfully created an index, we will issue the <code>SELECT</code> query to find rows with the first name matching <code>Kendra</code> and the last name matching <code>Puppo</code>. The result is a single row with an employee named <code>Kendra Puppo</code>.</p>
<p>Now, use the <code>EXPLAIN</code> query to check whether the index was used:</p>
<p><img alt="Select from employees with index" sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw" srcset="/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fselect-from-employees-index.png&amp;w=256&amp;q=75 256w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fselect-from-employees-index.png&amp;w=384&amp;q=75 384w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fselect-from-employees-index.png&amp;w=640&amp;q=75 640w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fselect-from-employees-index.png&amp;w=768&amp;q=75 768w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fselect-from-employees-index.png&amp;w=1024&amp;q=75 1024w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fselect-from-employees-index.png&amp;w=1280&amp;q=75 1280w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fselect-from-employees-index.png&amp;w=1536&amp;q=75 1536w, /_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fselect-from-employees-index.png&amp;w=3840&amp;q=75 3840w" src="https://thomasbroadley.com/_next/image?url=%2Fimages%2Fblog%2Fcontent%2Fmysql-explains%2Fselect-from-employees-index.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="fill" loading="lazy"/></p><p>These results show that the index was used, and <strong>only one row</strong> was accessed to fulfill this request. This is much better than the <strong>299,202 rows</strong> we needed to access before the index.</p>
<h2 id="conclusion"><a href="#conclusion">Conclusion<span aria-label="Permalink to Conclusion" role="complementary">#</span></a></h2>
<p>The <code>EXPLAIN</code> statement in MySQL can be used to obtain information about query execution. It is valuable when designing schemas or indexes and ensuring that our database can use the features provided by MySQL to the greatest extent possible.</p>
<p>In PlanetScale, our <a href="https://thomasbroadley.com/blog/arewefastyet-query-optimization-with-insights">Insights feature</a> + <code>EXPLAIN</code> statement in MySQL can be of massive assistance when you need to optimize the performance of your queries.</p>
</div></section></article></div>
  </body>
</html>
