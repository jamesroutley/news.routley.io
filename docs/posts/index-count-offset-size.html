<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tigerbeetle.com/blog/2026-02-16-index-count-offset-size/">Original</a>
    <h1>Index, Count, Offset, Size</h1>
    
    <div id="readability-page-1" class="page"><div><p>Wherein we make progress towards solving one of the most vexing
problems of Computer Science — naming things.</p>
<p>I am at a point in my career where the bulk of my bugs are stupid — I
simply fail to type in the code I have in my mind correctly. In
languages with shadowing (like Rust), I will fail to use a shadowed
variable from the outer scope. In languages without shadowing (like
Zig), I will use the wrong version of a variable.</p>
<p>Pests like these are annoying, so I am always on the lookout for
tricks to minimize the probability of bugs. One of the best possible
tricks is of course strong static typing. Types are good at preventing
me from doing stupid things by accident. But types have limitations. The
text of a well-typed program is a two-in-one artifact — a specification
of behavior of a machine (the algorithm), and a proof that the behavior
is not unacceptable. Zero cost abstractions are code without behavior,
just proofs!</p>
<p>The art of skillful typing lies in minimizing verbosity of the proof,
while maximizing the amount of unwanted behaviors ruled out, weighted by
the probability and the cost of misbehavior. But this ratio is not
always favorable — the code can be so proof-heavy that it becomes
impossible to understand what it actually <em>does</em>!</p>
<p>There’s one particular cranny where types don’t seem to usefully
penetrate yet: indexing and associated off-by-one errors.</p>
<p>If you don’t need indexing <em>arithmetic</em>, you can use <a href="https://matklad.github.io/2025/12/23/zig-newtype-index-pattern.html">newtype
pattern</a> to prevent accessing oranges with apple-derived indexes. You
can even go further and bind indexes to <em>specific</em> arrays, using,
e.g., <a href="https://faultlore.com/blah/papers/thesis.pdf#page=56">Gankra
trick</a>, but I haven’t seen that to be useful in practice.</p>
<p>If, however, you <em>compute</em> indexes, you need to be extra
careful to stay in bounds of an array, and need to be mindful that the
maximum valid index is one less than the length of the array. While we
don’t solve this problem perfectly at TigerBeetle, I think we have a
naming convention that helps:</p>
<figure>
    
</figure>

<p>Thanks <a href="https://ziggit.dev/t/a-rare-bug-in-audio-code-by-zig-s-creator-can-you-find-it/11366/6">@marler8997</a>
for the illustration idea!</p>
<p>We consistently use <code>count</code> whenever we talk about the
number of items, and <code>index</code> to point to a particular item.
The <a href="https://github.com/tigerbeetle/tigerbeetle/blob/0.16.73/docs/TIGER_STYLE.md#:~:text=State%20invariants%20positively">positive
invariant</a> is <code>index &lt; count</code>. Consistency is the trick
— there are certain valid and invalid ways to combine indexes and counts
in an expression, and, if there’s always an <code>_index</code> or a
<code>_count</code> suffix in the name, wrong combinations immediately
jump out at you, dear reader, even if you don’t understand the specifics
of the code.</p>
<p>In low-level code you often need to switch between a well-typed
representation <code>[]T</code>and raw bytes <code>[]u8</code>. To not
confuse the two index spaces, the “count of bytes” is always called a
<code>size</code>. By definition,</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>size <span>=</span> <span>@sizeOf</span>(T) <span>*</span> count;</span></code></pre></div>
<p>And <code>offset</code> is the bytewise counterpart of
<code>index</code>.</p>
<p>We don’t use <code>length</code> in our code, as its meaning is
ambiguous. Rust <code>str::len</code> is the byte-<code>size</code> of
the string, but Python’s <code>len(str)</code> is the <code>count</code>
of Unicode code-points!</p>
<p>Here’s an example of the naming convention in action from <a href="https://github.com/tigerbeetle/tigerbeetle/blob/0cd32077bff00b15b83b3417bf700ecb0c888f78/src/lsm/node_pool.zig#L70-L82">NodePool</a>:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>fn</span> release(pool<span>:</span> <span>*</span>NodePool<span>,</span> node<span>:</span> Node) <span>void</span> <span>{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span>comptime</span> <span>assert</span>(meta<span>.</span>Elem(Node) <span>==</span> <span>u8</span>);</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span>comptime</span> <span>assert</span>(meta<span>.</span>Elem(<span>@TypeOf</span>(pool<span>.</span>buffer)) <span>==</span> <span>u8</span>);</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span>assert</span>(@intFromPtr(node) <span>&gt;=</span> @intFromPtr(pool<span>.</span>buffer<span>.</span>ptr));</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span>assert</span>(</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        @intFromPtr(node) <span>+</span> node_size <span>&lt;=</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>            @intFromPtr(pool<span>.</span>buffer<span>.</span>ptr) <span>+</span> pool<span>.</span>buffer<span>.</span>len</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    );</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span>const</span> node_offset <span>=</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        @intFromPtr(node) <span>-</span> @intFromPtr(pool<span>.</span>buffer<span>.</span>ptr);</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span>const</span> node_index <span>=</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        <span>@divExact</span>(node_offset<span>,</span> node_size);</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span>assert</span>(<span>!</span>pool<span>.</span>free<span>.</span>isSet(node_index));</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    pool<span>.</span>free<span>.</span>set(node_index);</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>You can see that the <code>node_index</code> calculation is correct
mechanically, just from the names of the variables.</p>
<p>And here’s an <code>index/count</code> example from our <a href="https://github.com/tigerbeetle/tigerbeetle/blob/81f78fe21a939ed1bffc43a10a484779e3866cf9/src/ewah.zig#L68-L95"><code>ewah</code></a>
implementation:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>fn</span> decode(</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    source<span>:</span> []<span>align</span>(<span>@alignOf</span>(Word)) <span>const</span> <span>u8</span><span>,</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    target_words<span>:</span> []Word<span>,</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>) <span>usize</span> <span>{</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span>assert</span>(source<span>.</span>len <span>%</span> <span>@sizeOf</span>(Word) <span>==</span> <span>0</span>);</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span>assert</span>(disjoint_slices(<span>u8</span><span>,</span> Word<span>,</span> source<span>,</span> target_words));</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span>const</span> source_words <span>=</span> mem<span>.</span>bytesAsSlice(Word<span>,</span> source);</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span>var</span> source_index<span>:</span> <span>usize</span> <span>=</span> <span>0</span>;</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span>var</span> target_index<span>:</span> <span>usize</span> <span>=</span> <span>0</span>;</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span>while</span> (source_index <span>&lt;</span> source_words<span>.</span>len) <span>{</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span>const</span> marker<span>:</span> <span>*</span><span>const</span> Marker <span>=</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>            <span>@ptrCast</span>(<span>&amp;</span>source_words[source_index]);</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        source_index <span>+=</span> <span>1</span>;</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        <span>@memset</span>(</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>            target_words[target_index<span>..</span>][<span>0</span><span>..</span>marker<span>.</span>uniform_word_count]<span>,</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>            <span>if</span> (marker<span>.</span>uniform_bit <span>==</span> <span>1</span>) <span>~</span><span>@as</span>(Word<span>,</span> <span>0</span>) <span>else</span> <span>0</span><span>,</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        );</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        target_index <span>+=</span> marker<span>.</span>uniform_word_count;</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        stdx<span>.</span>copy_disjoint(</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>            <span>.</span>exact<span>,</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>            Word<span>,</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>            target_words[target_index<span>..</span>][<span>0</span><span>..</span>marker<span>.</span>literal_word_count]<span>,</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>            source_words[source_index<span>..</span>][<span>0</span><span>..</span>marker<span>.</span>literal_word_count]<span>,</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>        );</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>        source_index <span>+=</span> marker<span>.</span>literal_word_count;</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>        target_index <span>+=</span> marker<span>.</span>literal_word_count;</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>    <span>assert</span>(source_index <span>==</span> source_words<span>.</span>len);</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>    <span>assert</span>(target_index <span>&lt;=</span> target_words<span>.</span>len);</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>    <span>return</span> target_index;</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Note well that the <code>index/count</code> convention synergizes
with two other TigerStyle shticks. We use “big endian naming”, where
qualifiers are appended as suffixes:</p>
<pre><code>source
source_words
source_index</code></pre>
<p>And we try to make sure that dual names have the same length:</p>
<pre><code>source
target</code></pre>
<p>The code aligns itself, and makes the bugs pop out:</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>source_index <span>+=</span> marker<span>.</span>literal_word_count;</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>target_index <span>+=</span> marker<span>.</span>literal_word_count;</span></code></pre></div>
<p>Of course, a simple naming convention by itself won’t make software
significantly better. But grains of sand add up to Dune: there’s no one
trick to get rid of the bugs, but you can layer your defenses to
exponentially decrease the probability of a failure.</p>
  </div></div>
  </body>
</html>
