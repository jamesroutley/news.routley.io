<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.synopse.info/?post/2022/11/26/Modern-Pascal-is-Still-in-the-Race">Original</a>
    <h1>Modern Pascal is still in the race (2022)</h1>
    
    <div id="readability-page-1" class="page"><div><p>A recent poll <a href="https://forum.lazarus.freepascal.org/index.php/topic,61276.0.html">on the Lazarus/FPC forum</a> highlighted a fact: pascal coders are older than most coders. Usually, at our age, we should be managers, not developers. But we like coding in pascal. It is still fun after decades!</p>


<p><img src="https://blog.synopse.info/public/blog/performance.jpg" alt=""/></p>


<p>And a recent thread <a href="https://forum.lazarus.freepascal.org/index.php/topic,61035.0.html">in this very same forum</a> was about comparing languages to implement a REST server, in C#, Go, Scala, TypeScript, Elixir and Rust.</p></div><div><h4>The Challenge and the Algorithms</h4>


<p>The original challenge is available at <a href="https://github.com/losvedir/transit-lang-cmp">transit-lang-cmp</a> with the original source code, of all those fancy languages and libraries.</p>


<p>In practice, the goal of this test program is to load two big CSVs into memory (80MB + 2MB), then serve over HTTP some JSON generated by route identifiers, joining both CSVs.</p>


<p>To be fair, a regular/business coder would have used a database for this. Not silly memory structures. And asked for money to setup a huge set of cloud machines with load balancing. <img src="https://blog.synopse.info?pf=smile.svg" alt=":-)"/></p>


<h4>Reference Implementations in Today Languages</h4>


<p>The &#34;modern&#34; / &#34;school&#34; approach, as implemented in the reference project in Go/Rust/C#/... is using two lists for the CSVs data, then two maps/dictionaries between route ID and lists indexes.</p>

<ul>
<li>The <a href="https://github.com/losvedir/transit-lang-cmp/blob/main/trogsit/app.go">Golang version</a> has a good expressiveness, and is nice to read, even if you don&#39;t know the language.</li>
<li>The <a href="https://github.com/losvedir/transit-lang-cmp/tree/main/Trannet">C# version</a> is also readable, but making a webserver is still confusing because it is not built from code, but from config files.</li>
<li><a href="https://github.com/losvedir/transit-lang-cmp/tree/main/trexit">Elixir</a> is a bit over-complicated to my taste.</li>
<li><a href="https://github.com/losvedir/transit-lang-cmp/tree/main/trala">Scala</a> and <a href="https://github.com/losvedir/transit-lang-cmp/tree/main/trypsit">TypeScript/Deno</a> versions, are fine to read, but really slow. You may better use a database instead.</li>
<li>Just for fun, check <a href="https://github.com/losvedir/transit-lang-cmp/blob/main/trustit/src/main.rs">the Rust version</a> - do you think Rust is good for big maintainable projects with junior developers?</li>
</ul>


<p>There was a first attempt to write a FPC version of it, by Leledumbo.</p>


<p>So is Pascal out of the race?</p>


<h4>Following the mORMot Way</h4>


<p>For the <em>mORMot</em> version in FPC, I used another approach, with two diverse algorithms:</p>

<ul>
<li>I ensured the lists were sorted in memory, then made a O(log(n)) binary lookup in it;</li>
<li>All stored strings were &#34;interned&#34;, i.e. the same text was sharing a single string instance, and FPC reference counting did its magic.</li>
</ul>


<p>There is no low-level tricks like generating the JSON by hand or using complex data structures - data structures are still are high-level, with readable field names and such. The logic and the intent are clearly readable.</p>


<p>Please <a href="https://github.com/synopse/mORMot2/tree/master/ex/lang-cmp/LangCmp.dpr">check the source code in our repository</a>.</p>


<p>As a result:</p>

<ul>
<li>Code is still readable, short and efficient (most of the process is done by <em>mORMot</em>, i.e. CSV, searching, JSON);</li>
<li>It uses much less memory - 10 times less memory than Go when holding the data, 5 times less memory than Go when serving the data;</li>
<li>Performance is as fast as Go, and its very tuned/optimized compiler and RTL.</li>
</ul>


<p><img src="https://blog.synopse.info/public/blog/mORMot2-small.png" alt=""/></p>


<h4>Algorithms Matters</h4>


<p>Main idea was to let the algorithms match the input data and the expected resultset.</p>

<ul>
<li>The source code is still pretty readable, thanks to using <em>mORMot</em> efficient <code>TDynArray</code> to map the dynamic array storage, and its CSV and JSON abilities.</li>
<li>I guess source is still understandable for out-of-school programmers - much more readable than Rust for instance.</li>
</ul>


<p>To by fair, I used typed pointers in <code>TScheduler.BuildTripResponse</code> but it is not so hard getting their purpose, and FPC compiles this function into very efficient assembly. I could have used regular dynamic array access with indexes, it would have been slightly slower, but not really easier to follow, nor safer (if we compile with no range checking).</p>


<p>Worth noting that we did not make any specific tuning, like pre-allocating the results with constants, as other frameworks did. We just specified the data, then let <em>mORMot</em> play with it - that&#39;s all.</p>


<h4>Give Me Some Numbers</h4>


<p>Here are a performance comparison with Go (FPC on the left, Go on the right):</p>

<pre>parsed 1790905 stop times in 968.43ms                         | parsed 1790905 stop times in 3.245251432s
parsed 71091 trips in 39.54ms                                 | parsed 71091 trips in 85.747852ms

running (0m33.4s), 00/50 VUs, 348 complete and 0 interrupted  | running (0m32.3s), 00/50 VUs, 320 complete and 0 interrupted
default ✓ [======================================] 50 VUs  30   default ✓ [======================================] 50 VUs  30

     data_received..................: 31 GB  933 MB/s         |      data_received..................: 31 GB  971 MB/s
     data_sent......................: 3.2 MB 97 kB/s          |      data_sent......................: 3.0 MB 92 kB/s
     http_req_blocked...............: avg=9µs     min=1.09µs  |      http_req_blocked...............: avg=6.77µs  min=1.09µs
     http_req_connecting............: avg=2.95µs  min=0s      |      http_req_connecting............: avg=1.73µs  min=0s     
     http_req_duration..............: avg=47.59ms min=97.28µs |      http_req_duration..............: avg=49.02ms min=123.81µ
       { expected_response:true }...: avg=47.59ms min=97.28µs |        { expected_response:true }...: avg=49.02ms min=123.81µ
     http_req_failed................: 0.00%  ✓ 0           ✗  |      http_req_failed................: 0.00%  ✓ 0          ✗ 3
     http_req_receiving.............: avg=9.66ms  min=15.35µs |      http_req_receiving.............: avg=5.92ms  min=14.76µs
     http_req_sending...............: avg=87.24µs min=5.2µs   |      http_req_sending...............: avg=70.71µs min=5.2µs 
     http_req_tls_handshaking.......: avg=0s      min=0s      |      http_req_tls_handshaking.......: avg=0s      min=0s     
     http_req_waiting...............: avg=37.83ms min=54.74µs |      http_req_waiting...............: avg=43.02ms min=91.84µs
     http_reqs......................: 34452  1032.205528/s    |      http_reqs......................: 31680  981.949476/s
     iteration_duration.............: avg=4.72s   min=3.54s   |      iteration_duration.............: avg=4.86s   min=2.19s 
     iterations.....................: 348    10.426318/s      |      iterations.....................: 320    9.918682/s
     vus............................: 30     min=30        ma |      vus............................: 15     min=15       max
     vus_max........................: 50     min=50        ma |      vus_max........................: 50     min=50       max
</pre>


<p>So CSV loading was much faster, then the HTTP server performance was almost the same.</p>


<h4>No Alzheimer</h4>


<p>Here are some numbers about memory consumption:</p>


<blockquote><p>Upon finished loading the CSV, mORMot only eats 80MB, heck so little. Sounds a bit magical. But during load test, it fluctuates between 250-350MB, upon which it returns to 80MB at the end.
The Go version eats 925MB upon finished loading the CSV. During load test, it tops at 1.5GB, returning to 925MB afterwards.</p></blockquote>


<p>Nice to read. :)</p>


<h4>Pascal has a Modern and Capable Ecosystem</h4>


<p>This article was not only about Pascal, but about algorithms and libraries.</p>


<p><strong>And... Pascal is still in the race for sure!</strong></p>


<p>The more we spread such kind of information, the less people would make jokes about pascal programmers.</p></div></div>
  </body>
</html>
