<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.braintrust.dev/blog/async-programming">Original</a>
    <h1>The rise of async AI programming</h1>
    
    <div id="readability-page-1" class="page"><div>
<p><span>19 August 2025</span><span>Ankur Goyal</span></p>
<p>I spend a decent amount of time reviewing code I didn&#39;t write. An AI agent takes a detailed problem description, writes code (primarily Typescript, Rust, and Python), adds tests, and commits the changes to a branch. I tap back in when everything&#39;s ready for review.</p>
<p>This used to feel like a futuristic scenario, but it&#39;s how I work now, and it&#39;s how many developers are starting to work. The shift is subtle but powerful: instead of writing code line by line, we&#39;re learning to describe problems clearly and let tools solve them in the background.</p>

<p>This version of &#34;async programming&#34; is different from the classic definition. It&#39;s about how developers approach building software.</p>
<p>The workflow looks like this:</p>
<ol>
<li><strong>Define the problem clearly.</strong> Write a detailed specification of what needs to be built, including edge cases, constraints, and success criteria.</li>
<li><strong>Hand it off.</strong> Delegate the implementation to an AI agent, a teammate, or even your future self with comprehensive notes.</li>
<li><strong>Return later.</strong> Come back to review results, provide feedback, and decide on next steps.</li>
</ol>
<p>The key difference from traditional programming is the time separation between problem definition and implementation. Instead of immediate feedback loops, you have background problem solving driven by clear requirements and automated verification.</p>
<p>Async programming is not <em>vibe coding</em>. Vibe coding enables you to write code without getting into the nitty gritty details. Async programming is a workflow for developers to solve more complex problems simultaneously, while still understanding the details
of the code being written. You&#39;re still architecting solutions, reviewing implementations, and maintaining a codebase. You&#39;re just not typing a vast majority of characters yourself.</p>

<p>For async programming to work in practice, you need three things: a clear definition of the problem you&#39;re solving, a way to automatically verify your results, and human-driven code review.</p>
<h3 id="1-clear-problem-definitions"><a data-card="" href="#1-clear-problem-definitions">1. Clear problem definitions</a><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-label="Link to section"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></h3>
<p>The quality of your problem statement determines everything else. Vague requirements produce vague results. Precise specifications produce working code.</p>
<p>Here&#39;s the difference:</p>
<p><strong>Vague:</strong> &#34;Make the search faster&#34;</p>
<p><strong>Precise:</strong> &#34;My goal is to reduce search latency from about 800ms to around 200ms. I suspect the root cause is the heap allocation I&#39;m doing on each batch of rows. Can you try refactoring the allocation to happen once per search, instead, and measure the impact?&#34;</p>
<p>The precise version includes the current state, target outcome, proposed approach, and acceptance criteria. An AI agent (or human teammate) can work independently because the requirements are unambiguous.</p>
<p>Effective async programming specs read like technical documentation: they include context, constraints, examples, and explicit success criteria. If you can&#39;t explain the problem clearly, you probably don&#39;t understand it well enough to delegate it.</p>
<h3 id="2-automated-verification"><a data-card="" href="#2-automated-verification">2. Automated verification</a><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-label="Link to section"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></h3>
<p>Async programming only works if you can verify results without manual testing every edge case. You need systems that can check the work automatically.</p>
<p>This might include:</p>
<ul>
<li><strong>Unit and integration tests</strong> that validate core functionality</li>
<li><strong>Type checking</strong> that catches interface mismatches</li>
<li><strong>Performance benchmarks</strong> that ensure code meets speed requirements</li>
<li><strong>Linting and formatting</strong> that enforce style guidelines</li>
</ul>
<p>The goal is developing a process that agents can use to validate their work independently. This takes time. You&#39;ll provide significant guidance initially, then develop patterns that allow agents to work autonomously. Setting this up in CI is challenging but enables background agents to perform work outside your development environment.</p>
<h3 id="3-detailed-code-review"><a data-card="" href="#3-detailed-code-review">3. Detailed code review</a><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-label="Link to section"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></h3>
<p>Once you&#39;re not typing every character yourself, code review becomes absolutely crucial. I regularly find PRs that solve the completely wrong problem, make poor design decisions, or have large amounts of code duplication.</p>
<p>Reviewing AI-generated code is valuable, similar to traditional code review. Expect to spend significantly more time on code review than before.</p>
<p>The code may not be yours line by line, but the system design and technical decisions should still reflect your judgment.</p>

<p>My workflow has changed since adopting async programming. I now work on four or five tasks simultaneously: one complex problem synchronously and three or four in the background. When I context switch, I review in-progress work on each background task, provide guidance, and return to synchronous work or code review.</p>

<p>We&#39;ve been using async programming to build Braintrust itself, and now we&#39;re building tools to translate these ideas to AI engineering.</p>
<p>Traditional prompt engineering is manual. You write a prompt, test it against examples, observe failures, make small adjustments, and repeat. The process requires expertise but involves significant iteration.</p>
<p>Our agent, Loop, lets you describe the evaluation problem you&#39;re trying to solve and spends time in the background analyzing experiment results, identifying patterns in failed test cases, and suggesting improvements to prompts, datasets, and scorers.</p>

<p>The implications of working this way are still emerging. This changes what I optimize for as a developer: less time on IDE shortcuts and typing speed, more time explaining problems clearly and reviewing solutions thoroughly.</p>
<p>The implementation work can happen in parallel with other thinking. More developers will likely adopt this approach as tools improve. AI isn&#39;t replacing programming, but the most valuable parts of programming are becoming more prominent while routine tasks move to the background.</p></div></div>
  </body>
</html>
