<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.grisp.org/blog/posts/2025-10-07-jit-arm32.3">Original</a>
    <h1>Erlang ARM32 JIT is born</h1>
    
    <div id="readability-page-1" class="page"><div data-v-39a288b8=""><div data-v-39a288b8=""><div><p><em>A blog series recounting our adventures in the quest to port the BEAM JIT to the ARM32-bit architecture.</em></p><p><em>This work is made possible thanks to funding from the <a href="https://www.erlef.org" target="_blank" rel="noreferrer">Erlang Ecosystem Foundation</a> and the ongoing support of its <a href="https://www.erlef.org/wg/embedded" target="_blank" rel="noreferrer">Embedded Working Group</a>.</em></p><p><img src="https://www.grisp.org/images/blog/eef-logo.svg" alt="EEF Logo" width="100px"/></p><hr/><p>This week we finally achieved our first milestone in developing the ARM32 JIT. We executed our first Erlang function through JITted ARM32 machine code!</p><div><p><span>shell</span></p><pre tabindex="0"><code><span><span>    ~/arm32-jit$</span><span> qemu-arm</span><span> -L</span><span> /usr/arm-linux-gnueabihf</span><span> ./otp/RELEASE/erts-15.0/bin/beam.smp</span><span> -S</span><span> 1:1</span><span> -SDcpu</span><span> 1:1</span><span> -SDio</span><span> 1</span><span> -JDdump</span><span> true</span><span> -JMsingle</span><span>     true</span><span> --</span><span> -root</span><span> /home/arm32-jit/otp/RELEASE</span><span> -progname</span><span> erl</span><span> -home</span><span> /home</span></span>
<span><span>    ~/arm32-jit$</span><span> echo</span><span> $?</span></span>
<span><span>    42</span></span></code></pre></div><p>The BEAM successfully runs and terminates with error code 42! That 42 comes from an Erlang function, just-in-time compiled by our ARM32 JIT!</p><p>Announcement is done! All code is available at <a href="https://github.com/stritzinger/otp/tree/arm32-jit" target="_blank" rel="noreferrer">https://github.com/stritzinger/otp/tree/arm32-jit</a></p><p>Keep reading for a lot of interesting details!</p><h2 id="the-first-piece-of-erlang-code" tabindex="-1">The first piece of Erlang code <a href="#the-first-piece-of-erlang-code" aria-label="Permalink to &#34;The first piece of Erlang code&#34;">​</a></h2><div><p><span>erlang</span></p><pre tabindex="0"><code><span><span>-</span><span>module</span><span>(</span><span>hello</span><span>).</span></span>
<span><span>-</span><span>export</span><span>([</span><span>start</span><span>/</span><span>2</span><span>]).</span></span>
<span></span>
<span><span>start</span><span>(_BootMod, _BootArgs) </span><span>-&gt;</span></span>
<span><span>    halt</span><span>(</span><span>42</span><span>, [{</span><span>flush</span><span>, </span><span>false</span><span>}]).</span></span></code></pre></div><p>This is <code>hello.erl</code> that contains a <code>start/2</code> function. The function head mimics the <code>erl_init:start/2</code> function, which is the entry point of the first Erlang process. We replaced <code>erl_init:start/2</code> with <code>hello:start/2</code> in the <code>erl_init.c</code> module of the BEAM VM. This way, we forced the runtime to execute this Erlang function.</p><p><code>hello:start/2</code> is very simple as it just calls the <code>erlang:halt/2</code>. This function is a <strong>BIF</strong> (Built-in Function) that executes C code, part of the BEAM VM. This code executes an ordered shutdown of the BEAM and allows us to customize the error code, in this case: <code>42</code>.</p><p>(Why <code>{flush, false}</code>? At the time I am writing this, letting it be true causes a segmentation fault EHEH)</p><p>Obviously, we need to compile this Erlang module, but I will also generate the BEAM assembly so we can have a look at what we will have to deal with.</p><div><p><span>erlang</span></p><pre tabindex="0"><code><span><span>{</span><span>module</span><span>, </span><span>hello</span><span>}.  </span><span>%% version = 0</span></span>
<span><span>{</span><span>exports</span><span>, [{</span><span>module_info</span><span>,</span><span>0</span><span>},{</span><span>module_info</span><span>,</span><span>1</span><span>},{</span><span>start</span><span>,</span><span>2</span><span>}]}.</span></span>
<span><span>{</span><span>attributes</span><span>, []}.</span></span>
<span><span>{</span><span>labels</span><span>, </span><span>7</span><span>}.</span></span>
<span></span>
<span><span>{</span><span>function</span><span>, </span><span>start</span><span>, </span><span>2</span><span>, </span><span>2</span><span>}.</span></span>
<span><span>  {</span><span>label</span><span>,</span><span>1</span><span>}.</span></span>
<span><span>    {</span><span>line</span><span>,[{</span><span>location</span><span>,</span><span>&#34;erts/preloaded/src/hello.erl&#34;</span><span>,</span><span>74</span><span>}]}.</span></span>
<span><span>    {</span><span>func_info</span><span>,{</span><span>atom</span><span>,</span><span>hello</span><span>},{</span><span>atom</span><span>,</span><span>start</span><span>},</span><span>2</span><span>}.</span></span>
<span><span>  {</span><span>label</span><span>,</span><span>2</span><span>}.</span></span>
<span><span>    {</span><span>move</span><span>,{</span><span>literal</span><span>,[{</span><span>flush</span><span>,</span><span>false</span><span>}]},{</span><span>x</span><span>,</span><span>1</span><span>}}.</span></span>
<span><span>    {</span><span>move</span><span>,{</span><span>integer</span><span>,</span><span>42</span><span>},{</span><span>x</span><span>,</span><span>0</span><span>}}.</span></span>
<span><span>    {</span><span>line</span><span>,[{</span><span>location</span><span>,</span><span>&#34;erts/preloaded/src/hello.erl&#34;</span><span>,</span><span>76</span><span>}]}.</span></span>
<span><span>    {</span><span>call_ext_only</span><span>,</span><span>2</span><span>,{</span><span>extfunc</span><span>,</span><span>erlang</span><span>,</span><span>halt</span><span>,</span><span>2</span><span>}}.</span></span>
<span></span>
<span><span>{</span><span>function</span><span>, </span><span>module_info</span><span>, </span><span>0</span><span>, </span><span>4</span><span>}.</span></span>
<span><span>  {</span><span>label</span><span>,</span><span>3</span><span>}.</span></span>
<span><span>    {</span><span>line</span><span>,[]}.</span></span>
<span><span>    {</span><span>func_info</span><span>,{</span><span>atom</span><span>,</span><span>hello</span><span>},{</span><span>atom</span><span>,</span><span>module_info</span><span>},</span><span>0</span><span>}.</span></span>
<span><span>  {</span><span>label</span><span>,</span><span>4</span><span>}.</span></span>
<span><span>    {</span><span>move</span><span>,{</span><span>atom</span><span>,</span><span>hello</span><span>},{</span><span>x</span><span>,</span><span>0</span><span>}}.</span></span>
<span><span>    {</span><span>call_ext_only</span><span>,</span><span>1</span><span>,{</span><span>extfunc</span><span>,</span><span>erlang</span><span>,</span><span>get_module_info</span><span>,</span><span>1</span><span>}}.</span></span>
<span></span>
<span><span>{</span><span>function</span><span>, </span><span>module_info</span><span>, </span><span>1</span><span>, </span><span>6</span><span>}.</span></span>
<span><span>  {</span><span>label</span><span>,</span><span>5</span><span>}.</span></span>
<span><span>    {</span><span>line</span><span>,[]}.</span></span>
<span><span>    {</span><span>func_info</span><span>,{</span><span>atom</span><span>,</span><span>hello</span><span>},{</span><span>atom</span><span>,</span><span>module_info</span><span>},</span><span>1</span><span>}.</span></span>
<span><span>  {</span><span>label</span><span>,</span><span>6</span><span>}.</span></span>
<span><span>    {</span><span>move</span><span>,{</span><span>x</span><span>,</span><span>0</span><span>},{</span><span>x</span><span>,</span><span>1</span><span>}}.</span></span>
<span><span>    {</span><span>move</span><span>,{</span><span>atom</span><span>,</span><span>hello</span><span>},{</span><span>x</span><span>,</span><span>0</span><span>}}.</span></span>
<span><span>    {</span><span>call_ext_only</span><span>,</span><span>2</span><span>,{</span><span>extfunc</span><span>,</span><span>erlang</span><span>,</span><span>get_module_info</span><span>,</span><span>2</span><span>}}.</span></span></code></pre></div><p>You can spot the start function and the two standard module_info functions that all Erlang modules have. We do not care much about those right now as we discovered that they are not executed and are not required to work, for now.</p><p>We can see that the core of the start function is just two <code>move</code> operations and one <code>call_ext_only</code>. But bear in mind that the BEAM loader will transmute these <em>Generic</em> BEAM Operations into <em>Specific</em> operations. More complexity will pop up!</p><h2 id="execution" tabindex="-1">Execution <a href="#execution" aria-label="Permalink to &#34;Execution&#34;">​</a></h2><p>We are using <code>qemu-arm</code> to emulate <code>Arm32</code> and we are directly using <code>beam.smp</code> to run the BEAM.</p><div><p><span>shell</span></p><pre tabindex="0"><code><span><span>    ~/arm32-jit$</span><span> qemu-arm</span><span> -L</span><span> /usr/arm-linux-gnueabihf</span><span> ./otp/RELEASE/erts-15.0/bin/beam.smp</span><span> -S</span><span> 1:1</span><span> -SDcpu</span><span> 1:1</span><span> -SDio</span><span> 1</span><span> -JDdump</span><span> true</span><span> -JMsingle</span><span>     true</span><span> --</span><span> -root</span><span> /home/vagrant/arm32-jit/otp/RELEASE</span><span> -progname</span><span> erl</span><span> -home</span><span> /home/vagrant</span></span></code></pre></div><h3 id="jit-initialization" tabindex="-1">JIT initialization <a href="#jit-initialization" aria-label="Permalink to &#34;JIT initialization&#34;">​</a></h3><p>At boot, the BEAM initializes the JIT if enabled. The JIT leverages the AsmJit library to emit all machine code instructions.</p><p>There are 90+ code snippets that are shared among all modules. The JIT loads them one single time and sets up jumps to them in every other module. It is like a global library for all modules.</p><p>We skipped most of these because just the shared fragments involved in the <code>hello:start/2</code> execution were needed.</p><h4 id="emission-of-the-erts-beamasm-module" tabindex="-1">Emission of the <em>erts_beamasm</em> module <a href="#emission-of-the-erts-beamasm-module" aria-label="Permalink to &#34;Emission of the *erts_beamasm* module&#34;">​</a></h4><p>As part of the JIT initialization, <code>erts_beamasm</code> is emitted. This module is an internal hardcoded module that exists only when BEAM is using the JIT. It holds 7 fundamental instructions used to manage the Erlang process executions.</p><ul><li>run_process - The main process execution entry point</li><li>normal_exit - Normal process termination</li><li>continue_exit - Continue after exit handling</li><li>exception_trace - Exception tracing functionality</li><li>return_trace - Return value tracing</li><li>return_to_trace - Return to tracing state</li><li>call_trace_return - Call tracing return handling</li></ul><h3 id="preloaded-modules" tabindex="-1">Preloaded modules <a href="#preloaded-modules" aria-label="Permalink to &#34;Preloaded modules&#34;">​</a></h3><p>The <code>hello.erl</code> module has been compiled and put as first and single Erlang module in the list of preloaded modules. Preloaded modules are Erlang fundamental modules that are always loaded by the BEAM before the first Erlang process can start. They implement, in Erlang, the core features of the Erlang Runtime System (ERTS). The OTP build scripts group all <code>ebin</code> files into a single C header that is then linked into the executable. This makes the Erlang binaries available as a static C array in the BEAM source code. These are then loaded one by one after the BEAM VM is initialized.</p><p>Cool, let&#39;s nuke all these modules and leave just our <code>hello.erl</code>. It does not need many BEAM instructions and we can easily verify that it executes. To do the substitution we just need to change this build variable in <a href="https://github.com/erlang/otp/commit/fa61ec65e57cfdf96b70514800f7021b83cc7fdc#diff-ffe95702266c55f8aeab7d07a0898c9548fbb390b238145f0abe05399baab62aL749-R749" target="_blank" rel="noreferrer">otp/erts/emulator/Makefile.in</a></p><p>We are running BEAMASM with <code>-JDdump true</code> so <code>asmjit</code> will dump all ARM32 assembly for each module! This is incredibly useful if monitored while executing with a debugger, as we can see the assembler being printed line by line by our code.</p><div><p><span>shell</span></p><pre tabindex="0"><code><span><span>~</span><span>/arm32-jit$ cat hello.asm </span></span>
<span><span>L6:</span></span>
<span><span>.byte</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00</span></span>
<span><span># i_flush_stubs</span></span>
<span><span># func_line_I</span></span>
<span><span># aligned_label_Lt</span></span>
<span><span>label_1:</span></span>
<span><span># i_func_info_IaaI</span></span>
<span><span># hello:start/2</span></span>
<span><span>    blx</span><span> L8</span></span>
<span><span>.byte</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00</span></span>
<span><span>.byte</span><span> 0x0B,</span><span> 0x4F,</span><span> 0x00,</span><span> 0x00,</span><span> 0x0B,</span><span> 0xA4,</span><span> 0x00,</span><span> 0x00,</span><span> 0x02,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00</span></span>
<span><span># aligned_label_Lt</span></span>
<span><span>start/2:</span></span>
<span><span># i_breakpoint_trampoline</span></span>
<span><span>    str</span><span> lr,</span><span> [r7, </span><span>-4</span><span>]</span><span>!</span></span>
<span><span>    b</span><span> L9</span></span>
<span><span>    bl</span><span> L11</span></span>
<span><span>L9:</span></span>
<span><span># i_test_yield</span></span>
<span><span>    adr</span><span> r2,</span><span> start/2</span></span>
<span><span>    subs</span><span> r9,</span><span> r9,</span><span> 1</span></span>
<span><span>    b.le</span><span> L13</span></span>
<span><span># i_move_sd</span></span>
<span><span>    ldr</span><span> r12,</span><span> [L14]</span></span>
<span><span>    str</span><span> r12,</span><span> [r4, </span><span>68]</span></span>
<span><span># i_move_sd</span></span>
<span><span>    movw</span><span> r12,</span><span> 687</span></span>
<span><span>    str</span><span> r12,</span><span> [r4, </span><span>64]</span></span>
<span><span># line_I</span></span>
<span><span># allocate_tt</span></span>
<span><span># call_light_bif_be</span></span>
<span><span>L15:</span></span>
<span><span>    ldr</span><span> r3,</span><span> [L16]</span></span>
<span><span>    movw</span><span> r1,</span><span> 10188</span></span>
<span><span>    movt</span><span> r1,</span><span> 16432</span></span>
<span><span>    adr</span><span> r2,</span><span> L15</span></span>
<span><span># BIF: erlang:halt/2</span></span>
<span><span>    sub</span><span> r12,</span><span> r7,</span><span> 4</span></span>
<span><span>    cmp</span><span> r10,</span><span> r12</span></span>
<span><span>    b.ls</span><span> L17</span></span>
<span><span>    udf</span><span> 48879</span></span>
<span><span>L17:</span></span>
<span><span>    movw</span><span> r12,</span><span> 12424</span></span>
<span><span>    add</span><span> r12,</span><span> r4,</span><span> r12</span></span>
<span><span>    ldr</span><span> r12,</span><span> [r12]</span></span>
<span><span>    cmp</span><span> sp,</span><span> r12</span></span>
<span><span>    b.eq</span><span> L18</span></span>
<span><span>    udf</span><span> 57005</span></span>
<span><span>L18:</span></span>
<span><span>    bl</span><span> L20</span></span>
<span><span># deallocate_t</span></span>
<span><span>    movw</span><span> r0,</span><span> 64676</span></span>
<span><span>    movt</span><span> r0,</span><span> 16480</span></span>
<span><span>    blx</span><span> L22</span></span>
<span><span># return</span></span>
<span><span>    movw</span><span> r0,</span><span> 61636</span></span>
<span><span>    movt</span><span> r0,</span><span> 16480</span></span>
<span><span>    blx</span><span> L22</span></span>
<span><span># i_flush_stubs</span></span>
<span><span># func_line_I</span></span>
<span><span># aligned_label_Lt</span></span>
<span><span>label_3:</span></span>
<span><span># i_func_info_IaaI</span></span>
<span><span># hello:module_info/0</span></span>
<span><span>    blx</span><span> L8</span></span>
<span><span>.byte</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00</span></span>
<span><span>.byte</span><span> 0x0B,</span><span> 0x4F,</span><span> 0x00,</span><span> 0x00,</span><span> 0x4B,</span><span> 0x6B,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00</span></span>
<span><span># aligned_label_Lt</span></span>
<span><span>module_info/0:</span></span>
<span><span># i_breakpoint_trampoline</span></span>
<span><span>    str</span><span> lr,</span><span> [r7, </span><span>-4</span><span>]</span><span>!</span></span>
<span><span>    b</span><span> L23</span></span>
<span><span>    bl</span><span> L11</span></span>
<span><span>L23:</span></span>
<span><span># i_test_yield</span></span>
<span><span>    adr</span><span> r2,</span><span> module_info/0</span></span>
<span><span>    subs</span><span> r9,</span><span> r9,</span><span> 1</span></span>
<span><span>    b.le</span><span> L13</span></span>
<span><span># i_move_sd</span></span>
<span><span>    movw</span><span> r12,</span><span> 20235</span></span>
<span><span>    str</span><span> r12,</span><span> [r4, </span><span>64]</span></span>
<span><span># allocate_tt</span></span>
<span><span># call_light_bif_be</span></span>
<span><span>L24:</span></span>
<span><span>    ldr</span><span> r3,</span><span> [L25]</span></span>
<span><span>    movw</span><span> r1,</span><span> 4772</span></span>
<span><span>    movt</span><span> r1,</span><span> 16425</span></span>
<span><span>    adr</span><span> r2,</span><span> L24</span></span>
<span><span># BIF: erlang:get_module_info/1</span></span>
<span><span>    sub</span><span> r12,</span><span> r7,</span><span> 4</span></span>
<span><span>    cmp</span><span> r10,</span><span> r12</span></span>
<span><span>    b.ls</span><span> L26</span></span>
<span><span>    udf</span><span> 48879</span></span>
<span><span>L26:</span></span>
<span><span>    movw</span><span> r12,</span><span> 12424</span></span>
<span><span>    add</span><span> r12,</span><span> r4,</span><span> r12</span></span>
<span><span>    ldr</span><span> r12,</span><span> [r12]</span></span>
<span><span>    cmp</span><span> sp,</span><span> r12</span></span>
<span><span>    b.eq</span><span> L27</span></span>
<span><span>    udf</span><span> 57005</span></span>
<span><span>L27:</span></span>
<span><span>    bl</span><span> L20</span></span>
<span><span># deallocate_t</span></span>
<span><span>    movw</span><span> r0,</span><span> 64676</span></span>
<span><span>    movt</span><span> r0,</span><span> 16480</span></span>
<span><span>    blx</span><span> L22</span></span>
<span><span># return</span></span>
<span><span>    movw</span><span> r0,</span><span> 61636</span></span>
<span><span>    movt</span><span> r0,</span><span> 16480</span></span>
<span><span>    blx</span><span> L22</span></span>
<span><span># i_flush_stubs</span></span>
<span><span># func_line_I</span></span>
<span><span># aligned_label_Lt</span></span>
<span><span>label_5:</span></span>
<span><span># i_func_info_IaaI</span></span>
<span><span># hello:module_info/1</span></span>
<span><span>    blx</span><span> L8</span></span>
<span><span>.byte</span><span> 0x00,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00</span></span>
<span><span>.byte</span><span> 0x0B,</span><span> 0x4F,</span><span> 0x00,</span><span> 0x00,</span><span> 0x4B,</span><span> 0x6B,</span><span> 0x00,</span><span> 0x00,</span><span> 0x01,</span><span> 0x00,</span><span> 0x00,</span><span> 0x00</span></span>
<span><span># aligned_label_Lt</span></span>
<span><span>module_info/1:</span></span>
<span><span># i_breakpoint_trampoline</span></span>
<span><span>    str</span><span> lr,</span><span> [r7, </span><span>-4</span><span>]</span><span>!</span></span>
<span><span>    b</span><span> L28</span></span>
<span><span>    bl</span><span> L11</span></span>
<span><span>L28:</span></span>
<span><span># i_test_yield</span></span>
<span><span>    adr</span><span> r2,</span><span> module_info/1</span></span>
<span><span>    subs</span><span> r9,</span><span> r9,</span><span> 1</span></span>
<span><span>    b.le</span><span> L13</span></span>
<span><span># i_move_sd</span></span>
<span><span>    ldr</span><span> r12,</span><span> [r4, </span><span>64]</span></span>
<span><span>    str</span><span> r12,</span><span> [r4, </span><span>68]</span></span>
<span><span># i_move_sd</span></span>
<span><span>    movw</span><span> r12,</span><span> 20235</span></span>
<span><span>    str</span><span> r12,</span><span> [r4, </span><span>64]</span></span>
<span><span># allocate_tt</span></span>
<span><span># call_light_bif_be</span></span>
<span><span>L29:</span></span>
<span><span>    ldr</span><span> r3,</span><span> [L30]</span></span>
<span><span>    movw</span><span> r1,</span><span> 4868</span></span>
<span><span>    movt</span><span> r1,</span><span> 16425</span></span>
<span><span>    adr</span><span> r2,</span><span> L29</span></span>
<span><span># BIF: erlang:get_module_info/2</span></span>
<span><span>    sub</span><span> r12,</span><span> r7,</span><span> 4</span></span>
<span><span>    cmp</span><span> r10,</span><span> r12</span></span>
<span><span>    b.ls</span><span> L31</span></span>
<span><span>    udf</span><span> 48879</span></span>
<span><span>L31:</span></span>
<span><span>    movw</span><span> r12,</span><span> 12424</span></span>
<span><span>    add</span><span> r12,</span><span> r4,</span><span> r12</span></span>
<span><span>    ldr</span><span> r12,</span><span> [r12]</span></span>
<span><span>    cmp</span><span> sp,</span><span> r12</span></span>
<span><span>    b.eq</span><span> L32</span></span>
<span><span>    udf</span><span> 57005</span></span>
<span><span>L32:</span></span>
<span><span>    bl</span><span> L20</span></span>
<span><span># deallocate_t</span></span>
<span><span>    movw</span><span> r0,</span><span> 64676</span></span>
<span><span>    movt</span><span> r0,</span><span> 16480</span></span>
<span><span>    blx</span><span> L22</span></span>
<span><span># return</span></span>
<span><span>    movw</span><span> r0,</span><span> 61636</span></span>
<span><span>    movt</span><span> r0,</span><span> 16480</span></span>
<span><span>    blx</span><span> L22</span></span>
<span><span># int_code_end</span></span>
<span><span>L33:</span></span>
<span><span>    movw</span><span> r0,</span><span> 18576</span></span>
<span><span>    movt</span><span> r0,</span><span> 16480</span></span>
<span><span>    blx</span><span> L22</span></span>
<span><span>L13:</span></span>
<span><span>L12:</span></span>
<span><span>    movw</span><span> r12,</span><span> 1968</span></span>
<span><span>    movt</span><span> r12,</span><span> 14656</span></span>
<span><span>    blx</span><span> r12</span></span>
<span><span>L22:</span></span>
<span><span>L21:</span></span>
<span><span>    movw</span><span> r12,</span><span> 29192</span></span>
<span><span>    movt</span><span> r12,</span><span> 16399</span></span>
<span><span>    blx</span><span> r12</span></span>
<span><span>L11:</span></span>
<span><span>L10:</span></span>
<span><span>    movw</span><span> r12,</span><span> 1752</span></span>
<span><span>    movt</span><span> r12,</span><span> 14656</span></span>
<span><span>    blx</span><span> r12</span></span>
<span><span>L20:</span></span>
<span><span>L19:</span></span>
<span><span>    movw</span><span> r12,</span><span> 680</span></span>
<span><span>    movt</span><span> r12,</span><span> 14656</span></span>
<span><span>    blx</span><span> r12</span></span>
<span><span>L8:</span></span>
<span><span>L7:</span></span>
<span><span>    movw</span><span> r12,</span><span> 1824</span></span>
<span><span>    movt</span><span> r12,</span><span> 14656</span></span>
<span><span>    blx</span><span> r12</span></span>
<span><span># Begin stub section</span></span>
<span><span>L14:</span></span>
<span><span>.xword</span><span> 0x000000007FFFFFFF</span></span>
<span><span>L16:</span></span>
<span><span>.xword</span><span> 0x000000007FFFFFFF</span></span>
<span><span>L25:</span></span>
<span><span>.xword</span><span> 0x000000007FFFFFFF</span></span>
<span><span>L30:</span></span>
<span><span>.xword</span><span> 0x000000007FFFFFFF</span></span>
<span><span># End stub section</span></span>
<span><span>L34:</span></span>
<span><span>.section</span><span> .rodata</span><span> {#1}</span></span>
<span><span>md5:</span></span>
<span><span>.byte</span><span> 0x6D,</span><span> 0xC4,</span><span> 0x1E,</span><span> 0xF1,</span><span> 0x13,</span><span> 0x1E,</span><span> 0xBF,</span><span> 0xF2,</span><span> 0x4B,</span><span> 0xF5,</span><span> 0xC0,</span><span> 0x41,</span><span> 0x57,</span><span> 0x86,</span><span> 0xDF,</span><span> 0xD5</span></span>
<span><span>.section</span><span> .text</span><span> {#0}</span></span>
<span><span>; </span><span>CODE_SIZE:</span><span> 632</span></span></code></pre></div><p>Bear in mind, this assembler is not what hello should look like. We are missing a lot of things.</p><p>You can spot many sequences like:</p><div><p><span>asm</span></p><pre tabindex="0"><code><span><span>    movw r0, </span><span>64676</span></span>
<span><span>    movt r0, </span><span>16480</span></span>
<span><span>    blx L22</span><span> # &lt;---- branch to NYI</span></span></code></pre></div><p>This is a call to <code>nyi</code> (Not Yet Implemented) function and the argument loaded to R0 is the pointer to a string that contains the name of the BEAM instruction that should have been emitted instead. You can spot many of these since we are only emitting the code to reach halt. Everything after that is not important now as halt will never return!</p><p>There are many more comments we could make around all the details in this assembler dump, but let&#39;s move on.</p><h3 id="jumping-into-jitted-code" tabindex="-1">Jumping into Jitted code! <a href="#jumping-into-jitted-code" aria-label="Permalink to &#34;Jumping into Jitted code!&#34;">​</a></h3><p>Later in the BEAM initialization the first Erlang process will be allocated and started.</p><p>We swap the module and function with hello in <a href="https://github.com/erlang/otp/commit/fa61ec65e57cfdf96b70514800f7021b83cc7fdc#diff-3517781afd08bfe826dcc3babdfa35cdabb9d13011d5dd9ae49922f3996cadb5L395" target="_blank" rel="noreferrer">erts/emulator/beam/erl_init.c</a></p><div><p><span>cpp</span></p><pre tabindex="0"><code><span><span>    erl_spawn_system_process</span><span>(</span><span>&amp;</span><span>parent, am_hello, am_start, args, </span><span>&amp;</span><span>so);</span></span></code></pre></div><p>One BEAM scheduler thread will jump to the <code>process_main</code> function. You can find it <a href="https://github.com/stritzinger/otp/blob/31edb99e9851e9d35b0cf6a3f4ead9a4cc4cfcb6/erts/emulator/beam/jit/arm/32/process_main.cpp#L49" target="_blank" rel="noreferrer">here</a> in the source code. This is emitted by our JIT and is the first emitted code that will run.</p><p>Here we need to handle the Erlang processes scheduling by calling BEAM routines that implement the algorithms of Erlang concurrency, like <a href="https://github.com/stritzinger/otp/blob/eda80cd2fe028c2db6f67bcf97ac50de85c41b2f/erts/emulator/beam/erl_process.c#L9465" target="_blank" rel="noreferrer"><code>erts_schedule</code></a>.</p><p><code>erts_schedule</code> will return the pointer to the <code>Process</code> C structure that holds all information about the process that is going to execute. We then load all necessary data inside registers and then we branch to the exact point where the program execution stopped.</p><h3 id="the-first-erlang-function-call" tabindex="-1">The first Erlang function call <a href="#the-first-erlang-function-call" aria-label="Permalink to &#34;The first Erlang function call&#34;">​</a></h3><p>In this case we are calling <code>hello:start/2</code> so the first instruction to execute is <code>apply_only</code> that does a few things but ends up calling the C <code>apply</code> routine.</p><p>The routine processes the Module-Function-Arity information to get the address where the function code resides in memory.</p><p>What follows is the Erlang function prologue. You can see it in the assembler code section above. For example, all functions have these instructions in their prologue:</p><ul><li>i_breakpoint_trampoline: handle breakpoints for the <code>debugger</code> app</li><li>i_test_yield: checks if the function should yield and go back to the scheduler</li></ul><p>We have minimal or partial implementations of these since we do not really need them. We have to emit them though, as the C++ generated loader functions from the BEAM are expanding the Erlang function call Operation into a more specific and complex function prologue sequence.</p><p>After that, we added support for the <a href="https://github.com/stritzinger/otp/blob/31edb99e9851e9d35b0cf6a3f4ead9a4cc4cfcb6/erts/emulator/beam/jit/arm/32/instr_bif.cpp#L280" target="_blank" rel="noreferrer"><code>call_light_bif</code></a> operation that precedes the call to the halt_2 BIF routine. This implementation is also minimal.</p><p><em>Question for later: did you notice that we put a <code>42</code> as a number in the code? Numeric constants are printed as decimals in the dump, but we cannot spot any 42!?</em></p><p>After the call, we see two other operations:</p><ul><li>dealloc</li><li>return</li></ul><p>These are just calls to NYI as we will never reach this code! So for now, we can skip them...</p><h3 id="let-s-roll-the-jit" tabindex="-1">Let&#39;s roll the JIT! <a href="#let-s-roll-the-jit" aria-label="Permalink to &#34;Let&#39;s roll the JIT!&#34;">​</a></h3><div><p><span>shell</span></p><pre tabindex="0"><code><span><span>    ~/arm32-jit$</span><span> qemu-arm</span><span> -L</span><span> /usr/arm-linux-gnueabihf</span><span> ./otp/RELEASE/erts-15.0/bin/beam.smp</span><span> -S</span><span> 1:1</span><span> -SDcpu</span><span> 1:1</span><span> -SDio</span><span> 1</span><span> -JDdump</span><span> true</span><span> -JMsingle</span><span>     true</span><span> --</span><span> -root</span><span> /home/arm32-jit/otp/RELEASE</span><span> -progname</span><span> erl</span><span> -home</span><span> /home</span></span>
<span><span>    ~/arm32-jit$</span></span></code></pre></div><p>Impressive, the program returns immediately without even saying <em>&#34;Hi&#34;</em> ... and without Segmentation Fault!!</p><p>But let&#39;s check the program return code!</p><pre><code>~/arm32-jit$ echo $?
42
</code></pre><p>We can safely say that number is not there by accident! This is a great achievement as from now on we will be able to incrementally add Erlang instructions.</p><p>Every Erlang line we add will trigger new Opcodes. By emitting them and running the code we will have immediate feedback on everything.</p><p>The next goal now is to complete the <code>hello</code> module to host all possible beam instructions!</p><h4 id="hey-where-is-42" tabindex="-1">Hey where is 42??? <a href="#hey-where-is-42" aria-label="Permalink to &#34;Hey where is 42???&#34;">​</a></h4><p>One interesting thing I spotted looking at the assembly: You cannot find the number <code>42</code> in there. Or actually, you can, it is just hidden in plain sight. To understand you need to know how we are using ARM32 registers.</p><p>In particular the register <code>r4</code>, a callee-saved register. We are using it to store the pointer to the <code>ErtsSchedulerRegisters</code> struct. The <code>ErtsSchedulerRegisters</code> contains the X register array. When a function is called, X registers are used to store the arguments of the call.</p><p>This becomes more obvious if we compare the Erlang assembly to the Arm32 assembly.</p><div><p><span>asm</span></p><pre tabindex="0"><code><span><span># i_move_sd                       &lt;---- {move,{literal,[{flush,false}]},{x,1}}. % List at X[1]</span></span>
<span><span>    ldr </span><span>r12</span><span>, [L14]</span></span>
<span><span>    str</span><span> r12</span><span>, [r4, </span><span>68</span><span>]</span></span>
<span><span># i_move_sd                       &lt;---- {move,{integer,42},{x,0}}. % 42 at X[0]</span></span>
<span><span>    movw </span><span>r12</span><span>, </span><span>687</span><span> </span></span>
<span><span>    str</span><span> r12</span><span>, [r4, </span><span>64</span><span>]</span></span>
<span><span># line_I</span></span>
<span><span># allocate_tt</span></span>
<span><span># call_light_bif_be</span></span>
<span><span>L15:</span></span>
<span><span>    ldr r3, [L16]</span></span>
<span><span>    movw r1, </span><span>10188</span></span>
<span><span>    movt r1, </span><span>16432</span></span>
<span><span>    adr r2, L15</span></span>
<span><span># BIF: erlang:halt/2</span></span>
<span><span># ...</span></span></code></pre></div><p>42 is stored at <code>r4</code>+64.</p><ul><li>r4: pointer to the <code>ErtsSchedulerRegisters</code> struct</li><li>64: base offset from the beginning of the struct to the beginning of the <code>x_reg_array</code></li></ul><p>The list is stored at <code>r4</code>+68.</p><ul><li>68: is the base offset + the size of one <code>Eterm</code> (4 bytes on ARM32)</li></ul><p>But why in assembly do we see 687 and not 42?</p><p>Converting both numbers to hex we get:</p><ul><li>42 -&gt; 2A</li><li>687 -&gt; 2AF !!</li></ul><p>Yep, this is an example of a Tagged Value. If we consult the BEAM book we can learn about the <a href="https://blog.stenmans.org/theBeamBook/#_the_tagging_scheme" target="_blank" rel="noreferrer">Tagging Scheme</a>:</p><ul><li>00 11 Pid</li><li>01 11 Port</li><li>10 11 Immediate 2</li><li>11 11 Small integer</li></ul><p>42 is tagged with <code>1111</code> at the low end. So the BEAM can quickly recognize during a pattern match that this Erlang Term is a Small Integer!</p></div></div></div></div>
  </body>
</html>
