<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://craftofcoding.wordpress.com/2022/11/04/languages-pre-fortran/">Original</a>
    <h1>Languages Pre-Fortran</h1>
    
    <div id="readability-page-1" class="page"><article id="post-16442">

	
	<!-- .entry-header -->

	<div>

				<!-- .entry-meta -->
		
				<div>
			
<p>There were many languages that pre-dated Fortran. This series is based on the white paper by Knuth and Pardo published in 1976, “<em><a href="http://www.club.cc.cmu.edu/~ajo/disseminate/STAN-CS-76-562_EarlyDevelPgmgLang_Aug76.pdf">The early development of programming languages</a></em>”. In this paper the authors describe 20 languages, and use a generic program “TPK” described using ALGOL-60 to illustrate how each language would be formed. </p>



<ul>
<li>1945 – <strong>Plankalkül</strong> (Zuse)
<ul>
<li>Likely the first programming language developed, yet not implemented at the time. </li>
</ul>
</li>



<li>1946 – <strong>Flow Diagrams</strong> (Goldstine/von Neumann)
<ul>
<li>Proposed a pictorial representation involving boxes joined by arrows, calling it a “flow diagram”. These were the original flowcharts. Never implemented.</li>
</ul>
</li>



<li>1948 – <strong>Composition</strong> (Curry)
<ul>
<li>A notation for program construction more compact than flowcharts. It had aspects of structured programming, e.g. analyzing the computation into parts called divisions. The notation was somewhat eccentric and the work was left unfinished. Never implemented.</li>
</ul>
</li>



<li>1950 – <strong>Short Code</strong> (Mauchly et al.,)
<ul>
<li>Coded for the BINAC, and in 1950 for the UNIVAC. Mathematical equations could be solved just by writing them down, i.e. it was an algebraic interpreter. Earliest literature dates to 1952.</li>
</ul>
</li>



<li>1950 – <strong>Intermediate PL</strong> (Burks)
<ul>
<li>Showed how “machine programs” could be expressed at a higher level of abstraction.</li>
</ul>
</li>



<li>1951 – <strong>Superplan</strong> (Rutishauser)
<ul>
<li>A simple algebraic language with one non-sequential control structure (for), no conditionals or goto.</li>
</ul>
</li>



<li>1951 – <strong>Böhm’s Compiler</strong> (Böhm)
<ul>
<li>A language in which every statement was a special case of an assignment statement. Described a compiler that was defined in its own language. Considered his language “universal”, i.e. capable of computing any computable function.</li>
</ul>
</li>



<li>1952 – <strong>AUTOCODE</strong> (Glennie)
<ul>
<li>The first real compiler, as it was really implemented and used. It took algebraic statements and converted them to machine code. Simpler than machine code, but still machine-oriented.</li>



<li>Manchester Mark I, not algebraic, very machine dependent, fixed point</li>
</ul>
</li>



<li>1953 – <strong>A-2</strong> (Hopper et al.,)
<ul>
<li>Primitive language, more like a compiling routine. Not algebraic, machine dependent, floating-point. Successor to A-0 and A-1.</li>
</ul>
</li>



<li>1953 <strong>Laning and Zierler</strong>
<ul>
<li>Algebraic pseudo coding implemented for Whirlwind computer, which contributed to FORTRAN for the 704. The programmer no longer needed to know much about the computer at all. Notation was easy to read.</li>



<li>Algebraic, machine independent, floating-point</li>
</ul>
</li>



<li>1954-57 – <strong>FORTRAN0</strong> (Backus et al.,)
<ul>
<li>Fortran 0, 1954, a simpler version of Fortran 1. All things were formulas, even control structures – arithmetic formulas, DO formulas, GO TO formulas etc. The term compiler is never used, just a FORTRAN language and system. First rigorous attempt to define a programming language. BNF notation can be seen in early form here.</li>



<li>Fortran I (1957) included comments, arithmetic statement functions, I/O formatting, CONTINUE statement for loops, and three-way arithmetic IF statement.</li>
</ul>
</li>



<li>1954 – <strong>Mark I Autocode</strong> (Brooker)
<ul>
<li>A new type of Autocode for the Mark I. It was nearly machine independent and used floating-point arithmetic. One operation per line, few mnemonic names, and no user defined subroutines.</li>
</ul>
</li>



<li>1954 – <strong>ПП-2</strong> (Kamynin/Liubimskii)
<ul>
<li>Early Russian systems were called Programming Programs, or ПП for short. Based on a notation for expressing programs developed by A.A. Liapunov in 1953. Built for the STRELA computer, and based on operator schemata.</li>
</ul>
</li>



<li>1955 – <strong>ПП</strong> (Ershov)
<ul>
<li>Improvement of ПП-2, built for BESM computer. Computers for both had no alphabetic input, so programs had to be converted to numeric codes.</li>
</ul>
</li>



<li>1955 – <strong>BACAIC</strong> (Grems/Porter)
<ul>
<li>Interpretive algebraic language developed at Boeing. A straight-line computation applied to various “cases” of data. Language too restrictive for general purpose computing.</li>
</ul>
</li>



<li>1955 – <strong>Kompiler 2</strong> (Elsworth et al.)
<ul>
<li>University of California Radiation Laboratory, program to perform translation of algebraic equations into IBM 701 machine language – KOMPILER 1. It had individual formulas, no control statements, constants or I/O. KOMPILER 2 similar in flavour to ПП-2, but based on flow diagrams.</li>
</ul>
</li>



<li>1956 – <strong>ADES</strong> (Blum)
<ul>
<li>US Naval Ordinance Lab. ADES – Automatic Digital Encoding System. Mathematical in structure, based on the theory of recursive functions (but did not really include recursive procedures in the same sense of ALGOL-60). Produced an embryonic form of the conditional expressions introduced into LISP and ALGOL.</li>
</ul>
</li>



<li>1956 – <strong>IT</strong> (Perlis, et al.)
<ul>
<li>Purdue University Computing Laboratory. Built a compiler for the Burroughs 205 computer (Purdue Compiler Language). Perlis and Smith moved on to Carnegie IT and adapted their language to the IBM 650 – IT (Internal Translator). One of the first useful compilers. Contained a method of iteration and a conditional.</li>
</ul>
</li>



<li>1956-58 – <strong>MATH-MATIC</strong> (Katz, et al.)
<ul>
<li>Algebraic language, from UNIVAC, very readable. MATH-MATIC source was translated into A-3 (an extension of A-2), which produced inefficient programs.</li>
</ul>
</li>



<li>1956-58 – <strong>FLOW-MATIC</strong> (Hopper et al.)
<ul>
<li>Also from UNIVAC, using more English language words than MATH-MATIC. Released to UNIVAC customers in 1958. Had a significant influence on the design COBOL.</li>
</ul>
</li>



<li>1956-58 – <strong>Formula-Controlled Computer </strong>(Bauer/Samelson)
<ul>
<li>Designed a computer in which algebraic formulas were the machine language. Their patent (for a machine never built), included four levels of language.</li>
</ul>
</li>
</ul>




			
			
								</div><!-- .entry-content -->
		
				<!-- .entry-meta -->
		
			</div><!-- .entry-body -->

</article></div>
  </body>
</html>
