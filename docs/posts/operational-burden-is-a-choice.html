<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://abstract.properties/operational-burden-is-a-choice.html">Original</a>
    <h1>Operational burden is a choice</h1>
    
    <div id="readability-page-1" class="page"><div>
                    <p>Time for devlog #5! <a href="https://blog.ericgoldman.org/devlog-dependency-graph-as-architecture.html">Last week&#39;s was here</a>.</p>
<p>This one isn&#39;t really a devlog. It&#39;s my thoughts about how software is made, and how I think we should have a shift.</p>
<a id="types-of-software" href="#types-of-software"><h2>Types of software</h2></a>
<p>I don&#39;t like being oncall.</p>
<p>The Internet doesn&#39;t have opening hours. It&#39;s a distributed system that unfortunately comes with the expectation of
being always available 24/7.</p>
<p>As a result, software companies have broadly shifted from selling <strong>standalone applications</strong> to selling <strong>online
applications</strong>.</p>
<p>I think we should build <strong>peer to peer applications</strong>.</p>

<a id="the-perils-of-always-online-applications" href="#the-perils-of-always-online-applications"><h2>The perils of always online applications</h2></a>
<p>Online applications let businesses <strong>observe &amp; control</strong> the data the app consumes and produces.</p>
<p>This is not always a bad thing. Some observation &amp; control enables features that help people.</p>
<p>Search and recommendation features often require a decent amount of data storage and processing that is
typically performed within the walls of the business.</p>
<p>Recommendations may also require collecting, mixing, and processing data sourced from many different users to infer
general user behaviors. This sort of thing is harder to do well with standalone applications.</p>

<p>But online applications come with costs to the business &amp; consequences to users:</p>
<ul>
<li><strong>Data breach?</strong> Users have to reckon with their data suddenly becoming public</li>
<li><strong>Business shuts down?</strong> Users often get left in the lurch</li>
<li><strong>Service outage?</strong> Users have to deal with a broken piece of software</li>
</ul>
<a id="github-(centralized)-≠-git-(decentralized)" href="#github-(centralized)-%E2%89%A0-git-(decentralized)"><h3>GitHub (centralized) ≠ git (decentralized)</h3></a>
<p>Consider GitHub, a business built on the shoulders of a free and open source distributed system: <a href="https://git-scm.com/">git</a>.</p>
<p>You don&#39;t need GitHub to use git. Every repository (by default) contains the full history of changes and may pull and
push additional changes to any other repository. A git repo is just a bunch of files in a <code>.git/</code> directory. They&#39;re all
inert while not being used. There&#39;s no backend needed, each repo is self-contained and may freely interoperate with
peers as long as there&#39;s a bidirectional channel between them.</p>
<p>But there are good reasons to use GitHub: issues, pull requests, and actions make it easy to build software with others.</p>
<p><img alt="A screenshot of GitHub when it goes down, featuring an angry looking unicorn" src="https://blog.ericgoldman.org/img/screenshot/github-outage.png"/>
</p>
<p>But easy features can cause lazy thinking.</p>
<p>Nearly every company I&#39;ve worked for in the past decade had GitHub in the critical path to production. If GitHub went
down (<a href="https://www.githubstatus.com/history">which it does, often</a>), there was an incident—people needed to be oncall.</p>
<p>This is an architectural choice. And this kind of choice leads to a 24/7 oncall support rotation—an operational burden.</p>
<p>If instead, git and a few shell scripts was used in the critical path for deploying to production, these companies would
be mostly immune to these sorts of outages—and the overall need for oncall would be reduced.</p>
<p>GitHub could still be used for the typical workflow, it just wouldn&#39;t be in the critical path.</p>

<p>Ironically, GitHub itself has also chosen to have a high operational burden. <em>(I&#39;ve never worked there, but can make
observations about their architecture.)</em></p>
<p>Many of the business objects that GitHub offers (issues, pull requests, actions, etc...) could themselves be stored as
primitives inside of git&#39;s distributed object model (as blobs, trees, commits, branches, tags, etc...).</p>
<p>If this choice were to be made, then GitHub would not need to run as many online services to manipulate these remote
business objects. They would be stored them the same as ordinary source files tracked within git. And they could build
UI to present them in the same, pleasant way.</p>
<p>There still would need to be online services, but there&#39;d be fewer of them, and they&#39;d be more limited in scope.</p>
<p>And fewer online services means less operational burden.</p>

<p>They probably don&#39;t do this because it would give away a piece of their value proposition: managing this data for you.</p>
<p>In a way, they&#39;re exchanging a higher operational burden for your data.</p>
<a id="what&#39;s-the-alternative?" href="#what&#39;s-the-alternative%3F"><h2>What&#39;s the alternative?</h2></a>
<p>I&#39;m not suggesting we go offline and stop building online applications.</p>
<p>Working on the same thing with people who aren&#39;t in the same room is table stakes these days.</p>
<p>Instead, we should start building <strong>peer-to-peer applications</strong>.</p>
<p>Running and maintaining a 24/7 <strong>centralized server</strong> to handle data and relay communication between parties is a drag.
With a peer-to-peer application, each client can act as a server managing its own data.</p>
<p>This can even be done in a web application today.</p>
<p><a href="https://en.wikipedia.org/wiki/WebRTC">WebRTC</a> allows web pages to establish peer-to-peer connections without¹ an
intermediate server handling the data.</p>

<a id="multiplayer-peer-to-peer-collaboration" href="#multiplayer-peer-to-peer-collaboration"><h2>Multiplayer peer-to-peer collaboration</h2></a>
<p>It&#39;s hard to add &#34;multiplayer&#34; support to documents.</p>
<p>When I look around for best practices to implement this, I often see
folks talk about <a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type">CRDTs</a> as a solution to manage the
complexity of multiple parties manipulating the same document without conflicts.</p>
<p>CRDTs are fascinating, but to me feel like overengineered &#34;solutions&#34; to fundamentally social problems.</p>

<p>Every time I&#39;ve worked with people on the same document, there&#39;s always the same power structure: one person &#34;hosts&#34; the
session, and everyone else is a &#34;guest&#34; acting politely while changing the document.</p>
<ul>
<li><strong>As the host</strong>, I can make authoritative calls about the document&#39;s content and structure</li>
<li><strong>As a guest</strong>, I can make changes, but I&#39;m not going to make a fuss if those changes are backed out or altered</li>
</ul>
<p>It can get a bit messy when multiple people are trying to change the same thing. (i.e. everyone adding items to the same
list)</p>
<p>But that messiness is <em>social</em>, we end up talking with each other to come up with an ad-hoc strategy to work
together. (i.e. split the list so each person has their own; merge afterward)</p>
<p>And once the session is over, the host typically does a bit of tidying up of the loose ends once everyone has left.</p>
<a id="build-" multiplayer"-support-that-embraces-this-power-structure"="" href="#build-%22multiplayer%22-support-that-embraces-this-power-structure"><h3>Build &#34;multiplayer&#34; support that embraces this power structure</h3></a>
<p>Instead of reaching for CRDTs and distributed state synchronization (where all parties are &#34;equal&#34; in ownership
and intent), let&#39;s reach for the same tools used when a client makes requests of data on a server.</p>
<p>There then is no difference between a client/server structure and a peer-to-peer multiplayer structure. <strong>The client is
a guest</strong> and <strong>the server is the host</strong>.</p>
<p>Document coordination could be as simple as:</p>
<table>
<thead>
<tr>
<th scope="col">Event</th>
<th scope="col">Response</th>
</tr>
</thead>
<tbody>
<tr>
<th scope="row">A guest joins</th>
<td>The host tells them the state of the world.</td>
</tr>
<tr>
<th scope="row">Host makes a change</th>
<td>The host tells all guests what has changed.</td>
</tr>
<tr>
<th rowspan="3" scope="row">A guest makes a change</th>
<td>The <em>guest asks the host</em> to accept a change.</td>
</tr>
<tr>
<td>Guests may optimistically update their local view (but be prepared to roll back).</td>
</tr>
<tr>
<td>The host may automatically or manually accept/reject this change depending on the host&#39;s state.</td>
</tr>
<tr>
<th scope="row">Host accepts guest change</th>
<td>The host makes the change and tells all guests what has changed.</td>
</tr>
<tr>
<th scope="row">Host rejects guest change</th>
<td>The host rejects the change, resulting in no state changes.</td>
</tr>
</tbody>
</table>
<a id="does-this-actually-work?" href="#does-this-actually-work%3F"><h2>Does this actually work?</h2></a>
<p>Probably! I&#39;m not sure, but I&#39;m going to try.</p>
<p>Hopefully, I&#39;ll have an implementation of the above soon, which will allow multiple people to operate as guests on a
document hosted by one of the users—without any servers requiring heavy maintenance involved.</p>

                </div></div>
  </body>
</html>
