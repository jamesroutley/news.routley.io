<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://vittorioromeo.info/index/blog/wordlexpr.html">Original</a>
    <h1>Wordlexpr: Compile-Time Wordle in C&#43;&#43;20</h1>
    
    <div id="readability-page-1" class="page"><div>
        <div>
            <p>It felt wrong to not participate in the Wordle craze, and what better way of doing so than by creating a purely compile-time version of the game in C++20? I proudly present to you… <strong>Wordlexpr</strong>!</p>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/wp3LPrhu2Sk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="">
</iframe>
</center>
<p><a href="https://gcc.godbolt.org/z/4oo3PrvqY"><em>(You can play <strong>Wordlexpr</strong> on Compiler Explorer.)</em></a></p>
<p>Carry on reading to understand the magic behind it!</p>
<h3 id="high-level-overview">high-level overview</h3>
<p>Wordlexpr is played entirely at compile-time as no executable is ever generated – the game is experienced through compiler errors. Therefore, we need to solve a few problems to make everything happen:</p>
<ol type="1">
<li><p>Produce arbitrary human-readable output as a compiler diagnostic.</p></li>
<li><p>Random number generation at compile-time.</p></li>
<li><p>Retain state and keep track of the player’s progress in-between compilations.</p></li>
</ol>
<h3 id="error-is-the-new-printf">error is the new <code>printf</code></h3>
<p>In order to abuse the compiler into outputting errors with an arbitrary string of our own liking, let’s start by trying to figure out how to make it print out a simple string literal. The first attempt, <code>static_assert</code>, seems promising:</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1"></a><span>static_assert</span>(<span>false</span>, <span>&#34;Welcome to Wordlexpr!&#34;</span>);</span></code></pre></div>
<blockquote>
<pre><code>error: static assertion failed: Welcome to Wordlexpr!
    1 | static_assert(false, &#34;Welcome to Wordlexpr!&#34;);
      |               ^^^^^</code></pre>
</blockquote>
<p>However, our delight is short-lived, as <code>static_assert</code> only accepts a string literal – a <code>constexpr</code> array of characters or <code>const char*</code> will not work as an argument:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1"></a><span>constexpr</span> <span>const</span> <span>char</span>* msg = <span>&#34;Welcome to Wordlexpr!&#34;</span>;</span>
<span id="cb3-2"><a href="#cb3-2"></a><span>static_assert</span>(<span>false</span>, msg);</span></code></pre></div>
<blockquote>
<pre><code>error: expected string-literal before &#39;msg&#39;
    2 | static_assert(false, msg);
      |                      ^^^</code></pre>
</blockquote>
<p>So, how about storing the contents of our string as part of the type of a <code>struct</code>, then produce an error containing such type?</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1"></a><span>template</span> &lt;<span>char</span>...&gt; <span>struct</span> print;</span>
<span id="cb5-2"><a href="#cb5-2"></a>print&lt;<span>&#39;a&#39;</span>, <span>&#39;b&#39;</span>, <span>&#39;c&#39;</span>, <span>&#39;d&#39;</span>&gt; _{};</span></code></pre></div>
<blockquote>
<pre><code>error: variable &#39;print&lt;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;&gt; _&#39;
       has initializer but incomplete type
    3 | print&lt;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;&gt; _{};
      |</code></pre>
</blockquote>
<p>Nice! We are able to see our characters in the compiler output, and we could theoretically mutate or generate the sequence of characters to our liking at compile-time. However, working with a <code>char...</code> template parameter pack is very cumbersome, and the final output is not very readable.</p>
<p>C++20’s <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0732r2.pdf">P0732R2: <strong>“Class Types in Non-Type Template Parameters”</strong></a> comes to the rescue here! In short, we can use any <em>literal type</em> as a non-type template parameter. We can therefore create our own little compile-time string literal type:</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1"></a><span>struct</span> ct_str</span>
<span id="cb7-2"><a href="#cb7-2"></a>{</span>
<span id="cb7-3"><a href="#cb7-3"></a>    <span>char</span>        _data[<span>512</span>]{};</span>
<span id="cb7-4"><a href="#cb7-4"></a>    <span>std::</span>size_t _size{<span>0</span>};</span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a>    <span>template</span> &lt;<span>std::</span>size_t N&gt;</span>
<span id="cb7-7"><a href="#cb7-7"></a>    <span>constexpr</span> ct_str(<span>const</span> <span>char</span> (&amp;str)[N]) : _data{}, _size{N - <span>1</span>}</span>
<span id="cb7-8"><a href="#cb7-8"></a>    {</span>
<span id="cb7-9"><a href="#cb7-9"></a>        <span>for</span>(<span>std::</span>size_t i = <span>0</span>; i &lt; _size; ++i)</span>
<span id="cb7-10"><a href="#cb7-10"></a>            _data[i] = str[i];</span>
<span id="cb7-11"><a href="#cb7-11"></a>    }</span>
<span id="cb7-12"><a href="#cb7-12"></a>};</span></code></pre></div>
<p>We can then accept <code>ct_str</code> as a template parameter for <code>print</code>, and use the same idea as before:</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1"></a><span>template</span> &lt;ct_str&gt; <span>struct</span> print;</span>
<span id="cb8-2"><a href="#cb8-2"></a>print&lt;<span>&#34;Welcome to Wordlexpr!&#34;</span>&gt; _{};</span></code></pre></div>
<blockquote>
<pre><code>error: variable &#39;print&lt;ct_str{&#34;Welcome to Wordlexpr!&#34;, 21}&gt; _&#39; has
       initializer but incomplete type
   22 | print&lt;&#34;Welcome to Wordlexpr!&#34;&gt; _{};
      |</code></pre>
</blockquote>
<p>Now we have a way of making the compiler emit whatever we’d like as an error. In fact, we can perform string manipulation at compile-time on <code>ct_str</code>:</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1"></a><span>constexpr</span> ct_str test()</span>
<span id="cb10-2"><a href="#cb10-2"></a>{</span>
<span id="cb10-3"><a href="#cb10-3"></a>    ct_str s{<span>&#34;Welcome to Wordlexpr!&#34;</span>};</span>
<span id="cb10-4"><a href="#cb10-4"></a>    s._data[<span>0</span>] = <span>&#39;w&#39;</span>;</span>
<span id="cb10-5"><a href="#cb10-5"></a>    s._data[<span>11</span>] = <span>&#39;w&#39;</span>;</span>
<span id="cb10-6"><a href="#cb10-6"></a>    s._data[<span>20</span>] = <span>&#39;.&#39;</span>;</span>
<span id="cb10-7"><a href="#cb10-7"></a>    <span>return</span> s;</span>
<span id="cb10-8"><a href="#cb10-8"></a>}</span>
<span id="cb10-9"><a href="#cb10-9"></a></span>
<span id="cb10-10"><a href="#cb10-10"></a>print&lt;test()&gt; _{};</span></code></pre></div>
<blockquote>
<pre><code>error: variable &#39;print&lt;ct_str{&#34;welcome to wordlexpr.&#34;, 20}&gt; _&#39; has
       initializer but incomplete type
   33 | print&lt;test()&gt; _{};
      |               ^</code></pre>
</blockquote>
<p>By extending <code>ct_str</code> with functionalities such as <code>append</code>, <code>contains</code>, <code>replace</code>, etc… we will end up being able to create any sort of string at compile-time and print it out as an error.</p>
<p>First problem solved!</p>
<h3 id="compile-time-random-number-generation">compile-time random number generation</h3>
<p>This is really not a big deal, if we allow our users to provide a seed on the command line via preprocessor defines. Pseudo-random number generation is always deterministic, and the final result only depends on the state of the RNG and the initially provided seed.</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1"></a>g++ -std=c++<span>20</span> ./wordlexpr.cpp -DSEED=<span>123</span></span></code></pre></div>
<p>It is fairly easy to port a common RNG engine such as Mersenne Twister to C++20 <code>constexpr</code>. For the purpose of Wordlexpr, the modulo operator (<code>%</code>) was enough:</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1"></a><span>constexpr</span> <span>const</span> ct_str&amp; get_target_word()</span>
<span id="cb13-2"><a href="#cb13-2"></a>{</span>
<span id="cb13-3"><a href="#cb13-3"></a>    <span>return</span> wordlist[SEED % wordlist_size];</span>
<span id="cb13-4"><a href="#cb13-4"></a>}</span></code></pre></div>
<p>Second problem solved!</p>
<h3 id="retaining-state-and-making-progress">retaining state and making progress</h3>
<p>If we allow the user to give us a seed via preprocessor defines, why not also allow the user to make progress in the same game session by telling us where they left off last time they played? Think of it as any save file system in a modern game – except that the “save file” is a short string which is going to be passed to the compiler:</p>
<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1"></a>g++ -std=c++<span>20</span> ./wordlexpr.cpp -DSEED=<span>123</span> -DSTATE=DJYHULDOPALISHJRBFJNSWAEIM</span></code></pre></div>
<p>The user doesn’t have to come up with the state string themselves – it will be generated by Wordlexpr on every step:</p>
<blockquote>
<pre><code>error: variable &#39;print&lt;ct_str{&#34;You guessed `crane`. Outcome: `x-xx-`.
       You guessed `white`. Outcome: `xxox-`.
       You guessed `black`. Outcome: `xoxxx`.
       You guessed `tower`. Outcome: `xxxoo`.
       To continue the game, pass `-DSTATE=EJYHULDOPALISHJRAVDLYWAEIM`
       alongside a new guess.&#34;, 242}&gt; _&#39; has initializer but incomplete
       type
 2612 |         print&lt;make_full_str(SEED, guess, s)&gt; _{};
      |                                              ^</code></pre>
</blockquote>
<p>The state of the game is stored in this simple <code>struct</code>:</p>
<div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1"></a><span>struct</span> state</span>
<span id="cb16-2"><a href="#cb16-2"></a>{</span>
<span id="cb16-3"><a href="#cb16-3"></a>    <span>std::</span>size_t _n_guesses{<span>0</span>};</span>
<span id="cb16-4"><a href="#cb16-4"></a>    ct_str      _guesses[<span>5</span>];</span>
<span id="cb16-5"><a href="#cb16-5"></a>};</span></code></pre></div>
<p>All that’s left to do is to define encoding and decoding functions for the state:</p>
<div id="cb17"><pre><code><span id="cb17-1"><a href="#cb17-1"></a><span>constexpr</span> ct_str encode_state(<span>const</span> state&amp; s);</span>
<span id="cb17-2"><a href="#cb17-2"></a><span>constexpr</span> state decode_state(<span>const</span> ct_str&amp; str);</span></code></pre></div>
<p>In Wordlexpr, I used a simple Caesar cipher to encode the guesses into the string without making them human-readable. It is not really necessary, but generally speaking another type of compile-time game might want to hide the current state by performing some sort of encoding.</p>
<p>Third problem solved!</p>
<h3 id="conclusion">conclusion</h3>
<p>I hope you enjoyed this brief explanation of how Wordlexpr works. Remember that you can play it yourself and see the entire source code <a href="https://gcc.godbolt.org/z/4oo3PrvqY">on Compiler Explorer</a>. Feel free to reach out to ask any question!</p>
<p>Now, for some shameless self-promotion:</p>
<ul>
<li><p>My book <a href="http://emcpps.com/"><strong>“Embracing Modern C++ Safely”</strong> is now available on all major resellers</a>. Please consider purchasing it and share the news with your friends and colleagues – that helps a lot!</p>
<ul>
<li>For more information, read the following interview: <a href="https://www.techatbloomberg.com/blog/why-4-bloomberg-engineers-wrote-another-cplusplus-book/">“Why 4 Bloomberg engineers wrote another C++ book”</a></li>
</ul></li>
<li><p>If you are a fan of fast-paced open-source arcade games that allow user-created content, check out <a href="https://store.steampowered.com/app/1358090/Open_Hexagon/"><strong>Open Hexagon</strong></a>, my first fully-released game <a href="https://store.steampowered.com/app/1358090/Open_Hexagon/">available on Steam</a> and <a href="https://itch.io/t/1758441/open-hexagon-my-spiritual-successor-to-super-hexagon">on itch.io</a>.</p>
<ul>
<li>Open Hexagon is a spiritual successor to the critically acclaimed Super Hexagon by Terry Cavanagh. <a href="https://twitter.com/terrycavanagh/status/1397372432877379587">Terry fully supports my project!</a> Thanks!</li>
</ul></li>
<li><p>I offer 1-1 C++ mentoring and consulting sessions in my spare time. If it’s something you are interested in, feel free to reach out at <code>mail (at) vittorioromeo (dot) com</code> or <a href="https://twitter.com/supahvee1234">on Twitter</a>.</p></li>
</ul>

        </div>
    </div></div>
  </body>
</html>
