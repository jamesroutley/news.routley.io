<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.gojiberries.io/how-to-make-things-slower-so-they-go-faster-a-jitter-design-manual/">Original</a>
    <h1>How to make things slower so they go faster</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>Synchronized demand is the moment a large cohort of clients acts almost together. In a service with capacity $\mu$ requests per second and background load $\lambda_0$, the usable headroom is $H = \mu - \lambda_0 &gt; 0$. When $M$ clients align—after a cache expiry, at a cron boundary, or as a service returns from an outage—the bucketed arrival rate can exceed $H$ by large factors. Queues form, timeouts propagate, retries synchronize, and a minor disturbance becomes a major incident. The task is to prevent such peaks when possible and to drain safely when they occur, with mechanisms that are fair to clients and disciplined about capacity.</p><p>The phenomenon has simple origins. Natural alignment comes from clocks and defaults—crons on the minute, hour‑aligned TTLs, SDK timers, people starting work at the same time. Induced alignment comes from state transitions—deployments and restarts, leader elections, circuit‑breaker reopenings, cache flushes, token refreshes, and rate‑limit windows that reset simultaneously. Adversarial and accidental alignment includes DDoS and flash crowds. In each case the system faces a coherent cohort that would be harmless if spread over time but is dangerous when synchronized.</p><p>How failure unfolds depends on which constraint binds first. Queueing delay grows as utilization approaches one, yet many resources have hard limits: connection pools, file descriptors, threads. Crossing those limits produces cliff behavior—one more connection request forces timeouts and then retries, which raise arrivals further. A narrow spike can exhaust connections long before CPU is saturated; a wider plateau can saturate CPU or bandwidth. Feedback tightens the spiral: errors beget retries, retries beget more errors. Whether work is online or offline matters, too. When a user is waiting, added delay is costly and fairness across requests matters; when no user is waiting, buffering is acceptable and the objective becomes sustained throughput.</p><p>A useful way to reason about mitigation is to make the objective explicit. If $M$ actions are spread uniformly over a window $[0, W]$, the expected per‑bucket arrival rate is $M/W$ (take one‑second buckets unless your enforcement uses a different interval) and the expected added wait per action is $W/2$. Their product is fixed,</p><p>$$ \left(\frac{M}{W}\right) \cdot \left(\frac{W}{2}\right) = \frac{M}{2}, $$</p><p>so lowering the peak by widening $W$ necessarily increases delay. The design decision is where to operate on this curve, constrained by safety and product requirements. Under any convex cost of instantaneous load—capturing rising queueing delay, tail latency, and risk near saturation—an even schedule minimizes cost for a given $W$. Formally, with rate $r(t) \geq 0$ on $[0, W]$ and $\int_0^W r(t) , dt = M$, Jensen&#39;s inequality yields</p><p>$$ \int_0^W C(r(t)) , dt \geq W , C\left(\frac{M}{W}\right), $$</p><p>with equality at $r(t) \equiv M/W$. Uniform jitter is therefore both optimal for peak reduction among schedules with the same $W$ and equitable, because each client draws from the same delay distribution.</p><p>Translating principle into practice begins with the bounds your system must satisfy. Deterministically, the headroom requirement $M/W \leq H$ gives $W \geq M/H$, and Little&#39;s Law for extra in‑flight work gives $(M/W) \cdot s \leq K \Rightarrow W \geq Ms/K$, where $s$ is a tail service time (p90–p95) and $K$ the spare concurrency budget. Expectation is not enough operationally, because bucketed counts fluctuate even under a uniform schedule. To bound the chance that any bucket exceeds headroom, size $W$ so $\Pr{N &gt; H} \leq \varepsilon$ for bucket counts $N$ modeled as $\text{Poisson}(\lambda)$ with $\lambda = M/W$ when $M$ is large and buckets are short. For $H \gtrsim 50$, a continuity‑corrected normal approximation gives an explicit $\lambda_\varepsilon$:</p><p>$$ \frac{H + 0.5 - \lambda}{\sqrt{\lambda}} \gtrsim z_{1-\varepsilon} \quad \Rightarrow \quad \lambda_\varepsilon \approx \left(\frac{-z_{1-\varepsilon} + \sqrt{z_{1-\varepsilon}^2 + 4(H + 0.5)}}{2}\right)^2, \quad W \geq \frac{M}{\lambda_\varepsilon}. $$</p><p>For small $H$ or very small $\varepsilon$, compute the exact Poisson tail (or use a Chernoff bound) rather than relying on the normal approximation. Server‑provided hints refine the same calculation: a <code>Retry‑After = Δ</code> header shifts the start and requires jitter over $[\Delta, \Delta + W]$; published rate‑limit fields (Remaining $R$, Reset $\Delta$) define an admitted rate $\lambda_{\text{adm}} = \min(H, R/\Delta)$, which implies $W \geq M/\lambda_{\text{adm}}$. Product constraints set upper bounds: finishing by a deadline $D$ or keeping p95 added wait $\leq L$ implies $W \leq D$ and, since p95 of $\text{Uniform}[0, W]$ equals $0.95W$, $W \leq L/0.95$. The minimal‑waiting policy is to choose the smallest $W$ that satisfies all lower bounds while respecting upper bounds; if that is infeasible, either add capacity or relax requirements.</p><p>This same arithmetic governs prevention and recovery; what changes is timing. In steady state, the goal is to prevent cohorts from forming or acting in sync: randomize TTLs, splay periodic work, de‑synchronize health checks and timers, and use jittered backoff for retries while honoring server hints. When a backlog already exists, the goal is to drain safely. With fixed headroom $H$, the minimum safe drain time is $M/H$; with time‑varying headroom $H(t)$ due to autoscaling or warm‑up, the earliest possible drain time satisfies</p><p>$$ \int_0^{T_{\text{drain}}} H(t) , dt = M. $$</p><p>The capacity‑filling ideal admits at $r^*(t) = H(t)$ until drained, which can be approximated without client coordination by pacing admissions server‑side with a token bucket refilled at an estimate $\hat{H}(t)$. Requests are accepted only when a token is available and otherwise receive a fast response with a short <code>Retry‑After</code> so clients can self‑schedule.</p><p>Seen this way, implementation is a single control problem rather than a menu of tricks. Short‑horizon headroom is forecast from telemetry (request rate, latency, queue depth, error rates, and autoscaler intent). Decisions minimize a loss that trades overload risk against added wait (and, where relevant, explicit cost). Actions combine slowing demand and adding supply, but real admissions are always paced to match estimated headroom. Clients remain simple: full (uniform) jitter with backoff, respect for <code>Retry‑After</code> and published rate‑limit fields, and strict retry budgets. Scaling is valuable when it arrives in time; without pacing, added instances can still admit synchronized bursts.</p><p>Verification closes the loop by confronting assumptions with behavior. In steady state track peak‑to‑average ratios, per‑second peaks, tail latency, and retry rates; during recovery drills compare predicted and actual drain times and verify that peaks stayed at or below headroom. The common errors are predictable: understating $M$; overstating $H$; ignoring service‑time tails so connection pools fail first; and forgetting that new arrivals reduce headroom available to a backlog. Start conservatively with a wider window, measure outcomes, and tighten once you have data.</p><p>The conclusion is simple. Peaks are a synchronization problem; jitter is an equitable way to allocate delay when the objective is to minimize overload risk at minimal added latency. Its parameters are determined by measurable constraints, not taste. Queue when no user is waiting, jitter when fairness and latency both matter, reject when delay is unacceptable, and scale when supply can rise in time. Pace admissions so the plan survives real‑world dynamics, and the synchronized spike becomes a controlled flow.</p>
        </div></div>
  </body>
</html>
