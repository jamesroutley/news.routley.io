<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://axisofeval.blogspot.com/2024/01/common-lisps-block-return-from-and.html">Original</a>
    <h1>Common Lisp&#39;s block / return-from and unwind-protect</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-3640259933044464038" itemprop="description articleBody">
<p>I was just <a href="https://twitter.com/TitzerBL/status/1743775279485452497">chatting with Ben Titzer on Twitter</a> about control flow in his <a href="https://github.com/titzer/virgil">Virgil language</a> (which is cool and you should definitely check out), when I felt the need to <b>once more promote how Common Lisp does non-local control flow</b> (stuff like returning early from a function or breaking from a loop), because I think it&#39;s a very nice solution.</p><p>So in Common Lisp we have BLOCK / RETURN-FROM (which work as a pair) and UNWIND-PROTECT.</p><h3>BLOCK / RETURN-FROM</h3><p><a href="http://clhs.lisp.se/Body/s_block.htm">BLOCK</a> and <a href="http://clhs.lisp.se/Body/s_ret_fr.htm">RETURN-FROM</a> effectively offer the same functionality as C&#39;s <b>setjmp/longjmp</b> -- non-local exits -- but nicely wrapped as we expect it in a lexically-scoped, expression-oriented language.</p><p>BLOCK / RETURN-FROM lets you do:</p><ul><li><b>Early returns</b> from functions or arbitrary code blocks</li><li><b>Breaking</b> from loops, including any number of nested loops</li><li><b>Continuing</b> in loops, including any number of nested loops</li><li>Even <b>arbitrary GOTOs</b> in a code block (with some macrology &amp; trampolining, see <a href="https://www.plover.com/~mjd/misc/hbaker-archive/MetaCircular.html">Baker&#39;s TAGBODY</a>)</li></ul><p><b>(block name forms*)</b> lexically binds name within the forms as a non-local exit from which you can return a value with <b>(return-from name value)</b>. Just <b>(return-from name)</b> without a value uses nil as the value.</p><p>A BLOCK without any RETURN-FROM just returns the last value: </p><p><b>(block b 1 2 3)</b> returns 3.</p><p>This prints 1 and returns 2:</p><p><b>(block b (print 1) (return-from b 2) (print 3))</b></p><p>You can have any number of <b>nested blocks</b>:</p><p><b>(block b1 ... (block b2 ... (return-from b1) ...) ...)</b></p><p>To do an <b>early return</b> from a function, place a block at its beginning:</p><p><b>(defun foo ()</b></p><p><b>    (block b </b></p><p><b>    </b><b>    </b><b>...</b></p><p><b>    </b><b>    </b><b>(return-from b)</b></p><p><b>        </b><b>...))</b></p><p>(Common Lisp automatically places an anonymous block around every function body, so you don&#39;t need to do this in practice, but my hobby Lisp doesn&#39;t, and I&#39;m using this explicit approach, and I like it.)</p><p>To <b>break from a loop</b>, place a block around it:</p><p><b>(block break</b></p><p><b>    (loop</b></p><p><b>    </b><b>    </b><b>...</b></p><p><b>        (return-from break)</b></p><p><b>        </b><b>...))</b></p><p>To <b>continue in a loop</b>, place a block inside it:</p><p><b>(loop</b></p><p><b>    (block continue</b></p><p><b>        ...</b></p><p><b>        (return-from continue)</b></p><p><b>        ...))</b></p><p>You can have <b>multiple nested loops</b>, like in Java:</p><p><b>(block break-outer</b></p><p><b>    (loop</b></p><p><b>        (block break-inner</b></p><p><b>    </b><b>    </b><b>    </b><b>(loop</b></p><p><b>            </b><b>    </b><b>...</b></p><p><b>                (return-from break-inner)</b></p><p><b>                ...))))</b></p><h3>UNWIND-PROTECT</h3><p><a href="http://clhs.lisp.se/Body/s_unwind.htm">UNWIND-PROTECT</a> is effectively a try/finally block (without a catch).</p><p><b>(unwind-protect protected-form cleanup-forms*)</b> evaluates the protected form, and regardless of whether it returns normally or does a non-local exit with RETURN-FROM, the cleanup forms are evaluated.</p><p><b>(unwind-protect (foo)</b></p><p><b>   (bar)</b></p><p><b>   </b><b>(quux))</b></p><p>is analogous to</p><p><b>try {</b></p><p><b>   return foo();</b></p><p><b>} finally {</b></p><p><b>   bar();</b></p><p><b>   quux();</b></p><p><b>}</b></p><p>Both of the following expressions print 2 and return 1:</p><p><b>(unwind-protect 1</b></p><p><b>   (print 2))</b></p><p><b>(block exit</b></p><p><b>   </b><b>(unwind-protect (return-from exit 1)</b></p><p><b>      (print 2)))</b></p><h3>Conclusion</h3><p>Common Lisp&#39;s BLOCK / RETURN-FROM and UNWIND-PROTECT offer a minimalistic and expressive system for non-local control flow.</p>

</div></div>
  </body>
</html>
