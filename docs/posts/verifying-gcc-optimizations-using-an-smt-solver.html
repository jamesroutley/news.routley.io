<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kristerw.github.io/2022/11/01/verifying-optimizations/">Original</a>
    <h1>Verifying GCC optimizations using an SMT solver</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p><em>This post describes the implementation of <a href="https://github.com/kristerw/pysmtgcc">pysmtgcc</a>. See “<a href="https://kristerw.github.io/2022/09/13/translation-validation/">GCC Translation Validation</a>” for background information.</em></p>


<p>SMT solvers are used to find solutions to a system of equations. As a first example, let’s consider</p><p>

\[3x + xy = 12\\\\
x^2 + y^2 = 13\]

</p><p>where \(x,y\in\mathbb{Z}\). There is a convenient Python API for Z3 and CVC5<sup id="fnref:CVC5" role="doc-noteref"><a href="#fn:CVC5" rel="footnote">1</a></sup> that we can use this to solve this equation.</p>

<h3 id="creating-the-variables">Creating the variables</h3>
<p>We start by creating the variables \(x\) and \(y\).</p>
<div><div><pre><code><span>x</span> <span>=</span> <span>z3</span><span>.</span><span>Const</span><span>(</span><span>&#34;x&#34;</span><span>,</span> <span>z3</span><span>.</span><span>IntSort</span><span>())</span>
<span>y</span> <span>=</span> <span>z3</span><span>.</span><span>Const</span><span>(</span><span>&#34;y&#34;</span><span>,</span> <span>z3</span><span>.</span><span>IntSort</span><span>())</span>
</code></pre></div></div>
<p><code>IntSort()</code> sets the type to be a bignum integer. We could have used some other type, such as BitVecSort(32) representing 32-bit integers.</p>

<h3 id="creating-the-equations-to-solve">Creating the equations to solve</h3>
<p>Next, we create a solver representing the problem to solve and populate it with our formulas</p>
<div><div><pre><code><span>solver</span> <span>=</span> <span>z3</span><span>.</span><span>Solver</span><span>()</span>
<span>solver</span><span>.</span><span>append</span><span>(</span><span>z3</span><span>.</span><span>IntVal</span><span>(</span><span>3</span><span>)</span> <span>*</span> <span>x</span> <span>+</span> <span>x</span> <span>*</span> <span>y</span> <span>==</span> <span>z3</span><span>.</span><span>IntVal</span><span>(</span><span>12</span><span>))</span>
<span>solver</span><span>.</span><span>append</span><span>(</span><span>x</span> <span>*</span> <span>x</span> <span>+</span> <span>y</span> <span>*</span> <span>y</span> <span>==</span> <span>z3</span><span>.</span><span>IntVal</span><span>(</span><span>13</span><span>))</span>
</code></pre></div></div>
<p>The Python API can convert Python values to SMT values without an explicit cast, so we can write, e.g., <code>z3.IntVal(3)</code> as <code>3</code>, which makes this easier to read</p>
<div><div><pre><code><span>solver</span> <span>=</span> <span>z3</span><span>.</span><span>Solver</span><span>()</span>
<span>solver</span><span>.</span><span>append</span><span>(</span><span>3</span> <span>*</span> <span>x</span> <span>+</span> <span>x</span> <span>*</span> <span>y</span> <span>==</span> <span>12</span><span>)</span>
<span>solver</span><span>.</span><span>append</span><span>(</span><span>x</span> <span>*</span> <span>x</span> <span>+</span> <span>y</span> <span>*</span> <span>y</span> <span>==</span> <span>13</span><span>)</span>
</code></pre></div></div>

<h3 id="running-the-solver">Running the solver</h3>
<p>Finally, we add a call to <code>solver.check()</code> to solve the equation. The solver will, in principle, test all possible values, but it has clever ways of eliminating cases that cannot be a solution, and it is surprisingly fast for most cases that happen in reality.</p>

<p>The SMT solver returns one of</p>
<ul>
  <li>‘sat’ – the system of equations has a solution. The solution can then be obtained by calling <code>solver.model()</code>.</li>
  <li><code>unsat</code> – no solution exists<sup id="fnref:proof" role="doc-noteref"><a href="#fn:proof" rel="footnote">2</a></sup>.</li>
  <li><code>unknown</code> – the operation timed out, or the solver ran out of memory.</li>
</ul>

<div><div><pre><code><span>res</span> <span>=</span> <span>solver</span><span>.</span><span>check</span><span>()</span>
<span>if</span> <span>res</span> <span>==</span> <span>z3</span><span>.</span><span>sat</span><span>:</span>
    <span>print</span><span>(</span><span>f</span><span>&#34;</span><span>{</span><span>solver</span><span>.</span><span>model</span><span>()</span><span>}</span><span>&#34;</span><span>)</span>
<span>elif</span> <span>res</span> <span>==</span> <span>z3</span><span>.</span><span>unsat</span><span>:</span>
    <span>print</span><span>(</span><span>&#34;Has no solution&#34;</span><span>)</span>
<span>else</span><span>:</span>
    <span>print</span><span>(</span><span>&#34;Timeout&#34;</span><span>)</span>
</code></pre></div></div>
<h3 id="summary">Summary</h3>
<p>Putting all of this together gives us the Python script</p>
<div><div><pre><code><span>import</span> <span>z3</span>

<span>x</span> <span>=</span> <span>z3</span><span>.</span><span>Const</span><span>(</span><span>&#34;x&#34;</span><span>,</span> <span>z3</span><span>.</span><span>IntSort</span><span>())</span>
<span>y</span> <span>=</span> <span>z3</span><span>.</span><span>Const</span><span>(</span><span>&#34;y&#34;</span><span>,</span> <span>z3</span><span>.</span><span>IntSort</span><span>())</span>

<span>solver</span> <span>=</span> <span>z3</span><span>.</span><span>Solver</span><span>()</span>
<span>solver</span><span>.</span><span>append</span><span>(</span><span>3</span> <span>*</span> <span>x</span> <span>+</span> <span>x</span> <span>*</span> <span>y</span> <span>==</span> <span>12</span><span>)</span>
<span>solver</span><span>.</span><span>append</span><span>(</span><span>x</span> <span>*</span> <span>x</span> <span>+</span> <span>y</span> <span>*</span> <span>y</span> <span>==</span> <span>13</span><span>)</span>

<span>res</span> <span>=</span> <span>solver</span><span>.</span><span>check</span><span>()</span>
<span>if</span> <span>res</span> <span>==</span> <span>z3</span><span>.</span><span>sat</span><span>:</span>
    <span>print</span><span>(</span><span>f</span><span>&#34;</span><span>{</span><span>solver</span><span>.</span><span>model</span><span>()</span><span>}</span><span>&#34;</span><span>)</span>
<span>elif</span> <span>res</span> <span>==</span> <span>z3</span><span>.</span><span>unsat</span><span>:</span>
    <span>print</span><span>(</span><span>&#34;Has no solution&#34;</span><span>)</span>
<span>else</span><span>:</span>
    <span>print</span><span>(</span><span>&#34;Timeout&#34;</span><span>)</span>
</code></pre></div></div>


<p>We can use an SMT solver to verify compiler optimizations. The idea is that an optimization is valid if the original and optimized functions return the same value for all valid input<sup id="fnref:memory" role="doc-noteref"><a href="#fn:memory" rel="footnote">3</a></sup>, so we let the SMT solver try to find a solution to</p><p>

\[f(x) \neq f_{optimized}(x)\]

</p><p>The optimization is valid if it does not exist any solution.</p>

<p><strong>Example</strong>: To check the optimization where</p>
<div><div><pre><code><span>unsigned</span> <span>src</span><span>(</span><span>unsigned</span> <span>a</span><span>,</span> <span>unsigned</span> <span>b</span><span>)</span>
<span>{</span>
  <span>return</span> <span>(</span><span>a</span> <span>&amp;</span> <span>~</span><span>b</span><span>)</span> <span>-</span> <span>(</span><span>a</span> <span>&amp;</span> <span>b</span><span>);</span>
<span>}</span>
</code></pre></div></div>
<p>is optimized to</p>
<div><div><pre><code><span>unsigned</span> <span>tgt</span><span>(</span><span>unsigned</span> <span>a</span><span>,</span> <span>unsigned</span> <span>b</span><span>)</span>
<span>{</span>
  <span>return</span> <span>(</span><span>a</span> <span>^</span> <span>b</span><span>)</span> <span>-</span> <span>b</span><span>;</span>
<span>}</span>
</code></pre></div></div>
<p>we encode it as</p>
<div><div><pre><code><span>import</span> <span>z3</span>

<span>a</span> <span>=</span> <span>z3</span><span>.</span><span>Const</span><span>(</span><span>&#34;a&#34;</span><span>,</span> <span>z3</span><span>.</span><span>BitVecSort</span><span>(</span><span>32</span><span>))</span>
<span>b</span> <span>=</span> <span>z3</span><span>.</span><span>Const</span><span>(</span><span>&#34;b&#34;</span><span>,</span> <span>z3</span><span>.</span><span>BitVecSort</span><span>(</span><span>32</span><span>))</span>

<span>src_retval</span> <span>=</span> <span>(</span><span>a</span> <span>&amp;</span> <span>~</span><span>b</span><span>)</span> <span>-</span> <span>(</span><span>a</span> <span>&amp;</span> <span>b</span><span>)</span>
<span>tgt_retval</span> <span>=</span> <span>(</span><span>a</span> <span>^</span> <span>b</span><span>)</span> <span>-</span> <span>b</span>

<span>solver</span> <span>=</span> <span>z3</span><span>.</span><span>Solver</span><span>()</span>
<span>solver</span><span>.</span><span>append</span><span>(</span><span>src_retval</span> <span>!=</span> <span>tgt_retval</span><span>)</span>

<span>res</span> <span>=</span> <span>solver</span><span>.</span><span>check</span><span>()</span>
<span>if</span> <span>res</span> <span>==</span> <span>z3</span><span>.</span><span>unsat</span><span>:</span>
    <span>print</span><span>(</span><span>&#34;Transformation seems to be correct.&#34;</span><span>)</span>
<span>elif</span> <span>res</span> <span>==</span> <span>z3</span><span>.</span><span>sat</span><span>:</span>
    <span>print</span><span>(</span><span>f</span><span>&#34;Incorrect: </span><span>{</span><span>solver</span><span>.</span><span>model</span><span>()</span><span>}</span><span>&#34;</span><span>)</span>
<span>else</span><span>:</span>
    <span>print</span><span>(</span><span>&#34;Timeout&#34;</span><span>)</span>
</code></pre></div></div>

<h2 id="undefined-behavior">Undefined behavior</h2>
<p>One complication is that some operations have restrictions on what values they accept. For example, the result of <code>1/x</code> is not defined for <code>x=0</code>. We must therefore exclude any input that invokes this undefined behavior for any instruction. We must also check that the optimized function does not introduce any new undefined behavior for values where the original function had a defined result.</p>

<p>This is done by adding two SMT formulas <code>src_invokes_ub</code> and <code>tgt_invokes_ub</code> that keep track of the cases where the two functions invoke UB, and we change the solver setup to</p>
<div><div><pre><code>solver = z3.Solver()
solver.append(z3.Not(src_invokes_ub))
solver.append(Or(src_retval != tgt_retval, tgt_invokes_ub))
</code></pre></div></div>

<p><strong>Example</strong>: To check the optimization where</p>
<div><div><pre><code><span>int</span> <span>src</span><span>(</span><span>int</span> <span>x</span><span>)</span>
<span>{</span>
  <span>return</span> <span>1</span> <span>/</span> <span>x</span><span>;</span>
<span>}</span>
</code></pre></div></div>
<p>is optimized to</p>
<div><div><pre><code><span>int</span> <span>tgt</span><span>(</span><span>int</span> <span>x</span><span>)</span>
<span>{</span>
  <span>return</span> <span>((</span><span>unsigned</span><span>)</span><span>x</span> <span>+</span> <span>1</span><span>)</span> <span>&lt;=</span> <span>2</span> <span>?</span> <span>x</span> <span>:</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>
<p>we encode it as</p>
<div><div><pre><code><span>import</span> <span>z3</span>

<span>x</span> <span>=</span> <span>z3</span><span>.</span><span>Const</span><span>(</span><span>&#34;x&#34;</span><span>,</span> <span>z3</span><span>.</span><span>BitVecSort</span><span>(</span><span>32</span><span>))</span>

<span>src_retval</span> <span>=</span> <span>1</span> <span>/</span> <span>x</span>
<span>src_invokes_ub</span> <span>=</span> <span>x</span> <span>==</span> <span>0</span>
<span>tgt_retval</span> <span>=</span> <span>z3</span><span>.</span><span>If</span><span>(</span><span>z3</span><span>.</span><span>ULE</span><span>((</span><span>x</span> <span>+</span> <span>1</span><span>),</span> <span>2</span><span>),</span> <span>x</span><span>,</span> <span>0</span><span>)</span>
<span>tgt_invokes_ub</span> <span>=</span> <span>False</span>

<span>solver</span> <span>=</span> <span>z3</span><span>.</span><span>Solver</span><span>()</span>
<span>solver</span><span>.</span><span>append</span><span>(</span><span>z3</span><span>.</span><span>Not</span><span>(</span><span>src_invokes_ub</span><span>))</span>
<span>solver</span><span>.</span><span>append</span><span>(</span><span>z3</span><span>.</span><span>Or</span><span>(</span><span>src_retval</span> <span>!=</span> <span>tgt_retval</span><span>,</span> <span>tgt_invokes_ub</span><span>))</span>

<span>res</span> <span>=</span> <span>solver</span><span>.</span><span>check</span><span>()</span>
<span>if</span> <span>res</span> <span>==</span> <span>z3</span><span>.</span><span>unsat</span><span>:</span>
    <span>print</span><span>(</span><span>&#34;Transformation seems to be correct.&#34;</span><span>)</span>
<span>elif</span> <span>res</span> <span>==</span> <span>z3</span><span>.</span><span>sat</span><span>:</span>
    <span>print</span><span>(</span><span>f</span><span>&#34;Incorrect: </span><span>{</span><span>solver</span><span>.</span><span>model</span><span>()</span><span>}</span><span>&#34;</span><span>)</span>
<span>else</span><span>:</span>
    <span>print</span><span>(</span><span>&#34;Timeout&#34;</span><span>)</span>
</code></pre></div></div>

<p><strong>Note</strong>: One must be careful with <code>src_invokes_ub</code> as it makes the SMT solver ignore all values where it is <code>True</code> – e.g., a bug always setting it to <code>True</code> will say that all optimizations are correct, regardless of what they do!</p>

<p><code>pysmtgcc</code> does that checking in two steps – first, it checks that the functions return the same value</p>
<div><div><pre><code><span>solver</span> <span>=</span> <span>z3</span><span>.</span><span>Solver</span><span>()</span>
<span>solver</span><span>.</span><span>append</span><span>(</span><span>z3</span><span>.</span><span>Not</span><span>(</span><span>src_invokes_ub</span><span>))</span>
<span>solver</span><span>.</span><span>append</span><span>(</span><span>src_retval</span> <span>!=</span> <span>tgt_retval</span><span>,</span> <span>tgt_invokes_ub</span><span>)</span>
<span>res</span> <span>=</span> <span>solver</span><span>.</span><span>check</span><span>()</span>
<span>...</span>
</code></pre></div></div>
<p>and then it checks that the optimized function does not have additional UB</p>
<div><div><pre><code><span>solver</span> <span>=</span> <span>z3</span><span>.</span><span>Solver</span><span>()</span>
<span>solver</span><span>.</span><span>append</span><span>(</span><span>z3</span><span>.</span><span>Not</span><span>(</span><span>src_invokes_ub</span><span>))</span>
<span>solver</span><span>.</span><span>append</span><span>(</span><span>tgt_invokes_ub</span><span>)</span>
<span>res</span> <span>=</span> <span>solver</span><span>.</span><span>check</span><span>()</span>
<span>...</span>
</code></pre></div></div>
<p>The reason is that it made it easier for me to debug issues – if the return value differs, then I can just take the model values and generate a test case. If it is UB that does not modify the return value, then it needs a closer look to determine which instruction that invokes undefined behavior.</p>



<p>Generating an SMT formula for a GIMPLE function is done by iterating over the IR and building the SMT expressions as we go. We keep track of the translated expressions using a Python dictionary, which we use when looking up instruction operands</p>
<div><div><pre><code><span>def</span> <span>get_tree_as_smt</span><span>(</span><span>expr</span><span>,</span> <span>smt_fun</span><span>):</span>
    <span>if</span> <span>isinstance</span><span>(</span><span>expr</span><span>,</span> <span>gcc</span><span>.</span><span>ParmDecl</span><span>):</span>
        <span>return</span> <span>smt_fun</span><span>.</span><span>tree_to_smt</span><span>[</span><span>expr</span><span>]</span>
    <span>if</span> <span>isinstance</span><span>(</span><span>expr</span><span>,</span> <span>gcc</span><span>.</span><span>SsaName</span><span>):</span>
        <span>return</span> <span>smt_fun</span><span>.</span><span>tree_to_smt</span><span>[</span><span>expr</span><span>]</span>
    <span>if</span> <span>isinstance</span><span>(</span><span>expr</span><span>,</span> <span>gcc</span><span>.</span><span>IntegerCst</span><span>):</span>
        <span>if</span> <span>isinstance</span><span>(</span><span>expr</span><span>.</span><span>type</span><span>,</span> <span>gcc</span><span>.</span><span>BooleanType</span><span>):</span>
            <span>return</span> <span>BoolVal</span><span>(</span><span>expr</span><span>.</span><span>constant</span> <span>!=</span> <span>0</span><span>)</span>
        <span>assert</span> <span>isinstance</span><span>(</span><span>expr</span><span>.</span><span>type</span><span>,</span> <span>gcc</span><span>.</span><span>IntegerType</span><span>)</span>
        <span>return</span> <span>BitVecVal</span><span>(</span><span>expr</span><span>.</span><span>constant</span><span>,</span> <span>expr</span><span>.</span><span>type</span><span>.</span><span>precision</span><span>)</span>
    <span>...</span>
</code></pre></div></div>
<p>The translation of a GIMPLE function is done as</p>
<div><div><pre><code><span>for</span> <span>bb</span> <span>in</span> <span>fun</span><span>.</span><span>cfg</span><span>.</span><span>inverted_post_order</span><span>:</span>
    <span>for</span> <span>stmt</span> <span>in</span> <span>bb</span><span>.</span><span>gimple</span><span>:</span>
        <span>if</span> <span>isinstance</span><span>(</span><span>stmt</span><span>,</span> <span>gcc</span><span>.</span><span>GimpleAssign</span><span>)</span> <span>and</span> <span>len</span><span>(</span><span>stmt</span><span>.</span><span>rhs</span><span>)</span> <span>==</span> <span>2</span><span>:</span>
            <span># Binary operation
</span>            <span>rhs0</span> <span>=</span> <span>get_tree_as_smt</span><span>(</span><span>stmt</span><span>.</span><span>rhs</span><span>[</span><span>0</span><span>],</span> <span>smt_fun</span><span>)</span>
            <span>rhs1</span> <span>=</span> <span>get_tree_as_smt</span><span>(</span><span>stmt</span><span>.</span><span>rhs</span><span>[</span><span>1</span><span>],</span> <span>smt_fun</span><span>)</span>
            <span>if</span> <span>stmt</span><span>.</span><span>exprcode</span> <span>==</span> <span>gcc</span><span>.</span><span>BitIorExpr</span><span>:</span>
                <span>smt_fun</span><span>.</span><span>tree_to_smt</span><span>[</span><span>stmt</span><span>.</span><span>lhs</span><span>]</span> <span>=</span> <span>rhs0</span> <span>|</span> <span>rhs1</span>
            <span>elif</span> <span>stmt</span><span>.</span><span>exprcode</span> <span>==</span> <span>gcc</span><span>.</span><span>BitAndExpr</span><span>:</span>
                <span>smt_fun</span><span>.</span><span>tree_to_smt</span><span>[</span><span>stmt</span><span>.</span><span>lhs</span><span>]</span> <span>=</span> <span>rhs0</span> <span>&amp;</span> <span>rhs1</span>
            <span>elif</span> <span>stmt</span><span>.</span><span>exprcode</span> <span>==</span> <span>gcc</span><span>.</span><span>BitXorExpr</span><span>:</span>
                <span>smt_fun</span><span>.</span><span>tree_to_smt</span><span>[</span><span>stmt</span><span>.</span><span>lhs</span><span>]</span> <span>=</span> <span>rhs0</span> <span>^</span> <span>rhs1</span>
            <span>elif</span> <span>...</span>
                <span>...</span>
        <span>elif</span> <span>...</span>
            <span>...</span>
</code></pre></div></div>
<p>where <code>fun</code> is the GIMPLE function we receive from GCC, and <code>smt_fun</code> is the class representing this function in <code>pysmtgcc</code>.</p>

<p>Doing the translation in one pass works reasonably well for experiments like <code>pysmtgcc</code>, but it has problems. For example, it would be hard to handle loops with this method<sup id="fnref:loops" role="doc-noteref"><a href="#fn:loops" rel="footnote">4</a></sup>. So a real implementation would need to transform the IR into a representation it can analyze and modify before generating the SMT formula.</p>

<h2 id="gimple-undefined-behavior">GIMPLE undefined behavior</h2>

<p>GIMPLE undefined behavior is similar to how it is done in the C language. For example, arithmetic instructions such as <code>PLUS_EXPR</code> invokes undefined behavior if a signed addition wraps, and the program is then invalid<sup id="fnref:llvm_ub" role="doc-noteref"><a href="#fn:llvm_ub" rel="footnote">5</a></sup>. So the implementation just builds <code>invokes_ub</code> as describes in “Verifying compiler optimizations” above. For example, integer addition is implemented as</p>
<div><div><pre><code><span>if</span> <span>stmt</span><span>.</span><span>exprcode</span> <span>==</span> <span>gcc</span><span>.</span><span>PlusExpr</span><span>:</span>
    <span>res</span> <span>=</span> <span>rhs0</span> <span>+</span> <span>rhs1</span>
    <span>if</span> <span>not</span> <span>stmt</span><span>.</span><span>lhs</span><span>.</span><span>type</span><span>.</span><span>overflow_wraps</span><span>:</span>
        <span>erhs0</span> <span>=</span> <span>SignExt</span><span>(</span><span>1</span><span>,</span> <span>rhs0</span><span>)</span>
        <span>erhs1</span> <span>=</span> <span>SignExt</span><span>(</span><span>1</span><span>,</span> <span>rhs1</span><span>)</span>
        <span>eres</span> <span>=</span> <span>erhs0</span> <span>+</span> <span>erhs1</span>
        <span>smt_fun</span><span>.</span><span>invokes_ub</span> <span>=</span> <span>Or</span><span>(</span><span>SignExt</span><span>(</span><span>1</span><span>,</span> <span>res</span><span>)</span> <span>!=</span> <span>eres</span><span>,</span> <span>smt_fun</span><span>.</span><span>invokes_ub</span><span>)</span>
    <span>smt_fun</span><span>.</span><span>tree_to_smt</span><span>[</span><span>stmt</span><span>.</span><span>lhs</span><span>]</span> <span>=</span> <span>res</span>
</code></pre></div></div>
<p>It is, unfortunately, a bit unclear exactly what is UB in GIMPLE<sup id="fnref:PR106811" role="doc-noteref"><a href="#fn:PR106811" rel="footnote">6</a></sup>. Some are documented in <a href="https://gcc.gnu.org/git/?p=gcc.git;a=blob;f=gcc/tree.def"><code>tree.def</code></a>, but not all. And the text in <code>tree.def</code> is a bit unclear. For example, for the number of bits to shift by in shift instructions, it says</p>

<blockquote>
  <p>Note that the result is undefined if the second operand is larger than or equal to the first operand’s type size.</p>
</blockquote>

<p>Does this mean that this invokes undefined behavior? Or that it is defined, but it can return an arbitrary value? Anyway, GCC optimizes code involving shift instructions in ways that are invalid for both interpretations<sup id="fnref:PR106884" role="doc-noteref"><a href="#fn:PR106884" rel="footnote">7</a></sup>.</p>


<p>This section discusses some issues that annoyed me during the implementation.</p>

<h2 id="floating-point">Floating point</h2>
<p>The IEEE-754 floating-point representation for NaN is not unique – for example, the significand may contain a payload thath can be used to pass additional information<sup id="fnref:NaN" role="doc-noteref"><a href="#fn:NaN" rel="footnote">8</a></sup>. The SMT solver does, however, canonicalize NaN to one value, which makes the result differ after some optimizations.</p>

<p>This is not a big problem – different CPU architectures handle payload differently, so the GCC middle-end can only make a few assumptions. But it fails tests where a function</p>
<div><div><pre><code><span>int</span> <span>foo</span><span>(</span><span>int</span> <span>i</span><span>)</span>
<span>{</span>
  <span>union</span> <span>{</span>
    <span>int</span> <span>i</span><span>;</span>
    <span>float</span> <span>f</span><span>;</span>
  <span>}</span> <span>u</span><span>;</span>
  <span>u</span><span>.</span><span>i</span> <span>=</span> <span>i</span><span>;</span>
  <span>u</span><span>.</span><span>f</span> <span>=</span> <span>u</span><span>.</span><span>f</span><span>;</span>
  <span>return</span> <span>u</span><span>.</span><span>i</span><span>;</span>
<span>}</span>
</code></pre></div></div>
<p>is optimized to</p>
<div><div><pre><code><span>int</span> <span>foo</span><span>(</span><span>int</span> <span>i</span><span>)</span>
<span>{</span>
  <span>return</span> <span>i</span><span>;</span>
<span>}</span>
</code></pre></div></div>
<p>as this gives different results for the SMT solver when, e.g., <code>i = -2</code>.</p>

<p>We could fix this particular case by always representing a floating-point number as a bit vector, and only making it a floating-point sort when needed. But that would give us a similar problem when optimizing</p>
<div><div><pre><code><span>int</span> <span>foo</span><span>(</span><span>int</span> <span>i</span><span>)</span>
<span>{</span>
  <span>union</span> <span>{</span>
    <span>int</span> <span>i</span><span>;</span>
    <span>float</span> <span>f</span><span>;</span>
  <span>}</span> <span>u</span><span>;</span>
  <span>float</span> <span>t</span> <span>=</span> <span>-</span><span>0</span><span>.</span><span>0</span><span>;</span>
  <span>u</span><span>.</span><span>i</span> <span>=</span> <span>i</span><span>;</span>
  <span>u</span><span>.</span><span>f</span> <span>=</span> <span>u</span><span>.</span><span>f</span> <span>+</span> <span>t</span><span>;</span>
  <span>return</span> <span>u</span><span>.</span><span>i</span><span>;</span>
<span>}</span>
</code></pre></div></div>
<p>as it converts the bit vector to a floating-point sort when doing the addition, but not when the addition with <code>-0.0</code> has been eliminated.</p>

<p>I cannot see any way to solve all the problems without writing my own SMT floating point implementation<sup id="fnref:float" role="doc-noteref"><a href="#fn:float" rel="footnote">9</a></sup>…</p>

<h2 id="interprocedural-optimizations">Interprocedural optimizations</h2>
<p>GCC does interprocedural optimizations that move code between functions etc., and this cannot be handled by <code>pysmtgcc</code> as it works on one function at a time. We mitigate this by skipping the interprocedural (“IPA”) passes in <code>plugin1.py</code>, but that does not solve all problems…</p>

<p>The IPA passes do global analysis, which can then be queried by the normal GIMPLE passes that work one function at a time. There are two cases where use of such information incorrectly is reported as miscompilations:</p>

<ul>
  <li>
    <p>Initialized static variables that are never written work in the same ways as constants, so their uses can be substituted by the constants (that can then be constant folded etc.).</p>
  </li>
  <li>
    <p>Static functions that are always called with constants for some arguments can be optimized with knowledge of those values. For example, if a function</p>
    <div><div><pre><code><span>int</span> <span>foo</span><span>(</span><span>int</span> <span>a</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>a</span> <span>&gt;</span> <span>10</span><span>)</span>
    <span>return</span> <span>42</span><span>;</span>
  <span>return</span> <span>23</span><span>;</span>
<span>}</span>
</code></pre></div>    </div>
    <p>only is called as <code>foo(1)</code> and <code>foo(9)</code>, then it can be optimized to the equivalent of</p>
    <div><div><pre><code><span>int</span> <span>foo</span><span>(</span><span>int</span> <span>a</span><span>)</span> <span>{</span>
  <span>return</span> <span>23</span><span>;</span>
<span>}</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>We can solve this by letting <code>pysmtgcc</code> query the IPA information, and generate SMT using that information:</p>
<ul>
  <li>Treat global <code>static</code> variables in the same way as <code>const</code> if the IPA information says it is not written to.</li>
  <li>Adding extra constraints to function <code>gcc.ParmDecl</code>, restricting the values to the ones used in the calls.</li>
</ul>

<p>But the <code>gcc-python-plugin</code> does not have APIs for querying the IPA information, so I currently ignore those issues (by passing <code>-Dstatic=&#34;&#34;</code> to the compiler).</p>

<h2 id="parallel-z3">Parallel Z3</h2>
<p>It is possible to get Z3 to distribute its work over multiple threads by setting
the <code>parallel.enable</code> parameter to <code>True</code>:</p>
<div><div><pre><code><span>z3</span><span>.</span><span>set_param</span><span>(</span><span>&#34;parallel.enable&#34;</span><span>,</span> <span>True</span><span>)</span>
</code></pre></div></div>
<p>I guess it makes Z3 faster, but timeouts stop working, so the resulting plugin is slower when some checks take “forever” to analyze instead of giving up after <code>SOLVER_TIMEOUT</code> seconds.</p>

<h2 id="performance">Performance</h2>

<p>It is common that optimization passes do not find anything to optimize, so the two functions we compare are often identical. Z3 seems to detect this and is generally fast when checking such, but I noticed that some functions timed out on each UB query (thus taking several hours to check the translation unit).</p>

<p>I initially did the checking as</p>
<div><div><pre><code><span>solver</span><span>.</span><span>append</span><span>(</span><span>z3</span><span>.</span><span>Not</span><span>(</span><span>src_invokes_ub</span><span>))</span>
<span>solver</span><span>.</span><span>append</span><span>(</span><span>tgt_invokes_ub</span><span>)</span>
</code></pre></div></div>
<p>Changing this to</p>
<div><div><pre><code><span>solver</span><span>.</span><span>append</span><span>(</span><span>z3</span><span>.</span><span>Not</span><span>(</span><span>src_invokes_ub</span><span>))</span>
<span>solver</span><span>.</span><span>append</span><span>(</span><span>tgt_invokes_ub</span> <span>!=</span> <span>src_invokes_ub</span><span>)</span>
</code></pre></div></div>
<p>made it quick for the cases that used to time out. But other UB checks got slower for cases where <code>src_invokes_ub</code> and <code>tgt_invokes_ub</code> were not identical. So I am now using</p>
<div><div><pre><code><span>solver</span><span>.</span><span>append</span><span>(</span><span>z3</span><span>.</span><span>Not</span><span>(</span><span>src_invokes_ub</span><span>))</span>
<span>solver</span><span>.</span><span>append</span><span>(</span><span>tgt_invokes_ub</span> <span>!=</span> <span>src_invokes_ub</span><span>)</span>
<span>solver</span><span>.</span><span>append</span><span>(</span><span>tgt_invokes_ub</span><span>)</span>
</code></pre></div></div>
<p>which seems to be the best of both worlds.</p>

<hr/>



  </div></div>
  </body>
</html>
