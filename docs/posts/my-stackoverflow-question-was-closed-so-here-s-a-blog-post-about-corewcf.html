<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://richardcocks.github.io/2025-05-08-CoreWCF.html">Original</a>
    <h1>My stackoverflow question was closed so here&#39;s a blog post about CoreWCF</h1>
    
    <div id="readability-page-1" class="page"><div>
      
      
      

      
<p>I&#39;m preparing a blog post on remote procedure calls (RPC) and Interprocess Communication between .NET Framework and dotnet 8, but while doing so I ran into an issue with a service getting stuck consuming CPU after a client has closed.</p>
<p>It&#39;s not a good fit for asking Claude, etc., because there&#39;s too much confusion on whether you&#39;re talking about CoreWCF, WCF client on .Net Core (<code>System.ServiceModel</code> nuget package version ), or WCF on .NET Framework ( <code>System.ServiceModel</code> from the framework ). This is confusing enough for humans, let alone a machine that will happily reproduce calls and configuration from something that is almost identical, yet subtly different and incompatible.</p>
<p>I didn&#39;t want to raise a github issue, because I doubt I&#39;ve found a bug in WCF, especially since it feels like what I&#39;m trying to do is probably a misunderstanding of how WCF streams are supposed to work.  I&#39;m also quickly hitting maximum message lengths, and that feels like a red flag that I&#39;m not using it as intended.</p>
<p>I took my question to StackOverflow (SO). I&#39;m not a stranger to SO, although it&#39;s been a while since I have contributed anything there. This turned out to be a mistake, because I rushed asking my question. I extracted the classes I thought were pertinent to the question and that I thought could reproduce the issue. I skipped over some boilerplate starting Kestrel, but I also included a link to my repo in case answerers wanted to see the full context of the servicescalled. I had forgotten that any external links are a big no-no in SO land, so my question immediately attracted 2 close votes.</p>
<p>I went back, rewrote the entire question, now with a complete minimal reproduction of the issue. Client and Server fully complete in 3 source files. It now contained all the code needed to reproduce the issue, and nothing  but that code.</p>
<p>Two days later my question got it&#39;s third vote for closure, and remains unanswered and now closed forever.</p>
<p>In my frustration I&#39;m writing this blog post, to briefly introduce CoreWCF and hope someone will be able to answer my question about what I&#39;m doing wrong.</p>
<h2 id="scenario">Scenario</h2>
<p>For the purpose of testing RPC throughput, I want to stream random numbers from one process to another. We can test requesting numbers call-by-call or streamed. Ideally with sequence numbers so we can also examine the reliabilty for certain transport types.</p>
<p>In gRPC, the proto file would look something like this:</p>
<div><div><pre><code><span>syntax</span> <span>=</span> <span>&#34;proto3&#34;</span><span>;</span>

<span>option</span> <span>csharp_namespace</span> <span>=</span> <span>&#34;RandomNumberGrpc&#34;</span><span>;</span>

<span>package</span> <span>randomService</span><span>;</span>

<span>service</span> <span>RandomProvider</span> <span>{</span>
  <span>rpc</span> <span>NextInt</span> <span>(</span><span>NextIntRequest</span><span>)</span> <span>returns</span> <span>(</span><span>ValueWithSequence</span><span>);</span>
  <span>rpc</span> <span>Stream</span> <span>(</span><span>NextIntStreamRequest</span><span>)</span> <span>returns</span> <span>(</span><span>stream</span> <span>ValueWithSequence</span><span>);</span>
<span>}</span>

<span>message</span> <span>NextIntRequest</span> <span>{}</span>
<span>message</span> <span>NextIntStreamRequest</span><span>{}</span>

<span>message</span> <span>ValueWithSequence</span> <span>{</span>
  <span>int32</span> <span>sequenceNumber</span> <span>=</span> <span>1</span><span>;</span>
  <span>int32</span> <span>Value</span> <span>=</span> <span>2</span><span>;</span>
<span>}</span>
</code></pre></div></div>
<p>In WCF, we define services through <code>ServiceContract</code> attributes. For this post I&#39;ll just focus on the streaming service and ignore the per-call implementation. In WCF, <a href="https://learn.microsoft.com/en-us/dotnet/framework/wcf/samples/stream">as I understand it</a>, we can&#39;t strongly type our stream.  For now therefore, to get streams working, I just made a contract that returns a raw byte <code>Stream</code>, and will worry about casting or marshalling that to the right structure later.</p>
<p>Let&#39;s look at our service class.</p>
<div><div><pre><code><span>namespace</span> <span>RandomNumberCore</span><span>;</span>

<span>[</span><span>ServiceContract</span><span>]</span>
<span>public</span> <span>interface</span> <span>IStreamingService</span>
<span>{</span>
    <span>[</span><span>OperationContract</span><span>]</span>
    <span>Stream</span> <span>GetRandomStream</span><span>();</span>
<span>}</span>
    

<span>public</span> <span>class</span> <span>StreamingService</span> <span>:</span> <span>IStreamingService</span>
<span>{</span>
    <span>public</span> <span>Stream</span> <span>GetRandomStream</span><span>()</span>
    <span>{</span>
        <span>return</span> <span>new</span> <span>RandomStream</span><span>(</span><span>Random</span><span>.</span><span>Shared</span><span>);</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>
<p>Where <code>RandomStream</code> is my own class that exposes <code>Random.Shared</code> as a stream, without worrying about returning the sequence number for now:</p>
<div><div><pre><code><span>namespace</span> <span>RandomNumberCore</span><span>;</span>

<span>public</span> <span>class</span> <span>RandomStream</span> <span>:</span> <span>Stream</span>
<span>{</span>
    <span>public</span> <span>RandomStream</span><span>(</span><span>Random</span> <span>random</span><span>)</span>
    <span>{</span>
        <span>this</span><span>.</span><span>_random</span> <span>=</span> <span>random</span><span>;</span>
    <span>}</span>
    
    <span>private</span> <span>int</span> <span>_sequence</span><span>;</span>
    <span>private</span> <span>readonly</span> <span>Random</span> <span>_random</span><span>;</span>
    <span>public</span> <span>override</span> <span>bool</span> <span>CanRead</span> <span>=&gt;</span> <span>true</span><span>;</span>

    <span>public</span> <span>override</span> <span>bool</span> <span>CanSeek</span> <span>=&gt;</span> <span>false</span><span>;</span>

    <span>public</span> <span>override</span> <span>bool</span> <span>CanWrite</span> <span>=&gt;</span> <span>false</span><span>;</span>

    <span>public</span> <span>override</span> <span>long</span> <span>Length</span> <span>=&gt;</span> <span>throw</span> <span>new</span> <span>NotSupportedException</span><span>();</span>

    <span>// ReSharper disable once ValueParameterNotUsed</span>
    <span>public</span> <span>override</span> <span>long</span> <span>Position</span> <span>{</span> <span>get</span> <span>=&gt;</span> <span>_sequence</span><span>;</span> <span>set</span> <span>=&gt;</span> <span>throw</span> <span>new</span> <span>NotSupportedException</span><span>();</span> <span>}</span>

    <span>public</span> <span>override</span> <span>void</span> <span>Flush</span><span>()</span>
    <span>{}</span>
    
    <span>public</span> <span>override</span> <span>int</span> <span>Read</span><span>(</span><span>byte</span><span>[]</span> <span>buffer</span><span>,</span> <span>int</span> <span>offset</span><span>,</span> <span>int</span> <span>count</span><span>)</span>
    <span>{</span>
        <span>var</span> <span>internalBuffer</span> <span>=</span> <span>new</span> <span>Span</span><span>&lt;</span><span>byte</span><span>&gt;(</span><span>buffer</span><span>,</span> <span>offset</span><span>,</span> <span>count</span><span>);</span>
        <span>_random</span><span>.</span><span>NextBytes</span><span>(</span><span>internalBuffer</span><span>);</span>
        <span>_sequence</span><span>+=</span><span>count</span><span>;</span>
        <span>return</span> <span>count</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>override</span> <span>int</span> <span>Read</span><span>(</span><span>Span</span><span>&lt;</span><span>byte</span><span>&gt;</span> <span>buffer</span><span>)</span>
    <span>{</span>
        <span>_random</span><span>.</span><span>NextBytes</span><span>(</span><span>buffer</span><span>);</span>
        <span>_sequence</span><span>+=</span><span>buffer</span><span>.</span><span>Length</span><span>;</span>
        <span>return</span> <span>buffer</span><span>.</span><span>Length</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>override</span> <span>long</span> <span>Seek</span><span>(</span><span>long</span> <span>offset</span><span>,</span> <span>SeekOrigin</span> <span>origin</span><span>)</span>
    <span>{</span>
        <span>throw</span> <span>new</span> <span>NotSupportedException</span><span>();</span>
    <span>}</span>

    <span>public</span> <span>override</span> <span>void</span> <span>SetLength</span><span>(</span><span>long</span> <span>value</span><span>)</span>
    <span>{</span>
        <span>throw</span> <span>new</span> <span>NotSupportedException</span><span>();</span>
    <span>}</span>

    <span>public</span> <span>override</span> <span>void</span> <span>Write</span><span>(</span><span>byte</span><span>[]</span> <span>buffer</span><span>,</span> <span>int</span> <span>offset</span><span>,</span> <span>int</span> <span>count</span><span>)</span>
    <span>{</span>
        <span>throw</span> <span>new</span> <span>NotSupportedException</span><span>();</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>
<p>A read-only, non-seekable stream that returns random numbers. I&#39;ve not extensively tested this stream, but it appears to work fine.</p>
<p>Let&#39;s write a simple client, including the contract. In a real world application you&#39;d likely define a contract assembly to share the contracts.</p>
<div><div><pre><code><span>using</span> <span>System.ServiceModel</span><span>;</span>

<span>namespace</span> <span>RandomNumberConsumerNet8</span>
<span>{</span>
    <span>[</span><span>ServiceContract</span><span>]</span>
    <span>public</span> <span>interface</span> <span>IStreamingService</span>
    <span>{</span>
        <span>[</span><span>OperationContract</span><span>]</span>
        <span>Stream</span> <span>GetRandomStream</span><span>();</span>
    <span>}</span>
    <span>public</span> <span>interface</span> <span>IStreamingServiceChannel</span> <span>:</span> <span>IStreamingService</span><span>,</span> <span>IClientChannel</span><span>;</span>

    <span>internal</span> <span>class</span> <span>Program</span>
    <span>{</span>
        <span>public</span> <span>static</span> <span>async</span> <span>Task</span> <span>Main</span><span>(</span><span>string</span><span>[]</span> <span>args</span><span>)</span>
        <span>{</span>
            <span>var</span> <span>cts</span> <span>=</span> <span>new</span> <span>CancellationTokenSource</span><span>();</span>
            <span>using</span> <span>var</span> <span>channelFactory</span> <span>=</span> <span>new</span> <span>ChannelFactory</span><span>&lt;</span><span>IStreamingServiceChannel</span><span>&gt;(</span><span>new</span> <span>BasicHttpBinding</span><span>(</span><span>BasicHttpSecurityMode</span><span>.</span><span>Transport</span><span>){</span><span>TransferMode</span> <span>=</span> <span>TransferMode</span><span>.</span><span>Streamed</span><span>,</span> <span>MaxReceivedMessageSize</span> <span>=</span> <span>1</span><span>_000_000_000</span> <span>},</span> <span>new</span> <span>EndpointAddress</span><span>(</span><span>&#34;https://localhost:7151/StreamingService.svc&#34;</span><span>));</span>
            <span>using</span> <span>var</span> <span>service</span> <span>=</span> <span>channelFactory</span><span>.</span><span>CreateChannel</span><span>();</span>
            <span>service</span><span>.</span><span>Open</span><span>();</span>
            <span>using</span> <span>var</span> <span>randomStream</span> <span>=</span> <span>service</span><span>.</span><span>GetRandomStream</span><span>();</span>
            <span>byte</span><span>[]</span> <span>buffer</span> <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>4</span><span>];</span>
            <span>await</span> <span>randomStream</span><span>.</span><span>ReadExactlyAsync</span><span>(</span><span>buffer</span><span>,</span> <span>cts</span><span>.</span><span>Token</span><span>);</span>
            
            <span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>$&#34;Received bytes </span><span>{</span><span>buffer</span><span>[</span><span>0</span><span>]}</span><span> , </span><span>{</span><span>buffer</span><span>[</span><span>1</span><span>]}</span><span>, </span><span>{</span><span>buffer</span><span>[</span><span>2</span><span>]}</span><span>, </span><span>{</span><span>buffer</span><span>[</span><span>3</span><span>]}</span><span> &#34;</span><span>);</span>
            <span>service</span><span>.</span><span>Close</span><span>();</span>
            <span>channelFactory</span><span>.</span><span>Close</span><span>();</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>
<h2 id="results">Results</h2>
<p>Now when I run the server and client, it appears to work:</p>
<pre><code>Received bytes 101 , 18, 99, 251
</code></pre>
<p>Great, we opened the stream, streamed 4 bytes and then closed service.</p>
<p>But now when I look at my CPU, it&#39;s still chugging along. Profiling the server shows it&#39;s still trying to write bytes to the stream, well after the client has long ago disconnected.</p>
<p><img src="https://richardcocks.github.io/assets/img/1_WCF_Serializing.png" alt="Server trace" title="It&#39;s stuck processing the message"/></p>
<p>What is it doing? It&#39;s trying to write to the stream, with no hint of back-pressure or sense it shouldn&#39;t be doing so. The sending stream doesn&#39;t have any sense that it&#39;s not being read from.</p>
<p>I&#39;m coming to the conclusion that WCF streaming is not suitable for this, and is only suitable for single bounded streams, not for streams of unknown length or a stream of messages.</p>
<p>But it&#39;s not therefore clear what to do in this scenario, of wanting to transfer an unknown quantity of random numbers. Do I go back to requesting numbers via single messages? That has limited throughput. My initial testing showed ~5k messages / sec that way. I could manually increase the buffer so that each message sends a greater quantity of random numbers, but that loses the fidelity, and rather misses the point, this isn&#39;t really about random numbers, it&#39;s about how quickly we can pass messages between applications.</p>
<p>Do I need to use session mode and coordinate the stream externally to the RPC?</p>
<p>I&#39;m not sure if I&#39;ve missed the point of WCF streams or something else about WCF tuning entirely, but what I really wish is that this could have been answered on StackOverflow, so others trying something similarly misguided could have learned from my mistakes.</p>

<p>Comments? Questions? Want to point out how much of an idiot I&#39;ve been? Please reach out at <a href="https://bsky.app/profile/eterm.bsky.social">@eterm.bsky.social</a>.</p>
<p>Code behind this post is available at <a href="https://github.com/richardcocks/randomNumberStackOverflow">https://github.com/richardcocks/randomNumberStackOverflow</a> .</p>


      
    </div></div>
  </body>
</html>
