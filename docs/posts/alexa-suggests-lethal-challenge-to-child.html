<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://twitter.com/klivdahl/status/1475220450598924297">Original</a>
    <h1>Alexa suggests lethal challenge to child</h1>
    
    <div id="readability-page-1" class="page"><div role="main"><article><header><section><span><a href="https://thevaluable.dev/tags/tools/">#Tools</a></span>
<span><a href="https://thevaluable.dev/tags/mouseless/">#Mouseless</a></span></section></header><section><picture>
<source srcset="https://thevaluable.dev/images/2021/zsh_expansion/expand_happiness.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2021/zsh_expansion/expand_happiness.jpg" alt="A Guide to Zsh Expansion with Examples"/></picture><p>This article is part of a series of article about Zsh:</p><p>What would we do if we couldn’t use the wonderful <code>TAB</code> key to expand our commands, filenames, or variables in our lovely shell? Not much, I’m afraid. We would still live in dark caves, hunting some dangerous Mammoth with knives made of stones!</p><p>Zsh is particularly powerful when you need some good old expansions. It supports common ones used by Bash too, and add many flags and modifiers on top. It comes in handy to manipulate quickly your commands without writing boring shell scripts.</p><p>We’ll see, in this article, what we can do with Zsh expansions, and more specifically:</p><ul><li>How to use glob operators and globbing flags.</li><li>What glob qualifiers we can use to expand filenames.</li><li>How to expand the Zsh history and how to modify these expansions.</li><li>How to expand parameters, using modifiers and flags.</li></ul><p>In the examples of this article, the character <code>&gt;</code> represents the shell’s prompt. If you want to run the commands in your terminal (which I warmly recommend you to do), don’t copy these <code>&gt;</code> characters. Why not using the dollar character <code>$</code> for the prompt, like every other articles out there? Because it’s my article, I do what I want.</p><p>There are many, many ways to expand your filenames, history entries, or parameters with Zsh. I won’t cover everything here, only what I find the most useful. The amount of information can still be overwhelming, however; that’s why I recommend the following:</p><ol><li>Take two or three useful tips from this article and try to apply them in your daily work.</li><li>When you’re confident with your new knowledge, come back to this article and pick two or three more tips.</li><li>Rinse and repeat.</li></ol><p>Last bit of information before diving in: I used Zsh 5.8 and GNU Bash 5.1.8 for testing the different examples. With that out of the way, let’s begin to expand our souls.</p><h2 id="glob-operators">Glob Operators</h2><p>We can’t use regular expressions with Bash or Zsh to expand our filenames. Instead, we can use glob operators to expand various filenames.</p><p>If you use the shell for long enough, I’m sure you’re already familiar with some of them. Here’s the list of glob operators for Zsh: <code>*</code>, <code>(</code>, <code>|</code>, <code>&lt;</code>, <code>[</code>, and <code>?</code>.</p><p>We’ll see in this section how to use these glob operators. The examples given here follow this set of rules:</p><ol><li>The first line is the non-expanded version of the command.</li><li>The second line is the expanded version of the command, after typing the non-expanded version and hitting the <code>TAB</code> key.</li><li>Each example uses the following directory structure:</li></ol><div><pre><code data-lang="shell">.
├── a_dir_with_a_file
│   └── a_file
├── A_FILE_WITH_UPPERCASE
├── another_file
├── empty_dir
├── file_1
└── file_2
</code></pre></div><p>I encourage you to create the exact same file tree with these commands and try the examples in your shell:</p><div><pre><code data-lang="bash">mkdir a_dir_with_a_file empty_dir <span>\
</span><span></span><span>&amp;&amp;</span> touch a_dir_with_a_file/a_file A_FILE_WITH_UPPERCASE another_file file_1 file_2
</code></pre></div><p>Trying by yourself will let you feel the power of Zsh under your fingertips. Nothing less!</p><h3 id="basic-glob-operators">Basic Glob Operators</h3><p>These two basic glob operators work in Bash and Zsh:</p><ul><li><code>*</code> - Matches any string.</li><li><code>?</code> - Matches any character.</li></ul><p>For example:</p><div><pre><code data-lang="bash">&gt; cat fil*
&gt; cat file_1 file_2

&gt; cat file_?
&gt; cat file_1 file_2

&gt; ls ./*file*
&gt; ls ./a_dir_with_a_file ./another_file ./file_1 ./file_2 
</code></pre></div><h3 id="character-classes">Character classes</h3><p>Beyond the useful <code>*</code> and <code>?</code>, we can also use character classes in both Bash and Zsh:</p><ul><li><code>[]</code> - Matches one of the enclosed character, or a range of characters separated with <code>-</code>.</li><li><code>[:&lt;set&gt;:]</code> - Matches a specific set of characters.</li><li><code>[^&lt;set&gt;]</code> or <code>[!&lt;set&gt;]</code> - Match any character which is <em>not</em> in the set <code>&lt;set&gt;</code>.</li></ul><p>For example:</p><div><pre><code data-lang="bash"><span># Match every filename beginning with &#34;f&#34;, &#34;l&#34;, or &#34;e&#34;</span>
&gt; ls <span>[</span>fle<span>]</span>*
&gt; ls empty_dir file_1 file_2 

<span># Match every filename not beginning with &#34;a&#34;</span>
&gt; ls <span>[</span>^a<span>]</span>*
&gt; ls A_FILE_WITH_UPPERCASE empty_dir file_1 file_2 

<span># Match every filename beginning with &#34;a&#34;</span>
&gt; ls <span>[</span>a<span>]</span>*
&gt; ls a_dir_with_a_file another_file 

<span># Match a filename beginning with any letter from &#34;a&#34; to &#34;z&#34;</span>
&gt; ls <span>[</span>a-z<span>]</span>*
&gt; ls a_dir_with_a_file another_file empty_dir file_1 file_2

<span># Match a filename beginning with lowercase, followed by an underscore, and any other character</span>
&gt; ls <span>[</span>^<span>[</span>:upper:<span>]]</span>_*
&gt; ls a_dir_with_a_file
</code></pre></div><h3 id="grouping">Grouping</h3><p>Grouping is only available in Zsh. To group, we can use the following characters:</p><ul><li><code>()</code> - Matches the enclosed pattern.</li><li><code>|</code> - Equivalent of the boolean operator “OR”. It needs to be used inside groups.</li></ul><p>For example:</p><div><pre><code data-lang="bash"><span># Match any filename beginning with &#34;fi&#34; or &#34;an&#34;</span>
&gt; ls <span>(</span><span>fi</span><span>|</span>an<span>)</span>*
&gt; ls another_file file_1 file_2
</code></pre></div><h3 id="globbing-flags">Globbing Flags</h3><p>Globbing flags are only available in Zsh. They need to be added before any glob operator, and they need to have this syntax: <code>(#&lt;flag&gt;)</code>.</p><p>Here are the three most useful flags:</p><ul><li>i - Case insensitive.</li><li>I - Case sensitive.</li><li>l - Lowercase match lower case or uppercase; uppercase match only uppercase.</li></ul><p>For example:</p><div><pre><code data-lang="bash">&gt; cat a*
&gt; cat a_dir_with_a_file another_file

&gt; cat <span>(</span><span>#i)a*</span>
&gt; cat a_dir_with_a_file A_FILE_WITH_UPPERCASE another_file

&gt; cat <span>(</span><span>#l)a*</span>
&gt; cat a_dir_with_a_file A_FILE_WITH_UPPERCASE another_file 

&gt; cat <span>(</span><span>#l)A*</span>
&gt; cat A_FILE_WITH_UPPERCASE
</code></pre></div><h3 id="recursive-globbing">Recursive Globbing</h3><p>You can also use the recursive glob operator <code>**</code> to expand the files in the working directory (like <code>*</code>) <em>and</em> every file in every subdirectory, recursively.</p><p>For example:</p><div><pre><code data-lang="bash"><span># Search filenames including the substring &#34;file&#34; in the working directory and its subdirectories</span>
&gt; ls ./**/*file*
&gt; ls ./a_dir_with_a_file ./a_dir_with_a_file/a_file ./another_file ./file_1 ./file_2
</code></pre></div><p>The depth of the directory tree doesn’t matter: Zsh will go through the whole tree and find whatever you want. You can also use the alternative glob operator <code>***</code> if you also want to parse symlink’s targets.</p><p>The recursive glob operator can be used in Bash too, but it will only expand files on the first level below the working directory. If you want it to behave like its Zsh counterpart, you need to set the option <code>globstar</code> with the following command <code>shopt -s globstar</code>.</p><h3 id="glob-qualifiers">Glob Qualifiers</h3><p>Glob qualifiers are only available in Zsh. They are added after the glob operators to filter even further the filenames expanded. They are always between parenthesis.</p><p>You can use multiple qualifiers inside the parenthesis, separated with a colon <code>:</code>.</p><h4 id="basic-qualifiers">Basic Qualifiers</h4><p>Here are some basic qualifiers:</p><ul><li><code>^</code> - Negate all qualifiers following it.</li><li><code>-</code> - The qualifier works on the target of the symbolic link (and not the symbolic link itself).</li><li><code>[&lt;beginning&gt;, &lt;end&gt;]</code> - Choose what filenames should be expanded, depending on their positions. Can be negative to count from last match backward.</li></ul><p>For example:</p><div><pre><code data-lang="bash">$ ls *
$ ls a_dir_with_a_file A_FILE_WITH_UPPERCASE another_file empty_dir file_1 file_2 

<span># Only expand the second and third file</span>
&gt; ls *<span>([</span>2,3<span>])</span>
&gt; ls A_FILE_WITH_UPPERCASE another_file 
</code></pre></div><h4 id="directory-expansion">Directory Expansion</h4><p>These qualifiers will only expand to directories, except if they’re negated with <code>^</code>.</p><ul><li><code>F</code> - Expand to non-empty directories.</li><li><code>^F</code> - Expand to empty directories and non-directories (plain files).</li><li><code>/^F</code> - Expand to empty directories.</li></ul><div><pre><code data-lang="bash"><span># Only expand non-empty directory</span>
&gt; ls *<span>(</span>F<span>)</span>
&gt; ls a_dir_with_a_file

<span># Only expand plain files and empty directories</span>
&gt; ls *<span>(</span>^F<span>)</span>
&gt; ls A_FILE_WITH_UPPERCASE another_file empty_dir file_1 file_2 

<span># Only expand empty directories</span>
&gt; ls *<span>(</span>/^F<span>)</span>
&gt; ls empty_dir
</code></pre></div><h4 id="expanding-by-filetype">Expanding By Filetype</h4><p>We can also use qualifiers to expand specific file types (plain files or directory):</p><ul><li><code>.</code> - Expand to plain files</li><li><code>/</code> - Expand to directories</li></ul><div><pre><code data-lang="bash"><span># Only expand plain files</span>
&gt; cat *<span>(</span>.<span>)</span>
&gt; cat A_FILE_WITH_UPPERCASE another_file file_1 file_2 

<span># Only expand directories</span>
&gt; ls *<span>(</span>/<span>)</span>
&gt; ls a_dir_with_a_file empty_dir
</code></pre></div><h4 id="expansions-depending-on-the-permissions">Expansions Depending On the Permissions</h4><p>To only expand files with specific permissions, we can use the following qualifiers:</p><p>Depending on the owner:</p><ul><li><code>*</code> - Expand to executable plain files.</li><li><code>r</code> - Expand to owner readable files.</li><li><code>w</code> - Expand to owner writable files.</li><li><code>x</code> - Expand to owner executable files.</li><li><code>U</code> - Expand to files or directories owned by the current user.</li></ul><p>Depending on the world:</p><ul><li><code>R</code> - Expand to world readable files.</li><li><code>W</code> - Expand to world writable files.</li><li><code>X</code> - Expand to world executable files&gt;</li></ul><p>Depending on the group:</p><ul><li><code>A</code> - Expand to group readable files</li><li><code>I</code> - Expand to group writable files</li><li><code>E</code> - Expand to group executable files</li><li><code>G</code> - File or directory owned by the current user’s group.</li></ul><p>For even more control, we can specify the precise permissions:</p><ul><li><code>f&lt;spec&gt;</code> - Expand the files with access right matching the octal number <code>&lt;spec&gt;</code>. If <code>&lt;spec&gt;</code> is preceded by:<ul><li><code>=</code> (default when none given) - <code>&lt;spec&gt;</code> must match the exact file-mode.</li><li><code>+</code> - At least one bit needs to be in the file-mode.</li><li><code>-</code> - The bits must not be set.</li></ul></li></ul><p>For example:</p><div><pre><code data-lang="bash"><span># Set the permissions for &#34;file_1&#34; to 777 (world can read, write, execute)</span>
&gt; chmod <span>777</span> file_1

<span># Expand files the user can read</span>
&gt; ls *<span>(</span>w<span>)</span>
&gt; ls a_dir_with_a_file A_FILE_WITH_UPPERCASE another_file empty_dir file_1 file_2 

<span># Only expand the files with permission 777</span>
&gt; cat *<span>(</span>f777<span>)</span>
&gt; cat file_1

<span># Only expand files when the permissions are always more than executable:</span>
&gt; cat *<span>(</span>f-1<span>)</span> 
&gt; cat A_FILE_WITH_UPPERCASE another_file file_2
</code></pre></div><h4 id="expansions-depending-on-date-or-size">Expansions Depending on Date or Size</h4><p>It’s also possible to expand files depending on some dates:</p><ul><li><code>m&lt;unit&gt;&lt;operator&gt;&lt;n&gt;</code> - Expand to files modified <code>&lt;n&gt;</code> time ago.<ul><li>The <code>&lt;unit&gt;</code> can be <code>M</code> for month of 30 days, <code>w</code> for <code>w</code>eeks, <code>d</code> for <code>d</code>ays (default when nothing is given),<code>h</code> for <code>h</code>our, <code>m</code> for <code>m</code>inute, or <code>s</code> for <code>s</code>econd.</li><li>The <code>&lt;operator&gt;</code> can be:<ul><li><code>+</code> - Files accessed more than <code>&lt;n&gt;</code> <code>&lt;unit&gt;</code> ago</li><li><code>-</code> - Files accessed less than <code>&lt;n&gt;</code> <code>&lt;unit&gt;</code> ago.</li></ul></li></ul></li></ul><p>The qualifier to expand only files with a specific size is similar:</p><ul><li><code>L&lt;unit&gt;&lt;operator&gt;&lt;n&gt;</code> - Expand to file with a certain size <code>&lt;n&gt;</code>.<ul><li>The unit can be <code>K</code> (Kilobyte), <code>M</code> (Megabyte), <code>G</code> (gigabyte), <code>T</code> (terrabyte).</li><li>If <code>&lt;operator&gt;</code> is:<ul><li><code>+</code> - Files more than <code>&lt;n&gt;</code> bytes.</li><li><code>-</code> - Files less than <code>&lt;n&gt;</code> bytes.</li><li>To match exactly the size, don’t give an <code>&lt;operator&gt;</code>.</li></ul></li></ul></li></ul><p>For example:</p><div><pre><code data-lang="bash"><span># Delete every files greater than 1Gb recursively</span>
&gt; rm **/*<span>(</span>LG+1<span>)</span>

<span># Delete all empty files recursively</span>
&gt; rm **/*<span>(</span>L0<span>)</span>

<span># Delete all files modified in the last hour</span>
&gt; rm **/*<span>(</span>mh-1<span>)</span>

<span># Delete all files modified more than one hour ago</span> 
&gt; rm **/*<span>(</span>mh+1<span>)</span>
</code></pre></div><h3 id="expanding-a-precise-number-of-files">Expanding A Precise Number of Files</h3><p>Let’s say that you had a vision: you <em>know</em> that you only want to expand a precise number of files. The following qualifier will grant your crazy wish:</p><ul><li><code>Y&lt;n&gt;</code> - Limit the expansion to <code>&lt;n&gt;</code> number of files</li></ul><div><pre><code data-lang="bash"><span># Only expand two files</span>
&gt; ls *<span>(</span>Y2<span>)</span>
&gt; ls A_FILE_WITH_UPPERCASE empty_dir
</code></pre></div><h3 id="expanding-and-sorting">Expanding and Sorting</h3><p>We can also sort our files if we want to:</p><ul><li><code>o&lt;sort&gt;</code> - Sort files depending on the value of <code>&lt;sort&gt;</code></li><li><code>O&lt;sort&gt;</code> - Like <code>o</code>, but sort in descending order</li></ul><p>The value of <code>&lt;sort&gt;</code> can be:</p><ul><li><code>n</code> - Sort by name (the default).</li><li><code>L</code> - Sort by size.</li><li><code>l</code> - Sort by number of links.</li><li><code>a</code> - Sort by last access.</li><li><code>m</code> - Sort by last modification.</li><li><code>c</code> - Sort by last inode change.</li><li><code>d</code> - Files in subdirectories appear before.</li><li><code>N</code> - Don’t sort anything.</li></ul><p>For example:</p><div><pre><code data-lang="bash"><span># Sort files from the smallest to the largest</span>
&gt; ls *<span>(</span>oL<span>)</span>

<span># Sort files from the largest to the smallest</span>
&gt; ls *<span>(</span>OL<span>)</span>

<span># Output the three biggest files (excluding directories) in the whole filetree</span>
&gt; ls **/*<span>(</span>.OL<span>[</span>1,3<span>])</span>
</code></pre></div><h3 id="expanding-depending-on-a-predicate">Expanding Depending on a Predicate</h3><p>As far as I know, a predicate is not a dinosaur, but a command (or a function) returning a boolean. Here’s a qualifier to filter the expansion depending on a predicate:</p><ul><li><code>e:&#39;&lt;cmd&gt;&#39;</code> - The estring will filter the files depending on a command returning true or false. The filename being tested is available via the special variable REPLY. You can also change the value of REPLY to generate new filenames.</li></ul><p>Here are two examples to help you understand my complicated rambling:</p><div><pre><code data-lang="bash"><span># Expand every file except the ones called &#34;file_2&#34;</span>
&gt; cat *<span>(</span>e:<span>&#39;[[ $REPLY != file_2 ]]&#39;</span>:<span>)</span>
&gt; cat a_dir_with_a_file A_FILE_WITH_UPPERCASE another_file empty_dir file_1

<span># Expand only plain files (with the qualifier &#34;.&#34;), except the ones called &#34;file_2&#34;</span>
&gt; cat *<span>(</span>e:<span>&#39;[[ $REPLY != file_2 ]]&#39;</span>:.<span>)</span>
&gt; cat A_FILE_WITH_UPPERCASE another_file file_1 

<span># Expand only plain files, and reassign the REPLY variable to expand even more files (even if they don&#39;t exist)</span>
&gt; touch *<span>(</span>e:<span>&#39;reply=(${REPLY}_{1..3})&#39;</span>:.<span>)</span>
&gt; touch A_FILE_WITH_UPPERCASE_1 A_FILE_WITH_UPPERCASE_2 A_FILE_WITH_UPPERCASE_3 another_file_1 another_file_2 another_file_3 file_1_1 file_1_2 file_1_3 file_2_1 file_2_2 file_2_3
</code></pre></div><p>The form <code>e:&#39;&lt;cmd&gt;&#39;</code> can take the form <code>+&lt;cmd&gt;</code> if you need to call a function instead of using a command.</p><div><pre><code data-lang="bash"><span># Create the function &#34;condition&#34;</span>
&gt; condition<span>()</span> <span>{</span> <span>[[</span> <span>$REPLY</span> <span>==</span> file_2 <span>]]</span> <span>}</span>

<span># Only expand file named &#34;file_2&#34;</span>
&gt; cat *<span>(</span>+condition<span>)</span>
&gt; cat file_2
</code></pre></div><p>That was quite a ride! Let’s now abandon the glob operators, their flags, and their qualifiers, to focus on the history of Zsh.</p><h2 id="expanding-the-zsh-history">Expanding the Zsh History</h2><p>To me, the best way to manage the shell’s history is to use a fuzzy finder like <a href="https://github.com/junegunn/fzf" target="_blank" rel="noopener">fzf</a>. That said, if you want to use vanilla Zsh to manipulate your history, you can use these three special characters:</p><ul><li><code>!</code> - The history character.</li><li><code>^</code> - The modification character.</li><li><code>#</code> - The command character.</li></ul><p>These characters are defined in the special variable <code>$HISTCHARS</code>.</p><p>It means that you can’t use these three characters in your commands without properly escaping them. For example, If you run <code>echo hello!!</code> or <code>echo &#34;hello!!&#34;</code>, the shell will expand the <code>!!</code>. In that case, you would need to use simple quotes (<code>echo &#39;hello!!&#39;</code>) or escaping the special characters with backslashes (<code>echo &#34;hello\!\!&#34;</code>).</p><h3 id="the-event-designators">The Event Designators</h3><p>The event designator is used to expand a command (or part of a command) from the history.</p><p>First, to display your shell’s history, you can run the command <code>history</code>, or <code>history -&lt;number&gt;</code> (<code>&lt;number&gt;</code> indicating how many commands you want to output). For example,<code>history -100</code> will display the last 100 commands you’ve executed in your shell.</p><p>Here are some nice and sweet event designators:</p><ul><li><code>!&lt;number&gt;</code> - Expand the <code>&lt;number&gt;</code>th entry from the history.</li><li><code>!-&lt;number&gt;</code> - Expand the <code>&lt;number&gt;</code>th entry from the history, beginning by the most recent command.</li><li><code>!!</code> - Expand the previous command executed.</li><li><code>!&lt;string&gt;</code> - Expand the most recent command executed, starting with <code>&lt;string&gt;</code>.</li><li><code>!#</code> - Expand to the current command you’re typing.</li></ul><p>For example:</p><div><pre><code data-lang="bash"><span># Expand the history&#39;s entry 123</span>
&gt; !123

<span># Expand the second most recent command.</span>
&gt; !-2

<span># Run a command for the following examples</span>
&gt; <span>echo</span> <span>&#34;first&#34;</span> <span>&#34;second&#34;</span> <span>&#34;third&#34;</span>

<span># Expand to the last echo command executed</span>
&gt; !echo
&gt; <span>echo</span> <span>&#34;first&#34;</span> <span>&#34;second&#34;</span> <span>&#34;third&#34;</span>

<span># Expand to the last command executed</span>
&gt; !!
&gt; <span>echo</span> <span>&#34;first&#34;</span> <span>&#34;second&#34;</span> <span>&#34;third&#34;</span>

<span># try to read install Neovim</span>
&gt; pacman -S neovim
error: you cannot perform this operation unless you are root.

<span># Repeat the previous command with sudo (super handy!)</span>
&gt; sudo !!
&gt; sudo pacman -S neovim
</code></pre></div><h3 id="word-designators">Word Designators</h3><p>Going down to the rabbit hole, we can add word designators to our event designator. The goal is to only expand parts of the command from the history.</p><p>The word designator needs to be separated from the event designator with a color <code>:</code>.</p><p>Here are my favorites:</p><ul><li><code>0</code> - Expand the first input word of the command.</li><li><code>&lt;number&gt;</code> - Expand the <code>&lt;number&gt;</code>th argument.</li><li><code>^</code> - Expand the first argument or option.</li><li><code>$</code> - Expand the last argument or option.</li><li><code>*</code> - Expand to all the arguments or options. If there is none, expand to the NULL value.</li></ul><p>You know what will follow? Yes! Examples! More of them!</p><div><pre><code data-lang="bash">&gt; <span>echo</span> <span>&#34;first&#34;</span> <span>&#34;second&#34;</span> <span>&#34;third&#34;</span>

<span># Expand to the first word of the last command</span>
&gt; !!:0
&gt; <span>echo</span>

<span># Expand to the second argument of the last command</span>
&gt; <span>echo</span> !!:2
&gt; <span>echo</span> <span>&#34;second&#34;</span>

<span># Expand to the first argument of the last command</span>
&gt; <span>echo</span> !!:^
&gt; <span>echo</span> <span>&#34;first&#34;</span>

<span># Expand to the last argument of the last command</span>
&gt; <span>echo</span> !!:$
&gt; <span>echo</span> <span>&#34;third&#34;</span>

<span># Expand to all the arguments of the last command</span>
&gt; print !!:*
&gt; print <span>&#34;first&#34;</span> <span>&#34;second&#34;</span> <span>&#34;third&#34;</span>
</code></pre></div><h3 id="history-modifiers">History Modifiers</h3><p>Believe it or not, there’s more. Additionally, you can add some modifiers to the word designator, again separated with <code>:</code>.</p><p>As always, here are my favorites:</p><ul><li><code>a</code> - Transform a file name into an absolute path.</li><li><code>A</code> - Transform a file name into an absolute path and resolve the eventual symlinks.</li><li><code>h&lt;number&gt;</code> - Keep the <code>head</code> of the path: everything except the last component of the path. Use <code>&lt;number&gt;</code> to keep the <code>&lt;number&gt;</code> of component of the pathname. In absolute path, the root directory <code>/</code> is the first component.</li><li><code>t&lt;number&gt;</code> - Remove all leading path components except the final one (the tail). Add a <code>&lt;number&gt;</code> to keep a precise amount of trailing components.</li><li><code>r</code> - Remove the filename extension.</li><li><code>l</code> - Convert everything to lowercase.</li><li><code>u</code> - Convert everything to uppercase.</li></ul><div><pre><code data-lang="bash"><span># Run a command</span>
&gt; ls ~/a_dir_with_a_file/a_dir/a_file

<span># Expand to the absolute path</span>
&gt; !!:^:a
&gt; ls /home/user/a_dir_with_a_file/a_dir/a_file

<span># Expand only the head (delete the tail) - similar to dirname</span>
&gt; !!:^:h
&gt; a_dir_with_a_file/a_dir

<span># Expand only the first part of the head</span>
&gt; !!:^:h1
&gt; a_dir_with_a_file

<span># Expand only the tail (delete the head) - similar to basename</span>
&gt; !!:^:t
&gt; a_file

<span># Expand only the tail and one element before</span>
&gt; !!:^:t2
&gt; a_dir/a_file
</code></pre></div><h3 id="the-substitution-modifier">The Substitution Modifier</h3><p>We can also substitute one substring with another using the substitution modifier:</p><ul><li><code>s/&lt;string&gt;/&lt;replacement&gt;/&lt;flag&gt;</code> - Substitute <code>&lt;string&gt;</code> with <code>&lt;replacement&gt;</code> using an optional <code>&lt;flag&gt;</code>.</li><li><code>gs/&lt;string&gt;/&lt;replacement&gt;/</code> or <code>s/&lt;string&gt;/&lt;replacement&gt;/:g</code> - Substitute globally.</li></ul><p>If we use the <a href="https://en.wikipedia.org/wiki/Metacharacter" target="_blank" rel="noopener">metacharacter</a> <code>&amp;</code> in the replacement, it will be expanded with <code>&lt;string&gt;</code>. If you want to use the literal symbol <code>&amp;</code> and not the metacharacter, you need to escape it with a backslash.</p><p>If the <code>&lt;string&gt;</code> is empty, it uses the previous <code>&lt;string&gt;</code> from the previous substitution.</p><p>For example:</p><div><pre><code data-lang="bash">&gt; <span>echo</span> <span>&#34;hello&#34;</span> <span>&#34;hello&#34;</span> <span>&#34;bonjour&#34;</span>

&gt; !!:s/hello/bonjour
&gt; <span>echo</span> <span>&#34;bonjour&#34;</span> <span>&#34;hello&#34;</span> <span>&#34;bonjour&#34;</span>

&gt; !!:gs/hello/bonjour
&gt; <span>echo</span> <span>&#34;bonjour&#34;</span> <span>&#34;bonjour&#34;</span> <span>&#34;bonjour&#34;</span>

&gt; !!:gs/hello/<span>&amp;</span> dear friend
&gt; <span>echo</span> <span>&#34;hello dear friend&#34;</span> <span>&#34;hello dear friend&#34;</span> <span>&#34;bonjour&#34;</span>
</code></pre></div><p>That’s all for expanding the history. Next steps: expanding variables and parameters!</p><h2 id="parameters-expansion">Parameters Expansion</h2><p>Again, Zsh gives us many tools to expand variables and parameters.</p><h3 id="the-dollar-character">The Dollar Character</h3><p>As you probably know, the dollar character <code>$</code> is used for variable expansion in Bash and Zsh. For example, if you define a wonderful variable <code>var=hello</code>, you can expand its value with <code>$var</code>.</p><p>Zsh, unlike Bash, can also expand arrays using the good old dollar.</p><p>For example:</p><div><pre><code data-lang="bash"><span># Create a variable &#34;var&#34; and assign the value &#34;hello&#34;. Spaces between `=` are not authorized (don&#39;t do &#34;var = hello&#34;).</span>
&gt; <span>var</span><span>=</span>hello

<span># Expand the variable &#34;var&#34;</span>
&gt; <span>echo</span> <span>&#34;</span><span>$var</span><span>&#34;</span>
&gt; <span>echo</span> hello

<span># Create an array with three elements</span>
&gt; <span>array</span><span>=(</span><span>&#34;one&#34;</span> <span>&#34;two&#34;</span> <span>&#34;three&#34;</span><span>)</span>

<span># Expand the values of the array (only in Zsh)</span>
&gt; <span>echo</span> <span>$array</span>
&gt; <span>echo</span> one two three
</code></pre></div><h3 id="parameters-expansion-adding-braces">Parameters Expansion: Adding Braces</h3><p>If the name of your variable is a substring of a word, you need to add braces to specify to the shell what’s the name of the variable and what’s some common string to display. For example:</p><div><pre><code data-lang="bash"><span># Create a variable &#34;size&#34;</span>
&gt; <span>size</span><span>=</span><span>12</span>

<span># The shell tries to expand the variable &#34;sizeGb&#34;</span>
&gt; <span>echo</span> <span>&#34;This is </span><span>$sizeGb</span><span>&#34;</span>
&gt; <span>echo</span> This<span>\ </span>is<span>\
</span><span></span>
<span># The shell knows that it needs to expand the variable &#34;size&#34; (and not &#34;sizeGb&#34;)</span>
&gt; <span>echo</span> <span>&#34;This is </span><span>${</span><span>size</span><span>}</span><span>Gb&#34;</span>
&gt; <span>echo</span> This<span>\ </span>is<span>\ </span>12Gb
</code></pre></div><p>That’s not all: we can add modifiers to these braces, to manipulate the expansion of the variable (and not the value itself). Here’s a list of the most useful ones, all available for Bash and Zsh :</p><ul><li><code>${var:-default}</code> - If <code>var</code> is not null, the value is expanded. Otherwise, <code>default</code> is expanded. Useful when you need a default value when the variable (or parameter) is empty.</li><li><code>${var:+default}</code> - If <code>var</code> is not null, <code>default</code> is expanded. Otherwise, nothing is expanded.</li><li><code>${var#pattern}</code> - If the pattern match the beginning of the value of <code>var</code>, the match is deleted and the rest is expanded. Use <code>##</code> to match larger matching pattern.</li><li><code>${var%pattern}</code> - If the pattern match the end of the value of <code>var</code>, the match is removed and the rest is expanded. Use <code>%%</code> to match larger matching pattern.</li><li><code>${var/&lt;pattern&gt;/&lt;replacement&gt;}</code> - Replace the first pattern in <code>var</code> with <code>replacement</code>.</li><li><code>${var//&lt;pattern&gt;/&lt;replacement&gt;}</code> - Replace all occurrences of <code>pattern</code> in <code>var</code> with <code>replacement</code>.</li></ul><p>You guessed it already: I like examples. So here you go:</p><div><pre><code data-lang="bash"><span># Create a variable</span>
&gt; <span>var</span><span>=</span>new-value

<span># Remove the prefix &#34;new&#34;</span>
&gt; <span>echo</span> <span>&#34;</span><span>${</span><span>var</span><span>#new</span><span>}</span><span>&#34;</span>
&gt; <span>echo</span> -value

<span># Change the value of the variable</span>
&gt; <span>var</span><span>=</span><span>&#34;/home/user&#34;</span>

<span># Delete the first slash and everything before</span>
&gt; ls <span>&#34;</span><span>${</span><span>var</span><span>#*/</span><span>}</span><span>&#34;</span>
&gt; home/user

<span># Delete the last slash and everything before</span>
&gt; ls <span>&#34;</span><span>${</span><span>var</span><span>##*/</span><span>}</span><span>&#34;</span>
&gt; ls user

<span># Create a new variable &#34;image&#34;</span>
&gt; <span>image</span><span>=</span>file.png

<span># Delete everything after the first dot</span>
&gt; <span>echo</span> <span>&#34;</span><span>${</span><span>image</span><span>%.*</span><span>}</span><span>&#34;</span>
&gt; <span>echo</span> file

<span># Delete everything before the first dot</span>
&gt; <span>echo</span> <span>&#34;</span><span>${</span><span>image</span><span>#*.</span><span>}</span><span>&#34;</span>
&gt; <span>echo</span> png

&gt; <span>var</span><span>=</span><span>&#34;hello hello hello&#34;</span>

<span># Replace the first word &#34;hello&#34; by &#34;bonjour&#34;</span>
&gt; <span>echo</span> <span>&#34;</span><span>${</span><span>var</span><span>/hello/bonjour</span><span>}</span><span>&#34;</span>
&gt; <span>echo</span> bonjour<span>\ </span>hello<span>\ </span>hello

<span># Replace every word &#34;hello&#34; by &#34;bonjour&#34;</span>
&gt; <span>echo</span> <span>&#34;</span><span>${</span><span>var</span><span>//hello/bonjour</span><span>}</span><span>&#34;</span>
&gt; <span>echo</span> bonjour<span>\ </span>bonjour<span>\ </span>bonjour
</code></pre></div><p>The following ones are only available with Zsh:</p><ul><li><code>${var:/&lt;pattern&gt;/&lt;replacement&gt;}</code> - Substitute <code>&lt;pattern&gt;</code> with <code>&lt;replacement&gt;</code>. The substitution only happens when <code>pattern</code> match the whole value of <code>var</code>.</li><li><code>${^array}</code> - Substitute every element of the <code>array</code> with whatever comes before or after.</li><li><code>${=array}</code> - Split a string to an array using the internal field separators. These separators are the values of the variable <code>$IFS</code>, by default whitepaces (spaces, tabs, and new lines characters).</li></ul><div><pre><code data-lang="bash"><span># The pattern matches the entire value of the variable var, so everything is replaced with &#34;bonjour&#34;</span>
&gt; <span>echo</span> <span>&#34;</span><span>${</span><span>var</span><span>:/hello hello hello/bonjour</span><span>}</span><span>&#34;</span>
&gt; <span>echo</span> bonjour

<span># Create a new variable &#34;array&#34;</span>
&gt; <span>array</span><span>=(</span><span>&#34;one&#34;</span> <span>&#34;two&#34;</span> <span>&#34;three&#34;</span><span>)</span>

<span># Expand the whole array and add the suffix &#34;.png&#34; to the last element</span>
&gt; <span>echo</span> <span>&#34;</span><span>${</span><span>array</span><span>}</span><span>.png&#34;</span>
&gt; <span>echo</span> one<span>\ </span>two<span>\ </span>three.png

<span># Expand every element of the array with the suffix &#34;.png&#34;.</span>
<span># This command needs to be executed, not expanded (pressing the key &#34;ENTER&#34;, not &#34;TAB&#34;).</span>
&gt; <span>echo</span> <span>${</span><span>^array</span><span>}</span>.png
one.png two.png three.png

&gt; <span>var</span><span>=</span><span>&#34;a big var&#34;</span>

<span># Assign the whole value of var to the array</span>
&gt; <span>arr</span><span>=(</span><span>${</span><span>var</span><span>}</span><span>)</span>

<span># Expand the first element of the array</span>
&gt; <span>echo</span> <span>&#34;</span><span>$arr</span><span>[1]&#34;</span>
&gt; <span>echo</span> a<span>\ </span>big<span>\ </span>var

<span># Cut the value of var and assign it to the array</span>
&gt; <span>arr</span><span>=(</span><span>${</span><span>=var</span><span>}</span><span>)</span>

&gt; <span>echo</span> <span>&#34;</span><span>$arr</span><span>[1]&#34;</span>
&gt; <span>echo</span> a

&gt; <span>echo</span> <span>&#34;</span><span>$arr</span><span>[2]&#34;</span>
&gt; <span>echo</span> big
</code></pre></div><p>It’s also possible to nest the pair of braces. Everything will be expanded from in out.</p><div><pre><code data-lang="bash">&gt; <span>var</span><span>=</span><span>&#34;/home/user/woupi/&#34;</span>

<span># 1. &#34;${var#/home}&#34; is expanded, output: &#34;/user/woupi&#34;</span>
<span># 2. The output is expanded as follows: &#34;&lt;output&gt;%woupi/&#34;</span>
<span># 3. The final output is &#34;/user/&#34;</span>
&gt; <span>echo</span> <span>&#34;</span><span>${${</span><span>var</span><span>#/home</span><span>}</span><span>%woupi/</span><span>}</span><span>&#34;</span>
&gt; <span>echo</span> /user/

&gt; <span>var</span><span>=</span><span>&#34;prefix-image.png&#34;</span>

<span># 1. &#34;${var#prefix-}&#34; is expanded, output: image.png</span> 
<span># 2. &#34;${output%.*}&#34; is expanded, output: image</span>
<span># 3. &#34;.jpg&#34; is added to the output, final output: image.jpg</span>
&gt; <span>echo</span> <span>&#34;</span><span>${${</span><span>var</span><span>#prefix-</span><span>}</span><span>%.*</span><span>}</span><span>.jpg&#34;</span>
&gt; <span>echo</span> image.jpg
</code></pre></div><h4 id="flags">Flags</h4><p>You want more? That’s not a problem. With Zsh, you can also add flags to parameter expansions. These flags are surrounded by parenthesis <code>()</code>, just after the opening curly braces <code>{</code>. You can use as many as you want, as your heart’s content.</p><p>As always, here are the most interesting ones, with examples of course. For these examples, the expansion is not the result of hitting the key <code>TAB</code>, but by hitting the key <code>ENTER</code>.</p><ul><li><code>C</code> - Capitalise (first letter uppercase) every word.</li></ul><div><pre><code data-lang="bash">&gt; <span>var</span><span>=</span><span>&#34;hello i like zsh&#34;</span>

&gt; <span>echo</span> <span>&#34;</span><span>${</span><span>(C)var</span><span>}</span><span>&#34;</span>
Hello I Like Zsh
</code></pre></div><ul><li><code>f</code> - Join strings separated with newlines.</li><li><code>F</code> - Split array with each element separated with newline.</li></ul><div><pre><code data-lang="bash"><span># Assign all the files of the current directories and subdirectories to the variable &#34;files&#34;</span>
&gt; <span>files</span><span>=</span><span>$(</span>find<span>)</span>

&gt; <span>echo</span> <span>$files</span>
.
./file1
./file2

&gt; <span>echo</span> <span>${</span><span>(f)files</span><span>}</span>
. ./file1 ./file2

&gt; <span>arr</span><span>=(</span><span>${</span><span>(f)files</span><span>}</span><span>)</span>

<span># First index of array is 1</span>
&gt; <span>echo</span> <span>$arr</span><span>[</span>1<span>]</span>
.

&gt; <span>echo</span> <span>$arr</span><span>[</span>2<span>]</span>
./file1

&gt; <span>echo</span> <span>${</span><span>(F)arr</span><span>}</span>
.
./file1
./file2
</code></pre></div><ul><li><code>i</code> - Sort an array (case-insensitive).</li></ul><div><pre><code data-lang="bash">&gt; <span>arr</span><span>=(</span>file_02 file_01 B_FILE a_file 02_file 01_file<span>)</span>

&gt; <span>echo</span> <span>${</span><span>(i)arr</span><span>}</span>
01_file 02_file a_file file_01 file_02
</code></pre></div><ul><li><code>O</code> - Sort an array in descending order. Useful when combined with <code>i</code>.</li></ul><div><pre><code data-lang="bash">&gt; <span>arr</span><span>=(</span>file_02 file_01 a_file 02_file 01_file<span>)</span>

&gt; <span>echo</span> <span>${</span><span>(Oi)arr</span><span>}</span>
file_02 file_01 a_file 02_file 01_file
</code></pre></div><ul><li><code>L</code> - Convert all letters to lowercase</li><li><code>U</code> - Convert all letters to uppercase</li></ul><div><pre><code data-lang="bash">&gt; <span>var</span><span>=</span><span>&#34;file_1 FILE_2&#34;</span>

&gt; <span>echo</span> <span>${</span><span>(U)var</span><span>}</span>
FILE_1 FILE_2

&gt; <span>echo</span> <span>${</span><span>(L)var</span><span>}</span>
file_1 file_2
</code></pre></div><ul><li><code>t</code> - Describe the type of the variable. It can be:<ul><li>scalar</li><li>array</li><li>integer</li><li>float</li><li>association</li></ul></li></ul><div><pre><code data-lang="bash">&gt; <span>arr</span><span>=(</span><span>&#34;one&#34;</span> <span>&#34;two&#34;</span><span>)</span>

&gt; <span>echo</span> <span>${</span><span>(t)arr</span><span>}</span>
array

<span># Create an associative array</span>
&gt; <span>declare</span> -A <span>assoc</span><span>=(</span><span>&#34;key&#34;</span> <span>&#34;value&#34;</span><span>)</span>

&gt; <span>echo</span> <span>${</span><span>(t)assoc</span><span>}</span>
association
</code></pre></div><ul><li><code>u</code> - Only expand the unique words in an array, even if these words are repeated multiple times.</li></ul><div><pre><code data-lang="bash">&gt; <span>arr</span><span>=(</span><span>&#34;one&#34;</span> <span>&#34;two&#34;</span> <span>&#34;two&#34;</span> <span>&#34;three&#34;</span><span>)</span>

&gt; <span>echo</span> <span>${</span><span>(u)arr</span><span>}</span>
one two three
</code></pre></div><ul><li><code>k</code> - Expand the keys instead of the values from an associative array.</li><li><code>v</code> - Used with k, expand both key and value from an associative array</li></ul><div><pre><code data-lang="bash">&gt; <span>declare</span> -A <span>assoc</span><span>=(</span><span>&#34;key&#34;</span> <span>&#34;value&#34;</span><span>)</span>

&gt; <span>echo</span> <span>${</span><span>assoc</span><span>}</span>
value

&gt; <span>echo</span> <span>${</span><span>(k)assoc</span><span>}</span>
key

&gt; <span>echo</span> <span>${</span><span>(kv)assoc</span><span>}</span>
key value
</code></pre></div><ul><li><code>S</code> - Adding this flag with <code>#</code>, <code>##</code>, <code>%</code>, or <code>%%</code> will match a substring.</li></ul><div><pre><code data-lang="bash">&gt; <span>var</span><span>=</span><span>&#34;/home/user/workspace/tvd&#34;</span>

&gt; <span>echo</span> <span>&#34;</span><span>${</span><span>var</span><span>#home*</span><span>}</span><span>&#34;</span>
/home/user/workspace/tvd

&gt; <span>echo</span> <span>&#34;</span><span>${</span><span>(S)var#home*</span><span>}</span><span>&#34;</span>
//user/workspace/tvd

&gt; <span>echo</span> <span>${</span><span>(S)var##home*</span><span>}</span>
/

&gt; <span>echo</span> <span>${</span><span>(S)var%work*</span><span>}</span>
/home/user/space/tvd

&gt; <span>echo</span> <span>${</span><span>(S)var%%work*</span><span>}</span>
/home/user/
</code></pre></div><ul><li><code>M</code> - Adding this flag with <code>#</code>, <code>##</code>, <code>%</code>, or <code>%%</code> will output the matched portion.</li></ul><div><pre><code data-lang="bash">&gt; <span>var</span><span>=</span><span>&#34;/home/user&#34;</span>

&gt; <span>echo</span> <span>&#34;</span><span>${</span><span>var</span><span>#*/</span><span>}</span><span>&#34;</span>
home/user

&gt; <span>echo</span> <span>&#34;</span><span>${</span><span>(M)var#*/</span><span>}</span><span>&#34;</span>
/

&gt; <span>echo</span> <span>&#34;</span><span>${</span><span>var</span><span>##*/</span><span>}</span><span>&#34;</span>
user

&gt; <span>echo</span> <span>&#34;</span><span>${</span><span>(M)var##*/</span><span>}</span><span>&#34;</span>
/home/
</code></pre></div><h2 id="you-can-now-become-a-zsh-godly-figure">You Can Now Become a Zsh Godly Figure</h2><p>You can do many things with Zsh, even if it’s not always easy to figure out what. With what we’ve seen in this article, we’re now able to manipulate our expansions in more straightforward ways. No need to use annoying for loops anymore!</p><p>To summarize:</p><ul><li>Glob operators can help you expand filenames, even recursively through a whole file tree. You can also add globbing qualifiers and flags to expand specific filenames.</li><li>Being able to run commands you’ve run in the past is really useful. Being able to modify the expansion of these commands on the fly is even better.</li><li>With Zsh, we can also expand parameters and variables easily using the famous dollar <code>$</code>, curly braces <code>{}</code>, and flags.</li></ul><p>If it’s not enough for you, I invite you to read the part of the Zsh’s manual about expansion (<code>man zshexpn</code>). There’s everything we’ve covered here, and much more, if your brain can handle it. Mine was on a strike after going through it.</p></section></article></div></div>
  </body>
</html>
