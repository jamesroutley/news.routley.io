<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://everydaysuperpowers.dev/articles/why-i-switched-from-htmx-to-datastar/">Original</a>
    <h1>I switched from Htmx to Datastar</h1>
    
    <div id="readability-page-1" class="page"><article>
        

<div>
  
    
      <p data-block-key="s17b6">In 2022, David Guillot delivered an <a href="https://djangotv.com/videos/djangocon-europe/2022/djangocon-2022-from-react-to-htmx-on-a-real-world-saas-product-we-did-it-and-its-awesome/">inspiring DjangoCon Europe talk</a>, showcasing a web app that looked and felt as dynamic as a React app. Yet he and his team had done something bold. They converted it <i>from</i> React <i>to</i> <span>HTMX</span>, cutting their codebase by almost 70% while significantly improving its capabilities.</p><p data-block-key="31qki">Since then, teams everywhere have discovered the same thing: turning a single-page app into a multi-page hypermedia app often slashes lines of code by 60% or more while improving both developer and user experience.</p><p data-block-key="6buao">I saw similar results when I switched my projects from <span>HTMX</span> to Datastar. It was exciting to reduce my code while building real-time, multi-user applications without needing WebSockets or complex frontend state management.</p>


    
  
    
      <h2 id="the-pain-point-that-moved-the-needle">
        <a href="https://everydaysuperpowers.dev/articles/why-i-switched-from-htmx-to-datastar/#the-pain-point-that-moved-the-needle">The pain point that moved the needle</a>
      </h2>
    
  
    
      <p data-block-key="8hqu3">While preparing <a href="http://pyvideo.org/flaskcon-2025/death-to-the-spinner-event-sourcing-for-reactive-web-apps.html">my FlaskCon 2025 talk</a>, I hit a wall. I was juggling <span>HTMX</span> and AlpineJS to keep pieces of my <span>UI</span> in sync, but they fell out of step. I lost hours debugging why my component wasn’t updating. Neither library communicates with the other. Since they are different libraries created by different developers, you are the one responsible for helping them work together.</p><p data-block-key="59dih">Managing the dance to initialize components at various times and orchestrating events was causing me to write more code than I wanted to and spend more time than I could spare to complete tasks.</p><p data-block-key="a6n9s">Knowing that Datastar had the capability of both libraries with a smaller download, I thought I’d give it a try. It handled it without breaking a sweat, and the resulting code was much easier to understand.</p><p data-block-key="bs4ft">I appreciate that there’s less code to download and maintain. Having a library handle all of this in under 11 <span>KB</span> is great for improving page load performance, especially for users on mobile devices. The less you need to download, the better off you are.</p><p data-block-key="bm6tk">But that’s just the starting point.</p>


    
  
    
      <h2 id="better-api">
        <a href="https://everydaysuperpowers.dev/articles/why-i-switched-from-htmx-to-datastar/#better-api">Better API</a>
      </h2>
    
  
    
      <p data-block-key="fn731">As I incorporated Datastar into my project at work, I began to appreciate Datastar’s <span>API</span>. It feels significantly lighter than <span>HTMX</span>. I find that I need to add fewer attributes to achieve the desired results.</p><p data-block-key="c33tr">For example, most interactions with <span>HTMX</span> require you to create an attribute to define the <span>URL</span> to hit, what element to target with the response, and then you might need to add more to customize how <span>HTMX</span> behaves, like this:</p>


    
  
    
      
<pre><code id="target-element-current">&lt;a hx-target=&#34;#rebuild-bundle-status-button&#34;
      hx-select=&#34;#rebuild-bundle-status-button&#34;
      hx-swap=&#34;outerHTML&#34;
      hx-trigger=&#34;click&#34;
      hx-get=&#34;/rebuild/status-button&#34;&gt;&lt;/a&gt;</code></pre>

    
  
    
      <p data-block-key="7odg3">One doesn’t always need all of these, but I find it common to have two or three attributes every time<label for="2"></label><span>And then there are the times I need to remember to look up the ancestry chain to see if any attribute changes the way I’m expecting things to work. Those are confusing bugs when they happen!</span> .</p><p data-block-key="auct3">With Datastar, I regularly use just one attribute, like this:</p>


    
  
    
      
<pre><code id="target-element-current">&lt;a data-on-click=&#34;@get(&#39;/rebuild/status-button&#39;)&#34;&gt;&lt;/a&gt;</code></pre>

    
  
    
      <p data-block-key="6vp3b">This gives me less to think about when I return months later and need to recall how this works.</p>


    
  
    
      <h2 id="how-to-update-page-elements">
        <a href="https://everydaysuperpowers.dev/articles/why-i-switched-from-htmx-to-datastar/#how-to-update-page-elements">How to update page elements</a>
      </h2>
    
  
    
      <p data-block-key="bl2en">The primary difference between <span>HTMX</span> and Datastar is that <span>HTMX</span> is a front-end library that advances the <span>HTML</span> specification. DataStar is a server-side-driven library that aims to create high-performance, web-native, live-updating web applications.</p><p data-block-key="9g7pj">In <span>HTMX</span>, you describe its behavior by adding attributes to the element that <i>triggers</i> the request, even if it updates something far away on the page. That’s powerful, but it means your logic is scattered across multiple layers. Datastar flips that: the server decides what should change, keeping all your update logic in one place.</p><p data-block-key="a4mai">To cite an example from <span>HTMX</span>’s documentation:</p>


    
  
    
      
<pre><code id="target-element-current">&lt;div&gt;
   &lt;div id=&#34;alert&#34;&gt;&lt;/div&gt;
    &lt;button hx-get=&#34;/info&#34; 
            hx-select=&#34;#info-details&#34; 
            hx-swap=&#34;outerHTML&#34;
            hx-select-oob=&#34;#alert&#34;&gt;
        Get Info!
    &lt;/button&gt;
&lt;/div&gt;</code></pre>

    
  
    
      <p data-block-key="48rr">When the button is pressed, it sends a <span>GET</span> request to  <code>/info</code> , replaces the button with the element in the response that has the <span>ID</span> &#39;info-details&#39;, and then retrieves the element in the response with the <span>ID</span> &#39;alert&#39;, replacing the element with the same <span>ID</span> on the page.</p><p data-block-key="2goa1">This is a lot for that button element to know. To author this code, you need to know what information you’re going to return from the server, which is done outside of editing the <span>HTML</span>. This is when <span>HTMX</span> loses the ”locality of behavior” I like so much.</p><p data-block-key="cc4f8">Datastar, on the other hand, expects the server to define the behavior, and it works better.</p><p data-block-key="dt5pc">To replicate the behavior above, you have options. The first option keeps the <span>HTML</span> similar to above:</p>


    
  
    
      
<pre><code id="target-element-current">&lt;div&gt;
    &lt;div id=&#34;alert&#34;&gt;&lt;/div&gt;
    &lt;button id=&#34;info-details&#34;
     data-on-click=&#34;@get(&#39;/info&#39;)&#34;&gt;
        Get Info!
    &lt;/button&gt;
&lt;/div&gt;</code></pre>

    
  
    
      <p data-block-key="9mr7p">In this case, the server can return an <span>HTML</span> string with two root elements that have the same IDs as the elements they’re updating:</p>


    
  
    
      
<pre><code id="target-element-current">&lt;p id=&#34;info-details&#34;&gt;These are the details you are looking for…&lt;/p&gt;
&lt;div id=&#34;alert&#34;&gt;Alert! This is a test.&lt;/div&gt;</code></pre>

    
  
    
      <p data-block-key="e1hat">I love this option because it’s simple and performant.</p>


    
  
    
      <h2 id="think-at-the-component-level">
        <a href="https://everydaysuperpowers.dev/articles/why-i-switched-from-htmx-to-datastar/#think-at-the-component-level">Think at the component level</a>
      </h2>
    
  
    
      <p data-block-key="8qlvg">A better option would change the <span>HTML</span> to treat it as a component.</p><p data-block-key="9q03t">What is this component? It appears to be a way for the user to get more information about a specific item.</p><p data-block-key="2cvu5">What happens when the user clicks the button? It seems like either the information appears or there is no information to appear, and instead we render an error. Either way, the component becomes static.</p><p data-block-key="e63lk">Maybe we could split the component into each state, first, the placeholder:</p>


    
  
    
      
<pre><code id="target-element-current">&lt;!-- info-component-placeholder.html --&gt;
&lt;div id=&#34;info-component&#34;&gt;
    &lt;button data-on-click=&#34;@get(&#39;/product/{{product.id}}/info&#39;)&#34;&gt;
        Get Info!
    &lt;/button&gt;
&lt;/div&gt;</code></pre>

    
  
    
      <p data-block-key="60pqr">Then the server could render the information the user requests…</p>


    
  
    
      
<pre><code id="target-element-current">&lt;!-- info-component-get.html --&gt;
&lt;div id=&#34;info-component&#34;&gt;
    {% if alert %}&lt;div id=&#34;alert&#34;&gt;{{ alert }}&lt;/div&gt;{% endif %}
    &lt;p&gt;{{product.additional_information}}&lt;/p&gt;
&lt;/div&gt;</code></pre>

    
  
    
      <p data-block-key="675ge">…and Datastar will update the page to reflect the changes.</p><p data-block-key="7sgvu">This particular example is a little wonky, but I hope you get the idea. Thinking at a component level is better as it prevents you from entering an invalid state or losing track of the user’s state.</p>


    
  
    
      <h2 id="or-more-than-one-component">
        <a href="https://everydaysuperpowers.dev/articles/why-i-switched-from-htmx-to-datastar/#or-more-than-one-component">…or more than one component</a>
      </h2>
    
  
    
      <p data-block-key="f1bmo">One of the amazing things from David Guillot’s talk is how his app updated the count of favored items even though that element was very far away from the component that changed the count.</p><p data-block-key="3q4t8">David’s team accomplished that by having <span>HTMX</span> trigger a JavaScript event, which in turn triggered the remote component to issue a <span>GET</span> request to update itself with the most up-to-date count.</p><p data-block-key="jr2n">With Datastar, you can update multiple components at once, even in a synchronous function.</p><p data-block-key="d2ffu">If we have a component that allows someone to add an item to a shopping cart:</p>


    
  
    
      
<pre><code id="target-element-current">&lt;form id=&#34;purchase-item&#34;
      data-on-submit=&#34;@post(&#39;/add-item&#39;, {contentType: &#39;form&#39;})&#34;&gt;&#34;
&gt;
  &lt;input type=hidden name=&#34;cart-id&#34; value=&#34;{{cart.id}}&#34;&gt;
  &lt;input type=hidden name=&#34;item-id&#34; value=&#34;{{item.id}}&#34;&gt;
  &lt;fieldset&gt;
    &lt;button data-on-click=&#34;$quantity -= 1&#34;&gt;-&lt;/button&gt;
    &lt;label&gt;Quantity
      &lt;input name=quantity type=number data-bind-quantity value=1&gt;
    &lt;/label&gt;
    &lt;button data-on-click=&#34;$quantity += 1&#34;&gt;+&lt;/button&gt;
  &lt;/fieldset&gt;
  &lt;button type=submit&gt;Add to cart&lt;/button&gt;
  {% if msg %}
    &lt;p class=message&gt;{{msg}}&lt;/p&gt;
  {% endif %}
&lt;/form&gt;</code></pre>

    
  
    
      <p data-block-key="frero">And another one that shows the current count of items in the cart:</p>


    
  
    
      
<pre><code id="target-element-current">&lt;div id=&#34;cart-count&#34;&gt;
    &lt;svg viewBox=&#34;0 0 10 10&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;
        &lt;use href=&#34;#shoppingCart&#34;&gt;
    &lt;/svg&gt;
    {{count}}
&lt;/div&gt;</code></pre>

    
  
    
      <p data-block-key="24m7f">Then a developer can update them both in the same request. This is one way it could look in Django:</p>


    
  
    
      
<pre><code id="target-element-current">from datastar_py.consts import ElementPatchMode
from datastar_py.django import (
    DatastarResponse,
    ServerSentEventGenerator as SSE,
)

def add_item(request):
    # skipping all the important state updates
	return DatastarResponse([
		SSE.patch_elements(
    		render_to_string(&#39;purchase-item.html&#39;, context=dict(cart=cart, item=item, msg=&#39;Item added!&#39;))
		),
		SSE.patch_elements(
    		render_to_string(&#39;cart-count.html&#39;, context=dict(count=item_count))
		),
	])</code></pre>

    
  
    
      <h2 id="web-native">
        <a href="https://everydaysuperpowers.dev/articles/why-i-switched-from-htmx-to-datastar/#web-native">Web native</a>
      </h2>
    
  
    
      <p data-block-key="3mvk6">Being a part of the Datastar Discord, I appreciate that Datastar isn’t just a helper script. It’s a philosophy about building apps with the web’s own primitives, letting the browser and the server do what they’re already great at.</p><p data-block-key="4bn0g">Where <span>HTMX</span> is trying to push the <span>HTML</span> spec forward, Datastar is more interested in promoting the adoption of web-native features, such as <span>CSS</span> view transitions, Server-Sent Events, and web components, where appropriate.</p><p data-block-key="bno5n">This has been a massive eye-opener for me, as I’ve long wanted to leverage each of these technologies, and now I’m seeing the benefits.</p><p data-block-key="883ln">One of the biggest wins I achieved with Datastar was by refactoring a complicated AlpineJS component and extracting a simple web component that I reused in multiple places<label for="3"></label><span>I’ll talk more about this in an upcoming post.</span> .</p><p data-block-key="582uj">I especially appreciate this because there are times when it’s best to rely on JavaScript to accomplish a task. But it doesn’t mean you have to reach for a tool like React to achieve it. Creating custom <span>HTML</span> elements is a great pattern to accomplish tasks with high locality of behavior and the ability to reuse them across your app.</p><p data-block-key="f84g2">However, Datastar provides you with even more capabilities.</p>


    
  
    
      <h2 id="real-time-updates-for-multi-user-apps">
        <a href="https://everydaysuperpowers.dev/articles/why-i-switched-from-htmx-to-datastar/#real-time-updates-for-multi-user-apps">Real-time updates for multi-user apps</a>
      </h2>
    
  
    
      <p data-block-key="en2m1">Apps built with collaboration as a first-class feature stand out from the rest, and Datastar is up to the challenge.</p><p data-block-key="1s5cr">To accomplish this, most <span>HTMX</span> developers achieve updates either by “pulling” information from the server by polling every few seconds or by writing custom WebSocket code, which increases complexity.</p><p data-block-key="5m3bm">Datastar uses a simple web technology called Server-Sent Events (<span>SSE</span>) to allow the server to “push” updates to connected clients. When something changes, such as a user adding a comment or a status change, the server can immediately update browsers with minimal additional code.</p><p data-block-key="1dfjj">You can now build live dashboards, admin panels, and collaborative tools without crafting custom JavaScript. Everything flows from the server, through <span>HTML</span>.</p><p data-block-key="675hi">Additionally, suppose a client’s connection is interrupted. In that case, the browser will automatically attempt to reconnect without requiring additional code, and it can even notify the server, “This is the last event I received.” It’s wonderful.</p>


    
  
    
      <h2 id="just-because-you-can-do-it-doesnt-mean-you-should">
        <a href="https://everydaysuperpowers.dev/articles/why-i-switched-from-htmx-to-datastar/#just-because-you-can-do-it-doesnt-mean-you-should">Just because you can do it doesn’t mean you should</a>
      </h2>
    
  
    
      <p data-block-key="ek8qm">Being a part of the Datastar community on Discord has helped me appreciate the Datastar vision of making web apps. They aim to have push-based <span>UI</span> updates, reduce complexity, and leverage tools like web components to handle more complex situations locally. It’s common for the community to help newcomers by helping them realize they’re overcomplicating things.</p><p data-block-key="697ei">Here are some of the tips I’ve picked up:</p><p data-block-key="ch5ak">- Don’t be afraid to re-render the whole component and send it down the pipe. It’s easier, it probably won’t affect performance too much, you get better compression ratios, and it’s incredibly fast for the browser to parse <span>HTML</span> strings.</p><p data-block-key="4lbku">- The server is the state of truth and is more powerful than the browser. Let it handle the majority of the state. You probably don’t need the reactive signals as much as you think you do.</p><p data-block-key="72snf">- Web components are great for encapsulating logic into a custom element with high locality of behavior. A great example of this is the star field animation in the header of <a href="https://data-star.dev/">the Datastar website</a>. The  <code>&lt;ds-starfield&gt;</code>  element encapsulates all the code to animate the star field and exposes three attributes to change its internal state. Datastar drives the attributes whenever the range input changes or the mouse moves over the element.</p>


    
  
    
      <h2 id="but-you-can-still-reach-for-the-stars">
        <a href="https://everydaysuperpowers.dev/articles/why-i-switched-from-htmx-to-datastar/#but-you-can-still-reach-for-the-stars">But you can still reach for the stars</a>
      </h2>
    
  
    
      <p data-block-key="d1ihu">But what I’m most excited about are the possibilities that Datastar enables. The community is routinely creating projects that push well beyond the limits experienced by developers using other tools.</p><p data-block-key="avlu">The examples page includes a <a href="https://data-star.dev/examples/dbmon">database monitoring demo</a> that leverages Hypermedia to significantly improve the speed and memory footprint of a demo presented at a JavaScript conference.</p><p data-block-key="8d52m">The one million checkbox experiment was too much for the server it started on. Anders Murphy used Datastar to create <a href="https://checkboxes.andersmurphy.com">one billion checkboxes</a> on an inexpensive server.</p><p data-block-key="17rb2">But the one that most inspired me was a web app that displayed data from every radar station in the United States. When a blip changed on a radar, the corresponding dot in the <span>UI</span> would change within 100 milliseconds. This means that *over 800,000 points are being updated per second*. Additionally, the user could scrub back in time for up to an hour (with under a 700 millisecond delay). Can you imagine this as a Hypermedia app? This is what Datastar enables.</p>


    
  
    
      <h2 id="how-its-working-for-me-today">
        <a href="https://everydaysuperpowers.dev/articles/why-i-switched-from-htmx-to-datastar/#how-its-working-for-me-today">How it’s working for me today</a>
      </h2>
    
  
    
      <p data-block-key="d3fja">I’m still in what I consider my discovery phase of Datastar. Replacing the standard <span>HTMX</span> functionality of ajaxing updates to a <span>UI</span> was quick and easy to implement. Now I’m learning and experimenting with different patterns to use Datastar to achieve more and more.</p><p data-block-key="8a1pf">For decades, I’ve been interested in ways I could provide better user experiences with real-time updates, and I love that Datastar enables me to do push-based updates, even in synchronous code.</p><p data-block-key="ctfe"><span>HTMX</span> filled me with so much joy when I started using it. But I haven’t felt like I lost anything since switching to Datastar. In fact, I feel like I’ve gained so much more.</p><p data-block-key="208b3">If you’ve ever felt the joy of using <span>HTMX</span>, I bet you’ll feel the same leap again with Datastar. It’s like discovering what the web was meant to do all along.</p>


    
  
</div>

      </article></div>
  </body>
</html>
