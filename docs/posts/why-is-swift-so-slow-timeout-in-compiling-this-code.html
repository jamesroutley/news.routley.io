<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://forums.swift.org/t/why-is-swift-so-slow-timeout-in-compiling-this-code/61382">Original</a>
    <h1>Why is Swift so slow (timeout) in compiling this code?</h1>
    
    <div id="readability-page-1" class="page"><div id="post_1">
            <div>
              


              <p><span>
                  <time itemprop="datePublished" datetime="2022-11-11T13:04:14Z">
                    November 11, 2022,  1:04pm
                  </time>
                  <meta itemprop="dateModified" content="2022-11-11T13:04:14Z"/>
              <span itemprop="position">1</span>
              </span>
            </p></div>
            <div itemprop="articleBody">
              <p>I wrote a <em>simple 6 lines</em> <strong>quick sort</strong> function for benchmarking Rust (1.65), Swift 5.7 and Python3.11.</p>
<p>The array length is <strong>999,999</strong>.</p>
<p>When I&#39;d tried for <strong>99,999</strong> numbers; it took <strong>4:30 mins to compile</strong> and the runtime was <strong>0.51 ms</strong> (compared to <strong>Python&#39;s 0.29</strong> and <strong>rust&#39;s 0.12ms</strong>) <strong>rust compiled in 2 secs</strong> btw.</p>
<p>Here&#39;s the <a href="https://gist.github.com/SaudKadiri/7d7d2c7cb887bca346b835cadda0f69c" rel="noopener nofollow ugc">Github gist</a> for the code... can someone try as well and confirm is it just my machine or Swift really isn&#39;t as fast as I expected🤔...</p>
            </div>

            

            

          </div><div id="post_2" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            
            <p>The compile time problem is not your 6 line quick sort function, is the huge literal <code>vector</code>. In short is because compiler has to infer it as <code>[Int]</code> but the only thing it knows about each element literal in this array is that it conforms to <code>ExpressibleByIntegerLiteral</code> so it would probably attempt <code>UInt8</code>,<code>Int8</code>, <code>Int16</code>, <code>Int32</code> ... every integer type in stdlib that conforms to that and possibly user defined types that also conform to it which takes a lot of time.</p>

            

            

          </div><div id="post_3" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://forums.swift.org/u/AlexanderM"><span itemprop="name">AlexanderM</span></a>
                (Alexander Momchilov)
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2022-11-11T13:57:42Z">
                    November 11, 2022,  1:57pm
                  </time>
                  <meta itemprop="dateModified" content="2022-11-11T13:57:42Z"/>
              <span itemprop="position">3</span>
              </span>
            </p></div>
            <div itemprop="text">
              <p>When your source code is so long that it brings GitHub, your browser, and probably your text editor to a grinding halt, perhaps that&#39;s a decent indication &#34;something ain&#39;t right&#34;.</p>
<p>I wouldn&#39;t be surprised if &#34;parse and compile 8MB of integer literals&#34; isn&#39;t a very well optimized code path in the compiler, because nobody is parsing and compiling 8MB of integer literals outside of artificial exercises like this <img src="https://emoji.discourse-cdn.com/apple/stuck_out_tongue.png?v=12" title=":stuck_out_tongue:" alt=":stuck_out_tongue:" loading="lazy" width="20" height="20"/></p>
<p>That said, it&#39;s not just the literal type-checking slowing things down here. I added a type annotation (<code>let vector: [Int] = [ ... ]</code>) and it still doesn&#39;t compile within a few mins</p>
            </div>

            

            

          </div><div id="post_4" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            
            <div itemprop="text">
              
<p>It is probably because even filtering only by <code>Int</code>, each one of the 99999 elements has to be convertible to <code>Int</code>. Because situations like <code>let vector: [Int] = [1, 1, ..., &#34;a&#34;]</code> has to fail...</p>
            </div>

            

            

          </div><div id="post_5" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://forums.swift.org/u/scanon"><span itemprop="name">scanon</span></a>
                (Steve Canon)
              </span></p>

                

              <p><span>
                  <time itemprop="datePublished" datetime="2022-11-11T14:20:56Z">
                    November 11, 2022,  2:20pm
                  </time>
                  <meta itemprop="dateModified" content="2022-11-11T14:20:56Z"/>
              <span itemprop="position">5</span>
              </span>
            </p></div>
            <div itemprop="text">
              
<p>It&#39;s not <em>that</em> unrealistic of a scenario, even if there are better ways to do it. And 8MB is pretty small. There&#39;s no good reason why we can&#39;t do better.</p>
<p>I found a trace of the compiler kind of surprising; the time is <em>not</em> all being spent in the type checker, as you observed:<br/>
</p><div><a href="https://global.discourse-cdn.com/swift/original/3X/b/a/ba10b781b535c22d699654182e326a277f31218d.png" data-download-href="/uploads/short-url/qy0CL0kOD8MZRiCp1oBVQT2bKuF.png?dl=1" title="Screenshot 2022-11-11 at 9.19.14 AM"><img src="https://global.discourse-cdn.com/swift/optimized/3X/b/a/ba10b781b535c22d699654182e326a277f31218d_2_690x229.png" alt="Screenshot 2022-11-11 at 9.19.14 AM" data-base62-sha1="qy0CL0kOD8MZRiCp1oBVQT2bKuF" width="690" height="229" srcset="https://global.discourse-cdn.com/swift/optimized/3X/b/a/ba10b781b535c22d699654182e326a277f31218d_2_690x229.png, https://global.discourse-cdn.com/swift/optimized/3X/b/a/ba10b781b535c22d699654182e326a277f31218d_2_1035x343.png 1.5x, https://global.discourse-cdn.com/swift/optimized/3X/b/a/ba10b781b535c22d699654182e326a277f31218d_2_1380x458.png 2x" data-dominant-color="E6E6E8"/></a></div>
            </div>

            

            

          </div><div id="post_6" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://forums.swift.org/u/blest"><span itemprop="name">blest</span></a>
                
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2022-11-11T14:40:45Z">
                    November 11, 2022,  2:40pm
                  </time>
                  <meta itemprop="dateModified" content="2022-11-11T14:40:45Z"/>
              <span itemprop="position">6</span>
              </span>
            </p></div>
            <p>Yup agree that the input size is too large... but the other two test languages do handle the situation and Swift, unfortunately doesn&#39;t.</p>

            

            

          </div><div id="post_7" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://forums.swift.org/u/blest"><span itemprop="name">blest</span></a>
                
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2022-11-11T14:43:57Z">
                    November 11, 2022,  2:43pm
                  </time>
                  <meta itemprop="dateModified" content="2022-11-11T14:56:04Z"/>
              <span itemprop="position">7</span>
              </span>
            </p></div>
            <p>Thanks for mentioning the internal workings of the compiler. I&#39;ve been trying your suggestion for the past hour... but unfortunately it&#39;s STILL compiling; Rust compiler is inferring the type much faster; so seems some flaw in Swift itself.</p>

            

            

          </div><div id="post_8" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            
            <div itemprop="text">
              
<p>As <a href="https://forums.swift.org/u/scanon">@scanon</a> mentioned there is something else going on other than type checker later on pipeline (if you try <code>swiftc -dump-ast your-file.swift</code> which only parse and typechecks and you see that is reasonable after adding type annotation. Although it will take sometime to actually print the AST typechecking is done in a reasonable time)</p>

<p>I think is unfair say is a &#34;flaw&#34;... it is just that swift has a different set of constraints then Rust when it comes to inference of literals because of some language features.</p>
            </div>

            

            

          </div><div id="post_9" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://forums.swift.org/u/blest"><span itemprop="name">blest</span></a>
                
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2022-11-11T15:46:48Z">
                    November 11, 2022,  3:46pm
                  </time>
                  <meta itemprop="dateModified" content="2022-11-11T15:46:48Z"/>
              <span itemprop="position">9</span>
              </span>
            </p></div>
            <div itemprop="text">
              
<p>Any misunderstanding is deeply regretted; but by &#34;much faster&#34;, I meant to say that the Swift compiler is <strong>taking forever</strong> to do the thing and still not giving any output (I kept it going for more that hour and still no output; consuming significant power in the process) unlike it&#39;s counterpart Rust (which does it <strong>under a minute</strong>). I understand there can be design constraints and I respect it; but I suspect there is something really fishy going on underneath so I said it to be a &#34;flaw&#34;.</p>
<p>That said; I have huge admiration for the Swift community and firstly hope that it&#39;s really not a flaw; and if it is, it get&#39;s sorted out🤝.</p>
            </div>

            

            

          </div><div id="post_10" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://forums.swift.org/u/tera"><span itemprop="name">tera</span></a>
                
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2022-11-11T16:19:13Z">
                    November 11, 2022,  4:19pm
                  </time>
                  <meta itemprop="dateModified" content="2022-11-11T17:19:01Z"/>
              <span itemprop="position">10</span>
              </span>
            </p></div>
            <div itemprop="text">
              <p>FWIW these are the results I got when moved that array into a json file:</p>
<pre><code>build time: 0.6 sec
999999 999999
load data from file:  0.012182950973510742 // try! Data(contentsOf: file)
decode json from data:  0.2169790267944336 // try! JSONSerialization.jsonObject(with: data) as! [Int]
quicksort array:  5.1729899644851685 // quicksort(vector)
standard sort array:  2.165964961051941 // vector.sorted(by: &lt;)
total time using quicksort:  5.402151942253113
total time using standard sort:  2.3951269388198853
</code></pre>
<p>With a quick &amp; dirty counted sort implementation:</p>
<pre><code>counted sort array:  0.6888679265975952
total time using counted sort:  0.9205169677734375
</code></pre>
<p>You can strip 0.2 sec from total time by storing Ints in a binary file instead of Json to make total time ~0.7 sec. No doubt with similar changes Rust will be faster.</p>
<details>
<summary>
PS. interestingly and unexpectedly JSONSerialization was faster than JSONDecoder</summary>
<pre><code>try! JSONSerialization.jsonObject(with: data) as! [Int]
decode json from data with JSONSerialization:  0.21882307529449463

try! JSONDecoder().decode([Int].self, from: data)
decode json from data with JSONDecoder:  1.128619909286499
</code></pre>
</details>
            </div>

            

            

          </div><div id="post_11" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            
            <p>JSONDecoder is (currently) implemented as a layer over JSONSerialization, so it being slower makes some sense. That said, the magnitude of the difference there is interesting, I&#39;d be somewhat interested in taking a look at an Instruments time profile of that.</p>

            

            

          </div><div id="post_12" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://forums.swift.org/u/Jon_Shier"><span itemprop="name">Jon_Shier</span></a>
                (Jon Shier)
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2022-11-11T17:32:01Z">
                    November 11, 2022,  5:32pm
                  </time>
                  <meta itemprop="dateModified" content="2022-11-11T17:32:01Z"/>
              <span itemprop="position">12</span>
              </span>
            </p></div>
            <div itemprop="text">
              
<p>Last I knew, <code>JSONDecoder</code> uses <code>JSONSerialization</code> under the hood and then does a bunch of dynamic casting and decoder work, so it&#39;s pretty much guaranteed to be slow. There are alternative JSON decoders which are much faster, when it matters. But <code>Decoder</code>&#39;s fundamental requirements basically guarantee it&#39;s slow no matter how much work is put in. Last figures I saw put it at 50 - 60 MB/s under the most optimal implementation.</p>
<p>Even if this isn&#39;t a common scenario, this sort of input makes a good stress test which can provide clear areas of improvement for the compiler. Swift&#39;s behavior here (large literals) has been poor from beginning but reports were often met with the same resistance seen in this thread.</p>
            </div>

            

            

          </div><div id="post_13" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://forums.swift.org/u/gonsolo"><span itemprop="name">gonsolo</span></a>
                (Andreas Wendleder)
              </span></p>

                

              <p><span>
                  <time itemprop="datePublished" datetime="2022-11-12T17:19:19Z">
                    November 12, 2022,  5:19pm
                  </time>
                  <meta itemprop="dateModified" content="2022-11-12T17:24:40Z"/>
              <span itemprop="position">13</span>
              </span>
            </p></div>
            <div itemprop="text">
              <p>I filed a number of bugs some time ago about this issue:</p>

<p>In particular (some are somewhat fixed):</p>






<p>You can see the quadratic complexity in this diagram:</p>


<p>It&#39;s quite common in rendering to include precomputed arrays:</p>


<p>I&#39;d be interested in hearing about those. I can think of two:</p>
<ol>
<li>Read JSON as above. Disadvantages: a) Has to be done every time b) Can&#39;t be deployed as a single binary.</li>
<li>Use another language (C, C++). Disadvantage: Clumsy.</li>
</ol>

<p>Since the bugs are years old I wouldn&#39;t bet my hat on it.</p>
            </div>

            

            

          </div><div id="post_14" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://forums.swift.org/u/scanon"><span itemprop="name">scanon</span></a>
                (Steve Canon)
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2022-11-12T18:38:46Z">
                    November 12, 2022,  6:38pm
                  </time>
                  <meta itemprop="dateModified" content="2022-11-12T18:38:46Z"/>
              <span itemprop="position">14</span>
              </span>
            </p></div>
            <div itemprop="text">
              
<p>Personally, I would put them in a binary file and mmap it, but a <code>.h</code> would be perfectly reasonable as well (and to my mind less clumsy, because who needs to have huge data buffers cluttering up their source).</p>
            </div>

            

            

          </div><div id="post_15" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://forums.swift.org/u/ksluder"><span itemprop="name">ksluder</span></a>
                (Kyle Sluder)
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2022-11-12T18:43:44Z">
                    November 12, 2022,  6:43pm
                  </time>
                  <meta itemprop="dateModified" content="2022-11-12T18:43:44Z"/>
              <span itemprop="position">15</span>
              </span>
            </p></div>
            <div itemprop="text">
              
<p>This also lets you more easily put the content in an arbitrary executable section using build tools, which may or may not be a good thing depending on your access pattern. (Possibly a good idea for data that will be copied or made mutable; probably a bad idea for constants referred to by nearby code.)</p>
            </div>

            

            

          </div><div id="post_16" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://forums.swift.org/u/tera"><span itemprop="name">tera</span></a>
                
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2022-11-12T18:45:42Z">
                    November 12, 2022,  6:45pm
                  </time>
                  <meta itemprop="dateModified" content="2022-11-12T18:45:42Z"/>
              <span itemprop="position">16</span>
              </span>
            </p></div>
            <div itemprop="text">
              
<p>Interestingly more time was spent in the type casting than JSON decoding itself:</p>
<pre><code>let o = try! JSONSerialization.jsonObject(with: data) // 0.075 sec
let vector = o as! [Int] // 0.156 sec
</code></pre>

<ol start="3">
<li>
<p>Use a binary format for the external file. Advantages - no parsing required (perhaps an endian conversion the file is intended being readable from differently endian devices). Disadvantages: a) Not convenient (harder to read by human / change) b) Can&#39;t be deployed as a single binary</p>
</li>
<li>
<p>Base64 encoded String (if it&#39;s faster). Disadvantages: a) Not convenient to read / change.</p>
</li>
</ol>
<p>2 - I do every now and then on the as needed basis. E.g. when I need to be sure that struct has a particular binary layout or when I need to drop down to manual reference counting or when I need to patch method implementation (method_exchangeImplementation), or for an ultimate performance and/or crossplatfomability. In this case if I needed to ship a single binary executable without extra files I&#39;d use (2) or (4).</p>
            </div>

            

            

          </div><div id="post_17" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            
            <div itemprop="text">
              
<p>Makes sense that this would be primarily a bridging issue. I have a few ideas for speeding up Array bridging in general but I’m curious if very long Arrays like this hit anything unusual. Unfortunately I have my hands full with other tasks right now <img src="https://emoji.discourse-cdn.com/apple/frowning.png?v=12" title=":frowning:" alt=":frowning:" loading="lazy" width="20" height="20"/></p>
            </div>

            

            

          </div><div id="post_18" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            
            <div itemprop="text">
              
<p>not only that, it also avoids the need to link 12.5 MB of <code>libFoundation.so</code>.</p>
            </div>

            

            

          </div><div id="post_19" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://forums.swift.org/u/tera"><span itemprop="name">tera</span></a>
                
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2022-11-12T21:54:13Z">
                    November 12, 2022,  9:54pm
                  </time>
                  <meta itemprop="dateModified" content="2022-11-12T22:40:45Z"/>
              <span itemprop="position">19</span>
              </span>
            </p></div>
            <div itemprop="text">
              <p>Another option: convert array of ints to a string: &#34;12858, 964801,... &#34;. Compilation time is instant in this case (a fraction of a second). Runtime is a bit slower than the already mentioned alternatives.</p>
<pre><code>let intsString = &#34;12858, 964801, .... 767751, 764160&#34; // one million integers in a string
let components = intsString.components(separatedBy: &#34;, &#34;) // 0.24 sec
let vector = components.map { Int($0)! } // 0.21 sec
let l = quicksort(vector) // 5.1 sec
total time:  5.5 sec
</code></pre>
<details>
<summary>
A slight optimization to your quicksort algorithm to cut its time from 5 seconds to 3 by doing filtering once.</summary>
<pre><code>func quicksort(_ arr: [Int]) -&gt; [Int] {
    guard arr.count &gt; 1 else { return arr }
    let pivot = arr[0]
    var leftInts: [Int] = []
    var rightInts: [Int] = []
    arr.forEach { v in
        if v &lt; pivot {
            leftInts.append(v)
        } else if v &gt; pivot {
            rightInts.append(v)
        }
    }
    let left = quicksort(leftInts)
    let right = quicksort(rightInts)
    return left + [pivot] + right
}
</code></pre>
</details>
            </div>

            

            

          </div><div id="post_20" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://forums.swift.org/u/gonsolo"><span itemprop="name">gonsolo</span></a>
                (Andreas Wendleder)
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2022-11-13T17:03:26Z">
                    November 13, 2022,  5:03pm
                  </time>
                  <meta itemprop="dateModified" content="2022-11-13T17:03:26Z"/>
              <span itemprop="position">20</span>
              </span>
            </p></div>
            <div itemprop="text">
              
<p>We obviously don&#39;t agree here. <img src="https://emoji.discourse-cdn.com/apple/slight_smile.png?v=12" title=":slight_smile:" alt=":slight_smile:" loading="lazy" width="20" height="20"/></p>
<pre><code>let a = [ ... 10.000 floats ... ]
let x = a[i]
</code></pre>
<p>is less clumsy than</p>
<ol>
<li>Generating low-discrepancy numbers</li>
<li>Put them into an external binary file</li>
<li>mmap them at runtime</li>
</ol>
<p>Reasoning:</p>
<ol>
<li>A compiler is <em>made</em> to convert source code to binaries.</li>
<li>
<em>Every</em> other language I tried (C, C++, Rust, even Python) gets this right.</li>
</ol>
<p>But I totally understand if it&#39;s not top priority.</p>
            </div>

            

            

          </div></div>
  </body>
</html>
