<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.macarthur.me/posts/more-aggressive-cache-headers">Original</a>
    <h1>Cache headers could probably be more aggressive</h1>
    
    <div id="readability-page-1" class="page"><div><p>We&#39;ve got it real good when it comes to standing up websites these days (especially static ones). Modern hosts like Vercel and Netlify take care of a <em>lot</em> out of the box, shielding us from the meticulous, complicated stuff.</p><p>Caching is one of them. To accommodate the widest range of users, many providers will cache static assets with a <code>Cache-Control</code> header of <code>public</code>, <code>max-age=0</code>, <code>must-revalidate</code>. Translation:</p><blockquote>Cache this thing, but immediately let it go stale and ask the origin server if there&#39;s a fresh copy to download next time around.</blockquote><p>It&#39;s a smart default. On each subsequent visit to a page, the browser will <em>always</em> check in with the origin server (or global CDN) for the latest version of the asset, but it&#39;ll only actually perform a full download <em>if those assets have changed. </em>If everything&#39;s the same, you&#39;ll get a <code>304 Not Modified</code> response back, and the browser&#39;s &#34;stale&#34; version will be used. Like this:</p><figure><img alt="non-initial page views with default caching" src="https://picperf.dev/https://cms.macarthur.me/content/images/2023/09/image-4.png" height="1302" loading="lazy" width="1410" sizes="(min-width: 720px) 720px" srcset="https://picperf.dev/https://cms.macarthur.me/content/images/size/w600/2023/09/image-4.png 600w,https://picperf.dev/https://cms.macarthur.me/content/images/size/w1000/2023/09/image-4.png 1000w,https://picperf.dev/https://cms.macarthur.me/content/images/2023/09/image-4.png 1410w"/><figcaption>non-initial page views with default caching</figcaption></figure><p>Even though it&#39;s performing a distinct GET request to perform that check, if it returns with 304, it&#39;ll end up being far smaller &amp; faster than full fetch with a 200. For example, here are a couple of actual requests for a font file from my site. The one that came back with a 304 had a significantly smaller footprint.</p><figure><img alt="" src="https://picperf.dev/https://cms.macarthur.me/content/images/2023/08/image-6.png" height="182" loading="lazy" width="1222" sizes="(min-width: 720px) 720px" srcset="https://picperf.dev/https://cms.macarthur.me/content/images/size/w600/2023/08/image-6.png 600w,https://picperf.dev/https://cms.macarthur.me/content/images/size/w1000/2023/08/image-6.png 1000w,https://picperf.dev/https://cms.macarthur.me/content/images/2023/08/image-6.png 1222w"/><figcaption>screenshot comparing the duration of a 304 and a 200 response</figcaption></figure><p>So, while it may sound counterintuitive to immediately let something cached go stale, it&#39;s a good balance between performance and flexibility. It&#39;ll save some headaches too. You won&#39;t end up with someone being served outdated CSS or a previous deployment&#39;s JavaScript bundle. Ship as much as you want, and your users will get the latest. If you&#39;d like to dig more into this specific caching strategy, both <a href="https://www.netlify.com/blog/2017/02/23/better-living-through-caching/?ref=alex-macarthur" target="_blank" rel="noopener">Netlify</a> and <a href="https://vercel.com/docs/edge-network/caching?ref=alex-macarthur#static-files-caching" target="_blank" rel="noopener">Vercel</a> have some information on the philosophy behind it.</p><p>Even so, if you consider yourself a performance scrutineer, it should bother you that you&#39;re leaving some speed on the table by sticking with these defaults. Your caching <em>could be a little more aggressive</em>, and in my opinion, it&#39;s a no-brainer for particular types of assets.</p><h2 id="some-things-never-change"><a href="#some-things-never-change" target="_blank" rel="noopener">Some Things Never Change</a></h2><p>For a typical content site, most of the assets served via URL aren&#39;t dynamic. The same pile of CSS will be used for every visitor. Same story for fonts, individual images, and JavaScript bundles. Certain things just aren&#39;t designed to change based on who made the request or when it was performed, and it&#39;s technically wasteful to perform an extra HTTP request (albeit a small one) when you&#39;re likely to get back 304 anyway.</p><p>You can virtually eliminate those unnecessary requests by using a cache header like this instead.</p><p><code>public, max-age=31560000, immutable</code></p><p>Here&#39;s what it means:</p><ul><li><code>public</code> - the asset can be stored in any cache between (and including) the browser and origin server</li><li><code>max-age=31560000</code> - the cache doesn&#39;t have to consider it &#34;stale&#34; until a full year has passed</li><li><code>immutable</code> - the browser is explicitly instructed to NOT reach out to origin/CDN just to check if something newer is available (no more revalidation requests)</li></ul><p>With that policy in place, after a page has been visited for the first time, each asset is loaded straight from the cache, and the flow ends up looking more like this:</p><figure><img alt="non-initial page views with smarter caching" src="https://picperf.dev/https://cms.macarthur.me/content/images/2023/09/image-10.png" height="1122" loading="lazy" width="1162" sizes="(min-width: 720px) 720px" srcset="https://picperf.dev/https://cms.macarthur.me/content/images/size/w600/2023/09/image-10.png 600w,https://picperf.dev/https://cms.macarthur.me/content/images/size/w1000/2023/09/image-10.png 1000w,https://picperf.dev/https://cms.macarthur.me/content/images/2023/09/image-10.png 1162w"/><figcaption>non-initial page views with smarter caching</figcaption></figure><p>As long as the browser&#39;s still got a cached copy of the asset (identified by unique URL), it&#39;ll be a full year before it ever checks origin again. That makes page performance marginally better, and you can feel a little better about yourself as an performance-minded engineer.</p><h2 id="nothing-lasts-forever"><a href="#nothing-lasts-forever" target="_blank" rel="noopener">Nothing Lasts Forever</a></h2><p>Ok. It&#39;s foolishly optimistic to say you&#39;ll never need to refresh assets before a year crawls by. You&#39;ll update a logo, refresh your site design, or swap out your fonts. It&#39;ll inevitably happen.</p><p>But serving fresh assets in those scenarios is a problem easy to solve with an age-old cache-busting tactic: <strong>fingerprinting</strong>. Every time an asset&#39;s URL changes (it gets a new &#34;fingerprint&#34;), it&#39;ll force the browser and any intermediary cache to treat it as <em>a completely different asset</em>. The URL serves as the cache key, and when it changes, it gets a new identity.</p><p>Most frameworks and site builders already do this for you out-of-the-box, by the way, so it&#39;s likely that you&#39;ll need to do nothing to benefit from it (at least for some asset types). For example, my site&#39;s on Astro. On every build, each static asset is given a very unique name:</p><figure><img alt="example of a fingerprinted asset" src="https://picperf.dev/https://cms.macarthur.me/content/images/2023/09/image.png" height="140" loading="lazy" width="1550" sizes="(min-width: 720px) 720px" srcset="https://picperf.dev/https://cms.macarthur.me/content/images/size/w600/2023/09/image.png 600w,https://picperf.dev/https://cms.macarthur.me/content/images/size/w1000/2023/09/image.png 1000w,https://picperf.dev/https://cms.macarthur.me/content/images/2023/09/image.png 1550w"/></figure><p>And for the resources that aren&#39;t auto-fingerprinted, you&#39;ll get the same benefit using a different file name. For example:</p><pre><code><span><span>-</span><span> &lt;img src=&#34;./logo.svg&#34; alt=&#34;site logo&#34; /&gt;
</span></span><span><span>+</span><span> &lt;img src=&#34;./logo-v2.svg&#34; alt=&#34;site logo&#34; /&gt;</span></span></code></pre><p>All of this, by the way, is a good reason<em> not</em> to use overly aggressive caching on your page&#39;s HTML itself. The URL of your home page will likely never change, and so it&#39;s just not practical to cache it for a year with no revalidation. That&#39;s the advantage static assets have over an HTML document. The cache keys of static resources only matter to the HTML that references them. As long as the code&#39;s pointed to the correct versions, it doesn&#39;t matter what they&#39;re named or how frequently they&#39;re changed.</p><h2 id="how-do-i-do-it"><a href="#how-do-i-do-it" target="_blank" rel="noopener">How do I do it?</a></h2><p>Implementing this highly depends on how you&#39;re hosting your site, but before you do, get clear on which types of assets you&#39;d like to cache more aggressively. For my own site, that&#39;s every <code>.js</code>, <code>.css</code>, and <code>.woff2</code> file (my images are already routed through <a href="https://www.picperf.dev/?ref=alex-macarthur" target="_blank" rel="noopener">PicPerf</a>, so I&#39;m good there). That list is probably similar for you too.</p><p>If you&#39;re on Vercel, you can update your <code>vercel.json</code> file to <a href="https://vercel.com/docs/edge-network/caching?ref=alex-macarthur#using-vercel.json-and-next.config.js" target="_blank" rel="noopener">set specific response headers</a> on the assets you target. I use this:</p><pre><code><span>{</span>
	<span>&#34;headers&#34;</span><span>:</span> <span>[</span>
    	<span>{</span>
			<span>&#34;source&#34;</span><span>:</span> <span>&#34;/(.+\\.js|.+\\.css|.+\\.woff2)&#34;</span><span>,</span>
			<span>&#34;headers&#34;</span><span>:</span> <span>[</span>
				<span>{</span>
					<span>&#34;key&#34;</span><span>:</span> <span>&#34;Cache-Control&#34;</span><span>,</span>
					<span>&#34;value&#34;</span><span>:</span> <span>&#34;public, max-age=31560000, immutable&#34;</span>
				<span>}</span>
			<span>]</span>
		<span>}</span>
	<span>]</span>
<span>}</span></code></pre><p>Be careful writing that pattern, <a href="https://vercel.com/docs/errors/error-list?ref=alex-macarthur#invalid-route-source-pattern" target="_blank" rel="noopener">by the way</a>. Vercel follows the <a href="https://github.com/pillarjs/path-to-regexp/tree/v6.1.0?ref=alex-macarthur" target="_blank" rel="noopener">path-to-regex</a> syntax â€“ not <code>RegExp</code>. That&#39;s caused a moment or two of extreme frustration for me.</p><p>Netlify has its own ways to <a href="https://docs.netlify.com/routing/headers/?ref=alex-macarthur" target="_blank" rel="noopener">customize headers</a> using a <code>_headers</code> or <code>netlify.toml</code> file. Here&#39;s the same setup using a <code>netlify.toml</code>:</p><pre><code><span>[</span><span>[</span><span>headers</span><span>]</span><span>]</span>
  <span>for</span> <span>=</span> <span>&#34;/*.(css|js|woff2)&#34;</span>
  <span>[</span><span>headers.values</span><span>]</span>
  <span>Cache-Control</span> <span>=</span> <span>&#34;public, max-age=31536000, immutable&#34;</span></code></pre><h3 id="using-cloudflare"><a href="#using-cloudflare" target="_blank" rel="noopener">Using Cloudflare</a></h3><p>If you&#39;re on a provider that doesn&#39;t permit customizing response headers so easily, you&#39;re not out of luck. You can set up a Cloudflare account to act as a reverse proxy and set the response headers using a <a href="https://developers.cloudflare.com/rules/transform/response-header-modification/create-dashboard/?ref=alex-macarthur" target="_blank" rel="noopener">modification rule</a>:</p><figure><img alt="" src="https://picperf.dev/https://cms.macarthur.me/content/images/2023/09/image-1.png" height="914" loading="lazy" width="2000" sizes="(min-width: 720px) 720px" srcset="https://picperf.dev/https://cms.macarthur.me/content/images/size/w600/2023/09/image-1.png 600w,https://picperf.dev/https://cms.macarthur.me/content/images/size/w1000/2023/09/image-1.png 1000w,https://picperf.dev/https://cms.macarthur.me/content/images/size/w1600/2023/09/image-1.png 1600w,https://picperf.dev/https://cms.macarthur.me/content/images/2023/09/image-1.png 2184w"/></figure><p>Or, if you&#39;d like to do it in a more interesting way, intercept the request and modify the response with a Cloudflare Worker. Use something like <a href="https://github.com/kwhitley/itty-router?ref=alex-macarthur" target="_blank" rel="noopener">itty-router</a> and it&#39;ll amount to less than 30 lines of code:</p><pre><code><span>import</span> <span>{</span> Router<span>,</span> IRequest <span>}</span> <span>from</span> <span>&#34;itty-router&#34;</span><span>;</span>

<span>const</span> router <span>=</span> <span>Router</span><span>(</span><span>)</span><span>;</span>

router<span>.</span><span>get</span><span>(</span><span>&#34;/*.(css|js|woff2)&#34;</span><span>,</span> <span>async</span> <span>(</span>request<span>:</span> IRequest<span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> response <span>=</span> <span>await</span> <span>fetch</span><span>(</span>request<span>)</span><span>;</span>

	<span>return</span> <span>new</span> <span>Response</span><span>(</span>response<span>.</span>body<span>,</span> <span>{</span>
		status<span>:</span> response<span>.</span>status<span>,</span>
		statusText<span>:</span> response<span>.</span>statusText<span>,</span>
		headers<span>:</span> <span>{</span>
			<span>...</span>response<span>.</span>headers<span>,</span>
			<span>&#34;cache-control&#34;</span><span>:</span> <span>&#34;public, max-age=31560000, immutable&#34;</span><span>,</span>
		<span>}</span><span>,</span>
	<span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

<span>export</span> <span>default</span> <span>{</span>
	<span>async</span> <span>fetch</span><span>(</span>
		request<span>:</span> Request<span>,</span>
		env<span>:</span> <span>{</span><span>}</span><span>,</span>
        context<span>:</span> ExecutionContext
	<span>)</span><span>:</span> <span>Promise</span><span>&lt;</span>Response<span>&gt;</span> <span>{</span>
	context<span>.</span><span>passThroughOnException</span><span>(</span><span>)</span><span>;</span>

	<span>return</span> router<span>.</span><span>handle</span><span>(</span>request<span>,</span> env<span>,</span> context<span>)</span><span>.</span><span>then</span><span>(</span><span>(</span>response<span>)</span> <span>=&gt;</span> response<span>)</span><span>;</span>
	<span>}</span><span>,</span>
<span>}</span><span>;</span></code></pre><p>This, by the way, is the same approach used to cache every image optimized by <a href="https://picperf.dev/?ref=alex-macarthur" target="_blank" rel="noopener">PicPerf.dev</a>. I love it.</p><h2 id="spend-more-time-in-the-network-tab"><a href="#spend-more-time-in-the-network-tab" target="_blank" rel="noopener">Spend more time in the Network Tab.</a></h2><p>The only reason I started thinking about this was because I was curious about the network activity behind any given page load on my own site. It struck me as too much, considering my site&#39;s fairly simple and doesn&#39;t have any ads or other network-chatty things. It was fun, I learned a lot, and my site came out a little quicker in the process.</p><p>Dive into those tools yourself, and maybe you&#39;ll emerge with a similar tip of your own. If you do, I&#39;d love to hear it.</p></div></div>
  </body>
</html>
