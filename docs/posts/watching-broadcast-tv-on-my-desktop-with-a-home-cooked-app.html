<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://silly.business/blog/watching-broadcast-tv-on-my-desktop-with-a-home-cooked-app/">Original</a>
    <h1>Watching Broadcast TV on My Desktop With a Home Cooked App</h1>
    
    <div id="readability-page-1" class="page"><div>
  
<p>
I like to watch broadcast TV from time to time, as it is free and local, but I&#39;m used to the usual affordances of the streaming era like the ability to pause or watch on any of my devices, and to be able to record TV, so when my wife and I started to watch <em>Jeopardy!</em> more religiously I decided to investigate getting a TV tuner so I could record episodes.</p>
<p>
TV tuners have been supported in the Linux kernel officially for a really long time at this point, and I was vaguely aware of this from high school when I used a TV tuner card to play GameCube on my desktop monitor which was quite some time ago.</p>
<p>
The state of Linux TV today is.. weird. When I bought a tuner a few years ago, I wound up buying a Hauppauge WinTV-dualHD USB device. Hauppauge makes a whole bunch of different tuners, and as far as I could tell, is basically the only manufacturer around. Their marketing copy is confusing and their website kind of sketches me out, and the firmware is shitty: tuning to a frequency takes a hysterically long time and the process is poorly behaved once it&#39;s started.</p>
<p>
The documentation for using TV tuners on Linux is all super old and if you search online for how to install the device, you&#39;ll find firmware install instructions that have probably not been necessary in a decade and that you shouldn&#39;t follow, but the support is all at the kernel level so when you plug in the tuner, if you aren&#39;t looking at <code>dmesg</code> you&#39;d have no idea.</p>
<p>
In practice, I mainly watch broadcast TV through Plex, and that works for the most part with only minor jank. Despite the lack of documentation, none is really needed; you just plug it in and Plex detects it. After setup, Plex lets me manage my DVR schedule through a sane interface, and integrates Electronic Programming Guide data into the interface so that you can have a guide. EPG data is only available through a paid subscription, so this interface and the EPG data are something I&#39;m happy to get through my lifetime Plex Pass.</p>
<p>
However, I recently moved, and in my new market I&#39;m not sure if the EPG data from Plex is correct. This would be a problem, because Plex will only display channels that are known to the EPG database. It does not allow me to simply type in the channel number and tune the card.</p>
<p>
I looked around to see if I could find different software to control the tuner. <code>kaffeine</code> crashes after successfully scanning for channels, and every other piece of software for viewing streams from the tuner was abandonware, except for the commands bundled with <code>v4l</code>, in the package <code>v4l-utils</code> on Arch.</p>
<p>
<code>v4l-utils</code> gives us <code>dvb-fe-tool</code> which shows what <code>dvb</code> devices are available. From there I was able to determine that my tuner card creates two virtual tuners at <code>/dev/dvb/adapter0</code> and <code>/dev/dvb/adapter1</code>. OK, that&#39;s straightforward.</p>
<p>
I figured out that <code>dvbv5-zap</code> lets you tune, but it requires a configuration file that I don&#39;t have, to tell it what channels exist. I tried to use <code>dvbv5-scan</code> to find channels, only to discover that it.. can&#39;t? You have to have &#34;scan tables&#34; from.. somewhere..</p>
<p>
After a few more searches I found that &#34;the community&#34; maintains some scan tables, and in Arch they can be installed from the AUR package <code>dtv-scan-tables-dvbv5-git</code>. <em>Obviously</em>.</p>
<p>
Now I can scan for channels and save them in the file <code>dvbv5-zap</code> expects:</p>
<pre>dvbv5-scan /usr/share/dvb/atsc/us-ATSC-center-frequencies-8VSB -a /dev/dvb/adapter1 -o dvb_channel.conf
</pre>
<p>
This takes awhile, so I went to bed. When I woke up, it had produced a file full of entries like this:</p>
<div>
<pre tabindex="0"><code data-lang="fundamental">  [BUZZR  ]
        VCHANNEL = 13.4
        SERVICE_ID = 6
        VIDEO_PID = 97
        AUDIO_PID = 100
        FREQUENCY = 521028615
        MODULATION = VSB/8
        DELIVERY_SYSTEM = ATSC</code></pre>
</div>
<p>
Sure, why not? Now I can finally tune to them, by browsing this file and then running a command like the following:</p>
<pre>dvbv5-zap -c dvb_channel.conf -p -r BUZZR
</pre>
<p>
and … okay that just outputs some stuff on the command line and doesn&#39;t give the prompt back. After a little while, if the signal is strong enough, it tells me <code>/dev/dvb/adapter0/dvr0</code> is ready.</p>
<p>
Now, finally, it is possible to watch the channel, by firing up <code>mplayer</code> with some options I chose through trial and error:</p>
<pre>mplayer /dev/dvb/adapter0/dvr0 -framedrop -cache 4000
</pre>
<p>
At this point <code>mplayer</code> is displaying the raw stream from the OTA broadcast and I&#39;m pretty pleased. It&#39;s not pretty, but it works (unlike <code>kaffeine</code>), and doesn&#39;t require a web UI like Plex or Jellyfin. I suspect VLC can play these streams too but it wasn&#39;t obvious to me how.</p>
<p>
Now I wanted to browse the channels and compare to the ones Plex&#39;s scanner found, as this expedition was initially sparked by my desire to see if Plex&#39;s EPG data was incorrect, since it is missing my local PBS channel. Perhaps I can tune the channel, but the wrong data is displayed?</p>
<p>
Looking through <code>dvb_channel.conf</code> I didn&#39;t see the channel I was looking for, so I began to tune them using the <code>dvbv5-zap</code> command. Cumbersome.</p>
<p>
I decided it&#39;d be fun to build a channel browser in Tcl/Tk, so I threw one together:</p>
<video controls="" width="100%">
  <source src="screencast.webm" type="video/webm"/>
</video>
<p>
I love Tcl for this kind of thing, because I can easily write a shell script with a GUI. Writing a proper program to combine these steps with <code>dvbv5-zap</code> and <code>mplayer</code> would be a huge undertaking, especially if I didn&#39;t want to simply instrument those commands, as I would have to build upon lower-level primitives.</p>
<p>
But especially with the help of an LLM to scaffold the boilerplate for the UI, I can whip up a usable interface in much less time than it takes me to write about it afterwards. I love the directness of it. Sure, this is <em>hardly</em> production software that I would or could distribute. I have hard-coded the path to the channels file, which I manually generated earlier. This is not software that is ready to distribute. It is very home-cooked.</p>
<p>
But with frankly very little code, I can now surf the channels on my desktop just by clicking around in the list element. It&#39;s much more ergonomic than a CLI, does exactly what I want, and it doesn&#39;t need to do anything else. Likely nobody else will ever have any use for it – but nor would they if it was better built. That&#39;s noteworthy. There&#39;s something to do be said for tools that let us quickly arrive at solutions that are simply good enough; worse really can be better.</p>
<p>
In any case, here&#39;s the code:</p>
<div>
<div><pre tabindex="0"><code data-lang="tcl"><span><span>  <span>#!/usr/bin/env wish
</span></span></span><span><span><span></span>  <span>package</span> require Tk
</span></span><span><span>
</span></span><span><span>  <span>wm</span> title . <span>&#34;TV Tuner&#34;</span>
</span></span><span><span>  <span>wm</span> geometry . <span>400</span>x300
</span></span><span><span>
</span></span><span><span>  <span>frame</span> .mainFrame <span>-</span>borderwidth <span>2</span> <span>-</span>relief groove
</span></span><span><span>  <span>pack</span> .mainFrame <span>-</span>fill both <span>-</span>expand <span>1</span> <span>-</span>padx <span>10</span> <span>-</span>pady <span>10</span>
</span></span><span><span>
</span></span><span><span>  <span>listbox</span> .mainFrame.list <span>-</span>height <span>10</span> <span>-</span>width <span>40</span>
</span></span><span><span>  <span>pack</span> .mainFrame.list <span>-</span>fill both <span>-</span>expand <span>1</span>
</span></span><span><span>
</span></span><span><span>  <span>set</span> channelFile <span>[</span><span>open</span> <span>&#34;~/dvb_channel.conf&#34;</span><span>]</span>
</span></span><span><span>  <span>set</span> tunerPid <span>-</span><span>1</span>
</span></span><span><span>
</span></span><span><span>  <span>while</span> <span>{[</span><span>gets</span> <span>$channelFile</span> line<span>]</span> <span>&gt;=</span> <span>0</span><span>}</span> <span>{</span>
</span></span><span><span>      <span>if</span> <span>{[</span><span>regexp</span> <span>{</span><span>^</span><span>\</span><span>[[</span><span>A-Za-z0-9-</span><span>]</span><span>+</span><span>\</span><span>]</span><span>$</span><span>}</span> <span>$line</span><span>]}</span> <span>{</span>
</span></span><span><span>          <span>set</span> line <span>[</span><span>string</span> range <span>$line</span> <span>1</span> end-1<span>]</span>
</span></span><span><span>          <span>.mainFrame.list</span> insert end <span>$line</span>
</span></span><span><span>      <span>}</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>  <span>close</span> <span>$channelFile</span>
</span></span><span><span>
</span></span><span><span>  <span>set</span> mplayerPid <span>[</span><span>exec</span> mplayer <span>/</span>dev<span>/</span>dvb<span>/</span>adapter0<span>/</span>dvr0 <span>-</span>framedrop <span>-</span>cache <span>4000</span> <span>&amp;</span><span>]</span>
</span></span><span><span>
</span></span><span><span>  <span>proc</span> tuneChannel <span>{}</span> <span>{</span>
</span></span><span><span>      <span>set</span> selection <span>[</span><span>.mainFrame.list</span> curselection<span>]</span>
</span></span><span><span>      <span>global</span> tunerPid mplayerPid
</span></span><span><span>      <span>if</span> <span>{</span><span>$selection</span> <span>ne</span> <span>-</span><span>1</span><span>}</span> <span>{</span>
</span></span><span><span>          <span>set</span> channel <span>[</span><span>.mainFrame.list</span> get <span>$selection</span><span>]</span>
</span></span><span><span>          <span>if</span> <span>{</span><span>$tunerPid</span> <span>ne</span> <span>-</span><span>1</span><span>}</span> <span>{</span>
</span></span><span><span>              <span>catch</span> <span>{</span>
</span></span><span><span>                  <span>exec</span> kill <span>-</span><span>9</span> <span>$tunerPid</span>
</span></span><span><span>                  <span>exec</span> killall dvbv5-zap
</span></span><span><span>              <span>}</span>
</span></span><span><span>              <span>while</span> <span>{</span><span>!</span><span>[catch</span> <span>{</span><span>exec</span> kill <span>-</span><span>0</span> <span>$tunerPid</span> <span>2</span><span>&gt;</span><span>@</span><span>1</span><span>}]}</span> <span>{</span>
</span></span><span><span>                  <span>after</span> <span>10</span>
</span></span><span><span>              <span>}</span>
</span></span><span><span>              <span>set</span> tunerPid <span>-</span><span>1</span>
</span></span><span><span>
</span></span><span><span>              <span>catch</span> <span>{</span>
</span></span><span><span>                  <span>exec</span> kill <span>$mplayerPid</span>
</span></span><span><span>              <span>}</span>
</span></span><span><span>              <span>set</span> mplayerPid <span>[</span><span>exec</span> mplayer <span>/</span>dev<span>/</span>dvb<span>/</span>adapter0<span>/</span>dvr0 <span>-</span>framedrop <span>-</span>cache <span>4000</span> <span>&amp;</span><span>]</span>
</span></span><span><span>          <span>}</span>
</span></span><span><span>          <span>set</span> tunerPid <span>[</span><span>exec</span> dvbv5-zap <span>-</span>c dvb_channel.conf <span>-</span>p <span>-</span>r <span>$channel</span> <span>&amp;</span><span>]</span>
</span></span><span><span>      <span>}</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>
</span></span><span><span>  <span>bind</span> .mainFrame.list <span>&lt;&lt;</span>ListboxSelect<span>&gt;&gt;</span> tuneChannel
</span></span><span><span>
</span></span><span><span>  <span>proc</span> cleanup <span>{}</span> <span>{</span>
</span></span><span><span>      <span>global</span> mplayerPid tunerPid
</span></span><span><span>      <span>catch</span> <span>{</span>
</span></span><span><span>          <span>exec</span> kill <span>$mplayerPid</span>
</span></span><span><span>      <span>}</span>
</span></span><span><span>      <span>catch</span> <span>{</span>
</span></span><span><span>          <span>if</span> <span>{</span><span>$tunerPid</span> <span>ne</span> <span>-</span><span>1</span><span>}</span> <span>{</span>
</span></span><span><span>              <span>exec</span> kill <span>-</span><span>9</span> <span>$tunerPid</span>
</span></span><span><span>          <span>}</span>
</span></span><span><span>  	<span>exec</span> killall dvbv5-zap
</span></span><span><span>      <span>}</span>
</span></span><span><span>      <span>exit</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>
</span></span><span><span>  <span>wm</span> protocol . WM_DELETE_WINDOW cleanup
</span></span><span><span>  <span>bind</span> . <span>&lt;</span>Destroy<span>&gt;</span> <span>{</span><span>+</span><span>if</span> <span>{</span><span>&#34;%W&#34;</span> <span>eq</span> <span>&#34;.&#34;</span><span>}</span> <span>{</span><span>cleanup</span><span>}}</span></span></span></code></pre></div>
</div>
<p>
The end product is janky, but usable. It&#39;s now slightly more apparent to me why tuning takes so long in Plex; it takes forever at the lower level, as well. And sometimes <code>SIGTERM</code> doesn&#39;t properly terminate the process holding the tuner. That explains why every so often I need to restart Plex to change the channel. This is made abundantly clear in my crappy <code>cleanup</code> function above and my dubious use of <code>killall</code>. It&#39;s okay, it&#39;s home-cooked, remember?</p>
<p>
At the end of the journey, PBS is still missing, so my quest has been unsuccessful. Now that I&#39;ve done all this digging, I have to guess that the scan tables must be out of date and Plex shares a data source with.. uh.. whoever puts them in the AUR. Or maybe I just need a roof antenna? I will have to continue to investigate.</p>
<p id="outline-container-headline-1">
<h2 id="headline-1">
Footnotes
</h2>
</p>


</div></div>
  </body>
</html>
