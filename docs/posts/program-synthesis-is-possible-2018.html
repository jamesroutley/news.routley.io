<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.cs.cornell.edu/~asampson/blog/minisynth.html">Original</a>
    <h1>Program Synthesis is Possible (2018)</h1>
    
    <div id="readability-page-1" class="page"><article>
<p><a href="https://homes.cs.washington.edu/~bornholt/post/synthesis-explained.html">Program synthesis</a> is not only a hip session title at programming languages conferences. It’s also a broadly applicable technique that people from many walks of computer-science life can use.
But it can seem like magic: automatically generating programs from specifications sounds like it might require a PhD in formal methods.
<a href="https://www.cs.wisc.edu">Wisconsin</a>’s <a href="http://www.cs.wisc.edu/~aws">Aws Albarghouthi</a> wrote a wonderful <a href="http://barghouthi.github.io/2017/04/24/synthesis-primer/">primer on synthesis</a> last year that helps demystify the basic techniques with example code.
Here, we’ll expand on Aws’s primer and build a tiny but complete-ish synthesis engine from scratch.</p>

<p>You can follow along with <a href="https://github.com/sampsyo/minisynth">my Python code</a> or start from an empty buffer.</p>

<h2 id="z3-is-amazing">Z3 is Amazing</h2>

<p>We won’t <em>quite</em> start from scratch—we’ll start with <a href="https://github.com/Z3Prover/z3">Z3</a> and its Python bindings.
Z3 is a <a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories">satisfiability modulo theories (SMT) solver</a>, which is like a SAT solver with <em>theories</em> that let you express constraints involving integers, bit vectors, floating point numbers, and what have you.
We’ll use Z3’s Python bindings.
On a Mac, you can install everything from <a href="https://brew.sh">Homebrew</a>:</p>



<p>Let’s <a href="https://github.com/sampsyo/minisynth/blob/master/ex0.py">try it out</a>:</p>



<p>To use Z3, we’ll write a logical formula over some variables and then solve them to get a <em>model</em>, which is a valuation of the variables that makes the formula true.
Here’s one formula, for example:</p>

<div><div><pre><code>formula = (z3.Int(&#39;x&#39;) / 7 == 6)
</code></pre></div></div>

<p>The <code>z3.Int</code> call introduces a Z3 variable.
Running this line of Python doesn’t actually do any division or equality checking; instead, the Z3 library overloads Python’s <code>/</code> and <code>==</code> operators on its variables to produce a proposition.
So <code>formula</code> here is a logical proposition of one free integer variable, $x$, that says that $x \div 7 = 6$.</p>

<p>Let’s solve <code>formula</code>.
We’ll use a little function called <code>solve</code> to invoke Z3:</p>

<div><div><pre><code>def solve(phi):
    s = z3.Solver()
    s.add(phi)
    s.check()
    return s.model()
</code></pre></div></div>

<p>Z3’s solver interface is much more powerful than what we’re doing here, but this is all we’ll need to get the model for a single problem:</p>



<p>On my machine, I get:</p>



<p>which is admittedly a little disappointing, but at least it’s true: using integer division, $43 \div 7 = 6$.</p>

<p>Z3 also has a theory of bit vectors, as opposed to unbounded integers, which supports shifting and whatnot:</p>

<div><div><pre><code>y = z3.BitVec(&#39;y&#39;, 8)
print(solve(y &lt;&lt; 3 == 40))
</code></pre></div></div>

<p>There are even logical quantifiers:</p>

<div><div><pre><code>z = z3.Int(&#39;z&#39;)
n = z3.Int(&#39;n&#39;)
print(solve(z3.ForAll([z], z * n == z)))
</code></pre></div></div>

<p>Truly, Z3 is amazing.
But we haven’t quite synthesized a program yet.</p>

<h2 id="sketching">Sketching</h2>

<p>In the <a href="https://people.csail.mit.edu/asolar/papers/thesis.pdf">Sketch</a> spirit, we’ll start by synthesizing <em>holes</em> to make programs equivalent.
Here’s the scenario: you have a slow version of a program you’re happy with; that’s your specification.
You can <em>sort of</em> imagine how to write a faster version, but a few of the hard parts elude you.
The synthesis engine’s job will be fill in those details so that the two programs are equivalent on every input.</p>

<p>Take <a href="http://barghouthi.github.io/2017/04/24/synthesis-primer/">Aws’s little example</a>:
you have the “slow” expression <code>x * 2</code>, and you know that there’s a “faster” version to be had that can be written <code>x &lt;&lt; ??</code> for some value of <code>??</code>.
<a href="https://github.com/sampsyo/minisynth/blob/master/ex1.py">Let’s ask Z3</a> what to write there:</p>

<div><div><pre><code>x = z3.BitVec(&#39;x&#39;, 8)
slow_expr = x * 2
h = z3.BitVec(&#39;h&#39;, 8)  # The hole, a.k.a. ??
fast_expr = x &lt;&lt; h
goal = z3.ForAll([x], slow_expr == fast_expr)
print(solve(goal))
</code></pre></div></div>

<p>Nice! We get the model <code>[h = 1]</code>, which tells us that the two programs produce the same result for every byte <code>x</code> when we left-shift by 1.
That’s (a very simple case of) synthesis: we’ve generated a (subexpression of a) program that meets our specification.</p>

<p>Without a proper programming language, however, it doesn’t feel much like generating programs.
We’ll fix that next.</p>

<h2 id="a-tiny-language">A Tiny Language</h2>

<p>Let’s <a href="https://github.com/sampsyo/minisynth/blob/master/ex2.py">conjure a programming language</a>.
We’ll need a parser; I choose <a href="https://github.com/lark-parser/lark">Lark</a>.
Here’s my Lark grammar for a little language of arithmetic expressions, which I ripped off from the <a href="https://github.com/lark-parser/lark/blob/master/examples/calc.py">Lark examples</a> and which I offer to you now for no charge:</p>

<div><div><pre><code><span>GRAMMAR</span> <span>=</span> <span>&#34;&#34;&#34;
?start: sum

?sum: term
  | sum &#34;+&#34; term        -&gt; add
  | sum &#34;-&#34; term        -&gt; sub

?term: item
  | term &#34;*&#34;  item      -&gt; mul
  | term &#34;/&#34;  item      -&gt; div
  | term &#34;&gt;&gt;&#34; item      -&gt; shr
  | term &#34;&lt;&lt;&#34; item      -&gt; shl

?item: NUMBER           -&gt; num
  | &#34;-&#34; item            -&gt; neg
  | CNAME               -&gt; var
  | &#34;(&#34; start &#34;)&#34;

%import common.NUMBER
%import common.WS
%import common.CNAME
%ignore WS
&#34;&#34;&#34;</span><span>.</span><span>strip</span><span>()</span>
</code></pre></div></div>

<p>You can write arithmetic and shift operations on literal numbers and variables. And there are parentheses!
Lark parsers are easy to use:</p>

<div><div><pre><code>import lark
parser = lark.Lark(GRAMMAR)
tree = parser.parse(&#34;(5 * (3 &lt;&lt; x)) + y - 1&#34;)
</code></pre></div></div>

<p>As for any good language, you’ll want an interpreter.
<a href="https://github.com/sampsyo/minisynth/blob/master/ex2.py">Here’s one</a> that processes Lark parse trees and takes a function in as an argument to look up variables by their names:</p>

<div><div><pre><code>def interp(tree, lookup):
    op = tree.data
    if op in (&#39;add&#39;, &#39;sub&#39;, &#39;mul&#39;, &#39;div&#39;, &#39;shl&#39;, &#39;shr&#39;):
        lhs = interp(tree.children[0], lookup)
        rhs = interp(tree.children[1], lookup)
        if op == &#39;add&#39;:
            return lhs + rhs
        elif op == &#39;sub&#39;:
            return lhs - rhs
        elif op == &#39;mul&#39;:
            return lhs * rhs
        elif op == &#39;div&#39;:
            return lhs / rhs
        elif op == &#39;shl&#39;:
            return lhs &lt;&lt; rhs
        elif op == &#39;shr&#39;:
            return lhs &gt;&gt; rhs
    elif op == &#39;neg&#39;:
        sub = interp(tree.children[0], lookup)
        return -sub
    elif op == &#39;num&#39;:
        return int(tree.children[0])
    elif op == &#39;var&#39;:
        return lookup(tree.children[0])
</code></pre></div></div>

<p>As everybody already knows from their time in <a href="http://www.cs.cornell.edu/courses/cs6110/2018sp/">CS 6110</a>, your interpreter is just an embodiment of your language’s big-step operational semantics.
It works:</p>

<div><div><pre><code>env = {&#39;x&#39;: 2, &#39;y&#39;: -17}
answer = interp(tree, lambda v: env[v])
</code></pre></div></div>

<p>Nifty, but there’s no magic here yet.
Let’s add the magic.</p>

<h2 id="from-interpreter-to-constraint-generator">From Interpreter to Constraint Generator</h2>

<p>The key ingredient we’ll need is a <em>translation</em> from our source programs into Z3 constraint systems.
Instead of computing actual numbers, we want to produce equivalent formulas.
For this, Z3’s operator overloading is the raddest thing:</p>

<div><div><pre><code>formula = interp(tree, lambda v: z3.BitVec(v, 8))
</code></pre></div></div>

<p>Incredibly, we get to reuse our interpreter as a constraint generator by just swapping out the variable-lookup function.
Every Python <code>+</code> becomes a plus-constraint-generator, etc.
In general, we’d want to convince ourselves of the <em>adequacy</em> of our translation, but reusing our interpreter code makes this particularly easy to believe.
This similarity between interpreters and synthesizers is a big deal: it’s an insight that <a href="https://homes.cs.washington.edu/~emina/index.html">Emina Torlak</a>’s <a href="https://emina.github.io/rosette/">Rosette</a> exploits with great aplomb.</p>

<h2 id="finishing-synthesis">Finishing Synthesis</h2>

<p>With formulas in hand, we’re almost there.
Remember that we want to synthesize values for holes to make two programs equivalent, so
we’ll need two Z3 expressions that share variables.
I wrapped up an enhanced version of the constraint generator above in a function that also produces the variables involved:</p>

<div><div><pre><code>expr1, vars1 = z3_expr(tree1)
expr2, vars2 = z3_expr(tree2, vars1)
</code></pre></div></div>

<p>And here’s my hack for allowing holes without changing the grammar: any variable name that starts with an “H” is a hole.
So we can filter out the plain, non-hole variables:</p>

<div><div><pre><code>plain_vars = {k: v for k, v in vars1.items()
              if not k.startswith(&#39;h&#39;)}
</code></pre></div></div>

<p>All we need now is a quantifier over equality:</p>

<div><div><pre><code>goal = z3.ForAll(
    list(plain_vars.values()),  # For every valuation of variables...
    expr1 == expr2,  # ...the two expressions produce equal results.
)
</code></pre></div></div>

<p>Running <code>solve(goal)</code> gets a valuation for each hole.
In <a href="https://github.com/sampsyo/minisynth/blob/master/ex2.py">my complete example</a>, I’ve added some scaffolding to load programs from files and to pretty-print the expression with the holes substituted for their values.
It expects two programs, the spec and the hole-ridden sketch, on two lines:</p>

<div><div><pre><code>$ cat sketches/s2.txt
x * 10
x &lt;&lt; h1 + x &lt;&lt; h2
</code></pre></div></div>

<p>It absolutely works:</p>

<div><div><pre><code>$ python3 ex2.py &lt; sketches/s2.txt
x * 10
(x &lt;&lt; 3) + (x &lt;&lt; 1)
</code></pre></div></div>

<h2 id="better-holes-with-conditions">Better Holes with Conditions</h2>

<p>Our example so far can only synthesize constants, which is nice but unsatisfying.
What if we want to synthesize a shifty equivalent to <code>x * 9</code>, for example?
We might think of a sketch like <code>x &lt;&lt; ?? + ??</code>, but there is no pair of literal numbers we can put into those holes to make it equivalent.
How can we synthesize a wider variety of expressions, like <code>x</code>?</p>

<p>We can get this to work without fundamentally changing our synthesis strategy.
We will, however, need to add conditions to our language.
We’ll need to extend the parser with a ternary operator:</p>

<div><div><pre><code>?start: sum
  | sum &#34;?&#34; sum &#34;:&#34; sum -&gt; if
</code></pre></div></div>

<p>And I’ll add a very suspicious-looking case to our interpreter:</p>

<div><div><pre><code>elif op == &#39;if&#39;:
    cond = interp(tree.children[0], lookup)
    true = interp(tree.children[1], lookup)
    false = interp(tree.children[2], lookup)
    return (cond != 0) * true + (cond == 0) * false
</code></pre></div></div>

<p>These funky multiplications are just a terrible alternative to Python’s built-in condition expression.
I’m using this here instead of a straightforward <code>true if cond else false</code> because this works in both interpreter mode <em>and in Z3 constraint generation mode</em> and behaves the same way.
I apologize for the illegible code but not for the convenience of a single implementation.</p>

<p>The trick is to use conditional holes to switch between expression forms.
Here’s an implementation of the sketch we want above:</p>

<div><div><pre><code>$ cat sketches/s4.txt
x * 9
x &lt;&lt; (hb1 ? x : hn1) + (hb2 ? x : hn2)
</code></pre></div></div>

<p>Each ternary operator here represents a <code>??</code> hole in the sketch we wanted to write, <code>x &lt;&lt; ?? + ??</code>.
By choosing the values of <code>hb1</code> and <code>hb2</code>, the synthesizer can choose whether to use a literal or a variable in that place.
In a proper synthesis system, we’d hide these conditions from the surface syntax—the constraint generator would insert a condition for every <code>??</code>.
By conditionally switching between a wider variety of syntax forms—even using nested conditions for nested expressions—the tool can synthesize complex program fragments in each hole.</p>

<h2 id="keep-synthesizing">Keep Synthesizing</h2>

<p>It may be a toy language, but we’ve built a synthesizer!
Program synthesis is a powerful idea that can come in handy in far-flung domains of computer science.
To learn more about the hard parts that come next, I recommend <a href="https://homes.cs.washington.edu/~bornholt/">James Bornholt</a>’s <a href="https://homes.cs.washington.edu/~bornholt/post/synthesis-explained.html">overview</a>.
And you must check out <a href="https://emina.github.io/rosette/">Rosette</a>, a tool that gives you the scaffolding to write synthesis-based tools without interacting with an SMT solver directly as we did here.</p>


</article></div>
  </body>
</html>
