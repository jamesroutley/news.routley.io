<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zknill.io/posts/collaboration-no-crdts/">Original</a>
    <h1>You don&#39;t need a CRDT to build a collaborative experience</h1>
    
    <div id="readability-page-1" class="page"><div id="content"><h2 id="you-dont-need-crdts">You don’t need CRDTs</h2><p><strong>You don’t need CRDTs for collaborative experiences.</strong></p><p>First lets get the ‘what-about-ery’ out the way…</p><div><p><i></i>Things you do need CRDTs for<i></i></p><div><div><ol><li>Offline first – this is wayy harder to get useful behaviour with out CRDTs. If you don’t use them, you’re pretty much destined to have LWW (which is actually a CRDT behaviour),
and one user is likely to overwrite the changes of another. This isn’t a great experience for anyone involved.</li><li>Text editing – everyone’s gonna say “but hey, google docs uses operational transform not CRDTs”.. OK yes, but <em>you are not google</em>. Martin Kleppmann has a great round-up of the
various people who though they implemented OT correctly, but actually didn’t. The reason that you need CRDTs for text editing collaboration is that it’s a really extreme example
of collaboration. The nature of text editing is that any tiny errors in the placement of characters by the convergence algorithm is going to create incorrect words, and
incorrect words are incredibly obvious. Text editing has a high rate of edits (as you type), and the edits need to interleave perfectly or you get incorrect words, and errors in
the interleaving are super obvious (incorrect words)!</li></ol></div></div></div><p>Hold, on.. that all sounds great, but..</p><p><strong>Maybe I want to use a CRDT even if I don’t strictly need to?</strong> OK, yes, maybe you do.</p><p>But CRDTs are not without their downsides:</p><ul><li><strong>Ever-growing state</strong>: for CRDTs to work well they need to keep a record of both what exists, and what has been deleted (so that the deletes aren’t accidentally added back in later).
This means that CRDT state will continually expand. There’s a bunch of magic that CRDT library authors are doing with clever compression techniques to make this problem less-bad,
but it’s basically in-escapable. The size of your CRDT state is not purely a function of the size of the state the CRDT represents, but also of the number of updates that state
has gone through.</li><li><strong>Complex implementations</strong>: CRDTs are easy to implement wrong, so probably don’t roll your own. Instead you’re going to end up using one of the main libraries that are growing in
maturity and popularity. These libraries solve the hard internal-CRDT problems for you, like converging updates, and compressing state, etc. But in using one of these, you’re
locked into that technology (generally Javascript).</li><li><strong>Opaque state</strong>: Because the CRDT has to represent <em>both</em> the underlying state and the updates that led to that state, in order for it’s convergence algorithm to work properly,
you’re generally left with an opaque blob of binary encoded data. You can’t inspect your model represented by the CRDT without using the CRDT library to decode the blob, and you
can’t just store the underlying model state because the CRDT needs its change history also. You’re left with an opaque blob of data in your database. You can’t join on it, you
can’t search it, you can’t do much without building extra features around that state blob.</li></ul><p>So maybe you are convinced that CRDTs are not the be-all-and-end-all of collaboration, and that you aren’t in one of the two categories where you probably should use a CRDT, and
you’ve made it this far in the post.</p><h2 id="what-you-need-instead-of-crdts">What you need instead of CRDTs</h2><p><strong>Now, let me explain why you don’t need CRDTs, and what you do need instead:</strong></p><div><p><i></i>What you do need<i></i></p><div><div><ol><li><strong>Contextual information</strong> – the ability to show where a collaborator is in the collaborative environment; who is engaging with the page, which element they’ve selected, and where
their cursor is.</li><li><strong>Locking for safety</strong> – the ability to lock them smallest possible individual components or elements of the page to stop conflicting updates from happening.</li><li><strong>Small-scale updates</strong> – the ability to update only the information that has changed, and no more.</li><li><strong>Realtime fan-out of updates</strong> – the ability to share the update a user has made, in real-time, with all the other collaborators in that environment.</li></ol></div></div></div><p><img src="https://zknill.io/svg/loading.min.svg" data-src="/img/collaboration-features.png" data-srcset="/img/collaboration-features.png, /img/collaboration-features.png 1.5x, /img/collaboration-features.png 2x" data-sizes="auto" alt="/img/collaboration-features.png" title="Collaboration features"/></p><p>Remind me again why this is better? Well, you get realtime collaborative experiences in a data format/structure that you own and control, without suffering any of the downsides of
CRDTs. TL;DR - because it works!</p><h2 id="examples-of-collaboration-without-crdts">Examples of collaboration without CRDTs</h2><p>I’ll run through a bunch of broad categories of applications, and describe how to make use of these features.</p><h4 id="form-builders-google-forms-typeform-attest-etc"><strong>Form builders</strong>; Google Forms, Typeform, Attest, etc</h4><p>Typically lots of smaller individual inputs. You’re unlikely to want two users collaborating on the same form-box at once.</p><p>How to make it collaborative:</p><ol><li>Lock the individual inputs/elements that a user is engaging with.</li><li>Add Contextual information to show which user has locked which element.</li><li>Add Contextual information to allow users to indicate to each other with their cursors.</li><li>Have a mechanism to update only the form element that has changed, so that two users making updates at the same time do not overwrite each other</li><li>Have a mechanism to fan-out the update that each user has made to the other user’s in real-time, so that each can see the other’s changes as soon as the input is unlocked.</li></ol><h4 id="task-management-jira-shortcut-trello-linear"><strong>Task management</strong>; Jira, Shortcut, Trello, Linear</h4><p>Typically lots of ‘cards’ or ’tasks’ with various properties: status, owner, title, description, project, epic, etc.</p><p>How to make it collaborative:</p><ol><li>Lock the individual inputs/elements that a user is engaging with.</li><li>Add Contextual information to show which user has locked which element.</li><li>Have a mechanism to update only the form element that has changed, so that two users making updates at the same time do not overwrite each other</li><li>Have a mechanism to fan-out the update that each user has made to the other user’s in real-time, so that each can see the other’s changes as soon as the input is unlocked.</li></ol><h4 id="spreadsheets-google-sheets-airtable"><strong>Spreadsheets</strong>; Google sheets, Airtable</h4><p>Typically a ui of rows and columns. Sometimes the records can expand to show inner-details of that row, similar to the task management apps.</p><p>How to make it collaborative:</p><ol><li>Lock the individual inputs/elements that a user is engaging with. For Google Sheets; the individual cells. For Airtable, the individual elements on the record.</li><li>Add Contextual information to show which user has locked which element.</li><li>Have a mechanism to update only the form element that has changed, so that two users making updates at the same time do not overwrite each other</li><li>Have a mechanism to fan-out the update that each user has made to the other user’s in real-time, so that each can see the other’s changes as soon as the input is unlocked.</li></ol><h4 id="picture-drawing-presentation-and-whiteboards-miro-figma-google-slides"><strong>Picture drawing, presentation and whiteboards</strong>; Miro, Figma, Google Slides</h4><p>Typically free-form drawing combined with preset shapes, stickies, note and text boxes, and more.</p><p>How to make it collaborative:</p><ol><li>Lock the individual elements that a user is engaging with, it doesn’t really matter if two users draw over the same part of the canvas. It only matters if two users try and
change the same element at once.</li><li>Add Contextual information to show which user has locked which element.</li><li>Add Contextual information to allow users to indicate to each other with their cursors.</li><li>Have a mechanism to update only the form element that has changed, so that two users making updates at the same time do not overwrite each other</li><li>Have a mechanism to fan-out the update that each user has made to the other user’s in real-time, so that each can see the other’s changes as soon as the input is unlocked.</li></ol><h2 id="design-patterns">Design patterns</h2><p>You can start to see a few things here;</p><ul><li>The pattern for building collaborative experiences is almost exactly the same across all of these types of applications that
don’t need CRDTs,</li><li>Many of the applications that you know from these broad categories operate in exactly this way. A few examples; cell locking in Google Sheets,
post-it locking in Miro and Figma, element locking in Google Slides.</li></ul></div></div>
  </body>
</html>
