<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://iafisher.com/blog/2025/08/robustly-parsing-flags-in-bash-scripts">Original</a>
    <h1>Robustly parsing flags in Bash scripts</h1>
    
    <div id="readability-page-1" class="page"><div>
  <header>
  <a href="https://www.livescience.com/">home</a>
  <a href="https://www.livescience.com/blog">blog</a>
  <a href="https://www.livescience.com/portfolio">portfolio</a>
  <span>Ian Fisher</span>
</header>


  
  
  

  <main>
  <p>Parsing command-line arguments in Bash is a pain. Still, it&#39;s worthwhile to do it correctly, and well. Many times have I run <code>myscript.sh --help</code> only to watch helplessly as it barrelled ahead heedless of the <code>--help</code> flag. Or omitted options or skimped on validation in my own scripts because writing a big <code>for arg in &#34;$@&#34;; do case &#34;$arg&#34; in ... esac; done</code> loop was too annoying for a small script.</p>
<p>One obstacle is that Bash&#39;s limited facilities for abstraction – functions can only return an integer error code and write unstructured bytes to <code>stdout</code> and <code>stderr</code> – make it impossible to write something like Python&#39;s <a href="https://docs.python.org/3/library/argparse.html"><code>argparse</code></a> library.</p>
<p>Or so I thought. But with the help of <a href="https://xeiaso.net/notes/2024/bash-hashmap/">associative arrays</a> (which Bash has had since <a href="https://tldp.org/LDP/abs/html/bashver4.html">2009</a>), it <em>is</em> possible to do better than <a href="https://man7.org/linux/man-pages/man1/getopts.1p.html"><code>getopts</code></a>:</p>
<div><pre><span></span><code>parse_flags <span>&#34;ARG1 [--name=] --verbose&#34;</span> <span>&#34;</span><span>$@</span><span>&#34;</span>
<span>arg1</span><span>=</span><span>&#34;</span><span>${</span><span>__args</span><span>[ARG1]</span><span>}</span><span>&#34;</span>
<span>name</span><span>=</span><span>&#34;</span><span>${</span><span>__args</span><span>[--name]</span><span>}</span><span>&#34;</span>
<span>verbose</span><span>=</span><span>&#34;</span><span>${</span><span>__args</span><span>[--verbose]</span><span>}</span><span>&#34;</span>
</code></pre></div>

<p><em><a href="https://github.com/iafisher/foundation/blob/master/shell/bash_functions.sh#:~:text=ian_parse_flags()">https://github.com/iafisher/foundation/blob/master/shell/bash_functions.sh#:~:text=ian_parse_flags()</a></em></p>
<p>Here we define a command that takes a positional argument called <code>ARG1</code>, an optional flag <code>--name</code> that takes an argument, and a switch <code>--verbose</code>.</p>
<p><code>__args</code> is how library clients access the parsed arguments. It&#39;s a global variable declared by the library; if that makes you uneasy, you could modify the implementation to use a <a href="https://www.gnu.org/software/bash/manual/html_node/Shell-Parameters.html">nameref</a> to pass in a locally-declared associative array.</p>
<p>Subcommands are also supported:</p>
<div><pre><span></span><code>parse_flags_subcmd <span>\</span>
  add <span>&#39;PATH [--name=] --overwrite&#39;</span> <span>\</span>
  remove <span>&#39;NAME&#39;</span> <span>\</span>
  -- <span>&#34;</span><span>$@</span><span>&#34;</span>

<span>case</span> <span>&#34;</span><span>$__subcmd</span><span>&#34;</span> <span>in</span>
  <span># `main_XYZ` functions can access their args in `__args`.</span>
  add<span>)</span>
    main_add
    <span>;;</span>
  remove<span>)</span>
    main_remove
    <span>;;</span>
<span>esac</span>
</code></pre></div>

<p>The format of the description string allows the function to provide a useful help message to the user with no extra effort. You can&#39;t add your own help text, but if your script has gotten <em>that</em> complicated, consider Python. ∎</p>
  </main>

  
</div></div>
  </body>
</html>
