<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jiha-kim.github.io/posts/introduction-to-stochastic-calculus/">Original</a>
    <h1>Introduction to Stochastic Calculus</h1>
    
    <div id="readability-page-1" class="page"><div><p>Notation and code for generating visuals are presented in the <a href="#appendix">Appendix</a>.</p><h3 id="0-introduction"><span><strong>0. Introduction</strong></span><a href="#0-introduction"><i></i></a></h3><p>This document is a brief introduction to stochastic calculus. Like, an actual introduction. Not the textbook “introductions” which immediately blast you with graduate-level probability theory axioms and definitions.</p><p>The goal of this blog post is more to focus on the physical intuition and derivation of Brownian motion, which is the foundation of stochastic calculus. I will avoid very technical formalisms such as probability spaces, measure theory, filtrations, etc. in favor of a more informal approach by considering only well-behaved cases. I also try to avoid introducing too many new concepts and vocabulary.</p><p>I hope that a wider audience can feel inspired as to how stochastic calculus emerges naturally from the physical world. Then, hopefully, more people can appreciate the beauty and meaning of the mathematics behind it, and decide to dig deeper into the subject.</p><h4 id="applications"><span>Applications</span><a href="#applications"><i></i></a></h4><p>Brownian motion and Itô calculare a notable example of fairly high-level mathematics that are applied to model the real world. Stock prices jiggle erratically, molecules bounce in fluids, and noise partially corrupts signals. Stochastic calculus gives us tools to predict, optimize, and understand these messy systems in a simpified model.</p><ul><li><strong>Physics</strong>: Einstein used Brownian motion to prove atoms exist—its jittering matched molecular collisions.</li><li><strong>Finance</strong>: Option pricing (e.g., the famous Black-Scholes equation) relies on stochastic differential equations like \(dS = \mu S dt + \sigma S dW\).</li><li><strong>Biology</strong>: Random walks model how species spread or neurons fire.</li></ul><p>This is just the tip of the iceberg. More and more applications are emerging, notably in machine learning, as <a href="https://arxiv.org/abs/2011.13456">Song et al. (2021)</a> have shown in their great paper “Score-Based Generative Modeling through Stochastic Differential Equations”.</p><p>They precisely use a stochastic differential equation using Itô calculus to model the evolution of noise over time, which they can then reverse in time to generate new samples. This framework generalizes previous ones and improves performance, allowing for new paths of innovation to be explored.</p><h3 id="1-motivation"><span><strong>1. Motivation</strong></span><a href="#1-motivation"><i></i></a></h3><p>Pascal’s triangle gives the number of paths that go either left or right at each step, up to a certain point:</p><p>\[\begin{array}{cccccc} &amp; &amp; &amp; 1 &amp; &amp; &amp; \\ &amp; &amp; 1 &amp; &amp; 1 &amp; &amp; \\ &amp; 1 &amp; &amp; 2 &amp; &amp; 1 &amp; \\ 1 &amp; &amp; 3 &amp; &amp; 3 &amp; &amp; 1 \end{array}\]</p><p>Using 0-indexing, the number of ways to reach the \(k\)-th spot in the \(n\)-th row is \(\binom{n}{k} = \frac{n!}{k!(n-k)!}\). For example, in row 3, there are \(\binom{3}{2} = 3\) ways to hit position 2.</p><p><a href="https://olu.online/posts/introduction-to-stochastic-calculus/binom_3_2_paths_pascal.svg"><img src="https://olu.online/posts/introduction-to-stochastic-calculus/binom_3_2_paths_pascal.svg" alt="Pascal&#39;s Triangle Paths for 3 choose 2" loading="lazy"/></a> <em><a href="#b5-latex-code-for-tikz-diagram-of-paths-in-pascals-triangle">Code</a> 2D image: All 3 paths for the 2nd position in the 3rd row of Pascal’s triangle</em></p><p>Why care? This setup powers the binomial distribution, which models repeated trials with two outcomes—win or lose, heads or tails. Think of:</p><ul><li>A basketball player shooting free throws with probability \(p\) of success and \(q = 1 - p\) of failure.</li><li>A gambler betting on dice rolls.</li></ul><p>Pascal’s triangle tells us there are \(\binom{n}{k}\) ways to get \(k\) wins in \(n\) trials. If the trials are <strong>independent</strong>, we can use the multiplication rule for probabilities:</p><blockquote><p>Note that the independence assumption is <strong>strong</strong>. Real life isn’t always so clean—winning streaks in games often tie to mentality or momentum, not just chance. Keep in mind that this model can and will be inaccurate, especially visibile for very long streaks in phenomena like stock prices or sports. However, in more common scenarios, it usually approximates reality well.</p></blockquote><p>\[P(A \text{ and } B \text{ and } C \dots) = P(A) P(B) P(C) \dots\]</p><p>For one sequence with \(k\) wins (probability \(p\) each) and \(n - k\) losses (probability \(q\) each), the probability is \(p^k q^{n-k}\). Multiply by the number of ways to arrange those wins, and we get:</p><p>\[P(k \text{ wins in } n \text{ trials}) = \binom{n}{k} p^k q^{n-k}\]</p><p>This is the binomial distribution—great for discrete setups. Now, let’s zoom out. The real world often involves <strong>continuous</strong> processes, like:</p><ul><li>The motion of a falling object,</li><li>Gas diffusing through a room,</li><li>Stock prices jumping around,</li><li>Molecules colliding in a liquid.</li></ul><p>For these, the binomial model gets messy as trials pile up. Calculus, with its focus on continuous change, feels more natural. In the continuous case:</p><blockquote><p>Points and sums (discrete tools) lead to infinities. We need <strong>intervals</strong> and <strong>integrals</strong> instead.</p></blockquote><h3 id="2-from-discrete-steps-to-continuous-limits"><span><strong>2. From Discrete Steps to Continuous Limits</strong></span><a href="#2-from-discrete-steps-to-continuous-limits"><i></i></a></h3><p>It’s actually known what happens to the binomial distribution as it becomes continuous. But what does that conversion mean mathematically? Let’s dig in with examples and then formalize it.</p><p>In calculus, going from discrete to continuous means shrinking step sizes and cranking up the number of steps. For an interval \([a, b]\), we:</p><ol><li>Split it into \(n\) chunks of size \(h = \frac{b - a}{n}\),</li><li>Sum up contributions (like a Riemann sum),</li><li>Let \(n \to \infty\) and \(h \to 0\), landing on an integral.</li></ol><p>Can we adapt this to the binomial distribution? Let’s try.</p><p>Picture the \(n\)-th row of Pascal’s triangle as a random walk: at each of \(n\) steps, we move \(+1\) (a win) or \(-1\) (a loss).</p><p>We’ll set the probabability of winning as \(p = 0.5\) as a first example since it’s symmetric, making each direction equally likely and simpler to work with.</p><p>The number of ways to get \(k\) wins (and \(n - k\) losses) is \(\binom{n}{k}\). Let’s try to plot this for a different values \(n\) over \(k\). (The code can be found in the <a href="#b1-python-code-for-binomial-plots">Appendix</a>.)</p><p><a href="https://olu.online/posts/introduction-to-stochastic-calculus/random_walk_combined.png"><img src="https://olu.online/posts/introduction-to-stochastic-calculus/random_walk_combined.png" alt="Plots for n=5,10,25,50,100" loading="lazy"/></a> <em><a href="#b1-python-code-for-binomial-plots">Code</a> 2D image: Binomial distribution plots for n=5,10,25,50,100</em></p><p>That looks awfully familiar, doesn’t it? It’s a bell curve, so naturally, we might guess that the limit is a <strong>normal distribution</strong> (aka Gaussian distribution).</p><p>Where does such a normal distribution arise from? The answer lies in the <strong>Central Limit Theorem</strong>, which states that the sum of a large number of independent random variables will be approximately normally distributed. So where’s the sum happening here? Let’s proceed to formalizing our intuition.</p><p>To accomplish this, let’s define a random variable for a single step as:</p><p>\[X(t) = \begin{cases} 1 &amp; \text{with probability } \frac{1}{2} \\ -1 &amp; \text{with probability } \frac{1}{2} \\ \end{cases}\]</p><p>Here, \(X(t)\) will encode our displacement at the \(t\)-th step where \(t \in \{1,\dots,n\}\) is an indexing parameter. As before, we assume that \(X(t_1)\) is independent of \(X(t_2)\) for \(t_1 \ne t_2\). At each step \(t\), \(X(t)\) has mean \(0\) and variance \(1\).</p><p>Then, the overall displacement \(S(n)\) is:</p><p>\[S(n) = X(1) + X(2) + \dots + X(n) = \sum_{t=1}^n X(t)\]</p><p>So there it is! The central limit theorem states more precisely that given \(n\) independent and identically distributed random variables \(X_1, X_2, \dots, X_n\) with mean \(\mu\) and variance \(\sigma^2\), we have:</p><p>\[X_1 + \dots + X_n \sim N(n\mu, n\sigma^2) \text{ as } n \to \infty\]</p><p>This is precisely what need. As we take \(n \to \infty\), we have that</p><p>\[S(n) \sim N(0, n)\]</p><p>such that</p><p>\[\lim_{n \to \infty} \frac{1}{\sqrt{n}} \cdot S(n) = N(0, 1)\]</p><p>which is our desired limit. We have shown that a “continuous binomial distribution” is in fact a normal distribution.</p><p>Here are some very nice 3D animations of sample paths with the distribution evolving over the number of steps:</p><p><a href="https://olu.online/posts/introduction-to-stochastic-calculus/discrete_binomial.gif"><img src="https://olu.online/posts/introduction-to-stochastic-calculus/discrete_binomial.gif" alt="Discrete Random Walk, 15 steps" loading="lazy"/></a> <em><a href="#c1-3d-plot-of-discrete-random-walks">Code</a> 3D animation: Discrete Random Walk, 15 steps</em></p><p><a href="https://olu.online/posts/introduction-to-stochastic-calculus/discrete_binomial_normalizing.gif"><img src="https://olu.online/posts/introduction-to-stochastic-calculus/discrete_binomial_normalizing.gif" alt="Discrete Random Walk, 100 steps" loading="lazy"/></a> <em><a href="#c1-3d-plot-of-discrete-random-walks">Code</a> 3D Animation: Discrete Random Walk, 100 steps over 5 seconds</em></p><p><a href="https://olu.online/posts/introduction-to-stochastic-calculus/discrete_random_walk.gif"><img src="https://olu.online/posts/introduction-to-stochastic-calculus/discrete_random_walk.gif" alt="Normal Distribution Approximation by Random Walks" loading="lazy"/></a> <em><a href="#c4-python-code-for-normal-distribution-approximation-by-random-walks">Code</a> 2D animation: Normal distribution approximation by discrete random walks</em></p><h3 id="3-defining-brownian-motion-wiener-process"><span><strong>3. Defining Brownian motion (Wiener process)</strong></span><a href="#3-defining-brownian-motion-wiener-process"><i></i></a></h3><p>Let’s consider a scenario faced by Scottish botanist <strong>Robert Brown</strong> in the 1820s. Imagine a small particle, like dust or pollen, floating on a body of water.</p><p>Brown realized that its movement was surprisingly erratic. It seemed like the small-scale nature of the setup resulted in such sensitivity to fluctuations, so much is that the real movement from external forces would completely overtake the previous one. Hence, in a simplified mathematical model we scale consider the events at different times as <em>independent</em>.</p><p>In addition, there is positional symmetry: the average position of the particle at time \(t\) seemed float approximately around the origin.</p><p>Motivated by these observations as well as our previous intuition on continuous random walks, let’s first think about a simplified model for 1-dimensional discrete case. We’ll list some properties that a continuous random walk should have.</p><ol><li><strong>Starting Point</strong>: As a mathematical convenience, we position our coordinate system to set the starting point of the walk to be zero.</li><li><strong>Positional Symmetry</strong>: The walk has no directional bias. For each step, the expected displacement is zero, such that the overall expected displacement is also zero.</li><li><strong>Independence</strong>: Steps at different times are independent. The displacement between two different intervals of time is independent.</li><li><strong>Continuity</strong>: The walk is continuous, with no jumps or gaps.</li><li><strong>Normality</strong>: As we established by taking discrete random walks in the continuous limit, the distribution of positions at any given time should be normal.</li></ol><p>So let’s write this mathematically. Such a random variable is usually denoted either by \(B_t\) for “Bronian motion”, which is the physical phenomenon, or \(W_t\) for “Wiener process”, in honor of the mathematician <strong>Norbert Wiener</strong> who developed a lot of its early theory.</p><p>I will use \(W(t)\) to emphasize its dependence on \(t\).</p><p>Let \(W(t)\) be the position of the Brownian motion at time \(t\), and let \(\Delta W(t_1,t_2)\) be the displacement of the Brownian motion from time \(t_1\) to time \(t_2\).</p><blockquote><p>Note that, unlike the discrete case, we cannot consider a single increment and have a single index \(t\) for displacements as we did with \(X(t)\). As mentioned, the continuous case requires considering intervals instead of single steps.</p></blockquote><p>Then, we write some properties of Brownian motion:</p><ol><li>\(W(0)=0\) almost surely</li><li>\(W(t)\sim N(0,t)\)<ul><li>With the first condition, this is often written equivalently as \(\Delta W(s,t)\sim N(0,t-s)\) for all \(s \ne t\)</li></ul></li><li>\(\Delta W(t_1,t_2)\) is independent of \(\Delta W(t_2,t_3)\) for arbitrary distinct \(t_1 &lt; t_2 \le t_3\)</li></ol><p>We can straightforwardly use these conditions are enough to find</p><ol><li>\(E[W(t)]=0\) for all \(t\)</li><li>\(Var(W(t))=t\) for all \(t\)</li></ol><p>This is analogous to the discrete case.</p><p>But it also turns out that these conditions are sufficient to prove continuity, although it’s more involved:</p><ol><li>The sample path \(t \mapsto W(t)\) is almost surely uniformly Hölder continuous for each exponent \(\gamma &lt; \frac{1}{2}\), but is nowhere Hölder continuous for \(\gamma &gt;= \frac{1}{2}\). <a href="https://math.nyu.edu/~bourgade/SA2010/StochasticAnalysis.pdf#page30">p.30,33 of source</a><ul><li>In particular, a sample path \(t \mapsto W(t)\) is almost surely nowhere differentiable.</li></ul></li></ol><p>So, \(W(t)\) is our mathematical model for Brownian motion: a continuous, random, zero-mean process with variance proportional to time. It’s wild—it’s globally somewhat predictable yet locally completely unpredictable. A plot of W(t) looks like a jagged mess, but it’s got structure under the hood. (You can generate one yourself with the code in <a href="#b2-python-code-for-brownian-motion-plot">Appendix</a>.)</p><p><a href="https://olu.online/posts/introduction-to-stochastic-calculus/sample_brownian_motion.png"><img src="https://olu.online/posts/introduction-to-stochastic-calculus/sample_brownian_motion.png" alt="Sample Brownian Motion Path" loading="lazy"/></a> <em><a href="#b2-python-code-for-brownian-motion-plot">Code</a> 2D image: Sample Brownian motion path</em></p><p><a href="https://olu.online/posts/introduction-to-stochastic-calculus/continuous_brownian_3d_smooth.gif"><img src="https://olu.online/posts/introduction-to-stochastic-calculus/continuous_brownian_3d_smooth.gif" alt="3D Animation Continuous Brownian Motion" loading="lazy"/></a> <em><a href="#c2-3d-animation-of-brownian-motion">Code</a> 3D animation: Brownian motion with evolving distribution</em></p><p>Now, let’s take this beast and do something useful with it.</p><hr/><h3 id="4-itô-calculus"><span><strong>4. Itô Calculus</strong></span><a href="#4-itô-calculus"><i></i></a></h3><p>Brownian motion \(W(t)\) is continuous but so irregular that it’s nowhere differentiable. To see why, consider the rate of change over a small interval \(dt\):</p><p>\[\lim_{dt \to 0} \frac{W(t + dt) - W(t)}{dt} = \lim_{dt \to 0} \frac{\Delta W(t, t + dt)}{dt}\]</p><p>Since \(\Delta W(t, t + dt) \sim N(0, dt) = \sqrt{dt} \, N(0, 1)\):</p><p>\[\frac{\Delta W(t, t + dt)}{dt} = \frac{\sqrt{dt} \, N(0, 1)}{dt} = \frac{1}{\sqrt{dt}} N(0, 1)\]</p><p>As \(dt \to 0\), \(\frac{1}{\sqrt{dt}}\) grows without bound, and the expression becomes dominated by random fluctuations—it doesn’t converge to a finite derivative. This rules out standard calculus for handling Brownian motion, but we still need a way to work with processes driven by it, like stock prices or particle diffusion.</p><p>In the 1940s, Kiyosi Itô developed a framework to address this: <strong>Itô calculus</strong>. Rather than forcing Brownian motion into the rules of regular calculus, Itô built a new system tailored to its random nature, forming the foundation of stochastic calculus.</p><h4 id="the-increment-dw-and-its-properties"><span><strong>The Increment \(dW\) and Its Properties</strong></span><a href="#the-increment-dw-and-its-properties"><i></i></a></h4><p>Define the small change in Brownian motion over an interval \(dt\):</p><p>\[dW := W(t + dt) - W(t) = \Delta W(t, t + dt)\]</p><p>From Section 3, \(W(t + dt) - W(t) \sim N(0, dt)\), so:</p><p>\[dW = \sqrt{dt} \, N(0, 1)\]</p><p>Unlike the deterministic \(dx\) in regular calculus, \(dW\) is random—its magnitude scales with \(\sqrt{dt}\), and its sign depends on a standard normal distribution \(N(0, 1)\). It’s a small but erratic step, with:</p><ul><li>\(E[dW] = 0\),</li><li>\(Var(dW) = E[(dW)^2] = dt\).</li></ul><p>Now consider \((dW)^2\). Its expected value is \(dt\), but what about its variability? The variance is \(Var[(dW)^2] = 2 dt^2\), which becomes negligible as \(dt \to 0\). This stability allows us to treat \((dW)^2 \approx dt\) in Itô calculus (formally, in the mean-square sense—see the <a href="#a1-notation">Appendix</a> for details). In contrast to regular calculus, where \((dx)^2\) is too small to matter, \((dW)^2\) is on the same scale as \(dt\), which changes how we handle calculations.</p><h4 id="the-itô-integral-integrating-against-randomness"><span><strong>The Itô Integral: Integrating Against Randomness</strong></span><a href="#the-itô-integral-integrating-against-randomness"><i></i></a></h4><p>In regular calculus, \(\int_a^b f(x) \, dx\) approximates the area under a curve by summing rectangles, \(\sum f(x_i) \Delta x\), and taking the limit as \(\Delta x \to 0\). For Brownian motion, we want something like \(\int_0^t f(s) \, dW(s)\), where \(dW(s)\) replaces \(dx\). Here, the steps are random: \(\Delta W(s_i, s_{i+1}) \sim \sqrt{\Delta s} \, N(0, 1)\). We approximate:</p><p>\[\int_0^t f(s) \, dW(s) \approx \sum_{i=0}^{n-1} f(s_i) [\Delta W(s_i, s_{i+1})]\]</p><p>over a partition \(s_0, s_1, \dots, s_n\) of \([0, t]\), then let \(n \to \infty\). Unlike a deterministic integral, the result is a random variable, reflecting \(W(t)’s\) randomness. Using \(f(s_i)\) from the left endpoint keeps the integral “non-anticipating”—we only use information up to time \(s_i\), which aligns with the forward-evolving nature of stochastic processes.</p><h4 id="itôs-lemma-a-chain-rule-for-randomness"><span><strong>Itô’s Lemma: A Chain Rule for Randomness</strong></span><a href="#itôs-lemma-a-chain-rule-for-randomness"><i></i></a></h4><p>For a function \(f(t, W(t))\), regular calculus gives:</p><p>\[df = \frac{\partial f}{\partial t} dt + \frac{\partial f}{\partial W} dW\]</p><p>But Brownian motion’s roughness requires a second-order term. Taylor-expand \(f(t, W(t))\):</p><p>\[df = \frac{\partial f}{\partial t} dt + \frac{\partial f}{\partial W} dW + \frac{1}{2} \frac{\partial^2 f}{\partial W^2} (dW)^2 + \text{smaller terms}\]</p><p>As \(dt \to 0\):</p><ul><li>\(dt^2\) and \(dt \, dW\) vanish,</li><li>\((dW)^2 \approx dt\) stays significant.</li></ul><p>This leaves:</p><p>\[df = \frac{\partial f}{\partial t} dt + \frac{\partial f}{\partial W} dW + \frac{1}{2} \frac{\partial^2 f}{\partial W^2} dt\]</p><p>This is <strong>Itô’s Lemma</strong>. The extra \(\frac{1}{2} \frac{\partial^2 f}{\partial W^2} dt\) arises because \((dW)^2\) contributes at the \(dt\) scale, capturing the effect of Brownian motion’s curvature.</p><p>Since we have the algebraic heuristic \(dW^2 = dt\), we could in some define everything in terms of powers \(dW\) to expand things algebraically and implicitly compute derivative rules.</p><p>This is precisely the idea behind my blog post on <a href="https://olu.online/posts/automatic-stochastic-differentiation/index.html">Automatic Stochastic Differentiation</a>, where we use \(\mathbb{R}[\epsilon]/\epsilon^3\) in a similar fashion to dual numbers \(\mathbb{R}[\epsilon]/\epsilon^2\) for automatic differentiation in deterministic calculus.</p><p>If you haven’t already, I highly recommend checking it out.</p><h4 id="example-fw--w2"><span><strong>Example: \(f(W) = W^2\)</strong></span><a href="#example-fw--w2"><i></i></a></h4><p>Take \(f(t, W(t)) = W^2\):</p><ul><li>\(\frac{\partial f}{\partial t} = 0\),</li><li>\(\frac{\partial f}{\partial W} = 2W\),</li><li>\(\frac{\partial^2 f}{\partial W^2} = 2\).</li></ul><p>Then:</p><p>\[d(W^2) = 0 \cdot dt + 2W \, dW + \frac{1}{2} \cdot 2 \cdot dt = 2W \, dW + dt\]</p><p>Integrate from 0 to \(t\) (with \(W(0) = 0\)):</p><p>\[W(t)^2 = \int_0^t 2W(s) \, dW(s) + t\]</p><p>The \(t\) term matches \(E[W(t)^2] = t\), and the integral is a random component with mean 0, consistent with Brownian motion’s properties.</p><hr/><h3 id="5-stochastic-differential-equations"><span><strong>5. Stochastic Differential Equations</strong></span><a href="#5-stochastic-differential-equations"><i></i></a></h3><p>Itô calculus gives us tools—integrals and a chain rule—to handle Brownian motion. Now we can model systems where randomness and trends coexist, using <strong>stochastic differential equations (SDEs)</strong>. Unlike regular differential equations (e.g., \(\frac{dx}{dt} = -kx\)) that describe smooth dynamics, SDEs blend deterministic behavior with stochastic noise, fitting phenomena like stock prices or diffusing particles.</p><h4 id="defining-an-sde"><span><strong>Defining an SDE</strong></span><a href="#defining-an-sde"><i></i></a></h4><p>Consider a process influenced by both a predictable trend and random fluctuations:</p><p>\[dX(t) = a(t, X(t)) \, dt + b(t, X(t)) \, dW(t)\]</p><ul><li>\(X(t)\): The evolving quantity (e.g., position or price).</li><li>\(a(t, X(t)) \, dt\): The “drift”—the systematic part, scaled by \(dt\).</li><li>\(b(t, X(t)) \, dW(t)\): The “diffusion”—random perturbations from Brownian motion.</li></ul><p>Here, \(a\) and \(b\) are functions of time and state, and \(dW(t) = \sqrt{dt} \, N(0, 1)\) brings the noise. Solutions to SDEs aren’t fixed curves but random paths, each run producing a different trajectory with statistical patterns we can study.</p><h4 id="itôs-lemma-revisited"><span><strong>Itô’s Lemma Revisited</strong></span><a href="#itôs-lemma-revisited"><i></i></a></h4><p>Itô’s lemma actually applies to a function \(f(t, X(t))\) and its stochastic derivative \(df(t, X(t))\) for a general \(dX(t) = b(t,X(t))dt+\sigma(t,X(t))dW\), and this is done through the linearity of the Itô differential (as seen using the \(\mathbb{R}[\epsilon]/\epsilon^3\) formulation).</p><p>Considering that \(dX=O(dW)\), we consider terms up to \(dX^2=O(dW^2)\):</p><p>\[\begin{aligned} df &amp;= f_t \, dt + f_X \, dX + \frac{1}{2}f_{XX} dX^2 \\ &amp;= f_t \, dt + f_X \, (b \, dt+\sigma \, dW) + \frac{1}{2}f_{XX} (b \, dt+\sigma \, dW)^2 \\ &amp;= (f_t + bf_X+\frac{1}{2}\sigma^2 f_{XX}) \, dt + \sigma f_X \, dW \end{aligned}\]</p><p>which is the general form typically presented.</p><h4 id="drift-and-diffusion"><span><strong>Drift and Diffusion</strong></span><a href="#drift-and-diffusion"><i></i></a></h4><p>The drift \(a(t, X)\) sets the average direction, like a current pushing a particle. The diffusion \(b(t, X)\) determines the random jitter’s strength. If \(b = 0\), we get a standard ODE; if \(a = 0\), it’s just scaled Brownian motion. Together, they model systems with both structure and uncertainty.</p><p>Take a simple case:</p><p>\[dX(t) = \mu \, dt + \sigma \, dW(t)\]</p><ul><li>\(\mu\): Constant drift.</li><li>\(\sigma\): Constant noise amplitude.</li></ul><p>Starting at \(X(0) = 0\), integrate:</p><p>\[X(t) = \int_0^t \mu \, ds + \int_0^t \sigma \, dW(s) = \mu t + \sigma W(t)\]</p><p>Since \(W(t) \sim N(0, t)\), we have \(X(t) \sim N(\mu t, \sigma^2 t)\)—a process drifting linearly with noise spreading over time. It’s a basic model for things like a stock with steady growth and volatility.</p><p><a href="https://olu.online/posts/introduction-to-stochastic-calculus/sample_SDE.png"><img src="https://olu.online/posts/introduction-to-stochastic-calculus/sample_SDE.png" alt="Sample SDE Path" loading="lazy"/></a> <em><a href="#b3-python-code-for-basic-sde-simulation">Code</a> 2D image: Sample SDE path with mu=1.0, sigma=0.5</em></p><h4 id="geometric-brownian-motion"><span><strong>Geometric Brownian Motion</strong></span><a href="#geometric-brownian-motion"><i></i></a></h4><p>For systems where changes scale with size—like stock prices or certain physical processes—consider <strong>geometric Brownian motion (GBM)</strong>:</p><p>\[dS(t) = \mu S(t) \, dt + \sigma S(t) \, dW(t)\]</p><ul><li>\(S(t)\): The state (e.g., stock price).</li><li>\(\mu S(t)\): Proportional drift.</li><li>\(\sigma S(t)\): Proportional noise.</li></ul><p>The percentage change \(\frac{dS}{S} = \mu \, dt + \sigma \, dW\) has a trend and randomness. To solve, let \(f = \ln S\):</p><ul><li>\(\frac{\partial f}{\partial t} = 0\),</li><li>\(\frac{\partial f}{\partial S} = \frac{1}{S}\),</li><li>\(\frac{\partial^2 f}{\partial S^2} = -\frac{1}{S^2}\).</li></ul><p>Using Itô’s lemma:</p><p>\[d(\ln S) = \frac{1}{S} (\mu S \, dt + \sigma S \, dW) + \frac{1}{2} \left( -\frac{1}{S^2} \right) (\sigma^2 S^2 dt)\] \[= \left( \mu - \frac{1}{2} \sigma^2 \right) dt + \sigma \, dW\]</p><p>Integrate from \(0\) to \(t\):</p><p>\[\ln S(t) - \ln S(0) = \left( \mu - \frac{1}{2} \sigma^2 \right) t + \sigma W(t)\] \[S(t) = S(0) \exp\left( \left( \mu - \frac{1}{2} \sigma^2 \right) t + \sigma W(t) \right)\]</p><p>The drift is adjusted by \(-\frac{1}{2} \sigma^2\) due to the second-order effect of noise, and \(\sigma W(t)\) adds random fluctuations. This form underlies the Black-Scholes model in finance.</p><p><a href="https://olu.online/posts/introduction-to-stochastic-calculus/gbm_path.png"><img src="https://olu.online/posts/introduction-to-stochastic-calculus/gbm_path.png" alt="Sample Geometric Brownian Motion Path" loading="lazy"/></a> <em><a href="#b4-python-code-for-geometric-brownian-motion-simulation">Code</a> 2D image: A sample path of a geometric Brownian motion with parameters μ = 0.15 and σ = 0.2</em></p><p><a href="https://olu.online/posts/introduction-to-stochastic-calculus/geometric_brownian_drifted_3d.gif"><img src="https://olu.online/posts/introduction-to-stochastic-calculus/geometric_brownian_drifted_3d.gif" alt="Geometric Brownian Motion drifting over time" loading="lazy"/></a> <em><a href="#c3-3d-animation-of-geometric-brownian-motion">Code</a> 3D animation: Geometric Brownian Motion drifting over time</em></p><h4 id="beyond-analytics"><span><strong>Beyond Analytics</strong></span><a href="#beyond-analytics"><i></i></a></h4><p>Analytical solutions like GBM’s are exceptions. Most SDEs require numerical simulation (e.g., stepping \(X(t + \Delta t) = X(t) + \mu \Delta t + \sigma \sqrt{\Delta t} \, N(0, 1)\)) or statistical analysis via equations like Fokker-Planck. See the <a href="#b3-python-code-for-basic-sde-simulation">appendix</a> for simulation code.</p><hr/><h3 id="6-stratonovich-calculus"><span><strong>6. Stratonovich Calculus</strong></span><a href="#6-stratonovich-calculus"><i></i></a></h3><p>Recall Itô’s lemma:</p><p>\[df = \left(\frac{\partial f}{\partial t} + \frac{1}{2} \frac{\partial^2 f}{\partial X^2}\right) dt + \frac{\partial f}{\partial X} dX\]</p><p>That second derivative term is pretty annoying to deal with in calculations. Is there a way we can simplify it to the familiar chain rule in regular calculus?</p><p>\[df = \frac{\partial f}{\partial t} dt + \frac{\partial f}{\partial X} dX\]</p><p>The answer is yes, and it’s called <strong>Stratonovich calculus</strong>. Let’s explore a bit. First, the deterministic part clearly satisfies the regular chain rule, since we can directly apply it using linearity. The trouble arises in the stochastic part, which we need to analyze. This means we only need to consider a function \(f(X(t))\).</p><p>Remember, for the Itô form, we chose to define the integral by choosing the left endpoint of each interval. In other words, it is this stochastic part that will vary. To delete this second order term, we need to somehow absorb it into the stochastic part by defining some Stratonovich differential, typically denoted by \(\circ dW\).</p><p>Going back to our Riemann sum definitions, our degrees of freedom lie in the choice of the evaluation point for each interval:</p><p>\[\int_{0}^{T} f(X(t)) \diamond dW = \lim_{n \to \infty} \sum_{i=0}^{n-1} f(X(t_i) + \lambda \Delta X(t_i,t_{i+1})) \Delta W(t_i, t_{i+1})\]</p><p>where \(\lambda \in [0,1]\) is a constant that linearly interpolates between the left and right endpoints of each interval giving a corresponding differential \(\diamond dW\), and \(\Delta X(t_i,t_{i+1}):=X(t_{i+1})-X(t_i)\).</p><p>In the deterministic case, since we always have \(O(dX^2) \to 0\), it doesn’t matter where we choose the evaluation point. However, in the stochastic case, remember that \(O(dW^2) \to O(dt)\), so we need a more careful choice of evaluation point.</p><p>Mathematically, our goal is to define a new stochastic integral that preserves the standard chain rule:</p><p>\[df = f_X \circ dX\]</p><p>In the limiting discrete form, let’s try setting every term equal to each other:</p><p>\[f(X+\Delta X) - f(X) = f_X(X+\lambda \Delta X) \Delta X\]</p><p>In other words, our newly defined differential should result in the derivative being a linear approximation of the original function instead of quadratic:</p><p>\[\frac{f(X+\Delta X)-f(X)}{\Delta X} = f_X(X+\lambda \Delta X)\]</p><p>But watch what happens as we take the Taylor expansion on both sides about \(X\) (recalling that \(o(\Delta X^2)\to 0\)):</p><p>\[f_X + \frac{1}{2}f_{XX}\Delta X = f_X + \lambda f_{XX}\Delta X\]</p><p>Comparing coefficients, we wish to set \(\lambda = 1/2\) to preserve the chain rule. So Stratonovich integrals are defined by the midpoint evaluation rule:</p><p>\[\begin{aligned} \int_{0}^{T} f(X(t)) \circ dW &amp;= \lim_{n \to \infty} \sum_{i=0}^{n-1} f(X(t_i) + \frac{1}{2} \Delta X(t_i,t_{i+1})) \Delta W(t_i, t_{i+1}) \\ &amp;= \lim_{n \to \infty} \sum_{i=0}^{n-1} f\left(\frac{X(t_i)+X(t_{i+1})}{2}\right) \Delta W(t_i, t_{i+1}) \\ \end{aligned}\]</p><h4 id="conversion-formula-between-itô-and-stratonovich"><span>Conversion Formula between Itô and Stratonovich</span><a href="#conversion-formula-between-itô-and-stratonovich"><i></i></a></h4><p>There is a formula to convert the Stratonovich differential into a corresponding Itô SDE that depends on the Itô differential as well as the volatility function \(\sigma\).</p><p>Recall that Itô’s lemma states that for \(dX = a dt + b dW\):</p><p>\[df = f_t dt + f_X dX + \frac{1}{2}f_{XX} dX^2 = (af_t + \frac{1}{2} b^2 f_{XX}) dt + bf_X dW\]</p><p>In parallel, we defined Stratonovich’s chain rule to satisfy for \(dX = \tilde a dt + \tilde b \circ dW\):</p><p>\[df = f_t dt + f_X \circ dX = (f_t + \tilde a f_X) dt + \tilde b f_X \circ dW\]</p><p>Hence, between Itô and Stratonovich SDEs, we have in both cases that the differential is scaled by the volatility function of \(X\) and \(f_X\), but the drift function changes. Let’s find a conversion formula between the two.</p><p>Suppose we have:</p><p>\[dX = a dt + b dW = \tilde a dt + b \circ dW\]</p><p>Then, our objective is to find \(\tilde a\) in terms of \(a\).</p><p>Recall from the integral definition that \(b(X) \circ dW = b(X+\frac{1}{2}dX) dW\). If we Taylor expand around \(X\), we have:</p><p>\[b(X+\frac{1}{2}dX) dW = b(X)dW + b_X(X)\frac{1}{2}dX dW + o(dt)\]</p><p>Now, if we plug in \(dX=a dt + b dW\), the first term vanishes, leaving \(b_X b \frac{1}{2}dW^2 \sim \frac{1}{2}b_X b dt\) (where the arguments \(X\) are left implicit).</p><p>Hence:</p><p>\[a = \tilde a + \frac{1}{2} b_X b.\]</p><h4 id="applications-of-stratonovich-calculus"><span><strong>Applications of Stratonovich Calculus</strong></span><a href="#applications-of-stratonovich-calculus"><i></i></a></h4><p>Stratonovich calculus, with its midpoint evaluation rule, adjusts how we handle stochastic integrals compared to Itô’s left-endpoint approach. This shift makes it valuable in certain fields where its properties align with physical systems or simplify calculations. Below are some practical applications, each with a concrete mathematical example.</p><ul><li><p><strong>Physics with Multiplicative Noise</strong>: In physical systems, noise often scales with the state—like a particle in a fluid where random kicks depend on its position. Consider a damped oscillator with position \(X(t)\) under state-dependent noise:</p>\[dX = -k X \, dt + \sigma X \circ dW\]<p>Here, \(k &gt; 0\) is the damping constant, \(\sigma\) is the noise strength, and \(\circ dW\) denotes the Stratonovich differential. Using Stratonovich’s chain rule, for \(f(X) = \ln X\):</p>\[d(\ln X) = \frac{1}{X} (-k X \, dt + \sigma X \circ dW) = -k \, dt + \sigma \circ dW\]<p>This integrates to \(X(t) = X(0) e^{-kt + \sigma W(t)}\), matching the expected exponential decay with noise. Stratonovich fits here because it preserves symmetries in continuous physical processes, unlike Itô, which adds a \(\frac{1}{2} \sigma^2 X \, dt\) drift term.</p></li><li><p><strong>Wong-Zakai Theorem and Smooth Noise</strong>: Real-world noise isn’t perfectly white (uncorrelated like \(dW\))—it’s often smoother. The Wong-Zakai theorem shows that approximating smooth noise (e.g., \(\eta(t)\) with correlation time \(\epsilon\)) as \(\epsilon \to 0\) yields a Stratonovich SDE. Take a simple system:</p>\[\dot{x} = a x + b x \eta(t)\]<p>As \(\eta(t) \to\) white noise, this becomes \(dX = a X \, dt + b X \circ dW\). In Stratonovich form, the solution is \(X(t) = X(0) e^{a t + b W(t)}\). This is useful in engineering, like modeling voltage in a circuit with thermal fluctuations, where noise has slight smoothness.</p></li><li><p><strong>Stochastic Control</strong>: In control problems, Stratonovich can simplify dynamics under feedback. Consider a system with control input \(u(t)\) and noise:</p>\[dX = (a X + u) \, dt + \sigma X \circ dW\]<p>For \(f(X) = X^2\), the Stratonovich rule gives:</p>\[d(X^2) = 2X (a X + u) \, dt + 2X \cdot \sigma X \circ dW = (2a X^2 + 2X u) \, dt + 2\sigma X^2 \circ dW\]<p>The lack of a second-derivative term (unlike Itô’s \(+ \sigma^2 X^2 dt\)) aligns with classical control intuition, making it easier to design \(u(t)\) for, say, stabilizing a noisy pendulum or a drone in wind.</p></li><li><p><strong>Biological Diffusion</strong>: In biology, noise can depend on spatial gradients, like protein diffusion across a cell. Model this as:</p>\[dX = \mu \, dt + \sigma(X) \circ dW, \quad \sigma(X) = \sqrt{2D (1 + k X^2)}\]<p>where \(D\) is diffusivity and \(k\) adjusts noise with position. Stratonovich ensures the diffusion term reflects physical conservation laws, matching experimental data in systems like bacterial motility better than Itô, which alters the drift.</p></li><li><p><strong>Numerical Stability</strong>: For simulations, Stratonovich pairs well with midpoint methods. Take \(dX = -a X \, dt + \sigma \circ dW\). A Stratonovich discretization might use:</p>\[X_{n+1} = X_n - a \left(\frac{X_n + X_{n+1}}{2}\right) \Delta t + \sigma \Delta W_n\]<p>This implicit scheme leverages the midpoint rule, reducing numerical artifacts in models like chemical kinetics compared to Itô’s explicit steps.</p></li></ul><p>The choice between Stratonovich and Itô depends on context. Stratonovich suits systems where noise is tied to physical continuity or symmetry, while Itô dominates in finance for its non-anticipating properties. The conversion \(a = \tilde{a} + \frac{1}{2} b b_X\) lets you switch forms as needed.</p><h2 id="appendix"><span>Appendix</span><a href="#appendix"><i></i></a></h2><h3 id="a0-further-reading"><span>A.0. Further Reading</span><a href="#a0-further-reading"><i></i></a></h3><ul><li><a href="https://www.chrisrackauckas.com/assets/Papers/ChrisRackauckas-IntuitiveSDEs.pdf">An Intuitive Introduction For Understanding and Solving Stochastic Differential Equations - Chris Rackauckas (2017)</a></li><li><a href="https://math.nyu.edu/~bourgade/SA2010/StochasticAnalysis.pdf">Stochastic analysis - Paul Bourgade (2010)</a></li><li><a href="https://www.cmor-faculty.rice.edu/~cox/stoch/SDE.course.pdf">AN INTRODUCTION TO STOCHASTIC DIFFERENTIAL EQUATIONS VERSION 1.2 - Lawrence C. Evans (2013)</a></li><li>Stochastic differential equations An introduction with applications - Bernt K. Øksendal (2003)</li><li><a href="https://en.wikipedia.org/wiki/Stochastic_calculus">Wikipedia: Stochastic calculus</a></li><li><a href="https://en.wikipedia.org/wiki/Stochastic_differential_equation">Wikipedia: Stochastic differential equation</a></li></ul><h3 id="a1-notation"><span>A.1. Notation</span><a href="#a1-notation"><i></i></a></h3><p>Here is a list of notation used in this document:</p><ul><li>\(\binom{n}{k}=\frac{n!}{k!(n-k)!}\) is the binomial coefficient</li><li>\(X: \Omega \to \mathbb{R}\) is a random variable from a sample space \(\Omega\) to a real number</li><li>\(P(A)\) is the probability of event \(A\)</li><li>\(E[X]=\int_{\omega \in \Omega} X(\omega) dP(\omega)\) is the expected value of \(X\)</li><li>\(N(\mu, \sigma^2)\) is a normal distribution with mean \(\mu\) and variance \(\sigma^2\)</li><li>\(W(t)\) is the position of a Brownian motion at time \(t\)</li><li>\(\Delta W(t_1,t_2)\) is the displacement of a Brownian motion from time \(t_1\) to time \(t_2\)</li><li>\(dt\) is an infinitesimal time increment</li><li>\(dW := \Delta W(t,t+dt)\) is an infinitesimal increment of Brownian motion over time</li><li>\((dW)^2 \sim dt\) denotes that \((dW^2) = dt + o(dt)\) where \(\lim_{t \to 0} \frac{o(dt)}{dt} = 0\), such that \((dW)^2\) is asymptotically equal to \(dt\) in the mean-square limit:</li></ul><p>\(\lim_{dt \to 0} \frac{E[(dW)^2-dt]^2}{dt}=0\)</p><ul><li>\(f_t:=\frac{\partial f}{\partial t}\) is the partial derivative of \(f\) with respect to \(t\)</li><li>\(f_xx:=\frac{\partial^2 f}{\partial x^2}\) is the second order partial derivative of \(f\) with respect to \(x\)</li></ul><h3 id="b1-python-code-for-binomial-plots"><span>B.1. Python code for binomial plots</span><a href="#b1-python-code-for-binomial-plots"><i></i></a></h3><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td><pre><span>import</span> <span>numpy</span> <span>as</span> <span>np</span>
<span>import</span> <span>matplotlib.pyplot</span> <span>as</span> <span>plt</span>
<span>from</span> <span>scipy.stats</span> <span>import</span> <span>binom</span>

<span>n_values</span> <span>=</span> <span>[</span><span>5</span><span>,</span> <span>10</span><span>,</span> <span>25</span><span>,</span> <span>50</span><span>,</span> <span>100</span><span>]</span>
<span>p</span> <span>=</span> <span>0.5</span>

<span># Individual plots
</span><span>for</span> <span>n</span> <span>in</span> <span>n_values</span><span>:</span>
    <span>k</span> <span>=</span> <span>np</span><span>.</span><span>arange</span><span>(</span><span>0</span><span>,</span> <span>n</span> <span>+</span> <span>1</span><span>)</span>
    <span>positions</span> <span>=</span> <span>2</span> <span>*</span> <span>k</span> <span>-</span> <span>n</span>
    <span>probs</span> <span>=</span> <span>binom</span><span>.</span><span>pmf</span><span>(</span><span>k</span><span>,</span> <span>n</span><span>,</span> <span>p</span><span>)</span>
    
    <span>plt</span><span>.</span><span>figure</span><span>(</span><span>figsize</span><span>=</span><span>(</span><span>6</span><span>,</span> <span>4</span><span>))</span>
    <span>plt</span><span>.</span><span>bar</span><span>(</span><span>positions</span><span>,</span> <span>probs</span><span>,</span> <span>width</span><span>=</span><span>1.0</span><span>,</span> <span>color</span><span>=</span><span>&#39;</span><span>skyblue</span><span>&#39;</span><span>,</span> <span>edgecolor</span><span>=</span><span>&#39;</span><span>black</span><span>&#39;</span><span>)</span>
    <span>plt</span><span>.</span><span>title</span><span>(</span><span>f</span><span>&#39;</span><span>n = </span><span>{</span><span>n</span><span>}</span><span>&#39;</span><span>)</span>
    <span>plt</span><span>.</span><span>xlabel</span><span>(</span><span>&#39;</span><span>Position (# wins - # losses)</span><span>&#39;</span><span>)</span>
    <span>plt</span><span>.</span><span>ylabel</span><span>(</span><span>&#39;</span><span>Probability</span><span>&#39;</span><span>)</span>
    <span>plt</span><span>.</span><span>ylim</span><span>(</span><span>0</span><span>,</span> <span>max</span><span>(</span><span>probs</span><span>)</span> <span>*</span> <span>1.2</span><span>)</span>
    <span>plt</span><span>.</span><span>savefig</span><span>(</span><span>f</span><span>&#39;</span><span>random_walk_n_</span><span>{</span><span>n</span><span>}</span><span>.png</span><span>&#39;</span><span>,</span> <span>dpi</span><span>=</span><span>300</span><span>,</span> <span>bbox_inches</span><span>=</span><span>&#39;</span><span>tight</span><span>&#39;</span><span>)</span>
    <span>plt</span><span>.</span><span>close</span><span>()</span>

<span># Combined plot
</span><span>fig</span><span>,</span> <span>axes</span> <span>=</span> <span>plt</span><span>.</span><span>subplots</span><span>(</span><span>5</span><span>,</span> <span>1</span><span>,</span> <span>figsize</span><span>=</span><span>(</span><span>8</span><span>,</span> <span>12</span><span>),</span> <span>sharex</span><span>=</span><span>True</span><span>)</span>
<span>for</span> <span>i</span><span>,</span> <span>n</span> <span>in</span> <span>enumerate</span><span>(</span><span>n_values</span><span>):</span>
    <span>k</span> <span>=</span> <span>np</span><span>.</span><span>arange</span><span>(</span><span>0</span><span>,</span> <span>n</span> <span>+</span> <span>1</span><span>)</span>
    <span>positions</span> <span>=</span> <span>2</span> <span>*</span> <span>k</span> <span>-</span> <span>n</span>
    <span>probs</span> <span>=</span> <span>binom</span><span>.</span><span>pmf</span><span>(</span><span>k</span><span>,</span> <span>n</span><span>,</span> <span>p</span><span>)</span>
    <span>axes</span><span>[</span><span>i</span><span>].</span><span>bar</span><span>(</span><span>positions</span><span>,</span> <span>probs</span><span>,</span> <span>width</span><span>=</span><span>1.0</span><span>,</span> <span>color</span><span>=</span><span>&#39;</span><span>skyblue</span><span>&#39;</span><span>,</span> <span>edgecolor</span><span>=</span><span>&#39;</span><span>black</span><span>&#39;</span><span>)</span>
    <span>axes</span><span>[</span><span>i</span><span>].</span><span>set_title</span><span>(</span><span>f</span><span>&#39;</span><span>n = </span><span>{</span><span>n</span><span>}</span><span>&#39;</span><span>)</span>
    <span>axes</span><span>[</span><span>i</span><span>].</span><span>set_ylabel</span><span>(</span><span>&#39;</span><span>Probability</span><span>&#39;</span><span>)</span>
    <span>axes</span><span>[</span><span>i</span><span>].</span><span>set_ylim</span><span>(</span><span>0</span><span>,</span> <span>max</span><span>(</span><span>probs</span><span>)</span> <span>*</span> <span>1.2</span><span>)</span>
<span>axes</span><span>[</span><span>-</span><span>1</span><span>].</span><span>set_xlabel</span><span>(</span><span>&#39;</span><span>Position (# wins - # losses)</span><span>&#39;</span><span>)</span>
<span>plt</span><span>.</span><span>tight_layout</span><span>()</span>
<span>plt</span><span>.</span><span>savefig</span><span>(</span><span>&#39;</span><span>random_walk_combined.png</span><span>&#39;</span><span>,</span> <span>dpi</span><span>=</span><span>300</span><span>,</span> <span>bbox_inches</span><span>=</span><span>&#39;</span><span>tight</span><span>&#39;</span><span>)</span>
<span>plt</span><span>.</span><span>close</span><span>()</span>
</pre></td></tr></tbody></table></code></p></div><h3 id="b2-python-code-for-brownian-motion-plot"><span><strong>B2. Python Code for Brownian Motion Plot</strong></span><a href="#b2-python-code-for-brownian-motion-plot"><i></i></a></h3><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td><pre><span>import</span> <span>numpy</span> <span>as</span> <span>np</span>
<span>import</span> <span>matplotlib.pyplot</span> <span>as</span> <span>plt</span>

<span># Simulate Brownian motion
</span><span>np</span><span>.</span><span>random</span><span>.</span><span>seed</span><span>(</span><span>42</span><span>)</span>
<span>t</span> <span>=</span> <span>np</span><span>.</span><span>linspace</span><span>(</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>1000</span><span>)</span>  <span># Time from 0 to 1
</span><span>dt</span> <span>=</span> <span>t</span><span>[</span><span>1</span><span>]</span> <span>-</span> <span>t</span><span>[</span><span>0</span><span>]</span>
<span>dW</span> <span>=</span> <span>np</span><span>.</span><span>sqrt</span><span>(</span><span>dt</span><span>)</span> <span>*</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>normal</span><span>(</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>size</span><span>=</span><span>len</span><span>(</span><span>t</span><span>)</span><span>-</span><span>1</span><span>)</span>  <span># Increments
</span><span>W</span> <span>=</span> <span>np</span><span>.</span><span>concatenate</span><span>([[</span><span>0</span><span>],</span> <span>np</span><span>.</span><span>cumsum</span><span>(</span><span>dW</span><span>)])</span>  <span># Cumulative sum starts at 0
</span>
<span># Plot
</span><span>plt</span><span>.</span><span>plot</span><span>(</span><span>t</span><span>,</span> <span>W</span><span>)</span>
<span>plt</span><span>.</span><span>title</span><span>(</span><span>&#34;</span><span>Sample Brownian Motion Path</span><span>&#34;</span><span>)</span>
<span>plt</span><span>.</span><span>xlabel</span><span>(</span><span>&#34;</span><span>Time t</span><span>&#34;</span><span>)</span>
<span>plt</span><span>.</span><span>ylabel</span><span>(</span><span>&#34;</span><span>W(t)</span><span>&#34;</span><span>)</span>
<span>plt</span><span>.</span><span>grid</span><span>(</span><span>True</span><span>)</span>
<span>plt</span><span>.</span><span>show</span><span>()</span>
</pre></td></tr></tbody></table></code></p></div><h3 id="b3-python-code-for-basic-sde-simulation"><span><strong>B3. Python Code for Basic SDE Simulation</strong></span><a href="#b3-python-code-for-basic-sde-simulation"><i></i></a></h3><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td><pre><span>import</span> <span>numpy</span> <span>as</span> <span>np</span>
<span>import</span> <span>matplotlib.pyplot</span> <span>as</span> <span>plt</span>

<span># Simulate simple SDE: dX = mu dt + sigma dW
</span><span>np</span><span>.</span><span>random</span><span>.</span><span>seed</span><span>(</span><span>42</span><span>)</span>
<span>T</span> <span>=</span> <span>1.0</span>
<span>N</span> <span>=</span> <span>1000</span>
<span>dt</span> <span>=</span> <span>T</span> <span>/</span> <span>N</span>
<span>t</span> <span>=</span> <span>np</span><span>.</span><span>linspace</span><span>(</span><span>0</span><span>,</span> <span>T</span><span>,</span> <span>N</span><span>+</span><span>1</span><span>)</span>
<span>mu</span><span>,</span> <span>sigma</span> <span>=</span> <span>1.0</span><span>,</span> <span>0.5</span>
<span>X</span> <span>=</span> <span>np</span><span>.</span><span>zeros</span><span>(</span><span>N</span><span>+</span><span>1</span><span>)</span>
<span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>N</span><span>):</span>
    <span>dW</span> <span>=</span> <span>np</span><span>.</span><span>sqrt</span><span>(</span><span>dt</span><span>)</span> <span>*</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>normal</span><span>(</span><span>0</span><span>,</span> <span>1</span><span>)</span>
    <span>X</span><span>[</span><span>i</span><span>+</span><span>1</span><span>]</span> <span>=</span> <span>X</span><span>[</span><span>i</span><span>]</span> <span>+</span> <span>mu</span> <span>*</span> <span>dt</span> <span>+</span> <span>sigma</span> <span>*</span> <span>dW</span>

<span>plt</span><span>.</span><span>plot</span><span>(</span><span>t</span><span>,</span> <span>X</span><span>,</span> <span>label</span><span>=</span><span>f</span><span>&#34;</span><span>μ=</span><span>{</span><span>mu</span><span>}</span><span>, σ=</span><span>{</span><span>sigma</span><span>}</span><span>&#34;</span><span>)</span>
<span>plt</span><span>.</span><span>title</span><span>(</span><span>&#34;</span><span>Sample Path of dX = μ dt + σ dW</span><span>&#34;</span><span>)</span>
<span>plt</span><span>.</span><span>xlabel</span><span>(</span><span>&#34;</span><span>Time t</span><span>&#34;</span><span>)</span>
<span>plt</span><span>.</span><span>ylabel</span><span>(</span><span>&#34;</span><span>X(t)</span><span>&#34;</span><span>)</span>
<span>plt</span><span>.</span><span>legend</span><span>()</span>
<span>plt</span><span>.</span><span>grid</span><span>(</span><span>True</span><span>)</span>
<span>plt</span><span>.</span><span>show</span><span>()</span>
</pre></td></tr></tbody></table></code></p></div><h3 id="b4-python-code-for-geometric-brownian-motion-simulation"><span><strong>B4. Python Code for Geometric Brownian Motion Simulation</strong></span><a href="#b4-python-code-for-geometric-brownian-motion-simulation"><i></i></a></h3><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td><pre><span>import</span> <span>numpy</span> <span>as</span> <span>np</span>
<span>import</span> <span>matplotlib.pyplot</span> <span>as</span> <span>plt</span>

<span># Simulate simple SDE: dX = mu dt + sigma dW
</span><span>np</span><span>.</span><span>random</span><span>.</span><span>seed</span><span>(</span><span>42</span><span>)</span>

<span># Simulate Geometric Brownian Motion (exact solution)
</span><span>T_gbm</span> <span>=</span> <span>10.0</span>  <span># Longer time to show exponential nature
</span><span>N_gbm</span> <span>=</span> <span>1000</span>
<span>t_gbm</span> <span>=</span> <span>np</span><span>.</span><span>linspace</span><span>(</span><span>0</span><span>,</span> <span>T_gbm</span><span>,</span> <span>N_gbm</span><span>+</span><span>1</span><span>)</span>
<span>S0</span> <span>=</span> <span>100.0</span>  <span># Initial stock price
</span><span>mu</span><span>,</span> <span>sigma</span> <span>=</span> <span>0.15</span><span>,</span> <span>0.2</span>  <span># Slightly larger for visibility
</span><span>S</span> <span>=</span> <span>S0</span> <span>*</span> <span>np</span><span>.</span><span>exp</span><span>((</span><span>mu</span> <span>-</span> <span>0.5</span> <span>*</span> <span>sigma</span><span>**</span><span>2</span><span>)</span> <span>*</span> <span>t_gbm</span> <span>+</span> <span>sigma</span> <span>*</span> <span>np</span><span>.</span><span>sqrt</span><span>(</span><span>t_gbm</span><span>)</span> <span>*</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>normal</span><span>(</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>N_gbm</span><span>+</span><span>1</span><span>))</span>

<span>plt</span><span>.</span><span>figure</span><span>(</span><span>figsize</span><span>=</span><span>(</span><span>8</span><span>,</span> <span>4</span><span>))</span>
<span>plt</span><span>.</span><span>plot</span><span>(</span><span>t_gbm</span><span>,</span> <span>S</span><span>,</span> <span>label</span><span>=</span><span>f</span><span>&#34;</span><span>μ=</span><span>{</span><span>mu</span><span>}</span><span>, σ=</span><span>{</span><span>sigma</span><span>}</span><span>&#34;</span><span>)</span>
<span>plt</span><span>.</span><span>title</span><span>(</span><span>&#34;</span><span>Sample Path: Geometric Brownian Motion</span><span>&#34;</span><span>)</span>
<span>plt</span><span>.</span><span>xlabel</span><span>(</span><span>&#34;</span><span>Time t</span><span>&#34;</span><span>)</span>
<span>plt</span><span>.</span><span>ylabel</span><span>(</span><span>&#34;</span><span>S(t)</span><span>&#34;</span><span>)</span>
<span>plt</span><span>.</span><span>legend</span><span>()</span>
<span>plt</span><span>.</span><span>grid</span><span>(</span><span>True</span><span>)</span>
<span>plt</span><span>.</span><span>savefig</span><span>(</span><span>&#34;</span><span>gbm_path.png</span><span>&#34;</span><span>,</span> <span>dpi</span><span>=</span><span>300</span><span>,</span> <span>bbox_inches</span><span>=</span><span>&#34;</span><span>tight</span><span>&#34;</span><span>)</span>
<span>plt</span><span>.</span><span>show</span><span>()</span>
</pre></td></tr></tbody></table></code></p></div><h3 id="b5-latex-code-for-tikz-diagram-of-paths-in-pascals-triangle"><span>B5. LaTeX Code for Tikz Diagram of Paths in Pascal’s Triangle</span><a href="#b5-latex-code-for-tikz-diagram-of-paths-in-pascals-triangle"><i></i></a></h3><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre></td><td><pre><span>\documentclass</span><span>{</span>standalone<span>}</span>
<span>\usepackage</span><span>{</span>tikz<span>}</span>
<span>\begin{document}</span>

<span>\begin{tikzpicture}</span>[scale=0.8]
    <span>% Add a white background rectangle</span>
  <span>\fill</span><span>[white]</span> (-12, 1) rectangle (10, -5);
  
  <span>% Row labels (only once, to the left of the first diagram)</span>
  <span>\node</span><span>[align=right]</span> at (-11, 0) <span>{</span>Row 0<span>}</span>;
  <span>\node</span><span>[align=right]</span> at (-11, -1) <span>{</span>Row 1<span>}</span>;
  <span>\node</span><span>[align=right]</span> at (-11, -2) <span>{</span>Row 2<span>}</span>;
  <span>\node</span><span>[align=right]</span> at (-11, -3) <span>{</span>Row 3<span>}</span>;

  <span>% Diagram 1: Path RRL</span>
  <span>\node</span> at (-6, 0) <span>{</span>1<span>}</span>; <span>% Row 0</span>
  <span>\node</span> at (-7, -1) <span>{</span>1<span>}</span>; <span>% Row 1</span>
  <span>\node</span> at (-5, -1) <span>{</span>1<span>}</span>;
  <span>\node</span> at (-8, -2) <span>{</span>1<span>}</span>; <span>% Row 2</span>
  <span>\node</span> at (-6, -2) <span>{</span>2<span>}</span>;
  <span>\node</span> at (-4, -2) <span>{</span>1<span>}</span>;
  <span>\node</span> at (-9, -3) <span>{</span>1<span>}</span>; <span>% Row 3</span>
  <span>\node</span> at (-7, -3) <span>{</span>3<span>}</span>;
  <span>\node</span> at (-5, -3) <span>{</span>3<span>}</span>;
  <span>\node</span> at (-3, -3) <span>{</span>1<span>}</span>;
  <span>\draw</span><span>[-&gt;, red, thick]</span> (-6, 0) -- (-5, -1) -- (-4, -2) -- (-5, -3); <span>% RRL</span>
  <span>\node</span> at (-6, -4) <span>{</span>Right-Right-Left<span>}</span>;

  <span>% Diagram 2: Path RLR</span>
  <span>\node</span> at (0, 0) <span>{</span>1<span>}</span>; <span>% Row 0</span>
  <span>\node</span> at (-1, -1) <span>{</span>1<span>}</span>; <span>% Row 1</span>
  <span>\node</span> at (1, -1) <span>{</span>1<span>}</span>;
  <span>\node</span> at (-2, -2) <span>{</span>1<span>}</span>; <span>% Row 2</span>
  <span>\node</span> at (0, -2) <span>{</span>2<span>}</span>;
  <span>\node</span> at (2, -2) <span>{</span>1<span>}</span>;
  <span>\node</span> at (-3, -3) <span>{</span>1<span>}</span>; <span>% Row 3</span>
  <span>\node</span> at (-1, -3) <span>{</span>3<span>}</span>;
  <span>\node</span> at (1, -3) <span>{</span>3<span>}</span>;
  <span>\node</span> at (3, -3) <span>{</span>1<span>}</span>;
  <span>\draw</span><span>[-&gt;, blue, thick]</span> (0, 0) -- (1, -1) -- (0, -2) -- (1, -3); <span>% RLR</span>
  <span>\node</span> at (0, -4) <span>{</span>Right-Left-Right<span>}</span>;

  <span>% Diagram 3: Path LRR</span>
  <span>\node</span> at (6, 0) <span>{</span>1<span>}</span>; <span>% Row 0</span>
  <span>\node</span> at (5, -1) <span>{</span>1<span>}</span>; <span>% Row 1</span>
  <span>\node</span> at (7, -1) <span>{</span>1<span>}</span>;
  <span>\node</span> at (4, -2) <span>{</span>1<span>}</span>; <span>% Row 2</span>
  <span>\node</span> at (6, -2) <span>{</span>2<span>}</span>;
  <span>\node</span> at (8, -2) <span>{</span>1<span>}</span>;
  <span>\node</span> at (3, -3) <span>{</span>1<span>}</span>; <span>% Row 3</span>
  <span>\node</span> at (5, -3) <span>{</span>3<span>}</span>;
  <span>\node</span> at (7, -3) <span>{</span>3<span>}</span>;
  <span>\node</span> at (9, -3) <span>{</span>1<span>}</span>;
  <span>\draw</span><span>[-&gt;, green, thick]</span> (6, 0) -- (5, -1) -- (6, -2) -- (7, -3); <span>% LRR</span>
  <span>\node</span> at (6, -4) <span>{</span>Left-Right-Right<span>}</span>;
<span>\end{tikzpicture}</span>

<span>\end{document}</span>
</pre></td></tr></tbody></table></code></p></div><h3 id="3d-visualizations"><span>3D Visualizations</span><a href="#3d-visualizations"><i></i></a></h3><h4 id="c1-3d-plot-of-discrete-random-walks"><span>C1. 3D Plot of Discrete Random Walks</span><a href="#c1-3d-plot-of-discrete-random-walks"><i></i></a></h4><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
</pre></td><td><pre><span>import</span> <span>numpy</span> <span>as</span> <span>np</span>
<span>import</span> <span>matplotlib.pyplot</span> <span>as</span> <span>plt</span>
<span>from</span> <span>mpl_toolkits.mplot3d</span> <span>import</span> <span>Axes3D</span>  <span># for 3D plotting
</span><span>import</span> <span>imageio.v3</span> <span>as</span> <span>imageio</span>  <span># using modern imageio v3 API
</span><span>import</span> <span>os</span>
<span>from</span> <span>scipy.special</span> <span>import</span> <span>comb</span>
<span>from</span> <span>scipy.stats</span> <span>import</span> <span>norm</span>

<span># Create a directory for frames
</span><span>os</span><span>.</span><span>makedirs</span><span>(</span><span>&#39;</span><span>gif_frames</span><span>&#39;</span><span>,</span> <span>exist_ok</span><span>=</span><span>True</span><span>)</span>

<span>##############################################
# Part 1: Discrete Binomial Random Walk (N = 15)
##############################################
</span>
<span>N</span> <span>=</span> <span>15</span>  <span># total number of steps (kept small for clear discreteness)
</span><span>num_sample_paths</span> <span>=</span> <span>5</span>  <span># number of sample paths to overlay
</span>
<span># Simulate a few discrete random walk sample paths
</span><span>sample_paths</span> <span>=</span> <span>[]</span>
<span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>num_sample_paths</span><span>):</span>
    <span>steps</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>choice</span><span>([</span><span>-</span><span>1</span><span>,</span> <span>1</span><span>],</span> <span>size</span><span>=</span><span>N</span><span>)</span>
    <span>path</span> <span>=</span> <span>np</span><span>.</span><span>concatenate</span><span>(([</span><span>0</span><span>],</span> <span>np</span><span>.</span><span>cumsum</span><span>(</span><span>steps</span><span>)))</span>
    <span>sample_paths</span><span>.</span><span>append</span><span>(</span><span>path</span><span>)</span>
<span>sample_paths</span> <span>=</span> <span>np</span><span>.</span><span>array</span><span>(</span><span>sample_paths</span><span>)</span>  <span># shape: (num_sample_paths, N+1)
</span>
<span>frames</span> <span>=</span> <span>[]</span>
<span>for</span> <span>t_step</span> <span>in</span> <span>range</span><span>(</span><span>N</span> <span>+</span> <span>1</span><span>):</span>
    <span>fig</span> <span>=</span> <span>plt</span><span>.</span><span>figure</span><span>(</span><span>figsize</span><span>=</span><span>(</span><span>10</span><span>,</span> <span>7</span><span>))</span>
    <span>ax</span> <span>=</span> <span>fig</span><span>.</span><span>add_subplot</span><span>(</span><span>111</span><span>,</span> <span>projection</span><span>=</span><span>&#39;</span><span>3d</span><span>&#39;</span><span>)</span>
    
    <span># For each discrete time slice up to the current time, plot the PMF
</span>    <span>for</span> <span>t</span> <span>in</span> <span>range</span><span>(</span><span>t_step</span> <span>+</span> <span>1</span><span>):</span>
        <span># For a random walk starting at 0, possible positions are -t, -t+2, ..., t
</span>        <span>x_values</span> <span>=</span> <span>np</span><span>.</span><span>arange</span><span>(</span><span>-</span><span>t</span><span>,</span> <span>t</span> <span>+</span> <span>1</span><span>,</span> <span>2</span><span>)</span>
        <span>if</span> <span>t</span> <span>==</span> <span>0</span><span>:</span>
            <span>p_values</span> <span>=</span> <span>np</span><span>.</span><span>array</span><span>([</span><span>1.0</span><span>])</span>
        <span>else</span><span>:</span>
            <span># k = (x + t)/2 gives the number of +1 steps
</span>            <span>k</span> <span>=</span> <span>(</span><span>x_values</span> <span>+</span> <span>t</span><span>)</span> <span>//</span> <span>2</span>  
            <span>p_values</span> <span>=</span> <span>comb</span><span>(</span><span>t</span><span>,</span> <span>k</span><span>)</span> <span>*</span> <span>(</span><span>0.5</span> <span>**</span> <span>t</span><span>)</span>
        <span># Plot the discrete PMF as blue markers (and connect them with a line)
</span>        <span>ax</span><span>.</span><span>scatter</span><span>(</span><span>x_values</span><span>,</span> <span>[</span><span>t</span><span>]</span><span>*</span><span>len</span><span>(</span><span>x_values</span><span>),</span> <span>p_values</span><span>,</span> <span>color</span><span>=</span><span>&#39;</span><span>blue</span><span>&#39;</span><span>,</span> <span>s</span><span>=</span><span>50</span><span>)</span>
        <span>ax</span><span>.</span><span>plot</span><span>(</span><span>x_values</span><span>,</span> <span>[</span><span>t</span><span>]</span><span>*</span><span>len</span><span>(</span><span>x_values</span><span>),</span> <span>p_values</span><span>,</span> <span>color</span><span>=</span><span>&#39;</span><span>blue</span><span>&#39;</span><span>,</span> <span>alpha</span><span>=</span><span>0.5</span><span>)</span>
    
    <span># Overlay the sample random walk paths (projected at z=0)
</span>    <span>for</span> <span>sp</span> <span>in</span> <span>sample_paths</span><span>:</span>
        <span>ax</span><span>.</span><span>plot</span><span>(</span><span>sp</span><span>[:</span><span>t_step</span> <span>+</span> <span>1</span><span>],</span> <span>np</span><span>.</span><span>arange</span><span>(</span><span>t_step</span> <span>+</span> <span>1</span><span>),</span> <span>np</span><span>.</span><span>zeros</span><span>(</span><span>t_step</span> <span>+</span> <span>1</span><span>),</span>
                <span>&#39;</span><span>r-o</span><span>&#39;</span><span>,</span> <span>markersize</span><span>=</span><span>5</span><span>,</span> <span>label</span><span>=</span><span>&#39;</span><span>Sample Path</span><span>&#39;</span> <span>if</span> <span>t_step</span> <span>==</span> <span>0</span> <span>else</span> <span>&#34;&#34;</span><span>)</span>
    
    <span>ax</span><span>.</span><span>set_xlabel</span><span>(</span><span>&#39;</span><span>Position (x)</span><span>&#39;</span><span>)</span>
    <span>ax</span><span>.</span><span>set_ylabel</span><span>(</span><span>&#39;</span><span>Time (steps)</span><span>&#39;</span><span>)</span>
    <span>ax</span><span>.</span><span>set_zlabel</span><span>(</span><span>&#39;</span><span>Probability</span><span>&#39;</span><span>)</span>
    <span>ax</span><span>.</span><span>set_title</span><span>(</span><span>f</span><span>&#39;</span><span>Discrete Binomial Random Walk: Step </span><span>{</span><span>t_step</span><span>}</span><span>&#39;</span><span>)</span>
    <span>ax</span><span>.</span><span>set_zlim</span><span>(</span><span>0</span><span>,</span> <span>1.0</span><span>)</span>
    <span>ax</span><span>.</span><span>view_init</span><span>(</span><span>elev</span><span>=</span><span>30</span><span>,</span> <span>azim</span><span>=-</span><span>60</span><span>)</span>
    
    <span>frame_path</span> <span>=</span> <span>f</span><span>&#39;</span><span>gif_frames/discrete_binomial_</span><span>{</span><span>t_step</span><span>:</span><span>02</span><span>d</span><span>}</span><span>.png</span><span>&#39;</span>
    <span>plt</span><span>.</span><span>savefig</span><span>(</span><span>frame_path</span><span>)</span>
    <span>plt</span><span>.</span><span>close</span><span>()</span>
    <span>frames</span><span>.</span><span>append</span><span>(</span><span>imageio</span><span>.</span><span>imread</span><span>(</span><span>frame_path</span><span>))</span>

<span># Compute per-frame durations: 0.25 sec for all frames except the last one (2 sec)
</span><span>durations</span> <span>=</span> <span>[</span><span>0.25</span><span>]</span> <span>*</span> <span>(</span><span>len</span><span>(</span><span>frames</span><span>)</span> <span>-</span> <span>1</span><span>)</span> <span>+</span> <span>[</span><span>2.0</span><span>]</span>

<span># Write the GIF with variable durations and infinite looping
</span><span>imageio</span><span>.</span><span>imwrite</span><span>(</span><span>&#39;</span><span>discrete_binomial.gif</span><span>&#39;</span><span>,</span> <span>frames</span><span>,</span> <span>duration</span><span>=</span><span>durations</span><span>,</span> <span>loop</span><span>=</span><span>0</span><span>)</span>

<span>##############################################
# Part 2: Discrete Random Walk Normalizing (N = 50)
##############################################
</span>
<span>N</span> <span>=</span> <span>50</span>  <span># total number of steps (increased to show gradual convergence)
</span><span>num_sample_paths</span> <span>=</span> <span>5</span>  <span># number of sample paths to overlay
</span>
<span># Simulate a few discrete random walk sample paths
</span><span>sample_paths</span> <span>=</span> <span>[]</span>
<span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>num_sample_paths</span><span>):</span>
    <span>steps</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>choice</span><span>([</span><span>-</span><span>1</span><span>,</span> <span>1</span><span>],</span> <span>size</span><span>=</span><span>N</span><span>)</span>
    <span>path</span> <span>=</span> <span>np</span><span>.</span><span>concatenate</span><span>(([</span><span>0</span><span>],</span> <span>np</span><span>.</span><span>cumsum</span><span>(</span><span>steps</span><span>)))</span>
    <span>sample_paths</span><span>.</span><span>append</span><span>(</span><span>path</span><span>)</span>
<span>sample_paths</span> <span>=</span> <span>np</span><span>.</span><span>array</span><span>(</span><span>sample_paths</span><span>)</span>  <span># shape: (num_sample_paths, N+1)
</span>
<span>frames</span> <span>=</span> <span>[]</span>
<span>for</span> <span>t_step</span> <span>in</span> <span>range</span><span>(</span><span>N</span> <span>+</span> <span>1</span><span>):</span>
    <span>fig</span> <span>=</span> <span>plt</span><span>.</span><span>figure</span><span>(</span><span>figsize</span><span>=</span><span>(</span><span>10</span><span>,</span> <span>7</span><span>))</span>
    <span>ax</span> <span>=</span> <span>fig</span><span>.</span><span>add_subplot</span><span>(</span><span>111</span><span>,</span> <span>projection</span><span>=</span><span>&#39;</span><span>3d</span><span>&#39;</span><span>)</span>
    
    <span># Plot the PMFs for all time slices from 0 to the current step
</span>    <span>for</span> <span>t</span> <span>in</span> <span>range</span><span>(</span><span>t_step</span> <span>+</span> <span>1</span><span>):</span>
        <span># For a random walk starting at 0, possible positions are -t, -t+2, ..., t
</span>        <span>x_values</span> <span>=</span> <span>np</span><span>.</span><span>arange</span><span>(</span><span>-</span><span>t</span><span>,</span> <span>t</span> <span>+</span> <span>1</span><span>,</span> <span>2</span><span>)</span>
        <span>if</span> <span>t</span> <span>==</span> <span>0</span><span>:</span>
            <span>p_values</span> <span>=</span> <span>np</span><span>.</span><span>array</span><span>([</span><span>1.0</span><span>])</span>
        <span>else</span><span>:</span>
            <span># For each x, number of +1 steps is (x+t)/2
</span>            <span>k</span> <span>=</span> <span>(</span><span>x_values</span> <span>+</span> <span>t</span><span>)</span> <span>//</span> <span>2</span>
            <span>p_values</span> <span>=</span> <span>comb</span><span>(</span><span>t</span><span>,</span> <span>k</span><span>)</span> <span>*</span> <span>(</span><span>0.5</span> <span>**</span> <span>t</span><span>)</span>
        
        <span># Plot the discrete PMF as blue markers and lines
</span>        <span>ax</span><span>.</span><span>scatter</span><span>(</span><span>x_values</span><span>,</span> <span>[</span><span>t</span><span>]</span><span>*</span><span>len</span><span>(</span><span>x_values</span><span>),</span> <span>p_values</span><span>,</span> <span>color</span><span>=</span><span>&#39;</span><span>blue</span><span>&#39;</span><span>,</span> <span>s</span><span>=</span><span>50</span><span>)</span>
        <span>ax</span><span>.</span><span>plot</span><span>(</span><span>x_values</span><span>,</span> <span>[</span><span>t</span><span>]</span><span>*</span><span>len</span><span>(</span><span>x_values</span><span>),</span> <span>p_values</span><span>,</span> <span>color</span><span>=</span><span>&#39;</span><span>blue</span><span>&#39;</span><span>,</span> <span>alpha</span><span>=</span><span>0.5</span><span>)</span>
        
        <span># For the current time slice, overlay the normal approximation in red
</span>        <span>if</span> <span>t</span> <span>==</span> <span>t_step</span> <span>and</span> <span>t</span> <span>&gt;</span> <span>0</span><span>:</span>
            <span>x_cont</span> <span>=</span> <span>np</span><span>.</span><span>linspace</span><span>(</span><span>-</span><span>t</span><span>,</span> <span>t</span><span>,</span> <span>200</span><span>)</span>
            <span>normal_pdf</span> <span>=</span> <span>norm</span><span>.</span><span>pdf</span><span>(</span><span>x_cont</span><span>,</span> <span>0</span><span>,</span> <span>np</span><span>.</span><span>sqrt</span><span>(</span><span>t</span><span>))</span>
            <span>ax</span><span>.</span><span>plot</span><span>(</span><span>x_cont</span><span>,</span> <span>[</span><span>t</span><span>]</span><span>*</span><span>len</span><span>(</span><span>x_cont</span><span>),</span> <span>normal_pdf</span><span>,</span> <span>&#39;</span><span>r-</span><span>&#39;</span><span>,</span> <span>linewidth</span><span>=</span><span>2</span><span>,</span> <span>label</span><span>=</span><span>&#39;</span><span>Normal Approx.</span><span>&#39;</span><span>)</span>
    
    <span># Overlay the sample random walk paths (projected along the z=0 plane)
</span>    <span>for</span> <span>sp</span> <span>in</span> <span>sample_paths</span><span>:</span>
        <span>ax</span><span>.</span><span>plot</span><span>(</span><span>sp</span><span>[:</span><span>t_step</span> <span>+</span> <span>1</span><span>],</span> <span>np</span><span>.</span><span>arange</span><span>(</span><span>t_step</span> <span>+</span> <span>1</span><span>),</span> <span>np</span><span>.</span><span>zeros</span><span>(</span><span>t_step</span> <span>+</span> <span>1</span><span>),</span>
                <span>&#39;</span><span>g-o</span><span>&#39;</span><span>,</span> <span>markersize</span><span>=</span><span>5</span><span>,</span> <span>label</span><span>=</span><span>&#39;</span><span>Sample Path</span><span>&#39;</span> <span>if</span> <span>t_step</span> <span>==</span> <span>0</span> <span>else</span> <span>&#34;&#34;</span><span>)</span>
    
    <span>ax</span><span>.</span><span>set_xlabel</span><span>(</span><span>&#39;</span><span>Position (x)</span><span>&#39;</span><span>)</span>
    <span>ax</span><span>.</span><span>set_ylabel</span><span>(</span><span>&#39;</span><span>Time (steps)</span><span>&#39;</span><span>)</span>
    <span>ax</span><span>.</span><span>set_zlabel</span><span>(</span><span>&#39;</span><span>Probability</span><span>&#39;</span><span>)</span>
    <span>ax</span><span>.</span><span>set_title</span><span>(</span><span>f</span><span>&#39;</span><span>Discrete Binomial Random Walk at Step </span><span>{</span><span>t_step</span><span>}</span><span>&#39;</span><span>)</span>
    <span>ax</span><span>.</span><span>set_zlim</span><span>(</span><span>0</span><span>,</span> <span>1.0</span><span>)</span>
    <span>ax</span><span>.</span><span>view_init</span><span>(</span><span>elev</span><span>=</span><span>30</span><span>,</span> <span>azim</span><span>=-</span><span>60</span><span>)</span>
    
    <span>frame_path</span> <span>=</span> <span>f</span><span>&#39;</span><span>gif_frames/discrete_binomial_</span><span>{</span><span>t_step</span><span>:</span><span>02</span><span>d</span><span>}</span><span>.png</span><span>&#39;</span>
    <span>plt</span><span>.</span><span>savefig</span><span>(</span><span>frame_path</span><span>)</span>
    <span>plt</span><span>.</span><span>close</span><span>()</span>
    <span>frames</span><span>.</span><span>append</span><span>(</span><span>imageio</span><span>.</span><span>imread</span><span>(</span><span>frame_path</span><span>))</span>

<span># Compute per-frame durations: 0.25 sec for all frames except the last one (2 sec)
</span><span>durations</span> <span>=</span> <span>[</span><span>0.25</span><span>]</span> <span>*</span> <span>(</span><span>len</span><span>(</span><span>frames</span><span>)</span> <span>-</span> <span>1</span><span>)</span> <span>+</span> <span>[</span><span>2.0</span><span>]</span>

<span># Write the GIF with variable durations and infinite looping
</span><span>imageio</span><span>.</span><span>imwrite</span><span>(</span><span>&#39;</span><span>discrete_binomial_normalizing.gif</span><span>&#39;</span><span>,</span> <span>frames</span><span>,</span> <span>duration</span><span>=</span><span>durations</span><span>,</span> <span>loop</span><span>=</span><span>0</span><span>)</span>
</pre></td></tr></tbody></table></code></p></div><h3 id="c2-3d-animation-of-brownian-motion"><span>C2. 3D Animation of Brownian Motion</span><a href="#c2-3d-animation-of-brownian-motion"><i></i></a></h3><p>Normal distribution sweeping and evolving across time according Brownian motion</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td><td><pre><span>import</span> <span>numpy</span> <span>as</span> <span>np</span>
<span>import</span> <span>matplotlib.pyplot</span> <span>as</span> <span>plt</span>
<span>from</span> <span>mpl_toolkits.mplot3d</span> <span>import</span> <span>Axes3D</span>  <span># for 3D plotting
</span><span>from</span> <span>scipy.stats</span> <span>import</span> <span>norm</span>
<span>import</span> <span>imageio.v3</span> <span>as</span> <span>imageio</span>  <span># using modern API
</span><span>import</span> <span>os</span>

<span>os</span><span>.</span><span>makedirs</span><span>(</span><span>&#39;</span><span>gif_frames</span><span>&#39;</span><span>,</span> <span>exist_ok</span><span>=</span><span>True</span><span>)</span>

<span># Parameters for continuous Brownian motion
</span><span>num_frames</span> <span>=</span> <span>100</span>  <span># more frames for smoother animation
</span><span>t_values</span> <span>=</span> <span>np</span><span>.</span><span>linspace</span><span>(</span><span>0.1</span><span>,</span> <span>5</span><span>,</span> <span>num_frames</span><span>)</span>
<span>x</span> <span>=</span> <span>np</span><span>.</span><span>linspace</span><span>(</span><span>-</span><span>5</span><span>,</span> <span>5</span><span>,</span> <span>200</span><span>)</span>  <span># increased resolution
</span>
<span>num_sample_paths</span> <span>=</span> <span>5</span>
<span>sample_paths</span> <span>=</span> <span>np</span><span>.</span><span>zeros</span><span>((</span><span>num_sample_paths</span><span>,</span> <span>len</span><span>(</span><span>t_values</span><span>)))</span>
<span>dt_cont</span> <span>=</span> <span>t_values</span><span>[</span><span>1</span><span>]</span> <span>-</span> <span>t_values</span><span>[</span><span>0</span><span>]</span>
<span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>num_sample_paths</span><span>):</span>
    <span>increments</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>normal</span><span>(</span><span>0</span><span>,</span> <span>np</span><span>.</span><span>sqrt</span><span>(</span><span>dt_cont</span><span>),</span> <span>size</span><span>=</span><span>len</span><span>(</span><span>t_values</span><span>)</span><span>-</span><span>1</span><span>)</span>
    <span>sample_paths</span><span>[</span><span>i</span><span>,</span> <span>1</span><span>:]</span> <span>=</span> <span>np</span><span>.</span><span>cumsum</span><span>(</span><span>increments</span><span>)</span>

<span>frames</span> <span>=</span> <span>[]</span>
<span>for</span> <span>i</span><span>,</span> <span>t</span> <span>in</span> <span>enumerate</span><span>(</span><span>t_values</span><span>):</span>
    <span>fig</span> <span>=</span> <span>plt</span><span>.</span><span>figure</span><span>(</span><span>figsize</span><span>=</span><span>(</span><span>10</span><span>,</span> <span>7</span><span>))</span>
    <span>ax</span> <span>=</span> <span>fig</span><span>.</span><span>add_subplot</span><span>(</span><span>111</span><span>,</span> <span>projection</span><span>=</span><span>&#39;</span><span>3d</span><span>&#39;</span><span>)</span>
    
    <span>mask</span> <span>=</span> <span>t_values</span> <span>&lt;=</span> <span>t</span>
    <span>T_sub</span><span>,</span> <span>X_sub</span> <span>=</span> <span>np</span><span>.</span><span>meshgrid</span><span>(</span><span>t_values</span><span>[</span><span>mask</span><span>],</span> <span>x</span><span>)</span>
    <span>P_sub</span> <span>=</span> <span>(</span><span>1</span> <span>/</span> <span>np</span><span>.</span><span>sqrt</span><span>(</span><span>2</span> <span>*</span> <span>np</span><span>.</span><span>pi</span> <span>*</span> <span>T_sub</span><span>))</span> <span>*</span> <span>np</span><span>.</span><span>exp</span><span>(</span><span>-</span><span>X_sub</span><span>**</span><span>2</span> <span>/</span> <span>(</span><span>2</span> <span>*</span> <span>T_sub</span><span>))</span>
    <span>ax</span><span>.</span><span>plot_surface</span><span>(</span><span>X_sub</span><span>,</span> <span>T_sub</span><span>,</span> <span>P_sub</span><span>,</span> <span>cmap</span><span>=</span><span>&#39;</span><span>viridis</span><span>&#39;</span><span>,</span> <span>alpha</span><span>=</span><span>0.7</span><span>,</span> <span>edgecolor</span><span>=</span><span>&#39;</span><span>none</span><span>&#39;</span><span>)</span>
    
    <span>for</span> <span>sp</span> <span>in</span> <span>sample_paths</span><span>:</span>
        <span>ax</span><span>.</span><span>plot</span><span>(</span><span>sp</span><span>[:</span><span>i</span><span>+</span><span>1</span><span>],</span> <span>t_values</span><span>[:</span><span>i</span><span>+</span><span>1</span><span>],</span> <span>np</span><span>.</span><span>zeros</span><span>(</span><span>i</span><span>+</span><span>1</span><span>),</span> <span>&#39;</span><span>r-</span><span>&#39;</span><span>,</span> <span>marker</span><span>=</span><span>&#39;</span><span>o</span><span>&#39;</span><span>,</span> <span>markersize</span><span>=</span><span>3</span><span>)</span>
    
    <span>ax</span><span>.</span><span>set_xlabel</span><span>(</span><span>&#39;</span><span>Position (x)</span><span>&#39;</span><span>)</span>
    <span>ax</span><span>.</span><span>set_ylabel</span><span>(</span><span>&#39;</span><span>Time (t)</span><span>&#39;</span><span>)</span>
    <span>ax</span><span>.</span><span>set_zlabel</span><span>(</span><span>&#39;</span><span>Density</span><span>&#39;</span><span>)</span>
    <span>ax</span><span>.</span><span>set_title</span><span>(</span><span>f</span><span>&#39;</span><span>Continuous Brownian Motion at t = </span><span>{</span><span>t</span><span>:</span><span>.</span><span>2</span><span>f</span><span>}</span><span>&#39;</span><span>)</span>
    <span>ax</span><span>.</span><span>view_init</span><span>(</span><span>elev</span><span>=</span><span>30</span><span>,</span> <span>azim</span><span>=-</span><span>60</span><span>)</span>
    
    <span>frame_path</span> <span>=</span> <span>f</span><span>&#39;</span><span>gif_frames/continuous_3d_smooth_t_</span><span>{</span><span>t</span><span>:</span><span>.</span><span>2</span><span>f</span><span>}</span><span>.png</span><span>&#39;</span>
    <span>plt</span><span>.</span><span>savefig</span><span>(</span><span>frame_path</span><span>)</span>
    <span>plt</span><span>.</span><span>close</span><span>()</span>
    <span>frames</span><span>.</span><span>append</span><span>(</span><span>imageio</span><span>.</span><span>imread</span><span>(</span><span>frame_path</span><span>))</span>

<span>imageio</span><span>.</span><span>imwrite</span><span>(</span><span>&#39;</span><span>continuous_brownian_3d_smooth.gif</span><span>&#39;</span><span>,</span> <span>frames</span><span>,</span> <span>duration</span><span>=</span><span>0.1</span><span>)</span>
</pre></td></tr></tbody></table></code></p></div><h3 id="c3-3d-animation-of-geometric-brownian-motion"><span>C3. 3D Animation of Geometric Brownian Motion</span><a href="#c3-3d-animation-of-geometric-brownian-motion"><i></i></a></h3><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre></td><td><pre><span>import</span> <span>numpy</span> <span>as</span> <span>np</span>
<span>import</span> <span>matplotlib.pyplot</span> <span>as</span> <span>plt</span>
<span>from</span> <span>mpl_toolkits.mplot3d</span> <span>import</span> <span>Axes3D</span>  <span># for 3D plotting
</span><span>import</span> <span>imageio.v3</span> <span>as</span> <span>imageio</span>  <span># modern API
</span><span>import</span> <span>os</span>

<span>os</span><span>.</span><span>makedirs</span><span>(</span><span>&#39;</span><span>gif_frames</span><span>&#39;</span><span>,</span> <span>exist_ok</span><span>=</span><span>True</span><span>)</span>

<span># Parameters for geometric Brownian motion (GBM)
</span><span>S0</span> <span>=</span> <span>1.0</span>    <span># initial stock price
</span><span>mu</span> <span>=</span> <span>0.2</span>    <span># drift rate (increased for noticeable drift)
</span><span>sigma</span> <span>=</span> <span>0.2</span> <span># volatility
</span>
<span>num_frames</span> <span>=</span> <span>100</span>
<span>t_values</span> <span>=</span> <span>np</span><span>.</span><span>linspace</span><span>(</span><span>0.1</span><span>,</span> <span>5</span><span>,</span> <span>num_frames</span><span>)</span>  <span># avoid t=0 to prevent singularity in density
</span><span>S_range</span> <span>=</span> <span>np</span><span>.</span><span>linspace</span><span>(</span><span>0.01</span><span>,</span> <span>5</span><span>,</span> <span>200</span><span>)</span>         <span># price range
</span>
<span># Simulate GBM sample paths
</span><span>num_sample_paths</span> <span>=</span> <span>5</span>
<span>sample_paths</span> <span>=</span> <span>np</span><span>.</span><span>zeros</span><span>((</span><span>num_sample_paths</span><span>,</span> <span>len</span><span>(</span><span>t_values</span><span>)))</span>
<span>dt</span> <span>=</span> <span>t_values</span><span>[</span><span>1</span><span>]</span> <span>-</span> <span>t_values</span><span>[</span><span>0</span><span>]</span>
<span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>num_sample_paths</span><span>):</span>
    <span>increments</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>normal</span><span>(</span><span>0</span><span>,</span> <span>np</span><span>.</span><span>sqrt</span><span>(</span><span>dt</span><span>),</span> <span>size</span><span>=</span><span>len</span><span>(</span><span>t_values</span><span>)</span><span>-</span><span>1</span><span>)</span>
    <span>W</span> <span>=</span> <span>np</span><span>.</span><span>concatenate</span><span>(([</span><span>0</span><span>],</span> <span>np</span><span>.</span><span>cumsum</span><span>(</span><span>increments</span><span>)))</span>
    <span>sample_paths</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>S0</span> <span>*</span> <span>np</span><span>.</span><span>exp</span><span>((</span><span>mu</span> <span>-</span> <span>0.5</span> <span>*</span> <span>sigma</span><span>**</span><span>2</span><span>)</span> <span>*</span> <span>t_values</span> <span>+</span> <span>sigma</span> <span>*</span> <span>W</span><span>)</span>

<span>frames</span> <span>=</span> <span>[]</span>
<span>for</span> <span>i</span><span>,</span> <span>t</span> <span>in</span> <span>enumerate</span><span>(</span><span>t_values</span><span>):</span>
    <span>fig</span> <span>=</span> <span>plt</span><span>.</span><span>figure</span><span>(</span><span>figsize</span><span>=</span><span>(</span><span>10</span><span>,</span> <span>7</span><span>))</span>
    <span>ax</span> <span>=</span> <span>fig</span><span>.</span><span>add_subplot</span><span>(</span><span>111</span><span>,</span> <span>projection</span><span>=</span><span>&#39;</span><span>3d</span><span>&#39;</span><span>)</span>
    
    <span>mask</span> <span>=</span> <span>t_values</span> <span>&lt;=</span> <span>t</span>
    <span>T_sub</span><span>,</span> <span>S_sub</span> <span>=</span> <span>np</span><span>.</span><span>meshgrid</span><span>(</span><span>t_values</span><span>[</span><span>mask</span><span>],</span> <span>S_range</span><span>)</span>
    <span>P_sub</span> <span>=</span> <span>(</span><span>1</span> <span>/</span> <span>(</span><span>S_sub</span> <span>*</span> <span>sigma</span> <span>*</span> <span>np</span><span>.</span><span>sqrt</span><span>(</span><span>2</span> <span>*</span> <span>np</span><span>.</span><span>pi</span> <span>*</span> <span>T_sub</span><span>)))</span> <span>*</span> \
            <span>np</span><span>.</span><span>exp</span><span>(</span><span>-</span> <span>(</span><span>np</span><span>.</span><span>log</span><span>(</span><span>S_sub</span> <span>/</span> <span>S0</span><span>)</span> <span>-</span> <span>(</span><span>mu</span> <span>-</span> <span>0.5</span> <span>*</span> <span>sigma</span><span>**</span><span>2</span><span>)</span> <span>*</span> <span>T_sub</span><span>)</span><span>**</span><span>2</span> <span>/</span> <span>(</span><span>2</span> <span>*</span> <span>sigma</span><span>**</span><span>2</span> <span>*</span> <span>T_sub</span><span>))</span>
    <span>ax</span><span>.</span><span>plot_surface</span><span>(</span><span>S_sub</span><span>,</span> <span>T_sub</span><span>,</span> <span>P_sub</span><span>,</span> <span>cmap</span><span>=</span><span>&#39;</span><span>viridis</span><span>&#39;</span><span>,</span> <span>alpha</span><span>=</span><span>0.7</span><span>,</span> <span>edgecolor</span><span>=</span><span>&#39;</span><span>none</span><span>&#39;</span><span>)</span>
    
    <span>for</span> <span>sp</span> <span>in</span> <span>sample_paths</span><span>:</span>
        <span>ax</span><span>.</span><span>plot</span><span>(</span><span>sp</span><span>[:</span><span>i</span><span>+</span><span>1</span><span>],</span> <span>t_values</span><span>[:</span><span>i</span><span>+</span><span>1</span><span>],</span> <span>np</span><span>.</span><span>zeros</span><span>(</span><span>i</span><span>+</span><span>1</span><span>),</span> <span>&#39;</span><span>r-</span><span>&#39;</span><span>,</span> <span>marker</span><span>=</span><span>&#39;</span><span>o</span><span>&#39;</span><span>,</span> <span>markersize</span><span>=</span><span>3</span><span>)</span>
    
    <span>ax</span><span>.</span><span>set_xlabel</span><span>(</span><span>&#39;</span><span>Stock Price S</span><span>&#39;</span><span>)</span>
    <span>ax</span><span>.</span><span>set_ylabel</span><span>(</span><span>&#39;</span><span>Time t</span><span>&#39;</span><span>)</span>
    <span>ax</span><span>.</span><span>set_zlabel</span><span>(</span><span>&#39;</span><span>Density</span><span>&#39;</span><span>)</span>
    <span>ax</span><span>.</span><span>set_title</span><span>(</span><span>f</span><span>&#39;</span><span>Geometric Brownian Motion at t = </span><span>{</span><span>t</span><span>:</span><span>.</span><span>2</span><span>f</span><span>}</span><span>&#39;</span><span>)</span>
    <span>ax</span><span>.</span><span>view_init</span><span>(</span><span>elev</span><span>=</span><span>30</span><span>,</span> <span>azim</span><span>=-</span><span>60</span><span>)</span>
    
    <span>frame_path</span> <span>=</span> <span>f</span><span>&#39;</span><span>gif_frames/geometric_brownian_drifted_3d_t_</span><span>{</span><span>t</span><span>:</span><span>.</span><span>2</span><span>f</span><span>}</span><span>.png</span><span>&#39;</span>
    <span>plt</span><span>.</span><span>savefig</span><span>(</span><span>frame_path</span><span>)</span>
    <span>plt</span><span>.</span><span>close</span><span>()</span>
    <span>frames</span><span>.</span><span>append</span><span>(</span><span>imageio</span><span>.</span><span>imread</span><span>(</span><span>frame_path</span><span>))</span>

<span>imageio</span><span>.</span><span>imwrite</span><span>(</span><span>&#39;</span><span>geometric_brownian_drifted_3d.gif</span><span>&#39;</span><span>,</span> <span>frames</span><span>,</span> <span>duration</span><span>=</span><span>0.1</span><span>)</span>
</pre></td></tr></tbody></table></code></p></div><h3 id="c4-python-code-for-normal-distribution-approximation-by-random-walks"><span>C4. Python Code for Normal Distribution Approximation by Random Walks</span><a href="#c4-python-code-for-normal-distribution-approximation-by-random-walks"><i></i></a></h3><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
</pre></td><td><pre><span>import</span> <span>numpy</span> <span>as</span> <span>np</span>
<span>import</span> <span>matplotlib.pyplot</span> <span>as</span> <span>plt</span>
<span>from</span> <span>scipy.stats</span> <span>import</span> <span>norm</span>
<span>import</span> <span>imageio.v3</span> <span>as</span> <span>imageio</span>  <span># modern ImageIO v3 API
</span><span>import</span> <span>os</span>
<span>from</span> <span>scipy.special</span> <span>import</span> <span>comb</span>

<span># Create a directory for frames
</span><span>os</span><span>.</span><span>makedirs</span><span>(</span><span>&#39;</span><span>gif_frames</span><span>&#39;</span><span>,</span> <span>exist_ok</span><span>=</span><span>True</span><span>)</span>

<span># 1. Continuous Brownian Motion with Sample Paths
</span>
<span># Define time values and x range for density
</span><span>t_values</span> <span>=</span> <span>np</span><span>.</span><span>linspace</span><span>(</span><span>0.1</span><span>,</span> <span>5</span><span>,</span> <span>50</span><span>)</span>  <span># Times from 0.1 to 5
</span><span>x</span> <span>=</span> <span>np</span><span>.</span><span>linspace</span><span>(</span><span>-</span><span>5</span><span>,</span> <span>5</span><span>,</span> <span>100</span><span>)</span>          <span># Range of x values
</span>
<span># Simulate a few sample Brownian motion paths
</span><span>num_sample_paths</span> <span>=</span> <span>5</span>
<span>dt_cont</span> <span>=</span> <span>t_values</span><span>[</span><span>1</span><span>]</span> <span>-</span> <span>t_values</span><span>[</span><span>0</span><span>]</span>  <span># constant time step (~0.1)
</span><span>sample_paths</span> <span>=</span> <span>np</span><span>.</span><span>zeros</span><span>((</span><span>num_sample_paths</span><span>,</span> <span>len</span><span>(</span><span>t_values</span><span>)))</span>
<span>sample_paths</span><span>[:,</span> <span>0</span><span>]</span> <span>=</span> <span>0</span>
<span>increments</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>normal</span><span>(</span><span>0</span><span>,</span> <span>np</span><span>.</span><span>sqrt</span><span>(</span><span>dt_cont</span><span>),</span> <span>size</span><span>=</span><span>(</span><span>num_sample_paths</span><span>,</span> <span>len</span><span>(</span><span>t_values</span><span>)</span><span>-</span><span>1</span><span>))</span>
<span>sample_paths</span><span>[:,</span> <span>1</span><span>:]</span> <span>=</span> <span>np</span><span>.</span><span>cumsum</span><span>(</span><span>increments</span><span>,</span> <span>axis</span><span>=</span><span>1</span><span>)</span>

<span>frames</span> <span>=</span> <span>[]</span>
<span>for</span> <span>i</span><span>,</span> <span>t</span> <span>in</span> <span>enumerate</span><span>(</span><span>t_values</span><span>):</span>
    <span>p</span> <span>=</span> <span>(</span><span>1</span> <span>/</span> <span>np</span><span>.</span><span>sqrt</span><span>(</span><span>2</span> <span>*</span> <span>np</span><span>.</span><span>pi</span> <span>*</span> <span>t</span><span>))</span> <span>*</span> <span>np</span><span>.</span><span>exp</span><span>(</span><span>-</span><span>x</span><span>**</span><span>2</span> <span>/</span> <span>(</span><span>2</span> <span>*</span> <span>t</span><span>))</span>
    
    <span>plt</span><span>.</span><span>figure</span><span>(</span><span>figsize</span><span>=</span><span>(</span><span>12</span><span>,</span> <span>4</span><span>))</span>
    <span>plt</span><span>.</span><span>subplot</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>)</span>
    <span>plt</span><span>.</span><span>plot</span><span>(</span><span>x</span><span>,</span> <span>p</span><span>,</span> <span>&#39;</span><span>b-</span><span>&#39;</span><span>,</span> <span>label</span><span>=</span><span>f</span><span>&#39;</span><span>t = </span><span>{</span><span>t</span><span>:</span><span>.</span><span>2</span><span>f</span><span>}</span><span>&#39;</span><span>)</span>
    <span>plt</span><span>.</span><span>title</span><span>(</span><span>&#39;</span><span>Brownian Motion Distribution</span><span>&#39;</span><span>)</span>
    <span>plt</span><span>.</span><span>xlabel</span><span>(</span><span>&#39;</span><span>x</span><span>&#39;</span><span>)</span>
    <span>plt</span><span>.</span><span>ylabel</span><span>(</span><span>&#39;</span><span>Density p(x,t)</span><span>&#39;</span><span>)</span>
    <span>plt</span><span>.</span><span>ylim</span><span>(</span><span>0</span><span>,</span> <span>0.8</span><span>)</span>
    <span>plt</span><span>.</span><span>legend</span><span>()</span>
    <span>plt</span><span>.</span><span>grid</span><span>(</span><span>True</span><span>)</span>
    
    <span>plt</span><span>.</span><span>subplot</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>2</span><span>)</span>
    <span>for</span> <span>sp</span> <span>in</span> <span>sample_paths</span><span>:</span>
        <span>plt</span><span>.</span><span>plot</span><span>(</span><span>t_values</span><span>[:</span><span>i</span><span>+</span><span>1</span><span>],</span> <span>sp</span><span>[:</span><span>i</span><span>+</span><span>1</span><span>],</span> <span>&#39;</span><span>-o</span><span>&#39;</span><span>,</span> <span>markersize</span><span>=</span><span>3</span><span>)</span>
    <span>plt</span><span>.</span><span>title</span><span>(</span><span>&#39;</span><span>Sample Brownian Paths</span><span>&#39;</span><span>)</span>
    <span>plt</span><span>.</span><span>xlabel</span><span>(</span><span>&#39;</span><span>Time</span><span>&#39;</span><span>)</span>
    <span>plt</span><span>.</span><span>ylabel</span><span>(</span><span>&#39;</span><span>Position</span><span>&#39;</span><span>)</span>
    <span>plt</span><span>.</span><span>xlim</span><span>(</span><span>0</span><span>,</span> <span>5</span><span>)</span>
    <span>plt</span><span>.</span><span>grid</span><span>(</span><span>True</span><span>)</span>
    
    <span>frame_path</span> <span>=</span> <span>f</span><span>&#39;</span><span>gif_frames/continuous_t_</span><span>{</span><span>t</span><span>:</span><span>.</span><span>2</span><span>f</span><span>}</span><span>.png</span><span>&#39;</span>
    <span>plt</span><span>.</span><span>tight_layout</span><span>()</span>
    <span>plt</span><span>.</span><span>savefig</span><span>(</span><span>frame_path</span><span>)</span>
    <span>plt</span><span>.</span><span>close</span><span>()</span>
    <span>frames</span><span>.</span><span>append</span><span>(</span><span>imageio</span><span>.</span><span>imread</span><span>(</span><span>frame_path</span><span>))</span>

<span># Save the continuous Brownian motion GIF
# (duration in seconds per frame; adjust as desired)
</span><span>imageio</span><span>.</span><span>imwrite</span><span>(</span><span>&#39;</span><span>continuous_brownian.gif</span><span>&#39;</span><span>,</span> <span>frames</span><span>,</span> <span>duration</span><span>=</span><span>0.1</span><span>)</span>

<span># 2. Discrete Random Walk with Sample Paths
</span>
<span>def</span> <span>simulate_random_walk</span><span>(</span><span>dt</span><span>,</span> <span>T</span><span>,</span> <span>num_paths</span><span>):</span>
    <span>&#34;&#34;&#34;</span><span>Simulate random walk paths with step size sqrt(dt).</span><span>&#34;&#34;&#34;</span>
    <span>n_steps</span> <span>=</span> <span>int</span><span>(</span><span>T</span> <span>/</span> <span>dt</span><span>)</span>
    <span>positions</span> <span>=</span> <span>np</span><span>.</span><span>zeros</span><span>((</span><span>num_paths</span><span>,</span> <span>n_steps</span> <span>+</span> <span>1</span><span>))</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>num_paths</span><span>):</span>
        <span>increments</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>choice</span><span>([</span><span>-</span><span>1</span><span>,</span> <span>1</span><span>],</span> <span>size</span><span>=</span><span>n_steps</span><span>)</span> <span>*</span> <span>np</span><span>.</span><span>sqrt</span><span>(</span><span>dt</span><span>)</span>
        <span>positions</span><span>[</span><span>i</span><span>,</span> <span>1</span><span>:]</span> <span>=</span> <span>np</span><span>.</span><span>cumsum</span><span>(</span><span>increments</span><span>)</span>
    <span>return</span> <span>positions</span>

<span>dt</span> <span>=</span> <span>0.01</span>  <span># Step size
</span><span>T</span> <span>=</span> <span>5.0</span>    <span># Total time
</span><span>num_paths</span> <span>=</span> <span>10000</span>  <span># For histogram
</span><span>times</span> <span>=</span> <span>np</span><span>.</span><span>arange</span><span>(</span><span>0</span><span>,</span> <span>T</span> <span>+</span> <span>dt</span><span>,</span> <span>dt</span><span>)</span>
<span>positions</span> <span>=</span> <span>simulate_random_walk</span><span>(</span><span>dt</span><span>,</span> <span>T</span><span>,</span> <span>num_paths</span><span>)</span>
<span>sample_indices</span> <span>=</span> <span>np</span><span>.</span><span>arange</span><span>(</span><span>5</span><span>)</span>

<span>frames</span> <span>=</span> <span>[]</span>
<span>for</span> <span>i</span><span>,</span> <span>t</span> <span>in</span> <span>enumerate</span><span>(</span><span>times</span><span>):</span>
    <span>if</span> <span>i</span> <span>%</span> <span>10</span> <span>==</span> <span>0</span><span>:</span>  <span># Use every 10th frame for the GIF
</span>        <span>current_positions</span> <span>=</span> <span>positions</span><span>[:,</span> <span>i</span><span>]</span>
        <span>x_vals</span> <span>=</span> <span>np</span><span>.</span><span>linspace</span><span>(</span><span>-</span><span>5</span><span>,</span> <span>5</span><span>,</span> <span>100</span><span>)</span>
        <span>p_theoretical</span> <span>=</span> <span>norm</span><span>.</span><span>pdf</span><span>(</span><span>x_vals</span><span>,</span> <span>0</span><span>,</span> <span>np</span><span>.</span><span>sqrt</span><span>(</span><span>t</span><span>)</span> <span>if</span> <span>t</span> <span>&gt;</span> <span>0</span> <span>else</span> <span>1e-5</span><span>)</span>
        
        <span>plt</span><span>.</span><span>figure</span><span>(</span><span>figsize</span><span>=</span><span>(</span><span>12</span><span>,</span> <span>4</span><span>))</span>
        <span>plt</span><span>.</span><span>subplot</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>)</span>
        <span>plt</span><span>.</span><span>hist</span><span>(</span><span>current_positions</span><span>,</span> <span>bins</span><span>=</span><span>50</span><span>,</span> <span>density</span><span>=</span><span>True</span><span>,</span> <span>alpha</span><span>=</span><span>0.6</span><span>,</span> <span>label</span><span>=</span><span>f</span><span>&#39;</span><span>t = </span><span>{</span><span>t</span><span>:</span><span>.</span><span>2</span><span>f</span><span>}</span><span>&#39;</span><span>)</span>
        <span>plt</span><span>.</span><span>plot</span><span>(</span><span>x_vals</span><span>,</span> <span>p_theoretical</span><span>,</span> <span>&#39;</span><span>r-</span><span>&#39;</span><span>,</span> <span>label</span><span>=</span><span>&#39;</span><span>N(0,t)</span><span>&#39;</span><span>)</span>
        <span>plt</span><span>.</span><span>title</span><span>(</span><span>&#39;</span><span>Discrete Random Walk Distribution</span><span>&#39;</span><span>)</span>
        <span>plt</span><span>.</span><span>xlabel</span><span>(</span><span>&#39;</span><span>Position</span><span>&#39;</span><span>)</span>
        <span>plt</span><span>.</span><span>ylabel</span><span>(</span><span>&#39;</span><span>Density</span><span>&#39;</span><span>)</span>
        <span>plt</span><span>.</span><span>ylim</span><span>(</span><span>0</span><span>,</span> <span>0.8</span><span>)</span>
        <span>plt</span><span>.</span><span>legend</span><span>()</span>
        <span>plt</span><span>.</span><span>grid</span><span>(</span><span>True</span><span>)</span>
        
        <span>plt</span><span>.</span><span>subplot</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>2</span><span>)</span>
        <span>for</span> <span>idx</span> <span>in</span> <span>sample_indices</span><span>:</span>
            <span>plt</span><span>.</span><span>plot</span><span>(</span><span>times</span><span>[:</span><span>i</span><span>+</span><span>1</span><span>],</span> <span>positions</span><span>[</span><span>idx</span><span>,</span> <span>:</span><span>i</span><span>+</span><span>1</span><span>],</span> <span>&#39;</span><span>-o</span><span>&#39;</span><span>,</span> <span>markersize</span><span>=</span><span>3</span><span>)</span>
        <span>plt</span><span>.</span><span>title</span><span>(</span><span>&#39;</span><span>Sample Random Walk Paths</span><span>&#39;</span><span>)</span>
        <span>plt</span><span>.</span><span>xlabel</span><span>(</span><span>&#39;</span><span>Time</span><span>&#39;</span><span>)</span>
        <span>plt</span><span>.</span><span>ylabel</span><span>(</span><span>&#39;</span><span>Position</span><span>&#39;</span><span>)</span>
        <span>plt</span><span>.</span><span>xlim</span><span>(</span><span>0</span><span>,</span> <span>T</span><span>)</span>
        <span>plt</span><span>.</span><span>grid</span><span>(</span><span>True</span><span>)</span>
        
        <span>frame_path</span> <span>=</span> <span>f</span><span>&#39;</span><span>gif_frames/discrete_t_</span><span>{</span><span>t</span><span>:</span><span>.</span><span>2</span><span>f</span><span>}</span><span>.png</span><span>&#39;</span>
        <span>plt</span><span>.</span><span>tight_layout</span><span>()</span>
        <span>plt</span><span>.</span><span>savefig</span><span>(</span><span>frame_path</span><span>)</span>
        <span>plt</span><span>.</span><span>close</span><span>()</span>
        <span>frames</span><span>.</span><span>append</span><span>(</span><span>imageio</span><span>.</span><span>imread</span><span>(</span><span>frame_path</span><span>))</span>

<span># Save the discrete random walk GIF with infinite looping
</span><span>imageio</span><span>.</span><span>imwrite</span><span>(</span><span>&#39;</span><span>discrete_random_walk.gif</span><span>&#39;</span><span>,</span> <span>frames</span><span>,</span> <span>duration</span><span>=</span><span>0.1</span><span>,</span> <span>loop</span><span>=</span><span>0</span><span>)</span>
</pre></td></tr></tbody></table></code></p></div></div></div>
  </body>
</html>
