<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jvns.ca/blog/2022/11/06/making-a-dns-query-in-ruby-from-scratch/">Original</a>
    <h1>Making a DNS query in Ruby from scratch</h1>
    
    

<p>Hello! A while back I wrote a post about <a href="https://jvns.ca/blog/2022/02/01/a-dns-resolver-in-80-lines-of-go/">how to write a toy DNS resolver in Go</a>.</p>

<p>In that post I left out &ldquo;how to generate and parse DNS queries&rdquo; because I
thought it was boring, but a few people pointed out that they did not know how
to parse and generate DNS queries and they were interested in how to do it.</p>

<p>This made me curious &ndash; how much work <em>is</em> it do the DNS parsing? It turns out
we can do it in a pretty nice 120-line Ruby program, which is not that bad.</p>

<p>So here&rsquo;s a quick post on how to generate DNS queries and parse DNS responses!
We&rsquo;re going to do it in Ruby because I&rsquo;m giving a talk at a Ruby conference
soon, and this blog post is partly prep for that talk :). I&rsquo;ve tried to keep it
readable for folks who don&rsquo;t know Ruby though, I&rsquo;ve only used pretty basic Ruby
code.</p>

<p>At the end we&rsquo;re going to have a very simple toy Ruby version of <code>dig</code> that can
look up domain names like this:</p>

<pre><code>$ ruby dig.rb example.com
example.com	   20314    A    93.184.216.34
</code></pre>

<p>The whole thing is about 120 lines of code, so it&rsquo;s not <em>that</em> much.  (The
final program is
<a href="https://gist.github.com/jvns/1e5838a53520e45969687e2f90199770">dig.rb</a> if you want to skip the explanations and just read some code.)
We won&rsquo;t
implement the &ldquo;how a DNS resolver works&rdquo; from the previous post because, well,
we already did that. Let&rsquo;s get into it!</p>

<p>Along the way I&rsquo;m going to try to explain how you could figure out some of this
stuff yourself if you were trying to figure out how DNS queries are formatted from scratch. Mostly that&rsquo;s &ldquo;poke around in Wireshark&rdquo; and &ldquo;read RFC 1035, the DNS RFC&rdquo;.</p>

<h1 id="step-1-open-a-udp-socket">step 1: open a UDP socket</h1>

<p>We need to actually <em>send</em> our queries, so to do that we need to open a UDP
socket. We&rsquo;ll send our queries to <code>8.8.8.8</code>, Google&rsquo;s DNS server.</p>

<p>Here&rsquo;s the code to set up a UDP connection to <code>8.8.8.8</code>, port 53 (the DNS port).</p>

<pre><code>require 'socket'
sock = UDPSocket.new

sock.bind('0.0.0.0', 12345)
sock.connect('8.8.8.8', 53)
</code></pre>

<h3 id="a-quick-note-on-udp">a quick note on UDP</h3>

<p>I&rsquo;m not going to say too much about UDP here, but I will say that the basic
unit of computer networking is the &ldquo;packet&rdquo; (a packet is a string of bytes),
and in this program we&rsquo;re going to do the simplest possible thing you can do
with a computer network &ndash; send 1 packet and receive 1 packet in response.</p>

<p>So UDP is a way to send packets in the simplest possible way.</p>

<p>It&rsquo;s the most common way to send DNS queries, though you can also use TCP or
DNS-over-HTTPS instead.</p>

<h3 id="step-2-copy-a-dns-query-from-wireshark">step 2: copy a DNS query from Wireshark</h3>

<p>Next: let&rsquo;s say we have no idea how DNS works but we want to send a working
query as fast as possible. The easiest way to get a DNS query to play with and
make sure our UDP connection is working is to just copy one that already works!</p>

<p>So that&rsquo;s what we&rsquo;re going to do, using Wireshark (an incredible packet analysis tool)</p>

<p>The steps I used to this are roughly:</p>

<ol>
<li>Open Wireshark and click &lsquo;capture&rsquo;</li>
<li>Enter <code>udp.port == 53</code> as a filter (in the search bar)</li>
<li>Run <code>ping example.com</code> in my terminal (to generate a DNS query)</li>
<li>Click on the DNS query (&ldquo;Standard query A example.com&rdquo;)</li>
<li>Right click on &ldquo;Domain Name System (query&rdquo;) in the bottom left pane</li>
<li>Click &lsquo;Copy&rsquo; -&gt; &lsquo;as a hex stream&rsquo;</li>
<li>Now I have &ldquo;b96201000001000000000000076578616d706c6503636f6d0000010001&rdquo; on my clipboard, to use in my Ruby program. Hooray!</li>
</ol>

<h3 id="step-3-decode-the-hex-stream-and-send-the-dns-query">step 3: decode the hex stream and send the DNS query</h3>

<p>Now we can send our DNS query to <code>8.8.8.8</code>! Here&rsquo;s what that looks like: we just need to add 5 lines of code</p>

<pre><code>hex_string = &quot;b96201000001000000000000076578616d706c6503636f6d0000010001&quot;
bytes = [hex_string].pack('H*')
sock.send(bytes, 0)

# get the reply
reply, _ = sock.recvfrom(1024)
puts reply.unpack('H*')
</code></pre>

<p><code>[hex_string].pack('H*')</code> is translating our hex string into a byte string. At
this point we don&rsquo;t really know what this data <em>means</em> but we&rsquo;ll get there in a
second.</p>

<p>We can also take this opportunity to make sure our program is working and is sending valid data, using <code>tcpdump</code>. How I did that:</p>

<ol>
<li>Run <code>sudo tcpdump -ni any port 53 and host 8.8.8.8</code> in a terminal tab</li>
<li>In a different terminal tab, run <a href="https://gist.github.com/jvns/aa202b1edd97ae261715c806b2ba7d39">this Ruby program</a> (<code>ruby dns-1.rb</code>)</li>
</ol>

<p>Here&rsquo;s what the output looks like:</p>

<pre><code>$ sudo tcpdump -ni any port 53 and host 8.8.8.8
08:50:28.287440 IP 192.168.1.174.12345 &gt; 8.8.8.8.53: 47458+ A? example.com. (29)
08:50:28.312043 IP 8.8.8.8.53 &gt; 192.168.1.174.12345: 47458 1/0/0 A 93.184.216.34 (45)
</code></pre>

<p>This is really good - we can see the DNS request (&ldquo;what&rsquo;s the IP for
<code>example.com</code>&rdquo;) and the response (&ldquo;it&rsquo;s 93.184.216.34&rdquo;). So everything is
working. Now we just need to, you know, figure out how to generate and decode this data ourselves.</p>

<h3 id="step-4-learn-a-little-about-how-dns-queries-are-formatted">step 4: learn a little about how DNS queries are formatted</h3>

<p>Now that we have a DNS query for <code>example.com</code>, let&rsquo;s learn about what it means.</p>

<p>Here&rsquo;s our query, formatted as hex.</p>

<pre><code>b96201000001000000000000076578616d706c6503636f6d0000010001
</code></pre>

<p>If you poke around in Wireshark, you&rsquo;ll see that this query has 2 parts:</p>

<ul>
<li>The <strong>header</strong> (<code>b96201000001000000000000</code>)</li>
<li>The <strong>question</strong> (<code>076578616d706c6503636f6d0000010001</code>)</li>
</ul>

<h3 id="step-5-make-the-header">step 5: make the header</h3>

<p>Our goal in this step is to generate the byte string
<code>b96201000001000000000000</code>, but with a Ruby function instead of hardcoding it.</p>

<p>So: the header is 12 bytes. What do those 12 bytes mean? If you look at
Wireshark (or read <a href="https://datatracker.ietf.org/doc/html/rfc1035#section-4.1.1">RFC 1035</a>), you&rsquo;ll see
that it&rsquo;s 6 2-byte numbers concatenated together.</p>

<p>The 6 numbers correspond to the query ID, the flags, and then the number of
questions, answer records, authoritative records, and additional records in the
packet.</p>

<p>We don&rsquo;t need to worry about what all those things are yet though &ndash; we just need
to put in 6 numbers.</p>

<p>And luckily we know exactly which 6 numbers to put because our goal is to
literally generate the string <code>b96201000001000000000000</code>.</p>

<p>So here&rsquo;s a function to make the header. (note: there&rsquo;s no <code>return</code> because you don&rsquo;t need to write <code>return</code> in Ruby if it&rsquo;s the last line of the function)</p>

<pre><code class="language-ruby">def make_question_header(query_id)
  # id, flags, num questions, num answers, num auth, num additional
  [query_id, 0x0100, 0x0001, 0x0000, 0x0000, 0x0000].pack('nnnnnn')
end
</code></pre>

<p>This is very short because we&rsquo;ve hardcoded everything except the query ID.</p>

<h3 id="what-s-nnnnnn">what&rsquo;s <code>nnnnnn</code>?</h3>

<p>You might be wondering what <code>nnnnnn</code> is in <code>.pack('nnnnnn')</code>. That&rsquo;s a format
string telling <code>.pack()</code> how to convert that array of 6 numbers into a byte
string.</p>

<p><a href="https://ruby-doc.org/core-3.0.0/Array.html#method-i-pack">The documentation for <code>.pack</code> is here</a>, and it says that <code>n</code> means
&ldquo;represent it as &ldquo;16-bit unsigned, network (big-endian) byte order&rdquo;.</p>

<p>16 bits is the same as 2 bytes, and we need to use network byte order because
this is computer networking. I&rsquo;m not going to explain byte order right now
(though I do have a <a href="https://wizardzines.com/comics/little-endian/">comic attempting to explain
it</a>)</p>

<h3 id="test-the-header-code">test the header code</h3>

<p>Let&rsquo;s quickly test that our <code>make_question_header</code> function works.</p>

<pre><code>puts make_question_header(0xb962) == [&quot;b96201000001000000000000&quot;].pack(&quot;H*&quot;)
</code></pre>

<p>This prints out &ldquo;true&rdquo;, so we win and we can move on.</p>

<h3 id="step-5-encode-the-domain-name">step 5: encode the domain name</h3>

<p>Next we need to generate the <strong>question</strong> (&ldquo;what&rsquo;s the IP for <code>example.com</code>?&ldquo;). This has 3 parts:</p>

<ul>
<li>the <strong>domain name</strong> (for example &ldquo;example.com&rdquo;)</li>
<li>the <strong>query type</strong> (for example &ldquo;A&rdquo; is for &ldquo;IPv4 <strong>A</strong>ddress&rdquo;</li>
<li>the <strong>query class</strong> (which is always the same, 1 is for <strong>IN</strong> is for <strong>IN</strong>ternet)</li>
</ul>

<p>The hardest part of this is the domain name so let&rsquo;s write a function to do that.</p>

<p><code>example.com</code> is encoded in a DNS query, in hex, as <code>076578616d706c6503636f6d00</code>. What does that mean?</p>

<p>Well, if we translate the bytes into ASCII, it looks like this:</p>

<pre><code>076578616d706c6503636f6d00
 7 e x a m p l e 3 c o m 0
</code></pre>

<p>So each segment (like <code>example</code>) has its length (like 7) in front of it.</p>

<p>Here&rsquo;s the Ruby code to translate <code>example.com</code> into <code>7 e x a m p l e 3 c o m 0</code>:</p>

<pre><code>def encode_domain_name(domain)
  domain
    .split(&quot;.&quot;)
    .map { |x| x.length.chr + x }
    .join + &quot;\0&quot;
end
</code></pre>

<p>Other than that, to finish generating the question section we just need to
append the type and class onto the end of the domain name.</p>

<h3 id="step-6-write-make-dns-query">step 6: write <code>make_dns_query</code></h3>

<p>Here&rsquo;s the final function to make a DNS query:</p>

<pre><code>def make_dns_query(domain, type)
  query_id = rand(65535)
  header = make_question_header(query_id)
  question =  encode_domain_name(domain) + [type, 1].pack('nn')
  header + question
end
</code></pre>

<p><a href="https://gist.github.com/jvns/3587ea0b4a2a6c20dcfd8bf653fc11d9">Here&rsquo;s all the code we&rsquo;ve written before in <code>dns-2.rb</code></a> &ndash;
it&rsquo;s still only 29 lines.</p>

<h3 id="now-for-the-parsing">now for the parsing</h3>

<p>Now that we&rsquo;ve managed to <em>generate</em> a DNS query, we get into the hard part:
the parsing. Again, we&rsquo;ll split this into a bunch of different</p>

<ul>
<li>parse a DNS header</li>
<li>parse a DNS name</li>
<li>parse a DNS record</li>
</ul>

<p>The hardest part of this (maybe surprisingly) is going to be &ldquo;parse a DNS
name&rdquo;.</p>

<h3 id="step-7-parse-the-dns-header">step 7: parse the DNS header</h3>

<p>Let&rsquo;s start with the easiest part: the DNS header. We already talked about how
it&rsquo;s 6 numbers concatenated together.</p>

<p>So all we need to do is</p>

<ul>
<li>read the first 12 bytes</li>
<li>convert that into an array of 6 numbers</li>
<li>put those numbers in a class for convenience</li>
</ul>

<p>Here&rsquo;s the Ruby code to do that.</p>

<pre><code class="language-ruby">class DNSHeader
  attr_reader :id, :flags, :num_questions, :num_answers, :num_auth, :num_additional
  def initialize(buf)
    hdr = buf.read(12)
    @id, @flags, @num_questions, @num_answers, @num_auth, @num_additional = hdr.unpack('nnnnnn')
  end
end
</code></pre>

<p><small>
Quick Ruby note: <code>attr_reader</code> is a Ruby thing that means &ldquo;make these instance
variables accessible as methods&rdquo;. So you can call <code>header.flags</code> to look at the
<code>@flags</code> variable.
</small></p>

<p>We can call this with <code>DNSHeader(buf)</code>. Not so bad.</p>

<p>Let&rsquo;s move on to the hardest part: parsing a domain name.</p>

<h3 id="step-8-parse-a-domain-name">step 8: parse a domain name</h3>

<p>First, let&rsquo;s write a partial version.</p>

<pre><code>def read_domain_name_wrong(buf)
  domain = []
  loop do
    len = buf.read(1).unpack('C')[0]
    break if len == 0
    domain &lt;&lt; buf.read(len)
  end
  domain.join('.')
end
</code></pre>

<p>This repeatedly reads 1 byte and then reads that length into a string until the
length is 0.</p>

<p>This works great, for the first time we see a domain name (<code>example.com</code>) in our DNS response.</p>

<h3 id="trouble-with-domain-names-compression">trouble with domain names: compression!</h3>

<p>But the second time <code>example.com</code> appears, we run into trouble &ndash; in Wireshark,
it says that the domain is represented cryptically as just the 2 bytes <code>c00c</code>.</p>

<p>This is something called <strong>DNS compression</strong> and if we want to parse any DNS
responses we&rsquo;re going to have to implement it.</p>

<p>This is luckily not <strong>that</strong> hard. All <code>c00c</code> is saying is:</p>

<ul>
<li>The first 2 bits (<code>0b11.....</code>) mean &ldquo;DNS compression ahead!&rdquo;</li>
<li>The remaining 14 bits are an integer. In this case that integer is <code>12</code>
(<code>0x0c</code>), so that means &ldquo;go back to the 12th byte in the packet and use the
domain name you find there&rdquo;</li>
</ul>

<p>If you want to read more about DNS compression, I found the <a href="https://datatracker.ietf.org/doc/html/rfc1035#section-4.1.4">explanation in the DNS RFC</a> relatively readable.</p>

<h3 id="step-9-implement-dns-compression">step 9: implement DNS compression</h3>

<p>So we need a more complicated version of our <code>read_domain_name</code> function</p>

<p>Here it is.</p>

<pre><code class="language-ruby">  domain = []
  loop do
    len = buf.read(1).unpack('C')[0]
    break if len == 0
    if len &amp; 0b11000000 == 0b11000000
      # weird case: DNS compression!
      second_byte = buf.read(1).unpack('C')[0]
      offset = ((len &amp; 0x3f) &lt;&lt; 8) + second_byte
      old_pos = buf.pos
      buf.pos = offset
      domain &lt;&lt; read_domain_name(buf)
      buf.pos = old_pos
      break
    else
      # normal case
      domain &lt;&lt; buf.read(len)
    end
  end
  domain.join('.')
</code></pre>

<p>Basically what&rsquo;s happening is:</p>

<ul>
<li>if the first 2 bits are <code>0b11</code>, we need to do DNS compression. Then:

<ul>
<li>read the second byte and do a little bit arithmetic to convert that into the offset</li>
<li>save the current position in the buffer</li>
<li>read the domain name at the offset we calculated</li>
<li>restore our position in the buffer</li>
</ul></li>
</ul>

<p>This is kind of messy but it&rsquo;s the most complicated part of parsing the DNS response, so we&rsquo;re almost done!</p>

<h3 id="a-dns-compression-exploit">a DNS compression exploit</h3>

<p>Someone pointed out that a malicious actor could exploit this code by sending a
DNS response with a DNS compression entry that points to itself, so that
<code>read_domain_name</code> would end up in an infinite loop. I won&rsquo;t update it (the
code is already complicated enough!) but a real DNS parser would be
smarter and deal with that. For example <a href="https://github.com/miekg/dns/blob/b3dfea07155dbe4baafd90792c67b85a3bf5be23/msg.go#L430-L435">here&rsquo;s the code that avoids infinite loops in miekg/dns</a></p>

<p>There are also probably other edge cases that would be problematic if this were
a real DNS parser.</p>

<h3 id="step-10-parse-a-dns-query">step 10: parse a DNS query</h3>

<p>You might think &ldquo;why do we need to parse a DNS query? This is the response!&rdquo;.
But every DNS response has the original query in it, so we need to parse it.</p>

<p>Here&rsquo;s the code for parsing the DNS query.</p>

<pre><code>class DNSQuery
  attr_reader :domain, :type, :cls
  def initialize(buf)
    @domain = read_domain_name(buf)
    @type, @cls = buf.read(4).unpack('nn')
  end
end
</code></pre>

<p>There&rsquo;s not very much to it: the type and class are 2 bytes each.</p>

<h3 id="step-11-parse-a-dns-record">step 11: parse a DNS record</h3>

<p>This is the exciting part &ndash; the DNS record is where our query data lives! The
&ldquo;rdata field&rdquo; (&ldquo;record data&rdquo;) is where the IP address we&rsquo;re going to get in
response to our DNS query lives.</p>

<p>Here&rsquo;s the code:</p>

<pre><code>class DNSRecord 
  attr_reader :name, :type, :class, :ttl, :rdlength, :rdata
  def initialize(buf)
    @name = read_domain_name(buf)
    @type, @class, @ttl, @rdlength = buf.read(10).unpack('nnNn')
    @rdata = buf.read(@rdlength)
  end
</code></pre>

<p>We also need to do a little work to make the <code>rdata</code> field human readable. The
meaning of the record data depends on the record type  &ndash; for example for an
&ldquo;A&rdquo; record it&rsquo;s a 4-byte IP address, for but a &ldquo;CNAME&rdquo; record it&rsquo;s a domain
name.</p>

<p>So here&rsquo;s some code to make the request data human readable:</p>

<pre><code>  def read_rdata(buf, length)
    @type_name = TYPES[@type] || @type
    if @type_name == &quot;CNAME&quot; or @type_name == &quot;NS&quot;
      read_domain_name(buf)
    elsif @type_name == &quot;A&quot;
      buf.read(length).unpack('C*').join('.')
    else
      buf.read(length)
    end
  end
</code></pre>

<p>This function uses this <code>TYPES</code> hash to map the record type to a human-readable name:</p>

<pre><code>TYPES = {
  1 =&gt; &quot;A&quot;,
  2 =&gt; &quot;NS&quot;,
  5 =&gt; &quot;CNAME&quot;,
  # there are a lot more but we don't need them for this example
}
</code></pre>

<p>The most interesting part of <code>read_rdata</code> is probably the line <code>buf.read(length).unpack('C*').join('.')</code> &ndash; it&rsquo;s saying &ldquo;hey, an IP address is 4 bytes,
so convert it into an array of 4 numbers and then join those with &ldquo;.&ldquo;s&rdquo;.</p>

<h3 id="step-12-finish-parsing-the-dns-response">step 12: finish parsing the DNS response</h3>

<p>Now we&rsquo;re ready to parse the DNS response!</p>

<p>Here&rsquo;s some code to do that:</p>

<pre><code class="language-ruby">class DNSResponse
  attr_reader :header, :queries, :answers, :authorities, :additionals
  def initialize(bytes)
    buf = StringIO.new(bytes)
    @header = DNSHeader.new(buf)
    @queries = (1..@header.num_questions).map { DNSQuery.new(buf) }
    @answers = (1..@header.num_answers).map { DNSRecord.new(buf) }
    @authorities = (1..@header.num_auth).map { DNSRecord.new(buf) }
    @additionals = (1..@header.num_additional).map { DNSRecord.new(buf) }
  end
end
</code></pre>

<p>This mostly just calls the other functions we&rsquo;ve written to parse the DNS response.</p>

<p>It uses this cute <code>(1..@header.num_answers).map</code> construction to create an
array of 2 DNS records if <code>@header.num_answers</code> is 2. (which is maybe a
<em>little</em> bit of Ruby magic but I think it&rsquo;s kind of fun and hopefully isn&rsquo;t too hard
to read)</p>

<p>We can integrate this code into our main function like this:</p>

<pre><code>sock.send(make_dns_query(&quot;example.com&quot;, 1), 0) # 1 is &quot;A&quot;, for IP address
reply, _ = sock.recvfrom(1024)
response = DNSResponse.new(reply) # parse the response!!!
puts response.answers[0]
</code></pre>

<p>Printing out the records looks awful though (it says something like
<code>#&lt;DNSRecord:0x00000001368e3118&gt;</code>). So we need to write some pretty printing
code to make it human readable.</p>

<h3 id="step-13-pretty-print-our-dns-records">step 13: pretty print our DNS records</h3>

<p>We need to add a <code>.to_s</code> field to DNS records to make them have a nice string
representation. This is just a 1-line method in <code>DNSRecord</code>:</p>

<pre><code>  def to_s
    &quot;#{@name}\t\t#{@ttl}\t#{@type_name}\t#{@parsed_rdata}&quot;
  end
</code></pre>

<p>You also might notice that I left out the <code>class</code> field of the DNS record. That&rsquo;s because it&rsquo;s
always the same (IN for &ldquo;internet&rdquo;) so I felt it was redundant. Most DNS tools
(like real <code>dig</code>) will print out the class though.</p>

<h3 id="and-we-re-done">and we&rsquo;re done!</h3>

<p>Here&rsquo;s our final <code>main</code> function:</p>

<pre><code>def main
  # connect to google dns
  sock = UDPSocket.new
  sock.bind('0.0.0.0', 0)
  sock.connect('8.8.8.8', 53)

  # send query
  domain = ARGV[0]
  sock.send(make_dns_query(domain, 1), 0)

  # receive &amp; parse response
  reply, _ = sock.recvfrom(1024)
  response = DNSResponse.new(reply)
  response.answers.each do |record|
    puts record
  end
</code></pre>

<p>I don&rsquo;t think there&rsquo;s too much to say about this &ndash; we connect, send a query,
print out each of the answers, and exit. Success!</p>

<pre><code>$ ruby dig.rb example.com
example.com   18608   A   93.184.216.34
</code></pre>

<p>You can see the final program as a gist here:
<a href="https://gist.github.com/jvns/1e5838a53520e45969687e2f90199770">dig.rb</a>. You could add more features to it if you want, like</p>

<ul>
<li>pretty printing for other query types</li>
<li>options to print out the &ldquo;authority&rdquo; and &ldquo;additional&rdquo; sections of the DNS response</li>
<li>retries</li>
<li>making sure that the DNS response we see is <em>actually</em> a response to the query we sent (the query ID has to match!</li>
</ul>

<p>Also <a href="https://twitter.com/b0rk">you can let me know on Twitter</a> if I&rsquo;ve made a mistake in this post somewhere
&ndash; I wrote this pretty quickly so I probably got something wrong.</p>

  </body>
</html>
