<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://laurent.le-brun.eu/blog/making-a-game-on-a-custom-bytecode-vm-in-7-days-and-3kb">Original</a>
    <h1>Making a game on a custom bytecode VM in 7 days and 3kB</h1>
    
    <div id="readability-page-1" class="page"><div>
                    <p>In the last few days, I built a shoot ’em up game by embedding a tiny custom bytecode VM and rendering the graphics using a fullscreen pixel shader. The result is a 3kB Windows executable.</p>
<p>This was done for <a href="https://langjamgamejam.com/">Langjam Gamejam</a>, a 7-day challenge where you create a programming language and then use it to build a game.</p>
<p>The project combines several interests of mine: <a href="https://laurent.le-brun.eu/blog/an-overview-of-starlark">language tooling</a>, <a href="https://laurent.le-brun.eu/blog/designing-a-video-game-for-language-learners">game development</a>, procedural graphics, and <a href="https://www.ctrl-alt-test.fr/2024/how-we-made-an-animated-movie-in-8kb/">demoscene-style size constraints</a>. The game jam format forced me to keep the scope small and explore new ideas. Also, it was fun!</p>
<p>As always, <a href="https://github.com/laurentlb/shmup8">my code is on GitHub</a>; it&#39;s also on <a href="https://laurentlb.itch.io/shmup8">itch.io</a>. For convenience, here’s a YouTube capture:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/ZNnRwzm5FHU?si=5kchN1IHUvZdPMO9" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>

<p>When I first heard about the game jam, I immediately got interested. I thought for a few days, as it’s not easy to find a game concept that would benefit from a new language (apart from, well, programming games like TIS-100).</p>
<p>Then I remembered demoscene productions that used custom bytecode to make things smaller. An example that came to mind was <a href="https://www.pouet.net/prod.php?which=54561">Ikadalawampu</a>, a 2010 demo in 4kB that runs on Amiga. I was still a bit skeptical: is it really worth embedding an interpreter, just to make the actual code smaller? I had to give it a try.</p>
<p>Another inspiration of mine has been the first-person shooter video game, <a href="https://en.wikipedia.org/wiki/.kkrieger">kkrieger</a>, made in 2004 and that fits in 96kB. Since then, we’ve rarely seen good video games that were size-coded. Exploring this domain has been on the side of my mind for a while.</p>
<p>With all that in mind, I thought the game jam would be a good excuse for exploratory work.</p>

<ul>
<li>Design a language.</li>
<li>Implement a compiler to compile it to bytecode, using F#.</li>
<li>Write a bytecode interpreter, using C++.</li>
<li>Create a shoot’em up game, using the custom language.</li>
<li>Render the graphics, using a single GLSL shader.</li>
</ul>
<p>Although the design choices were made with size-coding in mind, I also didn’t want to spend time optimizing the code. I originally estimated that the game would fit in 4 to 8kB, so I named the project shmup8. The executable turned out to be smaller than expected, but it’s also because I didn’t include music or 3D graphics. As always, <a href="https://www.ctrl-alt-test.fr/2025/15-years-of-shader-minification/">the shader code is minified</a> and the executable compressed with <a href="https://github.com/runestubbe/Crinkler/">Crinkler</a>.</p>

<p>Coding is much more fun when there’s instant visual feedback. I wanted to be able to write the entire game logic and visuals without recompiling C++ code. The idea was to run the executable once, then iterate entirely through live reload.</p>
<p>Each time I edit the source code in my IDE, my custom compiler is invoked, it dumps bytecode in a file. Then the C++ project reloads the bytecode that it executes at every frame. In a similar way, the GLSL shader is also reloaded automatically when edited.</p>
<p>Early development screenshot: the game running on the top left, the custom language on the bottom left, the GLSL shader on the bottom right, and the console logs on the top right. As the custom language sends data to be displayed by the shader, having two live-coding environments makes it very easy to iterate.</p>
<p><img title="Screenshot%202025-12-16%20000557" alt="Screenshot%202025-12-16%20000557" src="https://laurent.le-brun.eu/blog/user/pages/01.blog/making-a-game-on-a-custom-bytecode-vm-in-7-days-and-3kb/Screenshot%202025-12-16%20000557.png"/></p>
<p>Rapid iteration is a critical feature for productivity, especially in creative environments where you can hardly predict what will feel good.</p>

<p>I quickly decided that the communication between bytecode and shader would happen through float arrays.</p>
<p>With minimalism in mind, I decided that I needed just one type: float32. All values are stored in arrays. You want a local variable? Pick a slot in a float array and use it. How to index the array? Use a float, the interpreter will cast it to int. How to write conditions? Use a float, it’s true if it’s greater than 0.5.</p>
<p>The bytecode has only two kinds of statements: either you update a cell in an array; or you jump (possibly with a condition) to another address in the bytecode.</p>
<p>The bytecode also has a concept of expression: so when you update a cell, the value can be a complex math expression that references other array cells or functions (like sine).</p>
<p>Constants between 0 and 255 are stored one byte. Other float numbers are stored on 2 bytes using <a href="https://www.ctrl-alt-test.fr/2018/making-floating-point-numbers-smaller/">my favourite float trick</a>!</p>
<p>This design avoids things like stacks, registers, and type tagging, which keeps both the interpreter and the bytecode compact.</p>
<p><a href="https://github.com/laurentlb/shmup8/blob/main/src/interp.cpp#L9">See the list of bytecodes elements</a></p>

<p>The minimalist bytecode restricts what I can support in the language, but I still have the possibility of using syntactic sugar to make some things nicer.</p>
<p>Using a C-like syntax, I implemented support for assignments, if conditions and while loops. Syntactic sugar is used to allow augmented assignments and for loops.</p>
<p>Each time the compiler sees a variable, it gives it a location in a float array.
When a value is to be shared with the shader, I have to give it a specific position. For example, I decided that state[5] would store the current score. For increased readability, I added support for inlining things. With:</p>
<pre><code>inline score = state[5];</code></pre>
<p>I can now use <code>score</code> for reading or writing to state[5].</p>
<p>While iterating on the game, I sometimes had to stop to add missing features. But in some cases, I also decided to work around the limitations; for example, I used a multiplication instead of &amp;&amp; when writing conditions. It’s just the same… provided that the values are just 0s and 1s. :)</p>
<p>I used an array called <code>missiles</code> to store the position of every missile. The first cell indicates the number of missiles on screen. How to remove any element from an array without writing a loop? Swap it.</p>
<pre><code>   // remove missiles outside the screen
    if (missiles[i*2 + 2] &gt; 0.5) {
        // O(1) removal: swap element with the last one in the array
        missiles[i*2 + 1] = missiles[(missiles[0] - 1)*2 + 1]; // position.x
        missiles[i*2 + 2] = missiles[(missiles[0] - 1)*2 + 2]; // position.y
        missiles[0] -= 1;
    }</code></pre>
<p>(<a href="https://github.com/laurentlb/shmup8/blob/main/game.source">See the rest of the file</a>)</p>

<p>This is very similar to what we have in ShaderToy. It’s just about computing the color of a pixel based on the data provided by the game engine.</p>
<p>I kept the graphics code simple, as the game jam time is limited.</p>
<p>I used a feedback effect (blending the previous frame with the current frame) to make the visuals more interesting, and combined the effect with some noise functions.</p>
<p><img title="Screenshot%202025-12-16%20025758" alt="Screenshot%202025-12-16%20025758" src="https://laurent.le-brun.eu/blog/user/pages/01.blog/making-a-game-on-a-custom-bytecode-vm-in-7-days-and-3kb/Screenshot%202025-12-16%20025758.png"/></p>

<p>The game design is also kept simple. The game is infinite. It starts with three enemies. It adds an enemy every 7 seconds. There are three kinds of enemies, each of them has its special behavior and visuals.</p>
<p>Contrary to what some might believe, enemies can’t die. When a missile hits an enemy, it gets teleported outside the screen, and it’s able to come back to the playing field.</p>
<p>This approach keeps the code very simple, while ensuring the game gets more and more. My first thought was to create a list of enemy waves, but that was harder to design and balance the difficulty.</p>
<p>Like in Super Hexagon, special care was taken to provide a rapid restart and encourage replays. Expect the game to last between 30s and 60s.</p>

<p>The quick iteration workflow was essential. Designing the bytecode and the game in parallel made it hard to predict which features would be needed upfront, and many constraints only became apparent once I started writing the game itself.</p>
<p>Of course, a question remains… Is the bytecode actually smaller than using compiled C++? I ported the game logic to C++, removed the bytecode interpreter and checked the size.</p>
<p>The C++ version is 90 bytes bigger than the bytecode version. So the savings from using bytecode are more important than the interpreter size. Some people might say that the C++ engine I ported was not really optimized; but neither are the interpreter and the bytecode. So take the actual numbers with a grain of salt.</p>
<p>Overall this was a fun project. It worked better than anticipated and I learned a few things. I’m sure I’ll do more game dev explorations in the future.</p>
                        </div></div>
  </body>
</html>
