<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://css-tricks.com/send-an-http-request-on-page-exit/">Original</a>
    <h1>Reliably Send an HTTP Request as a User Leaves a Page</h1>
    
    <div id="readability-page-1" class="page"><div>

          
          
<p>On several occasions, I’ve needed to send off an <code>HTTP</code> request with some data to log when a user does something like navigate to a different page or submit a form. Consider this contrived example of sending some information to an external service when a link is clicked:</p>



<pre rel="HTML" data-line=""><code markup="tt">&lt;a href=&#34;/some-other-page&#34; id=&#34;link&#34;&gt;Go to Page&lt;/a&gt;

&lt;script&gt;
document.getElementById(&#39;link&#39;).addEventListener(&#39;click&#39;, (e) =&gt; {
  fetch(&#34;/log&#34;, {
    method: &#34;POST&#34;,
    headers: {
      &#34;Content-Type&#34;: &#34;application/json&#34;
    }, 
    body: JSON.stringify({
      some: &#34;data&#34;
    })
  });
});
&lt;/script&gt;</code></pre>



<p>There’s nothing terribly complicated going on here. The link is permitted to behave as it normally would (I’m not using <code>e.preventDefault()</code>), but before that behavior occurs, a <code>POST</code> request is triggered on <code>click</code>. There’s no need to wait for any sort of response. <strong>I just want it to be sent</strong> to whatever service I’m hitting.</p>



<p>On first glance, you might expect the dispatch of that request to be synchronous, after which we’d continue navigating away from the page while some other server successfully handles that request. But as it turns out, that’s not what always happens.</p>



<h3 id="browsers-don-t-guarantee-to-preserve-open-http-requests"><a href="#aa-browsers-dont-guarantee-to-preserve-open-http-requests" aria-hidden="true" id="aa-browsers-dont-guarantee-to-preserve-open-http-requests"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Browsers don’t guarantee to preserve open HTTP requests</h3>



<p>When something occurs to terminate a page in the browser, there’s no guarantee that an in-process <code>HTTP</code> request will be successful (<a href="https://developers.google.com/web/updates/2018/07/page-lifecycle-api" rel="noopener">see more</a> about the “terminated” and other states of a page’s lifecycle). The reliability of those requests may depend on several things — network connection, application performance, and even the configuration of the external service itself.</p>



<p>As a result, sending data at those moments can be anything but reliable, which presents a potentially significant problem if you’re relying on those logs to make data-sensitive business decisions.</p>



<p>To help illustrate this unreliability, I set up a small Express application with a page using the code included above. When the link is clicked, the browser navigates to <code>/other</code>, but before that happens, a <code>POST</code> request is fired off.</p>



<p>While everything happens, I have the browser’s Network tab open, and I’m using a “Slow 3G” connection speed. Once the page loads and I’ve cleared the log out, things look pretty quiet:</p>



<figure><img width="2000" height="946" src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2022/02/initial-load-1.png?resize=2000%2C946&amp;ssl=1" alt="Viewing HTTP request in the network tab" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/css-tricks.com/wp-content/uploads/2022/02/initial-load-1.png?w=2000&amp;ssl=1 2000w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2022/02/initial-load-1.png?resize=300%2C142&amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2022/02/initial-load-1.png?resize=1024%2C484&amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2022/02/initial-load-1.png?resize=768%2C363&amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2022/02/initial-load-1.png?resize=1536%2C727&amp;ssl=1 1536w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2022/02/initial-load-1.png?resize=1000%2C473&amp;ssl=1 1000w" data-lazy-sizes="(min-width: 735px) 864px, 96vw" data-lazy-src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2022/02/initial-load-1.png?resize=2000%2C946&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></figure>



<p>But as soon as the link is clicked, things go awry. When navigation occurs, the request is cancelled.</p>



<figure><img loading="lazy" width="1000" height="472" src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2022/02/request-failed-1.gif?resize=1000%2C472&amp;ssl=1" alt="Viewing HTTP request fail in the network tab" data-recalc-dims="1" data-lazy-src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2022/02/request-failed-1.gif?resize=1000%2C472&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></figure>



<p>And that leaves us with little confidence that the external service was actually able process the request. Just to verify this behavior, it also occurs when we navigate programmatically with <code>window.location</code>:</p>



<pre rel="JavaScript" data-line=""><code markup="tt">document.getElementById(&#39;link&#39;).addEventListener(&#39;click&#39;, (e) =&gt; {
+ e.preventDefault();

  // Request is queued, but cancelled as soon as navigation occurs. 
  fetch(&#34;/log&#34;, {
    method: &#34;POST&#34;,
    headers: {
      &#34;Content-Type&#34;: &#34;application/json&#34;
    }, 
    body: JSON.stringify({
      some: &#39;data&#39;
    }),
  });

+ window.location = e.target.href;
});</code></pre>



<p>Regardless of how or when navigation occurs and the active page is terminated, those unfinished requests are at risk for being abandoned.</p>



<h3 id="but-why-are-they-cancelled"><a href="#aa-but-why-are-they-cancelled" aria-hidden="true" id="aa-but-why-are-they-cancelled"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>But why are they cancelled?</h3>



<p>The root of the issue is that, by default, XHR requests (via <code>fetch</code> or <code>XMLHttpRequest</code>) are asynchronous and non-blocking. As soon as the request is queued, the actual <em>work</em> of the request is handed off to a browser-level API behind the scenes.</p>



<p>As it relates to performance, this is good — you don’t want requests hogging the main thread. But it also means there’s a risk of them being deserted when a page enters into that “terminated” state, leaving no guarantee that any of that behind-the-scenes work reaches completion. <a href="https://developers.google.com/web/updates/2018/07/page-lifecycle-api#states" rel="noopener">Here’s how Google summarizes</a> that specific lifecycle state:</p>



<blockquote><p>A page is in the terminated state once it has started being unloaded and cleared from memory by the browser. No <a href="https://html.spec.whatwg.org/multipage/webappapis.html#queue-a-task" rel="noopener">new tasks</a> can start in this state, and in-progress tasks may be killed if they run too long.</p></blockquote>



<p>In short, the browser is designed with the assumption that when a page is dismissed, there’s no need to continue to process any background processes queued by it.</p>



<h3 id="so-what-are-our-options"><a href="#aa-so-what-are-our-options" aria-hidden="true" id="aa-so-what-are-our-options"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>So, what are our options?</h3>



<p>Perhaps the most obvious approach to avoid this problem is, as much as possible, to delay the user action until the request returns a response. In the past, this has been done the wrong way by use of the <a href="https://xhr.spec.whatwg.org/#synchronous-flag" rel="noopener">synchronous flag</a> supported within <code>XMLHttpRequest</code>. But using it completely blocks the main thread, causing a host of performance issues — <a href="https://macarthur.me/posts/use-web-workers-for-your-event-listeners" rel="noopener">I’ve written</a> about some of this in the past — so the idea shouldn’t even be entertained. In fact, it’s on its way out of the platform (Chrome v80+ <a href="https://developers.google.com/web/updates/2019/12/chrome-80-deps-rems" rel="noopener">has already</a> removed it).</p>



<p>Instead, if you’re going to take this type of approach, it’s better to wait for a <code>Promise</code> to resolve as a response is returned. After it’s back, you can safely perform the behavior. Using our snippet from earlier, that might look something like this:</p>



<pre rel="JavaScript" data-line=""><code markup="tt">document.getElementById(&#39;link&#39;).addEventListener(&#39;click&#39;, async (e) =&gt; {
  e.preventDefault();

  // Wait for response to come back...
  await fetch(&#34;/log&#34;, {
    method: &#34;POST&#34;,
    headers: {
      &#34;Content-Type&#34;: &#34;application/json&#34;
    }, 
    body: JSON.stringify({
      some: &#39;data&#39;
    }),
  });

  // ...and THEN navigate away.
   window.location = e.target.href;
});</code></pre>



<p>That gets the job done, but there are some non-trivial drawbacks.</p>



<p><strong>First, it compromises the user’s experience by delaying the desired behavior from occurring.</strong> Collecting analytics data certainly benefits the business (and hopefully future users), but it’s less than ideal to make your <em>present</em> users to pay the cost to realize those benefits. Not to mention, as an external dependency, any latency or other performance issues within the service itself will be surfaced to the user. If timeouts from your analytics service cause a customer from completing a high-value action, everyone loses.</p>



<p><strong>Second, this approach isn’t as reliable as it initially sounds, since some termination behaviors can’t be programmatically delayed.</strong> For example, <code>e.preventDefault()</code> is useless in delaying someone from closing a browser tab. So, at best, it’ll cover collecting data for <em>some</em> user actions, but not enough to be able to trust it comprehensively.</p>



<h3 id="instructing-the-browser-to-preserve-outstanding-requests"><a href="#aa-instructing-the-browser-to-preserve-outstanding-requests" aria-hidden="true" id="aa-instructing-the-browser-to-preserve-outstanding-requests"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Instructing the browser to preserve outstanding requests</h3>



<p>Thankfully, there are options to <em>preserve</em> outstanding <code>HTTP</code> requests that are built into the vast majority of browsers, and that don’t require user experience to be compromised.</p>



<h4 id="using-fetch-s-keepalive-flag"><a href="#aa-using-fetchs-keepalive-flag" aria-hidden="true" id="aa-using-fetchs-keepalive-flag"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using Fetch’s <code>keepalive</code> flag</h4>



<p>If the <a href="https://fetch.spec.whatwg.org/#request-keepalive-flag" rel="noopener"><code>keepalive</code> flag</a> is set to <code>true</code> when using <code>fetch()</code>, the corresponding request will remain open, even if the page that initiated that request is terminated. Using our initial example, that’d make for an implementation that looks like this:</p>



<pre rel="HTML" data-line="12"><code markup="tt">&lt;a href=&#34;/some-other-page&#34; id=&#34;link&#34;&gt;Go to Page&lt;/a&gt;

&lt;script&gt;
  document.getElementById(&#39;link&#39;).addEventListener(&#39;click&#39;, (e) =&gt; {
    fetch(&#34;/log&#34;, {
      method: &#34;POST&#34;,
      headers: {
        &#34;Content-Type&#34;: &#34;application/json&#34;
      }, 
      body: JSON.stringify({
        some: &#34;data&#34;
      }), 
      keepalive: true
    });
  });
&lt;/script&gt;</code></pre>



<p>When that link is clicked and page navigation occurs, no request cancellation occurs:</p>



<figure><img loading="lazy" width="1000" height="472" src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2022/02/request-succeeded.gif?resize=1000%2C472&amp;ssl=1" alt="Viewing HTTP request succeed in the network tab" data-recalc-dims="1" data-lazy-src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2022/02/request-succeeded.gif?resize=1000%2C472&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></figure>



<p>Instead, we’re left with an <code>(unknown)</code> status, simply because the active page never waited around to receive any sort of response.</p>



<p>A one-liner like this an easy fix, especially when it’s part of a commonly used browser API. But if you’re looking for a more focused option with a simpler interface, there’s another way with virtually the same browser support.</p>



<h4 id="using-navigator-sendbeacon"><a href="#aa-using-navigator-sendbeacon" aria-hidden="true" id="aa-using-navigator-sendbeacon"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using <code>Navigator.sendBeacon()</code></h4>



<p>The <code>Navigator.sendBeacon()</code>function is specifically intended for sending one-way requests (<a href="https://w3c.github.io/beacon/#sec-processing-model" rel="noopener">beacons</a>). A basic implementation looks like this, sending a <code>POST</code> with stringified JSON and a “text/plain” <code>Content-Type</code>:</p>



<pre rel="JavaScript" data-line=""><code markup="tt">navigator.sendBeacon(&#39;/log&#39;, JSON.stringify({
  some: &#34;data&#34;
}));</code></pre>



<p>But this API doesn’t permit you to send custom headers. So, in order for us to send our data as “application/json”, we’ll need to make a small tweak and use a <code>Blob</code>:</p>



<pre rel="HTML" data-line=""><code markup="tt">&lt;a href=&#34;/some-other-page&#34; id=&#34;link&#34;&gt;Go to Page&lt;/a&gt;

&lt;script&gt;
  document.getElementById(&#39;link&#39;).addEventListener(&#39;click&#39;, (e) =&gt; {
    const blob = new Blob([JSON.stringify({ some: &#34;data&#34; })], { type: &#39;application/json; charset=UTF-8&#39; });
    navigator.sendBeacon(&#39;/log&#39;, blob));
  });
&lt;/script&gt;</code></pre>



<p>In the end, we get the same result — a request that’s allowed to complete even after page navigation. But there’s something more going on that may give it an edge over <code>fetch()</code>: beacons are sent with a low priority.</p>



<p>To demonstrate, here’s what’s shown in the Network tab when both <code>fetch()</code> with <code>keepalive</code> <em>and</em> <code>sendBeacon()</code> are used at the same time:</p>



<figure><img loading="lazy" width="2000" height="946" src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2022/02/request-priorities.png?resize=2000%2C946&amp;ssl=1" alt="Viewing HTTP request in the network tab" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/css-tricks.com/wp-content/uploads/2022/02/request-priorities.png?w=2000&amp;ssl=1 2000w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2022/02/request-priorities.png?resize=300%2C142&amp;ssl=1 300w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2022/02/request-priorities.png?resize=1024%2C484&amp;ssl=1 1024w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2022/02/request-priorities.png?resize=768%2C363&amp;ssl=1 768w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2022/02/request-priorities.png?resize=1536%2C727&amp;ssl=1 1536w, https://i0.wp.com/css-tricks.com/wp-content/uploads/2022/02/request-priorities.png?resize=1000%2C473&amp;ssl=1 1000w" data-lazy-sizes="(min-width: 735px) 864px, 96vw" data-lazy-src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2022/02/request-priorities.png?resize=2000%2C946&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></figure>



<p>By default, <code>fetch()</code> gets a “High” priority, while the beacon (noted as the “ping” type above) have the “Lowest” priority. For requests that aren’t critical to the functionality of the page, this is a good thing. Taken straight from the <a href="https://www.w3.org/TR/beacon/" rel="noopener">Beacon specification</a>:</p>



<blockquote><p>This specification defines an interface that […] minimizes resource contention with other time-critical operations, while ensuring that such requests are still processed and delivered to destination.</p></blockquote>



<p>Put another way, <code>sendBeacon()</code> ensures its requests stay out of the way of those that really matter for your application and your user’s experience.</p>



<h4 id="an-honorable-mention-for-the-ping-attribute"><a href="#aa-an-honorable-mention-for-the-ping-attribute" aria-hidden="true" id="aa-an-honorable-mention-for-the-ping-attribute"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>An honorable mention for the <code>ping</code> attribute</h4>



<p>It’s worth mentioning that a growing number of browsers support <a href="https://css-tricks.com/the-ping-attribute-on-anchor-links/">the <code>ping</code> attribute</a>. When attached to links, it’ll fire off a small <code>POST</code> request:</p>



<pre rel="HTML" data-line=""><code markup="tt">&lt;a href=&#34;http://localhost:3000/other&#34; ping=&#34;http://localhost:3000/log&#34;&gt;
  Go to Other Page
&lt;/a&gt;</code></pre>



<p>And those requests headers will contain the page on which the link was clicked (<code>ping-from</code>), as well as the <code>href</code> value of that link (<code>ping-to</code>):</p>



<pre rel="JavaScript" data-line=""><code markup="tt">headers: {
  &#39;ping-from&#39;: &#39;http://localhost:3000/&#39;,
  &#39;ping-to&#39;: &#39;http://localhost:3000/other&#39;
  &#39;content-type&#39;: &#39;text/ping&#39;
  // ...other headers
},</code></pre>



<p>It’s technically similar to sending a beacon, but has a few notable limitations:</p>



<ol><li><strong>It’s strictly limited for use on links,</strong> which makes it a non-starter if you need to track data associated with other interactions, like button clicks or form submissions.</li><li><strong>Browser support is good, <a href="https://caniuse.com/ping" rel="noopener">but not great</a>.</strong> At the time of this writing, Firefox specifically doesn’t have it enabled by default.</li><li><strong>You’re unable to send any custom data along with the request.</strong> As mentioned, the most you’ll get is a couple of  <code>ping-*</code> headers, along with whatever other headers are along for the ride.</li></ol>



<p>All things considered, <code>ping</code> is a good tool if you’re fine with sending simple requests and don’t want to write any custom JavaScript. But if you’re needing to send anything of more substance, it might not be the best thing to reach for.</p>



<h3 id="so-which-one-should-i-reach-for"><a href="#aa-so-which-one-should-i-reach-for" aria-hidden="true" id="aa-so-which-one-should-i-reach-for"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>So, which one <em>should</em> I reach for?</h3>



<p>There are definitely tradeoffs to using either <code>fetch</code> with <code>keepalive</code> or <code>sendBeacon()</code> to send your last-second requests. To help discern which is the most appropriate for different circumstances, here are some things to consider:</p>



<h4 id="you-might-go-with-fetch-keepalive-if"><a href="#aa-you-might-go-with-fetch-keepalive-if" aria-hidden="true" id="aa-you-might-go-with-fetch-keepalive-if"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>You might go with <code>fetch()</code> + <code>keepalive</code> if:</h4>



<ul><li>You need to easily pass custom headers with the request.</li><li>You want to make a <code>GET</code> request to a service, rather than a <code>POST</code>.</li><li>You’re supporting older browsers (like IE) and already have a <code>fetch</code> polyfill being loaded.</li></ul>



<h4 id="but-sendbeacon-might-be-a-better-choice-if"><a href="#aa-but-sendbeacon-might-be-a-better-choice-if" aria-hidden="true" id="aa-but-sendbeacon-might-be-a-better-choice-if"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>But <code>sendBeacon()</code> might be a better choice if:</h4>



<ul><li>You’re making simple service requests that don’t need much customization.</li><li>You prefer the cleaner, more elegant API.</li><li>You want to guarantee that your requests don’t compete with other high-priority requests being sent in the application.</li></ul>



<h3 id="avoid-repeating-my-mistakes"><a href="#aa-avoid-repeating-my-mistakes" aria-hidden="true" id="aa-avoid-repeating-my-mistakes"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Avoid repeating my mistakes</h3>



<p>There’s a reason I chose to do a deep dive into the nature of how browsers handle in-process requests as a page is terminated. A while back, my team saw a sudden change in the frequency of a particular type of analytics log after we began firing the request just as a form was being submitted. The change was abrupt and significant — a ~30% drop from what we had been seeing historically. </p>



<p>Digging into the reasons this problem arose, as well as the tools that are available to avoid it again, saved the day. So, if anything, I’m hoping that understanding the nuances of these challenges help someone avoid some of the pain we ran into. Happy logging!</p>

          
        </div></div>
  </body>
</html>
