<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://x61.sh/log/2023/02/20230217T112354-nextcloud_openbsd.html">Original</a>
    <h1>Nextcloud and OpenBSD = &lt;3</h1>
    
    <div id="readability-page-1" class="page"><div id="wrapper">
		
		<p>[x61]</p>
		<hr/>
		<nav>
			
		</nav>


<p>Looks like everything is made of clouds and farts now, so we cannot be out of it we need to keep up on the trend. I maintain the <b><a href="https://cvsweb.openbsd.org/ports/www/nextcloud/">nextcloud port</a></b> since ever, and I am using since then, to be honest it&#39;s pretty cool and handy, despite all the php slowness and other flavors the system has and the <b><a href="https://openbsd.org/">OpenBSD&#39;s</a></b> issues as client and server (in comparation with loonix and others), it works really really well in every way I use it; which is as &#34;multimedia cloud&#34;, &#34;CalDAV/CardDAV&#34; server for my android phone, &#34;Password Manager&#34; and &#34;Backups&#34; in general.</p>

<h2>:. Install</h2>

<p>As I explained before in other articles, I like to keep using base system as much as I can, I like minimal stuff, I like minimalism and <b><a href="https://openbsd.org/">OpenBSD</a></b> is very minimal and full of tools for the task. The setup will be with <b><a href="https://man.openbsd.org/relayd.8">relayd(8)</a></b> in front, and <b><a href="https://man.openbsd.org/httpd.8">httpd(8)</a></b> behind, the only package we need it&#39;s <b><a href="https://cvsweb.openbsd.org/ports/www/nextcloud/">nextcloud</a></b>, the rest will come along with it, so we do:</p>

<pre><code>$ doas pkg_add nextcloud
quirks-6.101 signed on 2023-02-14T11:05:49Z
quirks-6.101: ok
Ambiguous: choose package for nextcloud
a       0: &lt;None&gt;
        1: nextcloud-23.0.12p0
        2: nextcloud-24.0.9p0
        3: nextcloud-25.0.3p0
Your choice: 3
---
PORTS MAGIC
---
nextcloud-25.0.3p0: ok
Running tags: ok
The following new rcscripts were installed: /etc/rc.d/php81_fpm
See rcctl(8) for details.
New and changed readme(s):
        /usr/local/share/doc/pkg-readmes/femail-chroot
        /usr/local/share/doc/pkg-readmes/glib2
        /usr/local/share/doc/pkg-readmes/nextcloud
        /usr/local/share/doc/pkg-readmes/php-8.1</code></pre>

<p>I recommend if you are using -current to use the higher one, it will be the one keeping get upgrades and changing to the new major one in the port and probably the one getting more updates from upstream. As always I will not explain you in details what it&#39;s already in the <b><a href="https://cvsweb.openbsd.org/ports/www/nextcloud/pkg/README">README</a></b>, which btw, you should know that you can find as the others here: <b>/usr/local/share/doc/pkg-readmes/</b>. If you read the file, you will see that you have an example file for <b><a href="https://man.openbsd.org/httpd.8">httpd(8)</a></b>, and I will show you my version of it, which not differ much from the one in the <b><a href="https://cvsweb.openbsd.org/ports/www/nextcloud/pkg/README">README</a></b> file:</p>

<pre><code>$ doas cat /etc/httpd.conf
server &#34;cloud.x61.sh&#34; {
        listen on * tls port 443
        listen on * port 80

        location &#34;/.well-known/acme-challenge/*&#34; {
                root &#34;/acme&#34;
                request strip 2
        }

        root &#34;/nextcloud&#34;

        hsts max-age 15768000

        tls {
                certificate &#34;/etc/ssl/cloud.x61.sh.crt&#34;
                key &#34;/etc/ssl/private/cloud.x61.sh.key&#34;
        }

        # Set max upload size
        connection max request body 537919488
        connection max requests 1000
        connection request timeout 3600
        connection timeout 3600
        tcp nodelay

        gzip-static

        # First deny access to the specified files
        location &#34;/db_structure.xml&#34;            { block }
        location &#34;/README&#34;                      { block }
        location &#34;/config*&#34;                     { block }
        location &#34;/build*&#34;                      { block }
        location &#34;/tests*&#34;                      { block }
        location &#34;/lib*&#34;                        { block }
        location &#34;/3rdparty*&#34;                   { block }
        location &#34;/templates*&#34;                  { block }
        location &#34;/data*&#34;                       { block }
        location &#34;/.ht*&#34;                        { block }
        location &#34;/.user*&#34;                      { block }
        location &#34;/autotest*&#34;                   { block }
        location &#34;/occ*&#34;                        { block }
        location &#34;/issue*&#34;                      { block }
        location &#34;/indie*&#34;                      { block }
        location &#34;/db_*&#34;                        { block }
        location &#34;/console*&#34;                    { block }

        location &#34;/core/*&#34; {
                gzip-static
                pass                                                                                      
        }

        location &#34;/apps/*&#34; {
                gzip-static
                pass
        }

        location &#34;/dist/*&#34; {
                gzip-static
                pass
        }

        location &#34;/.well-known/carddav&#34; {
                block return 301 &#34;/remote.php/dav/&#34;
        }

        location &#34;/.well-known/caldav&#34; {
                block return 301 &#34;/remote.php/dav/&#34;
        }

        location match &#34;/oc[ms]%-provider/*&#34; {
                directory index index.php
                pass
        }

        location &#34;/.well-known/webfinger&#34; {
                block return 301 &#34;/index.php$REQUEST_URI&#34;
        }

        location &#34;/.well-known/nodeinfo&#34; {
                block return 301 &#34;/index.php$REQUEST_URI&#34;
        }
 
        location &#34;/.well-known/host-meta&#34; {
                block return 301 &#34;/public.php?service=host-meta&#34;
        }

        location &#34;/.well-known/host-meta.json&#34; {
                block return 301 &#34;/public.php?service=host-meta-json&#34;
        }

        location &#34;/*.php*&#34; {
                fastcgi socket &#34;/run/php-fpm.sock&#34;
        }
}</code></pre>

<h2>:. Nextcloud config.php</h2>

<p>For the DB I use <b><a stiyle="font-weight: bold;" href="https://www.postgresql.org/">postgresql</a></b> and <b><a href="https://redis.io//">redis</a></b> as in-memory data store, I have no special setup for those more than the one on their READMEs, so I will move to the <b>&#34;/var/www/nextcloud/config/config.php&#34;</b> file of my <b><a href="https://nextcloud.com">nextcloud</a></b> setup, I will breakdown the important parts that are not there by default:</p>

<pre><code>...
  &#39;trusted_domains&#39; =&gt; 
  array (
    0 =&gt; &#39;10.10.0.9&#39;,
    1 =&gt; &#39;cloud.x61.sh&#39;,
  ),
  &#39;trusted_proxies&#39; =&gt;
  array (
    0 =&gt; &#39;10.10.0.1&#39;,
    1 =&gt; &#39;10.10.0.9&#39;,
    2 =&gt; &#39;127.0.0.1&#39;,
  ),
...</code></pre>

<p><b>&#34;trusted_domains&#34;</b> and <b>&#34;trusted_proxies&#34;</b>, are just that, those domains, IPs or proxies that <b><a href="https://nextcloud.com">nextcloud</a></b> will mark as safe for your instance, I have an internal IP for my local network and the public domain, as I have the proxy/ies in front of my <b><a href="https://nextcloud.com">nextcloud</a></b> to try different things, you probably don&#39;t need this last one.</p>

<pre><code>...
  &#39;overwriteprotocol&#39; =&gt; &#39;https&#39;,
  &#39;memcache.local&#39; =&gt; &#39;\\OC\\Memcache\\Redis&#39;,
  &#39;memcache.locking&#39; =&gt; &#39;\\OC\\Memcache\\Redis&#39;,
  &#39;redis&#39; =&gt; 
  array (
    &#39;host&#39; =&gt; &#39;127.0.0.1&#39;,
    &#39;port&#39; =&gt; 6379,
    &#39;timeout&#39; =&gt; 1.5,
  ),
...</code></pre>

<p><b>&#34;overwriteprotocol&#34;</b> so let&#39;s make it always go over <b>&#34;https&#34;</b> specially if you have it facing the interwebz, at home in a local network, well, maybe you can use <b>&#34;http&#34;</b> but why?. The next options are for our cache (<b><a href="https://docs.nextcloud.com/server/19/admin_manual/configuration_server/caching_configuration.html">nextcloud cache</a></b>), remember that we installed <b><a href="https://redis.io//">redis</a></b> and you followed the README to make it work, so now that you have it listening on the default port in &#34;127.0.0.1&#34; you can add it to your conf.</p>

<pre><code>...
  &#39;filesystem_check_changes&#39; =&gt; 1,
...</code></pre>

<p><b>&#34;filesystem_check_changes&#34;</b> as <b><a href="https://docs.nextcloud.com/server/latest/admin_manual/configuration_server/config_sample_php_parameters.html">config_sample_php_parameters</a></b> explains this option specifies how often the local filesystem (the Nextcloud data/ directory, and NFS mounts in data/) is checked for changes made outside Nextcloud, I have it enable since my <b>&#34;files&#34;</b> in <b><a href="https://nextcloud.com">nextcloud</a></b> reside in a crypto partition on another disk, you might not need it in a different setup but remember that if you &#34;scp&#34; or copy raw files from some drive to the <b>&#34;nextcloud-data&#34;</b> directory inside your user on the instance without uploaded them over the page, <b><a href="https://nextcloud.com">nextcloud</a></b> won&#39;t see those files, so for those cases, you should enable <b>&#34;filesystem_check_changes&#34;</b>.</p>

<pre><code>...
  &#39;mail_from_address&#39; =&gt; &#39;cloud&#39;,
  &#39;mail_smtpmode&#39; =&gt; &#39;smtp&#39;,
  &#39;mail_smtpauthtype&#39; =&gt; &#39;PLAIN&#39;,
  &#39;mail_domain&#39; =&gt; &#39;cloud.x61.sh&#39;,
  &#39;mail_smtphost&#39; =&gt; &#39;127.0.0.1&#39;,
  &#39;mail_sendmailmode&#39; =&gt; &#39;smtp&#39;,
...</code></pre>

<p>These are pretty clear I believe, and yes, get emails with random information it&#39;s not cool, but I found those in this particular case important, since enabling the email notification you can get emails of modified files, login attempts, brute force attacks and many other things, I recommend to enable it, but it&#39;s not need it.</p>

<pre><code>...
  &#39;app_install_overwrite&#39; =&gt; 
  array (
    0 =&gt; &#39;calendar&#39;,
    1 =&gt; &#39;bruteforcesettings&#39;,
    2 =&gt; &#39;twofactor_yubikey&#39;,
    3 =&gt; &#39;twofactor_u2f&#39;,
    4 =&gt; &#39;side_menu&#39;,
    5 =&gt; &#39;impersonate&#39;,
    6 =&gt; &#39;duplicatefinder&#39;,
  ),
...</code></pre>

<p>Well this is not something you should have, but those are some of the <b><a href="https://apps.nextcloud.com/">apps</a></b> I use, in case you need it, a calendar (which is really useful for your android or ios phone to keep things in sync), bruteforcesettings blocks stupid attemps of login, twofactor_* are apps to use yubikey, solokeys or freeopt and have a 2fa, side_menu because I don&#39;t know who was the genious that created that awful default menu on top with all the titles together, impersonate which is useful to impersonate your mum user and re-arrange all the photos she has so then you can use the duplicatefinder to delete those 332 copies of the same photo she uploaded in different places.</p>

<pre><code>...
  &#39;maintenance&#39; =&gt; false,
);
...</code></pre>

<p>This is an important one, if your upgrade or installation went wrong for X reason and you cannot access again your instance, you should probably look at this flag, fix the issue and turn it into &#34;false&#34; again, for more options you should check: <b><a href="https://docs.nextcloud.com/server/latest/admin_manual/configuration_server/config_sample_php_parameters.html">config_sample_php_parameters</a></b>.</p>

<p>So far at this point, if you have the services up (db, php and <b><a href="https://man.openbsd.org/httpd.8">httpd(8)</a></b>) your <b><a href="https://nextcloud.com">nextcloud</a></b> should be running nicely, but what about those gzip on the <b><a href="https://man.openbsd.org/httpd.conf.5">httpd.conf(5)</a></b>? what about all the Content Security Policy (CSP) we need to make it secure? what about let&#39;s encrypt certs?</p>

<h2>:. Gzip</h2>

<p>Around OpenBSD 7.1, <b><a href="https://man.openbsd.org/httpd.8">httpd(8)</a></b> got the feature to serves pre-compressed files, so as you saw on the <b><a href="https://man.openbsd.org/httpd.conf.5">httpd.conf(5)</a></b> above we have something like this:</p>

<pre><code>...
        location &#34;/core/*&#34; {
                gzip-static
                pass
        }
...</code></pre>

<p>Exactly, there is where <b><a href="https://nextcloud.com">nextcloud</a></b> has a lot of huge .js and .css files, so why not &#34;gzip&#34; them to make them go faaaaaster? After every update I usually run something similar to this:</p>

<pre><code># find /var/www/nextcloud \( -name &#34;*.js&#34; -o -name &#34;*.css&#34; \) -size +100000c -exec gzip -f -k &#34;{}&#34; \;</code></pre>

<p>If you check on those files now, you will see that are .gz and you will notice some speed up on your instance.</p>

<h2>:. Nextcloud updates</h2>

<p>To keep <b><a href="https://nextcloud.com">nextcloud</a></b> package up-to-date on <b>OpenBSD</b> we just need to run <b>pkg_add -Vu</b> on -release and <b>pkg_add -Vu -Dsnap</b> on -current, these will upgrade your <b>Nextcloud&#39;s files</b>, and then we need to upgrade the db and other things inside of it, you have 2 ways to do this; over the browser opening your domain it will guide you through the process or you can use the <b><a href="https://docs.nextcloud.com/server/stable/admin_manual/configuration_server/occ_command.html">occ command</a></b>. On <b>OpenBSD</b> we have <b><a href="https://man.openbsd.org/chroot.2">chroot(2)</a></b> and our <b><a href="https://man.openbsd.org/httpd.8">httpd(8)</a></b> is working under it, so to update the instance with the command line we should do something like:</p>

<pre><code>$ doas -u www /usr/local/bin/php-8.1 /var/www/nextcloud/occ upgrade</code></pre>

<p>This will manage the whole update and get the instance ready to use with the new version, if you are gziping *.js and *.css files you should re-run the find line to compress the new ones.</p>

<h2>:. Relayd CSP and Certs</h2>

<p>Let&#39;s put some other layer of security by adding some <b><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP">CSP</a></b> headers, if you don&#39;t know what they are, follow the previous link, you will have plenty of details there. <b><a href="https://man.openbsd.org/httpd.8">httpd(8)</a></b> has no way to add headers itself so to give it some help I will put <b><a href="https://man.openbsd.org/relayd.8">relayd(8)</a></b> in front of it and play around with headers and the certificate for our <b><a href="https://nextcloud.com">nextcloud</a></b>.</p>

<p>Yes, I specified my certificates in our <b><a href="https://man.openbsd.org/httpd.conf.5">httpd.conf(5)</a></b> because after created them over <b><a href="https://man.openbsd.org/relayd.8">relayd(8)</a></b> I scp them to the cloud server, just in case, but you don&#39;t need it, <b><a href="https://man.openbsd.org/relayd.8">relayd(8)</a></b> will manage them for you, anyway it is the right conf for people without using <b><a href="https://man.openbsd.org/relayd.8">relayd(8)</a></b> on front.</p>

<p><b><a href="https://man.openbsd.org/relayd.8">relayd(8)</a></b> as the man says: <b>is a daemon to relay and dynamically redirect incoming connections to a target host.  Its main purposes are to run as a load-balancer, application layer gateway, or transparent proxy</b>, and that is what we gonna do, I will show my <b><a href="https://man.openbsd.org/relayd.conf.5">relayd.con(5)</a></b> and explain a bit parts of it as example:</p>

<pre><code>table  &lt;honk&gt;    { 10.10.0.7 }
table  &lt;matrix&gt;  { 10.10.0.8 }
table  &lt;certs&gt;   { 127.0.0.1 }
table  &lt;cloud&gt;   { 10.10.0.9 }

log state changes
log connection

http protocol &#34;http&#34; {
  block

  match header set &#34;X-Client-IP&#34; value &#34;$REMOTE_ADDR:$REMOTE_PORT&#34;
  match header set &#34;X-Forwarded-For&#34; value &#34;$REMOTE_ADDR&#34;
  match request header set &#34;X-Forwarded-Port&#34; value &#34;$REMOTE_PORT&#34;
  match header set &#34;X-Forwarded-By&#34; value &#34;$SERVER_ADDR:$SERVER_PORT&#34;
  match header set &#34;Keep-Alive&#34; value &#34;$TIMEOUT&#34;
  match query hash &#34;sessid&#34;

  match response header remove &#34;Server&#34;
  match response header set &#34;X-Robots-Tag&#34; value &#34;none&#34;
  match response header set &#34;Permissions-Policy&#34; value &#34;interest-cohort=()&#34;
  match response header set &#34;Cache-Control&#34; value &#34;public, no-cache, must-revalidate, max-age=1814400&#34;
  match response header set &#34;Strict-Transport-Security&#34; value &#34;max-age=31536000; includeSubDomains; preload&#34;
  match response header set &#34;X-Content-Type-Options&#34; value &#34;nosniff&#34;
  match response header set &#34;X-XSS-Protection&#34; value &#34;1; mode=block&#34;
  match response header set &#34;Referrer-Policy&#34; value &#34;no-referrer&#34;
  match response header set &#34;Permissions-Policy&#34; value &#34;autoplay &#39;self&#39;; geolocation &#39;none&#39;;payment &#39;none&#39;&#34;
  match response header set &#34;Content-Security-Policy&#34; value &#34;default-src https:; style-src &#39;self&#39; &#39;unsafe-inline&#39;;img-src &#39;self&#39; data: blob:; script-src &#39;self&#39; &#39;unsafe-inline&#39; &#39;unsafe-eval&#39;;object-src &#39;self&#39;; frame-ancestors &#39;self&#39;;base-uri &#39;self&#39;;connect-src &#39;self&#39;;media-src &#39;self&#39;; manifest-src &#39;self&#39;;font-src &#39;self&#39; data:;worker-src &#39;self&#39; blob:;form-action &#39;self&#39;;&#34;

  match request quick path &#34;/.well-known/acme-challenge/*&#34; tag &#34;certs&#34;
  pass request quick tagged &#34;certs&#34; forward to &lt;certs&gt;

  match request quick header &#34;Host&#34; value &#34;cloud.x61.sh&#34; tag &#34;cloud&#34;
  pass request quick tagged &#34;cloud&#34; forward to &lt;cloud&gt;

  match request quick header &#34;Host&#34; value &#34;honk.x61.sh&#34; tag &#34;honk&#34;
  pass request quick tagged &#34;honk&#34; forward to &lt;honk&gt;

  match request quick header &#34;Host&#34; value &#34;m.x61.sh&#34; tag &#34;matrix&#34;
  match request quick path &#34;/_matrix/*&#34; tag &#34;matrix&#34;
  pass request quick tagged &#34;matrix&#34; forward to &lt;matrix&gt;

  tls keypair &#34;m.x61.sh&#34;
  tls keypair &#34;honk.x61.sh&#34;
  tls keypair &#34;cloud.x61.sh&#34;

  tls { no tlsv1.0, ciphers &#34;HIGH&#34; }
  tls ciphers &#34;ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256&#34;
  tcp { nodelay, socket buffer 65536, backlog 100 }
}

relay &#34;https&#34; {
  listen on egress port 443 tls
  listen on egress port 80

  protocol &#34;http&#34;

  forward to &lt;honk&gt; port 31337 check tcp
  forward to &lt;matrix&gt; port 8448 check tcp
  forward to &lt;certs&gt; port 3080 check tcp
  forward to &lt;cloud&gt; port 80 check tcp
}</code></pre>

<p>On the top of the file you will see my tables with their IPs for each services behind my <b>relayd</b>, if you read my other articles you will remember those. We &#34;log&#34; connections and state changes, then the fun part starts where we define a &#34;http protocol&#34; called &#34;http&#34; (you can set any name here), to manage all our http connections and add what we need for our setup, in this case headers.</p>

<pre><code>...
match header set &#34;X-Client-IP&#34; value &#34;$REMOTE_ADDR:$REMOTE_PORT&#34;
match header set &#34;X-Forwarded-For&#34; value &#34;$REMOTE_ADDR&#34;
match request header set &#34;X-Forwarded-Port&#34; value &#34;$REMOTE_PORT&#34;
match header set &#34;X-Forwarded-By&#34; value &#34;$SERVER_ADDR:$SERVER_PORT&#34;
match header set &#34;Keep-Alive&#34; value &#34;$TIMEOUT&#34;
match query hash &#34;sessid&#34;
...</code></pre>

<p>Here we tell to <b>relayd</b> (our reverse proxy) to use X-Forwarded-For and X-Forwarded-By in the connections it passes to <b>httpd</b> (honk, certs and cloud) without those you will not see any entries in your access log (and for this you will need &#34;log style forwarded&#34; in your httpd.conf from above), we also set the &#34;Keep-Alive&#34; header and &#34;sessid&#34;.</p>

<pre><code>...
match response header remove &#34;Server&#34;
match response header set &#34;X-Robots-Tag&#34; value &#34;none&#34;
match response header set &#34;Permissions-Policy&#34; value &#34;interest-cohort=()&#34;
match response header set &#34;Cache-Control&#34; value &#34;public, no-cache, must-revalidate, max-age=1814400&#34;
match response header set &#34;Strict-Transport-Security&#34; value &#34;max-age=31536000; includeSubDomains; preload&#34;
match response header set &#34;X-Content-Type-Options&#34; value &#34;nosniff&#34;
match response header set &#34;X-XSS-Protection&#34; value &#34;1; mode=block&#34;
match response header set &#34;Referrer-Policy&#34; value &#34;no-referrer&#34;
match response header set &#34;Permissions-Policy&#34; value &#34;autoplay &#39;self&#39;; geolocation &#39;none&#39;;payment &#39;none&#39;&#34;
match response header set &#34;Content-Security-Policy&#34; value &#34;default-src https:; style-src &#39;self&#39; &#39;unsafe-inline&#39;;img-src &#39;self&#39; data: blob:; script-src &#39;self&#39; &#39;unsafe-inline&#39; &#39;unsafe-eval&#39;;object-src &#39;self&#39;; frame-ancestors &#39;self&#39;;base-uri &#39;self&#39;;connect-src &#39;self&#39;;media-src &#39;self&#39;; manifest-src &#39;self&#39;;font-src &#39;self&#39; data:;worker-src &#39;self&#39; blob:;form-action &#39;self&#39;;&#34;
...</code></pre>

<p>Big long block now, all the headers that make <b><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP">CSP</a></b> happy. The syntax it&#39;s very simple, take a look at the <b><a href="https://man.openbsd.org/relayd.conf.5">manual</a></b>, but basically we &#34;match response&#34; from the manual &#34;the request, a client initiating a new connection to a server via the relay, and the response, the server accepting the connection.&#34; then we &#34;set header&#34; to our needs depending of what we want, in this case a bunch of them are for <b><a href="https://nextcloud.com">nextcloud</a></b> in particular but the rest are for example to provide a layer to mitigate XSS attacks by restricting which scripts can be executed by the page. There are tons of different ones, and depends on what are you trying to do or which kind of software your website is using you will need to adjust accordingly to it, another good site to look at all the variations is <b><a href="https://web.dev/security-headers/">this one</a></b>.</p>

<pre><code>...
match request quick path &#34;/.well-known/acme-challenge/*&#34; tag &#34;certs&#34;
pass request quick tagged &#34;certs&#34; forward to <certs>
...</certs></code></pre>

<p>I will explain this chunk first but the rest following are kinda the same. To get <b><a href="https://man.openbsd.org/acme-client">acme-client</a></b> to find the &#34;/.well-known/acme-challenge/&#34; for all our sites behind, we need to tell <b>relayd</b> what to do when a http request ask for &#34;/.well-known/acme-challenge/*&#34;. For this I have in my 127.0.0.1 machine an <b>httpd</b> running just to serve the certificate directories, the <b>httpd.conf</b> looks like this:</p>

<pre><code>server &#34;foobar.x61.sh&#34; {
  listen on 127.0.0.1 port 3080

  alias &#34;honk.x61.sh&#34;
  alias &#34;m.x61.sh&#34;
  alias &#34;cloud.x61.sh&#34;

  location &#34;/.well-known/acme-challenge/*&#34; {
     root &#34;/acme&#34;
     request strip 2
  }

  log { access &#34;certs-httpd.log&#34;, style combined }

  root &#34;/htdocs&#34;
}
</code></pre>

<p>The <b><a href="https://man.openbsd.org/acme-client">acme-client</a></b> will try to renew or generate a certificate of oursites it will ask our DNS, it will hit our public IP through <b>relayd</b> it will match the &#34;certs&#34; rule and it will send the request to the local <b>httpd</b> above, the certificate will be generate or renew in the same server and ready to use by <b>relayd</b> (remember to reload it after it) by the next piece of code:</p>

<pre><code>...
tls keypair &#34;m.x61.sh&#34;
tls keypair &#34;honk.x61.sh&#34;
tls keypair &#34;cloud.x61.sh&#34;

tls { no tlsv1.0, ciphers &#34;HIGH&#34; }
tls ciphers &#34;ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256&#34;
...</code></pre>

<p>At the bottom of it we disable a weak tls version and set most secure ciphers. The final part, the relay, which will forward traffic between a client and a target server.</p>

<pre><code>...
relay &#34;https&#34; {
  listen on egress port 443 tls
  listen on egress port 80

  protocol &#34;http&#34;

  forward to &lt;honk&gt; port 31337 check tcp
  forward to &lt;matrix&gt; port 8448 check tcp
  forward to &lt;certs&gt; port 3080 check tcp
  forward to &lt;cloud&gt; port 80 check tcp
}
...</code></pre>

<p>Our relay is called &#34;https&#34; it will listen on &#34;egress&#34; ports 80 and 443, of course we will use the protocol &#34;http&#34; created previusly. The requests over this relay to each one of the previous matches tagged will be forwarded to the right table over the set port. The forward like will check constantly the port of that server to make sure that it&#39;s alive and working, so for example for the <cloud> line, <b>relayd</b> will check the port 80 (by tcp) of the IP 10.10.0.9 in the table <cloud>, if it&#39;s alive the request to &#34;cloud.x61.sh&#34; will end up in the right place. Can we check the health of these hosts? Sure:</cloud></cloud></p>

<pre><code># relayctl show hosts
Id   Type            Name                     Avlblty Status
1    table           cloud:80                        active (1 hosts)
1    host            10.10.0.9                100.00% up
                     total: 252/252 checks
2    table           honk:31337                      active (1 hosts)
2    host            10.10.0.7                100.00% up
                     total: 252/252 checks
3    table           certs:3080                      active (1 hosts)
3    host            127.0.0.1                100.00% up
                     total: 252/252 checks
4    table           matrix:8448                     active (1 hosts)
4    host            10.10.0.8                100.00% up
                     total: 252/252 checks
</code></pre>

<pre><code># relayctl show relays
Id      Type            Name                            Avlblty Status
1       relay           https                                   active
                        total: 109 sessions
                        last: 1/60s 109/h 109/d sessions
                        average: 2/60s 0/h 0/d sessions
2       relay           https2:80                               active
                        total: 7 sessions
                        last: 0/60s 7/h 7/d sessions
                        average: 0/60s 0/h 0/d sessions
</code></pre>

<p>That&#39;s all, now you have <b>relayd</b> in front of your cloud managing headers and certs, let&#39;s do a fast configtest and enable it on boot time:</p>

<pre><code># relayd -nf /etc/relayd.conf                                                                                                                      
configuration OK
# rcctl enable relayd
# rcctl start relayd
relayd(ok)
</code></pre>

<p>Now you are in trend with your own cloud. If you want to try your headers, you can use <b><a href="https://securityheaders.com/">this site</a></b> or <b><a href="https://internet.nl">this one</a></b>. Have fun!.</p>
			<hr/>
			
			</div></div>
  </body>
</html>
