<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wordsandbuttons.online/a_smooth_and_sharp_image_interpolation.html">Original</a>
    <h1>A smooth and sharp image interpolation you probably haven&#39;t heard of</h1>
    
    <div id="readability-page-1" class="page"><div>
	<p>This is <a href="https://wordsandbuttons.online/index.html">Words and Buttons Online</a> — a collection of interactive <a href="https://wordsandbuttons.online/all_tutorials.html">#tutorials</a>, <a href="https://wordsandbuttons.online/all_demos.html">#demos</a><a>, and </a><a href="https://wordsandbuttons.online/all_quizzes.html">#quizzes</a> about <a href="https://wordsandbuttons.online/all_mathematics.html">#mathematics</a>, <a href="https://wordsandbuttons.online/all_algorithms.html">#algorithms</a> and <a href="https://wordsandbuttons.online/all_programming.html">#programming</a>.</p>
	
	<p>
Image interpolation is guessing pixels between pixels. You can go without, but then when you upscale your image or do any other image transformation, you&#39;ll see square pixels.
	</p>
	<p>
Here is the image to play with. The thing is interactive, you can control the frame with your mouse or your fingers.
	</p>
	
	<p>
And here are the square pixels.
	</p>
	<canvas id="canvas_i0" width="640" height="512"></canvas>
	<p>
You can make the picture nice and smooth by employing an image interpolation. 
	</p>
	<p>
Common interpolations for that are bilinear and bicubic. (see <a href="https://wordsandbuttons.online/biwhatever_transformations.html">Bi-whatever transformations</a>) The downside of the bilinear one is that it makes your image continuous, so no squares, but not smooth, so the upscale still looks unnatural. The downside of bicubic interpolation is that, while it does give you a nice and smooth picture, it smudges the thing a little so sharp features 1 pixel wide appear to be 3 pixels wide after the interpolation.
	</p>
	<p>
Here is another interpolation you probably haven&#39;t heard about before.
	</p><p>
This is an inverse weight interpolation, a close relative of a <a href="https://wordsandbuttons.online/swine_simplicial_weight_interpolation_and_extrapolation.html">SWInE</a>, not to be confused with &#34;<a href="https://wordsandbuttons.online/programmers_guide_to_polynomials_and_splines.html">spline</a>&#34;. The whole inverse weight family is not highly popular partially due to its computational issues, and partially, because their localization for spatial applications is tricky. But here, for the image interpolation, the localization is not tricky at all. 
	</p>
	<p>
Let&#39;s start with a simple 1D case. We have a pair of values and we want to interpolate between them.
	</p>
	<p>
F(x<sub>1</sub>) = y<sub>1</sub>
</p>
	<p>
Let&#39;s define the interpolating function as a weighted sum of values divided by the sum of weights, where each weight is the inverse square of the x-axis distance between the data point we have and the interpolating function argument.
	</p>
	<table>
	<tbody><tr>
	<td rowspan="2">
	∀ x, x<sub>i</sub> &lt; x &lt; x<sub>i+1</sub>   F(x) =  
	</td>
	<td>
	y<sub>i</sub> * k(x - x<sub>i</sub>) + y<sub>i+1</sub> * k(x<sub>i+1</sub> - x)
	</td>
	</tr>
	<tr>
	<td>
	k(x - x<sub>i</sub>) + k(x<sub>i+1</sub> - x)
	</td>
	</tr>
	</tbody></table>
	
	<p>
You probably noticed that when the argument coincides with one of the data points, we have a division by zero, so the formula doesn&#39;t work. Well, in the ideal world, it&#39;s okay, we do have a value for every data point anyway. We can join or values outside or on the data points with the interpolation function from within.
	</p>
	<p>
F(x<sub>i</sub>) = y<sub>i</sub>
	</p>
	<p>
In the real world, there are computationally problematic areas near the data points. Which would have been bad, but image interpolation is an inherently inaccurate problem to begin with. You have to guess color values in the 0..255 discrete range, so any computational error below 1/512 doesn&#39;t bother you at all.
	</p>
	<canvas id="canvas2d1" width="640" height="640"></canvas>

	<p>
Now, for the image interpolation, the data points are, of course, 2-dimensional.
	</p>
	<p>
F(x<sub>j</sub>, y<sub>i</sub>) = z<sub>ij</sub>
	</p>
	<p>
And the formula is larger.
	</p>
	<table>
	<tbody><tr>
	<td rowspan="2">
	F(x) =  
	</td>
	<td>
	z<sub>ij</sub> k(x - x<sub>j</sub>) k(y - y<sub>i</sub>) + z<sub>i(j+1)</sub> k(x<sub>j+1</sub> - x) k(y - y<sub>i</sub>) +
	z<sub>(i+1)j</sub> k(x - x<sub>j</sub>) k(y<sub>i+1</sub> - y) + z<sub>(i+1)(j+1)</sub> k(x<sub>j+1</sub> - x) k(y<sub>i+1</sub> - y)
	</td>
	</tr>
	<tr>
	<td>
	k(x - x<sub>j</sub>) k(y - y<sub>i</sub>) + k(x<sub>j+1</sub> - x) k(y - y<sub>i</sub>) +
	k(x - x<sub>j</sub>) k(y<sub>i+1</sub> - y) + k(x<sub>j+1</sub> - x) k(y<sub>i+1</sub> - y)
	</td>
	</tr>
	</tbody></table>
	<p>
We don&#39;t have to keep the inverse distance squared. We can chose any degree, the interpolation will still work. For this particular case, even simple inverse (power 1) will suffice.
	</p>
	
	<p>
But, generally, it&#39;s the same formula. The sum of weighted values divided by the sum of weights. The only non-obvious generalization here is that the weights for each axis contribute via a product and not a sum or anything else.
	</p>
	<p>
This interpolation gives us a continuous and smooth image, where every interpolated value only depends on the four neighboring pixel values. The image becomes smooth, but sharp features remain sharp.
	</p>

	


	
	</div></div>
  </body>
</html>
