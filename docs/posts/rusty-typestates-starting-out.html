<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rustype.github.io/notes/notes/rust-typestate-series/rust-typestate-part-1.html">Original</a>
    <h1>Rusty Typestates – Starting Out</h1>
    
    <div id="readability-page-1" class="page"><div>
      
      
      

      




<blockquote>
  <p>This post is part of a series, you can see an overview of the whole series in [<a href="https://rustype.github.io/notes/notes/rust-typestate-series/rust-typestate-index" title="Rusty Typestates">rust-typestate-index</a>].</p>
</blockquote>

<h2 id="introduction">Introduction</h2>

<p>In the present days, as systems become more complex, with more moving parts,
being able to ensure that each part cooperates in unison is extremely important.</p>

<p>One of the key ideas from the last years of PL research revolves around making our type-systems smarter,
moving reasoning from the programmer to the compiler.
Rust’s borrow checker is a prime example of this, for those which are not familiar,
in a simple manner, Rust is able to reason about memory usage,
ditching manual memory management and garbage collectors.</p>

<h2 id="behavioral-types">Behavioral Types</h2>

<p>In the same research lineage, we find behavioral types,
these are meant to describe the behavior of the program,
rather than just the types of data moving around the program.</p>

<p>Further along the road, there are two main topics,
typestates and session types, for now I focus solely on typestates.</p>

<h2 id="typestates">Typestates</h2>

<p>Typestates are the idea that types should describe the state of the program,
they can be described as finite state machines, making them easy to verify,
they also provide “call-safety”, that is, when using typestates,
if a method is called, the program is in a state which allows so.</p>

<p>For example, consider Java’s <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html"><code>Scanner</code></a>,
nothing stops you from writing the following code:</p>

<div><div><pre><code><span>Scanner</span> <span>s</span> <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>System</span><span>.</span><span>in</span><span>);</span>
<span>s</span><span>.</span><span>close</span><span>();</span>
<span>s</span><span>.</span><span>nextLine</span><span>();</span>
</code></pre></div></div>

<p>Resulting in a <code>IllegalStateException</code>,
we should be able to do better, that is,
after calling close there should be no doubt that trying to read from the <code>Scanner</code> is an error.
Some IDEs might warn you, but not everyone uses an IDE, neither every language has one.</p>

<p>To do better we can use typestates!
If Java had typestates the above example could look like:</p>

<div><div><pre><code><span>Scanner</span><span>&lt;</span><span>Open</span><span>&gt;</span> <span>sOpen</span> <span>=</span> <span>Scanner</span><span>(</span><span>System</span><span>.</span><span>in</span><span>);</span>
<span>// `sOpen.close()` consumes the original `sOpen` and returns a new Scanner</span>
<span>Scanner</span><span>&lt;</span><span>Closed</span><span>&gt;</span> <span>sClosed</span> <span>=</span> <span>sOpen</span><span>.</span><span>close</span><span>();</span>
<span>sClosed</span><span>.</span><span>nextLine</span><span>();</span> <span>// Type error, Scanner&lt;Closed&gt; does not implement `nextLine`</span>
</code></pre></div></div>

<p>Before we move on, it is important to note that typestates require aliasing control,
that is, if we have aliases to <code>sOpen</code> we cannot ensure someone else does not call <code>nextLine</code>.
We are required to consume <code>sOpen</code> when <code>close</code> is called,
while Java is unable to provide this mechanism, Rust is.</p>

<h2 id="typestates-in-rust">Typestates in Rust</h2>

<p>Using Rust we will be implementing something more complex than a <code>Open</code>/<code>Closed</code> switch,
the following example is taken from the paper <a href="https://arxiv.org/pdf/2009.08769.pdf">“Typestates to Automata and back: a tool”</a>.</p>



<p>We have a <code>Drone</code> which can be in three states:</p>
<ul>
  <li><code>Idle</code> — the drone is on the ground.</li>
  <li><code>Hovering</code> — the drone is stopped mid-air.</li>
  <li><code>Flying</code> — the drone is flying from a place to another.</li>
</ul>

<p>Possible transitions are:</p>
<ul>
  <li>From <code>Idle</code> to <code>Hovering</code>, through the <code>take_off</code> method.</li>
  <li>From <code>Hovering</code> to <code>Idle</code>, through the <code>land</code> method.</li>
  <li>From <code>Hovering</code> to <code>Flying</code>, during <code>move_to</code> flight from a place to another.</li>
  <li>From <code>Flying</code> to <code>Hovering</code>, after the <code>move_to</code> method.</li>
</ul>

<p>We can start by defining our <code>Drone</code> and the possible states:</p>

<div><div><pre><code><span>struct</span> <span>Idle</span><span>;</span>
<span>struct</span> <span>Hovering</span><span>;</span>
<span>struct</span> <span>Flying</span><span>;</span>
<span>struct</span> <span>Drone</span><span>&lt;</span><span>State</span><span>&gt;</span> <span>{</span>
    <span>x</span><span>:</span> <span>f32</span><span>,</span>
    <span>y</span><span>:</span> <span>f32</span><span>,</span>
    <span>state</span><span>:</span> <span>PhantomData</span><span>&lt;</span><span>State</span><span>&gt;</span><span>,</span>
<span>}</span>
</code></pre></div></div>

<p>We now need to implement <code>Drone&lt;State&gt;</code> for each of our states:</p>

<div><div><pre><code><span>impl</span> <span>Drone</span><span>&lt;</span><span>Idle</span><span>&gt;</span> <span>{</span>
    <span>pub</span> <span>fn</span> <span>new</span><span>()</span> <span>-&gt;</span> <span>Self</span> <span>{</span>
        <span>Self</span> <span>{</span>
            <span>x</span><span>:</span> <span>0.0</span><span>,</span>
            <span>y</span><span>:</span> <span>0.0</span><span>,</span>
            <span>state</span><span>:</span> <span>PhantomData</span><span>,</span>
        <span>}</span>
    <span>}</span>

    <span>pub</span> <span>fn</span> <span>take_off</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>Drone</span><span>&lt;</span><span>Hovering</span><span>&gt;</span> <span>{</span>
        <span>Drone</span><span>::</span><span>&lt;</span><span>Hovering</span><span>&gt;</span><span>::</span><span>from</span><span>(</span><span>self</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>impl</span> <span>Drone</span><span>&lt;</span><span>Hovering</span><span>&gt;</span> <span>{</span>
    <span>fn</span> <span>land</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>Drone</span><span>&lt;</span><span>Idle</span><span>&gt;</span> <span>{</span>
        <span>Drone</span><span>::</span><span>&lt;</span><span>Idle</span><span>&gt;</span><span>::</span><span>new</span><span>()</span>
    <span>}</span>

    <span>fn</span> <span>move_to</span><span>(</span><span>self</span><span>,</span> <span>x</span><span>:</span> <span>f32</span><span>,</span> <span>y</span><span>:</span> <span>f32</span><span>)</span> <span>-&gt;</span> <span>Drone</span><span>&lt;</span><span>Hovering</span><span>&gt;</span> <span>{</span>
        <span>let</span> <span>drone</span> <span>=</span> <span>Drone</span><span>::</span><span>&lt;</span><span>Flying</span><span>&gt;</span><span>::</span><span>from</span><span>(</span><span>self</span><span>);</span>
        <span>drone</span><span>.fly</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>impl</span> <span>Drone</span><span>&lt;</span><span>Flying</span><span>&gt;</span> <span>{</span>
    <span>fn</span> <span>fly</span><span>(</span><span>mut</span> <span>self</span><span>,</span> <span>x</span><span>:</span> <span>f32</span><span>,</span> <span>y</span><span>:</span> <span>f32</span><span>)</span> <span>-&gt;</span> <span>Drone</span><span>&lt;</span><span>Hovering</span><span>&gt;</span> <span>{</span>
        <span>self</span><span>.x</span> <span>=</span> <span>x</span><span>;</span>
        <span>self</span><span>.y</span> <span>=</span> <span>y</span><span>;</span>
        <span>Drone</span><span>::</span><span>&lt;</span><span>Hovering</span><span>&gt;</span><span>::</span><span>from</span><span>(</span><span>self</span><span>)</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>Notice that methods consume the structure by using <code>self</code> instead of <code>&amp;self</code>,
this enables aliasing control, guaranteeing that instances are not reused.
Another important note is the reason behind <code>move_to</code> consuming <code>self</code> rather than <code>&amp;self</code>,
since the input and output types match we should be able to simply use the reference and return <code>()</code>.
Given that the typestate is changed from <code>Hovering</code> to <code>Flying</code> and back during <code>move_to</code>,
<code>self</code> must be consumed.</p>

<blockquote>
  <p>The <code>From</code> implementations were left out since they are simple assignments from the old structure to the new one.</p>
</blockquote>

<p>Now we are able to safely fly our drone:</p>

<div><div><pre><code><span>fn</span> <span>drone_flies</span><span>()</span> <span>{</span>
    <span>let</span> <span>drone</span> <span>=</span> <span>Drone</span><span>::</span><span>&lt;</span><span>Idle</span><span>&gt;</span><span>::</span><span>new</span><span>()</span> <span>// Drone&lt;Idle&gt;</span>
        <span>.take_off</span><span>()</span>                  <span>// Drone&lt;Hovering&gt;</span>
        <span>.move_to</span><span>(</span><span>-</span><span>5.0</span><span>,</span> <span>-</span><span>5.0</span><span>)</span>         <span>// =&gt; Drone&lt;Flying&gt; =&gt; Drone&lt;Hovering&gt;</span>
        <span>.land</span><span>();</span>                     <span>// Drone&lt;Idle&gt;</span>
    <span>assert_eq!</span><span>(</span><span>drone</span><span>.x</span><span>,</span> <span>-</span><span>5.0</span><span>);</span>
    <span>assert_eq!</span><span>(</span><span>drone</span><span>.y</span><span>,</span> <span>-</span><span>5.0</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>If we try to fly our drone before <code>take_off</code> or land our drone twice the compiler will correctly point out that the method is not implemented, as seen in the following example:</p>

<div><div><pre><code><span>fn</span> <span>drone_does_not_fly_idle</span><span>()</span> <span>{</span>
    <span>let</span> <span>drone</span> <span>=</span> <span>Drone</span><span>::</span><span>&lt;</span><span>Idle</span><span>&gt;</span><span>::</span><span>new</span><span>();</span>
    <span>drone</span><span>.move_to</span><span>(</span><span>10.0</span><span>,</span> <span>10.0</span><span>);</span> <span>// comptime error: &#34;move_to&#34; is not a member of type Idle</span>
<span>}</span>
</code></pre></div></div>

<div><div><pre><code>error[E0599]: no method named `move_to` found for struct `drone::Drone&lt;drone::Idle&gt;` in the current scope
   --&gt; src/drone.rs:128:15
    |
4   | / pub struct Drone&lt;State&gt;
5   | | where
6   | |     State: DroneState,
7   | | {
...   |
10  | |     state: PhantomData&lt;State&gt;,
11  | | }
    | |_- method `move_to` not found for this
...
128 |           drone.move_to(10.0, 10.0);
    |                 ^^^^^^^ method not found in `drone::Drone&lt;drone::Idle&gt;`
</code></pre></div></div>

<h2 id="improvements">Improvements</h2>

<h3 id="stricter-states">Stricter States</h3>

<p>There still are some possible improvements to be made, as it stands, any type can implement <code>Drone&lt;State&gt;</code>,
to provide more security, to avoid someone implementing <code>Drone&lt;NotAState&gt;</code> we can bind <code>State</code> with a <code>trait</code>:</p>

<div><div><pre><code><span>trait</span> <span>DroneState</span> <span>{}</span>

<span>struct</span> <span>Drone</span><span>&lt;</span><span>State</span><span>&gt;</span> <span>where</span> <span>State</span><span>:</span> <span>DroneState</span> <span>{</span> <span>...</span> <span>}</span>
</code></pre></div></div>

<p>Now, if we try to implement <code>NotAState</code> we get a compiler error:</p>

<div><div><pre><code>error[E0277]: the trait bound `drone::NotAState: drone::DroneState` is not satisfied
...
137 | impl Drone&lt;NotAState&gt; {}
    |      ^^^^^^^^^^^^^^^^^^^^ the trait `drone::DroneState` is not implemented for `drone::NotAState`
</code></pre></div></div>

<h3 id="even-stricter-states">Even Stricter States</h3>

<p>Stricter states grants us more security, however, we may have even stricter requirements!
Our previous implementation disallows states which do not implement <code>DroneState</code>,
but an outsider can still implement the trait for a custom state.</p>

<p>To disallow it, we can use <a href="https://rust-lang.github.io/api-guidelines/future-proofing.html#sealed-traits-protect-against-downstream-implementations-c-sealed">sealed traits</a>.</p>

<p>With sealed traits we create a <code>Sealed</code> trait, inside a local private module.
Then we implement it for our states, finalizing by adding a type bound to <code>DroneState</code>.
Since clients are not able to access the <code>Sealed</code> trait, they are not able to add more <code>DroneState</code>s:</p>

<div><div><pre><code><span>mod</span> <span>sealed</span> <span>{</span>
    <span>pub</span> <span>trait</span> <span>Sealed</span> <span>{}</span>
    <span>impl</span> <span>Sealed</span> <span>for</span> <span>super</span><span>::</span><span>Idle</span> <span>{}</span>
    <span>impl</span> <span>Sealed</span> <span>for</span> <span>super</span><span>::</span><span>Hovering</span> <span>{}</span>
    <span>impl</span> <span>Sealed</span> <span>for</span> <span>super</span><span>::</span><span>Flying</span> <span>{}</span>
<span>}</span>
<span>pub</span> <span>trait</span> <span>DroneState</span><span>:</span> <span>sealed</span><span>::</span><span>Sealed</span> <span>{}</span>
</code></pre></div></div>

<h3 id="adding-references">Adding References</h3>

<p>The attentive reader may have noticed that the consumption and conversion of <code>self</code> into other types implies the values are moved
(and in some cases, copied) around.
In modern hardware, the cost of these operations can be negligible, however typestates should be domain independent,
being available for use embedded systems and HPC clusters alike.</p>

<p>Furthermore, making the most out of hardware should be a constant concern as it allows programs to be more efficient,
saving resources which in turn equates in being able to run more software in the same machine, or electric savings.
An example would be PHP 7, which boasts impressive performance improvements when compared to version 5 (<a href="https://www.phoronix.com/scan.php?page=article&amp;item=php-74-benchmarks&amp;num=2">Phoronix</a>).</p>

<p>With this in mind we can improve our typestate implementation to allow for the use of references.
This improvement is based on the key takeaway that the drone state can be divided into two parts:
the internal state, consisting of the coordinates;
and the external state, represented by its physical state (<code>Idle</code>, <code>Hovering</code> or <code>Flying</code>).</p>

<p>Our changes begin by extracting the coordinates to a separate structure:</p>

<div><div><pre><code><span>pub</span> <span>struct</span> <span>Coordinates</span> <span>{</span>
    <span>x</span><span>:</span> <span>f32</span><span>,</span>
    <span>y</span><span>:</span> <span>f32</span><span>,</span>
<span>}</span>

<span>impl</span> <span>Coordinates</span> <span>{</span>
    <span>fn</span> <span>new</span><span>()</span> <span>-&gt;</span> <span>Self</span> <span>{</span>
        <span>Self</span> <span>{</span><span>x</span><span>:</span> <span>0</span><span>,</span> <span>y</span><span>:</span> <span>0</span><span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>In turn, this allows us to describe our <code>Drone</code> as:</p>

<div><div><pre><code><span>pub</span> <span>struct</span> <span>Drone</span><span>&lt;</span><span>&#39;coords</span><span>,</span> <span>State</span><span>&gt;</span>
<span>where</span>
    <span>State</span><span>:</span> <span>DroneState</span><span>,</span>
<span>{</span>
    <span>coordinates</span><span>:</span> <span>&amp;</span><span>&#39;coords</span> <span>mut</span> <span>Coordinates</span><span>,</span>
    <span>state</span><span>:</span> <span>PhantomData</span><span>&lt;</span><span>State</span><span>&gt;</span><span>,</span>
<span>}</span>
</code></pre></div></div>

<p>We still need to implement our new initial state
(the state transitions are addressed further in this tutorial).
Bearing the previous changes in mind, our new <code>Drone::new</code> now takes a <code>Coordinates</code> mutable reference:</p>

<div><div><pre><code><span>impl</span><span>&lt;</span><span>&#39;coords</span><span>&gt;</span> <span>Drone</span><span>&lt;</span><span>&#39;coords</span><span>,</span> <span>Idle</span><span>&gt;</span> <span>{</span>
    <span>pub</span> <span>fn</span> <span>new</span><span>(</span><span>coordinates</span><span>:</span> <span>&amp;</span><span>&#39;coords</span> <span>mut</span> <span>Coordinates</span><span>)</span> <span>-&gt;</span> <span>Self</span> <span>{</span>
        <span>Self</span> <span>{</span>
            <span>coordinates</span><span>,</span>
            <span>state</span><span>:</span> <span>PhantomData</span><span>,</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>The code above (and the remaining code) makes use of lifetimes to ensure our reference stays alive throughout the operation of the drone and
gets reused instead of creating a new copy or moving the structure around.</p>

<p>We declare <code>coordinates</code> as <code>mut</code> since in order for our drone to be able to fly,
<code>x</code> and <code>y</code> should be able to be mutated, thus our reference is required to be mutable.
The main use case for this detail is present in the <code>fly</code> function:</p>

<div><div><pre><code><span>impl</span><span>&lt;</span><span>&#39;coords</span><span>&gt;</span> <span>Drone</span><span>&lt;</span><span>&#39;coords</span><span>,</span> <span>Flying</span><span>&gt;</span> <span>{</span>
    <span>fn</span> <span>fly</span><span>(</span><span>mut</span> <span>self</span><span>,</span> <span>x</span><span>:</span> <span>f32</span><span>,</span> <span>y</span><span>:</span> <span>f32</span><span>)</span> <span>-&gt;</span> <span>Drone</span><span>&lt;</span><span>&#39;coords</span><span>,</span> <span>Hovering</span><span>&gt;</span> <span>{</span>
        <span>self</span><span>.inner.x</span> <span>=</span> <span>x</span><span>;</span>
        <span>self</span><span>.inner.y</span> <span>=</span> <span>y</span><span>;</span>
        <span>Drone</span><span>::</span><span>&lt;</span><span>Hovering</span><span>&gt;</span><span>::</span><span>from</span><span>(</span><span>self</span><span>)</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>Finally, the code that creates and uses the drone will first create a <code>Coordinates</code> instance and then pass it to our new <code>Drone::new</code>.</p>

<div><div><pre><code><span>fn</span> <span>fly_drone</span><span>()</span> <span>{</span>
    <span>let</span> <span>mut</span> <span>coordinates</span> <span>=</span> <span>Coordinates</span><span>::</span><span>new</span><span>();</span>
    <span>let</span> <span>drone</span> <span>=</span> <span>Drone</span><span>::</span><span>&lt;</span><span>Idle</span><span>&gt;</span><span>::</span><span>new</span><span>(</span><span>&amp;</span><span>mut</span> <span>coordinates</span><span>)</span>
        <span>.take_off</span><span>()</span>
        <span>.move_to</span><span>(</span><span>-</span><span>5.0</span><span>,</span> <span>-</span><span>5.0</span><span>)</span>
        <span>.land</span><span>();</span>
<span>}</span>
</code></pre></div></div>

<p><strong>Note</strong>: This implementation method could be avoided by using <code>Box</code>, thus allocating the value on the heap,
however, as previously mentioned, all kinds of systems should be able to use our typestate implementation,
to this end, we need to take into account that not every system has a heap,
the best example would be embedded systems which are only able to use the stack.
With our approach, using <code>Box</code> is still possible,
by using <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#impl-AsMut%3CT%3E"><code>Box::as_mut</code></a>.</p>







<!-- Adds the back to top link to your website -->
<p><a href="#" id="back-to-top">🏡</a></p><!-- Fades in the button when you scroll down -->








      
    </div></div>
  </body>
</html>
