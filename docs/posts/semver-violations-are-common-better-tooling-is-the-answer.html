<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://predr.ag/blog/semver-violations-are-common-better-tooling-is-the-answer/">Original</a>
    <h1>Semver violations are common, better tooling is the answer</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p><em>This post is coauthored by <a href="https://tonowak.com/">Tomasz Nowak</a> and Predrag Gruevski. It describes work the two of us did together with Bartosz Smolarczyk, Michał Staniewski, and Mieszko Grodzicki.</em></p>
<p><a href="https://twitter.com/PredragGruevski/status/1587877518018756609/photo/1">Anecdotally</a>, <code>cargo-semver-checks</code> is a helpful tool for preventing the semver violations that every so often cause ecosystem-wide pain.
This is why it earned a spot in the CI pipelines of key Rust crates like <a href="https://github.com/tokio-rs/tokio/blob/37bb47c4a2aff8913e536767645772f15650e6cd/.github/workflows/ci.yml#L393-L403"><code>tokio</code></a>, and also why <a href="https://github.com/obi1kenobi/cargo-semver-checks/issues/61">the <code>cargo</code> team hopes to integrate it into <code>cargo</code> itself</a>.</p>
<p>While anedotal evidence is nice, we wanted to get concrete data across a large sample of real-world Rust code. <span id="continue-reading"></span>
Inspired by <a href="https://github.com/rust-lang/crater">Crater</a>,<label for="sn-crater"></label>

<span>A tool that builds a large number of public Rust crates and runs their test suites to check for Rust compiler regressions.</span>
 we used <code>cargo-semver-checks</code> to lint the top 1000 most-downloaded library crates on crates.io.<label for="sn-semver-crater"></label>

<span>Our test setup has no connection to the Crater project. However, between us this work was affectionately known as <code>semver-crater</code> as a succinct and clear description of the work. We hope the team working on Crater doesn&#39;t mind this way of paying homage to our source of inspiration.</span>
</p>
<p>The outcome was a goldmine of valuable data.</p>
<h2 id="tl-dr-table-of-contents">TL;DR + table of contents</h2>
<p>Long story short: semver accidents are common.
They happen even in the most carefully-developed projects run by the most experienced maintainers.
The maintainers are not to blame, and improved tooling is our best way forward.
<code>cargo-semver-checks</code> is part of that improved tooling story, since it found every semver violation we report here.</p>
<p>Across more than 14000 releases<label for="sn-releases"></label>

<span>We only considered non-yanked releases published in 2017 or later. We only scanned <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies-from-cratesio">minor and patch releases</a>, since major version releases do not have any semver obligations. We also skipped 919 releases which we were not able to build with a modern version of Rust. That left us with 14389 total scanned releases.</span>
 of the top 1000 most downloaded crates, on average:</p>
<ul>
<li><strong>Around 1 in 31 releases had at least one semver violation</strong> – we found one or more violations in 464 releases (3.22%).<label for="sn-not-equivalent"></label>

<span>If you never use the affected functionality, it&#39;s possible that a semver-violating release does not break your project. This means that most projects will break due to a semver violation in less than 1-in-31 dependency upgrades on average. But with many projects having hundreds of dependencies, the odds are still concerningly high!</span>
</li>
<li><strong>More than 1 in 6 crates violated semver at least once</strong> – 172 crates (17.2%) had at least one release with a semver violation!</li>
</ul>
<p>The most common sources of semver violations were:</p>
<ul>
<li>A change to an exhaustive type, like adding new variants to an existing enum, or adding new fields to an existing struct that previously contained only public fields.</li>
<li>A struct that has been removed, or a type which had one of its methods removed,</li>
<li>A type that stopped implementing one or more auto traits.<label for="sn-auto-traits-example"></label>

<span>A <a href="https://predr.ag/blog/toward-fearless-cargo-update/#breaking-semver-with-auto-traits">previous post</a> has an example of how such semver violations may go unnoticed. While unexpected removals of <code>Send</code> or <code>Sync</code> can be frustrating, they are just the <a href="https://en.wikipedia.org/wiki/Shooting_the_messenger">bearers of bad news</a>. Making a type stop being thread-safe is a major breaking change in <em>every</em> language, and Rust merely chooses to point that out at compile-time instead of in production at 3am.</span>
</li>
</ul>
<h3 id="table-of-contents">Table of contents</h3>
<ul>
<li><a href="https://predr.ag/blog/semver-violations-are-common-better-tooling-is-the-answer/#this-is-a-failure-of-tooling-not-humans">This is a failure of tooling, not humans</a></li>
<li><a href="https://predr.ag/blog/semver-violations-are-common-better-tooling-is-the-answer/#detailed-results-how-we-validated-them">Detailed results &amp; how we validated them</a>
<ul>
<li><a href="https://predr.ag/blog/semver-violations-are-common-better-tooling-is-the-answer/#automated-validation-via-witnesses">Automated validation via &#34;witnesses&#34;</a></li>
<li><a href="https://predr.ag/blog/semver-violations-are-common-better-tooling-is-the-answer/#handling-the-doc-hidden-attribute">Handling the <code>#[doc(hidden)]</code> attribute</a></li>
<li><a href="https://predr.ag/blog/semver-violations-are-common-better-tooling-is-the-answer/#non-exhaustiveness-prior-to-non-exhaustive">Non-exhaustiveness prior to <code>#[non_exhaustive]</code></a></li>
<li><a href="https://predr.ag/blog/semver-violations-are-common-better-tooling-is-the-answer/#consulting-maintainers">Consulting maintainers</a></li>
</ul>
</li>
<li><a href="https://predr.ag/blog/semver-violations-are-common-better-tooling-is-the-answer/#this-is-only-a-fraction-of-all-semver-violations">This is only a fraction of all semver violations</a></li>
<li><a href="https://predr.ag/blog/semver-violations-are-common-better-tooling-is-the-answer/#just-scratching-the-surface-of-our-work">Just scratching the surface of our work</a></li>
</ul>
<p>We&#39;ll dig deeper into our findings in a bit.
First, we have to discuss a key point: <em>none of this is maintainers&#39; fault</em>.</p>

<p>Thanks to semver, <code>cargo update</code> can easily upgrade dependency versions to bring in performance upgrades, security fixes, and new functionality.
These benefits are significant and should not be understated.</p>
<p>Unfortunately, the benefits come at a cost to maintainers.
While many semver rules seem &#34;obvious,&#34; there&#39;s also a long tail of complex rules with tricky edge cases.
For example, editing the details of private types can sometimes result in <a href="https://predr.ag/blog/toward-fearless-cargo-update/#breaking-semver-with-auto-traits">a major breaking change in a public API elsewhere</a> in the library — <a href="https://predr.ag/blog/breaking-semver-in-rust-by-adding-private-type-or-import/">in more than one way</a>.
Spooky action at a distance!</p>
<p>Demanding perfection from maintainers would be naïve, unreasonable, and unfair.
Whenever hardworking, conscientious, well-intentioned people make a mistake, the failure is not with <em>the people</em> but in <em>the system</em>.</p>
<p>Blaming human error would also be out of line with Rust&#39;s existing practices.
After all, Rust adopted borrow-checking to address accidental and costly mistakes originating from another system of complex rules.
The parallels to semver and <code>cargo-semver-checks</code> are clear: in both cases, we rely on automated systems to check the rules that are not amenable to manual checking by humans.</p>
<p>Analyses like this one are key to learning how we can do better.
Our findings help us understand the needs of the ecosystem, contextualize our impact thus far, and determine how to best help Rustaceans going forward.</p>
<h2 id="detailed-results-how-we-validated-them">Detailed results &amp; how we validated them</h2>
<p>Automated linters can sometimes have false-positives, so we spent substantial effort on validating our results.</p>
<p>We discovered a total of 3060 verified semver violations across all scanned crate releases.
Each of those was first reported by <code>cargo-semver-checks</code> and then validated by a combination of automated and manual means.</p>
<details>
<summary>
Detailed results (click to expand)
</summary>
<p>Here is a table showing all the different kinds of verified semver violations we discovered. We show which <code>cargo-semver-checks</code> lint caught each semver violation, and how many different releases and crates had that kind of violation.</p>
<table><thead><tr><th>lint name</th><th>individual items</th><th>different releases</th><th>affected crates</th></tr></thead><tbody>
<tr><td><a href="https://github.com/obi1kenobi/cargo-semver-checks/blob/main/src/lints/inherent_method_missing.ron">inherent method missing</a></td><td>791</td><td>41</td><td>27</td></tr>
<tr><td><a href="https://github.com/obi1kenobi/cargo-semver-checks/blob/main/src/lints/enum_variant_added.ron">enum variant added</a></td><td>382</td><td>138</td><td>60</td></tr>
<tr><td><a href="https://github.com/obi1kenobi/cargo-semver-checks/blob/main/src/lints/constructible_struct_adds_field.ron">constructible struct adds field</a></td><td>343</td><td>123</td><td>34</td></tr>
<tr><td><a href="https://github.com/obi1kenobi/cargo-semver-checks/blob/main/src/lints/auto_trait_impl_removed.ron">auto trait impl removed</a></td><td>318</td><td>57</td><td>45</td></tr>
<tr><td><a href="https://github.com/obi1kenobi/cargo-semver-checks/blob/main/src/lints/struct_missing.ron">struct missing</a></td><td>291</td><td>66</td><td>40</td></tr>
<tr><td><a href="https://github.com/obi1kenobi/cargo-semver-checks/blob/main/src/lints/function_missing.ron">function missing</a></td><td>265</td><td>50</td><td>33</td></tr>
<tr><td><a href="https://github.com/obi1kenobi/cargo-semver-checks/blob/main/src/lints/inherent_method_const_removed.ron">inherent method const removed</a></td><td>139</td><td>5</td><td>3</td></tr>
<tr><td><a href="https://github.com/obi1kenobi/cargo-semver-checks/blob/main/src/lints/derive_trait_impl_removed.ron">derive trait impl removed</a></td><td>115</td><td>11</td><td>11</td></tr>
<tr><td><a href="https://github.com/obi1kenobi/cargo-semver-checks/blob/main/src/lints/enum_variant_missing.ron">enum variant missing</a></td><td>112</td><td>27</td><td>18</td></tr>
<tr><td><a href="https://github.com/obi1kenobi/cargo-semver-checks/blob/main/src/lints/struct_pub_field_missing.ron">struct pub field missing</a></td><td>79</td><td>32</td><td>16</td></tr>
<tr><td><a href="https://github.com/obi1kenobi/cargo-semver-checks/blob/main/src/lints/enum_missing.ron">enum missing</a></td><td>78</td><td>26</td><td>20</td></tr>
<tr><td><a href="https://github.com/obi1kenobi/cargo-semver-checks/blob/main/src/lints/trait_missing.ron">trait missing</a></td><td>45</td><td>24</td><td>19</td></tr>
<tr><td><a href="https://github.com/obi1kenobi/cargo-semver-checks/blob/main/src/lints/method_parameter_count_changed.ron">method parameter count changed</a></td><td>22</td><td>14</td><td>12</td></tr>
<tr><td><a href="https://github.com/obi1kenobi/cargo-semver-checks/blob/main/src/lints/enum_marked_non_exhaustive.ron">enum marked non-exhaustive</a></td><td>16</td><td>4</td><td>4</td></tr>
<tr><td><a href="https://github.com/obi1kenobi/cargo-semver-checks/blob/main/src/lints/struct_repr_c_removed.ron">struct repr(C) removed</a></td><td>12</td><td>3</td><td>3</td></tr>
<tr><td><a href="https://github.com/obi1kenobi/cargo-semver-checks/blob/main/src/lints/constructible_struct_adds_private_field.ron">constructible struct adds private field</a></td><td>9</td><td>7</td><td>6</td></tr>
<tr><td><a href="https://github.com/obi1kenobi/cargo-semver-checks/blob/main/src/lints/inherent_method_unsafe_added.ron">inherent method unsafe added</a></td><td>9</td><td>3</td><td>3</td></tr>
<tr><td><a href="https://github.com/obi1kenobi/cargo-semver-checks/blob/main/src/lints/function_parameter_count_changed.ron">function parameter count changed</a></td><td>8</td><td>4</td><td>4</td></tr>
<tr><td><a href="https://github.com/obi1kenobi/cargo-semver-checks/blob/main/src/lints/function_unsafe_added.ron">function unsafe added</a></td><td>8</td><td>2</td><td>2</td></tr>
<tr><td><a href="https://github.com/obi1kenobi/cargo-semver-checks/blob/main/src/lints/unit_struct_changed_kind.ron">unit struct changed kind</a></td><td>5</td><td>3</td><td>2</td></tr>
<tr><td><a href="https://github.com/obi1kenobi/cargo-semver-checks/blob/main/src/lints/enum_tuple_variant_field_missing.ron">enum tuple variant field missing</a></td><td>4</td><td>2</td><td>2</td></tr>
<tr><td><a href="https://github.com/obi1kenobi/cargo-semver-checks/blob/main/src/lints/tuple_struct_to_plain_struct.ron">tuple struct to plain struct</a></td><td>4</td><td>2</td><td>2</td></tr>
<tr><td><a href="https://github.com/obi1kenobi/cargo-semver-checks/blob/main/src/lints/enum_tuple_variant_field_added.ron">enum tuple variant field added</a></td><td>3</td><td>3</td><td>3</td></tr>
<tr><td><a href="https://github.com/obi1kenobi/cargo-semver-checks/blob/main/src/lints/enum_repr_int_removed.ron">enum repr int removed</a></td><td>1</td><td>1</td><td>1</td></tr>
<tr><td><a href="https://github.com/obi1kenobi/cargo-semver-checks/blob/main/src/lints/enum_struct_variant_field_added.ron">enum struct variant field added</a></td><td>1</td><td>1</td><td>1</td></tr>
</tbody></table>
</details>
<p>As part of our validation process, we discarded approximately 10000 other instances where <code>cargo-semver-checks</code> reported an issue that was determined to be either erroneous (confirmed false-positive) or inconclusive (e.g., causing <code>rustc</code> to crash when attempting to use the affected release in a new crate).</p>
<p>Here are the major components of our validation process.</p>
<h3 id="automated-validation-via-witnesses">Automated validation via &#34;witnesses&#34;</h3>
<p>For each reported semver violation, we created a <em>witness</em> – a code snippet that compiles on the older library version, but fails to compile on the newer version due to the semver-violating change.
This is how we prove that code external to the library, such as code in a downstream use case, can be impacted by that semver issue.</p>
<p>For example, imagine a library with the following code:</p>
<pre data-lang="rust"><code data-lang="rust"><span>pub enum </span><span>Example {
</span><span>    First,
</span><span>    Second,
</span><span>
</span><span>    </span><span>// Imagine the following variant is added
</span><span>    </span><span>// in a minor version. This violates semver,
</span><span>    </span><span>// since `Example` is an exhaustive enum.
</span><span>    Third,
</span><span>}
</span></code></pre>
<p>The witness for this code would look like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span>use </span><span>dependency::Example;
</span><span>
</span><span>fn </span><span>witness</span><span>(</span><span>value</span><span>: Example) {
</span><span>    </span><span>match</span><span> value {
</span><span>        Example::First =&gt; {}
</span><span>        Example::Second =&gt; {}
</span><span>    }
</span><span>}
</span></code></pre>
<p>This snippet compiles successfully with the original version, but is affected by the breaking change in the new version:</p>
<pre data-lang="rust_errors"><code data-lang="rust_errors"><span>error[E0004]: non-exhaustive patterns: `Example::Third` not covered
</span><span>  --&gt; src/lib.rs:4:11
</span><span>   |
</span><span>4  |     match value {
</span><span>   |           ^^^^^ pattern `Example::Third` not covered
</span><span>   |
</span></code></pre>
<h3 id="handling-the-doc-hidden-attribute">Handling the <code>#[doc(hidden)]</code> attribute</h3>
<p>In the code above, what if the <code>Example</code> enum was marked <code>#[doc(hidden)]</code>?
Items marked with this attribute don&#39;t appear in the documentation of the crate&#39;s public API, but are still accessible outside the crate.
This can be useful, for example, in crates that expose macros: the macros&#39; internal implementation details are usually not themselves a stable public API, even though they must be public for the macros to work.
<code>#[doc(hidden)]</code> items therefore have reduced semver obligations: if our <code>Example</code> enum above was <code>#[doc(hidden)]</code>, adding a new variant would not have violated semver.<label for="sn-reduced-not-none"></label>

<span>Interestingly, <code>#[doc(hidden)]</code> items still <a href="https://github.com/obi1kenobi/cargo-semver-checks/issues/120#issuecomment-1496766897">have <em>some</em> semver obligations</a>.</span>
</p>
<p>While <a href="https://github.com/obi1kenobi/cargo-semver-checks/issues/120#issuecomment-1496766897">we&#39;ve done some work on correctly handling <code>#[doc(hidden)]</code></a>, today&#39;s version of <code>cargo-semver-checks</code> still has a false-positive here.<label for="sn-fixing-doc-hidden-false-positives"></label>

<span>Thanks to this survey, we saw that <code>#[doc(hidden)]</code> is by far the most common source of false-positives in <code>cargo-semver-checks</code>. We are prioritizing shipping a fix here.</span>

A witness wouldn&#39;t detect this as false-positive, either — it would <em>also</em> claim a violation.</p>
<p>We discarded over 6000 such false-positives!
We used a combination of automated and manual triage, ensuring that flagged items are neither directly hidden nor indirectly hidden via <code>#[doc(hidden)]</code> on a containing module.</p>
<p>Our automated triage process relied on rustdoc&#39;s JSON output format.
It detected hidden items by finding items that are emitted only when rustdoc is passed the nightly-only <code>--document-hidden-items</code> flag.</p>
<p>We followed this up by manually inspecting the source code of any items that were not eliminated as hidden via automated means.
This step protected our results against possible false-negatives caused by bugs in our automated script, in rustdoc or its JSON backend, or in the nightly-only rustdoc flag we used.</p>
<h3 id="non-exhaustiveness-prior-to-non-exhaustive">Non-exhaustiveness prior to <code>#[non_exhaustive]</code></h3>
<p>These days, it&#39;s easy to forget that <code>#[non_exhaustive]</code> is a fairly recent addition — it was only stabilized <a href="https://blog.rust-lang.org/2019/12/19/Rust-1.40.0.html">in Rust 1.40</a>, released in late December 2019.
Our analysis covers releases made from 2017 onward, covering 3 years in which <code>#[non_exhaustive]</code> <em>did not exist</em> in the Rust language.
In 2023, we expect that non-exhaustive types are marked <code>#[non_exhaustive]</code>, and additions to exhaustive types are a clear-cut major breaking change.
It seems unfair to apply the same standard to code released in 2017–2019.</p>
<p>Semver is about <em>communicating expectations with users</em>.
Prior to the introduction of the <code>#[non_exhaustive]</code> attribute, maintainers noted non-exhaustiveness in doc comments or via enum variants with names like <code>__Nonexhaustive</code>.
As these were the community-accepted ways of indicating non-exhaustiveness at the time, that is the standard to which we held crates in our analysis.
We manually triaged exhaustiveness violations with those kinds of documented non-exhaustiveness.<label for="sn-changing-semver-standards"></label>

<span>This is an example of how the rules of semver <em>change over time</em> as a function of community expectations. In 2018, Rustaceans might have expected an enum to have its non-exhaustiveness communicated via a doc comment or a <code>__Nonexhaustive</code> variant. In 2023, we expect that non-exhaustive enums have the <code>#[non_exhaustive]</code> attribute — if the attribute isn&#39;t set, we probably wouldn&#39;t look for exhaustiveness information in the enum&#39;s doc comment. Then consider the act of adding a variant to an enum <em>only</em> specified as non-exhaustive in a doc comment: that&#39;s a major breaking change in 2023, but not in 2018.</span>
</p>
<h3 id="consulting-maintainers">Consulting maintainers</h3>
<p>Having verified our results via both automated and manual means, we decided to add one last check: we privately reached out to several maintainers of affected crates and discussed our findings with them.</p>
<p>In all cases, those maintainers confirmed our findings as correct.</p>
<p>In most cases, the maintainers stated the semver violations were novel, and not previously discovered nor reported anywhere to their knowledge.</p>
<p>In a tiny number of cases, maintainers reported making a semver-breaking change on purpose.
In one example, a part of a library was unintentionally made public in one release and that change was rolled back in the subsequent release, which is technically a removal of public API.</p>
<p>Such situations are why <code>cargo-semver-checks</code> aims to aid and inform maintainers, not take away their power to decide what&#39;s best for their crate.
We consider semver-checking akin to the <code>cargo publish</code> check about uncommitted changes: inform the user about the findings, but allow them to explicitly opt into proceeding if they are confident that&#39;s the right thing to do.</p>
<h2 id="this-is-only-a-fraction-of-all-semver-violations">This is only a fraction of all semver violations</h2>
<p>While this work found many real-world semver violations, our current setup could only hope to detect a fraction of all such issues.</p>
<p>There are good reasons to believe there are many more semver issues still to be discovered:</p>
<ul>
<li><code>cargo-semver-checks</code> is currently able to detect <a href="https://github.com/obi1kenobi/cargo-semver-checks#will-cargo-semver-checks-catch-every-semver-violation">only a subset of semver violations</a>. More lints are added in every new release, so repeating this analysis in the future is likely to find more semver violations in the same crate releases.</li>
<li>We only counted semver violations for which we were able to construct a witness. In some cases, <code>cargo-semver-checks</code> reported violations in code that relied on complex uses of generics where our witness-generator failed to produce a working witness. We consider such cases <em>inconclusive</em>, and believe that re-analyzing our dataset with more sophisticated witness generation may confirm more semver violations among these inconclusive cases.</li>
<li>Scanning the top crates likely makes our analysis heavily biased toward Rust code written by highly experienced maintainers. We believe that analyzing a broader set of crates is likely to produce a more-than-linear increase in discovered semver violations, since many ways to accidentally break semver would likely be non-obvious to many Rustaceans.</li>
<li>We semver-checked only the crates&#39; default features. Crate features produce a combinatorial increase in a crate&#39;s API surface area, so it&#39;s likely that checking more feature combinations would find evidence of more semver issues.<label for="sn-default-features-only"></label>

<span>We only checked default features to avoid compilation failures due to platform-specific code tucked behind feature flags. Otherwise, <code>cargo-semver-checks</code> by default <a href="https://github.com/obi1kenobi/cargo-semver-checks#what-features-does-cargo-semver-checks-enable-in-the-tested-crates">checks all crate features except ones with names commonly used to indicate unstable or internal-only code</a>.</span>
</li>
</ul>
<h2 id="just-scratching-the-surface-of-our-work">Just scratching the surface of our work</h2>
<p>This case study summarizes several engineer-years&#39; worth of work done by five people.
It shows that <code>cargo-semver-checks</code> can discover semver violations in real-world Rust code, and is therefore effective in helping today&#39;s maintainers avoid semver violations in their new releases.</p>
<p>But this is just a slice of what we built and discovered.
We didn&#39;t get to talk about many other interesting topics, like:</p>
<ul>
<li>how witness-generation works and how it might one day become part of <code>cargo-semver-checks</code> itself,</li>
<li>how <code>#[doc(hidden)]</code> items sometimes have semver obligations after all,</li>
<li>how <code>cargo-semver-checks</code> can also be used to discover crates whose <a href="https://doc.rust-lang.org/cargo/reference/features.html?highlight=additive#feature-unification">features are not additive</a>, or</li>
<li>all the <code>cargo-semver-checks</code> bugs we discovered and fixed as a result of proactively scanning such a large number of crates.</li>
</ul>
<p>If you are curious to learn more, we have a few resources for you to check out!</p>
<p>The work described in this post was part of the bachelors&#39; thesis project for <a href="https://tonowak.com/">Tomasz Nowak</a>, Bartosz Smolarczyk, Michał Staniewski, and Mieszko Grodzicki.
Their thesis is <a href="https://arxiv.org/abs/2308.14623">available here</a>, and contains many more details that we couldn&#39;t fit here.</p>
<p>More information on <code>cargo-semver-checks</code> is available on its <a href="https://github.com/obi1kenobi/cargo-semver-checks">GitHub page</a>.
It&#39;s safe to assume that the vast majority of bug reports opened by Tomasz, Bartosz, Michał, Mieszko, or Predrag in the last year were discovered as a result of the semver survey described in this post.</p>
<p>Various nuances of semver in Rust <a href="https://predr.ag/tags/semver/">have already been covered on this blog</a>, and more posts on the subject are sure to follow.
You can subscribe to this blog <a href="https://predr.ag/atom.xml">via RSS</a> or <a href="https://predr.ag/subscribe/">via email</a>.</p>
<p>If you maintain Rust crates, are you using <code>cargo-semver-checks</code> already? Why, or why not?</p>
<p><em>Discuss on <a href="https://www.reddit.com/r/rust/comments/16cj1mo/semver_violations_are_common_better_tooling_is/">r/rust</a> or <a href="https://lobste.rs/s/lsvmkq/semver_violations_are_common_better">lobste.rs</a>.</em></p>
<p><em>Thanks to <a href="https://tim.mcnamara.nz/">Tim McNamara</a>, <a href="https://www.lpalmieri.com/">Luca Palmieri</a>, <a href="https://steveklabnik.com/">Steve Klabnik</a>, <a href="https://github.com/oli-obk">oli-obk</a>, <a href="https://github.com/weihanglo">weihanglo</a>, and <a href="https://github.com/epage">Ed Page</a> for their feedback on drafts of this post. All mistakes belong to the post authors alone.</em></p>

  </div></div>
  </body>
</html>
