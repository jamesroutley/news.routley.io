<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://discourse.llvm.org/t/rfc-mdl-a-micro-architecture-description-language-for-llvm/66409">Original</a>
    <h1>MDL: A Micro-Architecture Description Language for LLVM</h1>
    
    <div id="readability-page-1" class="page"><div id="main-outlet" role="main">
        

  


      <div id="post_1" itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        <div>
          
          


          <p><span>
              <time itemprop="datePublished" datetime="2022-11-04T23:44:26Z">
                November 4, 2022, 11:44pm
              </time>
              <meta itemprop="dateModified" content="2022-11-04T23:44:26Z"/>
          <span itemprop="position">#1</span>
          </span>
        </p></div>
        <div itemprop="articleBody">
          <p>TL;DR:</p>
<p>We’ve created a DSL and compiler for modeling micro-architecture that handles a very broad class of architectures - CPU, GPUs, VLIWs, DSPs, ML accelerators, and embedded devices. This effort grew out of a need to quickly develop and experiment with high-quality compilers and tools to facilitate rapid architecture exploration. We named the DSL “MDL” for “Microarchitecture Description Language”.</p>
<p>While being significantly more expressive than TableGen’s Schedules and Itineraries used in LLVM, MDL is also more concise, and simpler to read and write while supporting a much broader class of embedded and accelerator architectures. We currently can automatically _generate _MDL descriptions for all upstream targets which are in many cases 1/10 the size of the equivalent TableGen descriptions.  We’ve integrated this with LLVM, and are sending out this RFC because we believe it could be valuable to the larger LLVM community. \</p>
<p>The MDL compiler, associated tools, and documentation are available as open source (at <a href="https://github.com/MPACT-ORG/llvm-project/tree/work" rel="noopener nofollow ugc">GitHub - MPACT-ORG/llvm-project at work</a>), and we would like to explore adding this to the LLVM project, and encourage contributions from others.</p>
<p>Background</p>
<p>Over the last few years, we have been using LLVM to develop a compiler backend for Google’s TPU machine learning accelerators.  TPUs have complex microarchitectures and pose a number of challenges that are not seen in in typical LLVM targets:</p>
<ul>
<li>Clustered VLIW with partitioned register files.</li>
<li>Extremely deep pipelines with complex hazard conditions</li>
<li>Instructions with functional-unit-specific and/or cluster-specific behaviors
<ul>
<li>Non-trivial and/or instance-specific latencies</li>
<li>Complex resource usage</li>
<li>Functional-unit-specific register constraints</li>
</ul>
</li>
<li>Shared/allocated encoding resources (instructions need 1…M of N resources)</li>
<li>Explicitly managed hardware resources (register ports, internal datapaths, busses, etc)</li>
</ul>
<p>While some of these problems manifest in a few upstream targets, this collection of problems is a superset of the problems directly addressed by LLVM - Schedules and Itineraries are simply not sufficient to model everything. Supporting this class of architecture is therefore code-intensive - it takes around 20,000 lines of C++ code to model the TPU sub-targets. This is brittle, hard to write, debug, test, and evolve over time. In contrast, the MDL description for these sub-targets is ~2,000 lines of text.</p>
<p>Status</p>
<ul>
<li>We’ve created the MDL language and compiler for describing microarchitecture details, a methodology for integrating it with TableGen files for any target, and a set of APIs that can be used in a machine-independent way to inform back-end passes such as bundle-packing, instruction scheduling, and register allocation.</li>
<li>To facilitate integration with LLVM, we built a tool which scrapes architectural information from TableGen files, and produces our MDL language for all upstream targets.</li>
<li>We’ve modified the CodeGen and MC libraries to (optionally) use our methodology for latency management.</li>
</ul>
<p>There is a lot more to do. For example, we plan to enhance existing back-end scheduling passes and register allocation passes to cleanly handle a larger class of embedded and accelerator architectures, based on MDL-generated information.</p>
<p>We welcome feedback on the language design and associated tools and use model.  You can find the MDL design documentation in our github repo in llvm/docs/Mdl.</p>
<p>-Reid</p>
        </div>

        <meta itemprop="headline" content="[RFC] MDL: A Micro-Architecture Description Language for LLVM"/>
          <meta itemprop="keywords" content="llvm"/>

        

         

            
      </div>
      <div id="post_2" itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        
        <div itemprop="articleBody">
          <p>I wonder if this can improve the precision of MCA, given the fact that it can create a model with finer granularity (<a href="https://discourse.llvm.org/u/adibiagio">@adibiagio</a> <a href="https://discourse.llvm.org/u/rksimon">@RKSimon</a>).</p>
<p>(Also I just tried to build the repo to see how MDL looks like. In case anyone here also wants to try it, please build LLVM with RTTI)</p>
        </div>

        <meta itemprop="headline" content="[RFC] MDL: A Micro-Architecture Description Language for LLVM"/>

        

         

      </div>
      
      <div id="post_4" itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        
        <p>How are the VLIW instruction scheduling restrictions implemented ex: x and y cannot go into the same bundle/packet ?</p>

        <meta itemprop="headline" content="[RFC] MDL: A Micro-Architecture Description Language for LLVM"/>

        

         

      </div>
      <div id="post_5" itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        <div>
          
          <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            <a itemprop="url" href="https://discourse.llvm.org/u/RKSimon"><span itemprop="name">RKSimon</span></a>
            
          </span></p>


          <p><span>
              <time itemprop="datePublished" datetime="2022-11-07T15:31:25Z">
                November 7, 2022,  3:31pm
              </time>
              <meta itemprop="dateModified" content="2022-11-07T15:31:25Z"/>
          <span itemprop="position">#5</span>
          </span>
        </p></div>
        <p><a href="https://discourse.llvm.org/u/reidtatge">@reidtatge</a> This looks interesting, and anything that can reduce the pain of maintaining the more complex aspects of arch modelling would be awesome. Do you have examples of the definitions that are consumed by MdlCompiler? Any reason that you use antlr4 instead of tblgen?</p>

        <meta itemprop="headline" content="[RFC] MDL: A Micro-Architecture Description Language for LLVM"/>

        

         

      </div>
      <div id="post_6" itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        
        <div itemprop="articleBody">
          <p>It can provide more detailed information, although for current upstream targets it doesn’t provide any additional information than whats already in tablegen (since the descriptions are scraped from tablegen).  But you’re right - we can provide a lot more inforrmation than tablegen can, and this could be used to build tools like MCA for more complex architectures.</p>
<p>(BTW, you shouldn’t have to build with RTTI, so I’m wondering why you had to do that.)</p>
        </div>

        <meta itemprop="headline" content="[RFC] MDL: A Micro-Architecture Description Language for LLVM"/>

        

         

      </div>
      <div id="post_7" itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        
        <div itemprop="articleBody">
          <p>The language is designed to allow you to describe the overall architecture in such a way that we can derive bundle-packing attributes about each instruction.  In your example, if X and Y can’t be bundled together, typically its because they both use a particular resource: a functional unit, an issue slot, encoding bits, or some other hardware component.  You can also define abstract shared resources that allow you to define arbitrary constraints on classes of instructions.  The MDL has first-class language structures for things like functional units, issue slots, and register ports, but you can define your own too.</p>
<p>So, the MDL compiler builds a “database” of instruction behaviors, and we have a solver (in MDLBundle.h) which not only determines whether a set of instructions can be issued in parallel, but which resources each instruction in the bundle would use, what their latencies would be, and any additional register constraints that the bundling implies.</p>
<p>There’s some related reading in llvm/docs/Mdl/BundlePacking.md.</p>
        </div>

        <meta itemprop="headline" content="[RFC] MDL: A Micro-Architecture Description Language for LLVM"/>

        

         

      </div>
      <div id="post_8" itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        
        <div itemprop="articleBody">
          <p>Hi Simon.  Take a look at llvm/docs/Mdl/MachineDescripitionNotes.md.  It’s meant to be a “users’ guide” for the MDL language, and has lots of simple examples, as well as a complete grammar for the language, and a complete RISCV (generated) description.  As I mentioned  in the RFC this was built to handle much more complex architectures (TPUs), but unfortunately I can’t publish a TPU machine description (its proprietary), which would better demonstrate the power of the language.  But the docs describe most of this stuff with simple examples.  If you build the repo, it will generate descriptions for AArch64, AMDGPU, ARM, Hexagon, Lanai, Mips, PowerPC, RISCV, Sparc, SystemZ, and X86 - all the targets that have Schedules and/or Itineraries.  They’re generated into build/lib/Target/<em>/</em>.mdl (the same place that tablegen .inc&#34; files are generated to). Caveat: in general, since these are generated files, they’re not particularly pretty to look at, but it will give you some examples to look at.</p>
<p>Why Antlr rather than Tablegen?  It seems I ought to make a tablegen joke here, but seriously: I wanted a concise, more expressive, purpose-built language that didn’t require the writer to explicitly connect a lot of information, and I couldn’t find a clean way to do that in tablegen. To be honest, I also wanted a very low-touch methodology - I wasn’t thinking that major hacks to tablegen was something the community wanted to see!  Antrl allowed us to experiment with and build a first-class language that was much easier to use and integrate with llvm.</p>
        </div>

        <meta itemprop="headline" content="[RFC] MDL: A Micro-Architecture Description Language for LLVM"/>

        

         

      </div>
      <div id="post_9" itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
        
        <div itemprop="articleBody">
          
<p>It throws some link time errors complaining about “undefined reference: typeinfo for &lt;some LLVM symbols from LLVMSupport&gt;” when building the <code>mdl</code> tool. I’m not sure if this is caused by the fact that I’m using ANTLR4 4.7.2 (the one bundled with Ubuntu 20.04, I did make some tweaks in your cmake file).</p>
        </div>

        <meta itemprop="headline" content="[RFC] MDL: A Micro-Architecture Description Language for LLVM"/>

        

         

      </div>






    </div></div>
  </body>
</html>
