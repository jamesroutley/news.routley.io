<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ohadravid.github.io/posts/2023-03-rusty-python/">Original</a>
    <h1>Making Python 100x faster with less than 100 lines of Rust</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>A while ago at <a href="https://www.trigoretail.com/">$work</a>, we had a performance issue with one of our core Python libraries.</p><p>This particular library forms the backbone of our 3D processing pipeline. It’s a rather big and complex library which uses NumPy and other scientific Python packages to do a wide range of mathematical and geometrical operations.</p><p>Our system also has to work on-prem with limited CPU resources, and while at first it performed well,
as the number of concurrent physical users grew we started running into problems and our system struggled to keep up with the load.</p><p>We came to the conclusion that we had to make our system at least 50 times faster to handle the increased workload, and we figured that Rust could help us achieve that.</p><p>Because the performance problems we encountered are pretty common,
we can recreate &amp; solve them right here, in a (not-so-short) article.</p><p>So grab a cup of tea (or coffee) and I’ll walk you through (a) the basic underlying problem and (b) a few iterations of optimizations we can apply to solve this problem.</p><p>If you want to jump straight to the final code, just to go to <a href="#summary">the summary</a>.</p><h2 id="our-running-example">Our running example</h2><p>Let’s create a small library, which will exhibit our original performance issues (but does completely arbitrary work).</p><p>Imagine you have a list of polygons and a of list points, all in 2D.
For business reasons, we want to “match” each point to a single polygon.</p><p>Our imaginary library is going to:</p><ol><li>Start with an initial list of points and polygons (all in 2D).</li><li>For each point, find a much smaller subset of polygons that are closest to it, based on distance from the center.</li><li>Out of those polygons, select the “best” one (we are going to use “smallest area” as “best”).</li></ol><p>In code, that’s going to look like this (The full code can be found <a href="https://github.com/ohadravid/poly-match">here</a>):</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> <span>typing</span> <span>import</span> List<span>,</span> Tuple
</span></span><span><span><span>import</span> <span>numpy</span> <span>as</span> <span>np</span>
</span></span><span><span><span>from</span> <span>dataclasses</span> <span>import</span> dataclass
</span></span><span><span><span>from</span> <span>functools</span> <span>import</span> cached_property
</span></span><span><span>
</span></span><span><span>Point <span>=</span> np<span>.</span>array
</span></span><span><span>
</span></span><span><span><span>@dataclass</span>
</span></span><span><span><span>class</span> <span>Polygon</span><span>:</span>
</span></span><span><span>    x<span>:</span> np<span>.</span>array
</span></span><span><span>    y<span>:</span> np<span>.</span>array
</span></span><span><span>
</span></span><span><span>    <span>@cached_property</span>
</span></span><span><span>    <span>def</span> <span>center</span><span>(</span>self<span>)</span> <span>-&gt;</span> Point<span>:</span> <span>...</span>
</span></span><span><span>    <span>def</span> <span>area</span><span>(</span>self<span>)</span> <span>-&gt;</span> <span>float</span><span>:</span> <span>...</span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>find_close_polygons</span><span>(</span>polygon_subset<span>:</span> List<span>[</span>Polygon<span>],</span> point<span>:</span> Point<span>,</span> max_dist<span>:</span> <span>float</span><span>)</span> <span>-&gt;</span> List<span>[</span>Polygon<span>]:</span>
</span></span><span><span>    <span>...</span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>select_best_polygon</span><span>(</span>polygon_sets<span>:</span> List<span>[</span>Tuple<span>[</span>Point<span>,</span> List<span>[</span>Polygon<span>]]])</span> <span>-&gt;</span> List<span>[</span>Tuple<span>[</span>Point<span>,</span> Polygon<span>]]:</span>
</span></span><span><span>    <span>...</span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>main</span><span>(</span>polygons<span>:</span> List<span>[</span>Polygon<span>],</span> points<span>:</span> np<span>.</span>ndarray<span>)</span> <span>-&gt;</span> List<span>[</span>Tuple<span>[</span>Point<span>,</span> Polygon<span>]]:</span>
</span></span><span><span>    <span>...</span>
</span></span></code></pre></div><p><strong>The key difficulty (performance wise) is this mix of Python objects and numpy arrays.</strong></p><p>We are going to analyze this in depth in a minute.</p><p>It’s worth noting that converting parts of / everything to <a href="https://numpy.org/doc/stable/glossary.html#term-vectorization">vectorized</a> numpy might be possible for this toy library,
but will be nearly impossible for the real library while making the code much less readable and modifiable, and the gains are going to be limited (<a href="https://github.com/ohadravid/poly-match/blob/main/poly_match_v1_5_vectorized.py">here’s a partially vertorized version</a>, which is faster but far from the results we are going to achieve).</p><p>Also, using any JIT-based tricks (PyPy / numba) results in very small gains (as we will measure, just to make sure).</p><h2 id="why-not-just-rewrite-it-all-in-rust">Why not just Rewrite It (all) In Rust™?</h2><p>As compelling as a complete rewrite was, it had a few problems:</p><ol><li>The library was already using numpy for a lot of its calculations, so why should we expect Rust to be better?</li><li>It is big and complex and very business critical and highly algorithmic, so that would take ~months of work, and our poor on-prem server is dying <strong>today</strong>.</li><li>A bunch of friendly researchers are actively working on said library, implementing better algorithms and doing a lot of experiments.
They aren’t going to be very happy to learn a new programming language, waiting for things to compile and fighting with the borrow checker. They would appreciate us not moving their cheese too far.</li></ol><h2 id="dipping-our-toes">Dipping our toes</h2><p>It is time to introduce our friend the profiler.</p><p>Python has a built in Profiler (<code>cProfile</code>), but in this case it’s not really the right tool for the job:</p><ol><li>It’ll introduce a lot of overhead to all the Python code, and none for native code, so our results might be biased.</li><li>We won’t be able to see into native frames, meaning we aren’t going to be able to see into our Rust code.</li></ol><p>We are going to use <code>py-spy</code> (<a href="https://github.com/benfred/py-spy">GitHub</a>).</p><p><code>py-spy</code> is a <a href="https://en.wikipedia.org/wiki/Profiling_(computer_programming)#Statistical_profilers">sampling profiler</a> which can see into native frames.</p><p>They also mercifully publish pre-built wheels to pypi, so we can just <code>pip install py-spy</code> and get to work.</p><p>We also need something to measure.</p><div><pre tabindex="0"><code data-lang="python"><span><span><span># measure.py</span>
</span></span><span><span><span>import</span> <span>time</span>
</span></span><span><span><span>import</span> <span>poly_match</span>
</span></span><span><span><span>import</span> <span>os</span>
</span></span><span><span>  
</span></span><span><span><span># Reduce noise, actually improve perf in our case.</span>
</span></span><span><span>os<span>.</span>environ<span>[</span><span>&#34;OPENBLAS_NUM_THREADS&#34;</span><span>]</span> <span>=</span> <span>&#34;1&#34;</span>
</span></span><span><span>
</span></span><span><span>polygons<span>,</span> points <span>=</span> poly_match<span>.</span>generate_example<span>()</span>
</span></span><span><span>
</span></span><span><span><span># We are going to increase this as the code gets faster and faster.</span>
</span></span><span><span>NUM_ITER <span>=</span> <span>10</span>
</span></span><span><span>
</span></span><span><span>t0 <span>=</span> time<span>.</span>perf_counter<span>()</span>
</span></span><span><span><span>for</span> _ <span>in</span> <span>range</span><span>(</span>NUM_ITER<span>):</span>
</span></span><span><span>    poly_match<span>.</span>main<span>(</span>polygons<span>,</span> points<span>)</span>
</span></span><span><span>t1 <span>=</span> time<span>.</span>perf_counter<span>()</span>
</span></span><span><span>
</span></span><span><span>took <span>=</span> <span>(</span>t1 <span>-</span> t0<span>)</span> <span>/</span> NUM_ITER
</span></span><span><span><span>print</span><span>(</span><span>f</span><span>&#34;Took and avg of </span><span>{</span>took <span>*</span> <span>1000</span><span>:</span><span>.2f</span><span>}</span><span>ms per iteration&#34;</span><span>)</span>
</span></span></code></pre></div><p>It’s not very scientific, but it’s going to take us <em>very</em> far.</p><blockquote><p>“Good benchmarking is hard. Having said that, do not stress too much about having a perfect benchmarking setup, particularly when you start optimizing a program.”</p><p>~ Nicholas Nethercote, in <a href="https://nnethercote.github.io/perf-book/benchmarking.html">“The Rust Performance Book”</a></p></blockquote><p>Running this script will give us our baseline:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ python measure.py
</span></span><span><span>Took an avg of 293.41ms per iteration
</span></span></code></pre></div><p>For the original library, we used 50 different examples to make sure all cases are covered.</p><p>This matched the overall system perf, meaning we can start working on crushing this number.</p><p>Side note: We can also measure using PyPy (we’ll also add a warmup to allow the JIT to do its magic).</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ conda create -n pypyenv -c conda-forge pypy numpy <span>&amp;&amp;</span> conda activate pypyenv
</span></span><span><span>$ pypy measure_with_warmup.py
</span></span><span><span>Took an avg of 1495.81ms per iteration
</span></span></code></pre></div><h2 id="measure-first">Measure first</h2><p>So, let’s find out what is so slow here.</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ py-spy record --native -o profile.svg -- python measure.py
</span></span><span><span>py-spy&gt; Sampling process <span>100</span> <span>times</span> a second. Press Control-C to exit.
</span></span><span><span>
</span></span><span><span>Took an avg of 365.43ms per iteration
</span></span><span><span>
</span></span><span><span>py-spy&gt; Stopped sampling because process exited
</span></span><span><span>py-spy&gt; Wrote flamegraph data to <span>&#39;profile.svg&#39;</span>. Samples: <span>391</span> Errors: <span>0</span>
</span></span></code></pre></div><p>Already, we can see that the overhead is pretty small.
Just for comparison, using <code>cProfile</code> we get this:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ python -m cProfile measure.py
</span></span><span><span>Took an avg of 546.47ms per iteration
</span></span><span><span>         <span>7551778</span> <span>function</span> calls <span>(</span><span>7409483</span> primitive calls<span>)</span> in 7.806 seconds
</span></span><span><span>         ...
</span></span></code></pre></div><p>We get this nice, reddish graph called a <a href="https://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html">flamegraph</a>:</p><p>Each box is a function, and we can see the relative time we spend in each function,
including the functions it is calling to (going down the graph/stack).
Try clicking on a the <code>norm</code> box to zoom into it.</p><p>Here, the main takeaways are:</p><ol><li>The vast majority of time is spent in <code>find_close_polygons</code>.</li><li>Most of that time is spend doing <code>norm</code>, which is a numpy function.</li></ol><p>So, let’s have a look at <code>find_close_polygons</code>:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>def</span> <span>find_close_polygons</span><span>(</span>
</span></span><span><span>    polygon_subset<span>:</span> List<span>[</span>Polygon<span>],</span> point<span>:</span> np<span>.</span>array<span>,</span> max_dist<span>:</span> <span>float</span>
</span></span><span><span><span>)</span> <span>-&gt;</span> List<span>[</span>Polygon<span>]:</span>
</span></span><span><span>    close_polygons <span>=</span> <span>[]</span>
</span></span><span><span>    <span>for</span> poly <span>in</span> polygon_subset<span>:</span>
</span></span><span><span>        <span>if</span> np<span>.</span>linalg<span>.</span>norm<span>(</span>poly<span>.</span>center <span>-</span> point<span>)</span> <span>&lt;</span> max_dist<span>:</span>
</span></span><span><span>            close_polygons<span>.</span>append<span>(</span>poly<span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>return</span> close_polygons
</span></span></code></pre></div><p>We are going to rewrite this function in Rust.</p><p>Before diving into the details, it’s important to notice a few things here:</p><ol><li>This function accepts &amp; returns complex objects (<code>Polygon</code>, <code>np.array</code>).</li><li>The size of the objects is non-trivial (so copying stuff might cost us).</li><li>This function is called “a lot” (so overhead we introduce is probably going to matter).</li></ol><h2 id="my-first-rust-module">My first Rust module</h2><p><code>pyo3</code> is a crate for interacting between Python and Rust.
It has exceptionally good documentation, and they explain the basic setup <a href="https://pyo3.rs/v0.18.1/#using-rust-from-python">here</a>.</p><p>We are going to call our crate <code>poly_match_rs</code>, and add function called <code>find_close_polygons</code>.</p><div><pre tabindex="0"><code data-lang="bash"><span><span>mkdir poly_match_rs <span>&amp;&amp;</span> <span>cd</span> <span>&#34;</span>$_<span>&#34;</span>
</span></span><span><span>pip install maturin
</span></span><span><span>maturin init --bindings pyo3
</span></span><span><span>maturin develop
</span></span></code></pre></div><p>Starting out, our crate is going to look like this:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span> pyo3::prelude::<span>*</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>#[pyfunction]</span>
</span></span><span><span><span>fn</span> <span>find_close_polygons</span><span>()</span> -&gt; <span>PyResult</span><span>&lt;</span><span>()</span><span>&gt;</span> <span>{</span>
</span></span><span><span>    <span>Ok</span><span>(())</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>#[pymodule]</span>
</span></span><span><span><span>fn</span> <span>poly_match_rs</span><span>(</span>_py: <span>Python</span><span>,</span> m: <span>&amp;</span><span>PyModule</span><span>)</span> -&gt; <span>PyResult</span><span>&lt;</span><span>()</span><span>&gt;</span> <span>{</span>
</span></span><span><span>    m<span>.</span>add_function<span>(</span>wrap_pyfunction!<span>(</span>find_close_polygons<span>,</span> m<span>)</span><span>?</span><span>)</span><span>?</span><span>;</span>
</span></span><span><span>    <span>Ok</span><span>(())</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>We also need to remember to execute <code>maturin develop</code> every time we change the Rust library.</p><p>And thats it! Let’s call our new function and see what happens.</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>&gt;&gt;&gt;</span> poly_match_rs<span>.</span>find_close_polygons<span>(</span>polygons<span>,</span> point<span>,</span> max_dist<span>)</span>
</span></span><span><span>E <span>TypeError</span><span>:</span> poly_match_rs<span>.</span>poly_match_rs<span>.</span>find_close_polygons<span>()</span> takes no arguments <span>(</span><span>3</span> given<span>)</span>
</span></span></code></pre></div><h2 id="v1---a-naive-rust-translation">v1 - A naive Rust translation</h2><p>We’ll start with matching the expected API.</p><p>PyO3 is pretty smart about Python to Rust conversions, so that’s going to be pretty easy:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>#[pyfunction]</span>
</span></span><span><span><span>fn</span> <span>find_close_polygons</span><span>(</span>polygons: <span>Vec</span><span>&lt;</span>PyObject<span>&gt;</span><span>,</span> point: <span>PyObject</span><span>,</span> max_dist: <span>f64</span><span>)</span> -&gt; <span>PyResult</span><span>&lt;</span><span>Vec</span><span>&lt;</span>PyObject<span>&gt;&gt;</span> <span>{</span>
</span></span><span><span>    <span>Ok</span><span>(</span>vec!<span>[])</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p><code>PyObject</code> is (as the name suggest) a generic “anything goes” Python object.
We’ll try to interact with it in a bit.</p><p>This should make the program run (albeit incorrectly).</p><p>I’m going to just copy and paste the original Python function, and fix the syntax.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>#[pyfunction]</span>
</span></span><span><span><span>fn</span> <span>find_close_polygons</span><span>(</span>polygons: <span>Vec</span><span>&lt;</span>PyObject<span>&gt;</span><span>,</span> point: <span>PyObject</span><span>,</span> max_dist: <span>f64</span><span>)</span> -&gt; <span>PyResult</span><span>&lt;</span><span>Vec</span><span>&lt;</span>PyObject<span>&gt;&gt;</span> <span>{</span>
</span></span><span><span>    <span>let</span> <span>mut</span> close_polygons <span>=</span> vec!<span>[];</span>
</span></span><span><span>    
</span></span><span><span>    <span>for</span> poly <span>in</span> polygons <span>{</span>
</span></span><span><span>        <span>if</span> norm<span>(</span>poly<span>.</span>center <span>-</span> point<span>)</span> <span>&lt;</span> max_dist <span>{</span>
</span></span><span><span>            close_polygons<span>.</span>push<span>(</span>poly<span>)</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    
</span></span><span><span>    <span>Ok</span><span>(</span>close_polygons<span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Cool, but this won’t compile:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>% maturin develop
</span></span><span><span>...
</span></span><span><span>
</span></span><span><span>error<span>[</span>E0609<span>]</span>: no field <span>`</span>center<span>`</span> on <span>type</span> <span>`</span>Py&lt;PyAny&gt;<span>`</span>
</span></span><span><span> --&gt; src/lib.rs:8:22
</span></span><span><span>  <span>|</span>
</span></span><span><span><span>8</span> <span>|</span>         <span>if</span> norm<span>(</span>poly.center - point<span>)</span> &lt; max_dist <span>{</span>
</span></span><span><span>  <span>|</span>                      ^^^^^^ unknown field
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>error<span>[</span>E0425<span>]</span>: cannot find <span>function</span> <span>`</span>norm<span>`</span> in this scope
</span></span><span><span> --&gt; src/lib.rs:8:12
</span></span><span><span>  <span>|</span>
</span></span><span><span><span>8</span> <span>|</span>         <span>if</span> norm<span>(</span>poly.center - point<span>)</span> &lt; max_dist <span>{</span>
</span></span><span><span>  <span>|</span>            ^^^^ not found in this scope
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>error: aborting due to <span>2</span> previous errors <span>]</span> 58/59: poly_match_rs
</span></span></code></pre></div><p>We need three crates to implement our function:</p><div><pre tabindex="0"><code data-lang="toml"><span><span><span># For Rust-native array operations.</span>
</span></span><span><span>ndarray <span>=</span> <span>&#34;0.15&#34;</span>
</span></span><span><span>
</span></span><span><span><span># For a `norm` function for arrays.</span>
</span></span><span><span>ndarray-linalg <span>=</span> <span>&#34;0.16&#34;</span>  
</span></span><span><span>
</span></span><span><span><span># For accessing numpy-created objects, based on `ndarray`.</span>
</span></span><span><span>numpy <span>=</span> <span>&#34;0.18&#34;</span>
</span></span></code></pre></div><p>First, lets turn the opaque and generic <code>point: PyObject</code> into something we can work with.</p><p>Just like we asked PyO3 for a “<code>Vec</code> of <code>PyObject</code>s”, we can ask for a numpy-array,
and it’ll auto-convert the argument for us.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span> numpy::PyReadonlyArray1<span>;</span>
</span></span><span><span>
</span></span><span><span><span>#[pyfunction]</span>
</span></span><span><span><span>fn</span> <span>find_close_polygons</span><span>(</span>
</span></span><span><span>    <span>// An object which says &#34;I have the GIL&#34;, so we can access Python-managed memory.
</span></span></span><span><span><span></span>    py: <span>Python</span><span>&lt;</span><span>&#39;_</span><span>&gt;</span><span>,</span>
</span></span><span><span>    polygons: <span>Vec</span><span>&lt;</span>PyObject<span>&gt;</span><span>,</span>
</span></span><span><span>    <span>// A reference to a numpy array we will be able to access.
</span></span></span><span><span><span></span>    point: <span>PyReadonlyArray1</span><span>&lt;</span><span>f64</span><span>&gt;</span><span>,</span>
</span></span><span><span>    max_dist: <span>f64</span><span>,</span>
</span></span><span><span><span>)</span> -&gt; <span>PyResult</span><span>&lt;</span><span>Vec</span><span>&lt;</span>PyObject<span>&gt;&gt;</span> <span>{</span>
</span></span><span><span>    <span>// Convert to `ndarray::ArrayView1`, a fully operational native array.
</span></span></span><span><span><span></span>    <span>let</span> point <span>=</span> point<span>.</span>as_array<span>();</span>
</span></span><span><span>    <span>..</span><span>.</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Because <code>point</code> is now an <code>ArrayView1</code>, we can actually use it. For example:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>// Make the `norm` function available.
</span></span></span><span><span><span></span><span>use</span> ndarray_linalg::Norm<span>;</span>
</span></span><span><span>
</span></span><span><span>assert_eq!<span>((</span>point<span>.</span>to_owned<span>()</span> <span>-</span> point<span>).</span>norm<span>(),</span> <span>0.</span><span>);</span>
</span></span></code></pre></div><p>Now we just need to get the center of each polygon, and “cast” it to an <code>ArrayView1</code>.</p><p>In PyO3, this looks like this:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span> center <span>=</span> poly
</span></span><span><span>  <span>.</span>getattr<span>(</span>py<span>,</span> <span>&#34;center&#34;</span><span>)</span><span>?</span>                 <span>// Python-style getattr, requires a GIL token (`py`).
</span></span></span><span><span><span></span>  <span>.</span>extract::<span>&lt;</span>PyReadonlyArray1<span>&lt;</span><span>f64</span><span>&gt;&gt;</span><span>(</span>py<span>)</span><span>?</span>  <span>// Tell PyO3 what to convert the result to.
</span></span></span><span><span><span></span>  <span>.</span>as_array<span>()</span>                             <span>// Like `point` before.
</span></span></span><span><span><span></span>  <span>.</span>to_owned<span>();</span>                            <span>// We need one of the sides of the `-` to be &#34;owned&#34;.
</span></span></span></code></pre></div><p>It’s a bit of a mouthful, but overall the result is a pretty clear line-to-line translation of the original code:</p><div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>use</span> pyo3::prelude::<span>*</span><span>;</span>
</span></span><span><span> 2</span><span>
</span></span><span><span> 3</span><span><span>use</span> ndarray_linalg::Norm<span>;</span>
</span></span><span><span> 4</span><span><span>use</span> numpy::PyReadonlyArray1<span>;</span>
</span></span><span><span> 5</span><span>
</span></span><span><span> 6</span><span><span>#[pyfunction]</span>
</span></span><span><span> 7</span><span><span>fn</span> <span>find_close_polygons</span><span>(</span>
</span></span><span><span> 8</span><span>    py: <span>Python</span><span>&lt;</span><span>&#39;_</span><span>&gt;</span><span>,</span>
</span></span><span><span> 9</span><span>    polygons: <span>Vec</span><span>&lt;</span>PyObject<span>&gt;</span><span>,</span>
</span></span><span><span>10</span><span>    point: <span>PyReadonlyArray1</span><span>&lt;</span><span>f64</span><span>&gt;</span><span>,</span>
</span></span><span><span>11</span><span>    max_dist: <span>f64</span><span>,</span>
</span></span><span><span>12</span><span><span>)</span> -&gt; <span>PyResult</span><span>&lt;</span><span>Vec</span><span>&lt;</span>PyObject<span>&gt;&gt;</span> <span>{</span>
</span></span><span><span>13</span><span>    <span>let</span> <span>mut</span> close_polygons <span>=</span> vec!<span>[];</span>
</span></span><span><span>14</span><span>    <span>let</span> point <span>=</span> point<span>.</span>as_array<span>();</span>
</span></span><span><span>15</span><span>    <span>for</span> poly <span>in</span> polygons <span>{</span>
</span></span><span><span>16</span><span>        <span>let</span> center <span>=</span> poly
</span></span><span><span>17</span><span>            <span>.</span>getattr<span>(</span>py<span>,</span> <span>&#34;center&#34;</span><span>)</span><span>?</span>
</span></span><span><span>18</span><span>            <span>.</span>extract::<span>&lt;</span>PyReadonlyArray1<span>&lt;</span><span>f64</span><span>&gt;&gt;</span><span>(</span>py<span>)</span><span>?</span>
</span></span><span><span>19</span><span>            <span>.</span>as_array<span>()</span>
</span></span><span><span>20</span><span>            <span>.</span>to_owned<span>();</span>
</span></span><span><span>21</span><span>
</span></span><span><span>22</span><span>        <span>if</span> <span>(</span>center <span>-</span> point<span>).</span>norm<span>()</span> <span>&lt;</span> max_dist <span>{</span>
</span></span><span><span>23</span><span>            close_polygons<span>.</span>push<span>(</span>poly<span>)</span>
</span></span><span><span>24</span><span>        <span>}</span>
</span></span><span><span>25</span><span>    <span>}</span>
</span></span><span><span>26</span><span>
</span></span><span><span>27</span><span>    <span>Ok</span><span>(</span>close_polygons<span>)</span>
</span></span><span><span>28</span><span><span>}</span>
</span></span></code></pre></div><p>vs the original:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>def</span> <span>find_close_polygons</span><span>(</span>
</span></span><span><span>    polygon_subset<span>:</span> List<span>[</span>Polygon<span>],</span> point<span>:</span> np<span>.</span>array<span>,</span> max_dist<span>:</span> <span>float</span>
</span></span><span><span><span>)</span> <span>-&gt;</span> List<span>[</span>Polygon<span>]:</span>
</span></span><span><span>    close_polygons <span>=</span> <span>[]</span>
</span></span><span><span>    <span>for</span> poly <span>in</span> polygon_subset<span>:</span>
</span></span><span><span>        <span>if</span> np<span>.</span>linalg<span>.</span>norm<span>(</span>poly<span>.</span>center <span>-</span> point<span>)</span> <span>&lt;</span> max_dist<span>:</span>
</span></span><span><span>            close_polygons<span>.</span>append<span>(</span>poly<span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>return</span> close_polygons
</span></span></code></pre></div><p>We expect this version to have some advantage over the original function,
but how much?</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ <span>(</span><span>cd</span> ./poly_match_rs/ <span>&amp;&amp;</span> maturin develop<span>)</span>
</span></span><span><span>$ python measure.py
</span></span><span><span>Took an avg of 609.46ms per iteration 
</span></span></code></pre></div><p>So.. Is Rust just super slow?
No! We just forgot to ask for speed!
If we run with <code>maturin develop --release</code> we get much better results:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ <span>(</span><span>cd</span> ./poly_match_rs/ <span>&amp;&amp;</span> maturin develop --release<span>)</span>
</span></span><span><span>$ python measure.py
</span></span><span><span>Took an avg of 23.44ms per iteration
</span></span></code></pre></div><p>Now <em>that</em> is a nice speedup!</p><p>We also want to see into our native code, so we are going to enable debug symbols in release.
While we are at it, we might as well ask for <em>maximum speed</em>.</p><div><pre tabindex="0"><code data-lang="toml"><span><span><span># added to Cargo.toml</span>
</span></span><span><span><span>[</span>profile<span>.</span>release<span>]</span>
</span></span><span><span>debug <span>=</span> <span>true</span>       <span># Debug symbols for our profiler.</span>
</span></span><span><span>lto <span>=</span> <span>true</span>         <span># Link-time optimization.</span>
</span></span><span><span>codegen-units <span>=</span> <span>1</span>  <span># Slower compilation but faster code. </span>
</span></span></code></pre></div><h2 id="v2---rewrite-even-more-in-rust">v2 - Rewrite even more in Rust</h2><p>Now, using the <code>--native</code> flag in <code>py-spy</code> is going to show us both Python and our new native code.</p><p>Running <code>py-spy</code> again</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ py-spy record --native -o profile.svg -- python measure.py
</span></span><span><span>py-spy&gt; Sampling process <span>100</span> <span>times</span> a second. Press Control-C to exit.
</span></span></code></pre></div><p>we get this flamegraph (non-red colors are added to so we can refer to them):</p><p>Looking at the profiler output, we can see a few interesting things:</p><ol><li>The relative size of <code>find_close_polygons::...::trampoline</code> (the symbol Python directly calls) and <code>__pyfunction_find_close_polygons</code> (our actual implementation).<ul><li>Hovering, they are 95% vs 88% of samples, so the overhead is pretty small.</li></ul></li><li>The actual logic (<code>if (center - point).norm() &lt; max_dist { ... }</code>) which is <code>lib_v1.rs:22</code> (very small box on the right), is about 9% of the total runtime.<ul><li>So x10 improvement should still be possible!</li></ul></li><li>Most of the time is spent in <code>lib_v1.rs:16</code>, which is <code>poly.getattr(...).extract(...)</code> and if we zoom in we can see is really just <code>getattr</code> and getting the underlying array using <code>as_array</code>.</li></ol><p>The conclusion here is that we need to focus on solving the 3rd point,
and the way to do that is to Rewrite <code>Polygon</code> in Rust.</p><p>Let’s look at our target:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>@dataclass</span>
</span></span><span><span><span>class</span> <span>Polygon</span><span>:</span>
</span></span><span><span>    x<span>:</span> np<span>.</span>array
</span></span><span><span>    y<span>:</span> np<span>.</span>array
</span></span><span><span>    _area<span>:</span> <span>float</span> <span>=</span> <span>None</span>
</span></span><span><span>
</span></span><span><span>    <span>@cached_property</span>
</span></span><span><span>    <span>def</span> <span>center</span><span>(</span>self<span>)</span> <span>-&gt;</span> np<span>.</span>array<span>:</span>
</span></span><span><span>        centroid <span>=</span> np<span>.</span>array<span>([</span>self<span>.</span>x<span>,</span> self<span>.</span>y<span>])</span><span>.</span>mean<span>(</span>axis<span>=</span><span>1</span><span>)</span>
</span></span><span><span>        <span>return</span> centroid
</span></span><span><span>
</span></span><span><span>    <span>def</span> <span>area</span><span>(</span>self<span>)</span> <span>-&gt;</span> <span>float</span><span>:</span>
</span></span><span><span>        <span>if</span> self<span>.</span>_area <span>is</span> <span>None</span><span>:</span>
</span></span><span><span>            self<span>.</span>_area <span>=</span> <span>0.5</span> <span>*</span> np<span>.</span>abs<span>(</span>
</span></span><span><span>                np<span>.</span>dot<span>(</span>self<span>.</span>x<span>,</span> np<span>.</span>roll<span>(</span>self<span>.</span>y<span>,</span> <span>1</span><span>))</span> <span>-</span> np<span>.</span>dot<span>(</span>self<span>.</span>y<span>,</span> np<span>.</span>roll<span>(</span>self<span>.</span>x<span>,</span> <span>1</span><span>))</span>
</span></span><span><span>            <span>)</span>
</span></span><span><span>        <span>return</span> self<span>.</span>_area
</span></span></code></pre></div><p>We’ll want to keep the existing API as much as possible,
but we don’t really need <code>area</code> to be that fast (for now).</p><p>The actual class might have additional complex stuff,
like a <code>merge</code> method which uses <code>ConvexHull</code> from <code>scipy.spatial</code>.</p><p>To cut costs (and limit the scope of this already long article),
we will only move the “core” functionality of <code>Polygon</code> to Rust,
and subclass that from Python to implement the rest of the API.</p><p>Our <code>struct</code> is going to look like this:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>// `Array1` is a 1d array, and the `numpy` crate will play nicely with it.
</span></span></span><span><span><span></span><span>use</span> ndarray::Array1<span>;</span>
</span></span><span><span>
</span></span><span><span><span>// `subclass` tells PyO3 to allow subclassing this in Python.
</span></span></span><span><span><span></span><span>#[pyclass(subclass)]</span>
</span></span><span><span><span>struct</span> <span>Polygon</span> <span>{</span>
</span></span><span><span>    x: <span>Array1</span><span>&lt;</span><span>f64</span><span>&gt;</span><span>,</span>
</span></span><span><span>    y: <span>Array1</span><span>&lt;</span><span>f64</span><span>&gt;</span><span>,</span>
</span></span><span><span>    center: <span>Array1</span><span>&lt;</span><span>f64</span><span>&gt;</span><span>,</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Now we need to actually implement it.
We want to expose <code>poly.{x, y, center}</code> as:</p><ol><li>Properties.</li><li>numpy Arrays.</li></ol><p>We also need a constructor so Python can create new <code>Polygon</code>s.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span> numpy::<span>{</span>PyArray1<span>,</span> PyReadonlyArray1<span>,</span> ToPyArray<span>};</span>
</span></span><span><span>
</span></span><span><span><span>#[pymethods]</span>
</span></span><span><span><span>impl</span> Polygon <span>{</span>
</span></span><span><span>    <span>#[new]</span>
</span></span><span><span>    <span>fn</span> <span>new</span><span>(</span>x: <span>PyReadonlyArray1</span><span>&lt;</span><span>f64</span><span>&gt;</span><span>,</span> y: <span>PyReadonlyArray1</span><span>&lt;</span><span>f64</span><span>&gt;</span><span>)</span> -&gt; <span>Polygon</span> <span>{</span>
</span></span><span><span>        <span>let</span> x <span>=</span> x<span>.</span>as_array<span>();</span>
</span></span><span><span>        <span>let</span> y <span>=</span> y<span>.</span>as_array<span>();</span>
</span></span><span><span>        <span>let</span> center <span>=</span> Array1::from_vec<span>(</span>vec!<span>[</span>x<span>.</span>mean<span>().</span>unwrap<span>(),</span> y<span>.</span>mean<span>().</span>unwrap<span>()]);</span>
</span></span><span><span>
</span></span><span><span>        Polygon <span>{</span>
</span></span><span><span>            x: <span>x</span><span>.</span>to_owned<span>(),</span>
</span></span><span><span>            y: <span>y</span><span>.</span>to_owned<span>(),</span>
</span></span><span><span>            center<span>,</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    
</span></span><span><span>    <span>// the `Py&lt;..&gt;` in the return type is a way of saying &#34;an Object owned by Python&#34;.
</span></span></span><span><span><span></span>    <span>#[getter]</span>               
</span></span><span><span>    <span>fn</span> <span>x</span><span>(</span><span>&amp;</span>self<span>,</span> py: <span>Python</span><span>&lt;</span><span>&#39;_</span><span>&gt;</span><span>)</span> -&gt; <span>PyResult</span><span>&lt;</span>Py<span>&lt;</span>PyArray1<span>&lt;</span><span>f64</span><span>&gt;&gt;&gt;</span> <span>{</span>
</span></span><span><span>        <span>Ok</span><span>(</span>self<span>.</span>x<span>.</span>to_pyarray<span>(</span>py<span>).</span>to_owned<span>())</span> <span>// Create a Python-owned, numpy version of `x`.
</span></span></span><span><span><span></span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>// Same for `y` and `center`.
</span></span></span><span><span><span></span><span>}</span>
</span></span></code></pre></div><p>We need to add our new struct as a class to the module:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>#[pymodule]</span>
</span></span><span><span><span>fn</span> <span>poly_match_rs</span><span>(</span>_py: <span>Python</span><span>,</span> m: <span>&amp;</span><span>PyModule</span><span>)</span> -&gt; <span>PyResult</span><span>&lt;</span><span>()</span><span>&gt;</span> <span>{</span>
</span></span><span><span>    m<span>.</span>add_class::<span>&lt;</span>Polygon<span>&gt;</span><span>()</span><span>?</span><span>;</span> <span>// new.
</span></span></span><span><span><span></span>    m<span>.</span>add_function<span>(</span>wrap_pyfunction!<span>(</span>find_close_polygons<span>,</span> m<span>)</span><span>?</span><span>)</span><span>?</span><span>;</span>
</span></span><span><span>    <span>Ok</span><span>(())</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>And now we can update the Python code to use it:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>class</span> <span>Polygon</span><span>(</span>poly_match_rs<span>.</span>Polygon<span>):</span>
</span></span><span><span>    _area<span>:</span> <span>float</span> <span>=</span> <span>None</span>
</span></span><span><span>
</span></span><span><span>    <span>def</span> <span>area</span><span>(</span>self<span>)</span> <span>-&gt;</span> <span>float</span><span>:</span>
</span></span><span><span>        <span>...</span>
</span></span></code></pre></div><p>We can compile it and it’ll actually work, but it’ll be much slower!
(Remember that <code>x</code>, <code>y</code>, and <code>center</code> will now need to create a new numpy array <strong>on each access</strong>).</p><p>To actually improve performance, we need to <code>extract</code> our original Rust-based <code>Polygon</code> from the list of Python-<code>Polygon</code>s.</p><p>PyO3 is very flexible with this type of operation, so there are a few ways we could do it.
One limit we have is that we also need to return Python-<code>Polygon</code>s, and we don’t want to do any cloning of the actual data.</p><p>It’s possible to manually call <code>.extract::&lt;Polygon&gt;(py)?</code> on each <code>PyObject</code>s, but we ask PyO3 to give us <code>Py&lt;Polygon&gt;</code> directly.</p><p>This is a reference to a Python-owned object,
which we expect to contain an instance (or a subclass, in our case) of a native <code>pyclass</code> struct.</p><div><pre tabindex="0"><code data-lang="rust"><span><span>45</span><span><span>#[pyfunction]</span>
</span></span><span><span>46</span><span><span>fn</span> <span>find_close_polygons</span><span>(</span>
</span></span><span><span>47</span><span>    py: <span>Python</span><span>&lt;</span><span>&#39;_</span><span>&gt;</span><span>,</span>
</span></span><span><span>48</span><span>    polygons: <span>Vec</span><span>&lt;</span>Py<span>&lt;</span>Polygon<span>&gt;&gt;</span><span>,</span>             <span>// References to Python-owned objects.
</span></span></span><span><span>49</span><span><span></span>    point: <span>PyReadonlyArray1</span><span>&lt;</span><span>f64</span><span>&gt;</span><span>,</span>
</span></span><span><span>50</span><span>    max_dist: <span>f64</span><span>,</span>
</span></span><span><span>51</span><span><span>)</span> -&gt; <span>PyResult</span><span>&lt;</span><span>Vec</span><span>&lt;</span>Py<span>&lt;</span>Polygon<span>&gt;&gt;&gt;</span> <span>{</span>           <span>// Return the same `Py` references, unmodified.
</span></span></span><span><span>52</span><span><span></span>    <span>let</span> <span>mut</span> close_polygons <span>=</span> vec!<span>[];</span>
</span></span><span><span>53</span><span>    <span>let</span> point <span>=</span> point<span>.</span>as_array<span>();</span>
</span></span><span><span>54</span><span>    <span>for</span> poly <span>in</span> polygons <span>{</span>
</span></span><span><span>55</span><span>        <span>let</span> center <span>=</span> poly<span>.</span>borrow<span>(</span>py<span>).</span>center <span>// Need to use the GIL (`py`) to borrow the underlying `Polygon`.
</span></span></span><span><span>56</span><span><span></span>            <span>.</span>to_owned<span>();</span>
</span></span><span><span>57</span><span>
</span></span><span><span>58</span><span>        <span>if</span> <span>(</span>center <span>-</span> point<span>).</span>norm<span>()</span> <span>&lt;</span> max_dist <span>{</span>
</span></span><span><span>59</span><span>            close_polygons<span>.</span>push<span>(</span>poly<span>)</span>
</span></span><span><span>60</span><span>        <span>}</span>
</span></span><span><span>61</span><span>    <span>}</span>
</span></span><span><span>62</span><span>
</span></span><span><span>63</span><span>    <span>Ok</span><span>(</span>close_polygons<span>)</span>
</span></span><span><span>64</span><span><span>}</span>
</span></span></code></pre></div><p>Let’s see what we get using this code:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ python measure.py
</span></span><span><span>Took an avg of 6.29ms per iteration
</span></span></code></pre></div><p>We are nearly there! Just x2 to go!</p><h2 id="v3---avoid-allocations">v3 - Avoid allocations</h2><p>Let’s fire up the profiler one more time.</p><ol><li>We start to see <code>select_best_polygon</code>, which now calls some Rust code (when it gets the <code>x</code> &amp; <code>y</code> vectors)<ul><li>We could fix that, but that’s a very small potential improvement (maybe 10%)</li></ul></li><li>We see we spend about 20% the time on <code>extract_argument</code> (under <code>lib_v2.rs:48</code>), so we are still paying quite a lot on overhead!<ul><li>But most of the time is in <code>PyIterator::next</code> and <code>PyTypeInfo::is_type_of</code>, which aren’t easy to fix.</li></ul></li><li>We see a bunch of time spent allocating stuff!<ul><li><code>lib_v2.rs:58</code> is our <code>if</code>, and we see <code>drop_in_place</code> and <code>to_owned</code>.</li><li>The actual line is about 35% of the overall time, which is a lot more than we expect: this should be the “fast bit” with all the data in place.</li></ul></li></ol><p>Let’s tackle the last point.</p><p>This our problematic snippet:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span> center <span>=</span> poly<span>.</span>borrow<span>(</span>py<span>).</span>center
</span></span><span><span>    <span>.</span>to_owned<span>();</span>
</span></span><span><span>
</span></span><span><span><span>if</span> <span>(</span>center <span>-</span> point<span>).</span>norm<span>()</span> <span>&lt;</span> max_dist <span>{</span> <span>..</span><span>.</span> <span>}</span> 
</span></span></code></pre></div><p>What we want is to avoid that <code>to_owned</code>.
But we need an owned object for <code>norm</code>, so we’ll have to implement that manually.</p><p>(The reason we can improve on <code>ndarray</code> here is that we know that our array is actually just 2 <code>f32</code>s).</p><p>This would look like this:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span> ndarray_linalg::Scalar<span>;</span>
</span></span><span><span>
</span></span><span><span><span>let</span> center <span>=</span> <span>&amp;</span>poly<span>.</span>as_ref<span>(</span>py<span>).</span>borrow<span>().</span>center<span>;</span>
</span></span><span><span>
</span></span><span><span><span>if</span> <span>((</span>center<span>[</span><span>0</span><span>]</span> <span>-</span> point<span>[</span><span>0</span><span>]).</span>square<span>()</span> <span>+</span> <span>(</span>center<span>[</span><span>1</span><span>]</span> <span>-</span> point<span>[</span><span>1</span><span>]).</span>square<span>()).</span>sqrt<span>()</span> <span>&lt;</span> max_dist <span>{</span>
</span></span><span><span>    close_polygons<span>.</span>push<span>(</span>poly<span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>But, alas, the borrow checker is unhappy with us:</p><div><pre tabindex="0"><code data-lang="rust"><span><span>error<span>[</span>E0505<span>]</span>: <span>cannot</span> <span>move</span> out of <span>`</span>poly<span>`</span> because it is borrowed
</span></span><span><span>  <span>-</span>-&gt; <span>src</span><span>/</span>lib<span>.</span>rs:<span>58</span>:<span>33</span>
</span></span><span><span>   <span>|</span>
</span></span><span><span><span>55</span> <span>|</span>         <span>let</span> center <span>=</span> <span>&amp;</span>poly<span>.</span>as_ref<span>(</span>py<span>).</span>borrow<span>().</span>center<span>;</span>
</span></span><span><span>   <span>|</span>                       <span>------------------------</span>
</span></span><span><span>   <span>|</span>                       <span>|</span>
</span></span><span><span>   <span>|</span>                       borrow of <span>`</span>poly<span>`</span> occurs here
</span></span><span><span>   <span>|</span>                       a temporary with access to the borrow is created here <span>..</span><span>.</span>
</span></span><span><span><span>..</span><span>.</span>
</span></span><span><span><span>58</span> <span>|</span>             close_polygons<span>.</span>push<span>(</span>poly<span>);</span>
</span></span><span><span>   <span>|</span>                                 <span>^^^^</span> <span>move</span> out of <span>`</span>poly<span>`</span> occurs here
</span></span><span><span><span>59</span> <span>|</span>         <span>}</span>
</span></span><span><span><span>60</span> <span>|</span>     <span>}</span>
</span></span><span><span>   <span>|</span>     <span>-</span> <span>..</span><span>.</span> and the borrow might be used here<span>,</span> when that temporary is dropped and runs the <span>`</span><span>Drop</span><span>`</span> code <span>for</span> <span>type</span> <span>`</span>PyRef<span>`</span>
</span></span></code></pre></div><p>As usual, the borrow checker is correct: we are doing memory crimes.</p><p>The simpler fix is to <em>Just Clone</em>, and <code>close_polygons.push(poly.clone())</code> compiles.</p><p>This is actually a very cheap clone, because we only <code>incr</code> the reference count of the Python object.</p><p>However, in this case we can also shorten the borrow by doing a classic Rust trick:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span> norm <span>=</span> <span>{</span>
</span></span><span><span>    <span>let</span> center <span>=</span> <span>&amp;</span>poly<span>.</span>as_ref<span>(</span>py<span>).</span>borrow<span>().</span>center<span>;</span>
</span></span><span><span>
</span></span><span><span>    <span>((</span>center<span>[</span><span>0</span><span>]</span> <span>-</span> point<span>[</span><span>0</span><span>]).</span>square<span>()</span> <span>+</span> <span>(</span>center<span>[</span><span>1</span><span>]</span> <span>-</span> point<span>[</span><span>1</span><span>]).</span>square<span>()).</span>sqrt<span>()</span>
</span></span><span><span><span>};</span>
</span></span><span><span>
</span></span><span><span><span>if</span> norm <span>&lt;</span> max_dist <span>{</span>
</span></span><span><span>    close_polygons<span>.</span>push<span>(</span>poly<span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Because <code>poly</code> is only borrowed in the inner scope, once we reach <code>close_polygons.push</code> the compiler
can know that we no longer hold that reference, and will happily compile the new version.</p><p>And finally, we have</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ python measure.py
</span></span><span><span>Took an avg of 2.90ms per iteration
</span></span></code></pre></div><p>Which is 100x improvement over the original code.</p><h2 id="summary">Summary</h2><p>We started out with this Python code:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>@dataclass</span>
</span></span><span><span><span>class</span> <span>Polygon</span><span>:</span>
</span></span><span><span>    x<span>:</span> np<span>.</span>array
</span></span><span><span>    y<span>:</span> np<span>.</span>array
</span></span><span><span>    _area<span>:</span> <span>float</span> <span>=</span> <span>None</span>
</span></span><span><span>
</span></span><span><span>    <span>@cached_property</span>
</span></span><span><span>    <span>def</span> <span>center</span><span>(</span>self<span>)</span> <span>-&gt;</span> np<span>.</span>array<span>:</span>
</span></span><span><span>        centroid <span>=</span> np<span>.</span>array<span>([</span>self<span>.</span>x<span>,</span> self<span>.</span>y<span>])</span><span>.</span>mean<span>(</span>axis<span>=</span><span>1</span><span>)</span>
</span></span><span><span>        <span>return</span> centroid
</span></span><span><span>
</span></span><span><span>    <span>def</span> <span>area</span><span>(</span>self<span>)</span> <span>-&gt;</span> <span>float</span><span>:</span>
</span></span><span><span>        <span>...</span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>find_close_polygons</span><span>(</span>
</span></span><span><span>    polygon_subset<span>:</span> List<span>[</span>Polygon<span>],</span> point<span>:</span> np<span>.</span>array<span>,</span> max_dist<span>:</span> <span>float</span>
</span></span><span><span><span>)</span> <span>-&gt;</span> List<span>[</span>Polygon<span>]:</span>
</span></span><span><span>    close_polygons <span>=</span> <span>[]</span>
</span></span><span><span>    <span>for</span> poly <span>in</span> polygon_subset<span>:</span>
</span></span><span><span>        <span>if</span> np<span>.</span>linalg<span>.</span>norm<span>(</span>poly<span>.</span>center <span>-</span> point<span>)</span> <span>&lt;</span> max_dist<span>:</span>
</span></span><span><span>            close_polygons<span>.</span>append<span>(</span>poly<span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>return</span> close_polygons
</span></span><span><span>
</span></span><span><span><span># Rest of file (main, select_best_polygon).</span>
</span></span></code></pre></div><p>We profiled it using <code>py-spy</code>, and even our most <a href="#v1-a-naive-rust-translation">naive, line-to-line translation</a> of <code>find_close_polygons</code> resulted in more than a x10 improvement.</p><p>We did a few additional iterations of profile-write-measure iterations until we finally we gained a x100 improvement in runtime, while keeping the same API as the original library.</p><table><thead><tr><th>Version</th><th>Avg time per iteration (ms)</th><th>Multiplier</th></tr></thead><tbody><tr><td>Baseline implementation (Python)</td><td>293.41</td><td>1x</td></tr><tr><td>Naive line-to-line Rust translation of <code>find_close_polygons</code></td><td>23.44</td><td>12.50x</td></tr><tr><td><code>Polygon</code> implementation in Rust</td><td>6.29</td><td>46.53x</td></tr><tr><td>Optimized allocation implementation in Rust</td><td>2.90</td><td>101.16x</td></tr></tbody></table><p>The final python code looks like this</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>import</span> <span>poly_match_rs</span>
</span></span><span><span><span>from</span> <span>poly_match_rs</span> <span>import</span> find_close_polygons
</span></span><span><span>
</span></span><span><span><span>class</span> <span>Polygon</span><span>(</span>poly_match_rs<span>.</span>Polygon<span>):</span>
</span></span><span><span>    _area<span>:</span> <span>float</span> <span>=</span> <span>None</span>
</span></span><span><span>
</span></span><span><span>    <span>def</span> <span>area</span><span>(</span>self<span>)</span> <span>-&gt;</span> <span>float</span><span>:</span>
</span></span><span><span>        <span>...</span>
</span></span><span><span>
</span></span><span><span><span># Rest of file unchanged (main, select_best_polygon).</span>
</span></span></code></pre></div><p>which calls this Rust code:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span> pyo3::prelude::<span>*</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>use</span> ndarray::Array1<span>;</span>
</span></span><span><span><span>use</span> ndarray_linalg::Scalar<span>;</span>
</span></span><span><span><span>use</span> numpy::<span>{</span>PyArray1<span>,</span> PyReadonlyArray1<span>,</span> ToPyArray<span>};</span>
</span></span><span><span>
</span></span><span><span><span>#[pyclass(subclass)]</span>
</span></span><span><span><span>struct</span> <span>Polygon</span> <span>{</span>
</span></span><span><span>    x: <span>Array1</span><span>&lt;</span><span>f64</span><span>&gt;</span><span>,</span>
</span></span><span><span>    y: <span>Array1</span><span>&lt;</span><span>f64</span><span>&gt;</span><span>,</span>
</span></span><span><span>    center: <span>Array1</span><span>&lt;</span><span>f64</span><span>&gt;</span><span>,</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>#[pymethods]</span>
</span></span><span><span><span>impl</span> Polygon <span>{</span>
</span></span><span><span>    <span>#[new]</span>
</span></span><span><span>    <span>fn</span> <span>new</span><span>(</span>x: <span>PyReadonlyArray1</span><span>&lt;</span><span>f64</span><span>&gt;</span><span>,</span> y: <span>PyReadonlyArray1</span><span>&lt;</span><span>f64</span><span>&gt;</span><span>)</span> -&gt; <span>Polygon</span> <span>{</span>
</span></span><span><span>        <span>let</span> x <span>=</span> x<span>.</span>as_array<span>();</span>
</span></span><span><span>        <span>let</span> y <span>=</span> y<span>.</span>as_array<span>();</span>
</span></span><span><span>        <span>let</span> center <span>=</span> Array1::from_vec<span>(</span>vec!<span>[</span>x<span>.</span>mean<span>().</span>unwrap<span>(),</span> y<span>.</span>mean<span>().</span>unwrap<span>()]);</span>
</span></span><span><span>
</span></span><span><span>        Polygon <span>{</span>
</span></span><span><span>            x: <span>x</span><span>.</span>to_owned<span>(),</span>
</span></span><span><span>            y: <span>y</span><span>.</span>to_owned<span>(),</span>
</span></span><span><span>            center<span>,</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>#[getter]</span>
</span></span><span><span>    <span>fn</span> <span>x</span><span>(</span><span>&amp;</span>self<span>,</span> py: <span>Python</span><span>&lt;</span><span>&#39;_</span><span>&gt;</span><span>)</span> -&gt; <span>PyResult</span><span>&lt;</span>Py<span>&lt;</span>PyArray1<span>&lt;</span><span>f64</span><span>&gt;&gt;&gt;</span> <span>{</span>
</span></span><span><span>        <span>Ok</span><span>(</span>self<span>.</span>x<span>.</span>to_pyarray<span>(</span>py<span>).</span>to_owned<span>())</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>// Same for `y` and `center`.
</span></span></span><span><span><span></span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>#[pyfunction]</span>
</span></span><span><span><span>fn</span> <span>find_close_polygons</span><span>(</span>
</span></span><span><span>    py: <span>Python</span><span>&lt;</span><span>&#39;_</span><span>&gt;</span><span>,</span>
</span></span><span><span>    polygons: <span>Vec</span><span>&lt;</span>Py<span>&lt;</span>Polygon<span>&gt;&gt;</span><span>,</span>
</span></span><span><span>    point: <span>PyReadonlyArray1</span><span>&lt;</span><span>f64</span><span>&gt;</span><span>,</span>
</span></span><span><span>    max_dist: <span>f64</span><span>,</span>
</span></span><span><span><span>)</span> -&gt; <span>PyResult</span><span>&lt;</span><span>Vec</span><span>&lt;</span>Py<span>&lt;</span>Polygon<span>&gt;&gt;&gt;</span> <span>{</span>
</span></span><span><span>    <span>let</span> <span>mut</span> close_polygons <span>=</span> vec!<span>[];</span>
</span></span><span><span>    <span>let</span> point <span>=</span> point<span>.</span>as_array<span>();</span>
</span></span><span><span>    <span>for</span> poly <span>in</span> polygons <span>{</span>
</span></span><span><span>        <span>let</span> norm <span>=</span> <span>{</span>
</span></span><span><span>            <span>let</span> center <span>=</span> <span>&amp;</span>poly<span>.</span>as_ref<span>(</span>py<span>).</span>borrow<span>().</span>center<span>;</span>
</span></span><span><span>
</span></span><span><span>            <span>((</span>center<span>[</span><span>0</span><span>]</span> <span>-</span> point<span>[</span><span>0</span><span>]).</span>square<span>()</span> <span>+</span> <span>(</span>center<span>[</span><span>1</span><span>]</span> <span>-</span> point<span>[</span><span>1</span><span>]).</span>square<span>()).</span>sqrt<span>()</span>
</span></span><span><span>        <span>};</span>
</span></span><span><span>
</span></span><span><span>        <span>if</span> norm <span>&lt;</span> max_dist <span>{</span>
</span></span><span><span>            close_polygons<span>.</span>push<span>(</span>poly<span>)</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>Ok</span><span>(</span>close_polygons<span>)</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>#[pymodule]</span>
</span></span><span><span><span>fn</span> <span>poly_match_rs</span><span>(</span>_py: <span>Python</span><span>,</span> m: <span>&amp;</span><span>PyModule</span><span>)</span> -&gt; <span>PyResult</span><span>&lt;</span><span>()</span><span>&gt;</span> <span>{</span>
</span></span><span><span>    m<span>.</span>add_class::<span>&lt;</span>Polygon<span>&gt;</span><span>()</span><span>?</span><span>;</span>
</span></span><span><span>    m<span>.</span>add_function<span>(</span>wrap_pyfunction!<span>(</span>find_close_polygons<span>,</span> m<span>)</span><span>?</span><span>)</span><span>?</span><span>;</span>
</span></span><span><span>    <span>Ok</span><span>(())</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><h2 id="takeaways">Takeaways</h2><ul><li><p>Rust (with the help of pyo3) unlocks true native performance for everyday Python code, with minimal compromises.</p></li><li><p>Python is a superb API for researchers, and crafting fast building blocks with Rust is an extremely powerful combination.</p></li><li><p>Profiling is super interesting, and it pushes you to truly understand everything that’s happening in your code.</p></li></ul><p>And finally: computers are <em>crazy fast</em>. The next time you wait for something to complete, consider firing up a profiler, you might learn something new 🚀</p></div></div></div>
  </body>
</html>
