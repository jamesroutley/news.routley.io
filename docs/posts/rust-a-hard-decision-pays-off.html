<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.pinecone.io/learn/inside-the-pinecone/#rust-a-hard-decision-pays-off">Original</a>
    <h1>Rust – A hard decision pays off</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p><img loading="lazy" src="https://d33wubrfki0l68.cloudfront.net/24d097ec3c05ea389318b31f41360825723f9eef/41b0a/images/inside-the-pinecone.jpg" alt="Inside the Pinecone" width="100%"/></p><p>Last week we <a href="https://www.pinecone.io/learn/faster-easier-scalable/">announced</a> a major <a href="https://www.pinecone.io/docs/release-notes/#august-16-2022">update</a>. The incredible work that led to the launch and the reaction from our users — a combination of delight and curiosity — inspired me to write this post. This is a glimpse into the journey of building a database company up to this point, some of the internal debates and decisions we made along the way (bad and good alike), and on-going innovation at the core of Pinecone that I find exciting.</p><h2 id="in-memory-graph-based-index">In-memory graph-based index</h2><p>In May 2010, I wrote Professor <a href="https://scholar.google.com/citations?user=vTigGywAAAAJ&amp;hl=en">Yuval Rabani</a> an email. Yuval is one of the inventors of approximate nearest neighbor (ANN) search as a concept. I suggested we work together on answering a seemingly simple question:</p><p><em>“Why are graph based data structures so good at vector search?”</em></p><p>You see, they were much better in practice than the theory predicted they should be. This hinted that we were lacking some fundamental understanding of either <a href="https://www.pinecone.io/learn/vector-search-basics/">vector search</a> or graph based indexes (or both). We decided to analyze the behavior of vector search with graphs using mathematical machinery from a different domain. Specifically, those spearheaded by <a href="http://www.cs.yale.edu/homes/spielman/">Dan Speilman</a> for bounding the running time of solving systems of linear equations (for the CS theoreticians, think about max-dot product search and its similarity to the simplex method, and it will make more sense). We made some progress with this approach, but never quite got a full answer. Graph based vector search still seemed to be “too good”.</p><p>Fast forward twelve years, graph based techniques now take center stage for vector search software. These include <a href="https://www.pinecone.io/learn/hnsw/">HNSW</a> by <a href="https://www.linkedin.com/in/yury-malkov-b6597382/">Yuri Malkov</a> (an advisor to Pinecone), implementations in <a href="https://www.pinecone.io/learn/faiss/">Faiss</a>, and a flurry of further research and software progress. It was therefore only natural for Pinecone to consider using graph indexes for its vector database.</p><p>Bringing graph based search into a production-grade database, however, was not going to be simple. As a managed database, we have to make sure our systems always work and without the user tweaking and experimenting with different configurations. We could not afford to have best-effort-heuristics and magic-constants floating around. We also knew we needed to efficiently combine metadata filtering and graph traversal, optimize updates and deletes, and other functionality which HNSW or Faiss do not provide.</p><p>In the end, we did it. It took many months of work by Pinecone’s technical leaders <a href="https://www.linkedin.com/in/marek-galovic/?originalSubdomain=cz">Marek Galovic</a>, <a href="https://www.linkedin.com/in/roei-mutay-bb3743200/?originalSubdomain=il">Roei Mutay</a>, and <a href="https://www.linkedin.com/in/harsha340/">Ram Sriharsha</a> along with Yuri Malkov. We now have a high-performance, stable, fully dynamic, and filterable graph index!</p><p>However, my curiosity from twelve years ago hasn’t diminished one bit. There is still so much we don’t know. Under what conditions can we guarantee the convergence of the search method? Can we check in advance what datasets are good for graph based indexes? Can we reliably prune graphs and keep their search effectiveness? I truly hope to be able to make some progress on these questions soon.</p><h2 id="a-new-storage-engine-for-vectors">A new storage engine for vectors</h2><p>Because Pinecone is a managed vector database and not just an index, we need to take care of storage and persistence of the data in every index. We also need to constantly update and fetch thousands of raw vectors in milliseconds. Think about batch updates (upserts), raw vector-metadata fetch operations, and most importantly, raw <em>exact</em> comparisons between queries and candidate matches suggested by the ANN vector search index. We need an object storage engine.</p><p>We originally chose <a href="http://rocksdb.org/">RocksDB</a> for that. RocksDB is commonly used as an embedded layer in other database offerings. And, developing a completely new storage engine seemed like an insurmountable effort; the specter of data-loss looms big in our collective psyche.</p><p>We were very happy with our decision. We loved RocksDB. It is a great piece of software. It was 100% the right choice, until it wasn’t…</p><p>When we tried to vertically scale our pods, we started hitting RocksDB limits. Write throughput became a big issue. Simultaneous fetches of thousands (sometimes tens of thousands) of objects started becoming inefficient, especially when fetching from collections of tens of millions of objects. The fetch latency variance also grew. Higher p99 latencies started leaking into our p50s when operating horizontally distributed indexes. Write amplification started really hurting our pods’ capacities… To make matters worse, we were also spending a ton of time and energy grappling with RocksDB trying to maximize our performance.</p><p>Late last year, our VP of Engineering, <a href="https://www.linkedin.com/in/harsha340/">Ram Sriharsha</a>, came up with a brillant <a href="https://en.wikipedia.org/wiki/Bitcask">bitcask-like</a> design for a completely new vector store that is optimized for random multigets and updates, low fetch variance, minimal storage overhead, and maximal operational simplicity.</p><p><a href="https://www.linkedin.com/in/marek-galovic/?originalSubdomain=cz">Marek</a> and Ram took on the herculean challenge to build the initial new vector store (internally nicknamed memkey). The resulting object store is up to 10x faster than RocksDB on large datasets. It reduces our overall operating costs 30-50%. We passed these improvements on to our customers when we <a href="https://www.pinecone.io/docs/release-notes/#improved-p1-and-s1-performance">updated p1 and s1 pods to use the new vector store</a>. Customers will seamlessly get more capacity and lower latency without changing a single line of code on their end. How cool is that?</p><p><img loading="lazy" src="https://d33wubrfki0l68.cloudfront.net/ebe5187f9793f052cbca86e07f4a31245ed3faa6/d6e45/images/multiget-latency.png" alt="Multiget latency" width="100%"/>
<small>Memkey’s low (and flat!) multiget latency as collections grow compared to RocksDB. On the y-axis: Multiget times in milliseconds for fetching 1000 random objects (vectors) from local SSD. On the x-axis: Collection size being 5m, 10mm, 20m, and 40mm.</small></p><h2 id="rust-a-hard-decision-pays-off">Rust: A hard decision pays off</h2><p>Although this change was implemented inside Pinecone a while ago, this is the first time we’re talking about it publically.</p><p>In the beginning, Pinecone was built with a mix of C/C++ and Python. The argument for this went something like this: a C/C++ core will be highly efficient, and experienced C/C++ engineers are easy to find. Anything not at the core doesn’t have to be efficient. It can therefore be easily and quickly delivered in Python, which sacrifices running speed with easy development. It was, indeed, relatively easy to develop, and we got some impressive results pretty quickly. So, that seemed to be the winning formula. We went for it full tilt.</p><p>Not until a few weeks before a big release last year did the number of issues we had to fix begin to pile up. We kept fixing one issue only to discover (or create) another. Every few hours we would find some major bug or oversight in our codebase; and each cycle to fix and redeploy took hours of work. To make matters worse, we would discover issues only after deploying (or in production!) due to Python’s run time nature. Sometimes these would be minor bugs that any compiler would have easily flagged, and sometimes they were complex runtime issues which were almost impossible to reproduce or isolate.</p><p>That’s when internal murmurs about a complete rewrite started brewing…</p><p>I personally vehemently resisted the idea. Rewrites are notoriously dangerous. They feel exciting at first, but often turn sour. First, they always end up being much bigger projects than you plan for. This is especially dangerous in a startup where a significant delay in shipping new features could be your undoing. Second, rewrites often backfire in spectacular ways; the new codebase often produces completely new challenges, often much worse than those you originally had.</p><p>Nevertheless, we reached a tipping point. We decided to move our entire codebase to Rust (and Go for the k8s control plane). Rust seemed to give us all the capabilities we needed, however, there was still one <em>minor</em> problem - no one on the team knew Rust. It was (and still is) a hard-to-master, young language with a much smaller community than either C++ or Python.</p><p>We started with a small team of senior engineers and managers learning Rust and developing the skeleton of the DB and dev environment (for others to build on). Then, slowly, others joined in rewriting and contributing different components until we eventually got rid of the old codebase altogether (I still remember the day my original C modules, from the first days of Pinecone, were taken out). Unbeknownst to most Pinecone customers, the new Rust core was deployed in March this year. And in the process of taking over running workloads, we managed not to drop a single API call!</p><p>So, what did we learn? We all expect performance and dev processes to improve. Those indeed happened. What we didn’t expect was the extent to which dev velocity increased and operational incidents decreased. Dev velocity, which was supposed to be the claim to fame of Python, improved dramatically with Rust. Built-in testing, CI/CD, benchmarking, and an overzealous compiler increased engineers’ confidence in pushing changes, and enabled them to work on the same code sections and contribute simultaneously without breaking the code base. Most impressively though, real time operational events dropped almost to zero overnight after the original release. Sure, there are still surprises here and there but, by and large, the core engine has been shockingly stable and predictable.</p><hr/><p><em>Note: Interested in hearing more about our Rust rewrite? Don’t miss <a href="https://www.meetup.com/rust-nyc/events/287821884/">our talk at the NYC Rust meetup on August 31</a>, and subscribe for updates at the bottom of this page to get notified when we post the full writeup.</em></p><hr/><h2 id="closing-thoughts">Closing thoughts</h2><p>While I could keep rambling on about more exciting developments within the space like vertical scaling, data collections, more advanced monitoring, and others, those will have to wait until the next post.</p><p>If building the best vector database in the world sounds exciting, give me a ping. <a href="https://www.pinecone.io/careers/">We are hiring</a> on all fronts. Also, if you are building on Pinecone and missing a feature or experiencing something other than expected, please don’t be shy and write to me directly (<a href="mailto:edo@pinecone.io">edo@pinecone.io</a>).</p></div></div></div></div>
  </body>
</html>
