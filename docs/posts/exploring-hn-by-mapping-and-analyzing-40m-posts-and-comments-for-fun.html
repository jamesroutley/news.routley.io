<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.wilsonl.in/hackerverse/">Original</a>
    <h1>Exploring HN by mapping and analyzing 40M posts and comments for fun</h1>
    
    <div id="readability-page-1" class="page"><div>
    <article>
      
<p><img src="https://blog.wilsonl.in/hackerverse/map.png" alt="Semantic map of Hacker News posts."/></p>
<p>The above is a map of all Hacker News posts since its <a href="https://news.ycombinator.com/item?id=1">founding</a>, laid semantically i.e. where there <em>should</em> be some relationship between positions and distances. I&#39;ve been building it and some other interesting stuff over the past few weeks, to play around with <a href="https://platform.openai.com/docs/guides/embeddings">text embeddings</a>. Given that HN has a lot of interesting, curated content and <a href="https://github.com/HackerNews/API">exposes all its content programatically</a>, I thought it&#39;d be a fun place to start.</p>
<p>A quick primer of embeddings: they are a powerful and cool way to represent <em>something</em> (in this case, text) as a point in a high-dimensional <a href="https://en.wikipedia.org/wiki/Latent_space">space</a>, which in practical terms just means an array of floats, one for its coordinate in that dimension. The absolute position doesn&#39;t really mean much, but their relativity to each other is where much of their usefulness comes in, because &#34;similar&#34; things should be nearby, while dissimilar things are far apart. Text embeddings these days often <a href="https://en.wikipedia.org/wiki/BERT_(language_model)">come from language models</a>, given their SOTA understanding of the meaning of text, and it&#39;s pretty trivial to generate them given the high-quality open source <a href="https://huggingface.co/spaces/mteb/leaderboard">models</a> and <a href="https://huggingface.co/sentence-transformers">libraries</a>, that are freely accessible to anyone with a CPU or GPU.</p>
<p>Going in, my theories for what I could do <em>if</em> I had the embeddings were:</p>
<ul>
<li>Powerful search: given HN&#39;s curated high bar of content, I knew there were lots of interesting insights and things I&#39;ve missed over the years. It&#39;d be cool if I could query something like &#34;how to communicate well&#34; and instantly surface the best advice over the years for communicating.</li>
<li>Recommendations: it might be possible to build a personalized discovery engine by navigating the latent space of HN content biased towards/away from dis/interest areas.</li>
<li>Analysis: there are a lot of opinions on HN. It should be possible to calculate the sentiment and popularity of various topics within the community, find opposing viewpoints, etc.</li>
</ul>
<p>These sounded pretty interesting, so I decided to dive right in. In this blog post, I&#39;ll lay out my journey starting from no data and no code, to interactive search, analysis, and spatial visualization tools leveraging millions of HN content, dive into all the interesting diverse problems and solutions that came up along the way, and hopefully give you some indication (and hopefully motivation) of the power and applicability of embeddings in many areas.</p>
<p>You may also have better ideas of using the data or the demo that I came up with. I&#39;m also opening up all the data and source code that I built as part of this journey, and invite you to use them to play around, suggest and refine ideas, or kick off your own creative projects and learning journeys. Over 30 million comments and 4 million posts are available to download <a href="https://github.com/wilsonzlin/hackerverse/releases/tag/dataset-39996091">here</a>, which include metadata (IDs, scores, authors, etc.), embeddings, and texts (including crawled web pages). The code is also <a href="https://github.com/wilsonzlin/hackerverse">completely open source</a>; feel free to fork, open PRs, or raise issues. If you do end up using the code or data, I&#39;d appreciate a reference back to this project and blog post.</p>
<p>If you want to jump right to the demo, <a href="#demo">click here</a>. Otherwise, let&#39;s dive in!</p>
<h2 id="fetching-items-from-hn">Fetching items from HN</h2>
<p>HN has a very simple <a href="https://github.com/HackerNews/API">public API</a>:</p>
<pre><code>GET /v0/item/$ITEM_ID.json
Host: hacker-news.firebaseio.com
</code></pre><p>Everything is an <em>item</em>, and the response always has the same JSON object structure:</p>
<pre><code><span>{</span>
  <span>&#34;by&#34;</span><span>:</span> <span>&#34;dhouston&#34;</span><span>,</span>
  <span>&#34;descendants&#34;</span><span>:</span> <span>71</span><span>,</span>
  <span>&#34;id&#34;</span><span>:</span> <span>8863</span><span>,</span>
  <span>&#34;score&#34;</span><span>:</span> <span>111</span><span>,</span>
  <span>&#34;time&#34;</span><span>:</span> <span>1175714200</span><span>,</span>
  <span>&#34;title&#34;</span><span>:</span> <span>&#34;My YC app: Dropbox - Throw away your USB drive&#34;</span><span>,</span>
  <span>&#34;type&#34;</span><span>:</span> <span>&#34;story&#34;</span><span>,</span>
  <span>&#34;url&#34;</span><span>:</span> <span>&#34;http://www.getdropbox.com/u/2/screencast.html&#34;</span>
<span>}</span>
</code></pre><p>There&#39;s also a <a href="https://hacker-news.firebaseio.com/v0/maxitem.json">maxitem.json</a> API, which gives the largest ID. As of this writing, the max item ID is over 40 million. Even with a very nice and low 10 ms mean response time, this would take over 4 days to crawl, so we need some parallelism.</p>
<p>I decided to write a <a href="https://github.com/wilsonzlin/hackerverse/tree/master/enqueuer">quick service</a> in Node.js to do this. An initial approach with a <a href="https://github.com/wilsonzlin/xtjs-lib/blob/master/Semaphore.ts">semaphore</a> and then queueing up the fetch Promises, despite being simple and async, ended up being too slow, with most CPU time being spent in userspace JS code.</p>
<p>It&#39;s a good reminder that Node.js can handle async I/O pretty well, but it&#39;s still fundamentally a single-threaded dynamic language, and those few parts running JS code can still drag down performance. I moved to using the <a href="https://nodejs.org/api/worker_threads.html">worker threads</a> API and distributed the fetches across all CPUs, which ended up saturating all cores on my machine, mostly spent in kernel space (a good sign). The final code ended up looking something like:</p>
<pre><code><span>new</span> <span>WorkerPool</span>(__filename, <span>cpus</span>().<span>length</span>)
  .<span>workerTask</span>(<span>&#34;process&#34;</span>, <span>async</span> (<span>id</span>: <span>number</span>) =&gt; {
    <span>const</span> item = <span>await</span> <span>fetchItem</span>(id);
    <span>await</span> <span>processItem</span>(item);
  })
  .<span>leader</span>(<span>async</span> (pool) =&gt; {
    <span>let</span> nextId = <span>await</span> <span>getNextIdToResumefrom</span>();
    <span>const</span> maxId = <span>await</span> <span>fetchHnMaxId</span>();

    <span>let</span> nextIdToCommit = nextId;
    <span>const</span> idsPendingCommit = <span>new</span> <span>Set</span>&lt;<span>number</span>&gt;();
    <span>let</span> flushing = <span>false</span>;
    <span>const</span> <span>maybeFlushId</span> = <span>async</span> (<span></span>) =&gt; {
      <span>if</span> (flushing) {
        <span>return</span>;
      }
      flushing = <span>true</span>;
      <span>let</span> didChange = <span>false</span>;
      <span>while</span> (idsPendingCommit.<span>has</span>(nextIdToCommit)) {
        idsPendingCommit.<span>delete</span>(nextIdToCommit);
        nextIdToCommit++;
        didChange = <span>true</span>;
      }
      <span>if</span> (didChange) {
        <span>await</span> <span>recordNextIdToResumeFrom</span>(nextIdToCommit);
      }
      flushing = <span>false</span>;
    };

    <span>const</span> <span>CONCURRENCY</span> = <span>cpus</span>().<span>length</span> * <span>16</span>;
    <span>await</span> <span>Promise</span>.<span>all</span>(
      <span>Array</span>.<span>from</span>({ <span>length</span>: <span>CONCURRENCY</span> }, <span>async</span> () =&gt; {
        <span>while</span> (nextId &lt;= maxId) {
          <span>const</span> id = nextId++;
          <span>await</span> pool.<span>execute</span>(<span>&#34;process&#34;</span>, id);
          idsPendingCommit.<span>add</span>(id);
          <span>maybeFlushId</span>();
        }
      }),
    );
  })
  .<span>go</span>();
</code></pre><p><a href="https://github.com/wilsonzlin/xtjs-lib/blob/master/WorkerPool.ts">WorkerPool</a> is a helper class I made to simplify using worker threads, by making it easy to make type-checked requests between the main thread and a pool of worker threads. The parallelism fetched things out-of-order, so for idempotency, I recorded the marker in order so I don&#39;t skip anything if it is interrupted.</p>
<p>Some interesting things I noticed about the HN items returned by the API:</p>
<ul>
<li>Scores never seem to be below -1.</li>
<li>You can&#39;t get the downvotes for posts, and the votes at all for comments.</li>
<li>Some posts and comments have blank titles and texts/URLs, despite not being flagged or deleted; I presume they were moderated.</li>
<li>It&#39;s possible for comment IDs to have be smaller than an ancestor, probably due to a moderator moving the comment tree.</li>
</ul>
<p>I&#39;ve exported the HN crawler (in TypeScript) to its own <a href="https://github.com/wilsonzlin/crawler-toolkit-hn">project</a>, if you&#39;re ever in need to fetch HN items.</p>
<h2 id="generating-embeddings">Generating embeddings</h2>
<p>My initial theory was that the title alone would be enough to semantically represent a post, so I dove right in with just the data collected so far to generate some embeddings. The <a href="https://huggingface.co/spaces/mteb/leaderboard">Massive Text Embedding Benchmark (MTEB)</a> is a good place to compare the latest SOTA models, where I found <a href="https://huggingface.co/BAAI/bge-m3">BGE-M3</a>, the latest iteration of the popular <a href="https://huggingface.co/BAAI/bge-base-en-v1.5">FlagEmbedding</a> models that came out last year. Their v3 version supports generating &#34;lexical weights&#34; for basically free, which are essentially sparse bags-of-words, a map from token ID to weight, which you can use with an algorithm like BM25 in addition to the normal &#34;dense&#34; embeddings for hybrid retrieval. According to their <a href="https://arxiv.org/pdf/2402.03216">paper</a>, this increases retrieval performance significantly.</p>
<p>The infrastructure required for generating embeddings is not so trivial:</p>
<ul>
<li>Models are computationally expensive, with good ones having anything from millions to billions of parameters.</li>
<li>Like most AI models, they are much more efficient to compute on GPUs, but GPU clusters are expensive.</li>
<li>Inference can take hundreds of milliseconds, meaning a processing rate in the ballpark of <em>tens</em> per second. That&#39;s almost a <em>year</em> to process 40 million inputs on one GPU.</li>
<li>The GPUs are likely separate from our data and server machines. A way to ensure a flowing full pipe from our data to our GPUs will ensure our GPUs are not expensively idling.</li>
</ul>
<p>Fortunately, I discovered <a href="https://runpod.io">RunPod</a>, a provider of machines with GPUs that you can deploy your containers onto, at a cost far cheaper than major cloud providers. They also have more cost-effective GPUs like RTX 4090, while still running in datacenters with fast Internet connections. This made scaling up a price-accessible option to mitigate the inference time required.</p>
<p>The GPUs were scattered around the world, so DB connection latency and connection overhead became a problem, and the decentralized client-side pooling caused a lot of server overhead. I created <a href="https://github.com/wilsonzlin/db-rpc">db-rpc</a> to mitigate these aspects. It&#39;s a simple service that proxies SQL queries over HTTP/2 to a local DB with a large shared connection pool. HTTP/2 supports multiplexing (= many queries, one connection, no blocking), lighter connections, and quicker handshakes, so for the simple queries I&#39;m making (CRUD statements), it worked great.</p>
<p>A simple message queue was needed to distribute the item IDs to embed to the various GPU workers, which is exactly what AWS SQS offers. Unfortunately, it has quite low rate limits and is expensive per message, which is annoying given the millions of tiny job messages. Some batching can mitigate this partially, but I often need something like this, so I created <a href="https://github.com/wilsonzlin/queued">queued</a>, a RocksDB-based queue service written in Rust. It handles 100K+ op/s with one node, so there&#39;s no worrying about batching, message sizes, rate limits, and costs. RocksDB&#39;s write-optimized design makes for a great queue storage backing.</p>
<p>The optimizations paid off: after scaling to ~150 GPUs, all 40 million posts and comments were embedded in only a few hours. A snapshot from my Grafana dashboard indicates some of the impact:</p>
<p><img src="https://blog.wilsonl.in/hackerverse/embedder-grafana.png" alt="Grafana dashboard of a period during the embeddings process."/></p>
<p>The GPU utilization stayed peak for the entire time, and the processing rate was stable. Connection latencies remained steady and low on average despite many distributed workers and concurrent queries, although there was not as much batching because it was quite expensive to embed each input (at around 600 ms <em>per input</em>), as previously mentioned.</p>
<h2 id="adding-additional-context-by-crawing-the-web">Adding additional context by crawing the web</h2>
<p>Unfortunately, my theory about the titles being enough did not pay off. While it worked well for most posts because they have descriptive titles, a lot have <a href="https://news.ycombinator.com/item?id=21686264">&#34;strange&#34;</a>, <a href="https://news.ycombinator.com/item?id=25771953">creative</a>, <a href="https://news.ycombinator.com/item?id=21379174">ambiguous</a> titles that don&#39;t play well with the embedding model. Also, the model tended to cluster <em>Ask HN</em> and <em>Show HN</em> posts together, regardless of topic, probably because, given that the entire input was just the title, those two phrases were significant. I needed more context to give to the model.</p>
<p>For text posts and comments, the answer is simple. However, for the vast majority of link posts, this would mean crawling those pages being linked to. So I wrote up a quick <a href="https://github.com/wilsonzlin/hackerverse/tree/master/crawler">Rust service</a> to fetch the URLs linked to and parse the HTML for metadata (title, picture, author, etc.) and text. This was CPU-intensive so an initial Node.js-based version was 10x slower and a Rust rewrite was worthwhile. Fortunately, other than that, it was mostly smooth and painless, likely because HN links are pretty good (responsive servers, non-pathological HTML, etc.).</p>
<p>Extracting text involved parsing the HTML using the excellent <a href="https://docs.rs/scraper/latest/scraper/">scraper</a>, removing <a href="https://github.com/wilsonzlin/hackerverse/blob/14fde395984a693e0d05c3bfc6f37bb2a7f7f549/crawler/parse.rs#L45">semantically non-primary HTML5 elements</a>, and <a href="https://github.com/wilsonzlin/hackerverse/blob/14fde395984a693e0d05c3bfc6f37bb2a7f7f549/crawler/parse.rs#L140">traversing the remaining tree</a>.</p>
<p>A <em>lot</em> of content even on Hacker News suffers from the well-known <a href="https://en.wikipedia.org/wiki/Link_rot">link rot</a>: around 200K resulted in a 404, DNS lookup failure, or connection timeout, which is a sizable &#34;hole&#34; in the dataset that would be nice to mend. Fortunately, the <a href="https://en.wikipedia.org/wiki/Internet_Archive">Internet Archive</a> has an <a href="https://archive.org/help/wayback_api.php">API</a> that we can use to use to programmatically fetch archived copies of these pages. So, as a final push for a more &#34;complete&#34; dataset, I used the Wayback API to fetch the last few thousands of articles, some dating back years, which was very annoying because IA has very, very low rate limits (around 5 per minute).</p>
<p>Our end tally of pages that could not be fetched:</p>
<p><img src="https://blog.wilsonl.in/hackerverse/fetch_err.webp" alt="Pie chart of fetch error counts."/></p>
<p>Not bad, out of 4 million. That&#39;s less than 5% of all fetched pages.</p>
<h2 id="embeddings,-attempt-two">Embeddings, attempt two</h2>
<p>Web pages are long, but luckily the BGE-M3 model supports a context window of 8192 tokens. However, the model is really slow, as we saw previously, so I decided to switch to <a href="https://huggingface.co/jinaai/jina-embeddings-v2-small-en">jina-embeddings-v2-small-en</a> which has a far smaller parameter count, while still having good performance (according to MTEB). This saved a lot of time and money, as the inference time dropped to 6 ms (100x faster):</p>
<p><img src="https://blog.wilsonl.in/hackerverse/embedder-grafana-jinav2small.png" alt="Grafana dashboard of embedder using jina-embeddings-v2-small-en."/></p>
<p>The GPUs could not actually be saturated, because any increase in batch size would cause OOMs due to the extended length of the inputs.</p>
<p>Some pages did not have a lot of text (e.g. more creative visual pages), or could not be fetched at all. To still ensure these posts still had decent context, I packed the top HN comments for those posts after the page text as extra &#34;insurance&#34;:</p>
<pre><code><span>const</span> topComments = item.<span>kids</span>?.<span>slice</span>() ?? [];
<span>const</span> <span>MAX_LEN</span> = <span>1024</span> * <span>64</span>; 
<span>while</span> (topComments.<span>length</span> &amp;&amp; embInput.<span>length</span> &lt; <span>MAX_LEN</span>) {
  
  <span>const</span> i = <span>await</span> <span>fetchItem</span>(topComments.<span>shift</span>()!);
  
  <span>if</span> (!i || i.<span>type</span> !== <span>&#34;comment&#34;</span> || i.<span>dead</span> || i.<span>deleted</span> || i.<span>score</span>! &lt; <span>0</span>) {
    <span>continue</span>;
  }
  <span>const</span> text = <span>extractText</span>(i.<span>text</span> ?? <span>&#34;&#34;</span>);
  <span>if</span> (!addedSep) {
    
    embInput += <span>&#34;\n\n# Comments:\n==========&#34;</span>;
    addedSep = <span>true</span>;
  } <span>else</span> {
    embInput += <span>&#34;\n\n----------&#34;</span>;
  }
  embInput += <span>&#34;\n\n&#34;</span> + text;
}
embInput = embInput.<span>slice</span>(<span>0</span>, <span>MAX_LEN</span>);
</code></pre><p>For comments, many refer to parents or ancestors, so wouldn&#39;t make sense alone. Using a similar approach, I traversed comments&#39; ancestors and built up a longer context with everything up to the post title. Now, the inputs for posts and comments were nice and full of context, hopefully corresponding to more accurate, useful embeddings.</p>
<p>One thing I did this time round was to create a <code>kv</code> table that could hold arbitrary keys and values, and store these large values (embeddings, texts, etc.) there. When stored alongside the row, they would make the row &#34;fat&#34; and updates to any column (even for a tiny value) were expensive. Schema changes were also expensive. These weren&#39;t worth the benefits of having these mostly-opaque values within a row, which were basically none.</p>
<h2 id="umap">UMAP</h2>
<p><a href="https://umap-learn.readthedocs.io/en/latest/index.html">Uniform Manifold Approximation and Projection (UMAP)</a> is a dimensionality reduction technique, which means to take our large 1024-dimension embedding vectors and turn them into points in fewer dimensional space <em>while</em> still (trying) to preserve most of the semantic relationships between points. <a href="https://scikit-learn.org/stable/modules/decomposition.html#pca">PCA</a> and <a href="https://scikit-learn.org/stable/modules/manifold.html#t-sne">t-SNE</a> are similar algorithms in this space you may have heard of, but UMAP is newer and <a href="https://umap-learn.readthedocs.io/en/latest/performance.html">makes the case</a> that it offers a better performance-accuracy trade-off than the others. Regardless of which algorithm, dim. reduction is often used to visualize embeddings, because it&#39;s hard to &#34;see&#34; points in 1024-dimensional space. We&#39;ll use UMAP to reduce our embeddings to 2D space, so we can scatter plot it and do some basic eyeballing for basic checks and anything interesting with our dataset.</p>
<p>Generating the 2D embeddings is not hard. UMAP takes in two main things: a PyNNDescent graph, and the original embeddings. There are <a href="https://umap-learn.readthedocs.io/en/latest/parameters.html">a few hyperparameters</a> that affect the distribution of points in the lower dim. space, as well as the primary parameter: the target dimensionality.</p>
<pre><code><span>import</span> umap

<span>with</span> <span>open</span>(<span>&#34;ann.joblib&#34;</span>, <span>&#34;rb&#34;</span>) <span>as</span> f:
    ann = joblib.load(f)
knn_indices, knn_dists = ann.neighbor_graph
mat_emb = np.memmap(<span>&#34;emb.mat&#34;</span>, dtype=np.float32, mode=<span>&#34;r&#34;</span>, shape=(N_ITEMS, <span>512</span>))

mapper = umap.UMAP(
    precomputed_knn=(knn_indices, knn_dists, ann),
    n_components=<span>2</span>,
    metric=<span>&#34;cosine&#34;</span>,
    n_neighbors=N_NEIGHBORS,
    min_dist=MIN_DIST,
)
mapper.fit(mat_emb)

mat_umap = mapper.embedding_
<span>with</span> <span>open</span>(<span>&#34;emb_umap.mat&#34;</span>, <span>&#34;wb&#34;</span>) <span>as</span> f:
    f.write(mat_umap.tobytes())

<span>with</span> <span>open</span>(<span>&#34;umap-model.joblib&#34;</span>, <span>&#34;wb&#34;</span>) <span>as</span> f:
    joblib.dump(mapper, f)
</code></pre><p>Training is highly parallel and, with millions of high dim. inputs, can take a while, so I spun up a c7i.metal-48xl VM on EC2. After about an hour and a half, maxing out the 96-core processor, it was done, and an equivalent <code>(N_ITEMS, 2)</code> matrix was available. I saved both the 2D embeddings, as well as the trained model which can be later used to transform other embeddings without running the fitting process again.</p>
<p>Let&#39;s now plot these 2D embeddings and see what we find.</p>
<pre><code><span>import</span> matplotlib.pyplot <span>as</span> plt

mat_umap = load_umap()

plt.figure(figsize=(<span>10</span>, <span>10</span>))
plt.gca().invert_yaxis()
plt.scatter(mat_umap[:, <span>0</span>], mat_umap[:, <span>1</span>], s=<span>1</span>)

plt.savefig(<span>&#34;umap.webp&#34;</span>, dpi=<span>300</span>, bbox_inches=<span>&#34;tight&#34;</span>)
</code></pre><p><img src="https://blog.wilsonl.in/hackerverse/umap.webp" alt="Plot of all post UMAP embeddings."/></p>
<p>Oops, too many points. Let&#39;s do a quick and easy way to reduce the points by tiling into a fine (but finite) grid and selecting only the highest-scoring post from each cell. Let&#39;s also add some titles so we see how those points relate:</p>
<pre><code><span>import</span> pyarrow

df = pyarrow.feather.read_feather(<span>&#34;posts.arrow&#34;</span>, memory_map=<span>True</span>)
df_titles = pyarrow.feather.read_feather(<span>&#34;post_titles.arrow&#34;</span>, memory_map=<span>True</span>)
df = df.merge(df_titles, on=<span>&#34;id&#34;</span>, how=<span>&#34;inner&#34;</span>)
df[<span>&#34;x&#34;</span>] = mat_umap[:, <span>0</span>]
df[<span>&#34;y&#34;</span>] = mat_umap[:, <span>1</span>]

x_range = df[<span>&#34;x&#34;</span>].<span>max</span>() - df[<span>&#34;x&#34;</span>].<span>min</span>()
y_range = df[<span>&#34;y&#34;</span>].<span>max</span>() - df[<span>&#34;y&#34;</span>].<span>min</span>()
grid_size = <span>100</span>
df[<span>&#34;cell_x&#34;</span>] = df[<span>&#34;x&#34;</span>] // (x_range / grid_size)
df[<span>&#34;cell_y&#34;</span>] = df[<span>&#34;y&#34;</span>] // (y_range / grid_size)
df = df.sort_values(<span>&#34;score&#34;</span>, ascending=<span>False</span>).drop_duplicates([<span>&#34;cell_x&#34;</span>, <span>&#34;cell_y&#34;</span>])

plt.figure(figsize=(<span>50</span>, <span>50</span>))
plt.gca().invert_yaxis()
plt.scatter(df[<span>&#34;x&#34;</span>], df[<span>&#34;y&#34;</span>], s=<span>1</span>)
<span>for</span> i, row <span>in</span> df.sample(n=<span>1000</span>).iterrows():
    plt.annotate(row[<span>&#34;text&#34;</span>], (row[<span>&#34;x&#34;</span>], row[<span>&#34;y&#34;</span>]), fontsize=<span>3</span>)
</code></pre><p>It&#39;s a bit hard to see (there are still lots of points and text labels, so the image is very high resolution), but if you open the image and zoom in, you can see the 2D space and the semantic relationships between points a bit more clearly:</p>
<p><img src="https://blog.wilsonl.in/hackerverse/umap-labelled.webp" alt="Plot of some post UMAP embeddings, with some labelled."/></p>
<p>It also looks like adding more context paid off, as those previously-mentioned posts with &#34;exotic&#34; titles are now placed in more accurate points near related content.</p>
<h2 id="cosine-similiarity">Cosine similiarity</h2>
<p>All the data is now ready. A lot of using embeddings involves finding the similarity between them. This is basically the inverse of the distance: if something is far away (high distance), it&#39;s not similar (low similarity), and vice versa. From school, we may think of one way to measure the distance between two points:</p>
<pre><code>x1, y1 = (<span>2</span>, <span>3</span>)
x2, y2 = (<span>4</span>, <span>5</span>)
dist = math.sqrt((x2 - x1)**<span>2</span> + (y2 - y1)**<span>2</span>)
</code></pre><p>Most of us knows the formula as the <a href="https://en.wikipedia.org/wiki/Pythagorean_theorem">Pythagorean theorem</a>, and this way of calculating distance is known as the <a href="https://en.wikipedia.org/wiki/Euclidean_distance">Euclidean distance</a>, which feels intuitive to us. However, it&#39;s not the only way of calculating distance, and it&#39;s not the one commonly used for text embeddings.</p>
<p>You may have seen the cosine metric used a lot w.r.t. embeddings and semantic similarity. You might be wondering why the euclidean distance isn&#39;t used instead, given how more &#34;normal&#34; it seems in our world. Here&#39;s an example to demonstrate why:</p>
<p><img src="https://blog.wilsonl.in/hackerverse/cosine-vs-euclid.webp" alt="Cosine vs. euclid distance metrics."/></p>
<p>We can see that in this case, where perhaps the X axis represents &#34;more cat&#34; and Y axis &#34;more dog&#34;, using the euclidean distance (i.e. physical distance length), a pitbull is somehow more similar to a Siamese cat than a &#34;dog&#34;, whereas intuitively we&#39;d expect the opposite. The fact that a pitbull is &#34;very dog&#34; somehow makes it closer to a &#34;very cat&#34;. Instead, if we take the angle distance between lines (i.e. cosine distance, or 1 minus angle), the world makes sense again.</p>
<p>In summary, cosine distances are useful when magitude does not matter (as much), and when using the magnitude would be misleading. This is often the case with text content, where an intense long discussion about X should be similar to X and not an intense long discussion about Y. A good blog post on this is <a href="https://cmry.github.io/notes/euclidean-v-cosine">Euclidean vs. Cosine Distance</a> by Chris Emmery.</p>
<p>Going forward, we&#39;ll use the cosine distance/metric/similarity a lot. The core of it is:</p>
<pre><code>dist = corpus_embeddings @ query_embeddings.T
sim = <span>1</span> - dist
</code></pre><p>The <code>@</code> operator performs a dot product. Normally, you then divide by the product of their magnitudes, but in this case, they are unit vectors, so that isn&#39;t needed.</p>
<h2 id="building-a-map">Building a map</h2>
<p>Wouldn&#39;t it be cool to have an interactive visualization of the latent space of all these embeddings, a &#34;map of the Hacker News universe&#34; so to speak? Something like Google Maps, where you can pan and zoom and move around, with terrain and landmarks and coordinates? It sounds like a fun and challenging thing to try and do!</p>
<p>I first scoped out how this map should work:</p>
<ul>
<li>Zooming in (via pinching or the mousewheel) should increase the amount of points shown, and points should get farther apart.</li>
<li>Some points should be labelled, but not all because it would get cluttered and text would overlap.</li>
<li>Clicking a point should show more details about that post.</li>
<li>It should be in the browser, as a web app, that works well on mobile and desktop and touch and mouse.</li>
</ul>
<p>Basically, it should work like you&#39;d expect, like Google Maps.</p>
<h2 id="preparing-the-map-data">Preparing the map data</h2>
<p>There are millions of points, not ideal to send all at once to the client. Working backwards, there are two &#34;axes&#34; that dictate the points shown: position and zoom, so structuring and segmenting the data alongst those lines is a good start.</p>
<p>The first thing that came to mind was tiling: divide the map space into a grid, then pack all points into each cell. The client can load tiles on-demand as they need to, instead of the whole map. There are probably more sophisticated ways of tiling, esp. given that points aren&#39;t distributed evenly and clients have different viewports, but the effectiveness is great given its simplicity. A tile can simply be referred to by its (x, y) coordinate, and stored in any KV datastore (e.g. S3), making it easy to distribute and requiring no server-side logic.</p>
<p>For zooming, my approach was a loop for each Level of Detail (LOD), subdividing into 2x more grid cells per axis (and therefore 4x more points), but making sure to first copy over all points picked by the previous level, because the user doesn&#39;t expect a point to disappear as they zoom in.</p>
<p>I aimed for each tile to be less than 20 KiB when packed, a balance between fast to load on mediocre Internet and sizable to avoid excessive fetches. This limited tiles to around 1,500 points: 4+4 bytes for the (x, y), 4 bytes for the ID, and 2 bytes for the score.</p>
<p>To ensure a diverse set of points per tile, I further subdivided each tile to pick at least something from each area; this reduced the chance that a less-populated area in the fringes seems completely non-existent on the map from afar. Any remaining capacity was taken by sampling uniformly, which should visually represent the background distribution on the map.</p>
<p>The code is pretty straightforward and self-explanatory in the <a href="https://github.com/wilsonzlin/hackerverse/blob/master/build-map/main.py">build-map</a> service, so I won&#39;t repeat the code here.</p>
<h2 id="building-the-web-app">Building the web app</h2>
<p>It took a while to figure out the best approach. Using even thousands of DOM elements (one for each point) completely trashed performance, so that was out of the picture. Having a giant Canvas, dynamically rendering points only as they come into view, and changing its DOM position and scale when panning/zooming, didn&#39;t work either; the points would grow in size when zooming in, and at sufficiently large zoom levels, the image became too big (clearing the Canvas took too long, and memory usage was extreme). Eventually I settled on a Canvas and drawing on every update of the &#34;viewport&#34;, which represents the position and zoom level of the current user. Despite needing to redraw potentially thousands of points on every frame (to feel smooth and responsive), this worked really well, and was the simplest approach.</p>
<p>I kept the labelling algorithm simple: repeatedly pick the highest scoring post (a reasonable metric), unless the label would intersect with another existing label. <a href="https://en.wikipedia.org/wiki/R-tree">R-trees</a> can do the job of finding box collisions well, and thankfully <a href="https://github.com/mourner/rbush">RBush</a> exists, an excellent and fast R-tree implementation in JS. There exists a <a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/measureText">measureText()</a> API in the browser, but fetching thousands (or more) titles just to measure them and pick a handful was neither fast nor efficient, so I packed post title lengths into a byte array (so a thousand would only be ~1 KB) and simply used a tuned formula to approximate the length, which worked reasonably well:</p>
<p><img src="https://blog.wilsonl.in/hackerverse/map-bboxes.png" alt="Map of posts with bounding boxes around labels."/></p>
<p>The one-off initial calculations of these boxes and collisions was CPU intensive and caused stuttering, so I moved it to its own thread using <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">Web Workers</a>. I also experimented with <a href="https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas">OffscreenCanvas</a>, but it didn&#39;t do much; the render logic was very efficient already, and given that 99% of the app was the map (represented by the Canvas), having &#34;the rest of the app&#34; still respond while the map was rendering was not very useful.</p>
<h2 id="adding-some-visual-appeal-and-guidance">Adding some visual appeal and guidance</h2>
<p>There was something still disorienting and &#34;dull&#34; about the map. Real maps have landmarks, cities, borders, terrains, and colors; there is a sense of direction, orientation, and navigation as you browse and navigate the map. Let&#39;s try to add some of those, analogizing where necessary.</p>
<p>Terrain and borders will require some analogizing, since there are no real geographical or geopolitical features of this map. If you look on Google Maps, you&#39;ll notice that there are shades of terrain, but no smooth gradients. They are contours, quickly informing the viewer of the intensity of something compared to everywhere else, in their case vegetation. For our map, intensity could represent density of points, quickly signifying where there&#39;s a lot of interest, activity, content, engagement, popularity, discussion, etc. It would also provide some of the orientation, because a user can sense their movement based on the shifting terrain.</p>
<p><a href="https://scikit-learn.org/stable/modules/density.html">Kernel Density Estimation</a> would seem like the perfect tool for this job. Basically, you take a bunch of discrete values and generate a smooth curve around it, inferring the underlying distribution. Matthew Conlen <a href="https://mathisonian.github.io/kde/">created a cool visual walkthrough</a> explaining intuitively in more detail. Unfortunately, attempts using standard libraries like <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html">SciPy</a> took too long. However, as I was playing around with them, something occurred to me when I saw &#34;Gaussian kernel&#34; (one option for KDE): why not try Gaussian blurring? They seem to be related: when you blur an image, you have a <a href="https://en.wikipedia.org/wiki/Kernel_(image_processing)">kernel</a> and apply a Gaussian function, which when you look at <a href="https://en.wikipedia.org/wiki/File:Normal_Distribution_PDF.svg">its plot</a>, it essentially &#34;pushes out&#34; values from the kernel&#39;s center (in layman&#39;s terms) — this is how you get the <em>smoothing</em> effect from blurs. Would applying such a blur also &#34;push out&#34; and smoothing the many discrete sharp points into a meaningful representation of the approximate density?</p>
<p>My approach will be to map each point to a cell in a large grid with the same aspect ratio, where each cell&#39;s value will be the count of points mapped to it. If the grid is too small, everything&#39;s clumped together, but if it&#39;s too big, everything&#39;s too far apart and it&#39;s mostly sparse everywhere, so finding a balance is necessary.</p>
<pre><code>ppc = <span>32</span> 
x_min, x_max = (xs.<span>min</span>(), xs.<span>max</span>())
y_min, y_max = (ys.<span>min</span>(), ys.<span>max</span>())
grid_width = <span>int</span>((x_max - x_min) * ppc)
grid_height = <span>int</span>((y_max - y_min) * ppc)

gv = pd.DataFrame({
    <span>&#34;x&#34;</span>: (xs - x_min).clip(<span>0</span>, grid_width - <span>1</span>).astype(<span>&#34;int32&#34;</span>),
    <span>&#34;y&#34;</span>: (ys - y_min).clip(<span>0</span>, grid_height - <span>1</span>).astype(<span>&#34;int32&#34;</span>),
})
gv = gv.groupby([<span>&#34;x&#34;</span>, <span>&#34;y&#34;</span>]).size().reset_index(name=<span>&#34;density&#34;</span>)

grid = np.zeros((grid_height, grid_width), dtype=np.float32)
grid[gv[<span>&#34;y&#34;</span>], gv[<span>&#34;x&#34;</span>]] = gv[<span>&#34;density&#34;</span>]
grid = gaussian_filter(grid, sigma=<span>1</span>)

g_min, g_max = grid.<span>min</span>(), grid.<span>max</span>()
level_size = (g_max - g_min) / levels
grid = (grid - g_min) // level_size

grid = np.clip(grid, <span>0</span>, levels - <span>1</span>)
</code></pre><p>Let&#39;s quickly render an image, using the values as the alpha component, to see how it looks so far.</p>
<pre><code>alpha = grid.astype(np.float32) / (levels - <span>1</span>) * <span>255</span>

img = np.full(
    (grid_height, grid_width, <span>4</span>),
    (<span>144</span>, <span>224</span>, <span>190</span>, <span>0</span>), 
    dtype=np.uint8,
)
img[:, :, <span>3</span>] = alpha.astype(np.uint8)

Image.fromarray(img, <span>&#34;RGBA&#34;</span>).save(<span>&#34;terrain.webp&#34;</span>)
</code></pre><p><img src="https://blog.wilsonl.in/hackerverse/terrain-linear.webp" alt="Initial terrain map."/></p>
<p>It does not look so good. It looks like most cells were zero, and there are seemingly very few areas with any actual posts.</p>
<p>I have a theory: just as the distribution of votes/likes on social media across posts exhibit power-law distributions, perhaps the same is true of the popularity of topics? If there were a few topics that are posted about 10x more than most others, then it could explain the above map, as few areas would fall in the middle tiers. Let&#39;s apply a <code>log</code> to the values:</p>
<pre><code>gv[<span>&#34;density&#34;</span>] = np.log(gv[<span>&#34;density&#34;</span>] + <span>1</span>)
</code></pre><p><img src="https://blog.wilsonl.in/hackerverse/terrain-logarithmic.webp" alt="Logarithmic terrain map."/></p>
<p>That looks much nicer. It also has implicit &#34;borders&#34; at the places where different <em>log(density)</em> levels meet, which is cool.</p>
<p>Instead of rendering it as a giant image, which is inefficient to transport and blurry when zoomed in, I&#39;ll create SVG paths instead, given that there are literally only 4 colors in this entire figure. On the client, I&#39;ll draw and fill in these paths that form a polygon. This will ensure that the &#34;terrain&#34; looks sharp (including at borders) even when zoomed in. I&#39;ll use <a href="https://opencv.org/">OpenCV</a>&#39;s built-in <a href="https://en.wikipedia.org/wiki/Contour_line">contour</a> functions to calculate the path around these levels and export them as a closed polygon.</p>
<pre><code>shapes: <span>Dict</span>[<span>int</span>, <span>List</span>[npt.NDArray[np.float32]]] = {}
<span>for</span> level <span>in</span> <span>range</span>(levels):
    shapes[level] = []
    num_shapes, labelled_image = cv2.connectedComponents((grid == level).astype(np.uint8))
    
    <span>for</span> shape_no <span>in</span> <span>range</span>(<span>1</span>, num_shapes):
        shape_mask = labelled_image == shape_no
        
        shape_contours, _ = cv2.findContours(shape_mask.astype(np.uint8), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        <span>for</span> shape_border_points <span>in</span> shape_contours:
            
            shape_border_points = shape_border_points.squeeze(<span>1</span>)
            <span>if</span> shape_border_points.shape[<span>0</span>] &lt; <span>4</span>:
                
                <span>continue</span>
            
            <span>if</span> level == <span>0</span> <span>and</span> (<span>0</span>, <span>0</span>) <span>in</span> shape_border_points:
                <span>continue</span>

            
            shape_border_points[:, <span>0</span>] = shape_border_points[:, <span>0</span>] / ppc + x_min
            shape_border_points[:, <span>1</span>] = shape_border_points[:, <span>1</span>] / ppc + y_min
            shapes[level].append(shape_border_points.astype(np.float32))
</code></pre><h2 id="cities">Cities</h2>
<p>I also wanted to add some &#34;cities&#34; (representing the common topic within some radius), so you can find your way around and not get lost in the many points and titles shown at once, and have some sense of direction and where to start. The UMAP model has been saved, so all that&#39;s necessary is to embed the city names and get their (x, y) position using the UMAP model:</p>
<pre><code>CITIES = [<span>&#34;Programming&#34;</span>, <span>&#34;Startups&#34;</span>, <span>&#34;Marketing&#34;</span>, ...]
embs = model.encode(CITIES)
points = umapper.transform(embs)
</code></pre><p>There were some automated ways of doing this that I explored a bit. Using LLMs to generate these automatically. K-means clustering to figure out optimal points and radii. Unfortunately, it was not so trivial: it was hard to prompt the LLM to output what I expected, likely because describing the task was not trivial, and K-means did not find a lot of meaningful clusters that I would (as a human labeller) group together. You&#39;d expect that there would be some hierarchy, but some topics are really popular on their own (sometimes even more than their logical &#34;parent&#34;), like &#34;Programming&#34; vs. &#34;Rust&#34;, so they needed to be shown at the same detail level. Ultimately, it only required a few cities before it looked good, so manually walking the map and jotting down a few cities only took an hour or so.</p>
<h2 id="pushing-things-to-the-edge">Pushing things to the edge</h2>
<p>As you&#39;re browsing the map, you want it to feel snappy and responsive, because you&#39;re trying to find something, get immersed, get orientated, etc., and having parts be blank or partial interrupts this flow. Therefore, I knew I needed to reduce the time it took to get the map onto the screen. The rendering part was fast, it was fetching the data that took a while; I had started by putting all the map data on Cloudflare R2 in the ENAM region, but the latency was too high (600 ms to a few seconds) despite the physical latency being ~200 ms. However, even 200 ms was not really great, given that <a href="https://www.pubnub.com/blog/how-fast-is-realtime-human-perception-and-technology/">100 ms is the treshold where things feel &#34;instant&#34;</a>. Given that the limitation was a law of physics, there was only one real way to reduce that latency and that was to move the data closer to the user. So I spun up a few tiny servers in major regions: Virginia, San Jose, London, and Sydney (near me). I wrote a basic Rust server to ship out the data and get the most bang-for-buck from these tiny servers (plus, why spend all this effort only to have a slow server?), and had some tiny JS to pick the nearest server from the client:</p>
<pre><code><span>const</span> <span>EDGES</span> = [
  <span>&#34;ap-sydney-1&#34;</span>,
  <span>&#34;uk-london-1&#34;</span>,
  <span>&#34;us-ashburn-1&#34;</span>,
  <span>&#34;us-sanjose-1&#34;</span>,
] <span>as</span> <span>const</span>;

<span>const</span> edge = <span>await</span> <span>Promise</span>.<span>race</span>(
  <span>EDGES</span>.<span>map</span>(<span>async</span> (edge) =&gt; {
    
    <span>for</span> (<span>let</span> i = <span>0</span>; i &lt; <span>3</span>; i++) {
      <span>await</span> <span>fetch</span>(<span>`https://<span>${edge}</span>.edge-hndr.wilsonl.in/healthz`</span>);
    }
    <span>return</span> edge;
  }),
);
</code></pre><p>Some anycast, CDN, etc. solution may have been even cooler, but likely costly and overkill.</p>
<p>One thing that puzzled me was how much more memory was being used by the process compared to the actual data itself. The data is built once then pushed to all the edge servers, and it&#39;s in MessagePack format, so it has the bloat from type markers and property names. Once deserialized into Rust structures, it should all be memory offsets. So I was surprised when memory usage was 2-4x the source data size. I could only really think of four reasons:</p>
<ul>
<li>I used the wrong type (e.g. <code>f64</code> instead of <code>f32</code>).</li>
<li>Struct padding.</li>
<li>Vec, HashMap overallocation.</li>
<li>Memory allocator fragmentation or other inefficiency.</li>
</ul>
<p>I didn&#39;t look too much into this, but it was the one thing left that otherwise made the edge setup pretty neat and efficient. If anyone has any ideas, let me know.</p>
<h2 id="testing-out-the-search">Testing out the search</h2>
<p>Now that we got our app and data all up and running, let&#39;s see if our theory about better query comprehension and search results pans out. Let&#39;s try a simple query: &#34;entering the tech industry&#34;.</p>
<p><img src="https://blog.wilsonl.in/hackerverse/search-entering-the-tech-industry.png" alt="Search results for &#34;entering the tech industry&#34;"/></p>
<p>It gives some nice results, both upvoted and less noticed ones, and seem to be pretty relevant and helpful. Compare this to HN&#39;s current search service:</p>
<p><img src="https://blog.wilsonl.in/hackerverse/search-algolia-entering-the-tech-industry.png" alt="Search results for &#34;entering the tech industry&#34; by Algolia"/></p>
<p>We can see the power of semantic embeddings over something like literal text matching. Of course, we could try more queries and get better results, but the embeddings-powered search engine got it immediately, did not return only part of the results, and there was no need to optimize the query or &#34;reverse engineer&#34; the algorithm.</p>
<p>How about a question, instead of just matching?</p>
<p><img src="https://blog.wilsonl.in/hackerverse/search-what-happened-to-wework.png" alt="Search results for &#34;what happened to wework&#34;"/></p>
<p>It gave us results about WeWork over the years, from layoffs to stock tank to bankruptcy, a nice holistic view. Notice that the results don&#39;t literally contain the words &#34;what happened&#34;, and most aren&#39;t even questions. The model seems to have &#34;understood&#34; our query, which is pretty nice considering this isn&#39;t some generative model, just cosine distances.</p>
<p>There is one quirk: the bottom result is completely irrelevant. This is largely my fault; I did not filter out results that are too dissimilar, so it ended up including generic results. This is something trivially fixable though.</p>
<p>Given the curated quality of HN posts (and scores), can we find some sage advice over the years about something important, like say career growth, just by typing something simple?</p>
<p><img src="https://blog.wilsonl.in/hackerverse/search-career-growth.png" alt="Search results for &#34;career growth&#34;"/></p>
<p>Seems pretty good to me: not literally matching the words so creative, interesting, diverse essays showed up. The curation of HN really helps here; I did a quick comparison to the results from a well-known search engine and these results seemed far better. Obviously they have a much more difficult job and far more sophisticated pipelines, but it goes to show that good data + powerful semantic embeddings can go pretty far.</p>
<p>I&#39;ve hard-coded some interesting queries I found into the app, which show up as suggestions; everything from &#34;linus rants&#34; to &#34;self bootstrapping&#34; to &#34;cool things with css&#34;. Try them out and any other queries. What works well? What doesn&#39;t? Did you find anything interesting, rare, and/or useful? Let me know!</p>
<p>One thing I haven&#39;t mentioned yet is that the results are not <em>directly</em> the similarity matches. There are weights involved in calculating the final score (i.e. rank), and cosine similarity is a big one but not the only one.</p>
<p>Another important one is score. This may not seem as necessary given how powerful these embedding models are, but it is, even with 100% accurate models. Consider two posts talking about some topic, say Rust. One is written by <a href="https://news.ycombinator.com/user?id=steveklabnik">steveklabnik</a>. Another one says that Rust is terrible because it&#39;s a garbage-collected dynamic scripting language. To the model, these are both (mostly) talking about Rust, so they are very close together. Yet, it&#39;s obvious to most people that the latter should not be ranked as high as the former. (It should probably be filtered out entirely.) This highlights the importance of <em>social proof</em> in search and recommendation systems, because there are things that the model doesn&#39;t understand (and maybe never can) because of context, trends, events, etc. Incorporating the score ensures some social proof is taken into consideration.</p>
<p>Another weight is time. Some queries usually prefer newer content to older ones. The common example is news about some recent event; usually it&#39;s more important to show the latest updates than yesterday&#39;s or some distant but similar event. We can incorporate this by adding a negative weight component proportional to <em>log(age)</em>, so that non-fresh content quickly drops off.</p>
<h2 id="automatic-virtual-subcommunities">Automatic virtual subcommunities</h2>
<p>Another neat feature enabled by these embeddings is &#34;virtual&#34; subcommunities. Just type a community name (or description) and all the posts that meet some similarity threshold show up, like your very own subreddit on the fly. Hacker News doesn&#39;t have the ability to further subdivide posts, so this was a cool way to have a curated set of posts focused on a specific interest.</p>
<p><img src="https://blog.wilsonl.in/hackerverse/community.png" alt="Apple virtual subcommunity."/></p>
<p>If you&#39;re wondering where those snippets and images came from, that&#39;s what the crawler was extracting and storing as metadata for each page. It usually comes in handy down the line when you want to show/list the pages as results somewhere, as otherwise you&#39;d only have a URL. While I could&#39;ve also saved the <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link">site icon metadata</a>, it&#39;s tricky to parse, so I decided to keep it simple by just fetching <code>/favicon.ico</code> of the domain on the client side.</p>
<p>It&#39;s just as possible to show interesting comment threads and discussions. Unfortunately, scores aren&#39;t available to us, so we can only sort by timestamp, but luckily most comments on HN are pretty useful and insightful:</p>
<p><img src="https://blog.wilsonl.in/hackerverse/community-comments.png" alt="Entrepreneurship virtual community comments."/></p>
<p>It would be an interesting challenge to try and rank the comments without the score, perhaps involving user comment histories, engagement around that comment, and the post, topic, and contents. This may be something as simple as a linear equation, to a deep learning model.</p>
<p>We can also see who are the most influential, active, passionate about something by calculating how many comments a user makes proportional to the similarity.</p>
<p><img src="https://blog.wilsonl.in/hackerverse/community-cloudflare-users.png" alt="Cloudflare virtual community top users."/></p>
<p>We can see that this works well: <a href="https://news.ycombinator.com/user?id=jgrahamc">jgrahamc</a> and <a href="https://news.ycombinator.com/user?id=eastdakota">eastdakota</a> are the CTO and CEO of Cloudflare respectively. We managed to do this without needing to classify each comment or use a more fragile and inaccurate keyword-based search. All it takes is some matrix operations:</p>
<pre><code>q = model.embed(<span>&#34;cloudflare&#34;</span>)
df_comments[<span>&#34;sim&#34;</span>] = mat_comments @ q
min_threshold = <span>0.8</span>
df_comments_relevant = df_comments[df[<span>&#34;sim&#34;</span>] &gt;= min_threshold]
df_scores = df_comments_relevant.groupby(<span>&#34;author&#34;</span>).agg({<span>&#34;sim&#34;</span>: <span>&#34;sum&#34;</span>}).reset_index().sort_by(<span>&#34;sim&#34;</span>, ascending=<span>False</span>)[:<span>20</span>]
</code></pre><p>One important realisation was that pre-filtering is really slow and usually unnecessary compared to post-filtering. By pre-filtering, I mean removing rows before doing similarity matching. This is because you end up needing to also remove those corresponding rows from the embedding matrix, and that can mean having to reconstruct (read: gigabytes of memory copying) the entire matrix or use much slower partially-vectorized computations. It&#39;s usually better to just filter the rows after finding the most similar rows i.e. post-filter.</p>
<p>Note that a minimum threshold is important, because &#34;dissimilarity&#34; can be as high as 0.6, which makes the set of non-relevant items (in this case, users) have high scores due to the size of such sets. In this example, <em>most</em> comments aren&#39;t talking about Cloudflare, so any user that has a lot of comments would otherwise dominate this leaderboard just by sheer volume of comments as 100,000 * 0.6 is still higher than 500 * 0.999.</p>
<h2 id="analyzing-the-entire-dataset">Analyzing the entire dataset</h2>
<p>What can we do with the 30 million comments? Two things I wanted to try to analyze at scale were popularity and sentiment. Could I see how HN feels about something over time, and the impact that major events has on the sentiment? Can I track the growth and fall of various interests and topics, and how they compare against their competition?</p>
<p>I don&#39;t have sentiment data, but there are lots of high-quality open source sentiment classification models, on HuggingFace, using <a href="https://huggingface.co/docs/transformers/en/index">Transformers</a>. I decided to use the <a href="https://huggingface.co/cardiffnlp/twitter-roberta-base-sentiment-latest">TweetEval</a> model as it was similarly trained on social media content. Tweets are short, and I didn&#39;t know how well it&#39;d work on contextualized comments (which I added when generating embeddings), so to keep it aligned with the model I only used the comments themselves without adding any context. A queue was created, the comments were pushed, a GPU cluster spun up to process the jobs, and the results were stored.</p>
<p>The model was much smaller, so increasing the batch size was a good idea to get more bang-for-buck from the GPUs. Increasing the batch size uses more VRAM, but decreases the amount of host-GPU memory transfer (which can be the bottleneck given how fast GPUs are) and possibly increases parallelism. It&#39;s finicky though, because, at least for transformer-based models, it can sometimes cause memory spikes and OOM errors. This is because the input matrix has to be a &#34;rectangle&#34;, so all inputs (which are converted into tokens) must be padded to the longest input length to maintain this constraint. If you have a batch where 4 texts are length 1, then the input size and internal state is relatively small. But if you instead have a batch size of 5 and the next text has length 1024, then all those sizes suddenly jump by thousands. I added some basic code to conservatively guess the optimal batch size given the VRAM, but I&#39;m curious if this problem has already been tackled more dynamically, given its implications for efficiency.</p>
<p>Once the data was ready, it was time for some number crunching. Let&#39;s check out the sentiment of Rust over time:</p>
<p><img src="https://blog.wilsonl.in/hackerverse/sentiment-rust.png" alt="Sentiment of Rust."/></p>
<p>Values below 0 represent the count of negative comments (where confidence of negative sentiment &gt; 0.5) and above 0 represent positive (where confidence of positive sentiment &gt; 0.5); I probably need to polish and clear it up a bit more. Nonetheless, we can see that there&#39;s generally a lot of positive sentiment about Rust (which isn&#39;t surprising if you&#39;ve been around on HN). There was a spike in positivity around the 1.0 announcement, which makes sense, and the more negative posts correlated with a lot of negative comments (according to the model). This is similar to how bots measure sentiment on social media and predict the price of stocks; using powerful semantic embeddings would probably beat any keyword- or bag-of-words-based algorithm. I will say, assuming the model is accurate and I did a reasonable job, there seems to be a lot of negative sentiment on HN <em>in general</em>.</p>
<p>We can also estimate the popularity of Rust compared to other languages by weighing the score and similarity. Unfortunately, HN does not expose comment scores, so we can&#39;t use them.</p>
<p><img src="https://blog.wilsonl.in/hackerverse/popularity-languages.png" alt="Popularity of Go, JavaScript, Python, and Rust."/></p>
<p>It seems like Rust is doing great, but not as popular as the other languages. Some of the similarity thresholds may need tuning, so I may be wrong here; have a play with it yourself and try various queries and thresholds. Share anything interesting you find!</p>
<p>These were very basic demos and analyses of the data available, and I&#39;m sure there are infinitely more ways to slice and dice the data in interesting, insightful, useful, sophisticated ways. I have many more ideas myself, but wanted to open up the code and data sooner so you can build on top of this, either with more ideas and suggestions, or to play with your own research and visualization projects.</p>
<h2 id="big-data-number-crunching-with-a-gpu">Big data number crunching with a GPU</h2>
<p>One last thing before I wrap this long post up. The analysis queries were taking a while (10-30 seconds) to number-crunch for each one, which was annoying when playing around with it. This was on a 32-core machine, so it was not for a lack of horsepower. I was thinking of various ways to index, preprocess, or prepare the data, when it occurred to me that there already exists a powerful device for lots of vectorized number-crunching, and it&#39;s why we run all our AI models on it, but it doesn&#39;t have to be restricted to those. Fortunately, libraries like <a href="https://cupy.dev/">CuPy</a> and <a href="https://docs.rapids.ai/api/cudf/stable/">cuDF</a> exist, which basically have the same API as NumPy and pandas (respectively) but run everything on the GPU, so it was pretty trivial to port over. Now, queries run in hundreds of milliseconds, and life is great. It&#39;s so fast I didn&#39;t even bother using a built ANN graph.</p>
<p>The only tricky thing was loading the data on the GPU. Given how large the matrix of embeddings was (30M x 512), it was critical to manage memory effectively, because it wasn&#39;t actually possible to fit anything more than 1x the matrix in either system or video memory. Some key points:</p>
<ul>
<li>Loading in batches can cause a lot of allocations, which can fragment memory, so in reality you may not be able to load in chunks and then concatenate at the end. (Concatenation also requires contiguous memory, which usually means copying into a separate memory location.)</li>
<li>If you read the bytes from disk, load into a NumPy array, convert into a CuPy array, and then copy over to the GPU, that&#39;s 4 copies, 3 of which are in memory.</li>
<li>CuPy seems to need to have the entire matrix in system memory first before it can copy over to the GPU. For example, <code>cupy.asarray(np_matrix)</code> actually creates a copy of <code>np_matrix</code> in system memory first.</li>
</ul>
<p>Ultimately I ended up memory-mapping the matrix on disk, preallocating an uninitialized matrix on the GPU of the same size, then copying over in chunks. This had the benefit of avoiding reading from disk into Python memory first, and using exactly 1x the system RAM and VRAM.</p>
<h2 id="demo">Demo</h2>
<p>You can find the app at <a href="https://hn.wilsonl.in">hn.wilsonl.in</a>. The main page is the map and search, but you can find the other tools (communities and analysis) by clicking the button in the top right. If you find an interesting community, analysis, etc., feel free to share the URL with others; the query is always stored in the URL.</p>
<p>Note that the demo dataset is cut off at around 10 April 2024, so it contains recent but not live posts and comments.</p>
<h2 id="what&#39;s-next">What&#39;s next</h2>
<p>There is much more I wanted to explore, learn, build, but I did not get the time. Some ideas I&#39;m thinking of going into:</p>
<ul>
<li>Live data that is continuously kept up to date.</li>
<li>Deep learning powered recommendations system, a <a href="https://en.wikipedia.org/wiki/StumbleUpon">StumbleUpon</a> over the curated HN web.</li>
<li>Improving search results by training a reranker.</li>
<li>Interesting &#34;paths&#34; and &#34;journeys&#34; along the map.</li>
<li>Analyzing users more: who are the most similar/opposite to each other? Who is the most expert in various niches?</li>
<li>…</li>
</ul>
<p>However, I&#39;m more interested in hearing from the community. What do you want to see? How useful were these tools? What were shortcomings or things I overlooked? What other cool ideas do you have? Share any thoughts, feedback, interesting findings, complaints—there&#39;s likely a lot more potential with these data and tools, and I&#39;m hoping that, by opening it up, there&#39;s some interested people who will push this further than I can alone.</p>
<p>If there&#39;s any interest in diving deeper or clarifying any aspect of this project, let me know, I&#39;d be happy to. Once again, you can find all the <a href="https://github.com/wilsonzlin/hackerverse/releases/tag/dataset-39996091">data</a> and <a href="https://github.com/wilsonzlin/hackerverse">code</a> on GitHub.</p>
<p>If you managed to make it all the way here, thanks for reading!</p>

    </article>
  </div></div>
  </body>
</html>
