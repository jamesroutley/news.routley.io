<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lucumr.pocoo.org/2025/6/17/measuring/">Original</a>
    <h1>We Can Just Measure Things</h1>
    
    <div id="readability-page-1" class="page"><div>
        
  

  
  <p data-date="2025-06-17T00:00:00">written on Tuesday, June 17, 2025</p>
  

  <p>This week I spent time with friends to letting agents go wild
and see <a href="https://vibetunnel.sh/">what we could build in 24 hours</a>.  I
took some notes for myself to reflect on that experience.  I won&#39;t bore
you with another vibecoding post, but you can read <a href="https://steipete.me/posts/2025/vibetunnel-turn-any-browser-into-your-mac-terminal">Peter&#39;s post</a>
about how that went.</p>
<p>As fun as it was, it also was frustrating in other ways and in entire
predictable ways.  It became a meme about how much I hated working with
Xcode for this project.  This got me thinking quite a bit more that this
has been an entirely unacceptable experience for a long time, but with
programming agents, the pain becomes measurable.</p>
<p>When I first dove into programming I found the idea of <a href="https://en.wikipedia.org/wiki/RTFM">RTFM</a> quite hilarious.  “Why are you
asking dumb questions, just read it up.”  The unfortunate reality is that
the manual often doesn&#39;t exist — or is wrong.  In fact, we as engineers
are quite willing to subject each others to completely inadequate tooling,
bad or missing documentation and ridiculous API footguns all the time.
“User error” is what we used to call this, nowadays it&#39;s a “skill issue”.
It puts the blame on the user and absolves the creator, at least
momentarily.  For APIs it can be random crashes if you use a function
wrong, for programs it can be impossible to navigate UI or lack of error
messages.  There are many different ways in which we humans get stuck.</p>
<p>What agents change about this is, is that I can subject them to something
I wouldn&#39;t really want to subject other developers to: measuring.  I
picked the language for my current project by running basic evals and it
worked well.  I learned from that, that there are objectively better and
worse language when it comes to my particular problem.  The choice however
is not just how much the AI knows about the language from the corpus of
examples during training.  It&#39;s also tooling, the inherent capabilities
of the language, ecosystem churn and other aspects.</p>
<p>Using agents to measure code quality is great because agents don&#39;t judge
me, but they do judge the code they are writing.  Not all agents will
swear, but they will <a href="https://x.com/ankrgyl/status/1934415308800053485">express frustration with libraries</a> when loops don&#39;t go
well or give up.  That opens up an opportunity to bring some measurements
into not agent performance, but the health of a project.</p>
<p>We should pay more attention to how healthy engineering teams are, and
that starts with the code base.  Using agents we can put some numbers to
it in which we cannot do with humans (or in a very slow and expensive
way).  We can figure out how successful agents are in using the things are
are creating in rather objective ways which is in many ways a proxy for
how humans experience working with the code.  Getting together with fresh
souls to walk them through a tutorial or some tasks is laborious and
expensive.  Getting agents that have never seen a codebase start using a
library is repeatable, rather cheap, fast and if set up the right way very
objective.  It also takes the emotion out of it or running the experiment
multiple times.</p>
<p>Now obviously we can have debates over if the type of code we would write
with an agent is objectively beautiful or if the way agents execute tools
creates the right type of tools.  This is a debate worth having.  Right at
this very moment though what programming agents need to be successful is
rather well aligned with what humans need.</p>
<p>So what works better than other things?  For now these are basic
indicators, for agents and humans alike:</p>
<ul>
<li><strong>Good test coverage:</strong> they help with future code writing but they also
greatly help preventing regressions.  Hopefully no surprise to anyone.
I would add though that this is not just for the tests, but also for
examples and small tools that a user and agent can run to validate
behavior manually.</li>
<li><strong>Good error reporting:</strong> a compiler, tool or an API that does not
provide good error reporting is a bad tool.  I have been harping on this
for years when working at Sentry, but with agents it becomes even
clearer that this investment pays off.  It also means errors should be
where they can be found.  If errors are hidden in an obscure log neither
human nor agent will find it.</li>
<li><strong>High ecosystem stability:</strong> if your ecosystem churns a lot, if APIs keep
changing you will not just upset humans, you will also slow down the
agent.  It will find outdated docs, examples and patterns and it will
slow down / write bad code.</li>
<li><strong>Few superfluous abstractions:</strong> too many layers just make data flow and
refactoring expensive.  We might even want to start questioning the
value proposition of (most) ORMs today because of how much harder they
make things.</li>
<li><strong>Everything needs to be fast and user friendly:</strong> The quicker tools
respond (and the less useless output they produce) the better.
Crashes are tolerable; hangs are problematic.  <cite>uv</cite> for instance is a
much better experience in Python than any of the rest of the ecosystem,
even though most of the ecosystem points at <cite>pip</cite>.  Agents are super
happy to use and keep using <cite>uv</cite> because they get good infos out of it,
and low failure rates.</li>
<li><strong>A good dev environment:</strong> If stuff only reproduces in CI you have to move
your agent into CI.  That&#39;s not a good experience.  Give your agent a
way to run Docker locally.  If you write a backend, make sure there is a
database to access and introspect, don&#39;t just mock it out (badly).
Deferring things into a CI flow is not an option.  It&#39;s also important
that it&#39;s clear when the devenv is broken vs the code is broken.  For
both human and agent it can be hard to distinguish this if the tooling
is not set up correctly.</li>
</ul>
<p>When an agent struggles, so does a human.  There is a lot of code and
tooling out there which is objectively not good, but because of one reason
or another became dominant.  If you want to start paying attention to
technology choices or you want to start writing your own libraries, now
you can use agents to evaluate the developer experience.</p>
<p>Because so can your users.  I can confidently say it&#39;s not just me that
does not like Xcode, my agent also expresses frustration — measurably so.</p>


  
  <p>This entry was tagged
    
      <a href="https://lucumr.pocoo.org/tags/ai/">ai</a>, 
      <a href="https://lucumr.pocoo.org/tags/api/">api</a> and 
      <a href="https://lucumr.pocoo.org/tags/thoughts/">thoughts</a>
  

      </p></div></div>
  </body>
</html>
