<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.greptile.com/blog/github-ids">Original</a>
    <h1>Every GitHub object has two IDs</h1>
    
    <div id="readability-page-1" class="page"><div><article><p>I was recently building a feature for Greptile (an AI-powered code review tool), when I hit a weird snag with GitHub&#39;s API.</p>
<p>The feature should have been simple: I wanted to add clickable links to GitHub PR comments, so users could jump directly from our reviews to relevant GitHub discussions. We already stored the comment IDs, so I just needed to construct the URLs.</p>
<p>The problem was, when I tested it, the links didn&#39;t work.</p>
<p>Searching through <a target="_blank" rel="noopener noreferrer" href="https://docs.github.com/en/graphql/guides/using-global-node-ids">GitHub&#39;s documentation</a> for answers revealed that their team maintains two separate ID systems. We&#39;d been using GitHub&#39;s GraphQL API, which returns <a target="_blank" rel="noopener noreferrer" href="https://docs.github.com/en/graphql/reference/scalars#id">node IDs</a> like <code>PRRC_kwDOL4aMSs6Tkzl8</code>. GitHub designed these node IDs to uniquely identify any object across its entire system. But web URLs required database IDs, integer values visible in URLs and often associated with REST responses, like <code>2475899260</code>.</p>
<p>I was looking at either backfilling millions of records or migrating our entire database, and neither sounded fun. So I did what any annoyed engineer would do: I stared at these IDs for way too long, looking for a way out of the migration.</p>
<p>And I found it.</p>

<p>I looked for a relationship between these two ID formats. I pulled up a few of our stored node IDs and opened the corresponding PR comments from the same pull request in my editor:</p>
<div><table><thead><tr><th>Node ID</th><th>Database ID</th></tr></thead><tbody><tr><td><span>PRRC_kwDOL4aMSs</span><span>6Tkzl8</span></td><td>2475<span>899260</span></td></tr><tr><td><span>PRRC_kwDOL4aMSs</span><span>6Tkzya</span></td><td>2475<span>900058</span></td></tr><tr><td><span>PRRC_kwDOL4aMSs</span><span>6Tkz3e</span></td><td>2475<span>900382</span></td></tr></tbody></table></div>
<p>The database IDs incremented sequentially, and the node IDs were almost identical too, differing only in their last few characters. GitHub&#39;s documentation mentioned that node IDs are base64 encoded. I tried decoding just the part after <code>PRRC_</code>:</p>
<pre><div><pre><code>def base64_2_int(s):
    base64_part = s.split(&#34;_&#34;)[1]
    return int.from_bytes(base64.b64decode(base64_part))
</code></pre></div></pre>
<p>The decoded values were very long (96 bit) integers:</p>
<div><table><thead><tr><th>Node ID</th><th>Decoded Integer</th><th>Database ID</th></tr></thead><tbody><tr><td><span>PRRC_kwDOL4aMSs6Tkz</span><span>l8</span></td><td><span>454952701279253740627272</span><span>15484</span></td><td>24758992<span>60</span></td></tr><tr><td><span>PRRC_kwDOL4aMSs6Tkz</span><span>ya</span></td><td><span>454952701279253740627272</span><span>16282</span></td><td>24759000<span>58</span></td></tr><tr><td><span>PRRC_kwDOL4aMSs6Tkz</span><span>3e</span></td><td><span>454952701279253740627272</span><span>16606</span></td><td>24759003<span>82</span></td></tr></tbody></table></div>
<p>The decoded integers were incremented by 798, exactly matching the database ID increment. The database ID had to be embedded in there somewhere.</p>

<p>Since both values were changing by the same amount, and the decoded value was 96 bits, I figured the database ID was likely embedded in the lower 32 bits of the node ID. I wrote a quick test:</p>
<pre><div><pre><code>def node_id_to_database_id(s):
    decoded = int.from_bytes(base64.b64decode(s.split(&#34;_&#34;)[1]))
    # Mask to keep only the lower 32 bits
    return decoded &amp; ((1 &lt;&lt; 32) - 1)

node_id_to_database_id(&#34;PRRC_kwDOL4aMSs6Tkzl8&#34;)
# Returns: 2475899260
</code></pre></div></pre>
<p>It worked! The database ID was just the last 32 bits of the decoded node ID. I could skip the entire migration, and extract what I needed with a simple bitmask operation.</p>
<p>After the relief sunk in, I couldn&#39;t help but ask, &#34;If the database ID only used the last 32 bits out of the 96 total bits, what were the first 64 bits being used for?&#34;</p>
<p>Since the node ID is a global identifier across all of GitHub, I assumed that the extra 64 bits had to encode either the object type or an id to another resource that &#34;owned&#34; the current node. I wanted to see if I could decode them the same way I&#39;d decoded the database ID.</p>

<p>To understand what was in those 64 bits, I started <a target="_blank" rel="noopener noreferrer" href="https://docs.github.com/en/graphql/overview/explorer">querying different GitHub objects</a>. My test repository returned the familiar <code>PRRC_</code> format for everything. I tried the first famous repository that came to mind, <code>torvalds/linux</code>, to see if the pattern held.</p>
<p>The response was a completely different base64 encoded string:</p>
<pre><code>MDEwOlJlcG9zaXRvcnkyMzI1Mjk4
MDQ6VHJlZTIzMjUyOTg6NzIwMWJmYjkyOGIyOWU4MGIwMDVkYTE1OTc4MzQ1ZjIzYmEwZmY5Yg==
MDQ6QmxvYjIzMjUyOTg6ZjM3MWExM2I0ZDE5MmQyZTM3ZDcwMTdiNjNlMzNkZmE3YzY3Mzc4Zg==
</code></pre>
<p>When I decoded these they showed the following:</p>
<pre><div><pre><code>base64.b64decode(&#34;MDEwOlJlcG9zaXRvcnkyMzI1Mjk4&#34;)
# Returns: b&#39;010:Repository2325298&#39;
</code></pre></div></pre>
<p>The Linux repository was using a completely different format. I realized the repository was created in 2011. By picking an old repository, I&#39;d accidentally stumbled onto GitHub&#39;s legacy ID format which was quite simple:</p>
<pre><code>[Object Type Number]:[Object Type Name][Database ID]
</code></pre>
<p>That repository ID (<code>010:Repository2325298</code>) had a clear structure: <code>010</code> is some type enum, followed by a colon, the word <code>Repository</code>, and then the database ID <code>2325298</code>. Since repositories are just containers, I wanted to see if git objects like trees would reveal more complexity:</p>
<pre><div><pre><code>base64.b64decode(&#34;MDQ6VHJlZTIzMjUyOTg6NzIwMWJmYjkyOGI...&#34;)
# Returns: b&#39;04:Tree2325298:7201bfb928b29e80b005da15978345f23ba0ff9b&#39;
</code></pre></div></pre>
<p>That&#39;s the enum again, the word <code>Tree</code>, the repository ID, and the tree SHA.</p>
<p>It was apparent that GitHub had two systems for ID&#39;ing their internal objects. Somewhere in GitHub&#39;s codebase, there&#39;s an if-statement checking when a repository was created to decide which ID format to return.</p>
<p>I started mapping out which objects used which format. The pattern wasn&#39;t as simple as &#34;old repos use old IDs, new repos use new IDs&#34;:</p>
<div><table><thead><tr><th>Format</th><th>Example</th><th>Usage</th></tr></thead><tbody><tr><td>Legacy</td><td>MDEwOlJlcG9zaXRvcnkyMzI1Mjk4</td><td>Old repositories like torvalds/linux</td></tr><tr><td>New</td><td>PRRC_kwDOL4aMSs6Tkzl8</td><td>Newer repositories and most objects</td></tr></tbody></table></div>
<p>Old repositories kept their legacy IDs, while newer ones were issued IDs following the new format. But the split isn&#39;t clean; GitHub still uses the legacy format for some object types, like Users, even when newly created. New objects in old repositories sometimes get new IDs, sometimes don&#39;t. It depends on their creation date.</p>
<p>Surely the new format had some benefit that warranted this messy migration. It shouldn&#39;t be too hard to create a more efficient IDing system than base64 encoding the string representation of an enum and the object name. This information could easily be packed into those 64 extra bits that I still had to understand.</p>

<p>GitHub&#39;s <a target="_blank" rel="noopener noreferrer" href="https://docs.github.com/en/graphql/guides/migrating-graphql-global-node-ids">migration guide</a> tells developers to treat the new IDs as opaque strings and treat them as references. However it was clear that there was some underlying structure to these IDs as we just saw with the bitmasking. My best guess was that it used some binary serialization format, so I could just test a bunch to see what worked.</p>
<p>This is when I came across <a target="_blank" rel="noopener noreferrer" href="https://msgpack.org/">MessagePack</a>, a compact binary serialization format. It seemed promising as it was frequently used in Ruby projects, and GitHub&#39;s backend is built on Ruby. I tried decoding it:</p>
<pre><div><pre><code>import msgpack
import base64

def decode_new_node_id(node_id):
    prefix, encoded = node_id.split(&#39;_&#39;)
    packed = base64.b64decode(encoded)
    return msgpack.unpackb(packed)

decode_new_node_id(&#34;PRRC_kwDOL4aMSs6Tkzl8&#34;)
# Returns: [0, 47954445, 2475899260]
</code></pre></div></pre>
<p>It worked. The new format uses MessagePack to encode the relevant IDs into an array.</p>
<p>The structure made sense once I saw it:</p>
<ul>
<li><strong>First element (0):</strong> Still unclear. Probably a version identifier, but if you know what this is for, please email me at <a target="_blank" rel="noopener noreferrer" href="mailto:soohoon@greptile.com">soohoon@greptile.com</a>.</li>
<li><strong>Second element (47954445):</strong> The repository&#39;s database ID. This provides the context needed to make the ID global. Pull requests, issues, and comments are all usually scoped to a repository.</li>
<li><strong>Third element (2475899260):</strong> The object&#39;s database ID.</li>
</ul>
<p>Different object types sometimes have different array lengths. Repositories only need <code>[0, repository_database_id]</code>. Commits include the git SHA: <code>[0, repository_database_id, commit_sha]</code>. The first element is always 0, and repository-scoped objects include both the repository ID and the specific object identifier. Since the database ID of the comment is the last element in the array, when bitmasking for the lower 32 bits we are able extract just that.</p>

<p>What started as a URL generation problem turned into &#34;reverse-engineering&#34; and exploring of GitHub&#39;s ID system.</p>
<p>Putting it all together, for modern GitHub node IDs you can use:</p>
<pre><div><pre><code>import base64
import msgpack

def node_id_to_database_id(node_id):
    prefix, encoded = node_id.split(&#39;_&#39;)
    packed = base64.b64decode(encoded)
    array = msgpack.unpackb(packed)
    return array[-1]
</code></pre></div></pre>
<p>to extract the database ID for pull request comments. Should I have made sure that we were storing the right ID in the first place? Probably, but then I wouldn&#39;t have had much fun uncovering all of this. And my deepest condolences to the GitHub engineer who has to deal with supporting these two different node ID formats.</p></article></div></div>
  </body>
</html>
