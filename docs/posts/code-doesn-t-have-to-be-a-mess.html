<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.danielsieger.com/blog/2022/07/25/your-code-doesnt-have-to-be-a-mess.html">Original</a>
    <h1>Code doesn’t have to be a mess</h1>
    
    <div id="readability-page-1" class="page"><div id="maincontent"><article>  <time datetime="2022-07-25">Jul 25, 2022</time> <blockquote> <p>Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it. - <a href="http://www.cs.yale.edu/homes/perlis-alan/quotes.html">Alan Perlis</a></p> </blockquote> <p>If you’ve been developing software for a while, you know that code has this natural tendency to turn into a mess. Keeping software simple over time is a challenge that keeps me thinking. My <a href="https://www.danielsieger.com/blog/2022/03/30/kiss-over-time.html">last post</a> left you hanging without much concrete advice. This time I will outline a few high-level strategies to keep software simple.</p> <h2 id="define-clear-goals">Define Clear Goals</h2> <p>Define clear goals what problem your software is trying to solve. Write them down, keep them visible. Always keep them in mind when making decisions about adding a new feature or accepting a proposed change. Do one thing and do it well. Don’t try to solve a myriad of problems at the same time. Follow basic <a href="https://en.wikipedia.org/wiki/Unix_philosophy">Unix philosophy</a>.</p> <h2 id="setup-constraints">Setup Constraints</h2> <p>Define your non-goals as well: What problems does your software explicitly <em>not</em> solve? Constrain the scope of your software. Setup technical constraints on programming languages, libraries, or models of computation you are using. Embrace those constraints and stick to them. They will force you to think harder about the problem at hand. Get creative within the bounds of your constraints. Working with constraints can <a href="https://www.inc.com/thomas-oppong/for-a-more-creative-brain-embrace-constraints.html">foster creativity and innovation</a>. However, be aware when you need to bend your code too much.</p> <h2 id="say-no">Say No</h2> <p>There is almost always an infinite demand for new features and functionality. Learning to say no is crucial to keep your software from growing wildly into too many directions. This can be super tough or downright impossible, notably in a commercial context. But even then: Do what is needed, but not more. Be aware of feature creep. But also be aware of when saying no would be unreasonable.</p> <h2 id="eliminate-waste">Eliminate Waste</h2> <p>Regularly pare down your code, and be relentless while doing it. Remove any unused features, dead code, debugging helpers, or prototype code used during development. Version control has your back. Eliminating waste is a core principle of <a href="https://en.wikipedia.org/wiki/Lean_software_development">lean software development</a>. Borderline but fun: Only accept PRs that reduce net code size for a while. Be aware of code obfuscation though.</p> <h2 id="minimize-dependencies">Minimize Dependencies</h2> <p>Be picky about adding any dependencies. Don’t treat code re-use as a holy grail. Carefully consider the pros and cons. Dependencies might break, disappear, turn into garbage, or become a security risk. Consider to <a href="https://macwright.com/2021/03/11/vendor-by-default.html">vendor by default</a>. If the functionality in question is crucial for your core business: Consider <a href="https://www.joelonsoftware.com/2001/10/14/in-defense-of-not-invented-here-syndrome/">doing it yourself</a>.</p>  <p>Obviously, the above strategies are not equally applicable in all settings. Your mileage might vary a lot between commercial development, an open source project, or creative coding.</p> <p>Similarly, striving for simplicity can be much harder if you are working on software that tackles complex problems. Some problem domains have an inherent complexity that can not be negotiated away. However, even in those cases you can strive for simplicity in the building blocks of your complex system.</p> <p>If you are developing software on a team, there is also an important social dimension. Some folks just revel in complexity, and it can be tough to develop a sense for simplicity with them. I’ve got the suspicion that the C++ crowd is particularly vulnerable to this disposition, but that’s another story.</p> <p>Finally, keep in mind that simplicity is not a value by itself. It is a means to an end: produce better software, and be able to maintain and evolve it over time.</p> <h2 id="references-and-further-reading">References and Further Reading</h2> <ul> <li><a href="https://youtu.be/SxdOUGdseq4">Simple Made Easy</a> by Rich Hickey</li> <li><a href="https://iansommerville.com/technology/software-simplicity/">The Myth of Software Simplicity</a> by Ian Sommerville</li> <li><a href="https://en.wikipedia.org/wiki/Unix_philosophy">Unix philosophy</a></li> <li><a href="https://en.wikipedia.org/wiki/Lean_software_development">Lean software development</a></li> <li><a href="http://www.cs.yale.edu/homes/perlis-alan/quotes.html">Epigrams in Programming</a> by Alan Perlis</li> <li><a href="https://www.goodreads.com/book/show/3735293-clean-code">Clean Code</a> by Robert C. Martin</li> <li><a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> by John Ousterhout</li> </ul> </article> </div></div>
  </body>
</html>
