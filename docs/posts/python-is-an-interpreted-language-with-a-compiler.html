<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ntietz.com/blog/python-is-an-interpreted-language-with-a-compiler/?utm_source=atom&amp;utm_medium=feed">Original</a>
    <h1>Python is an interpreted language with a compiler</h1>
    
    <div id="readability-page-1" class="page"><div><p>After I put up a post about a Python gotcha, someone remarked that &#34;there are very few interpreted languages in common usage,&#34; and that they &#34;wish Python was more widely recognized as a compiled language.&#34;
This got me thinking: what <em>is</em> the distinction between a compiled or interpreted language?
I was pretty sure that I do think Python is interpreted, but how would I draw that distinction cleanly?</p>
<p>On the surface level, it seems like the distinction between compiled and interpreted languages is obvious: compiled languages have a compiler, and interpreted languages have an interpreter.
We typically call Java a compiled language and Python an interpreted language.
But on the inside, Java has an interpreter and Python has a compiler.</p>
<p>What&#39;s going on?</p>

<p>A <em>compiler</em> takes code written in one programming language and turns it into a runnable thing.
It&#39;s common for this to be machine code in an executable program, but it can also by bytecode for VM or assembly language.</p>
<p>On the other hand, an <em>interpreter</em> directly takes a program and runs it.
It doesn&#39;t require any pre-compilation to do so, and can apply a variety of techniques to achieve this (even a compiler).</p>
<p>That&#39;s where the distinction really lies: what you end up running.
An interpeter runs your program, while a compiler produces something that <em>can</em> run later (or right now, if it&#39;s in an interpreter).</p>

<p>A compiled language is one that uses a compiler, and an interpreted language uses an interpreter.
Except... many languages use both.</p>
<p>Let&#39;s look at Java.
It has a compiler, which you feed Java source code into and you get out an artifact that <em>you can&#39;t run directly</em>.
No, you have to feed that into the Java virtual machine, which then <em>interprets</em> the bytecode and runs it.
So the entire Java stack seems to have both a compiler and an interpreter.
But it&#39;s the <em>usage</em>, that you have to pre-compile it, that makes it a compiled language.</p>
<p>And similarly is Python.
It has an interpreter, which you feed Python source code into and it runs the program.
But on the inside, it has a compiler.
That compiler takes the source code, turns it into Python bytecode, and then feeds that into the Python virtual machine.
So, just like Java, it goes from code to bytecode (which is even written to the disk, usually) and bytecode to VM, which then runs it.
And here again we see the usage, where you don&#39;t pre-compile anything, you just run it.</p>
<p>That&#39;s the difference.
And that&#39;s why Python is an interpreted language <em>with</em> a compiler!</p>

<p>Ultimately, why does it matter?
If I can do <code>cargo run</code> and get my Rust program running the same as if I did <code>python main.py</code>, don&#39;t they feel the same?
On the surface level, they do, and that&#39;s because it&#39;s a really nice interface so we&#39;ve adopted it for many interactions!
But underneath it, you see the differences peeping out from the compiled or interpreted nature.</p>
<p>When you run a Python program, it will run until it encounters an error, even if there&#39;s malformed syntax!
As long as it doesn&#39;t need to <em>load</em> that malformed syntax, you&#39;re able to start running.
But if you <code>cargo run</code> a Rust program, it won&#39;t run <em>at all</em> if it encounters an error in the compilation step!
It has to run the <em>entire</em> compilation process before the program will start at all.</p>
<p>The difference in approaches runs pretty deep into the feel of an entire toolchain.
That&#39;s where it matters, because it is one of the fundamental choices that everything else is built around.
The words here are ultimately arbitrary.
But they tell us a lot about the language and tools we&#39;re using.</p>
<p>* * *</p>
<p>Thank you to <a href="https://recurse.social/@cthulahoops">Adam</a> for feedback on a draft of this post.</p>
<hr/>
</div><p>
  If you&#39;re looking to grow more effective as a software engineer, please consider my <a href="https://jonathan.protzenko.fr/coaching/">coaching services</a>.
  </p></div>
  </body>
</html>
