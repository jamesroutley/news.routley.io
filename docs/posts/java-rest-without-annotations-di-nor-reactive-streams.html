<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/MartinGeisse/grumpyrest">Original</a>
    <h1>Show HN: Java REST without annotations, DI nor reactive streams</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">grumpyrest is a Java REST server framework that does not use annotations, automatic dependency injection or reactive
streams, and minimizes the use of reflection. Instead,</p>
<ul dir="auto">
<li>it leverages the Java type system to indicate the meaning of classes, fields and methods</li>
<li>it calls constructors to create dependency objects, and passes constructor parameters to inject them</li>
<li>it uses threads to achieve parallelism, and in particular virtual threads for highly parallel I/O</li>
</ul>
<p dir="auto">Particular differences with typical REST frameworks:</p>
<ul dir="auto">
<li>To mount an endpoint to a URL, you do not annotate the handler method. Instead, you call a mount method and pass the
handler as a parameter.</li>
<li>To access request properties such as URL path parameters, querystring parameters or the request body, you do not
declare handler parameters. Instead, you call a method. This method takes a specification of the expected type
and performs validation before returning its data.</li>
<li>Request/response bodies are typically expected to be JSON. To declare how the request body is parsed from JSON, as
well as validations to perform, you use appropriate Java types that validate their parameters / fields in their
constructor. Similarly, to declare how the response objects are mapped to JSON, you use appropriate Java types with
a well-defined JSON mapping. Mappings in both directions can be registered from outside the data-holding classes to
support existing classes.</li>
<li>This includes nullable and optional fields: Appropriate generic wrapper types are provided to define nullable and/or
optional fields. Java&#39;s null references are NOT considered equivalent to JSON-null nor to absent JSON properties,
and having null references on the Java side of JSON mapping is considered an error to avoid any ambiguities.</li>
<li>No type / field is nullable or optional by default. No default values will be inserted for missing fields. No
coercion from number to string or from string to number will be done by default. An empty JSON object, empty JSON
array, false, 0, null and missing fields are all different things that are not considered equal. If you want to
bend these rules for specific types or fields, use an appropriate type for that which defines a relaxed mapping.
If you want to bend these rules for all of your JSON mapping, replace the built-in type adapters by your own which
define a relaxed mapping.</li>
</ul>
<h2 tabindex="-1" dir="auto"><a id="user-content-how-does-this-look-in-code" aria-hidden="true" href="#how-does-this-look-in-code"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>How does this look in code?</h2>
<p dir="auto">Here&#39;s a simple API that builds a greeting:</p>
<div data-snippet-clipboard-copy-content="RestApi api = new RestApi();
api.addRoute(&#34;/make-greeting&#34;, requestCycle -&gt; {
    MakeGreetingRequest request = requestCycle.parseBody(MakeGreetingRequest.class);
    if (request.addendum.isPresent()) {
        return new MakeGreetingResponse(&#34;Hello, &#34; + request.name + &#34;! &#34; + request.addendum.getValue());
    } else {
        return new MakeGreetingResponse(&#34;Hello, &#34; + request.name + &#34;!&#34;);
    }
});"><pre><code>RestApi api = new RestApi();
api.addRoute(&#34;/make-greeting&#34;, requestCycle -&gt; {
    MakeGreetingRequest request = requestCycle.parseBody(MakeGreetingRequest.class);
    if (request.addendum.isPresent()) {
        return new MakeGreetingResponse(&#34;Hello, &#34; + request.name + &#34;! &#34; + request.addendum.getValue());
    } else {
        return new MakeGreetingResponse(&#34;Hello, &#34; + request.name + &#34;!&#34;);
    }
});
</code></pre></div>
<p dir="auto">Request 1: <code>{&#34;name&#34;: &#34;Joe&#34;}</code></p>
<p dir="auto">Response 1: <code>{&#34;greeting&#34;: &#34;Hello, Joe!&#34;}</code></p>
<p dir="auto">Request 2: <code>{&#34;name&#34;: &#34;Joe&#34;, &#34;addendum&#34;: &#34;Nice to meet you.&#34;}</code></p>
<p dir="auto">Response 2: <code>{&#34;greeting&#34;: &#34;Hello, Joe! Nice to meet you.&#34;}</code></p>
<h2 tabindex="-1" dir="auto"><a id="user-content-what-about-performance" aria-hidden="true" href="#what-about-performance"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>What about performance?</h2>
<p dir="auto">It <em>is</em> anticipated that grumpyrest may provide tools to tackle potential performance problems, which rely on
reactive programming and/or code generation. The goal of grumpyrest is not to totally avoid these things internally,
but to allow the developers using it to totally avoid them in their application code.</p>
<p dir="auto">This means:</p>
<ul dir="auto">
<li>We will not add anything like that to grumpyrest until it is perfectly clear that it solves a performance problem
in modern Java which, for example, virtual threads cannot handle.</li>
<li>None of this affects application code, unless you choose to use it in application code (because the performance
problem lies there instead of inside grumpyrest).</li>
<li>Any such features can be turned of to exclude them as a potential source of bugs, as well as to single-step debug
into grumpyrest to understand what happens inside (e.g. to track down a specific bug). We all know what single-step
debugging into highly asynchronous / reactive or generated code is like.</li>
</ul>
<h2 tabindex="-1" dir="auto"><a id="user-content-json-mapping" aria-hidden="true" href="#json-mapping"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>JSON Mapping</h2>
<p dir="auto">A mapping exists between Java records and JSON objects:</p>
<div data-snippet-clipboard-copy-content="record CategoryLink(int id, String name) {}
record ProductResponse(CategoryLink category, String name, String description, int unitPrice) {}
new ProductResponse(new CategoryLink(2, &#34;Widgets&#34;), &#34;Left-handed Hammer&#34;, &#34;Excellent choice for left-handed people!&#34;, 10)"><pre><code>record CategoryLink(int id, String name) {}
record ProductResponse(CategoryLink category, String name, String description, int unitPrice) {}
new ProductResponse(new CategoryLink(2, &#34;Widgets&#34;), &#34;Left-handed Hammer&#34;, &#34;Excellent choice for left-handed people!&#34;, 10)
</code></pre></div>
<p dir="auto">&lt;-&gt;</p>
<div data-snippet-clipboard-copy-content="{
  &#34;category&#34;: {
    &#34;id&#34;: 2,
    &#34;name&#34;: &#34;Widgets&#34;
  },
  &#34;name&#34;: &#34;Left-handed Hammer&#34;,
  &#34;description&#34;: &#34;Excellent choice for left-handed people!&#34;,
  &#34;unitPrice&#34;: 10
}"><pre><code>{
  &#34;category&#34;: {
    &#34;id&#34;: 2,
    &#34;name&#34;: &#34;Widgets&#34;
  },
  &#34;name&#34;: &#34;Left-handed Hammer&#34;,
  &#34;description&#34;: &#34;Excellent choice for left-handed people!&#34;,
  &#34;unitPrice&#34;: 10
}
</code></pre></div>
<p dir="auto">A mapping for non-record objects could be defined, but the strong guarantees about their shape that come from the
language make the mapping very easy. Also, I just like that they are immutable.</p>
<p dir="auto">JSON arrays can be mapped to Guava&#39;s ImmutableList:</p>
<div data-snippet-clipboard-copy-content="ImmutableList.of(1, 2, 3)"><pre><code>ImmutableList.of(1, 2, 3)
</code></pre></div>
<p dir="auto">&lt;-&gt;</p>

<p dir="auto">Again, normal List / ArrayList could be mapped too, but I just like ImmutableList.</p>
<p dir="auto">JSON primitives are mapped to Java&#39;s built-in types, both boxed and unboxed. No coercion takes place, so for example
the number 123 cannot be parsed into a String-typed field (unless you override the type adapter for type String to
accept numbers).</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-nullable-and-optional-properties" aria-hidden="true" href="#nullable-and-optional-properties"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Nullable and Optional Properties</h3>
<p dir="auto">Object properties are neither nullable nor optional by default. That is, a missing property in JSON causes an error,
and so does a property that is null in JSON. The Java record can use the type NullableField to allow null in JSON,
but on the Java side, it is still not null but a NullableField without a value. This works similar to java.util.Optional
but IDEs complain if you actually use java.util.Optional except in a few specific places, and besides that nullable
properties and optional properties are different things, So I defined my own types.</p>
<p dir="auto">Similar to nullable fields, the type OptionalField defines a property which may be absent from its record. Again, I
didn&#39;t use java.util.Optional because that type doesn&#39;t seem to be meant for using it that way. This type can only be
used in records since a top-level value cannot be just absent, and for JSON array elements, an &#34;optional&#34; property can
never be parsed as absent and acts as a poor man&#39;s filter during serialization. So there is no added value in allowing
this in JSON arrays. Like NullableField, a missing optional property corresponds to an OptionalField object without a
value on the Java side, not to a field that is directly null in the containing record.</p>
<p dir="auto">As you may have guessed by now, Java&#39;s null reference never appears in JSON mapping: The parser won&#39;t produce it and
the serializer will throw an exception if you give it a record with a field that is null. Java&#39;s null references are
just too easy to get wrong, and especially, are ambiguous with respect to the fact that a property in JSON may be
nullable or optional. It may even be both: An OptionalField&lt;NullableField&gt; on the Java side maps to a JSON field
that may be absent, or null, or have a value.</p>
<p dir="auto">Unknown properties in records cause an error too. A type adapter which collects extra properties in a Map&lt;&gt; may be
defined in the  future.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-validation" aria-hidden="true" href="#validation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Validation</h3>
<p dir="auto">Other JSON mapping frameworks either define how they do validation after parsing, or say that validation is not their
business. In contrast, I do not think that it is possible to split parsing and validation into two different phases in
any meaningful way. To split them, there would have to be a Java type that results from parsing that represents the
data in a parsed but unvalidated state, which is then passed to validation. This implies one of three possible things:</p>
<ul dir="auto">
<li>either that such data is defined as Java classes which routinely do not validate their state in their constructor,
so they are happy with being in an inconsistent state. It might be even worse and such classes might not just delay
validation of their state until later, but they might even rely on external validation rules to do so, i.e. they do
not have an independent notion of what it means for their state to be &#34;valid&#34;.</li>
<li>or the classes used for JSON mapping are built outright as a set of dumb data containers, with the sole purpose of
making the JSON data accessible from Java code, and getting away from those classes agin as fast as possible. This
adds unnecessary complexity (there is a whole extra layer in your code without any real purpose) and validation is
actually harder now, because you have to define rules for your JSON but express them as rules in Java. This is
one of the reasons we have OptionalField and NullableField as two separate classes, because good luck if you have a
null reference in Java and when building an error message you want to know if the client sent null or forgot that
field.</li>
<li>or you aren&#39;t even defining rigorous validation rules, and impose whatever meaning is closest on the incoming JSON
data. Code that does this will happily ignore extra fields in records, coerce numbers to strings, give missing
properties and null properties the same meaning, and so on. This does not mean that your code is unsafe -- safety
is implemented by the code that does something with that data, and is rarely dependent on JSON validation. However,
I think that being careless about validation will steer you directly into hell when it comes to versioning you
JSON API payloads, and making changes to them, because the clients calling your API are almost guaranteed to be
dependent on behavior of your API in cases that you never defined.</li>
</ul>
<p dir="auto">The bottom line is that we don&#39;t have any validation after parsing. Rather, validation is part of parsing. If signing
up to your service requires users to be at least 18 years old, validate (age &gt;= 18) in the constructor of your
SignUpRequestBody. If the username cannot be empty, check that too in the same constructor. Alternatively, if usernames
must be specific in many places and must be validated to be nonempty (and possibly at least 5 characters, and not
contain ASCII control characters nor offensive words), define a UserName type that checks these things in its
constructor. If you have an existing typpe chose constructor cannot be changed, wrap it in a type that defines
its validity rules. Or, as the last resort, you can define a custom type adapter and register it in the JsonRegistry
that defines how a type gets parsed and serialized. But there is no validation after parsing, period.</p>
</article>
          </div></div>
  </body>
</html>
