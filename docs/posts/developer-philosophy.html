<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://qntm.org/devphilo">Original</a>
    <h1>Developer Philosophy</h1>
    
    <div id="readability-page-1" class="page">
    

    <div>
      <div>
         

        <div>
          <p>Amazing as it may seem after all these years, there are still junior developers in the world.</p>
<p>A few weeks ago at work we had a talk where senior developers (including me) were invited to spend around five minutes each talking about our personal software development philosophies. The idea was for us to share our years of experience with our more junior developers.</p>
<p>After the session, I felt that it might be valuable to write my own thoughts up, and add a little more detail. So here we are.</p>
<p>This listing is a little miscellaneous; it isn&#39;t intended to be an exhaustive exploration of the way in which I develop software. Also, if you are a senior developer already then obviously you might already be familiar with some of this. Or disagree! Software development is a famously subjective field. See you in the comments.</p>

<h3 id="sec0">Avoid, at all costs, arriving at a scenario where the ground-up rewrite starts to look attractive</h3>

<p>It&#39;s generally pretty well-understood that the ground-up rewrite can be an attractive and extremely dangerous prospect. The standard advice when it comes to ground-up rewrites is &#34;Don&#39;t, ever&#34;. But I want to take a step back from that.</p>
<p>By the time the ground-up rewrite starts to seem like a good idea, <em>avoidable mistakes have already been made</em>. This is a scenario which you can see coming from a long way out and you can, and must, actively steer away from.</p>
<p>Warning signs to watch for: compounding technical debt. Increasing difficulty in making seemingly simple changes to code. Difficulty in documenting/commenting code. Difficulty in onboarding new developers. Dwindling numbers of people who know how particular areas of the codebase actually work. Bugs nobody understands.</p>
<p>Compounding complexity must be fought at every turn. <a href="https://knowledge.csc.gov.sg/ethos-issue-21/how-to-build-good-software/#:~:text=good%20software%20involves-,alternating%20cycles%20of%20expanding%20and%20reducing%20complexity,-.%20As%20new%20features">Alternate between phases of expansion (new features) and consolidation</a>.</p>
<p>Of course, a ground-up rewrite <em>can</em> actually work. It might even be a better choice that the alternative (persisting with your existing technical debt-laden swamp of code). Equally, it might be that <em>neither</em> choice will work — the project is doomed, and you&#39;re just choosing how it dies. The point is that there is inherent risk to this situation... but the situation itself is avoidable, and that risk is avoidable.</p>

<h3 id="sec1">Aim to be 90% done in 50% of the available time</h3>

<p>There is a famous adage in software development — actually, thinking about it, it might originate outside of software development — which goes,</p>

<blockquote>
<p>The first 90% of the job takes 90% of the time. The last 10% of the job takes the other 90% of the time.</p>
</blockquote>

<p>This is mildly amusing and absolutely factually accurate. Having understood this, it is entirely possible to correct for it.</p>

<p>Writing the code, once, and getting it to work, takes a certain amount of time. Once you have done this, you need to understand that you are about half done. Polishing code up to a suitable level of coherence and maintainability, proper handling of edge cases and failure cases, unit testing, integration testing, usability testing/demos, &#34;last-minute&#34; feature changes, performance, serviceability, documentation... all of these things can take immense amounts of additional time, and they are also part of your job.</p>
<p>Many of these things are <em>theoretically</em> skippable. But in practice when you skip these things you end up with a shoddy, incomplete feature. And nobody is ever going to come back and finish the work &#34;properly&#34; afterwards. There is always more work. Do this three or four more times and you have a shoddy product.</p>
<p>Also, the writing of the code itself will throw up unexpected roadblocks. It is advisable to try to discover these roadblocks as soon as possible.</p>
<p>And if it magically turns out you don&#39;t need the extra time you planned for? Great, time to implement some process improvements! Or pay down some technical debt (see above)!</p>

<h3 id="sec2">Automate good practice</h3>

<p>Sometimes there&#39;s a particular thing which developers on a project should all <em>start</em> doing or <em>stop</em> doing. There&#39;s new best practice. There&#39;s a new tool we need to use consistently, everywhere; a new mandatory header on every source file; a check everybody has to run; a method which we&#39;ve collectively decided is no good to use (either an internal method or a third-party API). When this happens, there are two ways to get the developer base as a whole to change its behaviour:</p>

<ol>
<li>Socialise it. Tell everybody in person, one at a time or at the scrum or at the team meeting. Send out emails. Add the new guidelines to the wiki, or to the repo README, or the pull request remplate. Remind people to read the documentation, over and over. Manually review everybody&#39;s changes for oversights, forever. Make sure you never forget! Add checklists, try to train everybody to properly enforce those checklists. Increase the level of mandatory peer review. Remind everybody again. And again...</li>
<li>Automate it.</li>
</ol>

<p>Add an automated test which fails if the guideline is not followed. Or, if we can&#39;t fix everything everywhere all at once, add a <a href="https://qntm.org/ratchet">ratchet</a>. Fail fast, with a polite and instructive warning, if the right thing isn&#39;t done, or better yet, automatically fix the problem. In general, enforce best practice mechanically.</p>

<p>Automation isn&#39;t a perfect solution or a universal solution or a universally appropriate solution for things like this. There are plenty of softer requirements and abstract technical requirements which can&#39;t be automated, and it&#39;s possible to get <em>really</em> annoyingly strict by introducing too many <em>arbitrary</em> rules, and motivated developers can usually circumvent automation by various means. But if you find yourself telling people over and over again, &#34;You forgot to do <var>X</var>, please remember to always <var>X</var>&#34;, maybe it&#39;s time to automate <var>X</var>?</p>

<h3 id="sec3">Think about pathological data</h3>

<p>Nobody cares about the golden path. Edge cases are our <em>entire job</em>. Think about ways in which things can fail. Think about ways to try to make things break. Code should handle <em>every</em> possibility.</p>

<p>What if the request fails, or stalls forever, or sends back one byte per second for an hour? What if the table you&#39;re showing has a million rows? A billion rows? What if the name has a slash in it, or trailing whitespace, or is a megabyte long? I don&#39;t believe you when you say that you can prove that that string can&#39;t be empty!</p>

<h3 id="sec4">There is usually a simpler way to write it</h3>

<p>If you budgeted your time properly (see above), you have time to go back and see if you can do better. <i>C.f.</i> the old chess adage, &#34;When you see a good move, look for a better one.&#34; And another difficult-to-source quote, &#34;I apologise for writing such a long letter, but I didn&#39;t have time to write a short one.&#34;</p>

<h3 id="sec5">Write code to be testable</h3>

<p>This means well-defined interfaces and minimal side-effects. Code which is proving to be difficult to test is probably not properly encapsulated.</p>

<h3 id="sec6">It is insufficient for code to be provably correct; it should be obviously, visibly, trivially correct</h3>

<p>Some code seems to work correctly by accident, because the circumstances which could cause it to receive bad inputs and fail are ruled out by the structure of the other code surrounding it. I dislike this. Although technically the code may be free of bugs, restructuring the other code is now difficult and dangerous.</p>
<p>This is particularly true for security issues, or the theoretical absence of security issues. It doesn&#39;t matter that all of the callers to this particular internal function are trustworthy <em>right now</em>.</p>



<p>I had one other thing for this list but I don&#39;t remember it right now.</p>
        </div>

         
          
         
      </div>
    </div>

          <div>
        

        

        <div>
          <h3>Discussion (4)</h3>

                      <div id="komment67a11995522df">
              <h4>
                <a href="#komment67a11995522df">2025-02-03 19:31:33</a>
                by Richard B:
              </h4>

              <div>&gt; And another difficult-to-source quote, &#34;I apologise for writing such a long letter, but I didn&#39;t have time to write a short one.&#34;

Pascal: &#34;Je n&#39;ai fait cette lettre-ci plus longue que parce que je n&#39;ai pas eu le loisir de la faire plus courte.&#34;</div>

               
            </div>
                      <div id="komment67a119fe9be56">
              <h4>
                <a href="#komment67a119fe9be56">2025-02-03 19:33:18</a>
                by Richard B:
              </h4>

              <div>&gt; I had one other thing for this list but I don&#39;t remember it right now.

Always check twice for off by one errors.</div>

               
            </div>
                      <div id="komment67a1203a4c223">
              <h4>
                <a href="#komment67a1203a4c223">2025-02-03 19:59:54</a>
                by tyler:
              </h4>

              <div>&gt; Add the new guidelines to the wiki

Yes, it&#39;s obviously better to avoid any need for this, but it touches on a point that sometimes needs emphasis: people need to know where to find the information they need, how to use the automated systems, and so on.

I&#39;m reminded of a Mitch Hedberg joke: &#34;This shirt is dry-clean-only... which means it&#39;s dirty.&#34; At one job, our &#34;official&#34; software documentation had to go through a whole approval process, which meant it was outdated. Nobody really wanted to go through the bureaucracy of updating it, or even knew how to do that, so eventually those documents were mostly forgotten about. As for wikis, it would&#39;ve been nice to have &#34;the&#34; wiki; we had 3 or 4 at first, and nobody would ever update them because nobody knew which was canonical; as with the documents, they thus became a useless and forgotten resource.

After too much time, we decided on one wiki, copied stuff there, and told everyone. Then when a junior person found something wasn&#39;t explained there, I could write a mail message and paste it into the wiki, or ask them to reverse-engineer and document it. We&#39;d make sure all the relevant documents were linked from there; a page would say who&#39;s familiar with which areas; and so on. That was a big improvement. Of course, going back to your point, it&#39;s better to have this stuff be accessible: documents stored in source control with the code are usually better than those in a wiki; code comments (within reason) are probably better than separate documents; code that&#39;s so obvious that it doesn&#39;t need explanation is ideal.

Automated testing and building was a whole other problem. A lot of these tests had &#34;weird&#34; environmental requirements such that most programmers had never run *all* the tests. Same for the builds; a &#34;desktop build&#34; would never *quite* match the official Jenkins builds, if it worked at all. Plus the system would only build what was already committed to the repository, which meant breakage would sometimes be detected too late. The builds were run on &#34;janky&#34; virtual machines (hard-coded passwords etc.), inaccessible to us, managed by an entirely separate team; we didn&#39;t fully understand their setup, and they didn&#39;t understand our software.

One tip: don&#39;t use non-trivial Jenkins &#34;build scripts&#34;; it shouldn&#39;t be much more than &#34;cd project; ./build-it&#34;, with &#34;build-it&#34; being source-controlled like everything else, and the same script that people use at their desks. And if virtual machines are used, make those images available to everybody. I guess it all kind of goes back to the same point: try to avoid &#34;edge cases&#34;. Make destroy_object(foo) work when foo is NULL, rather than expecting callers to check; have a failed create_object() call destroy_object() rather than duplicating its logic (&#34;goto fail7&#34;); have developers run the same build and test scripts as the servers; have everyone participate in documentation.</div>

               
            </div>
                      <div id="komment67a1244bd4d2c">
              <h4>
                <a href="#komment67a1244bd4d2c">2025-02-03 20:17:15</a>
                by Aybri:
              </h4>

              <div>There is no tool for changing behavior more effective than inconveniencing people until they memorize the wanted behavior.</div>

               
            </div>
           

                      

            

            <!-- comment -->
           
        </div><!-- comments -->
      </div>
     

    
  
</div>
  </body>
</html>
