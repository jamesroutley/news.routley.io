<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://atproto.com/articles/atproto-for-distsys-engineers">Original</a>
    <h1>ATProto for distributed system engineers</h1>
    
    <div id="readability-page-1" class="page"><div><article><div>
<p><em>Sep 3, 2024</em></p>
<p>AT Protocol is the tech developed at <a href="https://bsky.app">Bluesky</a> for open social networking. In this article we&#39;re going to explore AT Proto from the perspective of distributed backend engineering.</p>
<p>If you&#39;ve ever built a backend with <a href="https://milinda.pathirage.org/kappa-architecture.com/">stream-processing</a>, then you&#39;re familiar with the kind of systems we&#39;ll be exploring. If you&#39;re not — no worries! We&#39;ll step through it.</p>

<p>The classic, happy Web architecture is the “one big SQL database” behind our app server. The app talks to the database and handles requests from the frontend.</p>
<p><img alt="" loading="lazy" width="1169" height="1600" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage1.c6dcf0c4.png&amp;w=1200&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage1.c6dcf0c4.png&amp;w=3840&amp;q=75 2x" src="https://atproto.com/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage1.c6dcf0c4.png&amp;w=3840&amp;q=75"/></p>
<p>As our application grows, we hit some performance limits so we toss some caches into the stack.</p>
<p><img alt="" loading="lazy" width="1600" height="1229" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage2.693478de.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage2.693478de.png&amp;w=3840&amp;q=75 2x" src="https://atproto.com/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage2.693478de.png&amp;w=3840&amp;q=75"/></p>
<p>Then let&#39;s say we scale our database horizontally through sharding and replicas.</p>
<p><img alt="" loading="lazy" width="1600" height="1457" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage3.88182e12.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage3.88182e12.png&amp;w=3840&amp;q=75 2x" src="https://atproto.com/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage3.88182e12.png&amp;w=3840&amp;q=75"/></p>
<p>This is pretty good, but we&#39;re building a social network with hundreds of millions of users; even this model hits limits. The problem is that our SQL database is “<a href="https://en.wikipedia.org/wiki/Strong_consistency">strongly consistent</a>” which means the state is kept uniformly in sync across the system. Maintaining strong consistency incurs a performance cost which becomes our bottleneck.</p>
<p>If we can relax our system to use “<a href="https://en.wikipedia.org/wiki/Eventual_consistency">eventual consistency</a>,” we can scale much further. We start by switching to a NoSQL cluster.</p>
<p><img alt="" loading="lazy" width="1600" height="1492" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage4.524d9b4a.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage4.524d9b4a.png&amp;w=3840&amp;q=75 2x" src="https://atproto.com/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage4.524d9b4a.png&amp;w=3840&amp;q=75"/></p>
<p>This is better for scaling, but without SQL it&#39;s becoming harder to build our queries. It turns out that SQL databases have a lot of useful features, like JOIN and aggregation queries. In fact, our NoSQL database is really just a key-value store. Writing features is becoming a pain!</p>
<p>To fix this, we need to write programs which generate precomputed views of our dataset. These views are essentially like cached queries. We even duplicate the canonical data into these views so they&#39;re very fast.</p>
<p>We&#39;ll call these our View servers.</p>
<p><img alt="" loading="lazy" width="1378" height="1038" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage5.5e756a1a.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage5.5e756a1a.png&amp;w=3840&amp;q=75 2x" src="https://atproto.com/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage5.5e756a1a.png&amp;w=3840&amp;q=75"/></p>
<p>Now we notice that keeping our view servers synced with the canonical data in the NoSQL cluster is tricky. Sometimes our view servers crash and miss updates. We need to make sure that our views stay reliably up-to-date.</p>
<p>To solve this, we introduce an event log (such as <a href="https://kafka.apache.org/">Kafka</a>). That log records and broadcasts all the changes to the NoSQL cluster. Our view servers listen to — and replay — that log to ensure they never miss an update, even when they need to restart.</p>
<p><img alt="" loading="lazy" width="1600" height="1183" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage6.9e038bff.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage6.9e038bff.png&amp;w=3840&amp;q=75 2x" src="https://atproto.com/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage6.9e038bff.png&amp;w=3840&amp;q=75"/></p>
<p>We&#39;ve now arrived at a <a href="https://milinda.pathirage.org/kappa-architecture.com/">stream processing architecture</a>, and while there are a lot more details we could cover, this is enough for now.</p>
<p>The good news is that this architecture scales pretty well. We&#39;ve given up strong consistency and sometimes our read queries lag behind the most up to date version of the data, but the service doesn&#39;t drop writes or enter an incorrect state.</p>
<p>In a way, what we&#39;ve done is custom-built a database by <a href="https://www.youtube.com/watch?v=fU9hR3kiOK0">turning it inside-out</a>. We simplified the canonical storage into a NoSQL cluster, and then built our own querying engine with the view servers. It&#39;s a lot less convenient to build with, but it scales.</p>

<p>The goal of AT Protocol is to interconnect applications so that their backends share state, including user accounts and content.</p>
<p>How can we do that? If we look at our diagram, we can see that most of the system is isolated from the outside world, with only the App server providing a public interface.</p>
<p><img alt="" loading="lazy" width="1600" height="1094" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage7.0e152275.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage7.0e152275.png&amp;w=3840&amp;q=75 2x" src="https://atproto.com/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage7.0e152275.png&amp;w=3840&amp;q=75"/></p>
<p>Our goal is to break this isolation down so that other people can join our NoSQL cluster, our event log, our view servers, and so on.</p>
<p>Here&#39;s how it&#39;s going to look:</p>
<p><img alt="" loading="lazy" width="1600" height="1109" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage8.8cde2a8c.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage8.8cde2a8c.png&amp;w=3840&amp;q=75 2x" src="https://atproto.com/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage8.8cde2a8c.png&amp;w=3840&amp;q=75"/></p>
<p>Each of these internal services are now external services. They have public APIs which anybody can consume. On top of that, anybody can create their own instances of these services.</p>
<p>Our goal is to make it so anybody can contribute to this decentralized backend. That means that we don&#39;t just want one NoSQL cluster, or one View server. We want lots of these servers working together. So really it&#39;s more like this:</p>
<p><img alt="" loading="lazy" width="1600" height="925" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage9.a51ae040.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage9.a51ae040.png&amp;w=3840&amp;q=75 2x" src="https://atproto.com/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage9.a51ae040.png&amp;w=3840&amp;q=75"/></p>
<p>So how do we make all of these services work together?</p>

<p>We&#39;re going to establish a shared data model called the <a href="https://atproto.com/guides/data-repos">“user data repository.”</a></p>
<p><img alt="" loading="lazy" width="438" height="464" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage10.6817a213.png&amp;w=640&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage10.6817a213.png&amp;w=1080&amp;q=75 2x" src="https://atproto.com/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage10.6817a213.png&amp;w=1080&amp;q=75"/></p>
<p>Every data repository contains JSON documents, which we&#39;ll call “records”.</p>
<p><img alt="" loading="lazy" width="838" height="554" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage11.4f73b780.png&amp;w=1080&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage11.4f73b780.png&amp;w=1920&amp;q=75 2x" src="https://atproto.com/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage11.4f73b780.png&amp;w=1920&amp;q=75"/></p>
<p>For organizational purposes, we&#39;ll bucket these records into “collections.”</p>
<p><img alt="" loading="lazy" width="870" height="570" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage12.bd8affbd.png&amp;w=1080&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage12.bd8affbd.png&amp;w=1920&amp;q=75 2x" src="https://atproto.com/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage12.bd8affbd.png&amp;w=1920&amp;q=75"/></p>
<p>Now we&#39;re going to opinionate our NoSQL services so they all use this <a href="https://atproto.com/guides/data-repos">data repository</a> model.</p>
<p><img alt="" loading="lazy" width="1600" height="1010" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage13.88b82924.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage13.88b82924.png&amp;w=3840&amp;q=75 2x" src="https://atproto.com/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage13.88b82924.png&amp;w=3840&amp;q=75"/></p>
<p>Remember: the data repo services are still basically NoSQL stores, it&#39;s just that they&#39;re now organized in a very specific way:</p>
<ol>
<li>Each user has a data repository.</li>
<li>Each repository has collections.</li>
<li>Each collection is an ordered K/V store of JSON documents.</li>
</ol>
<p>Since the data repositories can be hosted by anybody, we need to give them <a href="https://atproto.com/specs/at-uri-scheme">URLs</a>.</p>
<p><img alt="" loading="lazy" width="380" height="354" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage14.47dc55b6.png&amp;w=384&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage14.47dc55b6.png&amp;w=828&amp;q=75 2x" src="https://atproto.com/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage14.47dc55b6.png&amp;w=828&amp;q=75"/></p>
<p>While we&#39;re at it, let&#39;s create a <a href="https://atproto.com/specs/at-uri-scheme">whole URL scheme</a> for our records too.</p>
<p><img alt="" loading="lazy" width="816" height="600" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage15.b82b14bb.png&amp;w=828&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage15.b82b14bb.png&amp;w=1920&amp;q=75 2x" src="https://atproto.com/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage15.b82b14bb.png&amp;w=1920&amp;q=75"/></p>
<p>Great! Also, since we&#39;re going to be syncing these records around the Internet, it would be a good idea to cryptographically sign them so that we know they&#39;re authentic.</p>
<p><img alt="" loading="lazy" width="1510" height="964" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage16.1d02511f.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage16.1d02511f.png&amp;w=3840&amp;q=75 2x" src="https://atproto.com/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage16.1d02511f.png&amp;w=3840&amp;q=75"/></p>

<p>Now that we&#39;ve set up our high-scale decentralized backend, let&#39;s map out how an application actually works on ATProto.</p>
<p>Since we&#39;re making a new app, we&#39;re going to want two things: an app server (which hosts our API &amp; frontend) and a view server (which collects data from the network for us). We often bundle the app &amp; view servers, and so we can just call it an “Appview.” Let&#39;s start there:</p>
<p><img alt="" loading="lazy" width="1294" height="876" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage17.bdea24e3.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage17.bdea24e3.png&amp;w=3840&amp;q=75 2x" src="https://atproto.com/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage17.bdea24e3.png&amp;w=3840&amp;q=75"/></p>
<p>A user logs into our app using OAuth. In the process, they tell us which server hosts their data repository, <em>and</em> they give us permission to read and write to it.</p>
<p><img alt="" loading="lazy" width="1256" height="1338" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage18.5b6c97f8.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage18.5b6c97f8.png&amp;w=3840&amp;q=75 2x" src="https://atproto.com/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage18.5b6c97f8.png&amp;w=3840&amp;q=75"/></p>
<p>We&#39;re off to a good start — we can read and write JSON documents in the user&#39;s repo. If they already have data from other apps (like a profile) we can read that data too. If we were building a singleplayer app, we&#39;d already be done.</p>
<p>But let&#39;s chart what happens when we write a JSON document.</p>
<p><img alt="" loading="lazy" width="1600" height="1324" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage19.6cb5a9de.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage19.6cb5a9de.png&amp;w=3840&amp;q=75 2x" src="https://atproto.com/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage19.6cb5a9de.png&amp;w=3840&amp;q=75"/></p>
<p>This commits the document to the repo, then fires off a write into the event logs which are listening to the repo.</p>
<p><img alt="" loading="lazy" width="1600" height="827" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage20.032fb864.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage20.032fb864.png&amp;w=3840&amp;q=75 2x" src="https://atproto.com/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage20.032fb864.png&amp;w=3840&amp;q=75"/></p>
<p>From there, the event gets sent to any view services that are listening — including our own!</p>
<p><img alt="" loading="lazy" width="1600" height="846" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage21.d3fed181.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage21.d3fed181.png&amp;w=3840&amp;q=75 2x" src="https://atproto.com/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage21.d3fed181.png&amp;w=3840&amp;q=75"/></p>
<p>Why are we listening to the event stream if we&#39;re the one making the write? Because we&#39;re not the only ones making writes! There are lots of user repos generating events, and lots of apps writing to them!</p>
<p><img alt="" loading="lazy" width="950" height="1250" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage22.da5edbc6.png&amp;w=1080&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage22.da5edbc6.png&amp;w=1920&amp;q=75 2x" src="https://atproto.com/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage22.da5edbc6.png&amp;w=1920&amp;q=75"/></p>
<p>So we can see a kind of circular data flow throughout our decentralized backend, with writes being committed to the data repos, then emitted through the event logs into the view servers, where they can be read by our applications.</p>
<p><img alt="" loading="lazy" width="1600" height="1013" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage23.5342b3db.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage23.5342b3db.png&amp;w=3840&amp;q=75 2x" src="https://atproto.com/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage23.5342b3db.png&amp;w=3840&amp;q=75"/></p>
<p>And (one hopes) that this network continues to scale: not just to add capacity, but to create a wider variety of applications sharing in this open applications network.</p>
<p><img loading="lazy" width="1504" height="1082" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage24.2111e734.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage24.2111e734.png&amp;w=3840&amp;q=75 2x" src="https://atproto.com/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fimage24.2111e734.png&amp;w=3840&amp;q=75"/></p>

<p>The AT Protocol merges p2p tech with high-scale systems practices. Our founding engineers were core <a href="https://en.wikipedia.org/wiki/InterPlanetary_File_System">IPFS</a> and <a href="https://en.wikipedia.org/wiki/Dat_(software)">Dat</a> engineers, and Martin Kleppmann — the author of <a href="https://www.oreilly.com/library/view/designing-data-intensive-applications/9781491903063/">Data Intensive Applications</a> — is an active technical advisor.</p>
<p>Before Bluesky was started, we established a clear requirement of “no steps backwards.” We wanted the network to feel as convenient and global as every social app before it, while still working as an open network. This is why, when we looked at federation and blockchains, the scaling limits of those architectures stood out to us. Our solution was to take standard practices for high scale backends, and then apply the techniques we used in peer-to-peer systems to create an open network.</p>
</div></article></div></div>
  </body>
</html>
