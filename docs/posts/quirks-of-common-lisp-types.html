<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.fosskers.ca/en/blog/cl-type-quirks">Original</a>
    <h1>Quirks of Common Lisp Types</h1>
    
    <div id="readability-page-1" class="page"><div><p>&#34;But I need types,&#34; he told me.</p><p>Humans have a tendency toward binary thinking (pardon the pun). If it&#39;s not A, it&#39;s B. Perhaps because Lisps have REPLs, they are often thought of from the outside as being dynamic, interpreted languages. Our years of Python have taught us that such languages don&#39;t really have strong typing - it&#39;s all a wild guess until the interpreter calls <code>foo</code> on <code>a</code> and <code>b</code> and we find out who everyone really is.</p><p>Yet Common Lisp is fully typed, and AOT compiled. You can assign strict types to variables and entire functions, and the compilers will use this both for optimization and general correctness checking, and you can freely inspect the assembly code of any compiled function. All of this while maintaining the fluidity of development flows usually reserved for dynamic languages.</p><p>But we&#39;re not here today for the revelation that Common Lisp has types.</p><p>This article elaborates Common Lisp&#39;s conception of &#34;types&#34; and their triple-natured reality, answering the questions:</p><ul><li>What is a type?</li><li>What is a class?</li><li>What is the machine really doing?</li></ul><p>Discussions:</p><ul><li><a href="https://news.ycombinator.com/item?id=45079131">Hacker News</a></li><li><a href="https://lobste.rs/s/vn42xa/quirks_common_lisp_types">Lobsters</a></li></ul><h2 id="orgcd1acb">Types are of the Sky</h2><p>I settled on Common Lisp two years ago because I found it to be the most debuggable language I had tried in my career. The time between discovery of the <i>What</i> of a problem to the <i>Why</i> is the shortest for me in this language, and this is due to how inspectable everything is.</p><p>In Common Lisp, each type is a <span>set</span>, and each piece of Lisp data belongs to at least one. We can ask any such data value for its type:</p><pre>(INTEGER 0 4611686018427387903)</pre><p>An unsigned integer, by the looks of it, of 62-bit range. How about a string literal?</p><pre>(SIMPLE-ARRAY CHARACTER (1))</pre><p>A one-dimensional, length-one <code>array</code> of <code>character</code> values.</p><p>We can interrogate these values a bit further:</p><div><pre>(list (typep 37 &#39;integer)
      (typep 37 &#39;real)
      (typep 37 &#39;number)
      (typep 37 t))</pre></div><pre>(T T T T)</pre><p>Where <code>T</code> means &#34;True&#34;.</p><div><pre>(list (typep &#34;漣&#34; &#39;simple-array)
      (typep &#34;漣&#34; &#39;string)
      (typep &#34;漣&#34; &#39;vector)
      (typep &#34;漣&#34; &#39;array)
      (typep &#34;漣&#34; t))</pre></div><pre>(T T T T T)</pre><p>As we can see, these types form larger and larger sets, and the same value can be a member of many such sets at the same time. Note also that this isn&#39;t a linear hierarchy: in the String example above, <code>simple-array</code> and <code>string</code> are unrelated. While any given string-like value will always be a <code>string</code>, it might not be a <code>simple-array</code>, depending on how it was initialized. <a href="https://lispcookbook.github.io/cl-cookbook/strings.html#string-and-character-types-hierarchy">See here for an
illustration</a>. I hear you thinking perhaps of Diamond Inheritance, so let us flee from these considerations for now.</p><h3 id="orgd71ed4">Types for Correctness</h3><p>The age old test: can I add an int to a string?</p><p>If we try to run this in our REPL, we&#39;re told:</p><pre>Value of #1=&#34;漣&#34; in (+ 37 &#34;漣&#34;) is #1#, not a NUMBER.</pre><p>Thank goodness. And if we try to really compile it?</p><div><pre>(defun rigourous-addition (n)
  (+ n &#34;漣&#34;))</pre></div><p>Luckily this also fails:</p><pre>warning: Constant &#34;漣&#34; conflicts with its asserted type NUMBER.</pre><p>The assertion here is coming from usage of <code>+</code>, which knows the expected types of its own arguments:</p><pre>(FUNCTION (&amp;REST NUMBER) (VALUES NUMBER &amp;OPTIONAL))</pre><p>We can set types on struct fields as well.</p><div><pre>(defstruct sky
  (molecules 0 :type integer))</pre></div><p>And if we try to violate that contract:</p><div><pre>(make-sky :molecules 1.1)</pre></div><pre>The value
  1.1
is not of type
  INTEGER
when setting slot MOLECULES of structure SKY</pre><p>It even works for array lengths:</p><div><pre>(defstruct haiku
  &#34;A poem of 5-7-5 characters.&#34;
  (mora nil :type (simple-array character (17))))</pre></div><div><pre>(make-haiku :mora &#34;まなつのひつうきんてらすおれはあつい&#34;)</pre></div><pre>The value
  &#34;まなつのひつうきんてらすおれはあつい&#34;
is not of type
  (SIMPLE-ARRAY CHARACTER (17))
when setting slot MORA of structure HAIKU</pre><p>Looks like I can&#39;t write a proper Haiku - I have one character too many, so its type is actually <code>(simple-array character (18))</code>. Had there been one less, it would have run without issue.</p><p>So as we can see, at both run-time and compile-time, Common Lisp does typechecking to prevent silly errors.</p><h3 id="orgc5d00e">Types for Optimization</h3><p>More often, however, such type hints are used to coax the compiler into producing better assembly code. Fortunately, we can be active participants in this process.</p><p>Let&#39;s improve our <code>rigourous-addition</code> function.</p><div><pre>(defun rigourous-addition (n)
  (+ n 37))</pre></div><p>If we compile this and run <code>(disassemble #&#39;rigourous-addition)</code>, we see:</p><pre>; disassembly for RIGOUROUS-ADDITION
; Size: 30 bytes. Origin: #xB800C62D23                        ; RIGOUROUS-ADDITION
; 23:       498B4D10         MOV RCX, [R13+16]                ; thread.binding-stack-pointer
; 27:       48894DF8         MOV [RBP-8], RCX
; 2B:       BF10000000       MOV EDI, 16
; 30:       488BD0           MOV RDX, RAX
; 33:       E818E339FF       CALL #xB800001050                ; SB-VM::GENERIC-+
; 38:       488B45F0         MOV RAX, [RBP-16]
; 3C:       C9               LEAVE
; 3D:       F8               CLC
; 3E:       C3               RET
; 3F:       CC0F             INT3 15                          ; Invalid argument count trap</pre><p>Here we notice something dreadful, a separate function call to a generic function.</p><pre>CALL #xB800001050                ; SB-VM::GENERIC-+</pre><p>It&#39;s doing this because at the moment it can&#39;t know what the type of <code>n</code> is. At best it could constrain it to <code>number</code>, but that&#39;s the type at <a href="https://lispcookbook.github.io/cl-cookbook/numbers.html">the top of the
number tower</a>, and adding ints to floats is not going to be free.</p><p>Let&#39;s add a function signature to tell the compiler that we know what we want.</p><div><pre>(declaim (ftype (function (fixnum) fixnum) rigourous-addition))
(defun rigourous-addition (n)
  (+ n 8))</pre></div><p><code>fixnum</code> is lower in the tower than <code>integer</code>, and (mostly) corresponds to a machine word, so this should always be the fastest thing to do arithmetic with. If we recompile and run <code>disassemble</code> again:</p><pre>; disassembly for RIGOUROUS-ADDITION
; Size: 25 bytes. Origin: #xB800C64DE9                        ; RIGOUROUS-ADDITION
; DE9:       498B4D10         MOV RCX, [R13+16]               ; thread.binding-stack-pointer
; DED:       48894DF8         MOV [RBP-8], RCX
; DF1:       488BD0           MOV RDX, RAX
; DF4:       4883C210         ADD RDX, 16
; DF8:       7005             JO L0
; DFA:       C9               LEAVE
; DFB:       F8               CLC
; DFC:       C3               RET
; DFD:       CC0F             INT3 15                         ; Invalid argument count trap
; DFF: L0:   CC2E             INT3 46                         ; ADD-SUB-OVERFLOW-ERROR
; E01:       09               BYTE #X09                       ; RDX(a)</pre><p>The extra function call has been compiled away into a single <code>ADD</code> instruction on two raw machine words. Don&#39;t yet worry about why there&#39;s a <code>16</code>, not an <code>8</code>, sitting there.</p><h3 id="org3aaf3d">Type Fluidity</h3><p>It seems that we&#39;ve achieved strong typing, until we see something like this:</p><div><pre>(let ((a 1)
      (b 37))
  (format t &#34;A:   ~a~%&#34; (type-of a))
  (format t &#34;B:   ~a~%&#34; (type-of b))
  (format t &#34;SUM: ~a~%&#34; (type-of (+ a b)))
  (format t &#34;NEG: ~a~%&#34; (type-of (+ a b -39))))</pre></div><pre>A:   BIT
B:   (INTEGER 0 4611686018427387903)
SUM: (INTEGER 0 4611686018427387903)
NEG: FIXNUM</pre><p>The C-mind sees type casting, but that isn&#39;t what&#39;s happening here. In C-thought, when it comes to types, we believe &#34;an int is an int and a struct is a struct&#34;. We use aliases like <code>bool</code>, but we know it&#39;s really just an unsigned byte under that.</p><p>In Common Lisp, <span>types offer a notion of general compatibility between
operations</span>, but are in fact <span>disconnected from their data representations</span> within Lisp itself. See for yourself:</p><div><pre>(let ((a 1)
      (b 37))
  (format t &#34;A:   ~a~%&#34; (class-of a))
  (format t &#34;B:   ~a~%&#34; (class-of b))
  (format t &#34;SUM: ~a~%&#34; (class-of (+ a b)))
  (format t &#34;NEG: ~a~%&#34; (class-of (+ a b -39))))</pre></div><pre>A:   #&lt;BUILT-IN-CLASS COMMON-LISP:FIXNUM&gt;
B:   #&lt;BUILT-IN-CLASS COMMON-LISP:FIXNUM&gt;
SUM: #&lt;BUILT-IN-CLASS COMMON-LISP:FIXNUM&gt;
NEG: #&lt;BUILT-IN-CLASS COMMON-LISP:FIXNUM&gt;</pre><p>Now onto classes.</p><h2 id="org580418">Classes are of the Earth</h2><p>Many of us were raised on the Big OO languages but later escaped, so even the word &#34;class&#34; may evoke complex emotions. Some OO languages make a distinction between classes and primitives (Java), while others call everything a class and box all their data (Ruby).</p><p>In Common Lisp, if the word &#34;type&#34; corresponds to a &#34;compatibility family&#34;, then &#34;class&#34; is what the data value is actually implemented as internally. So &#34;class&#34; here means &#34;type&#34; in C-thought.</p><p>As we saw above, <code>class-of</code> can be used to inspect what our data &#34;really is&#34;. How about that string literal from before?</p><div><pre>(list (type-of &#34;漣&#34;)
      (class-of &#34;漣&#34;))</pre></div><pre>((SIMPLE-ARRAY CHARACTER (1))
#&lt;BUILT-IN-CLASS SB-KERNEL:SIMPLE-CHARACTER-STRING&gt;)</pre><p>Likely for performance reasons, the SBCL compiler is using its own internal implementation for this, whose true details we have basically no access to. While the type claims it&#39;s a <code>simple-array</code>, technically the implementation is under no obligation to <i>be</i> a true array (in the C-sense) at all (although I&#39;m sure it is). It only has to <i>act</i> like one.</p><p>Classes are also types, as we can see from the <code>NEG</code> example from the previous section. <code>fixnum</code> was given as both the type and class of that return value, which is why we can use <code>fixnum</code> in function signatures and the <code>:type</code> declaration of struct fields.</p><p>Finally, we point out that while a value is only ever one class, and may have many types (recall the string example from the beginning), which type-sets it is a member of <span>depends on the value itself</span>. Recall <code>bit</code>. If you are a <code>fixnum</code> class you&#39;ll always be of <code>fixnum</code> type as well, but if you&#39;re of value 0 or 1, you&#39;ll also be of <code>bit</code> type (meaning you can interact with a <code>bit-vector</code>).</p><h3 id="orgfb2d51">Inheritance</h3><p>I said that values only have one class, which is true in terms of implementation, but Common Lisp also supports class inheritance in the usual OO sense. This lets child classes &#34;act as&#34; their parents if a certain function had expected the parent, and has implications about what fields are available (called &#34;slots&#34; in CL). Recall that like Haskell, struct/class field access is all done through typed functions (not <code>foo.bar</code> calls), and the concept of &#34;method&#34; exists but is different in a nice way.</p><h3 id="org97b2be">Generic Function Dispatch</h3><p>In Common Lisp, methods are not defined directly on classes. They are instead &#34;associated&#34;. We first define a &#34;generic function&#34;:</p><div><pre>(defgeneric collide (a b)
  (:documentation &#34;Smash two objects together.&#34;))</pre></div><p><code>collide</code> wants two of something. Let&#39;s define a method for it:</p><div><pre>(defmethod collide ((a fixnum) (b string))
  &#34;Who said I couldn&#39;t add an int and a string?&#34;
  (+ a (length b)))</pre></div><p>Just because the <code>fixnum</code> argument comes first doesn&#39;t mean that <code>collide</code> &#34;belongs&#34; to <code>fixnum</code> in any way. In fact, when defining a <code>defgeneric</code> we can ask for as many arguments as we want. Critically, the &#34;type annotations&#34; here are actually <span>class annotations</span>. You cannot, for instance, do:</p><div><pre>(defmethod collide ((a bit) (b (simple-array character (37)))))</pre></div><p>Since neither <code>bit</code> nor <code>simple-array</code> are classes.</p><p>It should be noted in passing that while <code>defmethod</code> is very flexible, in that we can define new ones anywhere and on any classes (whether we own them or not), we run the risk of &#34;orphan instances&#34; if we own neither the original <code>defgeneric</code> nor the classes we&#39;re associating with it.</p><h2 id="orgcb53e4">The Heart of the Machine</h2><h3 id="org28635e">&#34;Abstract&#34; Classes</h3><p>So classes are &#34;real&#34; and types are ephemeral, just compiler aids? Well no, classes might be ghostly too. While &#34;abstract class&#34; is never a term used in the Common Lisp world, some parent classes may be just that. Recall our string literal <code>&#34;漣&#34;</code> and its class <code>sb-kernel:simple-character-string</code>. If we inspect its chain of superclasses (not supertypes), we see:</p><pre>sb-kernel:simple-character-string
sb-kernel::character-string
common-lisp:string
common-lisp:vector
...</pre><p>Now let&#39;s construct an adjustable string and see what we see:</p><div><pre>(let ((s (make-array 5 :element-type &#39;character :adjustable t :fill-pointer 0)))
  (vector-push #\a s)
  (class-of s))</pre></div><pre>#&lt;BUILT-IN-CLASS SB-KERNEL::CHARACTER-STRING&gt;</pre><p>So we can&#39;t actually make something that is just a <code>string</code> with SBCL, but we can with ECL, where <code>class-of</code> on both literals and this adjustable string yields <code>string</code>; the same &#34;class&#34; even though they have different &#34;types&#34;. But then how does the compiler really know what to do when I call a function like <code>schar</code>, which in this case can only be called on the literal and not the adjustable string?</p><p>Here we&#39;d do well to recall that to the machine, our programming languages do not exist. The compiler is under no obligation to produce machine code that has any trace of the original types and classes we thought we were using. Rather, its duty to us is to ensure that we believe that when we call <code>schar</code> that the results produced are interpreted by us as what we wanted.</p><p>So during development what we really care about is behaviour, not implementation. And the guarantor of behaviour in Common Lisp is chiefly the <span>type system</span>. This explains why types, not classes, are what is shown by <code>inspect</code> when we view the result of some call.</p><h3 id="orgbce5a6">Fixnums</h3><p>To drive home the point that perceived behaviour and implementation can differ, let&#39;s recall our optimized <code>rigourous-addition</code> function.</p><p>Why did <code>(+ n 8)</code> become <code>ADD RDX, 16</code>?</p><p>This is because (at least with SBCL), the compiler sets certain bits of each machine word to use as &#34;type tags&#34;. These enable various optimizations. For <code>fixnum</code>, it is mandated that the least significant bit be 0, meaning that finite ints are really only 62-bit (1 sign bit, 62 value bits, 1 tag bit). Yet this &#34;machine truth&#34; is hidden from us. If we inspect <code>#b1111</code>:</p><pre>#&lt;(INTEGER 0 4611686018427387903) {1E}&gt;
--------------------
Value: 15 = #x0000000F = #o17 = #b1111 = 1.5e+1</pre><p>15, as we expected. And if we do a rightward bitshift to mess up the tag bit?</p><pre>Value: 7 = #x00000007 = #o7 = #b111 = 7.0e+0</pre><p>Thwarted: <code>0111</code>. Really the tag bit isn&#39;t even shown to us here. Yet I promise you that if we could <a href="https://simonsafar.com/2020/sbcl/">&#34;get in&#34;</a> to that value on the hardware, we&#39;d see the first four bits as <code>1110</code>. 8 became 16 in the assembly because:</p><pre>0000 1000 &lt;- 8
0001 0000 &lt;- 16</pre><p>But as we have seen, being aware of this is not necessary for daily Lisp usage.</p><h2 id="org15831d">Summary</h2><p>As <a href="https://en.wikipedia.org/wiki/Arjuna">Arjuna</a> asked Krishna, &#34;Yeah okay, but now what?&#34;</p><p>For Common Lisp development, we can mostly think in terms of types. Specifically:</p><ul><li>For function call and struct field compatibility, it&#39;s the <span>type</span> that matters.</li><li>For optimization, it&#39;s the <span>type</span> that matters.</li><li>For method dispatch, it&#39;s the <span>class</span> that matters.</li><li>For OO inheritance, it&#39;s the <span>class</span> that matters.</li></ul><p>Please let me know if I&#39;ve overlooked or mistaken any detail.</p><h2 id="org394751">Resources</h2><ul><li><a href="https://www.lispworks.com/documentation/HyperSpec/Body/04_a.htm">Hyperspec: Introduction to Types</a></li><li><a href="https://lispcookbook.github.io/cl-cookbook/strings.html#string-and-character-types-hierarchy">Type Hierarchy of Strings</a></li><li><a href="https://www.chiark.greenend.org.uk/doc/sbcl/sbcl-internals/Type-tags.html">SBCL Type Tags</a></li><li><a href="https://github.com/guicho271828/sbcl-wiki/wiki/Object-representation-%28lowtags%2C-widetags%2C-memory-consumption%2C-arrays%29">SBCL Object Representation</a></li></ul><p><span>Caution:</span> the SBCL links here have outdated information regarding the length of fixnum tag bits, but are still good resources.</p></div></div>
  </body>
</html>
