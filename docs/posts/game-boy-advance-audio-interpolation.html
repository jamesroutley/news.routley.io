<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jsgroth.dev/blog/posts/gba-audio-interpolation/">Original</a>
    <h1>Game Boy Advance Audio Interpolation</h1>
    
    <div id="readability-page-1" class="page"><div>
                <p>This post describes an audio enhancement that a Game Boy Advance emulator can implement to reduce audio aliasing and noise, at a fairly high level.</p>
<p>To start with, here’s a comparison from Metroid: Zero Mission as an example of what this can do:</p>
<figure>
  <audio controls="" preload="metadata">
    <source src="/blog/audio/gba-audio-interpolation/mzm-brinstar.mp3" type="audio/mpeg"/>
  </audio>
</figure>

<p><span>Metroid: Zero Mission - Brinstar (Accurate interpolation)</span></p><figure>
  <audio controls="" preload="metadata">
    <source src="/blog/audio/gba-audio-interpolation/mzm-brinstar-cubic.mp3" type="audio/mpeg"/>
  </audio>
</figure>

<p><span>Metroid: Zero Mission - Brinstar (Enhanced interpolation)</span></p>
<p>Much cleaner! The second recording does sound a little more muffled, but I’ll take that over the horrible audio aliasing in the first recording.</p>
<p>There are some alternative approaches to improving GBA audio that produce higher-quality results, such as <a href="https://github.com/nba-emu/NanoBoyAdvance" target="_blank" rel="noopener">NanoBoyAdvance’s</a> excellent MP2K HQ feature, but the interpolation approach is notable in that it works with any GBA game (though quality can vary by game). MP2K HQ for example only works with games that use the MP2K audio driver (aka M4A aka Sappy), which is <em>many</em> games but not every game.</p>
<p>This approach is not particularly novel - <a href="https://github.com/visualboyadvance-m/visualboyadvance-m" target="_blank" rel="noopener">VBA-M</a> has supported enhanced audio interpolation for a very long time. I believe the implementation details are a bit different though.</p>
<h2 id="background"><a href="#background"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"></path></svg></a><a href="#contents:background">Background</a></h2>
<p>The <a href="https://jsgroth.dev/blog/posts/gba-audio/#output">previous post</a> goes into more detail on how the GBA audio hardware works, but to summarize the part that’s most relevant for improving audio interpolation:</p>
<p>The GBA audio hardware outputs the final mixed audio samples using <a href="https://en.wikipedia.org/wiki/Pulse-width_modulation" target="_blank" rel="noopener">PWM</a> at 1 of 4 possible sampling frequencies ranging from 32768 Hz to 262144 Hz. The vast majority of GBA games use 65536 Hz, though occasionally you’ll see 32768 Hz (e.g. Castlevania: Circle of the Moon).</p>
<p>The GBA resamples from each audio channel’s frequency to the PWM sampling frequency by applying nearest neighbor interpolation, i.e. just outputting the channel’s current sample. This causes extremely noticeable audio aliasing in the final audio output, particularly when games use very low sample rates with the 2 PCM channels, which many games unfortunately do - sample rates in the 10000-14000 Hz range are very common (e.g. the Metroid example above is 13379 Hz).</p>
<p>The core idea behind enhancing interpolation is fairly simple: what if, instead of accurately emulating how the GBA PWM hardware works, the emulator uses its own interpolation algorithm to resample from audio channels’ sample rates directly to the emulator’s audio output sample rate?</p>
<h2 id="source-sample-rate"><a href="#source-sample-rate"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"></path></svg></a><a href="#contents:source-sample-rate">Source Sample Rate</a></h2>
<p>The first step is figuring out the source sample rate to resample from.</p>
<p>As mentioned in the previous post, you can compute a PCM channel’s sample rate using the clock divider and counter reload value of the GBA timer that it’s tracking:</p>
<div><div>
<div><table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="python"><span><span><span>gba_clock</span> <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>24</span>  <span># 16777216 Hz</span>
</span></span><span><span><span>sample_rate</span> <span>=</span> <span>gba_clock</span> <span>/</span> <span>((</span><span>0x10000</span> <span>-</span> <span>timer</span><span>.</span><span>reload</span><span>)</span> <span>*</span> <span>timer</span><span>.</span><span>clock_divider</span><span>)</span>
</span></span></code></pre></td></tr></tbody></table></div>
</div>
</div><p>The sample rate can be a fractional number, though the final clock divider value (<code>(0x10000 - reload) * divider</code>) is always a positive integer.</p>
<p>Games generally play most of their PCM audio at the same sample rate, but you will occasionally see games use different sample rates for different songs (e.g. Castlevania: Circle of the Moon again, it uses a much higher sample rate for its main menu music).</p>
<p>You need to recalculate the channels’ sample rates (or at least check if they’ve changed) whenever any of the following occurs:</p>
<ul>
<li>The game changes which timer a channel is tracking</li>
<li>Timer 0 or 1 is enabled or disabled</li>
<li>Timer 0 or 1’s reload value or clock divider changes</li>
<li>Timer 1’s cascading mode is enabled or disabled</li>
</ul>
<p>When a PCM channel is tracking a disabled timer, it constantly outputs the last sample that it popped from its FIFO. While not completely accurate, you could emulate this as the channel being muted. This will cause problems if a game frequently disables and re-enables its audio timer but that is extremely uncommon. (I wish I could say I’ve never seen it, but…Driver 2 Advance.)</p>
<p>I’ve never seen a game use timer 1 in cascading mode as an audio timer, but the hardware theoretically supports it. You could calculate the effective sample rate like so:</p>
<div><div>
<div><table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="python"><span><span><span>gba_clock</span> <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>24</span>
</span></span><span><span><span>gba_clock_divider</span> <span>=</span> <span>(</span><span>0x10000</span> <span>-</span> <span>timers</span><span>[</span><span>0</span><span>]</span><span>.</span><span>reload</span><span>)</span> <span>*</span> <span>timers</span><span>[</span><span>0</span><span>]</span><span>.</span><span>clock_divider</span> <span>*</span> <span>(</span><span>0x10000</span> <span>-</span> <span>timers</span><span>[</span><span>1</span><span>]</span><span>.</span><span>reload</span><span>)</span>
</span></span><span><span><span>sample_rate</span> <span>=</span> <span>gba_clock</span> <span>/</span> <span>gba_clock_divider</span>
</span></span></code></pre></td></tr></tbody></table></div>
</div>
</div><p>However, in my own implementation I just fall back to nearest neighbor resampling when a channel is tracking timer 1 in cascading mode (for that channel only, not for everything). I haven’t seen a game do this and I can’t think of a reason why a game would <em>want</em> to do this.</p>
<h2 id="resampling--mixing"><a href="#resampling--mixing"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"></path></svg></a><a href="#contents:resampling--mixing">Resampling &amp; Mixing</a></h2>
<p>Once you know each PCM channel’s source sample rate, you then need to resample from that to your output sample rate (e.g. 48000 Hz). You can ignore the PWM sampling frequency; if you’re not going for accurate emulation, there’s no reason to resample to the PWM sampling frequency as an intermediate step when you can resample directly to the output sample rate.</p>
<p>At this point this is no longer a GBA-specific problem, so you can plug in whatever resampling algorithm you want (or use a library), and then send it an input sample each time the PCM channel pops from its sample FIFO. I use my own resampling implementation so that I can control exactly how interpolation is performed. (Maybe a topic for a future post…)</p>
<p>You’ll need to separately resample the PSG channels down to your output sample rate. You <em>could</em> do nearest neighbor, which will sound somewhat similar to actual hardware, though not exactly the same since actual hardware nearest neighbor resamples to the PWM sampling frequency (usually 65536 Hz).</p>
<p>For higher quality PSG resampling you could do the same thing you can do in a GB/GBC emulator: sample all 4 PSG channels at 2097152 Hz (every 8 GBA CPU cycles), mix them at 2097152 Hz, then interpolate down from 2097152 Hz to your output sample rate. This works because every possible PSG channel frequency is an even divisor of 2097152 Hz, and due to how PSG audio generation works you can safely assume that samples are infinitely repeated in between sample changes. (That’s not <em>really</em> true in physical reality, but it’s true if you’re sampling at 2097152 Hz.) Whatever interpolation you perform will need to involve a <a href="https://en.wikipedia.org/wiki/Low-pass_filter" target="_blank" rel="noopener">low-pass filter</a> to avoid audio aliasing.</p>
<p>For final mixing, you probably want to leave everything as signed samples and completely ignore the GBA sound bias functionality. There’s also no reason to truncate the lowest bits as you’d do with accurate emulation, or even to round to the nearest integer; the resampling process will give you floating-point output samples, so you can just leave them that way and do floating-point mixing. If you want you can even scale the samples down to make clipping impossible (unlike on actual hardware), though that will make the audio output very quiet most of the time.</p>
<p>In my enhanced resampling implementation I support two different interpolation algorithms: 6-point cubic Hermite interpolation and windowed sinc interpolation.</p>
<p>Cubic Hermite is implemented exactly as described in <a href="https://jsgroth.dev/blog/posts/sega-cd-pcm-interpolation/">a previous post on Sega CD</a>, originally from <a href="https://yehar.com/blog/?p=197" target="_blank" rel="noopener">here</a>:</p>
<div><div>
<div><table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span><span>9
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="python"><span><span><span>def</span> <span>interpolate_cubic_hermite_6p</span><span>(</span><span>samples</span><span>,</span> <span>n</span><span>,</span> <span>x</span><span>):</span>
</span></span><span><span>    <span>[</span><span>ym2</span><span>,</span> <span>ym1</span><span>,</span> <span>y0</span><span>,</span> <span>y1</span><span>,</span> <span>y2</span><span>,</span> <span>y3</span><span>]</span> <span>=</span> <span>samples</span><span>[</span><span>n</span><span>-</span><span>2</span><span>:</span><span>n</span><span>+</span><span>4</span><span>]</span>
</span></span><span><span>
</span></span><span><span>    <span>c0</span> <span>=</span> <span>y0</span>
</span></span><span><span>    <span>c1</span> <span>=</span> <span>1</span><span>/</span><span>12</span> <span>*</span> <span>(</span><span>ym2</span> <span>-</span> <span>y2</span><span>)</span> <span>+</span> <span>2</span><span>/</span><span>3</span> <span>*</span> <span>(</span><span>y1</span> <span>-</span> <span>ym1</span><span>)</span>
</span></span><span><span>    <span>c2</span> <span>=</span> <span>5</span><span>/</span><span>4</span> <span>*</span> <span>ym1</span> <span>-</span> <span>7</span><span>/</span><span>3</span> <span>*</span> <span>y0</span> <span>+</span> <span>5</span><span>/</span><span>3</span> <span>*</span> <span>y1</span> <span>-</span> <span>1</span><span>/</span><span>2</span> <span>*</span> <span>y2</span> <span>+</span> <span>1</span><span>/</span><span>12</span> <span>*</span> <span>y3</span> <span>-</span> <span>1</span><span>/</span><span>6</span> <span>*</span> <span>ym2</span>
</span></span><span><span>    <span>c3</span> <span>=</span> <span>1</span><span>/</span><span>12</span> <span>*</span> <span>(</span><span>ym2</span> <span>-</span> <span>y3</span><span>)</span> <span>+</span> <span>7</span><span>/</span><span>12</span> <span>*</span> <span>(</span><span>y2</span> <span>-</span> <span>ym1</span><span>)</span> <span>+</span> <span>4</span><span>/</span><span>3</span> <span>*</span> <span>(</span><span>y0</span> <span>-</span> <span>y1</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>return</span> <span>((</span><span>c3</span> <span>*</span> <span>x</span> <span>+</span> <span>c2</span><span>)</span> <span>*</span> <span>x</span> <span>+</span> <span>c1</span><span>)</span> <span>*</span> <span>x</span> <span>+</span> <span>c0</span>
</span></span></code></pre></td></tr></tbody></table></div>
</div>
</div><p>This algorithm works pretty well for upsampling, where your output sample rate is higher than the source sample rate. This is almost always the case for the GBA PCM channels, with the notable exception of Golden Sun: The Lost Age with its exceptionally high 63072 Hz sample rate. It does  not work as well for downsampling unless you apply a low-pass filter to the source signal before interpolating; otherwise you’ll introduce some audio aliasing.</p>
<p>Sinc interpolation, or band-limited interpolation, is extremely high-quality but much more complex. Two approaches to implementing that:</p>
<ul>
<li><a href="https://ccrma.stanford.edu/~jos/resample/resample.html" target="_blank" rel="noopener">Digital Audio Resampling Home Page</a> (what I based my implementation on)</li>
<li><a href="https://slack.net/~ant/bl-synth/" target="_blank" rel="noopener">Band-Limited Sound Synthesis</a></li>
</ul>
<p>Note that with the low sample rates common on GBA, band-limited interpolation doesn’t necessarily produce a more pleasant sound than simpler interpolation algorithms! Yes, it’s time for some comparisons.</p>
<h2 id="examples"><a href="#examples"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"></path></svg></a><a href="#contents:examples">Examples</a></h2>
<p>First, Brinstar again, but this time also with a windowed sinc version - the example at the top used cubic Hermite. For reference, this game uses a sample rate of ~13379 Hz:</p>
<figure>
  <audio controls="" preload="metadata">
    <source src="/blog/audio/gba-audio-interpolation/mzm-brinstar.mp3" type="audio/mpeg"/>
  </audio>
</figure>

<p><span>Metroid: Zero Mission - Brinstar (Accurate resampling)</span></p><figure>
  <audio controls="" preload="metadata">
    <source src="/blog/audio/gba-audio-interpolation/mzm-brinstar-cubic.mp3" type="audio/mpeg"/>
  </audio>
</figure>

<p><span>Metroid: Zero Mission - Brinstar (Cubic Hermite interpolation)</span></p><figure>
  <audio controls="" preload="metadata">
    <source src="/blog/audio/gba-audio-interpolation/mzm-brinstar-sinc.mp3" type="audio/mpeg"/>
  </audio>
</figure>

<p><span>Metroid: Zero Mission - Brinstar (Windowed sinc interpolation)</span></p>
<p>The windowed sinc version sounds less aliased but <em>really</em> muffled. I personally prefer the sound of the cubic version.</p>
<p>In general, sinc interpolation does a much better job at eliminating audio aliasing and noise than cubic interpolation does, but the complete removal of wave frequencies above the source signal’s <a href="https://en.wikipedia.org/wiki/Nyquist_frequency" target="_blank" rel="noopener">Nyquist frequency</a> (~6689 Hz here) muffles the sound. This is technically more accurate as far as resampling the original 13379 Hz signal, but in this case at least I don’t think it sounds better.</p>
<p>Here’s another 13379 Hz example, this one from Fire Emblem: The Blazing Blade:</p>
<figure>
  <audio controls="" preload="metadata">
    <source src="/blog/audio/gba-audio-interpolation/fire-emblem-strike.mp3" type="audio/mpeg"/>
  </audio>
</figure>

<p><span>Fire Emblem - Strike (Accurate resampling)</span></p><figure>
  <audio controls="" preload="metadata">
    <source src="/blog/audio/gba-audio-interpolation/fire-emblem-strike-cubic.mp3" type="audio/mpeg"/>
  </audio>
</figure>

<p><span>Fire Emblem - Strike (Cubic Hermite interpolation)</span></p><figure>
  <audio controls="" preload="metadata">
    <source src="/blog/audio/gba-audio-interpolation/fire-emblem-strike-sinc.mp3" type="audio/mpeg"/>
  </audio>
</figure>

<p><span>Fire Emblem - Strike (Windowed sinc interpolation)</span></p>
<p>I also prefer the cubic version for this one, again because the sinc version sounds very muffled.</p>
<p>Windowed sinc doesn’t always sound like that though! Here’s a song from Mega Man Zero 4, sample rate ~21024 Hz:
</p><figure>
  <audio controls="" preload="metadata">
    <source src="/blog/audio/gba-audio-interpolation/mmz4-esperanto.mp3" type="audio/mpeg"/>
  </audio>
</figure>

<p><span>Mega Man Zero 4 - Esperanto (Accurate resampling)</span></p><figure>
  <audio controls="" preload="metadata">
    <source src="/blog/audio/gba-audio-interpolation/mmz4-esperanto-cubic.mp3" type="audio/mpeg"/>
  </audio>
</figure>

<p><span>Mega Man Zero 4 - Esperanto (Cubic Hermite interpolation)</span></p><figure>
  <audio controls="" preload="metadata">
    <source src="/blog/audio/gba-audio-interpolation/mmz4-esperanto-sinc.mp3" type="audio/mpeg"/>
  </audio>
</figure>

<p><span>Mega Man Zero 4 - Esperanto (Windowed sinc interpolation)</span></p>
<p>All three versions of this have noticeable static/hissing (thank you 8-bit sample quantization), but the windowed sinc version definitely has the least, and unlike the Metroid and Fire Emblem examples it doesn’t sound significantly more muffled than the cubic version.</p>
<p>Here’s an interesting example from Castlevania: Circle of the Moon, the aforementioned main menu music. It uses a PCM sample rate of 42048 Hz here but with the PWM sampling frequency set to 32768 Hz, which sounds fairly awful with accurate emulation:</p>
<figure>
  <audio controls="" preload="metadata">
    <source src="/blog/audio/gba-audio-interpolation/cotm-menu.mp3" type="audio/mpeg"/>
  </audio>
</figure>

<p><span>Castlevania: Circle of the Moon - Main Menu (Accurate resampling)</span></p><figure>
  <audio controls="" preload="metadata">
    <source src="/blog/audio/gba-audio-interpolation/cotm-menu-cubic.mp3" type="audio/mpeg"/>
  </audio>
</figure>

<p><span>Castlevania: Circle of the Moon - Main Menu (Cubic Hermite interpolation)</span></p><figure>
  <audio controls="" preload="metadata">
    <source src="/blog/audio/gba-audio-interpolation/cotm-menu-sinc.mp3" type="audio/mpeg"/>
  </audio>
</figure>

<p><span>Castlevania: Circle of the Moon - Main Menu (Windowed sinc interpolation)</span></p>
<p>(If you’ve played Rondo of Blood, yes, it’s the same song.)</p>
<p>Finally, an example from Golden Sun: The Lost Age with its crazy high 63072 Hz sample rate. This song has really noticeable audio noise despite the high sample rate and the game’s high-quality audio mixing code:</p>
<figure>
  <audio controls="" preload="metadata">
    <source src="/blog/audio/gba-audio-interpolation/tla-gloomy-caves.mp3" type="audio/mpeg"/>
  </audio>
</figure>

<p><span>Golden Sun: The Lost Age - Gloomy Caves (Accurate resampling)</span></p><figure>
  <audio controls="" preload="metadata">
    <source src="/blog/audio/gba-audio-interpolation/tla-gloomy-caves-cubic.mp3" type="audio/mpeg"/>
  </audio>
</figure>

<p><span>Golden Sun: The Lost Age - Gloomy Caves (Cubic Hermite interpolation)</span></p><figure>
  <audio controls="" preload="metadata">
    <source src="/blog/audio/gba-audio-interpolation/tla-gloomy-caves-sinc.mp3" type="audio/mpeg"/>
  </audio>
</figure>

<p><span>Golden Sun: The Lost Age - Gloomy Caves (Windowed sinc interpolation)</span></p>
<p>It’s not as noticeable as in the other examples, but sinc interpolation does remove some of the audio noise! Cubic interpolation doesn’t fare quite as well here, though the difference isn’t massive.</p>
<h2 id="the-psg-problem"><a href="#the-psg-problem"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"></path></svg></a><a href="#contents:the-psg-problem">The PSG Problem</a></h2>
<p>Here’s a song from Castlevania: Aria of Sorrow that uses both the PCM channels and the PSG channels:</p>
<figure>
  <audio controls="" preload="metadata">
    <source src="/blog/audio/gba-audio-interpolation/aos-corridor.mp3" type="audio/mpeg"/>
  </audio>
</figure>

<p><span>Castlevania: Aria of Sorrow - Castle Corridor (Accurate resampling)</span></p><figure>
  <audio controls="" preload="metadata">
    <source src="/blog/audio/gba-audio-interpolation/aos-corridor-cubic.mp3" type="audio/mpeg"/>
  </audio>
</figure>

<p><span>Castlevania: Aria of Sorrow - Castle Corridor (Cubic Hermite interpolation)</span></p><figure>
  <audio controls="" preload="metadata">
    <source src="/blog/audio/gba-audio-interpolation/aos-corridor-sinc.mp3" type="audio/mpeg"/>
  </audio>
</figure>

<p><span>Castlevania: Aria of Sorrow - Castle Corridor (Windowed sinc interpolation)</span></p>
<p>I picked out Aria of Sorrow here because it uses a PCM sample rate of ~10512 Hz, <em>very</em> low.</p>
<p>Higher-quality interpolation removes most of the high-frequency aliasing from the PCM channel output, but the PSG output still accurately contains high-frequency wave components. This makes the PSG channels stand out <em>much</em> more than they’re supposed to in music that uses both the PCM and PSG channels, particularly at low PCM sample rates.</p>
<p>One possible solution to this is to try removing the high-frequency waves from the PSG output, i.e. a low-pass filter.</p>
<p>Here’s what happens after applying a low-pass filter to all PSG output with a cutoff frequency of 5256 Hz, right at the <a href="https://en.wikipedia.org/wiki/Nyquist_frequency" target="_blank" rel="noopener">Nyquist frequency</a> of sample rate 10512 Hz:</p>
<figure>
  <audio controls="" preload="metadata">
    <source src="/blog/audio/gba-audio-interpolation/aos-corridor-cubic-lpf.mp3" type="audio/mpeg"/>
  </audio>
</figure>

<p><span>Castlevania: Aria of Sorrow - Castle Corridor (Cubic Hermite interpolation + PSG LPF)</span></p><figure>
  <audio controls="" preload="metadata">
    <source src="/blog/audio/gba-audio-interpolation/aos-corridor-sinc-lpf.mp3" type="audio/mpeg"/>
  </audio>
</figure>

<p><span>Castlevania: Aria of Sorrow - Castle Corridor (Windowed sinc interpolation + PSG LPF)</span></p>
<p>I think that sounds a lot better than not low-pass filtering the PSG, and better than bluntly reducing PSG volume relative to PCM (I tried that, didn’t work well). The windowed sinc version could maybe benefit from using a low-pass filter with either a lower cutoff frequency or a steeper post-cutoff attenuation slope, but it still sounds a lot better than the version with unfiltered PSG I think.</p>
<p>This doesn’t work quite as well when games do the reverse, with the PSG leading the music while the PCM channels play secondary instruments (this one is also 10512 Hz):</p>
<figure>
  <audio controls="" preload="metadata">
    <source src="/blog/audio/gba-audio-interpolation/mmbn2-title-all.mp3" type="audio/mpeg"/>
  </audio>
</figure>

<p><span>Mega Man Battle Network 2 - Title Screen (Accurate resampling)</span></p><figure>
  <audio controls="" preload="metadata">
    <source src="/blog/audio/gba-audio-interpolation/mmbn2-title-cubic.mp3" type="audio/mpeg"/>
  </audio>
</figure>

<p><span>Mega Man Battle Network 2 - Title Screen (Cubic Hermite interpolation)</span></p><figure>
  <audio controls="" preload="metadata">
    <source src="/blog/audio/gba-audio-interpolation/mmbn2-title-cubic-lpf.mp3" type="audio/mpeg"/>
  </audio>
</figure>

<p><span>Mega Man Battle Network 2 - Title Screen (Cubic Hermite interpolation + PSG LPF)</span></p>
<p>This particular song has an additional issue where higher-quality PSG resampling makes the noise channel sound much quieter than it does on actual hardware (because it’s playing at an ultrasonic frequency), but even aside from that, I don’t think the interpolated version sounds better here.</p>
<p>In my implementation I dynamically set the low-pass cutoff frequency to <code>(0.5 * pcm_sample_rate)</code>, designing a new 2nd-order <a href="https://en.wikipedia.org/wiki/Butterworth_filter" target="_blank" rel="noopener">Butterworth filter</a> each time the sample rate changes. This doesn’t do a perfect job, but it works well enough for the task of moderately attenuating high-frequency PSG output.</p>
<p>I apply the filter <em>after</em> resampling from 2097152 Hz to 48000 Hz, both because it attenuates much more sharply (a mere 2nd-order Butterworth filter does not work well at very high source frequencies) and because it’s significantly less computationally expensive.</p>
<h2 id="end"><a href="#end"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"></path></svg></a><a href="#contents:end">End</a></h2>
<p>I think this approach works pretty well for cleaning up GBA audio in real time, though the performance impact can be pretty significant (mainly because of the PSG downsampling). It can’t completely eliminate audio noise (static/hissing sound) due to still receiving noisy 8-bit samples as input, but it <em>significantly</em> reduces audio aliasing and it does still remove some noise.</p>

            </div></div>
  </body>
</html>
