<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/ortuman/nuke">Original</a>
    <h1>Nuke: A memory arena implementation for Go</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">A memory arena implementation for Go.</p>
<p dir="auto"><a href="https://goreportcard.com/report/github.com/ortuman/nuke" rel="nofollow"><img src="https://camo.githubusercontent.com/39f0625ff4f58762cd32c216af2fafb8c95e0c70dfc6ff3bc581facbba22c330/68747470733a2f2f676f7265706f7274636172642e636f6d2f62616467652f6769746875622e636f6d2f6f7274756d616e2f6e756b653f7374796c653d666c61742d737175617265" alt="Go Report Card" data-canonical-src="https://goreportcard.com/badge/github.com/ortuman/nuke?style=flat-square"/></a>
<a href="https://godoc.org/github.com/ortuman/nuke" rel="nofollow"><img src="https://camo.githubusercontent.com/56354c8a4f62bee8401431e1980683c9aec0c0a52517d53bd82d19cb3b07cd21/687474703a2f2f696d672e736869656c64732e696f2f62616467652f676f2d646f63756d656e746174696f6e2d626c75652e7376673f7374796c653d666c61742d737175617265" alt="Godoc" data-canonical-src="http://img.shields.io/badge/go-documentation-blue.svg?style=flat-square"/></a>
<a href="https://github.com/ortuman/nuke/releases"><img src="https://camo.githubusercontent.com/120cc9ca6a5b1157e71ecb9e32b1653310530509d7f19679762652f5af473fc6/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f72656c656173652f6f7274756d616e2f6e756b652f616c6c2e7376673f7374796c653d666c61742d737175617265" alt="Releases" data-canonical-src="https://img.shields.io/github/release/ortuman/nuke/all.svg?style=flat-square"/></a>
<a href="https://github.com/ortuman/nuke/blob/master/LICENSE"><img src="https://camo.githubusercontent.com/9b193fa0c1852075c0fb916e66657810e61792b6458921a832fdca6e18499a54/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6c6963656e73652f6f7274756d616e2f6e756b652e7376673f7374796c653d666c61742d737175617265" alt="LICENSE" data-canonical-src="https://img.shields.io/github/license/ortuman/nuke.svg?style=flat-square"/></a></p>
<p><a href="#">
      <img src="https://github.com/ortuman/nuke/raw/main/logo/logo-0.png"/>
    </a>
</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">But wait, what is a memory arena?</h2><a id="user-content-but-wait-what-is-a-memory-arena" aria-label="Permalink: But wait, what is a memory arena?" href="#but-wait-what-is-a-memory-arena"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">A memory arena is a method of memory management where a large block of memory is allocated at once and portions of it are used to satisfy allocation requests from the program. In the context of a garbage-collected language such as Go, the use of memory arenas can offer several advantages:</p>
<ul dir="auto">
<li>
<p dir="auto"><strong>Performance Improvement</strong>: By allocating memory in large blocks, memory arenas reduce the overhead associated with frequent calls to the system&#39;s memory allocator. This can lead to performance improvements, especially in applications that perform many small allocations.</p>
</li>
<li>
<p dir="auto"><strong>Enhanced Cache Locality</strong>: Memory arenas can also improve cache locality by allocating closely related objects within the same block of memory. This arrangement increases the likelihood that when one object is accessed, other related objects are already in the cache, thus reducing cache misses and enhancing overall application performance.</p>
</li>
<li>
<p dir="auto"><strong>Garbage Collection Efficiency</strong>: Using memory arenas can reduce the workload on the garbage collector by decreasing the number of objects that need to be tracked and collected, leading to less pause time and more predictable performance.</p>
</li>
</ul>
<p dir="auto">However, while memory arenas offer these advantages, they are not a silver bullet and come with trade-offs, such as potentially increased memory usage due to unused space within the allocated blocks. Careful consideration and profiling are necessary to determine whether using a memory arena is beneficial for a particular application.</p>


<div dir="auto" data-snippet-clipboard-copy-content="go get -u github.com/ortuman/nuke"><pre>go get -u github.com/ortuman/nuke</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="package main

import (
	&#34;github.com/ortuman/nuke&#34;
)

type Foo struct { A int }

func main() {
	// Initialize a new memory arena with a slab size of 256KB 
	// and a max memory size of 20MB.
	arena := nuke.NewSlabArena(256*1024, 20*1024*1024)
	
	// Allocate a new object of type Foo.
	fooRef := nuke.New[Foo](arena)
	
	// Allocate a Foo slice with a capacity of 10 elements.
	fooSlice := nuke.MakeSlice[Foo](arena, 0, 10)
	
	// Append 20 elements to the slice allocating 
	// the required extra memory from the arena.
	for i := 0; i &lt; 20; i++ {
            fooSlice = nuke.SliceAppend(arena, fooSlice, Foo{A: i})
	}
	
	// ...

	// When done, reset the arena (releasing slab buffer memory).
	arena.Reset(true)
	
	// From here on, any arena reference is invalid.
	// ...
}"><pre><span>package</span> main

<span>import</span> (
	<span>&#34;github.com/ortuman/nuke&#34;</span>
)

<span>type</span> <span>Foo</span> <span>struct</span> { <span>A</span> <span>int</span> }

<span>func</span> <span>main</span>() {
	<span>// Initialize a new memory arena with a slab size of 256KB </span>
	<span>// and a max memory size of 20MB.</span>
	<span>arena</span> <span>:=</span> <span>nuke</span>.<span>NewSlabArena</span>(<span>256</span><span>*</span><span>1024</span>, <span>20</span><span>*</span><span>1024</span><span>*</span><span>1024</span>)
	
	<span>// Allocate a new object of type Foo.</span>
	<span>fooRef</span> <span>:=</span> <span>nuke</span>.<span>New</span>[<span>Foo</span>](<span>arena</span>)
	
	<span>// Allocate a Foo slice with a capacity of 10 elements.</span>
	<span>fooSlice</span> <span>:=</span> <span>nuke</span>.<span>MakeSlice</span>[<span>Foo</span>](<span>arena</span>, <span>0</span>, <span>10</span>)
	
	<span>// Append 20 elements to the slice allocating </span>
	<span>// the required extra memory from the arena.</span>
	<span>for</span> <span>i</span> <span>:=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>20</span>; <span>i</span><span>++</span> {
            <span>fooSlice</span> <span>=</span> <span>nuke</span>.<span>SliceAppend</span>(<span>arena</span>, <span>fooSlice</span>, <span>Foo</span>{<span>A</span>: <span>i</span>})
	}
	
	<span>// ...</span>

	<span>// When done, reset the arena (releasing slab buffer memory).</span>
	<span>arena</span>.<span>Reset</span>(<span>true</span>)
	
	<span>// From here on, any arena reference is invalid.</span>
	<span>// ...</span>
}</pre></div>
<p dir="auto">Additionally, we can inject a memory arena as part of a context, with the purpose of being used throughout the lifecycle of certain operations, such as an HTTP request.</p>
<div dir="auto" data-snippet-clipboard-copy-content="func httpHandler(w http.ResponseWriter, r *http.Request) {
    // Inject memory arena into request context.
    arena := nuke.NewSlabArena(64*1024, 1024*1024)
    defer arena.Reset(true)
	
    ctx := nuke.InjectContextArena(r.Context(), arena)
    processRequest(ctx)
    
    // ...
}

func processRequest(ctx context.Context) {
    // Get the memory arena from the context.
    arena := nuke.ExtractContextArena(ctx)
	
    // ...
}

func main() {
    http.HandleFunc(&#34;/&#34;, httpHandler) // Set the handler for the &#34;/&#34; route
    fmt.Println(&#34;Server is listening on port 8080...&#34;)
    http.ListenAndServe(&#34;:8080&#34;, nil) // Listen on port 8080
}"><pre><span>func</span> <span>httpHandler</span>(<span>w</span> http.<span>ResponseWriter</span>, <span>r</span> <span>*</span>http.<span>Request</span>) {
    <span>// Inject memory arena into request context.</span>
    <span>arena</span> <span>:=</span> <span>nuke</span>.<span>NewSlabArena</span>(<span>64</span><span>*</span><span>1024</span>, <span>1024</span><span>*</span><span>1024</span>)
    <span>defer</span> <span>arena</span>.<span>Reset</span>(<span>true</span>)
	
    <span>ctx</span> <span>:=</span> <span>nuke</span>.<span>InjectContextArena</span>(<span>r</span>.<span>Context</span>(), <span>arena</span>)
    <span>processRequest</span>(<span>ctx</span>)
    
    <span>// ...</span>
}

<span>func</span> <span>processRequest</span>(<span>ctx</span> context.<span>Context</span>) {
    <span>// Get the memory arena from the context.</span>
    <span>arena</span> <span>:=</span> <span>nuke</span>.<span>ExtractContextArena</span>(<span>ctx</span>)
	
    <span>// ...</span>
}

<span>func</span> <span>main</span>() {
    <span>http</span>.<span>HandleFunc</span>(<span>&#34;/&#34;</span>, <span>httpHandler</span>) <span>// Set the handler for the &#34;/&#34; route</span>
    <span>fmt</span>.<span>Println</span>(<span>&#34;Server is listening on port 8080...&#34;</span>)
    <span>http</span>.<span>ListenAndServe</span>(<span>&#34;:8080&#34;</span>, <span>nil</span>) <span>// Listen on port 8080</span>
}</pre></div>

<p dir="auto">By default, the arena implementation is not concurrent-safe, meaning it is not safe to access it concurrently from different goroutines. If the specific use case requires concurrent access, the library provides the <code>NewConcurrentArena</code> function, to which a base arena is passed and it returns a new instance that can be accessed concurrently.</p>
<div dir="auto" data-snippet-clipboard-copy-content="package main

import (
	&#34;github.com/ortuman/nuke&#34;
)

func main() {
	arena := nuke.NewConcurrentArena(
            nuke.NewSlabArena(256*1024, 20*1024*1024),
        )
	defer arena.Reset(true)
	
	// From here on, the arena can be safely accessed concurrently.
	// ...
}"><pre><span>package</span> main

<span>import</span> (
	<span>&#34;github.com/ortuman/nuke&#34;</span>
)

<span>func</span> <span>main</span>() {
	<span>arena</span> <span>:=</span> <span>nuke</span>.<span>NewConcurrentArena</span>(
            <span>nuke</span>.<span>NewSlabArena</span>(<span>256</span><span>*</span><span>1024</span>, <span>20</span><span>*</span><span>1024</span><span>*</span><span>1024</span>),
        )
	<span>defer</span> <span>arena</span>.<span>Reset</span>(<span>true</span>)
	
	<span>// From here on, the arena can be safely accessed concurrently.</span>
	<span>// ...</span>
}</pre></div>

<p dir="auto">Below is a comparative table with the different benchmark results.</p>
<div data-snippet-clipboard-copy-content="BenchmarkRuntimeNewObject/100-8           	         1394955	     846.6 ns/op	     800 B/op	     100 allocs/op
BenchmarkRuntimeNewObject/1000-8          	          143031	      8357 ns/op	    8000 B/op	    1000 allocs/op
BenchmarkRuntimeNewObject/10000-8         	           14371	     83562 ns/op	   80000 B/op	   10000 allocs/op
BenchmarkRuntimeNewObject/100000-8        	            1428	    835474 ns/op	  800005 B/op	  100000 allocs/op
BenchmarkSlabArenaNewObject/100-8         	          124495	     15469 ns/op	       0 B/op	       0 allocs/op
BenchmarkSlabArenaNewObject/1000-8        	           76744	     19602 ns/op	       0 B/op	       0 allocs/op
BenchmarkSlabArenaNewObject/10000-8       	           24104	     50845 ns/op	       0 B/op	       0 allocs/op
BenchmarkSlabArenaNewObject/100000-8      	            3282	    366044 ns/op	       0 B/op	       0 allocs/op
BenchmarkConcurrentSlabArenaNewObject/100-8         	   90392	     16679 ns/op	       0 B/op	       0 allocs/op
BenchmarkConcurrentSlabArenaNewObject/1000-8        	   43753	     29823 ns/op	       0 B/op	       0 allocs/op
BenchmarkConcurrentSlabArenaNewObject/10000-8       	    8037	    149923 ns/op	       0 B/op	       0 allocs/op
BenchmarkConcurrentSlabArenaNewObject/100000-8      	     879	   1364377 ns/op	       0 B/op	       0 allocs/op
BenchmarkRuntimeMakeSlice/100-8                     	   58166	     19684 ns/op	  204800 B/op	     100 allocs/op
BenchmarkRuntimeMakeSlice/1000-8                    	    5916	    196412 ns/op	 2048010 B/op	    1000 allocs/op
BenchmarkRuntimeMakeSlice/10000-8                   	     600	   1965622 ns/op	20480106 B/op	   10001 allocs/op
BenchmarkRuntimeMakeSlice/100000-8                  	      60	  19664140 ns/op	204801155 B/op	  100012 allocs/op
BenchmarkSlabArenaMakeSlice/100-8                   	  166300	     14520 ns/op	       0 B/op	       0 allocs/op
BenchmarkSlabArenaMakeSlice/1000-8                  	   43785	     36938 ns/op	       0 B/op	       0 allocs/op
BenchmarkSlabArenaMakeSlice/10000-8                 	    2707	    427398 ns/op	       0 B/op	       0 allocs/op
BenchmarkSlabArenaMakeSlice/100000-8                	      87	  14048963 ns/op	70582284 B/op	   34464 allocs/op
BenchmarkConcurrentSlabArenaMakeSlice/100-8         	   91959	     17944 ns/op	       0 B/op	       0 allocs/op
BenchmarkConcurrentSlabArenaMakeSlice/1000-8        	   27384	     42790 ns/op	       0 B/op	       0 allocs/op
BenchmarkConcurrentSlabArenaMakeSlice/10000-8       	    2406	    480474 ns/op	       0 B/op	       0 allocs/op
BenchmarkConcurrentSlabArenaMakeSlice/100000-8      	      84	  14702775 ns/op	70582280 B/op	   34464 allocs/op"><pre><code>BenchmarkRuntimeNewObject/100-8           	         1394955	     846.6 ns/op	     800 B/op	     100 allocs/op
BenchmarkRuntimeNewObject/1000-8          	          143031	      8357 ns/op	    8000 B/op	    1000 allocs/op
BenchmarkRuntimeNewObject/10000-8         	           14371	     83562 ns/op	   80000 B/op	   10000 allocs/op
BenchmarkRuntimeNewObject/100000-8        	            1428	    835474 ns/op	  800005 B/op	  100000 allocs/op
BenchmarkSlabArenaNewObject/100-8         	          124495	     15469 ns/op	       0 B/op	       0 allocs/op
BenchmarkSlabArenaNewObject/1000-8        	           76744	     19602 ns/op	       0 B/op	       0 allocs/op
BenchmarkSlabArenaNewObject/10000-8       	           24104	     50845 ns/op	       0 B/op	       0 allocs/op
BenchmarkSlabArenaNewObject/100000-8      	            3282	    366044 ns/op	       0 B/op	       0 allocs/op
BenchmarkConcurrentSlabArenaNewObject/100-8         	   90392	     16679 ns/op	       0 B/op	       0 allocs/op
BenchmarkConcurrentSlabArenaNewObject/1000-8        	   43753	     29823 ns/op	       0 B/op	       0 allocs/op
BenchmarkConcurrentSlabArenaNewObject/10000-8       	    8037	    149923 ns/op	       0 B/op	       0 allocs/op
BenchmarkConcurrentSlabArenaNewObject/100000-8      	     879	   1364377 ns/op	       0 B/op	       0 allocs/op
BenchmarkRuntimeMakeSlice/100-8                     	   58166	     19684 ns/op	  204800 B/op	     100 allocs/op
BenchmarkRuntimeMakeSlice/1000-8                    	    5916	    196412 ns/op	 2048010 B/op	    1000 allocs/op
BenchmarkRuntimeMakeSlice/10000-8                   	     600	   1965622 ns/op	20480106 B/op	   10001 allocs/op
BenchmarkRuntimeMakeSlice/100000-8                  	      60	  19664140 ns/op	204801155 B/op	  100012 allocs/op
BenchmarkSlabArenaMakeSlice/100-8                   	  166300	     14520 ns/op	       0 B/op	       0 allocs/op
BenchmarkSlabArenaMakeSlice/1000-8                  	   43785	     36938 ns/op	       0 B/op	       0 allocs/op
BenchmarkSlabArenaMakeSlice/10000-8                 	    2707	    427398 ns/op	       0 B/op	       0 allocs/op
BenchmarkSlabArenaMakeSlice/100000-8                	      87	  14048963 ns/op	70582284 B/op	   34464 allocs/op
BenchmarkConcurrentSlabArenaMakeSlice/100-8         	   91959	     17944 ns/op	       0 B/op	       0 allocs/op
BenchmarkConcurrentSlabArenaMakeSlice/1000-8        	   27384	     42790 ns/op	       0 B/op	       0 allocs/op
BenchmarkConcurrentSlabArenaMakeSlice/10000-8       	    2406	    480474 ns/op	       0 B/op	       0 allocs/op
BenchmarkConcurrentSlabArenaMakeSlice/100000-8      	      84	  14702775 ns/op	70582280 B/op	   34464 allocs/op
</code></pre></div>

<p dir="auto">Contributions from the community are welcome! If you&#39;d like to contribute, please fork the repository, make your changes, and submit a pull request.</p>

<p dir="auto">If you have any questions, feedback or suggestions, please feel free to contact me at <a href="mailto:ortuman@gmail.com">ortuman@gmail.com</a>. I&#39;m always open to feedback and would love to hear from you!</p>

<p dir="auto">This project is licensed under the terms of the Apache-2.0 license.</p>
</article></div></div>
  </body>
</html>
