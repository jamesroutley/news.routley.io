<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.downtowndougbrown.com/2024/06/upgrading-my-chumby-8-kernel-part-10-rtc/">Original</a>
    <h1>Upgrading my Chumby 8 kernel part 10: RTC</h1>
    
    <div id="readability-page-1" class="page"><div>
				
<p>I’m going to start this post off with the obligatory list of links to the previous parts in the series if you’re new here and are interested in seeing the full story: <a href="https://www.downtowndougbrown.com/2022/12/upgrading-my-old-chumby-8-linux-kernel-part-1-u-boot/" data-type="post" data-id="2063" target="_blank" rel="noreferrer noopener">1</a>, <a href="https://www.downtowndougbrown.com/2022/12/upgrading-my-chumby-8-kernel-part-2-initial-linux-boot/" data-type="post" data-id="2200" target="_blank" rel="noreferrer noopener">2</a>, <a href="https://www.downtowndougbrown.com/2023/01/upgrading-my-chumby-8-kernel-part-3-wi-fi/" data-type="post" data-id="2265" target="_blank" rel="noreferrer noopener">3</a>, <a href="https://www.downtowndougbrown.com/2023/03/upgrading-my-chumby-8-kernel-part-4-reboot-poweroff/" data-type="post" data-id="2751" target="_blank" rel="noreferrer noopener">4</a>, <a href="https://www.downtowndougbrown.com/2023/06/upgrading-my-chumby-8-kernel-part-5-graphics/" data-type="post" data-id="3156" target="_blank" rel="noreferrer noopener">5</a>, <a href="https://www.downtowndougbrown.com/2023/08/upgrading-my-chumby-8-kernel-part-6-pwm-backlight/" data-type="post" data-id="3360" target="_blank" rel="noreferrer noopener">6</a>, <a href="https://www.downtowndougbrown.com/2023/11/upgrading-my-chumby-8-kernel-part-7-touchscreen/" data-type="post" data-id="3564" target="_blank" rel="noreferrer noopener">7</a>, <a href="https://www.downtowndougbrown.com/2024/04/upgrading-my-chumby-8-kernel-part-8-audio/" data-type="post" data-id="4911" target="_blank" rel="noreferrer noopener">8</a>, and <a href="https://www.downtowndougbrown.com/2024/04/why-is-my-cpu-usage-always-100-upgrading-my-chumby-8-kernel-part-9/" data-type="post" data-id="5170" target="_blank" rel="noreferrer noopener">9</a>. This is the tale of how I upgraded my Chumby 8 to run a modern Linux kernel.</p>



<p>I only had some minor things on my list to figure out before I could call my kernel upgrade good enough to be finished. The most important remaining thing was the real-time clock, or RTC. I noticed that whenever I rebooted the Chumby, it always started out with the date set to the Unix epoch in 1970:</p>



<pre># date</pre>



<p>I had observed earlier that the <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm/boot/dts/marvell/pxa168.dtsi?h=v6.8" target="_blank" rel="noreferrer noopener">default pxa168.dtsi file in the kernel</a> had an RTC already added, but it was disabled:</p>



<pre>rtc: rtc@d4010000 {</pre>



<p>Would it really be this simple? Did I just need to enable the RTC in my device tree file, make sure the kernel driver was enabled, and then be done with it? I had already experienced similar success with other PXA168 peripherals. So I tried it out.</p>



<pre>&amp;rtc {</pre>



<p>I also had to set CONFIG_RTC_DRV_SA1100=y. Why that driver? I don’t see SA1100 mentioned anywhere in the blurb above. Well, it’s because that’s the driver that <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/rtc/rtc-sa1100.c#n333" target="_blank" rel="noreferrer noopener">contains the device tree compatible string for mrvl,mmp-rtc</a>:</p>


<div><pre title="">#ifdef CONFIG_OF
static const struct of_device_id sa1100_rtc_dt_ids[] = {
        { .compatible = &#34;mrvl,sa1100-rtc&#34;, },
        { .compatible = &#34;mrvl,mmp-rtc&#34;, },
        {}
};
MODULE_DEVICE_TABLE(of, sa1100_rtc_dt_ids);
#endif
</pre></div>


<p>The <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/rtc/Kconfig#n1458" target="_blank" rel="noreferrer noopener">Kconfig file mentions a few PXAxxx variants</a> in conjunction with this driver. It doesn’t specifically mention the PXA168, but it’s the exact same peripheral.</p>



<p>Anyway, with these changes made, I made sure a good battery was installed, and then powered my Chumby up using the new kernel. During the boot process, an RTC was detected which also seemed to have its date set to the Unix epoch, and it set the system clock:</p>



<pre>sa1100-rtc d4010000.rtc: registered as rtc0</pre>



<p>This was fairly promising, right? I already had a good amount of experience dealing with RTCs in Linux, so I understood what would be involved in testing them. First of all, the message “setting system clock to…” above meant it was reading that 1970-01-01 date from the RTC. That’s because I had CONFIG_RTC_HCTOSYS=y. If you have your kernel configured that way, it’ll automatically attempt to set the system date and time from the RTC date and time at startup. Clearly the RTC didn’t have a good date written in it, which makes sense because I had just put in a good battery.</p>



<p>I wrote a random date into the RTC for testing. First I set the date on my RTC, and then I used hwclock to write it:</p>



<pre># date -s &#39;2022-09-22&#39;</pre>



<p>Then I read back the RTC to see if all was good:</p>



<pre># hwclock</pre>



<p>Hooray! The RTC driver definitely seemed to be working. It was writing a date into the RTC, and then after writing it, it was able to read it back out. It was even advancing properly — I had read back the date 41 seconds after writing it in.</p>



<p>“That was easy,” I confidently said to myself as I rebooted once more to see if the changes stuck. I brushed off my shoulders, proud of a job well done. I already knew it was going to work perfectly. Testing it was just going to be a formality. The following text popped up on the screen as the kernel came back up:</p>



<pre>sa1100-rtc d4010000.rtc: registered as rtc0</pre>



<p>What the heck? I had successfully written to the RTC, but it was right back to thinking it was 1970. Not that I had any reason to doubt the console text I saw above, but using hwclock I confirmed that the date in the RTC had definitely reset:</p>



<pre># hwclock</pre>



<p>I double- and triple-checked that the battery I had inserted was good. Basically the RTC was working fine when the system was powered, but even the act of rebooting was enough to make it forget the date. I would expect that an RTC should also remember the date/time when the system is powered off. Obviously that wasn’t going to work if a reboot didn’t even preserve the date. So much for testing just being a formality. That’s what I get for being overconfident! Back to the schematics I went.</p>



<p>When I looked at the schematics, I realized I should have started there. I should have followed my own advice that I had followed on other parts of this series like the audio support. I had made a terrible assumption. My assumption had been that the Chumby 8 actually used the PXA168’s internal RTC. That turned out to be very incorrect.</p>



<p>I can’t thank Chumby enough for making the <a href="https://files.chumby.com/hdwedocs/silvermoon_OEM_ref_v3.pdf" target="_blank" rel="noreferrer noopener">schematics for the Chumby 8</a> available to the public. It really saved my bacon on this project. I’m sure I could have figured out a lot of this stuff without it, but having the schematics readily available really saved me a lot of time.</p>



<p>It turns out that the coin cell battery on the Chumby 8 doesn’t go to the main processor at all. In fact, further reading about the PXA16x’s built-in RTC seems to reveal that it’s basically useless. The <a href="https://web.archive.org/web/20160428154454/http://www.marvell.com/application-processors/armada-100/assets/armada_16x_software_manual.pdf" target="_blank" rel="noreferrer noopener">Armada 16x software manual</a> points out that in hibernate mode, it stops counting (page 220). If that’s the case, I would also expect it to stop counting when it’s powered off. I don’t see any pins labeled VRTC or VBAT in Marvell’s pinout, which I would expect to see for hooking up a battery. I did see a note in the <a href="https://web.archive.org/web/20150927154817/http://www.marvell.com/application-processors/armada-100/assets/Armada-16x-HW-Manual-RevA.pdf" target="_blank" rel="noreferrer noopener">hardware manual</a>‘s version history (page 16) saying “Added note that the RTC has no external hardware connection” though. That’s a funny way of saying “the RTC built into this SoC is useless.”</p>



<p>What Chumby did instead was use the battery to power the STM32F101 “cryptoprocessor” that I’ve mentioned in the past:</p>



<figure><img fetchpriority="high" decoding="async" width="285" height="254" src="https://www.downtowndougbrown.com/wp-content/uploads/2024/04/image.png" alt=""/></figure>



<p>This was the circuit I had expected to see going to the PXA168. But thinking about it further, it makes a ton of sense. This solution is so much more flexible than a conventional RTC. The STM32 always being on would have allowed Chumby to implement all kinds of other fun stuff like automatic scheduled powerups. I guess a lot of normal RTCs have alarms that can do stuff like that too, but it seems like you end up with ultimate flexibility by going this route. Either way, it appears Chumby had no choice anyway, since the PXA168’s RTC doesn’t have a battery power input. If I’m wrong about this, I’d love to be corrected!</p>



<p>I had slowly gained more familiarity with the Chumby’s boot process during this project, so I started looking into the original boot scripts to see if I could find something about setting the date. I knew that the original Chumby firmware would remember the date between power cycles, so I just had to figure out where it was handled. I didn’t see anything related to the RTC in the actual kernel source, so I suspected it was handled in userspace.</p>



<p>I went back to a backup of my original SD card containing Chumby’s stock firmware. There are two rootfs partitions and then a third partition which ends up being mounted as /mnt/storage. I looked through the boot scripts in /etc/init.d. rcS.background in particular contained a lot of interesting info, including this relevant chunk:</p>


<div><pre title=""># Attempt to restore time based on the crypto processor&#39;s uptime counter
echo &#34;Attempting to restore time from CP&#34;
message_start &#34;Restore time from CP&#34;
restore_time
echo &#34;Date is $(date)&#34;
message_end &#34;$(date)&#34;
</pre></div>


<p>This comment revealed some interesting info. It confirmed that the STM32 is responsible for remembering the date. It also told me that I would be looking for an uptime counter. So the STM32 wouldn’t be directly tracking the date and time; it would just be keeping track of how long it had been powered on. Remember that the battery keeps it powered even when the Chumby itself is off.</p>



<p>I found restore_time as a perl script in /usr/chumby/scripts. What it does is actually pretty simple. It reads the uptime (in seconds) from the cryptoprocessor using /usr/chumby/scripts/cpi.sh, and also reads a couple of local files: /psp/cp_offset and /psp/cp_time. cp_offset contains the time that the cryptoprocessor booted up as a Unix epoch. cp_time contains the uptime in seconds that the cryptoprocessor reported the last time we checked.</p>



<p>If the cryptoprocessor’s current uptime is less than the content of cp_time, then that means it has lost power since the last time we looked at it, and thus we don’t know what time it is. Otherwise, it adds cp_offset to the newly determined uptime, and that is the actual time it sets the system to using the “date” command.</p>



<p>cpi.sh is simply a wrapper that calls the /usr/bin/cpi utility and retries if it fails for whatever reason. It talks to the STM32 through a UART, using the same communication channel I discussed in <a href="https://www.downtowndougbrown.com/2023/03/upgrading-my-chumby-8-kernel-part-4-reboot-poweroff/" data-type="post" data-id="2751" target="_blank" rel="noreferrer noopener">part 4</a> when I got poweroff and reboot working. The UART is totally free during normal operation so that a userspace utility like cpi can use it. The reboot and poweroff functions will take over control of the UART only when they are invoked.</p>



<p>I also found a perl script next to restore_time called save_time. It writes out the cp_offset and cp_time files. It’s called by /usr/chumby/scripts/sync_time.sh, which is a script that first syncs up with an NTP server to get the actual date and time, and then runs save_time so it’ll be ready if the Chumby is later powered off or rebooted. This sync_time.sh script is called in a few different places, including when the network comes up.</p>



<p>So that’s how the Chumby manages its “RTC” if you want to call it that. It’s basically just a software RTC emulated by keeping track of the uptime of the STM32. Here’s a block diagram of the setup.</p>



<figure><img decoding="async" width="581" height="202" src="https://www.downtowndougbrown.com/wp-content/uploads/2024/06/image.png" alt="" srcset="https://www.downtowndougbrown.com/wp-content/uploads/2024/06/image.png 581w, https://www.downtowndougbrown.com/wp-content/uploads/2024/06/image-300x104.png 300w" sizes="(max-width: 581px) 100vw, 581px"/></figure>



<p>I actually like this solution a lot! It doesn’t require any special kernel logic. It’s entirely implemented in userspace. No special kernel drivers are involved whatsoever. This is a concept that I’ve come to appreciate as I’ve gained more Linux experience through the years. If you can solve a problem in userspace, why bother force-fitting it into the kernel? Chumby probably could have figured out a way to make the STM32 show up as an actual /dev/rtc0 device…but what would the advantage have been over the scripts they wrote? None. It would have been needless overcomplication. Overall, I think the userspace solution they settled on is excellent.</p>



<p>How could I make use of this with my modern setup? I knew I could easily make scripts just like the stock Chumby ones assuming I could somehow access the cryptoprocessor’s uptime counter. Luckily, I found that Chumby’s cpi utility that originally ran in Linux 2.6.28 using a much older glibc still worked fine in my newer environment. I even found the <a href="https://github.com/sutajiokousagi/cpi" target="_blank" rel="noreferrer noopener">source code</a> and <a href="https://github.com/sutajiokousagi/cpi/tree/master/export/arm-linux-silvermoon/bin" target="_blank" rel="noreferrer noopener">binaries</a> for it on GitHub, so if the binary hadn’t worked for whatever reason, I likely could have rebuilt it instead. The GitHub cpi binary wasn’t exactly the same as the original cpi binary I had found on my Chumby’s SD card, but out of convenience I opted to use it. It worked just as well. I <a href="https://github.com/dougg3/buildroot/commit/3ad6c9352443754dcf88deb92af7085f7c6c07d8" target="_blank" rel="noreferrer noopener">added it as a package in my custom buildroot</a>. Then <a href="https://github.com/dougg3/buildroot/commit/a51cd215fcd3272bd879ce9bae9151439e0a184e" target="_blank" rel="noreferrer noopener">I wrote some scripts</a> for saving/restoring the date and time. They were very similar to what I found in my Chumby’s rootfs, but they were written as shell scripts instead of perl.</p>



<p>After I <a href="https://github.com/dougg3/buildroot/commit/6ce5a7e24d42c14f279332e5a6cf1ca5c8c9ef77" target="_blank" rel="noreferrer noopener">enabled NTP</a> to keep the time synced up using time servers on the internet, I <a href="https://github.com/dougg3/buildroot/commit/4e5e53e46547739512129974a85eaa977df14ba3" target="_blank" rel="noreferrer noopener">wrote a simple daemon</a> that automatically restores the date and time at startup, saves it after NTP has successfully synced up, and then re-saves every 24 hours from that point on just to make sure everything is happy.</p>



<p>Originally I was saving these files directly to the rootfs but I eventually opted to <a href="https://github.com/dougg3/buildroot/commit/5bcb56c3e380db9d8afe7e592840d2d4dcd1c285" target="_blank" rel="noreferrer noopener">make a separate settings partition on the SD card</a> to use for <a href="https://github.com/dougg3/buildroot/commit/bc2d45a5327fadba91e9901a3676ec912d7b6185" target="_blank" rel="noreferrer noopener">storing settings like this</a> instead. I like to keep the rootfs read-only if I can.</p>



<p>With the solution I described above fully implemented, now when I boot, I can immediately log in and run the date command, and it looks perfect:</p>



<pre>Welcome to Buildroot</pre>



<p>Overall, the whole process of getting the “RTC” working properly went pretty well! When I originally discovered the PXA16x’s built-in peripheral wasn’t going to work, the first thing that popped into my head was “oh no, here we go again” but the solution still ended up being pretty simple. Kudos to the original Chumby developers for coming up with a nice solution for saving the date and time. I didn’t have to jump down into any crazy kernel rabbit holes this time.</p>



<p>This project is definitely starting to wind down now, but there’s still more to come. In the next post, I want to talk a little bit about the SD/CF/MS card reader that’s built into the Chumby and how I got it working as closely as possible to the original firmware’s approach.</p>
			  
			</div></div>
  </body>
</html>
