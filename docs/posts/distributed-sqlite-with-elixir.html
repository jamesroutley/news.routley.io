<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://silbernagel.dev/posts/distributed-sqlite-with-elixir">Original</a>
    <h1>Distributed SQLite with Elixir</h1>
    
    <div id="readability-page-1" class="page"><article>
      <p>
I recently read about <a href="https://litestream.io/">litestream</a> and wanted to try this on <a href="https://fly.io">Fly</a> with <a href="https://elixir-lang.org/">Elixir</a>.</p>
<p>
<a href="https://litestream.io/">Litestream</a> allows us to backup our SQLite database to any S3 compatible storage after every transaction. It will also restore from that backup. Meaning that anytime we scale our app on Fly, we can restore the latest version of the database.</p>
<h2>
Why</h2>
<ul>
  <li>
<strong>fast</strong> data access  </li>
  <li>
<strong>simple</strong> local development  </li>
  <li>
<strong>low</strong> maintenance  </li>
  <li>
Elixir makes it all possible via it’s distribution capabilities  </li>
</ul>
<h2>
Getting Started</h2>
<p>
See the <a href="https://github.com/silbermm/distributed_sqlite">companion repo</a> for reference.</p>
<p>
Create a new phoenix app that uses <a href="https://github.com/elixir-sqlite/ecto_sqlite3">SQLite3</a> as the database:</p>
<pre><code>$ mix phx.new distributed_sqlite --database sqlite3</code></pre>
<p>
Launch a new fly application:</p>
<pre><code>$ fly launch</code></pre>
<ul>
  <li>
type in an app name (or just take the default)  </li>
  <li>
choose any region you like  </li>
  <li>
choose <strong>N</strong> when asked if you want a Postgres database  </li>
  <li>
choose <strong>N</strong> when asked if you want a Redis instance  </li>
  <li>
choose <strong>N</strong> to deploy now  </li>
</ul>
<p>
An environment varilable <code>DATABASE_PATH</code> is needed to indicate which file to use for the SQLite database. Open the <code>fly.toml</code> file and add <code>DATABASE_PATH = /app/distributed_sqlite.db</code> (use any database name you want here) under the <code>[env]</code> section and try to deploy.</p>
<pre><code>$ flyctl deploy</code></pre>
<p>
Success! A Phoenix app running on Fly using SQLite! Now, to see it in action.</p>
<h2>
Counter Data Model</h2>
<p>
Lets build a simple, naive counter that just counts the views of each page.</p>
<pre><code>$ mix phx.gen.schema Counter.PageCount page_counts page:string count:integer
$ mix ecto.migrate</code></pre>
<p>
Add a <code>Counter</code> module where we can add page view counts</p>
<pre><code><span># lib/distributed_sqlite/counter.ex</span><span>
</span><span>defmodule</span><span> </span><span>DistributedSqlite.Counter</span><span> </span><span data-group-id="6111647571-1">do</span><span>
  </span><span>alias</span><span> </span><span>DistributedSqlite.Counter.PageCount</span><span>
  </span><span>alias</span><span> </span><span>DistributedSqlite.Repo</span><span>

  </span><span>def</span><span> </span><span>count_page_view</span><span data-group-id="6111647571-2">(</span><span>page_name</span><span data-group-id="6111647571-2">)</span><span> </span><span data-group-id="6111647571-3">do</span><span>
    </span><span>page_count</span><span> </span><span>=</span><span> </span><span>Repo</span><span>.</span><span>get_by</span><span data-group-id="6111647571-4">(</span><span>PageCount</span><span>,</span><span> </span><span>page</span><span>:</span><span> </span><span>page_name</span><span data-group-id="6111647571-4">)</span><span>
    </span><span>case</span><span> </span><span>page_count</span><span> </span><span data-group-id="6111647571-5">do</span><span>
      </span><span>nil</span><span> </span><span>-&gt;</span><span> 
       </span><span data-group-id="6111647571-6">%</span><span data-group-id="6111647571-6">PageCount</span><span data-group-id="6111647571-6">{</span><span data-group-id="6111647571-6">}</span><span>
       </span><span>|&gt;</span><span> </span><span>PageCount</span><span>.</span><span>changeset</span><span data-group-id="6111647571-7">(</span><span data-group-id="6111647571-8">%{</span><span>count</span><span>:</span><span> </span><span>1</span><span>,</span><span> </span><span>page</span><span>:</span><span> </span><span>page_name</span><span data-group-id="6111647571-8">}</span><span data-group-id="6111647571-7">)</span><span>
       </span><span>|&gt;</span><span> </span><span>Repo</span><span>.</span><span>insert</span><span data-group-id="6111647571-9">(</span><span data-group-id="6111647571-9">)</span><span>
      </span><span data-group-id="6111647571-10">%</span><span data-group-id="6111647571-10">PageCount</span><span data-group-id="6111647571-10">{</span><span data-group-id="6111647571-10">}</span><span> </span><span>=</span><span> </span><span>page_count</span><span> </span><span>-&gt;</span><span>
        </span><span>page_count</span><span>
        </span><span>|&gt;</span><span> </span><span>PageCount</span><span>.</span><span>changeset</span><span data-group-id="6111647571-11">(</span><span data-group-id="6111647571-12">%{</span><span>count</span><span>:</span><span> </span><span>page_count</span><span>.</span><span>count</span><span> </span><span>+</span><span> </span><span>1</span><span data-group-id="6111647571-12">}</span><span data-group-id="6111647571-11">)</span><span>
        </span><span>|&gt;</span><span> </span><span>Repo</span><span>.</span><span>update</span><span data-group-id="6111647571-13">(</span><span data-group-id="6111647571-13">)</span><span>
    </span><span data-group-id="6111647571-5">end</span><span>
  </span><span data-group-id="6111647571-3">end</span><span>
</span><span data-group-id="6111647571-1">end</span></code></pre>
<p>
and update the page_controller to count views</p>
<pre><code><span>  </span><span># lib/distributed_sqlite_web/controllers/page_controller.ex</span><span>
  </span><span>alias</span><span> </span><span>DistributedSqlite.Counter</span><span>

  </span><span>def</span><span> </span><span>index</span><span data-group-id="8742262905-1">(</span><span>conn</span><span>,</span><span> </span><span>_params</span><span data-group-id="8742262905-1">)</span><span> </span><span data-group-id="8742262905-2">do</span><span>
    </span><span>page_view</span><span> </span><span>=</span><span> </span><span>Counter</span><span>.</span><span>count_page_view</span><span data-group-id="8742262905-3">(</span><span>&#34;home&#34;</span><span data-group-id="8742262905-3">)</span><span>
    </span><span>render</span><span data-group-id="8742262905-4">(</span><span>conn</span><span>,</span><span> </span><span>&#34;index.html&#34;</span><span>,</span><span> </span><span>page_count</span><span>:</span><span> </span><span>page_view</span><span>.</span><span>count</span><span data-group-id="8742262905-4">)</span><span>
  </span><span data-group-id="8742262905-2">end</span></code></pre>
<p>
lastly, we can display the counter on our page</p>
<pre><code><span>&lt;!-- lib/distributed_sqlite_web/templates/page/index.html.heex --&gt;
&lt;h1&gt; Page Views </span><span data-group-id="4622997075-1">&lt;%=</span><span> </span><span>@view_count</span><span> </span><span data-group-id="4622997075-1">%&gt;</span><span> &lt;/h1&gt;</span></code></pre>
<p>
Now deploy again using <code>flyctl deploy</code> and then browse to your site to validate that the count is showing and updating when refreshing.</p>
<h2>
Restoring the Database on Deploy</h2>
<p>
The next problem to deal with is that the database will be wiped on our next deploy since it’s using ephemeral storage.</p>
<p>
One way to resolve this is to use a persistent volume (which should be done for production apps). But since this post is all about <a href="https://litestream.io/">litestream</a> lets set that up and see how it helps us here.</p>
<p>
The first step is to create a bucket in some S3 compatible storage. I like to use <a href="https://www.digitalocean.com/products/spaces">Digital Ocean spaces</a> for this, but you can also use AWS if you want. <a href="https://litestream.io/guides/">See litestream docs for more options</a></p>
<p>
You’ll need 3 things:</p>
<ol>
  <li>
the bucket url  </li>
  <li>
the access key  </li>
  <li>
the secret key  </li>
</ol>
<p>
Next, add litestream to our Docker image. Add the following lines to <code>Dockerfile</code> as part of the <code>builder</code> phase:</p>
<pre><code>ADD https://github.com/benbjohnson/litestream/releases/download/v0.3.9/litestream-v0.3.9-linux-amd64-static.tar.gz /tmp/litestream.tar.gz
RUN tar -C /usr/local/bin -xzf /tmp/litestream.tar.gz</code></pre>
<p>
And in the <code>runner</code> phase add:</p>
<pre><code>COPY --from=builder /usr/local/bin/litestream /usr/local/bin/litestream
COPY litestream.yml /etc/litestream.yml</code></pre>
<p>
We still need to create the <code>litestream.yml</code> file, lets do that now.</p>
<pre><code>access-key-id: ${LITESTREAM_ACCESS_KEY_ID}
secret-access-key: ${LITESTREAM_SECRET_ACCESS_KEY}

dbs:
  - path: /app/distributed_sql.db
    replicas:
      - url: ${REPLICA_URL}</code></pre>
<p>
Now set the three variables in Fly to the values you recorded from when setting up the bucket.</p>
<pre><code>$ flyctl secrets set REPLICA_URL=... LITESTREAM_ACCESS_KEY_ID=... LITESTREAM_SECRET_ACCESS_KEY=...</code></pre>
<p>
Finally, update the starting script so that the elixir release is a sub-process of litestream. The easiest way I’ve found to do this is to create a run script called <code>run.sh</code> with the following content:</p>
<pre><code>#!/bin/bash
set -e

# Restore the database if it does not already exist.
if [ -f /app/distributed_sql.db ]; then
  echo &#34;Database already exists, skipping restore&#34;
else
  echo &#34;No database found, restoring from replica if exists&#34;
  litestream restore -v -if-replica-exists -o /app/distributed_sql.db &#34;${REPLICA_URL}&#34;
fi

# Run migrations
/app/bin/migrate

# Run litestream with your app as the subprocess.
exec litestream replicate -exec &#34;/app/bin/server&#34;</code></pre>
<blockquote>
  <p>
Be sure to remove the migration script from fly.toml since we it runs in the run.sh script now.  </p>
</blockquote>
<p>
Now update the <code>Dockerfile</code> to use this new script to start the app:</p>
<pre><code>COPY run.sh /scripts/run.sh
RUN chmod 755 /scripts/run.sh

CMD [&#34;/scripts/run.sh&#34;]</code></pre>
<p>
Deploying should now start using litestream to restore the database on deploys and push backups when data changes. You can verify in the monitoring interface of fly. Look for something similar to the image below:</p>
<p>
  <img src="https://silbernagel.dev/images/fly-logs.png" alt="Fly logs showing that litestream is running" title="Fly Logs"/>
</p>
<h2>
Distributing</h2>
<p>
With all of this in place, things would work great when running one instance of you app. But as soon as you add another node things get out of wack. </p>
<p>
Lets see this in action – Scale the app to 2 and see what happens to the data.</p>
<pre><code>$ flyctl scale count 2</code></pre>
<p>
Enough refreshing or opening in different browser sessions and you’ll start to see discrepencies in the view count. This is because we are not replicating the data between the instances. This is a problem Elixir is built for…</p>
<p>
Follow the <a href="https://fly.io/docs/elixir/getting-started/clustering/">Fly guide to Clustering Your Application</a> to get clustering working correctly.</p>
<p>
Once your app is clustered, we can begin to replicate our database calls. Add a new GenServer with the following content:</p>
<pre><code><span># /lib/distributed_sqlite/repo_replication.ex</span><span>
</span><span>defmodule</span><span> </span><span>DistributedSqlite.RepoReplication</span><span> </span><span data-group-id="8351768842-1">do</span><span>
  </span><span>@moduledoc</span><span> </span><span>&#34;&#34;&#34;
  Run on each node to handle replicating Repo writes
  &#34;&#34;&#34;</span><span>
  </span><span>use</span><span> </span><span>GenServer</span><span>

  </span><span>alias</span><span> </span><span>DistributedSqlite.Repo</span><span>

  </span><span>def</span><span> </span><span>start_link</span><span data-group-id="8351768842-2">(</span><span>args</span><span data-group-id="8351768842-2">)</span><span> </span><span data-group-id="8351768842-3">do</span><span>
    </span><span>GenServer</span><span>.</span><span>start_link</span><span data-group-id="8351768842-4">(</span><span>__MODULE__</span><span>,</span><span> </span><span>args</span><span>,</span><span> </span><span>name</span><span>:</span><span> </span><span>__MODULE__</span><span data-group-id="8351768842-4">)</span><span>
  </span><span data-group-id="8351768842-3">end</span><span>

  </span><span>@impl</span><span> </span><span>true</span><span>
  </span><span>def</span><span> </span><span>init</span><span data-group-id="8351768842-5">(</span><span>_args</span><span data-group-id="8351768842-5">)</span><span> </span><span data-group-id="8351768842-6">do</span><span>
    </span><span data-group-id="8351768842-7">{</span><span>:ok</span><span>,</span><span> </span><span data-group-id="8351768842-8">[</span><span data-group-id="8351768842-8">]</span><span data-group-id="8351768842-7">}</span><span>
  </span><span data-group-id="8351768842-6">end</span><span>

  </span><span>def</span><span> </span><span>handle_cast</span><span data-group-id="8351768842-9">(</span><span data-group-id="8351768842-10">{</span><span>:replicate</span><span>,</span><span> </span><span>query</span><span>,</span><span> </span><span>:insert</span><span data-group-id="8351768842-10">}</span><span>,</span><span> </span><span>state</span><span data-group-id="8351768842-9">)</span><span> </span><span data-group-id="8351768842-11">do</span><span>
    </span><span>Repo</span><span>.</span><span>insert!</span><span data-group-id="8351768842-12">(</span><span>query</span><span data-group-id="8351768842-12">)</span><span>
    </span><span data-group-id="8351768842-13">{</span><span>:noreply</span><span>,</span><span> </span><span>state</span><span data-group-id="8351768842-13">}</span><span>
  </span><span data-group-id="8351768842-11">end</span><span>

  </span><span>def</span><span> </span><span>handle_cast</span><span data-group-id="8351768842-14">(</span><span data-group-id="8351768842-15">{</span><span>:replicate</span><span>,</span><span> </span><span>changeset</span><span>,</span><span> </span><span>:update</span><span data-group-id="8351768842-15">}</span><span>,</span><span> </span><span>state</span><span data-group-id="8351768842-14">)</span><span> </span><span data-group-id="8351768842-16">do</span><span>
    </span><span>Repo</span><span>.</span><span>update!</span><span data-group-id="8351768842-17">(</span><span>changeset</span><span data-group-id="8351768842-17">)</span><span>
    </span><span data-group-id="8351768842-18">{</span><span>:noreply</span><span>,</span><span> </span><span>state</span><span data-group-id="8351768842-18">}</span><span>
  </span><span data-group-id="8351768842-16">end</span><span>
</span><span data-group-id="8351768842-1">end</span></code></pre>
<p>
and make sure to start it in the <code>application.ex</code> </p>
<pre><code><span># lib/distributed_sqlite/application.ex</span><span>
</span><span>children</span><span> </span><span>=</span><span> </span><span data-group-id="3482002444-1">[</span><span>
  </span><span>...</span><span>,</span><span>
  </span><span data-group-id="3482002444-2">{</span><span>DistributedSqlite.RepoReplication</span><span>,</span><span> </span><span data-group-id="3482002444-3">[</span><span data-group-id="3482002444-3">]</span><span data-group-id="3482002444-2">}</span><span>
</span><span data-group-id="3482002444-1">]</span></code></pre>
<p>
Open the <code>DistributedSqlite.Repo</code> file and add a <code>replicate/2</code> function</p>
<pre><code><span>@doc</span><span> </span><span>&#34;&#34;&#34;
Replicate the query on the the other nodes in the cluster
&#34;&#34;&#34;</span><span>
</span><span>def</span><span> </span><span>replicate</span><span data-group-id="2429545247-1">(</span><span data-group-id="2429545247-2">{</span><span>:ok</span><span>,</span><span> </span><span>data_to_replicate</span><span data-group-id="2429545247-2">}</span><span> </span><span>=</span><span> </span><span>ret</span><span>,</span><span> </span><span>operation</span><span data-group-id="2429545247-1">)</span><span> </span><span>when</span><span> </span><span>operation</span><span> </span><span>in</span><span> </span><span data-group-id="2429545247-3">[</span><span>:insert</span><span>,</span><span> </span><span>:update</span><span data-group-id="2429545247-3">]</span><span> </span><span data-group-id="2429545247-4">do</span><span>
  </span><span>_</span><span> </span><span>=</span><span>
    </span><span>for</span><span> </span><span>node</span><span> </span><span>&lt;-</span><span> </span><span>Node</span><span>.</span><span>list</span><span data-group-id="2429545247-5">(</span><span data-group-id="2429545247-5">)</span><span> </span><span data-group-id="2429545247-6">do</span><span>
      </span><span>GenServer</span><span>.</span><span>cast</span><span data-group-id="2429545247-7">(</span><span>
        </span><span data-group-id="2429545247-8">{</span><span>DistributedSqlite.RepoReplication</span><span>,</span><span> </span><span>node</span><span data-group-id="2429545247-8">}</span><span>,</span><span>
        </span><span data-group-id="2429545247-9">{</span><span>:replicate</span><span>,</span><span> </span><span>data_to_replicate</span><span>,</span><span> </span><span>operation</span><span data-group-id="2429545247-9">}</span><span>
      </span><span data-group-id="2429545247-7">)</span><span>
    </span><span data-group-id="2429545247-6">end</span><span>

  </span><span>ret</span><span>
</span><span data-group-id="2429545247-4">end</span><span>

</span><span>def</span><span> </span><span>replicate</span><span data-group-id="2429545247-10">(</span><span data-group-id="2429545247-11">{</span><span>:error</span><span>,</span><span> </span><span>_changeset</span><span data-group-id="2429545247-11">}</span><span> </span><span>=</span><span> </span><span>ret</span><span>,</span><span> </span><span>_</span><span data-group-id="2429545247-10">)</span><span>,</span><span> </span><span>do</span><span>:</span><span> </span><span>ret</span><span>

</span><span>def</span><span> </span><span>replicate</span><span data-group-id="2429545247-12">(</span><span data-group-id="2429545247-13">%</span><span data-group-id="2429545247-13">Ecto.Changeset</span><span data-group-id="2429545247-13">{</span><span data-group-id="2429545247-13">}</span><span> </span><span>=</span><span> </span><span>changeset</span><span>,</span><span> </span><span>operation</span><span data-group-id="2429545247-12">)</span><span> </span><span>when</span><span> </span><span>operation</span><span> </span><span>in</span><span> </span><span data-group-id="2429545247-14">[</span><span>:insert</span><span>,</span><span> </span><span>:update</span><span data-group-id="2429545247-14">]</span><span> </span><span data-group-id="2429545247-15">do</span><span>
  </span><span>_</span><span> </span><span>=</span><span>
    </span><span>for</span><span> </span><span>node</span><span> </span><span>&lt;-</span><span> </span><span>Node</span><span>.</span><span>list</span><span data-group-id="2429545247-16">(</span><span data-group-id="2429545247-16">)</span><span> </span><span data-group-id="2429545247-17">do</span><span>
      </span><span>GenServer</span><span>.</span><span>cast</span><span data-group-id="2429545247-18">(</span><span>
        </span><span data-group-id="2429545247-19">{</span><span>DistributedSqlite.RepoReplication</span><span>,</span><span> </span><span>node</span><span data-group-id="2429545247-19">}</span><span>,</span><span>
        </span><span data-group-id="2429545247-20">{</span><span>:replicate</span><span>,</span><span> </span><span>changeset</span><span>,</span><span> </span><span>operation</span><span data-group-id="2429545247-20">}</span><span>
      </span><span data-group-id="2429545247-18">)</span><span>
    </span><span data-group-id="2429545247-17">end</span><span>

  </span><span data-group-id="2429545247-21">{</span><span>:ok</span><span>,</span><span> </span><span>changeset</span><span data-group-id="2429545247-21">}</span><span>
</span><span data-group-id="2429545247-15">end</span><span>

</span><span>def</span><span> </span><span>replicate</span><span data-group-id="2429545247-22">(</span><span>schema</span><span>,</span><span> </span><span>:insert</span><span data-group-id="2429545247-22">)</span><span> </span><span data-group-id="2429545247-23">do</span><span>
  </span><span>_</span><span> </span><span>=</span><span>
    </span><span>for</span><span> </span><span>node</span><span> </span><span>&lt;-</span><span> </span><span>Node</span><span>.</span><span>list</span><span data-group-id="2429545247-24">(</span><span data-group-id="2429545247-24">)</span><span> </span><span data-group-id="2429545247-25">do</span><span>
      </span><span>GenServer</span><span>.</span><span>cast</span><span data-group-id="2429545247-26">(</span><span>
        </span><span data-group-id="2429545247-27">{</span><span>DistributedSqlite.RepoReplication</span><span>,</span><span> </span><span>node</span><span data-group-id="2429545247-27">}</span><span>,</span><span>
        </span><span data-group-id="2429545247-28">{</span><span>:replicate</span><span>,</span><span> </span><span>schema</span><span>,</span><span> </span><span>:insert</span><span data-group-id="2429545247-28">}</span><span>
      </span><span data-group-id="2429545247-26">)</span><span>
    </span><span data-group-id="2429545247-25">end</span><span>

  </span><span data-group-id="2429545247-29">{</span><span>:ok</span><span>,</span><span> </span><span>schema</span><span data-group-id="2429545247-29">}</span><span>
</span><span data-group-id="2429545247-23">end</span></code></pre>
<p>
This gives us a function we can pipe into from an <code>Repo.insert</code> or the result of a <code>Repo.update</code>. Try this in the <code>DistributedSqlite.Counter</code> module:</p>
<pre><code><span>case</span><span> </span><span>page_count</span><span> </span><span data-group-id="3019222985-1">do</span><span>
  </span><span>nil</span><span> </span><span>-&gt;</span><span>
    </span><span data-group-id="3019222985-2">%</span><span data-group-id="3019222985-2">PageCount</span><span data-group-id="3019222985-2">{</span><span data-group-id="3019222985-2">}</span><span>
    </span><span>|&gt;</span><span> </span><span>PageCount</span><span>.</span><span>changeset</span><span data-group-id="3019222985-3">(</span><span data-group-id="3019222985-4">%{</span><span>count</span><span>:</span><span> </span><span>1</span><span>,</span><span> </span><span>page</span><span>:</span><span> </span><span>page_name</span><span data-group-id="3019222985-4">}</span><span data-group-id="3019222985-3">)</span><span>
    </span><span>|&gt;</span><span> </span><span>Repo</span><span>.</span><span>insert</span><span data-group-id="3019222985-5">(</span><span data-group-id="3019222985-5">)</span><span>
    </span><span>|&gt;</span><span> </span><span>Repo</span><span>.</span><span>replicate</span><span data-group-id="3019222985-6">(</span><span>:insert</span><span data-group-id="3019222985-6">)</span><span>

  </span><span data-group-id="3019222985-7">%</span><span data-group-id="3019222985-7">PageCount</span><span data-group-id="3019222985-7">{</span><span data-group-id="3019222985-7">}</span><span> </span><span>=</span><span> </span><span>page_count</span><span> </span><span>-&gt;</span><span>
    </span><span>page_count</span><span>
    </span><span>|&gt;</span><span> </span><span>PageCount</span><span>.</span><span>changeset</span><span data-group-id="3019222985-8">(</span><span data-group-id="3019222985-9">%{</span><span>count</span><span>:</span><span> </span><span>page_count</span><span>.</span><span>count</span><span> </span><span>+</span><span> </span><span>1</span><span data-group-id="3019222985-9">}</span><span data-group-id="3019222985-8">)</span><span>
    </span><span>|&gt;</span><span> </span><span>Repo</span><span>.</span><span>update</span><span data-group-id="3019222985-10">(</span><span data-group-id="3019222985-10">)</span><span>
    </span><span>|&gt;</span><span> </span><span>case</span><span> </span><span data-group-id="3019222985-11">do</span><span>
      </span><span data-group-id="3019222985-12">{</span><span>:ok</span><span>,</span><span> </span><span>cnt</span><span data-group-id="3019222985-12">}</span><span> </span><span>-&gt;</span><span>
        </span><span>cnt</span><span>
        </span><span>|&gt;</span><span> </span><span>PageCount</span><span>.</span><span>replicate_changeset</span><span data-group-id="3019222985-13">(</span><span data-group-id="3019222985-13">)</span><span>
        </span><span>|&gt;</span><span> </span><span>Repo</span><span>.</span><span>replicate</span><span data-group-id="3019222985-14">(</span><span>:update</span><span data-group-id="3019222985-14">)</span><span>

        </span><span data-group-id="3019222985-15">{</span><span>:ok</span><span>,</span><span> </span><span>cnt</span><span data-group-id="3019222985-15">}</span><span>
  </span><span data-group-id="3019222985-11">end</span><span>
</span><span data-group-id="3019222985-1">end</span></code></pre>
<p>
With all of this in place, deploy again. Your data should now be consistent no matter which node your traffic is served from!</p>
<h2>
Wrap Up</h2>
<p>
I’m not sure how far this can be pushed and there are downsides to this approach, but I plan on continuing this journey that puts my data as close to the application as possible.</p>
<p>
There is <a href="https://fly.io/docs/litefs/">another approach</a> worth exploring that removes the need to replicate the data on the application side. It is still in beta, but I plan on trying it out soon as well.</p>

    </article></div>
  </body>
</html>
