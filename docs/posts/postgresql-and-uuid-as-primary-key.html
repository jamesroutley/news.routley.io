<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://maciejwalkowiak.com/blog/postgres-uuid-primary-key/">Original</a>
    <h1>PostgreSQL and UUID as Primary Key</h1>
    
    <div id="readability-page-1" class="page"><div data-v-cc3220de=""><div data-v-cc3220de=""><div><p><strong>UUID</strong>s are often used as database table <strong>primary keys</strong>. They are easy to generate, easy to share between distributed systems and guarantee uniqueness.</p><p>Considering the size of UUID it is questionable if it is a right choice, but often it is not up to us to decide.</p><p>This article does not focus on &#34;<em>if UUID is the right format for a key</em>&#34;, but how to use <strong>UUID</strong> as a primary key with <strong>PostgreSQL</strong> efficiently.</p><hr/><h2 id="postgres-data-types-for-uuid" tabindex="-1">Postgres Data Types for UUID <a href="#postgres-data-types-for-uuid" aria-label="Permalink to &#34;Postgres Data Types for UUID&#34;">​</a></h2><p>UUID can be seen as a string and it may be tempting to store them as such. Postgres has a flexible data type for storing strings: <code>text</code> and it is often used as a primary key to store UUID values.</p><p>Is it a right data type? Definitely not.</p><p>Postgres has a dedicated data type for UUIDs: <code>uuid</code>. UUID is a 128 bit data type, so storing single value takes 16 bytes. <code>text</code> data type has 1 or 4 bytes overhead plus storing the actual string.</p><p>These differences are not that important in small tables, but become an issue once you start storing hundreds of thousands or millions of rows.</p><p>I run an experiment to see what is the difference in practice. There are two tables that have just one column - an <code>id</code> as a primary key. First table uses <code>text</code>, second <code>uuid</code>:</p><div><p><span>sql</span></p><pre><code><span><span>create</span><span> </span><span>table</span><span> </span><span>bank_transfer</span><span>(</span></span>
<span><span>    id </span><span>text</span><span> </span><span>primary key</span></span>
<span><span>);</span></span>
<span></span>
<span><span>create</span><span> </span><span>table</span><span> </span><span>bank_transfer_uuid</span><span>(</span></span>
<span><span>    id uuid </span><span>primary key</span></span>
<span><span>);</span></span></code></pre></div><p>I did not specify the type for primary key index, so Postgres uses the default one - <strong>B-tree</strong>.</p><p>Then I inserted <code>10 000 000</code> rows to each table using <code>batchUpdate</code> from Spring&#39;s <code>JdbcTemplate</code>:</p><div><p><span>java</span></p><pre><code><span><span>jdbcTemplate</span><span>.</span><span>batchUpdate</span><span>(</span><span>&#34;insert into bank_transfer (id) values (?)&#34;</span><span>,</span></span>
<span><span>        </span><span>new</span><span> </span><span>BatchPreparedStatementSetter</span><span>() {</span></span>
<span><span>            @</span><span>Override</span></span>
<span><span>            </span><span>public</span><span> </span><span>void</span><span> setValues</span><span>(</span><span>PreparedStatement</span><span> </span><span>ps</span><span>, </span><span>int</span><span> </span><span>i</span><span>)</span><span> </span><span>throws</span><span> </span><span>SQLException</span><span> </span><span>{</span></span>
<span><span>                </span><span>ps</span><span>.</span><span>setString</span><span>(</span><span>1</span><span>, </span><span>UUID</span><span>.</span><span>randomUUID</span><span>().</span><span>toString</span><span>());</span></span>
<span><span>            }</span></span>
<span><span>        </span></span>
<span><span>            @</span><span>Override</span></span>
<span><span>            </span><span>public</span><span> </span><span>int</span><span> getBatchSize</span><span>()</span><span> </span><span>{</span></span>
<span><span>                </span><span>return</span><span> </span><span>10_000_000</span><span>;</span></span>
<span><span>            }</span></span>
<span><span>});</span></span></code></pre></div><div><p><span>java</span></p><pre><code><span><span>jdbcTemplate</span><span>.</span><span>batchUpdate</span><span>(</span><span>&#34;insert into bank_transfer_uuid (id) values (?)&#34;</span><span>,</span></span>
<span><span>        </span><span>new</span><span> </span><span>BatchPreparedStatementSetter</span><span>() {</span></span>
<span><span>            @</span><span>Override</span></span>
<span><span>            </span><span>public</span><span> </span><span>void</span><span> setValues</span><span>(</span><span>PreparedStatement</span><span> </span><span>ps</span><span>, </span><span>int</span><span> </span><span>i</span><span>)</span><span> </span><span>throws</span><span> </span><span>SQLException</span><span> </span><span>{</span></span>
<span><span>                </span><span>ps</span><span>.</span><span>setObject</span><span>(</span><span>1</span><span>, </span><span>UUID</span><span>.</span><span>randomUUID</span><span>());</span></span>
<span><span>            }</span></span>
<span></span>
<span><span>            @</span><span>Override</span></span>
<span><span>            </span><span>public</span><span> </span><span>int</span><span> getBatchSize</span><span>()</span><span> </span><span>{</span></span>
<span><span>                </span><span>return</span><span> </span><span>10_000_000</span><span>;</span></span>
<span><span>            }</span></span>
<span><span>        });</span></span></code></pre></div><p>I run a query to find the table size and the index size:</p><div><p><span>sql</span></p><pre><code><span><span>select</span><span> </span></span>
<span><span>    relname </span><span>as</span><span> </span><span>&#34;table&#34;</span><span>, </span></span>
<span><span>    indexrelname </span><span>as</span><span> </span><span>&#34;index&#34;</span><span>,</span></span>
<span><span>    pg_size_pretty(pg_relation_size(relid)) </span><span>&#34;table size&#34;</span><span>,</span></span>
<span><span>    pg_size_pretty(pg_relation_size(indexrelid)) </span><span>&#34;index size&#34;</span></span>
<span><span>from</span><span> </span></span>
<span><span>    pg_stat_all_indexes</span></span>
<span><span>where</span><span> </span></span>
<span><span>    relname </span><span>not</span><span> </span><span>like</span><span> </span><span>&#39;pg%&#39;</span><span>;</span></span></code></pre></div><div><pre><code><span><span>+------------------+-----------------------+----------+----------+</span></span>
<span><span>|table             |index                  |table size|index size|</span></span>
<span><span>+------------------+-----------------------+----------+----------+</span></span>
<span><span>|bank_transfer_uuid|bank_transfer_uuid_pkey|422 MB    |394 MB    |</span></span>
<span><span>|bank_transfer     |bank_transfer_pkey     |651 MB    |730 MB    |</span></span>
<span><span>+------------------+-----------------------+----------+----------+</span></span></code></pre></div><p>Table that uses <code>text</code> is 54% larger and the index size 85% larger. This is also reflected in number of pages Postgres uses to store these tables and indexes:</p><div><p><span>sql</span></p><pre><code><span><span>select</span><span> relname, relpages </span><span>from</span><span> pg_class </span><span>where</span><span> relname </span><span>like</span><span> </span><span>&#39;bank_transfer%&#39;</span><span>;</span></span></code></pre></div><div><pre><code><span><span>+-----------------------+--------+</span></span>
<span><span>|relname                |relpages|</span></span>
<span><span>+-----------------------+--------+</span></span>
<span><span>|bank_transfer          |83334   |</span></span>
<span><span>|bank_transfer_pkey     |85498   |</span></span>
<span><span>|bank_transfer_uuid     |54055   |</span></span>
<span><span>|bank_transfer_uuid_pkey|50463   |</span></span>
<span><span>+-----------------------+--------+</span></span></code></pre></div><p>Larger size of tables, indexes and bigger number of tables means that Postgres must perform work to insert new rows and fetch rows - especially once index sizes are larger than available RAM memory, and Postgres must load indexes from disk.</p><h2 id="uuid-and-b-tree-index" tabindex="-1">UUID and B-Tree index <a href="#uuid-and-b-tree-index" aria-label="Permalink to &#34;UUID and B-Tree index&#34;">​</a></h2><p>Random UUIDs are not a good fit for a B-tree indexes - and B-tree index is the only available index type for a primary key.</p><p>B-tree indexes work the best with ordered values - like auto-incremented or time sorted columns.</p><p>UUID - even though always looks similar - comes in multiple variants. Java&#39;s <code>UUID.randomUUID()</code> - returns UUID v4 - which is a pseudo-random value. For us the more interesting one is UUID v7 - which produces time-sorted values. It means that each time new UUID v7 is generated, a greater value it has. And that makes it a good fit for B-Tree index.</p><p>To use UUID v7 in Java we need a 3rd party library like <a href="https://github.com/cowtowncoder/java-uuid-generator" target="_blank" rel="noreferrer">java-uuid-generator</a>:</p><div><p><span>xml</span></p><pre><code><span><span>&lt;</span><span>dependency</span><span>&gt;</span></span>
<span><span>  &lt;</span><span>groupId</span><span>&gt;com.fasterxml.uuid&lt;/</span><span>groupId</span><span>&gt;</span></span>
<span><span>  &lt;</span><span>artifactId</span><span>&gt;java-uuid-generator&lt;/</span><span>artifactId</span><span>&gt;</span></span>
<span><span>  &lt;</span><span>version</span><span>&gt;5.0.0&lt;/</span><span>version</span><span>&gt;</span></span>
<span><span>&lt;/</span><span>dependency</span><span>&gt;</span></span></code></pre></div><p>Then we can generate UUID v7 with:</p><div><p><span>java</span></p><pre><code><span><span>UUID</span><span> uuid </span><span>=</span><span> </span><span>Generators</span><span>.</span><span>timeBasedEpochGenerator</span><span>().</span><span>generate</span><span>();</span></span></code></pre></div><p>This theoretically should improve the performance of executing <code>INSERT</code> statements.</p><h2 id="how-uuid-v7-affects-insert-performance" tabindex="-1">How UUID v7 affects INSERT performance <a href="#how-uuid-v7-affects-insert-performance" aria-label="Permalink to &#34;How UUID v7 affects INSERT performance&#34;">​</a></h2><p>I created another table, exactly the same as <code>bank_transfer_uuid</code> but it will store only UUID v7 generated using the library mentioned above:</p><div><p><span>sql</span></p><pre><code><span><span>create</span><span> </span><span>table</span><span> </span><span>bank_transfer_uuid_v7</span><span>(</span></span>
<span><span>   id uuid </span><span>primary key</span></span>
<span><span>);</span></span></code></pre></div><p>Then I run <code>10</code> rounds of inserting <code>10000</code> rows to each table and measured how long it takes:</p><div><p><span>java</span></p><pre><code><span><span>for</span><span> (</span><span>int</span><span> i </span><span>=</span><span> </span><span>1</span><span>;</span><span> i </span><span>&lt;=</span><span> </span><span>10</span><span>;</span><span> i</span><span>++</span><span>) {</span></span>
<span><span>    </span><span>measure</span><span>(() </span><span>-&gt;</span><span> </span><span>IntStream</span><span>.</span><span>rangeClosed</span><span>(</span><span>0</span><span>, </span><span>10000</span><span>).</span><span>forEach</span><span>(it </span><span>-&gt;</span><span> {</span></span>
<span><span>        </span><span>jdbcClient</span><span>.</span><span>sql</span><span>(</span><span>&#34;insert into bank_transfer (id) values (:id)&#34;</span><span>)</span></span>
<span><span>                .</span><span>param</span><span>(</span><span>&#34;id&#34;</span><span>, </span><span>UUID</span><span>.</span><span>randomUUID</span><span>().</span><span>toString</span><span>())</span></span>
<span><span>                .</span><span>update</span><span>();</span></span>
<span><span>    })</span><span>)</span><span>;</span></span>
<span></span>
<span><span>    </span><span>measure</span><span>(() </span><span>-&gt;</span><span> </span><span>IntStream</span><span>.</span><span>rangeClosed</span><span>(</span><span>0</span><span>, </span><span>10000</span><span>).</span><span>forEach</span><span>(it </span><span>-&gt;</span><span> {</span></span>
<span><span>        </span><span>jdbcClient</span><span>.</span><span>sql</span><span>(</span><span>&#34;insert into bank_transfer_uuid (id) values (:id)&#34;</span><span>)</span></span>
<span><span>                .</span><span>param</span><span>(</span><span>&#34;id&#34;</span><span>, </span><span>UUID</span><span>.</span><span>randomUUID</span><span>())</span></span>
<span><span>                .</span><span>update</span><span>();</span></span>
<span><span>    })</span><span>)</span><span>;</span></span>
<span></span>
<span><span>    </span><span>measure</span><span>(() </span><span>-&gt;</span><span> </span><span>IntStream</span><span>.</span><span>rangeClosed</span><span>(</span><span>0</span><span>, </span><span>10000</span><span>).</span><span>forEach</span><span>(it </span><span>-&gt;</span><span> {</span></span>
<span><span>        </span><span>jdbcClient</span><span>.</span><span>sql</span><span>(</span><span>&#34;insert into bank_transfer_uuid_v7 (id) values (:id)&#34;</span><span>)</span></span>
<span><span>                .</span><span>param</span><span>(</span><span>&#34;id&#34;</span><span>, </span><span>Generators</span><span>.</span><span>timeBasedEpochGenerator</span><span>().</span><span>generate</span><span>())</span></span>
<span><span>                .</span><span>update</span><span>();</span></span>
<span><span>    })</span><span>)</span><span>;</span></span>
<span><span>}</span></span></code></pre></div><p>The results look a little random especially when comparing times for a table with regular <code>text</code> column and <code>uuid</code> v4:</p><div><pre><code><span><span>+-------+-------+---------+</span></span>
<span><span>| text  | uuid  | uuid v7 |</span></span>
<span><span>+-------+-------+---------+</span></span>
<span><span>| 7428  | 8584  | 3398    |</span></span>
<span><span>| 5611  | 4966  | 3654    |</span></span>
<span><span>| 13849 | 10398 | 3771    |</span></span>
<span><span>| 6585  | 7624  | 3679    |</span></span>
<span><span>| 6131  | 5142  | 3861    |</span></span>
<span><span>| 6199  | 10336 | 3722    |</span></span>
<span><span>| 6764  | 6039  | 3644    |</span></span>
<span><span>| 9053  | 5515  | 3621    |</span></span>
<span><span>| 6134  | 5367  | 3706    |</span></span>
<span><span>| 11058 | 5551  | 3850    |</span></span>
<span><span>+-------+-------+---------+</span></span></code></pre></div><p><strong>BUT</strong> we can clearly see, that inserting UUID v7 is <strong>~2x faster</strong> and inserting regular UUID v4.</p><h2 id="further-reading" tabindex="-1">Further reading <a href="#further-reading" aria-label="Permalink to &#34;Further reading&#34;">​</a></h2><ul><li><a href="https://commitfest.postgresql.org/47/4388/" target="_blank" rel="noreferrer">UUID v7 will likely be supported natively in Postgres 17</a></li><li><a href="https://www.ietf.org/archive/id/draft-peabody-dispatch-new-uuid-format-04.html#name-uuid-version-7" target="_blank" rel="noreferrer">UUID Version 7 format</a></li><li><a href="https://www.percona.com/blog/uuids-are-popular-but-bad-for-performance-lets-discuss/" target="_blank" rel="noreferrer">UUIDs are Popular, but Bad for Performance</a></li><li><a href="https://vladmihalcea.com/uuid-database-primary-key/" target="_blank" rel="noreferrer">https://vladmihalcea.com/uuid-database-primary-key/</a></li></ul><h2 id="summary" tabindex="-1">Summary <a href="#summary" aria-label="Permalink to &#34;Summary&#34;">​</a></h2><p>As mentioned at the beginning - due to UUID length - even with all these optimizations, it is not the best type for a primary key. If you have an option to choose, take a look at <a href="https://github.com/vladmihalcea/hypersistence-tsid" target="_blank" rel="noreferrer">TSID</a> maintained by <a href="https://twitter.com/vlad_mihalcea" target="_blank" rel="noreferrer">Vlad Mihalcea</a>.</p><p>But if you must or for some reason want to use UUIDs, take into account the optimizations I mentioned. Also keep in mind that such optimizations make a difference for large datasets. If you&#39;re storing hundreds or even few thousands of rows, and have a low traffic, you will likely not see any difference in the application performance. But if there&#39;s a chance you will have large dataset or big traffic - it is better to do it right from the beginning as changing primary keys can be quite a challenge.</p><p>At the end a disclarimer - I am not pretending to be a Postgres expert - I am rather sharing what I&#39;ve learned.</p><p>As usual, I hope you found it useful! Feel free to drop a comment if you found any mistake or have a question. Also, feel free to reach out to me on <a href="https://twitter.com/maciejwalkowiak" target="_blank" rel="noreferrer">twitter.com/maciejwalkowiak</a>.</p></div></div></div><div><p>Let&#39;s stay in touch and follow me on Twitter: <a href="https://twitter.com/maciejwalkowiak">@maciejwalkowiak</a></p><p>Subscribe to RSS feed <img src="https://jvns.ca/rss.png" width="30"/></p></div></div>
  </body>
</html>
