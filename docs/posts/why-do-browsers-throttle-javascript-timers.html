<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nolanlawson.com/2025/08/31/why-do-browsers-throttle-javascript-timers/">Original</a>
    <h1>Why do browsers throttle JavaScript timers?</h1>
    
    <div id="readability-page-1" class="page"><div>
				<p>Even if you’ve been doing JavaScript for a while, you might be surprised to learn that <code>setTimeout(0)</code> is not really <code>setTimeout(0)</code>. Instead, it could run 4 milliseconds later:</p>
<pre title="">const start = performance.now()
setTimeout(() =&gt; {
  // Likely 4ms
  console.log(performance.now() - start)
}, 0)
</pre>
<p>Nearly a decade ago when I was on the Microsoft Edge team, it was explained to me that browsers did this to avoid “abuse.” I.e. there are a lot of websites out there that spam <code>setTimeout</code>, so to avoid draining the user’s battery or blocking interactivity, browsers set a special “clamped” minimum of 4ms.</p>
<p>This also explains why some browsers would bump the throttling for devices on battery power (<a href="https://nolanlawson.com/2018/09/01/a-tour-of-javascript-timers-on-the-web/#:~:text=setTimeout%20and%20setInterval">16ms</a> in the case of legacy Edge), or throttle even more aggressively for background tabs (<a href="https://blog.chromium.org/2017/03/reducing-power-consumption-for.html">1 second</a> in Chrome!).</p>
<p>One question always vexed me, though: if <code>setTimeout</code> was so abused, then why did browsers keep introducing new timers like <code>setImmediate</code> (<a href="https://caniuse.com/setimmediate">RIP</a>), Promises, or even new fanciness like <a href="https://developer.mozilla.org/en-US/docs/Web/API/Scheduler/postTask"><code>scheduler.postTask()</code></a>? If <code>setTimeout</code> had to be nerfed, then wouldn’t these timers suffer the same fate eventually?</p>
<p>I wrote a long post about JavaScript timers <a href="https://nolanlawson.com/2018/09/01/a-tour-of-javascript-timers-on-the-web/">back in 2018</a>, but until recently I didn’t have a good reason to revisit this question. Then I was doing some work on <a href="https://github.com/dumbmatter/fakeIndexedDB"><code>fake-indexeddb</code></a>, which is a pure-JavaScript implementation of the IndexedDB API, and this question reared its head. As it turns out, IndexedDB wants to auto-commit <a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBTransaction">transactions</a> when there’s no outstanding work in the event loop – in other words, after all microtasks have finished, but before any tasks (can I cheekily say “macro-tasks”?) have started.</p>
<p>To accomplish this, <code>fake-indexeddb</code> was using <code>setImmediate</code> in Node.js (which shares some similarities with the legacy browser version) and <code>setTimeout</code> in the browser. In Node, <code>setImmediate</code> is kind of perfect, because it runs <a href="https://nodejs.org/en/learn/asynchronous-work/understanding-setimmediate">after microtasks but immediately before any other tasks</a>, and without clamping. In the browser, though, <code>setTimeout</code> is pretty sub-optimal: <a href="https://github.com/dumbmatter/fakeIndexedDB/pull/129">in one benchmark</a>, I was seeing Chrome take 4.8 seconds for something that only took 300 milliseconds in Node (a 16x slowdown!).</p>
<p>Looking out at the timer landscape in 2025, though, it wasn’t obvious what to choose. Some options included:</p>
<ul>
<li><code>setImmediate</code> – only supported in legacy Edge and IE, so that’s a no-go.</li>
<li><code>MessageChannel.postMessage</code> – this is the technique used by <a href="https://github.com/andrewiggins/afterframe/blob/6869d339acbdf64a7208ade338d539bde84c6fa2/src/index.js#L7">afterframe</a>.</li>
<li><code>window.postMessage</code> – a nice idea, but kind of janky since it might interfere with other scripts on the page using the same API. This approach is used by <a href="https://github.com/YuzuJS/setImmediate/blob/f1ccbfdf09cb93aadf77c4aa749ea554503b9234/setImmediate.js#L99-L122">the <code>setImmediate</code> polyfill</a> though.</li>
<li><code>scheduler.postTask</code> – if you read no further, this was the winner. But let’s explain why!</li>
</ul>
<p>To compare these options, I wrote <a href="https://codepen.io/nolanlawson-the-selector/pen/RNWJjNg?editors=1010">a quick benchmark</a>. A few important things about this benchmark:</p>
<ol>
<li>You have to run several iterations of <code>setTimeout</code> (and friends) to really suss out the clamping. Technically, per the <a href="https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout-dev:~:text=If%20nesting%20level%20is%20greater%20than%205%2C%20and%20timeout%20is%20less%20than%204">HTML specification</a>, the 4ms clamping is only supposed to kick in after a <code>setTimeout</code> has been nested (i.e. one <code>setTimeout</code> calls another) 5 times.</li>
<li>I didn’t test every possible combination of 1) battery vs plugged in, 2) monitor refresh rates, 3) background vs foreground tabs, etc., even though I know all of these things can affect the clamping. I have a life, and although it’s fun to don the lab coat and run some experiments, I don’t want to spend my entire Saturday doing that.</li>
</ol>
<p>In any case, here are the numbers (in milliseconds, median of 101 iterations, on a 2021 16-inch MacBook Pro):</p>
<table>
<thead>
<tr>
<th>Browser</th>
<th><code>setTimeout</code></th>
<th><code>MessageChannel</code></th>
<th><code>window</code></th>
<th><code>scheduler.postTask</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Chrome 139</td>
<td>4.2</td>
<td>0.05</td>
<td>0.03</td>
<td>0.00</td>
</tr>
<tr>
<td>Firefox 142</td>
<td>4.72</td>
<td>0.02</td>
<td>0.01</td>
<td>0.01</td>
</tr>
<tr>
<td>Safari 18.4</td>
<td>26.73</td>
<td>0.52</td>
<td>0.05</td>
<td>Not implemented</td>
</tr>
</tbody>
</table>
<p role="complementary"><strong>Note:</strong> this benchmark was tricky to write! When I first wrote it, I used <code>Promise.all</code> to run all the timers simultaneously, but this seemed to defeat Safari’s nesting heuristics, and made Firefox’s fire inconsistently. Now the benchmark runs each timer independently.</p>
<p>Don’t worry about the precise numbers too much: the point is that Chrome and Firefox clamp <code>setTimeout</code> to 4ms, and the other three options are roughly equivalent. In Safari, interestingly, <code>setTimeout</code> is even more heavily throttled, and <code>MessageChannel.postMessage</code> is a tad slower than <code>window.postMessage</code> (although <code>window.postMessage</code> is still janky for the reasons listed above).</p>
<p>This experiment answered my immediate question: <code>fake-indexeddb</code> should use <code>scheduler.postTask</code> (which I prefer for its ergonomics) and fall back to either <code>MessageChannel.postMessage</code> or <code>window.postMessage</code>. (I did experiment with different <a href="https://developer.mozilla.org/en-US/docs/Web/API/Prioritized_Task_Scheduling_API#task_priorities">priorities</a> for <code>postTask</code>, but they all performed <a href="https://github.com/dumbmatter/fakeIndexedDB/pull/136">almost identically</a>. For <code>fake-indexeddb</code>‘s use case, the default priority of <code>&#39;user-visible&#39;</code> seemed most appropriate, and that’s what the benchmark uses.)</p>
<p>None of this answered my original question, though: why exactly <em>do</em> browsers bother to throttle <code>setTimeout</code> if web developers can just use <code>scheduler.postTask</code> or <code>MessageChannel</code> instead? I asked my friend <a href="https://www.linkedin.com/in/toddreifsteck">Todd Reifsteck</a>, who was co-chair of the <a href="https://www.w3.org/webperf/">Web Performance Working Group</a> back when a lot of these discussions about <a href="https://github.com/WICG/interventions">“interventions”</a> were underway.</p>
<p>He said that there were effectively two camps: one camp felt that timers needed to be throttled to protect web devs from themselves, whereas the other camp felt that developers should “measure their own silliness,” and that any subtle throttling heuristics would just cause confusion. In short, it was the standard tradeoff in designing performance APIs: “some APIs are quick but come with footguns.”</p>
<p>This jives with my own intuitions on the topic. Browser interventions are usually put in place because web developers have either used too much of a good thing (e.g. <code>setTimeout</code>), or were blithely unaware of better options (the <a href="https://github.com/WICG/interventions/issues/18">touch listener controversy</a> is a good example). In the end, the browser is a “user agent” acting on the user’s behalf, and the W3C’s <a href="https://w3ctag.github.io/design-principles/#priority-of-constituencies">priority of constituencies</a> makes it clear that end-user needs always trump web developer needs.</p>
<p>That said, web developers often <em>do</em> want to do the right thing. (I consider this blog post an attempt in that direction.) We just don’t always have the tools to do it, so instead we grab whatever blunt instrument is nearby and start swinging. Giving us more control over tasks and scheduling could avoid the need to hammer away with <code>setTimeout</code> and cause a mess that calls for an intervention.</p>
<p>My prediction is that <code>postTask</code>/<code>postMessage</code> will remain unthrottled for the time being. Out of Todd’s two “camps,” the very existence of the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Prioritized_Task_Scheduling_API">Scheduler API</a>, which offers a whole slew of fine-grained tools for task scheduling, seems to point toward the “pro-control” camp as the one currently steering the ship. Although Todd sees the API more as a compromise between the two groups: yes, it offers a lot of control, but it also aligns with the browser’s actual rendering pipeline rather than random timeouts.</p>
<p>The pessimist in me wonders, though, if the API could still be abused – e.g. by carelessly using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Prioritized_Task_Scheduling_API#task_priorities"><code>user-blocking</code> priority</a> everywhere. Perhaps in the future, some enterprising browser vendor will put their foot more firmly on the throttle (so to speak) and discover that it causes websites to be snappier, more responsive, and less battery-draining. If that happens, then we may see another round of interventions. (Maybe we’ll need a <code>scheduler2</code> API to dig ourselves out of that mess!)</p>
<p>I’m not involved much in web standards anymore and can only speculate. For the time being, I’ll just do what most web devs do: choose whatever API accomplishes my goals today, and hope that browsers don’t change too much in the future. As long as we’re careful and don’t introduce too much “silliness,” I don’t think that’s a lot to ask.</p>
<p><em>Thanks to Todd Reifsteck for feedback on a draft of this post.</em></p>
<p role="complementary"><strong>Note:</strong> everything I said about <code>setTimeout</code> could also be said about <code>setInterval</code>. From the browser’s perspective, these are nearly the same APIs.</p>
<p role="complementary"><strong>Note:</strong> for what it’s worth, <code>fake-indexeddb</code> is still falling back to <code>setTimeout</code> rather than <code>MessageChannel</code> or <code>window.postMessage</code> in Safari. Despite my benchmarks above, I was only able to get <code>window.postMessage</code> to outperform the other two in <code>fake-indexeddb</code>‘s own benchmark – Safari seems to have some additional throttling for <code>MessageChannel</code> that my standalone benchmark couldn’t suss out. And <code>window.postMessage</code> still seems error-prone to me, so I’m reluctant to use it. Here is <a href="https://nolanlawson.github.io/fake-indexeddb-timer-benchmark/">my benchmark</a> for those curious.</p>
							</div></div>
  </body>
</html>
