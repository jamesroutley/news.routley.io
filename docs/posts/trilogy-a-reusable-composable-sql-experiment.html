<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://trilogydata.dev/demo">Original</a>
    <h1>Show HN: Trilogy â€“ A Reusable, Composable SQL Experiment</h1>
    
    <div id="readability-page-1" class="page"><div><!--[--><!--]--><div><p>This demo uses the popular TPD-DS dataset for transactional database benchmarking. You can read more about Trilogy and this benchmark tool here <a href="https://trilogydata.dev/blog/tpc_ds.html" target="_blank" rel="noopener noreferrer">here<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span>open in new window</span></span></a>.</p><p>No benchmarking right now, though - we just care that DuckDB can natively produce a nice representative data warehouse for TPC-DS with a built in extension, and that this dataset gives us a good way to explore the language syntax.</p><div><p>TIP</p><p>This demo uses an in-memory DuckDB database that may take some time to start for your first query. Trilogy is database agnostic; the same syntax will work on any backend such as Postgres, Bigquery, or Snowflake.</p></div><h3 id="our-first-queries" tabindex="-1"><a href="#our-first-queries" aria-hidden="true">#</a> Our First Queries</h3><p>TPC-DS creates a nice small warehouse; 17 dimension tables and 7 fact tables.</p><h4 id="dimensions" tabindex="-1"><a href="#dimensions" aria-hidden="true">#</a> Dimensions</h4><p><span><span><!--[-->call_center<!--]--></span></span><span><span><!--[-->catalog_page<!--]--></span></span><span><span><!--[-->customer<!--]--></span></span><span><span><!--[-->customer_address<!--]--></span></span><span><span><!--[-->customer_demographics<!--]--></span></span><span><span><!--[-->date_dim<!--]--></span></span><span><span><!--[-->household_demographics<!--]--></span></span><span><span><!--[-->income_band<!--]--></span></span><span><span><!--[-->item<!--]--></span></span><span><span><!--[-->promotion<!--]--></span></span><span><span><!--[-->reason<!--]--></span></span><span><span><!--[-->ship_mode<!--]--></span></span><span><span><!--[-->store<!--]--></span></span><span><span><!--[-->time_dim<!--]--></span></span><span><span><!--[-->warehouse<!--]--></span></span><span><span><!--[-->web_page<!--]--></span></span><span><span><!--[-->web_site<!--]--></span></span></p><h4 id="fact-tables" tabindex="-1"><a href="#fact-tables" aria-hidden="true">#</a> Fact Tables</h4><p><span><span><!--[-->catalog_sales<!--]--></span></span><span><span><!--[-->catalog_returns<!--]--></span></span><span><span><!--[-->inventory<!--]--></span></span><span><span><!--[-->store_sales<!--]--></span></span><span><span><!--[-->store_returns<!--]--></span></span><span><span><!--[-->web_sales<!--]--></span></span><span><span><!--[-->web_returns<!--]--></span></span></p><p>That&#39;s a lot to work with! Fortunately, someone has already defined a Trilogy model for TPC-DS <a href="https://github.com/trilogy-data/trilogy-public-models/tree/main/trilogy_public_models/duckdb/tpc_ds" target="_blank" rel="noopener noreferrer">here<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span>open in new window</span></span></a>; we&#39;ll be using that directly. We&#39;ll discuss models in more detail in a little bit.</p><p>To start out, let&#39;s focus on these Trilogy imports. You&#39;ll notice that these map closely to fact tables; that&#39;s not a coincidence. It&#39;s typical for a user query to be centered on one or more facts, so those are natural places to start a modeling hierarchy. Trilogy imports let you expose many entrypoints into the same relationship of tables to support intuitive query patterns.</p><div><p>TIP</p><p>We&#39;re going to hide the import statements from all the queries we run here. We&#39;ll work in an environment with all of them loaded already</p></div><p><span><span><!--[-->customer<!--]--></span></span><span><span><!--[-->store_sales<!--]--></span></span><span><span><!--[-->web_sales<!--]--></span></span><span><span><!--[-->catalog_sales<!--]--></span></span></p><!--[--><!--[--><h3>Basic Select</h3><div><div data-v-68594d18=""><div data-v-68594d18=""><pre id="query" data-ext="sql" data-v-68594d18=""><code data-v-68594d18="">select 
    customer.id, 
    customer.first_name, 
    customer.last_name 
limit 5;</code>
</pre></div></div><!----><!----><!----></div><!--]--><!--[--><h3>Another View, Similar Data</h3><div><div data-v-68594d18=""><div data-v-68594d18=""><pre id="query" data-ext="sql" data-v-68594d18=""><code data-v-68594d18="">select 
    store_sales.customer.id, 
    store_sales.customer.first_name, 
    store_sales.customer.last_name,
    store_sales.ticket_number, 
limit 5;</code>
</pre></div></div><!----><!----><!----></div><!--]--><!--[--><h3>Sales By Customer</h3><div><div data-v-68594d18=""><div data-v-68594d18=""><pre id="query" data-ext="sql" data-v-68594d18=""><code data-v-68594d18="">select 
    store_sales.customer.id,
    store_sales.customer.first_name,
    sum(store_sales.sales_price) as total_sales
order by
    total_sales desc
limit 10;</code>
</pre></div></div><!----><!----><!----></div><!--]--><!--]--><h3 id="the-model" tabindex="-1"><a href="#the-model" aria-hidden="true">#</a> The Model</h3><p>We mentioned earlier that we had a model defined that was lettings us run these queries. Let&#39;s peek below the hood. Modeling is the heart and &#34;art&#34; of Trilogy; defining names and relationships that enable intuitive access to data.</p><p>Models will define some concepts, bind some concepts, and often - import other models. While models can be 1-1 to tables and often are, they don&#39;t need to be - and this can be useful when refactoring, extending, or simplifying models.</p><div><p>TIP</p><p>A model describes the relationships between Trilogy concepts and the underlying data. It is a contract that can be used to generate queries.</p></div><div><p>TIP</p><p>A model definition <em>is</em> Trilogy - the access language and the modeling language are the same. You can define and extend a model inline.</p></div><p>This definition is for the <code>store_sales</code> references we&#39;ve been querying above. The full tpc-ds model contains multiple files like this.</p><div data-ext="sql"><pre><code>
<span>import</span> item <span>as</span> item<span>;</span>
<span>import</span> <span>date</span> <span>as</span> <span>date</span><span>;</span>
<span>import</span> <span>date</span> <span>as</span> return_date<span>;</span>
<span>import</span> <span>time</span> <span>as</span> <span>time</span><span>;</span>
<span>import</span> <span>time</span> <span>as</span> return_time<span>;</span>
<span>import</span> customer <span>as</span> customer<span>;</span>
<span>import</span> customer <span>as</span> return_customer<span>;</span>
<span>import</span> promotion <span>as</span> promotion<span>;</span>
<span>import</span> customer_demographic <span>as</span> customer_demographic<span>;</span>
<span>import</span> store <span>as</span> store<span>;</span>
<span>import</span> store <span>as</span> return_store<span>;</span>


<span>key</span> ticket_number <span>int</span><span>;</span>
property <span>&lt;</span>ticket_number<span>,</span>item<span>.</span>id<span>&gt;</span><span>.</span>quantity <span>int</span><span>;</span>
property <span>&lt;</span>ticket_number<span>,</span>item<span>.</span>id<span>&gt;</span><span>.</span>sales_price <span>float</span><span>;</span>
property <span>&lt;</span>ticket_number<span>,</span>item<span>.</span>id<span>&gt;</span><span>.</span>list_price <span>float</span><span>;</span>
property <span>&lt;</span>ticket_number<span>,</span>item<span>.</span>id<span>&gt;</span><span>.</span>ext_sales_price <span>float</span><span>;</span>
property <span>&lt;</span>ticket_number<span>,</span>item<span>.</span>id<span>&gt;</span><span>.</span>ext_wholesale_cost <span>float</span><span>;</span>
property <span>&lt;</span>ticket_number<span>,</span>item<span>.</span>id<span>&gt;</span><span>.</span>ext_list_price <span>float</span><span>;</span>
property <span>&lt;</span>ticket_number<span>,</span>item<span>.</span>id<span>&gt;</span><span>.</span>ext_discount_amount <span>float</span><span>;</span>
property <span>&lt;</span>ticket_number<span>,</span>item<span>.</span>id<span>&gt;</span><span>.</span>coupon_amt <span>float</span><span>;</span>
property <span>&lt;</span>ticket_number<span>,</span>item<span>.</span>id<span>&gt;</span><span>.</span>net_profit <span>float</span><span>;</span>
property <span>&lt;</span>ticket_number<span>,</span>item<span>.</span>id<span>&gt;</span><span>.</span>is_returned <span>bool</span><span>;</span>
property <span>&lt;</span>ticket_number<span>,</span>item<span>.</span>id<span>&gt;</span><span>.</span>net_paid <span>float</span><span>;</span>
property <span>&lt;</span>ticket_number<span>,</span>item<span>.</span>id<span>&gt;</span><span>.</span>return_amount <span>float</span>?<span>;</span>
property <span>&lt;</span>ticket_number<span>,</span>item<span>.</span>id<span>&gt;</span><span>.</span>return_net_loss <span>float</span>?<span>;</span>

auto profit <span>&lt;</span><span>-</span> ext_list_price <span>-</span> ext_wholesale_cost <span>-</span> ext_discount_amount <span>+</span> ext_sales_price<span>;</span>

datasource store_sales <span>(</span>
    SS_SOLD_DATE_SK: <span>date</span><span>.</span>id<span>,</span>
    SS_SOLD_TIME_SK: <span>time</span><span>.</span>id<span>,</span>
    SS_CUSTOMER_SK: customer<span>.</span>id<span>,</span>
    SS_CDEMO_SK: customer_demographic<span>.</span>id<span>,</span>
    SS_TICKET_NUMBER: ticket_number<span>,</span>
    SS_ITEM_SK: item<span>.</span>id<span>,</span>
    SS_SALES_PRICE: sales_price<span>,</span>
    SS_LIST_PRICE: list_price<span>,</span>
    SS_EXT_SALES_PRICE: ext_sales_price<span>,</span>
    SS_EXT_LIST_PRICE: ext_list_price<span>,</span>
    SS_EXT_WHOLESALE_COST: ext_wholesale_cost<span>,</span>
    SS_EXT_DISCOUNT_AMT: ext_discount_amount<span>,</span>
    SS_NET_PROFIT: net_profit<span>,</span>
    SS_PROMO_SK: promotion<span>.</span>id<span>,</span>
    SS_QUANTITY: quantity<span>,</span>
    SS_COUPON_AMT: coupon_amt<span>,</span>
    SS_STORE_SK: store<span>.</span>id<span>,</span>
    SS_NET_PAID: net_paid<span>,</span>
<span>)</span>
grain <span>(</span>ticket_number<span>,</span> item<span>.</span>id<span>)</span>
address memory<span>.</span>store_sales
<span>;</span>

datasource store_returns<span>(</span>
    SR_RETURNED_DATE_SK: return_date<span>.</span>id<span>,</span>
    SR_RETURN_TIME_SK: return_time<span>.</span>id<span>,</span>
    SR_ITEM_SK: <span>~</span>item<span>.</span>id<span>,</span>
    SR_CUSTOMER_SK: return_customer<span>.</span>id<span>,</span>
    SR_RETURN_AMT: return_amount<span>,</span>
    SR_TICKET_NUMBER: <span>~</span>ticket_number<span>,</span>
    SR_STORE_SK: return_store<span>.</span>id<span>,</span>
    SR_NET_LOSS: return_net_loss<span>,</span>
    
    <span>bool</span><span>(</span>return_time<span>.</span>id<span>)</span>: is_returned<span>,</span>
<span>)</span>
grain <span>(</span>ticket_number<span>,</span> item<span>.</span>id<span>)</span>
address memory<span>.</span>store_returns<span>;</span>
</code></pre></div><p>If you look at the top, there are imports. These are the key to reuse in Trilogy; they enable composition of models.</p><!--[--><!--[--><h3>Returns by Different State</h3><div><div data-v-68594d18=""><div data-v-68594d18=""><pre id="query" data-ext="sql" data-v-68594d18=""><code data-v-68594d18="">where store_sales.return_customer.state is not null 
    and store_sales.return_customer.state != store_sales.customer.state
SELECT
    store_sales.customer.state,
    sum(store_sales.sales_price) as total_sales,
    store_sales.return_customer.state,
order by
    total_sales desc
limit 10;</code>
</pre></div></div><!----><!----><!----></div><!--]--><!--]--><p>In fact, if we drill into customers, we&#39;ll see that model itself has an import. That entire extended model has been imported twice; once for the customer who bought, and once for the one that returned, enabling the same logic to be reused across both keys easily.</p><p>Beyond reuse, we want abstraction - the key to that is that datasources - which make the models concrete - can be evolved and split transparently to a consuming query. We can even use this to dynamically swap in aggregates when we compute a higher level table with the same outputs. (such as if a session runs a persist to store a query output).</p><div data-ext="sql"><pre><code><span>import</span> customer_demographic <span>as</span> demographics<span>;</span>

gjgjfj
<span>key</span> id <span>int</span><span>;</span>
property id<span>.</span>text_id string<span>;</span>
property id<span>.</span>last_name string<span>;</span>
property id<span>.</span>first_name string<span>;</span>
property id<span>.</span>preferred_cust_flag string<span>;</span>
property id<span>.</span>birth_day <span>int</span><span>;</span>
property id<span>.</span>birth_month <span>int</span><span>;</span>
property id<span>.</span>birth_year <span>int</span><span>;</span>
property id<span>.</span>birth_country string<span>;</span>
property id<span>.</span>salutation string<span>;</span>
property id<span>.</span>email_address string<span>;</span>
property id<span>.</span>login string<span>;</span>
property id<span>.</span>last_review_date string<span>;</span>

<span>key</span> address_id <span>int</span><span>;</span>
property address_id<span>.</span>address_id_string string<span>;</span>
property address_id<span>.</span>street string<span>;</span>
property address_id<span>.</span>city string<span>;</span>
property address_id<span>.</span>state string?<span>;</span>
property address_id<span>.</span>zip string<span>;</span>
property address_id<span>.</span>county string<span>;</span>
property address_id<span>.</span>country string<span>;</span>

datasource customers <span>(</span>
    C_CUSTOMER_SK: id<span>,</span>
    C_CUSTOMER_ID: text_id<span>,</span>
    C_LAST_NAME: last_name<span>,</span>
    C_FIRST_NAME: first_name<span>,</span>
    C_CURRENT_ADDR_SK: address_id<span>,</span>
    C_CURRENT_CDEMO_SK: demographics<span>.</span>id<span>,</span>
    C_PREFERRED_CUST_FLAG: preferred_cust_flag<span>,</span>
    C_BIRTH_COUNTRY: birth_country<span>,</span>
    C_SALUTATION: salutation<span>,</span>
    C_EMAIL_ADDRESS: email_address<span>,</span>
    C_BIRTH_DAY: birth_day<span>,</span>
    C_BIRTH_MONTH: birth_month<span>,</span>
    C_BIRTH_YEAR: birth_year<span>,</span>
    C_LOGIN: login<span>,</span>
    C_LAST_REVIEW_DATE_SK:last_review_date<span>,</span>
<span>)</span>
grain <span>(</span>id<span>)</span>
address memory<span>.</span>customer<span>;</span>


datasource customer_address<span>(</span>
    CA_ADDRESS_SK: address_id<span>,</span>
    CA_STREET_NAME: street<span>,</span>
    CA_CITY: city<span>,</span>
    CA_STATE: state<span>,</span> 
    CA_ZIP: zip<span>,</span>
    CA_COUNTY: county<span>,</span>
    CA_COUNTRY:country<span>,</span>
<span>)</span>
grain <span>(</span>address_id<span>)</span>
address memory<span>.</span>customer_address<span>;</span>
</code></pre></div><h3 id="derived-concepts-and-filtering" tabindex="-1"><a href="#derived-concepts-and-filtering" aria-hidden="true">#</a> Derived Concepts and Filtering</h3><p>Now that we understand the basics of selection, let&#39;s get into the world of derivation, multi-level aggregation, and filtering.</p><p>We&#39;re going to stick with <code>store_sales</code> data for now.</p><h2 id="let-s-run-through-some-examples" tabindex="-1"><a href="#let-s-run-through-some-examples" aria-hidden="true">#</a> Let&#39;s run through some examples</h2><!--[--><!--[--><h3>State Aggregation</h3><div><div data-v-68594d18=""><div data-v-68594d18=""><pre id="query" data-ext="sql" data-v-68594d18=""><code data-v-68594d18="">select 
    store_sales.customer.state,
    sum(store_sales.sales_price) as total_sales,
    count(store_sales.customer.id) as customer_count,
    total_sales / customer_count as average_sales_per_customer
order by
    average_sales_per_customer desc
limit 10; </code>
</pre></div></div><!----><!----><!----></div><!--]--><!--[--><h3>Mixed aggregate</h3><div><div data-v-68594d18=""><div data-v-68594d18=""><pre id="query" data-ext="sql" data-v-68594d18=""><code data-v-68594d18="">select 
    --store_sales.customer.id,
    store_sales.customer.first_name,
    --store_sales.customer.state,
    sum(store_sales.sales_price) as total_sales,
    --sum(store_sales.sales_price) by store_sales.customer.state as total_state_sales,
    total_sales / total_state_sales as fraction_of_total_state_sales
order by
    fraction_of_total_state_sales desc
limit 10;</code>
</pre></div></div><!----><!----><!----></div><!--]--><!--[--><h3>Filtering</h3><div><div data-v-68594d18=""><div data-v-68594d18=""><pre id="query" data-ext="sql" data-v-68594d18=""><code data-v-68594d18="">WHERE store_sales.customer_demographic.education_status = &#39;College&#39;
SELECT
    --store_sales.customer.id,
    store_sales.customer.first_name,
    store_sales.customer.state,
    sum(store_sales.sales_price) as total_sales,
    --sum(store_sales.sales_price) by store_sales.customer.state as total_state_sales,
    total_sales / total_state_sales as fraction_of_total_state_sales
order by
    store_sales.customer.state asc,
    fraction_of_total_state_sales desc
limit 10;
    </code>
</pre></div></div><!----><!----><!----></div><!--]--><!--[--><h3>Nuanced Filter</h3><div><div data-v-68594d18=""><div data-v-68594d18=""><pre id="query" data-ext="sql" data-v-68594d18=""><code data-v-68594d18="">SELECT
    store_sales.customer.state,
    store_sales.customer_demographic.education_status,
    sum(filter store_sales.sales_price where store_sales.customer_demographic.education_status = &#39;College&#39;) as college_sales,
    sum(store_sales.sales_price ? store_sales.customer_demographic.education_status = &#39;College&#39;) as college_sales_alt,
    --sum(store_sales.sales_price ) by store_sales.customer.state as total_state_sales,
    college_sales / total_state_sales as fraction_of_total_state_sales
HAVING
    store_sales.customer_demographic.education_status = &#39;College&#39;
order by
    store_sales.customer.state asc,
    fraction_of_total_state_sales desc
limit 10;
    </code>
</pre></div></div><!----><!----><!----></div><!--]--><!--[--><h3>Find the average per-state rank by total store sales of items</h3><div><div data-v-68594d18=""><div data-v-68594d18=""><pre id="query" data-ext="sql" data-v-68594d18=""><code data-v-68594d18="">
with ranked_states as
select 
    store_sales.item.name,
    store_sales.customer.state,
    rank store_sales.item.name
        over store_sales.customer.state 
        order by sum(store_sales.sales_price) by store_sales.item.name, store_sales.customer.state  desc 
    as sales_rank;

select 
    ranked_states.store_sales.item.name,
    avg(cast(ranked_states.sales_rank as int))-&gt; avg_sales_rank,
    max(cast(ranked_states.sales_rank as int))-&gt; max_sales_rank,
    min(cast(ranked_states.sales_rank as int))-&gt; min_sales_rank
order by 
    avg_sales_rank desc
limit 10
;</code>
</pre></div></div><!----><!----><!----></div><!--]--><!--]--><h3 id="sandbox" tabindex="-1"><a href="#sandbox" aria-hidden="true">#</a> Sandbox</h3><p>Ready? Let&#39;s have you try out some queries!</p><div><p>TIP</p><p>For basic queries, Trilogy should be almost identical to SQL. When in doubt, try the SQL syntax!</p></div><h4 id="can-you-answer-these-questions-click-to-show-a-possible-answer" tabindex="-1"><a href="#can-you-answer-these-questions-click-to-show-a-possible-answer" aria-hidden="true">#</a> Can you answer these questions? (click to show a possible answer)</h4><ul><li><p><span>What were the sales by year in the state of CA? <span>&gt;</span></span></p><!----></li><li><p><span>What was the average yearly sales for the state of CA? <span>&gt;</span></span></p><!----></li><li><p><span>Which customer demographics had the most store sales in 2001, and what were the sales within that demographic in hawaii? <span>&gt;</span></span></p><!----></li><li><p><span>What was the most popular item bought by customers in massachesetts and kentucky by customers with more than 5 orders? <span>&gt;</span></span></p><!----></li></ul><p>The following concepts are predefined for you and can be referenced by name.</p><h4 id="concept-search" tabindex="-1"><a href="#concept-search" aria-hidden="true">#</a> Concept Search</h4><p>There&#39;s more concepts that we can reasonably show you available. Search this box for inspiration:</p><div><p>WARNING</p><p>Stick to querying concepts with the same root for now - eg store_sales.x and store_sales.y. Or if you&#39;re feeling adventerous, read on to find out how to merge models to enable cross-namespace querying..</p></div><!--[--><!--]--><h2 id="multiple-models" tabindex="-1"><a href="#multiple-models" aria-hidden="true">#</a> Multiple Models</h2><p>We&#39;ve had some fun with store sales, but what about the rest of the dataset?</p><p>A typical Trilogy script will be based on importing existing models - and these models may themselves have imports. But if you have two models you want to connect, how can you do that?</p><p>There&#39;s two tools. Let&#39;s start with the one you generally don&#39;t want to use - a query merge.</p><h3 id="query-merges" tabindex="-1"><a href="#query-merges" aria-hidden="true">#</a> Query Merges</h3><p>Query merges look like selects, but with more than 1 select clause + an align statement that defines how to merge the selects. Think of this as a full outer join between the listed columns to merge the select outputs. The where, order by, and others are identical.</p><p>This can be useful to combine disparate concepts into a single result set row, such as show orders by ship date and delivery date in the same row.</p><div><p>TIP</p><p>Only use query merges when you are aligning conceptually unrelated topics into a tabular dataset.</p></div><div data-ext="py"><pre><code>SELECT <span>1</span> 
MERGE
SELECT <span>2</span>
ALIGN <span>&lt;</span>align_alias<span>&gt;</span><span>:</span><span>&lt;</span>select <span>1</span> concept<span>&gt;</span><span>,</span><span>&lt;</span>select <span>2</span> concept<span>&gt;</span>
AND 
<span>&lt;</span>align_alias_2<span>&gt;</span><span>:</span><span>&lt;</span>select <span>1</span> concept<span>&gt;</span><span>,</span><span>&lt;</span>select <span>2</span> concept<span>&gt;</span>
</code></pre></div><h3 id="model-merges" tabindex="-1"><a href="#model-merges" aria-hidden="true">#</a> Model Merges</h3><p>The preferred method is to <em>merge</em> the model on one or more concepts. This tells Trilogy that these two fields are the &#34;same&#34;. For example, if you have a sales dataset and a holidays dataset, they might have the following fields:</p><p>Sales: &#39;order_date&#39;, &#39;ship_date&#39;, &#39;returned_date&#39;, &#39;order_id&#39;</p><p>Holidays: &#39;date&#39;, &#39;&lt;&gt;.holiday_name&#39;</p><p>You want to know what sales were ordered on holidays - you would merge the holidays date into the sales.order_date, and you could now easily query <code>select holiday_name, count(order_id)</code>.</p><p>If you wanted to see orders that shipped on a holiday, you&#39;d merge them on ship date - and if you wanted to be able to query both, you could import the holidays dataset under two differet names and merge them independently.</p><p>Merge on one: <code>MERGE &lt;concept1&gt; into &lt;modifiers?&gt;&lt;concept2&gt;</code></p><p>Merge on many: <code>MERGE &lt;namespace1&gt;.* into &lt;modifiers?&gt;&lt;namespace2&gt;.*</code></p><p>Let&#39;s try both out:</p><!--[--><!--[--><h3>Query Merge</h3><div><div data-v-68594d18=""><div data-v-68594d18=""><pre id="query" data-ext="sql" data-v-68594d18=""><code data-v-68594d18="">SELECT
    store_sales.date.year,
    count(store_sales.ticket_number) as store_order_count
MERGE
SELECT
    web_sales.date.year,
    count(web_sales.order_number) as web_order_count
ALIGN 
    report_date: store_sales.date.year, web_sales.date.year
ORDER BY
    report_date asc;</code>
</pre></div></div><!----><!----><!----></div><!--]--><!--[--><h3>Model Merge</h3><div><div data-v-68594d18=""><div data-v-68594d18=""><pre id="query" data-ext="sql" data-v-68594d18=""><code data-v-68594d18="">MERGE store_sales.date.* into ~date.*;
MERGE web_sales.date.* into ~date.*;

SELECT
    date.year,
    count(web_sales.order_number) as web_order_count,
    count(store_sales.ticket_number) as store_order_count
HAVING
    web_order_count&gt;0 or store_order_count&gt;0
ORDER BY 
    date.year asc
LIMIT 100;</code>
</pre></div></div><!----><!----><!----></div><!--]--><!--]--><div><p>TIP</p><p>Multiple merge statements can be defined between two models; queries will merge across as many concepts as are referenced in the query.</p></div><h2 id="saving-results-etl" tabindex="-1"><a href="#saving-results-etl" aria-hidden="true">#</a> Saving Results / ETL</h2><p>Imagine you want to create tables or save the outputs of a query to power a dashboard.</p><p>Trilogy supports this through the <code>persist</code> keyword.</p><p>This keyword is used to signify that any table created by Trilogy is effectively a <em>cache</em> of a given output. You&#39;ve already defined canonical sources; if we copy that data into a new table it&#39;s only valid until the sources change.</p><p>In base Trilogy, this can be used to create or update a table, such as on powering a dashboard.</p><div><p>TIP</p><p>In practice, most warehouse will have a finite set of &#39;roots&#39; and a number of caches derived from them that are refreshed on some cadence to drive reporting, analytics, and performance. Trilogy allows you to explicitly define and manage those caches via persist statements.</p></div><!--[--><!--[--><h3>Basic Persist</h3><div><div data-v-68594d18=""><div data-v-68594d18=""><pre id="query" data-ext="sql" data-v-68594d18=""><code data-v-68594d18="">
MERGE store_sales.customer.* into customer.*;
MERGE web_sales.customer.* into customer.*;
MERGE store_sales.date.* into store_sales.date.*;
MERGE web_sales.date.* into web_sales.date.*;

PERSIST customer_fact into customer_fact from
WHERE date.year = 2000
AND customer.state = &#39;VT&#39;
SELECT
    customer.id,
    date.year,
    sum(store_sales.sales_price) as total_store_sales,
    sum(web_sales.sales_price) as total_web_sales,
    total_store_sales + total_web_sales as total_sales
</code>
</pre></div></div><!----><!----><!----></div><!--]--><!--]--><h3 id="trilogyt" tabindex="-1"><a href="#trilogyt" aria-hidden="true">#</a> TrilogyT</h3><p>Interested in using Trilogy for data transformation as well as data access?</p><p><a href="https://github.com/Trilogydata/Trilogyt" target="_blank" rel="noopener noreferrer">TrilogyT<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span>open in new window</span></span></a> is a Trilogy integration that adds additional keywords to support ETL workflows and integrates closely with DBT to support a full data warehouse workflow.</p><p>You can read more in the TrilogyT <a href="https://trilogydata.dev/Trilogyt">docs</a>.</p><h2 id="benefits-of-a-semantic-layer" tabindex="-1"><a href="#benefits-of-a-semantic-layer" aria-hidden="true">#</a> Benefits of A Semantic Layer</h2><p>A semantic layer is a business representation of data and offers a unified and consolidated view of data across an organization.</p><p>Trilogy <em>is</em> a semantic layer - the abstract expression of relationships between concepts enables a consistent and coherent view of the data, and the separation of the model from the underlying data enables the model to evolve independently of the underlying data.</p><p>This makes Trilogy a natural fit for any case where you want to operate at this higher level of abstraction - a popular one these days being GenAI. It&#39;s much easier for a GenAI model to identify the appropriate concepts for a query and let Trilogy map that to the underlying data model; and as with a human written query this makes the result robust to changes/evolution of your data model.</p><h3 id="trilogy-nlp-genai" tabindex="-1"><a href="#trilogy-nlp-genai" aria-hidden="true">#</a> Trilogy-NLP / GenAI</h3><p><a href="https://github.com/Trilogydata/Trilogy-nlp" target="_blank" rel="noopener noreferrer">Trilogy-NLP<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span>open in new window</span></span></a> is a Trilogy integration that adds natural language processing to Trilogy, enabling users to write queries in natural language and have them translated to SQL via the Trilogy semantic model. The simplified abstraction of a Trilogy model is natural fit for generative AI models, bypassing potential hallucination issues and SQL correctness challenges by focusing the model solely on interpreting the user query and mapping that to the higher level semantic layer.</p><div><p>WARNING</p><p>Trilogy-NLP is in active development and may not always return correct results. As with other generative AI tools, experimenting with what prompts produce the best results is recommended.</p></div><p>Trilogy-NLP can either be used in an interactive analytics context, as a helper for users to write queries, or as a backend for a chatbot or other natural language interface to a database.</p><p>You can experiment with querying the TPC-ds dataset with trilogy-NLP below.</p><div><p>TIP</p><p>You can view the generated query just like with Trilogy - Trilogy-NLP is just a different way to write the same queries, and it will always show it&#39;s work.</p></div><!--[--><!--]--><h2 id="query-comparisons" tabindex="-1"><a href="#query-comparisons" aria-hidden="true">#</a> Query Comparisons</h2><p>The TPC-DS benchmark comes with built in queries - we can use these to explore how idiomatic SQL compares to Trilogy in practice.</p><div><p>WARNING</p><p>This section is a work in progress and will be expanded over time.</p></div><h3 id="query-3-brand-sales" tabindex="-1"><a href="#query-3-brand-sales" aria-hidden="true">#</a> Query 3 - Brand Sales</h3><p>This is a fairly straightforward query in both languages.</p><h4 id="sql" tabindex="-1"><a href="#sql" aria-hidden="true">#</a> SQL</h4><div data-v-68594d18=""><div data-v-68594d18=""><pre id="query" data-ext="sql" data-v-68594d18=""><code data-v-68594d18="">SELECT dt.d_year,
       item.i_brand_id brand_id,
       item.i_brand brand,
       sum(ss_ext_sales_price) sum_agg
FROM date_dim dt,
     store_sales,
     item
WHERE dt.d_date_sk = store_sales.ss_sold_date_sk
  AND store_sales.ss_item_sk = item.i_item_sk
  AND item.i_manufact_id = 128
  AND dt.d_moy=11
GROUP BY dt.d_year,
         item.i_brand,
         item.i_brand_id
ORDER BY dt.d_year,
         sum_agg DESC,
         brand_id
LIMIT 100;</code>
</pre></div></div><h4 id="trilogy" tabindex="-1"><a href="#trilogy" aria-hidden="true">#</a> Trilogy</h4><p>Trilogy looks very similar, without the group by.</p><div data-v-68594d18=""><div data-v-68594d18=""><pre id="query" data-ext="sql" data-v-68594d18=""><code data-v-68594d18="">import store_sales as store_sales;

WHERE 
    store_sales.date.month_of_year=11 and store_sales.item.manufacturer_id=128
SELECT
    store_sales.date.year,
    store_sales.item.brand_id,
    store_sales.item.brand_name,
    sum(store_sales.ext_sales_price)-&gt;sum_agg
ORDER BY 
    store_sales.date.year asc,
    sum_agg desc,
    store_sales.item.brand_id asc
limit 100;
</code>
</pre></div></div><h3 id="query-1-customer-returns" tabindex="-1"><a href="#query-1-customer-returns" aria-hidden="true">#</a> Query 1 - Customer Returns</h3><p>This is a more complicated query.</p><h4 id="sql-1" tabindex="-1"><a href="#sql-1" aria-hidden="true">#</a> SQL</h4><div data-v-68594d18=""><div data-v-68594d18=""><pre id="query" data-ext="sql" data-v-68594d18=""><code data-v-68594d18="">WITH customer_total_return AS
  (SELECT sr_customer_sk AS ctr_customer_sk,
          sr_store_sk AS ctr_store_sk,
          sum(sr_return_amt) AS ctr_total_return
   FROM store_returns,
        date_dim
   WHERE sr_returned_date_sk = d_date_sk
     AND d_year = 2000
   GROUP BY sr_customer_sk,
            sr_store_sk)
SELECT c_customer_id
FROM customer_total_return ctr1,
     store,
     customer
WHERE ctr1.ctr_total_return &gt;
    (SELECT avg(ctr_total_return)*1.2
     FROM customer_total_return ctr2
     WHERE ctr1.ctr_store_sk = ctr2.ctr_store_sk)
  AND s_store_sk = ctr1.ctr_store_sk
  AND s_state = &#39;TN&#39;
  AND ctr1.ctr_customer_sk = c_customer_sk
ORDER BY c_customer_id
LIMIT 100;</code>
</pre></div></div><h4 id="trilogy-1" tabindex="-1"><a href="#trilogy-1" aria-hidden="true">#</a> Trilogy</h4><p>Here, we&#39;ll use an inline calculation of total returns by customer /store, and then reuse that immediately to calculate the average customer returns by store.</p><p>Since these are newly derived aggegates, we&#39;ll filter them in the having clause.</p><div data-v-68594d18=""><div data-v-68594d18=""><pre id="query" data-ext="sql" data-v-68594d18=""><code data-v-68594d18="">import store_returns as returns;

WHERE
    returns.store.state = &#39;TN&#39; and
    returns.return_date.year = 2000
SELECT
    returns.customer.text_id,
    --sum(returns.return_amount)-&gt; total_returns, # returns by store
    --returns.store.id, # this query implicity groups by text_id and store, but only returns text_id
    --avg(total_returns) by returns.store.id -&gt; avg_store_returns # verage off the previous calc
HAVING
   total_returns &gt; (1.2*avg_store_returns)
ORDER BY 
    returns.customer.text_id asc
limit 100;</code>
</pre></div></div></div><!--[--><!--]--></div></div>
  </body>
</html>
