<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matklad.github.io/2025/08/09/zigs-lovely-syntax.html">Original</a>
    <h1>Zig&#39;s Lovely Syntax</h1>
    
    <div id="readability-page-1" class="page"><div>
      <article>
        
        <p>
          It’s a bit of a silly post, because syntax is the least interesting
          detail about the language, but, still, I can’t stop thinking how Zig
          gets this detail just right for the class of curly-braced languages,
          and, well, now you’ll have to think about that too.
        </p>
        <p>
          On the first glance, Zig looks almost exactly like Rust, because Zig
          borrows from Rust liberally. And I think that Rust has great syntax,
          considering all the semantics it needs to express (see
          <a href="https://matklad.github.io/2023/01/26/rusts-ugly-syntax.html">“Rust’s Ugly Syntax”</a>). But Zig improves on that, mostly by
          leveraging simpler language semantics, but also through some purely
          syntactical tasteful decisions.
        </p>
        <section id="Integer-Literals">
          <h2>
            <a href="#Integer-Literals">Integer Literals </a>
          </h2>
          <p>
            How do you spell a number ninety-two? Easy, <code>92</code>. But
            what type is that? Statically-typed languages often come with
            several flavors of integers: <code>u32</code>, <code>u64</code>,
            <code>u8</code>. And there’s often a syntax for literals of a
            particular types: <code>92u8</code>, <code>92l</code>, <code>92z</code>.
          </p>
          <p>
            Zig doesn’t have suffixes, because, in Zig, all integer literals
            have the same type: <code>comptime_int</code>:
          </p>

          <figure>
            <pre><code><span><span>const</span> an_integer = <span>92</span>;</span>
<span>assert(<span>@TypeOf</span>(an_integer) <span>==</span> <span>comptime_int</span>);</span></code></pre>
          </figure>
          <p>
            The value of an integer literal is known at compile time and is
            coerced to a specific type on assignment
            <span><code>const x: i32 = 92;</code></span>
            or ascription:
            <span><code>@as(i32, 92)</code></span>
          </p>
          <p>
            To emphasize, this is <em>not</em> type inference, this is implicit
            comptime coercion. This does mean that code like
            <span><code>var x = 92;</code></span>
            generally doesn’t work, and requires an explicit type.
          </p>
        </section>
        <section id="String-Literals">
          <h2>
            <a href="#String-Literals">String Literals </a>
          </h2>
          <p>Raw or multiline strings are spelled like this:</p>

          <figure>
            <pre><code><span><span>const</span> raw =</span>
<span>    <span>\\Roses are red</span></span>
<span>    <span>\\  Violets are blue,</span></span>
<span>    <span>\\Sugar is sweet</span></span>
<span>    <span>\\  And so are you.</span></span>
<span>    <span>\\</span></span>
<span>;</span></code></pre>
          </figure>
          <p>
            This syntax doesn’t require a special form for escaping <code>\\</code> itself:
          </p>

          <figure>
            <pre><code><span><span>const</span> still_raw =</span>
<span>    <span>\\const raw =</span></span>
<span>    <span>\\    <span>\\</span>Roses are red</span></span>
<span>    <span>\\    <span>\\</span>  Violets are blue,</span></span>
<span>    <span>\\    <span>\\</span>Sugar is sweet</span></span>
<span>    <span>\\    <span>\\</span>  And so are you.</span></span>
<span>    <span>\\    <span>\\</span></span></span>
<span>    <span>\\;</span></span>
<span>    <span>\\</span></span>
<span>;</span></code></pre>
          </figure>
          <p>
            It nicely dodges indentation problems that plague every other
            language with a similar feature. And, the best thing ever:
            lexically, each line is a separate token. As Zig has only
            line-comments, this means that <code>\n</code> is <em>always</em>
            whitespace. Unlike most other languages, Zig can be correctly lexed
            in a line-by-line manner.
          </p>
          <p>
            Raw strings is perhaps the biggest improvement of Zig over Rust.
            Rust brute-forces the problem with
            <code>r##&#34;&#34;##</code> syntax, which does the required job,
            technically, but suffers from the mentioned problems: indentation is
            messy, nesting quotes requires adjusting hashes, unclosed raw
            literal breaks the following lexical structure completely, and
            rustfmt’s formatting of raw strings tends to be rather ugly. On the
            plus side, this syntax at least cannot be expressed by a
            context-free grammar!
          </p>
        </section>
        <section id="Record-Literals">
          <h2>
            <a href="#Record-Literals">Record Literals </a>
          </h2>
          <p>For the record, Zig takes C syntax (not that C would notice):</p>

          <figure>
            <pre><code><span><span>const</span> p: Point = .{</span>
<span>    .x = <span>1</span>,</span>
<span>    .y = <span>2</span>,</span>
<span>}</span></code></pre>
          </figure>
          <p>
            The <code>.{</code> feels weird! It will make sense by the end of
            the post. Here, I want only to note <code>.x = 1</code>
            part, which matches the assignment syntax <code>obj.x = 1</code>.
            This is great! This means that grepping for
            <code>&#34;.x = &#34;</code> gives you <em>all</em> instances where a field
            is written to. This is hugely valuable: most of usages are reads,
            but, to understand the flow of data, you only need to consider
            writes. Ability to mechanically partition the entire set of usages
            into majority of boring reads and a few interesting writes does
            wonders for code comprehension.
          </p>
        </section>
        <section id="Prefix-Types">
          <h2>
            <a href="#Prefix-Types">Prefix Types </a>
          </h2>
          <p>
            Where Zig departs from C the most is the syntax for types. C uses a
            needlessly confusing spiral rule. In Zig, all types are prefix:
          </p>

          <figure>
            <pre><code><span><span>u32</span>      </span>
<span>[<span>3</span>]<span>u32</span>   </span>
<span>?[<span>3</span>]<span>u32</span>  </span>
<span></span>
<span></span>
<span><span>*</span><span>const</span> ?[<span>3</span>]<span>u32</span></span></code></pre>
          </figure>
          <p>
            While pointer type is prefix, pointer dereference is postfix, which
            is a more natural subject-verb order to read: <span><code>ptr.* = 92;</code></span>
          </p>
        </section>
        <section id="Identifiers">
          <h2>
            <a href="#Identifiers">Identifiers </a>
          </h2>
          <p>
            Zig has general syntax for “raw” identifiers:
            <span><code>@&#34;a name which a space&#34;</code></span>
            It is useful to avoid collisions with keywords, or for exporting a
            symbol whose name is otherwise not a valid Zig identifier. It is a
            bit more to type than Kotlin’s delightful
            <span><code>`a name with a space`</code>,</span> but
            manages to re-use Zig’s syntax for built-ins (<code>@TypeOf</code>)
            and strings.
          </p>
        </section>
        <section id="Functions">
          <h2>
            <a href="#Functions">Functions </a>
          </h2>
          <p>
            Like, Rust, Zig goes for <code>fn foo</code> function declaration
            syntax. This is such a massive improvement over C/Java style
            function declarations: it puts <code>fn</code> token (which is
            completely absent in traditional C family) and function name next to
            each other, which means that textual search for <code>fn name</code>
            allows you to quickly find the function. Then Zig adds a little
            twist. While in Rust we write
          </p>

          <figure>
            <pre><code><span><span>fn</span> <span>add</span>(x: <span>i32</span>, <span>i32</span>) <span>-&gt;</span> <span>i32</span></span></code></pre>
          </figure>
          <p>Zig is</p>

          <figure>
            <pre><code><span><span>fn</span><span> add</span>(x: <span>i32</span>, <span>i32</span>) <span>i32</span></span></code></pre>
          </figure>
          <p>
            The arrow is gone! Now that I’ve used this for some time, I find
            arrow very annoying to type, and adding to the visual noise. Rust
            needs the arrow: Rust has lambdas with an inferred return type, and,
            in a lambda, the return type is optional. So you need some sort of
            an explicit syntax to tell the parser if there is return type:
          </p>

          <figure>
            <pre><code><span>|| expression;</span>
<span>|| <span>-&gt;</span> Type { }</span></code></pre>
          </figure>
          <p>
            And its understandable that lambdas and functions would want to use
            compatible syntax. But Zig doesn’t have lambdas, so it just makes
            the type mandatory. So the main is
          </p>

          <figure>
            <pre><code><span><span>pub</span> <span>fn</span><span> main</span>() <span>void</span> {}</span></code></pre>
          </figure>
          <p>
            Related small thing, but, as name of the type, I think I like <code>void</code> more than <code>()</code>.
          </p>
        </section>
        <section id="Locals">
          <h2>
            <a href="#Locals">Locals </a>
          </h2>
          <p>
            Zig is using <code>const</code> and <code>var</code> for binding
            values to names:
          </p>

          <figure>
            <pre><code><span><span>const</span> mid = lo <span>+</span> <span>@divFloor</span>(hi <span>-</span> lo, <span>2</span>);</span></code></pre>
          </figure>
          <p>
            This is ok, a bit weird after Rust’s, whose <code>const</code> would
            be <code>comptime</code> in Zig, but not really noticeable after
            some months. I do think this particular part is not great, because
            <code>const</code>, the more frequent one, is longer. I think Kotlin
            nails it: <code>val</code>, <code>var</code>, <code>fun</code>. Note
            all three are monosyllable, unlike <code>const</code> and <code>fn</code>! Number of syllables matters more than the number of
            letters!
          </p>
          <p>Like Rust, Zig uses</p>

          <figure>
            <pre><code><span><span>&#39;name&#39;</span> (<span>&#39;:&#39;</span> Type)?</span></code></pre>
          </figure>
          <p>syntax for ascribing types, which is better than</p>

          <figure>
            <pre><code><span>Type <span>&#39;name&#39;</span></span></code></pre>
          </figure>
          <p>
            because optional suffixes are easier to parse visually and
            mechanically than optional prefixes.
          </p>
        </section>
        <section id="Conjunction-Is-Control-Flow">
          <h2>
            <a href="#Conjunction-Is-Control-Flow">Conjunction Is Control Flow
            </a>
          </h2>
          <p>
            Zig doesn’t use <code>&amp;&amp;</code> and <code>||</code> and
            spells the relevant operators as <code>and</code> and <code>or</code>:
          </p>

          <figure>
            <pre><code><span><span>while</span> (count &gt; <span>0</span> <span>and</span> ascii.isWhitespace(buffer[count <span>-</span> <span>1</span>])) {</span></code></pre>
          </figure>
          <p>
            This is easier to type and much easier to read, but there’s also a
            deeper reason why they are not sigils. Zig marks any control flow
            with a keyword. And, because boolean operators short-circuit, they
            <em>are</em> control flow! Treating them as normal binary operator
            leads to an entirely incorrect mental model. For bitwise operations,
            Zig of course uses <code>&amp;</code> and <code>|</code>.
          </p>
        </section>
        <section id="Explicit-return">
          <h2>
            <a href="#Explicit-return">Explicit return </a>
          </h2>
          <p>
            Both Zig and Rust have statements and expressions. Zig is a bit more
            statement oriented, and requires explicit returns:
          </p>

          <figure>
            <pre><code><span><span>fn</span><span> add</span>(x: <span>i32</span>, y: <span>i32</span>) <span>i32</span> {</span>
<span>  <span>return</span> x <span>+</span> y;</span>
<span>}</span></code></pre>
          </figure>
          <p>
            Furthermore, because there are no lambdas, scope of return is always
            clear.
          </p>
          <p>
            Relatedly, the value of a block expression is void. A block is a
            list of statements, and doesn’t have an optional expression at the
            end. This removes the semicolon problem — while Rust rules around
            semicolons are sufficiently clear (until you get to macros), there’s
            some constant mental overhead to getting them right all the time.
            Zig is more uniform and mechanical here.
          </p>
          <p>
            If you need a block that yields a value, Zig supports a general
            syntax for breaking out of a labeled block:
          </p>

          <figure>
            <pre><code><span><span>const</span> header_oldest = blk: {</span>
<span>    <span>var</span> oldest: ?<span>usize</span> = <span>null</span>;</span>
<span>    <span>for</span> (headers.slice, <span>0</span>..) <span>|</span><span>*</span>header, i<span>|</span> {</span>
<span>        <span>switch</span> (Headers.dvc_header_type(header)) {</span>
<span>            .blank =&gt; assert(i &gt; <span>0</span>),</span>
<span>            .valid =&gt; oldest = i,</span>
<span>        }</span>
<span>    }</span>
<span>    <span>break</span> :blk <span>&amp;</span>headers.slice[oldest.?];</span>
<span>};</span></code></pre>
          </figure>
        </section>
        <section id="If">
          <h2>
            <a href="#If">If </a>
          </h2>
          <p>
            Rust makes pedantically correct choice regarding <code>if</code>s:
            braces are mandatory:
          </p>

          <figure>
            <pre><code><span><span>if</span> cond1 {</span>
<span>  case_a</span>
<span>} <span>else</span> {</span>
<span>  <span>if</span> cond2 {</span>
<span>    case_b</span>
<span>  } <span>else</span> {</span>
<span>    case_c</span>
<span>  }</span>
<span>}</span></code></pre>
          </figure>
          <p>
            This removes the dreaded “dangling else” grammatical ambiguity.
            While theoretically nice, it makes
            <code>if</code>-expression one-line feel too heavy. It’s not the
            braces, it’s the whitespace around them:
          </p>

          <figure>
            <pre><code><span>if (a) b else c</span>
<span>if a { b } else { c }</span></code></pre>
          </figure>
          <p>
            But the ternary is important! Exploding a simple choice into
            multi-line condition <em>hurts</em>
            readability. Zig goes with traditional choice of making parentheses
            required and braces optional:
          </p>

          <figure>
            <pre><code><span>  .direction = <span>if</span> (prng.boolean()) .ascending <span>else</span> .descending,</span></code></pre>
          </figure>
          <p>
            By itself, this does create a risk of <code>goto: fail;</code> style
            bugs. But in Zig formatter (non-configurable, user-directed) is a
            part of the compiler, and formatting errors that can mask bugs are
            caught during compilation. For example, <code>1 -2</code> is an
            error due to inconsistent whitespace around the minus sign, which
            signals a plausible mixup of infix and binary minus. No such errors
            are currently produced for incorrect indentation (the value add
            there is relatively little, given <code>zig fmt</code>), but this is
            planned.
          </p>
          <p>
            NB: because Rust requires <code>if</code> branches to be blocks, it
            is forced to make <code>{ expr }</code> synonym with
            <code>(expr)</code>. Otherwise, the ternary <code>if</code> would be
            even more unusable! Syntax design is tricky! Whether you need <code>return</code>s and whether you make <code>()</code> or <code>{}</code> mandatory in ifs are not orthogonal!
          </p>
        </section>
        <section id="Loops">
          <h2>
            <a href="#Loops">Loops </a>
          </h2>
          <p>
            Like Python, Zig allows <code>else</code> on loops. Unlike Python,
            loops are expressions, which leads to a nicely readable imperative
            searches:
          </p>

          <figure>
            <pre><code><span><span>pub</span> <span>const</span> Word = <span>for</span> (.{ <span>u8</span>, <span>u16</span>, <span>u32</span>, <span>u64</span>, <span>u128</span>, <span>u256</span> }) <span>|</span>W<span>|</span> {</span>
<span>    <span>if</span> (<span>@bitSizeOf</span>(W) &gt;= bitset_capacity) <span>break</span> W;</span>
<span>} <span>else</span> <span>unreachable</span>;</span></code></pre>
          </figure>
          <p>
            Zig doesn’t have syntactically-infinite loop like Rust’s <code>loop
              {</code> or Go’s <code>for {</code>. Normally I’d consider that a
            drawback, because these loops produce different control flow,
            affecting reachability analysis in the compiler, and I don’t think
            it’s great to make reachability dependent on condition being visibly
            constant. But! As Zig places <code>comptime</code> semantics front
            and center, and the rules for what is and isn’t a comptime constant
            are a backbone of every feature, “anything equivalent to
            <code>while (true)</code>” becomes sufficiently precise.
            Incidentally, these days I tend to write “infinite” loops as
          </p>

          <figure>
            <pre><code><span><span>for</span> (<span>0</span>..safety_bound) <span>|</span>_<span>|</span> {</span>
<span></span>
<span>} <span>else</span> <span>@panic</span>(<span>&#34;loop safety counter exceeded&#34;</span>);</span></code></pre>
          </figure>
          <p>
            Almost always there is an up-front bound for the number of
            iterations until the break, and its worth asserting this bound,
            because debugging crashes is easier than debugging hangs.
          </p>
          <p>
            <code>for</code>, <code>while</code>, <code>if</code>, <code>switch</code>, and <code>catch</code> all use the same Ruby/Rust
            inspired syntax for naming captured values:
          </p>

          <figure>
            <pre><code><span><span>for</span> (slice) <span>|</span>element<span>|</span> {</span>
<span>  use(element);</span>
<span>}</span>
<span></span>
<span><span>while</span> (iterator.next()) <span>|</span>element<span>|</span> {</span>
<span>  use(element);</span>
<span>}</span></code></pre>
          </figure>
          <p>
            I like how the iterator comes first, and then the name of an item
            follows, logically and syntactically.
          </p>
        </section>
        <section id="Clarity-of-Names">
          <h2>
            <a href="#Clarity-of-Names">Clarity of Names </a>
          </h2>
          <p>
            I have a very strong opinion about variable shadowing. It goes both
            ways: I spent hours debugging code which incorrectly tried to use a
            variable that was shadowed by something else, but I also spent hours
            debugging code that accidentally used a variable that should have
            been shadowed! I really don’t know whether on balance it is better
            to forbid or encourage shadowing!
          </p>
          <p>
            Zig of course forbids shadowing, but what’s curious is that it’s
            just one episode of the large crusade against any complexity in name
            resolution. There’s no “prelude”, if you want to use anything from
            std, you need to import it:
          </p>

          <figure>
            <pre><code><span><span>const</span> std = <span>@import</span>(<span>&#34;std&#34;</span>);</span></code></pre>
          </figure>
          <p>
            There are no glob imports, if you want to use an item from std, you
            need to import it:
          </p>

          <figure>
            <pre><code><span><span>const</span> ArrayList = std.ArrayList;</span></code></pre>
          </figure>
          <p>
            Zig doesn’t have inheritance, mixins, argument-dependent lookup,
            extension functions, implicit or traits, so, if you see <code>x.foo()</code>, that <code>foo</code> is guaranteed to be a boring
            method declared on <code>x</code>
            type. Similarly, while Zig has powerful comptime capabilities, it
            <a href="https://matklad.github.io/2025/04/19/things-zig-comptime-wont-do.html">intentionally disallows</a>
            declaring methods at compile time.
          </p>
          <p>
            Like Rust, Zig used to allow a method and a field to share a name,
            because it actually is syntactically clear enough at the call site
            which is which. But then this feature got removed from Zig.
          </p>
          <p>
            More generally, Zig doesn’t have namespaces. There can be only one
            kind of <code>foo</code> in scope, while Rust allows things like
          </p>

          <figure>
            <pre><code><span><span>struct</span> <span>Point</span> { x: <span>i32</span>, y: <span>i32</span> }</span>
<span><span>fn</span> <span>Point</span>(x: <span>i32</span>, y: <span>i32</span>) <span>-&gt;</span> Point { Point { x, y } }</span></code></pre>
          </figure>
          <p>
            I am astonished at the relative lack of inconvenience in Zig’s
            approach. Turns out that <code>foo.bar.baz</code>
            is all the syntax you’ll ever need for accessing things? For the
            historically inclined, see “The module naming situation” thread in
            the
            <a href="https://github.com/brson/rust-dev-archives">rust mailing list archive</a>
            to learn the story of how rust got its <code>std::vec</code> syntax.
          </p>
        </section>
        <section id="Everything-Is-an-Expression">
          <h2>
            <a href="#Everything-Is-an-Expression">Everything Is an Expression
            </a>
          </h2>
          <p>
            The lack of namespaces touches on the most notable (by its absence)
            feature of Zig syntax, which deeply relates to the most profound
            aspect of Zig’s semantics. Everything is an expression. By which I
            mean, there’s no separate syntactic categories of values, types, and
            patterns. Values, types, and patterns are of course different
            things. And usually in the language grammar it is <em>syntactically</em>
            obvious whether a particular text fragment refers to a type or a
            value:
          </p>

          <figure>
            <pre><code><span><span>let</span> <span>PATTERN</span>: TYPE = VALUE;</span></code></pre>
          </figure>
          <p>
            So the standard way is to have separate syntax families for the
            three categories, which need to be internally unambiguous, but <em>can</em> be ambiguous across the categories because the place in
            the grammar dictates the category: when parsing <code>let</code>,
            everything until <code>:</code> is a pattern, stuff between
            <code>:</code> and <code>=</code> is a type, and after <code>=</code> we have a value.
          </p>
          <p>
            There are two problems here. First, there’s a combinatorial
            explosion of sorts in the syntax, because, while three categories
            describe different things, it turns out that they have the same
            general tree-ish shape.
          </p>
          <p>
            The second problem is that it might be hard to maintain category
            separation in the grammar. Rust
            <em>started</em> with the three categories separated by a bright
            line. But then, changes happen. Originally, Rust only allowed
            <span><code>VALUE = VALUE;</code></span>
            syntax for assignment. But today you can also write
            <span><code>PATTERN = VALUE;</code></span>
            to do unpacking like
            <span><code>(a, b) = (b, a);</code></span>
          </p>
          <p>
            Similarly, the turbofish used to move the parser from the value to
            the type mode, but now const parameters are values that can be found
            in the type position!
          </p>
          <p>
            The alternative is not to pick this fight at all. Rather than trying
            to keep the categories separately in the syntax, use the same
            surface syntax to express all three, and categorize later, during
            semantic analysis. In fact, this is already happens in the <span><code>VALUE = VALUE</code></span>
            example — these are different things! One is a place (lvalue) and
            another is a “true” value (rvalue), but we use the same syntax for
            both.
          </p>
          <p>
            I don’t think such syntactic unification necessarily implies
            semantic unification, but Zig does treat everything uniformly, as a
            value with comptime and runtime behavior (for some values, runtime
            behavior may be missing, for others — comptime):
          </p>

          <figure>
            <pre><code><span><span>const</span> E = <span>enum</span> { a, b };</span>
<span></span>
<span><span>pub</span> <span>fn</span><span> main</span>() <span>void</span> {</span>
<span>    <span>const</span> e: <span>if</span> (<span>true</span>) E <span>else</span> <span>void</span> = .a;</span>
<span>    _ = <span>switch</span> (e) {</span>
<span>        (<span>if</span> (<span>true</span>) .a <span>else</span> .b) =&gt; .a,</span>
<span>        (<span>if</span> (<span>true</span>) .b <span>else</span> .a) =&gt; .b,</span>
<span>    };</span>
<span>}</span></code></pre>
          </figure>
          <p>
            The fact that you can write an <code>if</code> where a type goes is
            occasionally useful. But the fact that simple types look like simple
            values syntactically consistently make the language feel
            significantly less busy.
          </p>
        </section>
        <section id="Generics">
          <h2>
            <a href="#Generics">Generics </a>
          </h2>
          <p>
            As a special case of everything being an expression, instances of
            generic types look like this:
            <span><code>ArrayList(u32)</code></span>
          </p>
          <p>
            Just a function call! Though, there’s some resistance to trickery
            involved to make this work. Usually, languages rely on type
            inference to allow eliding generic arguments. That in turn requires
            making argument <em>syntax</em> optional, and that in turn leads to
            separating generic and non-generic arguments into separate parameter
            lists and some introducer sigil for generics, like <code>::&lt;&gt;</code> or
            <code>!()</code>.
          </p>
          <p>
            Zig solves this syntactic challenge in the most brute-force way
            possible. Generic parameters are never inferred, if a function takes
            3 comptime arguments and 2 runtime arguments, it will always be
            called with 5 arguments syntactically. Like with the (absence of)
            importing flourishes, a reasonable reaction would be “wait, does
            this mean that I’ll have to specify the types all the time?” And,
            like with import, in practice this is a non-issue. The trick are
            comptime closures. Consider a generic
            <code>ArrayList</code>:
          </p>

          <figure>
            <pre><code><span><span>fn</span><span> ArrayListType</span>(<span>comptime</span> T: <span>type</span>) <span>type</span> {</span>
<span>    <span>return</span> <span>struct</span> {</span>
<span>        <span>const</span> ArrayList = <span>@This</span>();</span>
<span></span>
<span>        <span>fn</span><span> init</span>(gpa: Allocator) ArrayList {}</span>
<span>        <span>fn</span><span> deinit</span>(list: <span>*</span>ArrayList, gpa: Allocator) <span>void</span> {}</span>
<span>        <span>fn</span><span> push</span>(list: <span>*</span>ArrayList, item: T) <span>!</span><span>void</span> {}</span>
<span>    };</span>
<span>}</span>
<span></span>
<span><span>fn</span><span> usage</span>(gpa: Allocator) <span>!</span><span>void</span> {</span>
<span>    <span>var</span> xs: ArrayListType(<span>u32</span>) = .init(gpa);</span>
<span>    <span>defer</span> xs.deinit(gpa);</span>
<span></span>
<span>    <span>try</span> xs.push(<span>92</span>);</span>
<span>}</span></code></pre>
          </figure>
          <p>
            We have to specify type <code>T</code> when creating an instance of
            an <code>ArrayList</code>. But subsequently, when we are <em>using</em> the array list, we don’t have to specify the type
            parameter again, because the type of
            <code>xs</code> variable already closes over <code>T</code>. This is
            the major truth of object-orienting programming, the truth so
            profound that no one even notices it: in real code, 90% of functions
            are happiest as (non-virtual) methods. And, because of that, the
            annotation burden in real-world Zig programs is low.
          </p>
        </section>
        <section id="Declaration-Literals">
          <h2>
            <a href="#Declaration-Literals">Declaration Literals </a>
          </h2>
          <p>
            While Zig doesn’t have Hindley-Milner constraint-based type
            inference, it relies heavily on one specific way to propagate types.
            Let’s revisit the first <code>comptime_int</code> example:
          </p>

          <figure>
            <pre><code><span><span>const</span> x = <span>if</span> (condition()) <span>1</span> <span>else</span> <span>2</span>;</span></code></pre>
          </figure>
          <p>
            This doesn’t compile: <code>1</code> and <code>2</code> are
            different <code>comptime</code> values, we can’t select between two
            at runtime because they are different. We need to coerce the
            constants to a specific runtime type:
          </p>

          <figure>
            <pre><code><span><span>const</span> x: <span>u32</span> = <span>if</span> (condition()) <span>1</span> <span>else</span> <span>2</span>;</span>
<span></span>
<span><span>const</span> x = <span>@coerceTo</span>(</span>
<span>  <span>u32</span>,</span>
<span>  <span>if</span> (condition()) <span>1</span> <span>else</span> <span>2</span>,</span>
<span>);</span></code></pre>
          </figure>
          <p>
            But this doesn’t kick the can sufficiently far enough and
            essentially reproduces the <code>if</code> with two incompatible
            branches. We need to sink coercion down the branches:
          </p>

          <figure>
            <pre><code><span><span>const</span> x = <span>if</span> (condition())</span>
<span>    <span>@coerceTo</span>(<span>u32</span>, <span>1</span>)</span>
<span><span>else</span></span>
<span>    <span>@coerceTo</span>(<span>u32</span>, <span>2</span>);</span></code></pre>
          </figure>
          <p>
            And that’s exactly how Zig’s “Result Location Semantics” works. Type
            “inference” runs a simple left-to-right tree-walking algorithm,
            which resembles interpreter’s <code>eval</code>. In fact, <code>eval</code> is
            <em>exactly</em> what happens. Zig is not a compiler, it is an
            interpreter. When <code>zig</code> evaluates an expression, it gets:
          </p>
          <ul>
            <li>
              expression’s type (as a Zig value),
            </li>
            <li>
              expression’s value (if it can be evaluated at comptime),
            </li>
            <li>
              code to compute expression’s value otherwise.
            </li>
          </ul>

          <figure>
            <pre><code><span>eval(&#34;1 + 2&#34;) =</span>
<span>  3</span>
<span></span>
<span>eval(&#34;f() + g()&#34;) =</span>
<span>  $1 = call &#39;f&#39;</span>
<span>  $2 = call &#39;g&#39;</span>
<span>  $3 = add $1 $2</span>
<span></span>
<span>eval(&#34;f() + 2&#34;) =</span>
<span>  $1 = call &#39;f&#39;</span>
<span>  $2 = add_immediate $1 2</span></code></pre>
          </figure>
          <p>When interpreting code like</p>

          <figure>
            <pre><code><span>obj.field = if (condition()) 1 else 2;</span></code></pre>
          </figure>
          <p>
            the interpreter passes the result location (<code>obj.field</code>)
            and type down the tree of subexpressions. If branches store result
            directly into object field (there’s a <code>store</code> inside each
            branch, as opposed to one <code>store</code> after the <code>if</code>), and each coerces its comptime constant to the
            appropriate runtime type of the result.
          </p>
          <p>
            This mechanism enables concise <code>.variant</code> syntax for
            specifying enums:
          </p>

          <figure>
            <pre><code><span><span>const</span> E = <span>enum</span> { a, b };</span>
<span></span>
<span><span>fn</span><span> example</span>(e: E) <span>u32</span> {</span>
<span>    <span>return</span> <span>switch</span> (e) {</span>
<span>        .a =&gt; <span>1</span>,</span>
<span>        (<span>if</span> (<span>true</span>) .b <span>else</span> .a) =&gt; <span>2</span>,</span>
<span>    };</span>
<span>}</span></code></pre>
          </figure>
          <p>
            When <code>zig</code> evaluates the switch, it first evaluates the
            scrutinee, and realizes that it has type
            <code>E</code>. When evaluating <code>switch</code> arm, it sets
            result type to <code>E</code> for the condition, and a literal <code>.a</code>
            gets coerced to <code>E</code>. The same happens for the second arm,
            where result type further sinks down the
            <code>if</code>.
          </p>
          <p>
            Result type semantics also explains the leading dot in the record
            literal syntax:
          </p>

          <figure>
            <pre><code><span><span>const</span> p: Point = .{</span>
<span>    .x = <span>1</span>,</span>
<span>    .y = <span>2</span>,</span>
<span>};</span></code></pre>
          </figure>
          <p>
            Syntactically, we just want to disambiguate records from blocks.
            But, semantically, we want to coerce the literal to whatever type we
            want to get out of this expression. In Zig, <code>.whatever</code>
            is a shorthand for <code>@ResultType().whatever</code>.
          </p>
          <p>
            I must confess that <code>.{}</code> did weird me out a lot at first
            during <em>writing</em> code (I don’t mind reading the dot). It’s
            not the easiest thing to type! But that was fixed once I added <code>..</code> snippet, expanding to <code>.{$0}</code>.
          </p>
          <p>
            The benefits to lightweight record literal syntax are huge, as they
            allow for some pretty nice APIs. In particular, you get named and
            default arguments for free:
          </p>

          <figure>
            <pre><code><span><span>fn</span><span> exec</span>(argv: []<span>const</span> <span>u8</span>, options: <span>struct</span> {</span>
<span>    working_directory: ?[]<span>const</span> <span>u8</span> = <span>null</span></span>
<span>}) <span>!</span><span>void</span> {</span>
<span>    </span>
<span>}</span>
<span></span>
<span><span>fn</span><span> usage</span>() <span>!</span><span>void</span> {</span>
<span>    <span>try</span> exec(<span>&amp;</span>.{ <span>&#34;git&#34;</span>, <span>&#34;status&#34;</span>}, .{});</span>
<span></span>
<span>    <span>try</span> exec(<span>&amp;</span>.{ <span>&#34;git&#34;</span>, <span>&#34;status&#34;</span>}, .{</span>
<span>        .working_directory = <span>&#34;./src&#34;</span>,</span>
<span>    });</span>
<span>}</span></code></pre>
          </figure>
          <p>
            I don’t really miss the absence of named arguments in Rust, you can
            always design APIs without them. But they are free in Zig, so I use
            them liberally. Syntax wise, we get two features (calling functions
            and initializing objects) for the price of one!
          </p>
        </section>
        <section id="Built-ins">
          <h2>
            <a href="#Built-ins">Built-ins </a>
          </h2>
          <p>
            Finally, the thing that weirds out some people when they see Zig
            code, and makes others reconsider their choice GitHub handles, even
            when they haven’t seen any Zig: <code>@divExact</code> syntax for
            built-in functions.
          </p>
          <p>
            Every language needs to glue “userspace” code with primitive
            operations supported by the compiler. Usually, the gluing is
            achieved by making the standard library privileged and allowing it
            to define intrinsic functions without bodies, or by adding ad-hoc
            operators directly to the language (like Rust’s <code>as</code>).
            And Zig does have a fair amount of operators, like <code>+</code> or
            <code>orelse</code>. But the release valve for a lot of
            functionality are built-in functions in distinct syntactic
            namespace, so Zig separates out <code>@bitCast</code>, <code>@addrSpaceCast</code>, <code>@alignCast</code>, <code>@constCast</code>, <code>@ptrCast</code>, <code>@intCast</code>,
            <code>@floatCast</code>, <code>@volatileCast</code>, <code>@ptrFromInt</code>, and <code>@intFromPtr</code>. There’s no need
            to overload casting when you can give each variant a name.
          </p>
          <p>
            There’s also <span><code>@as(i32, 92)</code></span>
            for type ascription. The types goes first, because the mechanism
            here is result type semantics: <code>@as</code> evaluates the first
            argument as a type, and then uses that as the type for the second
            argument. Curiously, <code>@as</code> I think actually can be
            implemented in the userspace:
          </p>

          <figure>
            <pre><code><span><span>fn</span><span> as</span>(<span>comptime</span> T: <span>type</span>, value: T) T {</span>
<span>    <span>return</span> value;</span>
<span>}</span></code></pre>
          </figure>
          <p>
            In Zig, a type of function parameter may depend on values of
            preceding (comptime) ones!
          </p>
          <p>
            My favorite builtin is <code>@import()</code>. First, it’s the most
            obvious way to import code:
            <span><code>const foo =
                @import(&#34;./foo.zig&#34;)</code></span>
            Its crystal clear where the file comes from.
          </p>
          <p>
            But, second, it is an instance of reverse syntax sugar. You see,
            import isn’t really a function. You can’t do
          </p>

          <figure>
            <pre><code><span><span>const</span> name = <span>&#34;./foo.zig&#34;</span>;</span>
<span><span>const</span> foo = <span>@import</span>(name);</span></code></pre>
          </figure>
          <p>
            The argument of <code>@import</code> has to be a string,
            syntactically. It really is
            <span><code>import &#34;./path.zig&#34;</code></span>
            syntax, except that the function-call form is re-used, because it
            already has the right shape.
          </p>
          <hr/>
          <p>
            So, this is it. Just a bunch of silly syntactical decisions, which
            add up to a language which is positively enjoyable to read. As for
            big lessons, obviously, the less features your language has, the
            less syntax you’ll need. And less syntax is generally good, because
            varied syntactic constructs tend to step on each other toes.
            Languages are not combinations of orthogonal aspects. Features tug
            and pull the language in different directions and their combinations
            might turn to be miraculous features in their own right, or might
            drag the language down.
          </p>
          <p>
            Even with a small feature-set fixed, there’s still a lot of work to
            pick a good concrete syntax: unambiguous to parse, useful to grep,
            easy to read and not to painful to write. A smart thing is of course
            to steal and borrow solutions from other languages, not because of
            familiarity, but because the ruthless natural selection tends to
            weed out poor ideas. But there’s a lot of inertia in languages, so
            there’s no need to fear innovation. If an odd-looking syntax is
            actually good, people will take to it.
          </p>
          <p>
            Is there anything about Zig’s syntax I don’t like? I thought no,
            when starting this post. But in the process of writing it I did
            discover one form that annoys me. It is the while with the increment
            loop:
          </p>

          <figure>
            <pre><code><span><span>var</span> i: <span>u32</span> = <span>0</span>;</span>
<span><span>while</span> (i &lt; <span>10</span>) : (i<span>+=</span><span>1</span>) {</span>
<span>    print(<span>&#34;{d}&#34;</span>, .{i});</span>
<span>}</span></code></pre>
          </figure>
          <p>
            This is two-thirds of a C-style <code>for</code> loop (without the
            declarator), and it sucks for the same reason: control flow jumps
            all other the place and is unrelated to the source code order. We go
            from condition, to the body, to the increment. But in the source
            order the increment is between the condition and the body. In Zig,
            this loop sucks for one additional reason: that <code>:</code>
            separating the increment I think is the single example of control
            flow in Zig that is expressed by a sigil, rather than a keyword.
          </p>
          <p>
            This form used to be rather important, as Zig lacked a counting
            loop. It has
            <span><code>for(0..10) |i|</code></span>
            form now, so I am tempted to call the while-with-increment
            redundant.
          </p>
          <p>Annoyingly,</p>

          <figure>
            <pre><code><span><span>while</span> (condition) {</span>
<span>    <span>defer</span> increment;</span>
<span></span>
<span>    body</span>
<span>}</span></code></pre>
          </figure>
          <p>is <em>almost</em> equivalent to</p>

          <figure>
            <pre><code><span><span>while</span> (condition) : (increment) {</span>
<span>  body</span>
<span>}</span></code></pre>
          </figure>
          <p>
            But not exactly: if <code>body</code> contains a <code>return</code>, <code>break</code> or <code>try</code>, the <code>defer</code> version would run the
            <code>increment</code> one extra time, which is useless and might be
            outright buggy. Oh well.
          </p>
        </section>
      </article>
    </div></div>
  </body>
</html>
