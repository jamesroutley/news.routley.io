<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://googleprojectzero.blogspot.com/2021/12/this-shouldnt-have-happened.html">Original</a>
    <h1>This shouldn&#39;t have happened: A vulnerability postmortem</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-7868790017880077590" itemprop="description articleBody">
<div>
 <p id="h.hkm9sn4jh6p1"><span>Posted by Tavis Ormandy, Project Zero</span></p>
 
 
 <p><span>This is an unusual blog post. I normally write posts to highlight some hidden attack surface or interesting complex vulnerability class. This time, I want to talk about a vulnerability that is neither of those things. The striking thing about this vulnerability is just how simple it is. This should have been caught earlier, and I want to explore why that didn’t happen.</span></p>
 
 <p><span>In 2021, all good bugs need a catchy name, so I’m calling this one “BigSig”.</span></p>
 
 <p><span>First, let’s take a look at the bug, I’ll explain how I found it and then try to understand why we missed it for so long.</span></p>
 
 
 <p><span><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Overview">Network Security Services</a></span><span> (NSS) is Mozilla&#39;s widely used, cross-platform cryptography library. </span><span>When you verify an ASN.1 encoded digital signature</span><span>, NSS will create a </span><span><a href="https://searchfox.org/mozilla-central/rev/f8576fec48d866c5f988baaf1fa8d2f8cce2a82f/security/nss/lib/cryptohi/secvfy.c#120">VFYContext</a></span><span> structure to store the necessary data. This includes things like the public key, the hash algorithm, and the signature itself.</span></p>
 <table><tbody><tr><td colspan="1" rowspan="1">
 <p><span>struct</span><span> </span><span>VFYContextStr</span><span> {</span></p>
 <p><span>   </span><span>SECOidTag</span><span> hashAlg; </span><span>/* the hash algorithm */</span></p>
 <p><span>   </span><span>SECKEYPublicKey</span><span> *key;</span></p>
 <p><span>   </span><span>union</span><span> {</span></p>
 <p><span>       </span><span>unsigned</span><span> </span><span>char</span><span> buffer[1];</span></p>
 <p><span>       </span><span>unsigned</span><span> </span><span>char</span><span> dsasig[DSA_MAX_SIGNATURE_LEN];</span></p>
 <p><span>       </span><span>unsigned</span><span> </span><span>char</span><span> ecdsasig[2 * MAX_ECKEY_LEN];</span></p>
 <p><span>       </span><span>unsigned</span><span> </span><span>char</span><span> rsasig[(RSA_MAX_MODULUS_BITS + 7) / 8];</span></p>
 <p><span>   } u;</span></p>
 <p><span>   </span><span>unsigned</span><span> </span><span>int</span><span> pkcs1RSADigestInfoLen;</span></p>
 <p><span>   </span><span>unsigned</span><span> </span><span>char</span><span> *pkcs1RSADigestInfo;</span></p>
 <p><span>   </span><span>void</span><span> *wincx;</span></p>
 <p><span>   </span><span>void</span><span> *hashcx;</span></p>
 <p><span>   </span><span>const</span><span> </span><span>SECHashObject</span><span> *</span><span>hashobj</span><span>;</span></p>
 <p><span>   </span><span>SECOidTag</span><span> encAlg;    </span><span>/* enc alg */</span></p>
 <p><span>   </span><span>PRBool</span><span> hasSignature;</span></p>
 <p><span>   </span><span>SECItem</span><span> *params;</span></p>
 <p><span>};</span></p></td></tr><tr><td colspan="1" rowspan="1">
 <p id="h.scw51sqnutu4"><span>Fig 1</span><span>. The </span><span>VFYContext</span><span> structure from NSS.</span></p></td></tr></tbody></table>
 <p><span></span><span><a href="https://searchfox.org/mozilla-central/rev/f8576fec48d866c5f988baaf1fa8d2f8cce2a82f/security/nss/lib/freebl/blapit.h#139">2048 bytes</a></span><span>.</span><span> That’s 16384 bits, large enough to accommodate signatures from even the most ridiculously oversized keys.</span></p>
 
 <p><span>Okay, but what happens if you just....make a signature that’s bigger than that?</span></p>
 
 <p><span>Well, it turns out the answer is memory corruption. Yes, really.</span></p>
 
 
 <p><span>The bug is simple to reproduce and affects multiple algorithms. The easiest to demonstrate is RSA-PSS. In fact, just these three commands work:</span></p>
 <table><tbody><tr><td colspan="1" rowspan="1">
 <p><span># We need 16384 bits to fill the buffer, then 32 + 64 + 64 + 64 bits to overflow to </span><span>hashobj</span><span>, </span></p>
 <p><span># which contains function pointers (bigger would work too, but takes longer to generate).</span></p>
 <p><span>$ openssl </span><span>genpkey</span><span> -algorithm rsa-pss -pkeyopt rsa_keygen_bits:$((16384 + 32 + 64 + 64 + 64)) -pkeyopt rsa_keygen_primes:5 -out </span><span>bigsig.key</span></p>
 <p><span># Generate a self-signed certificate from that key</span></p>
 <p><span>$ openssl req -x509 -new -key bigsig.key -subj &#34;/CN=BigSig&#34; -sha256 -out bigsig.cer</span></p>
 <p><span># Verify it with NSS...</span></p>
 <p><span>$ </span><span>vfychain</span><span> -a bigsig.cer </span></p>
 <p><span>Segmentation fault</span></p></td></tr><tr><td colspan="1" rowspan="1">
 <p id="h.48dytsqrxb61"><span>Fig 2</span><span>. Reproducing the BigSig vulnerability in three easy commands.</span></p></td></tr></tbody></table>
 
 <p><span>The actual code that does the corruption varies based on the algorithm; </span><span><a href="https://searchfox.org/mozilla-central/rev/f8576fec48d866c5f988baaf1fa8d2f8cce2a82f/security/nss/lib/cryptohi/secvfy.c#477">here is the code</a></span><span> for RSA-PSS. The bug is that there is simply no bounds checking at all; </span><span>sig</span><span> and </span><span>key</span><span> are  arbitrary-length, attacker-controlled blobs, and </span><span>cx-&gt;u</span><span> is a fixed-size buffer.</span></p>
 <table><tbody><tr><td colspan="1" rowspan="1">
 <p><span>           </span><span>case</span><span> </span><span>rsaPssKey</span><span>:</span></p>
 <p><span>               sigLen = SECKEY_SignatureLen(key);</span></p>
 <p><span>               </span><span>if</span><span> (sigLen == 0) {</span></p>
 <p><span>                   </span><span>/* error set by SECKEY_SignatureLen */</span></p>
 <p><span>                   rv = SECFailure;</span></p>
 <p><span>                   </span><span>break</span><span>;</span></p>
 <p><span>               }</span></p>
 
 <p><span>               </span><span>if</span><span> (sig-&gt;len != sigLen) {</span></p>
 <p><span>                   PORT_SetError(SEC_ERROR_BAD_SIGNATURE);</span></p>
 <p><span>                   rv = SECFailure;</span></p>
 <p><span>                   </span><span>break</span><span>;</span></p>
 <p><span>               }</span></p>
 
 <p><span>               PORT_Memcpy(cx-&gt;u.buffer, sig-&gt;data, sigLen);</span></p>
 <p><span>               </span><span>break</span><span>;</span></p></td></tr><tr><td colspan="1" rowspan="1">
 <p id="h.b383i7m17o2u"><span>Fig 3</span><span>. The signature size must match the size of the key, but there are no other limitations. </span><span>cx-&gt;u</span><span> is a fixed-size buffer, and </span><span>sig</span><span> is an arbitrary-length, attacker-controlled blob.</span></p></td></tr></tbody></table>
 
 
 <p><span>I think this vulnerability raises a few immediate questions:</span></p>
 <ul><li><span>Was this a recent code change or regression that hadn’t been around long enough to be discovered? </span><span>No</span><span>, the original code was </span><span><a href="https://hg.mozilla.org/projects/nss/annotate/41f5eb9e5df23951883ba3243f3ae51550663d77/security/nss/lib/cryptohi/secvfy.c#l158">checked in</a></span><span> with ECC support on the 17th October 2003, but wasn&#39;t exploitable until some </span><span><a href="https://hg.mozilla.org/projects/nss/diff/10393/security/nss/lib/cryptohi/seckey.c#l1.63">refactoring</a></span><span> in June 2012. In 2017, RSA-PSS support was </span><span><a href="https://hg.mozilla.org/projects/nss/rev/84e886ea090e36c69df58a71665a97bd25c62d02">added</a></span><span> and made the same error.</span></li></ul>
 <ul><li><span>Does this bug require a long time to generate a key that triggers the bug? </span><span>No</span><span>, the example above generates a real key and signature, but it can just be garbage as the overflow happens before the signature check. A few kilobytes of </span><span>A</span><span>’s works just fine.</span></li></ul>
 <ul><li><span>Does reaching the vulnerable code require some complicated state that fuzzers and static analyzers would have difficulty synthesizing, like hashes or checksums? </span><span>No</span><span>, it has to </span><span>be well-formed</span><span> DER, that’s about it.</span></li></ul>
 <ul><li><span>Is this an uncommon code path? </span><span>No</span><span>, Firefox does not use this code path for RSA-PSS signatures, but the default entrypoint for certificate verification in NSS, </span><span>CERT_VerifyCertificate(),</span><span> is vulnerable.</span></li></ul>
 <ul><li><span>Is it specific to the RSA-PSS algorithm? </span><span>No</span><span>, it also affects DSA signatures.</span></li></ul>
 <ul><li><span>Is it unexploitable, or otherwise limited impact? </span><span>No</span><span>, the </span><span>hashobj</span><span> </span><span>member can be clobbered. That object contains </span><span><a href="https://searchfox.org/mozilla-central/rev/41a8c58186206985c0d70d3d460c04ac844d11d0/security/nss/lib/util/hasht.h#45">function pointers</a></span><span>,</span><span> which are used immediately.</span></li></ul>
 
 <p><span>This wasn’t a process failure, the vendor did everything right</span><span>. Mozilla has a mature, world-class security team. They pioneered </span><span><a href="https://www.mozilla.org/en-US/security/bug-bounty/">bug bounties</a></span><span>,</span><span> </span><span>invest</span><span> in </span><span><a href="https://research.mozilla.org/rust/">memory safety</a></span><span>, fuzzing and </span><span><a href="https://coverage.moz.tools/">test coverage</a></span><span>.</span></p>
 
 <p><span>NSS was one of the very first projects included with </span><span><a href="https://google.github.io/oss-fuzz/">oss-fuzz</a></span><span>, it was officially supported since at least </span><span><a href="https://github.com/google/oss-fuzz/commit/3d325bf20f0b09961b6c7de34aa4da0d16cfa67d">October 2014</a></span><span>. Mozilla also fuzz NSS themselves with </span><span><a href="https://llvm.org/docs/LibFuzzer.html">libFuzzer</a></span><span>, and have contributed their own </span><span><a href="https://searchfox.org/mozilla-central/source/security/nss/fuzz/asn1_mutators.cc">mutator</a></span><span> collection and distilled </span><span><a href="https://github.com/mozilla/nss-fuzzing-corpus">coverage corpus</a></span><span>. There is an extensive testsuite, and nightly </span><span><a href="https://firefox-source-docs.mozilla.org/tools/sanitizer/asan.html">ASAN</a></span><span> builds.</span></p>
 
 <p><span>I&#39;m generally skeptical of static analysis, but this seems like a simple missing bounds check that should be easy to find. Coverity has been monitoring NSS since at least </span><span><a href="https://scan.coverity.com/projects/nss">December 2008</a></span><span>, and also </span><span>appears</span><span> to have failed to discover this.</span></p>
 
 <p><span>Until 2015, Google Chrome </span><span><a href="https://chromium.googlesource.com/chromium/third_party/nss/+/refs/heads/master/README.chromium">used</a></span><span> NSS, and maintained their own testsuite and fuzzing infrastructure independent of Mozilla. Today, Chrome platforms use </span><span><a href="https://boringssl.googlesource.com/boringssl/">BoringSSL</a></span><span>, but the NSS port is still maintained.</span></p>
 <ul><li><span>Did Mozilla have good test coverage for the vulnerable areas? </span><span><a href="https://coverage.moz.tools/#revision=latest&amp;path=security%2Fnss%2Flib%2Fcryptohi%2Fsecvfy.c&amp;suite=gtest&amp;view=file&amp;line=201">YES</a></span><span>.</span></li><li><span>Did Mozilla/chrome/oss-fuzz have relevant inputs in their fuzz corpus? </span><span><a href="https://storage.googleapis.com/oss-fuzz-coverage/nss/reports/20211027/linux/src/nss/lib/cryptohi/secvfy.c.html#L201">YES</a></span><span>.</span></li><li><span>Is there a mutator capable of extending </span><span>ASN1_ITEM</span><span>s? </span><span><a href="https://codereview.chromium.org/1677803002/patch/180001/190008">YES</a></span><span>.</span></li><li><span>Is this an </span><span><a href="https://github.com/google/sanitizers/wiki/AddressSanitizerIntraObjectOverflow">intra-object overflow</a></span><span>, or other form of corruption that ASAN would have difficulty detecting? NO, it&#39;s a textbook buffer overflow that ASAN can easily detect.</span></li></ul>
 
 
 <p><span>I&#39;ve been experimenting with alternative methods for measuring code coverage, to see if any have any practical use in fuzzing. The fuzzer that discovered this vulnerability used a combination of two approaches, stack coverage and object isolation.</span></p>
 <h2 id="h.j6f1q7cn6h69"><span>Stack Coverage</span></h2>
 
 <p><span>The most common method of measuring code coverage is block coverage, or </span><span><a href="https://clang.llvm.org/docs/SanitizerCoverage.html#edge-coverage">edge coverage</a></span><span> when source code is available. I’ve been curious if that is always sufficient. For example, consider a simple dispatch table with a combination of trusted and untrusted parameters, as in </span><span>Fig 4</span><span>.</span></p>
 <table><tbody><tr><td colspan="1" rowspan="1">
 <p><span>#include &lt;stdio.h&gt;</span></p>
 <p><span>#include &lt;string.h&gt;</span></p>
 <p><span>#include &lt;limits.h&gt;</span></p>
 
 <p><span>static</span><span> </span><span>char</span><span> buf</span><span>[</span><span>128</span><span>]</span><span>;</span></p>
 
 <p><span>void</span><span> cmd_handler_foo</span><span>(</span><span>int</span><span> a</span><span>,</span><span> </span><span>size_t</span><span> b</span><span>)</span><span> </span><span>{</span><span> </span><span>memset</span><span>(</span><span>buf</span><span>,</span><span> a</span><span>,</span><span> b</span><span>)</span><span>;</span><span> </span><span>}</span></p>
 <p><span>void</span><span> cmd_handler_bar</span><span>(</span><span>int</span><span> a</span><span>,</span><span> </span><span>size_t</span><span> b</span><span>)</span><span> </span><span>{</span><span> cmd_handler_foo</span><span>(</span><span>&#39;A&#39;</span><span>,</span><span> </span><span>sizeof</span><span> buf</span><span>)</span><span>;</span><span> </span><span>}</span></p>
 <p><span>void</span><span> cmd_handler_baz</span><span>(</span><span>int</span><span> a</span><span>,</span><span> </span><span>size_t</span><span> b</span><span>)</span><span> </span><span>{</span><span> cmd_handler_bar</span><span>(</span><span>a</span><span>,</span><span> </span><span>sizeof</span><span> buf</span><span>)</span><span>;</span><span> </span><span>}</span></p>
 
 <p><span>typedef</span><span> </span><span>void</span><span> </span><span>(</span><span>*</span><span> dispatch_t</span><span>)(</span><span>int</span><span>,</span><span> </span><span>size_t</span><span>)</span><span>;</span></p>
 
 <p><span>dispatch_t handlers</span><span>[</span><span>UCHAR_MAX</span><span>]</span><span> </span><span>=</span><span> </span><span>{</span></p>
 <p><span>    cmd_handler_foo</span><span>,</span></p>
 <p><span>    cmd_handler_bar</span><span>,</span></p>
 <p><span>    cmd_handler_baz</span><span>,</span></p>
 <p><span>}</span><span>;</span></p>
 
 <p><span>int</span><span> main</span><span>(</span><span>int</span><span> argc</span><span>,</span><span> </span><span>char</span><span> </span><span>**</span><span>argv</span><span>)</span></p>
 <p><span>{</span></p>
 <p><span>    </span><span>int</span><span> cmd</span><span>;</span></p>
 
 <p><span>    </span><span>while</span><span> </span><span>((</span><span>cmd </span><span>=</span><span> </span><span>getchar</span><span>())</span><span> </span><span>!=</span><span> EOF</span><span>)</span><span> </span><span>{</span></p>
 <p><span>        </span><span>if</span><span> </span><span>(</span><span>handlers</span><span>[</span><span>cmd</span><span>])</span><span> </span><span>{</span></p>
 <p><span>            handlers</span><span>[</span><span>cmd</span><span>](</span><span>getchar</span><span>()</span><span>,</span><span> </span><span>getchar</span><span>())</span><span>;</span></p>
 <p><span>        </span><span>}</span></p>
 <p><span>    </span><span>}</span></p>
 <p><span>}</span></p></td></tr><tr><td colspan="1" rowspan="1">
 <p id="h.9a31y6u3z63v"><span>Fig 4.</span><span> The coverage </span><span>of command</span><span> </span><span>bar</span><span> is a superset of command </span><span>foo</span><span>, so an input containing the latter would be discarded during corpus minimization. There is a vulnerability unreachable via command </span><span>bar </span><span>that might never be discovered. Stack coverage would correctly keep both inputs.</span><sup><a href="#ftnt1" id="ftnt_ref1" name="ftnt_ref1">[1]</a></sup></p></td></tr></tbody></table>
 
 
 <p><span>To solve this problem, I’ve been experimenting with monitoring the call stack during execution.</span></p>
 
 <p><span>The naive implementation is too slow to be practical, but after a lot of optimization I had come up with a library that was fast enough to be integrated into coverage-guided fuzzing, and was testing how it performed with NSS and other libraries.</span></p>
 <h2 id="h.hx3w7e9emdvh"><span>Object Isolation</span></h2>
 
 <p><span>Many data types are constructed from smaller records. PNG files are made of chunks, PDF files are made of streams, ELF files are made of sections, and X.509 certificates are made of ASN.1 TLV items. If a fuzzer has some understanding of the underlying format, it can isolate these records and extract the one(s) causing some new stack trace to be found.</span></p>
 
 <p><span>The fuzzer I was using is able to isolate and extract interesting new ASN.1 OIDs, SEQUENCEs, INTEGERs, and so on. Once extracted, it can then randomly combine or insert them into template data. This isn’t really a new idea, but is a new implementation. I&#39;m planning to open source this code in the future.</span></p>
 <h2 id="h.eyoyd5te8xd4"><span>Do these approaches work?</span></h2>
 
 <p><span>I wish that I could say that discovering this bug validates my ideas, but I’m not sure it does. I was doing some moderately novel fuzzing, but I see no reason this bug couldn’t have been found earlier with even rudimentary fuzzing techniques.</span></p>
 <h2 id="h.gjjikaq7urz2"><span>Lessons Learned</span></h2>
 
 <p><span>How did extensive, customized fuzzing with impressive coverage metrics fail to discover this bug?</span></p>
 <h3 id="h.jjxdnfbzkeky"><span>What went wrong</span></h3>
 <h4 id="h.tq5bofk5duby"><span>Issue #1 </span><span>Missing end-to-end testing</span><span>.</span></h4>
 
 <p><span>NSS is a </span><span><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/NSS_API_Guidelines">modular</a></span><span> library. This layered design is reflected in the </span><span><a href="https://searchfox.org/nss/source/fuzz/">fuzzing</a></span><span> approach, as each component is fuzzed independently. For example, the </span><span><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/NSS_Tech_Notes/nss_tech_note1#how_to_use_the_nss_asn.1_and_quickder_decoders">QuickDER</a></span><span> decoder is tested </span><span><a href="https://searchfox.org/nss/source/fuzz/quickder_target.cc">extensively</a></span><span>, but the fuzzer simply </span><span><a href="https://searchfox.org/nss/rev/5f2fa238b58c9158a52c0681ca2a67958a353082/fuzz/quickder_target.cc#72">creates and discards</a></span><span> objects and never uses them.</span></p>
 
 <table><tbody><tr><td colspan="1" rowspan="1">
 <p><span>extern</span><span> </span><span>&#34;C&#34;</span><span> </span><span>int</span><span> LLVMFuzzerTestOneInput(</span><span>const</span><span> uint8_t *Data, size_t Size) {</span></p>
 <p><span> </span><span>char</span><span> *dest[2048];</span></p>
 
 <p><span> </span><span>for</span><span> (</span><span>auto</span><span> tpl : templates) {</span></p>
 <p><span>   PORTCheapArenaPool pool;</span></p>
 <p><span>   SECItem buf = {siBuffer, </span><span>const_cast</span><span>&lt;</span><span>unsigned</span><span> </span><span>char</span><span> *&gt;(Data),</span></p>
 <p><span>                  </span><span>static_cast</span><span>&lt;</span><span>unsigned</span><span> </span><span>int</span><span>&gt;(Size)};</span></p>
 
 <p><span>   PORT_InitCheapArena(&amp;pool, DER_DEFAULT_CHUNKSIZE);</span></p>
 <p><span>   (</span><span>void</span><span>)SEC_QuickDERDecodeItem(&amp;pool.arena, dest, tpl, &amp;buf);</span></p>
 <p><span>   PORT_DestroyCheapArena(&amp;pool);</span></p>
 <p><span> }</span></p></td></tr><tr><td colspan="1" rowspan="1">
 <p id="h.9rchnmg47ypy"><span>Fig 5.</span><span> The QuickDER fuzzer simply creates and discards objects. This verifies the ASN.1 parsing, but not whether other components handle the resulting objects correctly.</span></p></td></tr></tbody></table>
 
 
 <p><span>This fuzzer might have produced a </span><span>SECKEYPublicKey</span><span> that could have reached the vulnerable code, but as the result was never used to verify a signature, the bug could never be discovered.</span></p>
 <h4 id="h.y3p8hf8j0qqo"><span>Issue #2 </span><span>Arbitrary size limits</span><span>.</span></h4>
 
 <p><span>There is an arbitrary limit of </span><span><a href="https://searchfox.org/nss/source/fuzz/options/quickder.options">10000 bytes</a></span><span> placed on fuzzed input. There is no such limit within NSS; many structures can exceed this size. This vulnerability demonstrates that errors happen at extremes, so this limit should be chosen thoughtfully.</span></p>
 
 <p><span>A reasonable choice might be 2</span><span>24</span><span>-1 bytes, the </span><span><a href="https://datatracker.ietf.org/doc/html/rfc8446#section-4.4.2">largest possible</a></span><span> certificate that can be presented by a server during a TLS handshake negotiation.</span></p>
 
 <p><span>While NSS might handle objects even larger than this, TLS cannot possibly be involved, reducing the overall severity of any vulnerabilities missed.</span></p>
 <h4 id="h.fny13amxfoss"><span>Issue #3 </span><span>Misleading metrics</span><span>.</span></h4>
 
 <p><span>All of the NSS fuzzers are represented in combined coverage metrics by oss-fuzz, rather than their individual coverage. This data proved misleading, as the vulnerable code is fuzzed extensively but by fuzzers that could not possibly generate a relevant input.</span></p>
 
 <p><span>This is because fuzzers like the </span><span><a href="https://searchfox.org/nss/source/fuzz/tls_server_target.cc">tls_server_target</a></span><span> use fixed, </span><span><a href="https://searchfox.org/nss/source/fuzz/tls_server_certs.cc">hardcoded</a></span><span> certificates. This exercises code relevant to certificate verification, but only fuzzes TLS messages and protocol state changes.</span></p>
 <h3 id="h.5iljytmv85wn"><span>What Worked</span></h3>
 <ul><li><span>The design of the mozilla::pkix validation library prevented this bug from being worse than it could have been. </span><span>Unfortunately it is unused outside of Firefox and Thunderbird.</span></li></ul>
 
 <p><span>It’s debatable whether this was just good fortune or not. It seems likely RSA-PSS would eventually be permitted by mozilla::pkix, even though it was not today.</span></p>
 <h2 id="h.t0ijbutqkb5h"><span>Recommendations</span></h2>
 
 <p><span>This issue demonstrates that even extremely well-maintained C/C++ can have fatal, trivial mistakes.</span></p>
 <h3 id="h.yesvwttsgrsf"><span>Short Term</span></h3>
 <ul><li><span>Raise the maximum size of ASN.1 objects produced by libFuzzer from 10,000 to 2</span><span>24</span><span>-1 = 16,777,215  bytes.</span></li></ul><ul><li><span>The QuickDER fuzzer should call some relevant APIs with any objects successfully created before destroying them.</span></li><li><span>The oss-fuzz code coverage metrics should be divided by fuzzer, not by project.</span></li></ul>
 
 
 <p><span>This vulnerability is </span><span>CVE-2021-43527,</span><span> and is resolved in </span><span><a href="https://www.mozilla.org/en-US/security/advisories/">NSS 3.73.0</a></span><span>. If you are a vendor that distributes NSS in your products, you will most likely need to update or backport the patch.</span></p>
 
 
 <p><span>I would not have been able to find this bug without assistance from my colleagues from Ch</span><span>rome, Ryan S</span><span>leevi and David Benjamin, who helped answer my ASN.1 encoding questions and engaged in thoughtful discussion on the topic.</span></p>
 
 <p><span>Thanks to the NSS team, who helped triage and analyze the vulnerability.</span></p><hr/><p><a href="#ftnt_ref1" id="ftnt1" name="ftnt1">[1]</a><span> In this minimal example, a workaround if source was available would be to use a combination of sancov&#39;s data-flow instrumentation options, but that also fails on more complex variants.</span></p></div>

</div></div>
  </body>
</html>
