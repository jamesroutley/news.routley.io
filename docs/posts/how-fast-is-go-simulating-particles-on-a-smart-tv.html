<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dgerrells.com/blog/how-fast-is-go-simulating-millions-of-particles-on-a-smart-tv">Original</a>
    <h1>How fast is Go? simulating particles on a smart TV</h1>
    
    <div id="readability-page-1" class="page"><div>


<p>The challenge, simulate millions of particles in golang, multi-player enabled, cpu only, smart tv compatible.</p>
<p>Let&#39;s go, pun very much intended.</p>
<p><img src="https://dgerrells.com/images/but-why-jon-tron-show.gif" alt="jon tron saying but why"/></p><p>So, during my day job I had to write a ws server which merged multiple upstream ws servers into a single ws server. (Don&#39;t ask) I was lost and not even the power of claude, gemini, and cursor could save me. The vibes were simply not enough to get the project done. I had to learn the real real stuff.</p>
<p>To learn the real stuff I decided to write a particle simulation and see how many particles I could get golang to push. I had already done this in the lands of javascript, rust, and swift. But given Go doesn&#39;t support simd, I knew it wouldn&#39;t be a fair fight against the other languages and more importantly, it would be boring let alone helping my day job.</p>
<p>I figured to give go the best shake I needed to up the difficulty by adding multi-player to the simulation. After all, go is best known as a snappy productive backend language. Is it snappy and productive enough for simulating a million particles and syncing it across hundreds of clients?</p>
<p>Only one way to find out.</p>

<h2>No Cheating</h2>
<p>There is a rule and an important one. No client simulation allowed only server. The client should be a simple web page. It should work anywhere browser runs.</p>
<p>Determinism. This is a key word in computer science and it is here too. If you start with the same initial state and apply the same input, you will always get the same result. Predictable and reproducible.</p>
<p>Many multi-player games use determinism to effectively decouple the relationship of bigger game states from the data the server must sync across clients.</p>
<p>Real-time strategy games are a poster child for this. Rather than send the positions of thousands of units, projectiles, unit health, etc to clients, you would send only player input data which the client can use to derive the game state at a given point in time. Add a little bit of client side prediction, rollback, and the like and you get a smooth game experience, usually.</p>
<p>But this requires the client to be able to simulate the game and not all clients are fast. How can this run everywhere a browser does if I want to simulate millions of particles?</p>
<p>I know what the <a href="https://gafferongames.com/">ol&#39;gafferongames</a> would say right now. Even if I didn&#39;t use determinism I&#39;d still need to simulate SOMETHING on the client. If I want to send millions of particle positions to the client, surely I&#39;d need to send at least the positions right? I could derive the velocities and quantize the crap out of everything too. I am sure there are other tricks I don&#39;t remember from his excellent blog series on game state networking code.</p>
<p>I still call that cheating too as the client has to simulate something and it may not scale to millions of particles.</p>
<p>I have another idea. I can decouple the simulation size much like determinism does by taking a hint from graphics programming.</p>
<h2>G-Buffer</h2>
<p>Way back when in the days of Doom 3 when Mr. Carmack was in his prime, games would calculate lighting based on building shadow geometry from polygons. This was done in Doom 3 and looked amazing. However, as you increased polygon count, the cost of shadows would go up.</p>
<p>The industry then figured out how to decouple polygon count from lighting by using a graphics buffer and <a href="https://en.wikipedia.org/wiki/Deferred_shading">deferred shading.</a> The details are heavy but the important part is that the cost of lighting is no longer proportional to number of polygons in the scene. Instead, it is based on a “fixed” g-buffer size. The buffer is proportional to the render resolution.</p>
<p>This is why 4k is so expensive to render and the games industry has stoked on AI upscaling and frame interpolation. Fewer pixels means faster rendering. Geometry is making a come back with slick virtualization too but I digress. The important part is that deferred shading decouples polygons count from lighting.</p>
<p>Well, what if, I went full SSR and did all the rendering on the server sending the simulation frames to the clients? All a client needs to do is just, play a video onto an html canvas element. I would still need to send the input to the server but the size of the simulation wouldn&#39;t matter. The cost would be fixed to the resolution of the client.</p>
<p>I could have a billion particles and the data the client needs would remain the same. Now, if there were only a few thousand particles it wouldn&#39;t be worth the trade off.</p>
<p>How do I know it is worth it though?</p>
<h2>The Math</h2>
<p>I want to simulate 1 million particles at HD resolution so 1920x1080 pixels. There are 4 bytes per pixel rgba but I only need rgb. Actually, I only need one byte per pixel since that is how the previous particle simulations in the other languages worked. That means I am sending 2,073,600 bytes per frame or a little over 2mb. Oof. That is 120mb/s at 60 fps.</p>
<p>If I were to compress the frames they could drop down to a fraction of that. H264 or H265 (if I pay) could cut that down to 260kb per frame. I could also send only 24 frames/s making it pretty close to streaming regular video content.</p>
<p>Note were are talking full bytes here not bits.</p>
<p>If I were to send the particle data instead, each particle is made up of an x, y, dx, and dy. They are floating point numbers at 4 bytes each so a particle takes up 16 bytes. I could, derive the dx and dy so I will say 8 bytes per particle. That makes it 8,000,000 bytes or 8mb. 4x as big as the raw frame buffer. I am sure with a bit of quantization that could be brought down more and I wouldn&#39;t need to send the data 60/s but what if I want 10 million particles? The frame buffer starts to look more appealing.</p>
<p>The other thing that is nice here is that by sending the frames, the complexity drops. I don&#39;t need to worry about prediction or interpolation on the client. This wouldn&#39;t be great for a twitch shooter but they also don&#39;t sync millions of data points either.</p>
<p>No lossy compression. A particle simulation like this gets destroyed by lossy compression due to how dense the information is. There is little repitition in the data so HEVC or other lossy codecs will wreck it. Lossy compression is out of the question. It HAS to be lossless.</p>
<p>For example, look at this image, see all that noise? That doesn&#39;t compress well especially in motion.</p>
<p><img src="https://dgerrells.com/images/particle-spiral.jpg" alt="noisey image with many colors in a spiral"/></p><p>Additionally, compression isn&#39;t free. If I want to scale to hundreds of clients, I cannot spend all my time compressing data. This is an important consideration.</p>
<p>I am going to use TCP via websockets. For low latency realtime apps UDP would be better as it allows unordered messages preventing head of line blocking. However, it is significantly more complicated and not well supported on the web. TCP&#39;s guaranteed ordering of messages will cause some lag spikes but alas it is the best the web has to offer. QUIC is a thing however it only helps the blocking when there are multiple connections which this won&#39;t have.</p>
<p>TCP websockets it is. Onwards!</p>
<h2>A Concept</h2>
<p>My end game is to have a configurable play area where each client has its own view into the world. The best starting point would be to have a single view that is sent to all the clients.</p>
<p>The simulation itself is pretty simple. A particle struct distributing updates to many go routines. I knew that I couldn&#39;t write to a buffer while sending it to a client so I setup double buffering of the frames. A <code>ticker</code> is the way to get a game loop going though I am not a fan of it.</p>
<p>Here is the gist.</p>
<pre><code><span>type</span> Particle <span>struct</span> {
  x  <span>float32</span>
  y  <span>float32</span>
  dx <span>float32</span>
  dy <span>float32</span>
}

<span>type</span> Input <span>struct</span> {
  X           <span>float32</span>
  Y           <span>float32</span>
  IsTouchDown <span>bool</span>
}

<span>type</span> SimState <span>struct</span> {
  dt     <span>float32</span>
  width  <span>uint32</span>
  height <span>uint32</span>
}



<span><span>func</span> <span>startSim</span><span>()</span></span> {
  

  <span>for</span> <span>range</span> ticker.C {
    

    wg.Add(numThreads)
    
    numClients := <span>len</span>(clients)
    <span>const</span> friction = <span>0.99</span>

    <span>for</span> i := <span>0</span>; i &lt; numThreads; i++ {
      <span>go</span> <span><span>func</span><span>(threadID <span>int</span>)</span></span> {
        <span>defer</span> wg.Done()

        startIndex := threadID * particlesPerThread
        endIndex := startIndex + particlesPerThread

        <span>if</span> threadID == numThreads<span>-1</span> {
          endIndex = particleCount
        }

        <span>for</span> p := startIndex; p &lt; endIndex; p++ {
          <span>for</span> i := <span>0</span>; i &lt; numClients; i++ {
            input := inputs[i]
            <span>if</span> input.IsTouchDown {
              
            }
          }

          particles[p].x += particles[p].dx
          particles[p].y += particles[p].dy
          particles[p].dx *= friction
          particles[p].dy *= friction

          
        }
      }(i)
    }

    
    wg.Wait()

    framebuffer := getWriteBuffer()
    <span>copy</span>(framebuffer, bytes.Repeat([]<span>byte</span>{<span>0</span>}, <span>len</span>(framebuffer)))
    <span>for</span> _, p := <span>range</span> particles {
      
    }
    swapBuffers()

    <span>go</span> <span><span>func</span><span>(data []<span>byte</span>)</span></span> {
      
      <span>select</span> {
      <span>case</span> fameChannel &lt;- framebuffer:
      <span>default</span>:
        
      }
    }(framebuffer)
  }
}
</code></pre>
<p>A few notes. The simulation is basic. Particles can be pulled around by players slowing down by some friction value.</p>

<p>I want to avoid locking as much as possible. This means I am going to try and create a fixed amount of memory based the max number of clients I can handle then use the clients index as a fast way to access their respective data, in this case input data.</p>
<p>I also want to avoid writing a frame buffer per client as I know that writing to the frame buffer is not cache friendly and should only be done once. As a matter of fact, building the frame buffer is the most expensive part. I learned this from previous languages. Cache locality and all that.</p>
<p>One thing I learned about go is that it can be verbose. Not java levels but it is pretty lengthy.</p>
<p>I will skip the boiler plate code.</p>
<pre><code><span><span>func</span> <span>main</span><span>()</span></span> {
  <span>go</span> startSim()

  http.HandleFunc(<span>&#34;/ws&#34;</span>, wsHandler)
  
  http.Handle(<span>&#34;/&#34;</span>, http.FileServer(http.Dir(<span>&#34;./public&#34;</span>)))

  log.Println(<span>&#34;Server started on :8080&#34;</span>)
  <span>if</span> err := http.ListenAndServe(<span>&#34;:8080&#34;</span>, <span>nil</span>); err != <span>nil</span> {
    log.Fatal(<span>&#34;ListenAndServe:&#34;</span>, err)
  }
}
</code></pre>
<p>Initially, each websocket spins up their own ticker writing the latest frame buffer to the client. This is ugly and has sync issues but as a first version it is fine.</p>
<pre><code><span><span>func</span> <span>wsHandler</span><span>(w http.ResponseWriter, r *http.Request)</span></span> {
  

  clientsMu.Lock()
  
  clientsMu.Unlock()

  <span>defer</span> <span><span>func</span><span>()</span></span> {
    
  }()

  <span>go</span> <span><span>func</span><span>()</span></span> {
    
    <span>var</span> input Input
    err := binary.Read(bytes.NewReader(message), binary.LittleEndian, &amp;input)

    
    
    idx := findClientIndex(conn)
    <span>if</span> idx != <span>-1</span> &amp;&amp; idx &lt; maxClients {
      inputs[idx] = input
    }
  }()

  ticker := time.NewTicker(time.Second / <span>30</span>)
  <span>for</span> <span>range</span> ticker.C {
    data := getReadBuffer()
    <span>if</span> err := conn.WriteMessage(websocket.BinaryMessage, data); err != <span>nil</span> {
      log.Println(<span>&#34;Write failed:&#34;</span>, err)
      <span>break</span>
    }
  }
}
</code></pre>
<p>The client index is pretty silly but I really don&#39;t want to lock the hot path here.</p>
<p>I&#39;ll skip over the client javascript/html. It isn&#39;t that interesting, setup a web socket, write data to a canvas element using <code>setPixels</code> the usually.</p>
<p>So, how well does it work? Pretty well. But it is not fast, and is writing a shit load of data. It also  sometimes flickers when the tickers touch the frame buffer at the same time the simulation thread does.</p>
<p>Still, a good starting point.</p>
<iframe width="100%" height="315" src="https://www.youtube.com/embed/lXz7sb5dS1c?si=GfD5cEiHtZQ9wGfF" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<h2>Speed Speed Speed</h2>
<p>I used <code>pprof</code> to run some samples to see where things are slow. I noticed that time was spent creating go routines. While light they are not free. The idea is to have go routines listening in on channels. I refactored the simulation to wait for <code>SimJob</code> requests to come in.</p>
<pre><code><span>type</span> SimJob <span>struct</span> {
  startIndex <span>int</span>
  endIndex   <span>int</span>
  simState   SimState
  inputs     [maxClients]Input
  numClients <span>int</span>
}



jobs := <span>make</span>(<span>chan</span> SimJob, numThreads)
<span>var</span> wg sync.WaitGroup
<span>for</span> i := <span>0</span>; i &lt; numThreads; i++ {
  <span>go</span> worker(jobs, &amp;wg)
}


<span>for</span> i := <span>0</span>; i &lt; numThreads; i++ {
  startIndex := i * particlesPerThread
  endIndex := startIndex + particlesPerThread
  <span>if</span> i == numThreads<span>-1</span> {
    endIndex = particleCount
  }
  jobs &lt;- SimJob{startIndex, endIndex, simState, &amp;inputs, numClients, &amp;framebuffer}
}
</code></pre>
<p>I also reused frame buffers with a <code>pool</code> and then fixed the syncing by pushing to a channel which another thread would listen on. This thread would then write the new frame out to all the clients before adding it back to the pool. At first I used a simple for loop but that made it write as fast as the slowest client so instead I had it prep the frame and then push it to ANOTHER set of channels per client. Threads on each of those channels would then actually write data to the client.</p>
<pre><code><span><span>func</span> <span>broadcastFrames</span><span>(ch &lt;-<span>chan</span> *Frame, pool *sync.Pool)</span></span> {
  <span>for</span> {
    frame := &lt;-ch
    
    clientsMu.Lock()
    <span>for</span> i, conn := <span>range</span> clients {
      
      <span>select</span> {
      <span>case</span> clientSendChannelMap[conn] &lt;- dataToSend:
      <span>default</span>:
        log.Printf(<span>&#34;Client %d&#39;s channel is full, dropping frame. Requesting full frame.&#34;</span>, i)
      }
    }
    clientsMu.Unlock()
    pool.Put(frame)
  }
}


<span><span>func</span> <span>writePump</span><span>(conn *websocket.Conn)</span></span> {
  <span>var</span> channel = clientSendChannelMap[conn]
  <span>for</span> {
    message, ok := &lt;-channel
    <span>if</span> !ok {
      <span>return</span>
    }

    <span>if</span> err := conn.WriteMessage(websocket.BinaryMessage, message); err != <span>nil</span> {
      log.Printf(<span>&#34;Write to client failed: %v&#34;</span>, err)
      <span>return</span>
    }
  }
}
</code></pre>
<p>I pump when a client connects and stop when they disconnect. This works pretty well and fixes the sync issue.</p>
<p>I experimented with compression a bit using the standard <code>flate</code> lib. It worked but was pretty slow. I then experimented with every kind of encoding I could think of to reduce the data transferred.</p>
<p>I tried a bit mask where I would sent 0/1 flags per pixel followed by the in order pixel data that changed. This was fast per client but ended up being larger than the raw frame data when particles started moving around.</p>
<p>I tried run length encoding, variable length encoding, and delta encoding all combined in different ways.</p>
<p>There are some gotchas I ran into For RLE to work you need a sentinel byte to know if there is a run of data. This drops the available space per pixel. It could be possible to encode multiple pixels at a time but that didn&#39;t work that well. VLE is just run length using varints to drop the size down for small numbers this worked and did help reduce size by almost 8% on average.</p>
<p>Delta encoding was the most fun. The way I tried it was to delta encode between frames. That way passing the delta into RLE would massively compress the data. The issue is that particle counts can go up or down per pixel. This required <code>zigzag</code> encoding but there was an issue.</p>
<p>If each pixel is one byte, and the byte can go from 0 to 255 in a single frame, then the size of the deltas would need to go from -255 to +255 which doesn&#39;t fit in a byte. The <code>zigzag</code> encoding worked and I figured I could just drop down to 7-bits per pixel.</p>
<p>I read about zigzag encoding from a microsoft paper on optimized compression for depth data from multiple connect sensors. I don&#39;t remember the name. To save you some time, just ask AI about it.</p>
<pre><code><span><span>func</span> <span>CreateDeltaBuffer</span><span>(oldBuffer, newBuffer []<span>byte</span>)</span> []<span>byte</span></span> {
  <span>if</span> <span>len</span>(oldBuffer) != <span>len</span>(newBuffer) {
    <span>return</span> newBuffer
  }
  deltaBuffer := <span>make</span>([]<span>byte</span>, <span>len</span>(newBuffer))

  <span>for</span> i := <span>0</span>; i &lt; <span>len</span>(newBuffer); i++ {
    diff := <span>int16</span>(newBuffer[i]) - <span>int16</span>(oldBuffer[i])
    deltaBuffer[i] = zigZagEncode(<span>int8</span>(diff))
  }

  <span>return</span> deltaBuffer
}
</code></pre>
<p>And it works. Unless the whole frame was moving around, the size was ~30% smaller than the raw frame data. If nothing moved, it would send only a few bytes! But again, there were problems.</p>
<p>The code is complicated. I had to track if I was sending delta frames or full frames, and if a client dropped a frame, I&#39;d need to send a full frame again. This would cause a brief flash on the screen. I could add frame counting logic so the client could drop out of sync deltas but the code was already a bit much.</p>
<pre><code><span><span>func</span> <span>broadcastFrames</span><span>(ch &lt;-<span>chan</span> *Frame, pool *sync.Pool)</span></span> {
  <span>for</span> {
    frame := &lt;-ch
    fullFrameBuffer.Reset()
    fullFrameBuffer.WriteByte(OpCodeFullFrame)
    fullFrameBuffer.Write(frame.FullBuffer)
    fullFrameBytes := fullFrameBuffer.Bytes()

    deltaFrameBuffer.Reset()
    deltaFrameBuffer.WriteByte(OpCodeDeltaFrame)
    deltaFrameBuffer.Write(frame.Delta)
    deltaFrameBytes := deltaFrameBuffer.Bytes()

    clientsMu.Lock()
    <span>for</span> i, conn := <span>range</span> clients {

      <span>var</span> dataToSend []<span>byte</span>
      <span>if</span> clientFullFrameRequestFlags[i] {
        dataToSend = fullFrameBytes
        clientFullFrameRequestFlags[i] = <span>false</span>
      } <span>else</span> {
        dataToSend = deltaFrameBytes
      }

      <span>select</span> {
      <span>case</span> clientSendChannelMap[conn] &lt;- dataToSend:
      <span>default</span>:
        log.Printf(<span>&#34;Client %d&#39;s channel is full, dropping frame. Requesting full frame.&#34;</span>, i)
        clientFullFrameRequestFlags[i] = <span>true</span>
      }
    }
    clientsMu.Unlock()
    pool.Put(frame)
  }
}
</code></pre>
<p>It does work though.</p>
<iframe width="100%" height="315" src="https://www.youtube.com/embed/WtF9IAUE4bs?si=DjqJ6vzWK9PwD6wK" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<p>However, I want each client to have their own “view” into a bigger frame where the can pan around the world fighting for particles. For this to work, with the current setup, I&#39;d need to track delta frames per client and figure out how to handle dropped delta frames better.</p>
<p>Back to the drawing board.</p>
<h2>The Drawing Board</h2>
<p>Stupid simple, is simple stupid.</p>
<p>I am going to have 1 bit per pixel. That means only a single “luminance” value. In the previous video I was only effectively using a few bits on the client having only about 8 “luminance” values. Bet you thought it was more right?</p>
<p>This will simplify everything. The only hard part is packing and unpacking the data. I also figured I could implement client camera state too. I waffled a bit around how to store this state and update it.</p>
<p>Does the client sent their camera position directly? What if the window resizes? What if the client sends a negative camera size? What if they send an infinite one? How do I prevent blocking?</p>
<p>I ended up copying what I did for the input data.</p>
<pre><code><span>type</span> ClientCam <span>struct</span> {
  X      <span>float32</span>
  Y      <span>float32</span>
  Width  <span>int32</span>
  Height <span>int32</span>
}
<span>var</span> (
  inputs     [maxClients]Input
  cameras    [maxClients]ClientCam
)
</code></pre>
<p>I would have the client send the camera data with the existing input message.</p>
<pre><code>  <span>for</span> {
    mt, message, err := conn.ReadMessage()
    <span>if</span> err != <span>nil</span> {
      log.Println(<span>&#34;Read failed:&#34;</span>, err)
      <span>return</span>
    }
    <span>if</span> mt == websocket.BinaryMessage {
      reader := bytes.NewReader(message)
      <span>var</span> touchInput Input
      
      <span>var</span> camInput ClientCam
      
      errInput := binary.Read(reader, binary.LittleEndian, &amp;touchInput)
      errCam := binary.Read(reader, binary.LittleEndian, &amp;camInput)
      
      
    }
  }
</code></pre>
<p>For sending frame data, at first, I naively packed the buffer and then unpacked it again based on the region a client was rendering.</p>
<pre><code>
<span>for</span> _, p := <span>range</span> particles {
  x := <span>int</span>(p.x)
  y := <span>int</span>(p.y)
  <span>if</span> x &gt;= <span>0</span> &amp;&amp; x &lt; <span>int</span>(simState.width) &amp;&amp; y &gt;= <span>0</span> &amp;&amp; y &lt; <span>int</span>(simState.height) {
    idx := (y*<span>int</span>(simState.width) + x)
    <span>if</span> idx &lt; <span>int</span>(simState.width*simState.height) {
      byteIndex := idx / <span>8</span>
      bitOffset := idx % <span>8</span>
      <span>if</span> byteIndex &lt; <span>len</span>(framebuffer) {
        framebuffer[byteIndex] |= (<span>1</span> &lt;&lt; bitOffset)
      }
    }
  }
}



<span>for</span> row := <span>int32</span>(<span>0</span>); row &lt; height; row++ {
  <span>for</span> col := <span>int32</span>(<span>0</span>); col &lt; width; col++ {
    mainFrameIndex := ((y+row)*<span>int32</span>(simState.width) + (x + col))
    dataToSendIndex := (row*width + col)

    <span>if</span> mainFrameIndex/<span>8</span> &lt; <span>int32</span>(<span>len</span>(frameBuffer)) &amp;&amp; dataToSendIndex/<span>8</span> &lt; <span>int32</span>(<span>len</span>(dataToSend)) {
      isSet := (frameBuffer[mainFrameIndex/<span>8</span>] &gt;&gt; (mainFrameIndex % <span>8</span>)) &amp; <span>1</span>
      <span>if</span> isSet == <span>1</span> {
        dataToSend[dataToSendIndex/<span>8</span>] |= (<span>1</span> &lt;&lt; (dataToSendIndex % <span>8</span>))
      }
    }
  }
}
</code></pre>
<p>This makes HD only a few hundred kb/frame.</p>
<p><code>pprof</code> has a niffy way of downloading a simple of the running up you can then load and look at with their cli tool.</p>
<p>I checked a sample using <code>pprof</code> and noticed the sim was slow when it was building the frame buffer so I moved the frame building to the simulation workers. This is possible now because each thread will only mark a bit as on if there is a particle there. Which means I don&#39;t need to lock anything and can let the last writer win.</p>
<p>Before</p>
<pre><code>Showing top 10 nodes out of 35
      flat  flat%   sum%        cum   cum%
    16.75s 52.54% 52.54%     17.05s 53.48%  main.worker
     6.42s 20.14% 72.68%      6.49s 20.36%  main.broadcastFrames
</code></pre>
<p>And after</p>
<pre><code>Showing top 10 nodes out of 36
      flat  flat%   sum%        cum   cum%
    13.01s 46.46% 46.46%     13.28s 47.43%  main.worker
     6.98s 24.93% 71.39%      7.08s 25.29%  main.broadcastFrames
</code></pre>
<p>The simulation is a bit faster but notice that the broadcast frames is slow. You know that packing I am doing? Ya, that ended up being very very slow. 25% of the time is spent broadcasting frames to a few clients due to all the bit opps packing and unpacking.</p>
<p>A simple fix is to use full bytes even if the count is only ever 0-1 and then using a lookup map to skip the bit opps like so.</p>
<pre><code><span>var</span> uint64ToByteLUT = <span>make</span>(<span>map</span>[<span>uint64</span>]<span>byte</span>)

<span><span>func</span> <span>init</span><span>()</span></span> {
  <span>var</span> byteSlice = <span>make</span>([]<span>byte</span>, <span>8</span>)
  <span>for</span> i := <span>0</span>; i &lt; <span>256</span>; i++ {
    <span>for</span> bit := <span>0</span>; bit &lt; <span>8</span>; bit++ {
      <span>if</span> (i&gt;&gt;bit)&amp;<span>1</span> == <span>1</span> {
        byteSlice[bit] = <span>1</span>
      } <span>else</span> {
        byteSlice[bit] = <span>0</span>
      }
    }
    
    uint64ToByteLUT[BytesToUint64Unsafe(byteSlice)] = <span>byte</span>(i)
  }
}

<span>for</span> row := <span>int32</span>(<span>0</span>); row &lt; height; row++ {
  yOffset := (y + row) * <span>int32</span>(simState.width)
  <span>for</span> col := <span>int32</span>(<span>0</span>); col &lt; width; col += <span>8</span> {
    fullBufferIndex := yOffset + (x + col)
    chunk := frameBuffer[fullBufferIndex : fullBufferIndex+<span>8</span>]
    key := BytesToUint64Unsafe(chunk)

    packedByte, _ := uint64ToByteLUT[key]

    <span>if</span> outputByteIndex &lt; <span>int32</span>(<span>len</span>(dataToSend)) {
      dataToSend[outputByteIndex] = packedByte
      outputByteIndex++
    }
  }
}
</code></pre>
<p>Now slicing the frame region for a client is almost free. The idea is pretty simple, interpret 8 bytes at a time as a uint64 which maps to the corresponding single byte with the right bits set. I did something similar on the client too to make unpacking faster. The extra memory here is pretty small and worth it to me.</p>
<p>Not bad. I am sure more can be done but the main sim is taking up the majority of the time.</p>
<pre><code>Showing top 10 nodes out of 49
      flat  flat%   sum%        cum   cum%
    15.62s 58.85% 58.85%     15.83s 59.65%  main.worker
     4.66s 17.56% 76.41%      4.66s 17.56%  runtime.pthread_cond_wait
     2.96s 11.15% 87.57%      2.96s 11.15%  runtime.pthread_cond_signal
     0.90s  3.39% 90.96%      0.90s  3.39%  runtime.kevent
     0.47s  1.77% 92.73%      0.80s  3.01%  runtime.mapaccess2_fast64
     0.36s  1.36% 94.08%      1.17s  4.41%  main.broadcastFrames
     0.20s  0.75% 94.84%      0.20s  0.75%  runtime.asyncPreempt
     0.17s  0.64% 95.48%      0.17s  0.64%  runtime.madvise
     0.17s  0.64% 96.12%      0.17s  0.64%  runtime.pthread_kill
     0.17s  0.64% 96.76%      0.17s  0.64%  runtime.usleep
</code></pre>
<p>On the topic of memory, with millions of particles the server barely breaks over 100mb. Not rust good but node would be well over a few gigs and I cannot imagine python would be much lighter.</p>
<p>I waffled about again for well over a day trying to get some go assembly to work for those sweet simd gains but it wasn&#39;t to be. There are some libraries I tried too but none of them did better than what I already had. There are some interesting things with go&#39;s compiler around how to optimize out dereferences and bounds checking which did give me a 30% boost.</p>
<p>For example, before I was updating the particles like so</p>
<pre><code><span>for</span> i := job.startIndex; i &lt; job.endIndex; i++ {
  particles[i].x += particles[i].dx
  
</code></pre>
<p>But by doing this</p>
<pre><code><span>for</span> i := job.startIndex; i &lt; job.endIndex; i++ {
  p := &amp;particles[i]
  p.x += p.dx
</code></pre>
<p>Big boost. It makes sense. Bounds checking was happening way too often. I did a few more micro optimizations which helped but nothing significant. I did try SoA too and that actually did worse than AoS. Go figure.</p>
<p>I tried to use a fast inverse square root function but for some reason the go version of it didn&#39;t work at all which is weird because js lands had no issue. Oh well.</p>
<p>The previous profile samples were taken simulating a dozen or so clients with a few million particles. If I bump that up to 20m particles, I get this.</p>
<pre><code>Showing top 10 nodes out of 21
      flat  flat%   sum%        cum   cum%
   113.16s 93.06% 93.06%    115.22s 94.75%  main.worker
     2.27s  1.87% 94.93%      2.27s  1.87%  runtime.pthread_cond_wait
     2.04s  1.68% 96.60%      2.04s  1.68%  runtime.asyncPreempt
     1.23s  1.01% 97.62%      1.23s  1.01%  runtime.pthread_cond_signal
     0.63s  0.52% 98.13%      1.56s  1.28%  runtime.mapaccess2_fast64
     0.30s  0.25% 98.38%      1.92s  1.58%  main.broadcastFrames
</code></pre>
<p>The simulation is the clear bottle neck and without simd, I am not sure how much better I can get it.</p>
<p>It works though. Time to deploy it to the cloud.</p>
<h2>The Cloud</h2>
<p>I was going to use a digital ocean docklet but it would cost more than an Equinox gym membership for anything faster than a toaster. I ended up spending ~$8/month at netcup for a 16 gig 10 core arm vm Manassas, Virginia with a ping of over 300ms. Fantastic. Not sure why the DNS on their panel says germany though.</p>
<p>I opened a few ports under root like the psychopath I and gave it a spin.</p>
<iframe width="100%" height="315" src="https://www.youtube.com/embed/5hr_wbV5VPs?si=jeifYjKPj1CtLS4L" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<p>Pretty slick. More clients barely impacts cpu usage. But will it scale to 1k clients? I am not sure.</p>
<p>The netcup vps has a 2.5 Gbit pipe. At a 1920x1080 resolution with 1 bit per pixel at a rate of 30 frames/s down the pipe, that should theoretically support well over 300 clients. Now, if these were mobile devices with a fraction of that resolution say 390x844 or so, (we are not talking native), it may actually scale.</p>
<p>It is worth noting it does suffer from head of line blocking at times especially as the resolution gets cranked up. Clients with a resolution larger than the max particle grid are ignored so your 5k display won&#39;t work.</p>
<h2>How fast is go?</h2>
<p>I did a bit of polishing on the client, edge scrolling, panning, mobile support, etc but this post isn&#39;t about javascript it is about golang.</p>
<p>Go is able to simulate 2.5 million particles at 60fps while sending data at 30 fps to in theory over 300 clients maybe even a thousand. And because this happens on the server it even runs on a smart tv. Don&#39;t believe me? Just visit, <a href="http://howfastisgo.dev">howfastisgo.dev</a> and see for yourself or watch the video below.</p>
<iframe width="100%" height="315" src="https://www.youtube.com/embed/cGubp-wOt7Q?si=r768c7VI67I_n51J" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<p>While go certainly isn&#39;t a compute workhorse, that is pretty impressive. Anywhere a browser runs this works! Go is just THAT fast.</p>
<p>This is just so cursed. I love it.</p>


<p>Until next time.</p><h2>where to find me?</h2></div></div>
  </body>
</html>
