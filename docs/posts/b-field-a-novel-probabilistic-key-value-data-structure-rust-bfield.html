<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/onecodex/rust-bfield">Original</a>
    <h1>Show HN: B-field, a novel probabilistic key-value data structure (`rust-bfield`)</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><a href="https://crates.io/crates/bfield" rel="nofollow"><img src="https://camo.githubusercontent.com/b0673bc61a8b98a999881e865548dd0b6cb6bb8a88045ae267a656f79eb7ccce/68747470733a2f2f696d672e736869656c64732e696f2f6372617465732f762f626669656c642e737667" alt="Crates.io Version" data-canonical-src="https://img.shields.io/crates/v/bfield.svg"/></a></p>
<p dir="auto">The B-field is a novel, probabilistic data structure for storing key-value pairs (or, said differently, it is a probabilistic associative array or map). B-fields support insertion (<code>insert</code>) and lookup (<code>get</code>) operations, and share a number of mathematical and performance properties with the well-known <a href="https://doi.org/10.1145/362686.362692" rel="nofollow">Bloom filter</a>.</p>
<p dir="auto">At <a href="https://www.onecodex.com" rel="nofollow">One Codex</a>, we use the <code>rust-bfield</code> crate in bioinformatics applications to efficiently store associations between billions of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$k$</math-renderer>-length nucleotide substrings (<a href="https://en.wikipedia.org/wiki/K-mer" rel="nofollow">&#34;k-mers&#34;</a>) and <a href="https://www.ncbi.nlm.nih.gov/taxonomy" rel="nofollow">their taxonomic identity</a> <em><strong>using only 6-7 bytes per <code>(kmer, value)</code> pair</strong></em> for up to 100,000 unique taxonomic IDs (distinct values) and a 0.1% error rate. We hope others are able to use this library (or implementations in other languages) for applications in bioinformatics and beyond.</p>
<blockquote>
<p dir="auto"><em>Note: In the <a href="#implementation-details">Implementation Details</a> section below, we detail the use of this B-field implementation in Rust and use <code>code</code> formatting and English parameter names (e.g., we discuss the B-field being a data structure for storing <code>(key, value)</code> pairs). In the following <a href="#formal-data-structure-details">Formal Data Structure Details</a> section, we detail the design and mechanics of the B-field using mathematical notation (i.e., we discuss it as an associate array mapping a set of</em> <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$(x, y)$</math-renderer> <em>pairs). The <a href="https://docs.rs/bfield/latest/bfield/" rel="nofollow">generated Rust documentation</a> includes both notations for ease of reference.</em></p>
</blockquote>

<p dir="auto">A B-field stores a <code>(key, value)</code> mapping <strong>without directly storing either the keys or the values</strong>. This permits highly space efficient association of <code>(key, value)</code> mappings, but comes at the cost of two classes of errors:</p>
<ul dir="auto">
<li>False positives (which we later describe as occurring at a tunable rate of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\alpha$</math-renderer>) in which the <code>get</code> operation for a <code>key</code> <em>that was not inserted into the B-field</em> returns an incorrect <code>value</code>; and</li>
<li>Indeterminacy errors (later described as occurring at a frequency of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta$</math-renderer>) in which the <code>get</code> operation for a <code>key</code> returns an <code>Indeterminate</code> instead of a specific <code>value</code>. Note that this error can occur for both <code>keys</code> that were inserted into the B-field as well as those that were not.</li>
</ul>
<p dir="auto">Both error categories can be minimized with appropriate <a href="#parameter-selection">parameter selection</a>, and it is trivial to achieve a zero or near-zero indeterminacy error rate (i.e., <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta\approx0$</math-renderer>).</p>

<p dir="auto">While the space requirements for a B-field depends on the number of discrete values and the desired error rates, the following examples are illustrative use cases:</p>
<ul dir="auto">
<li>
<p dir="auto">Store 1 billion web URLs and...</p>
<ul dir="auto">
<li>
<p dir="auto">Assign each of them one of a small number of categories values (n=8) in 2.22Gb (params include ŒΩ=8, Œ∫=1, ùõº=0.1%; 19 bits per element)</p>
</li>
<li>
<p dir="auto">Store their IPv4 prefix (n=32) in 3.16Gb (ŒΩ=24, Œ∫=2, ùõº=0.1%; 27 bits per element)</p>
</li>
<li>
<p dir="auto">Store their IP in an <code>0.0.0.0/8</code> address block (n=16,777,216) in 8.9Gb (ŒΩ=51, Œ∫=6, ùõº=0.1%; 76 bits per element)</p>
</li>
<li>
<p dir="auto">Determine if they are part of the set (a Bloom filter!) in 1.75Gb (params include ŒΩ=1, Œ∫=1, ùõº=0.1%; 15 bits per element)</p>
<blockquote>
<p dir="auto"><em>We don&#39;t estimate space savings over alternative data structures, but any structure storing URLs averaging ~40 bytes per key will several-fold larger than even a B-field associating keys with ~16M distinct values.</em></p>
</blockquote>
</li>
</ul>
</li>
<li>
<p dir="auto">Store 1 billion DNA or RNA <em>k</em>-mers (&#34;ACGTA...&#34;) and...</p>
<ul dir="auto">
<li>
<p dir="auto">Associate them with any of the ~500k bacterial IDs current described by NCBI in 6.93Gb (ŒΩ=62, Œ∫=4, ùõº=0.1%; 59 bits per element)</p>
</li>
<li>
<p dir="auto">Store which of 1000 datasets they were most frequently observed in using 3.65Gb (ŒΩ=46, Œ∫=2, ùõº=0.1%; 31 bits per element)</p>
</li>
<li>
<p dir="auto">Quantify their abundance in a dataset(s) (say with ~100 quantized values) in 2.91Gb (ŒΩ=15, Œ∫=2, ùõº=0.1%; 25 bits per element)</p>
<blockquote>
<p dir="auto"><em>Compare this to a naive implementation storing 2-bit encoded 32-mers (or 8 amino acid character) and an associated 32 bit value, requiring 96 bits per element without any indexing or data structure overhead.</em></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<div dir="auto"><h3 tabindex="-1" dir="auto"><em>üõ† Supported Operations &amp; Example Code</em></h3><a id="user-content--supported-operations--example-code" aria-label="Permalink: üõ† Supported Operations &amp; Example Code" href="#-supported-operations--example-code"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This implementation provides the following core functionality:</p>
<ul dir="auto">
<li>A B-field can be created with the <code>create</code> function (see <a href="#parameter-selection">parameter selection</a> for additional details) and then by iteratively inserting <code>(key, value)</code> pairs with the <code>insert</code> function:</li>
</ul>
<div dir="auto" data-snippet-clipboard-copy-content="use bfield::BField;

let tmp_dir = tempfile::tempdir().unwrap();

// Create a B-field in a temporary directory
// with a 1M bit array, 10 hash functions (k), a marker
// width of 39 (ŒΩ), weight of 4 (Œ∫), 4 secondary arrays, and
// an uncorrected Œ≤ error of 0.1
let mut bfield: BField&lt;String&gt; = BField::create(
    &#34;/tmp/&#34;,         // directory
    &#34;bfield&#34;,        // filename (used as base filename)
    1_000_000,       // size (in bits)
    10,              // n_hashes (k)
    39,              // marker_width (ŒΩ)
    4,               // n_marker_bits (weight / Œ∫)
    0.1,             // secondary_scaledown (uncorrected Œ≤)
    0.025,           // max_scaledown
    4,               // n_secondaries
    false,           // in_memory
    String::new()    // other_params
).expect(&#34;Failed to build B-field&#34;);

// Insert integers 0-10,000 as key-value pairs (10k keys, 10k distinct values)
for p in 0..4u32 {
    for i in 0..10_000u32 {
        bfield.insert(&amp;i.to_be_bytes().to_vec(), i, p as usize);
    }
}"><pre><span>use</span> bfield<span>::</span><span>BField</span><span>;</span>

<span>let</span> tmp_dir = tempfile<span>::</span><span>tempdir</span><span>(</span><span>)</span><span>.</span><span>unwrap</span><span>(</span><span>)</span><span>;</span>

<span>// Create a B-field in a temporary directory</span>
<span>// with a 1M bit array, 10 hash functions (k), a marker</span>
<span>// width of 39 (ŒΩ), weight of 4 (Œ∫), 4 secondary arrays, and</span>
<span>// an uncorrected Œ≤ error of 0.1</span>
<span>let</span> <span>mut</span> bfield<span>:</span> <span>BField</span><span>&lt;</span><span>String</span><span>&gt;</span> = <span>BField</span><span>::</span><span>create</span><span>(</span>
    <span>&#34;/tmp/&#34;</span><span>,</span>         <span>// directory</span>
    <span>&#34;bfield&#34;</span><span>,</span>        <span>// filename (used as base filename)</span>
    <span>1_000_000</span><span>,</span>       <span>// size (in bits)</span>
    <span>10</span><span>,</span>              <span>// n_hashes (k)</span>
    <span>39</span><span>,</span>              <span>// marker_width (ŒΩ)</span>
    <span>4</span><span>,</span>               <span>// n_marker_bits (weight / Œ∫)</span>
    <span>0.1</span><span>,</span>             <span>// secondary_scaledown (uncorrected Œ≤)</span>
    <span>0.025</span><span>,</span>           <span>// max_scaledown</span>
    <span>4</span><span>,</span>               <span>// n_secondaries</span>
    <span>false</span><span>,</span>           <span>// in_memory</span>
    <span>String</span><span>::</span><span>new</span><span>(</span><span>)</span>    <span>// other_params</span>
<span>)</span><span>.</span><span>expect</span><span>(</span><span>&#34;Failed to build B-field&#34;</span><span>)</span><span>;</span>

<span>// Insert integers 0-10,000 as key-value pairs (10k keys, 10k distinct values)</span>
<span>for</span> p <span>in</span> <span>0</span>..<span>4u32</span> <span>{</span>
    <span>for</span> i <span>in</span> <span>0</span>..<span>10_000u32</span> <span>{</span>
        bfield<span>.</span><span>insert</span><span>(</span><span>&amp;</span>i<span>.</span><span>to_be_bytes</span><span>(</span><span>)</span><span>.</span><span>to_vec</span><span>(</span><span>)</span><span>,</span> i<span>,</span> p <span>as</span> <span>usize</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span></pre></div>
<ul dir="auto">
<li>After creation, a B-field can optionally be loaded from a directory containing the produced <code>mmap</code> and related files with the <code>load</code> function. And once created or loaded, a B-field can be directly queried using the <code>get</code> function, which will either return <code>None</code>, <code>Indeterminate</code>, or <code>Some(BFieldValue)</code> (which is currently an alias for <code>Some(u32)</code> see <a href="#%E2%9A%A0%EF%B8%8F-current-limitations-of-the-rust-bfield-implementation">limitations</a> below for more details):</li>
</ul>
<div dir="auto" data-snippet-clipboard-copy-content="use bfield::BField;

// Load based on filename of the first array &#34;.0.bfd&#34;
let bfield: BField&lt;String&gt; = BField::load(&#34;/tmp/bfield.0.bfd&#34;, true).expect(&#34;Failed to load B-field&#34;);

for i in 0..10_000u32 {
    let value = bfield.get(&amp;i.to_be_bytes().to_vec());
}"><pre><span>use</span> bfield<span>::</span><span>BField</span><span>;</span>

<span>// Load based on filename of the first array &#34;.0.bfd&#34;</span>
<span>let</span> bfield<span>:</span> <span>BField</span><span>&lt;</span><span>String</span><span>&gt;</span> = <span>BField</span><span>::</span><span>load</span><span>(</span><span>&#34;/tmp/bfield.0.bfd&#34;</span><span>,</span> <span>true</span><span>)</span><span>.</span><span>expect</span><span>(</span><span>&#34;Failed to load B-field&#34;</span><span>)</span><span>;</span>

<span>for</span> i <span>in</span> <span>0</span>..<span>10_000u32</span> <span>{</span>
    <span>let</span> value = bfield<span>.</span><span>get</span><span>(</span><span>&amp;</span>i<span>.</span><span>to_be_bytes</span><span>(</span><span>)</span><span>.</span><span>to_vec</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span></pre></div>
<p dir="auto">Additional documentation can be generated using <code>cargo docs</code> and is hosted <a href="https://github.com/onecodex/rust-bfield/blob/main/...">on docs.rs</a> for the latest <code>rust-bfield</code> release.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto"><em>üöß Current Limitations of the <code>rust-bfield</code> Implementation</em></h3><a id="user-content--current-limitations-of-the-rust-bfield-implementation" aria-label="Permalink: üöß Current Limitations of the rust-bfield Implementation" href="#-current-limitations-of-the-rust-bfield-implementation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This implementation has several current limitations:</p>
<ul dir="auto">
<li>
<strong><code>u32</code> Values</strong>: Currently, this implementation only permits storing <code>u32</code> values, though those can trivially be mapped to any other arbitrary values, e.g., by using them as indices for an array of mapped values (<code>[value1, value2, value3, ...]</code>).</li>
<li>
<strong>No Parameter Selection Assistance</strong>: Currently, the <code>create</code> function requires manually specifying all of the B-field parameters. A future interface might automatically (and deterministically) select optimal parameters based on input information about the number of discrete <code>values</code> ( <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\theta$</math-renderer> below) and desired false positive and indeterminacy error rates ( <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\alpha$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta$</math-renderer> below, respectively).</li>
<li>
<strong>No Higher-Level Insertion Management</strong>: Because creation of a B-field with no indeterminacy error <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$(\beta\approx0)$</math-renderer> requires setting <code>n_secondaries</code> number of inserts (e.g., ~4), it is necessary to iterate through all inserted elements <code>n_secondaries</code> times (see <a href="https://github.com/onecodex/benches/benchmark.rs">benchmark.rs</a> for a crude example). A higher-level insertion function would take an <code>Iterable</code> data structure and manage performing the proper number of repeated insertions for the end-user.</li>
</ul>
<div dir="auto"><h2 tabindex="-1" dir="auto">Formal Data Structure Details</h2><a id="user-content-formal-data-structure-details" aria-label="Permalink: Formal Data Structure Details" href="#formal-data-structure-details"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>

<p dir="auto">In contrast to Bloom filters, which only support set membership queries, B-fields enable efficiently storing a set of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x, y$</math-renderer> key-value pairs, where <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$S$</math-renderer> is the set of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$n$</math-renderer> stored <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x$</math-renderer> values <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$(|S|=n)$</math-renderer>, <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$D$</math-renderer> is the set of all possible <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y$</math-renderer> values <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$(f:S \to D)$</math-renderer>, and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\theta$</math-renderer> represents the &#34;value range&#34; of the B-field <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$(max(D)=\theta)$</math-renderer>. Put differently, if <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$f(x)=y$</math-renderer> is the function that maps all <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x$</math-renderer> values to their corresponding <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y$</math-renderer> value, such that <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$f(x)=y$</math-renderer>, <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$D$</math-renderer> is the domain of the function <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$f(x)$</math-renderer>.</p>
<p dir="auto">B-fields have a number of advantages of other probabilistic and deterministic data structures for associating keys and values. Specifically, B-fields exhibit a unique combination of properties that makes them ideal for storing very large sets of keys mapped to a modest number of discrete values:</p>
<ul dir="auto">
<li>
<strong>Space Efficiency</strong>: B-fields probabilistically store key-value pairs in a highly space-efficient manner optimized for in-memory use. For many common use cases or configurations, it is possible to store many billions of elements using only tens of gigabytes of storage (or a few bytes per key-value pair). These space requirements scale linearly with the number of elements in the B-field <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$n$</math-renderer> (i.e., B-fields have <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$O(n)$</math-renderer> space complexity).</li>
<li>
<strong>Speed</strong>: B-fields are optimized for in-memory storage of key-value pairs and require little computational overhead and few memory accesses (implementation speed should resemble that of a Bloom filter). All B-field insert and lookup operations have <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$O(1)$</math-renderer> time complexity.</li>
<li>
<strong>Well-Defined and Bounded Errors</strong>: Three major types of errors are possible with probabilistic associative arrays:
<ul dir="auto">
<li>
<strong>False Positives</strong>: A false positive occurs when a data structure returns a value for <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y$</math-renderer> when <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x\notin S$</math-renderer> (vs. returning <code>None</code> or equivalent). B-fields do exhibit false positives at an error rate of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\alpha$</math-renderer>. At the cost of reduced space efficiency, it is possible to select parameters that result in <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\alpha$</math-renderer> being arbitrarily small. False positives are a common feature of probabilistic data structures, but a disadvantage of the B-field versus deterministic data structures (e.g., a hash table).</li>
<li>
<strong>Indeterminacy</strong>: An indeterminacy error, denoted <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta$</math-renderer>, is the rate at which a data structure returns two or more possible values <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y$</math-renderer> for an element <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x \in S$</math-renderer>. This can take the form of a vector of possible <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y$</math-renderer> values or an error type (e.g., this implementation returns <code>Indeterminate</code>). While the internal arrays that together comprise a B-field each independently exhibit substantial <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta$</math-renderer> errors, appropriate B-field parameter selection allows <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta = 0$</math-renderer> or <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta \approx 0$</math-renderer>.</li>
<li>
<strong>Erroneous Retrieval / Mismapping</strong>: An erroneous retrieval or mismapping error <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\gamma$</math-renderer> occurs when a data structure is queries for an <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x \in S$</math-renderer> and returns the wrong value of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y$</math-renderer> such that <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$f(x) \ne y$</math-renderer>. Erroneous retrievals are not possible with B-fields.</li>
</ul>
</li>
</ul>

<blockquote>
<p dir="auto"><g-emoji alias="warning">‚ö†Ô∏è</g-emoji> Warning: This section provides a detailed overview of the math underlying the B-field data structure and is intended for those interested in those mechanics or those implementing a new B-field library. Many readers may prefer to skip ahead to the <a href="#summarizing-b-field-properties">Summarizing B-field Properties</a> subsection.</p>
</blockquote>
<p dir="auto">The B-field works by encoding <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y$</math-renderer> into a binary pattern or string and then inserting that binary pattern into a series of bit arrays using <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$k$</math-renderer> distinct hash functions <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$(h_{1}..h_{k})$</math-renderer> for each inserted element <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x$</math-renderer>. While many of the implementation details that follow will be familiar to those acquainted with hash-based data structures in general and Bloom filters specifically, the B-field is designed for storing key-value  pairs rather than simple set membership information. The basic construction of a B-field requires each of the following steps:</p>

<p dir="auto">As the first step, the user needs to select several configuration options, which will determinate how the initial B-field is constructed. These key configuration variables are:</p>
<p dir="auto">(a) The desired maximum false positive rate <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\alpha$</math-renderer>.</p>
<p dir="auto">(b) The expected number of values to be stored <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$n$</math-renderer> where <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$n=|S|$</math-renderer>. If more than <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$n$</math-renderer> elements are inserted into the B-field, the expected false positive rate will exceed <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\alpha$</math-renderer>.</p>
<p dir="auto">(c) The maximum value <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\theta$</math-renderer> of the set of all possible <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y$</math-renderer> values. Note that using the default encoding system outlined here, the range of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y$</math-renderer> values <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$D$</math-renderer> must consist of all or a subset of the non-negative integers <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">${1, ...,  \theta}$</math-renderer> or <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">${0, ..., \theta - 1}$</math-renderer>. This can, however, be easily mapped to any set of up to <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\theta$</math-renderer> distinct values by simply using <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y$</math-renderer> as an index or pointer to a value in a set <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$D\prime$</math-renderer> where <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$|D\prime| = \theta$</math-renderer> (in which case <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y$</math-renderer> serves as an intermediate value).</p>
<p dir="auto">(d) The value <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu$</math-renderer> and a value <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa$</math-renderer> such that <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">${\nu \choose \kappa}\ge\theta$</math-renderer>, where <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">${\nu \choose \kappa}$</math-renderer> is simply the combination formula, but using <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu$</math-renderer> as the parameter instead of the more common <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$n$</math-renderer> (which is used for B-fields and Bloom filters to denote the cardinality of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$S$</math-renderer> or <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$|S|$</math-renderer>) and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa$</math-renderer> in place of the more common <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$k$</math-renderer> (which is used to enumerate the number of required hash functions <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$h_{1}...h_{k}$</math-renderer>):</p>
<p dir="auto"><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$${\nu \choose \kappa}=\frac{\nu!}{\kappa!(\nu-\kappa)!}$$</math-renderer></p>
<p dir="auto">As the B-field encodes the values <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y$</math-renderer> in <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu$</math-renderer>-length bit-strings with exactly <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa$</math-renderer> ones (or a Hamming weight of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa$</math-renderer> in information theoretic terms), it is best to both: (i) minimize <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa$</math-renderer>; and (ii) keep <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu$</math-renderer> within an order of magnitude of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa$</math-renderer> while selecting <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa$</math-renderer>. For example, in choosing values for <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa$</math-renderer> such that <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">${\nu \choose \kappa} \ge 1000$</math-renderer> it is preferable to set <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu = 20$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa = 3$</math-renderer> <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$({\nu \choose \kappa} = 1140)$</math-renderer> instead of setting <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu = 1000$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa = 1$</math-renderer>. The reasons for this should become clear in the proceeding discussion of error rates and the B-field&#39;s operation.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto"><strong>2. Bit Array Sizing and Hash Function Selection.</strong></h4><a id="user-content-2-bit-array-sizing-and-hash-function-selection" aria-label="Permalink: 2. Bit Array Sizing and Hash Function Selection." href="#2-bit-array-sizing-and-hash-function-selection"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Next, it is necessary to select a size for the primary bit array used in the B-field and select an appropriate number of hash functions <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$k$</math-renderer>. As the B-field hashes the input keys into a bit array in a manner similar to a Bloom filter, the same underlying formulas may be used for selecting the optimal size of the bit array and number of hash functions, with the exception that a B-field requires an <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$m\kappa$</math-renderer>-bit array vs. the <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$m$</math-renderer>-bit array required by a simple Bloom filter (here <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$p$</math-renderer> represents the probability of a single bit error, which is defined further below in 5b):</p>
<p dir="auto"><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$$m=-\frac{{n\ln p}}{(\ln2)^{2}}$$
$$k=\frac{m}{n}\ln2$$</math-renderer></p>
<p dir="auto">With regards to the selection of the hash function itself, any hash function with good pseudorandomness and distribution qualities will suffice for the B-field. While the prior equations assume a perfectly random hash function, the B-field performs comparably with non-cryptographic hash functions (such as MurmurHash3 or similar hash functions). Again, while the set of hash functions should in theory be fully independent, in practice it is possible (and preferable for performance reasons) to simply use 2 independent hash functions as seeds and then relax the independence requirements for the remaining hash functions, i.e., two seed hash functions <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$h_{a}(x)$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$h_{b}(x)$</math-renderer> can be used to create <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$k$</math-renderer> composite hash functions with each defined as <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$h_{k}(x)=h_{a}(x) \times ((n-1) \times h_{b}(x))$</math-renderer> (see <a href="http://dx.doi.org/10.1002/rsa.20208" rel="nofollow">Kirsch and Mitzenmacher 2008</a> for details)</p>

<p dir="auto">Now having calculated <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$m$</math-renderer> and selected <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa$</math-renderer>, we allocate an <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$m\kappa$</math-renderer>-bit array of memory, setting all bits initially to 0. Note that the B-field may make use of multiple bit arrays and this initial <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$m\kappa$</math-renderer>-bit array is termed the B-field <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{0}}$</math-renderer>.</p>

<p dir="auto">Next, the keys of the B-field <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$(x_{1}...x_{n})$</math-renderer> and their corresponding values <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$(y_{1}...y_{n})$</math-renderer> are inserted. This requires two steps or functions for all <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x$</math-renderer> in <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x_{1}...x_{n}$</math-renderer>.</p>
<p dir="auto">(a) <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{ENCODE}$</math-renderer>. The <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{ENCODE}$</math-renderer> operation translates a given value <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y$</math-renderer> into a binary <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu$</math-renderer>-length string with <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa$</math-renderer> 1s for insertion into the B-field primary array <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$(\mathtt{Array_{0}})$</math-renderer>. Using the standard encoding system, this simply involves translating <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y$</math-renderer> into the <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y^{th}$</math-renderer> <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu$</math-renderer>-length <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa$</math-renderer>-weight bit-string of all <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu \choose \kappa$</math-renderer> combinations in lexicographic order (e.g., 1 translates to <code>0001</code> if <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu = 4$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa = 1$</math-renderer>). Other even- and uneven-weighted coding schemes could also be used in this step (e.g., error-correcting codes), but are not detailed or further evaluated here. Figure 1 illustrates how the <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{ENCODE}$</math-renderer> (and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{DECODE}$</math-renderer>) operation works where <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu = 5, \kappa = 2$</math-renderer>.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/onecodex/rust-bfield/blob/main/docs/imgs/figure1.png"><img src="https://github.com/onecodex/rust-bfield/raw/main/docs/imgs/figure1.png" alt="Figure 1"/></a></p>
<p dir="auto"><strong>Figure 1:</strong> Sample <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{ENCODE}$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{DECODE}$</math-renderer> operations for <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu = 5$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa = 2$</math-renderer>.</p>
<p dir="auto">(b) <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{INSERT}$</math-renderer>. The <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{INSERT}$</math-renderer> operation places the coded value <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y$</math-renderer> (associated with the key <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x$</math-renderer>) into the B-field. First, the <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$k$</math-renderer> hash functions are applied to <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x$</math-renderer> <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$(h_{1}(x)...h_{k}(x))$</math-renderer> and the <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{mod}(m\kappa)$</math-renderer> of each value is taken (i.e., the modulo operation is applied to the hashed value <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$h(x)$</math-renderer> using the size of the bit array <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$m\kappa$</math-renderer>). These <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$k$</math-renderer> hashed values, where <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$0 \le h(x) \mathtt{mod} m\kappa \le m\kappa$</math-renderer>, serve as indices for the bitwise OR insertion of the coded value <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y$</math-renderer>, where the first bit of the <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu$</math-renderer>-length bit-string is <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$h(x) \mathtt{mod} m\kappa$</math-renderer> and the last bit is <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$h(x) \mathtt{mod} m\kappa + \nu - 1$</math-renderer>. In the case of inserting the first <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x, y$</math-renderer> key-value pair into an empty <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{0}}$</math-renderer> where <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$k=6, \nu=5, \kappa=2$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y=2$</math-renderer> (impractically small values but useful for illustration), the result would be bitwise ORing the bit-string <code>00101</code> into the <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$m\kappa$</math-renderer>-bit array 6 times <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$(k=6)$</math-renderer> and flipping a total of 12 bits from 0 to 1 (<math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$k \times \kappa$</math-renderer>). Figure 2 illustrates a sample <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{INSERT}$</math-renderer> operation for a key-value pair where the value <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y=2$</math-renderer> and the B-field is configured with <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu = 5, \kappa = 2$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$k=6$</math-renderer>. The pictured operation is the same for insertion into <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{0}}$</math-renderer> or any secondary array (described further below).</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/onecodex/rust-bfield/blob/main/docs/imgs/figure2.png"><img src="https://github.com/onecodex/rust-bfield/raw/main/docs/imgs/figure2.png" alt="Figure 2"/></a></p>
<p dir="auto"><strong>Figure 2:</strong> Sample <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{INSERT}$</math-renderer> operation: (a) Hash an input key <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x$</math-renderer> <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$k$</math-renderer> times, providing <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$k$</math-renderer> indices for positions in a B-field array; (b) Encode the value <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y$</math-renderer> associated with the key <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x$</math-renderer> into a <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu$</math-renderer>-length, <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa$</math-renderer>-weight bit-string (here <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y=2, \nu=5$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa=2$</math-renderer>); and (c) Perform a bitwise OR between a <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu$</math-renderer>-length slice of the array and the encoded <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu$</math-renderer>-length bit-string representing the coded value <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y$</math-renderer>, for all <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$k$</math-renderer> hash functions <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$h_{1}(x)...h_{k}(x)$</math-renderer>.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto"><strong>5. Construction of Subsequent B-field Arrays</strong></h4><a id="user-content-5-construction-of-subsequent-b-field-arrays" aria-label="Permalink: 5. Construction of Subsequent B-field Arrays" href="#5-construction-of-subsequent-b-field-arrays"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">In order to describe the construction of subsequent arrays <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{1}}...\mathtt{Array_{a-1}}$</math-renderer> where <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$a$</math-renderer> is the total number of bit arrays in the B-field, we briefly highlight: (a) how the <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{LOOKUP}$</math-renderer> operation is performed; and (b) the different types of error in the B-field as constructed thus far.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto"><strong>5(a). The <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{LOOKUP}$</math-renderer> operation.</strong></h4><a id="user-content-5a-the-mathttlookup-operation" aria-label="Permalink: 5(a). The $\mathtt{LOOKUP}$ operation." href="#5a-the-mathttlookup-operation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{LOOKUP}$</math-renderer> operation mirrors the <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{INSERT}$</math-renderer>. For a given <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x_{i}$</math-renderer>, we hash <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x_{i}$</math-renderer> <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$k$</math-renderer> times using the hash functions <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$h_{1}...h_{k}$</math-renderer> (all <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{mod} m\kappa$</math-renderer>). At each index position for <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$h_{1}(x_{i})...h_{k}(x_{i})$</math-renderer> a <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu$</math-renderer>-length bit string is taken and bitwise ANDed with an initial <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu$</math-renderer>-length bit-string consisting of all 1s (i.e., having a Hamming weight of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu$</math-renderer>). Using the values from the prior example in Figure 2, if the following 6 5-bit strings <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">${10101, 11111, 00111, 11111, 00101, 11101}$</math-renderer> are found in the B-field <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{0}}$</math-renderer> at <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$h_{1}(x_{i})...h_{k}(x_{i})$</math-renderer>, the bitwise AND of these returns <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$00101$</math-renderer> which we <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{DECODE}$</math-renderer> to the yield the value 2 for <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y_{i}$</math-renderer>. Figure 3 details this sample <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{LOOKUP}$</math-renderer> operation.</p>
<p dir="auto">A <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{LOOKUP}$</math-renderer> operation can yield any of the following:</p>
<ul dir="auto">
<li>
<p dir="auto">A bit string with a Hamming weight <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\lt \kappa$</math-renderer> indicates <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x \notin S$</math-renderer>. This is due to the fact that the <code>INSERT</code> operation detailed in 4(b) inserts <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa$</math-renderer> 1s with a bitwise OR, guaranteeing that at least <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa$</math-renderer> 1s will be returned via any subsequent <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{LOOKUP}$</math-renderer> of the same element. In this case, a B-field implementation should return <code>None</code> or a similar value that represents an <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x_{i} \notin S$</math-renderer>.</p>
</li>
<li>
<p dir="auto">A bit string with a Hamming weight <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$=\kappa$</math-renderer>. In this case, we <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{DECODE}$</math-renderer> the resulting bit string (simply the inverse of the <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{ENCODE}$</math-renderer> operation detailed in Figure 1) and the value <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y_{i}$</math-renderer> mapping to the key <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x_{i}$</math-renderer> is returned. This operation will erroneously return a <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y_{i}$</math-renderer> for an <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x \notin S$</math-renderer> at the false positive rate of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\alpha$</math-renderer> (derived below in 5(b)).</p>
</li>
<li>
<p dir="auto">Finally, a bit string with a Hamming weight of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\gt \kappa$</math-renderer> will be retrieved with a probability of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta$</math-renderer> (also derived below in 5(b)). This represents an <code>Indeterminate</code> result with more than <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa$</math-renderer> 1s. The dramatic reduction of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta$</math-renderer> is achieved via the construction of subsequent B-field arrays <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{1}}...\mathtt{Array_{a-1}}$</math-renderer>.</p>
</li>
</ul>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/onecodex/rust-bfield/blob/main/docs/imgs/figure3.png"><img src="https://github.com/onecodex/rust-bfield/raw/main/docs/imgs/figure3.png" alt="Figure 3"/></a></p>
<p dir="auto"><strong>Figure 3:</strong> Sample <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{LOOKUP}$</math-renderer> operation: (a) A key <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x$</math-renderer> is hashed <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$k$</math-renderer> times, and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu$</math-renderer>-length, <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa$</math-renderer>-weight bit strings are extracted from the B-field array; (b) The <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$k$</math-renderer> bit strings are bitwise ANDed together; and (c) The resulting bit string is <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{DECODE}$</math-renderer>-ed to recover the value <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y$</math-renderer> associated with the key <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x$</math-renderer>.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto"><strong>5(b). B-field error rates detailed.</strong></h4><a id="user-content-5b-b-field-error-rates-detailed" aria-label="Permalink: 5(b). B-field error rates detailed." href="#5b-b-field-error-rates-detailed"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">As noted above, the <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{LOOKUP}$</math-renderer> operation in B-field <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{0}}$</math-renderer> suffers from both false positive <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$(\alpha)$</math-renderer> and indeterminacy <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$(\beta)$</math-renderer> errors. These error rates can be simply derived based on the above <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{INSERT}$</math-renderer> operation&#39;s mechanics, which sets up to <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa$</math-renderer> random bits within the bit array to 1 for each of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$k$</math-renderer> hash functions. Note that these properties and error rates mirror those of a Bloom filter and, indeed, a B-field where <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu = 1, \kappa = 1$</math-renderer> and only a single bit array is used <em>is equivalent to a Bloom filter</em> (since it sets a single bit with each operation).</p>
<p dir="auto">First, we need to determine the probability that any single bit in the <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu$</math-renderer>-length bit string will be incorrect after the <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$k$</math-renderer> bit strings are bitwise ANDed together (described here as <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$p$</math-renderer>, the probability of a single bit error). The probability that an individual bit is <strong>not set</strong> to 1 by a single hash function (each of which flips <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa$</math-renderer> bits) during the insertion of an element <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x_{i}$</math-renderer> is:</p>
<p dir="auto"><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$$1-\frac{\kappa}{m\kappa}$$</math-renderer></p>
<p dir="auto">We can then cancel out <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa$</math-renderer>:</p>
<p dir="auto"><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$$1-\frac{1}{m}$$</math-renderer></p>
<p dir="auto">Thus, the probability that a single bit is <strong>not set</strong> for any of the <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$k$</math-renderer> hash functions is:</p>
<p dir="auto"><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$$(1-\frac{1}{m})^{k}$$</math-renderer></p>
<p dir="auto">After <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$n$</math-renderer> insertions of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x_{1}...x_{n}$</math-renderer> into a bit array, the probability that a given bit remains 0 is:</p>
<p dir="auto"><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$$(1 - \frac{1}{m})^{kn}$$</math-renderer></p>
<p dir="auto">And the probability that it is set to 1 is:</p>
<p dir="auto"><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$$1-(1 - \frac{1}{m})^{kn}$$</math-renderer></p>
<p dir="auto">After each of the <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$k$</math-renderer> individual accesses that comprise the <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{LOOKUP}$</math-renderer> operation for a given bit array (one per hash function), the probability than an individual bit is incorrectly set to 1 is:</p>
<p dir="auto"><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$$(1-(1-\frac{1}{m})^{kn})^{k} \approx (1-e^{-kn/m})^{k}$$</math-renderer></p>
<p dir="auto">Substituting the formulas for optimal <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$m$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$k$</math-renderer> values from above yields:</p>
<p dir="auto"><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$$p=(1-e^{(-m/n \ln 2)n/m})^{(m/n \ln 2)}$$</math-renderer></p>
<p dir="auto">Where <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$p$</math-renderer> is the probability that a given bit in the <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu$</math-renderer>-bit string encoding a given value <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y_{i}$</math-renderer> is set to 1 before an <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{INSERT}$</math-renderer> operation is performed (i.e., that a subsequent <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{LOOKUP}$</math-renderer> will fail with a false positive or indeterminacy error).</p>
<p dir="auto">Using <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$p$</math-renderer>, we can then derive the probability of a false positive for the overall <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{0}}$</math-renderer> of the B-field <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$(\alpha_{0})$</math-renderer>. Since a false positive is defined as there being <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\gt \kappa$</math-renderer> bits flipped to 1 in a <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu$</math-renderer>-bit string, <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\alpha_{0}$</math-renderer> is <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathit{CumBinom}(\nu, \kappa, p)$</math-renderer> where <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathit{CumBinom}$</math-renderer> is the right tail of the cumulative binomial distribution:</p>
<p dir="auto"><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$$\alpha=Pr(X\ge\kappa)=\sum_{i=\kappa}^{\nu}{\nu \choose i}p^{i}(1-p)^{\nu-i}$$</math-renderer></p>
<p dir="auto">And, correspondingly, <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta$</math-renderer> is the probability that a given value <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x \in S$</math-renderer> returns a <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu$</math-renderer>-length bit string with <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\gt \kappa$</math-renderer> bits flipped to 1 (at least <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa$</math-renderer> bits are guaranteed to be set ot 1 by the <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{INSERT}$</math-renderer> operation). This corresponds to <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathit{CumBinom}(\nu - \kappa, 1, p)$</math-renderer>. Without correction, <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta$</math-renderer> is too high for many applications (though usable for others), and consequently, the next step in the B-field&#39;s construction is an effort to correct <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta$</math-renderer> such that <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta \approx 0$</math-renderer>. This correction reduces <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\alpha$</math-renderer> from the cumulative binomial distribution for all values <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\ge \kappa$</math-renderer> to the binomial distribution for <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa$</math-renderer> exactly, which is <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">${\nu \choose \kappa}p^{\kappa}(1-p)^{\nu-\kappa}$</math-renderer>.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto"><strong>5(c). Reduction of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta$</math-renderer> Error through Construction of Additional Bit Arrays</strong></h4><a id="user-content-5c-reduction-of-beta-error-through-construction-of-additional-bit-arrays" aria-label="Permalink: 5(c). Reduction of $\beta$ Error through Construction of Additional Bit Arrays" href="#5c-reduction-of-beta-error-through-construction-of-additional-bit-arrays"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Given these error rates <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\alpha$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta$</math-renderer>, an additional correction is desirable. In order to (nearly) eliminate the indeterminacy error rate <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta$</math-renderer> (and as a side effect, greatly reduce the magnitude of the false positive error rate <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\alpha$</math-renderer>), we iterate through all of the input keys <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x_{1}...x_{n}$</math-renderer> an additional time after the first complete insert into <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{0}}$</math-renderer>. This time, however, instead of inserting them into <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{0}}$</math-renderer>, we perform a <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{LOOKUP}$</math-renderer> operation and note the Hamming weight of each <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu$</math-renderer>-bit string <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$(w_{i})$</math-renderer> for each <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x_{i}$</math-renderer>. If <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$w_{i} \gt \kappa$</math-renderer>, we have an indeterminacy error as a known <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x \in S$</math-renderer> is not returning its corresponding <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu$</math-renderer>-length <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa$</math-renderer>-weight bit string. The subset of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x_{1}...x_{n}$</math-renderer> for which <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$w_{i} \gt \kappa$</math-renderer> to include <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta n$</math-renderer> elements. This <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta n$</math-renderer> subset is then inserted into a second array <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{1}}$</math-renderer>, which is created following the above steps except it is scaled down to be a <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\approx \beta m\kappa$</math-renderer> bits in size and stores only <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta n$</math-renderer> elements instead of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$n$</math-renderer> key-value pairs.</p>
<p dir="auto">This secondary array <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{1}}$</math-renderer> allows for an indeterminate <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{LOOKUP}$</math-renderer> of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x_{i}$</math-renderer> in <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{0}}$</math-renderer> yield <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\gt \kappa$</math-renderer> 1 bits to have a <em>second</em> lookup performed against <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{1}}$</math-renderer>. Since the probability of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x_{i}$</math-renderer> yielding <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\gt \kappa$</math-renderer> 1 bits is <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta$</math-renderer> for <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{0}}$</math-renderer> and also <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta$</math-renderer> for <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{1}}$</math-renderer> (which shares identical parameters except for its overall size and number of stored key-value pairs), the indeterminacy rate is reducted from <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta$</math-renderer> to <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta^2$</math-renderer> with the addition of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{1}}$</math-renderer>.</p>
<p dir="auto">Further arrays <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{2}}...\mathtt{Array_{a-1}}$</math-renderer> can be added until a set of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$a$</math-renderer> arrays is formed, choosing <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$a$</math-renderer> such that <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta^{a}n \lt 1$</math-renderer> (though in practice, it will often suffice to simply pick a value of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$a$</math-renderer> such that only a handful of elements in <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$n$</math-renderer> will be inserted into <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{a-1}}$</math-renderer>). These secondary arrays also have the effect of lowering the false positive rate <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\alpha$</math-renderer> because a false positive where <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x_{i} \notin S$</math-renderer> yielding <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\gt \kappa$</math-renderer> 1 bits also leads to a check against <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{1}}$</math-renderer> (and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{2}}...\mathtt{Array_{a-1}}$</math-renderer> as appropriate). This reduces the false positive rate <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\alpha$</math-renderer> from the cumulative binomial towards the simple binomial <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">${\nu \choose \kappa}p^{\kappa}(1-p)^{\nu-\kappa}$</math-renderer>. Alternatively, we can understand this as reducing the set of circumstances where <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\alpha$</math-renderer> errors can occur from anytime <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\ge \kappa$</math-renderer> 1 bits are flipped for an <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x_{i} \notin S$</math-renderer> to two cases: (1) when exactly <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa$</math-renderer> 1 bits in <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{0}}$</math-renderer> for an <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x_{i} \notin S$</math-renderer> (the simple binomial); or (2) the exceedingly rare case where <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\gt \kappa$</math-renderer> 1 bits are flipped in <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{0}}...\mathtt{Array_{a-2}}$</math-renderer> and exactly <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa$</math-renderer> bits are flipped in <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{a-1}}$</math-renderer>. The probability of the second case should be <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\approx 0$</math-renderer> as the chance of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\gt \kappa$</math-renderer> bits flipping decreases exponentially with the addition of each secondary.</p>
<p dir="auto">To summarize, this cascade of secondary arrays beyond <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{0}}$</math-renderer> <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$(\mathtt{Array_{1}}...\mathtt{Array_{a-1}})$</math-renderer> reduces the false positive rate <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\alpha$</math-renderer> from a cumulative binomial distribution to the binomial for <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa$</math-renderer> individual bit-level errors and eliminates all indeterminacy errors (i.e., <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta = 0$</math-renderer> or <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta \approx 0$</math-renderer>). And, this error reduction is achieved at quite modest cost to the space efficiency of the B-field. Recall that the original space requirements for <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{0}}$</math-renderer> of the B-field is <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$m\kappa$</math-renderer> bits where <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$m=-\frac{n \ln \alpha}{(\ln 2)^{2}}$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa$</math-renderer> is selected for <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">${\nu \choose \kappa} \gt \theta$</math-renderer> where <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\theta$</math-renderer> is the maximum value of the domain of stores values <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y_{1}...y_{n}$</math-renderer> or <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$|D|$</math-renderer> in the case where <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y_{1}...y_{n}$</math-renderer> is <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$1...n$</math-renderer>. Consequently, <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{0}}$</math-renderer> requires <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta^{0}m\kappa$</math-renderer> bits, while <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{1}}$</math-renderer> requires <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta^{1}m\kappa$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{a-1}}$</math-renderer> requires <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta^{a-1}m\kappa$</math-renderer>. Dividing everything by <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$m\kappa$</math-renderer> bits reveals the underlying geometreic series:</p>
<p dir="auto"><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$$1+\beta^{1}+...+\beta^{a-1}$$</math-renderer></p>
<p dir="auto">The sum of which is simply:</p>
<p dir="auto"><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$$\frac{1}{1 - \beta}$$</math-renderer></p>
<p dir="auto">Thus, the total space requirements for a B-field with a primary <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{0}}$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$a - 1$</math-renderer> secondary arrays is only <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\frac{1}{1-\beta}m\kappa$</math-renderer> bits. In many uses cases, an initial uncorrected indeterminacy rate of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$0.05 \le \beta \le 0.20$</math-renderer> would not be uncommon. Correcting this for a 5.3% <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$(\frac{1}{0.95})$</math-renderer> or 25.0% <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$(\frac{1}{0.80})$</math-renderer> space penalty is generally a good tradeoff, though a B-field can be constructed with only <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{0}}$</math-renderer> at the cost of needing to manage <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta$</math-renderer> indeterminacy errors in the key-value lookups.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto"><em>Summarizing B-field Properties</em></h3><a id="user-content-summarizing-b-field-properties" aria-label="Permalink: Summarizing B-field Properties" href="#summarizing-b-field-properties"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">To briefly summarize, a B-field is a probabilistic associative array or map with the following unique set of properties:</p>
<ul dir="auto">
<li>
<p dir="auto"><strong>Creation &amp; Insertions</strong>: <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$O(n)$</math-renderer> total creation time and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$O(1)$</math-renderer> insertions, requiring an average of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\frac{\kappa}{1-\beta}$</math-renderer> hash computations and memory accesses, and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$a\kappa$</math-renderer> hash computations and memory accesses in the worst case. A common value of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$a$</math-renderer> would be <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\approx 4$</math-renderer>.</p>
</li>
<li>
<p dir="auto"><strong>Lookups</strong>: <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$O(1)$</math-renderer> lookups, requiring the same number of hash computations and memory accesses as an insertion.</p>
</li>
<li>
<p dir="auto"><strong>Space Complexity</strong>: <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$O(n)$</math-renderer> space complexity, requiring <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\frac{m\kappa}{1-\beta}$</math-renderer> bits where <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$m$</math-renderer>, <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa$</math-renderer>, and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta$</math-renderer> are defined above ( <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{0}}$</math-renderer> requires <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$m\kappa$</math-renderer> bits, while the entire B-field requires an additional factor of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$1 - \frac{1}{1-\beta}$</math-renderer>).</p>
</li>
</ul>

<p dir="auto">An efficient B-field requires optimal selection of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\nu$</math-renderer>, <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\kappa$</math-renderer>, the B-field <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{Array_{0}}$</math-renderer> size <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$(m\kappa)$</math-renderer>, and calculation of the required scaling factor for secondary arrays (uncorrected <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\beta$</math-renderer>). The
<a href="https://github.com/onecodex/docs/notebook/calculate-parameters.ipynb">parameter selection notebook</a> included here provides a template for computing these parameters.</p>

<p dir="auto">A number of additional extensions to the B-field design are possible, but not implemented here. Several are outlined below:</p>
<ul dir="auto">
<li>
<strong>Mutability</strong>: While this implementation is designed to support immutable B-fields, it is possible to implement a mutable B-field. For example, <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\mathtt{INSERT}$</math-renderer> operations may be saved and replayed in a continuous or batch fashion to ensure that all elements <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x \in S$</math-renderer> are properly inserted into a B-field&#39;s primary and secondary arrays.</li>
<li>
<strong>Cache Locality</strong>: Optimize the speed of memory accesses by setting a subset of the hash functions <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$h_{1}(x)...h_{k}(x)$</math-renderer> to perform lookups at a small fixed offset from a prior memory access (i.e., set <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$h_{2}(x)$</math-renderer> to select a random location within a fixed window after <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$h_{1}(x)$</math-renderer> in order to take advantage of cache locality).</li>
<li>
<strong>Alternative encoding schemes</strong>: While the above simple encoding scheme is well suited to relatively well distributed <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y$</math-renderer> values across a domain <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$\theta$</math-renderer>, it is possible to change the encoding scheme to, for example, (i) use an error-correcting code or (ii) use different weights for the subset of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y$</math-renderer> values that occur more frequently (to have the effect of minimizing the &#34;fill&#34; of the B-field arrays) amongst other possibilities.</li>
</ul>
<div dir="auto"><h3 tabindex="-1" dir="auto"><em>When to Consider Alternative Data Structures</em></h3><a id="user-content-when-to-consider-alternative-data-structures" aria-label="Permalink: When to Consider Alternative Data Structures" href="#when-to-consider-alternative-data-structures"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li>An associative array or map (e.g., a simple hash table) is likely a better choice when storing <code>(x, y)</code> pairs with many distinct <code>y</code> values (e.g., storing 1M keys with 800,000 distinct values). See <a href="#formal-data-structure-overview">Formal Data Structure Overview</a> and <a href="#parameter-selection">Parameter Selection</a> for further details on optimal use cases for a B-field.</li>
<li>A <a href="https://en.wikipedia.org/wiki/Perfect_hash_function#Minimal_perfect_hash_function" rel="nofollow">[minimal] perfect hash function</a> (possibly paired with a Bloom filter or other data structure supporting set membership queries) is a better choice for any injective function mappings, where there is one unique <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$y$</math-renderer> value <em>for each</em> <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="0a186f64e5a6107a8669f1f00105361e">$x$</math-renderer> (e.g., de Bruijn graph implementations)</li>
<li>Despite <a href="">reducing to a Bloom filter when configured with the appropriate parameters</a>, a Bloom filter (or perhaps <a href="https://lemire.me/blog/2019/12/19/xor-filters-faster-and-smaller-than-bloom-filters/" rel="nofollow">xor filter</a>) is a better choice than a B-field for supporting simple set membership queries</li>
</ul>

<p dir="auto">The B-field data structure was developed by Nick Greenfield (<a href="https://github.com/boydgreenfield">@boydgreenfield</a>) in collaboration with Nik Krumm (<a href="https://github.com/nkrumm">@nkrumm</a>) in 2013 as part of a metagenomics classifier developed under DTRA&#39;s 2013 Algorithm Challenge (some details on on Jonathan Eisen&#39;s blog <a href="https://phylogenomics.me/tag/dtra/" rel="nofollow">here</a>, primary content no longer online). After initial proof-of-concept implementations in Python, Cython, and C, a Nim implementation was developed in 2014 by <a href="https://github.com/boydgreenfield">@boydgreenfield</a> and used in production for ~4 years as part of One Codex&#39;s core metagenomics classifier (first described <a href="https://www.biorxiv.org/content/10.1101/027607v2" rel="nofollow">here</a>). Dominik Picheta (<a href="https://github.com/dom96">@dom96</a>) and Alex Bowe (<a href="https://github.com/alexbowe">@alexbowe</a>) contributed additional enhancements and ideas to the <code>nim-bfield</code> implementation in 2015.</p>
<p dir="auto">In 2017, Roderick Bovee (<a href="https://github.com/bovee">@bovee</a>) ported the <code>nim-bfield</code> library to this implementation in Rust, which continues to be used in the second-generation metagenomics classifier backing the One Codex platform. Vincent Prouillet (<a href="https://github.com/Keats">@Keats</a>) and Gerrit Gerritsen (<a href="https://github.com/GSGerritsen">@GSGerritsen</a>) contributed additional work (and documentation!) since 2020, and maintains the <code>rust-bfield</code> crate.</p>
<p dir="auto">In February 2021, One Codex was acquired by Invitae, where this library continued to be used as part of its metagenomics classification platform. In September 2022, the One Codex team spun the company back out of Invitae and decided to open source and make the B-field library freely available. We have done our best to document it here, and hope you find it useful! ‚ù§Ô∏è</p>

<p dir="auto">If you find this crate helpful, we&#39;d love to hear from you and document your use case here. Please feel free to open a PR against this section of the README or <a href="mailto:hello@onecodex.com">drop us an email</a>! üëã</p>

<p dir="auto">This source code is made available under the Apache 2 license with a patent grant (in order to ensure unencumbered use of the <code>rust-bfield</code> crate given a <a href="https://patents.google.com/patent/US20220093210A1/en" rel="nofollow">2014 patent</a>).</p>
</article></div></div>
  </body>
</html>
