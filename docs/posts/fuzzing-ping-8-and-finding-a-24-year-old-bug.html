<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tlakh.xyz/fuzzing-ping.html">Original</a>
    <h1>Fuzzing ping(8) and finding a 24 year old bug</h1>
    
    <div id="readability-page-1" class="page"><div id="content">


<div id="outline-container-org83968b5">
<h2 id="org83968b5">What about OpenBSD?</h2>
<div id="text-org83968b5">
<p>
<code>ping(8)</code> is ancient:
</p>
<pre id="org132a71c">* Author -
*      Mike Muuss
*      U. S. Army Ballistic Research Laboratory
*      December, 1983
</pre>

<p>
What we know today as <code>ping(8)</code> started to become recognizable in 1986, for
example see this <a href="https://github.com/csrg/csrg/commit/962056110ebf62ed8d4368964c7e82ac7434ea82">csrg commit</a>.
</p>

<p>
FreeBSD identified a stack overflow in the <code>pr_pack()</code> function and I
expected a lot of similarity between the BSDs. This stuff did not
change a lot since the csrg days.
</p>

<p>
Step one: Does this effect us? Turns out, it does not. FreeBSD rewrote
<code>pr_pack()</code> in <a href="https://github.com/freebsd/freebsd-src/commit/d9cacf605e2ac0f704e1ce76357cbfbe6cb63d52">2019</a>, citing alignment problems.
</p>

<p>
Now we could join the punters on the Internet and point and laugh. But
that&#39;s just rude, uncalled for, and generally boring and
pointless. Technically I&#39;m on vacation and I had resolved to only do
fun things this week. So let&#39;s have some fun.
</p>

<p>
Step two: Did we mess something else up? FreeBSD had a problem in
<code>pr_pack()</code> because that function handles data from the network. The
data is untrusted and needs to be validated. Now is a good a time as
any to check OpenBSD&#39;s implementation of <code>pr_pack()</code>. I wanted to try
fuzzing something, anything, with <a href="https://en.wikipedia.org/wiki/American_fuzzy_lop_(fuzzer)">afl</a> for a few years, but never got
around to it. I thought I might as well do it now, might be fun.
</p>
</div>
</div>

<div id="outline-container-orga7521b6">
<h2 id="orga7521b6">Make sure you are not holding it wrong.</h2>
<div id="text-orga7521b6">
<p>
I installed <code>afl++</code> from packages and glanced at
&#34;<a href="https://aflplus.plus/docs/tutorials/libxml2_tutorial/">Fuzzing libxml2 with AFL++</a>&#34;.  Here is what we need:
</p>
<ul>
<li>A program to test. Something with a know bug so that we can tell the
fuzzing works.</li>
<li>An input file, that does not trigger the bug.</li>
<li>Compile the program with <code>afl-clang-fast</code>.</li>
<li>Run <code>afl-fuzz</code>.</li>
</ul>

<p>
<a href="https://tlakh.xyz/fuzzing-ping/test.c"><code>test.c</code></a>:
</p>
<div>
<pre>

<span>#include</span> <span>&lt;err.h&gt;</span>
<span>#include</span> <span>&lt;stdio.h&gt;</span>
<span>#include</span> <span>&lt;stdlib.h&gt;</span>
<span>#include</span> <span>&lt;string.h&gt;</span>

<span>int</span>
<span>main</span>(<span>int</span> <span>argc</span>, <span>char</span> **<span>argv</span>)
{
        <span>FILE</span>    *<span>f</span>;
        <span>size_t</span>   <span>fsize</span>;
        <span>uint8_t</span> *<span>buf</span>, <span>len</span>, *<span>dbuf</span>;

        f = fopen(argv[1], <span>&#34;rb&#34;</span>);
        fseek(f, 0, SEEK_END);
        fsize = ftell(f);
        rewind(f);

        buf = malloc(fsize + 1);
        <span>if</span> (buf == <span>NULL</span>)
                err(1, <span>NULL</span>);
        fread(buf, fsize, 1, f);
        fclose(f);

        buf[fsize] = 0;

        len = buf[0];

        dbuf = malloc(len);
        <span>if</span> (dbuf == <span>NULL</span>)
                err(1, <span>NULL</span>);
        memcpy(buf + 1, dbuf, fsize - 1);
        warnx(<span>&#34;len: %d&#34;</span>, len);
        <span>return</span> 0;
}
</pre>
</div>
<p>
This program has a trivial buffer overflow. It figures out how big a
file is on disk and stores this in <code>fsize</code>. It allocates a buffer of
this size and then reads the whole file into it. It interprets the
first byte as the length of the data (<code>len</code>) and allocates a new
buffer (<code>dbuf</code>) of this size. It skips the length byte and copies
<code>fsize - 1</code> bytes into the new buffer. So it trusts that the amount of
data it read from disk is the same as indicated by the length byte.
</p>

<p>
While this might seem silly, this is what real world buffer overflows
look like.
</p>

<p>
Here is a file where the length byte and file size agree.  Create
folders <code>in</code> and <code>out</code> and place <code>test.txt</code> into <code>in/test.txt</code>. Don&#39;t
forget the newline.
</p>

<p>
<a href="https://tlakh.xyz/fuzzing-ping/test.txt"><code>test.txt</code></a>:
</p>
<pre id="org1a88321">ABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
</pre>

<p>
Compile <code>test.c</code>:
</p>
<div>
<pre><span>CC</span>=/usr/local/bin/afl-clang-fast make test
</pre>
</div>

<p>
and run <code>afl-fuzz</code>:
</p>
<div>
<pre>afl-fuzz -i in/ -o out -- ./test @@
</pre>
</div>
<p>
It more or less immediately finds a crash. The reproducer(s) are in
<code>out/default/crashes/</code>.
</p>
</div>
</div>
<div id="outline-container-org3940330">
<h2 id="org3940330">Fuzzing <code>ping(8)</code></h2>
<div id="text-org3940330">
<p>
At this point we are facing a few problems. What does it mean to fuzz
<code>ping(8)</code>, where are we getting the sample input from and how do we feed
it to <code>ping(8)</code>.
</p>

<p>
From a high level point of view <code>ping(8)</code> parses arguments,
initializes a bunch of stuff and then enters an infinite loop sending
ICMP echo request packets and waiting for a reply. It parses and
prints each reply.
</p>

<p>
Parsing the reply is the interesting thing. The reply comes from the
network and is untrusted. This is where things can go wrong. The
parsing is handled by <code>pr_pack()</code>, so that&#39;s what we should fuzz.
</p>
</div>

<div id="outline-container-org7bdf9eb">
<h3 id="org7bdf9eb"><code>in/</code> for <code>ping(8)</code></h3>
<div id="text-org7bdf9eb">
<p>
We need some sample data. An ICMP package is binary data
on-wire. Crafting it by hand is annoying. So let&#39;s just hack <code>ping(8)</code>
to dump the packet to disk.
</p>

<p>
<a href="https://tlakh.xyz/fuzzing-ping/ping_output_hack.diff"><code>ping_output_hack.diff</code></a>:
</p>
<div>
<pre>






<span> #include &lt;sys/types.h&gt;</span>
<span> #include &lt;sys/socket.h&gt;</span>
<span>+</span><span>#include &lt;sys/stat.h&gt;</span>
<span> #include &lt;sys/time.h&gt;</span>
<span> #include &lt;sys/uio.h&gt;</span>


<span> #include &lt;ctype.h&gt;</span>
<span> #include &lt;err.h&gt;</span>
<span> #include &lt;errno.h&gt;</span>
<span>+</span><span>#include &lt;fcntl.h&gt;</span>
<span> #include &lt;limits.h&gt;</span>
<span> #include &lt;math.h&gt;</span>
<span> #include &lt;poll.h&gt;</span>
<span> const char          *pr_addr(struct sockaddr *, socklen_t);</span>
<span> void                    pr_pack(u_char *, int, struct msghdr *);</span>
<span> __dead void             usage(void);</span>

<span>+</span><span>void                    output(char *, u_char *, int);</span>
<span>+</span>
<span> /* IPv4 specific functions */</span>
<span> void                    pr_ipopt(int, u_char *);</span>
<span> int                     in_cksum(u_short *, int);</span>
<span> main(int argc, char *argv[])</span>
<span>        int df = 0, tos = 0, bufspace = IP_MAXPACKET, hoplimit = -1, mflag = 0;</span>
<span>        u_char *datap, *packet;</span>
<span>        u_char ttl = MAXTTL;</span>
<span>-</span><span>       char *e, *target, hbuf[NI_MAXHOST], *source = NULL;</span>
<span>+</span><span>       char *e, *target, hbuf[NI_MAXHOST], *source = NULL</span><span><span>, *output_path = NULL</span></span><span>;</span>
<span>        char rspace[3 + 4 * NROUTES + 1];       /* record route space */</span>
<span>        const char *errstr;</span>
<span>        double fraction, integral, seconds;</span>
<span> main(int argc, char *argv[])</span>
<span>        u_int rtableid = 0;</span>
<span>        extern char *__progname;</span>

<span>+</span><span>#if 0</span>
<span>        /* Cannot pledge due to special setsockopt()s below */</span>
<span>        if (unveil(&#34;/&#34;, &#34;r&#34;) == -1)</span>
<span>                err(1, &#34;unveil /&#34;);</span>
<span>        if (unveil(NULL, NULL) == -1)</span>
<span>                err(1, &#34;unveil&#34;);</span>
<span>+</span><span>#endif</span>

<span>        if (strcmp(&#34;ping6&#34;, __progname) == 0) {</span>
<span>                v6flag = 1;</span>
<span> main(int argc, char *argv[])</span>
<span>        preload = 0;</span>
<span>        datap = &amp;outpack[ECHOLEN + ECHOTMLEN];</span>
<span>        while ((ch = getopt(argc, argv, v6flag ?</span>
<span>-</span><span>           &#34;c:DdEefgHh:I:i:Ll:m</span><span><span>Nnp</span></span><span>:qS:s:T:V:vw:&#34; :</span>
<span>-</span><span>           &#34;DEI:LRS:c:defgHi:l:</span><span><span>np</span></span><span>:qs:T:t:V:vw:&#34;)) != -1) {</span>
<span>+</span><span>           &#34;c:DdEefgHh:I:i:Ll:m</span><span><span>Nno</span></span><span>:</span><span><span>p:</span></span><span>qS:s:T:V:vw:&#34; :</span>
<span>+</span><span>           &#34;DEI:LRS:c:defgHi:l:</span><span><span>no:p</span></span><span>:qs:T:t:V:vw:&#34;)) != -1) {</span>
<span>                switch(ch) {</span>
<span>                case &#39;c&#39;:</span>
<span>                        npackets = strtonum(optarg, 0, INT64_MAX, &amp;errstr);</span>
<span> main(int argc, char *argv[])</span>
<span>                case &#39;n&#39;:</span>
<span>                        options &amp;= ~F_HOSTNAME;</span>
<span>                        break;</span>
<span>+</span><span>               case &#39;o&#39;:</span>
<span>+</span><span>                       output_path = optarg;</span>
<span>+</span><span>                       break;</span>
<span>                case &#39;p&#39;:               /* fill buffer with user pattern */</span>
<span>                        options |= F_PINGFILLED;</span>
<span>                        fill((char *)datap, optarg);</span>
<span> main(int argc, char *argv[])</span>
<span>        }</span>

<span>        if (options &amp; F_HOSTNAME) {</span>
<span>-</span><span>               if (pledge(&#34;stdio inet dns&#34;, NULL) == -1)</span>
<span>+</span><span>               if (pledge(&#34;stdio inet dns wpath cpath&#34;, NULL) == -1)</span>
<span>                        err(1, &#34;pledge&#34;);</span>
<span>        } else {</span>
<span>-</span><span>               if (pledge(&#34;stdio inet&#34;, NULL) == -1)</span>
<span>+</span><span>               if (pledge(&#34;stdio inet wpath cpath&#34;, NULL) == -1)</span>
<span>                        err(1, &#34;pledge&#34;);</span>
<span>        }</span>

<span> main(int argc, char *argv[])</span>
<span>                                }</span>
<span>                        }</span>
<span>                        continue;</span>
<span>-</span><span>               } else</span>
<span>+</span><span>               } else </span><span><span>{</span></span><span>
</span><span><span>+</span></span><span><span>                       if (output_path != NULL)</span></span><span>
</span><span><span>+</span></span><span><span>                               output(output_path, packet, cc);</span></span>
<span>                        pr_pack(packet, cc, &amp;m);</span>
<span>+</span><span>               }</span>

<span>                if (npackets &amp;&amp; nreceived &gt;= npackets)</span>
<span>                        break;</span>
<span> usage(void)</span>
<span>        }</span>
<span>        exit(1);</span>
<span> }</span>
<span>+</span>
<span>+</span><span>void</span>
<span>+</span><span>output(char *path, u_char *pack, int len)</span>
<span>+</span><span>{</span>
<span>+</span><span>       size_t bsz, off;</span>
<span>+</span><span>       ssize_t nw;</span>
<span>+</span><span>       int fd;</span>
<span>+</span><span>       char *fname;</span>
<span>+</span>
<span>+</span><span>       bsz = len;</span>
<span>+</span><span>       if (asprintf(&amp;fname, &#34;%s/ping_%lld_%d.out&#34;, path, time(NULL),</span>
<span>+</span><span>           getpid()) == -1)</span>
<span>+</span><span>               err(1, NULL);</span>
<span>+</span>
<span>+</span><span>       fd = open(fname, O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP |</span>
<span>+</span><span>           S_IROTH);</span>
<span>+</span><span>       free(fname);</span>
<span>+</span>
<span>+</span><span>       if (fd == -1)</span>
<span>+</span><span>               err(1, &#34;open&#34;);</span>
<span>+</span>
<span>+</span><span>       for (off = 0; off &lt; bsz; off += nw)</span>
<span>+</span><span>               if ((nw = write(fd, pack + off, bsz - off)) == 0 || nw == -1)</span>
<span>+</span><span>                       err(1, &#34;write&#34;);</span>
<span>+</span><span>       close(fd);</span>
+}
</pre>
</div>

<p>
After building and installing our hacked version of <code>ping(8)</code> we can
create sample input data for afl thusly:
</p>
<div>
<pre><span>while</span> :; <span>do</span>
    ping -o ./in/ -w 1 -c 1 <span>\</span>
         $(jot -r 0 255 | head -4 | tr <span>&#39;\n&#39;</span> <span>&#39;.&#39;</span> | sed <span>&#39;s/.$//&#39;</span>)
<span>done</span>
</pre>
</div>
<p>
<code>jot</code> creates a stream of random numbers between 0 and 255, we get the
first four, concatenate them with &#39;.&#39; and cut of the trailing
dot. Voil√† we have a bunch of random IPv4 addresses. We then send a
single ping and wait for one second. The ICMP reply is written to
<code>./in/</code>.
</p>
</div>
</div>

<div id="outline-container-orgf4b707e">
<h3 id="orgf4b707e">Fuzzing <code>pr_pack()</code></h3>
<div id="text-orgf4b707e">
<p>
At this point I wrote a <code>main()</code> function that accepts a file name as
argument and reads it into a buffer. I then ripped <code>pr_pack()</code> out of
<code>ping(8)</code> and fed it the file contents.
</p>

<p>
Of course compiling fails quite spectacularly at this point. So I
added a bunch of missing functions, defines and global variables. It
gets pretty close now. We don&#39;t have the <code>msghdr</code> from <code>recvfrom(2)</code> so
we need to <code>#if 0</code> some code. We also need to get rid of the
validation of the data packet using <code>SipHash</code> because the whole point
is that the data does not validate and <code>SipHash</code> would short circuit.
</p>

<p>
Oh yeah, and the thing is legacy IP only at this point.
</p>

<p>
So <a href="https://tlakh.xyz/fuzzing-ping/afl_ping.c">here (<code>afl_ping.c</code>)</a> it is, it is quite terrible. It would probably
make more sense to copy all of <code>ping(8)</code> and slap on a new <code>main()</code>
function. Maybe.
</p>

<p>
Anyway, at this point I was 30 minutes in, from reading about afl for
the first time until firing up <code>afl-fuzz</code> on my hacked
<code>pr_pack()</code>. Not too bad. It was time for dinner and I left the thing
running.
</p>
</div>
</div>

<div id="outline-container-orgab5185c">
<h3 id="orgab5185c">The promised bug</h3>
<div id="text-orgab5185c">
<p>
I came back after dinner and afl found zero crashes. That&#39;s
disappointing. Or good. Depending on how you look at it. But it found
hangs. Running <code>afl_ping</code> on one of the reproducers, it printed
&#34;<code>unknown option 20</code>&#34; forever.
</p>

<p>
The problem is in this part of the code:
</p>
<div>
<pre><span>for</span> (; hlen &gt; (<span>int</span>)<span>sizeof</span>(<span>struct</span> <span>ip</span>); --hlen, ++cp) {

    <span>switch</span> (*cp) {
    
    <span>default</span>:
       printf(<span>&#34;\nunknown option %x&#34;</span>, *cp);
       hlen = hlen - (cp[IPOPT_OLEN] - 1);
       cp = cp + (cp[IPOPT_OLEN] - 1);
       <span>break</span>;
    }
}
</pre>
</div>
<p>
<code>cp</code> is untrusted data and if <code>cp[IPOPT_OLEN]</code> is zero we would
increase <code>hlen</code> by one and the for loop would subtract one, same for
<code>cp</code>. We never make any progress and spin forever.
</p>

<p>
The diff is fairly simple:
</p>
<div>
<pre>




<span> pr_ipopt(int hlen, u_char *buf)</span>
<span>                        break;</span>
<span>                default:</span>
<span>                        printf(&#34;\nunknown option %x&#34;, *cp);</span>
<span>-</span><span>                       hlen = hlen - (cp[IPOPT_OLEN] - 1);</span>
<span>-</span><span>                       cp = cp + (cp[IPOPT_OLEN] - 1);</span>
<span>+</span><span>                       if (cp[IPOPT_OLEN] &gt; 0 &amp;&amp; (cp[IPOPT_OLEN] - 1) &lt;= hlen) {</span>
<span>+</span><span>                               hlen = hlen - (cp[IPOPT_OLEN] - 1);</span>
<span>+</span><span>                               cp = cp + (cp[IPOPT_OLEN] - 1);</span>
<span>+</span><span>                       } else</span>
<span>+</span><span>                               hlen = 0;</span>
<span>                        break;</span>
<span>                }</span>
        }
</pre>
</div>

<p>
I foolishly tweaked the diff after collecting OKs and of course the
tweak was wrong. Note to self: Never do this. So it&#39;s spread out over
two commits: <a href="https://cvsweb.openbsd.org/src/sbin/ping/ping.c#rev1.247">ping.c, Revision 1.247</a> and <a href="https://cvsweb.openbsd.org/src/sbin/ping/ping.c#rev1.248">ping.c, Revision 1.248</a>.
</p>

<p>
This bug was introduced April 3rd, 1998 in <a href="https://cvsweb.openbsd.org/src/sbin/ping/ping.c#rev1.30">revision 1.30</a>, over 24
years ago.
</p>
</div>
</div>
</div>

<div id="outline-container-orgdf96b5e">
<h2 id="orgdf96b5e">Epilogue</h2>
<div id="text-orgdf96b5e">
<p>
Afl uses files to feed data to programs to get them to crash or
otherwise misbehave. I had wondered for a few years how I could use
afl with things that talk to the network. Because that&#39;s what I mostly
work on. In hindsight it&#39;s quite obvious. You identify the main
parsing function, wrap it in a new <code>main()</code> function and Robert is
your father&#39;s nearest male relative.
</p>

<p>
The two main takeaways from this are: One, if someone messes up
somewhere, go look if you messed up in the same or similar way
somewhere else. Two, afl is pretty easy to use, even for network
programs. 30 minutes from reading about afl for the first time to
finding a bug in a real world program is pretty neat.
</p>
</div>
</div>
</div></div>
  </body>
</html>
