<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://interjectedfuture.com/crdts-turned-inside-out/">Original</a>
    <h1>CRDTs Turned Inside Out</h1>
    
    <div id="readability-page-1" class="page"><section>
            <div><p>üî∞</p><div><p>If CRDTs are new to you, here are some introductory links.</p></div></div><p>Last time, I discussed the <a href="https://interjectedfuture.com/trade-offs-between-different-crdts">trade-offs between more traditional CRDTs</a>, such as the State-based CRDT, Op-based CRDT, and Delta-based CRDT. </p><p>There is another class of CRDTs: Merkle CRDTs.</p><p>Most ink spilled on CRDTs focuses on consistently merging data from different replicas. That&#39;s just half the story. Without a way of storing when concurrent edits happen, merges can&#39;t make consistent decisions about conflict resolution. </p><p>Normally, this is the job of <a href="https://haslab.wordpress.com/2011/07/08/version-vectors-are-not-vector-clocks/">version vectors</a> in State-based CRDTs and the log of causal operations in Op-based CRDTs. But if you&#39;re familiar with blockchains or Git, we notice that <a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle Trees and DAGs</a> (Directed Acyclical Graph) can also do the same job. </p><p>The following is how we construct this bookkeeping, exposed as an inherent structure of the concurrent state, rather than hidden away within a container. Let&#39;s look at the two variations:</p><ul><li><a href="https://arxiv.org/pdf/2004.00107.pdf">Merkle-DAG CRDTs</a></li><li><a href="https://inria.hal.science/hal-02303490v1/document">Merkle Search Tree CRDTs</a></li></ul><h2 id="merkle-dag-crdt">Merkle-DAG CRDT</h2><p>The Merkle-DAG (Directed Acyclical Graph) models CRDTs as a growing DAG of Merkle nodes about concurrent updates as events occur. This is a Merklized version of <a href="https://www.bartoszsypytkowski.com/operation-based-crdts-protocol/">Op-based CRDTs</a>, where the internal bookkeeping grows with the number of state updates, rather than with the number of replicas.</p><p>Each node in the Merkle-DAG can carry a payload of operations, state snapshots, or even deltas. This node payload must be a CRDT for the Merkle-DAG to be a CRDT. However, these payload CRDTs can be much simpler in their implementation because the bookkeeping on concurrent edits is delegated up to the Merkle-DAG.</p><p>It&#39;s as if a state-based CRDT was turned inside-out. The common bookkeeping elements are now the container (the DAG), and the payload-specific bookkeeping is inside of the payload CRDT.</p><p>Beyond simpler bookkeeping for payload CRDTs, Merkle-DAG CRDTs have an advantage that non-Merklized CRDTs don&#39;t. They can determine equality by comparing root hashes, and they can determine diffs by walking down the DAG.</p><p>This reduces the bandwidth for syncing between replicas. </p><ol><li>A remote replica broadcasts its root hash to our local replica. </li><li>The local replica compares its root hash with the remote hash to determine if something has changed. </li><li>If the root hashes are different, it then asks the remote replica to send every node hash as it walks down the DAG from the root. </li><li>When the remote replica sends a hash that the local replica already has, the path from the root to this node is the list of all nodes missing in the local replica.</li></ol><p>This is quite a bit of chatter over the network, but the hashes don&#39;t have to be delivered in causal order any more. Merkle DAGs are by definition a causal chain of hashes. Hence, the nodes can be reordered at the receiver, regardless of how they were sent, as long as all of the nodes were received.</p><p>An upside of keeping the Merkle-DAG is that the data kept by a Merkle-DAG is immutable. It can be reconstructed and queried at any point in history. Immutability means diffs are easy, undos are easy, and provenance can be verified. But again, the downside here is a history of changes that grows with the number of events. However, Merkle Trees uses <a href="https://medium.com/@dumindux/how-immutable-data-structures-e-g-immutable-js-are-optimized-using-structural-sharing-e4424a866d56">structural sharing</a> as a form of compression to lower the space cost of storing such a data structure. </p><div><p>üí°</p><div><p>- Merging of two Merkle DAGs is done by comparing hashes and walking down a DAG.</p></div></div><div><p>üëç</p><div><p>- Smaller amount of data sent over the network to sync by comparing hashes.</p></div></div><div><p>üëé</p><p>- Internal data structure grows with the number of updates.</p></div><h2 id="merkle-search-tree-crdt">Merkle Search Tree CRDT</h2><p>The second kind of Merkle CRDT is covered in the <a href="https://inria.hal.science/hal-02303490v1/document">Merkle Search Tree paper</a>.</p><figure><img src="https://interjectedfuture.com/content/images/2023/12/image-1.png" alt="" loading="lazy" width="858" height="724" srcset="https://interjectedfuture.com/content/images/size/w600/2023/12/image-1.png 600w, https://interjectedfuture.com/content/images/2023/12/image-1.png 858w" sizes="(min-width: 720px) 720px"/></figure><p>A Merkle Search Tree (MST) is a tree that maintains an ordered set of keys. It does this by maintaining a few invariants. </p><ol><li>All the keys in a node are ordered.</li><li>All child nodes between two keys in a node contain entries lexicographically between the two keys.</li><li>The leaf layer is layer zero. The layer above is layer one, with increasing layer numbers until the root. The layer a key belongs to is dictated by the number of leading zeros in the hash of the key.</li><li>A node has a content ID that&#39;s a hash of all its keys concatenated with the content IDs of all its children. A child node is referenced by its content id.</li></ol><p>Keys live in all nodes of an MST tree, unlike a B-tree where keys are only at the leaves. This construction makes MSTs advantageous in two ways: it is self-balancing and it is unicit.</p><!--kg-card-begin: html--><!--kg-card-end: html--><p>A MST is self-balancing through both invariants #2 and #3. When a key is inserted in the tree, the layer is determined by the key&#39;s hash and the node in the layer is determined by the key&#39;s value. When the key is inserted in a node between two keys, it necessarily splits the child node between the two keys into two nodes due to invariant #2. Given a hash is in base <em>B</em> and invariant #3, the average number of keys in layer <em>L</em> is <em>B</em> times the average number of keys in layer <em>L + 1</em>. Hence, the average node size is <em>B</em>. Due to the placement of a key being completely deterministic, the tree self-balances.</p><p>Unicity means, for a given set of keys, the MST is unique. It implies the MST&#39;s construction does not depend on the order of the keys that were inserted. This is extremely desireable, because we can tell if two MSTs are different simply by comparing their root hashes regardless of the insertion order. If the root hash is the same, then the two trees are the same. </p><p>To construct a CRDT out of an MST, we simply add a payload to each key that&#39;s also a CRDT. Since the MST is an ordered set, merging sets have well-defined semantics, and merging the payloads is delegated to the payload itself to resolve. </p><p>And just like the Merkle-DAG construction, the payload CRDT doesn&#39;t need to be as complicated. For example, to construct a Grow-Only CRDT, we select the set { ‚èä, ‚èâ } (called &#34;bottom&#34; and &#34;top&#34; respectively) as the payload CRDT. All the values of the payload start as &#34;bottom&#34; by default. Merging means taking the max of &#34;top&#34; vs &#34;bottom&#34; (top always wins in a max operation). </p><p>Unfortunately, the paper leaves out the construction of other CRDTs using MSTs, as it was left as an exercise for the reader. However, there are two other possible constructions I think will work.</p><p><a href="https://dl.acm.org/doi/pdf/10.1145/3380787.3393678">Causal Length CRDTs</a> for add-remove sets could be implemented in MSTs with ‚Ñ§ (the set of integers) as the payload. If the number is even the key doesn&#39;t exist, and if it&#39;s odd, then it does. Merging would just be taking the max of the two replica&#39;s payloads.</p><p><a href="https://www.bartoszsypytkowski.com/operation-based-crdts-arrays-1/">Replicated Growable Arrays</a> (RGA) could be implemented by using virtual pointers concatted with the replica ID as the key. Since the MST keeps the keys ordered, we can read back the string by traversing in key order. This would need a mechanism outside of the MST to insert and assign tombstones for deletions. [^3]</p><p>Beyond that, there is an undetailed edge case. What if the key you&#39;re adding has a lot more (or a lot less) leading zeros in its hash than the number of leading zeros in the current root layer? Do you just add nodes in between the root and the new node? What should go in those in-between nodes? If there are no keys in these in-between nodes and just child content IDs, there would be no way to discern which child to descend into on a query. My guess is to simply insert a ghost key that doesn&#39;t exist in the set but only serves as a range bookend for queries. There are implementations to check out for details. [^4]</p><p>As for downsides, it&#39;s also vulnerable to attackers constructing a key with a large number of zeros and trying to insert it. That would result in a tall tree, reducing queries from O(log n) to O(n). And while the node size is on average <em>B</em>, the variance is spread pretty wide, so it can be common to have nodes that are too small or too large.</p><div><p>üí°</p><div><p>- Merging of two Merkle Search Trees is done similarly to a Merkle Tree: by comparing hashes and walking down the tree.</p></div></div><div><p>üëç</p><div><p>- Smaller amount of data sent over the network to sync by comparing hashes</p></div></div><div><p>üëé</p><div><p>- Possible for attackers to construct tall trees to slow query times</p></div></div><h2 id="the-surprising-connection">The surprising connection</h2><p>After this and the <a href="https://interjectedfuture.com/trade-offs-between-different-crdts/">previous survey</a> on CRDTs, I came away with some clarity on them. </p><p>CRDTs need two main ingredients to work, a merge/application operator that&#39;s commutative and associative, and some bookkeeping to keep track of concurrent or causal edits. This bookkeeping is like an uncollapsed superposition of state while the system isn&#39;t sure if there are any more concurrent edits. If we can be sure that all replicas are synced, we can either collapse the state or simply throw it away if we don&#39;t need to travel back in time.</p><p>For typical CRDTs, this bookkeeping is internal, and you&#39;re given an interface to set and query, so one can pretend this is a regular state that can be updated in place. Merkle CRDTs turn this inside out, exposing the inherent structure of concurrent edits and uncollapsed state for users to see and exploit.</p><p>This mirrors closely with how Git is structured. That surprised me at first. But as I dove into Git&#39;s history, I found this tidbit in passing.</p><blockquote>The important part of a merge is not how it handles conflicts (which need to be verified by a human anyway if they are at all interesting), but that it should meld the history together right so that you have a new solid base for future merges.</blockquote><p>The values are the contents of the file, and the bookkeeping on concurrent edits happens outside of the value. What stops Git from being a CRDT is that its default 3-way merge isn&#39;t commutative and associative.</p><p>As history proved, it&#39;s the bookkeeping data structure that&#39;s important for merges, not the conflict resolution itself. But in the case of CRDTs, it&#39;s important to constrain the merge with algebraic properties [^2].</p><h2 id="the-search-continues">The search continues</h2><p>Merkle Search Trees have lots of nice properties, such as unicity, self-balancing, and a CRDT that doesn&#39;t grow with the number of replicas or events. But I think we can do better. For one, the variance of the node sizes is large in MSTs, which makes for uneven trees. </p><p>In my search, I found <a href="https://github.com/attic-labs/noms/blob/master/doc/intro.md#prolly-trees-probabilistic-b-trees">Prolly Trees</a>, and will take a look at them. If anyone has other suggestions for data structures to look at to implement composable CRDTs, <a href="https://twitter.com/iamwil">let me know</a>. In the meantime, <a href="https://interjectedfuture.com/crdts-turned-inside-out/#/portal">subscribe</a> or <a href="https://twitter.com/iamwil">follow me on twitter</a>.</p><hr/><p>[^1] If you aren&#39;t familiar with the internals of Git, I&#39;d recommend looking into it. ¬†Git is the only piece of software where learning its internal data structure made it easier to use. </p><p>[^2] The algebraic properties we need to maintain for a merge are commutativity, associativity, and idempotency. This forces every replica to arrive at the same merged state without coordinating with each other.</p><p>[^3] Of course, actual RGA implementations are far more optimized than this outline.</p><p>[^4] There are two existing implementations of MSTs. </p><ul><li><a href="https://github.com/domodwyer/merkle-search-tree">https://github.com/domodwyer/merkle-search-tree</a></li><li><a href="https://github.com/jrhy/mast">https://github.com/jrhy/mast</a></li></ul>
        </section></div>
  </body>
</html>
