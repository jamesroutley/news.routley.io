<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://erikarow.land/notes/temporary-short-names">Original</a>
    <h1>Temporary Short Names</h1>
    
    <div id="readability-page-1" class="page"><section id="Temporary-Short-Names">

<p>When writing code, I prefer to use the full name of something to retain context and design decisions established by that name. However, there are cases where using a name many times in rapid succession becomes tedious, bordering on line noise. 
In those situations, it may make sense to use a temporary alias or short name to keep code legible.</p>
<p>Here are a couple examples, one in Elixir and one in Rust, of how you can do that:</p>
<section id="Rust---Enum-Alias">
<h2>Rust - Enum Alias</h2>
<p>If you have a long Enum name like this<label for="fn1"></label>
<span><span>Credit to <a href="https://www.youtube.com/watch?v=8j_FbjiowvE">Logan Smith</a> for introducing me the following trick. Go watch his video to hear more about the reasoning to prefer an alias over a <code>*</code> import, as well as other opinions on Rust. (This Enum suggestion is point 2 in the video).</span></span>:</p>
<pre><code>enum DecidedlyLongEnumNameHere {
  VariantX,
  VariantY,
  VariantZ,
}
</code></pre>
<p>Doing an exhaustive pattern match on that Enum becomes tedious:</p>
<pre><code>match enum {
  DecidedlyLongEnumNameHere::VariantX =&gt; x(),
  DecidedlyLongEnumNameHere::VariantY =&gt; y(),
  DecidedlyLongEnumNameHere::VariantZ =&gt; z(),
}
</code></pre>
<p>Rust lets you do a <code>use</code> declaration inside of a function, so you can create a short alias like this:</p>
<pre><code>use DecidedlyLongEnumNameHere as D;
match enum {
  D::VariantX =&gt; x(),
  D::VariantY =&gt; y(),
  D::VariantZ =&gt; z(),
}
</code></pre>
<p>The alias has the same scope as where you’ve used it, and is declared right next to its use, so context from the name is retained.</p>
</section>
<section id="Elixir---Scoped-Aliases">
<h2>Elixir - Scoped Aliases</h2>
<p>In Elixir, you may have a similar problem with long Module or Struct names<label for="fn2"></label>
<span><span>Or both, since structs are named after their creating module, and that module often defines functions useful to that struct.</span></span>:</p>
<pre><code>def my_fun do
  [1, 2, 3]
  |&gt; OverlyLongModuleName.fun1()
  |&gt; OverlyLongModuleName.fun2()
  |&gt; OverlyLongModuleName.fun3()
  ...
end
</code></pre>
<p>I prefer not to use a module wide short name, since that obscures the calling code by disconnecting that code from information important to understand its purpose.</p>
<p>Elixir supports lexical scope on <code>alias</code> and <code>import</code><label for="fn3"></label>
<span><span>Check out <a href="https://hexdocs.pm/elixir/1.12/Kernel.SpecialForms.html#alias/2-lexical-scope">hexdocs</a> for more information.</span></span>, so you can do this:</p>
<pre><code>def my_fun do
  alias OverlyLongModuleName, as: O

  [1, 2, 3]
  |&gt; O.fun1()
  |&gt; O.fun2()
  |&gt; O.fun3()
  ...
end
</code></pre>
<p>This allows for code to be shortened while retaining promixal knowledge about module context.</p>
<p>I haven’t tried either of these in collaborative codebases, but it’s nice to know that both are possible.</p>
</section>
</section></div>
  </body>
</html>
