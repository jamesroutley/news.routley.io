<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://serokell.io/blog/algebraic-data-types-in-haskell">Original</a>
    <h1>Algebraic Data Types in Haskell</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Most programming languages have a way to make compound data types. In Haskell, we can do that via algebraic data types. Even though the name might sound scary at first, it’s simply a way to construct types.</p>
<p>This article will introduce you to the concept of algebraic data types and show you how to use them.</p>
<p>Read further to learn:</p>
<ul>
<li>how to create your own Haskell data types;</li>
<li>what product and sum types are;</li>
<li>why algebraic data types are called algebraic;</li>
<li>how to use common Haskell ADTs such as <code>Maybe</code> and <code>Either</code>;</li>
<li>why functions are called exponential types.</li>
</ul>
<p>If you want to watch this article as a 10-minute video, you can do that on our <a href="https://www.youtube.com/watch?v=UqwLn2OyQ_E">YouTube channel</a>.</p>
<h2 id="product-types"><p>Product types</p></h2>
<h3 id="how-to-define-a-new-data-type-in-haskell%3F"><p>How to define a new data type in Haskell?</p></h3>
<p>Let’s start by creating a data type for a 2-dimensional point.</p>
<p>New data types are created via the <code>data</code> keyword. To create a <code>Point</code> data type, we need to provide a type constructor (the name of our type) and a data constructor (used to construct new instances of the type), followed by the types our type will contain.</p>
<pre><code>
<span><span>data</span> <span>Point</span> = <span>Point</span> <span>Double</span> <span>Double</span></span>
  <span>deriving</span> (<span>Show</span>, <span>Eq</span>)




</code></pre>
<p>A few notes on this piece of code.</p>
<p>First of all, there’s a difference between the type constructor and the data constructor. In our example, they are called the same, but they could have been <code>Point</code> and <code>Point2D</code>, for example. This frequently confuses beginners.</p>
<table>
  <tbody><tr>
   <td>Type constructor
   </td>
   <td>Data constructor
   </td>
  </tr>
  <tr>
   <td>Name of the type.
   </td>
   <td>Used to construct an instance of a type.
   </td>
  </tr>
  <tr>
   <td>Each type can have only one type constructor.
   </td>
   <td>Each type can have multiple data constructors (in case of <a href="https://serokell.io/blog/algebraic-data-types-in-haskell#sum-types">sum types</a>).
   </td>
  </tr>
</tbody></table>
<p>Second, adding <code>deriving (Show, Eq)</code> to the type definition above makes it possible to print values of the type and to compare them for equality. You can read more about deriving in this <a href="https://kowainik.github.io/posts/deriving">blog post</a>.</p>
<p>Let’s play with our <code>Point</code> type in GHCi.</p>
<p>We can create new values of this type via the data constructor.</p>
<pre><code>*Main&gt; a = Point 3 4
*Main&gt; a
Point 3.0 4.0
</code></pre>
<p>And we can create functions that pattern match on constructors and values inside them.</p>
<pre><code>*Main&gt; distance (Point x1 y1) (Point x2 y2) = sqrt ((x1 - x2) ^ 2 + (y1 - y2) ^ 2)
*Main&gt; a = Point 3 4
*Main&gt; b = Point 1 2
*Main&gt; distance a b
2.8284271247461903
</code></pre>
<h3 id="definition-of-a-product-type"><p>Definition of a product type</p></h3>
<p>We call <code>Point</code> (and all types with a similar structure) a <strong>product type</strong>. All product types combine multiple elements that are in the data structure at the same time. It’s the same as saying that you need this type <strong>and</strong> that type.</p>
<h3 id="polymorphic-data-types"><p>Polymorphic data types</p></h3>
<p>Our previously created <code>Point</code> data type can contain only double-precision floats.</p>
<p>In some cases, we would want it to work with other numbers as well. If so, we need to make it polymorphic (able to work with multiple different data types).</p>
<pre><code><span><span>data</span> <span>PPoint</span> a = <span>PPoint</span> a a</span>
  <span>deriving</span> (<span>Show</span>, <span>Eq</span>)
</code></pre>
<p>Here, we provide the type constructor with a type variable <code>a</code>, which we can later use in the definition of our type. In contrast to our previous <code>Point</code> type, <code>PPoint</code> is a type that needs to be “completed” by providing it with a concrete type.</p>
<p>To better illustrate this fact, we can look at the <a href="https://wiki.haskell.org/Kind">kinds</a> of both functions. While it is not possible to fully explain kinds in this article, you can think of them as type signatures for types.</p>
<p>If you wish to read more about kinds, I suggest <a href="https://diogocastro.com/blog/2018/10/17/haskells-kind-system-a-primer/">this article</a> by Diogo Castro.</p>
<p>As we can see, <code>Point</code> is a concrete type.</p>
<pre><code>*Main&gt; :kind Point
Point :: *
</code></pre>
<p>In contrast, <code>PPoint</code> is a function that takes a type and returns a concrete type.</p>
<pre><code>*Main&gt; :kind PPoint
PPoint :: * -&gt; *
</code></pre>
<p>Another typical example of a polymorphic product type is the tuple type.</p>
<pre><code>*Main&gt; :info (,)
type (,) :: * -&gt; * -&gt; *
data (,) a b = (,) a b
</code></pre>
<p>It takes two types – <code>a</code> and <code>b</code> – and returns a type that has <code>a</code> in the first slot and <code>b</code> in the second slot.</p>
<h3 id="records"><p>Records</p></h3>
<p>The individual types of our <code>Point</code> type are not named. While it doesn’t really add any difficulty right now, working with something like <code>Person String String String String</code> can be confusing.</p>
<p>An alternative is to use records, which have field labels.</p>
<pre><code><span><span>data</span> <span>Point</span> = <span>Point</span></span>
  { x :: <span>Double</span>
  , y :: <span>Double</span>
  }
  <span>deriving</span> (<span>Show</span>, <span>Eq</span>)
</code></pre>
<pre><code>*Main&gt; a = Point 3 4
*Main&gt; a
Point {x = 3.0, y = 4.0}
</code></pre>
<p>Records also provide us with getter functions for free. The names of those getters are the same as the field names.</p>
<pre><code>*Main&gt; x a
3.0
*Main&gt; y a
4.0
</code></pre>
<p>You can update a record by providing the fields you want to update (rest will stay the same).</p>
<pre><code>*Main&gt; b = a {x = 4}
*Main&gt; b
Point {x = 4.0, y = 4.0}
</code></pre>
<p>And you can put these two things together to create functional record updates.</p>
<pre><code>*Main&gt; moveUp point = point {y = y point + 1}
*Main&gt; c = moveUp a
*Main&gt; c
Point {x = 3.0, y = 5.0}
</code></pre>
<p>Of course, you can also work with records via pattern matching as with basic product types.</p>
<pre><code>*Main&gt; getX (Point x _) = x
*Main&gt; getX a
3.0
</code></pre>
<h2 id="sum-types"><p>Sum types</p></h2>
<p>There’s another flavor of types – sum types – that lists several possible variants a type could have. You might have encountered something similar under the name of <a href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html">enums</a> or <a href="https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html">union types</a>.</p>
<p>The simplest example of a sum type is <code>Bool</code>.</p>
<pre><code>
<span><span>data</span> <span>Bool</span> = <span>False</span> | <span>True</span></span>




</code></pre>
<p><code>Bool</code> can be constructed by either <code>True</code> or <code>False</code>.</p>
<p>We can make functions such as a negation that work on the values of <code>Bool</code>.</p>
<pre><code><span>neg</span> :: <span>Bool</span> -&gt; <span>Bool</span>
<span>neg</span> <span>True</span> = <span>False</span>
<span>neg</span> <span>False</span> = <span>True</span>
</code></pre>
<p>There are a lot of sum types in the wild that you wouldn’t even necessarily recognize as such. While it is not defined that way, an <code>Int</code> can be thought of as the enumeration of all the entries in <code>[-2^29 .. 2^29-1]</code>, for example.</p>
<p>A more nontrivial example of a sum type would be a data type that fits both a 2-dimensional and a 3-dimensional point.</p>
<pre><code><span><span>data</span> <span>Point</span> = <span>Point2D</span> <span>Double</span> <span>Double</span> | <span>Point3D</span> <span>Double</span> <span>Double</span> <span>Double</span></span>
  <span>deriving</span> (<span>Show</span>, <span>Eq</span>)
</code></pre>
<p>Now we can write a function that accepts both types of points by pattern matching on the data constructors.</p>
<pre><code><span>pointToList</span> :: <span>Point</span> -&gt; [<span>Double</span>]
<span>pointToList</span> (<span>Point2D</span> x y) = [x, y]
<span>pointToList</span> (<span>Point3D</span> x y z) = [x, y, z]
</code></pre>
<p>Here’s an example of its usage:</p>
<pre><code>*Main&gt; a = Point2D 3 4
*Main&gt; b = Point3D 3 4 5
*Main&gt; pointToList a
[3.0,4.0]
*Main&gt; pointToList b
[3.0,4.0,5.0]
</code></pre>
<h3 id="definition-of-a-sum-type"><p>Definition of a sum type</p></h3>
<p>Like product types, sum types are a way of putting together basic types to create a more complex one. But in comparison to product types, only one of those types can be present in any given instance of the type.</p>
<p>In other words, using a sum type is like saying that you need type a <strong>or</strong> type b: “I need True or False”, “I need a 2D point or a 3D point”, etc.</p>
<h2 id="product-types-vs.-sum-types"><p>Product types vs. sum types</p></h2>
<p>Here’s a small table to help you remember the differences between these two groups of types.</p>
<table>
  <tbody><tr>
   <td>
   </td>
   <td>Product types 
   </td>
   <td>Sum types
   </td>
  </tr>
  <tr>
   <td>Example
   </td>
	  <td><code>data (,) a b = (,) a b</code>
   </td>
	  <td><code>data Bool = False | True</code>
   </td>
  </tr>
  <tr>
   <td>Intuition
   </td>
   <td>Give me a <strong>and</strong> b
   </td>
   <td>Give me a <strong>or</strong> b
   </td>
  </tr>
</tbody></table>
<h2 id="algebraic-data-types"><p>Algebraic data types</p></h2>
<p>So why are these types called product and sum types? Let’s get into it.</p>
<p>If you remember your school math lessons, you worked with numbers (<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>1</span></span></span></span>, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>2</span></span></span></span>, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>3</span></span></span></span>, etc.), variables (<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>x</span></span></span></span>, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>y</span></span></span></span>, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>z</span></span></span></span>, etc.), and operators (<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>+</span></span></span></span>, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo></mrow><annotation encoding="application/x-tex">-</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>−</span></span></span></span>, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo></mrow><annotation encoding="application/x-tex">*</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>∗</span></span></span></span>, etc.). In algebraic data types, our numbers are the number of possible values a type can have and our operators are <code>|</code> and data constructors.</p>
<h3 id="summing-types"><p>Summing types</p></h3>
<p>If we use <code>|</code> in the definition of a type, the type can have a value from the values of types on either side of the operator. As such, the amount of possible values it has is the sum of the amount of values those types have.</p>
<p>For example, <code>False</code> contains only one value. <code>True</code> also contains only one value. <code>Bool = False | True</code> contains <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1 + 1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>1</span><span></span><span>+</span><span></span></span><span><span></span><span>1</span></span></span></span> values. If we add an <code>Unknown</code> value to <code>Bool</code>, we will have a type with three possible values, and so on.</p>
<h3 id="multiplying-types"><p>Multiplying types</p></h3>
<p>If we use a data constructor, our type can have all the possible combinations of the sets of values we provide. As such, the amount of possible values it has is the product of the amount of values those types have.</p>
<p>For example, if our type consists of two booleans, such as whether a person checked in for both parts of a return flight, it will have <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>∗</mo><mn>2</mn><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">2 * 2 = 4</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>2</span><span></span><span>∗</span><span></span></span><span><span></span><span>2</span><span></span><span>=</span><span></span></span><span><span></span><span>4</span></span></span></span> possible values.</p>
<pre><code><span><span>data</span> <span>CheckedInStatus</span> = <span>CheckedInStatus</span> <span>Bool</span> <span>Bool</span></span>
</code></pre>
<p>Possible values of <code>CheckedInStatus</code>:</p>
<pre><code>True True 
True False 
False True
False False
</code></pre>
<h3 id="definition-of-an-algebraic-data-type"><p>Definition of an algebraic data type</p></h3>
<p>By putting together sum and product types, we can construct elaborate types out of simple building blocks.</p>
<p>And this is what algebraic data types work with. They are a collection of one or more data constructors, composed with the <code>|</code> operator. In other words, they are <strong>a sum of products</strong>.</p>
<pre><code>
<span><span>data</span> <span>Point</span> = <span>Point2D</span> <span>Double</span> <span>Double</span> | <span>Point3D</span> <span>Double</span> <span>Double</span> <span>Double</span></span>

</code></pre>
<h2 id="common-adts"><p>Common ADTs</p></h2>
<p>Now, let’s look at two commonly used ADTs in Haskell: <code>Maybe</code> and <code>Either</code>.</p>
<h3 id="maybe"><p>Maybe</p></h3>
<p>First ADT we’ll cover is <code><a href="https://hackage.haskell.org/package/base-4.16.0.0/docs/Data-Maybe.html">Maybe</a></code>, which you might have encountered in other languages as <code>Optional</code>.</p>
<pre><code>*Main&gt; :info Maybe
type Maybe :: * -&gt; *
data Maybe a = Nothing | Just a
</code></pre>
<p>Sometimes, a function might not be able to return a value for a certain input. In that case, we can use the <code>Maybe</code> type. It has two possible data constructors: <code>Just</code> or <code>Nothing</code>. If the function succeeds, we wrap the result in <code>Just</code>. Otherwise, we return <code>Nothing</code>, which symbolizes something similar to null.</p>
<p>For example, <code>Prelude</code> has a scary function called <code>head</code>, which works on lists but not all of them.</p>
<p>In case we call it with an empty list, we’ll get an exception:</p>
<pre><code>*Main&gt; head []
*** Exception: Prelude.head: empty list
</code></pre>
<p>We can make it give a result for each input by pattern matching on the contents of the list and returning <code>Nothing</code> in the case of an empty list.</p>
<pre><code><span>safeHead</span> :: [a] -&gt; <span>Maybe</span> a
<span>safeHead</span> [] = <span>Nothing</span>
<span>safeHead</span> (x : _) = <span>Just</span> x
</code></pre>
<pre><code>*Main&gt; safeHead []
Nothing
*Main&gt; safeHead [1, 2, 3]
Just 1
</code></pre>
<p>All in all, you can think of <code>Maybe</code> as a safer alternative to null.</p>
<h3 id="either"><p>Either</p></h3>
<p>Now, what if you want to know what made the function fail?</p>
<p>In that case, there is another data type that we can use – <code><a href="https://hackage.haskell.org/package/base-4.16.0.0/docs/Data-Either.html">Either</a></code>. It functions similarly to what is called <code>Result</code> in other languages.</p>
<pre><code>*Main&gt; :info Either
type Either :: * -&gt; * -&gt; *
data Either a b = Left a | Right b
</code></pre>
<p>In contrast to <code>Maybe</code>, it can store something on the left side, such as an error message.</p>
<p>Let’s rewrite our <code>safeHead</code> function with <code>Either</code>.</p>
<pre><code><span>safeHead</span> :: [a] -&gt; <span>Either</span> <span>String</span> a
<span>safeHead</span> [] = <span>Left</span> <span>&#34;I have no head.&#34;</span>
<span>safeHead</span> (x : _) = <span>Right</span> x
</code></pre>
<pre><code>*Main&gt; safeHead []
Left &#34;I have no head.&#34;
*Main&gt; safeHead [1, 2, 3]
Right 1
</code></pre>
<p>All in all, you can think of <code>Either</code> as a safer alternative to exceptions.</p>
<h2 id="exponential-types-(functions)"><p>Exponential types (functions)</p></h2>
<p>To blow your mind a little bit in the end: functions can also add to our “type algebra” since they also have types.</p>
<p>Imagine we have a data type for traffic lights.</p>
<pre><code><span><span>data</span> <span>Light</span> = <span>Green</span> | <span>Yellow</span> | <span>Red</span> </span>
</code></pre>
<p>How many possible values are in the type <code>Light -&gt; Bool</code>? (One can imagine that they encode all possible rules for when is it legal to cross the street.)</p>
<p>Let’s try to write them all out.</p>
<ul>
<li>True if it is Green, False if it is Yellow or Red.</li>
<li>True if it is Green or Yellow, False if it is Red.</li>
<li>True if it is Green, Yellow, or Red.</li>
<li>True if it is Yellow or Red, False if it is Green.</li>
<li>True if it is Red, False if it is Green or Yellow.</li>
<li>False if it is Green, Yellow, or Red.</li>
<li>True if it is Green or Red, False if it is Yellow.</li>
<li>True if it is Yellow, False if it is Green or Red.</li>
</ul>
<p>The final number is <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>8</span></span></span></span>, or <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">2^3</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>2</span><span><span><span><span><span><span></span><span><span>3</span></span></span></span></span></span></span></span></span></span></span>.</p>
<p>Turns out, if we have two types <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>a</span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>b</span></span></span></span> with the amount of values inside those types being <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>a</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|a|</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>∣</span><span>a</span><span>∣</span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>b</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|b|</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>∣</span><span>b</span><span>∣</span></span></span></span>, respectively, then there are <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>b</mi><msup><mi mathvariant="normal">∣</mi><mrow><mi mathvariant="normal">∣</mi><mi>a</mi><mi mathvariant="normal">∣</mi></mrow></msup></mrow><annotation encoding="application/x-tex">|b|^ {|a|}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>∣</span><span>b</span><span><span>∣</span><span><span><span><span><span><span></span><span><span><span>∣</span><span>a</span><span>∣</span></span></span></span></span></span></span></span></span></span></span></span> functions in the set of possible functions from <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>a</span></span></span></span> to <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>b</span></span></span></span>.</p>
<h2 id="conclusion"><p>Conclusion</p></h2>
<p>In this article, we explored common ways of defining your own data types in Haskell. We looked at product types and sum types and how they work together to create algebraic data types. We also looked at common data types such as <code>Maybe</code> and <code>Either</code> and saw how functions are exponential data types.</p>
<p>Haskell’s type system is large and enables you to be very expressive, so there are a lot of things that we didn’t cover in our blog post, such as <a href="https://wiki.haskell.org/Newtype">newtypes</a>.</p>
<p>If you want to read more of our Haskell articles, follow us on <a href="https://twitter.com/serokell">Twitter</a> or <a href="https://dev.to/serokell">Dev</a>.</p>
<h2 id="exercises"><p>Exercises</p></h2>
<p>In case you want some practice with algebraic data types, here are a couple of quick exercises.</p>
<ol>
<li>
<p>Create a data type called <code>Person</code> that stores a person’s full name, address, and phone number. Create a function for getting a person’s name and a function for changing their phone number.</p>
</li>
<li>
<p>Convert the data type created in exercise 1 to a record.</p>
</li>
<li>
<p>Given a data type for days of the week: <code>data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday</code>, write two functions:</p>
<ul>
<li><code>isWednesday</code>, which takes a day of the week and returns <code>True</code> if it’s Wednesday and <code>False</code> otherwise.</li>
<li><code>nextDay</code>, which takes a day of the week and returns the day of the week that comes after it.</li>
</ul>
</li>
<li>
<p>Recall the <code>Maybe</code> data type we covered earlier. Write a ‘tail’ function for a list with the type signature of <code>safeTail :: [a] -&gt; Maybe [a]</code>. It should take a list and return the list without the first element, wrapped in <code>Just</code>. In case that is not possible, it should return <code>Nothing</code>. </p>
<pre><code>* <span><span>safeTail</span> [ ] -&gt;</span> Nothing  
* <span><span>safeTail</span> [1] -&gt;</span> Just [] 
* <span><span>safeTail</span> [1,2,3,4,5] -&gt;</span> Just [<span>2</span>,<span>3</span>,<span>4</span>,<span>5</span>]
</code></pre>
</li>
</ol>
<h2 id="appendix"><p>Appendix</p></h2>
<p>Here’s a handy table of some of the types we have covered in this article and how to compute the cardinality (how many members the type has) of those types, assuming that the cardinalities of their components are known.</p>
<p><strong>Note:</strong> <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>a</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|a|</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>∣</span><span>a</span><span>∣</span></span></span></span> notes the cardinality of the type <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>a</span></span></span></span> in the table.</p>
<table>
  <tbody><tr>
   <td>Name
   </td>
   <td>Haskell 
   </td>
   <td>Cardinality
   </td>
  </tr>
  <tr>
   <td>Bool
   </td>
	  <td><code>data Bool = False | True</code>
   </td>
   <td>
<p><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1 + 1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>1</span><span></span><span>+</span><span></span></span><span><span></span><span>1</span></span></span></span></p>
   </td>
  </tr>
  <tr>
   <td>Maybe 
   </td>
	  <td><code>data Maybe a  = Nothing | Just a</code>
   </td>
   <td>
<p><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mi mathvariant="normal">∣</mi><mi>a</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">1 + |a|</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>1</span><span></span><span>+</span><span></span></span><span><span></span><span>∣</span><span>a</span><span>∣</span></span></span></span></p>
   </td>
  </tr>
  <tr>
   <td>Either 
   </td>
	  <td><code>data Either a b = Left a | Right b</code>
   </td>
   <td> 
<p><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>a</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>b</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|a| + |b|</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>∣</span><span>a</span><span>∣</span><span></span><span>+</span><span></span></span><span><span></span><span>∣</span><span>b</span><span>∣</span></span></span></span></p>
   </td>
  </tr>
  <tr>
   <td>Tuple
   </td>
	  <td><code>(a, b)</code>
   </td>
   <td>
<p><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>a</mi><mi mathvariant="normal">∣</mi><mo>∗</mo><mi mathvariant="normal">∣</mi><mi>b</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|a| * |b|</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>∣</span><span>a</span><span>∣</span><span></span><span>∗</span><span></span></span><span><span></span><span>∣</span><span>b</span><span>∣</span></span></span></span></p>
   </td>
  </tr>
  <tr>
   <td>Function
   </td>
	  <td><code>a -&gt; b</code>
   </td>
   <td>
<p><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>b</mi><msup><mi mathvariant="normal">∣</mi><mrow><mi mathvariant="normal">∣</mi><mi>a</mi><mi mathvariant="normal">∣</mi></mrow></msup></mrow><annotation encoding="application/x-tex">|b| ^{|a|}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>∣</span><span>b</span><span><span>∣</span><span><span><span><span><span><span></span><span><span><span>∣</span><span>a</span><span>∣</span></span></span></span></span></span></span></span></span></span></span></span></p>
   </td>
  </tr>
  <tr>
   <td>2D point 
   </td>
   <td><code>data Point = Point Double Double</code>
   </td>
   <td>
<p><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>D</mi><mi>o</mi><mi>u</mi><mi>b</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">∣</mi><mo>∗</mo><mi mathvariant="normal">∣</mi><mi>D</mi><mi>o</mi><mi>u</mi><mi>b</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|Double| * |Double|</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>∣</span><span>D</span><span>o</span><span>u</span><span>b</span><span>l</span><span>e</span><span>∣</span><span></span><span>∗</span><span></span></span><span><span></span><span>∣</span><span>D</span><span>o</span><span>u</span><span>b</span><span>l</span><span>e</span><span>∣</span></span></span></span>
</p>
  </td></tr>
  <tr>
   <td>2D or 3D point 
   </td>
   <td><code>data Point = Point2D Double Double | Point3D Double Double Double</code>
   </td>
   <td>
<p><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>D</mi><mi>o</mi><mi>u</mi><mi>b</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">∣</mi><mo>∗</mo><mi mathvariant="normal">∣</mi><mi>D</mi><mi>o</mi><mi>u</mi><mi>b</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>D</mi><mi>o</mi><mi>u</mi><mi>b</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">∣</mi><mo>∗</mo><mi mathvariant="normal">∣</mi><mi>D</mi><mi>o</mi><mi>u</mi><mi>b</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">∣</mi><mo>∗</mo><mi mathvariant="normal">∣</mi><mi>D</mi><mi>o</mi><mi>u</mi><mi>b</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|Double| * |Double| + |Double| * |Double| * |Double|</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>∣</span><span>D</span><span>o</span><span>u</span><span>b</span><span>l</span><span>e</span><span>∣</span><span></span><span>∗</span><span></span></span><span><span></span><span>∣</span><span>D</span><span>o</span><span>u</span><span>b</span><span>l</span><span>e</span><span>∣</span><span></span><span>+</span><span></span></span><span><span></span><span>∣</span><span>D</span><span>o</span><span>u</span><span>b</span><span>l</span><span>e</span><span>∣</span><span></span><span>∗</span><span></span></span><span><span></span><span>∣</span><span>D</span><span>o</span><span>u</span><span>b</span><span>l</span><span>e</span><span>∣</span><span></span><span>∗</span><span></span></span><span><span></span><span>∣</span><span>D</span><span>o</span><span>u</span><span>b</span><span>l</span><span>e</span><span>∣</span></span></span></span></p>
   </td>
  </tr>
</tbody></table></div></div>
  </body>
</html>
