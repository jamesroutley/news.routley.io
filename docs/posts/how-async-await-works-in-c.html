<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://devblogs.microsoft.com/dotnet/how-async-await-really-works/">Original</a>
    <h1>How Async/Await Works in C#</h1>
    
    <div id="readability-page-1" class="page"><div id="featured">

	<div>
                         <p>
            March 16th, 2023</p><!-- .entry-meta -->
        
<p>Several weeks ago, the <a href="https://devblogs.microsoft.com/dotnet/">.NET Blog</a> featured a post <a href="https://devblogs.microsoft.com/dotnet/why-dotnet/">What is .NET, and why should you choose it?</a>. It provided a high-level overview of the platform, summarizing various components and design decisions, and promising more in-depth posts on the covered areas.  This post is the first such follow-up, deep-diving into the history leading to, the design decisions behind, and implementation details of <code>async</code>/<code>await</code> in C# and .NET.</p>
<p>The support for <code>async</code>/<code>await</code> has been around now for over a decade. In that time, it’s transformed how scalable code is written for .NET, and it’s both viable and extremely common to utilize the functionality without understanding exactly what’s going on under the covers.  You start with a synchronous method like the following (this method is “synchronous” because a caller will not be able to do anything else until this whole operation completes and control is returned back to the caller):</p>
<pre><code>// Synchronously copy all data from source to destination.
public void CopyStreamToStream(Stream source, Stream destination)
{
    var buffer = new byte[0x1000];
    int numRead;
    while ((numRead = source.Read(buffer, 0, buffer.Length)) != 0)
    {
        destination.Write(buffer, 0, numRead);
    }
}</code></pre>
<p>Then you sprinkle a few keywords, change a few method names, and you end up with the following asynchronous method instead (this method is “asynchronous” because control is expected to be returned back to its caller very quickly and possibly before the work associated with the whole operation has completed):</p>
<pre><code>// Asynchronously copy all data from source to destination.
public async Task CopyStreamToStreamAsync(Stream source, Stream destination)
{
    var buffer = new byte[0x1000];
    int numRead;
    while ((numRead = await source.ReadAsync(buffer, 0, buffer.Length)) != 0)
    {
        await destination.WriteAsync(buffer, 0, numRead);
    }
}</code></pre>
<p>Almost identical in syntax, still able to utilize all of the same control flow constructs, but now non-blocking in nature, with a significantly different underlying execution model, and with all the heavy lifting done for you under the covers by the C# compiler and core libraries.</p>
<p>While it’s common to use this support without knowing exactly what’s happening under the hood, I’m a firm believer that understanding how something actually works helps you to make even better use of it.  For <code>async</code>/<code>await</code> in particular, understanding the mechanisms involved is especially helpful when you want to look below the surface, such as when you’re trying to debug things gone wrong or improve the performance of things otherwise gone right. In this post, then, we’ll deep-dive into exactly how <code>await</code> works at the language, compiler, and library level, so that you can make the most of these valuable features.</p>
<p>To do that well, though, we need to go way back to before <code>async</code>/<code>await</code> to understand what state-of-the-art asynchronous code looked like in its absence. Fair warning, it wasn’t pretty.</p>
<h2 id="in-the-beginning">In the beginning…</h2>
<p>All the way back in .NET Framework 1.0, there was the Asynchronous Programming Model pattern, otherwise known as the APM pattern, otherwise known as the Begin/End pattern, otherwise known as the <code>IAsyncResult</code> pattern.  At a high-level, the pattern is simple.  For a synchronous operation <code>DoStuff</code>:</p>
<pre><code>class Handler
{
    public int DoStuff(string arg);
}</code></pre>
<p>there would be two corresponding methods as part of the pattern: a <code>BeginDoStuff</code> method and an <code>EndDoStuff</code> method:</p>
<pre><code>class Handler
{
    public int DoStuff(string arg);

    public IAsyncResult BeginDoStuff(string arg, AsyncCallback? callback, object? state);
    public int EndDoStuff(IAsyncResult asyncResult);
}</code></pre>
<p><code>BeginDoStuff</code> would accept all of the same parameters as does <code>DoStuff</code>, but in addition it would also accept an <a href="https://github.com/dotnet/runtime/blob/967a59712996c2cdb8ce2f65fb3167afbd8b01f3/src/libraries/System.Private.CoreLib/src/System/AsyncCallback.cs#L14"><code>AsyncCallback</code></a> delegate and an opaque state <code>object</code>, one or both of which could be <code>null</code>. The Begin method was responsible for initiating the asynchronous operation, and if provided with a callback (often referred to as the “continuation” for the initial operation), it was also responsible for ensuring the callback was invoked when the asynchronous operation completed.  The Begin method would also construct an instance of a type that implemented <a href="https://github.com/dotnet/runtime/blob/967a59712996c2cdb8ce2f65fb3167afbd8b01f3/src/libraries/System.Private.CoreLib/src/System/IAsyncResult.cs#L17-L27"><code>IAsyncResult</code></a>, using the optional <code>state</code> to populate that <code>IAsyncResult</code>‘s <code>AsyncState</code> property:</p>
<pre><code>namespace System
{
    public interface IAsyncResult
    {
        object? AsyncState { get; }
        WaitHandle AsyncWaitHandle { get; }
        bool IsCompleted { get; }
        bool CompletedSynchronously { get; }
    }

    public delegate void AsyncCallback(IAsyncResult ar);
}</code></pre>
<p>This <code>IAsyncResult</code> instance would then both be returned from the Begin method as well as passed to the <code>AsyncCallback</code> when it was eventually invoked.  When ready to consume the results of the operation, a caller would then pass that <code>IAsyncResult</code> instance to the End method, which was responsible for ensuring the operation was completed (synchronously waiting for it to complete by blocking if it wasn’t) and then returning any result of the operation, including propagating any errors/exceptions that may have occurred.  Thus, instead of writing code like the following to perform the operation synchronously:</p>
<pre><code>try
{
    int i = handler.DoStuff(arg); 
    Use(i);
}
catch (Exception e)
{
    ... // handle exceptions from DoStuff and Use
}</code></pre>
<p>the Begin/End methods could be used in the following manner to perform the same operation asynchronously:</p>
<pre><code>try
{
    handler.BeginDoStuff(arg, iar =&gt;
    {
        try
        {
            Handler handler = (Handler)iar.AsyncState!;
            int i = handler.EndDoStuff(iar);
            Use(i);
        }
        catch (Exception e2)
        {
            ... // handle exceptions from EndDoStuff and Use
        }
    }, handler);
}
catch (Exception e)
{
    ... // handle exceptions thrown from the synchronous call to BeginDoStuff
}</code></pre>
<p>For anyone who’s dealt with callback-based APIs in any language, this should feel familiar.</p>
<p>Things only got more complicated from there, however. For instance, there’s the issue of “stack dives.”  A stack dive is when code repeatedly makes calls that go deeper and deeper on the stack, to the point where it could potentially stack overflow.  The Begin method is allowed to invoke the callback synchronously if the operation completes synchronously, meaning the call to Begin might itself directly invoke the callback.  And “asynchronous” operations that complete synchronously are actually very common; they’re not “asynchronous” because they’re guaranteed to complete asynchronously but rather are just permitted to. For example, consider an asynchronous read from some networked operation, like receiving from a socket.  If you need only a small amount of data for each individual operation, such as reading some header data from a response, you might put a buffer in place in order to avoid the overhead of lots of system calls. Instead of doing a small read for just the amount of data you need immediately, you perform a larger read into the buffer and then consume data from that buffer until its exhausted; that lets you reduce the number of expensive system calls required to actually interact with the socket.  Such a buffer might exist behind whatever asynchronous abstraction you’re using, such that the first “asynchronous” operation you perform (filling the buffer) completes asynchronously, but then all subsequent operations until that underlying buffer is exhausted don’t actually need to do any I/O, instead just pulling from the buffer, and can thus all complete synchronously.  When the Begin method performs one of these operations, and finds it completes synchronously, it can then invoke the callback synchronously.  That means you have one stack frame that called the Begin method, another stack frame for the Begin method itself, and now another stack frame for the callback.  Now what happens if that callback turns around and calls Begin again?  If that operation completes synchronously and its callback is invoked synchronously, you’re now again several more frames deep on the stack.  And so on, and so on, until eventually you run out of stack.</p>
<p>This is a real possibility that’s easy to repro.  Try this program on .NET Core:</p>
<pre><code>using System.Net;
using System.Net.Sockets;

using Socket listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
listener.Bind(new IPEndPoint(IPAddress.Loopback, 0));
listener.Listen();

using Socket client = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
client.Connect(listener.LocalEndPoint!);

using Socket server = listener.Accept();
_ = server.SendAsync(new byte[100_000]);

var mres = new ManualResetEventSlim();
byte[] buffer = new byte[1];

var stream = new NetworkStream(client);

void ReadAgain()
{
    stream.BeginRead(buffer, 0, 1, iar =&gt;
    {
        if (stream.EndRead(iar) != 0)
        {
            ReadAgain(); // uh oh!
        }
        else
        {
            mres.Set();
        }
    }, null);
};
ReadAgain();

mres.Wait();</code></pre>
<p>Here I’ve set up a simple client socket and server socket connected to each other.  The server sends 100,000 bytes to the client, which then proceeds to use <code>BeginRead</code>/<code>EndRead</code> to consume them “asynchronously” one at a time (this is terribly inefficient and is only being done in the name of pedagogy).  The callback passed to <code>BeginRead</code> finishes the read by calling <code>EndRead</code>, and then if it successfully read the desired byte (in which case it wasn’t yet at end-of-stream), it issues another <code>BeginRead</code> via a recursive call to the <code>ReadAgain</code> local function.  However, in .NET Core, socket operations are much faster than they were on .NET Framework, and will complete synchronously if the OS is able to satisfy the operation synchronously (noting the kernel itself has a buffer used to satisfy socket receive operations).  Thus, this stack overflows:
<img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/03/BeginReadStackOverflow.png" alt="Stack overflow due to improper handling of synchronous completion"/></p>
<p>So, compensation for this was built into the APM model.  There are two possible ways to compensate for this:</p>
<ol>
<li>Don’t allow the <code>AsyncCallback</code> to be invoked synchronously.  If it’s always invoked asynchronously, even if the operation completes synchronously, then the risk of stack dives goes away.  But so too does performance, because operations that complete synchronously (or so quickly that they’re observably indistinguishable) are very common, and forcing each of those to queue its callback adds measurable overhead.</li>
<li>Employ a mechanism that allows the caller rather than the callback to do the continuation work if the operation completes synchronously. That way, you escape the extra method frame and continue doing the follow-on work no deeper on the stack.</li>
</ol>
<p>The APM pattern goes with option (2). For that, the <code>IAsyncResult</code> interface exposes two related but distinct members: <code>IsCompleted</code> and <code>CompletedSynchronously</code>.  <code>IsCompleted</code> tells you whether the operation has completed: you can check it multiple times, and eventually it’ll transition from <code>false</code> to <code>true</code> and then stay there.  In contrast, <code>CompletedSynchronously</code> never changes (or if it does, it’s a nasty bug waiting to happen); it’s used to communicate between the caller of the Begin method and the <code>AsyncCallback</code> which of them is responsible for performing any continuation work.  If <code>CompletedSynchronously</code> is <code>false</code>, then the operation is completing asynchronously and any continuation work in response to the operation completing should be left up to the callback; after all, if the work didn’t complete synchronously, the caller of Begin can’t really handle it because the operation isn’t known to be done yet (and if the caller were to just call End, it would block until the operation completed).  If, however, <code>CompletedSynchronously</code> is <code>true</code>, if the callback were to handle the continuation work, then it risks a stack dive, as it’ll be performing that continuation work deeper on the stack than where it started.  Thus, any implementations at all concerned about such stack dives need to examine <code>CompletedSynchronously</code> and have the caller of the Begin method do the continuation work if it’s <code>true</code>, which means the callback then needs to <em>not</em> do the continuation work.  This is also why <code>CompletedSynchronously</code> must never change: the caller and the callback need to see the same value to ensure that the continuation work is performed once and only once, regardless of race conditions.</p>
<p>In our previous <code>DoStuff</code> example, that then leads to code like this:</p>
<pre><code>try
{
    IAsyncResult ar = handler.BeginDoStuff(arg, iar =&gt;
    {
        if (!iar.CompletedSynchronously)
        {
            try
            {
                Handler handler = (Handler)iar.AsyncState!;
                int i = handler.EndDoStuff(iar);
                Use(i);
            }
            catch (Exception e2)
            {
                ... // handle exceptions from EndDoStuff and Use
            }
        }
    }, handler);
    if (ar.CompletedSynchronously)
    {
        int i = handler.EndDoStuff(ar);
        Use(i);
    }
}
catch (Exception e)
{
    ... // handle exceptions that emerge synchronously from BeginDoStuff and possibly EndDoStuff/Use
}</code></pre>
<p>That’s a mouthful.  And so far we’ve only looked at consuming the pattern… we haven’t looked at implementing the pattern.  While most developers wouldn’t need to be concerned about leaf operations (e.g. implementing the actual <code>Socket.BeginReceive</code>/<code>EndReceive</code> methods that interact with the operating system), many, many developers would need to be concerned with composing these operations (performing multiple asynchronous operations that together form a larger one), which means not only consuming other Begin/End methods but also implementing them yourself so that your composition itself can be consumed elsewhere.  And, you’ll notice there was no control flow in my previous <code>DoStuff</code> example.  Introduce multiple operations into this, especially with even simple control flow like a loop, and all of a sudden this becomes the domain of experts that enjoy pain, or blog post authors trying to make a point.</p>
<p>So just to drive that point home, let’s implement a complete example.  At the beginning of this post, I showed a <code>CopyStreamToStream</code> method that copies all of the data from one stream to another (à la <code>Stream.CopyTo</code>, but, for the sake of explanation, assuming that doesn’t exist):</p>
<pre><code>public void CopyStreamToStream(Stream source, Stream destination)
{
    var buffer = new byte[0x1000];
    int numRead;
    while ((numRead = source.Read(buffer, 0, buffer.Length)) != 0)
    {
        destination.Write(buffer, 0, numRead);
    }
}</code></pre>
<p>Straightforward: we repeatedly read from one stream and then write the resulting data to the other, read from one stream and write to the other, and so on, until we have no more data to read.  Now, how would we implement this asynchronously using the APM pattern?  Something like this:</p>
<pre><code>public IAsyncResult BeginCopyStreamToStream(
    Stream source, Stream destination,
    AsyncCallback callback, object state)
{
    var ar = new MyAsyncResult(state);
    var buffer = new byte[0x1000];

    Action&lt;IAsyncResult?&gt; readWriteLoop = null!;
    readWriteLoop = iar =&gt;
    {
        try
        {
            for (bool isRead = iar == null; ; isRead = !isRead)
            {
                if (isRead)
                {
                    iar = source.BeginRead(buffer, 0, buffer.Length, static readResult =&gt;
                    {
                        if (!readResult.CompletedSynchronously)
                        {
                            ((Action&lt;IAsyncResult?&gt;)readResult.AsyncState!)(readResult);
                        }
                    }, readWriteLoop);

                    if (!iar.CompletedSynchronously)
                    {
                        return;
                    }
                }
                else
                {
                    int numRead = source.EndRead(iar!);
                    if (numRead == 0)
                    {
                        ar.Complete(null);
                        callback?.Invoke(ar);
                        return;
                    }

                    iar = destination.BeginWrite(buffer, 0, numRead, writeResult =&gt;
                    {
                        if (!writeResult.CompletedSynchronously)
                        {
                            try
                            {
                                destination.EndWrite(writeResult);
                                readWriteLoop(null);
                            }
                            catch (Exception e2)
                            {
                                ar.Complete(e);
                                callback?.Invoke(ar);
                            }
                        }
                    }, null);

                    if (!iar.CompletedSynchronously)
                    {
                        return;
                    }

                    destination.EndWrite(iar);
                }
            }
        }
        catch (Exception e)
        {
            ar.Complete(e);
            callback?.Invoke(ar);
        }
    };

    readWriteLoop(null);

    return ar;
}

public void EndCopyStreamToStream(IAsyncResult asyncResult)
{
    if (asyncResult is not MyAsyncResult ar)
    {
        throw new ArgumentException(null, nameof(asyncResult));
    }

    ar.Wait();
}

private sealed class MyAsyncResult : IAsyncResult
{
    private bool _completed;
    private int _completedSynchronously;
    private ManualResetEvent? _event;
    private Exception? _error;

    public MyAsyncResult(object? state) =&gt; AsyncState = state;

    public object? AsyncState { get; }

    public void Complete(Exception? error)
    {
        lock (this)
        {
            _completed = true;
            _error = error;
            _event?.Set();
        }
    }

    public void Wait()
    {
        WaitHandle? h = null;
        lock (this)
        {
            if (_completed)
            {
                if (_error is not null)
                {
                    throw _error;
                }
                return;
            }

            h = _event ??= new ManualResetEvent(false);
        }

        h.WaitOne();
        if (_error is not null)
        {
            throw _error;
        }
    }

    public WaitHandle AsyncWaitHandle
    {
        get
        {
            lock (this)
            {
                return _event ??= new ManualResetEvent(_completed);
            }
        }
    }

    public bool CompletedSynchronously
    {
        get
        {
            lock (this)
            {
                if (_completedSynchronously == 0)
                {
                    _completedSynchronously = _completed ? 1 : -1;
                }

                return _completedSynchronously == 1;
            }
        }
    }

    public bool IsCompleted
    {
        get
        {
            lock (this)
            {
                return _completed;
            }
        }
    }
}</code></pre>
<p>Yowsers.  And, even with all of that gobbledygook, it’s still not a great implementation.  For example, the <code>IAsyncResult</code> implementation is locking on every operation rather than doing things in a more lock-free manner where possible, the <code>Exception</code> is being stored raw rather than as an <a href="https://github.com/dotnet/runtime/blob/967a59712996c2cdb8ce2f65fb3167afbd8b01f3/src/libraries/System.Private.CoreLib/src/System/Runtime/ExceptionServices/ExceptionDispatchInfo.cs#L9-L16"><code>ExceptionDispatchInfo</code></a> that would enable augmenting its call stack when propagated, there’s a lot of allocation involved in each individual operation (e.g. a delegate being allocated for each <code>BeginWrite</code> call), and so on. Now, imagine having to do all of this for each method you wanted to write.  Every time you wanted to write a reusable method that would consume another asynchronous operation, you’d need to do all of this work.  And if you wanted to write reusable combinators that could operate over multiple discrete <code>IAsyncResult</code>s efficiently (think <code>Task.WhenAll</code>), that’s another level of difficulty; every operation implementing and exposing its own APIs specific to that operation meant there was no lingua franca for talking about them all similarly (though some developers wrote libraries that tried to ease the burden a bit, typically via another layer of callbacks that enabled the API to supply an appropriate <code>AsyncCallback</code> to a Begin method).</p>
<p>And all of that complication meant that very few folks even attempted this, and for those who did, well, bugs were rampant.  To be fair, this isn’t really a criticism of the APM pattern.  Rather, it’s a critique of callback-based asynchrony in general.  We’re all so used to the power and simplicity that control flow constructs in modern languages provide us with, and callback-based approaches typically run afoul of such constructs once any reasonable amount of complexity is introduced.  No other mainstream language had a better alternative available, either.</p>
<p>We needed a better way, one in which we learned from the APM pattern, incorporating the things it got right while avoiding its pitfalls.  An interesting thing to note is that the APM pattern is just that, a pattern; the runtime, core libraries, and compiler didn’t provide any assistance in consuming or implementing the pattern.</p>
<h2 id="event-based-asynchronous-pattern">Event-Based Asynchronous Pattern</h2>
<p>.NET Framework 2.0 saw a few APIs introduced that implemented a different pattern for handling asynchronous operations, one primarily intended for doing so in the context of client applications.  This Event-based Asynchronous Pattern, or EAP, also came as a pair of members (at least, possibly more), this time a method to initiate the asynchronous operation and an event to listen for its completion.  Thus, our earlier <code>DoStuff</code> example might have been exposed as a set of members like this:</p>
<pre><code>class Handler
{
    public int DoStuff(string arg);

    public void DoStuffAsync(string arg, object? userToken);
    public event DoStuffEventHandler? DoStuffCompleted;
}

public delegate void DoStuffEventHandler(object sender, DoStuffEventArgs e);

public class DoStuffEventArgs : AsyncCompletedEventArgs
{
    public DoStuffEventArgs(int result, Exception? error, bool canceled, object? userToken) :
        base(error, canceled, usertoken) =&gt; Result = result;

    public int Result { get; }
}</code></pre>
<p>You’d register your continuation work with the <code>DoStuffCompleted</code> event and then invoke the <code>DoStuffAsync</code> method; it would initiate the operation, and upon that operation’s completion, the <code>DoStuffCompleted</code> event would be raised asynchronously from the caller.  The handler could then run its continuation work, likely validating that the <code>userToken</code> supplied matched the one it was expecting, enabling multiple handlers to be hooked up to the event at the same time.</p>
<p>This pattern made a few use cases a bit easier while making other uses cases significantly harder (and given the previous APM <code>CopyStreamToStream</code> example, that’s saying something). It didn’t get rolled out in a widespread manner, and it came and went effectively in a single release of .NET Framework, albeit leaving behind the APIs added during its tenure, like <code>Ping.SendAsync</code>/<code>Ping.PingCompleted</code>:</p>
<pre><code>public class Ping : Component
{
    public void SendAsync(string hostNameOrAddress, object? userToken);
    public event PingCompletedEventHandler? PingCompleted;
    ...
}</code></pre>
<p>However, it did add one notable advance that the APM pattern didn’t factor in at all, and that has endured into the models we embrace today: <a href="https://github.com/dotnet/runtime/blob/967a59712996c2cdb8ce2f65fb3167afbd8b01f3/src/libraries/System.Private.CoreLib/src/System/Threading/SynchronizationContext.cs#L6"><code>SynchronizationContext</code></a>.</p>
<p><code>SynchronizationContext</code> was also introduced in .NET Framework 2.0, as an abstraction for a general scheduler.  In particular, <code>SynchronizationContext</code>‘s most used method is <code>Post</code>, which queues a work item to whatever scheduler is represented by that context.  The base implementation of <code>SynchronizationContext</code>, for example, just represents the <code>ThreadPool</code>, and so the <a href="https://github.com/dotnet/runtime/blob/95df571be36ed8973d09746b61fae16b2e3f251f/src/libraries/System.Private.CoreLib/src/System/Threading/SynchronizationContext.cs#L22">base implementation of <code>SynchronizationContext.Post</code></a> simply delegates to <a href="https://learn.microsoft.com/dotnet/api/system.threading.threadpool.queueuserworkitem"><code>ThreadPool.QueueUserWorkItem</code></a>, which is used to ask the <code>ThreadPool</code> to invoke the supplied callback with the associated state on one the pool’s threads. However, <code>SynchronizationContext</code>‘s bread-and-butter isn’t just about supporting arbitrary schedulers, rather it’s about supporting scheduling in a manner that works according to the needs of various application models.</p>
<p>Consider a UI framework like Windows Forms.  As with most UI frameworks on Windows, controls are associated with a particular thread, and that thread runs a message pump which runs work that’s able to interact with those controls: only that thread should try to manipulate those controls, and any other thread that wants to interact with the controls should do so by sending a message to be consumed by the UI thread’s pump.  Windows Forms makes this easy with methods like <code>Control.BeginInvoke</code>, which queues the supplied delegate and arguments to be run by whatever thread is associated with that <code>Control</code>.  You can thus write code like this:</p>
<pre><code>private void button1_Click(object sender, EventArgs e)
{
    ThreadPool.QueueUserWorkItem(_ =&gt;
    {
        string message = ComputeMessage();
        button1.BeginInvoke(() =&gt;
        {
            button1.Text = message;
        });
    });
}</code></pre>
<p>That will offload the <code>ComputeMessage()</code> work to be done on a <code>ThreadPool</code> thread (so as to keep the UI responsive while it’s being processed), and then when that work has completed, queue a delegate back to the thread associated with <code>button1</code> to update <code>button1</code>‘s label.  Easy enough.  WPF has something similar, just with its <code>Dispatcher</code> type:</p>
<pre><code>private void button1_Click(object sender, RoutedEventArgs e)
{
    ThreadPool.QueueUserWorkItem(_ =&gt;
    {
        string message = ComputeMessage();
        button1.Dispatcher.InvokeAsync(() =&gt;
        {
            button1.Content = message;
        });
    });
}</code></pre>
<p>And .NET MAUI has something similar. But what if I wanted to put this logic into a helper method? e.g.</p>
<pre><code>// Call ComputeMessage and then invoke the update action to update controls.
internal static void ComputeMessageAndInvokeUpdate(Action&lt;string&gt; update) { ... }</code></pre>
<p>I could then use that like this:</p>
<pre><code>private void button1_Click(object sender, EventArgs e)
{
    ComputeMessageAndInvokeUpdate(message =&gt; button1.Text = message);
}</code></pre>
<p>but how could <code>ComputeMessageAndInvokeUpdate</code> be implemented in such a way that it could work in any of those applications?  Would it need to be hardcoded to know about every possible UI framework? That’s where <code>SynchronizationContext</code> shines.  We might implement the method like this:</p>
<pre><code>internal static void ComputeMessageAndInvokeUpdate(Action&lt;string&gt; update)
{
    SynchronizationContext? sc = SynchronizationContext.Current;
    ThreadPool.QueueUserWorkItem(_ =&gt;
    {
        string message = ComputeMessage();
        if (sc is not null)
        {
            sc.Post(_ =&gt; update(message), null);
        }
        else
        {
            update(message);
        }
    });
}</code></pre>
<p>That uses the <code>SynchronizationContext</code> as an abstraction to target whatever “scheduler” should be used to get back to the necessary environment for interacting with the UI.  Each application model then ensures it’s published as <code>SynchronizationContext.Current</code> a <code>SynchronizationContext</code>-derived type that does the “right thing.”  For example, <a href="https://github.com/dotnet/winforms/blob/41b11b6a7290a2bbc0c293042f30d9632e55aae2/src/System.Windows.Forms/src/System/Windows/Forms/WindowsFormsSynchronizationContext.cs#L13">Windows Forms has this</a>:</p>
<pre><code>public sealed class WindowsFormsSynchronizationContext : SynchronizationContext, IDisposable
{
    public override void Post(SendOrPostCallback d, object? state) =&gt;
        _controlToSendTo?.BeginInvoke(d, new object?[] { state });
    ...
}</code></pre>
<p>and <a href="https://github.com/dotnet/wpf/blob/c67b9f6f5ad04f5c264b52de0733a8832714615f/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Threading/DispatcherSynchronizationContext.cs#L18">WPF has this</a>:</p>
<pre><code>public sealed class DispatcherSynchronizationContext : SynchronizationContext
{
    public override void Post(SendOrPostCallback d, Object state) =&gt;
        _dispatcher.BeginInvoke(_priority, d, state);
    ...
}</code></pre>
<p>ASP.NET <em>used</em> to <a href="https://referencesource.microsoft.com/#System.Web/AspNetSynchronizationContext.cs,16">have one</a>, which didn’t actually care about what thread work ran on, but rather that work associated with a given request was serialized such that multiple threads wouldn’t concurrently be accessing a given <code>HttpContext</code>:</p>
<pre><code>internal sealed class AspNetSynchronizationContext : AspNetSynchronizationContextBase
{
    public override void Post(SendOrPostCallback callback, Object state) =&gt;
        _state.Helper.QueueAsynchronous(() =&gt; callback(state));
    ...
}</code></pre>
<p>This also isn’t limited to such main application models.  For example, <a href="https://github.com/xunit/xunit">xunit</a> is a popular unit testing framework, one that .NET’s core repos use for their unit testing, and it also employs multiple custom <code>SynchronizationContext</code>s. You can, for example, allow tests to run in parallel but limit the number of tests that are allowed to be running concurrently.  How is that enabled? Via a <code>SynchronizationContext</code>:</p>
<pre><code>public class MaxConcurrencySyncContext : SynchronizationContext, IDisposable
{
    public override void Post(SendOrPostCallback d, object? state)
    {
        var context = ExecutionContext.Capture();
        workQueue.Enqueue((d, state, context));
        workReady.Set();
    }
}</code></pre>
<p><a href="https://github.com/xunit/xunit/blob/601e2d830853fa2ef0048d34afae520d6b73deca/src/xunit.v3.core/Sdk/MaxConcurrencySyncContext.cs#L14"><code>MaxConcurrencySyncContext</code>‘s</a> <code>Post</code> method just queues the work to its own internal work queue, which it then processes on its own worker threads, where it controls how many there are based on the max concurrency desired. You get the idea.</p>
<p>How does this tie in with the Event-based Asynchronous Pattern?  Both EAP and <code>SynchronizationContext</code> were introduced at the same time, and the EAP dictated that the completion events should be queued to whatever <code>SynchronizationContext</code> was current when the asynchronous operation was initiated.  To simplify that ever so slightly (and arguably not enough to warrant the extra complexity), some helper types were also introduced in <code>System.ComponentModel</code>, in particular <code>AsyncOperation</code> and <code>AsyncOperationManager</code>.  The former was just a tuple that wrapped the user-supplied state object and the captured <code>SynchronizationContext</code>, and the latter just served as a simple factory to do that capture and create the <code>AsyncOperation</code> instance.  Then EAP implementations would use those, e.g. <code>Ping.SendAsync</code> called <a href="https://github.com/dotnet/runtime/blob/5f94bffeff62f4b767a311a4505d6d40d86279d9/src/libraries/System.ComponentModel.EventBasedAsync/src/System/ComponentModel/AsyncOperationManager.cs#L10-L36"><code>AsyncOperationManager.CreateOperation</code></a> to capture the <code>SynchronizationContext</code>, and then when the operation completed, the <code>AsyncOperation</code>‘s <a href="https://github.com/dotnet/runtime/blob/5f94bffeff62f4b767a311a4505d6d40d86279d9/src/libraries/System.ComponentModel.EventBasedAsync/src/System/ComponentModel/AsyncOperation.cs#L51-L77"><code>PostOperationCompleted</code></a> method would be invoked to call the stored <code>SynchronizationContext</code>‘s <code>Post</code> method.</p>
<p><code>SynchronizationContext</code> provides a few more trinkets worthy of mention as they’ll show up again in a bit.  In particular, it exposes <code>OperationStarted</code> and <code>OperationCompleted</code> methods.  The base implementation of these virtuals are empty, doing nothing, but a derived implementation might override these to know about in-flight operations.  That means EAP implementations would also invoke these <code>OperationStarted</code>/<code>OperationCompleted</code> at the beginning and end of each operation, in order to inform any present <code>SynchronizationContext</code> and allow it to track the work.  This is particularly relevant to the EAP pattern because the methods that initiate the async operations are <code>void</code> returning: you get nothing back that allows you to track the work individually.  We’ll get back to that.</p>
<p>So, we needed something better than the APM pattern, and the EAP that came next introduced some new things but didn’t really address the core problems we faced. We still needed something better.</p>
<h2 id="enter-tasks">Enter Tasks</h2>
<p>.NET Framework 4.0 introduced the <code>System.Threading.Tasks.Task</code> type. At its heart, a <code>Task</code> is just a data structure that represents the eventual completion of some asynchronous operation (other frameworks call a similar type a “promise” or a “future”).  A <code>Task</code> is created to represent some operation, and then when the operation it logically represents completes, the results are stored into that <code>Task</code>. Simple enough. But <em>the</em> key feature that <code>Task</code> provides that makes it leaps and bounds more useful than <code>IAsyncResult</code> is that it builds into itself the notion of a continuation.  That one feature means you can walk up to any <code>Task</code> and ask to be notified asynchronously when it completes, with the task itself handling the synchronization to ensure the continuation is invoked regardless of whether the task has already completed, hasn’t yet completed, or is completing concurrently with the notification request. Why is that so impactful?  Well, if you remember back to our discussion of the old APM pattern, there were two primary problems.</p>
<ol>
<li>You had to implement a custom <code>IAsyncResult</code> implementation for every operation: there was no built-in <code>IAsyncResult</code> implementation anyone could just use for their needs.</li>
<li>You had to know prior to the Begin method being called what you wanted to do when it was complete. This makes it a significant challenge to implement combinators and other generalized routines for consuming and composing arbitrary async implementations.</li>
</ol>
<p>In contrast, with <code>Task</code>, that shared representation lets you walk up to an async operation <em>after</em> you’ve already initiated the operation and provide a continuation <em>after</em> you’ve already initiated the operation… you don’t need to provide that continuation <em>to</em> the method that initiates the operation.  Everyone who has asynchronous operations can produce a <code>Task</code>, and everyone who consumes asynchronous operations can consume a <code>Task</code>, and nothing custom needs to be done to connect the two: <code>Task</code> becomes the lingua franca for enabling producers and consumers of asynchronous operations to talk.  And that has changed the face of .NET.  More on that in a bit…</p>
<p>For now, let’s better understand what this actually means.  Rather than dive into the intricate code for <code>Task</code>, we’ll do the pedagogical thing and just implement a simple version.  This isn’t meant to be a great implementation, rather only complete enough functionally to help understand the meat of what is a <code>Task</code>, which, at the end of the day, is really just a data structure that handles coordinating the setting and reception of a completion signal.  We’ll start with just a few fields:</p>
<pre><code>class MyTask
{
    private bool _completed;
    private Exception? _error;
    private Action&lt;MyTask&gt;? _continuation;
    private ExecutionContext? _ec;
    ...
}</code></pre>
<p>We need a field to know whether the task has completed (<code>_completed</code>), and we need a field to store any error that caused the task to fail (<code>_error</code>); if we were also implementing a generic <code>MyTask&lt;TResult&gt;</code>, there’d also be a <code>private TResult _result</code> field for storing the successful result of the operation.  Thus far, this looks a lot like our custom <code>IAsyncResult</code> implementation earlier (not a coincidence, of course).  But now the pièce de résistance, the <code>_continuation</code> field. In this simple implementation, we’re supporting just a single continuation, but that’s enough for explanatory purposes (the real <code>Task</code> employs an <a href="https://github.com/dotnet/runtime/blob/81977309048600e67fdb44a7d4c99aaad89846d7/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Task.cs#L176-L178"><code>object</code> field</a> that can either be an individual continuation object or a <code>List&lt;&gt;</code> of continuation objects).  This is a delegate that will be invoked when the task completes.</p>
<p>Now, a bit of surface area. As noted, one of the fundamental advances in <code>Task</code> over previous models was the ability to supply the continuation work (the callback) <em>after</em> the operation was initiated.  We need a method to let us do that, so let’s add <code>ContinueWith</code>:</p>
<pre><code>public void ContinueWith(Action&lt;MyTask&gt; action)
{
    lock (this)
    {
        if (_completed)
        {
            ThreadPool.QueueUserWorkItem(_ =&gt; action(this));
        }
        else if (_continuation is not null)
        {
            throw new InvalidOperationException(&#34;Unlike Task, this implementation only supports a single continuation.&#34;);
        }
        else
        {
            _continuation = action;
            _ec = ExecutionContext.Capture();
        }
    }
}</code></pre>
<p>If the task has already been marked completed by the time <code>ContinueWith</code> is called, <code>ContinueWith</code> just queues the execution of the delegate.  Otherwise, the method stores the delegate, such that the continuation may be queued when the task completes (it also stores something called an <code>ExecutionContext</code>, and then uses that when the delegate is later invoked, but don’t worry about that part for now… we’ll get to it).  Simple enough.</p>
<p>Then we need to be able to mark the <code>MyTask</code> as completed, meaning whatever asynchronous operation it represents has finished. For that, we’ll expose two methods, one to mark it completed successfully (“SetResult”), and one to mark it completed with an error (“SetException”):</p>
<pre><code>public void SetResult() =&gt; Complete(null);

public void SetException(Exception error) =&gt; Complete(error);

private void Complete(Exception? error)
{
    lock (this)
    {
        if (_completed)
        {
            throw new InvalidOperationException(&#34;Already completed&#34;);
        }

        _error = error;
        _completed = true;

        if (_continuation is not null)
        {
            ThreadPool.QueueUserWorkItem(_ =&gt;
            {
                if (_ec is not null)
                {
                    ExecutionContext.Run(_ec, _ =&gt; _continuation(this), null);
                }
                else
                {
                    _continuation(this);
                }
            });
        }
    }
}</code></pre>
<p>We store any error, we mark the task as having been completed, and then if a continuation had previously been registered, we queue it to be invoked.</p>
<p>Finally, we need a way to propagate any exception that may have occurred in the task (and, if this were a generic <code>MyTask&lt;T&gt;</code>, to return its <code>_result</code>); to facilitate certain scenarios, we also allow this method to block waiting for the task to complete, which we can implement in terms of <code>ContinueWith</code> (the continuation just signals a <code>ManualResetEventSlim</code> that the caller then blocks on waiting for completion).</p>
<pre><code>public void Wait()
{
    ManualResetEventSlim? mres = null;
    lock (this)
    {
        if (!_completed)
        {
            mres = new ManualResetEventSlim();
            ContinueWith(_ =&gt; mres.Set());
        }
    }

    mres?.Wait();
    if (_error is not null)
    {
        ExceptionDispatchInfo.Throw(_error);
    }
}</code></pre>
<p>And that’s basically it. Now to be sure, the real <code>Task</code> is way more complicated, with a much more efficient implementation, with support for any number of continuations, with a multitude of knobs about how it should behave (e.g. should continuations be queued as is being done here or should they be invoked synchronously as part of the task’s completion), with the ability to store multiple exceptions rather than just one, with special knowledge of cancellation, with tons of helper methods for doing common operations (e.g. <code>Task.Run</code> which creates a <code>Task</code> to represent a delegate queued to be invoked on the thread pool), and so on.  But there’s no magic to any of that; at its core, it’s just what we saw here.</p>
<p>You might also notice that my simple <code>MyTask</code> has public <code>SetResult</code>/<code>SetException</code> methods directly on it, whereas <code>Task</code> doesn’t.  Actually, <code>Task</code> <em>does</em> have such methods, <a href="https://github.com/dotnet/runtime/blob/81977309048600e67fdb44a7d4c99aaad89846d7/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Task.cs#L3271">they’re just internal</a>, with a <code>System.Threading.Tasks.TaskCompletionSource</code> type serving as a separate “producer” for the task and its completion; that was done not out of technical necessity but as a way to keep the completion methods off of the thing meant only for consumption.  You can then hand out a <code>Task</code> without having to worry about it being completed out from under you; the completion signal is an implementation detail of whatever created the task and also reserves the right to complete it by keeping the <code>TaskCompletionSource</code> to itself. (<code>CancellationToken</code> and <code>CancellationTokenSource</code> follow a similar pattern: <code>CancellationToken</code> is just a struct wrapper for a <code>CancellationTokenSource</code>, serving up only the public surface area related to consuming a cancellation signal but without the ability to produce one, which is a capability restricted to whomever has access to the <code>CancellationTokenSource</code>.)</p>
<p>Of course, we can implement combinators and helpers for this <code>MyTask</code> similar to what <code>Task</code> provides.  Want a simple <code>MyTask.WhenAll</code>? Here you go:</p>
<pre><code>public static MyTask WhenAll(MyTask t1, MyTask t2)
{
    var t = new MyTask();

    int remaining = 2;
    Exception? e = null;

    Action&lt;MyTask&gt; continuation = completed =&gt;
    {
        e ??= completed._error; // just store a single exception for simplicity
        if (Interlocked.Decrement(ref remaining) == 0)
        {
            if (e is not null) t.SetException(e);
            else t.SetResult();
        }
    };

    t1.ContinueWith(continuation);
    t2.ContinueWith(continuation);

    return t;
}</code></pre>
<p>Want a <code>MyTask.Run</code>? You got it:</p>
<pre><code>public static MyTask Run(Action action)
{
    var t = new MyTask();

    ThreadPool.QueueUserWorkItem(_ =&gt;
    {
        try
        {
            action();
            t.SetResult();
        }
        catch (Exception e)
        {
            t.SetException(e);
        }
    });

    return t;
}</code></pre>
<p>How about a <code>MyTask.Delay</code>? Sure:</p>
<pre><code>public static MyTask Delay(TimeSpan delay)
{
    var t = new MyTask();

    var timer = new Timer(_ =&gt; t.SetResult());
    timer.Change(delay, Timeout.InfiniteTimeSpan);

    return t;
}</code></pre>
<p>You get the idea.</p>
<p>With <code>Task</code> in place, all previous async patterns in .NET became a thing of the past.  Anywhere an asynchronous implementation previously was implemented with the APM pattern or the EAP pattern, new <code>Task</code>-returning methods were exposed.</p>
<h3 id="and-valuetasks">And ValueTasks</h3>
<p><code>Task</code> continues to be the workhorse for asynchrony in .NET to this day, with new methods exposed every release and routinely throughout the ecosystem that return <code>Task</code> and <code>Task&lt;TResult&gt;</code>. However, <code>Task</code> is a class, which means creating one does come with an allocation.  For the most part, one extra allocation for a long-lived asynchronous operation is a pittance and won’t meaningfully impact performance for all but the most performance-sensitive operations.  However, as was previously noted, synchronous completion of asynchronous operations is fairly common.  <code>Stream.ReadAsync</code> was introduced to return a <code>Task&lt;int&gt;</code>, but if you’re reading from, say, a <code>BufferedStream</code>, there’s a really good chance many of your reads are going to complete synchronously due to simply needing to pull data from an in-memory buffer rather than performing syscalls and real I/O.  Having to allocate an additional object just to return such data is unfortunate (note it was the case with APM as well).  For non-generic <code>Task</code>-returning methods, the method can just return a singleton already-completed task, and in fact one such singleton is provided by <code>Task</code> in the form of <code>Task.CompletedTask</code>.  But for <code>Task&lt;TResult&gt;</code>, it’s impossible to cache a <code>Task</code> for every possible <code>TResult</code>.  What can we do to make such synchronous completion faster?</p>
<p>It is possible to cache <em>some</em> <code>Task&lt;TResult&gt;</code>s.  For example, <code>Task&lt;bool&gt;</code> is very common, and there’s only two meaningful things to cache there: a <code>Task&lt;bool&gt;</code> when the <code>Result</code> is <code>true</code> and one when the <code>Result</code> is <code>false</code>.  Or while we wouldn’t want to try caching four billion <code>Task&lt;int&gt;</code>s to accommmodate every possible <code>Int32</code> result, small <code>Int32</code> values are very common, so we could cache a few for, say, -1 through 8.  Or for arbitrary types, <code>default</code> is a reasonably common value, so we could cache a <code>Task&lt;TResult&gt;</code> where <code>Result</code> is <code>default(TResult)</code> for every relevant type.  And in fact, <a href="https://github.com/dotnet/runtime/blob/81977309048600e67fdb44a7d4c99aaad89846d7/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Task.cs#L5222-L5273"><code>Task.FromResult</code> does that today</a> (as of recent versions of .NET), using a small cache of such reusable <code>Task&lt;TResult&gt;</code> singletons and returning one of them if appropriate or otherwise allocating a new <code>Task&lt;TResult&gt;</code> for the exact provided result value.  Other schemes can be created to handle other reasonably common cases.  For example, when working with <code>Stream.ReadAsync</code>, it’s reasonably common to call it multiple times on the same stream, all with the same <code>count</code> for the number of bytes allowed to be read.  And it’s reasonably common for the implementation to be able to fully satisfy that <code>count</code> request.  Which means it’s reasonably common for <code>Stream.ReadAsync</code> to repeatedly return the same <code>int</code> result value.  To avoid multiple allocations in such scenarios, multiple <code>Stream</code> types (like <code>MemoryStream</code>) will cache the last <code>Task&lt;int&gt;</code> they successfully returned, and if the next read ends up also completing synchronously and successfully with the same result, it can just return the same <code>Task&lt;int&gt;</code> again rather than creating a new one.  But what about other cases?  How can this allocation for synchronous completions be avoided more generally in situations where the performance overhead really matters?</p>
<p>That’s where <code>ValueTask&lt;TResult&gt;</code> comes into the picture (<a href="https://devblogs.microsoft.com/dotnet/understanding-the-whys-whats-and-whens-of-valuetask/">a much more detailed examination of <code>ValueTask&lt;TResult&gt;</code></a> is also available). <code>ValueTask&lt;TResult&gt;</code> started life as a discriminated union between a <code>TResult</code> and a <code>Task&lt;TResult&gt;</code>.  At the end of the day, ignoring all the bells and whistles, <a href="https://github.com/dotnet/corefx/blob/d6173e069a9bcedfdfd7f4f41e67d23f67157b61/src/System.Threading.Tasks.Extensions/src/System/Threading/Tasks/ValueTask.cs#L53-L58">that’s all it is</a> (or, rather, was), either an immediate result or a promise for a result at some point in the future:</p>
<pre><code>public readonly struct ValueTask&lt;TResult&gt;
{
   private readonly Task&lt;TResult&gt;? _task;
   private readonly TResult _result;
   ...
}</code></pre>
<p>A method could then return such a <code>ValueTask&lt;TResult&gt;</code> instead of a <code>Task&lt;TResult&gt;</code>, and at the expense of a larger return type and a little more indirection, avoid the <code>Task&lt;TResult&gt;</code> allocation if the <code>TResult</code> was known by the time it needed to be returned.</p>
<p>There are, however, super duper extreme high-performance scenarios where you want to be able to avoid the <code>Task&lt;TResult&gt;</code> allocation even in the asynchronous-completion case.  For example, <code>Socket</code> lives at the bottom of the networking stack, and <code>SendAsync</code> and <code>ReceiveAsync</code> on sockets are on the super hot path for many a service, with both synchronous and asynchronous completions being very common (most sends complete synchronously, and many receives complete synchronously due to data having already been buffered in the kernel).  Wouldn’t it be nice if, on a given <code>Socket</code>, we could make such sending and receiving allocation-free, regardless of whether the operations complete synchronously or asynchronously?</p>
<p>That’s where <code>System.Threading.Tasks.Sources.IValueTaskSource&lt;TResult&gt;</code> enters the picture:</p>
<pre><code>public interface IValueTaskSource&lt;out TResult&gt;
{
    ValueTaskSourceStatus GetStatus(short token);
    void OnCompleted(Action&lt;object?&gt; continuation, object? state, short token, ValueTaskSourceOnCompletedFlags flags);
    TResult GetResult(short token);
}</code></pre>
<p>The <code>IValueTaskSource&lt;TResult&gt;</code> interface allows an implementation to provide its own backing object for a <code>ValueTask&lt;TResult&gt;</code>, enabling the object to implement methods like <code>GetResult</code> to retrieve the result of the operation and <code>OnCompleted</code> to hook up a continuation to the operation. With that, <code>ValueTask&lt;TResult&gt;</code> evolved <a href="https://github.com/dotnet/runtime/blob/81977309048600e67fdb44a7d4c99aaad89846d7/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/ValueTask.cs#L465-L468">a small change to its definition</a>, with its <code>Task&lt;TResult&gt;? _task</code> field replaced by an <code>object? _obj</code> field:</p>
<pre><code>public readonly struct ValueTask&lt;TResult&gt;
{
   private readonly object? _obj;
   private readonly TResult _result;
   ...
}</code></pre>
<p>Whereas the <code>_task</code> field was either a <code>Task&lt;TResult&gt;</code> or null, the <code>_obj</code> field now can also be an <code>IValueTaskSource&lt;TResult&gt;</code>.  Once a <code>Task&lt;TResult&gt;</code> is marked as completed, that’s it, it will remain completed and never transition back to an incomplete state. In contrast, an object implementing <code>IValueTaskSource&lt;TResult&gt;</code> has full control over the implementation, and is free to transition bidirectionally between complete and incomplete states, as <code>ValueTask&lt;TResult&gt;</code>‘s contract is that a given instance may be consumed only once, thus by construction it shouldn’t observe a post-consumption change in the underlying instance (this is why analysis rules like <a href="https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca2012">CA2012</a> exist). This then enables types like <code>Socket</code> to pool <code>IValueTaskSource&lt;TResult&gt;</code> instances to use for repeated calls.  <code>Socket</code> caches up to two such instances, one for reads and one for writes, since the 99.999% case is to have at most one receive and one send in-flight at the same time.</p>
<p>I mentioned <code>ValueTask&lt;TResult&gt;</code> but not <code>ValueTask</code>.  When dealing only with avoiding allocation for synchronous completion, there’s little performance benefit to a non-generic <code>ValueTask</code> (representing result-less, <code>void</code> operations), since the same condition can be represented with <code>Task.CompletedTask</code>.  But once we care about the ability to use a poolable underlying object for avoiding allocation in asynchronous completion case, that then also matters for the non-generic.  Thus, when <code>IValueTaskSource&lt;TResult&gt;</code> was introduced, so too were <code>IValueTaskSource</code> and <code>ValueTask</code>.</p>
<p>So, we have <code>Task</code>, <code>Task&lt;TResult&gt;</code>, <code>ValueTask</code>, and <code>ValueTask&lt;TResult&gt;</code>.  We’re able to interact with them in various ways, representing arbitrary asynchronous operations and hooking up continuations to handle the completion of those asynchronous operations. And yes, we can do so <em>before</em> or <em>after</em> the operation completes.</p>
<p><em>But</em>… those continuations are still callbacks!</p>
<p>We’re still forced into a continuation-passing style for encoding our asynchronous control flow!!</p>
<p>It’s still really hard to get right!!!</p>
<p>How can we fix that????</p>
<h2 id="c-iterators-to-the-rescue">C# Iterators to the Rescue</h2>
<p>The glimmer of hope for that solution actually came about a few years before <code>Task</code> hit the scene, with C# 3.0, when it added support for iterators.</p>
<p>“Iterators?” you ask? “You mean for <code>IEnumerable&lt;T&gt;</code>?” That’s the one.  Iterators let you write a single method that is then used by the compiler to implement an <code>IEnumerable&lt;T&gt;</code> and/or an <code>IEnumerator&lt;T&gt;</code>.  For example, if I wanted to create an enumerable that yielded the Fibonnaci sequence, I might write something like this:</p>
<pre><code>public static IEnumerable&lt;int&gt; Fib()
{
    int prev = 0, next = 1;
    yield return prev;
    yield return next;

    while (true)
    {
        int sum = prev + next;
        yield return sum;
        prev = next;
        next = sum;
    }
}</code></pre>
<p>I can then enumerate this with a <code>foreach</code>:</p>
<pre><code>foreach (int i in Fib())
{
    if (i &gt; 100) break;
    Console.Write($&#34;{i} &#34;);
}</code></pre>
<p>I can compose it with other <code>IEnumerable&lt;T&gt;</code>s via combinators like those on <code>System.Linq.Enumerable</code>:</p>
<pre><code>foreach (int i in Fib().Take(12))
{
    Console.Write($&#34;{i} &#34;);
}</code></pre>
<p>Or I can just manually enumerate it directly via an <code>IEnumerator&lt;T&gt;</code>:</p>
<pre><code>using IEnumerator&lt;int&gt; e = Fib().GetEnumerator();
while (e.MoveNext())
{
    int i = e.Current;
    if (i &gt; 100) break;
    Console.Write($&#34;{i} &#34;);
}</code></pre>
<p>All of the above result in this output:</p>
<pre><code>0 1 1 2 3 5 8 13 21 34 55 89</code></pre>
<p>The really interesting thing about this is that in order to achieve the above, we need to be able to enter and exit that <code>Fib</code> method multiple times.  We call <code>MoveNext</code>, it enters the method, the method then executes until it encounters a <code>yield return</code>, at which point the call to <code>MoveNext</code> needs to return <code>true</code> and a subsequent access to <code>Current</code> needs to return the yielded value.  Then we call <code>MoveNext</code> again, and we need to be able to pick up in <code>Fib</code> just after where we last left off, and with all of the state from the previous invocation intact.  Iterators are effectively coroutines provided by the C# language / compiler, with the compiler expanding my <code>Fib</code> iterator into a full-blown state machine:</p>
<pre><code>public static IEnumerable&lt;int&gt; Fib() =&gt; new &lt;Fib&gt;d__0(-2);

[CompilerGenerated]
private sealed class &lt;Fib&gt;d__0 : IEnumerable&lt;int&gt;, IEnumerable, IEnumerator&lt;int&gt;, IEnumerator, IDisposable
{
    private int &lt;&gt;1__state;
    private int &lt;&gt;2__current;
    private int &lt;&gt;l__initialThreadId;
    private int &lt;prev&gt;5__2;
    private int &lt;next&gt;5__3;
    private int &lt;sum&gt;5__4;

    int IEnumerator&lt;int&gt;.Current =&gt; &lt;&gt;2__current;
    object IEnumerator.Current =&gt; &lt;&gt;2__current;

    public &lt;Fib&gt;d__0(int &lt;&gt;1__state)
    {
        this.&lt;&gt;1__state = &lt;&gt;1__state;
        &lt;&gt;l__initialThreadId = Environment.CurrentManagedThreadId;
    }

    private bool MoveNext()
    {
        switch (&lt;&gt;1__state)
        {
            default:
                return false;
            case 0:
                &lt;&gt;1__state = -1;
                &lt;prev&gt;5__2 = 0;
                &lt;next&gt;5__3 = 1;
                &lt;&gt;2__current = &lt;prev&gt;5__2;
                &lt;&gt;1__state = 1;
                return true;
            case 1:
                &lt;&gt;1__state = -1;
                &lt;&gt;2__current = &lt;next&gt;5__3;
                &lt;&gt;1__state = 2;
                return true;
            case 2:
                &lt;&gt;1__state = -1;
                break;
            case 3:
                &lt;&gt;1__state = -1;
                &lt;prev&gt;5__2 = &lt;next&gt;5__3;
                &lt;next&gt;5__3 = &lt;sum&gt;5__4;
                break;
        }
        &lt;sum&gt;5__4 = &lt;prev&gt;5__2 + &lt;next&gt;5__3;
        &lt;&gt;2__current = &lt;sum&gt;5__4;
        &lt;&gt;1__state = 3;
        return true;
    }

    IEnumerator&lt;int&gt; IEnumerable&lt;int&gt;.GetEnumerator()
    {
        if (&lt;&gt;1__state == -2 &amp;&amp;
            &lt;&gt;l__initialThreadId == Environment.CurrentManagedThreadId)
        {
            &lt;&gt;1__state = 0;
            return this;
        }
        return new &lt;Fib&gt;d__0(0);
    }

    IEnumerator IEnumerable.GetEnumerator() =&gt; ((IEnumerable&lt;int&gt;)this).GetEnumerator();
    void IEnumerator.Reset() =&gt; throw new NotSupportedException();
    void IDisposable.Dispose() { }
}</code></pre>
<p>All of the logic for Fib is now inside of the <code>MoveNext</code> method, but as part of a jump table that lets the implementation branch to where it last left off, which is tracked in a generated state field on the enumerator type.  And the variables I wrote as locals, like <code>prev</code>, <code>next</code>, and <code>sum</code>, have been “lifted” to be fields on the enumerator, so that they may persist across invocations of <code>MoveNext</code>.</p>
<p>(Note that the previous code snippet showing how the C# compiler emits the implementation won’t compile as-is.  The C# compiler synthesizes “unspeakable” names, meaning it names types and members it creates in a way that’s valid IL but invalid C#, so as not to risk conflicting with any user-named types and members.  I’ve kept everything named as the compiler does, but if you want to experiment with compiling it, you can rename things to use valid C# names instead.)</p>
<p>In my previous example, the last form of enumeration I showed involved manually using the <code>IEnumerator&lt;T&gt;</code>. At that level, we’re manually invoking <code>MoveNext()</code>, deciding when it was an appropriate time to re-enter the coroutine. But… what if instead of invoking it like that, I could instead have the next invocation of <code>MoveNext</code> actually be part of the continuation work performed when an asynchronous operation completes?  What if I could <code>yield return</code> something that represents an asynchronous operation and have the consuming code hook up a continuation to that yielded object where that continuation then does the <code>MoveNext</code>? With such an approach, I could write a helper method like this:</p>
<pre><code>static Task IterateAsync(IEnumerable&lt;Task&gt; tasks)
{
    var tcs = new TaskCompletionSource();

    IEnumerator&lt;Task&gt; e = tasks.GetEnumerator();

    void Process()
    {
        try
        {
            if (e.MoveNext())
            {
                e.Current.ContinueWith(t =&gt; Process());
                return;
            }
        }
        catch (Exception e)
        {
            tcs.SetException(e);
            return;
        }
        tcs.SetResult();
    };
    Process();

    return tcs.Task;
}</code></pre>
<p>Now this is getting interesting.  We’re given an enumerable of tasks that we can iterate through.  Each time we <code>MoveNext</code> to the next <code>Task</code> and get one, we then hook up a continuation to that <code>Task</code>; when that <code>Task</code> completes, it’ll just turn around and call right back to the same logic that does a <code>MoveNext</code>, gets the next <code>Task</code>, and so on.  This is building on the idea of <code>Task</code> as a single representation for any asynchronous operation, so the enumerable we’re fed can be a sequence of any asynchronous operations.  Where might such a sequence come from?  From an iterator, of course.  Remember our earlier <code>CopyToStreamToStream</code> example and how gloriously horrible the APM-based implementation was?  Consider this instead:</p>
<pre><code>static Task CopyStreamToStreamAsync(Stream source, Stream destination)
{
    return IterateAsync(Impl(source, destination));

    static IEnumerable&lt;Task&gt; Impl(Stream source, Stream destination)
    {
        var buffer = new byte[0x1000];
        while (true)
        {
            Task&lt;int&gt; read = source.ReadAsync(buffer, 0, buffer.Length);
            yield return read;
            int numRead = read.Result;
            if (numRead &lt;= 0)
            {
                break;
            }

            Task write = destination.WriteAsync(buffer, 0, numRead);
            yield return write;
            write.Wait();
        }
    }
}</code></pre>
<p>Wow, this is almost legible.  We’re calling that <code>IterateAsync</code> helper, and the enumerable we’re feeding it is one produced by an iterator that’s handling all the control flow for the copy.  It calls <code>Stream.ReadAsync</code> and then <code>yield return</code>s that <code>Task</code>; that yielded task is what will be handed off to <code>IterateAsync</code> after it calls <code>MoveNext</code>, and <code>IterateAsync</code> will hook a continuation up to that <code>Task</code>, which when it completes will then just call back into <code>MoveNext</code> and end up back in this iterator just after the <code>yield</code>.  At that point, the <code>Impl</code> logic gets the result of the method, calls <code>WriteAsync</code>, and again yields the <code>Task</code> it produced.  And so on.</p>
<p>And that, my friends, is the beginning of <code>async</code>/<code>await</code> in C# and .NET. Something around 95% of the logic in support of iterators and <code>async</code>/<code>await</code> in the C# compiler is shared.  Different syntax, different types involved, but fundamentally the same transform. Squint at the <code>yield return</code>s, and you can almost see <code>await</code>s in their stead.</p>
<p>In fact, some enterprising developers <a href="https://learn.microsoft.com/archive/msdn-magazine/2008/june/concurrent-affairs-simplified-apm-with-the-asyncenumerator"> used iterators in this fashion for asynchronous programming</a> before <code>async</code>/<code>await</code> hit the scene. And a similar transformation was prototyped in the experimental <a href="https://en.wikipedia.org/wiki/Axum_(programming_language)">Axum</a> programming language, serving as a key inspiration for C#’s async support. Axum provided an <code>async</code> keyword that could be put onto a method, just like <code>async</code> can now in C#. <code>Task</code> wasn’t yet ubiquitous, so inside of <code>async</code> methods, the Axum compiler heuristically matched synchronous method calls to their APM counterparts, e.g. if it saw you calling <code>stream.Read</code>, it would find and utilize the corresponding <code>stream.BeginRead</code> and <code>stream.EndRead</code> methods, synthesizing the appropriate delegate to pass to the Begin method, while also generating a complete APM implementation for the <code>async</code> method being defined such that it was compositional. It even integrated with <code>SynchronizationContext</code>! While Axum was eventually shelved, it served as an awesome and motivating prototype for what eventually became <code>async</code>/<code>await</code> in C#.</p>
<h2 id="async-await-under-the-covers"><code>async</code>/<code>await</code> under the covers</h2>
<p>Now that we know how we got here, let’s dive in to how it actually works.  For reference, here’s our example synchronous method again:</p>
<pre><code>public void CopyStreamToStream(Stream source, Stream destination)
{
    var buffer = new byte[0x1000];
    int numRead;
    while ((numRead = source.Read(buffer, 0, buffer.Length)) != 0)
    {
        destination.Write(buffer, 0, numRead);
    }
}</code></pre>
<p>and again here’s what the corresponding method looks like with <code>async</code>/<code>await</code>:</p>
<pre><code>public async Task CopyStreamToStreamAsync(Stream source, Stream destination)
{
    var buffer = new byte[0x1000];
    int numRead;
    while ((numRead = await source.ReadAsync(buffer, 0, buffer.Length)) != 0)
    {
        await destination.WriteAsync(buffer, 0, numRead);
    }
}</code></pre>
<p>A breadth of fresh air in comparison to everything we’ve seen thus far. The signature changed from <code>void</code> to <code>async Task</code>, we call <code>ReadAsync</code> and <code>WriteAsync</code> instead of <code>Read</code> and <code>Write</code>, respectively, and both of those operations are prefixed with <code>await</code>.  That’s it.  The compiler and the core libraries take over the rest, fundamentally changing how the code is actually executed.  Let’s dive into how.</p>
<h3 id="compiler-transform">Compiler Transform</h3>
<p>As we’ve already seen, as with iterators, the compiler rewrites the async method into one based on a state machine.  We still have a method with the same signature the developer wrote (<code>public Task CopyStreamToStreamAsync(Stream source, Stream destination)</code>), but the body of that method is completely different:</p>
<pre><code>[AsyncStateMachine(typeof(&lt;CopyStreamToStreamAsync&gt;d__0))]
public Task CopyStreamToStreamAsync(Stream source, Stream destination)
{
    &lt;CopyStreamToStreamAsync&gt;d__0 stateMachine = default;
    stateMachine.&lt;&gt;t__builder = AsyncTaskMethodBuilder.Create();
    stateMachine.source = source;
    stateMachine.destination = destination;
    stateMachine.&lt;&gt;1__state = -1;
    stateMachine.&lt;&gt;t__builder.Start(ref stateMachine);
    return stateMachine.&lt;&gt;t__builder.Task;
}

private struct &lt;CopyStreamToStreamAsync&gt;d__0 : IAsyncStateMachine
{
    public int &lt;&gt;1__state;
    public AsyncTaskMethodBuilder &lt;&gt;t__builder;
    public Stream source;
    public Stream destination;
    private byte[] &lt;buffer&gt;5__2;
    private TaskAwaiter &lt;&gt;u__1;
    private TaskAwaiter&lt;int&gt; &lt;&gt;u__2;

    ...
}</code></pre>
<p>Note that the only signature difference from what the dev wrote is the lack of the <code>async</code> keyword itself.  <code>async</code> isn’t actually a part of the method signature; like <code>unsafe</code>, when you put it in the method signature, you’re expressing an implementation detail of the method rather than something that’s actually exposed as part of the contract.  Using <code>async</code>/<code>await</code> to implement a <code>Task</code>-returning method is an implementation detail.</p>
<p>The compiler has generated a struct named <code>&lt;CopyStreamToStreamAsync&gt;d__0</code>, and it’s zero-initialized an instance of that struct on the stack. Importantly, if the async method completes synchronously, this state machine will never have left the stack.  That means there’s no allocation associated with the state machine <em>unless</em> the method needs to complete asynchronously, meaning it <code>await</code>s something that’s not yet completed by that point.  More on that in a bit.</p>
<p>This struct <em>is</em> the state machine for the method, containing not only all of the transformed logic from what the developer wrote, but also fields for tracking the current position in that method as well as all of the “local” state the compiler lifted out of the method that needs to survive between <code>MoveNext</code> invocations.  It’s the logical equivalent of the <code>IEnumerable&lt;T&gt;</code>/<code>IEnumerator&lt;T&gt;</code> implementation we saw in the iterator. (Note that the code I’m showing is from a release build; in debug builds the C# compiler will actually generate these state machine types as classes, as doing so can aid in certain debugging exercises).</p>
<p>After initializing the state machine, we see a call to <a href="https://github.com/dotnet/runtime/blob/6319039691477bf9296a0d62fd4a2491868966d8/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/AsyncTaskMethodBuilder.cs#L25"><code>AsyncTaskMethodBuilder.Create()</code></a>.  While we’re currently focused on <code>Task</code>s, the C# language and compiler allow for arbitrary types (<a href="https://learn.microsoft.com/dotnet/csharp/language-reference/proposals/csharp-7.0/task-types#builder-type">“task-like” types</a>) to be returned from <code>async</code> methods, e.g. I can write a method <code>public async MyTask CopyStreamToStreamAsync</code>, and it would compile just fine as long as we augment the <code>MyTask</code> we defined earlier in an appropriate way. That appropriateness includes declaring an associated “builder” type and associating it with the type via the <code>AsyncMethodBuilder</code> attribute:</p>
<pre><code>[AsyncMethodBuilder(typeof(MyTaskMethodBuilder))]
public class MyTask
{
    ...
}

public struct MyTaskMethodBuilder
{
    public static MyTaskMethodBuilder Create() { ... }

    public void Start&lt;TStateMachine&gt;(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine { ... }
    public void SetStateMachine(IAsyncStateMachine stateMachine) { ... }

    public void SetResult() { ... }
    public void SetException(Exception exception) { ... }

    public void AwaitOnCompleted&lt;TAwaiter, TStateMachine&gt;(
        ref TAwaiter awaiter, ref TStateMachine stateMachine)
        where TAwaiter : INotifyCompletion
        where TStateMachine : IAsyncStateMachine { ... }
    public void AwaitUnsafeOnCompleted&lt;TAwaiter, TStateMachine&gt;(
        ref TAwaiter awaiter, ref TStateMachine stateMachine)
        where TAwaiter : ICriticalNotifyCompletion
        where TStateMachine : IAsyncStateMachine { ... }

    public MyTask Task { get { ... } }
}</code></pre>
<p>In this context, such a “builder” is something that knows how to create an instance of that type (the <code>Task</code> property), complete it either successfully and with a result if appropriate (<code>SetResult</code>) or with an exception (<code>SetException</code>), and handle hooking up continuations to <code>await</code>ed things that haven’t yet completed (<code>AwaitOnCompleted</code>/<code>AwaitUnsafeOnCompleted</code>).  In the case of <code>System.Threading.Tasks.Task</code>, it is by default associated with the <code>AsyncTaskMethodBuilder</code>.  Normally that association is provided via an <code>[AsyncMethodBuilder(...)]</code> attribute applied to the type, but <code>Task</code> is known specially to C# and so isn’t actually adorned with that attribute.  As such, the compiler has reached for the builder to use for this <code>async</code> method, and is constructing an instance of it using the <code>Create</code> method that’s part of the pattern.  Note that as with the state machine, <code>AsyncTaskMethodBuilder</code> is also a struct, so there’s no allocation here, either.</p>
<p>The state machine is then populated with the arguments to this entry point method.  Those parameters need to be available to the body of the method that’s been moved into <code>MoveNext</code>, and as such these arguments need to be stored in the state machine so that they can be referenced by the code on the subsequent call to <code>MoveNext</code>.  The state machine is also initialized to be in the initial <code>-1</code> state.  If <code>MoveNext</code> is called and the state is <code>-1</code>, we’ll end up starting logically at the beginning of the method.</p>
<p>Now the most unassuming but most consequential line: a call to the builder’s <a href="https://github.com/dotnet/runtime/blob/6319039691477bf9296a0d62fd4a2491868966d8/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/AsyncTaskMethodBuilder.cs#L32-L33"><code>Start</code></a> method.  This is another part of the pattern that must be exposed on a type used in the return position of an <code>async</code> method, and it’s used to perform the initial <code>MoveNext</code> on the state machine.  The builder’s Start method is effectively just this:</p>
<pre><code>public void Start&lt;TStateMachine&gt;(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine
{
    stateMachine.MoveNext();
}</code></pre>
<p>such that calling <code>stateMachine.&lt;&gt;t__builder.Start(ref stateMachine);</code> is really just calling <code>stateMachine.MoveNext()</code>.  In which case, why doesn’t the compiler just emit that directly? Why have <code>Start</code> at all?  The answer is that there’s a tad bit more to <code>Start</code> than I let on.  But for that, we need to take a brief detour into understanding <code>ExecutionContext</code>.</p>
<h4 id="executioncontext">ExecutionContext</h4>
<p>We’re all familiar with passing around state from method to method.  You call a method, and if that method specifies parameters, you call the method with arguments in order to feed that data into the callee.  This is explicitly passing around data.  But there are other more implicit means.  For example, rather than passing data as arguments, a method could be parameterless but could dictate that some specific static fields may be populated prior to making the method call, and the method will pull state from there.  Nothing about the method’s signature indicates it takes arguments, because it doesn’t: there’s just an implicit contract between the caller and callee that the caller might populate some memory locations and the callee might read those memory locations.  The callee and the caller may not even realize it’s happening if they’re intermediaries, e.g. method <code>A</code> might populate the statics and then call <code>B</code> which calls <code>C</code> which calls <code>D</code> which eventually calls <code>E</code> that reads the values of those statics. This is often referred to as “ambient” data: it’s not passed to you via parameters but rather is just sort of hanging out there and available for you to consume if desired.</p>
<p>We can take this a step further, and use thread-local state. Thread-local state, which in .NET is achieved via static fields attributed as <code>[ThreadStatic]</code> or via the <code>ThreadLocal&lt;T&gt;</code> type, can be used in the same way, but with the data limited to just the current thread of execution, with every thread able to have its own isolated copy of those fields.  With that, you could populate the thread static, make the method call, and then upon the method’s completion revert the changes to the thread static, enabling a fully isolated form of such implicitly passed data.</p>
<p>But, what about asynchrony? If we make an asynchronous method call and logic inside that asynchronous method wants to access that ambient data, how would it do so?  If the data were stored in regular statics, the asynchronous method would be able to access it, but you could only ever have one such method in flight at a time, as multiple callers could end up overwriting each others’ state when they write to those shared static fields.  If the data were stored in thread statics, the asynchronous method would be able to access it, but only up until the point where it stopped running synchronously on the calling thread; if it hooked up a continuation to some operation it initiated and that continuation ended up running on some other thread, it would no longer have access to the thread static information.  Even if it did happen to run on the same thread, either by chance or because the scheduler forced it to, by the time it did it’s likely the data would have been removed and/or overwritten by some other operation initiated by that thread.  For asynchrony, what we need is a mechanism that would allow arbitrary ambient data to flow across these asynchronous points, such that throughout an async method’s logic, wherever and whenever that logic might run, it would have access to that same data.</p>
<p>Enter <code>ExecutionContext</code>.  The <code>ExecutionContext</code> type is the vehicle by which ambient data flows from async operation to async operation.  It lives in a <code>[ThreadStatic]</code>, but then when some asynchronous operation is initiated, it’s “captured” (a fancy way of saying “read a copy from that thread static”), stored, and then when the continuation of that asynchronous operation is run, the <code>ExecutionContext</code> is first restored to live in the <code>[ThreadStatic]</code> on the thread which is about to run the operation.  <code>ExecutionContext</code> is the mechanism by which <code>AsyncLocal&lt;T&gt;</code> is implemented (in fact, in .NET Core, <code>ExecutionContext</code> is entirely about <code>AsyncLocal&lt;T&gt;</code>, nothing more), such that if you store a value into an <code>AsyncLocal&lt;T&gt;</code>, and then for example queue a work item to run on the <code>ThreadPool</code>, that value will be visible in that <code>AsyncLocal&lt;T&gt;</code> inside of that work item running on the pool:</p>
<pre><code>var number = new AsyncLocal&lt;int&gt;();

number.Value = 42;
ThreadPool.QueueUserWorkItem(_ =&gt; Console.WriteLine(number.Value));
number.Value = 0;

Console.ReadLine();</code></pre>
<p>That will print <code>42</code> every time this is run.  It doesn’t matter that the moment after we queue the delegate we reset the value of the <code>AsyncLocal&lt;int&gt;</code> back to 0, because the <code>ExecutionContext</code> was captured as part of the <code>QueueUserWorkItem</code> call, and that capture included the state of the <code>AsyncLocal&lt;int&gt;</code> at that exact moment.  We can see this in more detail by implementing our own simple thread pool:</p>
<pre><code>using System.Collections.Concurrent;

var number = new AsyncLocal&lt;int&gt;();

number.Value = 42;
MyThreadPool.QueueUserWorkItem(() =&gt; Console.WriteLine(number.Value));
number.Value = 0;

Console.ReadLine();

class MyThreadPool
{
    private static readonly BlockingCollection&lt;(Action, ExecutionContext?)&gt; s_workItems = new();

    public static void QueueUserWorkItem(Action workItem)
    {
        s_workItems.Add((workItem, ExecutionContext.Capture()));
    }

    static MyThreadPool()
    {
        for (int i = 0; i &lt; Environment.ProcessorCount; i++)
        {
            new Thread(() =&gt;
            {
                while (true)
                {
                    (Action action, ExecutionContext? ec) = s_workItems.Take();
                    if (ec is null)
                    {
                        action();
                    }
                    else
                    {
                        ExecutionContext.Run(ec, s =&gt; ((Action)s!)(), action);
                    }
                }
            })
            { IsBackground = true }.UnsafeStart();
        }
    }
}</code></pre>
<p>Here <code>MyThreadPool</code> has a <code>BlockingCollection&lt;(Action, ExecutionContext?)&gt;</code> that represents its work item queue, with each work item being the delegate for the work to be invoked as well as the <code>ExecutionContext</code> associated with that work.  The static constructor for the pool spins up a bunch of threads, each of which just sits in an infinite loop taking the next work item and running it.  If no <code>ExecutionContext</code> was captured for a given delegate, the delegate is just invoked directly.  But if an <code>ExecutionContext</code> was captured, rather than invoking the delegate directly, we call the <code>ExecutionContext.Run</code> method, which will restore the supplied <code>ExecutionContext</code> as the current context prior to running the delegate, and will then reset the context afterwards.  This example includes the exact same code with an <code>AsyncLocal&lt;int&gt;</code> previously shown, except this time using <code>MyThreadPool</code> instead of <code>ThreadPool</code>, yet it will still output <code>42</code> each time, because the pool is properly flowing <code>ExecutionContext</code>.</p>
<p>As an aside, you’ll note I called <code>UnsafeStart</code> in <code>MyThreadPool</code>‘s static constructor. Starting a new thread is exactly the kind of asynchronous point that should flow <code>ExecutionContext</code>, and indeed, <code>Thread</code>‘s <code>Start</code> method uses <code>ExecutionContext.Capture</code> to capture the current context, store it on the <code>Thread</code>, and then use that captured context when eventually invoking the <code>Thread</code>‘s <code>ThreadStart</code> delegate.  I didn’t want to do that in this example, though, as I didn’t want the <code>Thread</code>s to capture whatever <code>ExecutionContext</code> happened to be present when the static constructor ran (doing so could make a demo about <code>ExecutionContext</code> more convoluted), so I used the <code>UnsafeStart</code> method instead.  Threading-related methods that begin with <code>Unsafe</code> behave exactly the same as the corresponding method that lacks the <code>Unsafe</code> prefix except that they <em>don’t</em> capture <code>ExecutionContext</code>, e.g. <code>Thread.Start</code> and <code>Thread.UnsafeStart</code> do identical work, but whereas <code>Start</code> captures <code>ExecutionContext</code>, <code>UnsafeStart</code> does not.</p>
<h4 id="back-to-start">Back To Start</h4>
<p>We took a detour into discussing <code>ExecutionContext</code> when I was writing about the implementation of <code>AsyncTaskMethodBuilder.Start</code>, which I said was effectively:</p>
<pre><code>public void Start&lt;TStateMachine&gt;(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine
{
    stateMachine.MoveNext();
}</code></pre>
<p>and then suggested I simplified a bit.  That simplification was ignoring the fact that the method actually needs to factor <code>ExecutionContext</code> into things, and is thus more like this:</p>
<pre><code>public void Start&lt;TStateMachine&gt;(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine
{
    ExecutionContext previous = Thread.CurrentThread._executionContext; // [ThreadStatic] field
    try
    {
        stateMachine.MoveNext();
    }
    finally
    {
        ExecutionContext.Restore(previous); // internal helper
    }
}</code></pre>
<p>Rather than just calling <code>stateMachine.MoveNext()</code> as I’d previously suggested we did, we do a dance here of getting the current <code>ExecutionContext</code>, then invoking <code>MoveNext</code>, and then upon its completion resetting the current context back to what it was prior to the <code>MoveNext</code> invocation.</p>
<p>The reason for this is to prevent ambient data leakage from an async method out to its caller.  An example method demonstrates why that matters:</p>
<pre><code>async Task ElevateAsAdminAndRunAsync()
{
    using (WindowsIdentity identity = LoginAdmin())
    {
        using (WindowsImpersonationContext impersonatedUser = identity.Impersonate())
        {
            await DoSensitiveWorkAsync();
        }
    }
}</code></pre>
<p>“Impersonation” is the act of changing ambient information about the current user to instead be that of someone else; this lets code act on behalf of someone else, using their privileges and access. In .NET, such impersonation flows across asynchronous operations, which means it’s part of <code>ExecutionContext</code>.  Now imagine if <code>Start</code> didn’t restore the previous context, and consider this code:</p>
<pre><code>Task t = ElevateAsAdminAndRunAsync();
PrintUser();
await t;</code></pre>
<p>This code could find that the <code>ExecutionContext</code> modified inside of <code>ElevateAsAdminAndRunAsync</code> remains after <code>ElevateAsAdminAndRunAsync</code> returns to its synchronous caller (which happens the first time the method <code>await</code>s something that’s not yet complete).  That’s because after calling <code>Impersonate</code>, we call <code>DoSensitiveWorkAsync</code> and <code>await</code> the task it returns.  Assuming that task isn’t complete, it will cause the invocation of <code>ElevateAsAdminAndRunAsync</code> to yield and return to the caller, with the impersonation still in effect on the current thread. That is not something we want.  As such, <code>Start</code> erects this guard that ensures any modifications to <code>ExecutionContext</code> don’t flow <em>out</em> of the synchronous method call and only flow along with any subsequent work performed by the method.</p>
<h4 id="movenext">MoveNext</h4>
<p>So, the entry point method was invoked, the state machine struct was initialized, <code>Start</code> was called, and that invoked <code>MoveNext</code>.  What is <code>MoveNext</code>?  It’s the method that contains all of the original logic from the dev’s method, but with a whole bunch of changes.  Let’s start just by looking at the scaffolding of the method. Here’s a decompiled version of what the compiler emit for our method, but with everything inside of the generated <code>try</code> block removed:</p>
<pre><code>private void MoveNext()
{
    try
    {
        ... // all of the code from the CopyStreamToStreamAsync method body, but not exactly as it was written
    }
    catch (Exception exception)
    {
        &lt;&gt;1__state = -2;
        &lt;buffer&gt;5__2 = null;
        &lt;&gt;t__builder.SetException(exception);
        return;
    }

    &lt;&gt;1__state = -2;
    &lt;buffer&gt;5__2 = null;
    &lt;&gt;t__builder.SetResult();
}</code></pre>
<p>Whatever other work is performed by <code>MoveNext</code>, it has the responsibility of completing the <code>Task</code> returned from the <code>async Task</code> method when all of the work is done.  If the body of the <code>try</code> block throws an exception that goes unhandled, then the task will be faulted with that exception.  And if the async method successfully reaches its end (equivalent to a synchronous method returning), it will complete the returned task successfully.  In either of those cases, it’s setting the state of the state machine to indicate completion. (I sometimes hear developers theorize that, when it comes to exceptions, there’s a difference between those thrown before the first <code>await</code> and after… based on the above, it should be clear that is <em>not</em> the case.  Any exception that goes unhandled inside of an <code>async</code> method, no matter where it is in the method and no matter whether the method has yielded, will end up in the above <code>catch</code> block, with the caught exception then stored into the <code>Task</code> that’s returned from the <code>async</code> method.)</p>
<p>Also note that this completion is going through the builder, using its <code>SetException</code> and <code>SetResult</code> methods that are part of the pattern for a builder expected by the compiler.  If the async method has previously suspended, the builder will have already had to manufacture a <code>Task</code> as part of that suspension handling (we’ll see how and where soon), in which case calling <code>SetException</code>/<code>SetResult</code> will complete that <code>Task</code>.  If, however, the async method hasn’t previously suspended, then we haven’t yet created a <code>Task</code> or returned anything to the caller, so the builder has more flexibility in how it produces that <code>Task</code>.  If you remember previously in the entry point method, the very last thing it does is return the <code>Task</code> to the caller, which it does by returning the result of accessing the builder’s <code>Task</code> property (so many things called “Task”, I know):</p>
<pre><code>public Task CopyStreamToStreamAsync(Stream source, Stream destination)
{
    ...
    return stateMachine.&lt;&gt;t__builder.Task;
}</code></pre>
<p>The builder knows if the method ever suspended, in which case it has a <code>Task</code> that was already created and just returns that.  If the method never suspended and the builder doesn’t yet have a task, it can manufacture a completed task here. In this case, with a successful completion, it can just use <code>Task.CompletedTask</code> rather than allocating a new task, avoiding any allocation. In the case of a generic <code>Task&lt;TResult&gt;</code>, the builder can just use <code>Task.FromResult&lt;TResult&gt;(TResult result)</code>.</p>
<p>The builder can also do whatever translations it deems are appropriate to the kind of object it’s creating.  For example, <code>Task</code> actually has three possible final states: success, failure, and canceled. The <code>AsyncTaskMethodBuilder</code>‘s <code>SetException</code> method <a href="https://github.com/dotnet/runtime/blob/3e73be1b8082840545dbf85867cc4f9023e9b1aa/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/AsyncTaskMethodBuilderT.cs#L461-L486">special-cases <code>OperationCanceledException</code></a>, transitioning the <code>Task</code> into a <code>TaskStatus.Canceled</code> final state if the exception provided is or derives from <code>OperationCanceledException</code>; otherwise, the task ends as <code>TaskStatus.Faulted</code>.  Such a distinction often isn’t apparent in consuming code; since the exception is stored into the <code>Task</code> regardless of whether it’s marked as <code>Canceled</code> or <code>Faulted</code>, code <code>await</code>‘ing that <code>Task</code> will not be able to observe the difference between the states (the original exception will be propagated in either case)… it only affects code that interacts with the <code>Task</code> directly, such as via <code>ContinueWith</code>, which has overloads that enable a continuation to be invoked only for a subset of completion statuses.</p>
<p>Now that we understand the lifecycle aspects, here’s everything filled in inside the <code>try</code> block in <code>MoveNext</code>:</p>
<pre><code>private void MoveNext()
{
    try
    {
        int num = &lt;&gt;1__state;

        TaskAwaiter&lt;int&gt; awaiter;
        if (num != 0)
        {
            if (num != 1)
            {
                &lt;buffer&gt;5__2 = new byte[4096];
                goto IL_008b;
            }

            awaiter = &lt;&gt;u__2;
            &lt;&gt;u__2 = default(TaskAwaiter&lt;int&gt;);
            num = (&lt;&gt;1__state = -1);
            goto IL_00f0;
        }

        TaskAwaiter awaiter2 = &lt;&gt;u__1;
        &lt;&gt;u__1 = default(TaskAwaiter);
        num = (&lt;&gt;1__state = -1);
        IL_0084:
        awaiter2.GetResult();

        IL_008b:
        awaiter = source.ReadAsync(&lt;buffer&gt;5__2, 0, &lt;buffer&gt;5__2.Length).GetAwaiter();
        if (!awaiter.IsCompleted)
        {
            num = (&lt;&gt;1__state = 1);
            &lt;&gt;u__2 = awaiter;
            &lt;&gt;t__builder.AwaitUnsafeOnCompleted(ref awaiter, ref this);
            return;
        }
        IL_00f0:
        int result;
        if ((result = awaiter.GetResult()) != 0)
        {
            awaiter2 = destination.WriteAsync(&lt;buffer&gt;5__2, 0, result).GetAwaiter();
            if (!awaiter2.IsCompleted)
            {
                num = (&lt;&gt;1__state = 0);
                &lt;&gt;u__1 = awaiter2;
                &lt;&gt;t__builder.AwaitUnsafeOnCompleted(ref awaiter2, ref this);
                return;
            }
            goto IL_0084;
        }
    }
    catch (Exception exception)
    {
        &lt;&gt;1__state = -2;
        &lt;buffer&gt;5__2 = null;
        &lt;&gt;t__builder.SetException(exception);
        return;
    }

    &lt;&gt;1__state = -2;
    &lt;buffer&gt;5__2 = null;
    &lt;&gt;t__builder.SetResult();
}</code></pre>
<p>This kind of complication might feel a tad familiar.  Remember how convoluted our manually-implemented <code>BeginCopyStreamToStream</code> based on APM was?  This isn’t quite as complicated, but is also way better in that the compiler is doing the work for us, having rewritten the method in a form of continuation passing while ensuring that all necessary state is preserved for those continuations.  Even so, we can squint and follow along.  Remember that the state was initialized to -1 in the entry point.  We then enter <code>MoveNext</code>, find that this state (which is now stored in the <code>num</code> local) is neither 0 nor 1, and thus execute the code that creates the temporary buffer and then branches to label IL_008b, where it makes the call to <code>stream.ReadAsync</code>.  Note that at this point we’re still running synchronously from this call to <code>MoveNext</code>, and thus synchronously from <code>Start</code>, and thus synchronously from the entry point, meaning the developer’s code called <code>CopyStreamToStreamAsync</code> and it’s still synchronously executing, having not yet returned back a <code>Task</code> to represent the eventual completion of this method. That might be about to change…</p>
<p>We call <code>Stream.ReadAsync</code> and we get back a <code>Task&lt;int&gt;</code> from it.  The read may have completed synchronously, it may have completed asynchronously but so fast that it’s now already completed, or it might not have completed yet.  Regardless, we have a <code>Task&lt;int&gt;</code> that represents its eventual completion, and the compiler emits code that inspects that <code>Task&lt;int&gt;</code> to determine how to proceed: if the <code>Task&lt;int&gt;</code> has in fact already completed (doesn’t matter whether it was completed synchronously or just by the time we checked), then the code for this method can just continue running synchronously… no point in spending unnecessary overhead queueing a work item to handle the remainder of the method’s execution when we can instead just keep running here and now.  But to handle the case where the <code>Task&lt;int&gt;</code> hasn’t completed, the compiler needs to emit code to hook up a continuation to the <code>Task</code>.  It thus needs to emit code that asks the <code>Task</code> “are you done?”  Does it talk to the <code>Task</code> directly to ask that?</p>
<p>It would be limiting if the only thing you could <code>await</code> in C# was a <code>System.Threading.Tasks.Task</code>.  Similarly, it would be limiting if the C# compiler had to know about every possible type that could be <code>await</code>ed.  Instead, C# does what it typically does in cases like this: it employs a pattern of APIs. Code can <code>await</code> anything that exposes that appropriate pattern, the “awaiter” pattern (just as you can <code>foreach</code> anything that provides the proper “enumerable” pattern).  For example, we can augment the <code>MyTask</code> type we wrote earlier to implement the awaiter pattern:</p>
<pre><code>class MyTask
{
    ...
    public MyTaskAwaiter GetAwaiter() =&gt; new MyTaskAwaiter { _task = this };

    public struct MyTaskAwaiter : ICriticalNotifyCompletion
    {
        internal MyTask _task;

        public bool IsCompleted =&gt; _task._completed;
        public void OnCompleted(Action continuation) =&gt; _task.ContinueWith(_ =&gt; continuation());
        public void UnsafeOnCompleted(Action continuation) =&gt; _task.ContinueWith(_ =&gt; continuation());
        public void GetResult() =&gt; _task.Wait();
    }
}</code></pre>
<p>A type can be awaited if it exposes a <code>GetAwaiter()</code> method, which <code>Task</code> does.  That method needs to return something that in turn exposes several members, including an <code>IsCompleted</code> property, which is used to check at the moment <code>IsCompleted</code> is called whether the operation has already completed.  And you can see that happening: at IL_008b, the <code>Task</code> returned from <code>ReadAsync</code> has <code>GetAwaiter</code> called on it, and then <code>IsCompleted</code> accessed on that struct awaiter instance.  If <code>IsCompleted</code> returns <code>true</code>, then we’ll end up falling through to IL_00f0, where the code calls another member of the awaiter: <code>GetResult()</code>.  If the operation failed, <code>GetResult()</code> is responsible for throwing an exception in order to propagate it out of the <code>await</code> in the async method; otherwise, <code>GetResult()</code> is responsible for returning the result of the operation, if there is one.  In the case here of the <code>ReadAsync</code>, if that result is 0, then we break out of our read/write loop, go to the end of the method where it calls <code>SetResult</code>, and we’re done.</p>
<p>Backing up a moment, though, the really interesting part of all of this is what happens if that <code>IsCompleted</code> check actually returns <code>false</code>.  If it returns <code>true</code>, we just keep on processing the loop, akin to in the APM pattern when <code>CompletedSynchronously</code> returned true and the caller of the Begin method, rather than the callback, was responsible for continuing execution. But if <code>IsCompleted</code> returns false, we need to suspend the execution of the async method until the <code>await</code>‘d operation completes.  That means returning out of <code>MoveNext</code>, and as this was part of <code>Start</code> and we’re still in the entry point method, that means returning the <code>Task</code> out to the caller.  But before any of that can happen, we need to hook up a continuation to the <code>Task</code> being awaited (noting that to avoid stack dives as in the APM case, if the asynchronous operation completes after <code>IsCompleted</code> returns false but before we get to hook up the continuation, the continuation still needs to be invoked asynchronously from the calling thread, and thus it’ll get queued).  Since we can <code>await</code> anything, we can’t just talk to the <code>Task</code> instance directly; instead, we need to go through some pattern-based method to perform this.</p>
<p>Does that mean there’s a method on the awaiter that will hook up the continuation?  That would make sense; after all, <code>Task</code> itself supports continuations, has a <code>ContinueWith</code> method, etc… shouldn’t it be the <code>TaskAwaiter</code> returned from <code>GetAwaiter</code> that exposes the method that lets us set up a continuation?  It does, in fact.  The awaiter pattern requires that the awaiter implement the <code>INotifyCompletion</code> interface, which contains a single method <code>void OnCompleted(Action continuation)</code>.  An awaiter can also optionally implement the <code>ICriticalNotifyCompletion</code> interface, which inherits <code>INotifyCompletion</code> and adds a <code>void UnsafeOnCompleted(Action continuation)</code> method.  Per our previous discussion of <code>ExecutionContext</code>, you can guess what the difference between these two methods is: both hook up the continuation, but whereas <code>OnCompleted</code> should flow <code>ExecutionContext</code>, <code>UnsafeOnCompleted</code> needn’t. The need for two distinct methods here, <code>INotifyCompletion.OnCompleted</code> and <code>ICriticalNotifyCompletion.UnsafeOnCompleted</code>, is largely historical, having to do with Code Access Security, or CAS.  CAS no longer exists in .NET Core, and it’s off by default in .NET Framework, having teeth only if you opt back in to the legacy partial trust feature.  When partial trust is used, CAS information flows as part of <code>ExecutionContext</code>, and thus not flowing it is “unsafe”, hence why methods that don’t flow <code>ExecutionContext</code> were prefixed with “Unsafe”.  Such methods were also attributed as <code>[SecurityCritical]</code>, and partially trusted code can’t call a <code>[SecurityCritical]</code> method.  As a result, two variants of <code>OnCompleted</code> were created, with the compiler preferring to use <code>UnsafeOnCompleted</code> if provided, but with the <code>OnCompleted</code> variant always provided on its own in case an awaiter needed to support partial trust.  From an async method perspective, however, the builder always flows <code>ExecutionContext</code> across await points, so an awaiter that also does so is unnecessary and duplicative work.</p>
<p>Ok, so the awaiter does expose a method to hook up the continuation.  The compiler <em>could</em> use it directly, except for a very critical piece of the puzzle: what exactly should the continuation be?  And more to the point, with what object should it be associated? Remember that the state machine struct is on the stack, and the <code>MoveNext</code> invocation we’re currently running in is a method call on that instance. We need to preserve the state machine so that upon resumption we have all the correct state, which means the state machine can’t just keep living on the stack; it needs to be copied to somewhere on the heap, since the stack is going to end up being used for other subsequent, unrelated work performed by this thread.  And then the continuation needs to invoke the <code>MoveNext</code> method on that copy of the state machine on the heap.</p>
<p>Moreover, <code>ExecutionContext</code> is relevant here as well.  The state machine needs to ensure that any ambient data stored in the <code>ExecutionContext</code> is captured at the point of suspension and then applied at the point of resumption, which means the continuation also needs to incorporate that <code>ExecutionContext</code>.  So, just creating a delegate that points to <code>MoveNext</code> on the state machine is insufficient.  It’s also undesirable overhead.  If when we suspend we create a delegate that points to <code>MoveNext</code> on the state machine, each time we do so we’ll be boxing the state machine struct (even when it’s already on the heap as part of some other object) and allocating an additional delegate (the delegate’s <code>this</code> object reference will be to a newly boxed copy of the struct).  We thus need to do a complicated dance whereby we ensure we only promote the struct from the stack to the heap the first time the method suspends execution but all other times uses the same heap object as the target of the <code>MoveNext</code>, and in the process ensures we’ve captured the right context, and upon resumption ensures we’re using that captured context to invoke the operation.</p>
<p>That’s a lot more logic than we want the compiler to emit… we instead want it encapsulated in a helper, for several reasons. First, it’s a lot of complicated code to be emitted into each user’s assembly. Second, we want to allow customization of that logic as part of implementing the builder pattern (we’ll see an example of why later when talking about pooling).  And third, we want to be able to evolve and improve that logic and have existing previously-compiled binaries just get better.  That’s not a hypothetical; the library code for this support was completely overhauled in .NET Core 2.1, such that the operation is much more efficient than it was on .NET Framework.  We’ll start by exploring exactly how this worked on .NET Framework, and then look at what happens now in .NET Core.</p>
<p>You can see in the code generated by the C# compiler happens when we need to suspend:</p>
<pre><code>if (!awaiter.IsCompleted) // we need to suspend when IsCompleted is false
{
    &lt;&gt;1__state = 1;
    &lt;&gt;u__2 = awaiter;
    &lt;&gt;t__builder.AwaitUnsafeOnCompleted(ref awaiter, ref this);
    return;
}</code></pre>
<p>We’re storing into the state field the state id that indicates the location we should jump to when the method resumes.  We’re then persisting the awaiter itself into a field, so that it can be used to call <code>GetResult</code> after resumption.  And then just before returning out of the <code>MoveNext</code> call, the very last thing we do is call <code>&lt;&gt;t__builder.AwaitUnsafeOnCompleted(ref awaiter, ref this)</code>, asking the builder to hook up a continuation to the awaiter for this state machine. (Note that it calls the builder’s <code>AwaitUnsafeOnCompleted</code> rather than the builder’s <code>AwaitOnCompleted</code> because the awaiter implements <code>ICriticalNotifyCompletion</code>; the state machine handles flowing <code>ExecutionContext</code> so we needn’t require the awaiter to as well… as mentioned earlier, doing so would just be duplicative and unnecessary overhead.)</p>
<p>The implementation of that <code>AwaitUnsafeOnCompleted</code> method is too complicated to copy here, so I’ll summarize <a href="https://referencesource.microsoft.com/#mscorlib/system/runtime/compilerservices/AsyncMethodBuilder.cs,535">what it does</a> on .NET Framework:</p>
<ol>
<li>
<p>It uses <code>ExecutionContext.Capture()</code> to grab the current context.</p>
</li>
<li>
<p>It then allocates a <code>MoveNextRunner</code> object to wrap both the captured context as well as the boxed state machine (which we don’t yet have if this is the first time the method suspends, so we just use <code>null</code> as a placeholder).</p>
</li>
<li>
<p>It then creates an <code>Action</code> delegate to a <code>Run</code> method on that <code>MoveNextRunner</code>; this is how it’s able to get a delegate that will invoke the state machine’s <code>MoveNext</code> in the context of the captured <code>ExecutionContext</code>.</p>
</li>
<li>
<p>If this is the first time the method is suspending, we won’t yet have a boxed state machine, so at this point it boxes it, creating a copy on the heap by storing the instance into a local typed as the <code>IAsyncStateMachine</code> interface.  That box is then stored into the <code>MoveNextRunner</code> that was allocated.</p>
</li>
<li>
<p>Now comes a somewhat mind-bending step.  If you look back at the definition of the state machine struct, it contains the builder, <code>public AsyncTaskMethodBuilder &lt;&gt;t__builder;</code>, and if you look at the definition of the builder, it contains <code>internal IAsyncStateMachine m_stateMachine;</code>.  The builder needs to reference the boxed state machine so that on subsequent suspensions it can see it’s already boxed the state machine and doesn’t need to do so again.  But we just boxed the state machine, and that state machine contained a builder whose <code>m_stateMachine</code> field is null.  We need to mutate that boxed state machine’s builder’s <code>m_stateMachine</code> to point to its parent box.  To achieve that, the <code>IAsyncStateMachine</code> interface that the compiler-generated state machine struct implements includes a <code>void SetStateMachine(IAsyncStateMachine stateMachine);</code> method, and that state machine struct includes an implementation of that interface method:</p>
<pre><code>private void SetStateMachine(IAsyncStateMachine stateMachine) =&gt;
    &lt;&gt;t__builder.SetStateMachine(stateMachine);</code></pre>
<p>So the builder boxes the state machine, and then passes that box to the box’s <code>SetStateMachine</code> method, which calls to the builder’s <code>SetStateMachine</code> method, which stores the box into the field. Whew.</p>
</li>
<li>
<p>Finally, we have an <code>Action</code> that represents the continuation, and that’s passed to the awaiter’s <code>UnsafeOnCompleted</code> method.  In the case of a <code>TaskAwaiter</code>, the task will store that <code>Action</code> into the task’s continuation list, such that when the task completes, it’ll invoke the <code>Action</code>, call back through the <code>MoveNextRunner.Run</code>, call back through <code>ExecutionContext.Run</code>, and finally invoke the state machine’s <code>MoveNext</code> method to re-enter the state machine and continue running from where it left off.</p>
</li>
</ol>
<p>That’s what happens on .NET Framework, and you can witness the outcome of this in a profiler, such as by running an allocation profiler to see what’s allocated on each await.  Let’s take this silly program, which I’ve written just to highlight the allocation costs involved:</p>
<pre><code>using System.Threading;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        var al = new AsyncLocal&lt;int&gt;() { Value = 42 };
        for (int i = 0; i &lt; 1000; i++)
        {
            await SomeMethodAsync();
        }
    }

    static async Task SomeMethodAsync()
    {
        for (int i = 0; i &lt; 1000; i++)
        {
            await Task.Yield();
        }
    }
}</code></pre>
<p>This program is creating an <code>AsyncLocal&lt;int&gt;</code> to flow the value 42 through all subsequent async operations.  It’s then calling <code>SomeMethodAsync</code> 1000 times, each of which is suspending/resuming 1000 times.  In Visual Studio, I run this using the <a href="https://learn.microsoft.com/visualstudio/profiling/dotnet-alloc-tool">.NET Object Allocation Tracking profiler</a>, which yields the following results:
<img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/03/AllocationNetFramework.png" alt="Allocation associated with asynchronous operations on .NET Framework"/>
That’s… a lot of allocation! Let’s examine each of these to understand where they’re coming from.</p>
<ul>
<li><code>ExecutionContext</code>.  There’s over a million of these being allocated. Why? Because in .NET Framework, <code>ExecutionContext</code> is a <em>mutable</em> data structure.  Since we want to flow the data that was present at the time an async operation was forked and we don’t want it to then see mutations performed after that fork, we need to copy the <code>ExecutionContext</code>.  Every single forked operation requires such a copy, so with 1000 calls to <code>SomeMethodAsync</code> each of which is suspending/resuming 1000 times, we have a million <code>ExecutionContext</code> instances. Ouch.</li>
<li><code>Action</code>. Similarly, every time we <code>await</code> something that’s not yet complete (which is the case with our million <code>await Task.Yield()</code>s), we end up allocating a new <code>Action</code> delegate to pass to that awaiter’s <code>UnsafeOnCompleted</code> method.</li>
<li><code>MoveNextRunner</code>.  Same deal; there’s a million of these, since in the outline of the steps earlier, every time we suspend, we’re allocating a new <code>MoveNextRunner</code> to store the <code>Action</code> and the <code>ExecutionContext</code>, in order to execute the former with the latter.</li>
<li><code>LogicalCallContext</code>. Another million.  These are an implementation detail of <code>AsyncLocal&lt;T&gt;</code> on .NET Framework; <code>AsyncLocal&lt;T&gt;</code> stores its data into the <code>ExecutionContext</code>‘s “logical call context”, which is a fancy way of saying the general state that’s flowed with the <code>ExecutionContext</code>.  So, if we’re making a million copies of the <code>ExecutionContext</code>, we’re making a million copies of the <code>LogicalCallContext</code>, too.</li>
<li><code>QueueUserWorkItemCallback</code>. Each <code>Task.Yield()</code> is queueing a work item to the thread pool, resulting in a million allocations of the work item objects used to represent those million operations.</li>
<li><code>Task&lt;VoidResult&gt;</code>. There’s a thousand of these, so at least we’re out of the “million” club.  Every <code>async Task</code> invocation that completes asynchronously needs to allocate a new <code>Task</code> instance to represent the eventual completion of that call.</li>
<li><code>&lt;SomeMethodAsync&gt;d__1</code>.  This is the box of the compiler-generated state machine struct.  1000 methods suspend, 1000 boxes occur.</li>
<li><code>QueueSegment</code>/<code>IThreadPoolWorkItem[]</code>.  There are several thousand of these, and they’re not technically related to async methods specifically, but rather to work being queued to the thread pool in general.  In .NET Framework, the thread pool’s queue is a linked list of non-circular segments. These segments aren’t reused; for a segment of length N, once N work items have been enqueued into and dequeued from that segment, the segment is discarded and left up for garbage collection.</li>
</ul>
<p>That was .NET Framework.  <a href="https://github.com/dotnet/runtime/blob/8de96c8b1b1cc3a781f23dcdf68c0aeb62dadbe7/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/AsyncTaskMethodBuilderT.cs#L97-L145">This</a> is .NET Core:
<img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/03/AllocationNetCore.png" alt="Allocation associated with asynchronous operations on .NET Core"/>
So much prettier!  For this sample on .NET Framework, there were more than 5 million allocations totaling ~145MB of allocated memory.  For that same sample on .NET Core, there were instead only ~1000 allocations totaling only ~109KB.  Why so much less?</p>
<ul>
<li><code>ExecutionContext</code>. In .NET Core, <code>ExecutionContext</code> is now <em>immutable</em>.  The downside to that is that every change to the context, e.g. by setting a value into an <code>AsyncLocal&lt;T&gt;</code>, requires allocating a new <code>ExecutionContext</code>.  The upside, however, is that flowing context is way, way, way more common than is changing it, and as <code>ExecutionContext</code> is now immutable, we no longer need to clone as part of flowing it. “Capturing” the context is literally just reading it out of a field, rather than reading it and doing a clone of its contents. So it’s not only way, way, way more common to flow than to change, it’s also way, way, way cheaper.</li>
<li><code>LogicalCallContext</code>. This no longer exists in .NET Core.  In .NET Core, the only thing <code>ExecutionContext</code> exists for is the storage for <code>AsyncLocal&lt;T&gt;</code>.  Other things that had their own special place in <code>ExecutionContext</code> are modeled in terms of <code>AsyncLocal&lt;T&gt;</code>.  For example, impersonation in .NET Framework would flow as part of the <code>SecurityContext</code> that’s part of <code>ExecutionContext</code>; in .NET Core, impersonation flows via an <code>AsyncLocal&lt;SafeAccessTokenHandle&gt;</code> that uses a <code>valueChangedHandler</code> to make appropriate changes to the current thread.</li>
<li><code>QueueSegment</code>/<code>IThreadPoolWorkItem[]</code>. In .NET Core, the <code>ThreadPool</code>‘s global queue is now implemented as a <code>ConcurrentQueue&lt;T&gt;</code>, and <code>ConcurrentQueue&lt;T&gt;</code> has been rewritten to be a linked list of <em>circular</em> segments of non-fixed size. Once the size of a segment is large enough that the segment never fills because steady-state dequeues are able to keep up with steady-state enqueues, no additional segments need to be allocated, and the same large-enough segment is just used endlessly.</li>
</ul>
<p>What about the rest of the allocations, like <code>Action</code>, <code>MoveNextRunner</code>, and <code>&lt;SomeMethodAsync&gt;d__1</code>?
Understanding how the remaining allocations were removed requires diving into how this now works on .NET Core.</p>
<p>Let’s rewind our discussion back to when we were discussing what happens at suspension time:</p>
<pre><code>if (!awaiter.IsCompleted) // we need to suspend when IsCompleted is false
{
    &lt;&gt;1__state = 1;
    &lt;&gt;u__2 = awaiter;
    &lt;&gt;t__builder.AwaitUnsafeOnCompleted(ref awaiter, ref this);
    return;
}</code></pre>
<p>The code that’s emitted here is the same regardless of which platform surface area is being targeted, so regardless of .NET Framework vs .NET Core, the generated IL for this suspension is identical.  What changes, however, is the implementation of that <code>AwaitUnsafeOnCompleted</code> method, which on .NET Core is much different:</p>
<ol>
<li>
<p>Things do start out the same: the method calls <code>ExecutionContext.Capture()</code> to get the current execution context.</p>
</li>
<li>
<p>Then things diverge from .NET Framework. The builder in .NET Core has just a single field on it:</p>
<pre><code>public struct AsyncTaskMethodBuilder
{
    private Task&lt;VoidTaskResult&gt;? m_task;
    ...
}</code></pre>
<p>After capturing the <code>ExecutionContext</code>, it checks whether that <code>m_task</code> field contains an instance of an <a href="https://github.com/dotnet/runtime/blob/8de96c8b1b1cc3a781f23dcdf68c0aeb62dadbe7/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/AsyncTaskMethodBuilderT.cs#L273"><code>AsyncStateMachineBox&lt;TStateMachine&gt;</code></a>, where <code>TStateMachine</code> is the type of the compiler-generated state machine struct.  That <code>AsyncStateMachineBox&lt;TStateMachine&gt;</code> type is the “magic.”  It’s defined like this:</p>
<pre><code>private class AsyncStateMachineBox&lt;TStateMachine&gt; :
    Task&lt;TResult&gt;, IAsyncStateMachineBox
    where TStateMachine : IAsyncStateMachine
{
    private Action? _moveNextAction;
    public TStateMachine? StateMachine;
    public ExecutionContext? Context;
    ...
}</code></pre>
<p>Rather than having a separate <code>Task</code>, this <em>is</em> the task (note its base type).  Rather than boxing the state machine, the struct just lives as a strongly-typed field on this task.  And rather than having a separate <code>MoveNextRunner</code> to store both the <code>Action</code> and the <code>ExecutionContext</code>, they’re just fields on this type, and since this <em>is</em> the instance that gets stored into the builder’s <code>m_task</code> field, we have direct access to it and don’t need to re-allocate things on every suspension.  If the <code>ExecutionContext</code> changes, we can just overwrite the field with the new context and don’t need to allocate anything else; any <code>Action</code> we have still points to the right place. So, after capturing the <code>ExecutionContext</code>, if we already have an instance of this <code>AsyncStateMachineBox&lt;TStateMachine&gt;</code>, this isn’t the first time the method is suspending, and we can just store the newly captured <code>ExecutionContext</code> into it.  If we don’t already have an instance of <code>AsyncStateMachineBox&lt;TStateMachine&gt;</code>, then we need to allocate it:</p>
<pre><code>var box = new AsyncStateMachineBox&lt;TStateMachine&gt;();
taskField = box; // important: this must be done before storing stateMachine into box.StateMachine!
box.StateMachine = stateMachine;
box.Context = currentContext;</code></pre>
<p>Note that line which the source comments as “important”.  This takes the place of that complicated <code>SetStateMachine</code> dance in .NET Framework, such that <code>SetStateMachine</code> isn’t actually used at all in .NET Core.  The <code>taskField</code> you see there is a <code>ref</code> to the <code>AsyncTaskMethodBuilder</code>‘s <code>m_task</code> field. We allocate the <code>AsyncStateMachineBox&lt;TStateMachine&gt;</code>, then via <code>taskField</code> store that object into the builder’s <code>m_task</code> (this is the builder that’s in the state machine struct on the stack), and then copy that stack-based state machine (which now already contains the reference to the box) into the heap-based <code>AsyncStateMachineBox&lt;TStateMachine&gt;</code>, such that the <code>AsyncStateMachineBox&lt;TStateMachine&gt;</code> appropriately and recursively ends up referencing itself.  Still mind bending, but a much more efficient mind bending.</p>
</li>
<li>
<p>We can then get an <code>Action</code> to a method on this instance that will invoke its <code>MoveNext</code> method that will do the appropriate <code>ExecutionContext</code> restoration prior to calling into the <code>StateMachine</code>‘s <code>MoveNext</code>.  And that <code>Action</code> can be cached into the <code>_moveNextAction</code> field such that any subsequent use can just reuse the same <code>Action</code>.  That <code>Action</code> is then passed to the awaiter’s <code>UnsafeOnCompleted</code> to hook up the continuation.</p>
</li>
</ol>
<p>That explanation explains why most of the rest of the allocations are gone: <code>&lt;SomeMethodAsync&gt;d__1</code> doesn’t get boxed and instead just lives as a field on the task itself, and the <code>MoveNextRunner</code> is no longer needed as it existed only to store the <code>Action</code> and <code>ExecutionContext</code>.  But, based on this explanation, we should have still seen 1000 <code>Action</code> allocations, one per method call, and we didn’t.  Why?  And what about those <code>QueueUserWorkItemCallback</code> objects… we’re still queueing as part of <code>Task.Yield()</code>, so why aren’t those showing up?</p>
<p>As I noted, one of the nice things about pushing off the implementation details into the core library is it can evolve the implementation over time, and we’ve already seen how it evolved from .NET Framework to .NET Core.  It’s also evolved further from the initial rewrite for .NET Core, with additional optimizations that benefit from having internal access to key components in the system.  In particular, the async infrastructure knows about core types like <code>Task</code> and <code>TaskAwaiter</code>.  And because it knows about them and has internals access, it doesn’t have to play by the publicly-defined rules.  The awaiter pattern followed by the C# language requires an awaiter to have an <code>AwaitOnCompleted</code> or <code>AwaitUnsafeOnCompleted</code> method, both of which take the continuation as an <code>Action</code>, and that means the infrastructure needs to be able to create an <code>Action</code> to represent the continuation, in order to work with arbitrary awaiters the infrastructure knows nothing about.  But if the infrastructure encounters an awaiter it <em>does</em> know about, it’s under no obligation to take the same code path.  For all of the core awaiters defined in System.Private.CoreLib, then, the infrastructure has a leaner path it can follow, one that doesn’t require an <code>Action</code> at all.  These awaiters all know about <code>IAsyncStateMachineBox</code>es, and are able to treat the box object itself as the continuation.  So, for example, the <code>YieldAwaitable</code> returned by <code>Task.Yield</code> is able to queue the <code>IAsyncStateMachineBox</code> itself directly into the <code>ThreadPool</code> as a work item, and the <code>TaskAwaiter</code> used when <code>await</code>‘ing a <code>Task</code> is able to store the <code>IAsyncStateMachineBox</code> itself directly into the <code>Task</code>‘s continuation list.  No <code>Action</code> needed, no <code>QueueUserWorkItemCallback</code> needed.</p>
<p>Thus, in the very common case where an async method only awaits things from System.Private.CoreLib (<code>Task</code>, <code>Task&lt;TResult&gt;</code>, <code>ValueTask</code>, <code>ValueTask&lt;TResult&gt;</code>, <code>YieldAwaitable</code>, and the <code>ConfigureAwait</code> variants of those), worst case is there’s only ever a single allocation of overhead associated with the entire lifecycle of the async method: if the method ever suspends, it allocates that single <code>Task</code>-derived type which stores all other required state, and if the method never suspends, there’s no additional allocation incurred.</p>
<p>We can get rid of that last allocation as well, if desired, at least in an amortized fashion.  As has been shown, there’s a default builder associated with <code>Task</code> (<code>AsyncTaskMethodBuilder</code>), and similarly there’s a default builder associated with <code>Task&lt;TResult&gt;</code> (<code>AsyncTaskMethodBuilder&lt;TResult&gt;</code>) and with <code>ValueTask</code> and <code>ValueTask&lt;TResult&gt;</code> (<code>AsyncValueTaskMethodBuilder</code> and <code>AsyncValueTaskMethodBuilder&lt;TResult&gt;</code>, respectively).  For <code>ValueTask</code>/<code>ValueTask&lt;TResult&gt;</code>, the builders are actually fairly simple, as they themselves only handle the synchronously-and-successfully-completing case, in which case the async method completes without ever suspending and the builders can just return a <code>ValueTask.Completed</code> or a <code>ValueTask&lt;TResult&gt;</code> wrapping the result value. For everything else, they just delegate to <code>AsyncTaskMethodBuilder</code>/<code>AsyncTaskMethodBuilder&lt;TResult&gt;</code>, since the <code>ValueTask</code>/<code>ValueTask&lt;TResult&gt;</code> that’ll be returned just wraps a <code>Task</code> and it can share all of the same logic.  But <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6">.NET 6 and C# 10</a> introduced the ability for a method to override the builder that’s used on a method-by-method basis, and introduced a couple of specialized builders for <code>ValueTask</code>/<code>ValueTask&lt;TResult&gt;</code> that are able to pool <code>IValueTaskSource</code>/<code>IValueTaskSource&lt;TResult&gt;</code> objects representing the eventual completion rather than using <code>Task</code>s.</p>
<p>We can see the impact of this in our sample. Let’s slightly tweak our <code>SomeMethodAsync</code> we were profiling to return <code>ValueTask</code> instead of <code>Task</code>:</p>
<pre><code>static async ValueTask SomeMethodAsync()
{
    for (int i = 0; i &lt; 1000; i++)
    {
        await Task.Yield();
    }
}</code></pre>
<p>That will result in this generated entry point:</p>
<pre><code>[AsyncStateMachine(typeof(&lt;SomeMethodAsync&gt;d__1))]
private static ValueTask SomeMethodAsync()
{
    &lt;SomeMethodAsync&gt;d__1 stateMachine = default;
    stateMachine.&lt;&gt;t__builder = AsyncValueTaskMethodBuilder.Create();
    stateMachine.&lt;&gt;1__state = -1;
    stateMachine.&lt;&gt;t__builder.Start(ref stateMachine);
    return stateMachine.&lt;&gt;t__builder.Task;
}</code></pre>
<p>Now, we add <code>[AsyncMethodBuilder(typeof(PoolingAsyncValueTaskMethodBuilder))]</code> to the declaration of <code>SomeMethodAsync</code>:</p>
<pre><code>[AsyncMethodBuilder(typeof(PoolingAsyncValueTaskMethodBuilder))]
static async ValueTask SomeMethodAsync()
{
    for (int i = 0; i &lt; 1000; i++)
    {
        await Task.Yield();
    }
}</code></pre>
<p>and the compiler instead outputs this:</p>
<pre><code>[AsyncStateMachine(typeof(&lt;SomeMethodAsync&gt;d__1))]
[AsyncMethodBuilder(typeof(PoolingAsyncValueTaskMethodBuilder))]
private static ValueTask SomeMethodAsync()
{
    &lt;SomeMethodAsync&gt;d__1 stateMachine = default;
    stateMachine.&lt;&gt;t__builder = PoolingAsyncValueTaskMethodBuilder.Create();
    stateMachine.&lt;&gt;1__state = -1;
    stateMachine.&lt;&gt;t__builder.Start(ref stateMachine);
    return stateMachine.&lt;&gt;t__builder.Task;
}</code></pre>
<p>The actual C# code gen for the entirety of the implementation, including the whole state machine (not shown), is almost identical; the <em>only</em> difference is the type of the builder that’s created and stored and thus used everywhere we previously saw references to the builder.  And if you look at <a href="https://github.com/dotnet/runtime/blob/8de96c8b1b1cc3a781f23dcdf68c0aeb62dadbe7/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/PoolingAsyncValueTaskMethodBuilderT.cs#L152-L218">the code for <code>PoolingAsyncValueTaskMethodBuilder</code></a>, you’ll see its structure is almost identical to that of <code>AsyncTaskMethodBuilder</code>, including using some of the exact same shared routines for doing things like special-casing known awaiter types.  The key difference is that instead of doing <code>new AsyncStateMachineBox&lt;TStateMachine&gt;()</code> when the method first suspends, it instead does <code>StateMachineBox&lt;TStateMachine&gt;.RentFromCache()</code>, and upon the async method (<code>SomeMethodAsync</code>) completing and an <code>await</code> on the returned <code>ValueTask</code> completing, the rented box is returned to the cache. That means (amortized) zero allocation:</p>
<p><img decoding="async" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2023/03/AllocationNetCoreWithPooling.png" alt="Allocation associated with asynchronous operations on .NET Core with pooling"/></p>
<p>That cache in and of itself is a bit interesting.  Object pooling can be a good idea and it can be a bad idea.  The more expensive an object is to create, the more valuable it is to pool them; so, for example, it’s a lot more valuable to pool really large arrays than it is to pool really tiny arrays, because larger arrays not only require more CPU cycles and memory accesses to zero out, they put more pressure on the garbage collector to collect more often.  For very small objects, though, pooling them can be a net negative.  Pools are just memory allocators, as is the GC, so when you pool, you’re trading off the costs associated with one allocator for the costs associated with another, and the GC is very efficient at handling lots of tiny, short-lived objects.  If you do a lot of work in an object’s constructor, avoiding that work can dwarf the costs of the allocator itself, making pooling valuable.  But if you do little to no work in an object’s constructor, and you pool it, you’re betting that your allocator (your pool) is more efficient for the access patterns employed than is the GC, and that is frequently a bad bet.  There are other costs involved as well, and in some cases you can end up effectively fighting against the GC’s heuristics; for example, the GC is optimized based on the premise that references from higher generation (e.g. gen2) objects to lower generation (e.g. gen0) objects are relatively rare, but pooling objects can invalidate those premises.</p>
<p>Now, the objects created by async methods aren’t <em>tiny</em>, and they can be on super hot paths, so pooling can be reasonable. But to make it as valuable as possible we also want to avoid as much overhead as possible. The pool is thus very simple, opting to make renting and returning really fast with little to no contention, even if that means it might end up allocating more than it would if it more aggressively cached more.  For each state machine type, the implementation <a href="https://github.com/dotnet/runtime/blob/8de96c8b1b1cc3a781f23dcdf68c0aeb62dadbe7/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/PoolingAsyncValueTaskMethodBuilderT.cs#L287-L292">pools</a> up to a single state machine box per <em>thread</em> and a single state machine box per <em>core</em>; this allows it to rent and return with minimal overhead and minimal contention (no other thread can be accessing the thread-specific cache at the same time, and it’s rare for another thread to be accessing the core-specific cache at the same time).  And while this might seem like a relatively small pool, it’s also quite effective at significantly reducing steady state allocation, given that the pool is only responsible for storing objects not currently in use; you could have a million async methods all in flight at any given time, and even though the pool is only able to store up to one object per thread and per core, it can still avoid dropping lots of objects, since it only needs to store an object long enough to transfer it from one operation to another, not while it’s in use by that operation.</p>
<h3 id="synchronizationcontext-and-configureawait">SynchronizationContext and ConfigureAwait</h3>
<p>We talked about <code>SynchronizationContext</code> previously in the context of the EAP pattern and mentioned that it would show up again. <code>SynchronizationContext</code> makes it possible to call reusable helpers and automatically be scheduled back whenever and to wherever the calling environment deems fit.  As a result, it’s natural to expect that to “just work” with <code>async</code>/<code>await</code>, and it does.  Going back to our button click handler from earlier:</p>
<pre><code>ThreadPool.QueueUserWorkItem(_ =&gt;
{
    string message = ComputeMessage();
    button1.BeginInvoke(() =&gt;
    {
        button1.Text = message;
    });
});</code></pre>
<p>with <code>async</code>/<code>await</code> we’d like to instead be able to write this as follows:</p>
<pre><code>button1.Text = await Task.Run(() =&gt; ComputeMessage());</code></pre>
<p>That invocation of <code>ComputeMessage</code> is offloaded to the thread pool, and upon the method’s completion, execution transitions back to the UI thread associated with the button, and the setting of its Text property happens on that thread.</p>
<p>That integration with <code>SynchronizationContext</code> is left up to the awaiter implementation (the code generated for the state machine knows nothing about <code>SynchronizationContext</code>), as it’s the awaiter that is responsible for actually invoking or queueing the supplied continuation when the represented asynchronous operation completes.  While a custom awaiter need not respect <code>SynchronizationContext.Current</code>, the awaiters for <code>Task</code>, <code>Task&lt;TResult&gt;</code>, <code>ValueTask</code>, and <code>ValueTask&lt;TResult&gt;</code> all do.  That means that, by default, when you <code>await</code> a <code>Task</code>, a <code>Task&lt;TResult&gt;</code>, a <code>ValueTask</code>, a <code>ValueTask&lt;TResult&gt;</code>, or even the result of a <code>Task.Yield()</code> call, the awaiter by default will look up the current <code>SynchronizationContext</code> and then if it successfully got a non-default one, will eventually queue the continuation to that context.</p>
<p>We can see this if we look at the code involved in <code>TaskAwaiter</code>.  Here’s a snippet of the <a href="https://github.com/dotnet/runtime/blob/967a59712996c2cdb8ce2f65fb3167afbd8b01f3/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Task.cs#L2558-L2583">relevant code</a> from Corelib:</p>
<pre><code>internal void UnsafeSetContinuationForAwait(IAsyncStateMachineBox stateMachineBox, bool continueOnCapturedContext)
{
    if (continueOnCapturedContext)
    {
        SynchronizationContext? syncCtx = SynchronizationContext.Current;
        if (syncCtx != null &amp;&amp; syncCtx.GetType() != typeof(SynchronizationContext))
        {
            var tc = new SynchronizationContextAwaitTaskContinuation(syncCtx, stateMachineBox.MoveNextAction, flowExecutionContext: false);
            if (!AddTaskContinuation(tc, addBeforeOthers: false))
            {
                tc.Run(this, canInlineContinuationTask: false);
            }
            return;
        }
        else
        {
            TaskScheduler? scheduler = TaskScheduler.InternalCurrent;
            if (scheduler != null &amp;&amp; scheduler != TaskScheduler.Default)
            {
                var tc = new TaskSchedulerAwaitTaskContinuation(scheduler, stateMachineBox.MoveNextAction, flowExecutionContext: false);
                if (!AddTaskContinuation(tc, addBeforeOthers: false))
                {
                    tc.Run(this, canInlineContinuationTask: false);
                }
                return;
            }
        }
    }

    ...
}</code></pre>
<p>This is part of a method that’s determining what object to store into the <code>Task</code> as a continuation.  It’s being passed the <code>stateMachineBox</code>, which, as was alluded to earlier, can be stored directly into the <code>Task</code>‘s continuation list. However, this special logic might wrap that <code>IAsyncStateMachineBox</code> to also incorporate a scheduler if one is present.  It checks to see whether there’s currently a non-default <code>SynchronizationContext</code>, and if there is, it creates a <code>SynchronizationContextAwaitTaskContinuation</code> as the actual object that’ll be stored as the continuation; that object in turn wraps the original and the captured <code>SynchronizationContext</code>, and knows how to invoke the former’s <code>MoveNext</code> in a work item queued to the latter.  This is how you’re able to <code>await</code> as part of some event handler in a UI application and have the code after the <code>await</code>s completion continue on the right thread. The next interesting thing to note here is that it’s not just paying attention to a <code>SynchronizationContext</code>: if it couldn’t find a custom <code>SynchronizationContext</code> to use, it also looks to see whether the <code>TaskScheduler</code> type that’s used by <code>Task</code>s has a custom one in play that needs to be considered.  As with <code>SynchronizationContext</code>, if there’s a non-default one of those, it’s then wrapped with the original box in a <code>TaskSchedulerAwaitTaskContinuation</code> that’s used as the continuation object.</p>
<p>But arguably the most interesting thing to notice here is the very first line of the method body: <code>if (continueOnCapturedContext)</code>.  We only do these checks for <code>SynchronizationContext</code>/<code>TaskScheduler</code> if <code>continueOnCapturedContext</code> is <code>true</code>; if it’s <code>false</code>, the implementation behaves as if both were default and ignores them.  What, pray tell, sets <code>continueOnCapturedContext</code> to false?  You’ve probably guessed it: using the ever popular <code>ConfigureAwait(false)</code>.</p>
<p>I talk about <code>ConfigureAwait</code> at length in <a href="https://devblogs.microsoft.com/dotnet/configureawait-faq/">ConfigureAwait FAQ</a>, so I’d encourage you to read that for more information.  Suffice it to say, the <em>only</em> thing <code>ConfigureAwait(false)</code> does as part of an <code>await</code> is feed its argument <code>Boolean</code> into this function (and others like it) as that <code>continueOnCapturedContext</code> value, so as to skip the checks on <code>SynchronizationContext</code>/<code>TaskScheduler</code> and behave as if neither of them existed.  In the case of <code>Task</code>s, this then permits the <code>Task</code> to invoke its continuations wherever it deems fit rather than being forced to queue them to execute on some specific scheduler.</p>
<p>I previously mentioned one other aspect of <code>SynchronizationContext</code>, and I said we’d see it again: <code>OperationStarted</code>/<code>OperationCompleted</code>.  Now’s the time.  These rear their heads as part of the feature everyone loves to hate: <code>async void</code>. <code>ConfigureAwait</code>-aside, <code>async void</code> is arguably one of the most divisive features added as part of <code>async/await</code>.  It was added for one reason and one reason only: event handlers. In a UI application, you want to be able to write code like the following:</p>
<pre><code>button1.Click += async (sender, eventArgs) =&gt;
{
  button1.Text = await Task.Run(() =&gt; ComputeMessage());  
};</code></pre>
<p>but if all <code>async</code> methods had to have a return type like <code>Task</code>, you wouldn’t be able to do this. The <code>Click</code> event has a signature <code>public event EventHandler? Click;</code>, with <code>EventHandler</code> defined as <code>public delegate void EventHandler(object? sender, EventArgs e);</code>, and thus to provide a method that matches that signature, the method needs to be <code>void</code>-returning.</p>
<p>There are a variety of reasons <code>async void</code> is considered bad, why <a href="https://learn.microsoft.com/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming">articles</a> recommend avoiding it wherever possible, and why <a href="https://github.com/microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD101.md">analyzers</a> have sprung up to flag use of them.  One of the biggest issues is with delegate inference.  Consider this program:</p>
<pre><code>using System.Diagnostics;

Time(async () =&gt;
{
    Console.WriteLine(&#34;Enter&#34;);
    await Task.Delay(TimeSpan.FromSeconds(10));
    Console.WriteLine(&#34;Exit&#34;);
});

static void Time(Action action)
{
    Console.WriteLine(&#34;Timing...&#34;);
    Stopwatch sw = Stopwatch.StartNew();
    action();
    Console.WriteLine($&#34;...done timing: {sw.Elapsed}&#34;);
}</code></pre>
<p>One could easily expect this to output an elapsed time of at least 10 seconds, but if you run this you’ll instead find output like this:</p>
<pre><code>Timing...
Enter
...done timing: 00:00:00.0037550</code></pre>
<p>Huh? Of course, based on everything we’ve discussed in this post, it should be understood what the problem is.  The <code>async</code> lambda is actually an <code>async void</code> method.  Async methods return to their caller the moment they hit the first suspension point.  If this were an <code>async Task</code> method, that’s when the <code>Task</code> would be returned.  But in the case of an <code>async void</code>, nothing is returned.  All the <code>Time</code> method knows is that it invoked <code>action();</code> and the delegate call returned; it has no idea that the async method is actually still “running” and will asynchronously complete later.</p>
<p>That’s where <code>OperationStarted</code>/<code>OperationCompleted</code> come in. Such <code>async void</code> methods are similar in nature to the EAP methods discussed earlier: the initiation of such methods is <code>void</code>, and so you need some other mechanism to be able to track all such operations in flight. The EAP implementations thus call the current <code>SynchronizationContext</code>‘s <code>OperationStarted</code> when the operation is initiated and <code>OperationCompleted</code> when it completes, and <code>async void</code> does the same.  The builder associated with <code>async void</code> is <code>AsyncVoidMethodBuilder</code>.  Remember in the entry point of an async method how the compiler-generated code invokes the builder’s static <code>Create</code> method to get an appropriate builder instance? <code>AsyncVoidMethodBuilder</code> takes advantage of that in order to hook creation and invoke <code>OperationStarted</code>:</p>
<pre><code>public static AsyncVoidMethodBuilder Create()
{
    SynchronizationContext? sc = SynchronizationContext.Current;
    sc?.OperationStarted();
    return new AsyncVoidMethodBuilder() { _synchronizationContext = sc };
}</code></pre>
<p>Similarly, when the builder is marked for completion via either <code>SetResult</code> or <code>SetException</code>, it invokes the corresponding <code>OperationCompleted</code> method.  This is how a unit testing framework like xunit is able to have <code>async void</code> test methods and still employ a maximum degree of concurrency on concurrent test executions, for example in xunit’s <a href="https://github.com/xunit/xunit/blob/4d1f2e5d4ac9260487d0a8f35a2d045388021b33/src/xunit.v3.core/Sdk/AsyncTestSyncContext.cs#L1">AsyncTestSyncContext</a>.</p>
<p>With that knowledge, we can now rewrite our timing sample:</p>
<pre><code>using System.Diagnostics;

Time(async () =&gt;
{
    Console.WriteLine(&#34;Enter&#34;);
    await Task.Delay(TimeSpan.FromSeconds(10));
    Console.WriteLine(&#34;Exit&#34;);
});

static void Time(Action action)
{
    var oldCtx = SynchronizationContext.Current;
    try
    {
        var newCtx = new CountdownContext();
        SynchronizationContext.SetSynchronizationContext(newCtx);

        Console.WriteLine(&#34;Timing...&#34;);
        Stopwatch sw = Stopwatch.StartNew();
        
        action();
        newCtx.SignalAndWait();

        Console.WriteLine($&#34;...done timing: {sw.Elapsed}&#34;);
    }
    finally
    {
        SynchronizationContext.SetSynchronizationContext(oldCtx);
    }
}

sealed class CountdownContext : SynchronizationContext
{
    private readonly ManualResetEventSlim _mres = new ManualResetEventSlim(false);
    private int _remaining = 1;

    public override void OperationStarted() =&gt; Interlocked.Increment(ref _remaining);

    public override void OperationCompleted()
    {
        if (Interlocked.Decrement(ref _remaining) == 0)
        {
            _mres.Set();
        }
    }

    public void SignalAndWait()
    {
        OperationCompleted();
        _mres.Wait();
    }
}</code></pre>
<p>Here, I’ve created a <code>SynchronizationContext</code> that tracks a count for pending operations, and supports blocking waiting for them all to complete. When I run that, I get output like this:</p>
<pre><code>Timing...
Enter
Exit
...done timing: 00:00:10.0149074</code></pre>
<p>Tada!</p>
<h3 id="state-machine-fields">State Machine Fields</h3>
<p>At this point, we’ve seen the generated entry point method and how everything in the <code>MoveNext</code> implementation works.  We also glimpsed some of the fields defined on the state machine.  Let’s take a closer look at those.</p>
<p>For the <code>CopyStreamToStream</code> method shown earlier:</p>
<pre><code>public async Task CopyStreamToStreamAsync(Stream source, Stream destination)
{
    var buffer = new byte[0x1000];
    int numRead;
    while ((numRead = await source.ReadAsync(buffer, 0, buffer.Length)) != 0)
    {
        await destination.WriteAsync(buffer, 0, numRead);
    }
}</code></pre>
<p>here are the fields we ended up with:</p>
<pre><code>private struct &lt;CopyStreamToStreamAsync&gt;d__0 : IAsyncStateMachine
{
    public int &lt;&gt;1__state;
    public AsyncTaskMethodBuilder &lt;&gt;t__builder;
    public Stream source;
    public Stream destination;
    private byte[] &lt;buffer&gt;5__2;
    private TaskAwaiter &lt;&gt;u__1;
    private TaskAwaiter&lt;int&gt; &lt;&gt;u__2;

    ...
}</code></pre>
<p>What are each of these?</p>
<ul>
<li><code>&lt;&gt;1__state</code>. The is the “state” in “state machine”. It defines the current state the state machine is in, and most importantly what should be done the next time <code>MoveNext</code> is called.  If the state is -2, the operation has completed.  If the state is -1, either we’re about to call <code>MoveNext</code> for the first time or <code>MoveNext</code> code is currently running on some thread.  If you’re debugging an async method’s processing and you see the state as -1, that means there’s some thread somewhere that’s actually executing the code contained in the method.  If the state is 0 or greater, the method is suspended, and the value of the state tells you at which <code>await</code> it’s suspended.  While this isn’t a hard and fast rule (certain code patterns can confuse the numbering), in general the state assigned corresponds to the 0-based number of the <code>await</code> in top-to-bottom ordering of the source code. So, for example, if the body of an <code>async</code> method were entirely:
<pre><code>await A();
await B();
await C();
await D();</code></pre>
<p>and you found the state value was 2, that almost certainly means the async method is currently suspended waiting for the task returned from <code>C()</code> to complete.</p>
</li>
<li><code>&lt;&gt;t__builder</code>. This is the builder for the state machine, e.g. <code>AsyncTaskMethodBuilder</code> for a <code>Task</code>, <code>AsyncValueTaskMethodBuilder&lt;TResult&gt;</code> for a <code>ValueTask&lt;TResult&gt;</code>, <code>AsyncVoidMethodBuilder</code> for an <code>async void</code> method, or whatever builder was declared for use via <code>[AsyncMethodBuilder(...)]</code> on either the async return type or overridden via such an attribute on the async method itself.  As previously discussed, the builder is responsible for the lifecycle of the async method, including creating the return task, eventually completing that task, and serving as an intermediary for suspension, with the code in the async method asking the builder to suspend until a specific awaiter completes.</li>
<li><code>source</code>/<code>destination</code>.  These are the method parameters.  You can tell because they’re not name mangled; the compiler has named them exactly as the parameter names were specified.  As noted earlier, all parameters that are used by the method body need to be stored onto the state machine so that the <code>MoveNext</code> method has access to them. Note I said “used by”.  If the compiler sees that a parameter is unused by the body of the async method, it can optimize away the need to store the field. For example, given the method:
<pre><code>public async Task M(int someArgument)
{
    await Task.Yield();
}</code></pre>
<p>the compiler will emit these fields onto the state machine:</p>
<pre><code>private struct &lt;M&gt;d__0 : IAsyncStateMachine
{
    public int &lt;&gt;1__state;
    public AsyncTaskMethodBuilder &lt;&gt;t__builder;
    private YieldAwaitable.YieldAwaiter &lt;&gt;u__1;
    ...
}</code></pre>
<p>Note the distinct lack of something named <code>someArgument</code>.  But, if we change the async method to actually use the argument in any way:</p>
<pre><code>public async Task M(int someArgument)
{
    Console.WriteLine(someArgument);
    await Task.Yield();
}</code></pre>
<p>it shows up:</p>
<pre><code>private struct &lt;M&gt;d__0 : IAsyncStateMachine
{
    public int &lt;&gt;1__state;
    public AsyncTaskMethodBuilder &lt;&gt;t__builder;
    public int someArgument;
    private YieldAwaitable.YieldAwaiter &lt;&gt;u__1;
    ...
}</code></pre>
</li>
<li><code>&lt;buffer&gt;5__2;</code>.  This is the <code>buffer</code> “local” that got lifted to be a field so that it could survive across <code>await</code> points.  The compiler tries reasonably hard to keep state from being lifted unnecessarily.  Note that there’s another local in the source, <code>numRead</code>, that <em>doesn’t</em> have a corresponding field in the state machine.  Why? Because it’s not necessary.  That local is set as the result of the <code>ReadAsync</code> call and is then used as the input to the <code>WriteAsync</code> call.  There’s no <code>await</code> in between those and across which the <code>numRead</code> value would need to be stored.  Just as how in a synchronous method the JIT compiler could choose to store such a value entirely in a register and never actually spill it to the stack, the C# compiler can avoid lifting this local to be a field as it needn’t preserve it’s value across any awaits.  In general, the C# compiler can elide lifting locals if it can prove that their value needn’t be preserved across <code>await</code>s.</li>
<li><code>&lt;&gt;u__1</code> and <code>&lt;&gt;u__2</code>. There are two <code>await</code>s in the async method: one for a <code>Task&lt;int&gt;</code> returned by <code>ReadAsync</code>, and one for a <code>Task</code> returned by <code>WriteAsync</code>.  <code>Task.GetAwaiter()</code> returns a <code>TaskAwaiter</code>, and <code>Task&lt;TResult&gt;.GetAwaiter()</code> returns a <code>TaskAwaiter&lt;TResult&gt;</code>, both of which are distinct struct types. Since the compiler needs to get these awaiters prior to the <code>await</code> (<code>IsCompleted</code>, <code>UnsafeOnCompleted</code>) and then needs to access them after the <code>await</code> (<code>GetResult</code>), the awaiters need to be stored .  And since they’re distinct struct types, the compiler needs to maintain two separate fields to do so (the alternative would be to box them and have a single <code>object</code> field for awaiters, but that would result in extra allocation costs).  The compiler will try to reuse fields whenever possible, though.  If I have:
<pre><code>public async Task M()
{
    await Task.FromResult(1);
    await Task.FromResult(true);
    await Task.FromResult(2);
    await Task.FromResult(false);
    await Task.FromResult(3);
}</code></pre>
<p>there are five <code>await</code>s, but only two different types of awaiters involved: three are <code>TaskAwaiter&lt;int&gt;</code> and two are <code>TaskAwaiter&lt;bool&gt;</code>.  As such, there only end up being two awaiter fields on the state machine:</p>
<pre><code>private struct &lt;M&gt;d__0 : IAsyncStateMachine
{
    public int &lt;&gt;1__state;
    public AsyncTaskMethodBuilder &lt;&gt;t__builder;
    private TaskAwaiter&lt;int&gt; &lt;&gt;u__1;
    private TaskAwaiter&lt;bool&gt; &lt;&gt;u__2;
    ...
}</code></pre>
<p>Then if I change my example to instead be:</p>
<pre><code>public async Task M()
{
    await Task.FromResult(1);
    await Task.FromResult(true);
    await Task.FromResult(2).ConfigureAwait(false);
    await Task.FromResult(false).ConfigureAwait(false);
    await Task.FromResult(3);
}</code></pre>
<p>there are still only <code>Task&lt;int&gt;</code>s and <code>Task&lt;bool&gt;</code>s involved, but I’m actually using four distinct struct awaiter types, because the awaiter returned from the <code>GetAwaiter()</code> call on the thing returned by <code>ConfigureAwait</code> is a different type than that returned by <code>Task.GetAwaiter()</code>… this is again evident from the awaiter fields created by the compiler:</p>
<pre><code>private struct &lt;M&gt;d__0 : IAsyncStateMachine
{
    public int &lt;&gt;1__state;
    public AsyncTaskMethodBuilder &lt;&gt;t__builder;
    private TaskAwaiter&lt;int&gt; &lt;&gt;u__1;
    private TaskAwaiter&lt;bool&gt; &lt;&gt;u__2;
    private ConfiguredTaskAwaitable&lt;int&gt;.ConfiguredTaskAwaiter &lt;&gt;u__3;
    private ConfiguredTaskAwaitable&lt;bool&gt;.ConfiguredTaskAwaiter &lt;&gt;u__4;
    ...
}</code></pre>
<p>If you find yourself wanting to optimize the size associated with an async state machine, one thing you can look at is whether you can consolidate the kinds of things being awaited and thereby consolidate these awaiter fields.</p>
</li>
</ul>
<p>There are other kinds of fields you might see defined on a state machine. Notably, you might see some fields containing the word “wrap”. Consider this silly example:</p>
<pre><code>public async Task&lt;int&gt; M() =&gt; await Task.FromResult(42) + DateTime.Now.Second;</code></pre>
<p>This produces a state machine with the following fields:</p>
<pre><code>private struct &lt;M&gt;d__0 : IAsyncStateMachine
{
    public int &lt;&gt;1__state;
    public AsyncTaskMethodBuilder&lt;int&gt; &lt;&gt;t__builder;
    private TaskAwaiter&lt;int&gt; &lt;&gt;u__1;
    ...
}</code></pre>
<p>Nothing special so far.  Now flip the order of the expressions being added:</p>
<pre><code>public async Task&lt;int&gt; M() =&gt; DateTime.Now.Second + await Task.FromResult(42);</code></pre>
<p>With that, you get these fields:</p>
<pre><code>private struct &lt;M&gt;d__0 : IAsyncStateMachine
{
    public int &lt;&gt;1__state;
    public AsyncTaskMethodBuilder&lt;int&gt; &lt;&gt;t__builder;
    private int &lt;&gt;7__wrap1;
    private TaskAwaiter&lt;int&gt; &lt;&gt;u__1;
    ...
}</code></pre>
<p>We now have one more: <code>&lt;&gt;7__wrap1</code>. Why? Because we computed the value of <code>DateTime.Now.Second</code>, and only after computing it, we had to <code>await</code> something, and the value of the first expression needs to be preserved in order to add it to the result of the second.  The compiler thus needs to ensure that the temporary result from that first expression is available to add to the result of the <code>await</code>, which means it needs to spill the result of the expression into a temporary, which it does with this <code>&lt;&gt;7__wrap1</code> field.  If you ever find yourself hyper-optimizing async method implementations to drive down the amount of memory allocated, you can look for such fields and see if small tweaks to the source could avoid the need for spilling and thus avoid the need for such temporaries.</p>
<h2 id="wrap-up">Wrap Up</h2>
<p>I hope this post has helped to illuminate exactly what’s going on under the covers when you use <code>async</code>/<code>await</code>, but thankfully you generally don’t need to know or care. There are many moving pieces here, all coming together to create an efficient solution to writing scalable asynchronous code without having to deal with callback soup.  And yet at the end of the day, those pieces are actually relatively simple: a universal representation for any asynchronous operation, a language and compiler capable of rewriting normal control flow into a state machine implementation of coroutines, and patterns that bind them all together.  Everything else is optimization gravy.</p>
<p>Happy coding!</p>

        

		
        
	</div><!-- .entry-content -->

</div></div>
  </body>
</html>
