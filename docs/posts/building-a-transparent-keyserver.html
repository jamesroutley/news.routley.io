<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://words.filippo.io/keyserver-tlog/">Original</a>
    <h1>Building a Transparent Keyserver</h1>
    
    <div id="readability-page-1" class="page"><article>
        <time datetime="2025-12-19">
            19 Dec 2025</time>
        
        <section>
            <!-- buttondown-editor-mode: plaintext -->
<p>Today, we are going to build a keyserver to lookup <a href="https://age-encryption.org/">age</a> public keys. That part is boring. What’s interesting is that we’ll apply the same transparency log technology as the Go Checksum Database to keep the keyserver operator honest and unable to surreptitiously inject malicious keys, while still protecting user privacy and delivering a smooth UX. You can see the final result at <a href="https://keyserver.geomys.org">keyserver.geomys.org</a>. We’ll build it step-by-step, using modern tooling from the tlog ecosystem, integrating transparency in less than 500 lines.</p>
<p>I am extremely excited to write this post: it demonstrates how to use a technology that I strongly believe is key in protecting users and holding centralized services accountable, and it’s the result of years of effort by me, the <a href="https://transparency.dev/">TrustFabric</a> team at Google, the <a href="https://www.sigsum.org/">Sigsum</a> team at <a href="https://www.glasklarteknik.se/">Glasklar</a>, and many others.</p>
<blockquote>
<p>This article is being cross-posted on the <a href="https://blog.transparency.dev/">Transparency.dev Community Blog</a>.</p>
</blockquote>
<p>Let’s start by defining the goal: we want a secure and convenient way to fetch <a href="https://age-encryption.org/">age</a> public keys for other people and services.<sup id="fnref:emailage"><a href="#fn:emailage">1</a></sup></p>
<p>The easiest and most usable way to achieve that is to build a centralized keyserver: a web service where you log in with your email address to set your public key, and other people can look up public keys by email address.</p>
<p><img alt="the keyserver web UI" src="https://assets.buttondown.email/images/d4f72ca6-0ff7-4b1b-8890-1b8f0cbfad90.png"/></p>
<p>Trusting the third party that operates the keyserver lets you solve identity, authentication, and spam by just delegating the responsibilities of checking email ownership and implementing rate limiting. The keyserver can send a link to the email address, and whoever receives it is authorized to manage the public key(s) bound to that address.</p>
<p>I had Claude Code <a href="https://github.com/FiloSottile/torchwood/commit/f191bdbadeb9c9c15ba0a9995dffdb20651710da">build the base service</a>, because it’s simple and not the interesting part of what we are doing today. There’s nothing special in the implementation: just a Go server, an SQLite database,<sup id="fnref:json"><a href="#fn:json">2</a></sup> a lookup API, a set API protected by a CAPTCHA that sends an email authentication link,<sup id="fnref:broadcast"><a href="#fn:broadcast">3</a></sup> and a Go CLI that calls the lookup API.</p>
<h2 id="transparency-logs-and-accountability-for-centralized-services">Transparency logs and accountability for centralized services</h2>
<p>A lot of problems are shaped like this and are much more solvable with a trusted third party: PKIs, package registries, voting systems… Sometimes the trusted third party is encapsulated behind a level of indirection, and we talk about Certificate Authorities, but it’s the same concept.</p>
<p>Centralization is so appealing that even the OpenPGP ecosystem embraced it: after the <a href="https://words.filippo.io/openpgp-is-broken/">SKS pool was killed by spam</a>, a <a href="https://keys.openpgp.org/">new OpenPGP keyserver</a> was built which is just a centralized, email-authenticated database of public keys. Its <a href="https://keys.openpgp.org/about/faq/#third-party-signatures">FAQ</a> claims they don’t wish to be a CA, but also explains they don’t support the (dubiously effective) Web-of-Trust at all, so effectively they can only act as a trusted third party.</p>
<p>The obvious downside of a trusted third party is, well, trust. You need to trust the operator, but also whoever will control the operator in the future, and also the operator’s security practices. That’s asking a lot, especially these days, and a malicious or compromised keyserver could provide fake public keys to targeted victims with little-to-no chance of detection.</p>
<p><strong>Transparency logs are a technology for applying cryptographic accountability to centralized systems with no UX sacrifices.</strong></p>
<p>A transparency log or tlog is an append-only, globally consistent list of entries, with efficient cryptographic proofs of inclusion and consistency. The log operator appends entries to the log, which can be tuples like <em>(package, version, hash)</em> or <em>(email, public key)</em>. The clients verify an inclusion proof before accepting an entry, guaranteeing that the log operator will have to stand by that entry in perpetuity and to the whole world, with no way to hide it or disown it. As long as <em>someone</em> who can check the authenticity of the entry will <em>eventually</em> check (or “monitor”) the log, the client can trust that malfeasance will be caught.</p>
<p>Effectively, a tlog lets the log operator stake their reputation to borrow time for collective, potentially manual verification of the log’s entries. This is a middle-ground between impractical local verification mechanisms like the <a href="https://en.wikipedia.org/wiki/Web_of_trust">Web of Trust</a>, and fully trusted mechanisms like centralized X.509 PKIs.</p>
<blockquote>
<p>If you’d like a longer introduction, <a href="https://youtu.be/SOfOe_z37jQ">my Real World Crypto 2024 talk</a> presents both the technical functioning and abstraction of modern transparency logs.</p>
</blockquote>
<p>There is a whole ecosystem of interoperable tlog tools and publicly available infrastructure built around <a href="https://c2sp.org/">C2SP</a> specifications. That’s what we are going to use today to add a tlog to our keyserver.</p>
<blockquote>
<p>If you want to catch up with the tlog ecosystem, <a href="https://www.youtube.com/watch?v=B-0ZW1ovPmk">my 2025 Transparency.dev Summit Keynote</a> maps out the tools, applications, and specifications.</p>
</blockquote>
<h3 id="tlogs-vs-certificate-transparency-vs-key-transparency">tlogs vs Certificate Transparency vs Key Transparency</h3>
<p>If you are familiar with Certificate Transparency, tlogs are derived from CT, but with a few major differences. Most importantly, there is no separate entry producer (in CT, the CAs) and log operator; moreover, clients check actual inclusion proofs instead of SCTs; finally, there are stronger split-view protections, as we will see below. The <a href="https://c2sp.org/static-ct-api">Static CT API</a> and <a href="https://sunlight.dev">Sunlight</a> CT log implementation were a first <a href="https://letsencrypt.org/2025/06/11/reflections-on-a-year-of-sunlight">successful</a> step in moving CT towards the tlog ecosystem, and a proposed design called <a href="https://datatracker.ietf.org/doc/draft-davidben-tls-merkle-tree-certs/">Merkle Tree Certificates</a> redesigns the WebPKI to have tlog-like and tlog-interoperable transparency.</p>
<p>In my experience, it’s best <em>not</em> to think about CT when learning about tlogs. A better production example of a tlog is the <a href="https://golang.org/design/25530-sumdb">Go Checksum Database</a>, where Google logs the module name, version, and hash for every module version observed by the Go Modules Proxy. The module fetches happen over regular HTTPS, so there is no publicly-verifiable proof of their authenticity. Instead, the central party appends every observation to the tlog, so that any misbehavior can be caught. The <code>go get</code> command verifies inclusion proofs for every module it downloads, protecting 100% of the ecosystem, without requiring module authors to manage keys.</p>
<blockquote>
<p>Katie Hockman gave <a href="https://www.youtube.com/watch?v=KqTySYYhPUE">a great talk on the Go Checksum Database</a> at GopherCon 2019.</p>
</blockquote>
<p>You might also have heard of <a href="https://engineering.fb.com/2023/04/13/security/whatsapp-key-transparency/">Key Transparency</a>. KT is an overlapping technology that was deployed by Apple, WhatsApp, and Signal amongst others. It has similar goals, but picks different tradeoffs that involve significantly more complexity, in exchange for better privacy and scalability in some settings.</p>
<h2 id="a-tlog-for-our-keyserver">A tlog for our keyserver</h2>
<p>Ok, so how do we apply a tlog to our email-based keyserver?</p>
<p>It’s pretty simple, and we can do it with <a href="https://github.com/FiloSottile/torchwood/commit/d031d34ec656156d51df074ae8823edd60329d92">a 250-line diff</a> using <a href="https://github.com/transparency-dev/tessera">Tessera</a> and <a href="https://filippo.io/torchwood">Torchwood</a>. Tessera is a general-purpose tlog implementation library, which can be backed by object storage or a POSIX filesystem. For our keyserver, we’ll use the latter backend, which stores the whole tlog in a directory according to the <a href="https://c2sp.org/tlog-tiles">c2sp.org/tlog-tiles</a> specification.</p>
<pre><code>s, err := note.NewSigner(os.Getenv(&#34;LOG_KEY&#34;))
if err != nil {
    log.Fatalln(&#34;failed to create checkpoint signer:&#34;, err)
}
v, err := torchwood.NewVerifierFromSigner(os.Getenv(&#34;LOG_KEY&#34;))
if err != nil {
    log.Fatalln(&#34;failed to create checkpoint verifier:&#34;, err)
}
policy := torchwood.ThresholdPolicy(2, torchwood.OriginPolicy(v.Name()),
    torchwood.SingleVerifierPolicy(v))

driver, err := posix.New(ctx, posix.Config{
    Path: *logPath,
})
if err != nil {
    log.Fatalln(&#34;failed to create log storage driver:&#34;, err)
}

// Since this is a low-traffic but interactive server, disable batching to
// remove integration latency for the first request. Keep a 1s checkpoint
// interval not to hit the witnesses too often; this will be observed only
// if two requests come in quick succession. Finally, only publish a
// checkpoint once a day if there are no new entries, making the average qps
// on witnesses low. Poll for new checkpoints quickly since it should be
// just a read from a hot filesystem cache.
checkpointInterval := 1 * time.Second
if testing.Testing() {
    checkpointInterval = 100 * time.Millisecond
}
appender, shutdown, logReader, err := tessera.NewAppender(ctx, driver, tessera.NewAppendOptions().
    WithCheckpointSigner(s).
    WithBatching(1, tessera.DefaultBatchMaxAge).
    WithCheckpointInterval(checkpointInterval).
    WithCheckpointRepublishInterval(24*time.Hour))
if err != nil {
    log.Fatalln(&#34;failed to create log appender:&#34;, err)
}
defer shutdown(context.Background())
awaiter := tessera.NewPublicationAwaiter(ctx, logReader.ReadCheckpoint, 25*time.Millisecond)
</code></pre>
<p>Every time a user sets their key, we append an encoded <em>(email, public key)</em> entry to the tlog, and we store the tlog entry index in the database.</p>
<pre><code>+    // Add to transparency log
+    if strings.ContainsAny(email, &#34;\n&#34;) {
+        http.Error(w, &#34;Invalid email format&#34;, http.StatusBadRequest)
+        return
+    }
+    entry := tessera.NewEntry(fmt.Appendf(nil, &#34;%s\n%s\n&#34;, email, pubkey))
+    index, _, err := s.awaiter.Await(r.Context(), s.appender.Add(r.Context(), entry))
+    if err != nil {
+        http.Error(w, &#34;Failed to add to transparency log&#34;, http.StatusInternalServerError)
+        log.Printf(&#34;transparency log error: %v&#34;, err)
+        return
+    }
+
     // Store in database
-    if err := s.storeKey(email, pubkey); err != nil {
+    if err := s.storeKey(email, pubkey, int64(index.Index)); err != nil {
         http.Error(w, &#34;Failed to store key&#34;, http.StatusInternalServerError)
         log.Printf(&#34;database error: %v&#34;, err)
         return
     }
</code></pre>
<p>The lookup API produces a proof from the index and provides it to the client.</p>
<pre><code>func (s *Server) makeSpicySignature(ctx context.Context, index int64) ([]byte, error) {
    checkpoint, err := s.reader.ReadCheckpoint(ctx)
    if err != nil {
        return nil, fmt.Errorf(&#34;failed to read checkpoint: %v&#34;, err)
    }
    c, _, err := torchwood.VerifyCheckpoint(checkpoint, s.policy)
    if err != nil {
        return nil, fmt.Errorf(&#34;failed to parse checkpoint: %v&#34;, err)
    }
    p, err := tlog.ProveRecord(c.N, index, torchwood.TileHashReaderWithContext(
        ctx, c.Tree, tesserax.NewTileReader(s.reader)))
    if err != nil {
        return nil, fmt.Errorf(&#34;failed to create proof: %v&#34;, err)
    }
    return torchwood.FormatProof(index, p, checkpoint), nil
}
</code></pre>
<p>The proof follows the <a href="https://c2sp.org/tlog-proof">c2sp.org/tlog-proof</a> specification. It looks like this</p>
<pre><code>c2sp.org/tlog-proof@v1
index 1
CJdjppwZSa2A60oEpcdj/OFjVQyrkP3fu/Ot2r6smg0=

keyserver.geomys.org
2
HtFreYGe2VBtaf3Vf0AG0DAwEZ+H92HQqrx4dkrzk0U=

— keyserver.geomys.org FrMVCWmHnYfHReztLams2F3HUY6UMub3c5xu7+e8R8SAk9cxPKAB1fsQ6gFM16xwkvZ8p5aWaBf8km+M20eHErSfGwI=
</code></pre>
<p>and it combines a <a href="https://c2sp.org/tlog-checkpoint">checkpoint</a> (a signed snapshot of the log at a certain size), the index of the entry in the log, and a proof of inclusion of the entry in the checkpoint.</p>
<p>The client CLI receives the proof from the lookup API, checks the signature on the checkpoint from the built-in log public key, hashes the expected entry, and checks the inclusion proof for that hash and checkpoint. It can do all this without interacting further with the log.</p>
<pre><code>vkey := os.Getenv(&#34;AGE_KEYSERVER_PUBKEY&#34;)
if vkey == &#34;&#34; {
    vkey = defaultKeyserverPubkey
}
v, err := note.NewVerifier(vkey)
if err != nil {
    fmt.Fprintf(os.Stderr, &#34;Error: invalid keyserver public key: %v\n&#34;, err)
    os.Exit(1)
}
policy := torchwood.ThresholdPolicy(2, torchwood.OriginPolicy(v.Name()),
    torchwood.SingleVerifierPolicy(v))
</code></pre>
<pre><code>// Verify spicy signature
entry := fmt.Appendf(nil, &#34;%s\n%s\n&#34;, result.Email, result.Pubkey)
if err := torchwood.VerifyProof(policy, tlog.RecordHash(entry), []byte(result.Proof)); err != nil {
    return &#34;&#34;, fmt.Errorf(&#34;failed to verify key proof: %w&#34;, err)
}
</code></pre>
<p>If you squint, you can see that the proof is really a “fat signature” for the entry, which you verify with the log’s public key, just like you’d verify an Ed25519 or RSA signature for a message. I like to call them <em>spicy signatures</em> to stress how <strong>tlogs can be deployed anywhere you can deploy regular digital signatures</strong>.</p>
<h3 id="monitoring">Monitoring</h3>
<p>What’s the point of all this though? The point is that anyone can look through the log to make sure the keyserver is not serving unauthorized keys for their email address! Indeed, just like <a href="https://alexgaynor.net/2024/sep/09/signatures-are-like-backups/">backups are useless without restores and signatures are useless without verification</a>, <a href="https://www.youtube.com/watch?v=uZXESulUuKA">tlogs are useless without monitoring</a>. That means we need to build tooling to monitor the log.</p>
<p>On the server side, it takes two lines of code, to expose the Tessera POSIX log directory.</p>
<pre><code>// Serve tlog-tiles log
fs := http.StripPrefix(&#34;/tlog/&#34;, http.FileServer(http.Dir(*logPath)))
mux.Handle(&#34;GET /tlog/&#34;, fs)
</code></pre>
<p>On the client side, we add an <code>-all</code> flag to the CLI that reads all matching entries in the log.</p>
<pre><code>func monitorLog(serverURL string, policy torchwood.Policy, email string) ([]string, error) {
    f, err := torchwood.NewTileFetcher(serverURL+&#34;/tlog&#34;, torchwood.WithUserAgent(&#34;age-keylookup/1.0&#34;))
    if err != nil {
        return nil, fmt.Errorf(&#34;failed to create tile fetcher: %w&#34;, err)
    }
    c, err := torchwood.NewClient(f)
    if err != nil {
        return nil, fmt.Errorf(&#34;failed to create torchwood client: %w&#34;, err)
    }

    // Fetch and verify checkpoint
    signedCheckpoint, err := f.ReadEndpoint(context.Background(), &#34;checkpoint&#34;)
    if err != nil {
        return nil, fmt.Errorf(&#34;failed to read checkpoint: %w&#34;, err)
    }
    checkpoint, _, err := torchwood.VerifyCheckpoint(signedCheckpoint, policy)
    if err != nil {
        return nil, fmt.Errorf(&#34;failed to parse checkpoint: %w&#34;, err)
    }

    // Fetch all entries up to the checkpoint size
    var pubkeys []string
    for i, entry := range c.AllEntries(context.Background(), checkpoint.Tree, 0) {
        e, rest, ok := strings.Cut(string(entry), &#34;\n&#34;)
        if !ok {
            return nil, fmt.Errorf(&#34;malformed log entry %d: %q&#34;, i, string(entry))
        }
        k, rest, ok := strings.Cut(rest, &#34;\n&#34;)
        if !ok || rest != &#34;&#34; {
            return nil, fmt.Errorf(&#34;malformed log entry %d: %q&#34;, i, string(entry))
        }
        if e == email {
            pubkeys = append(pubkeys, k)
        }
    }
    if c.Err() != nil {
        return nil, fmt.Errorf(&#34;error fetching log entries: %w&#34;, c.Err())
    }

    return pubkeys, nil
}
</code></pre>
<p>To enable effective monitoring, we also normalize email addresses by trimming spaces and lowercasing them, since users are unlikely to monitor all the variations. We do it before sending the login link, so normalization can’t lead to impersonation.</p>
<pre><code>// Normalize email
email = strings.TrimSpace(strings.ToLower(email))
</code></pre>
<p>A complete monitoring story would involve 3rd party services that monitor the log for you and email you if new keys are added, like <a href="https://www.gopherwatch.org/">gopherwatch</a> and <a href="https://sourcespotter.com/sumdb/">Source Spotter</a> do for the Go Checksum Database, but the <code>-all</code> flag is a start.</p>
<p>The <a href="https://github.com/FiloSottile/torchwood/commit/d031d34ec656156d51df074ae8823edd60329d92">full change</a> involves <em>5 files changed, 251 insertions(+), 6 deletions(-)</em>, plus tests, and includes a new keygen helper binary, the required database schema and help text and API changes, and web UI changes to show the proof.</p>
<p><strong>Edit</strong>: the original patch series is missing freshness checks in monitor mode, to ensure the log is not hiding entries from monitors by serving them an old checkpoint. The easiest solution is <a href="https://github.com/FiloSottile/torchwood/commit/8b61ef967">checking the timestamp on witness cosignatures</a> (<em>+15 lines</em>). You will learn about witness cosignatures below.</p>
<h2 id="privacy-with-vrfs">Privacy with VRFs</h2>
<p>We created a problem by implementing this tlog, though: now all the email addresses of our users are public! While this is ok for module names in the Go Checksum Database, allowing email address enumeration in our keyserver is a non-starter for privacy and spam reasons.</p>
<p>We could hash the email addresses, but that would still allow offline brute-force attacks. The right tool for the job is a Verifiable Random Function. You can think of a VRF as a hash with a private and public key: only you can produce a hash value, using the private key, but anyone can check that it’s the correct (and unique) hash value, using the public key.</p>
<p>Overall, implementing VRFs <a href="https://github.com/FiloSottile/torchwood/commit/52f07f1bcc7bb402b5f84a77a57dad8d9ce668e6">takes less than 130 lines</a> using the <a href="https://c2sp.org/vrf-r255">c2sp.org/vrf-r255</a> instantiation based on <a href="https://ristretto.group/">ristretto255</a>, implemented by <a href="https://filippo.io/mostly-harmless/vrf-r255">filippo.io/mostly-harmless/vrf-r255</a> (pending a more permanent location). Instead of the email address, we include the VRF hash in the log entry, and we save the VRF proof in the database.</p>
<pre><code>+       // Compute VRF hash and proof
+       vrfProof := s.vrf.Prove([]byte(email))
+       vrfHash := base64.StdEncoding.EncodeToString(vrfProof.Hash())
+
        // Add to transparency log
-       entry := tessera.NewEntry(fmt.Appendf(nil, &#34;%s\n%s\n&#34;, email, pubkey))
+       entry := tessera.NewEntry(fmt.Appendf(nil, &#34;%s\n%s\n&#34;, vrfHash, pubkey))
        index, _, err := s.awaiter.Await(r.Context(), s.appender.Add(r.Context(), entry))
        if err != nil {
            http.Error(w, &#34;Failed to add to transparency log&#34;, http.StatusInternalServerError)
        }

        // [...]

        // Store in database
-       if err := s.storeKey(email, pubkey, int64(index.Index)); err != nil {
+       if err := s.storeKey(email, pubkey, int64(index.Index), vrfProof.Bytes()); err != nil {
            http.Error(w, &#34;Failed to store key&#34;, http.StatusInternalServerError)
            log.Printf(&#34;database error: %v&#34;, err)
            return
        }
</code></pre>
<p>The tlog proof format has space for application-specific opaque extra data, so we can store the VRF proof there, to keep the tlog proof self-contained.</p>
<pre><code>-   return torchwood.FormatProof(index, p, checkpoint), nil
+   return torchwood.FormatProofWithExtraData(index, vrfProof, p, checkpoint), nil
</code></pre>
<p>In the client CLI, we extract the VRF hash from the tlog proof’s extra data and verify it’s the correct hash for the email address.</p>
<pre><code>+   // Compute and verify VRF hash
+   vrfProofBytes, err := torchwood.ProofExtraData([]byte(result.Proof))
+   if err != nil {
+       return &#34;&#34;, fmt.Errorf(&#34;failed to extract VRF proof: %w&#34;, err)
+   }
+   vrfProof, err := vrf.NewProof(vrfProofBytes)
+   if err != nil {
+       return &#34;&#34;, fmt.Errorf(&#34;failed to parse VRF proof: %w&#34;, err)
+   }
+   vrfHash, err := vrfKey.Verify(vrfProof, []byte(email))
+   if err != nil {
+       return &#34;&#34;, fmt.Errorf(&#34;failed to verify VRF proof: %w&#34;, err)
+   }
+
    // Verify spicy signature
-   entry := fmt.Appendf(nil, &#34;%s\n%s\n&#34;, result.Email, result.Pubkey)
+   vrfHashB64 := base64.StdEncoding.EncodeToString(vrfHash)
+   entry := fmt.Appendf(nil, &#34;%s\n%s\n&#34;, vrfHashB64, result.Pubkey)
    if err := torchwood.VerifyProof(policy, tlog.RecordHash(entry), []byte(result.Proof)); err != nil {
        return &#34;&#34;, fmt.Errorf(&#34;failed to verify key proof: %w&#34;, err)
    }
</code></pre>
<p>How do we do monitoring now, though? We need to add a new API that provides the VRF hash (and proof) for an email address.</p>
<pre><code>    mux.HandleFunc(&#34;GET /manage&#34;, srv.handleManage)
    mux.HandleFunc(&#34;POST /setkey&#34;, srv.handleSetKey)
    mux.HandleFunc(&#34;GET /api/lookup&#34;, srv.handleLookup)
+   mux.HandleFunc(&#34;GET /api/monitor&#34;, srv.handleMonitor)
    mux.HandleFunc(&#34;POST /api/verify-token&#34;, srv.handleVerifyToken)
</code></pre>
<pre><code>func (s *Server) handleMonitor(w http.ResponseWriter, r *http.Request) {
    email := r.URL.Query().Get(&#34;email&#34;)
    if email == &#34;&#34; {
        http.Error(w, &#34;Email parameter required&#34;, http.StatusBadRequest)
        return
    }

    // Return as JSON
    w.Header().Set(&#34;Content-Type&#34;, &#34;application/json&#34;)
    json.NewEncoder(w).Encode(map[string]any{
        &#34;email&#34;:     email,
        &#34;vrf_proof&#34;: s.vrf.Prove([]byte(email)).Bytes(),
    })
}
</code></pre>
<p>On the client side, we use that API to obtain the VRF proof, we verify it, and we look for the VRF hash in the log instead of looking for the email address.</p>
<p>Attackers can still enumerate email addresses by hitting the public lookup or monitor API, but they’ve always been able to do that: serving such a public API is the point of the keyserver! With VRFs, we restored the original status quo: enumeration requires brute-forcing the online, rate-limited API, instead of having a full list of email addresses in the tlog (or hashes that can be brute-forced offline).</p>
<p>VRFs have a further benefit: if a user requests to be deleted from the service, we can’t remove their entries from the tlog, but we <em>can</em> stop serving the VRF for their email address<sup id="fnref:stored"><a href="#fn:stored">4</a></sup> from the lookup and monitor APIs. This makes it impossible to obtain the key history for that user, or even to check if they ever used the keyserver, but doesn’t impact monitoring for other users.</p>
<p>The <a href="https://github.com/FiloSottile/torchwood/commit/52f07f1bcc7bb402b5f84a77a57dad8d9ce668e6">full change</a> adding VRFs involves <em>3 files changed, 125 insertions(+), 13 deletions(-)</em>, plus tests.</p>
<h2 id="anti-poisoning">Anti-poisoning</h2>
<p>We have one last marginal risk to mitigate: since we can’t ever remove entries from the tlog, what if someone inserts some unsavory message in the log by smuggling it in as a public key, like <code>age1llllllllllllllrustevangellsmstrlkef0rcellllllllllllq574n08</code>?</p>
<p>Protecting against this risk is called <em>anti-poisoning</em>. The risk to our log is relatively small, public keys have to be Bech32-encoded and short, so an attacker can’t usefully embed images or malware. Still, it’s easy enough to neutralize it: instead of the public keys, we put their hashes in the tlog entry, keeping the original public keys in a new table in the database, and serving them as part of the monitor API.</p>
<pre><code>         // Compute VRF hash and proof
         vrfProof := s.vrf.Prove([]byte(email))
-        vrfHash := base64.StdEncoding.EncodeToString(vrfProof.Hash())
+
+        // Keep track of the unhashed key
+        if err := s.storeHistory(email, pubkey); err != nil {
+            http.Error(w, &#34;Failed to store key history&#34;, http.StatusInternalServerError)
+            log.Printf(&#34;database error: %v&#34;, err)
+            return
+        }

         // Add to transparency log
-        entry := tessera.NewEntry(fmt.Appendf(nil, &#34;%s\n%s\n&#34;, vrfHash, pubkey))
+        h := sha256.New()
+        h.Write([]byte(pubkey))
+        entry := tessera.NewEntry(h.Sum(vrfProof.Hash())) // vrf-r255(email) || SHA-256(pubkey)
         index, _, err := s.awaiter.Await(r.Context(), s.appender.Add(r.Context(), entry))
</code></pre>
<p>It’s <em>very important</em> that we persist the original key in the database <u>before</u> adding the entry to the tlog. Losing the original key would be indistinguishable from refusing to provide a malicious key to monitors.</p>
<p>On the client side, to do a lookup we just hash the public key when verifying the inclusion proof. To monitor in <code>-all</code> mode, we match the hashes against the list of original public keys provided by the server through the monitor API.</p>
<pre><code>     var result struct {
         Email    string   `json:&#34;email&#34;`
         VRFProof []byte   `json:&#34;vrf_proof&#34;`
+        History  []string `json:&#34;history&#34;`
     }
</code></pre>
<pre><code>+    // Prepare map of hashes of historical keys
+    historyHashes := make(map[[32]byte]string)
+    for _, pk := range result.History {
+        h := sha256.Sum256([]byte(pk))
+        historyHashes[h] = pk
+    }
</code></pre>
<pre><code>     // Fetch all entries up to the checkpoint size
     var pubkeys []string
     for i, entry := range c.AllEntries(context.Background(), checkpoint.Tree, 0) {
-        e, rest, ok := strings.Cut(string(entry), &#34;\n&#34;)
-        if !ok {
-            return nil, fmt.Errorf(&#34;malformed log entry %d: %q&#34;, i, string(entry))
-        }
-        k, rest, ok := strings.Cut(rest, &#34;\n&#34;)
-        if !ok || rest != &#34;&#34; {
-            return nil, fmt.Errorf(&#34;malformed log entry %d: %q&#34;, i, string(entry))
-        }
-        if e == base64.StdEncoding.EncodeToString(vrfHash) {
-            pubkeys = append(pubkeys, k)
-        }
+        if len(entry) != 64+32 {
+            return nil, fmt.Errorf(&#34;invalid entry size at index %d&#34;, i)
+        }
+        if !bytes.Equal(entry[:64], vrfHash) {
+            continue
+        }
+        pk, ok := historyHashes[([32]byte)(entry[64:])]
+        if !ok {
+            return nil, fmt.Errorf(&#34;found unknown public key hash in log at index %d&#34;, i)
+        }
+        pubkeys = append(pubkeys, pk)
     }
</code></pre>
<p>Our final log entry format is <code>vrf-r255(email) || SHA-256(pubkey)</code>. Designing the tlog entry is the most important part of deploying a tlog: it needs to include enough information to let monitors isolate all the entries relevant to them, but not enough information to pose privacy or poisoning threats.</p>
<p>The <a href="https://github.com/FiloSottile/torchwood/commit/194a603666e1e278785878a727c88f062725eabc">full change</a> providing anti-poisoning involves <em>2 files changed, 93 insertions(+), 19 deletions(-)</em>, plus tests.</p>
<h2 id="non-equivocation-and-the-witness-network">Non-equivocation and the Witness Network</h2>
<p>We’re almost done! There’s still one thing to fix, and it <em>used</em> to be the hardest part.</p>
<p>To get the delayed, collective verification we need, all clients and monitors must see <em>consistent</em> views of the same log, where the log maintains its append-only property. This is called non-equivocation, or split-view protection. In other words, how do we stop the log operator from showing an inclusion proof for log A to a client, and then a different log B to the monitors?</p>
<p>Just like logging without a monitoring story is like signing without verification, logging without a non-equivocation story is just a complicated signature algorithm with no strong transparency properties.</p>
<p>This is the hard part because in the general case <a href="https://www.youtube.com/watch?v=_UHied0ZcIs&amp;list=PLwiyx1dc3P2J2jur9fm5U2ss9o2kHzNLB&amp;index=6&amp;pp=gAQBiAQBsAgC"><em>you can’t do it alone</em></a>. Instead, the tlog ecosystem has the concept of <a href="https://c2sp.org/tlog-witness">witness cosigners</a>: third-party operated services which cosign a checkpoint to attest that it is consistent with all the other checkpoints the witness observed for that log. Clients check these witness <a href="https://c2sp.org/tlog-cosignature">cosignatures</a> to get assurance that—unless a quorum of witnesses is colluding with the log—they are not being presented a split-view of the log.</p>
<p>These witnesses are <em>extremely</em> efficient to operate: the log provides the O(log N) consistency proof when requesting a cosignature, and the witness only needs to store the O(1) latest checkpoint it observed. All the potentially intensive verification is deferred and delegated to monitors, which can be sure to have the same view as all clients thanks to the witness cosignatures.</p>
<p>This efficiency makes it possible to operate witnesses for free as public benefit infrastructure. The <a href="https://witness-network.org/">Witness Network</a> collects public witnesses and maintains an open list of tlogs that the witnesses automatically configure.</p>
<p>For the Geomys instance of the keyserver, I generated a tlog key and then I sent <a href="https://github.com/transparency-dev/witness-network/pull/28">a PR to the Witness Network</a> to add the following lines to the testing log list.</p>
<pre><code>vkey keyserver.geomys.org+16b31509+ARLJ+pmTj78HzTeBj04V+LVfB+GFAQyrg54CRIju7Nn8
qpd 1440
contact keyserver-tlog@geomys.org
</code></pre>
<p>This got my log configured in <a href="https://witness-network.org/witness-tables/">a handful of witnesses</a>, from which I picked three to build the default keyserver witness policy.</p>
<pre><code>log keyserver.geomys.org+16b31509+ARLJ+pmTj78HzTeBj04V+LVfB+GFAQyrg54CRIju7Nn8
witness TrustFabric transparency.dev/DEV:witness-little-garden+d8042a87+BCtusOxINQNUTN5Oj8HObRkh2yHf/MwYaGX4CPdiVEPM https://api.transparency.dev/dev/witness/little-garden/
witness Mullvad witness.stagemole.eu+67f7aea0+BEqSG3yu9YrmcM3BHvQYTxwFj3uSWakQepafafpUqklv https://witness.stagemole.eu/
witness Geomys witness.navigli.sunlight.geomys.org+a3e00fe2+BNy/co4C1Hn1p+INwJrfUlgz7W55dSZReusH/GhUhJ/G https://witness.navigli.sunlight.geomys.org/
group public 2 TrustFabric Mullvad Geomys
quorum public
</code></pre>
<p>The policy format is based on <a href="https://git.glasklar.is/sigsum/core/sigsum-go/-/blob/main/doc/policy.md">Sigsum’s policies</a>, and it encodes the log’s public key and the witnesses’ public keys (for the clients) and submission URLs (for the log).</p>
<p>Tessera supports these policies directly. When minting a new checkpoint, it will reach out in parallel to all the witnesses, and return the checkpoint once it satisfies the policy. Configuration is trivial, and the added latency is minimal (less than one second).</p>
<pre><code>+    witnessPolicy := defaultWitnessPolicy
+    if path := os.Getenv(&#34;LOG_WITNESS_POLICY&#34;); path != &#34;&#34; {
+        witnessPolicy, err = os.ReadFile(path)
+        if err != nil {
+            log.Fatalln(&#34;failed to read witness policy file:&#34;, err)
+        }
+    }
+    witnesses, err := tessera.NewWitnessGroupFromPolicy(witnessPolicy)
+    if err != nil {
+        log.Fatalln(&#34;failed to create witness group from policy:&#34;, err)
+    }

     // [...]

     appender, shutdown, logReader, err := tessera.NewAppender(ctx, driver, tessera.NewAppendOptions().
         WithCheckpointSigner(s).
         WithBatching(1, tessera.DefaultBatchMaxAge).
         WithCheckpointInterval(checkpointInterval).
-        WithCheckpointRepublishInterval(24*time.Hour))
+        WithCheckpointRepublishInterval(24*time.Hour).
+        WithWitnesses(witnesses, nil))
</code></pre>
<p>On the client side, we can use Torchwood to parse the policy and use it directly with <a href="https://pkg.go.dev/filippo.io/torchwood@v0.8.1-0.20251217175055-7b37840a7b58#VerifyProof">VerifyProof</a> in place of the policy we were manually constructing from the log’s public key.</p>
<pre><code>-    vkey := os.Getenv(&#34;AGE_KEYSERVER_PUBKEY&#34;)
-    if vkey == &#34;&#34; {
-        vkey = defaultKeyserverPubkey
-    }
+    policyBytes := defaultPolicy
+    if policyPath := os.Getenv(&#34;AGE_KEYSERVER_POLICY&#34;); policyPath != &#34;&#34; {
+        p, err := os.ReadFile(policyPath)
+        if err != nil {
+            fmt.Fprintf(os.Stderr, &#34;Error: failed to read policy file: %v\n&#34;, err)
+            os.Exit(1)
+        }
+        policyBytes = p
+    }
-    v, err := note.NewVerifier(vkey)
-    if err != nil {
-        fmt.Fprintf(os.Stderr, &#34;Error: invalid keyserver public key: %v\n&#34;, err)
-        os.Exit(1)
-    }
-    policy := torchwood.ThresholdPolicy(2, torchwood.OriginPolicy(v.Name()), torchwood.SingleVerifierPolicy(v))
+    policy, err := torchwood.ParsePolicy(policyBytes)
+    if err != nil {
+        fmt.Fprintf(os.Stderr, &#34;Error: invalid policy: %v\n&#34;, err)
+        os.Exit(1)
+    }
</code></pre>
<p>Again, if you squint you can see that just like tlog proofs are <em>spicy signatures</em>, the policy is a <em>spicy public key</em>. Verification is a deterministic, offline function that takes a policy/public key and a proof/signature, just like digital signature verification!</p>
<p>The policies are a <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">DAG</a> that can get complex to match even the strictest uptime requirements. For example, you can require 3 out of 10 witness operators to cosign a checkpoint, where each operator can use any 1 out of N witness instances to do so. Note however that in that case you will need to periodically provide to monitors <a href="https://git.glasklar.is/sigsum/project/documentation/-/blob/main/archive/2023-11-byzantine-witnesses.pdf">all cosignatures from at least 8 out of 10 operators, to prevent split-views</a>.</p>
<p>The <a href="https://github.com/FiloSottile/torchwood/commit/e5b50faaad78fe2742e16a770be08746fc1f604e">full change</a> implementing witnessing involves <em>5 files changed, 43 insertions(+), 11 deletions(-)</em>, plus tests.</p>
<h2 id="summing-up">Summing up</h2>
<p>We started with a simple centralized email-authenticated<sup id="fnref:OIDC"><a href="#fn:OIDC">5</a></sup> keyserver, and we turned it into a transparent, privacy-preserving, anti-poisoning, and witness-cosigned service.</p>
<p>We did that in four small steps using <a href="https://github.com/transparency-dev/tessera">Tessera</a>, <a href="https://filippo.io/torchwood">Torchwood</a>, and various <a href="https://c2sp.org/">C2SP</a> specifications.</p>
<pre><code>cmd/age-keyserver: add transparency log of stored keys
    5 files changed, 259 insertions(+), 8 deletions(-)
cmd/age-keyserver: use VRFs to hide emails in the log
    3 files changed, 125 insertions(+), 13 deletions(-)
cmd/age-keyserver: hash age public key to prevent log poisoning
    2 files changed, 93 insertions(+), 19 deletions(-)
cmd/age-keyserver: add witness cosigning to prevent split-views
    5 files changed, 43 insertions(+), 11 deletions(-)
</code></pre>
<p>Overall, it took less than 500 lines.</p>
<blockquote>
<p>7 files changed, 472 insertions(+), 9 deletions(-)</p>
</blockquote>
<p>The UX is completely unchanged: there are no keys for users to manage, and the web UI and CLI work exactly like they did before. The only difference is the new <code>-all</code> functionality of the CLI, which allows holding the log operator accountable for all the public keys it could ever have presented for an email address.</p>
<p>The result is deployed live at <a href="https://keyserver.geomys.org">keyserver.geomys.org</a>.</p>
<h2 id="future-work-efficient-monitoring-and-revocation">Future work: efficient monitoring and revocation</h2>
<p>This tlog system still has two limitations:</p>
<ol>
<li>
<p>To monitor the log, the monitor needs to download it all. This is probably fine for our little keyserver, and even for the Go Checksum Database, but it’s a scaling problem for the Certificate Transparency / Merkle Tree Certificates ecosystem.</p>
</li>
<li>
<p>The inclusion proof guarantees that the public key is in the log, not that it’s the <em>latest</em> entry in the log for that email address. Similarly, the Go Checksum Database can’t efficiently prove the Go Modules Proxy <code>/list</code> response is complete.</p>
</li>
</ol>
<p>We are working on a design called <a href="https://github.com/transparency-dev/incubator/tree/main/vindex">Verifiable Indexes</a> which plugs on top of a tlog to provide verifiable indexes or even map-reduce operations over the log entries. We expect VI to be production-ready before the end of 2026, while everything above is ready today.</p>
<p>Even without VI, the tlog provides strong accountability for our keyserver, enabling a secure UX that would have simply not been possible without transparency.</p>
<p>I hope this step-by-step demo will help you apply tlogs to your own systems. If you need help, you can join the <a href="https://transparency.dev/slack/">Transparency.dev Slack</a>. You might also want to follow me on Bluesky at <a href="https://bsky.app/profile/filippo.abyssdomain.expert">@filippo.abyssdomain.expert</a> or on Mastodon at <a href="https://abyssdomain.expert/@filippo">@filippo@abyssdomain.expert</a>.</p>
<h2 id="the-picture">The picture</h2>
<p>Growing up, I used to drive my motorcycle around the hills near my hometown, trying to reach churches I could spot from hilltops. This was one of my favorite spots.</p>
<p><img alt="Rolling hills in autumn with golden trees bordering a plowed field, hilltop church and village in the distance, and mountains under blue sky" src="https://assets.buttondown.email/images/bbbcaa91-46e2-40d9-adcb-973ff54d0958.jpeg"/></p>
<p><a href="https://geomys.org">Geomys</a>, my Go open source maintenance organization, is funded by <a href="https://smallstep.com/">Smallstep</a>, <a href="https://www.avalabs.org/">Ava Labs</a>, <a href="https://goteleport.com/">Teleport</a>, <a href="https://tailscale.com/">Tailscale</a>, and <a href="https://sentry.io/">Sentry</a>. Through our retainer contracts they ensure the sustainability and reliability of our open source maintenance work and get a direct line to my expertise and that of the other Geomys maintainers. (Learn more in the <a href="https://words.filippo.io/geomys">Geomys announcement</a>.)</p>
<p>Here are a few words from some of them!</p>
<p>Teleport — For the past five years, attacks and compromises have been shifting from traditional malware and security breaches to identifying and compromising valid user accounts and credentials with social engineering, credential theft, or phishing. <a href="https://goteleport.com/platform/identity/?utm=filippo">Teleport Identity</a> is designed to eliminate weak access patterns through access monitoring, minimize attack surface with access requests, and purge unused permissions via mandatory access reviews.</p>
<p>Ava Labs — We at <a href="https://www.avalabs.org">Ava Labs</a>, maintainer of <a href="https://github.com/ava-labs/avalanchego">AvalancheGo</a> (the most widely used client for interacting with the <a href="https://www.avax.network">Avalanche Network</a>), believe the sustainable maintenance and development of open source cryptographic protocols is critical to the broad adoption of blockchain technology. We are proud to support this necessary and impactful work through our ongoing sponsorship of Filippo and his team.</p>
<div>
<hr/>
<ol>
<li id="fn:emailage">
<p>age is not really meant to encrypt messages to strangers, nor does it encourage long-term keys. Instead, keys are simple strings that can be exchanged easily through any semi-trusted (i.e. safe against active attackers) channel. Still, a keyserver could be useful in some cases, and it will serve as a decent example for what we are doing today. <a href="#fnref:emailage" title="Jump back to footnote 1 in the text">↩</a></p>
</li>
<li id="fn:json">
<p>I like to use the SQLite built-in JSON support as a simple document database, to avoid tedious table migrations when adding columns. <a href="#fnref:json" title="Jump back to footnote 2 in the text">↩</a></p>
</li>
<li id="fn:broadcast">
<p>Ok, one thing is special, but it doesn’t have anything to do with transparency. I strongly prefer email magic links that authenticate your <em>original</em> tab, where you have your browsing session history, instead of making you continue in the new tab you open from the email. However, intermediating that flow via a server introduces a phishing risk: if you click the link you risk authenticating the attacker’s session. This implementation uses the JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API">Broadcast Channel API</a> to <a href="https://github.com/FiloSottile/torchwood/blob/9d48087631d510ec2c9e6ac7f3f81c05038e1fbe/cmd/age-keyserver/templates/manage.html#L89-L130">pass the auth token locally to the original tab</a>, if it’s open in the same browser, and otherwise authenticates the new tab. Another advantage of this approach is that there are no authentication cookies. <a href="#fnref:broadcast" title="Jump back to footnote 3 in the text">↩</a></p>
</li>
<li id="fn:stored">
<p>Someone who stored the VRF for that email address could continue to match the tlog entries, but since we won’t be adding any new entries to the tlog for that email address, they can’t learn anything they didn’t already know. <a href="#fnref:stored" title="Jump back to footnote 4 in the text">↩</a></p>
</li>
<li id="fn:OIDC">
<p>Something cool about tlogs is that they are often agnostic to the mechanism by which entries are added to the log. For example, instead of email identities and verification we could have used OIDC identities, with our centralized server checking OIDC bearer tokens, held accountable by the tlog. Everything would have worked exactly the same. <a href="#fnref:OIDC" title="Jump back to footnote 5 in the text">↩</a></p>
</li>
</ol>
</div>
        </section>
    </article></div>
  </body>
</html>
