<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://mrcoles.com/intersection-observer-react-hook/">Original</a>
    <h1>Intersection Observer React Hook</h1>
    
    <div id="readability-page-1" class="page"><div id="post-152">
        
        <div><p><img alt="react use intersection observer" src="https://mrcoles.com/media/img/react-use-intersection-observer.png" title="the eyes in the React logo are observing an intersection… it made sense when I was mocking it up…" width="260"/></p>
<p>I was building a page in React recently and wanted to have a component animate upon scrolling into view. I knew <a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API">IntersectionObserver</a> was the right tool for the job and decided to take a fun digression to write my own React hook.</p>
<p>Here’s the result:</p>


<p>The <code>onIntersect</code> parameter is used in the <code>deps</code> of the <code>useEffect</code> call, so you’ll want to make sure you’re either using a function that’s defined outside the component or safely created through <a href="https://reactjs.org/docs/hooks-reference.html#usecallback">useCallback</a> in order to maintain referential equality across render calls.</p>
<p>A simple example would be:</p>
<div><pre><span></span><code><span>import</span> <span>React</span> <span>from</span> <span>&#39;react&#39;</span><span>;</span>

<span>const</span> <span>onObserveSetAnimate</span> <span>=</span> <span>(</span><span>elt</span><span>:</span> <span>HTMLElement</span><span>)</span> <span>=&gt;</span> <span>elt</span><span>.</span><span>classList</span><span>.</span><span>add</span><span>(</span><span>&#39;animate&#39;</span><span>);</span>

<span>const</span> <span>Foo</span> <span>=</span> <span>()</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>ref</span> <span>=</span> <span>useIntersectionObserver</span><span>(</span><span>onObserveSetAnimate</span><span>);</span>
  <span>return</span> <span>&lt;</span><span>div</span> <span>ref</span><span>=</span><span>{</span><span>ref</span><span>}</span><span>&gt;</span><span>hello</span><span>,</span> <span>world</span><span>&lt;/</span><span>div</span><span>&gt;</span><span>;</span>
<span>}</span>
</code></pre></div>

<p>I like how small and self-contained hooks can be, and writing them usually feels like a fun little puzzle that results in a new, reusable tool for my codebase, however, you can usually save time just seeing what other people have already done. Upon writing this, I did a quick search and immediately found existing examples online, such as <a href="https://usehooks-ts.com/react-hook/use-intersection-observer">this one</a> from usehooks-ts.com. </p>
<p>Their code inspired me to add a couple updates to my script:</p>
<ol>
<li>I added the destructuring assignment for the <code>IntersectionObserverInit</code> args param. For TypeScript, you need to assign it to a default variable in order to make it optional (line 19).</li>
<li>I employed <code>JSON.stringify(threshold)</code> in the <code>useEffect</code> to ensure referential equality in the case that it’s an Array that’s generated uniquely each render.</li>
</ol>
<p>It was also interesting to see the different approach where their example takes a <code>ref</code> and mine instead takes a callback and returns a <code>ref</code>. My approach felt straightforward for my particular application, however their approach seems more declarative. I’d love to hear thoughts on differences between the two! Regardless, one beauty of open source is learning from how different people solve similar problems.</p></div>
    </div></div>
  </body>
</html>
