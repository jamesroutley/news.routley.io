<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hamy.xyz/blog/2026-02_ai-orchestrator-overnight">Original</a>
    <h1>I Built an AI Orchestrator and Ran It Overnight - Here&#39;s What Happened</h1>
    
    <div id="readability-page-1" class="page"><p>DISCLOSURE: If you buy through affiliate links, I may earn a small commission. <a href="https://environment.ec.europa.eu/blog/disclosures">(disclosures)</a></p><div><p>I ran my AI orchestrator last night for 10 hours and it completed 15 tasks completely autonomously - triaging work items, researching context, writing PRDs, building features, and reviewing its own code.</p>
<p>It wasn&#39;t very fast and it wasn&#39;t particularly cheap but it worked surprisingly well and I think it tells us something about where the software engineering profession is headed.</p>
<p>In this post I want to share what the orchestrator is, how it works, how it performed, and why I keep coming back to the idea of a gardener when I think about the future of this profession.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/Z9lf0-EZibA?si=uN2RfxslIw2ju6FA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<h2 id="15-tasks-in-10-hours">15 Tasks in 10 Hours</h2>
<p>The orchestrator completed 15 tasks across two 1-hour sessions and one 8-hour overnight session. These were small-to-medium tasks - mechanical fixes, edge cases, improvements. Nothing huge, but sizable work that were good to do eventually.</p>
<p>15 tasks in 10 hours isn&#39;t that fast, AIs can write code much faster than this. But each task went through my full 8 phase engineering pipeline. The idea being that it&#39;s okay to sacrifice speed for quality, considering we want this to be run ~fully autonomously. It&#39;s better for it to only complete 15 tasks over night and need no rework than 20 but we have to fix 5 of them.</p>
<p><img src="https://cdn.hamy.xyz/blog/posts/2026-02_ai-orchestrator-overnight_coding-pipeline.png" alt="AI Coding Pipeline"/></p>
<p>The software engineering pipeline I&#39;ve landed on:</p>
<ul>
<li><strong>Triage</strong> - organize and prioritize the work item</li>
<li><strong>Research</strong> - gather context</li>
<li><strong>PRD</strong> - define what to build</li>
<li><strong>Tech Research</strong> - explore implementation options</li>
<li><strong>Design</strong> - design the system</li>
<li><strong>Spec</strong> - plan the implementation in phases (see: <a href="https://hamy.xyz/blog/2026-01_ai-engineering-best-practices">spec driven development</a>)</li>
<li><strong>Build</strong> - write the code</li>
<li><strong>Review</strong> - <a href="https://hamy.xyz/blog/2026-02_code-reviews-claude-subagents">9 parallel AI subagents review the output</a></li>
</ul>
<p>This pipeline is configured how I like to write software but others are seeing similar results with different approaches with tools like beads, gas town, ccswarm, etc.</p>
<p><em>If you want to see examples of what these phases look like, I&#39;ve taken a snapshot of my AI files (commands / skills) and put them in the <a href="https://github.com/HAMY-LABS/hamy-labs-code-examples/tree/main/artificial-intelligence/2026-01_claude-snapshot/.claude">HAMY LABS Example Repo</a> available to <a href="https://hamy.xyz/blog/haminions">HAMINIONS Members</a>.</em></p>
<h2 id="how-the-orchestrator-works">How the Orchestrator Works</h2>
<p>I&#39;ve been building this over the past week as part of <a href="https://hamy.xyz/blog/2026-01_recurse-center-statement">my Recurse Center batch</a>. One of my focuses coming in was applied AI and I&#39;ve leaned into that to improve <a href="https://hamy.xyz/blog/2026-01_how-i-think-about-vibe-engineering">my vibe engineering workflows</a>.</p>
<p>Through experimentation I found that having set phases for AI agents dramatically increases quality and consistency. Each agent only has so much context so spinning up a new one for each phase and moving them through the pipeline leads to much better outputs. This is the basis of spec-driven development and Ralph loops and I think it is a principle that&#39;s equally effective for humans as AI - I wrote about the principles behind this in <a href="https://hamy.xyz/blog/2026-01_ai-engineering-best-practices">5 AI Coding Best Practices from a Google AI Director</a>.</p>
<p>That idea formed the basis of the orchestrator. It&#39;s a simple state machine that:</p>
<ul>
<li>Keeps a backlog of work items</li>
<li>Triages and prioritizes them into configured pipelines</li>
<li>Moves items through pipeline phases</li>
<li>Spawns an AI agent for each phase</li>
</ul>
<p>Pipelines are fully configurable - phase definitions, parallelism, work guardrails. Each phase pipes out to a file that can be filled with instructions for your AI. The orchestrator doesn&#39;t care what AI CLI you use or what&#39;s in the instructions - it just keeps track of the core loop.</p>
<p>I&#39;m currently using it with Claude Code cause that&#39;s my daily driver but it could theoretically work with codex, opencode, or anything else that takes instructions from the command line.</p>
<p><img src="https://cdn.hamy.xyz/blog/posts/2026-02_ai-orchestrator-overnight_fresh-agents.png" alt="AI context windows"/></p>
<p>The primary thing we&#39;re trying to work around is LLM&#39;s limited context windows. The larger the context in their window, the more they hallucinate and get off track. So instead of one long-running agent that slowly deteriorates as it loses context, you have a deterministic core that spawns fresh agents for each task.</p>
<p>You get the determinism of traditional code with the flexibility of modern LLMs.</p>
<p>This is similar to the <a href="https://www.wisdomai.com/insights/matthew_berman/ralph-loop-autonomous-agents-ai-coding-context-window-ffdd1834">Ralph loop pattern</a> that&#39;s been gaining traction - fresh agent per task, test-driven completion, task decomposition. The difference is that mine encodes a full software engineering lifecycle rather than just a build-and-test loop and the orchestrator can be configured to run any kind of pipeline, not just coding.</p>
<p>Because it&#39;s just a harness that spawns agents, it could be changed to use AI APIs directly in the future. The orchestrator is the stable part and the AI the interchangeable part which hopefully gives it some longevity as AIs and interfaces evolve in the coming years.</p>
<h2 id="the-downsides-of-my-orchestrator">The Downsides of my Orchestrator</h2>
<p>There were 3 main problems with my orchestrator.</p>
<p><strong>It&#39;s slow.</strong> 8 phases per coding task is heavy, especially since we&#39;re only letting it iterate on small-medium tasks. I could speed it up by streamlining phases or using faster models, but for now I&#39;m okay biasing toward quality. A slower agent that produces correct output is more useful than a fast agent that creates rework in this context.</p>
<p><strong>It&#39;s expensive.</strong> It spent ~$90 in tokens for 10 hours of runtime based on outputs from <a href="https://github.com/ryankurte/ccusage">ccusage</a>. That&#39;s a lot for a tool and more than I&#39;d want to pay every day.</p>
<p>Luckily I&#39;m on a Claude Max subscription which is heavily subsidized by Anthropic so I didn&#39;t actually pay this out of pocket. But even at face value this is expensive for a tool but cheap compared to hiring a software engineer. It&#39;d be hard to find a competent SWE you could task with improving your codebase at this quality level for &lt;$10/h - for many things I wouldn&#39;t trust any other SWE to work on my project just due to the overhead involved with onboarding and managing them.</p>
<p>There&#39;s also a lot of room to optimize here with cheaper models, model routing (Opus for planning, Sonnet for implementation), less subagents per phase, or switching to cheaper AI CLIs entirely. So it&#39;s expensive but I&#39;m not too worried about it right now.</p>
<p><strong>Comprehension debt.</strong> A very real danger of this approach is I&#39;m further removed from the codebase. Code is landing that I didn&#39;t write and didn&#39;t directly oversee. I&#39;m not sure how to fully solve this except to regularly come back and get familiar with the codebase - do a task yourself, ask the AI to discuss what&#39;s changed, deep dive into a module. To be fair, this is the same as working at a company - so much code lands in a week that the system no longer looks like what you remembered. But it is jarring when it&#39;s a personal project you&#39;re building yourself.</p>
<h2 id="what-this-means-for-software-engineering">What This Means for Software Engineering</h2>
<p>My orchestrator isn&#39;t even that good but it works surprisingly well and I built it in a couple days. This tells me there will be way more investment here and I&#39;d guess we&#39;ll see some really compelling orchestrators hit mainstream in the next 6-12 months.</p>
<p>This has me thinking about the future of the profession and how to stay relevant. I&#39;m increasingly bullish on a few things:</p>
<ul>
<li>Software engineers will be more productive than ever before</li>
<li>There will be more software than ever before</li>
<li>Agents will write most of the code</li>
<li>Humans will be valuable as managers, product managers, tech leads, architects, and staff engineers - at least short to mid term</li>
</ul>
<p>There will still be applications for hand-written code in novel areas, deep expertise, and tricky places but for the most part AIs will do most of the typing. Others are seeing the same shift - <a href="https://newsletter.pragmaticengineer.com/p/when-ai-writes-almost-all-code-what">Pragmatic Engineer</a> says engineers become &#34;directors,&#34; <a href="https://addyosmani.com/blog/next-two-years/">Addy Osmani</a> says &#34;composers&#34; orchestrating ensembles, and <a href="https://humanwhocodes.com/blog/2026/01/coder-orchestrator-future-software-engineering/">Human Who Codes</a> describes an autocomplete → conductor → orchestrator progression. For a growing number of engineers, AI is already writing 90% of their code (not necessarily the planning and review parts, but still).</p>
<p><img src="https://cdn.hamy.xyz/blog/posts/2026-02_ai-orchestrator-overnight_gardener-cycle.png" alt="AI Gardener lifecycle"/></p>
<p>I keep coming back to the idea of a gardener for what this interaction looks like between human + AI long term:</p>
<ol>
<li><strong>Design</strong> - lay down the scaffolding and architecture of what you want</li>
<li><strong>Plant</strong> - set the agents loose within that design</li>
<li><strong>Leave</strong> - walk away, do other things</li>
<li><strong>Tend</strong> - come back, inspect what grew, fix things, redirect, prune, plant more seeds</li>
</ol>
<p>The gardening metaphor isn&#39;t new - Andy Hunt and Dave Thomas used it for software in <a href="https://blog.codinghorror.com/tending-your-software-garden/">The Pragmatic Programmer</a>. Software is alive, evolving - not a building you construct once. What&#39;s new is that AI makes the unsupervised growth part real. You plant seeds (tasks) and they actually grow (code) while you&#39;re away.</p>
<p>Tending a garden is active work - pruning, directing, protecting. Looking at it another way, it&#39;s basically leadership. As you get more senior this is what you do - set the direction, have people work within it, redirect as necessary.</p>
<p>As I wrote in <a href="https://hamy.xyz/blog/2025-12_software-engineers-ai">If AI can code, what will Software Engineers do?</a>, the tools are changing but what you need to do to stay relevant remains the same: keep building, keep learning, keep sharing, keep experimenting.</p>
<h2 id="next">Next</h2>
<p>We&#39;re early into the AI era of software engineering. The tools are expensive and imperfect, but the pattern is clear - these things can code.</p>
<p>The orchestrator isn&#39;t replacing me completely but it is changing what I do. Less typing code, more designing systems and tending results. That feels like where the puck is going.</p>
<p>If you liked this post you might also like:</p>
<ul>
<li><a href="https://hamy.xyz/blog/2026-01_how-i-think-about-vibe-engineering">How I Think About Writing Quality Software Fast with AI</a></li>
<li><a href="https://hamy.xyz/blog/2026-01_ai-engineering-best-practices">5 AI Coding Best Practices from a Google AI Director</a></li>
<li><a href="https://hamy.xyz/blog/2025-12_ai-is-here-to-stay">AI is Here to Stay</a></li>
</ul>
</div></div>
  </body>
</html>
