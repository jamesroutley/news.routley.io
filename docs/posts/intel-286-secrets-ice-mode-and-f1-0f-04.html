<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rep-lodsb.mataroa.blog/blog/intel-286-secrets-ice-mode-and-f1-0f-04/">Original</a>
    <h1>Intel 286 secrets: ICE mode and F1 0F 04</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
            <p>With some recent interest in undocumented opcodes and microcode on modern Intel chips, I decided to do a proper writeup on what I found out while researching and playing around with the venerable 80286 (&#34;Beige Unlock&#34;?).</p>
<p>There will probably be a follow-up part covering the function of the internal registers and slightly-informed speculations about the microcode!</p>

<p>The documentation for the &#39;286s <code>LOADALL</code> instruction - which Intel only made available under NDA back in the day - briefly mentions how it is used during automated testing of every produced chip (and is thus guaranteed to work). But its other purpose was kept secret: to support In-Circuit Emulation (ICE).</p>
<p>An ICE is a very expensive device that plugs into the CPU socket and &#34;emulates&#34; the chip while providing debugging functionality. This is not at all like the kind of software emulation familiar today, or even using a modern microcontroller to emulate 30+ year old hardware: it needs to run at the same speed and interact with external hardware in exactly the same way as the chip it replaces, using technology available at the time when the 286 was still in production.</p>
<p>Not-so-shockingly, the way they did it was to use an actual 286 chip to &#34;emulate&#34; itself, with some extra pins to allow the debugging hardware to monitor it and take control. This debug interface uses the 5 pins left unused on the 286 package. The only public description of these comes from a <a href="https://www.freepatentsonline.com/4442484.pdf" title="US4442484 - Microprocessor memory management and protection mechanism">patent</a>.</p>
<p>Putting the pieces together:</p>
<ul>
<li><code>ICE31</code> &amp; <code>ICE20</code> (output, pin 55/56)</li>
</ul>
<p>Output the length in bytes of the current instruction, with each half of the bits multiplexed on even/odd cycles (every instruction takes at least two to execute). This allows the external breakpoint logic to keep track of the instruction queue.</p>
<ul>
<li><code>ICEBP#</code> (input, pin 58)</li>
</ul>
<p>Signals a breakpoint. The CPU will save its state and enter a mode in which debugging code can run from its own isolated address space. The <code>LOADALL</code> instruction will restore the saved state and exit from ICE mode.</p>
<ul>
<li><code>ICES1#</code> &amp; <code>ICES0#</code> (output, pin 2/3)</li>
</ul>
<p>These are the control lines for ICE bus cycles, with the normal S1/S0 idle. The address and data lines used are the same, but the ICE hardware will disconnect them from the main bus.</p>
<p>On most 286 chips you can find, these pins are not bonded to the pads on the die. For some reason, Intel was very concerned about not making this functionality available for anyone else to use. In an amendment to their second-source agreement with AMD in 1984, they required them to not make it available either!</p>
<p>Then ICE mode evolved into SMM, and AMD <a href="https://ir.amd.com/sec-filings/content/0000898430-94-000804/EX-99_1.txt">got sued</a> when they produced their own 486 chips which exposed this now documented feature.</p>

<p><code>LOADALL</code> became one of the most well-known &#34;secret&#34; opcodes. But there was another one right next to it that remained mysterious. In some old textfiles, you can find the claim that 0F04 is &#34;likely to be an alias for <code>LOADALL</code>&#34; (0F05), and also that F1 is either an alias for <code>LOCK</code>, or the <code>INT1</code> / <code>ICEBP</code> instruction as on later chips.</p>
<p>This theory was based on the observation of how the 8086 handled invalid opcodes - it would interpret them as some other instruction, because Intel made some bits in the instruction decoder &#34;don&#39;t care&#34;s; this might have been the easiest way to make the CPU behave predictably if it encountered one of these opcodes, and there wasn&#39;t enough space in microcode ROM to cause an exception instead. And F1 on that chip was an alias for the <code>LOCK</code> prefix (F0).</p>
<p>However, next came the 80186 (rarely found in PCs), which already had an invalid opcode exception, and did trigger it on opcode F1! So, if the 286 doesn&#39;t do that, it must have become a valid-but-undocumented opcode. And it doesn&#39;t cause interrupt 1 either, so not ICEBP?</p>
<p>And 0F04 definitely does something different than <code>LOADALL</code>. There are plenty of working examples (including production code) using the <code>LOADALL</code> instruction, and substituting opcode 0F04 in them will always have the same effect: it causes the processor to lock up until it is reset.</p>
<p>This may look like a similar case as the <a href="https://en.wikipedia.org/wiki/F00F_bug">Pentium F00F bug</a>, but 0F04 is a privileged instruction that can only be executed in ring 0 or real mode. And being right next to the also undocumented <code>LOADALL</code>, it might be related. Perhaps doing the opposite and saving the entire CPU state, except for some reason it doesn&#39;t work?</p>

<p>Now remember that <code>LOADALL</code> not only restores the processor&#39;s state, but also exits from ICE mode. So if its counterpart instruction were to <em>enter</em> ICE mode, what would happen? After completing the instruction, the CPU would start to fetch code from the separate ICE address space, using the two extra bus control pins that aren&#39;t connected to anything (and likely can&#39;t be since they aren&#39;t exposed). It would simply wait forever for a response.</p>
<p>Regaining control is possible thanks to the keyboard controller, which has a command to pulse the CPU reset line. It is also notoriously slow, which works in our favour here: after sending the reset command, the CPU still has time to do something before it gets reset.</p>
<p>I was quite hopeful when I first tried this out... but nothing got written to memory.</p>
<p>Thinking more about it, it makes sense that the CPU state would <em>also</em> be saved to ICE memory. <code>LOADALL</code> can of course be used outside of ICE mode, and will then load the state from the normal address space, but if it always did that, it would defeat the purpose of ICE mode being isolated from the code that is being debugged.</p>
<p>So, if that opcode does in fact enter ICE mode, it would do so <em>before</em> saving the state, and would thus be unusable on a normal chip. Sad!</p>

<p>But what about the other undocumented opcode F1? It doesn&#39;t seem to do anything, but acts like a prefix to whatever instruction follows it. So I got an idea: could it have an effect on 0F04?</p>
<p>Well, it still hangs - but it does indeed dump the CPU state to memory first, including internal registers in the 10 &#34;unused&#34; <code>WORD</code>s! </p>
<p>I first posted about this on the VCFed.org forums in 2019, and someone there pointed out that there is one Intel document - about emulating the 286 <code>LOADALL</code> opcode using the different one provided on the 386 - that mentions the existence of a &#34;<code>STOREALL</code>&#34; instruction, but not its opcode. So apparently that is its official name.</p>
<p>There is another document which describes F1 as a no-op prefix, but does not give it a name (it also brazenly lies about opcode D6 doing nothing).</p>
<p>What F1 appears to be is the equivalent of <code>UMOV</code> on later processors, a way to access user memory from ICE mode. Maybe call it <code>UMPF</code>?</p>
<p>Outside of ICE mode, it does nothing - with the single exception of <code>STOREALL</code>, and that is likely an unintended effect that Intel wasn&#39;t even aware of.</p>

<p>Sometimes when running my test code, it didn&#39;t work and froze up so badly that the CPU didn&#39;t respond to reset anymore. On the machine I first tried it, this happened randomly and sometimes it did also write to both memory and I/O space, turning on the speaker or changing the timer tick frequency.</p>
<p>On another machine I had available, it always locked up when the prefix was present (with just 0F04 the reset did work, but of course nothing would be written to memory). </p>
<p>I finally got it to work reliably on both by disabling DRAM refresh during the critical time. My guess is that since the ICE hardware would normally disconnect it from the bus, the CPU doesn&#39;t bother to do that itself if anything else requests access while it is saving the state. Maybe I was lucky it didn&#39;t <em>literally</em> Halt And Catch Fire.</p>

<p>I couldn&#39;t find any code for Intel&#39;s ICE product, but very recently I stumbled on a reference to the HP 64000 series in an old AMD 286 manual, and found a CD image on bitsavers.org containing firmware for the different chips it can be used with. The files are in a custom binary format with records somewhat similar to Intel Hex. To make it more confusing, the monitor code which would be run in ICE mode is embedded inside of the host firmware (non-x86 from the looks of it) using a slightly different format.</p>
<p>That took a few hours to make sense of :)</p>
<p>Disassembling the code confirmed that ICE mode is entered at F000:FFF0, the same as after a normal CPU reset. The F1 prefix, as expected, is used to access user memory.</p>
<p><code>STOREALL</code>, on the other hand, is used for a surprising purpose: as part of the sequence to <em>exit</em> from ICE mode! The reason is that it is the <em>only</em> instruction capable of exiting protected mode, acting very much like a reset.</p>
<p>Why would the monitor code need to exit from protected mode? Well, it has to be able to inspect and modify user memory anywhere, not just in the first megabyte (-ish) accessible from real mode. Since it can&#39;t use <code>LOADALL</code> to load arbitrary segment bases (as that instruction also exits ICE mode), it has to run in protected mode.</p>
<p>So, the &#34;return to user code&#34; subroutine first checks if user was also in protected mode. In that case it can return using <code>LOADALL</code> immediately. Else, it executes <code>STOREALL</code> in order to re-enter the monitor in real mode, setting a flag that tells the entry code to do the return instead of entering protected mode.</p>
<p>The state saving of <code>STOREALL</code> is not at all desired for this, and makes it necessary to copy the actual user state to another buffer first. &#34;Braindead chip&#34; indeed.</p>
        </div></div>
  </body>
</html>
