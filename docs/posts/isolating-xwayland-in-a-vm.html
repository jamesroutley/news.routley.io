<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://roscidus.com/blog/blog/2021/10/30/xwayland/">Original</a>
    <h1>Isolating Xwayland in a VM</h1>
    
    <div id="readability-page-1" class="page"><div>
              <p>In my last post, <a href="https://thewitchofendor.com/blog/blog/2021/03/07/qubes-lite-with-kvm-and-wayland/">Qubes-lite with KVM and Wayland</a>, I described setting up a Qubes-inspired Linux system that runs applications in virtual machines. A Wayland proxy running in each VM connects its applications to the host Wayland compositor over virtwl, allowing them to appear on the desktop alongside normal host applications. In this post, I extend this to support X11 applications using Xwayland.</p>
<!-- more -->
<p><strong>Table of Contents</strong></p>
<ul id="markdown-toc">
<li><a href="#overview">Overview</a>
</li>
<li><a href="#introduction-to-x11">Introduction to X11</a>
</li>
<li><a href="#running-xwayland">Running Xwayland</a>
</li>
<li><a href="#the-x11-protocol">The X11 protocol</a>
</li>
<li><a href="#initialising-the-window-manager">Initialising the window manager</a>
</li>
<li><a href="#windows">Windows</a>
</li>
<li><a href="#performance">Performance</a>
</li>
<li><a href="#pointer-events">Pointer events</a>
</li>
<li><a href="#keyboard-events">Keyboard events</a>
</li>
<li><a href="#pointer-cursor">Pointer cursor</a>
</li>
<li><a href="#selections">Selections</a>
</li>
<li><a href="#drag-and-drop">Drag-and-drop</a>
</li>
<li><a href="#bonus-features">Bonus features</a>
<ul>
<li><a href="#hidpi-works">HiDPI works</a>
</li>
<li><a href="#ring-buffer-logging">Ring-buffer logging</a>
</li>
<li><a href="#vim-windows-open-correctly">Vim windows open correctly</a>
</li>
<li><a href="#copy-and-paste-without-m-characters">Copy-and-paste without ^M characters</a>
</li>
</ul>
</li>
<li><a href="#conclusions">Conclusions</a>
</li>
</ul>
<p>( this post also appeared on <a href="https://news.ycombinator.com/item?id=29645743">Hacker News</a> )</p>
<h2 id="overview">Overview</h2>
<p>A graphical desktop typically allows running multiple applications on a single display
(e.g. by showing each application in a separate window).
Client applications connect to a server process (usually on the same machine) and ask it to display their windows.</p>
<p>Until recently, this service was an <em>X server</em>, and applications would communicate with it using the X11 protocol.
However, on newer systems the display is managed by a <em>Wayland compositor</em>, using the Wayland protocol.</p>
<p>Many older applications haven&#39;t been updated yet.
<a href="https://wayland.freedesktop.org/docs/html/ch05.html">Xwayland</a> can be used to allow unmodified X11 applications to run in a Wayland desktop environment.
However, setting this up wasn&#39;t as easy as I&#39;d hoped.
Ideally, Xwayland would completely isolate the Wayland compositor from needing to know anything about X11:</p>
<p><span><img src="https://thewitchofendor.com/blog/images/xwayland/fantasy-xwayland.png" title="Fantasy Xwayland architecture"/><span>Fantasy Xwayland architecture</span></span></p>
<p>However, it doesn&#39;t work like this.
Xwayland handles X11 drawing operations, but it doesn&#39;t handle lots of other details, including window management (e.g. telling the Wayland compositor what the window title should be), copy-and-paste, and selections.
Instead, the Wayland compositor is supposed to connect back to Xwayland over the X11 protocol and act as an X11 window manager to provide the missing features:</p>
<p><span><img src="https://thewitchofendor.com/blog/images/xwayland/real-xwayland.png" title="Actual Xwayland architecture"/><span>Actual Xwayland architecture</span></span></p>
<p>This is a problem for several reasons:</p>
<ol>
<li>It means that every Wayland compositor has to implement not only the new Wayland protocol, but also the old X11 protocol.
</li>
<li>The compositor is part of the trusted computing base (it sees all your keystrokes and window contents)
and this adds a whole load of legacy code that you&#39;d need to audit to have confidence in it.
</li>
<li>It doesn&#39;t work when running applications in VMs,
because each VM needs its own Xwayland service and existing compositors can only manage one.
</li>
</ol>
<p>Because Wayland (unlike X11) doesn&#39;t allow applications to mess with other applications&#39; windows,
we can&#39;t have a third-party application act as the X11 window manager.
It wouldn&#39;t have any way to ask the compositor to put Xwayland&#39;s surfaces into a window frame, because Xwayland is a separate application.</p>
<p>There is another way to do it, however.
As I mentioned in the last post,
I already had to write a Wayland proxy (<a href="https://github.com/talex5/wayland-proxy-virtwl">wayland-proxy-virtwl</a>) to run in each VM
and relay Wayland messages over virtwl, so I decided to extend it to handle Xwayland too.
As a bonus, the proxy can also be used even without VMs, avoiding the need for any X11 support in Wayland compositors at all.
In fact, I found that doing this avoided several bugs in Sway&#39;s built-in Xwayland support.</p>
<p><a href="https://chromium.googlesource.com/chromiumos/platform2/+/refs/heads/main/vm_tools/sommelier/">Sommelier</a> already has support for this, but it doesn&#39;t work for the applications I want to use.
For example, popup menus appear in the center of the screen, text selections don&#39;t work, and it generally crashes after a few seconds (often with the error <code>xdg_surface has never been configured</code>).
So instead I&#39;d been using <code>ssh -Y vm</code> from the host to forward X11 connections to the host&#39;s Xwayland,
managed by Sway.
That works, but it&#39;s not at all secure.</p>
<h2 id="introduction-to-x11">Introduction to X11</h2>
<p>Unlike Wayland, where applications are mostly unaware of each other, X is much more collaborative.
The X server maintains a tree of windows (rectangles) and the applications manipulate it.
The root of the tree is called the <em>root window</em> and fills the screen.
You can see the tree using the <code>xwininfo</code> command, like this:</p>
<pre><code>$ xwininfo -tree -root

xwininfo: Window id: 0x47 (the root window) (has no name)

  Root window id: 0x47 (the root window) (has no name)
  Parent window id: 0x0 (none)
     9 children:
     0x800112 &#34;~/Projects/wayland/wayland-proxy-virtwl&#34;: (&#34;ROX-Filer&#34; &#34;ROX-Filer&#34;)  2184x2076+0+0  +0+0
        1 child:
        0x800113 (has no name): ()  1x1+-1+-1  +-1+-1
     0x800123 (has no name): ()  1x1+-1+-1  +-1+-1
     0x800003 &#34;ROX-Filer&#34;: ()  10x10+-100+-100  +-100+-100
     0x800001 &#34;ROX-Filer&#34;: (&#34;ROX-Filer&#34; &#34;ROX-Filer&#34;)  10x10+10+10  +10+10
        1 child:
        0x800002 (has no name): ()  1x1+-1+-1  +9+9
     0x600002 &#34;main.ml (~/Projects/wayland/wayland-proxy-virtwl) - GVIM1&#34;: (&#34;gvim&#34; &#34;Gvim&#34;)  1648x1012+0+0  +0+0
        1 child:
        0x600003 (has no name): ()  1x1+-1+-1  +-1+-1
     0x600007 (has no name): ()  1x1+-1+-1  +-1+-1
     0x600001 &#34;Vim&#34;: (&#34;gvim&#34; &#34;Gvim&#34;)  10x10+10+10  +10+10
     0x200002 (has no name): ()  1x1+0+0  +0+0
     0x200001 (has no name): ()  1x1+0+0  +0+0
</code></pre>
<p>This tree shows the windows of two X11 applications, ROX-Filer and GVim,
as well as various invisible utility windows (mostly 1x1 or 10x10 pixels in size).</p>
<p>Applications can create, move, resize and destroy windows, draw into them, and request events from them.
The X server also allows arbitrary data to be attached to windows in <em>properties</em>.
You can see a window&#39;s properties with <code>xprop</code>. Here are some of the properties on the GVim window:</p>
<pre><code>$ xprop -id 0x600002
WM_HINTS(WM_HINTS):
		Client accepts input or input focus: True
		Initial state is Normal State.
		window id # of group leader: 0x600001
_NET_WM_WINDOW_TYPE(ATOM) = _NET_WM_WINDOW_TYPE_NORMAL
WM_NORMAL_HINTS(WM_SIZE_HINTS):
		program specified minimum size: 188 by 59
		program specified base size: 188 by 59
		window gravity: NorthWest
WM_CLASS(STRING) = &#34;gvim&#34;, &#34;Gvim&#34;
WM_NAME(STRING) = &#34;main.ml (~/Projects/wayland/wayland-proxy-virtwl) - GVIM1&#34;
...
</code></pre>
<p>The X server itself doesn&#39;t know anything about e.g. window title bars.
Instead, a <em>window manager</em> process connects and handles that.
A window manager is just another X11 application.
It asks to be notified when an application tries to show (&#34;map&#34;) a window inside the root,
and when that happens it typically creates a slightly larger window (with room for the title bar, etc)
and moves the other application&#39;s window inside that.</p>
<p>This design gives X a lot of flexibility.
All kinds of window managers have been implemented, without needing to change the X server itself.
However, it is very bad for security. For example:</p>
<ol>
<li>Open an xterm.
</li>
<li>Use <code>xwininfo</code> to find its window ID (you need the nested child window, not the top-level one).
</li>
<li>Run <code>xev -id 0x80001b -event keyboard</code> in another window (using the ID you got above).
</li>
<li>Use <code>sudo</code> or similar inside <code>xterm</code> and enter a password.
</li>
</ol>
<p>As you type the password into <code>xterm</code>, you should see the characters being captured by <code>xev</code>.
An X application can easily spy on another application, send it synthetic events, etc.</p>
<h2 id="running-xwayland">Running Xwayland</h2>
<p>Xwayland is a version of the <a href="https://www.x.org/wiki/">xorg</a> X server that treats Wayland as its display hardware.
If you run it as e.g. <code>Xwayland :1</code> then it opens a single Wayland window corresponding to the X root window,
and you can use it as a nested desktop.
This isn&#39;t very useful, because these windows don&#39;t fit in with the rest of your desktop.
Instead, it is normally used in <em>rootless</em> mode, where each child of the X root window may have its own Wayland window.</p>
<pre><code>$ WAYLAND_DEBUG=1 Xwayland :1 -rootless
[3991465.523]  -&gt; wl_display@1.get_registry(new id wl_registry@2)
[3991465.531]  -&gt; wl_display@1.sync(new id wl_callback@3)
...
</code></pre>
<p>When run this way, however, no windows actually appear.
If we run <code>DISPLAY=:1 xterm</code> then we see Xwayland creating some buffers, but no surfaces:</p>
<pre><code>[4076460.506]  -&gt; wl_shm@4.create_pool(new id wl_shm_pool@15, fd 9, 540)
[4076460.520]  -&gt; wl_shm_pool@15.create_buffer(new id wl_buffer@24, 0, 9, 15, 36, 0)
[4076460.526]  -&gt; wl_shm_pool@15.destroy()
...
</code></pre>
<p>We need to run Xwayland as <code>Xwayland :1 -rootless -wm FD</code>, where FD is a socket we will use to speak the X11 protocol and act as a window manager.</p>
<p>It&#39;s a little hard to find information about Xwayland&#39;s rootless mode, because &#34;rootless&#34; has two separate common meanings in xorg:</p>
<ol>
<li>Running xorg without root privileges.
</li>
<li>Using xorg&#39;s miext/rootless extension to display application windows on some other desktop.
</li>
</ol>
<p>After a while, it became clear that Xwayland&#39;s rootless mode isn&#39;t either of these, but a third xorg feature also called &#34;rootless&#34;.</p>
<h2 id="the-x11-protocol">The X11 protocol</h2>
<p><a href="https://xcb.freedesktop.org/">libxcb</a> provides C bindings to the X11 protocol, but I wanted to program in OCaml.
Luckily, the <a href="https://www.x.org/releases/X11R7.7/doc/xproto/x11protocol.html">X11 protocol</a> is well documented, and generating the messages directly didn&#39;t look any harder than binding libxcb,
so I wrote a little OCaml library to do this (<a href="https://github.com/talex5/wayland-proxy-virtwl/blob/master/x11/x11.mli">ocaml-x11</a>).</p>
<p>At first, I hard-coded the messages. For example, here&#39;s the code to delete a property on a window:</p>
<figure><div><table><tbody><tr><td><pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
</pre></td><td><pre><code><span><span>module</span> <span>Delete</span> <span>=</span> <span>struct</span>
</span><span>  <span>[%%</span><span>cstruct</span>
</span><span>    <span>type</span> <span>req</span> <span>=</span> <span>{</span>
</span><span>      <span>window</span> <span>:</span> <span>uint32_t</span><span>;</span>
</span><span>      <span>property</span> <span>:</span> <span>uint32_t</span><span>;</span>
</span><span>    <span>}</span> <span>[@@</span><span>little_endian</span><span>]</span>
</span><span>  <span>]</span>
</span><span>
</span><span>  <span>let</span> <span>send</span> <span>t</span> <span>window</span> <span>property</span> <span>=</span>
</span><span>    <span>Request</span><span>.</span><span>send_only</span> <span>t</span> <span>~</span><span>major</span><span>:</span><span>19</span> <span>sizeof_req</span> <span>@@</span> <span>fun</span> <span>r</span> <span>-&gt;</span>
</span><span>    <span>set_req_window</span> <span>r</span> <span>window</span><span>;</span>
</span><span>    <span>set_req_property</span> <span>r</span> <span>property</span>
</span><span><span>end</span>
</span></code></pre></td></tr></tbody></table></div></figure><p>I&#39;m using the <a href="https://github.com/mirage/ocaml-cstruct">cstruct</a> syntax extension to let me define the exact layout of the message body.
Here, it generates <code>sizeof_req</code>, <code>set_req_window</code> and <code>set_req_property</code> automatically.</p>
<p>After a bit, I discovered that there are XML files in <a href="https://gitlab.freedesktop.org/xorg/proto/xcbproto">xcbproto</a> describing the X11 protocol.
This provides a Python library for parsing the XML,
which you can use by writing a Python script for your language of choice.
For example, this <a href="https://gitlab.freedesktop.org/xorg/lib/libxcb/-/blob/master/src/c_client.py">glorious 3394 line Python script</a>
generates the C bindings.
After studying this script carefully, I decided that hard-coding everything wasn&#39;t so bad after all.</p>
<p>I ended up having to implement more messages than I expected,
including some surprising ones like <code>OpenFont</code> (see <a href="https://github.com/talex5/wayland-proxy-virtwl/blob/master/x11/x11.mli">x11.mli</a> for the final list).
My implementation came to 1754 lines of OCaml,
which is quite a bit shorter than the Python generator script,
so I guess I still came out ahead!</p>
<p>In the X11 protocol, client applications send <em>requests</em> and the server sends <em>replies</em>, <em>errors</em> and <em>events</em>.
Most requests don&#39;t produce replies, but can produce errors.
Replies and errors are returned immediately, so if you see a response to a later request, you know all previous ones succeeded.
If you care about whether a request succeeded, you may need to send a dummy message that generates a reply after it.
Since message sequence numbers are 16-bit, after sending 0xffff consecutive requests without replies,
you should send a dummy one with a reply to resynchronise
(but window management involves lots of round-trips, so this isn&#39;t likely to be a problem for us).
Events can be sent by the server at any time.</p>
<p>Unlike Wayland, which is very regular, X11 has various quirks.
For example, every event has a sequence number at offset 2, except for <code>KeymapNotify</code>.</p>
<h2 id="initialising-the-window-manager">Initialising the window manager</h2>
<p>Using <code>Xwayland -wm FD</code> actually prevents any client applications from connecting at all at first,
because Xwayland then waits for the window manager to be ready before accepting any client connections.</p>
<p>To fix that, we need to claim ownership of the <code>WM_S0</code> <em>selection</em>.
A &#34;selection&#34; is something that can be owned by only one application at a time.
Selections were originally used to track ownership of the currently-selected text, and later also used for the clipboard.
<code>WM_S0</code> means &#34;Window Manager for Screen 0&#34; (Xwayland only has one screen).</p>
<figure><div><table><tbody><tr><td><pre><span>1</span>
<span>2</span>
<span>3</span>
</pre></td><td><pre><code><span><span>(* Become the window manager. This allows other clients to connect. *)</span>
</span><span><span>let</span><span>*</span> <span>wm_sn</span> <span>=</span> <span>intern</span> <span>t</span> <span>~</span><span>only_if_exists</span><span>:</span><span>false</span> <span>(</span><span>&#34;WM_S&#34;</span> <span>^</span> <span>string_of_int</span> <span>i</span><span>)</span> <span>in</span>
</span><span><span>X11</span><span>.</span><span>Selection</span><span>.</span><span>set_owner</span> <span>x11</span> <span>~</span><span>owner</span><span>:(</span><span>Some</span> <span>root</span><span>)</span> <span>~</span><span>timestamp</span><span>:`</span><span>CurrentTime</span> <span>wm_sn</span>
</span></code></pre></td></tr></tbody></table></div></figure><p>Instead of passing things like <code>WM_S0</code> as strings in each request, X11 requires us to first <em>intern</em> the string.
This returns a unique 32-bit ID for it, which we use in future messages.
Because <code>intern</code> may require a round-trip to the server, it returns a promise,
and so we use <code>let*</code> instead of <code>let</code> to wait for that to resolve before continuing.
<code>let*</code> is defined in the <code>Lwt.Syntax</code> module, as an alternative to the more traditional <code>&gt;&gt;=</code> notation.</p>
<p>This lets our clients connect. However, Xwayland still isn&#39;t creating any Wayland surfaces.
By reading the Sommelier code and stepping through Xwayland with a debugger, I found that I needed to enable the <a href="https://www.x.org/wiki/guide/extensions/">Composite</a> extension.</p>
<p>Composite was originally intended to speed up redraw operations, by having the server keep a copy of every top-level window&#39;s pixels
(even when obscured), so that when you move a window it can draw it right away without asking the application for help.
The application&#39;s drawing operations go to the window&#39;s buffer, and then the buffer is copied to the screen, either automatically by the X server
or manually by the window manager.
Xwayland reuses this mechanism, by turning each window buffer into a Wayland surface.
We just need to turn that on:</p>
<figure><div><table><tbody><tr><td><pre><span>1</span>
<span>2</span>
</pre></td><td><pre><code><span><span>let</span><span>*</span> <span>composite</span> <span>=</span> <span>X11</span><span>.</span><span>Composite</span><span>.</span><span>init</span> <span>x11</span> <span>in</span>
</span><span><span>let</span><span>*</span> <span>()</span> <span>=</span> <span>X11</span><span>.</span><span>Composite</span><span>.</span><span>redirect_subwindows</span> <span>composite</span> <span>~</span><span>window</span><span>:</span><span>root</span> <span>~</span><span>update</span><span>:`</span><span>Manual</span> <span>in</span>
</span></code></pre></td></tr></tbody></table></div></figure><p>This says that every child of the root window should use this system.
Finally, we see Xwayland creating Wayland surfaces:</p>
<pre><code>-&gt; wl_compositor@5.create_surface id:+28
</code></pre>
<p>Now we just need to make them appear on the screen!</p>
<h2 id="windows">Windows</h2>
<p>As usual for Wayland, we need to create a role object and attach it to the surface.
This tells Wayland whether the surface is a window or a dialog, for example, and lets us set the title, etc.</p>
<p>But first we have a problem: we need to know which X11 window corresponds to each Wayland surface.
For example, we need the title, which is stored in a property on the X11 window.
Xwayland does this by sending the new window a <em>ClientMessage</em> event of type <code>WL_SURFACE_ID</code> containing the Wayland ID.
We don&#39;t get this message by default, but it seems that selecting <code>SubstructureRedirect</code> on the root does the trick.</p>
<p><code>SubstructureRedirect</code> is used by window managers to intercept attempts by other applications to change the children of the root window.
When an application asks the server to e.g. map a window, the server just forwards the request to the window manager.
Operations performed by the window manager itself do not get redirected, so it can just perform the same request the client wanted, or
make any changes it requires.</p>
<p>In our case, we don&#39;t actually need to modify the request, so we just re-perform the original <code>map</code> operation:</p>
<figure><div><table><tbody><tr><td><pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
</pre></td><td><pre><code><span><span>let</span> <span>event_handler</span> <span>=</span> <span>object</span> <span>(_</span> <span>:</span> <span>X11</span><span>.</span><span>Event</span><span>.</span><span>handler</span><span>)</span>
</span><span>  <span>method</span> <span>map_request</span> <span>~</span><span>window</span> <span>=</span> <span>X11</span><span>.</span><span>Window</span><span>.</span><span>map</span> <span>x11</span> <span>window</span>
</span><span>
</span><span>  <span>method</span> <span>client_message</span> <span>~</span><span>window</span> <span>~</span><span>ty</span> <span>body</span> <span>=</span>
</span><span>      <span>if</span> <span>ty</span> <span>=</span> <span>wl_surface_id</span> <span>then</span> <span>(</span>
</span><span>        <span>let</span> <span>wayland_id</span> <span>=</span> <span>Cstruct</span><span>.</span><span>LE</span><span>.</span><span>get_uint32</span> <span>body</span> <span>0</span> <span>in</span>
</span><span>        <span>Log</span><span>.</span><span>info</span> <span>(</span><span>fun</span> <span>f</span> <span>-&gt;</span> <span>f</span> <span>&#34;X window %a corresponds to Wayland surface %ld&#34;</span> <span>X11</span><span>.</span><span>Window</span><span>.</span><span>pp</span> <span>window</span> <span>wayland_id</span><span>);</span>
</span><span>        <span>pair_when_ready</span> <span>~</span><span>x11</span> <span>t</span> <span>window</span> <span>wayland_id</span>
</span><span>      <span>)</span>
</span></code></pre></td></tr></tbody></table></div></figure><p>Having two separate connections to Xwayland is quite annoying, because messages can arrive in any order.
We might get the X11 <code>ClientMessage</code> first and need to wait for the Wayland <code>create_surface</code>, or we might get the <code>create_surface</code> first
and need to wait for the <code>ClientMessage</code>.</p>
<p>An added complication is that not all Wayland surfaces correspond to X11 windows.
For example, Xwayland also creates surfaces representing cursor shapes, and these don&#39;t have X11 windows.
However, when we get the <code>ClientMessage</code> we <em>can</em> be sure that a Wayland message is on the way,
so I just pause the X11 event handling until that has arrived:</p>
<figure><div><table><tbody><tr><td><pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
</pre></td><td><pre><code><span><span>(* We got an X11 message saying X11 [window] corresponds to Wayland surface [wayland_id].</span>
</span><span><span>   Turn [wayland_id] into an xdg_surface. If we haven&#39;t seen that surface yet, wait until it appears</span>
</span><span><span>   on the Wayland socket. *)</span>
</span><span><span>let</span> <span>rec</span> <span>pair_when_ready</span> <span>~</span><span>x11</span> <span>t</span> <span>window</span> <span>wayland_id</span> <span>=</span>
</span><span>  <span>match</span> <span>Hashtbl</span><span>.</span><span>find_opt</span> <span>t</span><span>.</span><span>unpaired</span> <span>wayland_id</span> <span>with</span>
</span><span>  <span>|</span> <span>None</span> <span>-&gt;</span>
</span><span>    <span>Log</span><span>.</span><span>info</span> <span>(</span><span>fun</span> <span>f</span> <span>-&gt;</span> <span>f</span> <span>&#34;Unknown Wayland object %ld; waiting for surface to be created...&#34;</span> <span>wayland_id</span><span>);</span>
</span><span>    <span>let</span><span>*</span> <span>()</span> <span>=</span> <span>Lwt_condition</span><span>.</span><span>wait</span> <span>t</span><span>.</span><span>unpaired_added</span> <span>in</span>
</span><span>    <span>pair_when_ready</span> <span>~</span><span>x11</span> <span>t</span> <span>window</span> <span>wayland_id</span>
</span><span>  <span>|</span> <span>Some</span> <span>{</span> <span>client_surface</span> <span>=</span> <span>_;</span> <span>host_surface</span><span>;</span> <span>set_configured</span> <span>}</span> <span>-&gt;</span>
</span><span>    <span>Log</span><span>.</span><span>info</span> <span>(</span><span>fun</span> <span>f</span> <span>-&gt;</span> <span>f</span> <span>&#34;Setting up Wayland surface %ld using X11 window %a&#34;</span> <span>wayland_id</span> <span>X11</span><span>.</span><span>Xid</span><span>.</span><span>pp</span> <span>window</span><span>);</span>
</span><span>    <span>Hashtbl</span><span>.</span><span>remove</span> <span>t</span><span>.</span><span>unpaired</span> <span>wayland_id</span><span>;</span>
</span><span>    <span>Lwt</span><span>.</span><span>async</span> <span>(</span><span>fun</span> <span>()</span> <span>-&gt;</span> <span>pair</span> <span>t</span> <span>~</span><span>set_configured</span> <span>~</span><span>host_surface</span> <span>window</span><span>);</span>
</span><span>    <span>Lwt</span><span>.</span><span>return_unit</span>
</span></code></pre></td></tr></tbody></table></div></figure><p>Another complication is that Wayland doesn&#39;t allow you to attach a buffer to a surface until the window has been &#34;configured&#34;.
Doing so is a protocol error, and Sway will disconnect us if we try!
But Xwayland likes to attach the buffer immediately after creating the surface.</p>
<p>To avoid this, I use a queue:</p>
<ol>
<li>Xwayland asks to create a surface.
</li>
<li>We forward this to Sway, add its ID to the <code>unpaired</code> map, and create a queue for further events.
</li>
<li>Xwayland asks us to attach a buffer, etc. We just queue these up.
</li>
<li>We get the <code>ClientMessage</code> over the X11 connection and create a role for the new surface.
</li>
<li>Sway sends us a <code>configure</code> event, confirming it&#39;s ready for the buffer.
</li>
<li>We forward the queued events.
</li>
</ol>
<p>However, this creates a new problem: if the surface isn&#39;t a window then the events will be queued forever.
To fix that, when we get a <code>create_surface</code> we also do a round-trip on the X11 connection.
If the window is still unpaired when that returns then we know that no <code>ClientMessage</code> is coming, and we flush the queue.</p>
<p>X applications like to create dummy windows for various purposes (e.g. receiving clipboard data),
and we need to avoid showing those.
They&#39;re normally set as <code>override_redirect</code> so the window manager doesn&#39;t handle them,
but Xwayland redirects them anyway (it needs to because otherwise e.g. tooltips wouldn&#39;t appear at all).
I&#39;m trying various heuristics to detect this, e.g. that override redirect windows with a size of 1x1 shouldn&#39;t be shown.</p>
<p>If Sway asks us to close a window, we need to relay that to the X application using the <code>WM_DELETE_WINDOW</code> protocol,
if it supports that:</p>
<figure><div><table><tbody><tr><td><pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
</pre></td><td><pre><code><span><span>let</span> <span>toplevel</span> <span>=</span> <span>Xdg_surface</span><span>.</span><span>get_toplevel</span> <span>xdg_surface</span> <span>@@</span> <span>object</span>
</span><span>    <span>inherit</span> <span>[_]</span> <span>Xdg_toplevel</span><span>.</span><span>v1</span>
</span><span>
</span><span>    <span>method</span> <span>on_close</span> <span>_</span> <span>=</span>
</span><span>      <span>Lwt</span><span>.</span><span>async</span> <span>(</span><span>fun</span> <span>()</span> <span>-&gt;</span>
</span><span>          <span>let</span><span>*</span> <span>x11</span> <span>=</span> <span>t</span><span>.</span><span>x11</span> <span>in</span>
</span><span>          <span>let</span><span>*</span> <span>wm_protocols</span> <span>=</span> <span>X11</span><span>.</span><span>Atom</span><span>.</span><span>intern</span> <span>x11</span> <span>&#34;WM_PROTOCOLS&#34;</span>
</span><span>          <span>and</span><span>*</span> <span>wm_delete_window</span> <span>=</span> <span>X11</span><span>.</span><span>Atom</span><span>.</span><span>intern</span> <span>x11</span> <span>&#34;WM_DELETE_WINDOW&#34;</span> <span>in</span>
</span><span>          <span>let</span><span>*</span> <span>protocols</span> <span>=</span> <span>X11</span><span>.</span><span>Property</span><span>.</span><span>get_atoms</span> <span>x11</span> <span>window</span> <span>wm_protocols</span> <span>in</span>
</span><span>          <span>if</span> <span>List</span><span>.</span><span>mem</span> <span>wm_delete_window</span> <span>protocols</span> <span>then</span> <span>(</span>
</span><span>            <span>let</span> <span>data</span> <span>=</span> <span>Cstruct</span><span>.</span><span>create</span> <span>8</span> <span>in</span>
</span><span>            <span>Cstruct</span><span>.</span><span>LE</span><span>.</span><span>set_uint32</span> <span>data</span> <span>0</span> <span>(</span><span>wm_delete_window</span> <span>:&gt;</span> <span>int32</span><span>);</span>
</span><span>            <span>Cstruct</span><span>.</span><span>LE</span><span>.</span><span>set_uint32</span> <span>data</span> <span>4</span> <span>0</span><span>l</span><span>;</span>
</span><span>            <span>X11</span><span>.</span><span>Window</span><span>.</span><span>send_client_message</span> <span>x11</span> <span>window</span> <span>~</span><span>fmt</span><span>:</span><span>32</span> <span>~</span><span>propagate</span><span>:</span><span>false</span> <span>~</span><span>event_mask</span><span>:</span><span>0</span><span>l</span> <span>~</span><span>ty</span><span>:</span><span>wm_protocols</span> <span>data</span><span>;</span>
</span><span>          <span>)</span> <span>else</span> <span>(</span>
</span><span>            <span>X11</span><span>.</span><span>Window</span><span>.</span><span>destroy</span> <span>x11</span> <span>window</span>
</span><span>          <span>)</span>
</span><span>        <span>)</span>
</span><span>  <span>end</span>
</span></code></pre></td></tr></tbody></table></div></figure><p>Wayland defaults to using client-side decorations (where the application draws its own window decorations).
X doesn&#39;t do that, so we need to turn it off (if the Wayland compositor supports the decoration manager extension):</p>
<figure><div><table><tbody><tr><td><pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
</pre></td><td><pre><code><span><span>t</span><span>.</span><span>decor_mgr</span> <span>|&gt;</span> <span>Option</span><span>.</span><span>iter</span> <span>(</span><span>fun</span> <span>decor_mgr</span> <span>-&gt;</span>
</span><span>    <span>let</span> <span>decor</span> <span>=</span> <span>Xdg_decor_mgr</span><span>.</span><span>get_toplevel_decoration</span> <span>decor_mgr</span> <span>~</span><span>toplevel</span> <span>@@</span> <span>object</span>
</span><span>        <span>inherit</span> <span>[_]</span> <span>Xdg_decoration</span><span>.</span><span>v1</span>
</span><span>        <span>method</span> <span>on_configure</span> <span>_</span> <span>~</span><span>mode</span><span>:_</span> <span>=</span> <span>()</span>
</span><span>      <span>end</span>
</span><span>    <span>in</span>
</span><span>    <span>Xdg_decoration</span><span>.</span><span>set_mode</span> <span>decor</span> <span>~</span><span>mode</span><span>:</span><span>Xdg_decoration</span><span>.</span><span>Mode</span><span>.</span><span>Server_side</span>
</span><span>  <span>)</span>
</span></code></pre></td></tr></tbody></table></div></figure><p>Dialog boxes are more of a problem.
Wayland requires every dialog box to have a parent window, but X11 doesn&#39;t.
To handle that, the proxy tracks the last window the user interacted with and uses that as a fallback parent
if an X11 window with type <code>_NET_WM_WINDOW_TYPE_DIALOG</code> is created without setting <code>WM_TRANSIENT_FOR</code>.
That could be a problem if the application closes that window, but it seems to work.</p>
<h2 id="performance">Performance</h2>
<p>I noticed a strange problem: scrolling around in GVim had long pauses once a second or so,
corresponding to OCaml GC runs.
This was surprising, as OCaml has a fast incremental garbage collector, and is normally not a problem for interactive programs.
Besides, I&#39;d been using the proxy with the (Wayland) Firefox and xfce4-terminal applications for 6 months without any similar problem.</p>
<p>Using <code>perf</code> showed that Linux was spending a huge amount of time in <code>release_pages</code>.
The problem is that Xwayland was sharing lots of short-lived memory pools with the proxy.
Each time it shares a pool, we have to ask the VM host for a chunk of memory of the same size.
We map both pools into our address space and then copy each frame across
(this is needed because we can&#39;t export guest memory to the host).</p>
<p>Normally, an application shares a single pool and just refers to regions within it, so we just map once at startup and unmap at exit.
But Xwayland was creating, sharing and discarding around 100 pools per second while scrolling in GVim!
Because these pools take up a lot of RAM, OCaml was (correctly) running the GC very fast, freeing them in batches of 100 or so each second.</p>
<p>First, I tried adding a cache of host memory, but that only solved half the problem: freeing the client pool was still slow.</p>
<p>Another option is to unmap the pools as soon as we get the destroy message, to spread the work out.
Annoyingly, OCaml&#39;s standard library doesn&#39;t let you free memory-mapped memory explicitly
(see the <a href="https://github.com/ocaml/ocaml/pull/389">Add BigArray.Genarray.free</a> PR for the current status),
but adding this myself with a bit of C code would have been easy enough.
We only touch the memory in one place (for the copy), so manually checking it hadn&#39;t been freed would have been pretty safe.</p>
<p>Then I noticed something interesting about the repeated log entries, which mostly looked like this:</p>
<pre><code>-&gt; wl_shm@4.create_pool id:+26 fd:(fd) size:8368360
-&gt; wl_shm_pool@26.create_buffer id:+28 offset:0 width:2090 height:1001 stride:8360 format:1
-&gt; wl_shm_pool@26.destroy 
&lt;- wl_display@1.delete_id id:26
-&gt; wl_buffer@28.destroy 
&lt;- wl_display@1.delete_id id:28
</code></pre>
<p>Xwayland creates a pool, allocates a buffer within it, destroys the pool (so it can&#39;t create more buffers), and then deletes the buffer.
But <em>it never uses the buffer for anything</em>!</p>
<p>So the solution was simple: I just made the host buffer allocation and the mapping operations lazy.
We force the mapping if a pool&#39;s buffer is ever attached to a surface, but if not we just close the FD and forget about it.
Would be more efficient if Xwayland only shared the pools when needed, though.</p>
<h2 id="pointer-events">Pointer events</h2>
<p>Wayland delivers pointer events relative to a surface, so we simply forward these on to Xwayland unmodified and everything just works.</p>
<p>I&#39;m kidding - this was the hardest bit! When Xwayland gets a pointer event on a window, it doesn&#39;t send it directly to that window.
Instead, it converts the location to screen coordinates and then pushes the event through the old X event handling mechanism, which looks at the X11 window stack to decide where to send it.</p>
<p>However, the X11 window stack (which we saw earlier with <code>xwininfo -tree -root</code>) doesn&#39;t correspond to the Wayland window layout at all.
In fact, Wayland doesn&#39;t provide us any way to know where our windows are, or how they are stacked.</p>
<p>Sway seems to handle this via a backdoor: X11 applications do get access to location information even though native Wayland clients don&#39;t.
This is one of the reasons I want to get X11 support out of the compositor - I want to make sure X11 apps don&#39;t have any special access.
Sommelier has a solution though: when the pointer enters a window we raise it to the top of the X11 stack. Since it&#39;s the topmost window, it will get the events.</p>
<p>Unfortunately, the raise request goes over the X11 connection while the pointer events go over the Wayland one.
We need to make sure that they arrive in the right order.
If the computer is running normally, this isn&#39;t much of a problem,
but if it&#39;s swapping or otherwise struggling it could result in events going to the wrong place
(I temporarily added a 2-second delay to test this).
This is what I ended up with:</p>
<ol>
<li>Get a wayland pointer enter event from Sway.
</li>
<li>Pause event delivery from Sway.
</li>
<li>Flush any pending Wayland events we previously sent to Xwayland by doing a round-trip on the Wayland connection.
</li>
<li>Send a raise on the X11 connection.
</li>
<li>Do a round-trip on the X11 connection to ensure the raise has completed.
</li>
<li>Forward the enter event on the Wayland connection.
</li>
<li>Unpause the event stream from Sway.
</li>
</ol>
<p>At first I tried queuing up just the pointer events,
but that doesn&#39;t work because e.g. keyboard events need to be synchronised with pointer events.
Otherwise, if you e.g. Shift-click on something then the click gets delayed but the Shift doesn&#39;t and it can do the wrong thing.
Also, Xwayland might ask Sway to destroy the window while we&#39;re entering it, and Sway might confirm the deletion.
Pausing the whole event stream from Sway fixes all these problems.</p>
<p>The next problem was how to do the two round-trips.
For X11 we just send an <code>Intern</code> request after the raise and wait to get a reply to that.
Wayland provides the <code>wl_display.sync</code> method to clients, but we&#39;re acting as a Wayland server to Xwayland,
not a client.
I remembered that Wayland&#39;s xdg-shell extension provides a ping from the server to the client
(the compositor can use this to detect when an application is not responding).
Unfortunately, Xwayland has no reason to use this extension because it doesn&#39;t deal with window roles.
Luckily, it uses it anyway (it does need it for non-rootless mode and doesn&#39;t bother to check).</p>
<p><code>wl_display.sync</code> works by creating a fresh callback object, but xdg-shell&#39;s <code>ping</code> just sends a <code>pong</code> event to a fixed object,
so we also need a queue to keep track of pings in flight so we don&#39;t get confused between our pings and any pings we&#39;re relaying for Sway.
Also, xdg-shell&#39;s ping requires a serial number and we don&#39;t have one.
But since Xwayland is the only app this needs to support, and it doesn&#39;t look at that, I cheat and just send zero.</p>
<p>And that&#39;s how to get pointer events to go to the right window with Xwayland.</p>
<h2 id="keyboard-events">Keyboard events</h2>
<p>A very similar problem exists with the keyboard.
When Wayland says the focus has entered a window
we need to send a <code>SetInputFocus</code> over the X11 connection
and then send the keyboard events over the Wayland one,
requiring another two round-trips to synchronise the two connections.</p>
<h2 id="pointer-cursor">Pointer cursor</h2>
<p>Some applications set their own pointer shape, which works fine.
But others rely on the default and for some reason you get no cursor at all in that case.
To fix it, you need to set a cursor on the root window, which applications will then inherit by default.
Unlike Wayland, where every application provides its own cursor bitmaps,
X very sensibly provides a standard set of cursors, in a font called <code>cursor</code>
(this is why I had to implement <code>OpenFont</code>).
As cursors have two colours and a mask, each cursor is two glyphs: even numbered glyphs are the image and the following glyph is its mask:</p>
<figure><div><table><tbody><tr><td><pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
</pre></td><td><pre><code><span><span>(* Load the default cursor image *)</span>
</span><span><span>let</span><span>*</span> <span>cursor_font</span> <span>=</span> <span>X11</span><span>.</span><span>Font</span><span>.</span><span>open_font</span> <span>x11</span> <span>&#34;cursor&#34;</span> <span>in</span>
</span><span><span>let</span><span>*</span> <span>default_cursor</span> <span>=</span> <span>X11</span><span>.</span><span>Font</span><span>.</span><span>create_glyph_cursor</span> <span>x11</span>
</span><span>    <span>~</span><span>source_font</span><span>:</span><span>cursor_font</span> <span>~</span><span>mask_font</span><span>:</span><span>cursor_font</span>
</span><span>    <span>~</span><span>source_char</span><span>:</span><span>68</span> <span>~</span><span>mask_char</span><span>:</span><span>69</span>
</span><span>    <span>~</span><span>bg</span><span>:(</span><span>0xffff</span><span>,</span> <span>0xffff</span><span>,</span> <span>0xffff</span><span>)</span>
</span><span>    <span>~</span><span>fg</span><span>:(</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span>
</span><span><span>in</span>
</span><span><span>X11</span><span>.</span><span>Window</span><span>.</span><span>create_attributes</span> <span>~</span><span>cursor</span><span>:</span><span>default_cursor</span> <span>()</span>
</span><span><span>|&gt;</span> <span>X11</span><span>.</span><span>Window</span><span>.</span><span>change_attributes</span> <span>x11</span> <span>root</span>
</span></code></pre></td></tr></tbody></table></div></figure><h2 id="selections">Selections</h2>
<p>The next job was to get copying text between X and Wayland working.</p>
<p>In X11:</p>
<ul>
<li>When you select something, the application takes ownership of the <code>PRIMARY</code> selection.
</li>
<li>When you click the middle button or press Shift-Insert, the application requests <code>PRIMARY</code>.
</li>
<li>When you press Ctrl-C, the application takes ownership of the <code>CLIPBOARD</code> selection.
</li>
<li>When you press Ctrl-V it requests <code>CLIPBOARD</code>.
</li>
</ul>
<p>It&#39;s quite neat that adding support for a Windows-style clipboard didn&#39;t require changing the X server at all.
Good forward-thinking design there.</p>
<p>In Wayland, things are not so simple.
I have so far found no less than four separate Wayland protocols for copying text:</p>
<ol>
<li><code>gtk_primary_selection</code> supports copying the primary selection, but not the clipboard.
</li>
<li><code>wp_primary_selection_unstable_v1</code> is identical to <code>gtk_primary_selection</code> except that it renames everything.
</li>
<li><code>wl_data_device_manager</code> supports clipboard transfers but not the primary selection.
</li>
<li><code>zwlr_data_control_manager_v1</code> supports both, but it&#39;s for a &#34;privileged client&#34; to be a clipboard manager.
</li>
</ol>
<p><code>gtk_primary_selection</code> and <code>wl_data_device_manager</code> both say they&#39;re stable, while the other two are unstable.
However, Sway dropped support for <code>gtk_primary_selection</code> a while ago, breaking many applications
(luckily, I had a handy Wayland proxy and was able to add some adaptor code
to route <code>gtk_primary_selection</code> messages to the new &#34;unstable&#34; protocol).</p>
<p>For this project, I went with <code>wp_primary_selection_unstable_v1</code> and <code>wl_data_device_manager</code>.
On the Wayland side, everything has to be written twice for the two protocols, which are almost-but-not-quite the same.
In particular, <code>wl_data_device_manager</code> also has a load of drag-and-drop stuff you need to ignore.</p>
<p>For each selection (<code>PRIMARY</code> or <code>CLIPBOARD</code>), we can be in one of two states:</p>
<ul>
<li>An X11 client owns the selection (and we own the Wayland selection).
</li>
<li>A Wayland client owns the selection (and we own the X11 selection).
</li>
</ul>
<p>When we own a selection we proxy requests for it to the matching selection on the other protocol.</p>
<ul>
<li>At startup, we take ownership of the X11 selection, since there are no X11 apps running yet.
</li>
<li>When we lose the X11 selection it means that an X11 client now owns it and we take the Wayland selection.
</li>
<li>When we lose the Wayland selection it means that a Wayland client now owns it and we take the X11 selection.
</li>
</ul>
<p>One good thing about the Wayland protocols is that you send the data by writing it to a normal Unix pipe.
For X11, we need to write the data to a property on the requesting application&#39;s window and then notify it about the data.
And we may need to split it into multiple chunks if there&#39;s a lot of data to transfer.</p>
<p>A strange problem I had was that, while pasting into GVim worked fine, xterm would segfault shortly after trying to paste into it.
This turned out to be a bug in the way I was sending the notifications.
If an X11 application requests the special <code>TEXT</code> target, it means that the sender should choose the exact format.
You write the property with the chosen type (e.g. <code>UTF8_STRING</code>),
but you must still send the notification with the target <code>TEXT</code>.
xterm is a C application (thankfully no longer set-uid!) and seems to have a use-after-free bug in the timeout code.</p>
<h2 id="drag-and-drop">Drag-and-drop</h2>
<p>Sadly, I wasn&#39;t able to get this working at all.
X itself doesn&#39;t know anything about drag-and-drop and instead applications look at the window tree to decide where the user dropped things.
This doesn&#39;t work with the proxy, because Wayland doesn&#39;t tell us where the windows really are on the screen.</p>
<p>Even without any VMs or proxies, drag-and-drop from X applications to Wayland ones doesn&#39;t work,
because the X app can&#39;t see the Wayland window and the drop lands on the X window below (if any).</p>
<h2 id="bonus-features">Bonus features</h2>
<p>In the last post, I mentioned several other problems, which have also now been solved by the proxy:</p>
<h3 id="hidpi-works">HiDPI works</h3>
<p>Wayland&#39;s support for high resolution screens is a bit strange.
I would have thought that applications really only need to know two things:</p>
<ol>
<li>The size in pixels of the window.
</li>
<li>The size in pixels you want some standard thing (e.g. a normal-sized letter M).
</li>
</ol>
<p>Some systems instead provide the size of the window and the DPI (dots-per-inch),
but this doesn&#39;t work well.
For example, a mobile phone might be high DPI but still want small text because you hold it close to your face,
while a display board will have very low DPI but want large text.</p>
<p>Wayland instead redefines the idea of pixel to be a group of pixels corresponding to a single pixel on a typical 1990&#39;s display.
So if you set your scale factor to 2 then 1 Wayland pixel is a 2x2 grid of physical pixels.
If you have a 1000x1000 pixel window, Wayland will tell the application it is 500x500 but suggest a scale factor of 2.
If the application supports HiDPI mode, it will double all the numbers and render a 1000x1000 image and things work correctly.
If not, it will render a 500x500 pixel image and the compositor will scale it up.</p>
<p>Since Xwayland doesn&#39;t support this, it just draws everything too small and Sway scales it up,
creating a blurry and unusable mess.
This might be made worse by <a href="https://en.wikipedia.org/wiki/Subpixel_rendering">subpixel rendering</a>, which doesn&#39;t cope well with being scaled.</p>
<p>With the proxy, the solution is simple enough: when talking to Xwayland we just scale everything back up to the real dimensions,
scaling all coordinates as we relay them:</p>
<figure><div><table><tbody><tr><td><pre><span>1</span>
<span>2</span>
<span>3</span>
</pre></td><td><pre><code><span><span>let</span> <span>scale_to_client</span> <span>t</span> <span>(</span><span>x</span><span>,</span> <span>y</span><span>)</span> <span>=</span>
</span><span>  <span>x</span> <span>*</span> <span>t</span><span>.</span><span>config</span><span>.</span><span>xunscale</span><span>,</span>
</span><span>  <span>y</span> <span>*</span> <span>t</span><span>.</span><span>config</span><span>.</span><span>xunscale</span>
</span></code></pre></td></tr></tbody></table></div></figure><figure><div><table><tbody><tr><td><pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
</pre></td><td><pre><code><span><span>method</span> <span>on_configure</span> <span>_</span> <span>~</span><span>width</span> <span>~</span><span>height</span> <span>~</span><span>states</span><span>:_</span> <span>=</span>
</span><span>  <span>let</span> <span>width</span> <span>=</span> <span>Int32</span><span>.</span><span>to_int</span> <span>width</span> <span>in</span>
</span><span>  <span>let</span> <span>height</span> <span>=</span> <span>Int32</span><span>.</span><span>to_int</span> <span>height</span> <span>in</span>
</span><span>  <span>if</span> <span>width</span> <span>&gt;</span> <span>0</span> <span>&amp;&amp;</span> <span>height</span> <span>&gt;</span> <span>0</span> <span>then</span> <span>(</span>
</span><span>    <span>Lwt</span><span>.</span><span>async</span> <span>(</span><span>fun</span> <span>()</span> <span>-&gt;</span>
</span><span>        <span>let</span> <span>(</span><span>width</span><span>,</span> <span>height</span><span>)</span> <span>=</span> <span>scale_to_client</span> <span>t</span> <span>(</span><span>width</span><span>,</span> <span>height</span><span>)</span> <span>in</span>
</span><span>        <span>X11</span><span>.</span><span>Window</span><span>.</span><span>configure</span> <span>x11</span> <span>window</span> <span>~</span><span>width</span> <span>~</span><span>height</span> <span>~</span><span>border_width</span><span>:</span><span>0</span>
</span><span>      <span>)</span>
</span><span>  <span>)</span>
</span></code></pre></td></tr></tbody></table></div></figure><p>This will tend to make things sharp but too small, but X applications already have their own ways to handle high resolution screens.
For example, you can set <code>Xft.dpi</code> to make all the fonts bigger. I run this proxy like this, which works for me:</p>
<pre><code>wayland-proxy-virtwl --x-display=0 --xrdb Xft.dpi:150 --x-unscale=2
</code></pre>
<p>However, there is a problem.
The Wayland specification says:</p>
<blockquote>
<p>The new size of the surface is calculated based on the buffer
size transformed by the inverse buffer_transform and the
inverse buffer_scale. This means that at commit time the supplied
buffer size must be an integer multiple of the buffer_scale. If
that&#39;s not the case, an invalid_size error is sent.</p>
</blockquote>
<p>Let&#39;s say we have an X11 image viewer that wants to show a 1001-pixel-high image in a 1001-pixel-high window.
This isn&#39;t allowed by the spec, which can only handle even-sized windows when the scale factor is 2.
Regular Wayland applications already have to deal with that somehow, but for X11 applications it becomes our problem.</p>
<p>I tried rounding down, but that has a bad side-effect: if GTK asks for a 1001-pixel high menu and gets a 1000 pixel allocation,
it switches to squashed mode and draws two big bumper arrows at the top and bottom of the menu which you must use to scroll it.
It looks very silly.</p>
<p>I also tried rounding up, but tooltips look bad with any rounding. Either one border is missing, or it&#39;s double thickness.
Luckily, it seems that Sway doesn&#39;t actually enforce the rule about surfaces being a multiple of the scale factor.
So, I just let the application attach a buffer of whatever size it likes to the surface and it seems to work!</p>
<p>The only problem I had was that when using unscaling, the mouse pointer in GVim would get lost.
Vim hides it when you start typing, but it&#39;s supposed to come back when you move the mouse.
The problem seems to be that it hides it by creating a 1x1 pixel cursor.
Sway decides this isn&#39;t worth showing (maybe because it&#39;s 0x0 in Wayland-pixels?),
and sends Xwayland a leave event saying the cursor is no longer on the screen.
Then when Vim sets the cursor back, Xwayland doesn&#39;t bother updating it, since it&#39;s not on screen!</p>
<p>The solution was to stop applying unscaling to cursors.
They look better doubled in size, anyway.
True, this does mean that the sharpness of the cursor changes as you move between windows,
but you&#39;re unlikely to notice this
due to the far more jarring effect of Wayland cursors also changing size and shape at the same time.</p>
<h3 id="ring-buffer-logging">Ring-buffer logging</h3>
<p>Even without a proxy to complicate things, Wayland applications often have problems.
To make investigating this easier, I added a ring-buffer log feature.
When on, the proxy keeps the last 512K or so of log messages in memory, and will dump them out on demand.</p>
<p>To use it, you run the proxy with e.g. <code>-v --log-ring-path ~/wayland.log</code>.
When something odd happens (e.g. an application crashes, or opens its menus in the wrong place) you can
dump out the ring buffer and see what just happened with:</p>
<pre><code>echo dump-log &gt; /run/user/1000/wayland-1-ctl
</code></pre>
<p>I also added some filtering options (e.g. <code>--log-suppress motion,shm</code>) to suppress certain classes of noisy messages.</p>
<h3 id="vim-windows-open-correctly">Vim windows open correctly</h3>
<p>One annoyance with Sway is that Vim&#39;s window always appears blank (even when running on the host, without any proxy).
You have to resize it before you can see the text.</p>
<p>My proxy initially suffered from the same problem, although only intermittently.
It turned out to be because Vim sends a <code>ConfigureRequest</code> with its desired size and then waits for the confirmation message.
Since Sway is a tiling window manager, it ignores the new size and no event is generated.
In this case, an X11 window manager is supposed to send a synthetic <code>ConfigureNotify</code>,
so I just got the proxy to do that and the problem disappeared
(I confirmed this by adding a sleep to Vim&#39;s <code>gui_mch_update</code>).</p>
<p>By the way, the GVim start-up code is quite interesting.
The code path to opening the window goes though three separate functions which each define a
<code>static int recursive = 0</code> and then proceed to behave differently depending on how many times they&#39;ve
been reentered - see <a href="https://github.com/vim/vim/blob/9cd063e3195a4c250c8016fa340922ab21fda252/src/gui.c#L489">gui_init</a> for an example!</p>
<h3 id="copy-and-paste-without-m-characters">Copy-and-paste without ^M characters</h3>
<p>The other major annoyance with Sway is that copy-and-paste doesn&#39;t work correctly (<a href="https://github.com/swaywm/wlroots/issues/1839">Sway bug #1839</a>).
Using the proxy avoids that problem completely.</p>
<h2 id="conclusions">Conclusions</h2>
<p>I&#39;m not sure how I feel about this project.
It ended up taking a lot longer than I expected, and I could probably have ported several X11 applications to Wayland in the same time.
On the other hand, I now have working X support in the VMs with no need for <code>ssh -Y</code> from the host, plus support for HiDPI in Wayland, mouse cursors that are large enough to see easily, windows that open reliably, text pasting that works, and I can get logs whenever something misbehaves.</p>
<p>In fact, I&#39;m now also running an instance of the proxy directly on the host to get the same benefits for host X11 applications.
Setting this up is actually a bit tricky:
you want to start Sway with <code>DISPLAY=:0</code> so that every application it spawns knows it has an X11 display,
but if you set that then Sway thinks you want it to run nested inside an X window provided by the proxy,
which doesn&#39;t end well (or, indeed, at all).</p>
<p>Having all the legacy X11 support in a separate binary should make it much easier to write new Wayland compositors,
which might be handy if I ever get some time to try that.
It also avoids having many thousands of lines of legacy C code in the highly-trusted compositor code.</p>
<p>If Wayland had an official protocol for letting applications know the window layout then I could make drag-and-drop between X11 applications within the same VM work, but it still wouldn&#39;t work between VMs or to Wayland applications, so it&#39;s probably not worth it.</p>
<p>Having two separate connections to Xwayland creates a lot of unnecessary race conditions.
A simple solution might be a Wayland extension that allows the Wayland server to say &#34;please read N bytes from the X11 socket now&#34;,
and likewise in the other direction.
Then messages would always arrive in the order in which they were sent.</p>
<p>The code is all available at <a href="https://github.com/talex5/wayland-proxy-virtwl">https://github.com/talex5/wayland-proxy-virtwl</a> if you want to try it.
It works with the applications I use when running under Sway,
but will probably require some tweaking for other programs or compositors.
Here&#39;s a screenshot of my desktop using it:</p>
<p><a href="https://thewitchofendor.com/blog/images/xwayland/desktop.png"><span><img src="https://thewitchofendor.com/blog/images/xwayland/desktop.png" title="Screenshot of my desktop"/><span>Screenshot of my desktop</span></span></a></p>
<p>The windows with <code>[dev]</code> in the title are from my Debian VM, while <code>[com]</code> is a SpectrumOS VM I use for email, etc.
Gitk, GVim and ROX-Filer are X11 applications using Xwayland,
while Firefox and xfce4-terminal are using plain Wayland proxying.</p>

            </div></div>
  </body>
</html>
