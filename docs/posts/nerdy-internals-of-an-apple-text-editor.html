<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://papereditor.app/internals">Original</a>
    <h1>Nerdy internals of an Apple text editor</h1>
    
    <div id="readability-page-1" class="page"><article><div><div><p><span>üçø</span>¬†¬†Fascinating engineering details behind <a href="https://papereditor.app" target="_blank">Paper</a>.</p><div><p><time datetime="2024-03-04" title="First published on January 28th, 2024. Last updated on March 4th, 2024."><span>üìÖ</span>¬†¬†March 4th, 2024</time></p><p><span>‚è≥</span>¬†¬†19 min read</p></div></div></div><section><p>In this article, we‚Äôll dive into the details of the way <a href="https://papereditor.app" target="_blank">Paper</a> functions as a <code>TextView</code>-based text editor for Apple platforms.</p><p>The <a href="https://papereditor.app/dev" target="_blank">first article</a> was just a warm-up ‚Äî here is where we get to truly geek out! ü§ì</p><p>Before we start, I‚Äôll add that for the time being Paper is built on the older TextKit 1 framework, so the article is relative to TextKit 1. That said, all of the concepts, abstractions, and principles discussed here still exist in TextKit 2, either unchanged or under a better API.</p></section><section><h2 id="text-view">Text view</h2><p>To understand how text editing works in native Apple text editors, we first need to discuss the centerpiece of the whole system ‚Äî the <code>TextView</code> class. Technically, <code>NSTextView</code> and <code>UITextView</code> have their differences, but the API is similar enough that we can treat them as a single <code>TextView</code> class. I will highlight the differences where necessary.</p><p><code>TextView</code> is a massive component that only <a href="https://papereditor.app/dev#gnarly-stuff" target="_blank">grows in complexity</a> with each release of respective operating systems. The TextEdit app consists almost entirely of a single <code>TextView</code>. When a single class can be used to build an entire app ‚Äî you know it‚Äôs a beast.</p><p>Luckily, <code>TextView</code> is not just one huge pile of code. Apple tried to subdivide it into a bunch of layers ‚Äî each represented by a flagship class. The layers build on top of each other to create a text editing experience.</p><img src="https://papereditor.app/internals-article/text-view-classes.png" width="544" height="1162" alt="A diagram showing the classes that make up the text view. NSTextStorage and NSTextContainer flow into NSLayoutManager which then flows into TextView. Finally, TextView flows into ScrollView. Each next class in the diagram uses the information from the previous one to, in the end, construct a complete text editor."/><div><div><h3><code>NSTextStorage</code></h3><ul><li><em>Stores</em> the raw text string.</li><li><div><p><em>Stores</em> the attributes (string-value pairs) assigned to ranges of text.</p><ol><li>Styles such as font and color <span>(defined by AppKit and UIKit)</span>.</li><li>Any string-value pair that acts as metadata for your needs.</li></ol></div></li><li>Emits events about text and attribute changes.</li></ul></div><div><h3><code>NSTextContainer</code></h3><ul><li>Defines the shape and dimensions of the area that hosts text symbols (glyphs).</li><li>Most of the time it‚Äôs a rectangle <span>(duh üôÑ)</span> but can be any shape.</li></ul></div><div><h3><code>NSLayoutManager</code></h3><ul><li><div><p>Figures out the dimensions of the glyphs and the spacings between them by looking at the ranges of attributes applied to the text string in <code>NSTextStorage</code>.</p><ul><li>Extracts vector glyphs from the font.</li><li>Converts each text character to one or more glyphs. Some symbols and languages need more than one.</li><li>Calculates the size of each glyph.</li><li>Calculates the distances between glyphs.</li><li>Calculates the distances between lines of glyphs.</li></ul></div></li><li><div><p>Lays out each glyph, line by line, into the shape defined by <code>NSTextContainer</code>.</p><ul><li>Calculates where every line of text starts and ends.</li><li>Calculates how many lines there are and what is the total height of the text.</li></ul></div></li></ul></div><div><h3><code>TextView</code></h3><ul><li>Draws the glyph layout generated by <code>NSLayoutManager</code>.</li><li>Syncs the height of the view with the current height of laid-out text.</li><li>Manages the <em>text selection</em>.</li><li>Manages the <em>caret</em> ‚Äî empty text selection.</li><li>Manages the <em>typing attributes</em> ‚Äî attributes applied to the newly inserted text.</li><li>Can define margins (<code>textContainerInset</code>) around the <code>NSTextContainer</code>.</li><li>Manages all the additional bells and whistles such as dictation, copy-paste, spell check, etc.</li></ul></div><div><h3><code>ScrollView</code></h3><ul><li>Shows the visible portion of the <code>TextView</code>.</li><li>Manages scrolling, scroll bars, and zooming.</li><li>Can define its own margins (<code>contentInset</code>) in addition to the <code>textContainerInset</code> defined by the <code>TextView</code>.</li><li><div><p>Implementation details:</p><ul><li><div><p><strong>AppKit</strong></p><ul><li><code>NSScrollView</code> contains <code>NSClipView</code> and two instances of <code>NSScroller</code>.</li><li><code>NSClipView</code> contains <code>NSTextView</code>.</li><li>Thus many separate classes work together to make the scrolling effect.</li></ul></div></li><li><div><p><strong>UIKit</strong></p><ul><li><code>UITextView</code> extends from <code>UIScrollView</code>.</li><li>Thus <code>UITextView</code> holds everything, including the scrolling logic.</li><li>Another notable detail is that moving the caret outside the visible area of <code>UITextView</code>, bounded by <code>contentInset</code>, causes <code>UITextView</code> to <em>auto-scroll</em> to ensure that the caret stays within the visible area. You can often experience this in iOS text editors, where if the caret moves behind the keyboard, the editor scrolls to the next line. This is because the bottom <code>contentInset</code> is dynamically set to the current height of the keyboard.</li></ul></div></li></ul></div></li></ul></div></div><img src="https://papereditor.app/internals-article/text-view-mac.png" width="768" height="1270" alt="A diagram breaking down the interface of the Mac app. Areas of the interface are outlined with different colors to show what classes are responsible for them."/> <img src="https://papereditor.app/internals-article/text-view-ipad.png" width="768" height="1632" alt="A diagram breaking down the interface of the iPad app. Areas of the interface are outlined with different colors to show what classes are responsible for them."/> <img src="https://papereditor.app/internals-article/text-view-iphone.png" width="768" height="1704" alt="A diagram breaking down the interface of the iPhone app. Areas of the interface are outlined with different colors to show what classes are responsible for them."/></section><section><h2 id="attributes">Attributes</h2><p>With the general structure of <code>TextView</code> out of the way, let‚Äôs zoom in on <code>NSTextStorage</code>, or rather its parent class <code>NSAttributedString</code>, as it is the foundation of rich text editing in Apple‚Äôs frameworks.</p><p><code>NSAttributedString</code> consists of two parts:</p><ol><li>A regular text string.</li><li>String-value pairs of attributes attached to ranges of text within the string.</li></ol><p>Attributes are used mostly for styling purposes, but nothing restricts you from assigning custom string-value pairs for your own needs.</p><p>To get started, let‚Äôs make an <code>NSAttributedString</code> via the API:</p><div><div><p><img src="https://papereditor.app/internals-article/m.png" width="15" height="11" aria-hidden="true"/> Attributes.m</p></div><p><code><span>NSMutableAttributedString</span> *string = [<span>NSMutableAttributedString</span>.<span>alloc</span></code></p></div><p><code>NSRange</code> is a structure consisting of a <code>location</code> and a <code>length</code>. <code>NSMakeRange(10,5)</code> means a range of <code>5</code> characters starting from position <code>10</code>, or in other words, an inclusive range between positions <code>10</code> and <code>14</code>. In case different ranges define the same attribute under the same position then the last applied range takes precedence. In the example above, the bold and italic fonts overwrite the default font that is applied to the whole string.</p><p>This code can be easily visualized in TextEdit as it is pretty much an <code>NSTextView</code> with some buttons.</p><img src="https://papereditor.app/internals-article/text-attributes-in-textedit.png" width="768" height="588" alt="TextEdit app window with the text ‚ÄúThe quick brown fox jumps over the lazy dog.‚Äù The text is styled with different fonts, colors, and background colors. Every style is labeled with the names of attributes that are applied to it."/><p>The second big part of the API is dedicated to checking what attributes are applied to what ranges. The API itself is quite peculiar. A lot of thought has gone into making it fast and efficient, but as a result, the usage can be a bit of a pain.</p><p>For instance, if you want to check whether a certain attribute exists at a certain position you would use this method:</p><div><div><p><img src="https://papereditor.app/internals-article/m.png" width="15" height="11" aria-hidden="true"/> Attributes.m</p></div><p><code><span>id</span> value = [string <span>attribute</span>:<span>NSFontAttributeName</span></code></p></div><p>If the <code>value</code> is <code>nil</code>, then it does not exist. Otherwise, it is the value of the attribute which in this case is a <code>NSFont</code>/<code>UIFont</code> object. So this method can be used both to query the value and to check the existence of the attribute.</p><p>But it gets better. You can pass a pointer to the <code>NSRange</code> structure as the last argument <span>(the good old C technique to return multiple values from a single function call)</span>:</p><div><div><p><img src="https://papereditor.app/internals-article/m.png" width="15" height="11" aria-hidden="true"/> Attributes.m</p></div><p><code><span>NSRange</span> effectiveRange;</code></p></div><p>And it will return either:</p><ul><li>The range of the continuous span of the same attribute with the same value.</li><li>Or the range of the gap where the attribute is absent.</li></ul><img src="https://papereditor.app/internals-article/text-attributes-at-index.png" width="768" height="882" alt="Two diagrams with the text ‚ÄúThe quick brown‚Äù. The word ‚Äúbrown‚Äù is in brown color. In the first diagram, the NSFontAttributeName attribute is sampled at index 6. The result is ‚Äúnil‚Äù and the effective range is between indexes 0 and 9 inclusive. In the second diagram, the NSFontAttributeName attribute is sampled at index 11. The result is an NSFont.brownColor object and the effective range is between indexes 10 and 14 inclusive."/><p>Though not exactly‚Ä¶ You see the <code>effectiveRange</code> here is not what you think it is. Quoting the documentation:</p><blockquote><p>The range isn‚Äôt necessarily the maximum range covered by the attribute, and its extent is implementation-dependent.</p></blockquote><p>In other words, it <em>could be</em> the correct maximum range‚Ä¶ but it also <em>might not be</em>.</p><p><span><span>‚Äú</span><span>Ahh ‚Äî I just love having a bit of non-determinism in my code!</span><span>‚Äù</span></span></p><img src="https://papereditor.app/internals-article/effective-range.png" width="768" height="452" alt="Same diagram as the second diagram in the previous image except multiple different ranges are labeled. Labels read: ‚ÄúCan be this‚Äù, ‚ÄúOr this‚Äù or ‚ÄúOr even this‚Äù."/><p>To get the guaranteed maximum range you need to use a different method.</p><div><div><p><img src="https://papereditor.app/internals-article/m.png" width="15" height="11" aria-hidden="true"/> Attributes.m</p></div><p><code><span>NSRange</span> effectiveRange;</code></p></div><p>I suppose, this separation is done to make the <em>checking</em> of the attribute existence faster with the former method as the latter one probably needs to do some range merging to figure out the longest range when multiple ranges overlap. Still ‚Äî how the <code>effectiveRange</code> in the former method is even useful? ü§∑üèº‚Äç‚ôÇÔ∏è</p><p>The same pair of methods exist to query an <code>NSDictionary</code> of all the attributes at a position and the <code>effectiveRange</code> for which this unique combination of attributes spans.</p><div><div><p><img src="https://papereditor.app/internals-article/m.png" width="15" height="11" aria-hidden="true"/> Attributes.m</p></div><p><code><span>NSRange</span> effectiveRange;</code></p></div><p>Finally, there is a convenience method to iterate over attributes within a range. With the longest constant name that ever existed for specifying which mode of attribute range inspection you prefer.</p><div><div><p><img src="https://papereditor.app/internals-article/m.png" width="15" height="11" aria-hidden="true"/> Attributes.m</p></div><p><code>[string <span>enumerateAttribute</span>:<span>NSFontAttributeName</span></code></p></div></section><section><h2 id="styling">Styling</h2><p>With the foundational knowledge behind us, it‚Äôs time to discuss how the syntax highlighting and text styling work in Paper.</p><p>As mentioned before, styling means applying special framework-defined attributes to ranges of text. In addition to them, Paper also uses custom attributes to identify the structure of the text before styling it. Here‚Äôs the breakdown:</p><ol><li><div><p><strong>Meta attributes</strong></p><ul><li>Defined by the Markdown parser to identify individual parts of the Markdown syntax.</li><li>These are custom string-value pairs used purely for semantics.</li><li>They do not influence the visual look of the text.</li></ul></div></li><li><div><p><strong>Styling attributes</strong></p><ul><li>The visual attributes applied on top of the parts marked by meta attributes.</li><li>These are built-in string-value pairs defined by AppKit and UIKit.</li></ul></div></li></ol><img src="https://papereditor.app/internals-article/meta-and-styling-attributes.png" width="768" height="768" alt="The Mac app with the text ‚ÄúThe quick brown fox **jumps** ==over== the ~_lazy_~ dog.‚Äù in the center. Meta and styling attributes are labeled."/><p>The attributes are kept in sync with:</p><ul><li>The <strong>Markdown text</strong> in <code>NSTextStorage</code> that changes due to user input.</li><li>The <strong>text-affecting settings</strong> that change as the user adjusts them from various menu items, sliders, and gestures.</li></ul><p>Technically, we can identify three types of events that trigger this attribute update process:</p><ol><li><strong>Document opened</strong> ‚Äî full update of meta attributes and styling attributes.</li><li><strong>Text changed</strong> ‚Äî partial update of meta attributes and styling attributes in the affected part. Most of the time only in the edited text. Sometimes in the whole paragraph. More on that in the next chapter.</li><li><strong>Setting changed</strong> ‚Äî full update of styling attributes but not meta attributes.</li></ol><img src="https://papereditor.app/internals-article/attribute-update-events.png" width="768" height="940" alt="A diagram showing the three events and how much they update the meta and styling attributes."/><p>In every update there is a well-defined sequence of steps:</p><ol><li><div><p><strong>Start the text editing transaction</strong></p><ul><li>Without a transaction, every attribute change would trigger an expensive layout recalc by the <code>NSLayoutManager</code>. Instead, we want to batch all the changes and re-layout only once in step <span><span>[</span><span>4.</span><span>]</span></span>.</li></ul></div></li><li><div><p><strong>Parse the Markdown structure</strong></p><ul><li>This is where the Markdown string is broken down into pieces denoted by the <em>meta attributes</em>.</li><li>This step is skipped for <em>setting change</em> since the Markdown structure does not change in this case.</li></ul></div></li><li><div><p><strong>Update layout-affecting attributes</strong></p><ul><li>The first batch of <em>styling attributes</em>.</li><li>This is every visual attribute that can influence the position or size of the glyphs in the text view.</li></ul></div></li><li><strong>End the text editing transaction</strong></li><li><div><p><strong>Update decorative attributes</strong></p><ul><li>The second batch of <em>styling attributes</em>.</li><li>The decorative attributes <span>(or <em>rendering attributes</em> in Apple‚Äôs terminology)</span> are applied outside the transaction. The reason is simple ‚Äî they don‚Äôt affect the layout, so updating them is not expensive. And they are not even aware of the transaction since they live in the <code>NSLayoutManager</code> itself, not in <code>NSTextStorage</code>.</li></ul></div></li></ol><img src="https://papereditor.app/internals-article/attribute-update-steps.png" width="768" height="922" alt="A diagram showing the five steps of the attribute update process on the text ‚Äú**jumps** ==over‚Äù. During step 3 the font attribute is applied to ‚Äújumps‚Äù. During step 5 the light gray color is applied to Markdown tags and the background color to ‚Äúover‚Äù."/><p>The most important attribute of the layout-affecting ones is <code>NSParagraphStyle</code>. It defines the bulk of the values that influence the layout of the lines and paragraphs.</p><img src="https://papereditor.app/internals-article/paragraph-style.png" width="768" height="712" alt="A diagram breaking down which parts of the text and in which way are affected by the NSParagraphStyle attribute in the Mac app."/><p>The last chunk of attributes that participate in the styling process are the <em>typing attributes</em>. They are tied to the attributes at the position preceding the caret <span>(for empty selection)</span> or to the one at the start of the selection <span>(for non-empty selection)</span>. Once you type a character, the typing attributes are assigned to the newly inserted text automatically. In a Markdown editor, they are not that important as the styling is derived entirely from the Markdown syntax, but they are crucial for rich text editors where the styles <em>stick</em> to the caret until you turn them off or move the caret to a new location. Despite being a Markdown editor, Paper <em>does</em> have a rich text editing experience called the Preview Mode. In this mode, the editor behaves just like a rich text editor with <em>toggleable</em> typing attributes being highlighted, for example, on the toolbar in the iOS app.</p></section><section><h2 id="performance">Performance</h2><p>The separation of meta, layout, and decorative attributes plays nicely into keeping certain editor changes fast. For instance, toggling between light and dark modes requires updating only decorative attributes which is very fast as it does not trigger the layout. Setting changes such as text size adjustments, though require a re-layout of the whole document, is still reasonably fast compared to doing that plus a full re-parse of the Markdown structure.</p><p>That said, the most crucial performance piece of any text editor is undoubtedly the typing speed. The bad news is that due to how Markdown works, any text change has the potential to affect the styling of the whole paragraph.</p><p>Thus the logical thing to do is to re-parse and re-style the whole paragraph on every keystroke. The problem with that is while this is technically the most correct approach, it can slow down the editing for longer paragraphs. At the same time, if you‚Äôre simply typing out a long sentence, the Markdown structure does not change. There is really no need to re-style everything all the time for those simple typing scenarios.</p><p>So to make typing snappier, I‚Äôve built an algorithm that looks at the next character being typed as well as what characters are around it. The gist of the logic is that if you‚Äôre typing a special Markdown symbol, or the location of the edit is surrounded by one, then you should update the whole paragraph, otherwise you can simply rely on the typing attributes. It‚Äôs a simple algorithm that does marvels for the speed of the editor in the majority of typing situations.</p><img src="https://papereditor.app/internals-article/typing-optimization.png" width="768" height="866" alt="Two diagrams. In the first diagram the letter ‚Äúp‚Äù is inserted into the text ‚Äú**jums** ==over=‚Äù between ‚Äúm‚Äù and ‚Äús‚Äù. The newly inserted letter ‚Äúp‚Äù is restyled as a result. In the second diagram the letter ‚Äú*‚Äù is deleted from ‚Äú**jumps** ==over‚Äù. The whole paragraph is restyled as a result and ‚Äújumps‚Äù is no longer bold."/><p>The only nasty exception to the above is when you have code blocks in the document. Code blocks are the only multi-paragraph Markdown constructs in Paper. A keystroke has the potential to re-style the whole document.</p><p>For now, I decided to ignore code blocks in documents beyond a certain character limit. It keeps the editor fast for the majority of users who don‚Äôt care about code, at the same time making Paper more useful for dev-adjacent audiences.</p><p>The final technique that I use to speed things up is to cache every complex value object in the string-value attribute pair.</p><ul><li><code>NSFont</code>/<code>UIFont</code></li><li><code>NSColor</code>/<code>UIColor</code></li><li><code>NSParagraphStyle</code></li></ul><p>They are being re-assigned on every keystroke and never change unless a text-affecting setting is changed, so it makes sense to reuse them instead of creating new instances every time.</p></section><section><p>Besides the highlighting logic, meta attributes play a crucial role in various features that need to know about the structure of the text.</p><div><div><h3>Formatting shortcuts</h3><div><ul><li>Toggling styles on a selected piece of Markdown text requires detailed information about the existing Markdown styles inside the selection.</li><li>If the selection completely encloses the same style, then the style is removed.</li><li>If the selection does not contain the same style, then the style is added.</li><li>If the selection partially encloses the same style, then the style is moved to the selection.</li><li>You also need to be careful not to mix the styles that cannot be mixed. The conflicting styles need to be removed first, before a new style can be added. For example, styles that define the type of the paragraph such as <em>heading</em> and <em>blockquote</em> cannot be mixed.</li></ul></div></div><div><h3>Jumping between chapters</h3><div><ul><li>Paper has a feature that allows you to jump to the previous or the next edge of the chapter.</li><li>Meta attributes help to locate the headings relative to the position of the caret.</li></ul></div></div><div><h3>Outline</h3><ul><li>The outline feature relies on being able to traverse every heading.</li><li>Pressing on the item in the outline moves the caret to that chapter.</li></ul></div><div><h3>Rearranging chapters</h3><div><ul><li>Paper also has a feature that allows rearranging chapters in the outline.</li></ul></div></div><div><h3>Converting formats</h3><ul><li>Converting the Markdown content to RTF, HTML, and DOCX relies on knowing the structure of the text.</li><li>Since Paper <a href="https://papereditor.app/dev#third-party-dependencies" target="_blank">does not include any external libraries</a>, having a pre-parsed model of the text allows me to traverse the structure, building the respective output format in the process.</li></ul><div><div><p><img src="https://papereditor.app/internals-article/m.png" width="15" height="11" aria-hidden="true"/> TextFormats.m</p></div><p><code>- (<span>NSString</span> *)<span>toHtml</span>:(<span>NSMutableAttributedString</span> *)string {</code></p></div></div></div></section><section><h2 id="text-container-math">Text container math</h2><p>The most important rule for the text container is to maintain the preferred line length, dividing the remaining space between side insets.</p><img src="https://papereditor.app/internals-article/text-container-math.png" width="768" height="798" alt="A diagram breaking down the interface of the Mac app. The text container is centered and the side margins are of the same width."/><p>There are however trickier cases where you need to fake the symmetry. Like when the heading tags are placed outside of the regular flow of text. The text container is shifted to the left and the paragraphs are indented with <code>NSParagraphStyle</code>.</p><img src="https://papereditor.app/internals-article/text-container-symmetry.png" width="768" height="1018" alt="A diagram breaking down the interface of the Mac app. Various gaps and dimensions are labeled."/><p>While there is enough space, it tries to keep the margins visually symmetrical. If there is no extra space left, then it breaks the symmetry in favor of keeping the specified line length. But only while there is padding remaining on the right side. When there is no padding left, the minimum margins take precedence over keeping the line length to its preferred width.</p><p>You can achieve this gradual collapsing with a combination of <code>min</code> and <code>max</code> functions. It takes a second or two to get your head around the math, but once you do, it feels quite elegant in my opinion. I love this kind of simple mathy code that leads to beautiful visual results.</p><div><div><p><img src="https://papereditor.app/internals-article/m.png" width="15" height="11" aria-hidden="true"/> MaTvTextContainerModule.m</p></div><p><code>- (<span>CGFloat</span>)<span>leftInset</span> {</code></p></div></section><section><h2 id="selection-anchoring">Selection anchoring</h2><p>Text selection always has an anchor point. It‚Äôs something we are so used to that we never stop to think about.</p><p>On the Mac, we click and drag to select the text and we instinctively know that the selection will increase when dragging to the right and decrease when dragging to the left. But only until we hit the point of the click. Then the opposite happens.</p><p>On iOS the selection is a bit more interactive. We can drag one edge and then the other one becomes the anchor, and vice versa.</p><p>The same logic applies when we extend the selection with the keyboard. Hold the <em>Option</em> key plus a left or a right arrow and you can jump between the edges of the words. Do the same while holding the <em>Shift</em> key, in addition to the <em>Option</em> key, and you can select with word increments. And again ‚Äî it remembers where you started.</p><p>It even works naturally when you first click and drag and then continue extending or shrinking the selection with the keyboard. The initial point of the click remains the anchor.</p></section><section><h2 id="selection-affinity">Selection affinity</h2><p>Another fascinating concept of text editing that you <em>most probably</em> don‚Äôt know about is <em>selection affinity</em>. Quoting Apple‚Äôs documentation:</p><blockquote><p>Selection affinity determines whether, for instance, the insertion point appears after the last character on a line or before the first character on the following line in cases where text wraps across line boundaries.</p></blockquote><p>My guess is you still have no clue what it means, so let‚Äôs see it in action.</p><p>Pay attention to the screencast below. When I move the caret with the arrow keys, it simply switches the lines when moving around the wrapping point denoted by the <em>space</em> character. However, if I move the caret to the end of the line with the shortcut, it attaches itself to the right side of the wrapping space while staying on the same line.</p><p>There are also other instances where the <code>TextView</code> decides to play this trick. It‚Äôs a tiny detail and sort of makes sense when you think about it, but quite hard to actually notice.</p></section><section><h2 id="utis">Uniform Type Identifiers</h2><p>The last chapter will focus on cross-app data exchange, but first, we need to discuss the system that underpins it ‚Äî the UTIs. It‚Äôs a hierarchical system where data types <em>conform to</em> (inherit from) parent data types.</p><ul><li><code>public.*</code> types are defined by Apple. They identify the widely accepted formats such as <code>public.html</code> and <code>public.jpeg</code>.</li><li>Developers can create their own identifiers using the <em>reverse domain naming scheme</em> to avoid collisions.</li></ul><img src="https://papereditor.app/internals-article/utis.png" width="768" height="768" alt="A diagram showing the hierarchical structure of UTIs. At the top is ‚Äúpublic.data‚Äù, below it ‚Äúpublic.text‚Äù. Then it splits to ‚Äúpublic.plain-text‚Äù and ‚Äúpublic.rtf‚Äù. Below ‚Äúpublic.plain-text‚Äù is ‚Äúnet.daringfireball.markdown‚Äù." .=""/><p>The benefit of the hierarchical system is that, for example, if your app can view any text format then you don‚Äôt need to list all of them ‚Äî you can just say that it works with <code>public.text</code>. And indeed, Paper declares that it can open any text file, and although you won‚Äôt get any highlighting, you can still open <code>.html</code>, <code>.rtf</code>, or any other text format.</p><img src="https://papereditor.app/internals-article/rtf-in-paper.png" width="768" height="712" alt="RTF file opened in the Mac app." .=""/><p>When exchanging data via a programmatic interface such as the clipboard, UTIs can be used directly. Files however are a bit trickier. File is a cross-platform concept and de-facto identifiers for files in the cross-platform realm are <em>file extensions</em>. Even if Apple would redo their systems to rely on some file-level UTI metadata field instead of the file extension <span>(and <a href="https://stackoverflow.com/questions/34927527" target="_blank">it appears they have</a>)</span>, other systems would not know anything about it. So to stay compatible, every UTI can define one or more file extensions that are associated with it.</p><p>Now, most of the time you work with either public UTIs or private ones that you‚Äôve created specifically for your app. Things are relatively straightforward in these scenarios. The harder case is when you have a format that‚Äôs widely accepted, but not defined by Apple. This is exactly the case with <a href="https://daringfireball.net/linked/2011/08/05/markdown-uti" target="_blank">Markdown</a>. I will explain some of the annoying edge cases with these <em>semi-public</em> UTIs in the next chapter.</p></section><section><h2 id="pasteboard">Pasteboard</h2><p>UTIs transition nicely into the topic of cross-app exchange driven primarily by the <em>clipboard</em>, or in Apple‚Äôs technical terms ‚Äî the <em>pasteboard</em>.</p><p>The pasteboard is nothing more than a dictionary where UTIs are mapped to serialized data ‚Äî in either textual or binary format. In fact, using the <em>Clipboard Viewer</em> from <em>Additional Tools for Xcode</em> you can inspect the contents of the pasteboard in real time.</p><p>As you can see, a single <em>copy</em> action writes multiple representations of the same data at once <span>(for backward compatibility some apps also write legacy non-UTI identifiers such as <code>NeXT Rich Text Format v1.0 pasteboard type</code>)</span>. That‚Äôs how, for instance, if you copy from Pages and paste it into <a href="https://apps.apple.com/app/id1669953820" target="_blank">MarkEdit</a> ‚Äî you get just the text, but if you paste it into TextEdit ‚Äî you get the whole shebang.</p><p>As a general rule, editors pick whatever is the <em>richest</em> format they can handle. Some apps provide ways to force a specific format to be used. For example, a common menu item in the <em>Edit</em> menu of rich text editors is <em>Paste and Match Style</em> or <em>Paste as Plain Text</em>. It tells the app to use the plain text format from the pasteboard. The styles applied to the pasted text are usually taken from the <em>typing attributes</em>.</p><p>A fun fact is that drag and drop is also powered by the pasteboard, but a different one. The standard one is called the <em>general pasteboard</em> and it‚Äôs used for copy-paste. You can even create custom ones for bespoke cross-app interactions.</p><p>Another fun fact is that RTF is basically the serialized form of <code>NSAttributedString</code>. Or vice versa, <code>NSAttributedString</code> is the programmatic interface for RTF.</p><div><div><p><img src="https://papereditor.app/internals-article/m.png" width="15" height="11" aria-hidden="true"/> Rtf.m</p></div><p><code><span>NSAttributedString</span> *string = [<span>NSAttributedString</span>.<span>alloc initWithString</span>:</code></p></div><p>This means that <code>TextView</code> is out-of-the-box compatible with the pasteboard since it works on top of <code>NSTextStorage</code> ‚Äî the child class of <code>NSAttributedString</code>. No extra coding is needed to copy the contents to the pasteboard.</p><p>Now, as I mentioned in the last chapter, this is all great for public UTIs. But what about <a href="https://daringfireball.net/linked/2011/08/05/markdown-uti" target="_blank">semi-public</a> ones like Markdown? From my experience, the cross-app exchange is a mixed bag‚Ä¶</p><p>Imagine you want to copy from one Markdown editor and paste it into another one. Let‚Äôs say both have implemented the standard protocol to export formats with various levels of richness and to import the richest format given. Copying from the first editor exports Markdown as <code>public.text</code> and the rich text representation as <code>public.rtf</code>. When pasting to the second editor, it will pick <code>public.rtf</code> instead of the native Markdown format since there is no indication that the text is indeed Markdown. You end up with this weird double conversion that leads to all sorts of small formatting issues, such as extra newlines due to slight variations in the way Markdown‚ÜîRTF translation works in both apps, as well as just fundamental styling differences between Markdown and RTF. For the user it is obvious ‚Äî <span><span>‚Äú</span><span>I copy Markdown from here and paste it here ‚Äî it should just copy 1:1</span><span>‚Äù</span>, but under the hood there is a lot of needless conversion.</span></p><p>For this to work nicely, both apps should magically agree to export the <code>net.daringfireball.markdown</code> UTI and prefer it over <code>public.rtf</code>. If only one of the apps does it ‚Äî it won‚Äôt make a difference. Paper tried to be a good citizen by exporting the Markdown UTI, but none of the other apps seem to prefer it over rich text. In addition to that, Pages has a weird behavior where it <em>does</em> prefer <code>net.daringfireball.markdown</code> over <code>public.rtf</code>, but in doing so it just inserts the raw Markdown string as is without converting it to rich text <span>(why-y-y??? üò´)</span>. For this reason, I had to drop the Markdown UTI.</p><p><span><span>‚Äú</span><span>But why export RTF at all? Markdown is all about plain text ‚Äî drop RTF and problem solved</span><span>‚Äù</span> ‚Äî you might think. Well, that‚Äôs true, but I want to provide a seamless copy-paste experience from Paper to rich text editors. And being a good OS citizen, you <em>should</em> provide many formats that represent the copied data, so that the receiving application could pick the richest one it can handle. In Paper, you can copy the Markdown text from the editor and paste it into the Mail app, and it would paste as nicely formatted rich text, not as some variant of Markdown. This is a great experience in my opinion. The only problem is that it often leads to less-than-ideal UX in other cases.</span></p><p>Another feature closely related to the pasteboard is <em>sharing</em> on iOS. It‚Äôs quite similar to copy-paste, only with a bit of UI on top. Your app exports data in various formats and the receiving app decides what format it wants to grab. Strangely enough, UTIs are not used to identify the data <span>(well actually they <a href="https://stackoverflow.com/questions/28654593" target="_blank">kind of are</a> through some bizarre scripting language in a config file üò±)</span>. Rather, classes such as <code>NSAttributedString</code>, <code>NSURL</code>, and <code>UIImage</code> are directly used to represent the type. Unlike the pasteboard that applies to all apps automatically, the sharing feature on iOS requires apps to explicitly opt-in to be present in that top row of apps by providing a <em>share extension</em> with a custom UI.</p></section><section><h2 id="thats-it">That‚Äôs it for now</h2><p>Check out the <a href="https://papereditor.app/dev" target="_blank">first article</a> if you haven‚Äôt already. It has a lot more tidbits about the app and the development process.</p></section></article><p>PS ‚Äî I like sweating the details. If you think I might be useful to you ‚Üí <a href="https://twitter.com/_mihhail" target="_blank">reach out</a>. <span>üòâ</span></p></div>
  </body>
</html>
