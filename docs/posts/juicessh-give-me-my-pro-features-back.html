<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nproject.io/blog/juicessh-give-me-back-my-pro-features/">Original</a>
    <h1>JuiceSSH â€“ Give me my pro features back</h1>
    
    <div id="readability-page-1" class="page"><div>
              
              <p>JuiceSSH used to be, in my humble personal opinion, and for the uses I had, the best SSH client available on Android until December 2025.</p><p>Since then, the purchase made in 2019 is not recognized anymore, and the price went up by 20$. Some users complained in review, before it got unlisted from google play, that after buying it again, the application doesn&#39;t get activated. Support is unresponsive, this looks like an exit scam.</p><p>Below is a way to make the application work again. This required <a href="https://github.com/skylot/jadx" rel="noreferrer">jadx</a> to understand smali, and will require you <a href="https://github.com/iBotPeaches/Apktool" rel="noreferrer">ApkTool</a> and jarsigner, which is part of OpenJDK, and you that can install on Windows using <code>choco install openjdk</code>.</p><p>You&#39;ll also need a JuiceSSH apk, I downloaded one from <a href="https://apkpure.com/fr/juicessh-ssh-client/com.sonelli.juicessh/download" rel="noreferrer">PureAPK</a>, but feel free to dump your own from your device using adb if you cannot find it. Make sure to verify the hash using virus total/sha256sum if downloading from internet, which should be <code>d1ee811bcd82f25aea0bdc568896d82017ee174d9c4631c123a9d9173c748232</code> for the last version available, version 3.2.2.</p><p>Below are powershell version of the command lines, but you get the idea.</p><h2 id="decompile">Decompile</h2><p>The first step is to decompile the dex packed code from the apk.</p><pre><code>&amp; &#34;C:\Program Files\OpenJDK\jdk-25\bin\java.exe&#34; -jar ./apktool_2.12.1.jar d juicessh.apk
</code></pre><h2 id="modify-smali">Modify smali</h2><p>You then need to modify the smali of three files, which are detailed below.</p><h3 id="smalicomsonellijuicesshmodelsusersmali">smali/com/sonelli/juicessh/models/User.smali</h3><p>In this file, we&#39;ll patch the purchase validation and signature validation, done by the <code>public boolean H()</code> function.</p><p>Here is the original version.</p><pre><code>public boolean H() {
    try {
        String str = &#34;&#34;;
        ArrayList arrayList = new ArrayList();
        for (Purchase purchase : this.purchases) {
            if (!arrayList.contains(purchase.order)) {
                str = str + purchase.product + purchase.state;
                arrayList.add(purchase.order);
            }
        }
        return vg0.b(this.signature, this.sessionIdentifier + this.name + this.email + str + this.disabled.toString());
    } catch (IllegalStateException e) {
        e.printStackTrace();
        return false;
    }
}</code></pre><p>Which we&#39;ll simply change into</p><pre><code>public boolean H() {
    return true;
}</code></pre><pre><code># virtual methods
.method public H()Z
    .locals 1

    const/4 v0, 0x1
    return v0
.end method</code></pre><h3 id="smalicomsonellioi0smali">smali/com/sonelli/oi0.smali</h3><p>In this one, we&#39;ll patch the <code>public static boolean d(Object obj)</code> function, who calls the H() function we modified above, which now returns true, filters product matching JuiceSSH in purchases list, and check if it the purchase is valid. We&#39;ll simply make it return true in any case.</p><p>Here is the original version:</p><pre><code>public static boolean d(Object obj) {
    if (!obj.getClass().getName().equals(User.class.getName())) {
        return false;
    }
    try {
        if (!((User) obj).H()) {
            return false;
        }
        ArrayList arrayList = new ArrayList();
        for (Purchase purchase : ((User) obj).purchases) {
            if (purchase.product.equals(a())) {
                arrayList.add(purchase);
            }
        }
        Collections.sort(arrayList, new a());
        if (arrayList.size() &gt; 0) {
            if (((Purchase) arrayList.get(arrayList.size() - 1)).state.intValue() == 0) {
                return true;
            }
        }
        return false;
    } catch (NullPointerException e) {
        e.printStackTrace();
        return false;
    }
}</code></pre><p>Here is the patched one:</p><pre><code>public static boolean d(Object obj) {
    return obj.getClass().getName().equals(User.class.getName());
}</code></pre><pre><code>.method public static d(Ljava/lang/Object;)Z
    .locals 3

    # obj.getClass()
    invoke-virtual {p0}, Ljava/lang/Object;-&gt;getClass()Ljava/lang/Class;
    move-result-object v0

    # obj.getClass().getName()
    invoke-virtual {v0}, Ljava/lang/Class;-&gt;getName()Ljava/lang/String;
    move-result-object v0

    # User.class
    const-class v1, Lcom/sonelli/juicessh/models/User;

    # User.class.getName()
    invoke-virtual {v1}, Ljava/lang/Class;-&gt;getName()Ljava/lang/String;
    move-result-object v1

    # compare strings
    invoke-virtual {v0, v1}, Ljava/lang/String;-&gt;equals(Ljava/lang/Object;)Z
    move-result v2

    if-nez v2, :cond_true

    const/4 v0, 0x0
    return v0

    :cond_true
    const/4 v0, 0x1
    return v0
.end method</code></pre><h3 id="smalicomsonellipi0smali">smali/com/sonelli/pi0.smali</h3><p>Finally, we&#39;ll patch the central part of the authentication, which is called each time a pro-feature is triggered to ensure user has valid license, the <code>public static void j(Context context, p pVar)</code> function.</p><p>Here is the original version:</p><pre><code>public static void j(Context context, p pVar) {
    User user;
    User user2;
    String strS = User.s(context);
    if (strS == null) {
        pVar.a(context.getString(R$string.authentication_failure));
        return;
    }
    if (strS.equals(&#34;New User&#34;)) {
        pVar.a(&#34;New User&#34;);
        return;
    }
    User user3 = b;
    if (user3 != null &amp;&amp; !user3.disabled.booleanValue()) {
        long jCurrentTimeMillis = System.currentTimeMillis() - b.modified;
        DateUtils.getRelativeTimeSpanString(System.currentTimeMillis() + (b.w() * 1000), System.currentTimeMillis(), 0L, 0);
        DateUtils.getRelativeTimeSpanString(System.currentTimeMillis() + (3600000 - jCurrentTimeMillis), System.currentTimeMillis(), 0L, 0);
        if (b.w() &lt;= 0) {
            gj0.b(&#34;API&#34;, &#34;Cached user&#39;s API session has expired - refreshing session...&#34;);
            e(context, null, b.sessionIdentifier, pVar);
            return;
        }
        pVar.b(b);
        if (jCurrentTimeMillis &lt;= 3600000 || context == null || (user2 = b) == null) {
            return;
        }
        e(context, null, user2.sessionIdentifier, null);
        return;
    }
    User userA = User.A(context);
    if (userA == null || userA.disabled.booleanValue() || !userA.H()) {
        e(context, null, null, pVar);
        return;
    }
    b = userA;
    if (userA.w() &lt;= 0) {
        e(context, null, b.sessionIdentifier, pVar);
        return;
    }
    pVar.b(b);
    if (context == null || (user = b) == null) {
        return;
    }
    e(context, null, user.sessionIdentifier, null);
}</code></pre><p><code>pVar.b()</code> is the success callback we&#39;ll call while <code>e()</code> is called in case of error. <code>b</code> is the globally stored user we&#39;ll have to set. To patch this, we&#39;ll simply craft a User with meaningless data, a session expire always in future, save the user in <code>b</code>, and call the success callback every time.</p><pre><code>public static void j(Context context, p pVar) {
    User user = new User();
    user.email = &#34;myemail@google.com&#34;;
    user.name = &#34;hello&#34;;
    user.given_name = &#34;hello&#34;;
    user.sessionExpires = System.currentTimeMillis() + (86400000 * 365);
    user.sessionIdentifier = &#34;&#34;;
    b = user;
    pVar.b(user);
}</code></pre><pre><code>.method public static j(Landroid/content/Context;Lcom/sonelli/pi0$p;)V
    .locals 8

    # User u = new User();
    new-instance v0, Lcom/sonelli/juicessh/models/User;
    invoke-direct {v0}, Lcom/sonelli/juicessh/models/User;-&gt;&lt;init&gt;()V

    # u.email = &#34;myemail@google.com&#34;;
    const-string v1, &#34;myemail@google.com&#34;
    iput-object v1, v0, Lcom/sonelli/juicessh/models/User;-&gt;email:Ljava/lang/String;

    # u.name = &#34;hello&#34;;
    const-string v1, &#34;hello&#34;
    iput-object v1, v0, Lcom/sonelli/juicessh/models/User;-&gt;name:Ljava/lang/String;

    # u.given_name = &#34;hello&#34;;
    iput-object v1, v0, Lcom/sonelli/juicessh/models/User;-&gt;given_name:Ljava/lang/String;

    # long now = System.currentTimeMillis();
    invoke-static {}, Ljava/lang/System;-&gt;currentTimeMillis()J
    move-result-wide v2

    # yearMillis = 86400000L * 365L
    const-wide/32 v4, 0x05265c00      # 86400000
    const-wide/16 v6, 0x016d          # 365
    mul-long/2addr v4, v6

    # u.sessionExpires = now + yearMillis;
    add-long/2addr v2, v4
    iput-wide v2, v0, Lcom/sonelli/juicessh/models/User;-&gt;sessionExpires:J

    # u.sessionIdentifier = &#34;&#34;
    const-string v1, &#34;&#34;
    iput-object v1, v0, Lcom/sonelli/juicessh/models/User;-&gt;sessionIdentifier:Ljava/lang/String;

    # pi0.b = u;
    sput-object v0, Lcom/sonelli/pi0;-&gt;b:Lcom/sonelli/juicessh/models/User;

    # pVar.b(b);
    invoke-virtual {p1, v0}, Lcom/sonelli/pi0$p;-&gt;b(Lcom/sonelli/juicessh/models/User;)V

    return-void
.end method</code></pre><h2 id="recompile">Recompile</h2><pre><code>&amp; &#34;C:\Program Files\OpenJDK\jdk-25\bin\java.exe&#34; -jar .\apktool_2.12.1.jar juicessh</code></pre><h2 id="sign-the-apk">Sign the apk</h2><pre><code># Create a keystore if needed to self sign the APK
keytool -genkey -v -keystore k.keystore -alias a -keyalg RSA -keysize 2048 -validity 50000

# Sign the APK
jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore k.keystore ./juicessh/dist/juicessh.apk a</code></pre><h2 id="done">Done</h2><p>You can install this apk, ignore the security warning because it is self signed, and enjoy JuiceSSH with its pro features again.</p><p>I don&#39;t think the cloud sync will ever work again, but that&#39;s a minor inconvenience, and you cannot trust a developper who act like this anyway. The plugins don&#39;t work anymore too, which is really a joke.</p>
            </div></div>
  </body>
</html>
