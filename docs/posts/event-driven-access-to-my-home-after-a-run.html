<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://randywestergren.com/event-driven-access-to-my-home-after-a-run/">Original</a>
    <h1>Event-Driven Access to My Home After a Run</h1>
    
    <div id="readability-page-1" class="page"><div id="page">
		<!-- #masthead -->

	<div id="content">

	<div id="primary">
		<main id="main" role="main">

		
			
<article id="post-2616">
	<!-- .entry-header -->

	<div>
		<p>I always run with my phone on me, so accessing my home afterward has been convenient since installing MyQ W-Fi connected garage doors several years ago. No need to remember to carry a separate house key anymore and getting into my house is (usually) an app launch away.</p>
<p>It has worked great, until one day when I returned from a particularly cold run — though it was fine playing music the entire 8 miles, as soon as I opened my phone’s home screen, its battery charge rapidly faded and died. This was certainly not ideal. After getting back inside, I was determined to fully automate home access going forward.</p>
<h2>Solution</h2>
<p>Using my home Wi-Fi network was the obvious choice in solving this problem. I simply needed to determine two states:</p>
<ol>
<li>When I left for a run</li>
<li>When I returned</li>
</ol>
<p><a href="https://randywestergren.com/wp-content/uploads/2022/02/home-router-range-2.png" rel="lightbox[2616]"><img src="https://randywestergren.com/wp-content/uploads/2022/02/home-router-range-2.png" alt="" width="489" height="340"/></a></p>
<p>Knowing I had left for a <em>run </em>was key to knowing when I had returned from a <em>run</em>, rather than a trip in the car for example. Therefore, I would at least need to start a process that would understand my intent to leave, detect my departure has occurred, and then detect my return to open the door.</p>
<h3>Departure</h3>
<p>Using ARP pings (who-has), I can determine if my device is currently connected to my network by filtering the replies using my MAC address. Though in practice it doesn’t necessarily respond to every ARP, it responds often enough. This meant I just needed to detect my phone had been disconnected for <em>some</em> period of time. Here’s a quick and dirty implementation using <a href="https://scapy.net/" target="_blank" rel="noopener">scapy</a>:</p>
<pre data-enlighter-language="python">def is_connected():
    ans, unans = arping(LOCAL_SUBNET, verbose=0)
    for s, r in ans:        
        mac_address = str(r[Ether].src)
        ip_address = s[ARP].pdst
        if mac_address == PHONE_MAC_ADDRESS:
            logging.debug(f&#34;PHONE FOUND, IP: {ip_address}&#34;)
            return True
    return False


def wait_for_departure(seconds_until_gone):
    time_last_seen = time.time()
    while True:
        if is_connected():
            time_last_seen = time.time()
        else:
            time_gone = (time.time() - time_last_seen)
            logging.debug(f&#34;Missing PHONE for {time_gone}&#34;)
            if time_gone &gt; seconds_until_gone:
                logging.info(&#34;PHONE is gone&#34;)
                return</pre>
<p>As you can see, we start by assuming the device is initially connected and keep track of the elapsed time since it was last seen (replied to an ARP). I’ve set this timeout to five minutes, or 300 seconds, and that’s seemed to work well enough to consider the device as having left the network.</p>
<p>Admittedly, this is not the “event-driven” solution promised in the title (since we’re polling)… but we’re getting there!</p>
<h3>Arrival</h3>
<p>After the <code data-enlighter-language="generic">wait_for_departure</code> function ends, it is time to kick off the wait for return:</p>
<pre data-enlighter-language="python">def handle_dhcp_packet(packet):
    if DHCP in packet and packet[DHCP].options[0][1] == 3:
        mac_address = packet[Ether].src
        if mac_address == PHONE_MAC_ADDRESS:
            logging.debug(&#34;PHONE IS BACK!&#34;)
            raise ReturnedPacketException
    return


def wait_for_return():
    logging.info(&#34;Waiting for return...&#34;)
    try:
        sniff(filter=&#34;udp and (port 67 or 68)&#34;, prn=handle_dhcp_packet)
    except ReturnedPacketException:
        logging.info(&#34;Returned&#34;)
</pre>
<p>Here we use scapy to start <a href="https://jcutrer.com/python/scapy-dhcp-listener" target="_blank" rel="noopener">sniffing DHCP packets</a> on the network. In the above handler function, we are looking for any “DHCP Request” packets and further filtering them using my device’s MAC address. Once such a packet is seen, indicating I’m back in Wi-Fi range, we raise an Exception and complete the blocking <code data-enlighter-language="generic">wait_for_return</code> function.</p>
<h3>Open Sesame</h3>
<p>After receiving the DHCP packet, it’s time to open the garage door. This was made easy with <a href="https://github.com/arraylabs/pymyq" target="_blank" rel="noopener">pymyq</a>:</p>
<pre data-enlighter-language="python">def open_door():
    async def main() -&gt; None:
        &#34;&#34;&#34;Create the aiohttp session and run.&#34;&#34;&#34;
        async with ClientSession() as websession:
            myq = await pymyq.login(MYQ_USERNAME, MYQ_PASSWORD, websession)
            devices = myq.devices
            await devices[GARAGE_DEVICE_ID].open()
    asyncio.get_event_loop().run_until_complete(main())
</pre>
<p>Again, quick and dirty.</p>
<h2>Final Result</h2>
<p>Putting it all together:</p>
<pre data-enlighter-language="python">def start_process():
    seconds_until_gone = (MINUTES_UNTIL_GONE * 60)
    
    wait_for_departure(seconds_until_gone)
    wait_for_return()
    logging.info(&#34;Opening the garage door...&#34;)
    open_door()
    exit()
</pre>
<p>I wrapped everything up in a small Flask app to serve a simple HTML form on a Raspberry Pi. Clicking Submit launches the <code data-enlighter-language="generic">start_process</code> function as a background process:</p>
<pre data-enlighter-language="generic">@app.get(&#34;/&#34;)
def get():
    csrf_token = generate_csrf()
    return f&#34;&#34;&#34;
     &lt;form method=&#34;post&#34;&gt;
         &lt;input type=&#34;hidden&#34; name=&#34;csrf_token&#34; value=&#34;{escape(csrf_token)}&#34;/&gt;
        &lt;input type=&#34;submit&#34;/&gt;
    &lt;/form&gt;
    &#34;&#34;&#34;


@app.post(&#34;/&#34;)
def post():
    p = multiprocessing.Process(target=start_process)
    p.start()
    return &#34;&lt;p&gt;Started background job...&lt;/p&gt;&#34;
</pre>
<p>Just a note, you may need to use <a href="https://man7.org/linux/man-pages/man8/setcap.8.html" target="_blank" rel="noopener">setcap</a> to add ‘CAP_NET_RAW+eip CAP_NET_ADMIN+eip’ permissions in order to listen to raw packets.</p>
<p>So far, this has been working well. Now when I get home from a cold run, the garage door opens as a I stop at the driveway — completely hands free!</p>
<p><em>Share this: </em>			</p></div><!-- .entry-content -->
</article><!-- #post-## -->

			
			


		
		</main><!-- #main -->
	</div><!-- #primary -->


	<!-- #secondary -->
	</div><!-- #content -->

	<!-- #colophon -->
</div></div>
  </body>
</html>
