<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.joshwcomeau.com/react/server-components/">Original</a>
    <h1>Making sense of React Server Components</h1>
    
    <div id="readability-page-1" class="page"><article data-layout="tutorial"><a id="introduction"><h2>Introduction</h2></a><p>So, here&#39;s something that makes me feel old: React celebrated its 10th birthday this year!</p><p>In the decade since React was first introduced to a bewildered dev community, it’s gone through several evolutions. The React team has not been shy when it comes to radical changes: if they discover a better solution to a problem, they&#39;ll run with it.</p><p>A couple of months ago, the React team unveiled <em>React Server Components,</em> the latest paradigm shift. For the first time ever, React components can run exclusively on the server.</p><p>There&#39;s been <em>so much friggin’ confusion</em> about this online. Lots of folks have lots of questions around what this is, how it works, what the benefits are, and how it fits together with things like Server Side Rendering.</p><p>I&#39;ve been doing a lot of experimentation with React Server Components, and I&#39;ve answered a lot of my own questions. I have to admit, I&#39;m <em>way</em> more excited about this stuff than I expected to be. <em>It&#39;s really cool!</em></p><p>So, my goal today is to help demystify this stuff for you, to answer a lot of the questions you might have about React Server Components!</p><p>To put React Server Components in context, it&#39;s helpful to understand how Server Side Rendering (SSR) works. If you&#39;re already familiar with SSR, feel free to skip to the next heading!</p><p>Originally, React was designed to work exclusively in-browser, on the user&#39;s device. The user would receive an HTML file that looked like this:</p><pre></pre><p>That <code>bundle.js</code> script includes everything we need to mount and run the application, including React, other third-party dependencies, and all of the code we&#39;ve written.</p><p>Once the JS has been downloaded and parsed, React springs into action, conjuring all of the DOM nodes for our entire application, and housing it in that empty <code>&lt;div id=&#34;root&#34;&gt;</code>.</p><p>The problem with this approach is that it takes time to do all of that work. <strong>And while it&#39;s all happening, the user is staring at a blank white screen.</strong> This problem tends to get worse over time: every new feature we ship adds more kilobytes to our JavaScript bundle, prolonging the amount of time that the user has to sit and wait.<span></span></p><p>Server Side Rendering was designed to improve this experience. Instead of sending an empty HTML file, the server will render our application to <em>generate</em> the actual HTML. The user receives a fully-formed HTML document.</p><p>That HTML file will still include the <code>&lt;script&gt;</code> tag, since we still need React to run on the client, to handle any interactivity. But we configure React to work a little bit differently in-browser: instead of conjuring all of the DOM nodes from scratch, it instead <em>adopts</em> the existing HTML. This process is known as <em>hydration.</em></p><p>I like the way React core team member Dan Abramov explains this:</p><blockquote><p>Hydration is like watering the “dry” HTML with the “water” of interactivity and event handlers.</p></blockquote><p>Once the JS bundle has been downloaded, React will quickly run through our entire application, building up a virtual sketch of the UI, and “fitting” it to the real DOM, attaching event handlers, firing off any effects, and so on.</p><p>And so, that&#39;s SSR in a nutshell. A server generates the initial HTML so that users don&#39;t have to stare at an empty white page while the JS bundles are downloaded and parsed. Client-side React then picks up where server-side React left off, adopting the DOM and sprinkling in the interactivity.</p><p>Let&#39;s talk about data-fetching in React. Typically, we&#39;ve had two separate applications that communicate over the network:</p><ul><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><p>A client-side React app</p></li><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><p>A server-side REST API</p></li></ul><p>Using something like React Query or SWR or Apollo, the client would make a network request to the back-end, which would then grab the data from the database and send it back over the network.</p><p>We can visualize this flow using a graph:</p><!--$?--><template id="B:0"></template><!--/$--><p>This first graph shows the flow using a Client Side Rendering (CSR) strategy. It starts with the client receiving an HTML file. This file doesn&#39;t have any content, but it does have one or more <code>&lt;script&gt;</code> tags.</p><p>Once the JS has been downloaded and parsed, our React app will boot up, creating a bunch of DOM nodes and populating the UI. At first, though, we don&#39;t have any of the actual <em>data</em>, so we can only render the shell (the header, the footer, the general layout) with a loading state.</p><p>You&#39;ve probably seen this sort of thing a lot. For example, Airbnb starts by rendering a shell while it fetches the data it needs to populate the actual listings:</p><p>The user will see this loading state until the network request resolves and React re-renders, replacing the loading UI with the real content.</p><p><strong>Let&#39;s look at another way we could architect this.</strong> This next graph keeps the same general data-fetching pattern, but uses <em>Server</em> Side Rendering instead of Client Side Rendering:</p><!--$?--><template id="B:1"></template><!--/$--><p>In this new flow, we perform the first render on the server. This means that the user receives an HTML file that isn&#39;t totally empty.</p><p>This is an improvement — a shell is better than a blank white page — but ultimately, it doesn&#39;t really move the needle in a significant way. The user isn&#39;t visiting our app to see a loading screen, they&#39;re visiting to see the <em>content</em> (rental listings, search results, messages, whatever).</p><p>To really get a sense of the differences in user experience, let&#39;s add some web performance metrics to our graphs. <strong>Toggle between these two flows, and notice what happens to the flags:</strong></p><!--$?--><template id="B:2"></template><!--/$--><p>Each of these flags represents a commonly-used web performance metric. Here&#39;s the breakdown:</p><ol><li><p><strong>First Paint</strong> — The user is no longer staring at a blank white screen. The general layout has been rendered, but the content is still missing. This is sometimes called FCP (First Contentful Paint).</p></li><li><p><strong>Page Interactive</strong> — React has been downloaded, and our application has been rendered/hydrated. Interactive elements are now fully responsive. This is sometimes called TTI (Time To Interactive).</p></li><li><p><strong>Content Paint</strong> — The page now includes the stuff the user cares about. We&#39;ve pulled the data from the database and rendered it in the UI. This is sometimes called LCP (Largest Contentful Paint).</p></li></ol><p>By doing the initial render on the server, we&#39;re able to get that initial “shell” drawn more quickly. This can make the loading experience feel a bit faster, since it provides a sense of progress, that things are happening.</p><p>And, in some situations, this <em>will</em> be a meaningful improvement. For example, maybe the user is only waiting for the header to load so that they can click a navigation link.</p><p><strong>But doesn&#39;t this flow feel a bit silly?</strong> When I look at the SSR graph, I can&#39;t help but notice that the request <em>starts</em> on the server. Instead of requiring a second round-trip network request, why don&#39;t we do the database work <em>during that initial request?</em></p><p>In order words, <strong>why not do something like this?</strong></p><!--$?--><template id="B:3"></template><!--/$--><p>Instead of bouncing back and forth between the client and server, we do our database query as part of the initial request, sending the fully-populated UI straight to the user.</p><p>But hm, how exactly would we do this?</p><p>In order for this to work, we&#39;d need to be able to give React a chunk of code that it runs <em>exclusively</em> on the server, to do the database query. But that hasn&#39;t been an option with React… even with Server Side Rendering, all of our components render on <em>both</em> the server and the client.</p><p><strong>The ecosystem has come up with lots of solutions to this problem.</strong> <span>Meta-frameworks<span>?</span></span> like Next.js and Gatsby have created their own way to run code exclusively on the server.</p><p>For example, here&#39;s what this looked like using Next.js (using the legacy “Pages” router):</p><pre></pre><p><strong>Let&#39;s break this down:</strong> when the server receives a request, the <code>getServerSideProps</code> function is called. It returns a <code>props</code> object. Those props are then funneled into the component, which is rendered first on the server, and then hydrated on the client.</p><p>The clever thing here is that <code>getServerSideProps</code> doesn&#39;t re-run on the client. In fact, this function isn&#39;t even included in our JavaScript bundles!</p><p>This approach was <em>super</em> ahead of its time. Honestly, it&#39;s pretty friggin’ great. But there <em>are</em> some downsides with this:</p><ol><li><p>This strategy only works at the route level, for components at the very top of the tree. We can&#39;t do this in any component.</p></li><li><p>Each meta-framework came up with its own approach. Next.js has one approach, Gatsby has another, Remix has yet another. It hasn&#39;t been standardized.</p></li><li><p>All of our React components will <em>always</em> hydrate on the client, even when there&#39;s no need for them to do so.</p></li></ol><p>For years, the React team has been quietly tinkering on this problem, trying to come up with an official way to solve this problem. Their solution is called <strong>React Server Components.</strong></p><p>At a high level, <em>React Server Components</em> is the name for a brand-new paradigm. In this new world, we can create components that run <em>exclusively on the server</em>. This allows us to do things like write database queries right inside our React components!</p><p>Here&#39;s a quick example of a “Server Component”:</p><pre></pre><p>As someone who has been using React for many years, this code looked <em>absolutely wild</em> to me at first. 😅</p><p>“But wait!”, my instincts screamed. “Function components can&#39;t be asynchronous! And we&#39;re not allowed to have side effects directly in the render like that!”</p><p><strong>The key thing to understand is this:</strong> Server Components never re-render. They run <em>once</em> on the server to generate the UI. The rendered value is sent to the client and locked in place. As far as React is concerned, this output is immutable, and will never change.</p><p>This means that a <em>big chunk</em> of React&#39;s API is incompatible with Server Components. For example, we can&#39;t use state, because state can change, but Server Components can&#39;t re-render. And we can&#39;t use effects because effects only run <em>after</em> the render, on the client, and Server Components never make it to the client.</p><p>It also means that a lot of the old rules don&#39;t apply. For example, in traditional React, we need to put side effects inside a <code>useEffect</code> callback or an event handler or something, so that they don&#39;t repeat on every render. But if the component only runs <em>once</em>, we don&#39;t have to worry about that! We can put the side effects wherever we want.</p><p>Server Components <em>themselves</em> are surprisingly straightforward, but the “React Server Components” paradigm is significantly more complex. This is because we <em>still have</em> regular ol’ components, and the way they fit together can be pretty confusing.</p><p>In this new paradigm, the “traditional” React components we&#39;re familiar with are called <em>Client Components</em>. I&#39;ll be honest, I don&#39;t love this name. 😅</p><p>The name “Client Component” implies that these components <em>only</em> render on the client, but that&#39;s not actually true. <strong>Client Components render on both the client <em>and</em> the server.</strong></p><!--$?--><template id="B:4"></template><!--/$--><p>I know that all this terminology is pretty confusing, so here&#39;s how I&#39;d summarize it:</p><ul><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><p><em>React Server Components</em> is the name for this new paradigm.</p></li><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><p>In this new paradigm, the “standard” React components we know and love have been rebranded as <em>Client Components</em>. It&#39;s a new name for an old thing.</p></li><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><p>This new paradigm introduces a new type of component, <em>Server Components</em>. These new components render exclusively on the server. Their code isn&#39;t included in the JS bundle, and so they never hydrate or re-render.</p></li></ul><p>So, typically, when a new React feature comes out, we can start using it in our existing projects by bumping our React dependency to the latest version. A quick <code>npm install react@latest</code> and we&#39;re off to the races.</p><p>Unfortunately, React Server Components doesn&#39;t work like that.</p><p>My understanding is that React Server Components needs to be tightly integrated with a bunch of stuff outside of React, things like the bundler, the server, and the router.</p><p>As I write this, there&#39;s only one way to start using React Server Components, and that&#39;s with Next.js 13.4+, using their brand-new re-architected “App Router”.</p><p>Hopefully in the future, more React-based frameworks will start to incorporate React Server Components. It feels awkward that a core React feature is only available in one particular tool! The React docs has a <a href="https://react.dev/learn/start-a-new-react-project#bleeding-edge-react-frameworks" rel="noopener noreferrer" target="_blank">“Bleeding-edge frameworks” section</a> where they list the frameworks that support React Server Components; I plan on checking this page from time to time, to see if any new options become available.</p><p>In this new “React Server Components” paradigm, <strong>all components are assumed to be Server Components by default.</strong> We have to “opt in” for Client Components.</p><p>We do this by specifying a brand-new <em>directive</em>:</p><pre></pre><p>That standalone string at the top, <code>&#34;use client&#34;</code>, is how we signal to React that the component(s) in this file are Client Components, that they should be included in our JS bundles so that they can re-render on the client.</p><p>This might <em>seem</em> like an incredibly odd way to specify the type of component we&#39;re creating, but there is a precedent for this sort of thing: the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" rel="noopener noreferrer" target="_blank">&#34;use strict&#34;</a> directive that opts into “Strict Mode” in JavaScript.</p><p>We don&#39;t need to specify the <code>&#34;use server&#34;</code> directive in our Server Components; in the React Server Components paradigm, components are treated as Server Components by default.</p><p>One of the first questions I had when I was getting familiar with React Server Components was this: <em>what happens when the props change?</em></p><p>For example, suppose we had a Server Component like this:</p><pre></pre><p>Let&#39;s suppose that in the initial Server Side Render, <code>hits</code> was equal to <code>0</code>. This component, then, will produce the following markup:</p><pre></pre><p>But what happens if the value of <code>hits</code> changes? Suppose it&#39;s a state variable, and it changes from <code>0</code> to <code>1</code>. <code>HitCounter</code> would need to re-render, but it <em>can&#39;t</em> re-render, because it&#39;s a Server Component!</p><p><strong>The thing is, Server Components don&#39;t really make sense in isolation.</strong> We have to zoom out, to take a more holistic view, to consider the structure of our application.</p><p>Let&#39;s say we have the following component tree:</p><!--$?--><template id="B:5"></template><!--/$--><p>If all of these components are Server Components, then it all makes sense. None of the props will ever change, because none of the components will ever re-render.</p><p>But let&#39;s suppose that <code>Article</code> component owns the <code>hits</code> state variable. In order to use state, we need to convert it to a Client Component:</p><!--$?--><template id="B:6"></template><!--/$--><p>Do you see the issue here? When <code>Article</code> re-renders, any owned components will <em>also</em> re-render, including <code>HitCounter</code> and <code>Discussion</code>. If these are Server Components, though, they <em>can&#39;t</em> re-render.</p><p>In order to prevent this impossible situation, the React team added a rule: <strong>Client Components can only render other Client Components.</strong> When we convert a component to a Client Component, it <em>automatically</em> converts its descendants.</p><p>One of the biggest “ah-ha” moments I had with React Server Components was the realization that this new paradigm is all about creating <em>client/server boundaries</em>. Here&#39;s what winds up happening, in practice:</p><!--$?--><template id="B:7"></template><!--/$--><p>When we add the <code>&#34;use client&#34;</code> directive to the <code>Article</code> component, we create a “client boundary”. All of the components within this boundary are <em>implicitly</em> converted to Client Components. Even though components like <code>HitCounter</code> don&#39;t have the <code>&#34;use client&#34;</code> directive, they&#39;ll still hydrate/render on the client in this particular situation.</p><p>Let&#39;s look at this at a bit of a lower level. When we use a Server Component, what does the output look like? What actually gets generated?</p><p>Let&#39;s start with a super-simple React application:</p><pre></pre><p>In the React Server Components paradigm, all components are Server Components by default. Since we haven&#39;t explicitly marked this component as a Client Component (or rendered it within a client boundary), it&#39;ll only render on the server.</p><p>When we visit this app in the browser, we&#39;ll receive an HTML document which looks something like this:</p><pre></pre><p>We see that our HTML document includes the UI generated by our React application, the “Hello world!” paragraph. This is thanks to Server Side Rendering, and isn&#39;t directly attributable to React Server Components.</p><p>Below that, we have a <code>&lt;script&gt;</code> tag that loads up our JS bundle. This bundle includes the dependencies like React, as well as any Client Components used in our application. And since our <code>Homepage</code> component is a Server Component, the code for that component is <em>not</em> included in this bundle.</p><p>Finally, we have a second <code>&lt;script&gt;</code> tag with some inline JS:</p><pre></pre><p>This is the really interesting bit. Essentially, what we&#39;re doing here is telling React “Hey, so I know you&#39;re missing the <code>Homepage</code> component code, but don&#39;t worry: here&#39;s what it rendered”.</p><p>Typically, when React hydrates on the client, it speed-renders all of the components, building up a virtual representation of the application. It can&#39;t do that for Server Components, because the code isn&#39;t included in the JS bundle.</p><p>And so, we send along the rendered value, the virtual representation that was generated on the server. When React loads on the client, it re-uses that description instead of re-generating it.</p><p>If you&#39;re curious to see <em>true</em> representations of how Server Components are serialized and sent over the network, check out the <a href="https://www.alvar.dev/blog/creating-devtools-for-react-server-components" rel="noopener noreferrer" target="_blank">RSC Devtools</a> by developer Alvar Lagerlöf.</p><p>React Server Components is the first “official” way to run server-exclusive code in React. As I mentioned earlier, though, this isn&#39;t <em>really</em> a new thing in the broader React ecosystem; we&#39;ve been able to run server-exclusive code in Next.js since 2016!</p><p>The big difference is that we&#39;ve never before had a way to run server-exclusive code <em>inside our components.</em></p><p>The most obvious benefit is performance. Server Components don&#39;t get included in our JS bundles, which reduces the amount of JavaScript that needs to be downloaded, and the number of components that need to be hydrated:</p><!--$?--><template id="B:8"></template><!--/$--><p>This is maybe the least exciting thing to me, though. Honestly, most Next.js apps are <em>already</em> fast enough when it comes to “Page Interactive” timing.</p><p>If you follow semantic HTML principles, most of your app should work even before React has hydrated. Links can be followed, forms can be submitted, accordions can be expanded and collapsed (using <code>&lt;details&gt;</code> and <code>&lt;summary&gt;</code>). For most projects, it&#39;s fine if it takes a few seconds for React to hydrate.</p><p><strong>But here&#39;s something I find really cool:</strong> we no longer have to make the same compromises, in terms of features vs. bundle size!</p><p>For example, most technical blogs require some sort of syntax highlighting library. On this blog, I use Prism. The code snippets look like this:</p><pre></pre><p>A proper syntax-highlighting library, with support for all popular programming languages, would be several megabytes, far too large to stick in a JS bundle. As a result, we have to make compromises, trimming out languages and features that aren&#39;t mission-critical.</p><p>But, suppose we do the syntax highlighting <em>in a Server Component.</em> In that case, none of the library code would actually be included in our JS bundles. As a result, we wouldn&#39;t have to make any compromises, we could use all of the bells and whistles.</p><p>This is the big idea behind <a href="https://bright.codehike.org/" rel="noopener noreferrer" target="_blank">Bright</a>, a modern syntax-highlighting package designed to work with React Server Components.</p><span type="default"><img src="https://www.joshwcomeau.com/images/server-components/bright.png" alt=""/></span><p>This is the sort of thing that gets me excited about React Server Components. Things that would be too cost-prohibitive to include in a JS bundle can now run on the server <em>for free,</em> adding zero kilobytes to our bundles, and producing an even better user experience.</p><p>It&#39;s not just about performance and UX either. After working with RSC for a while, I&#39;ve come to really appreciate how easy-breezy Server Components are. We never have to worry about dependency arrays, stale closures, memoization, or any of the other complex stuff caused by <em>things changing.</em></p><p>Ultimately, it&#39;s still very early days. React Server Components only emerged from beta a couple of months ago! I&#39;m really excited to see how things evolve over the next couple of years, as the community continues to innovate new solutions like Bright, taking advantage of this new paradigm. It&#39;s an exciting time to be a React developer!</p><p>React Server Components is an exciting development, but it&#39;s actually only one part of the “Modern React” puzzle.</p><p>Things get <em>really</em> interesting when we combine React Server Components with Suspense and the new Streaming SSR architecture. It allows us to do <em>wild</em> stuff like this:</p><!--$?--><template id="B:9"></template><!--/$--><p>It&#39;s beyond the scope of this tutorial, but you can learn more about this architecture <a href="https://github.com/reactwg/react-18/discussions/37" rel="noopener noreferrer" target="_blank">on Github</a>. Also, we explore all of this fancy modern stuff in my soon-to-be-released course, <a href="https://joyofreact.com/" rel="noopener noreferrer" target="_blank">The Joy of React</a>!</p><p>The Joy of React is a beginner-friendly interactive course, designed to help you build an intuition for how React works. We start at the very beginning (no prior React experience required), and work our way through some of the most notoriously-tricky aspects of React.</p><p>This course has been my full-time focus for almost two years now, and it includes all of the most important stuff I&#39;ve learned about React in over 8 years of experience.</p><p>You&#39;ll even learn how to do next-level layout animations like this, using Framer Motion:</p><p><strong>This course releases next week, on September 13th.</strong> You can learn much more about the course here:</p><ul><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span></li></ul><svg preserveAspectRatio="none" fill="none" style="width:100%;max-width:100px"><line x1="0" y1="0" x2="20" y2="10"></line><line x1="20" y1="0" x2="40" y2="10"></line><line x1="40" y1="0" x2="60" y2="10"></line><line x1="60" y1="0" x2="80" y2="10"></line><line x1="80" y1="0" x2="100" y2="10"></line></svg><p>React Server Components is a significant paradigm shift. Personally, I&#39;m <em>super</em> keen to see how things develop over the next couple of years, as the ecosystem builds more tools like Bright that takes advantage of Server Components.</p><p>I have the feeling that building in React is about to get even cooler. 😄</p><div><div><h3>Last Updated</h3><p>September 6th, 2023</p></div></div></article></div>
  </body>
</html>
