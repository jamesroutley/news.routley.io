<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matt-rickard.com/the-unreasonable-effectiveness-of-makefiles">Original</a>
    <h1>The Unreasonable Effectiveness of Makefiles</h1>
    
    <div id="readability-page-1" class="page"><div id="__next"><div><div><p><span><div><p>Aug 12, 2022</p><article><div><p>Few tools walk the right line between declarative and imperative like <code>make</code>. </p><blockquote>Make originated with a visit from Steve Johnson (author of yacc, etc.), storming into my office, cursing the Fates that had caused him to waste a morning debugging a correct program (bug had been fixed, file hadn&#39;t been compiled, <code>cc *.o</code> was therefore unaffected). As I had spent a part of the previous evening coping with the same disaster on a project I was working on, the idea of a tool to solve it came up. It began with an elaborate idea of a dependency analyzer, boiled down to something much simpler, and turned into Make that weekend. Use of tools that were still wet was part of the culture. <strong>Makefiles were text files, not magically encoded binaries, because that was the Unix ethos</strong>: printable, debuggable, understandable stuff. </blockquote><p><code>make</code> build a directed-acyclic build graph (DAG) of dependencies, and uses file modification times to decide whether or not the outputs need to be rebuilt.</p><p>Why is <code>make</code> so successful?</p><ul><li>Does not manage the state itself. No database of file modification times, checksums, or build output files that could cause bad states to happen. Instead, <code>make</code> just compares the file modification times of the outputs to the inputs.</li><li>Not <em>fully</em> declarative. While this is an undesirable property for excessively large systems, it is good enough for 80% of projects (Pareto principle for build systems). Declarative-ish syntax for the rules you care about and simple <code>PHONY</code> rules for tasks you don&#39;t. </li><li>Easy escape hatches. <code>Makefile</code> syntax isn&#39;t great for complicated configurations. Using <code>make</code> as the entry point for a variety of <code>bash</code> scripts usually isn&#39;t too bad.</li><li>For most configurations, not excessively templated. In some ways, the tough-to-learn syntax has prevented <code>Makefiles</code> from looking like Helm charts or Jinja templates.</li><li>Other <a href="https://matt-rickard.com/observations-of-the-lindy-effect">Lindy</a> reasons we might not know.</li></ul><p>Of course, there&#39;s always room for improvements in a 46-year-old piece of software. Some of these features might be out of scope, but a short list of ideas.</p><ul><li>Reconciling docker builds with makefile targets in <a href="https://matt-rickard.com/make-docker">$ make docker</a><strong>. </strong>Many language-specific tools already do a weak form of this â€“ <code>yarn</code> or <code>npm</code> will runs tasks in the context of your <code>node_modules</code> directory. Docker provides a much more generalized and cacheable substrate to run tasks. It also works well with DAG structure and <code>make</code>&#39;s semi-declarative nature.</li><li>First-class support for configuration languages like <code>JSON</code>, maybe <code>jq</code> built-in? Much like pattern substitution and wildcards, a little bit of optimization here could go a long way.</li><li>A dependency framework or flexible type system like <a href="https://matt-rickard.com/why-typescript-for-infrastructure">Why TypeScript for Infrastructure?</a> You can <code>include</code> Makefiles, but the behavior is not very intuitive and difficult to debug. Although this might be one of the strengths of a <code>Makefile</code>.</li><li>File-watcher or live-reloading. You can create a build/deploy loop fairly easily, but having knowledge of the DAG simplifies this for developers. That&#39;s how <code><a href="https://skaffold.dev/">skaffold</a></code> works.</li></ul></div></article></div><div><div><p>Subscribe for daily posts on startups &amp; engineering.</p></div></div></span></p></div></div></div></div>
  </body>
</html>
