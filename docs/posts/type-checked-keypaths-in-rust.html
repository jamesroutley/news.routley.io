<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.cmyr.net/blog/keypaths.html">Original</a>
    <h1>Type-checked keypaths in Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
      <article>

        

        <p>Like <a href="https://beachape.com/blog/2021/05/25/structural-typing-in-rust/">a number</a> <a href="https://www.jakobmeier.ch/blogging/Untapped-Rust.html">of other folks</a>, I have recently been exploring some slightly less well-worn corners of the Rust type system. In my particular case, this involves revisiting Swift-style <a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift/">keypaths</a>. My previous experiments in this direction (which began at the <a href="https://www.recurse.com">recurse center</a>) have
never really gone anywhere, but recently I’ve come up with a new approach that
feels promising; a preliminary sketch of this work is available as the <a href="https://docs.rs/keypath"><code>keypath</code></a> crate. With this crate, you can write the following:</p>

<div><div><pre><code><span>#[derive(Keyable)]</span>
<span>struct</span> <span>Playlist</span> <span>{</span>
    <span>songs</span><span>:</span> <span>Vec</span><span>&lt;</span><span>Song</span><span>&gt;</span><span>,</span>
<span>}</span>

<span>#[derive(Keyable)]</span>
<span>struct</span> <span>Song</span> <span>{</span>
    <span>name</span><span>:</span> <span>String</span><span>,</span>
    <span>artist</span><span>:</span> <span>String</span><span>,</span>
    <span>length</span><span>:</span> <span>u32</span><span>,</span>
    <span>favourite</span><span>:</span> <span>bool</span><span>,</span>
<span>}</span>

<span>fn</span> <span>main</span><span>()</span> <span>{</span>
    <span>let</span> <span>playlist</span> <span>=</span> <span>make_sample_playlist</span><span>();</span>
    <span>let</span> <span>first_song_name</span> <span>=</span> <span>keypath!</span><span>(</span><span>Playlist</span><span>.songs</span><span>[</span><span>0</span><span>]</span><span>.name</span><span>);</span>
    <span>println!</span><span>(</span><span>&#34;first song title: {}&#34;</span><span>,</span> <span>playlist</span><span>[</span><span>&amp;</span><span>first_song_name</span><span>]);</span>
<span>}</span>
</code></pre></div></div>

<h2 id="motivation">Motivation</h2>

<p>The idea behind a keypath is that it provides an uninvoked reference to a
field on some type, and that field can be arbitrarily deep in a graph of
objects.</p>

<p>This is particularly interesting to me in the context of my work on <a href="https://github.com/linebender/druid">Druid</a>, and more generally exploring patterns for building GUIs in Rust. Recently I have been spending quite a bit of time studying SwiftUI, where keypaths are used heavily. They can be helpful in a number of ways: for instance if you make a caller mutate something by passing a value and a keypath, you can apply custom update logic before or after the mutation (such as invalidating some dependency, or scheduling a redraw); similarly by abstracting away field access from the fields themselves, you can do fancy things like transparently delegate certain properties to an inner type. More prosaically, they provide a simple and ergonomic way to declare data relationships. For instance, imagine we have a have a <code>Checkbox</code> widget; we want this widget to toggle a <code>bool</code> when it is clicked, but we do not otherwise care about the data that bool comes from. We might have something like,</p>

<div><div><pre><code><span>let</span> <span>checkbox</span> <span>=</span> <span>Checkbox</span><span>::</span><span>new</span><span>(</span><span>keypath!</span><span>(</span><span>Playlist</span><span>.now_playing.favourite</span><span>));</span>
</code></pre></div></div>

<p>Without keypaths, the main way you might do something like this would probably be with closures, and you’d need separate closures for reading and writing:</p>

<div><div><pre><code><span>let</span> <span>checkbox</span><span>:</span> <span>Checkbox</span><span>&lt;</span><span>Playlist</span><span>&gt;</span> <span>=</span> <span>Checkbox</span><span>::</span><span>new</span><span>(</span>
    <span>|</span><span>playlist</span><span>|</span> <span>&amp;</span><span>playlist</span><span>.now_playing.favourite</span><span>,</span>
    <span>|</span><span>playlist</span><span>|</span> <span>&amp;</span><span>mut</span> <span>playlist</span><span>.now_playing.favourite</span><span>);</span>
</code></pre></div></div>

<p>In this simple case, keypaths are easier to use and easier to reason about.</p>

<h2 id="implementation">Implementation</h2>

<p>I think it’s helpful to explain the implementation in two parts: the <em>path
traversal</em> part, which is relatively straight-forward, and the <em>type checking</em>
part, which is hackier.</p>

<h3 id="path-traversal">Path traversal</h3>

<p>Ultimately, the path traversal component of this work is not especially
complicated. Types that wish to participate in keypaths have to implement the
following trait:</p>

<div><div><pre><code><span>/// A trait for types that expose their properties via keypath.</span>
<span>pub</span> <span>trait</span> <span>RawKeyable</span><span>:</span> <span>&#39;static</span> <span>{</span>
    <span>fn</span> <span>as_any</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>dyn</span> <span>Any</span><span>;</span>
    <span>fn</span> <span>as_any_mut</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>mut</span> <span>dyn</span> <span>Any</span><span>;</span>
    <span>fn</span> <span>get_field</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> <span>path</span><span>:</span> <span>&amp;</span><span>[</span><span>PathComponent</span><span>])</span>
        <span>-&gt;</span> <span>Result</span><span>&lt;&amp;</span><span>dyn</span> <span>RawKeyable</span><span>,</span> <span>FieldError</span><span>&gt;</span><span>;</span>
    <span>fn</span> <span>get_field_mut</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> <span>path</span><span>:</span> <span>&amp;</span><span>[</span><span>PathComponent</span><span>])</span>
        <span>-&gt;</span> <span>Result</span><span>&lt;&amp;</span><span>mut</span> <span>dyn</span> <span>RawKeyable</span><span>,</span> <span>FieldError</span><span>&gt;</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Where <code>PathComponent</code> is an enum of different possible ‘members’ a type
might have, which currently looks like this (although it may certainly expand or change in the future):</p>

<div><div><pre><code><span>/// A component of a keypath.</span>
<span>#[derive(Debug,</span> <span>Clone,</span> <span>Copy)]</span>
<span>pub</span> <span>enum</span> <span>PathComponent</span> <span>{</span>
    <span>/// An unnamed field, such as on a tuple or tuple struct</span>
    <span>Unnamed</span><span>(</span><span>usize</span><span>),</span>
    <span>/// A named field.</span>
    <span>Named</span><span>(</span><span>&amp;</span><span>&#39;static</span> <span>str</span><span>),</span>
    <span>/// An index into a sequence, such as a vec.</span>
    <span>IndexInt</span><span>(</span><span>usize</span><span>),</span>
    <span>/// An index into a map with string keys.</span>
    <span>IndexStr</span><span>(</span><span>&amp;</span><span>&#39;static</span> <span>str</span><span>),</span>
<span>}</span>
</code></pre></div></div>

<p>In any case, all of the work here is done in the <code>get_field[_mut]</code> methods.
These are called recursively, starting at the top object; at each layer, the
implementor looks at the <code>path</code> slice. If it is <em>empty</em>, it means we’re at the
end of the path, and we return <code>self</code>. Otherwise, we split off the first item in the path, and see if we have have a corresponding ‘member’. If we do, we call that member with the rest of the path, and if not we return an error.</p>

<p>As a concrete example, here is what an implementation might look like for a
simple type (ignoring the <code>_mut</code> methods, which are trivially similar to their non-mut equivalents):</p>

<div><div><pre><code><span>struct</span> <span>Person</span> <span>{</span>
    <span>name</span><span>:</span> <span>String</span><span>,</span>
    <span>friends</span><span>:</span> <span>Vec</span><span>&lt;</span><span>String</span><span>&gt;</span><span>,</span>
<span>}</span>

<span>impl</span> <span>RawKeyable</span> <span>for</span> <span>Person</span> <span>{</span>
    <span>fn</span> <span>as_any</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>dyn</span> <span>Any</span> <span>{</span>
        <span>self</span>
    <span>}</span>

    <span>fn</span> <span>get_field</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> <span>path</span><span>:</span> <span>&amp;</span><span>[</span><span>PathComponent</span><span>])</span> <span>-&gt;</span> <span>Result</span><span>&lt;&amp;</span><span>dyn</span> <span>RawKeyable</span><span>,</span>
    <span>FieldError</span><span>&gt;</span> <span>{</span>
        <span>let</span> <span>(</span><span>head</span><span>,</span> <span>rest</span><span>)</span> <span>=</span> <span>match</span> <span>path</span><span>.split_first</span><span>()</span> <span>{</span>
            <span>None</span> <span>=&gt;</span> <span>return</span> <span>Ok</span><span>(</span><span>self</span><span>),</span>
            <span>Some</span><span>(</span><span>tup</span><span>)</span> <span>=&gt;</span> <span>tup</span><span>,</span>
        <span>};</span>

        <span>match</span> <span>head</span> <span>{</span>
            <span>PathComponent</span><span>::</span><span>Named</span><span>(</span><span>&#34;name&#34;</span><span>)</span> <span>=&gt;</span> <span>self</span><span>.name</span><span>.get_field</span><span>(</span><span>rest</span><span>),</span>
            <span>PathComponent</span><span>::</span><span>Named</span><span>(</span><span>&#34;friends&#34;</span><span>)</span> <span>=&gt;</span> <span>self</span><span>.friends</span><span>.get_field</span><span>(</span><span>rest</span><span>),</span>
            <span>_</span> <span>=&gt;</span> <span>Err</span><span>(</span><span>FieldError</span><span>::</span><span>some_error</span><span>())</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>This fairly simple trait gets us pretty far: we can make a slice of
<code>PathComponent</code>s, pass it to the appropriate type, and if the path exists we will get back a <code>&amp;dyn RawKeyable</code>, which we can then try to downcast to a concrete type, by going through <code>as_any</code>. Putting this all together, we could write something like,</p>

<div><div><pre><code><span>let</span> <span>person</span> <span>=</span> <span>Person</span> <span>{</span>
    <span>name</span><span>:</span> <span>&#34;coco&#34;</span><span>.to_string</span><span>(),</span>
    <span>friends</span><span>:</span> <span>vec!</span><span>[</span><span>&#34;kiki&#34;</span><span>.to_string</span><span>(),</span> <span>&#34;jojo&#34;</span><span>.to_string</span><span>()],</span>
<span>}</span>

<span>let</span> <span>path</span> <span>=</span> <span>&amp;</span><span>[</span><span>PathComponent</span><span>::</span><span>Named</span><span>(</span><span>&#34;friends&#34;</span><span>),</span> <span>PathComponent</span><span>::</span><span>IndexInt</span><span>(</span><span>0</span><span>)];</span>
<span>let</span> <span>kiki</span> <span>=</span> <span>person</span><span>.get_field</span><span>(</span><span>&amp;</span><span>path</span><span>)</span><span>.unwrap</span><span>()</span><span>.as_any</span><span>()</span><span>.downcast_ref</span><span>::</span><span>&lt;</span><span>String</span><span>&gt;</span><span>();</span>
<span>assert_eq!</span><span>(</span><span>kiki</span><span>.unwrap</span><span>(),</span> <span>&#34;kiki&#34;</span><span>);</span>
</code></pre></div></div>

<p>What is especially compelling about this approach is that (at least in clear cases like
this) the compiler is smart enough to figure out what we’re doing, and when
building for <code>--release</code> this generates the same code as direct field
access (<a href="https://godbolt.org/z/nh7oq7Tc60">see godbolt</a>).</p>

<h2 id="compile-time-type-checking">Compile-time type-checking</h2>

<p>While path traversal is important, it is the least exciting of the two parts of
the story. The bit I find especially interesting is built on top of that
traversal, and lets us validate at compile time <em>that a given keypath exists</em>, and that the to generate a strongly-typed <code>KeyPath</code> object that represents that known route, as well as the types of the first object and the final value. We then take advantage of this with a new trait, that allows
infallible access to the values of known keypaths, which lets us write code like
this:</p>

<div><div><pre><code><span>let</span> <span>kiki</span><span>:</span> <span>Keypath</span><span>&lt;</span><span>Person</span><span>,</span> <span>String</span><span>&gt;</span> <span>=</span> <span>keypath!</span><span>(</span><span>Person</span><span>.friends_names</span><span>[</span><span>0</span><span>]);</span>
<span>assert_eq!</span><span>(</span><span>person</span><span>[</span><span>&amp;</span><span>kiki</span><span>],</span> <span>&#34;kiki&#34;</span><span>);</span>
</code></pre></div></div>

<h3 id="implementation-1">Implementation</h3>

<p>Getting this working was… a journey. Beyond just stretching my comfort with
Rust, it stretches my ability to <em>communicate</em> about Rust.</p>

<p>Our goal is simple enough: we want a way to generate code, at compile time, that
can verify that a particular path exists, starting at a base type (the <em>root</em>)
and ending up at some other type (the <em>value</em>). Importantly, we need to do this
with only access to <em>types</em>; we can’t work with actual <em>instances</em> of those
types. This sort of type-level programming is tricky in Rust.</p>

<p>To explain the eventual solution, I will first sketch out what an ‘ideal’
solution might look like: by this I mean a fairly clear, plausible-seeming
implementation strategy.</p>

<h3 id="what-we-want">What we want</h3>

<p>Let’s start with a <code>KeyPath</code> type, that looks something like:</p>

<div><div><pre><code><span>KeyPath</span><span>&lt;</span><span>Root</span><span>,</span> <span>Value</span><span>&gt;</span> <span>{</span>
    <span>_</span><span>root</span><span>:</span> <span>PhantomData</span><span>&lt;</span><span>Root</span><span>&gt;</span><span>,</span>
    <span>_</span><span>value</span><span>:</span> <span>PhantomData</span><span>&lt;</span><span>Value</span><span>&gt;</span><span>,</span>
    <span>path</span><span>:</span> <span>Vec</span><span>&lt;</span><span>PathComponent</span><span>&gt;</span><span>,</span>
<span>}</span>
</code></pre></div></div>

<p>For the purpose of these examples, let’s work with the following structs:</p>
<div><div><pre><code><span>struct</span> <span>Person</span> <span>{</span>
    <span>name</span><span>:</span> <span>String</span><span>,</span>
    <span>stats</span><span>:</span> <span>Stats</span><span>,</span>
<span>}</span>

<span>struct</span> <span>Stats</span> <span>{</span>
    <span>// in furlongs per fortnight</span>
    <span>speed</span><span>:</span> <span>f32</span><span>,</span>
    <span>// in kilograms per meter per second</span>
    <span>viscosity</span><span>:</span> <span>f32</span><span>,</span>
<span>}</span>
</code></pre></div></div>

<p>We would like to be able to write <code>keypath!(Person.stats.speed)</code>, and generate a
<code>KeyPath&lt;Person, f32&gt;</code>; and we would like <code>keypath!(Person.stats.missing_field)</code>
to fail to compile. What should this look like?</p>

<p>As a first approach, maybe we could do all of the work in the <code>KeyPath</code> type, by
defining the routes in impl blocks there; and then we need some way of getting a
‘root’ keypath to begin from. For instance, here, we might have:</p>

<div><div><pre><code><span>impl</span> <span>Person</span> <span>{</span>
    <span>fn</span> <span>__</span><span>keypath_root</span><span>()</span> <span>-&gt;</span> <span>KeyPath</span><span>&lt;</span><span>Person</span><span>,</span> <span>Person</span><span>&gt;</span> <span>{</span>
        <span>KeyPath</span><span>::</span><span>infer_types</span><span>(</span><span>vec!</span><span>[])</span>
    <span>}</span>
<span>}</span>

<span>impl</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>KeyPath</span><span>&lt;</span><span>T</span><span>,</span> <span>Person</span><span>&gt;</span> <span>{</span>
    <span>fn</span> <span>name</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>KeyPath</span><span>&lt;</span><span>Person</span><span>,</span> <span>String</span><span>&gt;</span> <span>{</span>
        <span>let</span> <span>mut</span> <span>path</span> <span>=</span> <span>self</span><span>.path</span><span>;</span>
        <span>path</span><span>.append</span><span>(</span><span>PathComponent</span><span>::</span><span>Named</span><span>(</span><span>&#34;name&#34;</span><span>));</span>
        <span>KeyPath</span><span>::</span><span>infer_types</span><span>(</span><span>path</span><span>)</span>
    <span>}</span>
    <span>fn</span> <span>stats</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>KeyPath</span><span>&lt;</span><span>Person</span><span>,</span> <span>Stats</span><span>&gt;</span> <span>{</span> <span>/* generate keypath */</span> <span>}</span>
<span>}</span>

<span>impl</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>KeyPath</span><span>&lt;</span><span>T</span><span>,</span> <span>Stats</span><span>&gt;</span> <span>{</span>
    <span>fn</span> <span>speed</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>KeyPath</span><span>&lt;</span><span>Person</span><span>,</span> <span>f32</span><span>&gt;</span> <span>{</span> <span>/* generate keypath */</span> <span>}</span>
    <span>fn</span> <span>viscosity</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>KeyPath</span><span>&lt;</span><span>Person</span><span>,</span> <span>f32</span><span>&gt;</span> <span>{</span> <span>/* generate keypath */</span> <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>And then we could imagine generating code that looked like,</p>

<div><div><pre><code><span>let</span> <span>valid_keypath</span> <span>=</span> <span>Person</span><span>::</span><span>__</span><span>keypath_root</span><span>()</span><span>.stats</span><span>()</span><span>.speed</span><span>();</span>
</code></pre></div></div>

<p>That looks nice! Unfortunately, this approach does not work. The first problem
is with the ‘inherent impl’ that we declare for the different <code>KeyPath</code> types;
that is, the routes. Rust does not allow you to make ‘inherent impl’ for a type
in an external crate; in this case, the <code>KeyPath</code> type is declared in the
<code>keypath</code> crate, which means it is external to wherever this code is being
generated. We could work around this by requiring the user to declare an
appropriate <code>KeyPath</code> struct in their crate root, but then we bump into the
second problem: we’re also using inherent impls to generate the <em>root</em> keypaths,
so there would be no way to add get the root keypath for a <code>std</code> type like a
<code>HashMap</code> or a <code>Vec</code>, and that does not feel like an acceptable limitation.</p>

<h3 id="what-we-get">What we get</h3>

<p>After experimenting with a bunch of ways to try and make this work, I settled on
something that is slightly less elegant; this involves generating ‘mirror’
structs. The basic idea is that each participating type implements a trait that
has an associated type, the <em>mirror</em>.</p>

<div><div><pre><code><span>trait</span> <span>Keyable</span> <span>{</span>
    <span>type</span> <span>Mirror</span><span>;</span>
    <span>fn</span> <span>mirror</span><span>()</span> <span>-&gt;</span> <span>Self</span><span>::</span><span>Mirror</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>The mirror type itself is a way of inspecting the types of the fields on the
main struct; the mirror has the same fields as the parent type, but those fields
themselves return the mirror of the type of the parent’s corresponding field.</p>

<div><div><pre><code><span>struct</span> <span>Stats</span> <span>{</span>
    <span>// in furlongs per fortnight</span>
    <span>speed</span><span>:</span> <span>f32</span><span>,</span>
    <span>// in kilograms per meter per second</span>
    <span>viscosity</span><span>:</span> <span>f32</span><span>,</span>
<span>}</span>

<span>struct</span> <span>StatsMirror</span> <span>{</span>
    <span>speed</span><span>:</span> <span>&lt;</span><span>f32</span> <span>as</span> <span>Keyable</span><span>&gt;</span><span>::</span><span>Mirror</span><span>,</span>
    <span>viscosity</span><span>:</span> <span>&lt;</span><span>f32</span> <span>as</span> <span>Keyable</span><span>&gt;</span><span>::</span><span>Mirror</span><span>,</span>
<span>}</span>
</code></pre></div></div>

<p><em>Aside: it was only when writing this up that I realized the above syntax was even legal; prior to this I was doing another weird trick to declare the fields</em>.</p>

<p>(For non-fields (indexes into collections) mirrors have specially-named methods
that return the mirror of the collection’s member type.)</p>

<p>This gives us a nice way to check at compile-time that fields exist; the final
step is to create the correct <code>KeyPath</code> type once we’ve verified the path. This
is simple enough; we know the root type already, and we know the type of the
mirrored object when we generate the mirror; so we can just add a method to each
mirror type that looks like,</p>

<div><div><pre><code><span>impl</span> <span>StatsMirror</span> <span>{</span>
    <span>fn</span> <span>to_key_path_with_root</span><span>&lt;</span><span>Root</span><span>&gt;</span><span>(</span><span>self</span><span>,</span> <span>fields</span><span>:</span> <span>&amp;</span><span>[</span><span>PathComponent</span><span>])</span>
        <span>-&gt;</span> <span>KeyPath</span><span>&lt;</span><span>Root</span><span>,</span> <span>Stats</span><span>&gt;</span> <span>{</span> <span>/* */</span> <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>Put this all together, and the code <code>let path = keypath!(Person.stats.speed);</code>
ends up generating (approximately) the following code:</p>

<div><div><pre><code><span>let</span> <span>path</span> <span>=</span> <span>Person</span><span>::</span><span>mirror</span><span>()</span>
    <span>.size</span>
    <span>.height</span>
    <span>.to_key_path_with_root</span><span>::</span><span>&lt;</span><span>Person</span><span>&gt;</span><span>(</span><span>&amp;</span><span>[</span>
        <span>PathComponent</span><span>::</span><span>Named</span><span>(</span><span>&#34;stats&#34;</span><span>),</span>
        <span>PathComponent</span><span>::</span><span>Named</span><span>(</span><span>&#34;speed&#34;</span><span>)</span>
    <span>]);</span>
</code></pre></div></div>

<p>And that works just fine. A nice quality of the mirror objects is that they are
all zero-sized types, and shouldn’t have any impact on the generated binary;
they’re only used at compile-time, to ensure that paths are valid. (Impact on
compile <em>time</em> is still possible, and I haven’t investigated that enough to say
anything useful).</p>

<h3 id="codegen-and-performance">Codegen and performance</h3>

<p>Despite all of the use of <code>Any</code> and all the generated types, the generated code can be quite efficient. In particular the ‘mirror’ types are all zero-sized, and don’t make it into the final binary; and in many cases the traversal of the fields can be inlined, and the generated code for accessing a keypath looks identical to direct field access.</p>

<p>The main overhead is in the additional code generated for the <code>Keyable</code> trait, but this should be modest in comparison to the code that is generated for things like <code>serde</code>.</p>

<p>I haven’t investigated performance as deeply as I hope to, but the preliminary indications are encouraging.</p>

<h2 id="some-possible-next-steps">Some possible next steps</h2>

<p>My focus thus far has been on proving out the concept: figuring out how to
traverse the object graph, and then figuring out how to generate type
information at compile time. This seems to work, but I haven’t put much work
into <em>making it useful</em>, although I have some ideas in this direction.</p>

<h3 id="refine-the-api">refine the API</h3>

<p>An important next step is going to be figuring out what the API should look
like. Currently, we only support strongly-typed keys, but we may want to
consider a sort of hierarchy of types. Swift distinguishes between
<a href="https://developer.apple.com/documentation/swift/anykeypath"><code>AnyKeyPath</code></a> (with neither root nor value types known) <a href="https://developer.apple.com/documentation/swift/partialkeypath"><code>PartialKeyPath</code></a>
(with only the root type known) and <a href="https://developer.apple.com/documentation/swift/keypath"><code>KeyPath</code></a>, which knows both. In
particular, <a href="https://developer.apple.com/documentation/swift/partialkeypath"><code>PartialKeyPath</code></a> may be useful in that you could store paths with
different value types in a single collection. It might also be interesting to do things like allow types to inspect and override paths, or to provide custom ‘fields’ backed by functions, etcetera. Similarly the <code>derive</code> macro could be improved with the addition of various attributes and customizations, and it could be possible to support keypaths for enums, with collection-like behaviour; if a given path is only valid for a subset of enum variants, it could resolve to <code>Option&lt;T&gt;</code>.</p>

<h3 id="better-collection-support">Better collection support</h3>

<p>Currently collection access will panic at runtime if a key or index doesn’t
exist in the collection. I would like to refine this, and either make collection
access always return some sort of <code>Option</code> type, or else introduce syntax into
the macro to allow the user to opt-in to cascading optionals. For instance, we
might have syntax like,</p>

<div><div><pre><code><span>let</span> <span>key</span><span>:</span> <span>KeyPath</span><span>&lt;</span><span>Person</span><span>,</span> <span>u16</span><span>&gt;</span> <span>=</span> <span>keypath!</span><span>(</span><span>Person</span><span>.friends</span><span>[</span><span>0</span><span>]</span><span>.age</span><span>);</span>
<span>let</span> <span>opt_key</span><span>:</span> <span>KeyPath</span><span>&lt;</span><span>Person</span><span>,</span> <span>Option</span><span>&lt;</span><span>u16</span><span>&gt;&gt;</span> <span>=</span> <span>keypath!</span><span>(</span><span>Person</span><span>.friends</span><span>[</span><span>0</span><span>]</span><span>?</span><span>.age</span><span>);</span>
</code></pre></div></div>
<p>where explicitly providing a <code>?</code> in the keypath allows the collection access to
return an <code>Option&lt;T&gt;</code> that is propagated through to the user.</p>

<p>In addition, it may be interesting to provide an additional API for working with
types like <a href="https://docs.rs/serde_json/1.0.64/serde_json/enum.Value.html"><code>serde_json::Value</code></a>, which contain heterogeneous data. The idea
here is that it would be nice to be able to retrieve specific forms of data from
these sorts of collections, so that you can attempt to retrieve a key as a
<code>u64</code>, instead of as a <code>serde_json::Number</code>.</p>

<h3 id="fun-stuff-predicates-orderings-etc">Fun stuff: predicates, orderings, etc</h3>

<p>Another possible case for keypaths is as a DSL for creating predicates and
orderings for things like constructing database queries or filtering
collections. We could imagine writing something like,</p>

<div><div><pre><code><span>let</span> <span>keypath</span><span>:</span> <span>KeyPath</span><span>&lt;</span><span>Person</span><span>,</span> <span>DateTime</span><span>&gt;</span> <span>=</span> <span>keypath!</span><span>(</span><span>Person</span><span>.registration.date</span><span>);</span>
<span>let</span> <span>is_old_user</span><span>:</span> <span>Predicate</span><span>&lt;</span><span>Person</span><span>&gt;</span> <span>=</span> <span>keypath</span><span>.less_than</span><span>(</span><span>REFERENCE_DATE</span><span>);</span>
<span>let</span> <span>is_precocious</span><span>:</span> <span>Predicate</span><span>&lt;</span><span>Person</span><span>&gt;</span> <span>=</span> <span>keypath!</span><span>(</span><span>Person</span><span>.info.age</span><span>)</span><span>.less_than</span><span>(</span><span>3</span><span>);</span>
<span>// oh no:</span>
<span>let</span> <span>extremely_precocious</span> <span>=</span> <span>is_old_user</span> <span>&amp;&amp;</span> <span>is_precocious</span><span>;</span>

<span>for</span> <span>person</span> <span>in</span> <span>data</span><span>.people</span><span>.iter</span><span>()</span><span>.filter_by_predicate</span><span>(</span><span>&amp;</span><span>extremely_precocious</span><span>)</span> <span>{</span>
    <span>/* hihi */</span>
<span>}</span>
</code></pre></div></div>

<p>Or for orderings,</p>

<div><div><pre><code><span>let</span> <span>ordering</span><span>:</span> <span>Ordering</span><span>&lt;</span><span>Person</span><span>&gt;</span> <span>=</span> <span>keypath!</span><span>(</span><span>Person</span><span>.rank</span><span>)</span>
    <span>.descending</span><span>()</span>
    <span>.then</span><span>(</span><span>keypath!</span><span>(</span><span>Person</span><span>.registration.signup_date</span><span>)</span><span>.ascending</span><span>())</span>

<span>data</span><span>.people</span><span>.sort_by_ordering</span><span>(</span><span>&amp;</span><span>ordering</span><span>);</span>
</code></pre></div></div>

<p>In any case this is all very speculative, and intended primarily as an
illustration of some of the things that this might make possible.</p>

<h2 id="conclusions">conclusions</h2>

<p>This work is not quite developed enough to be currently <em>useful</em>, but I do think
it’s at a point where it’s worth sharing. In particular, I think there are a
bunch of possible directions for this work that could be interesting, and I’m
sure there are lots of good ideas that just haven’t occurred to me personally. I
also have some reservations about the implementation, and I’m curious if there
are problems with my approach that I haven’t identified yet.</p>


      </article>

    </div></div>
  </body>
</html>
