<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://getgrapevine.ai/">Original</a>
    <h1>Launch HN: Grapevine (YC S19) – A company GPT that actually works</h1>
    
    <div id="readability-page-1" class="page"><div><p><span>Forced Browser-Based Zoom Extension</span><span></span></p></div><div><astro-slot> <div>  
<ul>
<li><a href="#the-idea">The Idea</a></li>
<li><a href="#research">Research</a></li>
<li><a href="#implementation">Implementation</a>
<ul>
<li><a href="#development">Development</a></li>
<li><a href="#redirecting">Redirecting</a></li>
<li><a href="#clicking-past">Clicking Past</a></li>
</ul>
</li>
<li><a href="#distributions">Distributions</a>
<ul>
<li><a href="#chrome">Chrome</a></li>
<li><a href="#firefox">Firefox</a></li>
</ul>
</li>
</ul>

<p>It’s just always a pain to deal with Zoom. Screen share often just doesn’t work
right, the UI glitches out, audio is a mess and very inconsistent, and it eats
up system resources and is probably doing mysterious things behind the scenes
intruding on privacy. But privacy aside, I’m sure everyone reading this has been
late to <strong>at least</strong> 1 meeting because Zoom randomly decided to update (I
thought that when I ditched windows that problem was behind me!).</p>
<p>There’s a solution though: use Zoom in your browser, only, always, ever! Zoom
provides an option to join in the browser, given that you reject their popups to
open in desktop, and then click through a chain of links to open in the browser.
The nice thing about the browser is that it’s sandboxed, it’s very limited in
what access it has to your system, and is much more private than a closed source
binary.</p>
<p>My solution: a browser extension to redirect Zoom links directly to browser
Zoom. The idea was simple, I would create a simple plugin for Chrome (and
eventually Firefox) to allow you to skip past popups to join Zoom rooms with the
desktop app. The goal was so that you could paste in a Zoom URL as usual, and
you would just be forwarded directly to the Zoom room in your browser.</p>

<p>The first step was to figure out what the exact user flow that I would need to
automate would be. It would be ideal if I could avoid simulating user actions as
much as possible, and just take advantage of flags/find ways to redirect right
to the browser Zoom interface.</p>
<p>What I quickly figured out is that when you visit a Zoom URL, <code>onWindowLoad</code> it
creates the infamous “Open Zoom Workplace” popup, <strong>AND</strong> appends <code>#success</code> to
the URL.</p>
<p>I figured out if you visit a Zoom URL that already has this <code>#success</code> flag at
the end of it, that Zoom will not give you the popup. This turned out to be a
great step, since apparently it’s just straight up not possible to interact with
browser dialogs with an extension. Not discovering this may have killed off the
project.</p>
<p><img src="https://static.404wolf.com/Post-20240716211735260.webp" alt="Joining a Zoom"/></p>
<p>The next step in the user flow I thought would be simple, just scrape the page
and find the URL that the “Join from your Browser” button links to, and then
redirect there, but it turns out that that button is actually executing
javascript.</p>
<p><img src="https://static.404wolf.com/Post-20240716212111111.webp" alt="The button"/></p>
<p>Luckily extensions do have the ability to modify the webpage, so I could just
click the button for the user. This is annoying, but it works fine.</p>
<p>Now let’s dive into how I actually wrote it.</p>

<p>I’d never made a browser extension before, but it turns out that
<a href="https://developer.chrome.com/docs/extensions">Google</a>’s (and Mozilla’s, as I’d
figure out later when porting to Firefox) documentation for extensions is pretty
good.</p>
<p>Basically, the general flow is that you create a directory with a image icon for
the extension, a <code>manifest.json</code> file that follows a specific schema (there’s a
few versions of the schema that chrome supports, but the most recent one is
called “Manifest v3”), and then some javascript files (technically optional, but
that’s where the extension’s logic goes). I started with a very bare bones basic
manifest and just added permissions and configuration as I went.</p>
<h2 id="development">Development</h2>
<p>Getting a developer environment set up for the project was pretty straight
forward. First, I made a <code>nix</code> devShell that had a base chromium and firefox
binary, so that I could test in a clean “sandbox”-y environment:</p>
<pre tabindex="0" data-language="nix"><code><span><span>{</span></span>
<span><span>  description</span><span> =</span><span> &#34;Force browser only Zoom&#34;</span><span>;</span></span>
<span></span>
<span><span>  inputs</span><span> =</span><span> {</span></span>
<span><span>    flake-utils</span><span>.</span><span>url</span><span> =</span><span> &#34;github:numtide/flake-utils&#34;</span><span>;</span></span>
<span><span>    nixpkgs</span><span>.</span><span>url</span><span> =</span><span> &#34;github:nixos/nixpkgs/nixos-unstable&#34;</span><span>;</span></span>
<span><span>  };</span></span>
<span></span>
<span><span>  outputs</span><span> =</span></span>
<span><span>    {</span></span>
<span><span>      self</span><span>,</span></span>
<span><span>      nixpkgs</span><span>,</span></span>
<span><span>      flake-utils</span><span>,</span></span>
<span><span>    }:</span></span>
<span><span>    flake-utils</span><span>.</span><span>lib</span><span>.</span><span>eachDefaultSystem</span><span> (</span></span>
<span><span>      system:</span></span>
<span><span>      let</span></span>
<span><span>        pkgs</span><span> =</span><span> import</span><span> nixpkgs</span><span> { </span><span>inherit</span><span> system</span><span>; };</span></span>
<span><span>      in</span></span>
<span><span>      {</span></span>
<span><span>        devShells</span><span> =</span><span> {</span></span>
<span><span>          default</span><span> =</span><span> pkgs</span><span>.</span><span>mkShell</span><span> {</span></span>
<span><span>            packages</span><span> =</span><span> [</span></span>
<span><span>              pkgs</span><span>.</span><span>ungoogled-chromium</span></span>
<span><span>              pkgs</span><span>.</span><span>librewolf</span></span>
<span><span>            ];</span></span>
<span><span>          };</span></span>
<span><span>        };</span></span>
<span><span>      }</span></span>
<span><span>    );</span></span>
<span><span>}</span></span></code></pre>
<p>And then in Chrome (and in Firefox it was a similar process) I went to
<code>chrome://extensions</code>, and enabled developer mode.</p>
<p><img src="https://static.404wolf.com/Post-20240716222255624.webp" alt="Developer mode"/></p>
<p>Afterwards, I clicked to load the “unpacked” (you can “pack” your extension as a
special zip like file with encryption, in case you want to deploy a closed
source extension) plugin.</p>
<p><img src="ttps://static.404wolf.com/Post-20240716222359125.webp" alt="Loading it in"/></p>
<p>And it was added! It was a pretty easy process. I could get logs by clicking
“Details”, and could just reload it by clicking a little reload icon.</p>
<h2 id="redirecting">Redirecting</h2>
<p>The first step of the project’s implementation would be to figure out how to
redirect users as they visit websites, as a function of the website they visit.
Something like</p>
<pre tabindex="0" data-language="ts"><code><span><span>;(</span><span>websiteVisited</span><span>:</span><span> string</span><span>) </span><span>=&gt;</span><span> websiteVisited </span><span>+</span><span> &#39;#success&#39;</span></span></code></pre>
<p>Super simple, I know.</p>
<p>I found <a href="https://stackoverflow.com/a/12070823">this super super helpful</a> Stack
Overflow post summarizing the options I had.</p>
<p>The options they presented:</p>
<blockquote>
<ol>
<li>The <a href="https://developer.chrome.com/extensions/webRequest.html"><code>webRequest</code></a> API,
specifically
the <a href="https://developer.chrome.com/extensions/webRequest.html#event-onBeforeRequest"><code>onBeforeRequest</code> event</a>.
(Even better, the
upcoming <a href="http://developer.chrome.com/extensions/declarativeWebRequest.html"><code>declarativeWebRequest</code> API</a>).</li>
</ol>
</blockquote>
<p>(note that the url is broken — it’s now
<a href="https://developer.chrome.com/docs/extensions/reference/api/declarativeNetRequestk">here</a></p>
<p>This initially seemed like the best option. It seemed like the “proper” way to
do it. Firstly, it’s pretty secure since I don’t have to have my extension view
the web content itself (although, as I’ll explain later, this turned out to be
necessary anyway)</p>
<blockquote>
<p>The <code>chrome.declarativeNetRequest</code> API is used to block or modify network
requests by specifying declarative rules. This lets extensions modify network
requests without intercepting them and viewing their content, thus providing
more privacy.</p>
</blockquote>
<p>More importantly though, it seemed like this approach wasn’t great for actual
browser navigation, and was better for redirecting network requests, which
wasn’t really my goal.</p>
<blockquote>
<ol start="2">
<li><a href="http://developer.chrome.com/extensions/content_scripts.html">Content scripts</a>.
Inject <code>location.replace(&#39;http://example.com&#39;)</code> in a page.</li>
</ol>
</blockquote>
<p>This option basically means swapping out links that users would click on so that
they never end up at the link without <code>#success</code> to begin with. This also means
that it wouldn’t work if users pasted the URL into the search bar, so this
wouldn’t work.</p>
<blockquote>
<ol start="3">
<li>The <a href="http://developer.chrome.com/extensions/tabs.html"><code>tabs</code></a> API. Use
the <a href="http://developer.chrome.com/extensions/tabs.html#event-onUpdated"><code>onUpdated</code> event</a> to
detect when a page has changed its location,
and <a href="http://developer.chrome.com/extensions/tabs.html#method-update"><code>chrome.tabs.update</code></a> to
change its URL. Avoid an infinite loop though!</li>
</ol>
</blockquote>
<p>This option looked great! Just monitor when a tab starts to visit a URL and then
before it can begin doing fetches swap the URL. This is what I went with, and it
turned out later that Mozilla had an identical API and version for Firefox.</p>
<p>The code for deciding to redirect the user ended up being super minimal, and
looked something like this…</p>
<pre tabindex="0" data-language="js"><code><span><span>chrome.webNavigation.onCommitted.</span><span>addListener</span><span>(</span></span>
<span><span>  (</span><span>details</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>    zoomPattern </span><span>=</span></span>
<span><span>      /</span><span>^</span><span>https:</span><span>\/\/</span><span>(</span><span>\w</span><span>+</span><span>\.</span><span>)</span><span>?</span><span>\w</span><span>+</span><span>\.</span><span>\w</span><span>+</span><span>\/</span><span>j</span><span>\/</span><span>\d</span><span>{10}</span><span>\?</span><span>pwd</span><span>\=</span><span>[a-zA-Z0-9]</span><span>{32}$</span><span>/</span></span>
<span><span>    if</span><span> (details.url.</span><span>match</span><span>(zoomPattern))</span></span>
<span><span>      chrome.tabs.</span><span>update</span><span>(details.tabId, { url: </span><span>`${</span><span>details</span><span>.</span><span>url</span><span>}#success`</span><span> })</span></span>
<span><span>  },</span></span>
<span><span>  { url: [{ urlMatches: </span><span>&#39;.*&#39;</span><span> }] },</span></span>
<span><span>)</span></span></code></pre>
<p>It’s probably a bit more complicated than it had to be, but basically I wanted
to be super careful that people would only be redirected when they visited Zoom
URLs, and Zoom URLs can be hosted on your own enterprise domain (e.g.
<code>zoom.yourcompany.com</code>), so I wanted to make sure that I pattern matched against
the Zoom URL schema as tightly as possible with regex.</p>
<h2 id="clicking-past">Clicking Past</h2>
<p>Now that I was able to skip the “Open in Zoom Desktop” popup, I’d need to click
the button for the user to actually go to the browser Zoom page.</p>
<p>This is just a clickable element, and interacting with it was as simple as using
a selector to select it, and calling the <code>click</code> method. I’d done quite a bit of
<code>puppeteer</code> before and it was very similar syntax.</p>
<p>The full code for this looks like this</p>
<pre tabindex="0" data-language="js"><code><span><span>const</span><span> elements</span><span> =</span><span> [</span></span>
<span><span>  ...</span><span>document.</span><span>querySelectorAll</span><span>(</span><span>&#39;a[role=&#34;button&#34;][tabindex=&#34;0&#34;]&#39;</span><span>),</span></span>
<span><span>]</span></span>
<span><span>const</span><span> element</span><span> =</span><span> elements.</span><span>find</span><span>((</span><span>el</span><span>) </span><span>=&gt;</span><span> el.innerText </span><span>===</span><span> &#39;Join from Your Browser&#39;</span><span>)</span></span>
<span><span>if</span><span> (element) {</span></span>
<span><span>  element.</span><span>click</span><span>()</span></span>
<span><span>}</span></span></code></pre>
<p>It’s really not that bad. I just add a listener to execute this on all page
loads (although I really should only do this on loads of Zoom-like-URLs, but
optimizations come later!).</p>
<p>I also added some code to remove the other buttons on the page and Ads to get
the app, for while the page redirected you and things were still loading</p>
<pre tabindex="0" data-language="js"><code><span><span>// findAndRemoveIfExists is a helper function I define elsewhere. It does what</span></span>
<span><span>// the name says it does.</span></span>
<span><span>findAndRemoveIfExists</span><span>(</span><span>&#39;div.ifP196ZE.x2RD4pnS&#39;</span><span>)</span></span>
<span><span>findAndRemoveIfExists</span><span>(</span><span>&#39;hr[role=&#34;presentation&#34;]&#39;</span><span>)</span></span>
<span><span>findAndRemoveIfExists</span><span>(</span><span>&#39;h3[class=&#34;rm-presentation&#34;]&#39;</span><span>)</span></span></code></pre>
<p>And had a bit of fun messing with the DOM…</p>
<pre tabindex="0" data-language="js"><code><span><span>const</span><span> zoomAppSpans</span><span> =</span><span> document.</span><span>querySelectorAll</span><span>(</span><span>&#39;span&#39;</span><span>)</span></span>
<span><span>const</span><span> targetSpan</span><span> =</span><span> [</span><span>...</span><span>zoomAppSpans].</span><span>find</span><span>((</span><span>span</span><span>) </span><span>=&gt;</span></span>
<span><span>  span.textContent.</span><span>includes</span><span>(</span><span>&#39;with the Zoom&#39;</span><span>),</span></span>
<span><span>)</span></span>
<span><span>if</span><span> (targetSpan)</span></span>
<span><span>  targetSpan.childNodes[</span><span>0</span><span>].textContent </span><span>=</span><span> &#39;Hate the Zoom Desktop App? &#39;</span></span></code></pre>
<p>And then all I had to do was write a <code>manifest.json</code> with the right permissions.
It turns out that ChatGPT is much better at writing the old <code>manifest V2</code> style
manifests, but it was still helpful</p>
<p>It was pretty simple, and the hard part was just finding what I needed
permissions for in the docs.</p>
<pre tabindex="0" data-language="json"><code><span><span>{</span></span>
<span><span>  &#34;manifest_version&#34;</span><span>: </span><span>3</span><span>,</span></span>
<span><span>  &#34;name&#34;</span><span>: </span><span>&#34;Browser Zoom&#34;</span><span>,</span></span>
<span><span>  &#34;description&#34;</span><span>: </span><span>&#34;Only let zoom run in the browser. No more popups!&#34;</span><span>,</span></span>
<span><span>  &#34;version&#34;</span><span>: </span><span>&#34;1.0&#34;</span><span>,</span></span>
<span><span>  &#34;background&#34;</span><span>: {</span></span>
<span><span>    &#34;service_worker&#34;</span><span>: </span><span>&#34;background.js&#34;</span></span>
<span><span>  },</span></span>
<span><span>  &#34;content_scripts&#34;</span><span>: [</span></span>
<span><span>    {</span></span>
<span><span>      &#34;matches&#34;</span><span>: [</span><span>&#34;https://*/*&#34;</span><span>],</span></span>
<span><span>      &#34;js&#34;</span><span>: [</span><span>&#34;content.js&#34;</span><span>],</span></span>
<span><span>      &#34;run_at&#34;</span><span>: </span><span>&#34;document_idle&#34;</span></span>
<span><span>    }</span></span>
<span><span>  ],</span></span>
<span><span>  &#34;permissions&#34;</span><span>: [</span><span>&#34;activeTab&#34;</span><span>, </span><span>&#34;webNavigation&#34;</span><span>],</span></span>
<span><span>  &#34;action&#34;</span><span>: {</span></span>
<span><span>    &#34;default_popup&#34;</span><span>: </span><span>&#34;popup.html&#34;</span><span>,</span></span>
<span><span>    &#34;icons&#34;</span><span>: {</span></span>
<span><span>      &#34;16&#34;</span><span>: </span><span>&#34;https://static.404wolf.com/icon-16.png&#34;</span><span>,</span></span>
<span><span>      &#34;48&#34;</span><span>: </span><span>&#34;https://static.404wolf.com/icon-48.png&#34;</span><span>,</span></span>
<span><span>      &#34;128&#34;</span><span>: </span><span>&#34;https://static.404wolf.com/icon-128.png&#34;</span></span>
<span><span>    }</span></span>
<span><span>  }</span></span>
<span><span>}</span></span></code></pre>

<p>The plugin is available on my Github
<a href="https://github.com/404wolf/Browser-Zoom">here</a>, and is totally open source.</p>
<h2 id="chrome">Chrome</h2>
<p><img src="https://static.404wolf.com/https://static.404wolf.com/Post-20240716215027831.webp" alt="Google Extension Rejection"/></p>
<p>It was a bit tricky to publish the plugin on extension stores, mostly because it
requires access to “modify” ANY website. Basically, in my extension’s manifest
(where metadata about it and its permissions live, which is mostly directives to
the browser), it has</p>
<pre tabindex="0" data-language="json"><code><span><span>...</span></span>
<span><span>&#34;content_scripts&#34;</span><span>: [</span></span>
<span><span>  {</span></span>
<span><span>    &#34;matches&#34;</span><span>: [ </span><span>&#34;https://*/*&#34;</span><span> ],</span></span>
<span><span>    &#34;js&#34;</span><span>: [ </span><span>&#34;content.js&#34;</span><span> ],</span></span>
<span><span>    &#34;run_at&#34;</span><span>: </span><span>&#34;document_idle&#34;</span></span>
<span><span>  }</span></span>
<span><span>],</span></span>
<span><span>...</span></span></code></pre>
<p>This means that the extension has permission to modify the DOM of any website.
Initially I was worried Google would reject the plugin because of this extensive
requirement, but my main justification is that Zoom can run on any domain (like
zoom.yourcompany.us), and thus I can’t match domains without complicated regex
(but the match pattern here is not regex, it’s special google syntax).</p>
<p><img src="https://static.404wolf.com/https://static.404wolf.com/Post-20240716215251691.webp" alt="Chrome developer dashboard"/></p>
<p>It turned out that the annoying parts of the Google extension publishing
experience were elsewhere, though. To start, to even make a developer account
for the Chrome webstore dashboard, you need to make a $5 deposit to “fight spam
and abuse.” Then, after publishing it a few times, while they haven’t gotten
upset about the permission I thought they would be upset about, they’ve rather
been nit picky on things that don’t matter — like, in my most recent rejection,
they told me I don’t have a privacy policy link, even though I don’t collect
user data and supplied a link to a plaintext file that says “I do not collect
any data.” I’ll keep trying to get it published on the Chrome extension store,
though!</p>
<p>For now, to run it on Chrome just get it from the Github and install it
yourself, it’s not that hard and you don’t need any developer experience.</p>
<h2 id="firefox">Firefox</h2>
<p>Mozilla on the other hand was really pleasant to deal with. Their store’s
developer UX was easier to navigate, there was no “anti-spam” deposit, and they
gave me “preliminary approval” in two days.</p>
<p><a href="https://addons.mozilla.org/en-US/firefox/addon/browser-zoom/reviews/">It’s here, on the Mozilla firefox extension store, if you use firefox!</a></p>
<p><img src="https://static.404wolf.com/https://static.404wolf.com/Post-20240716214604533.webp" alt="Extension Listing"/>
<img src="https://static.404wolf.com/https://static.404wolf.com/Post-20240716214554914.webp" alt="Extension ratings"/></p>  </div> </astro-slot></div></div>
  </body>
</html>
