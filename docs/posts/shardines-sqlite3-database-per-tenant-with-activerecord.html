<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.julik.nl/2025/04/a-can-of-shardines">Original</a>
    <h1>Shardines: SQLite3 Database-per-Tenant with ActiveRecord</h1>
    
    <div id="readability-page-1" class="page"><div>

	<article>

    
		

<small>
  
    
  ¬†¬∑¬†<time datetime="2025-04-25T00:00:00+00:00">25 Apr 2025</time>
</small>

    <p>There is a pattern I am very fond of - ‚Äúone database per tenant‚Äù in web applications with multiple, isolated users. Recently, I needed to fix an application I had for a long time where this database-per-tenant multitenancy utterly broke down, because I was doing connection management wrong. Which begat the question: how do you even approach doing it right?</p>

<p>And it turns out I was not alone in this. The most popular gem for multitenancy - Apartment - which I have even used in my failed startup back in the day -
<a href="https://github.com/rails-on-services/apartment/issues/304#issuecomment-2648202324">has the issue too.</a></p>

<p>The culprit of <q>does not handle multithreading very well</q> is actually deeper. Way deeper. Doing runtime-defined multiple databases with Rails has only recently become less haphazard, and there are no tools either via gems or built-in that facilitate these flows. It has also accrued a ton of complexity, and also changes with every major Rails revision.</p>

<p><strong>TL;DR</strong> If you need to do database-per-tenant multitenancy with Rails or ActiveRecord <em>right now</em> - grab the middleware from <a href="https://gist.github.com/julik/69066f5a819ac3b38480d42c1351f8ef">this gist</a> and move on.</p>

<p>If you are curious about the genesis of this solution, strap in - we are going on a tour of a sizeable problem, and of an API of stature - the ActiveRecord connection management. 
Read on and join me on the ride! Many thanks to <a href="https://kirshatrov.com/">Kir Shatrov</a> and <a href="https://fractaledmind.com">Stephen Margheim</a> for their help in this.</p>

<!--more-->

<h2 id="the-advantages-of-the-database-per-tenant">The advantages of the ‚Äúdatabase per tenant‚Äù</h2>

<p>If you have a tenanted application (your ‚Äútenant‚Äù is a subgraph of your data model that can function independently, and mostly references other entities from within itself), you have a number of ways to approach an architecture like that. Imagine we have a system where the tenant is a <code>Site</code>. That system is some kind of end-user-serviceable CMS, and users own multiple <code>Sites</code> and can manage pages, media and other items within a <code>Site</code>. The data model will be as follows:</p>

<div><div><pre><code><span>class</span> <span>Site</span> <span>&lt;</span> <span>ActiveRecord</span><span>::</span><span>Base</span>
<span>end</span>

<span>class</span> <span>Page</span> <span>&lt;</span> <span>ActiveRecord</span><span>::</span><span>Base</span>
  <span>belongs_to</span> <span>:site</span>
  <span>has_many</span> <span>:media_blocks</span>
  <span>has_many</span> <span>:pages</span><span>,</span> <span>through: :media_blocks</span>
<span>end</span>

<span>class</span> <span>MediaBlock</span> <span>&lt;</span> <span>ActiveRecord</span><span>::</span><span>Base</span>
  <span>belongs_to</span> <span>:media_item</span>
  <span>belongs_to</span> <span>:page</span>
<span>end</span>

<span>class</span> <span>Comment</span> <span>&lt;</span> <span>ActiveRecord</span><span>::</span><span>Base</span>
  <span>belongs_to</span> <span>:page</span> <span># and thus to a Site, &#34;through&#34;</span>
<span>end</span>

<span>class</span> <span>MediaItem</span> <span>&lt;</span> <span>ActiveRecord</span><span>::</span><span>Base</span>
  <span>has_many</span> <span>:media_items</span>
  <span>has_many</span> <span>:pages</span><span>,</span> <span>through: :media_items</span>
  <span>has_one_</span> <span>:site</span><span>,</span> <span>through: :pages</span> <span># since it can be reused across multiple pages</span>
<span>end</span>
</code></pre></div></div>

<p>Sites very rarely get merged together, and 99% of the data that gets created within a <code>Site</code> stays inside that <code>Site</code>, forever. Either because your system has outgrown hosting a single <code>Site</code>, or because you want to have robust isolation (you don‚Äôt want Jane to post to her <code>Site</code> only for the article to end up on Blake‚Äôs <code>Site</code> by mistake), or because your system is wildly successful and profitable, you may want to apply the following strategies:</p>

<ul>
  <li>Just like our initial model - the <code>Site</code> has an <code>id</code>, some models link to it directly, some - through others</li>
  <li>Every model gets a <code>site_id</code>. Every <code>INSERT</code>, <code>UPDATE</code> or <code>DELETE</code> then knows which <code>Site</code> a particular model makes part of - and a deletion can address the database where the site is stored. Databases will then be <em>shards</em> and store multiple <code>Sites</code>. If you decide to become a host for Slashdot, and get millions of <code>Page</code> records and bullions of <code>Comment</code> records, they will likely be extracted into a separate DB. There will be a mapping table of sorts, that will record that <code>slashdot.org</code> gets mapped to <code>db_slashdot_tenant</code> explicitly.</li>
  <li>Just like our initial model - but there is only <em>one</em> <code>Site</code> record in the entire database. All records belonging to a <code>Site</code> are stored inside that database.</li>
</ul>

<p>There are other tricks for doing sharding/multitenancy well - for example, using generated primary keys which contain the tenant ID within them - so that shards can be merged, etc.</p>

<p>But what interests us here, specifically, is the last approach - having one database per tenant. For my smaller sites, using SQLite as the database has become part and parcel. Having a DB server that you can configure easily is very good. Having a database server that you do not have to configure at all - exceptional, though. Same for backups: centralised backup is great and useful. But nothing beats an <code>rsync</code> if that‚Äôs all you need to do a backup. And the schema becomes smaller too - we can move the <code>Site</code> out of the database outright, and the rest of the models no longer needs the associations to <code>site</code>:</p>

<pre><code>class Page &lt; ActiveRecord::Base
  has_many :media_blocks
  has_many :pages, through: :media_blocks
end

class MediaBlock &lt; ActiveRecord::Base
  belongs_to :media_item
  belongs_to :page
end

class Comment &lt; ActiveRecord::Base
  belongs_to :page # and thus to a Site, &#34;through&#34;
end

class MediaItem &lt; ActiveRecord::Base
  has_many :media_blocks
end
</code></pre>

<p>Development-wise those setups are a breeze too - if you need to debug something inside a particular <code>Site</code>, all you need to do is download this site‚Äôs data. With just one <code>scp</code> command, usually. And there are elephants in the room too:</p>

<ul>
  <li>Doing schema migrations where a migration runs on one tenant, but fails on another</li>
  <li>Accessing the same DB from multiple servers</li>
  <li>Doing backups is somewhat unorthodox - there are many ways to do it</li>
</ul>

<p>But remember: using this approach has one jarring advantage. It firmly pushes you out of the ‚Äúbig data‚Äù territory, and even out of ‚Äúmedium data‚Äù - it is ‚Äútiny data‚Äù.</p>

<blockquote>
  <p>‚ÄúData which, when stored on immediately-accessible random-read storage media of reasonable speed, does not fit under your desk‚Äù is my formal definition for ‚Äúbig data‚Äù, if that helps.</p>
</blockquote>

<p>Some joints were exceptionally successful doing this. <a href="https://use.expensify.com/blog/scaling-sqlite-to-4m-qps-on-a-single-server">Expensify,</a> for one, is notorious for pushing and pulling SQLite well beyond the boundaries most folks would call comfortable. I know that Autodesk‚Äôs own ShotGrid - back when it used to be Shotgun and was an independent software product - used SQLite3 pretty extensively. Along with the obligatory <code>SQLite3::BusyException</code> every now and then üòâ</p>

<h2 id="why-this-is-challenging-with-rails">Why this is challenging with Rails</h2>

<p>When using SQLite3 ‚Äúbare‚Äù, handling a database ‚Äúopen‚Äù and ‚Äúclose‚Äù is absolutely trivial:</p>

<div><div><pre><code><span>SQLite3</span><span>::</span><span>Database</span><span>.</span><span>open</span><span>(</span><span>&#34;site_1.sqlite3&#34;</span><span>)</span> <span>do</span> <span>|</span><span>db</span><span>|</span>
  <span>site_title</span> <span>=</span> <span>db</span><span>.</span><span>get_first_value</span><span>(</span><span>&#34;SELECT title FROM sites LIMIT 1&#34;</span><span>)</span>
  <span>pages</span> <span>=</span> <span>db</span><span>.</span><span>execute</span><span>(</span><span>&#34;SELECT * FROM pages &#34;</span><span>)</span>
<span>end</span>
</code></pre></div></div>

<p>If we use Rack, we just wrap this in a middleware:</p>

<div><div><pre><code><span>def</span> <span>call</span><span>(</span><span>env</span><span>)</span>
  <span>SQLite3</span><span>::</span><span>Database</span><span>.</span><span>open</span><span>(</span><span>&#34;site_1.sqlite3&#34;</span><span>)</span> <span>do</span> <span>|</span><span>db</span><span>|</span>
    <span>@app</span><span>.</span><span>call</span><span>(</span><span>env</span><span>.</span><span>merge</span><span>(</span><span>&#34;site_db&#34;</span> <span>=&gt;</span> <span>db</span><span>))</span>
  <span>end</span>
<span>end</span>  
</code></pre></div></div>

<p>But for this to work, the <code>db</code> variable - the handle to the database - has to be explicitly used for every query! ActiveRecord, however, manages the connections not through a variable you give it, but through it‚Äôs own ‚Äúrecollection‚Äù of what database a particular ActiveRecord <a href="https://stackoverflow.com/questions/141201/how-to-best-handle-per-model-database-connections-with-activerecord">superclass connects to:</a></p>

<div><div><pre><code>class Page &lt; ActiveRecord::Base
  establish_connection database: &#34;site_1.sqlite3&#34;
end
</code></pre></div></div>

<p>Needless to say, this code runs just once (and you don‚Äôt know exactly ‚Äúwhen‚Äù - to which the answer is <em>at first query</em>), and is not at all designed for disconnecting and reconnecting all the time. Now, if there was a way to do this:</p>

<div><div><pre><code><span>class</span> <span>Page</span> <span>&lt;</span> <span>ActiveRecord</span><span>::</span><span>Base</span>
  <span>obtain_connection_from</span> <span>{</span> <span>tenancy_system</span><span>.</span><span>database_config</span> <span>}</span>
<span>end</span>
</code></pre></div></div>

<p>it would have been easier, but alas. And with the addition of connection pooling, query cache, schema cache - you are looking at a sizeable contraption of <a href="https://www.youtube.com/watch?v=LFrdqQZ8FFc">things which are put on top of other things.</a> Which is what makes this exercise so frustrating: you know something utterly trivial with a ‚Äúbare‚Äù API is infuriatingly complicated when doing it through ActiveRecord. Moreover - this is one of the headliner use-cases for SQLite3, and ActiveRecord seems to make it nigh-impossible to execute.</p>

<p>How come?</p>

<h2 id="churn-inevitable">Churn, inevitable</h2>

<p>The reason for difficulties with multiple databases in Rails comes down to the history of that feature and the needs of the <em>hyperscalers</em> - the Githubs, the Shopifys and the Zendesks of the ecosystem.</p>

<p>Since I have been using Rails - and this ActiveRecord - for quite a long while - here is a brief history recap:</p>

<ul>
  <li>Rails 1 already had database assignment per <code>ActiveRecord::Base</code> subclass</li>
  <li>Rails 3 added connection pooling</li>
  <li>Rails 4 added <code>connection_handling</code> (albeit - hidden)</li>
  <li>Rails 6 added <code>connected_to</code></li>
  <li>Rails 7 expanded on <code>connected_to</code> with the addition of shards (so now you have both roles and shards)</li>
</ul>

<p>The interesting part of it all is that while ActiveRecord <a href="https://github.com/rails/rails/blob/main/activerecord/examples/simple.rb">example code</a> includes snippets like this:</p>

<div><div><pre><code><span>class</span> <span>Person</span> <span>&lt;</span> <span>ActiveRecord</span><span>::</span><span>Base</span>
  <span>establish_connection</span> <span>adapter: </span><span>&#34;sqlite3&#34;</span><span>,</span> <span>database: </span><span>&#34;foobar.db&#34;</span>
  <span>connection</span><span>.</span><span>create_table</span> <span>table_name</span><span>,</span> <span>force: </span><span>true</span> <span>do</span> <span>|</span><span>t</span><span>|</span>
    <span>t</span><span>.</span><span>string</span> <span>:name</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>the changes in how Rails handles multiple databases have led to the fact that this example code is useful only in a very small number of cases. For example: with a snippet like this, how do we <code>close_connection</code>? Or, how do we tell <code>Person</code> to connect to a different database after having done a query or two?</p>

<p>If you start looking into this, an entire world opens befor your eyes. And this world has its own taxonomy - and it is sizeable. <code>ConnectionHandling</code>, <code>DatabaseConfig</code>, <code>DatabaseConfigurations</code> (yes, plural), <code>Resolver</code>, <code>PoolConfig</code>, <code>PoolManager</code>‚Ä¶ and all these things interact, live and breathe in a carefully managed dance. Spoiler: they can do everything we need, but we have to conduct them like a little orchestra - <em>just like so.</em></p>

<h2 id="divergent-api-design">Divergent API design</h2>

<p>The way ActiveRecord is designed - having model classes with no explicit way to tell them ‚Äúthrough which connection‚Äù they should work for this query - means that there will always be some hidden state. It can be a global, or a class variable (which is‚Ä¶ a glorified global) - or a thread-local, but somewhere there <em>is</em> a connection, and until recently (Rails 6, to be exact) there was no official way to tell ActiveRecord which connection to use.</p>

<p>In theory, an API like this could be realised:</p>

<p><code>Page.with_connection(tenant_db_conn).first</code></p>

<p>However, this database connection argument would then need to be provided to every call to ActiveRecord - and the API is truly vast.</p>

<p>An extra complication is that a lot of the design of AR assumes that a connection to the database (and that it is going to be <em>the</em> database) will be opened early, and then kept intact. The schema cache (letting ActiveRecord subclasses know which columns are in the tables, for example) gets loaded once. The query cache gets initialised once. Migrations get run once - and, again, they run on <em>the</em> database,</p>

<h2 id="divergent-configuration-lifecycle">Divergent configuration lifecycle</h2>

<p>If you want to build a multitenant system of small tenants using SQLite3, with a single database being allocated per tenant, your needs are not exactly in alignment with a hypothetical Shopify: they want to have <code>cluster_a</code>, <code>cluster_b</code>, <code>cluster_eu</code> and <code>cluster_us</code>, each tens of terabytes in size. You, instead, want to have <code>site_1</code>, <code>site_2</code> and so on - with some being just a few KB in size.</p>

<p>This would mean that for them, the configuration of those big clusters can be output into <code>database.yml</code> programmatically. It can be source-controlled, and follow strict and specific semantics regarding</p>

<ul>
  <li>When the file gets read</li>
  <li>Whether (and when) templating is done in it, for example - to inject credentials</li>
  <li>That all internal datastructures - such as connection pools - get initialised ahead of time</li>
  <li>Preconfigured, large clusters where data is usually sharded - using things like <code>shop_id</code> - but not segregated.</li>
</ul>

<p>None of the ‚Äúbig guys‚Äù from the mentioned three have true, single-database-per-tenant setups ‚Äì or at least I never heard they do.</p>

<p>Most of the modern ActiveRecord infrastructure is built around those assumptions, not because the makers of the feature want to work against what ‚Äúwe‚Äù want - they just made different tradeoffs.</p>

<h2 id="divergent-db-engine-tradeoffs">Divergent DB engine tradeoffs</h2>

<p>Another important item is database performance. ‚ÄúBig‚Äù database servers are designed with some assumptions. For example, if you have a database, the engine would be interested in holding file descriptors open for that database or <code>mmap()</code>ed files from it. If the tablespaces are large - they will be cached in memory, and cached fairly aggressively. If there are indices - the engine will try to cache them in memory as well, and keep access to the files containing the index data close at hand.</p>

<p>The end result is that, at least when I was working on an Apartment-based system with MySQL 5.7, after a certain number of databases created you would start hitting file descriptor limits. Those are set low on MacOS, but it was still noticeable - and it was clear that it was a question of time (and scale) - which we haven‚Äôt hit though - before that would become an actual problem.</p>

<p>On balance, thus, a database server is optimised for <em>few large databases</em> ‚Äì not for thousands of small ones. This is another reason why the approach with a static <code>database.yml</code> seemed so appealing.</p>

<p>Just check <a href="https://kirshatrov.com/posts/fast-skip-locked">this article</a> out:</p>

<blockquote>
  <p>By implementing these optimizations, I‚Äôve seen remarkable performance improvements: single MySQL server handling 2M+ ticket reservation transactions per minute while the average latency of SELECT ‚Ä¶ FOR UPDATE SKIP LOCKED query staying under 400ŒºS.</p>
</blockquote>

<p>This is the kind of perf those ‚Äúbig engines‚Äù optimise for. Not ‚Äúquickly handling 120 pages within this site, which is one of 2 thousands‚Äù.</p>

<p>With SQLite3, the story is completely different. SQLite3 <em>thrives</em> with multiple small databases. Since a SQLite3 database is just a file (well, 3 files sometimes, but you get the point), it makes perfect sense to have a single database per tenant in the system. Since the system is multitenanted, a request for tenant <code>A</code> is guaranteed not to need data from tenant <code>B</code>. Moreover - when we are handling a request for tenant <code>A</code>, we don‚Äôt need any resources from <code>B</code> - so we don‚Äôt even need a connection (file handle).</p>

<p>Having smaller SQLite3 databases has more affordances - for example, it‚Äôs much faster - and more granular - to do backups on a per-tenant basis. Debugging becomes much easier - instead of doing a sophisticated sequence of <code>SELECT</code>s to extract the ‚Äúslice‚Äù of data for a particular tenant, you just copy the tenant‚Äôs DB wholesale. Same for granular restore. Same for deletions - removing a tenant, even a large one, is just an <code>unlink</code> away.</p>

<p>So one of the reasons why the modern multi-DB features in Rails do not support dynamic tenant management with automatically allocated databases - in large numbers - is because, at least on the surface, only SQLite3 currently makes this pattern viable.</p>

<p>And it‚Äôs not only viable ‚Äì it is <em>glorious.</em> Did you know that the way iCloud works, for example, is literally millions of isolated SQLite databases, stored <em>inside</em> of larger Cassandra databases?</p>

<h2 id="back-to-the-original-problem">Back to the original problem</h2>

<p>So, I had an app. It has been running for more than a decade now. It was initially built with static HTML with some templating getting pre-processed before server upload using <code>rsync</code> - it was a glorified static site generator, essentially. Then came the ‚Äúadmin‚Äù features, and the app acquired databases. From the get go, the app - which is a mini-CMS of sorts - provided every website owner a UI to edit the content of their website. Every website also has its own database. Requests between them never cross - and no <code>site_id</code> is involved anywhere in the process.</p>

<p>Initially it was based on raw ERB and some glue code. Then it got rewritten into Camping, and the database switching looked roughly like the <code>establish_connection</code> example above. This was pre-Rails-3, so no Rack middleware, no frills, no nothing.</p>

<p>With the ActiveRecord 3 upgrade came the dance of splitting code into something more appropriate, along with a changeover to Sinatra. And the connection management - which got moved into a Rack middleware - took the following shape:</p>

<div><div><pre><code><span>def</span> <span>call</span><span>(</span><span>env</span><span>)</span>
  <span>begin</span>
    <span>ActiveRecord</span><span>::</span><span>Base</span><span>.</span><span>establish_connection</span><span>(</span><span>adapter: </span><span>&#39;sqlite3&#39;</span><span>,</span> 
      <span>database: </span><span>env</span><span>.</span><span>fetch</span><span>(</span><span>&#39;site_db_path&#39;</span><span>),</span>
      <span>timeout: </span><span>BUSY_TIMEOUT</span><span>)</span>

    <span>s</span><span>,</span> <span>h</span><span>,</span> <span>b</span> <span>=</span> <span>app</span><span>.</span><span>call</span><span>(</span><span>env</span><span>.</span><span>merge</span><span>(</span><span>&#39;database&#39;</span> <span>=&gt;</span> <span>self</span><span>))</span>
    <span>connection_closing_body</span> <span>=</span> <span>::</span><span>Rack</span><span>::</span><span>BodyProxy</span><span>.</span><span>new</span><span>(</span><span>b</span><span>)</span> <span>do</span>
      <span>::</span><span>ActiveRecord</span><span>::</span><span>Base</span><span>.</span><span>clear_active_connections!</span>
    <span>end</span>
    <span>[</span><span>s</span><span>,</span> <span>h</span><span>,</span> <span>connection_closing_body</span><span>]</span>
  <span>rescue</span> <span>Exception</span>
    <span>::</span><span>ActiveRecord</span><span>::</span><span>Base</span><span>.</span><span>clear_active_connections!</span>
    <span>raise</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>And this worked‚Ä¶ mostly. Around the same time I have installed Sentry, but I didn‚Äôt take the habit of looking at it regularly - don‚Äôt remember the exact reasons. But, after a few years of painless operation, the app started throwing odd errors. The error that caught my eye was <code>ActiveRecord::ConnectionNotEstablished</code>, and it became more frequent the more load on the site there was. More visits - more frequent errors. Fast-forward a few years, and the error became quite frequent.</p>

<p>My assumption was that to figure out what is going on, I can better upgrade to at least ActiveRecord 6. This version is the oldest Rails version which, by virtue of Ruby version compatibilities, was already able to run on Apple Silicon - <a href="https://blog.julik.nl/2025/03/a-little-adventure-in-modern-frontend">which I am a proud owner of now.</a></p>

<p>Some hours later and a multitude of CoffeeScript files converted (and even more Ruby files edited) the update was complete. I tested it locally, verified everything was in good working order, and deployed the app.</p>

<p>And just 30 minutes in - <code>ConnectionNotEstablished</code>. And not only that, but 10x as frequently as before. The update hasn‚Äôt fixed the problem ‚Äì in fact, it made it worse. Some experiments I did:</p>

<ul>
  <li>Allocating a separate connection pool per tenant and managing it myself</li>
  <li>Doing a connection checkout from a pool and checking it back into the pool</li>
  <li>Juju and voodoo magic</li>
</ul>

<p>Nothing worked. With a helpful hint from <a href="https://kirshatrov.com/posts">Kir</a> ‚Äì who is responsible for exactly the managing of database sharding at one of the ‚Äúbig boys‚Äù ‚Äì I got the idea that it should be possible to use the new <code>roles:</code> parameter - and a fake database configuration - to achieve this functionality.</p>

<p>My mistake was that I was trying to manage pools and connections myself, manually - while the new Rails functionality is actually geared towards Rails maging the pools and connections <em>for you.</em> So in this instance there was also‚Ä¶ a divergent understanding of the API.</p>

<p>I was still in the paradigm that you use <code>establish_connection</code> - like in the olden days - to manage that infrastructure. But the ‚Äúblessed‚Äù approach is actually to furnish Rails the connection configurations and let it handle them automatically.</p>

<h2 id="the-solution">The solution</h2>

<p><code>ActiveRecord::Base</code> now has a class method called <code>connected_to</code>. It allows you to do exactly the thing you need for a database-per-tenant setup - hop into a block with something being your ‚Äúmain‚Äù database. Previously, it accepted <code>database:</code> with a whole DB configuration, but now it only accepts <code>role:</code> (and - with Rails 7 and above - <code>shard:</code>). This is how you use it:</p>

<div><div><pre><code><span>ActiveRecord</span><span>::</span><span>Base</span><span>.</span><span>connected_to</span><span>(</span><span>shard: </span><span>&#34;sites_1&#34;</span><span>)</span> <span>do</span>
  <span>site</span> <span>=</span> <span>Site</span><span>.</span><span>find</span><span>(</span><span>site_id</span><span>)</span> <span># Which lives on this shard, &#34;sites_1&#34;</span>
  <span>posts</span> <span>=</span> <span>site</span><span>.</span><span>pages</span><span>.</span><span>order</span><span>(</span><span>created_at: :desc</span><span>)</span>
<span>end</span>
</code></pre></div></div>

<p>The challenge is where the <code>sites_1</code> gets configured. Normally it would be in your <code>database.yml</code>, as per the <a href="https://guides.rubyonrails.org/active_record_multiple_databases.html">official doc:</a></p>

<div><div><pre><code><span>production</span><span>:</span>
  <span>primary</span><span>:</span>
    <span>database</span><span>:</span> <span>my_primary_database</span>
    <span>adapter</span><span>:</span> <span>mysql2</span>
  <span>primary_replica</span><span>:</span>
    <span>database</span><span>:</span> <span>my_primary_database</span>
    <span>adapter</span><span>:</span> <span>mysql2</span>
    <span>replica</span><span>:</span> <span>true</span>
  <span>primary_shard_one</span><span>:</span>
    <span>database</span><span>:</span> <span>my_primary_shard_one</span>
    <span>adapter</span><span>:</span> <span>mysql2</span>
    <span>migrations_paths</span><span>:</span> <span>db/migrate_shards</span>
</code></pre></div></div>

<p>But if you want to switch between tenants live - and tenants get created (and deleted!) at runtime - having this static config with cross-referencing keys is not going to fly at all. Moreover - even if you can change that ‚ÄúGod config‚Äù ‚Äì how do you force ActiveRecord to reload it? How can you tell ActiveRecord that a shard/tenant no longer exists? And how do you do it in a thread-safe manner? Does it lead to a reinitialisation of all the connection pools, or just addition-deletion?</p>

<p>The solution then becomes focused in one area: taking over from ActiveRecord in managing those connection pools and naming the <code>roles</code> and <code>shards</code> automatically. This is where the bulk of the work was, in the end. We want to convert our tenant database name/filename into a string to devise the <code>role</code> name that we can furnish to AR. For me, I only went to update to Rails 6, so I didn‚Äôt go into shards yet. If I did (and I might, eventually) - the tenant name would be the <code>shard</code>, and the <code>reading</code> and <code>writing</code> roles could be used for hosting a <code>readonly: true</code> DB connection and a writable one. However, a method I ended up using does <em>not</em> support shards even on Rails 8, so read on.</p>

<h2 id="so-how-do-we-create-those-pools">So how do we create those pools?</h2>

<p>The way to do it is to <em>query</em> ActiveRecord for whether a particular connection pool is already setup or not. If it is not - there is going to be a <code>NoConnectionPool</code> exception if you try to switch to the role/shard that doesn‚Äôt exist. But doing this via rescues is not great ‚Äì the control flow becomes a bit intricate. What we can do instead is check whether there is a connection pool set up for a particular role/shard, and then connect if there are none. Note that since this manages pools - it needs to be protected by a mutex:</p>

<div><div><pre><code><span>MUX</span><span>.</span><span>synchronize</span> <span>do</span>
  <span>if</span> <span>ActiveRecord</span><span>::</span><span>Base</span><span>.</span><span>connection_handler</span><span>.</span><span>connection_pool_list</span><span>(</span><span>role_name</span><span>).</span><span>none?</span>
    <span>ActiveRecord</span><span>::</span><span>Base</span><span>.</span><span>connection_handler</span><span>.</span><span>establish_connection</span><span>(</span><span>database_config_hash</span><span>,</span> <span>role: </span><span>role_name</span><span>)</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>After that we can use <code>connected_to</code> - which is going to be thread-safe, fast and pretty neat:</p>

<div><div><pre><code><span>MUX</span><span>.</span><span>synchronize</span> <span>do</span>
  <span>if</span> <span>ActiveRecord</span><span>::</span><span>Base</span><span>.</span><span>connection_handler</span><span>.</span><span>connection_pool_list</span><span>(</span><span>role_name</span><span>).</span><span>none?</span>
    <span>ActiveRecord</span><span>::</span><span>Base</span><span>.</span><span>connection_handler</span><span>.</span><span>establish_connection</span><span>(</span><span>database_config_hash</span><span>,</span> <span>role: </span><span>role_name</span><span>)</span>
  <span>end</span>
<span>end</span>

<span>ActiveRecord</span><span>::</span><span>Base</span><span>.</span><span>connected_to</span><span>(</span><span>role: </span><span>role_name</span><span>)</span> <span>do</span>
  <span>pages</span> <span>=</span> <span>Page</span><span>.</span><span>order</span><span>(</span><span>created_at: :desc</span><span>).</span><span>limit</span><span>(</span><span>10</span><span>)</span> <span># Only selects from that site/tenant</span>
<span>end</span>
</code></pre></div></div>

<h2 id="dont-forget-about-streaming-rack-bodies">Don‚Äôt forget about streaming Rack bodies</h2>

<p>There is a small additional element we need to take care of, though: doing it correctly in Rack. To have something similar to <a href="https://github.com/rails-on-services/apartment/blob/development/lib/apartment/elevators/generic.rb">Apartment::Elevator</a> we need to do something that - again - <code>apartment</code> doesn‚Äôt do correctly. If we assume all the renders of our app are buffered, we can do this:</p>

<div><div><pre><code><span>def</span> <span>call</span><span>(</span><span>env</span><span>)</span>
  <span>site_name</span> <span>=</span> <span>env</span><span>[</span><span>&#34;SERVER_NAME&#34;</span><span>]</span>
  <span>connection_config_hash</span> <span>=</span> <span>{</span><span>adapter: </span><span>&#34;sqlite3&#34;</span><span>,</span> <span>database: </span><span>&#34;sites/</span><span>#{</span><span>site_name</span><span>}</span><span>.sqlite3&#34;</span><span>}</span>
  <span>role_name</span> <span>=</span> <span>&#34;site_</span><span>#{</span><span>site_name</span><span>}</span><span>&#34;</span>

  <span># Create a connection pool for that tenant if it doesn&#39;t exist</span>
  <span>MUX</span><span>.</span><span>synchronize</span> <span>do</span>
    <span>if</span> <span>ActiveRecord</span><span>::</span><span>Base</span><span>.</span><span>connection_handler</span><span>.</span><span>connection_pool_list</span><span>(</span><span>role_name</span><span>).</span><span>none?</span>
      <span>ActiveRecord</span><span>::</span><span>Base</span><span>.</span><span>connection_handler</span><span>.</span><span>establish_connection</span><span>(</span><span>connection_config_hash</span><span>,</span> <span>role: </span><span>role_name</span><span>)</span>
    <span>end</span>
  <span>end</span>
  <span>ActiveRecord</span><span>::</span><span>Base</span><span>.</span><span>connected_to</span><span>(</span><span>role: </span><span>role_name</span><span>)</span> <span>do</span>
    <span>@app</span><span>.</span><span>call</span><span>(</span><span>env</span><span>)</span> <span># returns [status, header, body]</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>But we are aware, of course, that Rack bodies are <em>callable</em> and <em>iterable</em> - and Rack response bodies may also just be doing SQL queries. Code that lives in the Rack response body and serves streaming data is not any less useful than the one living in the app <code>call()</code> method, even though much fewer people use it. I even worked on a <a href="https://github.com/appsignal/appsignal-ruby/pull/1037">big patch to Appsignal, my favorite APM</a> that made it report what happens inside a Rack streaming body the same way it would for the app‚Äôs <code>call</code>. The way it usually works for resource release with those bodies is this:</p>

<div><div><pre><code><span>f</span> <span>=</span> <span>File</span><span>.</span><span>open</span><span>(</span><span>path</span><span>,</span> <span>&#34;rb&#34;</span><span>)</span>
<span>status</span><span>,</span> <span>headers</span><span>,</span> <span>body</span> <span>=</span> <span>@app</span><span>.</span><span>call</span><span>(</span><span>env</span><span>)</span>
<span>body_with_close</span> <span>=</span> <span>Rack</span><span>::</span><span>BodyProxy</span><span>.</span><span>new</span><span>(</span><span>body</span><span>)</span> <span>{</span> <span>f</span><span>.</span><span>close</span> <span>}</span>
<span>[</span><span>status</span><span>,</span> <span>headers</span><span>,</span> <span>body_with_close</span><span>]</span>
</code></pre></div></div>

<p>This attaches a callback to the <code>#close</code> method of the Rack body we return, which - according to the Rack [SPEChttps://github.com/rack/rack/blob/main/SPEC.rdoc] - <em>must</em> be called by the webserver <em>or</em> by the calling middleware.</p>

<p>Reasonably enough, the ActiveRecord API for <code>connected_to</code> only works with a block. That‚Äôs a good idea from the point of encouraging the correct (and safe) usage of a rather blunt tool. However, specifically in this case, it gets in the way. Luckily, this problem can be bypassed with judicious <a href="https://blog.appsignal.com/2018/11/27/ruby-magic-fibers-and-enumerators-in-ruby.html">application of a Fiber:</a></p>

<div><div><pre><code><span>connected_to_context_fiber</span> <span>=</span> <span>Fiber</span><span>.</span><span>new</span> <span>do</span>
  <span>ActiveRecord</span><span>::</span><span>Base</span><span>.</span><span>connected_to</span><span>(</span><span>role: </span><span>role_name</span><span>)</span> <span>do</span>
    <span>Fiber</span><span>.</span><span>yield</span>
  <span>end</span>
<span>end</span>
<span>connected_to_context_fiber</span><span>.</span><span>resume</span>

<span>status</span><span>,</span> <span>headers</span><span>,</span> <span>body</span> <span>=</span> <span>@app</span><span>.</span><span>call</span><span>(</span><span>env</span><span>)</span>
<span>body_with_close</span> <span>=</span> <span>Rack</span><span>::</span><span>BodyProxy</span><span>.</span><span>new</span><span>(</span><span>body</span><span>)</span> <span>{</span> <span>connected_to_context_fiber_</span><span>.</span><span>resume</span> <span>}</span>

<span>[</span><span>status</span><span>,</span> <span>headers</span><span>,</span> <span>body_with_close</span><span>]</span>
</code></pre></div></div>

<p>And thus, our ‚Äútenant switching middleware‚Äù for ActiveRecord connection management with one database per tenant becomes:</p>

<div><div><pre><code><span>class</span> <span>Shardine</span>
  <span>MUX</span> <span>=</span> <span>Mutex</span><span>.</span><span>new</span>

  <span>def</span> <span>initialize</span><span>(</span><span>connection_config</span><span>)</span>
    <span>@config</span> <span>=</span> <span>connection_config</span>
    <span>@role_name</span> <span>=</span> <span>connection_config</span><span>.</span><span>fetch</span><span>(</span><span>:database</span><span>).</span><span>to_s</span>
  <span>end</span>

  <span>def</span> <span>with</span><span>(</span><span>&amp;</span><span>blk</span><span>)</span>
    <span># Create a connection pool for that tenant if it doesn&#39;t exist</span>
    <span>MUX</span><span>.</span><span>synchronize</span> <span>do</span>
      <span>if</span> <span>ActiveRecord</span><span>::</span><span>Base</span><span>.</span><span>connection_handler</span><span>.</span><span>connection_pool_list</span><span>(</span><span>@role_name</span><span>).</span><span>none?</span>
        <span>ActiveRecord</span><span>::</span><span>Base</span><span>.</span><span>connection_handler</span><span>.</span><span>establish_connection</span><span>(</span><span>@config</span><span>,</span> <span>role: </span><span>@role_name</span><span>)</span>
      <span>end</span>
    <span>end</span>
    <span>ActiveRecord</span><span>::</span><span>Base</span><span>.</span><span>connected_to</span><span>(</span><span>role: </span><span>@role_name</span><span>,</span> <span>&amp;</span><span>blk</span><span>)</span>
  <span>end</span>

  <span>def</span> <span>enter!</span>
    <span>@fiber</span> <span>=</span> <span>Fiber</span><span>.</span><span>new</span> <span>do</span>
      <span>with</span><span>(</span><span>conn</span><span>)</span> <span>{</span> <span>Fiber</span><span>.</span><span>yield</span> <span>}</span>
    <span>end</span>
    <span>@fiber</span><span>.</span><span>resume</span>
    <span>true</span>
  <span>end</span>

  <span>def</span> <span>leave!</span>
    <span># Probably there is something in ConnectionHandling</span>
    <span># that can be used here, but I was too lazy to look</span>
    <span>to_resume</span><span>,</span> <span>@fiber</span> <span>=</span> <span>@fiber</span><span>,</span> <span>nil</span>
    <span>to_resume</span><span>&amp;</span><span>.</span><span>resume</span>
  <span>end</span>

  <span>class</span> <span>Middleware</span>
    <span>def</span> <span>initialize</span><span>(</span><span>app</span><span>,</span> <span>&amp;</span><span>database_config_lookup</span><span>)</span>
      <span>@app</span> <span>=</span> <span>app</span>
      <span>@lookup</span> <span>=</span> <span>database_config_lookup</span>
    <span>end</span>

    <span>def</span> <span>call</span><span>(</span><span>env</span><span>)</span>
      <span>connection_config</span> <span>=</span> <span>@lookup</span><span>.</span><span>call</span><span>(</span><span>env</span><span>)</span>
      <span>switcher</span> <span>=</span> <span>TenantDatabaseSwitcher</span><span>.</span><span>new</span><span>(</span><span>connection_config</span><span>)</span>
      <span>did_enter</span> <span>=</span> <span>switcher</span><span>.</span><span>enter!</span>
      <span>status</span><span>,</span> <span>headers</span><span>,</span> <span>body</span> <span>=</span> <span>@app</span><span>.</span><span>call</span><span>(</span><span>env</span><span>)</span>
      <span>body_with_close</span> <span>=</span> <span>Rack</span><span>::</span><span>BodyProxy</span><span>.</span><span>new</span><span>(</span><span>body</span><span>)</span> <span>{</span> <span>switcher</span><span>.</span><span>leave!</span> <span>}</span>
      <span>[</span><span>status</span><span>,</span> <span>headers</span><span>,</span> <span>body_with_close</span><span>]</span>
    <span>rescue</span>
      <span>switcher</span><span>.</span><span>leave!</span> <span>if</span> <span>did_enter</span>
      <span>raise</span>
    <span>end</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>which we then configure in <code>config.ru</code> (or in Rails similarly) like so:</p>

<div><div><pre><code><span>use</span> <span>Shardine</span><span>::</span><span>Middleware</span> <span>do</span> <span>|</span><span>env</span><span>|</span>
  <span>site_name</span> <span>=</span> <span>env</span><span>[</span><span>&#34;SERVER_NAME&#34;</span><span>]</span>
  <span>{</span><span>adapter: </span><span>&#34;sqlite3&#34;</span><span>,</span> <span>database: </span><span>&#34;sites/</span><span>#{</span><span>site_name</span><span>}</span><span>.sqlite3&#34;</span><span>}</span>
<span>end</span>
</code></pre></div></div>

<p>And there you go - a safe and performant database-per-tenant switcher.</p>

<h2 id="an-additional-hurdle">An additional hurdle</h2>

<p>Since I was upgrading to Rails 6 - which seemed the lowest ‚Äúmodern‚Äù version I really had to go to - there was an extra snag.</p>

<p>By default, when you use ActiveRecord without Rails, it gets configured ‚Äúconservatively‚Äù - or, rather, not configured at all. Rails 6 has the concept of <code>legacy_connection_handling</code>. Without going into too much detail, to make this solution work that parameter must be turned off explicitly. In Rails 7 and above this parameter no longer exists.</p>

<h2 id="some-remaining-work">Some remaining work</h2>

<p>Since I initially migrated my app to ActiveRecord 6 I don‚Äôt have <code>shard</code> support yet. It would actually make perfect sense to have your ‚Äúreading replica‚Äù be a <code>readonly: true</code> SQLite3 database, <a href="https://fractaledmind.github.io/2024/04/11/sqlite-on-rails-isolated-connection-pools/">as Stephen has written.</a></p>

<p>Another aspect is that there‚Äôs currently no API to remove a connection pool if a tenant gets removed from the system, which I just don‚Äôt need (my tenants don‚Äôt change as frequently).</p>

<p>Handling other contexts when you need to ‚Äústep into‚Äù a Tenant can be handled similarly, either using <code>connected_to</code> or using the fiber approach.</p>

<p>And, of course, the ‚Äúdatabase per tenant‚Äù workflow is just starting and it‚Äôs only in the recent years, with product from the ONCE family specifically, where SQLite3 began to shine again - as an engine of ‚Äúsmall data, in big numbers‚Äù.</p>

<p>May we live to see this pattern come into the spotlight, finally.</p>


  </article>

</div></div>
  </body>
</html>
