<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lunatic.solutions/blog/magic-handler-functions-in-rust/">Original</a>
    <h1>Magical Handler Functions in Rust</h1>
    
    <div id="readability-page-1" class="page"><article itemscope="" itemtype="http://schema.org/Article"><header><p>October 14, 2022</p></header><section itemprop="articleBody"><p>We at lunatic have been working on a Rust web framework targeting <em>backend</em> WebAssembly, called
<a href="https://github.com/lunatic-solutions/submillisecond">submillisecond</a>. As part of our journey we looked at other web frameworks and their patterns. And
one of the patterns was standing out to me, because it’s used by almost all popular Rust web
frameworks. But not only web frameworks use it, other libraries do too, including the
popular game engine <a href="https://github.com/bevyengine/bevy">bevy</a>. I don’t know the “official” name for it, so I just stole the name
from a recent <a href="https://www.reddit.com/r/rust/comments/xornz5/axums_magical_handler_methods_amazed_me_when_i/">reddit</a> post (magical handler functions).</p>
<h3>Traditional handler functions</h3>
<p>Let’s explore how handler functions usually look in programming languages. Here are a few examples:</p>
<div data-language="rust"><pre><code><span>let</span> app <span>=</span> <span>Router</span><span>::</span><span>new</span><span>(</span><span>)</span>
    <span>.</span><span>route</span><span>(</span><span>&#34;/users&#34;</span><span>,</span> <span>get</span><span>(</span>users<span>)</span><span>)</span>
    <span>.</span><span>route</span><span>(</span><span>&#34;/products&#34;</span><span>,</span> <span>get</span><span>(</span>product<span>)</span><span>)</span><span>;</span>

<span>async</span> <span>fn</span> <span>users</span><span>(</span>req<span>:</span> <span>Request</span><span>)</span> <span>-&gt;</span> <span>Response</span> <span>{</span>
    <span>let</span> params <span>=</span> <span>Query</span><span>&lt;</span><span>Params</span><span>&gt;</span><span>::</span><span>from_request</span><span>(</span><span>&amp;</span>req<span>)</span><span>;</span>
    
<span>}</span>

<span>async</span> <span>fn</span> <span>product</span><span>(</span>req<span>:</span> <span>Request</span><span>)</span> <span>-&gt;</span> <span>Response</span> <span>{</span>
    <span>let</span> db <span>=</span> <span>State</span><span>&lt;</span><span>Db</span><span>&gt;</span><span>::</span><span>from_request</span><span>(</span><span>&amp;</span>req<span>)</span><span>;</span>
    <span>let</span> data <span>=</span> <span>Json</span><span>&lt;</span><span>Payload</span><span>&gt;</span><span>::</span><span>from_request</span><span>(</span><span>&amp;</span>req<span>)</span><span>;</span>
    
<span>}</span></code></pre></div>
<p>You get a <code>Request</code> type as input and return a <code>Response</code>. The <code>Request</code> argument can also be used to
<em>extract</em> more data out of the request, like payloads. The main advantage
of this approach is that it’s fairly simple to understand and maps well to the actual client/server
pattern. There is not much magic here, everything is explicit, and it’s easy to form a mental model
around it.</p>
<p>Rust developers generally like these properties, predictability and explicitness, instead of magic.
That’s why I’m quite surprised that most Rust web frameworks went another route. Let’s look at it!</p>
<h3>Magical handler functions</h3>
<p>What are “magical handler functions” in Rust? They are functions where the signature decides
<strong>what</strong> and <strong>how</strong> to <em>extract</em> from the <code>Request</code> structure. It’s easier to explain them on an
example. Let’s look at the following <a href="https://github.com/tokio-rs/axum">Axum</a> code:</p>
<div data-language="rust"><pre><code><span>let</span> app <span>=</span> <span>Router</span><span>::</span><span>new</span><span>(</span><span>)</span>
    <span>.</span><span>route</span><span>(</span><span>&#34;/users&#34;</span><span>,</span> <span>get</span><span>(</span>users<span>)</span><span>)</span>
    <span>.</span><span>route</span><span>(</span><span>&#34;/products&#34;</span><span>,</span> <span>get</span><span>(</span>product<span>)</span><span>)</span><span>;</span>

<span>async</span> <span>fn</span> <span>users</span><span>(</span><span>Query</span><span>(</span>params<span>)</span><span>:</span> <span>Query</span><span>&lt;</span><span>Params</span><span>&gt;</span><span>)</span>
    <span>-&gt;</span> <span>impl</span> <span>IntoResponse</span> <span>{</span>
    
<span>}</span>

<span>async</span> <span>fn</span> <span>product</span><span>(</span><span>State</span><span>(</span>db<span>)</span><span>:</span> <span>State</span><span>&lt;</span><span>Db</span><span>&gt;</span><span>,</span> data<span>:</span> <span>Json</span><span>&lt;</span><span>Payload</span><span>&gt;</span><span>)</span>
    <span>-&gt;</span> <span>String</span> <span>{</span>
    
<span>}</span></code></pre></div>
<p>Notice how the handler functions passed to the router have a different number of arguments and
different argument types, but magically they are turned into the right values. For example, <code>data</code>
will contain the payload parsed as a <code>Json</code> type.</p>
<p>These functions hide a lot of information from developers, from performance characteristics to error
handling behavior. So let’s take a deeper look to better understand them.</p>
<h3>How do magical handler functions actually work?</h3>
<p>The router takes a generic value <code>F</code> (usually a function), that implements
<code>IntoHandler</code>. And <code>IntoHandler</code> is implemented for functions with a different number of arguments,
where each argument implements <code>FromRequest</code>. This is a “pseudocode” view of the magic:</p>
<div data-language="rust"><pre><code>
<span>impl</span><span>&lt;</span><span>F</span><span>,</span> <span>T</span><span>&gt;</span> <span>IntoHandler</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>for</span> <span>F</span>
<span>where</span>
    <span>F</span><span>:</span> <span>Fn</span><span>(</span><span>T</span><span>)</span><span>,</span>
    <span>T</span><span>:</span> <span>FromRequest</span><span>,</span>
<span>{</span>
    <span>fn</span> <span>call</span><span>(</span><span>self</span><span>,</span> request<span>:</span> <span>Request</span><span>)</span> <span>{</span>
        
        <span>let</span> arg1 <span>=</span> <span>T</span><span>::</span><span>from_request</span><span>(</span><span>&amp;</span>request<span>)</span><span>;</span>
        
        <span>(</span><span>self</span><span>)</span><span>(</span>arg1<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>


<span>impl</span><span>&lt;</span><span>F</span><span>,</span> <span>T1</span><span>,</span> <span>T2</span><span>&gt;</span> <span>IntoHandler</span><span>&lt;</span><span>(</span><span>T1</span><span>,</span> <span>T2</span><span>)</span><span>&gt;</span> <span>for</span> <span>F</span>
<span>where</span>
    <span>F</span><span>:</span> <span>Fn</span><span>(</span><span>T1</span><span>,</span> <span>T2</span><span>)</span><span>,</span>
    <span>T1</span><span>:</span> <span>FromRequest</span><span>,</span>
    <span>T2</span><span>:</span> <span>FromRequest</span><span>,</span>
<span>{</span>
    <span>fn</span> <span>call</span><span>(</span><span>self</span><span>,</span> request<span>:</span> <span>Request</span><span>)</span> <span>{</span>
        <span>let</span> arg1 <span>=</span> <span>T1</span><span>::</span><span>from_request</span><span>(</span><span>&amp;</span>request<span>)</span><span>;</span>
        <span>let</span> arg2 <span>=</span> <span>T2</span><span>::</span><span>from_request</span><span>(</span><span>&amp;</span>request<span>)</span>
        <span>(</span><span>self</span><span>)</span><span>(</span>arg1<span>,</span> arg2<span>)</span><span>;</span>
    <span>}</span>
<span>}</span></code></pre></div>
<p>This version looks fairly similar to the first example of traditional handlers, but we just
moved the control flow into the type system. Now the type <code>T1</code> and <code>T2</code> (also called <em>Extractors</em>)
tell the handler how the request should be transformed into the right arguments.</p>
<h4>Performance implications</h4>
<p>The careful reader will notice that the <code>Request</code> is passed into <code>from_request</code> as a
reference (<code>&amp;</code>). And most of the time the <em>Extractors</em> will create internally a copy of some data.
With the explicit version, we have much more control around the borrowing and cloning:</p>
<div data-language="rust"><pre><code><span>async</span> <span>fn</span> <span>product</span><span>(</span>req<span>:</span> <span>Request</span><span>)</span> <span>-&gt;</span> <span>Response</span> <span>{</span>
    <span>let</span> db <span>=</span> <span>State</span><span>&lt;</span><span>Db</span><span>&gt;</span><span>::</span><span>from_request</span><span>(</span><span>&amp;</span>req<span>)</span><span>;</span>
    <span>let</span> data <span>=</span> <span>Json</span><span>&lt;</span><span>Payload</span><span>&gt;</span><span>::</span><span>from_request</span><span>(</span>req<span>)</span><span>;</span>
    
<span>}</span></code></pre></div>
<p>In this example we borrow the request to get a database connection, but consume it to avoid copying
the payload.</p>
<p>Interestingly enough, the Axum framework makes some of the same optimization, but hides them from the
developer behind the order of argument definitions (I think the last one avoids the clone?):</p>
<div data-language="rust"><pre><code>
<span>async</span> <span>fn</span> <span>product1</span><span>(</span><span>State</span><span>(</span>db<span>)</span><span>:</span> <span>State</span><span>&lt;</span><span>Db</span><span>&gt;</span><span>,</span> data<span>:</span> <span>Json</span><span>&lt;</span><span>Payload</span><span>&gt;</span><span>)</span>
    <span>{</span>  <span>}</span>

<span>async</span> <span>fn</span> <span>product2</span><span>(</span>data<span>:</span> <span>Json</span><span>&lt;</span><span>Payload</span><span>&gt;</span><span>,</span> <span>State</span><span>(</span>db<span>)</span><span>:</span> <span>State</span><span>&lt;</span><span>Db</span><span>&gt;</span><span>)</span>
    <span>{</span>  <span>}</span></code></pre></div>
<p>I’m not a huge fan of this hidden behavior as you need to be familiar with the implementation
details of Axum to reason about performance here. And this actually might change in the future.
Switching from framework to framework could also be confusing. For example, in <a href="https://github.com/lunatic-solutions/submillisecond">submillisecond</a>
it’s the first argument that avoids the clone.</p>
<p>Abstraction and structural sharing becomes also much harder. For example, if you have another
<em>Extractor</em> that needs to get an authorization token from the Json, it will need to re-parse
it. Building performant abstractions by just using <em>Extractors</em> is impossible, because they
are completely independent of each other and can’t share “work already done”.</p>
<h4>Error handling</h4>
<p>Another interesting question is, what happens if the <em>Extractor</em> fails? Rust is known for forcing
the developer to handle every failure, but magical handler functions push the error handling to
the <em>Extractor</em>:</p>
<div data-language="rust"><pre><code><span>pub</span> <span>trait</span> <span>FromRequest</span> <span>{</span>
    
    <span>type</span> <span>Rejection</span><span>:</span> <span>IntoResponse</span><span>;</span>
    
    <span>fn</span> <span>from_request</span><span>(</span>req<span>:</span> <span>&amp;</span><span>mut</span> <span>RequestContext</span><span>)</span>
        <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>Self</span><span>,</span> <span>Self</span><span>::</span><span>Rejection</span><span>&gt;</span><span>;</span>
<span>}</span></code></pre></div>
<p>This is also not great. Developers of extractors need to provide failure responses for their
extractors. This means that if you import two different extractors from different libraries,
they could return error pages that look completely different in style from each other and
also different from your application. And from what I know there is no great way of unifying
that. Makes them in most cases completely useless. Luckily you can catch the error and block
the automatic response by wrapping an <em>Extractor</em> into a <code>Result</code> type:</p>
<div data-language="rust"><pre><code><span>async</span> <span>fn</span> <span>product1</span><span>(</span>data<span>:</span> <span>Result</span><span>&lt;</span><span>Json</span><span>&lt;</span><span>Payload</span><span>&gt;&gt;</span><span>)</span> <span>{</span>  <span>}</span></code></pre></div>
<h4><em>Extractors</em> as an authorization mechanism</h4>
<p>This is something that <a href="https://rocket.rs">Rocket</a> encourages, but it gets a big NO-NO from me. The idea is simple,
if <code>Extractors</code> can fail they can also block you from accessing some handlers. So, why not do
something like this?:</p>
<div data-language="rust"><pre><code><span>async</span> <span>fn</span> <span>admin</span><span>(</span>admin<span>:</span> <span>Admin</span><span>)</span> <span>{</span>  <span>}</span></code></pre></div>
<p>The idea is straightforward. If you need to use the <code>Admin</code> struct in a handler, you should not be
able to access the handler without being able to acquire that struct. However, having arguments as
the only way of restricting access to handlers seems super dangerous to me. Sometimes we want to
guard non-public info but not really use any data belonging to the admin user. An unused argument
can be easily removed by a dev not completely familiar with this concept.</p>
<p>That’s why we decided in submillisecond to use a different approach. We express our routing as a
macro, so it’s easier to safeguard whole subtrees in a robuster way:</p>
<div data-language="rust"><pre><code><span>router!</span> <span>{</span>
    <span>&#34;/short_requests&#34;</span> <span>if</span> <span>ContentLengthGuard</span><span>(</span><span>128</span><span>)</span> <span>=&gt;</span> <span>{</span>
        <span>POST</span> <span>&#34;/super&#34;</span> <span>if</span> <span>ContentLengthGuard</span><span>(</span><span>64</span><span>)</span> <span>=&gt;</span> super_short
        <span>POST</span> <span>&#34;/&#34;</span> <span>=&gt;</span> short
    <span>}</span>
<span>}</span></code></pre></div>
<p>I feel strongly about this. Once your app grows to a certain size, you will need a way of robustly
guarding groups of routes. Having a more declarative mechanism for it makes changes less error-prone.</p>
<p><em>The <code>router!</code> macro in submillisecond generates just a handler function that uses a prefix tree
to dispatch the request to the correct handler, depending on the URL in the request.</em></p>
<h3>Conclusion</h3>
<p>Exploring this pattern was an interesting journey. I still can’t tell why it’s more popular
than the alternative that contains less magic and gives more flexibility to developers. I can only
assume that even Rust developers long for some magic and coolness in their tooling.</p>
<p>The more interesting question to me is, when does this magic become too much? What is the red
line a typical Rust developer would not cross? As Rust’s type system powers keep increasing
(higher-kinded-types and other features), we will probably see much more of compute hidden behind
type definitions. At this point, you can hardly call stuff zero-cost if the order in which
function arguments are defined starts to have side effects.</p>
<p>I also have the feeling that the “magic” word is just reserved for macros in the Rust community. If
you manage to build the same features, but hide them behind the type system, Rust developers will
mostly not consider it magic. In many cases I personally prefer well documented macros instead of
crazy type system workarounds. At a certain level of type complexity the compiler also becomes less
helpful, so it degrades the experience of simpler code being built on top of those abstractions.</p>
<p>I’m definitely not against <strong>some</strong> magic. That’s why we decided to use magical handler functions
in <a href="https://github.com/lunatic-solutions/submillisecond">submillisecond</a> too, but we offer you an escape hatch in the shape that the <code>RequestContext</code> is
also an <em>Extractor</em>, so you can have a handler function with only one argument taking the request:</p>
<div data-language="rust"><pre><code><span>fn</span> <span>product</span><span>(</span>req<span>:</span> <span>RequestContext</span><span>)</span> <span>-&gt;</span> <span>Response</span> <span>{</span> <span>}</span></code></pre></div>
<p>Submillisecond is still super early in the development, but we would love for people to
try it out and give us some feedback. It has some interesting properties:</p>
<ul>
<li>Fast compile times</li>
<li>async-free - preemption and scheduling is done by <a href="https://github.com/lunatic-solutions/lunatic">lunatic</a></li>
<li>strong security - each request is handled in a separate WebAssembly instance</li>
</ul>
<p>We are also working on a <a href="https://github.com/phoenixframework/phoenix_live_view">LiveView</a> implementation for Rust built on top of submillisecond.
<a href="https://discord.gg/b7zDqpXpB4">Join our discord to stay updated</a>!</p></section><hr/></article></div>
  </body>
</html>
