<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.gibbard.me/using_git_offline/">Original</a>
    <h1>Using Git Offline</h1>
    
    <div id="readability-page-1" class="page"><article>
        <p>Some companies use an isolated network or even the complete lack of a network as a security measure to protect from unauthorized access. Working on these systems can be a struggle but it is still possible, and perhaps even more important, to use a proper version control tool like Git.</p>
<p>By design Git works quite happily with no remote repository. You can branch, stage, and commit files just like normal.</p>
<div><pre><span></span><code>mkdir testRepo
<span>cd</span> testRepo
git init
touch test.txt
git add --all
git commit -m <span>&#34;Initial Commit&#34;</span>
</code></pre></div>

<p>This works great if just a single machine is used for development, but this is often not the case.</p>
<h2>Working with multiple machines — Using a USB memory stick/HDD</h2>
<p>When security policy allows read/write access to a memory stick or portable hard drive a remote repository can be created on this device.</p>
<p>On one development machine mount the memory stick.</p>
<div><pre><span></span><code><span>cd</span> /path/to/memory/stick
mkdir repoName.git
<span>cd</span> repoName.git
git init --bare
</code></pre></div>

<p>Navigate to the repository that is to be shared, add the remote repository on the memory stick, and push the changes.</p>
<div><pre><span></span><code><span>cd</span> /path/to/local/repo/
git remote add origin /path/to/memory/stick/repoName.git
git push origin master
</code></pre></div>

<p>NB. The remote can be called anything. It doesn’t have to be called “origin”.</p>
<p>Unmount the memory stick and mount it on another development machine.</p>
<p>If the development machine does not have a copy of the repository on it already then git clone can be used.</p>
<div><pre><span></span><code>git clone /path/to/memory/stick/repoName.git
</code></pre></div>

<p>If there is a copy of the repository already on the machine add the memory stick as a remote and fetch/pull the changes.</p>
<div><pre><span></span><code><span>cd</span> /path/to/local/repo/
git remote add origin /path/to/memory/stick/repoName.git
git pull origin
</code></pre></div>

<p>From now on use Git as normal but make sure that whenever a git pull, fetch, or push is performed the memory stick is mounted on the machine.</p>
<p>Ensure the memory stick is part of your backup routine.</p>
<h2>Working with multiple machines — Using CD/DVDs</h2>
<p>In locked down development environments memory sticks may be blocked. Using Git is still possible, but a little be more inconvenient.</p>
<p>Git will happily fetch changes from one copy of a local repository to another. One option then is to simply copy the directory containing the local Git repository to another computer via CD or other media and make changes and commits like normal on both machines. When you want to combine changes select one machine to perform the merge and copy the other repository over to this machine. To pull all the changes into the current branch use:</p>
<div><pre><span></span><code>git pull /path/to/other/repo
</code></pre></div>

<p>Alternatively you can fetch the changes and create a new branch to store them:</p>
<div><pre><span></span><code>git fetch /path/to/other/repo
git checkout -b new_branch FETCH_HEAD
</code></pre></div>

<p>At this point create a new copy of the repository complete with merges and move it over to the other machine/s. Pull the latest changes into the other repositories or if desired simply replace the whole repository with the new copy.</p>
<p>Obviously this is far from optimal. Copying the whole repository directory will include personal settings and files excluded in the .gitignore file. To mitigate this Git clone could be used to duplicate the repository rather than just copying it, but a much better option is to use git bundle.</p>
<h3>Git bundle</h3>
<p>A git bundle allows for part or all of a repository to be compressed into a single file in a format that git is able to clone and fetch from.</p>
<p>The workflow works very similar to before, but instead of copying the whole repository directory a git bundle is created. On the first machine create a bundle using:</p>
<div><pre><span></span><code>git bundle create repoName.bundle --all
</code></pre></div>

<p>The <code>-- all</code> option bundles the entire repository including all branches and tags. Specific branches or tags can be selected using <code>-b branchName</code> or <code>-t tagName</code>.</p>
<p>Copy the repoName.bundle file to another computer. To clone the repository simply use:</p>
<div><pre><span></span><code>git clone repoName.bundle
</code></pre></div>

<p>Changes and commits can be made on any of the computers then like before one machine must be selected to perform the merge. On the non-merging machine make sure all changes are committed and create a bundle using:</p>
<div><pre><span></span><code>git bundle create repoName.bundle --all
</code></pre></div>

<p>For larger repositories it is a good idea to only bundle part of the repository to avoid transferring more data than needed. For example to only include the last 5 commits on the master branch use:</p>
<div><pre><span></span><code>git bundle create repoName.bundle -5 master
</code></pre></div>

<p>It is important that there are no gaps between the commits in the bundle and the commits on the repository where the merging will occur or the process will fail.</p>
<p>Copy the bundle to the computer where the merge will occur and pull the changes using:</p>
<div><pre><span></span><code>git pull /path/to/repoName.bundle
</code></pre></div>

<p>Once the merging/rebasing is done create another bundle using:</p>
<div><pre><span></span><code>git bundle create repoName.bundle --all
</code></pre></div>

<p>In the above command <code>--all</code> can be replaced with the desired subset of repos/commits.</p>
<p>Move the bundle file to the other machine/s and update the changes there using:</p>
<div><pre><span></span><code>git pull /path/to/repoName.bundle
</code></pre></div>

<h3>Creating a local remote repository</h3>
<p>Bundles solve the problem of synchronising Git repositories without a network, but we are still left with multiple computers all likely to be slightly out of sync with each other. If a new developer joins the team who do they copy the repository from? The best option is to select one development machine that will act as the “server”. A bare Git repository can be created on this development machine in addition to a local clone of the repository where the developer will actually work.</p>
<div><pre><span></span><code><span>cd</span> /path/to/store/main/repo
mkdir remoteRepoName.git
<span>cd</span> remoteRepoName.git
git init --bare
</code></pre></div>

<p>Next navigate to the local git repository or create a new one and add the remoteRepoName.git repository as a remote repository.</p>
<div><pre><span></span><code><span>cd</span> /path/to/local/repo/
git remote add origin /path/to/store/main/repo/remoteRepoName.git
git push origin branchName
</code></pre></div>

<p>Changes can then be made in the local repository, or pulled from bundles created on other development machines. Whenever changes are made they can be pushed to the remote using:</p>
<div><pre><span></span><code>git push origin branchName
</code></pre></div>

<h2>Summary</h2>
<p>The distributed nature of Git allows it to work well without a central server. While the options presented will never be as convenient as just pushing to github they certainly beat the alternative of: <code>main_v1_final version_with_bobs_extra_patch finalfinal_version</code>.</p>
    </article></div>
  </body>
</html>
