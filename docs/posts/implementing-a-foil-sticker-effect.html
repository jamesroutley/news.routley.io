<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.4rknova.com/blog/2025/08/30/foil-sticker">Original</a>
    <h1>Implementing a Foil Sticker Effect</h1>
    
    <div id="readability-page-1" class="page"><div><p>In this post, I’ll walk you through how to create a custom shader in Three.js that simulates the look of a foil sticker, complete with angle-dependent iridescence and sparkling metallic flakes. The goal is to capture that premium, holographic effect you see on collectible stickers, trading cards, and high-end packaging, but to render it in real time directly in the browser.</p><p><img src="https://www.4rknova.com/img/post/20250830/anim01.gif" alt="Foil sticker animation"/></p><p>If you’ve ever tilted a holographic sticker or watched sunlight catch on a soap bubble, you’ve seen iridescence in action. In the real world, this rainbow shimmer comes from thin-film interference. When light waves bounce between layers of a surface, some wavelengths are reinforced while others cancel out, causing colors to shift depending on your viewing angle.</p><p>In real-time computer graphics, we don’t need to simulate the exact physics. Instead, we can approximate this by mapping view angle to hue, as the surface tilts relative to the camera, its color smoothly shifts through a spectrum. This gives that dynamic, “alive” quality you expect from foil stickers.</p><p>Alongside the shifting colors, there’s another key detail: foil flakes. Real metallic foils have tiny reflective particles embedded in them, creating hundreds of bright, sharp highlights that twinkle as you move. These aren’t smooth reflections but randomized sparkles, giving the surface its tactile, premium feel.</p><p>To replicate this in a shader, we’ll introduce procedural noise to generate small random patches of brightness across the surface. When combined with lighting, they look like metallic specks catching the light. Together, angular hue shifts and flake sparkles create a convincing illusion of printed holographic foil without expensive rendering tricks.</p><p>This implementation simulates a peeling, iridescent sticker with foil flakes using Three.js. While I will borrow concepts such as metalness, roughness, and Fresnel from Physically Based Rendering (PBR), this shader is not physically based. The goal is to create a visually plausible, artistic effect.</p><p>Below is a live demo of the shader, where you can modify its parameters and experiment with different configurations. Use your mouse to rotate the sticker around and see how the material reacts to the lighting.</p><h2 id="vertex-shader">Vertex Shader</h2><p>The vertex shader handles the peel geometry and passes useful information to the fragment shader.</p><table><thead><tr><th><strong>Uniform / Varying</strong></th><th><strong>Type</strong></th><th><strong>Purpose</strong></th></tr></thead><tbody><tr><td><code>uPeelAmount</code></td><td>float</td><td>Overall peel strength (0 = flat, 1 = fully peeled).</td></tr><tr><td><code>uPeelAngle</code></td><td>float</td><td>Peel direction in degrees.</td></tr><tr><td><code>vUv</code></td><td>vec2</td><td>UV coordinates for texture mapping.</td></tr><tr><td><code>vWorldPos</code></td><td>vec3</td><td>Vertex position in world space.</td></tr><tr><td><code>vNormal</code></td><td>vec3</td><td>Transformed normal for lighting.</td></tr><tr><td><code>vAOIntensity</code></td><td>float</td><td>Distance moved by vertex, used to darken lifted areas.</td></tr></tbody></table><p>The shader goes through the following simple steps:</p><ol><li>Compute vector from hinge to current vertex.</li><li>Calculate the peel factor and angle.</li><li>Define the rotation axis and apply Rodrigues’ rotation formula to rotate the vertex around that axis.</li><li>Apply the same rotation to the normal.</li><li>Calculate a fake ambient occlusion term.</li></ol><div role="alert" aria-live="polite"><p><img src="https://www.4rknova.com/img/icon/info.svg" alt="Information label"/></p><div><p>The Rodrigues rotation formula is a compact way to rotate a 3D vector around an arbitrary axis. It takes a vector \(\mathbf{v}\), a unit axis of rotation \(\mathbf{k}\), and an angle \(\theta\) and returns the rotated vector \(\mathbf{v}_{rot}\)</p><p>\[\mathbf{v}_{\text{rot}} = \mathbf{v}\cos\theta + (\mathbf{k}\times\mathbf{v})\sin\theta + \mathbf{k}(\mathbf{k}\cdot\mathbf{v})(1-\cos\theta)\]</p></div></div><p>Here’s the full vertex shader code:</p><div><div><pre><code><span>uniform</span> <span>float</span> <span>uPeelAmount</span><span>;</span>  <span>// Strength of peel (0.0 → no peel, 1.0 → full peel)</span>
<span>uniform</span> <span>float</span> <span>uPeelAngle</span><span>;</span>   <span>// Peel angle in degrees (converted to radians in shader)</span>
<span>varying</span> <span>vec2</span>  <span>vUv</span><span>;</span>          <span>// UV coordinates</span>
<span>varying</span> <span>vec3</span>  <span>vWorldPos</span><span>;</span>    <span>// Vertex position in world space</span>
<span>varying</span> <span>vec3</span>  <span>vNormal</span><span>;</span>      <span>// Transformed vertex normal</span>
<span>varying</span> <span>float</span> <span>vAOIntensity</span><span>;</span> <span>// Ambient occlusion or peel intensity factor</span>

<span>void</span> <span>main</span><span>()</span> <span>{</span>
    <span>vUv</span> <span>=</span> <span>vec2</span><span>(</span><span>uv</span><span>.</span><span>x</span><span>,</span> <span>1</span><span>.</span><span>0</span> <span>-</span> <span>uv</span><span>.</span><span>y</span><span>);</span>
    <span>vec3</span> <span>pos</span> <span>=</span> <span>position</span><span>;</span>

    <span>// Define hinge point for peel</span>
    <span>vec3</span> <span>hinge</span> <span>=</span> <span>vec3</span><span>(</span><span>0</span><span>.</span><span>0</span><span>,</span> <span>0</span><span>.</span><span>0</span><span>,</span> <span>0</span><span>.</span><span>0</span><span>);</span>

    <span>// Vector from hinge to current vertex</span>
    <span>vec3</span> <span>toVertex</span> <span>=</span> <span>pos</span> <span>-</span> <span>hinge</span><span>;</span>

    <span>// Peel factor calculation</span>
    <span>// Interpolates peel strength diagonally</span>
    <span>// (bottom-left → top-right)</span>
    <span>float</span> <span>peelFactor</span> <span>=</span> <span>(</span><span>uv</span><span>.</span><span>x</span> <span>+</span> <span>uv</span><span>.</span><span>y</span><span>)</span> <span>*</span> <span>0</span><span>.</span><span>5</span><span>;</span>

    <span>// Convert peel angle to radians</span>
    <span>// Final angle is scaled by peelAmount</span>
    <span>// and per-vertex peelFactor</span>
    <span>float</span> <span>radAngle</span> <span>=</span> <span>radians</span><span>(</span><span>uPeelAngle</span><span>);</span>
    <span>float</span> <span>angle</span> <span>=</span> <span>radAngle</span> <span>*</span> <span>uPeelAmount</span> <span>*</span> <span>peelFactor</span><span>;</span>

    <span>// Define rotation axis for peel</span>
    <span>// Diagonal axis pointing from top-left </span>
    <span>// to bottom-right</span>
    <span>vec3</span> <span>axis</span> <span>=</span> <span>normalize</span><span>(</span><span>vec3</span><span>(</span><span>-</span><span>1</span><span>.</span><span>0</span><span>,</span> <span>1</span><span>.</span><span>0</span><span>,</span> <span>0</span><span>.</span><span>0</span><span>));</span>
    <span>float</span> <span>cosA</span> <span>=</span> <span>cos</span><span>(</span><span>angle</span><span>);</span>
    <span>float</span> <span>sinA</span> <span>=</span> <span>sin</span><span>(</span><span>angle</span><span>);</span>

    <span>// Apply Rodrigues&#39; rotation formula</span>
    <span>// Rotates the vertex around the diagonal axis</span>
    <span>vec3</span> <span>rotated</span> <span>=</span> <span>toVertex</span> <span>*</span> <span>cosA</span> <span>+</span>
                   <span>cross</span><span>(</span><span>axis</span><span>,</span> <span>toVertex</span><span>)</span> <span>*</span> <span>sinA</span> <span>+</span>
                   <span>axis</span> <span>*</span> <span>dot</span><span>(</span><span>axis</span><span>,</span> <span>toVertex</span><span>)</span> <span>*</span> <span>(</span><span>1</span><span>.</span><span>0</span> <span>-</span> <span>cosA</span><span>);</span>

    <span>// Update vertex position after rotation</span>
    <span>pos</span> <span>=</span> <span>hinge</span> <span>+</span> <span>rotated</span><span>;</span>

    <span>// Rotate vertex normal the same way to</span>
    <span>// ensure lighting matches the peeled</span>
    <span>// geometry</span>
    <span>vec3</span> <span>rotatedNormal</span> <span>=</span> <span>normal</span> <span>*</span> <span>cosA</span> <span>+</span>
                         <span>cross</span><span>(</span><span>axis</span><span>,</span> <span>normal</span><span>)</span> <span>*</span> <span>sinA</span> <span>+</span>
                         <span>axis</span> <span>*</span> <span>dot</span><span>(</span><span>axis</span><span>,</span> <span>normal</span><span>)</span> <span>*</span> <span>(</span><span>1</span><span>.</span><span>0</span> <span>-</span> <span>cosA</span><span>);</span>

    <span>// Transform normal into view space</span>
    <span>vNormal</span> <span>=</span> <span>normalize</span><span>(</span><span>normalMatrix</span> <span>*</span> <span>rotatedNormal</span><span>);</span>

    <span>// Transform vertex to world space</span>
    <span>vec4</span> <span>worldPos</span> <span>=</span> <span>modelMatrix</span> <span>*</span> <span>vec4</span><span>(</span><span>pos</span><span>,</span> <span>1</span><span>.</span><span>0</span><span>);</span>
    <span>vWorldPos</span> <span>=</span> <span>worldPos</span><span>.</span><span>xyz</span><span>;</span>

    <span>// Ambient Occlusion term based on distance moved</span>
    <span>// from original vertex position</span>
    <span>vAOIntensity</span> <span>=</span> <span>length</span><span>(</span><span>toVertex</span> <span>-</span> <span>rotated</span><span>);</span>

    <span>// Final projection</span>
    <span>gl_Position</span> <span>=</span> <span>projectionMatrix</span> <span>*</span> <span>viewMatrix</span> <span>*</span> <span>worldPos</span><span>;</span>
<span>}</span>
</code></pre></div></div><h2 id="fragment-shader">Fragment Shader</h2><p>The fragment shader handles all lighting, reflections, iridescence, and foil flakes. It layers procedural effects to create a rich, dynamic look.</p><table><thead><tr><th>Uniform</th><th>Type</th><th>Purpose</th></tr></thead><tbody><tr><td><code>map</code></td><td>sampler2D</td><td>Sticker albedo + alpha.</td></tr><tr><td><code>envMap2D</code></td><td>sampler2D</td><td>Environment map for reflections.</td></tr><tr><td><code>uCameraPos</code></td><td>vec3</td><td>Camera position for view vector.</td></tr><tr><td><code>uAlphaCutoff</code></td><td>float</td><td>Discard pixels below this alpha.</td></tr><tr><td><code>uFlakesEnabled</code></td><td>float</td><td>Toggle foil flakes.</td></tr><tr><td><code>uFlakeSize</code></td><td>float</td><td>Size of flakes.</td></tr><tr><td><code>uFlakeReduction</code></td><td>float</td><td>Randomness threshold for flakes.</td></tr><tr><td><code>uFlakeThreshold</code></td><td>float</td><td>Brightness threshold to show flakes.</td></tr><tr><td><code>uFlakeBrightness</code></td><td>float</td><td>Base brightness of flakes.</td></tr><tr><td><code>uMetalness</code></td><td>float</td><td>PBR-like metal reflectivity control.</td></tr><tr><td><code>uRoughness</code></td><td>float</td><td>Controls reflection sharpness.</td></tr><tr><td><code>uEnvIntensity</code></td><td>float</td><td>Scales environment contribution.</td></tr><tr><td><code>uMetalmask</code></td><td>float</td><td>Mask controlling metallic regions.</td></tr><tr><td><code>uIridescence</code></td><td>float</td><td>Strength of angle-dependent rainbow effect.</td></tr><tr><td><code>uIriMin</code>, <code>uIriRange</code></td><td>float</td><td>Range for simulated film thickness.</td></tr><tr><td><code>uPeelAmount</code>, <code>uPeelAngle</code></td><td>float</td><td>Peel geometry info for shading.</td></tr></tbody></table><p>This is how this works:</p><ol><li>Alpha cutoff to discard transparent pixels early.</li><li>Back-face shading to render the rear surface as plain white or darkened, depending on peel.</li><li>Foil flakes are computed using procedural noise. Normals are perturbed slightly to create sparkle variation. The environment map is sampled to get an iridescent tint.</li><li>Iridescence (thin-film approximation) is calculated using sine-based waves to shift hue by view angle.</li><li>Environment reflections are modulated by Fresnel.</li><li>Final shading combines diffuse base, reflections, iridescence, and flakes.</li></ol><p>Here’s the full vertex shader code:</p><div><div><pre><code><span>precision</span> <span>highp</span> <span>float</span><span>;</span>

<span>#define PI  3.14159265
</span>
<span>varying</span> <span>vec2</span> <span>vUv</span><span>;</span>
<span>varying</span> <span>vec3</span> <span>vNormal</span><span>;</span>
<span>varying</span> <span>vec3</span> <span>vWorldPos</span><span>;</span>
<span>varying</span> <span>float</span> <span>vAOIntensity</span><span>;</span>

<span>uniform</span> <span>sampler2D</span> <span>map</span><span>;</span>      <span>// sticker albedo + alpha</span>
<span>uniform</span> <span>sampler2D</span> <span>envMap2D</span><span>;</span> <span>// LDR equirectangular environment</span>

<span>uniform</span> <span>vec3</span>  <span>uCameraPos</span><span>;</span>
<span>uniform</span> <span>float</span> <span>uAlphaCutoff</span><span>;</span>
<span>uniform</span> <span>float</span> <span>uMaxMip</span><span>;</span>
<span>uniform</span> <span>float</span> <span>uFlakesEnabled</span><span>;</span>
<span>uniform</span> <span>float</span> <span>uFlakeSize</span><span>;</span>
<span>uniform</span> <span>float</span> <span>uFlakeReduction</span><span>;</span>
<span>uniform</span> <span>float</span> <span>uFlakeThreshold</span><span>;</span>
<span>uniform</span> <span>float</span> <span>uFlakeBrightness</span><span>;</span>
<span>uniform</span> <span>float</span> <span>uPeelAmount</span><span>;</span>
<span>uniform</span> <span>float</span> <span>uPeelAngle</span><span>;</span>
<span>uniform</span> <span>float</span> <span>uMetalness</span><span>;</span>
<span>uniform</span> <span>float</span> <span>uRoughness</span><span>;</span>
<span>uniform</span> <span>float</span> <span>uEnvIntensity</span><span>;</span>
<span>uniform</span> <span>float</span> <span>uMetalmask</span><span>;</span>
<span>uniform</span> <span>float</span> <span>uIridescence</span><span>;</span>
<span>uniform</span> <span>float</span> <span>uIriMin</span><span>;</span>
<span>uniform</span> <span>float</span> <span>uIriRange</span><span>;</span>

<span>float</span> <span>hash</span><span>(</span><span>vec2</span> <span>p</span><span>)</span> <span>{</span>
    <span>return</span> <span>fract</span><span>(</span><span>sin</span><span>(</span><span>dot</span><span>(</span><span>p</span><span>,</span> <span>vec2</span><span>(</span><span>127</span><span>.</span><span>1</span><span>,</span> <span>311</span><span>.</span><span>7</span><span>)))</span> <span>*</span> <span>43758</span><span>.</span><span>5453123</span><span>);</span>
<span>}</span>

<span>// Map 3D dir to 2D equirect UV</span>
<span>vec2</span> <span>dirToEquirectUv</span><span>(</span><span>vec3</span> <span>dir</span><span>)</span> <span>{</span>
    <span>dir</span> <span>=</span> <span>normalize</span><span>(</span><span>dir</span><span>);</span>
    <span>float</span> <span>phi</span> <span>=</span> <span>atan</span><span>(</span><span>dir</span><span>.</span><span>z</span><span>,</span> <span>dir</span><span>.</span><span>x</span><span>);</span>
    <span>float</span> <span>theta</span> <span>=</span> <span>acos</span><span>(</span><span>clamp</span><span>(</span><span>dir</span><span>.</span><span>y</span><span>,</span> <span>-</span><span>1</span><span>.</span><span>0</span><span>,</span> <span>1</span><span>.</span><span>0</span><span>));</span>
    <span>return</span> <span>vec2</span><span>((</span><span>phi</span> <span>+</span> <span>3</span><span>.</span><span>14159265</span><span>)</span> <span>/</span> <span>(</span><span>2</span><span>.</span><span>0</span> <span>*</span> <span>3</span><span>.</span><span>14159265</span><span>),</span> <span>theta</span> <span>/</span> <span>3</span><span>.</span><span>14159265</span><span>);</span>
<span>}</span>

<span>vec3</span> <span>sampleEnvRough</span><span>(</span><span>vec3</span> <span>R</span><span>,</span> <span>float</span> <span>roughness</span><span>)</span> <span>{</span>
    <span>vec2</span> <span>uv</span> <span>=</span> <span>dirToEquirectUv</span><span>(</span><span>R</span><span>);</span>

    <span>// Map roughness to LOD level</span>
    <span>float</span> <span>lod</span> <span>=</span> <span>roughness</span> <span>*</span> <span>uMaxMip</span><span>;</span>
    <span>vec3</span> <span>color</span> <span>=</span> <span>texture2DLodEXT</span><span>(</span><span>envMap2D</span><span>,</span> <span>uv</span><span>,</span> <span>lod</span><span>).</span><span>rgb</span><span>;</span>

    <span>return</span> <span>color</span><span>;</span>
<span>}</span>

<span>// Iridescence / thin-film color</span>
<span>vec3</span> <span>iridescenceColor</span><span>(</span><span>float</span> <span>cosTheta</span><span>)</span> <span>{</span>
    <span>float</span> <span>thickness</span> <span>=</span> <span>uIriMin</span> <span>+</span> <span>uIriRange</span> <span>*</span> <span>(</span><span>1</span><span>.</span><span>0</span> <span>-</span> <span>cosTheta</span><span>);</span>
    <span>float</span> <span>phase</span> <span>=</span> <span>6</span><span>.</span><span>28318</span> <span>*</span> <span>thickness</span> <span>*</span> <span>0</span><span>.</span><span>01</span><span>;</span> <span>// scaled for visuals</span>
    <span>vec3</span> <span>rainbow</span> <span>=</span> <span>0</span><span>.</span><span>5</span> <span>+</span> <span>0</span><span>.</span><span>5</span> <span>*</span> <span>vec3</span><span>(</span><span>sin</span><span>(</span><span>phase</span><span>),</span> <span>sin</span><span>(</span><span>phase</span> <span>+</span> <span>2</span><span>.</span><span>094</span><span>),</span> <span>sin</span><span>(</span><span>phase</span> <span>+</span> <span>4</span><span>.</span><span>188</span><span>));</span>
    <span>return</span> <span>mix</span><span>(</span><span>vec3</span><span>(</span><span>1</span><span>.</span><span>0</span><span>),</span> <span>rainbow</span><span>,</span> <span>uIridescence</span><span>);</span>
<span>}</span>

<span>// Convert RGB to perceived luminance (Rec.709)</span>
<span>float</span> <span>luminance</span><span>(</span><span>vec3</span> <span>color</span><span>)</span> <span>{</span>
    <span>return</span> <span>dot</span><span>(</span><span>color</span><span>,</span> <span>vec3</span><span>(</span><span>0</span><span>.</span><span>2126</span><span>,</span> <span>0</span><span>.</span><span>7152</span><span>,</span> <span>0</span><span>.</span><span>0722</span><span>));</span>
<span>}</span>

<span>void</span> <span>main</span><span>()</span> <span>{</span>

    <span>vec4</span> <span>base</span> <span>=</span> <span>texture2D</span><span>(</span><span>map</span><span>,</span> <span>vUv</span><span>);</span>
    <span>if</span><span>(</span><span>base</span><span>.</span><span>a</span> <span>&lt;</span> <span>uAlphaCutoff</span><span>)</span>
        <span>discard</span><span>;</span>

    <span>if</span><span>(</span><span>!</span><span>gl_FrontFacing</span><span>)</span> <span>{</span>
        <span>float</span> <span>col</span> <span>=</span> <span>1</span><span>.</span><span>0</span><span>;</span>
        <span>if</span><span>(</span><span>uPeelAngle</span> <span>&gt;</span> <span>0</span><span>.</span><span>0</span><span>)</span> <span>{</span>
            <span>col</span> <span>=</span> <span>mix</span><span>(</span><span>1</span><span>.</span><span>0</span><span>,</span> <span>0</span><span>.</span><span>2</span><span>,</span> <span>vAOIntensity</span><span>);</span>
        <span>}</span>
        <span>// Render back side as white</span>
        <span>gl_FragColor</span> <span>=</span> <span>vec4</span><span>(</span><span>vec3</span><span>(</span><span>col</span><span>),</span> <span>base</span><span>.</span><span>a</span><span>);</span>
        <span>return</span><span>;</span>
    <span>}</span>

    <span>vec3</span> <span>N</span> <span>=</span> <span>normalize</span><span>(</span><span>vNormal</span><span>);</span>
    <span>vec3</span> <span>V</span> <span>=</span> <span>normalize</span><span>(</span><span>uCameraPos</span> <span>-</span> <span>vWorldPos</span><span>);</span>
    <span>vec3</span> <span>R</span> <span>=</span> <span>reflect</span><span>(</span><span>-</span><span>V</span><span>,</span> <span>N</span><span>);</span>

    <span>// Ambient occlusion / peel shadow</span>
    <span>float</span> <span>peelShadow</span> <span>=</span> <span>0</span><span>.</span><span>0</span><span>;</span>

    <span>if</span><span>(</span><span>uPeelAngle</span> <span>&lt;</span> <span>0</span><span>.</span><span>0</span><span>)</span> <span>{</span>
        <span>peelShadow</span> <span>=</span> <span>smoothstep</span><span>(</span><span>0</span><span>.</span><span>0</span><span>,</span> <span>0</span><span>.</span><span>3</span><span>,</span> <span>vAOIntensity</span><span>);</span>
        <span>base</span><span>.</span><span>rgb</span> <span>*=</span> <span>mix</span><span>(</span><span>1</span><span>.</span><span>0</span><span>,</span> <span>0</span><span>.</span><span>3</span><span>,</span> <span>peelShadow</span><span>);</span>
    <span>}</span>

    <span>// Flakes</span>
    <span>float</span> <span>flakeIntensity</span> <span>=</span> <span>0</span><span>.</span><span>0</span><span>;</span>
    <span>vec3</span> <span>flakeEnv</span> <span>=</span> <span>vec3</span><span>(</span><span>0</span><span>.</span><span>0</span><span>);</span>

    <span>float</span> <span>brightness</span> <span>=</span> <span>luminance</span><span>(</span><span>base</span><span>.</span><span>rgb</span><span>);</span>

    <span>if</span><span>(</span><span>uFlakesEnabled</span> <span>&gt;</span> <span>0</span><span>.</span><span>5</span><span>)</span> <span>{</span>
        <span>// Procedural flake mask</span>
        <span>float</span> <span>flake</span> <span>=</span> <span>hash</span><span>(</span><span>floor</span><span>(</span><span>vUv</span> <span>*</span> <span>uFlakeSize</span><span>));</span>
        <span>float</span> <span>flakeMask</span> <span>=</span> <span>smoothstep</span><span>(</span><span>uFlakeReduction</span><span>,</span> <span>1</span><span>.</span><span>0</span><span>,</span> <span>flake</span><span>);</span>

        <span>// Base brightness influence</span>
        <span>float</span> <span>flakeBoost</span> <span>=</span> <span>smoothstep</span><span>(</span><span>uFlakeThreshold</span><span>,</span> <span>1</span><span>.</span><span>0</span><span>,</span> <span>brightness</span><span>);</span>

        <span>// Perturbed flake normal</span>
        <span>float</span> <span>angleOffset</span> <span>=</span> <span>(</span><span>hash</span><span>(</span><span>vec2</span><span>(</span><span>flake</span><span>,</span> <span>flake</span> <span>+</span> <span>3</span><span>.</span><span>0</span><span>))</span> <span>-</span> <span>0</span><span>.</span><span>5</span><span>)</span> <span>*</span> <span>0</span><span>.</span><span>25</span><span>;</span>
        <span>vec3</span> <span>perturbedNormal</span> <span>=</span> <span>normalize</span><span>(</span><span>N</span> <span>+</span> <span>vec3</span><span>(</span><span>angleOffset</span><span>,</span> <span>0</span><span>.</span><span>0</span><span>,</span> <span>angleOffset</span><span>));</span>

        <span>// Reflection for sparkle</span>
        <span>vec3</span> <span>PR</span> <span>=</span> <span>reflect</span><span>(</span><span>-</span><span>V</span><span>,</span> <span>perturbedNormal</span><span>);</span>

        <span>// Dynamic flicker factor (only brightens, never darkens)</span>
        <span>float</span> <span>flakePhase</span> <span>=</span> <span>hash</span><span>(</span><span>floor</span><span>(</span><span>vUv</span> <span>*</span> <span>uFlakeSize</span><span>)</span> <span>+</span> <span>floor</span><span>(</span><span>PR</span><span>.</span><span>xy</span> <span>*</span> <span>15</span><span>.</span><span>0</span><span>));</span>
        <span>float</span> <span>phaseMod</span> <span>=</span> <span>mix</span><span>(</span><span>1</span><span>.</span><span>0</span><span>,</span> <span>1</span><span>.</span><span>8</span><span>,</span> <span>flakePhase</span><span>);</span>
        
        <span>// Core sparkle factor (glimmer preserved)</span>
        <span>float</span> <span>flakeSpec</span> <span>=</span> <span>pow</span><span>(</span><span>clamp</span><span>(</span><span>dot</span><span>(</span><span>perturbedNormal</span><span>,</span> <span>V</span><span>)</span> <span>*</span> <span>0</span><span>.</span><span>5</span> <span>+</span> <span>0</span><span>.</span><span>5</span><span>,</span> <span>0</span><span>.</span><span>0</span><span>,</span> <span>1</span><span>.</span><span>0</span><span>),</span> <span>8</span><span>.</span><span>0</span><span>);</span>
        <span>flakeSpec</span> <span>=</span> <span>max</span><span>(</span><span>flakeSpec</span><span>,</span> <span>0</span><span>.</span><span>15</span><span>);</span> <span>// always visible</span>

        <span>// Environment tint (never too dark, controlled by uniform)</span>
        <span>float</span> <span>flakeRough</span> <span>=</span> <span>clamp</span><span>(</span><span>uRoughness</span> <span>*</span> <span>0</span><span>.</span><span>4</span><span>,</span> <span>0</span><span>.</span><span>0</span><span>,</span> <span>1</span><span>.</span><span>0</span><span>);</span>
        <span>flakeEnv</span> <span>=</span> <span>sampleEnvRough</span><span>(</span><span>PR</span><span>,</span> <span>flakeRough</span><span>)</span> <span>*</span> <span>mix</span><span>(</span><span>0</span><span>.</span><span>9</span><span>,</span> <span>1</span><span>.</span><span>2</span><span>,</span> <span>brightness</span><span>);</span>
        <span>flakeEnv</span> <span>=</span> <span>max</span><span>(</span><span>flakeEnv</span><span>,</span> <span>vec3</span><span>(</span><span>uFlakeBrightness</span><span>));</span>

        <span>vec3</span> <span>flakeIri</span> <span>=</span> <span>iridescenceColor</span><span>(</span><span>dot</span><span>(</span><span>perturbedNormal</span><span>,</span> <span>V</span><span>));</span>
        <span>flakeEnv</span> <span>*=</span> <span>mix</span><span>(</span><span>vec3</span><span>(</span><span>1</span><span>.</span><span>0</span><span>),</span> <span>flakeIri</span><span>,</span> <span>0</span><span>.</span><span>9</span><span>);</span>

        <span>// Final intensity</span>
        <span>flakeIntensity</span> <span>=</span> <span>flakeMask</span> <span>*</span> <span>flakeBoost</span> <span>*</span> <span>flakeSpec</span> <span>*</span> <span>phaseMod</span> <span>*</span> <span>18</span><span>.</span><span>0</span><span>;</span>
        <span>flakeIntensity</span> <span>=</span> <span>clamp</span><span>(</span><span>flakeIntensity</span><span>,</span> <span>0</span><span>.</span><span>0</span><span>,</span> <span>1</span><span>.</span><span>0</span><span>);</span>
    <span>}</span>

    <span>// Final roughness modulation</span>
    <span>float</span> <span>finalRough</span> <span>=</span> <span>clamp</span><span>(</span><span>mix</span><span>(</span><span>uRoughness</span><span>,</span> <span>1</span><span>.</span><span>0</span><span>,</span> <span>flakeIntensity</span><span>),</span> <span>0</span><span>.</span><span>0</span><span>,</span> <span>1</span><span>.</span><span>0</span><span>);</span>

    <span>// Environment reflection</span>
    <span>vec3</span> <span>env</span> <span>=</span> <span>sampleEnvRough</span><span>(</span><span>R</span><span>,</span> <span>finalRough</span><span>)</span> <span>*</span> <span>uEnvIntensity</span><span>;</span>

    <span>// Blend in flake environment contribution</span>
    <span>env</span> <span>=</span> <span>mix</span><span>(</span><span>env</span><span>,</span> <span>flakeEnv</span><span>,</span> <span>clamp</span><span>(</span><span>flakeIntensity</span><span>,</span> <span>0</span><span>.</span><span>0</span><span>,</span> <span>1</span><span>.</span><span>0</span><span>));</span>

    <span>// Fresnel term</span>
    <span>float</span> <span>cosTheta</span> <span>=</span> <span>clamp</span><span>(</span><span>dot</span><span>(</span><span>N</span><span>,</span> <span>V</span><span>),</span> <span>0</span><span>.</span><span>0</span><span>,</span> <span>1</span><span>.</span><span>0</span><span>);</span>
    <span>float</span> <span>F0</span> <span>=</span> <span>mix</span><span>(</span><span>0</span><span>.</span><span>04</span><span>,</span> <span>1</span><span>.</span><span>0</span><span>,</span> <span>uMetalness</span><span>);</span>
    <span>float</span> <span>fres</span> <span>=</span> <span>F0</span> <span>+</span> <span>(</span><span>1</span><span>.</span><span>0</span> <span>-</span> <span>F0</span><span>)</span> <span>*</span> <span>pow</span><span>(</span><span>1</span><span>.</span><span>0</span> <span>-</span> <span>cosTheta</span><span>,</span> <span>5</span><span>.</span><span>0</span><span>);</span>

    <span>// Iridescence</span>
    <span>float</span> <span>metalicMask</span> <span>=</span> <span>mix</span><span>(</span><span>uMetalmask</span><span>,</span> <span>1</span><span>.</span><span>0</span><span>,</span> <span>brightness</span><span>);</span>
    <span>vec3</span> <span>iriCol</span> <span>=</span> <span>iridescenceColor</span><span>(</span><span>cosTheta</span><span>)</span> <span>*</span> <span>metalicMask</span><span>;</span>

    <span>// Final color</span>
    <span>vec3</span> <span>diffuse</span> <span>=</span> <span>base</span><span>.</span><span>rgb</span> <span>*</span> <span>(</span><span>1</span><span>.</span><span>0</span> <span>-</span> <span>uMetalness</span><span>);</span>
    <span>vec3</span> <span>spec</span> <span>=</span> <span>env</span> <span>*</span> <span>fres</span> <span>*</span> <span>iriCol</span> <span>*</span> <span>(</span><span>1</span><span>.</span><span>0</span> <span>-</span> <span>finalRough</span> <span>*</span> <span>0</span><span>.</span><span>85</span><span>);</span>
    <span>vec3</span> <span>color</span> <span>=</span> <span>diffuse</span> <span>+</span> <span>spec</span><span>;</span>

    <span>gl_FragColor</span> <span>=</span> <span>vec4</span><span>(</span><span>color</span><span>,</span> <span>base</span><span>.</span><span>a</span><span>);</span>
<span>}</span>
</code></pre></div></div><p>The code in this page is licensed under Creative Commons Attribution-NonCommercial 4.0 International (<a href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a>). Feel free to share and adapt the code for non-commercial purposes with proper attribution. If you wish to use the code commercially, please contact me for a separate license agreement.</p><div role="alert" aria-live="polite"><p><img src="https://www.4rknova.com/img/icon/info.svg" alt="Information label"/></p><p>If you enjoyed this post or found the shader implementation helpful, I’d greatly appreciate your support! You can contribute via <a href="https://github.com/sponsors/4rknova">GitHub Sponsors</a> to help me continue creating tutorials, demos, and open-source experiments. Every contribution, no matter the size, makes a difference and helps keep projects like this alive.</p></div></div></div>
  </body>
</html>
