<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/1053142/8ec93e58d5d3cc06/">Original</a>
    <h1>Read_once(), Write_once(), but Not for Rust</h1>
    
    <div id="readability-page-1" class="page"><p>

<h2>[LWN subscriber-only content]</h2>
</p><div>
<blockquote>
<div>
<h3>Welcome to LWN.net</h3>
<p>
The following subscription-only content has been made available to you 
by an LWN subscriber.  Thousands of subscribers depend on LWN for the 
best news from the Linux and free software communities.  If you enjoy this 
article, please consider <a href="https://lwn.net/subscribe/">subscribing to LWN</a>.  Thank you
for visiting LWN.net!
</p></div>
</blockquote>
<p>
The </p><tt>READ_ONCE()</tt><p> and </p><tt>WRITE_ONCE()</tt><p> macros are heavily used
within the kernel; there are nearly 8,000 call sites for
</p><tt>READ_ONCE()</tt><p>.  They are key to the implementation of many <a href="https://lwn.net/Articles/844224/">lockless algorithms</a> and can be necessary for some
types of device-memory access.  So one might think that, as the
amount of Rust code in the kernel increases, there would be a place for
Rust versions of these macros as well.  The truth of the matter, though, is
that the Rust community seems to want to take a different approach to
concurrent data access.
</p><p>
An understanding of <tt>READ_ONCE()</tt> and <tt>WRITE_ONCE()</tt> is
important for kernel developers who will be dealing with any sort of
concurrent access to data.  So, naturally, they are almost entirely absent
from the kernel&#39;s documentation.  A description of sorts can be found at
the top of <a href="https://elixir.bootlin.com/linux/v6.18.3/source/include/asm-generic/rwonce.h"><tt>include/asm-generic/rwonce.h</tt></a>:
</p><blockquote>
	Prevent the compiler from merging or refetching reads or
 	writes. The compiler is also forbidden from reordering successive
 	instances of READ_ONCE and WRITE_ONCE, but only when the compiler
 	is aware of some particular ordering. One way to make the compiler
 	aware of ordering is to put the two invocations of READ_ONCE or
 	WRITE_ONCE in different C statements.
</blockquote>
<p>
In other words, a <tt>READ_ONCE()</tt> call will force the compiler to read
from the indicated location exactly one time, with no optimization tricks
that would cause the read to be either elided or repeated;
<tt>WRITE_ONCE()</tt> will force a write under those terms.  They will also
ensure that the access is atomic; if one task reads a location with
<tt>READ_ONCE()</tt> while another is writing that location, the read will
return the value as it existed either before or after the write, but not
some random combination of the two.  These macros, other than as described
above, impose no ordering constraints on the compiler or the CPU, making
them different from macros like <tt>smp_load_acquire()</tt>, which have
stronger ordering requirements.
</p><p>
The <tt>READ_ONCE()</tt> and <tt>WRITE_ONCE()</tt> macros were <a href="https://git.kernel.org/linus/230fa253df635">added for the 3.18
release</a> in 2014.  <tt>WRITE_ONCE()</tt> was initially called
<tt>ASSIGN_ONCE()</tt>, but that name was <a href="https://git.kernel.org/linus/43239cbe79fc3">changed</a> during the
3.19 development cycle.
</p><p>
On the last day of 2025, Alice Ryhl posted <a href="https://lwn.net/ml/all/20251231-rwonce-v1-0-702a10b85278@google.com">a patch
series</a> adding implementations of <tt>READ_ONCE()</tt> and
<tt>WRITE_ONCE()</tt> for Rust.  There are places in the code, she said,
where volatile reads could be replaced with these calls, once they were
available; among other changes, the series <a href="https://lwn.net/ml/all/20251231-rwonce-v1-5-702a10b85278@google.com">changed access
to the <tt>struct file</tt> <tt>f_flags</tt> field</a> to use
<tt>READ_ONCE()</tt>.  The <a href="https://lwn.net/ml/all/20251231-rwonce-v1-2-702a10b85278@google.com">implementation</a>
of these macros involves a bunch of Rust macro magic, but in the end they come
down to calls to the Rust <a href="https://doc.rust-lang.org/std/ptr/fn.read_volatile.html"><tt>read_volatile()</tt></a>
and <a href="https://doc.rust-lang.org/stable/std/ptr/fn.write_volatile.html"><tt>write_volatile()</tt></a> functions.
</p><p>
Some of the other kernel Rust developers objected to this change, though.
Gary Guo <a href="https://lwn.net/ml/all/20251231151216.23446b64.gary@garyguo.net">said</a> that he
would rather not expose <tt>READ_ONCE()</tt> and <tt>WRITE_ONCE()</tt> and
suggested using relaxed operations from <strike><a href="https://doc.rust-lang.org/std/sync/atomic/">the Rust <tt>Atomic</tt>
crate</a></strike> the kernel&#39;s <a href="https://rust.docs.kernel.org/next/kernel/sync/atomic/struct.Atomic.html"><tt>Atomic</tt></a>
module instead.  Boqun Feng <a href="https://lwn.net/ml/all/aVXKP8vQ6uAxtazT@tardis-2.local">expanded on</a> the
objection:
</p><blockquote>
	The problem of READ_ONCE() and WRITE_ONCE() is that the semantics
	is complicated. Sometimes they are used for atomicity, sometimes
	they are used for preventing data race. So yes, we are using LKMM
	[the Linux kernel memory model] in Rust as well, but whenever
	possible, we need to clarify the intention of the API, using
	Atomic::from_ptr().load(Relaxed) helps on that front.
<p>
	IMO, READ_ONCE()/WRITE_ONCE() is like a &#34;band aid&#34; solution to a
	few problems, having it would prevent us from developing a more
	clear view for concurrent programming.
</p></blockquote>
<p>
In other words, using the <tt>Atomic</tt> crate allows developers to
specify more precisely which guarantees an operation needs, making the
expectations (and requirements) of the code more clear.
This point of view would appear to have won out, and Ryhl has stopped
pushing for this addition to the kernel&#39;s Rust code â€” for now, at least.
</p><p>
There are a couple of interesting implications from this outcome, should it
hold.  The first of those is that, as Rust code reaches more deeply into the
core kernel, its code for concurrent access to shared data will look
significantly different from the equivalent C code, even though the code on
both sides may be working with the same data.  Understanding lockless data
access is challenging enough when dealing with one API; developers may now
have to understand two APIs, which will not make the task easier.
</p><p>
Meanwhile, this discussion is drawing some attention to code on the C side
as well.  As Feng <a href="https://lwn.net/ml/all/aV0JkZdrZn97-d7d@tardis-2.local">pointed
out</a>, there is still C code in the kernel that assumes a plain write
will be atomic in many situations, even though the C standard explicitly
says otherwise.  Peter Zijlstra <a href="https://lwn.net/ml/all/20260106145622.GB3707837@noisy.programming.kicks-ass.net">answered</a>
that all such code should be updated to use <tt>WRITE_ONCE()</tt> properly.
Simply finding that code may be a challenge (though <a href="https://docs.kernel.org/dev-tools/kcsan.html">KCSAN</a> can help);
updating it all may take a while.  The conversation also <a href="https://lwn.net/ml/all/87ikdej4s1.fsf@t14s.mail-host-address-is-not-set">identified</a>
a place in the (C) high-resolution-timer code that is missing a needed
<tt>READ_ONCE()</tt> call.  This is another example of the Rust work
leading to improvements in the C code.
</p><p>
In past discussions on the design of Rust abstractions, there has been
resistance to the creation of Rust interfaces that look substantially
different from their C counterparts; see <a href="https://lwn.net/Articles/958072/">this
2024 article</a>, for example.  If the Rust developers come up with a
better design for an interface, the thinking went, the C side should be
improved to match this new design.  If one accepts the idea that the Rust
approach to <tt>READ_ONCE()</tt> and <tt>WRITE_ONCE()</tt> is better than
the original, then one might conclude that  a similar process should be
followed here.  Changing thousands of low-level concurrency primitives to
specify more precise semantics would not be a task for the faint of heart,
though.  This may end up being a case where code in the two languages just
does things differently.<br clear="all"/></p><table>
           <tbody><tr><th colspan="2">Index entries for this article</th></tr>
           <tr><td><a href="https://lwn.net/Kernel/Index">Kernel</a></td><td><a href="https://lwn.net/Kernel/Index#Development_tools-Rust">Development tools/Rust</a></td></tr>
            <tr><td><a href="https://lwn.net/Kernel/Index">Kernel</a></td><td><a href="https://lwn.net/Kernel/Index#Lockless_algorithms">Lockless algorithms</a></td></tr>
            </tbody></table></div></div>
  </body>
</html>
