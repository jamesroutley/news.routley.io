<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://radu-matei.com/blog/intro-wasm-components/">Original</a>
    <h1>Introduction to WebAssembly Components</h1>
    
    <div id="readability-page-1" class="page"><div>
            


            <p><a href="https://webassembly.org" target="_blank" rel="noreferrer noopener">WebAssembly</a>
 (or Wasm) is a W3C specification for a
portable binary format for distributing and running code that has been
implemented in the four major browser engines since 2017. In familiar terms,
Wasm is used as a compilation target for
<a href="https://webassembly.org/getting-started/developers-guide" target="_blank" rel="noreferrer noopener">various programming languages</a>
,
generating a compact binary that can run at near-native speeds in the browser.
This brought existing languages such as Rust, C and C++, Go, or C# (and new
languages like <a href="https://grain-lang.org/" target="_blank" rel="noreferrer noopener">Grain</a>
) to the web, and enabled porting
extremely complex applications such as
<a href="https://medium.com/google-earth/google-earth-comes-to-more-browsers-thanks-to-webassembly-1877d95810d6" target="_blank" rel="noreferrer noopener">Google Earth</a>

or <a href="https://web.dev/ps-on-the-web/" target="_blank" rel="noreferrer noopener">Photoshop</a>
 to the browser.</p>
<p>Despite the name, however, nothing in WebAssembly is specific to browsers —
and in fact, the same benefits that make it a compelling execution environment
for browsers (such as near-native speed, compact binary format, or sandbox
isolation) make it well-suited for scenarios outside the browser, in
datacenters, clouds, or on the edge.
<a href="https://wasi.dev/" target="_blank" rel="noreferrer noopener">The WASI project, or the WebAssembly System Interface</a>
, is a
proposal that aims to standardize the execution of Wasm outside the browser and
to provide a common (platform agnostic) layer and set of primitives that guest
modules can use to interact with the underlying runtime, while maintaining the
secure sandbox promised by WebAssembly.
(<a href="https://bytecodealliance.org/articles/announcing-the-bytecode-alliance" target="_blank" rel="noreferrer noopener">Lin Clark’s initial post announcing the Bytecode Alliance</a>

does a fantastic job at explaining the goals of WASI.)</p>
<p>WebAssembly and WASI show great promise for the future of computing outside the
browser — but attempting to write any non-trivial WebAssembly application that
tries to interoperate across runtime or language boundaries requires significant
effort today, and exchanging any non-fundamental data types (such as strings or
structures) involves pointer arithmetic and low-level memory manipulation.</p>
<p>The <a href="https://github.com/WebAssembly/component-model" target="_blank" rel="noreferrer noopener">component model proposal</a>

aims to solve this issue, and this article will explain the goals of the
proposal and will showcase how to use the current tooling from the
<a href="https://bytecodealliance.org/" target="_blank" rel="noreferrer noopener">Bytecode Alliance</a>
 to build and execute such
components in Rust and C++.</p>
<blockquote>
<p>Note: The demo components, the implementations, the tools used, and the
developer experience showed here represent very early attempts to solve this,
and future tooling will improve it. This is shown for educational purposes,
and should not be considered stable.</p>
</blockquote>
<h2 id="the-webassembly-component-model">The WebAssembly component model</h2>
<p>Using an operating system analogy, WebAssembly allows the execution of low-level
CPU instructions, while WASI is a way to model input/output interfaces. From
this perspective, the need for a “process model” that defines how processes are
started and how they interact with each other is starting to emerge — this is
what the WebAssembly component model proposal is trying to address.</p>
<p>The first stated
<a href="https://github.com/WebAssembly/component-model/blob/main/design/high-level/Goals.md" target="_blank" rel="noreferrer noopener">goal</a>

of the component model is <em>to define a portable, load- and run-time-efficient
binary format […] that enables portable, cross-language composition</em> –
effectively, addressing how multiple components can interact with each other,
and the use cases describe a wide range of scenarios for embedding components,
composition, and dynamic linking.</p>
<p>The main use case this article addresses is the following — defining an API
layer as a WebAssembly interface, implementing it as a WebAssembly component,
then consuming it from other components by passing arguments and return values.
There are numerous other topics to explore in this area such as transitive
dependencies, distribution, developer experience, or building specialized host
runtimes for a given interface, all of which will be addressed in future
articles.</p>
<h2 id="defining-and-implementing-webassembly-components">Defining and implementing WebAssembly components</h2>
<p>The goal is to build a component that can be imported from other WebAssembly
modules, written in potentially other programming languages, and the first step
is defining its interface — what is the public API this component will
implement? This is done using WIT (WebAssembly Interface), an experimental
textual format used for defining Wasm interfaces. It is the next iteration of
<a href="https://github.com/WebAssembly/WASI/blob/main/docs/witx.md" target="_blank" rel="noreferrer noopener">WITX</a>
, which itself
is based on
<a href="https://webassembly.github.io/spec/core/text/index.html" target="_blank" rel="noreferrer noopener">the standard text format</a>
.
(A non-trivial example of using the new WIT format can be found
<a href="https://github.com/bytecodealliance/wit-bindgen/blob/32e63116d469d8046727fae3c1333a7d35d0c5d3/tests/codegen/wasi-next/wasi_next.wit" target="_blank" rel="noreferrer noopener">here</a>
.)</p>
<p>The component is going to be a simple key/value cache layer that gets, stores,
and deletes arbitrary payloads:</p>
<pre><code>// cache.wit
// Type for cache errors.
enum error {
    runtime_error,
    not_found_error,
}
// Payload for cache values.
type payload = list&lt;u8&gt;
// Set the payload for the given key.
set: function(key: string, value: payload, ttl: option&lt;u32&gt;) -&gt; expected&lt;_, error&gt;
// Get the payload stored in the cache for the given key.
get: function(key: string) -&gt; expected&lt;payload, error&gt;
// Delete the cache entry for the given key.
delete: function(key: string) -&gt; expected&lt;_, error&gt;
</code></pre><p>Let’s implement this interface in Rust, using the file system as storage for the
cache:</p>
<div><pre><code data-lang="shell">$ cargo new --lib rust-wasi-impl
Created library <span>`</span>rust-wasi-impl<span>`</span> package
</code></pre></div><p>Next, the only dependency needed is
<a href="https://github.com/bytecodealliance/wit-bindgen" target="_blank" rel="noreferrer noopener">wit-bindgen-rust</a>
 — a
Bytecode Alliance project that generates Rust bindings given a WIT interface:</p>
<pre><code># Cargo.toml
[lib]
    crate-type = [ &#34;cdylib&#34; ]

[dependencies]
    wit-bindgen-rust = { git = &#34;https://github.com/bytecodealliance/wit-bindgen&#34;, rev = &#34;32e63116d469d8046727fae3c1333a7d35d0c5d3&#34; }

</code></pre><p>The next section contains a simplified version of the actual implementation
(note that the complete implementation for all components
<a href="https://github.com/radu-matei/wasm-components-example" target="_blank" rel="noreferrer noopener">can be found on GitHub</a>
).
A very important part here is the <code>wit_bindgen_rust::export!</code> procedural macro
— it takes the interface file as input, and it automatically generates Rust
bindings for all the objects defined in the interface, bindings necessary to
implement the interface.</p>
<p>This is equivalent to using the wit-bindgen CLI to manually generate the
bindings (to check in to source control, or inspect):</p>
<pre><code>$ wit-bindgen rust-wasm --export ../cache.wit
Generating &#34;bindings.rs&#34;
</code></pre><p>Inspecting the generated bindings, we can see the low-level code (that until now
had to be manually written) to handle passing non-fundamental data types between
modules, with
<a href="https://github.com/WebAssembly/interface-types/pull/140" target="_blank" rel="noreferrer noopener">the canonical ABI described in the interface types proposal</a>
.</p>
<p>Rust’s excellent macro support means the bindings can be dynamically generated
from the interface at build time. Regardless of how the bindings are generated,
the main piece to implement here is
<a href="https://doc.rust-lang.org/book/ch10-02-traits.html" target="_blank" rel="noreferrer noopener">a Rust trait</a>
 that models
the API from the interface:</p>
<div><pre><code data-lang="rust"><span>// lib.rs
</span><span></span>wit_bindgen_rust::export<span>!</span>(<span>&#34;../cache.wit&#34;</span>);

<span>struct</span> <span>Cache</span> {}
<span>impl</span> cache::Cache <span>for</span> Cache {
    <span>fn</span> <span>set</span>(key: String, value: <span>Payload</span>, _: Option<span>&lt;</span><span>u32</span><span>&gt;</span>) -&gt; Result<span>&lt;</span>(), Error<span>&gt;</span> {
        <span>let</span> <span>mut</span> file <span>=</span> File::create(path(<span>&amp;</span>key)<span>?</span>)<span>?</span>;
        file.write_all(<span>&amp;</span>value)<span>?</span>;
        Ok(())
    }

    <span>fn</span> <span>get</span>(key: String) -&gt; Result<span>&lt;</span>Payload, Error<span>&gt;</span> {
        <span>let</span> <span>mut</span> file <span>=</span> File::open(path(<span>&amp;</span>key)<span>?</span>)<span>?</span>;
        <span>let</span> <span>mut</span> buf <span>=</span> Vec::new();
        file.read_to_end(<span>&amp;</span><span>mut</span> buf)<span>?</span>;
        Ok(buf)
    }
 ...
}
</code></pre></div><p>(Note that at the time of writing this article, the convention for Rust
implementations is that the struct implementing the interface trait must have
the same name (accommodating for <code>snake_case</code>) as the interface file, hence
struct <code>Cache {}</code>. There are also a few error handling specific parts omitted
from the snippet above,
<a href="https://github.com/radu-matei/wasm-components-example" target="_blank" rel="noreferrer noopener">see complete implementation</a>
.)</p>
<p>The actual implementation is straightforward – store and retrieve keys/value
pairs as files in the file system (assuming this component has the capability to
write to a filesystem).</p>
<p>At this point, the Wasm module can be built using the Rust toolchain. Then,
using the translator from the binary format to the text format (from
<a href="https://github.com/bytecodealliance/wasm-tools" target="_blank" rel="noreferrer noopener">this repo</a>
), we can see the
module exports the three methods from the interface, together with functions to
adapt the arguments passed between boundaries (as described by
<a href="https://github.com/WebAssembly/interface-types/pull/140" target="_blank" rel="noreferrer noopener">the canonical ABI</a>
):</p>
<pre><code>$ cargo build --target wasm32-wasi --release
$ wasm2wat-rs target/wasm32-wasi/release/rust_wasi_impl.wasm | grep export
  (export &#34;set&#34; (func $set.command_export))
  (export &#34;get&#34; (func $get.command_export))
  (export &#34;delete&#34; (func $delete.command_export))
  (export &#34;canonical_abi_realloc&#34; (func $canonical_abi_realloc.command_export))
  (export &#34;canonical_abi_free&#34; (func $canonical_abi_free.command_export))
</code></pre><h2 id="importing-webassembly-interfaces-in-rust-and-c">Importing WebAssembly interfaces in Rust and C++</h2>
<p>The previous section defined an interface using WIT, then implemented it in Rust
using the convenient macros provided by <code>wit-bindgen</code>. This section will create
two new components, in Rust and C++, which will import the interface.</p>
<p>First, a new Rust executable with the same Cargo dependency as the previous
component:</p>
<pre><code>$ cargo new --bin rust-consumer
</code></pre><p>As in the previous Rust component, the main aspect here is the use of the
<code>wit_bindgen_rust::import!</code> procedural macro — same as before, the macro takes
the interface and generates Rust bindings, but crucially, because this component
<em>imports</em> the interface, the bindings will be different (they can be inspected
by executing <code>wit-bindgen rust-wasm --import ../cache.wit</code>):</p>
<div><pre><code data-lang="rust">wit_bindgen_rust::import<span>!</span>(<span>&#34;../cache.wit&#34;</span>);

<span>fn</span> <span>main</span>() {
    <span>let</span> key <span>=</span> <span>&#34;five-good-emperors&#34;</span>;
    <span>let</span> value <span>=</span> <span>&#34;Nerva, Trajan, Hadrian, Pius, and Marcus Aurelius&#34;</span>;

    cache::set(key, value.as_bytes(), None).unwrap();
    <span>let</span> ret <span>=</span> cache::get(key).unwrap();
    assert_eq<span>!</span>(ret, value.as_bytes());
}
</code></pre></div><p>The generated import bindings can be used in a very idiomatic way to set and
retrieve information.</p>
<p>The important thing to note here is that the program above only needs the
<em>interface</em> in order to compile, as the generated WebAssembly module will
contain imports for the cache functionality:</p>
<pre><code>$ cargo build --target wasm32-wasi --release
$ wasm2wat-rs target/wasm32-wasi/release/rust-consumer.wasm | grep import
  (import &#34;cache&#34; &#34;set&#34; (func $rust_consumer_cache_set_wit_import (type 8)))
  (import &#34;cache&#34; &#34;get&#34; (func $rust_consumer_cache_get_wit_import (type 9)))
  (import &#34;wasi_snapshot_preview1&#34; &#34;fd_write&#34; (func $wasi_wasi_fd_write (type 10)))

</code></pre><p>Before actually linking and executing the main module above, it is worth
exploring how to build another consumer, this time in C++.</p>
<p>Because C++ doesn’t have the same macro system as Rust, the bindings need to be
on disk at compile time — using wit-bindgen (and generating <em>import</em> bindings,
as the C++ component will import the interface), they are written into a
bindings/ directory:</p>
<pre><code># Makefile
bindgen:
    $(WIT_BINDGEN) c --import ../cache.wit --out-dir bindings

build:
    $(WASI_CC) -I . -I ./bindings -c -o cache.o bindings/cache.c
    $(WASI_CC) main.cpp cache.o -o cpp_consumer.wasm
</code></pre><p>At this point, the implementation is a C++ main program that uses the header
file defined in bindings/cache.h and calls the functions to get and set
key/value pairs:</p>
<div><pre><code data-lang="cpp"><span>#include</span> <span>&#34;bindings/cache.h&#34;</span><span>
</span><span></span>
<span>int</span> <span>main</span>(<span>int</span> argc, <span>char</span> <span>**</span>argv)
{
    <span>char</span> <span>*</span>key <span>=</span> <span>&#34;almost-consul&#34;</span>;
    <span>char</span> <span>*</span>value <span>=</span> <span>&#34;Caligula&#39;s horse, Incitatus&#34;</span>;
    printf(<span>&#34;Writing contents `%s` in storage `%s`&#34;</span>, value, key);

    cache_string_t <span>*</span>skey;
    skey<span>-&gt;</span>len <span>=</span> strlen(key);
    skey<span>-&gt;</span>ptr <span>=</span> key;

    cache_payload_t <span>*</span>svalue;
    svalue<span>-&gt;</span>len <span>=</span> strlen(value);
    svalue<span>-&gt;</span>ptr <span>=</span> (<span>uint8_t</span> <span>*</span>)value;

    cache_set(skey, svalue, NULL);

    cache_payload_t <span>*</span>ret;
    cache_get(skey, ret);
    printf(<span>&#34;Retrieved from `%s`: `%s`&#34;</span>, key, (<span>char</span> <span>*</span>)ret<span>-&gt;</span>ptr);
    assert(svalue<span>-&gt;</span>len <span>==</span> ret<span>-&gt;</span>len);
}
</code></pre></div><p>The rest of the implementation is adapting the character arrays where the key
and value are stored into the types expected by the interface. Finally, this can
be compiled, and exploring the resulting module’s imports, the same imports from
a cache module can be seen:</p>
<pre><code>$ make bindgen build
$ wasm2wat-rs cpp_consumer.wasm | grep import
  (import &#34;wasi_snapshot_preview1&#34; &#34;proc_exit&#34; (func $__wasi_proc_exit (type 2)))
  (import &#34;cache&#34; &#34;set&#34; (func $__wasm_import_cache_set (type 3)))
  (import &#34;cache&#34; &#34;get&#34; (func $__wasm_import_cache_get (type 4)))
</code></pre><h2 id="linking-and-executing-components">Linking and executing components</h2>
<p>The previous sections defined the interface, built an implementation for it,
then imported the interface in two Rust and C++ programs, resulting in two
WebAssembly modules with imports that must be satisfied before they can be
instantiated. This section will them with the actual component implementation
using
<a href="https://github.com/bytecodealliance/wit-bindgen/tree/main/crates/wasmlink" target="_blank" rel="noreferrer noopener">wasmlink</a>

, a CLI that allows us to statically link <em>a module and its dependencies using
<a href="https://github.com/WebAssembly/module-linking" target="_blank" rel="noreferrer noopener">module linking</a>
 and
<a href="https://github.com/WebAssembly/interface-types/pull/140" target="_blank" rel="noreferrer noopener">the Canonical Interface Types ABI</a>
.</em></p>
<p>Starting with the C++ module that imports the interface, before executing it,
its cache imports must be satisfied — this is currently done manually using
wasmlink:</p>
<div><pre><code data-lang="Makefile"><span>link</span><span>:</span>
    <span>$(</span>WASMLINK<span>)</span> cpp_consumer.wasm <span>\
</span><span></span>        --interface cache<span>=</span>../cache.wit <span>\
</span><span></span>        --profile wasmtime <span>\
</span><span></span>        --module cache<span>=</span>../rust-wasi-impl/target/wasm32-wasi/release/rust_wasi_impl.wasm <span>\
</span><span></span>        --output linked.wasm

<span>run</span><span>:</span>
    <span>$(</span>WASMTIME<span>)</span> --enable-module-linking --enable-multi-memory --mapdir<span>=</span>/cache::. linked.wasm
</code></pre></div><p>The link target uses the wasmlink CLI to supply the Rust implementation of the
interface whenever the cpp_consumer.wasm imports anything from the cache module.
The linker is also generating WebAssembly code responsible for adapting the data
between the linear memories of each component, meaning that no component can
access another component’s memory directly, ensuring a “shared-nothing”
approach.</p>
<p>The output of this target is a statically linked module that contains an inline
copy of the Rust implementation for the cache interface. (The various imports
and exports of the final linked module can be explored using wasm2wat-rs.)</p>
<p>Finally, this can be run using Wasmtime (with support for the module linking and
multi memory proposals enabled, and with granting the module the ability to use
the filesystem, where the cache implementations stores data):</p>
<pre><code>$ make link run
wasmtime --enable-module-linking --enable-multi-memory --mapdir=/cache::. linked.wasm
Retrieved from `almost-consul`: `Caligula&#39;s horse, Incitatus`
</code></pre><p>The same commands can be run for the Rust consumer:</p>
<pre><code>$ make link run
wasmtime --enable-module-linking --enable-multi-memory --mapdir=/cache::. linked.wasm
Retrieved from five-good-emperors: Nerva, Trajan, Hadrian, Pius, and Marcus Aurelius
</code></pre><p>Right now, linking is a manual operation, but as the tooling and language
support evolves, this will be significantly improved.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This article explored the new WebAssembly component model proposal and
demonstrated a very early way of using interfaces, building Rust and C++
components, linking, and running them with Wasmtime. There is a great
opportunity for improving the developer experience for building, consuming, and
linking Wasm component, and future articles will showcase the improvements done
together with the community, as well as other areas such as language toolchain
integration, or the distribution of components.</p>
<p>As more programming languages add WebAssembly as a compilation target, and as
tooling is built that automatically generates bindings for those programming
languages, the component model will enable true potable and cross-language
composition for software.</p>


            
            

            
        </div></div>
  </body>
</html>
