<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://arkadiyt.com/2024/03/03/reverse-engineering-protobuf-definitiions-from-compiled-binaries/">Original</a>
    <h1>Reverse Engineering Protobuf Definitions from Compiled Binaries</h1>
    
    <div id="readability-page-1" class="page"><div><div><p><span>Mar 3rd, 2024 | 14 minute read</span></p><p>A few years ago I released <a href="https://github.com/arkadiyt/protodump" target="_blank" rel=" noopener external">protodump</a>, a CLI for extracting full source protobuf definitions from compiled binaries (regardless of the target architecture). This can come in handy if you’re trying to reverse engineer an API used by a closed source binary, for instance. In this post I’ll explain how it works, but first, a demo:</p><p><img src="https://raw.githubusercontent.com/arkadiyt/protodump/main/demo/demo.gif" alt="Demo of protodump"/></p><h3 id="how-does-it-work">How does it work?</h3><p>To understand how it works, lets take a look at a small <code>test.proto</code> example:</p><div><div><pre><code><span>syntax</span> <span>=</span> <span>&#34;proto3&#34;</span><span>;</span>

<span>option</span> <span>go_package</span> <span>=</span> <span>&#34;./;helloworld&#34;</span><span>;</span>

<span>message</span> <span>HelloWorld</span> <span>{</span>
  <span>string</span> <span>name</span> <span>=</span> <span>1</span><span>;</span>
<span>}</span>
</code></pre></div></div><p>If we compile this with protoc to golang we’ll get some golang code that defines the object type, creates getters and setters for the <code>name</code> field, and so on. We can use it as follows:</p><div><div><pre><code><span>func</span> <span>main</span><span>()</span> <span>{</span>
	<span>obj</span> <span>:=</span> <span>helloworld</span><span>.</span><span>HelloWorld</span><span>{</span>
		<span>Name</span><span>:</span> <span>&#34;myname&#34;</span><span>,</span>
	<span>}</span>

	<span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;%s</span><span>\n</span><span>&#34;</span><span>,</span> <span>obj</span><span>.</span><span>GetName</span><span>())</span>
<span>}</span>
</code></pre></div></div><p>However protobuf also supports runtime reflection. Rather than invoking the getter method at compile time, we can fetch the list of fields and query them at runtime:</p><div><div><pre><code><span>func</span> <span>main</span><span>()</span> <span>{</span>
	<span>obj</span> <span>:=</span> <span>helloworld</span><span>.</span><span>HelloWorld</span><span>{</span>
		<span>Name</span><span>:</span> <span>&#34;myname&#34;</span><span>,</span>
	<span>}</span>

	<span>fields</span> <span>:=</span> <span>obj</span><span>.</span><span>ProtoReflect</span><span>()</span><span>.</span><span>Descriptor</span><span>()</span><span>.</span><span>Fields</span><span>()</span>
	<span>for</span> <span>i</span> <span>:=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>fields</span><span>.</span><span>Len</span><span>();</span> <span>i</span><span>++</span> <span>{</span>
		<span>field</span> <span>:=</span> <span>fields</span><span>.</span><span>Get</span><span>(</span><span>i</span><span>)</span>
		<span>value</span> <span>:=</span> <span>obj</span><span>.</span><span>ProtoReflect</span><span>()</span><span>.</span><span>Get</span><span>(</span><span>field</span><span>)</span><span>.</span><span>String</span><span>()</span>
		<span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;Field %d has value &#39;%v&#39;</span><span>\n</span><span>&#34;</span><span>,</span> <span>i</span><span>,</span> <span>value</span><span>)</span>
	<span>}</span>
<span>}</span>
</code></pre></div></div><div><div><pre><code><span>$ </span>go run main.go
Field 0 has value <span>&#39;myname&#39;</span>
</code></pre></div></div><p>How can the generated golang code know the field names and types at runtime like this? The protoc compiler stores a whole copy of the protobuf definition in the generated output code. <a href="https://gist.github.com/arkadiyt/c0853bcfdd966d06f574664ce33689d3" target="_blank" rel=" noopener external">Here</a> is the complete protoc output for our HelloWorld message type, and in particular, <a href="https://gist.github.com/arkadiyt/c0853bcfdd966d06f574664ce33689d3#file-helloworld-go-L72-L78" target="_blank" rel=" noopener external">lines 72-78</a> store this protobuf definition:</p><div><div><pre><code><span>var</span> <span>file_test_proto_rawDesc</span> <span>=</span> <span>[]</span><span>byte</span><span>{</span>
	<span>0x0a</span><span>,</span> <span>0x0a</span><span>,</span> <span>0x74</span><span>,</span> <span>0x65</span><span>,</span> <span>0x73</span><span>,</span> <span>0x74</span><span>,</span> <span>0x2e</span><span>,</span> <span>0x70</span><span>,</span> <span>0x72</span><span>,</span> <span>0x6f</span><span>,</span> <span>0x74</span><span>,</span> <span>0x6f</span><span>,</span> <span>0x22</span><span>,</span> <span>0x20</span><span>,</span> <span>0x0a</span><span>,</span> <span>0x0a</span><span>,</span>
	<span>0x48</span><span>,</span> <span>0x65</span><span>,</span> <span>0x6c</span><span>,</span> <span>0x6c</span><span>,</span> <span>0x6f</span><span>,</span> <span>0x57</span><span>,</span> <span>0x6f</span><span>,</span> <span>0x72</span><span>,</span> <span>0x6c</span><span>,</span> <span>0x64</span><span>,</span> <span>0x12</span><span>,</span> <span>0x12</span><span>,</span> <span>0x0a</span><span>,</span> <span>0x04</span><span>,</span> <span>0x6e</span><span>,</span> <span>0x61</span><span>,</span>
	<span>0x6d</span><span>,</span> <span>0x65</span><span>,</span> <span>0x18</span><span>,</span> <span>0x01</span><span>,</span> <span>0x20</span><span>,</span> <span>0x01</span><span>,</span> <span>0x28</span><span>,</span> <span>0x09</span><span>,</span> <span>0x52</span><span>,</span> <span>0x04</span><span>,</span> <span>0x6e</span><span>,</span> <span>0x61</span><span>,</span> <span>0x6d</span><span>,</span> <span>0x65</span><span>,</span> <span>0x42</span><span>,</span> <span>0x0f</span><span>,</span>
	<span>0x5a</span><span>,</span> <span>0x0d</span><span>,</span> <span>0x2e</span><span>,</span> <span>0x2f</span><span>,</span> <span>0x3b</span><span>,</span> <span>0x68</span><span>,</span> <span>0x65</span><span>,</span> <span>0x6c</span><span>,</span> <span>0x6c</span><span>,</span> <span>0x6f</span><span>,</span> <span>0x77</span><span>,</span> <span>0x6f</span><span>,</span> <span>0x72</span><span>,</span> <span>0x6c</span><span>,</span> <span>0x64</span><span>,</span> <span>0x62</span><span>,</span>
	<span>0x06</span><span>,</span> <span>0x70</span><span>,</span> <span>0x72</span><span>,</span> <span>0x6f</span><span>,</span> <span>0x74</span><span>,</span> <span>0x6f</span><span>,</span> <span>0x33</span><span>,</span>
<span>}</span>
</code></pre></div></div><p>This byte array stores the field names and types, messages, services, enums, options, and so on. It’s a little meta because the format of this object is <em>itself</em> a protobuf object, called a <a href="https://github.com/protocolbuffers/protobuf/blob/7a51eb5370905dec1943c5f1f6b4381fecb04116/src/google/protobuf/descriptor.proto#L92-L127" target="_blank" rel=" noopener external">FileDescriptor</a>, and is encoded into a byte array using the protobuf wire format.</p><p>With this knowledge in hand, the strategy for extracting protobuf definitions from binaries becomes the following:</p><ul><li>Iterate over the contents of a program binary</li><li>Find sequences of bytes that look like they might be FileDescriptors, such as the example above</li><li>Extract these bytes and decode them into “.proto” source definitions</li></ul><h3 id="finding-bytes-that-look-like-filedescriptors">Finding bytes that look like FileDescriptors</h3><p>To find FileDescriptors I take the naive approach of simply searching the program binary for the ascii string “.proto”. The FileDescriptor object has a field for the <a href="https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/descriptor.proto#L94" target="_blank" rel=" noopener external">file name</a> of the proto file it was compiled from, so if engineers are naming their files with a “.proto” extension then it’ll be present in the output.</p><p>We can imagine a program binary as a sequence of bytes laid out as follows:</p><p><img src="https://arkadiyt.com/images/protodump/program_memory.png" alt="Program memory"/></p><p>So when we find a “.proto” string, to capture the entire FileDescriptor (the entire purple segment) we need to first move backward to the start of the object and then read until the end.</p><p>To determine how far back to read, it’s helpful to understand the protobuf <a href="https://protobuf.dev/programming-guides/encoding/" target="_blank" rel=" noopener external">wire format</a>. Protobuf makes heavy use of variable-length integers (“varints”), which allow encoding unsigned 64-bit integers using anywhere between 1-10 bytes (in little-endian), with smaller integers using fewer bytes. When such a varint is encountered, if the most significant bit of a byte is set then this indicates that the following byte is also part of the varint:</p><div><div><pre><code># Value is 8:
  00001000
# ^ MSB is not set, end of varint

# Value is 150:
  10010110 00000001
# ^ MSB is set, varint continues to next byte
#          ^ MSB is not set, end of varint
# How to calculate 150:
# 10010110 00000001       // Original inputs
# 0010110  0000001        // Drop continuation bits
# 0000001  0010110        // Convert to big-endian
# 00000010010110          // Concatenate
# 128 + 16 + 4 + 2 = 150  // Interpret as an unsigned 64-bit integer
</code></pre></div></div><p>Protobuf Messages are encoded using a “Tag-Length-Value” scheme, where a message with some fields is encoded as the following structure, repeated:</p><ul><li>A varint for the index and type of the field (the “tag”)<ul><li>This is defined as the field number of a field within a message, bit-shifted left 3 times and OR-ed with the type. Protobuf defines <a href="https://protobuf.dev/programming-guides/encoding/#structure" target="_blank" rel=" noopener external">6 types</a>, with string types having value 2</li></ul></li><li>A varint for the byte-length of the payload</li><li>The payload itself</li></ul><p>and this gets repeated for every field in the message. Using the byte array from the HelloWorld example above, we have the following structure:</p><p><img src="https://arkadiyt.com/images/protodump/file_descriptor.png" alt="Annotated file descriptor"/></p><p>So the search strategy is:</p><ul><li>Loop over program memory looking for the ascii string “.proto”. When we find one:<ul><li>Assume that this is the start of an encoded file descriptor object. Move back to the previous <code>0x0a</code> byte (the tag for the file name field)</li><li>If the file name is exactly 10 bytes long, move back 1 byte further (otherwise the <code>0x0a</code> byte we found is actually the string length and not the tag)</li><li>Now that we’re at the beginning of the FileDescriptor object, keep consuming bytes so long as they are a valid protobuf wire encoding</li><li>Take all the bytes we’ve consumed and attempt to unmarshal them into a FileDescriptor object<ul><li>If successful, convert the FileDescriptor object to a source “.proto” file and output it</li></ul></li></ul></li></ul><p>To convert the FileDescriptor object to a source “.proto” file, I couldn’t find any existing code in the protoc compiler to do that so I wrote <a href="https://github.com/arkadiyt/protodump/blob/main/pkg/protodump/proto.go" target="_blank" rel=" noopener external">my own implementation</a>.</p><p>Finally, for unit testing, I wrote a small harness that takes proto files as input, executes the protoc compiler on them, takes that FileDescriptor output and reserializes it as proto, and checks that the input proto and output proto are byte-for-byte identical.</p><h3 id="shortcomings">Shortcomings</h3><p>There are a number of limitations to this approach. First and foremost, everything written above is specific to Google’s protoc compiler; it does not apply to the more general protobuf specification. If someone uses a non-protoc compiler, it may have a completely different mechanism for implementing reflection.</p><p>Even when using protoc:</p><ul><li>People can name their files with an extension other than “.proto”</li><li>They can obfuscate the file descriptor in program memory</li><li>Protobuf <a href="https://protobuf.dev/programming-guides/encoding/#order" target="_blank" rel=" noopener external">explicitly does not guarantee</a> field ordering on the wire format, so moving the file name field to a different location other than the start of the FileDescriptor would break the scanning</li></ul><p>Additionally many protobuf compilers offer the option to suppress this embedding completely (at the cost of losing runtime reflection capabilities).</p><p>Despite all these shortcomings, I’ve found that the 99% of binaries I examine use protoc and don’t have any obfuscation, and all their protobuf definitions are extracted in full.</p><p>P.S. If you enjoy this kind of content feel free to follow me on Twitter: <a href="https://twitter.com/arkadiyt" target="_blank" rel=" noopener external">@arkadiyt</a></p></div></div></div>
  </body>
</html>
