<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://marioslab.io/posts/rendering-like-its-1996/dos-nostalgia/">Original</a>
    <h1>Rendering like it&#39;s 1996 – Bitmap fonts and DOS</h1>
    
    <div id="readability-page-1" class="page"><div>



<div>




<p><img src="https://marioslab.io/posts/rendering-like-its-1996/dos-nostalgia/dos-nostalgia.png"/>
	<span>This screen has burned itself into my retina.</span>
</p>




<blockquote>
<p>To follow along this blog post with running code, make sure you&#39;ve installed the <a href="https://github.com/badlogic/r96/tree/04-dos-nostalgia#installing-required-tools">prerequisites</a>. Then:</p>
</blockquote>
<pre><code>git clone https://github.com/badlogic/r96
cd r96
git checkout 04-dos-nostalgia
./tools/download-tools.sh
code .
</code></pre>
<p><a href="https://marioslab.io/posts/rendering-like-its-1996/blistering-fast-blits/">Last time</a> we learned about loading images and blitting. That was over 3 weeks ago, making me miss my target of posting one series entry a week. But there&#39;s a reason for it! I was rather busy in those two weeks.</p>
<p>After using Hopper to generate control flow graphs to discuss performance optimization, I got a little sick of the workflow and built my own <a href="https://marioslab.io/projects/cfg/">assembly CFG viewer</a>. Just paste some x86 or ARM assembly generated by MSVC, Clang, or GCC into the left panel, and view the control flow graph of each function on the right. I also made it a <a href="https://www.npmjs.com/package/@marioslab/asmcfg">re-usable NPM package</a>. Going forward, I can embed those fancy CFGs directly.</p>
<p>Then I drifted off into yet another rabbit hole. Spurred by a mean comment on Reddit about how the <code>r96</code> code doesn&#39;t even run in DOS, I made the code of the series run in DOS.</p>
<p>First, I built a <a href="https://github.com/emoon/MiniFB/pull/98">DOS backend for MiniFB</a>. Then, I <a href="https://github.com/badlogic/gdb-7.1a-djgpp/releases/tag/gdb-7.1a-djgpp">forked an old GDB version</a> which is capable of remotely debugging 32-bit protected mode DOS programs as produced by <a href="https://www.delorie.com/djgpp/">DJGPP</a>, the GCC fork I use to build C/C++ DOS programs. I also forked <a href="https://github.com/badlogic/dosbox-x/">DOSBox-x</a> to fix it up so my forked GDB can actually connect to DOS programs via the serial port/TCP emulation.</p>
<p>Finally, I took the barely functional <a href="https://sourceware.org/gdb/onlinedocs/gdb/Remote-Stub.html">GDB stub</a> that comes with DJGPP, rewrote it and added a ton of functionality to it, so I can now debug DOS programs running in DOSBox-x from the comforts of Visual Studio Code.</p>
<p>All of that work culminated in a <a href="https://marketplace.visualstudio.com/items?itemName=badlogicgames.dos-dev">VS Code extension</a>, which lets you go from 0 to debugging a simple DOS mode 13h demo app in VS code in about 80 seconds:</p>
<p><img src="https://marioslab.io/posts/rendering-like-its-1996/dos-nostalgia/vsc-extension.gif"/></p>
<p>With all of that out of my system, I built some shell scripts that will help you install (almost) all the tools to compile, run, and debug the <code>r96</code> project for desktop, web, and DOS. And I added some VS Code magic so you can comfortably start debugging sessions on each platform.</p>
<p>And to round it all off, I cleaned up the Git repo, so each blog post maps to exactly one commit. And I rewrote the first 3 blog posts in the series. So yeah.</p>
<p>I can now happily continue writing the series. Promise. Unless I&#39;ll add Android and iOS support in the future. I currently don&#39;t feel that specific masochism piling up inside of me.</p>
<p>Today, we&#39;re looking at DOS support, and then load and draw some bitmap fonts.</p>
<h2>Demo: Hello DOS</h2>
<p>Alright, go get the latest and greatest from the <code>r96</code> repository. Follow the <a href="https://github.com/badlogic/r96/blob/04-dos-nostalgia/README.md">README.md</a> to install the tools, including the new DOS tools. The README.md will also get you up to speed on how to build and debug everything in VS Code or on the command line. Or, if you want a detailed run-down of the project and its build and IDE support, read the <a href="https://marioslab.io/posts/rendering-like-its-1996/babys-first-pixel/">first entry of the series</a>.</p>
<p>To celebrate DOS support, I&#39;ve added a new demo called <a href="https://github.com/badlogic/r96/blob/04-dos-nostalgia/src/12_hello_dos.c"><code>12_hello_dos.c</code></a>:</p>


<div>
	<pre><code>#include &lt;MiniFB.h&gt;
#include &lt;stdio.h&gt;
#include &#34;r96/r96.h&#34;
#include &#34;stdlib.h&#34;
#include &lt;math.h&gt;

#define GDB_IMPLEMENTATION
#include &#34;dos/gdbstub.h&#34;

#define num_grunts 100

typedef struct grunt {
	int x, y, vx, vy;
} grunt;

int main(void) {
	gdb_start();
	r96_image image;
	if (!r96_image_init_from_file(&amp;image, &#34;assets/grunt.png&#34;)) {
		printf(&#34;Couldn&#39;t load file &#39;assets/grunt.png&#39;\n&#34;);
		return -1;
	}

	r96_image output;
	r96_image_init(&amp;output, 320, 240);
	struct mfb_window *window = mfb_open(&#34;12_hello_dos&#34;, output.width, output.height);

	grunt grunts[num_grunts];
	for (int i = 0; i &lt; num_grunts; i++) {
		grunt *grunt = &amp;grunts[i];
		grunt-&gt;x = rand() % 320;
		grunt-&gt;y = rand() % 200;
		grunt-&gt;vx = 1;
		grunt-&gt;vy = 1;
	}
	do {
		r96_clear_with_color(&amp;output, 0xff222222);
		for (int i = 0; i &lt; num_grunts; i++) {
			grunt *grunt = &amp;grunts[i];
			if (grunt-&gt;x &lt; 0) {
				grunt-&gt;x = 0;
				grunt-&gt;vx = -grunt-&gt;vx;
			}
			if (grunt-&gt;x &gt; 320 - 64) {
				grunt-&gt;x = 320 - 64;
				grunt-&gt;vx = -grunt-&gt;vx;
			}
			if (grunt-&gt;y &lt; 0) {
				grunt-&gt;y = 0;
				grunt-&gt;vy = -grunt-&gt;vy;
			}
			if (grunt-&gt;y &gt; 240 - 64) {
				grunt-&gt;y = 240 - 64;
				grunt-&gt;vy = -grunt-&gt;vy;
			}
			grunt-&gt;x += grunt-&gt;vx;
			grunt-&gt;y += grunt-&gt;vy;
			r96_blit_keyed(&amp;output, &amp;image, grunt-&gt;x, grunt-&gt;y, 0x00000000);
		}
		if (mfb_update_ex(window, output.pixels, output.width, output.height) != STATE_OK) break;
		gdb_checkpoint();
	} while (mfb_wait_sync(window));

	r96_image_dispose(&amp;image);
	r96_image_dispose(&amp;output);
	return 0;
}</code></pre>
</div>

<p>This is our first animated demo!</p>
<p>The demo draws 100 moving grunts, that bounce off of the screen boundaries. Each grunt is stored in a simple <code>grunt</code> struct, which in turn stores the grunt&#39;s position (<code>x</code>, <code>y</code>) and velocity on the x- and y-axis (<code>vx</code>, <code>vy</code>) in pixels per frame. During initialization, we give each grunt a random position within the screen boundaries and set its velocity on each axis to <code>1</code> (lines 29-35).</p>
<p>What&#39;s a frame you may ask? A frame can be many things, but in our case, a frame is simply one iteration of the main loop of your program (lines 36-62). In each frame, we check whether each grunt is still inside the screen boundaries. If a grunt is outside the screen boundaries on the x- or y-axis (or both), we move them back inside the bounds and negate their velocity on the axis they left the screen on.</p>
<p>E.g. a grunt moving to the right (<code>vx = 1</code>), leaving the screen on the x-axis (<code>x &gt; 320 - 64</code>), will be moved back inside the screen boundaries (<code>x = 320 - 64</code>), and its velocity on the x-axis will become <code>-1</code>. Starting in the next frame, the grunt will then move to the left, until it exits the screen boundaries on the left side of the screen. The same happens on the y-axis.</p>
<p>Once all the checks are complete, we add the grunt&#39;s velocity to its position. Each frame, the grunt&#39;s position thus changes by <code>vx</code> pixels on the x-axis, and <code>vy</code> pixels on the y-axis. Hence why <code>vx</code> and <code>vy</code> are given as pixels per frame.</p>
<blockquote>
<p><strong>Note:</strong> This is a very basic form of <a href="https://gafferongames.com/post/integration_basics/">explicit Euler integration</a>. It&#39;s much less scary than it sounds! Go learn your fundamentals.</p>
</blockquote>
<p>Now, there&#39;s one big problem with this type of moving objects: it depends on the speed of execution.</p>
<p>We call <code>mfb_wait_sync()</code>, which waits for a vertical refresh, effectively limiting the number of frames per second to the screen refresh rate, so 60Hz, 90Hz, 120Hz, or whatever other wonky screen refresh rate the display has.</p>
<p>On a 60Hz screen a grunt will thus move 60 pixels per second, on a 120Hz it will move 120 pixels.</p>
<p>For a game, that&#39;s not great: different players will experience the game at different speeds, depending on their hardware. We&#39;ll look into this issue in a future series entry.</p>
<blockquote>
<p><strong>Note:</strong> Many old DOS games actually did have this problem: they would not take into account how much time has passed since the last frame, but instead update game object positions at a fixed rate each frame. There&#39;s a reason Wikipedia has an entry on the notorious <a href="https://en.wikipedia.org/wiki/Turbo_button">PC turbo button</a>.</p>
</blockquote>
<p>Here&#39;s the little demo on the web:</p>






<p>And here it is running in DOSBox-x, telling DOSBox-x to go full speed.</p>

<video src="grunts-dosbox.mp4" autoplay="true" loop="true" controls="true"></video>
<p>DOSBox-x on my system syncs to 60Hz in windowed mode, while Chrome runs the web demo at the full 120Hz of my display. In the video above, there is some smearing and artifacts. That&#39;s mostly due to the MP4 encoding and doesn&#39;t look like that when actually running the demo in DOSBox-x on your system.</p>
<p>Is the DOSBox-x performance indicative of performance on old systems? No. DOSBox-x is going full speed, which is way faster than what my old 486 could do. However, you can modify the emulation speed via the DOSBox-x menu <code>CPU &gt; Emulated CPU speed</code>. In the following video, I&#39;ve set the emulated CPU speed to be equivalent to a 486DX2 with 66Mhz:</p>

<video src="grunts-dosbox-486.mp4" autoplay="true" loop="true" controls="true"></video>
<p>While that&#39;s more accurate, it&#39;s still not quite the same as real hardware. To get a more accurate sense of how the program would perform on a real 486, we can use <a href="https://86box.net/">86Box</a>. 86Box is as cycle accurate emulator for various old x86 systems.</p>

<video src="86box.mp4" autoplay="true" loop="true" controls="true"></video>
<p>Looks like DOSBox-x isn&#39;t far off with its emulation. So why is it so slow?</p>
<blockquote>
<p><strong>Note:</strong> Setting up virtual machine images for 86Box is a bit terrible. I&#39;ve created 2 images you can download, a <a href="https://marioslab.io/dump/dos/86box/486.zip">486</a> image and a <a href="https://marioslab.io/dump/dos/86box/pentium.zip">Pentium</a> image, pre-installed with MS-DOS 6.22, a mouse driver, and a CD-ROM driver. You can run them via <code>86box -c 486/86box.conf</code> and <code>86box -c pentium/86box.conf</code>. The images also include QBasic 1.1. And <a href="https://en.wikipedia.org/wiki/Nibbles_(video_game)"><code>NIBBLES.BAS</code></a> and <a href="https://en.wikipedia.org/wiki/Gorillas_(video_game)"><code>GORILLA.BAS</code></a>. Just saying.</p>
</blockquote>
<h3>Why is it so slow on a 486?</h3>
<p>The MiniFB DOS backend sets up a video mode with either 24-bit or 32-bit color depth through <a href="https://en.wikipedia.org/wiki/VESA_BIOS_Extensions">VESA</a>. MiniFB assumes 32-bit color depth, so we have to abide by that and go VESA.</p>
<p>This works pretty well from Pentium class machines onwards, if the (emulated) video card supports VESA. Here&#39;s the demo on Pentium class hardware in 86Box:</p>

<video src="86box-pentium.mp4" autoplay="true" loop="true" controls="true"></video>
<p>A 486 may support 24-bit and 32-bit color depth video modes, depending on the graphics card. Mine did. However, that doesn&#39;t mean the system is fast enough to actually deal with that amount of data. A run of the mill 486 would have memory throughput somewhere in the range of 10-25MB/s. You read that right.</p>
<p>In our demo above, we render to a 320x240 output <code>r96_image</code>. The call to <code>r96_clear_with_color()</code> has to touch <code>0.3MB</code> worth of pixels. Rendering a single grunt means reading 64x64x4 bytes from the grunt image and writing them to a 64x64x4 bytes big region in the output <code>r96_image</code>. For 100 grunts, that&#39;s reading <code>1.6MB</code> and writing <code>1.6MB</code>. Finally, the output <code>r96_image</code> is transferred to the VESA linear buffer, a memory mapped region from which the graphics card will read what it should output to the display. That&#39;s another 320x240x4 bytes, or <code>0.3MB</code>. Each frame we thus touch <code>0.3 + 1.6 + 1.6 + 0.3 = 3.8MB</code> of memory. And while this simple analysis doesn&#39;t account for memory caches, it does align with what we experience when running the demo on a (emulated) 486. We do indeed only get something like 3-5 frames per second, which is <code>11.4-19MB</code> of data pushed by the demo per second.</p>
<p>That&#39;s one of the reasons pretty much all older DOS games targeting 386 or 486 would use <a href="https://en.wikipedia.org/wiki/Mode_13h">mode 13h</a> or derivatives like <a href="https://en.wikipedia.org/wiki/Mode_X">Mode X</a>. Both of these video modes use 8 bits to encode a pixel&#39;s color. But instead of directly encoding the color&#39;s red, green and blue component, the 8-bit value is an index into a palette with a total of 256 colors. That cuts down on memory and bandwidth needs considerably.</p>
<p>If we went mode 13h in our demo, we&#39;d go from <code>3.8MB</code> to <code>0.95MB</code> of data per frame. That translates to 12-20 frames per second, which is still not great, but often playable enough. That&#39;s about the frame rate I got when playing <a href="https://www.youtube.com/watch?v=qATaCWHLAxw">MicroProse&#39;s Formula One Grand Prix</a> on my 486.</p>
<p>So what&#39;s the solution? Draw less each frame! DOOM and Quake relied on various techniques like <a href="https://twobithistory.org/2019/11/06/doom-bsp.html">binary space partitioning</a> to avoid drawing things that are invisible or occluded. Drawing less means touching less memory. Consider that 100 grunts are about 5.3 screens worth of pixels. That&#39;s a lot of overdraw.</p>
<p>Yes, we could probably squeeze a lot of cycles out of the blitting functions if we handcrafted some 32-bit x86 assembly. But DJGPP actually does a pretty good job at producing fast machine code. And I don&#39;t want to drop down into assembly land.</p>
<blockquote>
<p><strong>Note:</strong> modern hardware won&#39;t save you from these issues either sometimes. When NVIDIA sent me a prototype Tegra board in the early 2010s, I soon found out that you could only render about 2 full-screen alpha blended rectangles through OpenGL ES before the frame-rate takes a heavy hit.</p>
</blockquote>
<h3>Excursion: DOS debugging support</h3>
<p>When we debug the demo on the desktop, the debugger will spawn the demo process and use system APIs to stop, resume, inspect, and otherwise manipulate the process.</p>
<p>For DOS applications running in DOSBox-x or on a real machine, we do not have the luxury of a debugger. Instead, we use a piece of code called <a href="https://sourceware.org/gdb/onlinedocs/gdb/Remote-Stub.html">GDB stub</a> that we integrate in our program. Here&#39;s how that works in <code>12_hello_dos.c</code>.</p>
<p>Of note are 3 pieces of code in the demo above, which do nothing on any platform other than DOS. In lines 7-8 we have:</p>
<pre><code>#define GDB_IMPLEMENTATION
#include &#34;dos/gdbstub.h&#34;
</code></pre>
<p>This pulls in <a href="https://github.com/badlogic/r96/blob/main/src/dos/gdbstub.h">my GDB stub implementation for DJGPP/DOS</a>, which is a single header file library.</p>
<p>The stub&#39;s task is it to communicate with the debugger over the serial port, and tell it when the program has stopped due to a breakpoint, or segfault, or other reason. The stub then waits for commands from the debugger to execute, like setting breakpoints, inspecting memory and CPU registers, stepping, continuing, etc.</p>
<p>This GDB stub type of debugging is a cooperative debugging approach. The stub needs to be integrated with the program itself. This explains the other two GDB related lines of code in the demo.</p>
<p>The <code>gdb_start()</code> function is called at the beginning of <code>main()</code>. It waits for the debugger to connect on the serial port. When the debugger tells the stub to continue execution of the program, the stub stops communicating with the debugger for the time being, and gives back control to the program.</p>
<p>The stub then waits for a system level signal to be raised, like a breakpoint or segfault, for which the stub has registered handlers. If such a signal happens, the stub takes over control from the program again, tells the debugger about the program being stopped, and waits for debugger commands to execute.</p>
<p>The final GDB related line is <code>gdb_checkpoint()</code> in line 61. It is placed at the end of our main loop. This is required so the stub can check if the debugger asked to interrupt the program, in which case the stub will take control of the program again and talk to the debugger.</p>
<p>The GDB stub expects all communication to happen through serial port <code>COM1</code>. Some emulators and virtual machines, like DOSBox-x or VirtualBox, can expose the emulated serial port as a TCP port to programs on the host OS. That&#39;s what&#39;s happening when we debug a demo in DOSBox-x. DOSBox-x exposes the serial port on TCP port 5123, to which GDB connects via TCP. DOSBox-x will then translate TCP packages to writes to the serial port, which the GDB stub reads from <code>COM1</code>. If the GDB stub writes to <code>COM1</code>, then DOSBox-x will forward the data through TCP to GDB.</p>
<p>In theory, the GDB stub should also work on real-hardware. Sadly, I do not have my 486 anymore, nor a serial cable or a serial port on my MacBook.</p>
<p>If you want to debug any of the demos in DOS, you&#39;ll have to add the 3 pieces of GDB stub related code to the demo&#39;s sources as outlined above. Only the <code>12_hello_dos.c</code> demo is currently set-up for DOS debugging. Since our code is cross-platform, there won&#39;t be a need to debug in DOS a lot though.</p>
<blockquote>
<p><strong>Note:</strong> when debugging the demos compiled for DOS, we&#39;ll be using DOSBox-x instead of 86Box. Two reasons: getting data into and out of 86Box is very annoying. And there is no serial port over TCP emulation in 86Box, so the debugger couldn&#39;t even connect. It should be possible to hook the debugger up with a program running in MS-DOS or FreeDOS in VirtualBox though.</p>
</blockquote>
<h2>Bitmap fonts</h2>
<p>Rendering text these days is really, really hard. When we go zooming around documents or web pages via mouse wheel or touch zoom, we expect text to scale seamlessly and stay crisp. If we want to get fancy, we add <a href="https://en.wikipedia.org/wiki/Kerning">kerning</a> and <a href="https://en.wikipedia.org/wiki/Font_hinting">hinting</a> to the mix.</p>
<p>It gets even harder when non-latin scripts like <a href="https://en.wikipedia.org/wiki/Arabic_script">arabic script</a> or <a href="https://en.wikipedia.org/wiki/CJK_characters">CJK script</a> need to get put on a screen. Now you have to deal with (more) <a href="https://fonts.google.com/knowledge/glossary/ligature">ligatures</a>, mixed left-to-right and <a href="https://en.wikipedia.org/wiki/Right-to-left_script">right-to-left layouting</a>, and various other complexities.</p>
<p>And to top it all off, what you get out of a font file is usually a vector representation of not a character, but a <a href="https://en.wikipedia.org/wiki/Glyph">glyph</a>, which can be a character, or a part of a character, and oh my, this is all very complicated.</p>
<p>Thankfully, there are various libraries that can help us draw text. For translating a text string to a set of glyphs, or <a href="https://harfbuzz.github.io/what-is-harfbuzz.html#what-is-text-shaping">shaping</a> as it&#39;s usually called, you can use <a href="https://harfbuzz.github.io/">HarfBuzz</a>. If you want to rasterize those glyphs, which are usually given in vector form, you can use <a href="http://freetype.org/">FreeType</a>. If you  want to use your GPU to do most of that, you can use <a href="https://sluglibrary.com/">Slug</a>. Your operating system usually also comes with <a href="https://learn.microsoft.com/en-us/windows/win32/directwrite/direct-write-portal">APIs to draw text</a>.</p>
<p>We aren&#39;t going to do any of that though. We&#39;ll be going somewhat old school and draw inspiration from <a href="https://en.wikipedia.org/wiki/VGA_text_mode#Fonts">VGA text mode fonts</a>, but with a 2022 spirit (aka being wasteful).</p>
<p>Before we can look at font pixels, we need to talk about how text is stored in the tubes of our computerers.</p>
<h3>Character encodings</h3>
<p>Text is composed of characters. When we store text digitally, those characters need to be stored as a sequence of (binary) numbers. When we read characters from a file to draw them to the screen, or translate key strokes to characters, we need to map numbers back to characters. Similarly, when the C compiler encounters a string literal like <code>const char *text = &#34;Hello world&#34;</code>, it will convert the characters in the string to a sequence of numbers that gets embedded in the final executable.</p>
<p>Mapping those sequences of numbers to characters and vice versa is what <a href="https://en.wikipedia.org/wiki/Character_encoding">character encodings</a> are for.</p>
<p>One of the oldest character encodings is <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a>. Each character is encoded in 1 byte. Well, actually, ASCII only uses the first 7-bits, so it encodes a total of 128 characters. Well, that&#39;s not quite true either. Only 95 of these characters are printable. The other 33 &#34;characters&#34; are what&#39;s called <a href="https://en.wikipedia.org/wiki/Control_character">control codes</a>. Notable ones are <code>\t</code> or <code>9</code>, which indicates a tab, and <code>\n</code> or <code>10</code>, the line feed. See, it&#39;s already complicated!</p>
<p>Here are all the printable characters and non-printable control codes contained in ASCII with their (hexa-)decimal codes.</p>


<div>
	<pre><code>&gt; ascii -d
Dec Hex    Dec Hex    Dec Hex  Dec Hex  Dec Hex  Dec Hex   Dec Hex   Dec Hex
  0 00 NUL  16 10 DLE  32 20    48 30 0  64 40 @  80 50 P   96 60 \`  112 70 p
  1 01 SOH  17 11 DC1  33 21 !  49 31 1  65 41 A  81 51 Q   97 61 a  113 71 q
  2 02 STX  18 12 DC2  34 22 &#34;  50 32 2  66 42 B  82 52 R   98 62 b  114 72 r
  3 03 ETX  19 13 DC3  35 23 #  51 33 3  67 43 C  83 53 S   99 63 c  115 73 s
  4 04 EOT  20 14 DC4  36 24 $  52 34 4  68 44 D  84 54 T  100 64 d  116 74 t
  5 05 ENQ  21 15 NAK  37 25 %  53 35 5  69 45 E  85 55 U  101 65 e  117 75 u
  6 06 ACK  22 16 SYN  38 26 &amp;  54 36 6  70 46 F  86 56 V  102 66 f  118 76 v
  7 07 BEL  23 17 ETB  39 27 &#39;  55 37 7  71 47 G  87 57 W  103 67 g  119 77 w
  8 08 BS   24 18 CAN  40 28 (  56 38 8  72 48 H  88 58 X  104 68 h  120 78 x
  9 09 HT   25 19 EM   41 29 )  57 39 9  73 49 I  89 59 Y  105 69 i  121 79 y
 10 0A LF   26 1A SUB  42 2A *  58 3A :  74 4A J  90 5A Z  106 6A j  122 7A z
 11 0B VT   27 1B ESC  43 2B +  59 3B ;  75 4B K  91 5B [  107 6B k  123 7B {
 12 0C FF   28 1C FS   44 2C ,  60 3C &lt;  76 4C L  92 5C \  108 6C l  124 7C |
 13 0D CR   29 1D GS   45 2D -  61 3D =  77 4D M  93 5D ]  109 6D m  125 7D }
 14 0E SO   30 1E RS   46 2E .  62 3E &gt;  78 4E N  94 5E ^  110 6E n  126 7E ~
 15 0F SI   31 1F US   47 2F /  63 3F ?  79 4F O  95 5F _  111 6F o  127 7F DEL</code></pre>
</div>

<p>The codes <code>0-31</code> are control codes, including the <code>\t</code> (<code>9</code>) and <code>\n</code> (<code>10</code>) codes we discussed above. Printable characters start at code 32 (<code> </code> or space) and go to code <code>126</code>. The final code <code>127</code> is another control code.</p>
<p>ASCII is short for &#34;American Standard Code for Information Interchange&#34;. Unsurprisingly, the ASCII encoding really only contains characters used in US English, and by coincidence, some other western scripts.</p>
<p>Now, I&#39;m not &#39;merican. And based on my server logs, chances are good you aren&#39;t &#39;merican either. What about other fancy characters, like &#39;ö&#39; or &#39;ê&#39;? Or characters from the arabic or CJK scripts? Well, that&#39;s a lot more complicated and historically involves something called <a href="https://en.wikipedia.org/wiki/Code_page">code pages</a>, which was and still is an utter mess.</p>
<p>The alternative to code pages is <a href="https://en.wikipedia.org/wiki/Unicode">Unicode</a>. Unicode defines codes (or code points in Unicode parlance) for almost 150,000 characters used in scripts from all around the world, including historic ones. It also includes emojis, for better or worse. Your parents&#39; brains have probably also switched to emoji only instant messaging communication. And they said computers would make us kids dumb. Thanks, Unicode.</p>
<p>Unicode has multiple encodings, like <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a>, <a href="https://en.wikipedia.org/wiki/UTF-16">UTF-16</a>, and so on. Thankfully, the world has now mostly standardized on UTF-8, for <a href="http://utf8everywhere.org/">good reasons</a>. UTF-8 is a multi-byte encoding. Depending on the character, we may need 1 to 4 bytes to store it.</p>
<p>For our demos, we&#39;ll store text either in C source code as literals ala <code>const char *text = &#34;Hello world&#34;</code>, or in text files in the <code>assets/</code> folder of the <code>r96</code> project. Both the C sources and text files will be encoded using <code>UTF-8</code>. Anything else would be pain. This means we have to deal with UTF-8 when rendering text.</p>
<p>But as I said earlier, we do not want to go full Unicode text rendering, as that&#39;d require us to integrate all the fancy libraries mentioned above. We want a simpler solution. Enter Unicode&#39;s first 256 code points. These code points are split up into 2 blocks.</p>
<p>The first block from code point <code>0-127</code> is called the <a href="https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)">Basic Latin Unicode block</a>. The code points are the exact same codes as used in ASCII, including both non-printable control codes (<code>0-31</code> and <code>127</code>) and printable characters (<code>32-126</code>). When encoding text with UTF-8, the resulting sequence of bytes is backwards compatible with ASCII: the first 128 Unicode code points get encoded as a single byte in UTF-8.</p>
<p>The second block from code point <code>128-255</code> is called the <a href="https://en.wikipedia.org/wiki/Latin-1_Supplement">Latin 1 Supplement block</a>. It contains another set of non-printable control codes (<code>128-159</code>) called <a href="https://en.wikipedia.org/wiki/C0_and_C1_control_codes#C1_controls">C1 controls</a>, which we can safely ignore for the purpose of rendering text. The remaining code points in the block (<code>160-255</code>) include additional characters used in some western scripts. These Unicode code points are encoded with 2 bytes in UTF-8.</p>
<p>Surprise! Those first 256 Unicode code points map directly onto an old code page, namely, the  <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1">ISO-8859-1 character set</a>. It is sometimes incorrectly referred to as extended ASCII. Here are the characters contained in the set.</p>




<p>E.g. <code>ö</code> is encoded as <code>0xF6</code> or <code>246</code> in decimal. The gray blocks are the control codes.</p>
<p>Alright, we&#39;ve decided to use the first 2 Unicode blocks spanning code points <code>0-255</code>. All our C source code containing string literals will be stored UTF-8 encoded. And any text files we put into <code>assets/</code> to be read by our demos will also be UTF-8 encoded. There are two minor complications.</p>
<p>The first complication is how C compilers handle string literals. When the compiler encounters something like <code>const char *text = &#34;Hello world&#34;</code>, it will use a character encoding to turn the literal <code>&#34;Hello world&#34;</code> into a sequence of bytes embedded in the executable. Which encoding is chosen, depends on the compiler. By default, Clang and GCC convert the string literal to UTF-8 and embed the corresponding byte sequence. Clang even assumes that the source file encoding is UTF-8 and refuses to compile anything else. <a href="https://pspdfkit.com/blog/2021/string-literals-character-encodings-and-multiplatform-cpp/">MSVC is ... different</a>. Luckily, we do not care for MSVC in this series. If you do care for some reason, just make sure to pass <code>/utf8</code> as a compiler flag to ensure MSVC embeds string literals as UTF-8 as well.</p>
<p>The second complication is actually reading the code points of a UTF-8 encoded text string, whether it comes from a C string literal or a UTF-8 encoded file read from disk. We have to deal with the multi-byte nature of the UTF-8 encoding, as code points above <code>127</code> are encoded as two bytes. Luckily, I&#39;ve taken care of that with the function <a href="https://github.com/badlogic/r96/blob/04-dos-nostalgia/src/r96/r96.c#L15-L31"><code>r96_next_utf8_character()</code></a>:</p>


<div>
	<pre><code>uint32_t r96_next_utf8_code_point(const char *data, uint32_t *index, uint32_t end) {
	static const uint32_t utf8_offsets[6] = {
			0x00000000UL, 0x00003080UL, 0x000E2080UL,
			0x03C82080UL, 0xFA082080UL, 0x82082080UL};

	uint32_t character = 0;
	const unsigned char *bytes = (const unsigned char *) data;
	int num_bytes = 0;
	do {
		character &lt;&lt;= 6;
		character += bytes[(*index)++];
		num_bytes++;
	} while (*index != end &amp;&amp; ((bytes[*index]) &amp; 0xC0) == 0x80);
	character -= utf8_offsets[num_bytes - 1];

	return character;
}</code></pre>
</div>

<p>This function takes a sequence of bytes (<code>data</code>) encoding a UTF-8 string, an <code>index</code> into the byte sequence, and the last valid index (<code>end</code>). Both indices are byte offsets, not character offsets!</p>
<p>The function then reads the next UTF-8 character, which may be 1 to 4 bytes long, and returns its code point. Additionally, it increments the <code>index</code> accordingly, so we know at what byte offset the next character starts.</p>
<blockquote>
<p><strong>Note:</strong> I stole the original of this function many years ago from ... somewhere. I can not remember anymore. I&#39;ve since modified it to my needs. To the original author: I&#39;m deeply sorry I forgot who you are.</p>
</blockquote>
<p>We can use this function to iterate all UTF-8 characters in a byte sequence and get their code points:</p>


<div>
	<pre><code>const char *utf8_text = &#34;¡ÄÖ$\n\t&#34;;
uint32_t index = 0;
uint32_t end = strlen(utf8_text);
while (index != end) {
	uint32_t code_point = r96_next_utf8_code_point(utf8_text, &amp;index, end);
	printf(&#34;code point: %i/%x\n&#34;, code_point, code_point);
}</code></pre>
</div>

<p>Which prints the code point of each character in decimal and hexadecimal.</p>
<pre><code>code point: 161/a1
code point: 196/c4
code point: 214/d6
code point: 36/24
code point: 10/a
code point: 9/9
</code></pre>
<p>As expected. Compare the output to the ISO-8859-1 chart above for validation.</p>
<p>This function can deal with any valid UTF-8 byte sequence and returns code points as a 32-bit unsigned integer. For our purposes, we are only interested in code points <code>0-255</code> and will ignore any other code points.</p>
<h3>The glyph atlas</h3>
<p>Alright, we have all our encoding bases covered. The next question is: how do we turn a code point like <code>64</code> (<code>0x41</code>) into the corresponding glyph image for the character <code>A</code> from a font, so we can blit it onto the screen?</p>
<p>To make things easy for us, we&#39;ll define some limits:</p>
<ul>
<li>We&#39;ll only render the printable Unicode code points between <code>0-255</code> as described above.</li>
<li>We&#39;ll only use fixed-width or <a href="https://en.wikipedia.org/wiki/Monospaced_font">monospaced fonts</a>. Each glyph in such a font has the same width. We can entirely ignore things like kerning this way.</li>
<li>The font size is fixed.</li>
</ul>
<p>With these limits in place, the basic idea of a glyph atlas goes like this:</p>
<ul>
<li>Pick a monospaced font, like the original <a href="https://int10h.org/oldschool-pc-fonts/fontlist/font?ibm_vga_8x16">IBM VGA 8x16</a> font.</li>
<li>Use a glyph rendering library like <a href="http://freetype.org/">FreeType</a> to load the font and render out a glyph image for each printable Unicode code point between <code>0-255</code>.</li>
<li>Pack those glyph images into a single image called the glyph atlas in some order which makes mapping from a code point to the glyph image coordinates inside the glyph atlas trivial.</li>
</ul>
<p>Here&#39;s an example of what such a glyph atlas could look like.</p>
<p><img src="https://marioslab.io/posts/rendering-like-its-1996/dos-nostalgia/glyphatlas.png"/>
	<span></span>
</p>
<p>I&#39;ve super-imposed a red grid de-marking each glyph&#39;s boundaries. An atlas we can use would not have that grid on it. The pixels of the glyph are fully opaque white (<code>0xffffffff</code>), while the background pixels are transparent (<code>0x00000000</code>);</p>
<p>The atlas above contains glyph images from the IBM VGA 8x16 font for the Unicode code points <code>0-255</code>. Each glyph is 8x16 pixels in size. Each row consists of 16 glyphs. There are 16 rows in total, so 256 glyphs in total, one for each code point.</p>
<p>The glyphs in the first row map to code points <code>0-15</code>, the glyphs in the second row map to code points <code>16-31</code>, and so on. The first, second, ninth, and tenth row are empty, as these are the glyphs for non-printable control characters. The other rows contain the glyphs for all printable characters.</p>
<p>If you compare this glyph atlas with the ISO-8859-1 table above, you&#39;ll see that they are equivalent, except that the last glyph in the bottom right corner is missing from the atlas. The IBM VGA 8x16 font simply does not have a glyph for that code point.</p>
<p>So how do we generate this atlas? We don&#39;t. At least we won&#39;t write code for that as part of this series. I&#39;ve already written a web tool based on FreeType that does exactly what we need. It&#39;s called <a href="https://github.com/badlogic/bmfg"><code>Mario&#39;s (B)it(m)ap (F)ont (G)enerator</code></a> (I&#39;m a a dad, I&#39;m allowed to name it like that) and you can run it in your browser <a href="https://marioslab.io/projects/bmfg/">here</a>.</p>
<p>The tool lets you load a monospaced <a href="https://en.wikipedia.org/wiki/TrueType">TrueType</a> font, set the pixel height of the glyphs you want, and spits out a 16x14 grid of glyph images for the code points <code>32-255</code>. It omits the code points <code>0-31</code> and thus the first two rows of the atlas as those are non-printable control codes anyways. The above atlas thus becomes this:</p>
<p><img src="https://marioslab.io/posts/rendering-like-its-1996/dos-nostalgia/glyphatlas-trimmed.png"/>
	<span></span>
</p>
<p>We&#39;re still wasting two rows in the middle for the second set of control codes. But keeping them around makes converting code points to glyph image coordinates easier.</p>
<p>We can store the generated glyph atlas as a <code>.png</code> file in the <code>assets/</code> folder. I did just that using the file name <a href="https://github.com/badlogic/r96/blob/04-dos-nostalgia/assets/ibmvga.png"><code>assets/ibmvga.png</code></a>. The generator also tells us that each glyph has a size of 8x16 pixels. We&#39;ll need to remember that for when we actually draw text later. Since the glyph atlas is a plain old image, we can load it via <code>r96_image_init_from_file()</code>.</p>
<p>We&#39;re almost ready to render a text string. We need two more things:
* Being able to map a Unicode code point to a region in the glyph atlas image, where a region is defined by its top-left corner x- and y- pixel coordinates in the glyph atlas, and its width and height in pixels.
* Being able to not just blit an entire <code>r96_image</code> to another, but also blit regions of an <code>r96_image</code> to another <code>r96_image</code>.</p>
<p>Let&#39;s start with the mapping problem.</p>
<blockquote>
<p><strong>Note:</strong> We could put both the atlas and the glyph size information into some custom file format. I decided that&#39;s not worth it, so we&#39;ll go with a <code>.png</code> and some hard coded glyph sizes in the code.</p>
</blockquote>
<h3>Mapping code points to glyph atlas pixel coordinates</h3>
<p>How can we map a code point to the pixel coordinates of the top left corner of a glyph image in the atlas?</p>
<p>Before we resolve pixel coordinates for a code point, it&#39;s actually easier to use a different coordinate system. Let&#39;s give each glyph in the atlas an x- and y-coordinate.</p>



<p>For our example glyph atlas in the last section above, each cell represents a glyph image of size 8x16 pixels. In the diagram, the cell shows both the glyph and its code point.</p>
<p>The top-left glyph image has coordinate <code>(0, 0)</code> and the bottom-right glyph image has coordinate <code>(15, 13)</code>. We can define a simple equation that goes from glyph coordinates to code point, just like we did for pixel coordinates to pixel address:</p>
<pre><code>code_point = glyph_x + glyph_y * glyphs_per_row + 32
</code></pre>
<p>Why the <code>+ 32</code>? Because the first glyph has code point <code>32</code> (space). Without it, we&#39;d get 0 for <code>glyph_x = 0</code> and <code>glyph_y = 0</code>.</p>
<p>We can reverse this glyph coordinates to code point mapping as follows:</p>
<pre><code>glyph_x = (code_point - 32) % glyphs_per_row;
glyph_y = (code_point - 32 - glyph_x) / glyphs_per_row;
</code></pre>
<p>The <code>% glyphs_per_row</code> basically strips the <code>glyph_y * glyphs_per_row</code> component from the original equation above, leaving us with the glyph x-coordinate.</p>
<p>To calculate <code>glyph_y</code>, we can then subtract the just calculated <code>glyph_x</code>, which gives us the code point of the first glyph in the row, and divide by <code>glyphs_per_row</code> to arrive at the <code>glyph_y</code> coordinate.</p>
<p>All that&#39;s left to get the pixel coordinate of the top left corner of a glyph is to multiply the glyph coordinates by the glyph pixel width and height of the font, <code>8</code> and <code>16</code> in the example above.</p>
<pre><code>glyph_pixel_x = glyph_x * glyph_width;
glyph_pixel_y = glyph_x * glyph_height;
</code></pre>
<h3>Blitting regions</h3>
<p>Alright, we can generate glyph atlases for the first 255 Unicode code points, and we can calculate the pixel coordinates of a glyph image in the atlas corresponding to a code point. We also know the size of each glyph in pixels, as we specified that when generating the glyph atlas.</p>
<p>But we have one more problem: our current blitting functions can only blit an entire <code>r96_image</code>. What we need is blitting functions that blit just a region from a <code>r96_image</code>. Luckily, that&#39;s trivial, given our existing blitting functions! Here&#39;s a blitting function that blits a region from one <code>r96_image</code> to another.</p>


<div>
	<pre><code>void r96_blit_region(r96_image *dst, r96_image *src, int32_t dst_x, int32_t dst_y, int32_t src_x, int32_t src_y, int32_t src_width, int32_t src_height) {
	assert(src_x + src_width - 1 &lt; src-&gt;width);
	assert(src_y + src_height - 1 &lt; src-&gt;height);

	int32_t dst_x1 = dst_x;
	int32_t dst_y1 = dst_y;
	int32_t dst_x2 = dst_x + src_width - 1;
	int32_t dst_y2 = dst_y + src_height - 1;
	int32_t src_x1 = src_x;
	int32_t src_y1 = src_y;

	if (dst_x1 &gt;= dst-&gt;width) return;
	if (dst_x2 &lt; 0) return;
	if (dst_y1 &gt;= dst-&gt;height) return;
	if (dst_y2 &lt; 0) return;

	if (dst_x1 &lt; 0) {
		src_x1 -= dst_x1;
		dst_x1 = 0;
	}
	if (dst_y1 &lt; 0) {
		src_y1 -= dst_y1;
		dst_y1 = 0;
	}
	if (dst_x2 &gt;= dst-&gt;width) dst_x2 = dst-&gt;width - 1;
	if (dst_y2 &gt;= dst-&gt;height) dst_y2 = dst-&gt;height - 1;

	int32_t clipped_width = dst_x2 - dst_x1 + 1;
	int32_t dst_next_row = dst-&gt;width - clipped_width;
	int32_t src_next_row = src-&gt;width - clipped_width;
	uint32_t *dst_pixel = dst-&gt;pixels + dst_y1 * dst-&gt;width + dst_x1;
	uint32_t *src_pixel = src-&gt;pixels + src_y1 * src-&gt;width + src_x1;
	for (int32_t y = dst_y1; y &lt;= dst_y2; y++) {
		for (int32_t i = 0; i &lt; clipped_width; i++) {
			*dst_pixel++ = *src_pixel++;
		}
		dst_pixel += dst_next_row;
		src_pixel += src_next_row;
	}
}</code></pre>
</div>

<p>This is basically our old <a href="https://github.com/badlogic/r96/blob/04-dos-nostalgia/src/r96/r96.c#L222-L258"><code>r96_blit()</code></a> function with additional arguments. We sepcify the destination (<code>dst</code>) and source (<code>src</code>) image as before. We also specify the coordinates (<code>dst_x</code>, <code>dst_y</code>) at which the source image should be blitted in the destination image. Those used to be called <code>x</code> and <code>y</code>. Finally, we specify the region from the source image we want to blit, given as its top-left corner (<code>src_x</code>, <code>src_y</code>) and width and height (<code>src_width</code>, <code>src_height</code>).</p>
<p>The implementation itself then only has three minor modifications compared to <code>r96_blit()</code>.</p>
<p>The function starts with two asserts that ensure that the source region is valid. Next, <code>dst_x2</code> and <code>dst_y2</code> are calculated using the source region width and height instead of the source image width and height. Finally, <code>src_x1</code> and <code>src_y1</code> aren&#39;t initialized to <code>0</code>, but to <code>src_x</code> and <code>src_y</code>.</p>
<p>That&#39;s it! The rest, including the clipping, is exactly the same as <code>r96_blit()</code>. We can already use this function to blit glyph images from the glyph atlas. And for some use cases, that&#39;d be good enough.</p>
<p>However, if we only want to blit the white pixels of a glyph and ignore it&#39;s background pixels, we need color keying.</p>
<p>Easy, just copy <a href="https://github.com/badlogic/r96/blob/04-dos-nostalgia/src/r96/r96.c#L260-L300"><code>r96_blit_keyed()</code></a> and apply the same modifications.</p>


<div>
	<pre><code>void r96_blit_region_keyed(r96_image *dst, r96_image *src, int32_t dst_x, int32_t dst_y, int32_t src_x, int32_t src_y, int32_t src_width, int32_t src_height, uint32_t color_key) {
	assert(src_x + src_width - 1 &lt; src-&gt;width);
	assert(src_y + src_height - 1 &lt; src-&gt;height);

	int32_t dst_x1 = dst_x;
	int32_t dst_y1 = dst_y;
	int32_t dst_x2 = dst_x + src_width - 1;
	int32_t dst_y2 = dst_y + src_height - 1;
	int32_t src_x1 = src_x;
	int32_t src_y1 = src_y;

	if (dst_x1 &gt;= dst-&gt;width) return;
	if (dst_x2 &lt; 0) return;
	if (dst_y1 &gt;= dst-&gt;height) return;
	if (dst_y2 &lt; 0) return;

	if (dst_x1 &lt; 0) {
		src_x1 -= dst_x1;
		dst_x1 = 0;
	}
	if (dst_y1 &lt; 0) {
		src_y1 -= dst_y1;
		dst_y1 = 0;
	}
	if (dst_x2 &gt;= dst-&gt;width) dst_x2 = dst-&gt;width - 1;
	if (dst_y2 &gt;= dst-&gt;height) dst_y2 = dst-&gt;height - 1;

	int32_t clipped_width = dst_x2 - dst_x1 + 1;
	int32_t dst_next_row = dst-&gt;width - clipped_width;
	int32_t src_next_row = src-&gt;width - clipped_width;
	uint32_t *dst_pixel = dst-&gt;pixels + dst_y1 * dst-&gt;width + dst_x1;
	uint32_t *src_pixel = src-&gt;pixels + src_y1 * src-&gt;width + src_x1;
	for (dst_y = dst_y1; dst_y &lt;= dst_y2; dst_y++) {
		for (int32_t i = 0; i &lt; clipped_width; i++) {
			uint32_t src_color = *src_pixel;
			uint32_t dst_color = *dst_pixel;
			*dst_pixel = src_color != color_key ? src_color : dst_color;
			src_pixel++;
			dst_pixel++;
		}
		dst_pixel += dst_next_row;
		src_pixel += src_next_row;
	}
}</code></pre>
</div>

<p>But we can do even better. No text rendering engine is complete without support for colored text! As is stands, we can only draw white text, as that&#39;s the color the glyph atlas generator spits out. On-top of color keying, we can also apply what&#39;s usually known as <a href="https://en.wikipedia.org/wiki/Tint,_shade_and_tone">tinting</a>.</p>
<p>We&#39;ll implement tinting in the simplest possible way: multiply the red, green, and blue color component of the source pixel with the red, green, and blue color component of the specified tinting color. That result of the multiplication is then normalized back to the <code>0-255</code> range for each component by dividing by <code>255</code>. This effectively mixes the two colors.</p>
<pre><code>tinted_red = ((source_red * tint_red) &gt;&gt; 8) &amp; 0xff;
tinted_green = ((source_green * tint_green) &gt;&gt; 8) &amp; 0xff;
tinted_blue = ((source_blue * tint_blue) &gt;&gt; 8) &amp; 0xff;
</code></pre>
<blockquote>
<p><strong>Note:</strong> for the case of tinting glyphs images as generated by the generator, we could just write the tint color to the destination if the source pixel color doesn&#39;t match the color key. However, this approach above also works for tinting arbitrary source pixel colors. We&#39;ll see why that&#39;s useful in a later demo.</p>
</blockquote>
<p>Here&#39;s the final region blitting routine, which takes both a color key and a tinting color:</p>


<div>
	<pre><code>void r96_blit_region_keyed_tinted(r96_image *dst, r96_image *src, int32_t dst_x, int32_t dst_y, int32_t src_x, int32_t src_y, int32_t src_width, int32_t src_height, uint32_t color_key, uint32_t tint) {
	assert(src_x + src_width - 1 &lt; src-&gt;width);
	assert(src_y + src_height - 1 &lt; src-&gt;height);

	int32_t dst_x1 = dst_x;
	int32_t dst_y1 = dst_y;
	int32_t dst_x2 = dst_x + src_width - 1;
	int32_t dst_y2 = dst_y + src_height - 1;
	int32_t src_x1 = src_x;
	int32_t src_y1 = src_y;

	if (dst_x1 &gt;= dst-&gt;width) return;
	if (dst_x2 &lt; 0) return;
	if (dst_y1 &gt;= dst-&gt;height) return;
	if (dst_y2 &lt; 0) return;

	if (dst_x1 &lt; 0) {
		src_x1 -= dst_x1;
		dst_x1 = 0;
	}
	if (dst_y1 &lt; 0) {
		src_y1 -= dst_y1;
		dst_y1 = 0;
	}
	if (dst_x2 &gt;= dst-&gt;width) dst_x2 = dst-&gt;width - 1;
	if (dst_y2 &gt;= dst-&gt;height) dst_y2 = dst-&gt;height - 1;

	uint32_t tint_r = R96_R(tint);
	uint32_t tint_g = R96_G(tint);
	uint32_t tint_b = R96_B(tint);

	int32_t clipped_width = dst_x2 - dst_x1 + 1;
	int32_t dst_next_row = dst-&gt;width - clipped_width;
	int32_t src_next_row = src-&gt;width - clipped_width;
	uint32_t *dst_pixel = dst-&gt;pixels + dst_y1 * dst-&gt;width + dst_x1;
	uint32_t *src_pixel = src-&gt;pixels + src_y1 * src-&gt;width + src_x1;
	for (dst_y = dst_y1; dst_y &lt;= dst_y2; dst_y++) {
		for (int32_t i = 0; i &lt; clipped_width; i++) {
			uint32_t src_color = *src_pixel;
			uint32_t dst_color = *dst_pixel;
			*dst_pixel = src_color != color_key ? R96_ARGB(
														  R96_A(src_color),
														  ((R96_R(src_color) * tint_r) &gt;&gt; 8) &amp; 0xff,
														  ((R96_G(src_color) * tint_g) &gt;&gt; 8) &amp; 0xff,
														  ((R96_B(src_color) * tint_b) &gt;&gt; 8) &amp; 0xff)
												: dst_color;
			src_pixel++;
			dst_pixel++;
		}
		dst_pixel += dst_next_row;
		src_pixel += src_next_row;
	}
}</code></pre>
</div>

<p>Since we&#39;ve already extensively benchmarked and optimized the original blitter functions, and since these new functions only change some setup code, we have no need to do another optimization pass. Whew.</p>
<p>Alright, let&#39;s put everything we learned into a little demo.</p>
<h3>Demo: Blitting regions</h3>
<p>In this demo, we are going to blit the glyphs for the string <code>&#34;Hello world!&#34;</code> sourced from the glyph atlas in <a href="https://github.com/badlogic/r96/blob/04-dos-nostalgia/assets/ibmvga.png"><code>assets/ibmvga.png</code></a>, which I generated via <a href="https://marioslab.io/projects/bmfg">Mario&#39;s BMFG</a>. We&#39;ll apply what we learned and created above, from iterating UTF-8 encoded characters, calculating pixel coordinates for glyphs from code points, to blitting regions in various ways.</p>
<p>Here&#39;s <a href="https://github.com/badlogic/r96/blob/04-dos-nostalgia/src/13_blit_region.c"><code>13_blit_region.c</code></a>:</p>


<div>
	<pre><code>#include &lt;MiniFB.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &#34;r96/r96.h&#34;

int main(void) {
	const int window_width = 320, window_height = 240;
	struct mfb_window *window = mfb_open(&#34;13_blit_region&#34;, window_width, window_height);
	r96_image output;
	r96_image_init(&amp;output, window_width, window_height);

	r96_image glyph_atlas;
	int32_t glyph_width = 8;
	int32_t glyph_height = 16;
	int32_t glyphs_per_row = 16;
	r96_image_init_from_file(&amp;glyph_atlas, &#34;assets/ibmvga.png&#34;);

	do {
		r96_clear_with_color(&amp;output, R96_ARGB(0xff, 0x22, 0x22, 0x22));

		const char *text = &#34;Hello world!&#34;;
		uint32_t text_length = strlen(text);
		uint32_t char_index = 0;
		uint32_t x_offset = 100;
		while (char_index &lt; text_length) {
			uint32_t code_point = r96_next_utf8_code_point(text, &amp;char_index, text_length);
			int32_t glyph_x = (code_point - 32) % glyphs_per_row;
			int32_t glyph_y = (code_point - 32 - glyph_x) / glyphs_per_row;
			int32_t glyph_pixel_x = glyph_x * glyph_width;
			int32_t glyph_pixel_y = glyph_y * glyph_height;

			r96_blit_region(&amp;output, &amp;glyph_atlas, x_offset, 50, glyph_pixel_x, glyph_pixel_y, glyph_width, glyph_height);
			r96_blit_region_keyed(&amp;output, &amp;glyph_atlas, x_offset, 100, glyph_pixel_x, glyph_pixel_y, glyph_width, glyph_height, 0x0);
			r96_blit_region_keyed_tinted(&amp;output, &amp;glyph_atlas, x_offset, 150, glyph_pixel_x, glyph_pixel_y, glyph_width, glyph_height, 0x0, 0xffff00ff);
			x_offset += glyph_width;
		}

		if (mfb_update_ex(window, output.pixels, window_width, window_height) != STATE_OK) break;
	} while (mfb_wait_sync(window));
	return 0;
}</code></pre>
</div>

<p>As usual, we start out by creating a window and an output <code>r96_image</code> to which we draw, which gets later drawn to the window.</p>
<p>Next, we define the properties of our glyph atlas and the glyphs contained there-in, and load the glyph atlas image.</p>
<p>In the main loop, we clear the output image, then iterate through the characters in the <code>text</code> string via <code>r96_next_utf8_code_point()</code>. We then calculate the glyph pixel coordinates for the code point in the glyph atlas and use that information to blit the glyph to the screen three times, using the normal blit, keyed blit, and keyed and tinted blit functions.</p>
<p>Take special note of <code>x_offset</code>. It specifies at what x-coordinate the next glyph will be blitted in the output image. As our font is monospaced, we can easily advance the drawing position on the x-axis by <code>glyph_width</code>. All glyphs have the same width. Variable width fonts are quite a bit more complex to get right in that regard.</p>
<p>And here is the web version.</p>






<p>Let&#39;s pack all of this up into re-useable code.</p>
<h3>r96_font</h3>
<p>Looking at the last demo, we can almost see a struct for fonts plop out:</p>


<div>
	<pre><code>r96_image glyph_atlas;
int32_t glyph_width = 8;
int32_t glyph_height = 16;
int32_t glyphs_per_row = 16;</code></pre>
</div>

<p>This is the minimum information we need to store for a font to draw text with it, which translates to the following struct:</p>


<div>
	<pre><code>typedef struct r96_font {
	r96_image glyph_atlas;
	int32_t glyph_width, glyph_height;
	int32_t glyphs_per_row;
	int32_t tab_size;
} r96_font;</code></pre>
</div>

<p>We load the <code>glyph_atlas</code> from an image file. <code>glyph_width</code> and <code>glyph_height</code> are parameters we&#39;ll need to specify when initializing the <code>r96_image</code> font. <code>glyphs_per_row</code> we can actually automatically deduce from the glyph atlas width and the glyph width, reducing the amount of parameters we need to specify when initializing a font. <code>tab_size</code> will make sense in a minute! Here&#39;s <code>r96_font_init()</code>:</p>


<div>
	<pre><code>bool r96_font_init(r96_font *font, const char *path, int32_t glyph_width, int32_t glyph_height) {
	if (!r96_image_init_from_file(&amp;font-&gt;glyph_atlas, path)) return false;
	font-&gt;glyph_width = glyph_width;
	font-&gt;glyph_height = glyph_height;
	font-&gt;glyphs_per_row = font-&gt;glyph_atlas.width / glyph_width;
	font-&gt;tab_size = 3;
	return true;
}</code></pre>
</div>

<p>Unremarkable. And the corresponding <code>r96_font_dispose()</code>:</p>


<div>
	<pre><code>void r96_font_dispose(r96_font *font) {
	r96_image_dispose(&amp;font-&gt;glyph_atlas);
}</code></pre>
</div>

<p>The rendering logic from the last example can be directly translated to a re-usable function. But we&#39;ll add two more features. We&#39;ll interpret <code>\n</code> and <code>\t</code> and adjust the rendering position for the next glyph accordingly.</p>


<div>
	<pre><code>void r96_text(r96_image *image, r96_font *font, const char *text, int32_t x, int32_t y, uint32_t tint) {
	int32_t cursor_x = x;
	int32_t cursor_y = y;
	uint32_t text_length = strlen(text);
	uint32_t index = 0;
	while (index &lt; text_length) {
		uint32_t c = r96_next_utf8_code_point(text, &amp;index, text_length);
		if (c == &#39;\t&#39;) {
			cursor_x += font-&gt;tab_size * font-&gt;glyph_width;
			continue;
		}
		if (c == &#39;\n&#39;) {
			cursor_x = x;
			cursor_y += font-&gt;glyph_height;			
			continue;
		}
		if (c &lt; 32 || c &gt; 255) {
			cursor_x += font-&gt;glyph_width;
			continue;
		}

		int32_t glyph_index = c - 32;
		int32_t glyph_x = (glyph_index % font-&gt;glyphs_per_row);
		int32_t glyph_y = (glyph_index - glyph_x) / font-&gt;glyphs_per_row;
		glyph_x *= font-&gt;glyph_width;
		glyph_y *= font-&gt;glyph_height;

		r96_blit_region_keyed_tinted(image, &amp;font-&gt;glyph_atlas, cursor_x, cursor_y, glyph_x, glyph_y, font-&gt;glyph_width, font-&gt;glyph_height, 0x0, tint);

		cursor_x += font-&gt;glyph_width;
	}
}</code></pre>
</div>

<p>The function takes the <code>image</code> we want to render the text to, the <code>font</code> to render with, the <code>text</code> as a null-terminated UTF-8 string, and the <code>x</code> and <code>y</code> position to start rendering the first glyph at in the image. It&#39;s final parameter is the <code>tint</code> color.</p>
<p>Inside the function, we keep track of the position to render the next glyph at in <code>cursor_x</code> and <code>cursor_y</code>. We also keep track of the text length in bytes and the byte <code>index</code> from which we&#39;ll read the next Unicode code point from the <code>text</code>.</p>
<p>The loop then iterates over all code points in the text via <code>r96_next_utf8_code_point()</code>. In case we encounter <code>\t</code>, we advance the cursor position by <code>font-&gt;tab_size * font-&gt;glyph_width</code> and continue on to the next glyph. In case of <code>\n</code>, we reset <code>cursor_x</code> to the original <code>x</code>, essentially moving the cursor to the beginning of the text line. We then increase <code>cursor_y</code> by the glyph height to move it to the next line below. Yay, multi-line rendering!</p>
<p>Before we actually render the glyph for the current code point, we also check that the code point is within <code>32-255</code>, so we don&#39;t try to draw a glyph that&#39;s not inside the glyph atlas.</p>
<p>The remainder of the function maps the code point to the glyph in the glyph atlas and uses <code>r96_blit_region_keyed_tinted()</code> to draw the glyph to the current cursor position. Finally, we advance the cursor by the glyph width.</p>
<p>Not counting the region blitting functions, the entire text rendering code code is about 70 LOC now. Let&#39;s add a few more lines of code.</p>
<p>In the previous demo, we positioned the glyphs at hard coded coordinates. If we wanted to center the text on the screen, or apply other alignments, we need to know the width and height of the text, also known as its bounds.</p>
<p>Let&#39;s write a little function that calculates exactly that.</p>


<div>
	<pre><code>void r96_font_get_text_bounds(r96_font *font, const char *text, int32_t *width, int32_t *height) {
	*width = 0;
	*height = font-&gt;glyph_height;
	int32_t current_line_width = 0;
	uint32_t text_length = strlen(text);
	uint32_t index = 0;
	while (index &lt; text_length) {
		uint32_t c = r96_next_utf8_code_point(text, &amp;index, text_length);
		if (c == &#39;\t&#39;) {
			current_line_width += font-&gt;tab_size * font-&gt;glyph_width;
			continue;
		}
		if (c == &#39;\n&#39;) {
			*width = current_line_width &gt; *width ? current_line_width : *width;
			*height += font-&gt;glyph_height;
			current_line_width = 0;
			continue;
		}
		current_line_width += font-&gt;glyph_width;
	}
	*width = current_line_width &gt; *width ? current_line_width : *width;
}</code></pre>
</div>

<p>The function takes the <code>font</code> that the <code>text</code> will be rendered with, as well as pointers <code>width</code> and <code>height</code> to which we write the calculated bounds.</p>
<p>The function then mirrors parts of the rendering logic in <code>r96_text()</code>, calculating the maximum line width, as well as how many lines there actually are.</p>
<p>Alright, let&#39;s use all this in a little demo.</p>
<h3>Demo: using r96_font and friends</h3>
<p>Here&#39;s <a href="https://github.com/badlogic/r96/blob/04-dos-nostalgia/src/14_fonts.c"><code>14_fonts.c</code></a>, our cute font demo:</p>


<div>
	<pre><code>#include &lt;MiniFB.h&gt;
#include &lt;stdlib.h&gt;
#include &#34;r96/r96.h&#34;

int main(void) {
	const int window_width = 320, window_height = 240;
	struct mfb_window *window = mfb_open(&#34;14_fonts&#34;, window_width, window_height);
	r96_image output;
	r96_image_init(&amp;output, window_width, window_height);
	r96_font font;
	r96_font_init(&amp;font, &#34;assets/ibmvga.png&#34;, 8, 16);

	do {
		r96_clear_with_color(&amp;output, R96_ARGB(0xff, 0x22, 0x22, 0x22));

		const char *text = &#34;The quick brown fox jumps\nover the lazy dog\n&#34;
						   &#34;¡¢£¤¥¦§¨©ª«¬\n&#34;
						   &#34;ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏ&#34;;

		int32_t text_x, text_y, text_width, text_height;
		r96_font_get_text_bounds(&amp;font, text, &amp;text_width, &amp;text_height);
		text_x = window_width / 2 - text_width / 2;
		text_y = window_height / 2 - text_height / 2;

		r96_rect(&amp;output, text_x, text_y, text_width, text_height, R96_ARGB(0xff, 0xff, 0x0, 0xff));
		r96_text(&amp;output, &amp;font, text, text_x + 1, text_y + 1, 0x00000000);
		r96_text(&amp;output, &amp;font, text, text_x, text_y, 0xffffffff);

		if (mfb_update_ex(window, output.pixels, window_width, window_height) != STATE_OK) break;
	} while (mfb_wait_sync(window));
	return 0;
}</code></pre>
</div>

<p>We start off by loading the font in line <code>11</code>, specifying the glyph atlas image path, the glyph width, and the glyph height. <code>r96_font_init</code> loads the glyph atlas image and sets up all the fields of the font as we saw earlier.</p>
<p>In the main loop, we clear the output image, then define the text we want to render. The <code>text</code> consists of 3 lines, using characters from the code point range we support.</p>
<p>The next block of code calculates the bounds of the text via <code>r96_font_get_text_bounds()</code>, which we use to calculate the text&#39;s top-left corner position in such a way, that the text is centered in the middle of the screen.</p>
<p>In the final block, we render a background rectangle using the text bounds, followed by rendering the text offset by 1 pixel on both axes with a black tint. Finally, we render the text at the calculated position with a white tint. Rendering the text twice this way gives us a simple shadow effect. Here&#39;s the demo running on the web.</p>






<p>Great success.</p>
<h3>Demo: fun with fonts</h3>
<p>While the original IBM VGA font is nice, it&#39;s also a bit of an outdated, and dare I say boring look.</p>
<p>I&#39;ve added two more glyph atlases to the <code>assets/</code> folder. The first one is derived from the awesome <a href="https://github.com/sunaku/tamzen-font/tree/master/ttf">Tamzen</a> font (<code>assets/tamzen.png</code>).</p>
<p><img src="https://marioslab.io/posts/rendering-like-its-1996/dos-nostalgia/assets/tamzen.png"/>
	<span></span>
</p>
<p>It has a lighter, more modern appearance and is well suited to display stats, like performance counters.</p>
<p>The other font was ripped from some old demo from the 90ies by <a href="https://hackaday.io/furan">Ian Hanschen</a>. He&#39;s put up a <a href="https://github.com/ianhan/BitmapFonts">GitHub repo</a> with a gargantuan amount of ripped fonts. Most of them do not have attribution. This is the one I picked (<code>assets/demofont.png</code>).</p>
<p><img src="https://marioslab.io/posts/rendering-like-its-1996/dos-nostalgia/assets/demofont.png"/>
	<span></span>
</p>
<p>Each font is basically just a glyph atlas. However, the atlas layout doesn&#39;t match the one generated by <a href="https://marioslab.io/projects/bmfg">BMFG</a>.</p>
<p>For the font I picked, we see that it only contains glyphs for the first few code points. Instead of 16 glyphs, it contains 20 glyphs per row. Thankfully, <code>r96_init_font()</code> can deal with this by calculating the number of glyphs per row based on the glyph atlas width and glyph width. The only thing we need to watch out for is to not use any code points that go above <code>Z</code> in our text strings.</p>
<p>This demo doesn&#39;t come with an explanation. Consider it to be a puzzle for your brain noggins! Can you figure out how it works? <a href="https://github.com/badlogic/r96/blob/04-dos-nostalgia/src/15_font_fun.c"><code>15_font_fun.c</code></a>:</p>


<div>
	<pre><code>#include &lt;MiniFB.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &#34;r96/r96.h&#34;

int main(void) {
	const int window_width = 320, window_height = 240;
	struct mfb_window *window = mfb_open(&#34;15_font_fun&#34;, window_width, window_height);
	r96_image output;
	r96_image_init(&amp;output, window_width, window_height);
	r96_font font;
	r96_font_init(&amp;font, &#34;assets/demofont.png&#34;, 16, 16);
	float counter = 0;
	struct mfb_timer *timer = mfb_timer_create();
	do {
		r96_clear_with_color(&amp;output, R96_ARGB(0xff, 0x22, 0x22, 0x22));

		const char *text = &#34;--(2022 DEMO CREW)--&#34;;
		int32_t text_x = 0;
		uint32_t text_length = strlen(text);
		uint32_t char_index = 0;
		while (char_index &lt; text_length) {
			char character[] = {0, 0};
			character[0] = (char) r96_next_utf8_code_point(text, &amp;char_index, text_length);
			int32_t text_y = output.height / 2 - font.glyph_width / 2 + (int32_t) (sinf(counter + char_index / 10.0f) * output.height / 4);
			r96_text(&amp;output, &amp;font, character, text_x, text_y, 0xffffffff);
			text_x += font.glyph_width;
		}

		counter += M_1_PI * mfb_timer_delta(timer) * 12;
		mfb_timer_reset(timer);

		if (mfb_update_ex(window, output.pixels, window_width, window_height) != STATE_OK) break;
	} while (mfb_wait_sync(window));
	return 0;
}</code></pre>
</div>

<p>And here it is in action.</p>






<h2>Next time on &#34;Mario writes a lot of words&#34;</h2>
<p>Our little code base is shaping up to be kinda useful. Next time, we&#39;re going to look into drawing lines. Possibly with sub-pixel precision. Unless I can&#39;t figure that out.</p>
<p>Discuss this post on <a href="https://twitter.com/badlogicgames/status/1614607123475992577">Twitter</a> or <a href="https://mastodon.gamedev.place/@badlogic/109693328234554967">Mastodon</a>.</p>



</div>

</div></div>
  </body>
</html>
