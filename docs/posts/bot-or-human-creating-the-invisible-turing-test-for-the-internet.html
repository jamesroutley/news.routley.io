<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://research.roundtable.ai/proof-of-human/">Original</a>
    <h1>Bot or Human? Creating the Invisible Turing Test for the Internet</h1>
    
    <div id="readability-page-1" class="page"><div>
    <!-- <a class="marker" href="#section-1" id="section-1"><span>1</span></a> -->
    <!-- <h2>Introduction</h2> -->
    <!-- <p>Online bot detection is becoming increasingly critical as AI agents grow more prevalent <d-cite key="ferrara2023social,hajli2022social,abdullah2022chatgpt"></d-cite> and AI scrapers put extra load on every website <d-cite key="zarf2025ai,hn2025foss,hn2025anubis,hn2025devs,hn2025nepenthes,hn2024traffic"></d-cite>. Early approaches relied on heuristics such as IP blacklisting and user-agent filtering (e.g. <d-cite key="nikiforakis2013cookieless"></d-cite>), but the realm has largely shifted toward browser and device fingerprinting (HTTP headers, JavaScript properties, device characteristics)<d-cite key="laperdrix2016beautiful,englehardt2016online"></d-cite>.</p>

      <p>
        In addition to data privacy concerns, these methods face challenges with AI agents. We provide an alternative — the Roundtable <a href="https://www.roundtable.ai">Proof-of-Human API</a> — which measures behavioral patterns (e.g. keystroke dynamics, mouse movements, and reaction times) to verify proof-of-human invisibly, continuously, and instantaneously.
      </p> -->

    <a href="#section-1" id="section-1"><span>1</span></a>
    <!-- <h2>Background</h2> -->

    <p><em> <strong>Want to see behavioral differences in action?</strong> Skip to <a href="#section-2">Section 2</a> for interactive keystroke and mouse movement demos, or <a href="#section-3">Section 3</a> for a cognitive psychology experiment.</em></p>


    <p>Google reCAPTCHA v3 <d-cite key="googleRecaptchaV3"></d-cite> boasts a commanding market share in bot detection today. It claims to analyze patterns of user behavior across the web, including mouse movements, typing patterns, and browsing history. However, reCAPTCHA v3 fails to detect AI agents using real browser environments.</p>
        
    <p>To illustrate, we tested OpenAI&#39;s Operator agent <d-cite key="openaiOperator2025"></d-cite> with reCAPTCHA v3. Despite Operator&#39;s non-humanlike interaction patterns (such as perfectly centered mouse clicks and repeatedly pasted text), reCAPTCHA v3 assigned a high &#34;human&#34; score and did not flag the agent as suspicious:</p>

    <figure>
      <p>
        <iframe src="https://www.youtube.com/embed/UeTpCdUc4Ls" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
      </p>
      <figcaption><b>Figure 1:</b> OpenAI&#39;s Operator agent passing reCAPTCHA v3 despite non-humanlike interaction patterns, demonstrating the limitations of current bot detection systems.</figcaption>
    </figure>

    <p> Today, LLMs from companies like OpenAI and Anthropic repeatedly pass as humans in the classic Turing Test <d-cite key="turing1950computing"></d-cite>, necessitating new approaches that — for example — focus on behavioral patterns and cognitive signatures.</p>

   <!-- <p>While recent work analyzes linguistic differences between large language models and human conversation <d-cite key="reinhart2025llms,mccoy2024embers"></d-cite>, we propose behavior as a constraint that creates natural boundaries for AI agents. This is not a completely novel development — behavior biometrics is a growing component in the Customer Identity and Access Management (CIAM) landscape and provides a promising alternative to traditional authentication methods <d-cite key="mastercardBehavioralBiometrics2022,biocatchFraudDetection2018"></d-cite>.</p>

<p>Our insight is to fuse this commercial work with academic work in computational cognitive science <d-cite key="griffiths2015manifesto,kriegeskorte2018cognitive,tenenbaum2011grow"></d-cite>, an academic field providing computational and mathematical framework for understanding human cognition and behavior. The rise of increasingly sophisticated AI systems has brought renewed attention to the question of what fundamentally distinguishes human cognition <d-cite key="griffiths2020understanding"></d-cite>. As Griffiths argues, these distinctions may lie not in our capabilities but in our limitations - the characteristic ways in which humans adapt to and work within cognitive constraints.</p>

    <p>These cognitive constraints manifest in several ways particularly relevant to human-machine distinction. First, humans exhibit natural variability in their responses due to the realized allocation of cognitive resources. Second, certain cognitive biases and limitations are fundamental to human information processing and unlikely needed for AI superintelligence. Third, the interplay between cognitive processes and motor control creates characteristic patterns that are difficult to perfectly simulate in an economical manner. We argue these behaviors persist even as AI systems become more sophisticated.</p> -->


    <!-- <p>Overall, this work contributes to a growing field of proof-of-human systems <d-cite key="worldcoin2023whitepaper,worldcoin2023privacy,berkeleydefi2023proof,vitalik2023biometric"></d-cite>. While most of this work centers around decentralized protocols and borrows from crypto-native frameworks, we propose an orthogonal approach that seeks to verify human identity through behavioral and cognitive signatures.</p> -->

    <a href="#section-2" id="section-2"><span>2</span></a>
    <!-- <h2>Results</h2> -->
    <!-- <p>Here are two analyses designed to highlight the distinction between human and AI agent interactions. </p> -->

    <!-- <h3>4.1 Behavioral Biometrics: Keystroke and Mouse Movement</h3> -->
    <p>Behavioral methods leverage the unique patterns in how humans physically interact with computers <d-cite key="mastercardBehavioralBiometrics2022,biocatchFraudDetection2018"></d-cite>. For example, human keystroke dynamics are irregular and context-dependent. Bots, by contrast, often paste text instantly or simulate key-by-key typing with unnatural regularity. Similarly, human mouse movements are characterized by micro-adjustments, overshoots, and corrections, while bots tend to move in straight lines or teleport between points. These differences are not only visually apparent but also quantifiable. </p>

<p><strong>Try out the interactive demos below to see the difference between human and bot behavior:</strong></p>
    <!-- Interactive keystroke latency tracker -->
    <figure>
      <div id="keystroke-preview-card">
        
        <p>Compare bot vs human typing patterns in real-time. See how AI agents exhibit different keystroke timing signatures compared to natural human typing.</p>
        <div>
          
        </div>
        </div>
      <figcaption><b>Figure 2:</b> Interactive keystroke latency tracker comparing bot and human typing patterns. </figcaption>
    </figure>

    <figure>
      <div id="mouse-preview-card">
        
        <p>Compare bot vs human mouse movement patterns during form interactions. Observe how AI agents exhibit different cursor trajectories compared to natural human movements.</p>
        <div>
          <div>
            
            
          </div>
        </div>
        </div>
      <figcaption><b>Figure 3:</b> Interactive mouse movement analysis comparing bot and human patterns during form filling.</figcaption>
    </figure>
    

        <a href="#section-3" id="section-3"><span>3</span></a>
    <p>
    How much can these behavioral patterns be spoofed? This remains an ongoing question, but the evidence to date is optimistic. Academic studies have found behavioral biometrics to be robust against attacks under adversarial conditions <d-cite key="stefan2012robustness,gonzalez2022towards,killourhy2009comparing"></d-cite>, and industry validation from top financial institutions demonstrates real-world resilience<d-cite key="mastercardBehavioralBiometrics2022,biocatchFraudDetection2018"></d-cite>. 
    </p>
    <p>
    The underlying reason appears to be cost complexity. After all, fraud is an economic game. Traditional credentials like passwords or device fingerprints are static, finite, and easily replayed, whereas behavioral signatures encode fine-grained variations that are difficult to reverse-engineer. While AI agents can theoretically simulate these patterns, the effort likely outweighs other alternatives.</p>
  
    <!-- <h3>4.2 Stroop Task Reaction Time</h3> -->
    <p>To further illustrate the point, we can extend the challenge: can a bot completely replicate human cognitive psychology?</p>
    
    <p>Take for example the Stroop task <d-cite key="stroop1935studies"></d-cite>. It&#39;s a classic psychology experiment where humans select the color a word is written it and not what the word says. Humans typically show slower responses when the meaning of a word conflicts with its color (e.g., the word &#34;BLUE&#34; written in green), reflecting an overriding of automatic behavior <d-cite key="posner1978chronometric,treisman1969strategies,cohen1990attention,macleod1991half"></d-cite>. Bots and AI agents, by contrast, are not subject to such interference and can respond with consistent speed regardless of stimuli. </p>

    <p><strong>Try out the interactive demo below to see the difference between human and bot behavior:</strong></p>

    <!-- Interactive Stroop Task: Human vs Superhuman Bot -->
    <figure>
      <div id="stroop-preview-card">
        
        <p>Compare bot vs human cognitive interference using the classic Stroop task. Observe how humans show slower responses during conflicting stimuli while bots maintain consistent performance.</p>
        <div>
          <div>
            
          </div>
        </div>
        </div>
      <figcaption><b>Figure 4:</b> Interactive Stroop Task comparing bot vs. human reaction time and interference.</figcaption>
    </figure>
    
    <!-- 
    <script>
    (function() {
      // --- Config ---
      const COLORS = ['red', 'green', 'blue', 'yellow'];
      const COLOR_HEX = { red: '#dc3545', green: '#28a745', blue: '#007bff', yellow: '#ffc107' };
      const N_TRIALS = 10;
      const BOT_DELAY = 120; // ms, superhuman
      const HUMAN_BTN_IDS = ['human-btn-red', 'human-btn-green', 'human-btn-blue', 'human-btn-yellow'];
      const BOT_BTN_IDS = ['bot-btn-red', 'bot-btn-green', 'bot-btn-blue', 'bot-btn-yellow'];
      
      // --- State ---
      let trials = [];
      let humanData = [];
      let botData = [];
      let trialIdx = 0;
      let humanStartTime = null;
      let botTimeout = null;
      let running = false;
      
      // --- DOM ---
      const humanWord = document.getElementById('human-stroop-word');
      const botWord = document.getElementById('bot-stroop-word');
      const humanTrialLabel = document.getElementById('human-trial-label');
      const botTrialLabel = document.getElementById('bot-trial-label');
      const stroopStartBtn = document.getElementById('stroop-start-btn');
      const stroopResetBtn = document.getElementById('stroop-reset-btn');
      const stroopResults = document.getElementById('stroop-results');
      
      // --- Trial Generation ---
      function makeTrials(n) {
        // Half congruent, half incongruent
        let arr = [];
        for (let i = 0; i < n; ++i) {
          const word = COLORS[Math.floor(Math.random() * COLORS.length)];
          let color = word;
          let congruent = true;
          if (i % 2 === 1) {
            // Incongruent: pick a color different from the word
            let otherColors = COLORS.filter(c => c !== word);
            color = otherColors[Math.floor(Math.random() * otherColors.length)];
            congruent = false;
          }
          arr.push({ word, color, congruent });
        }
        // Shuffle
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }
      
      // --- UI Helpers ---
      function setWord(el, word, color) {
        el.textContent = word.toUpperCase();
        el.style.color = COLOR_HEX[color];
      }
      function setTrialLabels(idx) {
        humanTrialLabel.textContent = `Trial ${idx+1}/${N_TRIALS}`;
        botTrialLabel.textContent = `Trial ${idx+1}/${N_TRIALS}`;
      }
      function enableHumanBtns(enable) {
        HUMAN_BTN_IDS.forEach(id => {
          document.getElementById(id).disabled = !enable;
        });
      }
      function resetBtns() {
        enableHumanBtns(false);
        BOT_BTN_IDS.forEach(id => {
          const btn = document.getElementById(id);
          btn.disabled = true;
          btn.classList.remove('btn-success');
          btn.classList.add('btn-primary');
        });
      }
      function clearWords() {
        humanWord.textContent = '---';
        humanWord.style.color = '#222';
        botWord.textContent = '---';
        botWord.style.color = '#222';
      }
      function showResults() {
        // Compute stats
        const humanRTs = humanData.map(d => d.rt);
        const botRTs = botData.map(d => d.rt);
        const humanAcc = humanData.filter(d => d.correct).length / N_TRIALS;
        const botAcc = botData.filter(d => d.correct).length / N_TRIALS;
        const humanCongRTs = humanData.filter(d => d.congruent).map(d => d.rt);
        const humanIncongRTs = humanData.filter(d => !d.congruent).map(d => d.rt);
        const botCongRTs = botData.filter(d => d.congruent).map(d => d.rt);
        const botIncongRTs = botData.filter(d => !d.congruent).map(d => d.rt);
        const mean = arr => arr.length ? (arr.reduce((a,b) => a+b,0)/arr.length).toFixed(1) : '-';
        
        // Second-order statistics
        const std = arr => {
          if (!arr.length) return 0;
          const m = arr.reduce((a,b) => a+b,0)/arr.length;
          return Math.sqrt(arr.reduce((a,b) => a + Math.pow(b-m,2), 0)/arr.length);
        };
        const cv = arr => arr.length ? (std(arr)/mean(arr)*100).toFixed(1) : '-'; // Coefficient of variation
        const skew = arr => {
          if (!arr.length) return 0;
          const m = arr.reduce((a,b) => a+b,0)/arr.length;
          const s = std(arr);
          return arr.reduce((a,b) => a + Math.pow((b-m)/s,3), 0)/arr.length;
        };
        
        stroopResults.innerHTML = `
        <div style="display:flex;gap:30px;justify-content:center;">
          <div style="flex:1;min-width:320px;background:#f8f9fa;padding:18px 18px 18px 18px;border-radius:8px;">
            <h4 style="margin-top:0;">Summary</h4>
            <table style="width:100%;font-size:1.05em;">
              <tr><th></th><th>Human</th><th>Bot</th></tr>
              <tr><td>Mean RT (ms)</td><td>${mean(humanRTs)}</td><td>${mean(botRTs)}</td></tr>
              <tr><td>Accuracy</td><td>${(humanAcc*100).toFixed(0)}%</td><td>${(botAcc*100).toFixed(0)}%</td></tr>
              <tr><td>Stroop Effect (ms)</td><td>${(mean(humanIncongRTs)-mean(humanCongRTs)).toFixed(1)}</td><td>${(mean(botIncongRTs)-mean(botCongRTs)).toFixed(1)}</td></tr>
              <tr><td>RT Std Dev (ms)</td><td>${std(humanRTs).toFixed(1)}</td><td>${std(botRTs).toFixed(1)}</td></tr>
              <tr><td>Coeff of Variation</td><td>${cv(humanRTs)}%</td><td>${cv(botRTs)}%</td></tr>
              <tr><td>RT Skewness</td><td>${skew(humanRTs).toFixed(2)}</td><td>${skew(botRTs).toFixed(2)}</td></tr>
            </table>
          </div>
          <div style="flex:2;min-width:320px;background:#fff;padding:18px 18px 18px 18px;border-radius:8px;">
            <h4 style="margin-top:0;">Trial-by-Trial RTs</h4>
            <canvas id="stroop-rt-chart" width="420" height="180"></canvas>
          </div>
        </div>
        <div style="display:flex;gap:30px;justify-content:center;margin-top:1.5em;">
          <div style="flex:1;min-width:320px;background:#fff;padding:18px 18px 18px 18px;border-radius:8px;">
            <h4 style="margin-top:0;">RT Distribution</h4>
            <canvas id="stroop-dist-chart" width="420" height="180"></canvas>
          </div>
          <div style="flex:1;min-width:320px;background:#fff;padding:18px 18px 18px 18px;border-radius:8px;">
            <h4 style="margin-top:0;">Congruency Effect</h4>
            <canvas id="stroop-cong-chart" width="420" height="180"></canvas>
          </div>
        </div>
        <div style="margin-top:1.5em;text-align:left;">
          <h4>Trial Table</h4>
          <table style="width:100%;font-size:0.98em;border-collapse:collapse;">
            <tr style="background:#f1f1f1;"><th>Trial</th><th>Type</th><th>Word</th><th>Color</th><th>Human RT</th><th>Human Correct</th><th>Bot RT</th><th>Bot Correct</th></tr>
            ${trials.map((t,i) => `
              <tr${i%2===0?' style=\"background:#fafbfc;\"':''}>
                <td>${i+1}</td>
                <td>${t.congruent?'Congruent':'Incongruent'}</td>
                <td>${t.word.toUpperCase()}</td>
                <td style=\"color:${COLOR_HEX[t.color]};font-weight:bold;\">${t.color.toUpperCase()}</td>
                <td>${humanData[i]?.rt?.toFixed(0) ?? '-'}</td>
                <td>${humanData[i]?.correct ? '✔️' : '❌'}</td>
                <td>${botData[i]?.rt?.toFixed(0) ?? '-'}</td>
                <td>${botData[i]?.correct ? '✔️' : '❌'}</td>
              </tr>
            `).join('')}
          </table>
        </div>
        `;
        
        // Draw RT chart
        const ctx = document.getElementById('stroop-rt-chart').getContext('2d');
        ctx.clearRect(0,0,420,180);
        // Axes
        ctx.beginPath();
        ctx.moveTo(40,10); ctx.lineTo(40,160); ctx.lineTo(410,160);
        ctx.strokeStyle = '#888'; ctx.lineWidth = 1; ctx.stroke();
        
        // Scale to show both human and bot RTs clearly
        const maxRT = Math.max(...humanRTs, ...botRTs);
        const yScale = 150 / maxRT;
        
        // Human RTs
        ctx.beginPath();
        ctx.moveTo(40,160-(humanData[0]?.rt||0)*yScale);
        humanData.forEach((d,i) => {
          ctx.lineTo(40+((370/(N_TRIALS-1))*i), 160-(d.rt*yScale));
        });
        ctx.strokeStyle = '#007bff'; ctx.lineWidth = 2; ctx.stroke();
        
        // Bot RTs
        ctx.beginPath();
        ctx.moveTo(40,160-(botData[0]?.rt||0)*yScale);
        botData.forEach((d,i) => {
          ctx.lineTo(40+((370/(N_TRIALS-1))*i), 160-(d.rt*yScale));
        });
        ctx.strokeStyle = '#28a745'; ctx.lineWidth = 2; ctx.stroke();
        
        // Labels
        ctx.fillStyle = '#000'; ctx.font = '12px sans-serif';
        ctx.fillText('Trial', 200, 175);
        ctx.save(); ctx.translate(10,100); ctx.rotate(-Math.PI/2);
        ctx.fillText('RT (ms)', 0, 0); ctx.restore();
        ctx.fillStyle = '#007bff'; ctx.fillRect(350,20,10,2); ctx.fillStyle = '#000'; ctx.fillText('Human', 365, 25);
        ctx.fillStyle = '#28a745'; ctx.fillRect(350,35,10,2); ctx.fillStyle = '#000'; ctx.fillText('Bot', 365, 40);
        
        // Draw distribution chart
        const distCtx = document.getElementById('stroop-dist-chart').getContext('2d');
        distCtx.clearRect(0,0,420,180);
        // Axes
        distCtx.beginPath();
        distCtx.moveTo(40,10); distCtx.lineTo(40,160); distCtx.lineTo(410,160);
        distCtx.strokeStyle = '#888'; distCtx.lineWidth = 1; distCtx.stroke();
        
        // Create histogram bins
        const binCount = 10;
        const binSize = maxRT / binCount;
        const humanBins = new Array(binCount).fill(0);
        const botBins = new Array(binCount).fill(0);
        
        humanRTs.forEach(rt => {
          const bin = Math.min(Math.floor(rt/binSize), binCount-1);
          humanBins[bin]++;
        });
        botRTs.forEach(rt => {
          const bin = Math.min(Math.floor(rt/binSize), binCount-1);
          botBins[bin]++;
        });
        
        const maxBin = Math.max(...humanBins, ...botBins);
        const binScale = 150 / maxBin;
        
        // Draw histograms
        humanBins.forEach((count, i) => {
          const x = 40 + (i * 370/binCount);
          const width = 370/binCount - 2;
          const height = count * binScale;
          distCtx.fillStyle = '#007bff';
          distCtx.fillRect(x, 160-height, width, height);
        });
        
        botBins.forEach((count, i) => {
          const x = 40 + (i * 370/binCount);
          const width = 370/binCount - 2;
          const height = count * binScale;
          distCtx.fillStyle = '#28a745';
          distCtx.fillRect(x, 160-height, width, height);
        });
        
        // Labels
        distCtx.fillStyle = '#000'; distCtx.font = '12px sans-serif';
        distCtx.fillText('RT (ms)', 200, 175);
        distCtx.save(); distCtx.translate(10,100); distCtx.rotate(-Math.PI/2);
        distCtx.fillText('Count', 0, 0); distCtx.restore();
        
        // Draw congruency effect chart
        const congCtx = document.getElementById('stroop-cong-chart').getContext('2d');
        congCtx.clearRect(0,0,420,180);
        // Axes
        congCtx.beginPath();
        congCtx.moveTo(40,10); congCtx.lineTo(40,160); congCtx.lineTo(410,160);
        congCtx.strokeStyle = '#888'; congCtx.lineWidth = 1; congCtx.stroke();
        
        // Draw bars
        const barWidth = 80;
        const spacing = 40;
        const startX = 40 + (410-40-2*barWidth-spacing)/2;
        
        // Human bars
        congCtx.fillStyle = '#007bff';
        congCtx.fillRect(startX, 160-mean(humanCongRTs)*yScale, barWidth, mean(humanCongRTs)*yScale);
        congCtx.fillRect(startX+barWidth+spacing, 160-mean(humanIncongRTs)*yScale, barWidth, mean(humanIncongRTs)*yScale);
        
        // Bot bars
        congCtx.fillStyle = '#28a745';
        congCtx.fillRect(startX, 160-mean(botCongRTs)*yScale, barWidth, mean(botCongRTs)*yScale);
        congCtx.fillRect(startX+barWidth+spacing, 160-mean(botIncongRTs)*yScale, barWidth, mean(botIncongRTs)*yScale);
        
        // Labels
        congCtx.fillStyle = '#000'; congCtx.font = '12px sans-serif';
        congCtx.fillText('Congruent', startX+barWidth/2-30, 175);
        congCtx.fillText('Incongruent', startX+barWidth+spacing+barWidth/2-40, 175);
        congCtx.save(); congCtx.translate(10,100); congCtx.rotate(-Math.PI/2);
        congCtx.fillText('RT (ms)', 0, 0); congCtx.restore();
        
        // Add legend
        congCtx.fillStyle = '#007bff'; congCtx.fillRect(350,20,10,2); congCtx.fillStyle = '#000'; congCtx.fillText('Human', 365, 25);
        congCtx.fillStyle = '#28a745'; congCtx.fillRect(350,35,10,2); congCtx.fillStyle = '#000'; congCtx.fillText('Bot', 365, 40);
      }
      // --- Trial Logic ---
      function nextTrial() {
        if (trialIdx >= N_TRIALS) {
          running = false;
          resetBtns();
          clearWords();
          stroopStartBtn.disabled = false;
          stroopStartBtn.textContent = 'Restart Trials';
          stroopResults.style.display = '';
          showResults();
          return;
        }
        setTrialLabels(trialIdx);
        const t = trials[trialIdx];
        setWord(humanWord, t.word, t.color);
        setWord(botWord, t.word, t.color);
        enableHumanBtns(true);
        humanStartTime = performance.now();
        // Bot response (superhuman: always correct, no interference, fixed fast RT)
        botTimeout = setTimeout(() => {
          botData.push({
            rt: BOT_DELAY,
            correct: true,
            congruent: t.congruent
          });
          // Visual feedback (flash correct button)
          const btnId = `bot-btn-${t.color}`;
          const btn = document.getElementById(btnId);
          btn.style.background = '#28a745';
          btn.style.color = '#fff';
          setTimeout(() => {
            btn.style.background = '#f1f1f1';
            btn.style.color = '#aaa';
          }, 250);
        }, BOT_DELAY);
      }
      function handleHumanBtn(color) {
        if (!running) return;
        enableHumanBtns(false);
        const t = trials[trialIdx];
        const rt = performance.now() - humanStartTime;
        const correct = color === t.color;
        humanData.push({ rt, correct, congruent: t.congruent });
        // Visual feedback
        const btnId = `human-btn-${color}`;
        const btn = document.getElementById(btnId);
        btn.style.background = correct ? '#28a745' : '#dc3545';
        btn.style.color = '#fff';
        setTimeout(() => {
          btn.style.background = '#e9ecef';
          btn.style.color = '#222';
        }, 250);
        // Next trial
        setTimeout(() => {
          trialIdx++;
          nextTrial();
        }, 350);
      }
      // --- Event Listeners ---
      HUMAN_BTN_IDS.forEach((id, idx) => {
        document.getElementById(id).addEventListener('click', () => handleHumanBtn(COLORS[idx]));
      });
      stroopStartBtn.addEventListener('click', () => {
        if (running) {
          // Stop the trials
          running = false;
          stroopStartBtn.textContent = 'Start Bot';
          stroopStartBtn.classList.remove('btn-danger');
          stroopStartBtn.classList.add('btn-primary');
          if (botTimeout) {
            clearTimeout(botTimeout);
            botTimeout = null;
          }
          resetBtns();
        } else {
          // Start the trials
          running = true;
          trialIdx = 0;
          humanData = [];
          botData = [];
          trials = makeTrials(N_TRIALS); // FIX: generate trials before starting
          stroopResults.style.display = 'none'; // Hide results on new run
          stroopStartBtn.textContent = 'Stop Bot';
          stroopStartBtn.classList.remove('btn-primary');
          stroopStartBtn.classList.add('btn-danger');
          nextTrial();
        }
      });
      stroopResetBtn.addEventListener('click', () => {
        running = false;
        resetBtns();
        clearWords();
        stroopStartBtn.disabled = false;
        stroopStartBtn.textContent = 'Start Bot';
        trials = makeTrials(N_TRIALS); // FIX: regenerate trials on reset
        humanData = [];
        botData = [];
        trialIdx = 0;
        stroopResults.style.display = 'none'; // Hide results on reset
      });
      // On load, reset
      clearWords();
      resetBtns();
      trials = makeTrials(N_TRIALS); // FIX: initialize trials on load
    })();
    </script>
    -->

    <p>The Stroop and other canonical experimental paradigms provide an additional obstacle to AI agents. To completely replicate human cognitive psychology, an AI agent would not only need to simulate our cognitive outputs, but our cognitive processes as well. These processes are a function of our neural and environment constraints. While someone can easily create a Stroop Bot that replicates human biases, fully replicating end-to-end human processing is a hard and unsolved problem.</p>

    <a href="#section-4" id="section-4"><span>4</span></a>
    <!-- <h2>Discussion</h2> -->

    <!-- <p>Concluding, the Turing Test is a foundational problem in computer science, artificial intelligence, and the philosophy of mind. Given the recent rise of AI systems, renewed interest in the Turing Test — and bot detection — is highly relevant for Internet security today.</p> -->

    <p>We first started identifying bots in graduate school for online data collection and model training. We would create simple tasks that humans could complete but bots would struggle with. One example was the Boston Temperature Test: guessing the twelve monthly average high temperatures in Boston.</p>

    <p>Humans err in predictable ways but follow macro seasonal patterns, whereas bots and AI agents were either completely random or too perfect. Figure 5 plots the individual user curves estimated for each agent type.</p>

    <figure>
      <img src="https://research.roundtable.ai/proof-of-human/temp-plots-v3.png" alt="Temperature plots showing human vs bot responses"/>
      <figcaption><b>Figure 5:</b> User temperature estimates grouped by agent type. Black line shows ground truth. Humans err in predictable ways but follow macro seasonal patterns, whereas bots and AI agents were completely random or too perfect.</figcaption>
    </figure>
    
    <p>Once we have a mapping between agent type and temperature estimates, we can use it to create a confidence score for any given user.</p>
  
    <p>While we can&#39;t bombard Internet users with experimental stimuli (e.g. Stroop or the traditional CAPTCHA <d-cite key="von2003captcha"></d-cite>), we <em>can</em> measure similar patterns across normal web interactions. For example, we can collect keystroke dynamics for users, bootstrap an initial dataset with artificial lab experiments like the Stroop or the Boston Temperature Test, and then create a direct mapping between keystroke dynamics and proof-of-human (Figure 6).</p>
      
      <!-- Human processing patterns are not restricted to artificial lab experiments, but manifest in real-life as digital environment micro-interactions.    -->

    <figure>
      <img src="https://research.roundtable.ai/proof-of-human/typing_hq.gif" alt="Keystroke dynamics analysis showing human vs bot typing patterns"/>
      <figcaption><b>Figure 6:</b> Keystroke dynamics analysis demonstrating the mapping between typing patterns and proof-of-human verification.</figcaption>
    </figure>

    <p>Similar detection logic can be applied using other behavioral patterns like mouse movement, click behavior, and scroll tracking or even more cognitively demanding stimuli like those that appear on an e-commerce site or a React app.</p>


<p>We offer this behavioral and cognitive approach for bot detection and cybersecurity. Rather than focus on privacy invasive methods like biometrics scans or cookie tracking, the Roundtable <a href="https://www.roundtable.ai">Proof-of-Human API</a> presents online agents an economic challenge: replicate the full range of human cognition naturally and continuously.</p>
  
  </div></div>
  </body>
</html>
