<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://remyhax.xyz/posts/golang-packet-editing/">Original</a>
    <h1>Packet-Editing Games in Golang (2021)</h1>
    
    <div id="readability-page-1" class="page"><div><figure><img src="https://remyhax.xyz/image/feature-packetediting.jpg"/></figure><p>It’s easy to set up an IDS or other infrastructure to drop packets that match rules. There are many tools for real-time inspection of connections that can handle higher level protocols like HTTP or TLS. This article aims to go a bit lower and address how to <em>edit</em> packets in flight. We’ll be looking at it through the lens of editing packets for a game using Golang.</p><p>Some basic guidelines / personal policy:</p><ul><li><strong>This is not a guide of how to cheat at online games and should not be used as such.</strong></li><li>There are plenty of old multiplayer games that have been lost to the tides of time with copyright’s long expired that are perfect for learning how they work.</li><li>Examples as shown are editing packets Server –&gt; Client. Any changes to client state could be done much easier using <a href="https://www.cheatengine.org/">Cheat Engine</a> etc…</li><li>No modified/forged packets are sent from Client –&gt; Server in any examples. There is a very obvious reason for this.</li><li><strong>Cheating ruins games for others and yourself.</strong></li></ul><p>With that out of the way, let’s get started:</p><p>If you’re interested in more projects like this, give me a follow on Twitter <a href="https://twitter.com/_mattata">@_mattata</a>. I’m always working on something fun.</p><p>You should generally be familiar with Wireshark, general networking, and Go.</p><p>For ease of use and a controlled environment, I usually start by downloading a Ubuntu Desktop ISO and spin up a Virtual machine in VirtualBox.</p><p>I’ll add a USB filter to expose a Wireless USB to the VM
<img src="https://remyhax.xyz/packetediting/usb.PNG" alt="USB Filter)"/></p><p>Then I’ll use the “Create Hotspot” function to create a wireless AP hosted through the VM
<img src="https://remyhax.xyz/packetediting/hotspot.PNG" alt="Hotspot)"/></p><p>You could of course also do this with a custom DHCP setup with IP Forwarding and maybe even a selective VPN. I’m lazy, so I do this because it takes 3 clicks and I’m done. The main idea is to be able to route traffic through the VM. However you want to accomplish that is up to you.</p><p>Here is a simple example that will route packets from TCP source port 9999 into nfqueue 0. The Go code will trigger a callback when a packet enters the queue which allows us to modify the data using the gopacket library. Once we are done with the packet, we can issue a verdict to allow the modified packet out of the queue and continue on to it’s destination.</p><p>In this case, we’re looking for packets containing “magic string” which we will replace with “modified value”</p><div><pre><code data-lang="go"><span>package</span> <span>main</span>

<span>import</span> (
	<span>&#34;bytes&#34;</span>
	<span>&#34;encoding/hex&#34;</span>
	<span>&#34;fmt&#34;</span>
	<span>&#34;io/ioutil&#34;</span>
	<span>&#34;log&#34;</span>
	<span>&#34;os&#34;</span>
	<span>&#34;os/exec&#34;</span>
	<span>&#34;os/signal&#34;</span>
	<span>&#34;strings&#34;</span>
	<span>&#34;syscall&#34;</span>

	<span>&#34;github.com/chifflier/nfqueue-go/nfqueue&#34;</span>

	<span>&#34;github.com/sergi/go-diff/diffmatchpatch&#34;</span>

	<span>&#34;github.com/google/gopacket&#34;</span>
	<span>&#34;github.com/google/gopacket/layers&#34;</span>
)

<span>func</span> <span>realCallback</span>(<span>payload</span> <span>*</span><span>nfqueue</span>.<span>Payload</span>) <span>int</span> {
	<span>// Decode a packet
</span><span></span>	<span>packet</span> <span>:=</span> <span>gopacket</span>.<span>NewPacket</span>(<span>payload</span>.<span>Data</span>, <span>layers</span>.<span>LayerTypeIPv4</span>, <span>gopacket</span>.<span>Default</span>)
	<span>// Get the TCP layer from this packet
</span><span></span>	<span>if</span> <span>tcpLayer</span> <span>:=</span> <span>packet</span>.<span>Layer</span>(<span>layers</span>.<span>LayerTypeTCP</span>); <span>tcpLayer</span> <span>!=</span> <span>nil</span> {
		<span>// Get actual TCP data from this layer
</span><span></span>		<span>tcp</span>, <span>_</span> <span>:=</span> <span>tcpLayer</span>.(<span>*</span><span>layers</span>.<span>TCP</span>)
		<span>fmt</span>.<span>Printf</span>(<span>&#34;From src port %d to dst port %d\n&#34;</span>, <span>tcp</span>.<span>SrcPort</span>, <span>tcp</span>.<span>DstPort</span>)
	}
	<span>//Log Initial State
</span><span></span>	<span>fmt</span>.<span>Printf</span>(<span>&#34;  id: %d\n&#34;</span>, <span>payload</span>.<span>Id</span>)
	<span>fmt</span>.<span>Println</span>(<span>hex</span>.<span>Dump</span>(<span>payload</span>.<span>Data</span>))
	<span>if</span> <span>app</span> <span>:=</span> <span>packet</span>.<span>ApplicationLayer</span>(); <span>app</span> <span>!=</span> <span>nil</span> {
		<span>if</span> <span>strings</span>.<span>Contains</span>(string(<span>app</span>.<span>Payload</span>()), <span>&#34;magic string&#34;</span>) {
			<span>// modify payload of application layer
</span><span></span>			<span>*</span><span>packet</span>.<span>ApplicationLayer</span>().(<span>*</span><span>gopacket</span>.<span>Payload</span>) = <span>bytes</span>.<span>ReplaceAll</span>(<span>app</span>.<span>Payload</span>(), []byte(<span>&#34;magic string&#34;</span>), []byte(<span>&#34;modified value&#34;</span>))
			<span>// if its tcp we need to tell it which network layer is being used
</span><span></span>			<span>// to be able to handle multiple protocols we can add a if clause around this
</span><span></span>			<span>packet</span>.<span>TransportLayer</span>().(<span>*</span><span>layers</span>.<span>TCP</span>).<span>SetNetworkLayerForChecksum</span>(<span>packet</span>.<span>NetworkLayer</span>())

			<span>buffer</span> <span>:=</span> <span>gopacket</span>.<span>NewSerializeBuffer</span>()
			<span>options</span> <span>:=</span> <span>gopacket</span>.<span>SerializeOptions</span>{
				<span>ComputeChecksums</span>: <span>true</span>,
				<span>FixLengths</span>:       <span>true</span>,
			}

			<span>// Serialize Packet to get raw bytes
</span><span></span>			<span>if</span> <span>err</span> <span>:=</span> <span>gopacket</span>.<span>SerializePacket</span>(<span>buffer</span>, <span>options</span>, <span>packet</span>); <span>err</span> <span>!=</span> <span>nil</span> {
				<span>log</span>.<span>Fatalln</span>(<span>err</span>)
			}

			<span>packetBytes</span> <span>:=</span> <span>buffer</span>.<span>Bytes</span>()
			
			<span>//Pretty color diff on the hexdump
</span><span></span>			<span>dmp</span> <span>:=</span> <span>diffmatchpatch</span>.<span>New</span>()
			<span>diffs</span> <span>:=</span> <span>dmp</span>.<span>DiffMain</span>(<span>hex</span>.<span>Dump</span>(<span>payload</span>.<span>Data</span>), <span>hex</span>.<span>Dump</span>(<span>packetBytes</span>), <span>true</span>)
			<span>fmt</span>.<span>Println</span>(<span>dmp</span>.<span>DiffPrettyText</span>(<span>diffs</span>))
			<span>//Set the packet verdict as modified
</span><span></span>			<span>payload</span>.<span>SetVerdictModified</span>(<span>nfqueue</span>.<span>NF_ACCEPT</span>, <span>packetBytes</span>)
			<span>return</span> <span>0</span>
		}
	}
	<span>fmt</span>.<span>Println</span>(<span>&#34;-- &#34;</span>)
	<span>payload</span>.<span>SetVerdict</span>(<span>nfqueue</span>.<span>NF_ACCEPT</span>)
	<span>return</span> <span>0</span>
}

<span>func</span> <span>main</span>() {
	<span>//Create go nfqueue
</span><span></span>	<span>q</span> <span>:=</span> new(<span>nfqueue</span>.<span>Queue</span>)
	<span>//Set callback for queue
</span><span></span>	<span>q</span>.<span>SetCallback</span>(<span>realCallback</span>)
	<span>//Initialize queue
</span><span></span>	<span>q</span>.<span>Init</span>()
	<span>//Generic reset for bind
</span><span></span>	<span>q</span>.<span>Unbind</span>(<span>syscall</span>.<span>AF_INET</span>)
	<span>q</span>.<span>Bind</span>(<span>syscall</span>.<span>AF_INET</span>)
	<span>//Create nfqueue &#34;0&#34;
</span><span></span>	<span>q</span>.<span>CreateQueue</span>(<span>0</span>)

	<span>//Set iptables rule to route packets from sourc eport 9999 to queue number 0
</span><span></span>	<span>cmd</span> <span>:=</span> <span>exec</span>.<span>Command</span>(<span>&#34;iptables&#34;</span>, <span>&#34;-t&#34;</span>, <span>&#34;raw&#34;</span>, <span>&#34;-A&#34;</span>, <span>&#34;PREROUTING&#34;</span>, <span>&#34;-p&#34;</span>, <span>&#34;tcp&#34;</span>, <span>&#34;--source-port&#34;</span>, <span>&#34;9999&#34;</span>, <span>&#34;-j&#34;</span>, <span>&#34;NFQUEUE&#34;</span>, <span>&#34;--queue-num&#34;</span>, <span>&#34;0&#34;</span>)
	<span>stdout</span>, <span>err</span> <span>:=</span> <span>cmd</span>.<span>Output</span>()

	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
		<span>fmt</span>.<span>Println</span>(<span>err</span>.<span>Error</span>())
		<span>return</span>
	} <span>else</span> {
		<span>fmt</span>.<span>Println</span>(string(<span>stdout</span>))
	}

	<span>//Listener for CNTRL+C
</span><span></span>	<span>c</span> <span>:=</span> make(<span>chan</span> <span>os</span>.<span>Signal</span>, <span>1</span>)
	<span>signal</span>.<span>Notify</span>(<span>c</span>, <span>os</span>.<span>Interrupt</span>)
	<span>log</span>.<span>SetOutput</span>(<span>ioutil</span>.<span>Discard</span>)
	<span>go</span> <span>func</span>() {
		<span>for</span> <span>sig</span> <span>:=</span> <span>range</span> <span>c</span> {
			<span>// sig is a ^C, handle it
</span><span></span>			<span>_</span> = <span>sig</span>
			<span>q</span>.<span>StopLoop</span>()
		}
	}()

	<span>// XXX Drop privileges here
</span><span></span>
	<span>q</span>.<span>Loop</span>()
	<span>q</span>.<span>DestroyQueue</span>()
	<span>q</span>.<span>Close</span>()

	<span>//Remove iptables rules that route packets into nfqueue
</span><span></span>	<span>unroute</span> <span>:=</span> <span>exec</span>.<span>Command</span>(<span>&#34;iptables&#34;</span>, <span>&#34;-F&#34;</span>, <span>&#34;-t&#34;</span>, <span>&#34;raw&#34;</span>)
	<span>stdoutUnroute</span>, <span>err</span> <span>:=</span> <span>unroute</span>.<span>Output</span>()

	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
		<span>fmt</span>.<span>Println</span>(<span>err</span>.<span>Error</span>())
		<span>return</span>
	} <span>else</span> {
		<span>fmt</span>.<span>Println</span>(string(<span>stdoutUnroute</span>))
	}

	<span>os</span>.<span>Exit</span>(<span>0</span>)
}</code></pre></div><p>So let’s see it in action eh? You’ll need libnetfilter-queue-dev installed in order to compile.</p><p>Outside of the VM, open a netcat listener on port 9999</p><p><code>nc -vvv -l 192.168.8.154 9999</code></p><p>Now, from inside the VM open a terminal and connect to the netcat listener outside the VM:</p><p><code>nc -vvv 192.168.8.154</code></p><p>We’ll type the string “hello” and see that it goes through without issue.</p><p>Then we’ll type the string “magic string” and note that is is modified in flight.</p><p><img src="https://remyhax.xyz/packetediting/basic.PNG" alt="Basic"/></p><p>The packet was modified because it had a source port of 9999, was routed into nfqueue 0, and contained the string “magic string”, so we replaced it before allowing it to continue to it’s destination.</p><p>Games have text too! But it’s typically embedded in a custom protocol.</p><p><img src="https://remyhax.xyz/packetediting/chatbox.jpg" alt="Chatbox"/></p><pre><code>00000070  00 0a 7c d9 e7 00 06 00  37 02 7b 00 12 46 61 74  |..|.....7.{..Fat|
00000080  68 65 72 20 41 65 72 65  63 6b 00 00 e7 00 03 a3  |her Aereck......|
00000090  00 2d 57 65 6c 63 6f 6d  65 20 74 6f 20 74 68 65  |.-Welcome to the|
000000a0  20 63 68 75 72 63 68 20  6f 66 20 68 6f 6c 79 20  | church of holy |
000000b0  53 61 72 61 64 6f 6d 69  6e 2e 00 00 e7 00 05 a0  |Saradomin.......
</code></pre><p>Let’s see if we can replace the characters name “Father Aereck” with “Remy”</p><div><pre><code data-lang="go"><span>// modify payload of application layer
</span><span></span><span>*</span><span>packet</span>.<span>ApplicationLayer</span>().(<span>*</span><span>gopacket</span>.<span>Payload</span>) = <span>bytes</span>.<span>ReplaceAll</span>(<span>app</span>.<span>Payload</span>(), []byte(<span>&#34;Father Aereck&#34;</span>), []byte(<span>&#34;REMY&#34;</span>))</code></pre></div><p><img src="https://remyhax.xyz/packetediting/connectionlost.jpg" alt="Connection lost"/></p><p>We can see that the bytes were replaced, but the game client glitched out. What happened?</p><p>The client reset because the custom protocol used for it couldn’t be parsed correctly! Even outside of editing packets, most protocols will have error handling for situations like this. Packet errors <strong>absolutely do</strong> occur in the real world.</p><p><strong>But why wasn’t the protocol parsed correctly? All we did was change some text!</strong></p><p>Incorrect! We changed the text <strong>and the length of the text</strong>. Unless you’re dealing with a text based protocol, you’ll usually encounter something called <a href="https://en.wikipedia.org/wiki/Type%E2%80%93length%E2%80%93value">TLV</a> in binary protocols.</p><p>We’re dealing with a binary protocol now, not a text based protocol like a simple netcat pipe.</p><p>The type and length are fixed in size (typically 1-4 bytes), and the value field is of variable size. These fields are used as follows:</p><ul><li>Type</li><li><ul><li>A binary code, often simply alphanumeric, which indicates the kind of field that this part of the message represents;</li></ul></li><li>Length</li><li><ul><li>The size of the value field (typically in bytes);</li></ul></li><li>Value</li><li><ul><li>Variable-sized series of bytes which contains data for this part of the message.</li></ul></li></ul><p><em>For a crash course on the subject of reverse engineering protocols, I recommend watching <a href="https://www.youtube.com/watch?v=FKbVNXnR10A">PancakesCon 2 - netspooky - Reverse Engineering &amp; ASCII Art For Beginners</a></em></p><h2 id="attempt-2">Attempt 2</h2><p>This time, we’re going to replace the text, but we’re going to pad the replaced text so that it matches the same length of the original value using spaces</p><div><pre><code data-lang="go"><span>//OLD
</span><span>//bytes.ReplaceAll(app.Payload(), []byte(&#34;Father Aereck&#34;), []byte(&#34;REMY&#34;))
</span><span>//New
</span><span></span><span>bytes</span>.<span>ReplaceAll</span>(<span>app</span>.<span>Payload</span>(), []byte(<span>&#34;Father Aereck&#34;</span>), []byte(<span>&#34;REMY         &#34;</span>))</code></pre></div><p><img src="https://remyhax.xyz/packetediting/remy.jpg" alt="success"/></p><p>Success! We can rewrite the text of an NPC.</p><p>Start looking into where the <em>Length</em> (L) value is defined in the protocol so that you don’t need to arbitrarily pad the <em>Value</em> (V). Once you know the format of the L and V, you might start playing with different <em>Types</em> (T).</p><p>From there, you’re well on your way to understanding how things work behind the scenes.</p><p>This will of course require staring at hex output, but there are tools that make it much easier. A method called “differential analysis” can be used to narrow down specific pieces of a protocol so that they are easier to understand.</p><p>A useful tool for this is <a href="https://github.com/netspooky/pdiff">pDiff</a> which is demoed in the PancakesCon youtube video linked above.</p><p>You can also use a WebAssembly implementation in-browser that I wrote here: <a href="https://remyhax.xyz/tools/pdiffwasm/">https://remyhax.xyz/tools/pdiffwasm/</a></p><p>The setup I use with a hosted Wifi AP allows packet editing for anything with WiFi support which keeps it versatile. iPhone, Android, Playstation, XBOX, Nintendo, etc…</p><p>The examples above explicitly modify packets destined for the client. You probably aren’t allowed to (and shouldn’t!) modify packets destined to the server.</p><p>Again, and I cannot be any more explicit about this:</p><ul><li>Cheating ruins games for everyone. Don’t do it.</li><li><a href="https://archive.org/">Archive.org</a> has tons of old games you can <em>self host</em> to poke around.</li><li>Don’t mess with servers you don’t own or manage.</li></ul><p>That being said, dissecting and playing with protocols is extremely fun.</p><p>Dissect the protocol because it’s fun.</p><p>Play the games because they’re fun.</p><p>Don’t mix those two.</p><p>-remy</p></div></div>
  </body>
</html>
