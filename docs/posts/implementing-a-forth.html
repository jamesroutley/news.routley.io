<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ratfactor.com/forth/implementing">Original</a>
    <h1>Implementing a Forth</h1>
    
    <div id="readability-page-1" class="page"><article>
        <header>
            
            
            
            
            
            
                <p>Page created: <span>2025-05-28</span></p>
            
            
                <p>Updated: <span>2025-05-30</span></p>
                
            
            
        </header>

        
        
<img src="https://ratfactor.com/forth/talkimg/dec_pdp_11.png" alt="drawing of chuck using a DEC PDP-11 computer by dave gauer in krita"/>

<p>I’ve made a couple Forths. Not a single one of them are &#34;finished software&#34;
intended for industrial use, but <em>all</em> of them taught me something about Forth,
concatenative programming, and how computers work in general.</p>
<p>Sure, I’ve done my time in that place where points are free and the stacks
always need twiddling. But what about you?</p>
<p>You’re thinking about making a Forth yourself, aren’t you? Of course you are.
The call is irresistable. I know that.</p>
<p>The only thing holding you back is uncertaintly.</p>
<p>You’re thinking, where do I start? How much Forth should I make? How do I know
when I’m done?</p>
<p><em>(Here, all of it, and you don’t.)</em></p>
<p>But here are three things to consider.</p>
<div>
<h2 id="_1_consider_porting_an_existing_forth">1. Consider porting an existing Forth</h2>
<div>
<p>The first Forth I made was a port of JONESFORTH by Richard WM Jones. I found
it through…​</p>

<p>…​which lead me to…​</p>

<p><img src="https://ratfactor.com/nasmjf/nasmjf.png" alt="my gold on gray logo for nasmjf"/></p>
<p>The beauty of many Forths is that they contain a core Forth written in a host
language (or machine code) and then the rest of the language features are
implemented in…​Forth!</p>
<p>Knowing when I had completed my port was easy - I was done when
my ported assembly half of JonesForth could run the Forth half
of JonesForth.</p>
<p>Here’s the Forth half of JonesForth:
<a href="https://ratfactor.com/repos/nasmjf/html/jonesforth/jonesforth.f.html">jonesforth.f</a></p>
<p>I think porting software is a pretty amazing way to learn
about a program and especially a language implementation. Here’s a card:
<a href="https://ratfactor.com/cards/porting-software">Porting Software</a>.
(At the moment, it’s somewhat redundant with the page you’re reading, but it
will probably get a lot more interesting when I do my next port, whatever that
ends up being. Hint: probably a Sed.)</p>
</div>
</div>
<div>
<h2 id="_2_consider_making_an_ultra_tiny_forth_core">2. Consider making an ultra-tiny Forth core</h2>
<div>
<p>I think one of the most interesting questions in the Forth universe is
<em>how small can its core be?</em></p>
<p>Which is to say, how few words do you need to
implement in a host language (or raw machine code, as we’ll see) before you can bootstrap
the rest of the language in the Forth itself?</p>

<p>(The most popular one I’ve seen is SUBLEQ, which stands for &#34;SUBtract, branch
if Less than/EQual to zero&#34;. And since there’s only one, you typically omit it
and your program is just the operands for the implied instruction. The
&#34;language&#34;, then, has <em>no</em> operations and feels to me like the computing
equivalent of John Cage’s musical stunt
<a href="https://en.wikipedia.org/wiki/4%E2%80%B233%E2%80%B3">4&#39;33&#34;</a> (wikipedia.org).)</p>
<p>So I guess a Forth with <strong>one</strong> word is all you need.</p>
<p>Therefore, it’s not a question of, &#34;How few words would be <em>possible</em>?&#34; but
rather, &#34;How few words would be <em>interesting</em>?&#34;</p>
<p>The answer will be personal to you.</p>
<p>The Forth-eV Wiki’s page on <strong>&#34;Minimal Word Set&#34;</strong> is a great place to start:</p>

<p>In addition to the word set, you can also constrain the total file weight of your
core Forth. (Or lines of source or some other arbitary limitation.)</p>
<p>Some really intriguing minimal Forths I’ve encountered:</p>
<div>
<h3 id="_planckforth">PlanckForth</h3>

<p>I love the hexdump visualization of Koichi Nakamura’s PlanckForth:</p>
<p><img src="https://ratfactor.com/forth/talkimg/planckforth.jpg" alt="binary layout of planckforth as taken from the repo"/></p><p>You’re looking at a complete working Forth implementation in the form of a
hand-written ELF binary in less than 1,000 bytes. The rest of PlanckForth is
written in PlanckForth to implement a &#34;normal&#34; Forth.</p>
</div>
<div>
<h3 id="_smithforth">SmithForth</h3>

<p>David Smith’s SmithForth is another 1,000 byte, hand-written machine code Forth
that bootstraps a more complete Forth.</p>
<div>
<blockquote>
<p>&#34;My goal with SmithForth is not to stop writing machine code early, but to
start writing Forth early.&#34;</p>
</blockquote>
</div>
<p>I love tiny Forths!</p>
</div>
<div>
<h3 id="_sectorforth">sectorforth</h3>

<p>Cesar Blum’s sectorforth is even smaller, at 512 bytes (the size of a boot sector).</p>
<p>Like other ultra-tiny Forths, it starts with just a handful of Forth primitives
with which to bootstrap higher-level constructs.</p>
<p>The included <code>01-helloworld.f</code> example is 200 lines of well-commented Forth
source which starts with making numbers, implements a core of standard
Forth words, and then prints &#34;Hello world&#34;.</p>
<p>I imagine this is how Ents talk.</p>
<div>
<blockquote>
<p><em>&#34;As soon as the whole company was assembled, standing in a wide
circle round Treebeard, a curious and unintelligible conversation
began.&#34;</em> --JRR Tolkein, The Two Towers</p>
</blockquote>
</div>
</div>
<div>
<h3 id="_milliforth">milliForth</h3>

<p>512 bytes too much for you? How about 336? By my count, fuzzballcat’s
milliFORTH implements 11 words and it can do anything, just, you know,
<em>painfully</em>. The &#34;Hello World&#34; is 53 lines of pain.</p>
</div>
<div>
<h3 id="_stoneknifeforth">StoneKnifeForth</h3>

<p>Not just a hand-written Forth binary, but <em>also</em> a metacircular compiler,
Kragen Javier Sitaker’s StoneKnifeForth source comes to a total of 1,902
essential bytes.</p>
<div>
<blockquote>
<p>&#34;Surprisingly, the language that results is still almost bearable to write a
compiler in, although it definitely has the flavor of an assembler.&#34;</p>
</blockquote>
</div>
<p>Many Forths are also compilers and/or assemblers, but rare is the program that
can compile its own source in less than 2Kb.</p>
</div>
<div>
<h3 id="_three_instruction_forth">&#34;Three Instruction&#34; Forth</h3>

<p>Frank Sergeant’s 3-instruction Forth for an early 1990s Mototorla chip is
possibily the smallest of them all?</p>
<p>I love the description:</p>
<div>
<blockquote>
<p>&#34;How many instructions does it take to make a Forth for target development
work? Does memory grow on trees? Does the cost of the development system come
out of your own pocket? A 3- instruction Forth makes Forth affordable for
target systems with very limited memory. It can be brought up quickly on
strange new hardware. You don’t have to do without Forth because of memory or
time limitations. It only takes 66 bytes for the Motorola MC68HC11. Full
source is provided.&#34;</p>
</blockquote>
</div>
<p>How can you <em>not</em> want to learn about that? I mean, <strong>66 bytes. What?!</strong></p>
<div>
<blockquote>
<p>&#34;If you do have extra RAM available on the system then you can use the
3-instruction Forth to build and test a full Forth, and then use it.&#34;</p>
</blockquote>
</div>
</div>
</div>
</div>
<div>
<h2 id="_3_consider_a_tiny_target_program">3. Consider a tiny target program</h2>
<div>
<p><img src="https://ratfactor.com/meow5/meow5.png" alt="meow5 kitty logo is black with two bright teal eyes and a pink nose"/></p><p>My &#34;extremely concatenative&#34; Forth-like, Meow5 is literally named
after the target program it was designed to run.</p>

<p>When Meow5 was done, it could run this program:</p>
<div>
<div>
<pre>def meow &#34;Meow!\n&#34; print ;
def meow5 meow meow meow meow meow ;
meow5</pre>
</div>
</div>
<p>(Yup, that’s it! Needless to say, the target program is <strong>not</strong> what makes Meow5
unique.)</p>
<p><img src="https://ratfactor.com/snobol/snobol_ratfactor.jpg" alt="Drawing of a little rat on a snowball with a heart drawn by Dave Gauer in Krita"/></p><p>For an even funnier example, my Forth written in the string
manipulation language from the 1960s, SNOBOL4, was complete when it could run this
&#34;99 Bottles of Beer on the Wall&#34; song generator program:</p>

<p>When Snobol4th was done, it could run this program:</p>
<div>
<div>
<pre>(
  *********************************************************
  99 Bottles of Beer
  Example by Arf Dysg
  http://www.99-bottles-of-beer.net/language-forth-793.html

  Lightly modified by Dave Gauer:
    * +LOOP changed to -LOOP
    * Explicit SPACE added
  *********************************************************
)

: MANY ( n) ?DUP IF . ELSE .&#34; No more &#34; THEN ; ( the number)
: BOTTLES ( n) .&#34; bottle&#34; 1 - IF .&#34; s&#34; THEN ; ( handle plural)

: BEER ( n) CR DUP MANY BOTTLES SPACE .&#34; of beer&#34; ;
: WALL SPACE .&#34; on the wall&#34; ;
: DRINK CR .&#34; Take one down and pass it around.&#34; ;
: BUY CR .&#34; Go to the store and buy some more.&#34; ;

: ANOTHER ( n-n) ?DUP IF DRINK 1- ELSE BUY 99 THEN ;

: VERSE ( n) DUP BEER WALL DUP BEER ANOTHER BEER WALL CR ;
: VERSES ( n) 0 SWAP DO I VERSE 1 -LOOP ;

99 VERSES</pre>
</div>
</div>

</div>
</div>
<div>
<h2 id="_resources">Resources</h2>
<div>
<p>If you’re going to implement a Forth, there are some really
high-quality resources out there. Reading the source of <strong>JonesForth</strong> is a great
place to start (there’s a complete copy in my NasmJF repo linked above).</p>
<p>Another one that everybody links to because it’s so good is Brad Rodriguez’s
<strong>Moving Forth</strong> series from <em>The Computer Journal</em> magazine.
Start with Part 1: <a href="https://www.bradrodriguez.com/papers/moving1.htm">https://www.bradrodriguez.com/papers/moving1.htm</a></p>

<p>Finally, the book <strong>Threaded Interpretive Languages</strong> by R.G. Loeliger.</p>
<p><img src="https://ratfactor.com/nasmjf/forth-book-til.jpg" alt="cover image of TIL book"/></p><p>I’ve used &#34;TIL&#34; a couple times as reference for the definitions of core words.
And it’s just a really cool little hardback book that feels good in the hand.</p>
<p>Happy hacking!</p>
</div>
</div>

        
    </article></div>
  </body>
</html>
