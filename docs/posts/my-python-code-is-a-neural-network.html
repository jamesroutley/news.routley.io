<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.gabornyeki.com/2024-07-my-python-code-is-a-neural-network/">Original</a>
    <h1>My Python code is a neural network</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
      
      
      
      
      <p>Many programs that we write can be embedded in recurrent neural networks (RNNs).
For such programs, a trained RNN can perform better than if we write the algorithm by hand, refining it via trial and error.
I walk through an example in detail.</p>
<div id="lgtm_rnn_display">
<p><img id="lgtm_rnn" src="https://olu.online/weeknotes-6-week-26-2024/figure_rnn_step_1.svg"/>
<img id="lgtm_rnn_dark" src="https://olu.online/weeknotes-6-week-26-2024/figure_rnn_step_28_dark.svg"/></p></div>
<h2 id="introduction">Introduction</h2>
<p>Humans are bad at managing spaghetti code.
Of course, we should try and avoid writing spaghetti code if we can.
But there are problems that are so ill-specified that any serious attempt to solve them results in just that.</p>
<p>Let me make this concrete.
In research projects, we often write programs that extract information from raw data.
The data may have idiosyncrasies and follow no clear specification.
Some examples:</p>
<ul>
<li>
Identify mentions of corporations and their officers in news articles.
</li>
<li>
Label public procurement contracts by what kind of service the firms supply.
</li>
<li>
Determine if a message exchanged between engineers contains program code.
</li>
</ul>
<p>If we want the output to be perfect—at least in the limit—then we need to exhaustively examine each observation.
We can go one step further to reassure ourselves that the program produces the correct output by picking representative examples and writing unit tests for them.
Almost every programming language has libraries for this, including <a href="https://testthat.r-lib.org/">R</a> and <a href="https://docs.python.org/3/library/unittest.html">Python</a>.</p>
<p>But this approach won’t work well if getting the correct output requires that we specify complicated decision rules.
In the examples above,</p>
<ul>
<li>
corporate officers might be mentioned in the news by nickname,
</li>
<li>
contracts might describe the procured services using synonyms, and
</li>
<li>
it might not always be trivial to tell apart program code from English.
</li>
</ul>
<p>In such situations, we might be better off training a neural network.
Algorithms that train neural networks thrive on spaghetti.</p>
<h2 id="detecting-program-code-in-messages">Detecting program code in messages</h2>
<p>In this post, the problem that I’ll walk through solving is this:
<em>how can we detect if a message sent during code review explicitly refers to program code?</em>
Let’s suppose that the code base that we observe is written in C, and that the following examples are representative of the messages that engineers send:</p>
<ol type="A">
<li>
<em>LGTM with <mark>render_ipa_alloc()</mark>.</em>
</li>
<li>
<em>If the <mark>FTPSACK</mark> flag is set, then use a prespecified value.</em>
</li>
<li>
<em>AFAICT there is nothing else to check (unless you can think of something).</em>
</li>
<li>
<em>Actually, <mark>debug_error()</mark> doesn’t return <mark>NULL</mark>, so we should use <mark>IS_ERROR()</mark> here.</em>
</li>
<li>
<em>This fails to build on aarch64 even though it works without issue on amd64.</em>
</li>
<li>
<em>I’ve added <mark>if (err) goto cleanup;</mark> but the code still leaks.</em>
</li>
</ol>
<p>The highlighted expressions are program-code references that we would like to detect.</p>
<h3 id="ideas-for-decision-rules">Ideas for decision rules</h3>
<p>We take a straightforward approach and look for decision rules that can tell apart program code from ordinary English.
Here are some simple ideas:</p>
<table>
<tbody><tr>
<th>#</th>
<th>Rule</th>
<th>True positive</th>
<th>False positive</th>
<th>False negative</th>
</tr>
<tr>
<td>1</td>
<td>Word followed by parentheses is code.</td>
<td>A and D</td>
<td>–</td>
<td>B and F</td>
</tr>
<tr>
<td>2</td>
<td>All-caps word is code.</td>
<td>B and D</td>
<td>C</td>
<td>A and F</td>
</tr>
<tr>
<td>3</td>
<td>Non-English word is code.</td>
<td>A, B, and D</td>
<td>C, E, and F</td>
<td>–</td>
</tr>
</tbody></table>
<p>None of these rules is perfect: each has false positives or false negatives or both.</p>
<ul>
<li>
Rule 1 is easy to implement but it misses obvious positive cases like <code>if (err) goto cleanup;</code>.
</li>
<li>
Rule 2 mistakenly classifies capitalized acronyms as program code.
To make this rule effective, we need to complement it with an extensive list of acronyms and abbreviations that we might encounter (e.g., <em>AFAICT, LGTM, USD, COVID</em>).
</li>
<li>
Rule 3 mistakenly classifies engineering jargon as program code.
To make this rule work, we need an even longer word list than for Rule 2.
We can start with a canonical list of English words, but we need to complement it both with acronyms and with words that commonly appear in software engineering, like <em>aarch64</em> and <em>amd64.</em>
</li>
</ul>
<h3 id="a-hand-written-algorithm">A hand-written algorithm</h3>
<p>Nevertheless, we reason that a simple algorithm might do well enough.
So we set out to write a program that implements Rule 1.
Our program will decide in two steps whether a message contains code:</p>
<ol>
<li>
<strong>Preprocessing:</strong> convert the message into a sequence of tokens.
The tokens are chosen so that they capture syntactic elements of C program code.
This is the information that we need to apply Rule 1.
</li>
<li>
<strong>Inference:</strong> apply a function to the token sequence to check if the sequence satisfies the rule.
If it does, then we conclude that the message contains valid C code.
</li>
</ol>
<p>Let’s take the first example sentence from before.
We could encode it as a sequence of eight tokens:<a id="fnref1" href="#fn1" role="doc-noteref"><sup>1</sup></a></p>
<div>
<p><img id="lgtm_tokens" src="https://olu.online/weeknotes-6-week-26-2024/figure_tokens_step_8.svg" width="600"/>
<img id="lgtm_tokens_dark" src="https://olu.online/weeknotes-6-week-26-2024/figure_tokens_step_8_dark.svg" width="600"/></p></div>
<p>Rule 1 says that the token sequence <code>underscore_identifier</code>–<code>open_paren</code>–<code>close_paren</code> indicates the presence of program code in the sentence.
Let’s write a classifier in Python that detects a sequence like this.</p>
<p>First, we set up the types.
For simplicity, we model tokens as strings.
In order to keep track of the tokens that we have seen in the sequence, we also define a <a href="https://peps.python.org/pep-0557/">data class</a> called <code>State</code>:</p>
<pre data-linenos="" data-lang="py"><code data-lang="py"><table><tbody><tr><td>1</td><td><span><span><span>from</span></span><span><span> <span><span>dataclasses</span></span> <span><span>import</span></span></span></span><span></span><span> <span>dataclass</span></span>
</span></td></tr><tr><td>2</td><td><span>
</span></td></tr><tr><td>3</td><td><span><span><span>Token</span></span> <span>=</span> <span><span>str</span></span>    </span></td></tr><tr><td>4</td><td><span>
</span></td></tr><tr><td>5</td><td><span><span><span>@</span><span><span><span>dataclass</span></span></span></span>
</span></td></tr><tr><td>6</td><td><span><span><span><span>class</span></span> <span><span>State</span></span><span>:</span></span>
</span></td></tr><tr><td>7</td><td><span>    <span><span>previous_was_identifier</span></span><span>:</span> <span><span>bool</span></span> <span>=</span> <span>False</span>
</span></td></tr><tr><td>8</td><td><span>    <span><span>previous_was_open_paren</span></span><span>:</span> <span><span>bool</span></span> <span>=</span> <span>False</span>
</span></td></tr><tr><td>9</td><td><span>    <span><span>previous_previous_was_identifier</span></span><span>:</span> <span><span>bool</span></span> <span>=</span> <span>False</span>
</span></td></tr><tr><td>10</td><td><span>    <span><span>seen_code</span></span><span>:</span> <span><span>bool</span></span> <span>=</span> <span>False</span>
</span></td></tr></tbody></table></code></pre>
<p>To classify a message, we write a function called <code>contains_code</code> that returns <code>True</code> if the message satisfies Rule 1.
The function decides this by iterating over the token sequence and checking at each element whether the rule applies.
Since applying the rule means checking three <em>consecutive</em> tokens, not just one token, we need to keep a memory of what tokens we have seen earlier in the sequence.
The function <code>contains_code</code> keeps this memory inside an instance of <code>State</code>:</p>
<pre data-linenos="" data-lang="py"><code data-lang="py"><table><tbody><tr><td>12</td><td><span><span><span>from</span></span><span><span> <span><span>typing</span></span> <span><span>import</span></span></span></span><span></span><span> <span>Iterable</span></span>
</span></td></tr><tr><td>13</td><td><span>
</span></td></tr><tr><td>14</td><td><span><span><span><span>def</span></span> <span><span>contains_code</span></span></span><span><span>(</span></span><span><span>tokens</span></span><span><span>:</span> <span><span><span>Iterable</span></span></span><span><span>[</span></span><span><span><span>Token</span></span></span><span><span>]</span></span></span><span><span>)</span></span><span> </span><span><span>-&gt;</span> <span><span>bool</span></span></span><span><span>:</span></span>
</span></td></tr><tr><td>15</td><td><span>    <span><span>state</span></span> <span>=</span> <span><span><span><span>State</span></span></span></span><span><span>(</span><span>)</span></span>
</span></td></tr><tr><td>16</td><td><span>
</span></td></tr><tr><td>17</td><td><span>    <span><span>for</span> <span>token</span> <span>in</span></span><span> <span><span>tokens</span></span></span><span><span>:</span></span>
</span></td></tr><tr><td>18</td><td><span>        <span><span>state</span></span> <span>=</span> <span><span><span><span>process</span></span></span></span><span><span>(</span><span><span>state</span></span><span>,</span> <span><span>token</span></span><span>)</span></span>
</span></td></tr><tr><td>19</td><td><span>
</span></td></tr><tr><td>20</td><td><span>    <span>return</span> <span><span>state</span><span>.</span><span>seen_code</span></span>
</span></td></tr></tbody></table></code></pre>
<p>Now we are ready to implement <code>process</code>.
This is where we check if the rule applies and maintain the state:</p>
<pre data-linenos="" data-lang="py"><code data-lang="py"><table><tbody><tr><td>22</td><td><span><span><span><span>def</span></span> <span><span>process</span></span></span><span><span>(</span></span><span><span>state</span></span><span><span>:</span> <span><span>State</span></span></span><span><span>,</span> <span>token</span></span><span><span>:</span> <span><span>Token</span></span></span><span><span>)</span></span><span> </span><span><span>-&gt;</span> <span><span>State</span></span></span><span><span>:</span></span>
</span></td></tr><tr><td>23</td><td><span>    </span></td></tr><tr><td>24</td><td><span>
</span></td></tr><tr><td>25</td><td><span>
</span></td></tr><tr><td>26</td><td><span>    <span><span>if</span> <span><span>state</span><span>.</span><span>seen_code</span></span><span>:</span></span>
</span></td></tr><tr><td>27</td><td><span>        <span>return</span> <span><span>state</span></span>
</span></td></tr><tr><td>28</td><td><span>
</span></td></tr><tr><td>29</td><td><span>    </span></td></tr><tr><td>30</td><td><span>    </span></td></tr><tr><td>31</td><td><span>    </span></td></tr><tr><td>32</td><td><span>    <span><span>if</span> <span><span>(</span><span><span>token</span></span> <span>==</span> <span><span><span>&#34;</span></span></span><span><span>close_paren<span>&#34;</span></span></span>
</span></span></span></td></tr><tr><td>33</td><td><span><span><span>        <span>and</span> <span><span>state</span><span>.</span><span>previous_was_open_paren</span></span>
</span></span></span></td></tr><tr><td>34</td><td><span><span><span>        <span>and</span> <span><span>state</span><span>.</span><span>previous_previous_was_identifier</span></span><span>)</span></span><span>:</span></span>
</span></td></tr><tr><td>35</td><td><span>        <span><span>state</span><span>.</span><span>seen_code</span></span> <span>=</span> <span>True</span>
</span></td></tr><tr><td>36</td><td><span>        <span>return</span> <span><span>state</span></span>
</span></td></tr><tr><td>37</td><td><span>
</span></td></tr><tr><td>38</td><td><span>    </span></td></tr><tr><td>39</td><td><span>    </span></td></tr><tr><td>40</td><td><span>    </span></td></tr><tr><td>41</td><td><span>
</span></td></tr><tr><td>42</td><td><span>    <span><span>state</span><span>.</span><span>previous_previous_was_identifier</span></span> <span>=</span> <span><span>(</span>
</span></span></td></tr><tr><td>43</td><td><span><span>        <span><span>state</span><span>.</span><span>previous_was_identifier</span></span>
</span></span></td></tr><tr><td>44</td><td><span><span>    <span>)</span></span>
</span></td></tr><tr><td>45</td><td><span>
</span></td></tr><tr><td>46</td><td><span>    <span><span>state</span><span>.</span><span>previous_was_identifier</span></span> <span>=</span> <span><span>token</span></span> <span>in</span> <span><span>(</span>
</span></span></td></tr><tr><td>47</td><td><span><span>        <span><span><span>&#34;</span></span></span><span><span>all_caps_identifier<span>&#34;</span></span></span><span>,</span>
</span></span></td></tr><tr><td>48</td><td><span><span>        <span><span><span>&#34;</span></span></span><span><span>underscore_identifier<span>&#34;</span></span></span><span>,</span>
</span></span></td></tr><tr><td>49</td><td><span><span>        <span><span><span>&#34;</span></span></span><span><span>misc_identifier<span>&#34;</span></span></span><span>,</span>
</span></span></td></tr><tr><td>50</td><td><span><span>    <span>)</span></span>
</span></td></tr><tr><td>51</td><td><span>    <span><span>state</span><span>.</span><span>previous_was_open_paren</span></span> <span>=</span> <span><span>token</span></span> <span>==</span> <span><span><span>&#34;</span></span></span><span><span>open_paren<span>&#34;</span></span></span>
</span></td></tr><tr><td>52</td><td><span>
</span></td></tr><tr><td>53</td><td><span>    <span>return</span> <span><span>state</span></span>
</span></td></tr></tbody></table></code></pre>
<p>And with that, we have a classifier that implements Rule 1.
Let’s see how well it performs by looking at its <a href="https://en.wikipedia.org/wiki/Precision_and_recall">precision and recall</a>.
The good news:</p>
<ol>
<li>
The code is simple.
</li>
<li>
It has no false positives.
</li>
<li>
It has a precision of 100 percent on our (completely made up) examples.
</li>
</ol>
<p>The bad news is that this classifier has a high false negative rate which leads to a recall of only 50 percent.</p>
<p>If we want to increase recall and add Rule 2 to the algorithm, then the code becomes more complex: we need to add more fields to the <code>State</code> class, and more <code>if</code>/<code>elif</code>/<code>else</code> statements and related housekeeping to <code>process</code>.
If we want to further refine any of the rules, then we need to add yet more complexity.</p>
<p>We see that tweaking the algorithm by hand to find improvements can get out of control.
It can easily result in spaghetti code that will be a struggle to maintain.
How can we do better?</p>
<h2 id="neural-networks-to-the-rescue">Neural networks to the rescue</h2>
<p>Mired in our predicament, we reflect on the fact that <code>contains_code</code> and <code>process</code> are a <a href="https://en.wikipedia.org/wiki/Finite-state_machine">state machine</a>.
This fact is notable because state machines can be encoded by recurrent neural networks (RNNs).<a id="fnref2" href="#fn2" role="doc-noteref"><sup>2</sup></a>
So rather than tweaking the algorithm by hand, we could find a better algorithm by training an RNN on our examples.</p>
<h3 id="the-general-idea">The general idea</h3>
<p>At a high level, an RNN is an approximation of the conditional probability
<span>\[\Pr({\rm MessageContainsCode} = 1 \mid {\rm Token}_1 = x_1, \ldots, {\rm Token}_T = x_T).\]</span>
This approximation is calculated by processing the token sequence element by element.
For each token, we calculate a vector that does what <code>State</code> did in our Python code.
This is usually called a <em>hidden</em> state because it is only an interim variable and appears in neither the input nor the output of the model.
We get it by taking into account the previous state:
<span>\[\begin{aligned}
{\rm State}_0 &amp;:= 0 \in \mathbb{R}^S \\
{\rm State}_1 &amp;:= f({\rm Token}_1, {\rm State}_0) \\
{\rm State}_2 &amp;:= f({\rm Token}_2, {\rm State}_1) \\
&amp;\;\;\vdots \\
{\rm State}_T &amp;:= f({\rm Token}_T, {\rm State}_{T-1}) \\
\end{aligned}\]</span>
where the function <span>\(f\)</span> represents the hidden layers of the recurrent network.
The message is classified based on the final state:
<span>\[\widehat{\Pr}({\rm MessageContainsCode} = 1 \mid {\rm Token}_1, \ldots) := g({\rm State}_T)\]</span>
where <span>\(g\)</span> is what is called the output layer of the network.</p>
<p>How should we parameterize the functions <span>\(f\)</span> and <span>\(g\)</span>?</p>
<h3 id="our-python-code-as-math">Our Python code as math</h3>
<p>Let’s think about what a network that encodes Rule 1 looks like.
Returning to the previous example sentence, let’s simplify the math that ensues by using fewer types of tokens:</p>
<div>
<p><img id="lgtm_tokens_simple" src="https://olu.online/weeknotes-6-week-26-2024/figure_tokens_simple_step_8.svg" width="520"/>
<img id="lgtm_tokens_simple_dark" src="https://olu.online/weeknotes-6-week-26-2024/figure_tokens_simple_step_8_dark.svg" width="520"/></p></div>
<p>Each token in the sentence is represented as a <a href="https://en.wikipedia.org/wiki/One-hot">binary vector</a>, so the input data that we get looks like this (with the zeros erased to make the table easier to read):</p>
<table>
<tbody><tr>
<th></th>
<th><span>\(x_1\)</span></th>
<th><span>\(x_2\)</span></th>
<th><span>\(x_3\)</span></th>
<th><span>\(x_4\)</span></th>
<th><span>\(x_5\)</span></th>
<th><span>\(x_6\)</span></th>
<th><span>\(x_7\)</span></th>
<th><span>\(x_8\)</span></th>
</tr>
<tr>
<td><code>identifier</code></td>
<td><span>\(1\)</span></td>
<td></td>
<td><span>\(1\)</span></td>
<td></td>
<td><span>\(1\)</span></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>open_paren</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><span>\(1\)</span></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>close_paren</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><span>\(1\)</span></td>
<td></td>
</tr>
<tr>
<td><code>unknown</code></td>
<td></td>
<td><span>\(1\)</span></td>
<td></td>
<td><span>\(1\)</span></td>
<td></td>
<td></td>
<td></td>
<td><span>\(1\)</span></td>
</tr>
</tbody></table>
<p>To model the state, we need to add three hidden layers to the network.
When we are processing the <span>\(t\)</span>-th token in the sequence, we calculate each of the three layers, one after the other.
Let’s denote the first layer by <span>\(h_t^1\)</span>, the second layer by <span>\(h_t^2\)</span>, and the third by <span>\(h_t^3\)</span>.
The first two layers hold intermediate calculations while the third layer holds our final state after processing the token.</p>
<p>The third layer, <span>\(h_t^3\)</span>, corresponds to <span>\({\rm State}_t\)</span> in the schematic presentation above, and the initial state, <span>\(h_0^3\)</span>, corresponds to <span>\({\rm State}_0\)</span>.
This table shows how the hidden state evolves:</p>
<table>
<tbody><tr>
<th></th>
<th><span>\(h_0^3\)</span></th>
<th><span>\(h_1^3\)</span></th>
<th><span>\(h_2^3\)</span></th>
<th><span>\(h_3^3\)</span></th>
<th><span>\(h_4^3\)</span></th>
<th><span>\(h_5^3\)</span></th>
<th><span>\(h_6^3\)</span></th>
<th><span>\(h_7^3\)</span></th>
<th><span>\(h_8^3\)</span></th>
</tr>
<tr>
<td><code>seen_code</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><span>\(1\)</span></td>
<td><span>\(1\)</span></td>
</tr>
<tr>
<td><code>identifier</code></td>
<td></td>
<td><span>\(1\)</span></td>
<td></td>
<td><span>\(1\)</span></td>
<td></td>
<td><span>\(1\)</span></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>open_paren</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><span>\(1\)</span></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>p_identifier</code></td>
<td></td>
<td></td>
<td><span>\(1\)</span></td>
<td></td>
<td><span>\(1\)</span></td>
<td></td>
<td><span>\(1\)</span></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>To encode the hand-written algorithm, we use the binary indicator function, <span>\(\mathbb{1}\{\cdot &gt; 0\}\)</span>, which evaluates to 1 if its input is positive and to 0 otherwise.<a id="fnref3" href="#fn3" role="doc-noteref"><sup>3</sup></a>
Of course, this would be an outstandingly bad choice if we wanted to <em>train</em> an RNN because its derivative is zero almost everywhere which breaks gradient descent.
But for now, we merely want to <em>specify</em> an RNN that mimics the hand-written algorithm.
The <code>State</code> class that we used is effectively a binary vector, and the binary indicator function ensures that the RNN’s hidden layers will be binary as well.</p>
<p>The key calculation is done in the second and third hidden layers.
The second layer checks if the token sequence <span>\((x_{t-2}, x_{t-1}, x_t)\)</span> satisfies Rule 1.
We don’t do this by referencing the three tokens directly.
Instead, we store information about them in the first hidden layer, and we reference that:</p>
<p><span>\[\begin{aligned}
h_{t,\tt this\_is\_code}^2 &amp;:= \mathbb{1}\left\{ 2 h_{t,\tt pp\_identifier}^1 h_{t,\tt p\_open\_paren}^1 h_{t,\tt close\_paren}^1 - 1 &gt; 0 \right\} \\
\end{aligned}\]</span></p>
<p>The third layer combines this check, <span>\(h_{t,\tt this\_is\_code}^2\)</span>, with a memory of whether any earlier part of the sequence has satisfied the rule:</p>
<p><span>\[\begin{aligned}
h_{t,\tt seen\_code}^3 &amp;:= \mathbb{1}\left\{ 2 \left( h_{t, \tt this\_is\_code}^2 + h_{t, \tt p\_seen\_code}^2 \right) - 1 &gt; 0 \right\} \\
\end{aligned}\]</span></p>
<p>Once we have processed all <span>\(T\)</span> tokens, the output is calculated using the final hidden layer:</p>
<p><span>\[y_T := \mathbb{1}\left\{ 2 h_{T,\tt seen\_code}^3 - 1 &gt; 0 \right\}\]</span></p>
<p>The formula for <span>\(h_{t,\tt this\_is\_code}^2\)</span> looks simple enough but it contains a multiplication between <span>\(h_{t,\tt pp\_identifier}^1\)</span>, <span>\(h_{t,\tt p\_open\_paren}^1\)</span>, and <span>\(h_{t,\tt close\_paren}^1\)</span>.
If we wanted to include this multiplicative term, we would need a higher-order RNN, similar to the second-order RNN that <a href="https://doi.org/10.1162/neco.1992.4.3.393">Giles et al. (1992)</a> used to discover state machines.
Fortunately, with binary hidden layers, we can stay within the framework of a first-order RNN by replacing the multiplication with a simple sum:</p>
<p><span>\[\begin{aligned}
h_{t,\tt this\_is\_code}^2 &amp;:= \mathbb{1}\left\{ h_{t,\tt pp\_identifier}^1 + h_{t,\tt p\_open\_paren}^1 + h_{t,\tt close\_paren}^1 - 2 &gt; 0 \right\} \\
\end{aligned}\]</span></p>
<p>(And when we will change the activation function in the next section so that we can train the network, we will see that a sum still works.)</p>
<p>Now to wrap things up, we also get some auxiliary calculations done that are needed for <span>\(h_{t,\tt this\_is\_code}^2\)</span> and <span>\(h_{t,\tt seen\_code}^3\)</span>.
In the first hidden layer, we take note of the token that we are processing and copy the previous state:</p>
<p><span>\[\begin{aligned}
h_{t,\tt identifier}^1 &amp;:= \mathbb{1}\{ 2 x_{t,\tt identifier} - 1 &gt; 0 \} \\
h_{t,\tt open\_paren}^1 &amp;:= \mathbb{1}\{ 2 x_{t,\tt open\_paren} - 1 &gt; 0 \} \\
h_{t,\tt close\_paren}^1 &amp;:= \mathbb{1}\{ 2 x_{t,\tt close\_paren} - 1 &gt; 0 \} \\
h_{t,\tt p\_seen\_code}^1 &amp;:= \mathbb{1}\{ 2 h_{t-1,\tt seen\_code}^3 - 1 &gt; 0 \} \\
h_{t,\tt p\_identifier}^1 &amp;:= \mathbb{1}\{ 2 h_{t-1,\tt identifier}^3 - 1 &gt; 0 \} \\
h_{t,\tt p\_open\_paren}^1 &amp;:= \mathbb{1}\{ 2 h_{t-1,\tt open\_paren}^3 - 1 &gt; 0 \} \\
h_{t,\tt pp\_identifier}^1 &amp;:= \mathbb{1}\{ 2 h_{t-1,\tt p\_identifier}^3 - 1 &gt; 0 \} \\
\end{aligned}\]</span></p>
<p>In the second layer, we copy some values that will be used in the third:</p>
<p><span>\[\begin{aligned}
h_{t,\tt identifier}^2 &amp;:= \mathbb{1}\left\{ 2 h_{t,\tt identifier}^1 - 1 &gt; 0 \right\} \\
h_{t,\tt open\_paren}^2 &amp;:= \mathbb{1}\left\{ 2 h_{t,\tt open\_paren}^1 - 1 &gt; 0 \right\} \\
h_{t,\tt p\_seen\_code}^2 &amp;:= \mathbb{1}\left\{ 2 h_{t,\tt p\_seen\_code}^1 - 1 &gt; 0 \right\} \\
h_{t,\tt p\_identifier}^2 &amp;:= \mathbb{1}\left\{ 2 h_{t,\tt p\_identifier}^1 - 1 &gt; 0 \right\} \\
\end{aligned}\]</span></p>
<p>And lastly, in the third layer, we maintain a memory of tokens that we can use later when we process the next token, <span>\(x_{t+1}\)</span>:</p>
<p><span>\[\begin{aligned}
h_{t,\tt identifier}^3 &amp;:= \mathbb{1}\left\{ 2 h_{t,\tt identifier}^2 - 1 &gt; 0 \right\} \\
h_{t,\tt open\_paren}^3 &amp;:= \mathbb{1}\left\{ 2 h_{t,\tt open\_paren}^2 - 1 &gt; 0 \right\} \\
h_{t,\tt p\_identifier}^3 &amp;:= \mathbb{1}\left\{ 2 h_{t,\tt p\_identifier}^2 - 1 &gt; 0 \right\} \\
\end{aligned}\]</span></p>
<p>The <a href="#lgtm_rnn_display">illustration at the beginning of the post</a> shows how this network classifies the example sentence.
I won’t do it in this post, but we could set it up in PyTorch, too, and verify that it classifies messages exactly as our hand-written algorithm does.</p>
<h2 id="training-the-network-to-discover-better-algorithms">Training the network to discover better algorithms</h2>
<p>If we have a recurrent network, then we should be able to train it.
But the network as we have parameterized it so far is not amenable to training.
Gradient descent, the algorithm that is commonly used to train neural networks, will be stuck because the binary indicator function has a zero slope almost everywhere.</p>
<h3 id="trainable-activation-functions">Trainable activation functions</h3>
<p>We overcome this hurdle by switching to an activation function called the <a href="https://en.wikipedia.org/wiki/Rectifier_%28neural_networks%29">rectified linear unit</a> (ReLU), defined as <span>\([x]^+ := x \mathbb{1}\{ x &gt; 0\}\)</span>.
The numerical constants, called <em>weights</em> and <em>biases,</em> also need to be replaced, as these are the parameters that gradient descent will estimate.
We end up with</p>
<p><span>\[\begin{aligned}
h_{t,\tt this\_is\_code}^2 &amp;:= \big[ w_{\tt pp\_identifier}^2 h_{t,\tt pp\_identifier}^1 + \\
&amp;\qquad\quad+ w_{\tt p\_open\_paren}^2 h_{t,\tt p\_open\_paren}^1 + \\
&amp;\qquad\quad+ w_{\tt close\_paren}^2 h_{t,\tt close\_paren}^1 + b_{\tt this\_is\_code}^2 \big]^+ \\
\end{aligned}\]</span></p>
<p>and so on for the hidden layers.
For the output layer, we use a sigmoid activation function:</p>
<p><span>\[y_T := \frac{1}{ 1 + \exp\left( - w_{\tt seen\_code}^y h_{T,\tt seen\_code}^3 - b_{\tt seen\_code}^y \right) }.\]</span></p>
<p>And we are ready to plug this into PyTorch and train it.</p>
<p>However, what we will find if we do that is that while it is possible to get this network to learn something from the data, its performance is far from exceptional.
We can tackle the code detection problem more effectively if we use some of the other options offered by PyTorch.</p>
<h3 id="architectures-with-more-efficient-implementations">Architectures with more efficient implementations</h3>
<p>One reason for the lackluster performance of our recurrent network is that its architecture is somewhat atypical.
As a consequence, more of our training procedure is executed in Python glue code and less of it in PyTorch’s C++ library.
An alternative that is <a href="https://pytorch.org/docs/stable/generated/torch.nn.RNN.html">provided off the shelf</a> by PyTorch, and that thus has a more efficient implementation, is the Elman RNN.
Our architecture differs from Elman’s in that in our network, each hidden layer takes only the previous layer as input: the first layer for token <span>\(t\)</span> takes the third layer for token <span>\(t-1\)</span>, the second layer takes the first, and the third layer takes the second.
In vector notation:</p>
<p><span>\[\begin{aligned}
h_t^1 &amp;:= \left[ w^1 \left( x_t&#39;, {h_{t-1}^3}&#39; \right)&#39; + b^1 \right]^+ \\
h_t^2 &amp;:= \left[ w^2 h_t^1 + b^2 \right]^+ \\
h_t^3 &amp;:= \left[ w^3 h_t^2 + b^3 \right]^+ \\
\end{aligned}\]</span></p>
<p>If we followed Elman’s architecture, the layers would be different in two ways.
First, each hidden layer for token <span>\(t\)</span> would also take the same layer for token <span>\(t-1\)</span> as input.
Second, the first hidden layer would <em>not</em> take the final layer for the previous taken as input.
This becomes clearer when we compare the formulas shown above with those of the Elman RNN:</p>
<p><span>\[\begin{aligned}
h_t^1 &amp;:= \left[ w^1 \left( x_t&#39;, {h_{t-1}^1}&#39; \right)&#39; + b^1 \right]^+ \\
h_t^2 &amp;:= \left[ w^2 \left( {h_t^1}&#39;, {h_{t-1}^2}&#39; \right)&#39; + b^2 \right]^+ \\
h_t^3 &amp;:= \left[ w^3 \left( {h_t^2}&#39;, {h_{t-1}^3}&#39; \right)&#39; + b^3 \right]^+ \\
\end{aligned}\]</span></p>
<h3 id="architectures-with-more-numerically-stable-gradients">Architectures with more numerically stable gradients</h3>
<p>Another reason for the subpar performance of our recurrent network is that in real-world code review, engineers often send longer messages.
Longer messages translate into longer token sequences which can throw off the gradient descent algorithm.
Gradient descent works in theory but not always in practice: the gradients, obtained by diligently applying the chain rule, <a href="https://en.wikipedia.org/wiki/Vanishing_gradient_problem">can get too close to zero</a> which causes problems with numerical stability.</p>
<p>While Elman’s architecture is susceptible, too, other architectures attempt to mitigate this.
So we might well find that a <a href="https://en.wikipedia.org/wiki/Gated_recurrent_unit">gated recurrent unit</a> or a <a href="https://en.wikipedia.org/wiki/Long_short-term_memory">long short term memory network</a> performs better for our code detection task.</p>
<h2 id="data-driven-discipline">Data-driven discipline</h2>
<p>Recurrent neural networks have handled our inevitable spaghetti code better than we could ourselves.
But they have done more than that: they have imposed a certain data-driven discipline on us that we would probably not follow if we wrote the algorithm by hand.
To train a network,</p>
<ol>
<li>
we need to select training and validation data sets,
</li>
<li>
we need to prelabel them, and
</li>
<li>
we need to specify a loss function that makes it explicit what we want the classifier to achieve and what we don’t.
</li>
</ol>
<p>This discipline forces us to clarify our thinking, as we will inevitably find gray areas that we didn’t expect.
And it turns out that this discipline is useful even for those problems that we decide to solve by hand.</p>
<hr/>
<ol>
<li id="fn1">
<p>The first word, “LGTM,” is a commonly used abbreviation of “looks good to me.”
Why is it coded as <code>all_caps_identifier</code> rather than something else?
Because in idiomatic C, constants are given all-uppercase names, so without a list of common abbreviations at hand, we err on the side of assuming that “LGTM” could be a constant in some program code.<a href="#fnref1" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn2">
<p>Marvin Minsky’s 1967 book, <em>Computation: Finite and Infinite Machines,</em> already pointed out that recurrent neural networks can encode state machines.
Later, in the late 1980s and through the 1990s, there was a burgeoning literature on how to discover state machines by training appropriately specified recurrent networks (e.g., <a href="https://doi.org/10.1162/neco.1992.4.3.393">Giles et al., 1992</a>).<a href="#fnref2" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn3">
<p>As a little-known trivia, this is also occasionally called the <a href="https://en.wikipedia.org/wiki/Heaviside_step_function">Heaviside step function</a> or the Heaviside activation function.<a href="#fnref3" role="doc-backlink">↩︎</a></p>
</li>
</ol>

      
    </div></div>
  </body>
</html>
