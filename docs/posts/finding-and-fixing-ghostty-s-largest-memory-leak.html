<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mitchellh.com/writing/ghostty-memory-leak-fix">Original</a>
    <h1>Finding and Fixing Ghostty&#39;s Largest Memory Leak</h1>
    
    <div id="readability-page-1" class="page"><div><p>A few months ago, users started reporting that Ghostty was consuming absurd
amounts of memory, with one user reporting <strong>37 GB</strong> after 10 days of uptime.
Today, I&#39;m happy to say <a target="_blank" rel="noopener noreferrer" href="https://github.com/ghostty-org/ghostty/pull/10251">the fix has been found and merged</a>.
This post is an overview of what caused the leak, a look at some of
Ghostty&#39;s internals, and some brief descriptions of how we tracked it down.<sup><a href="#user-content-fn-2" id="user-content-fnref-2" data-footnote-ref="true" aria-describedby="footnote-label">1</a></sup></p>
<p>The leak was present since at least Ghostty 1.0, but it is only recently
that popular CLI applications (particularly Claude Code) started producing
the correct conditions to trigger it at scale. The limited conditions that
triggered the leak are what made it particularly tricky to diagnose.</p>
<p>The fix is merged and is available in <a target="_blank" rel="noopener noreferrer" href="https://ghostty.org/docs/install/pre">tip/nightly releases</a>,
and will be part of the tagged 1.3 release in March.</p>
<hr/>
<h2 id="the-pagelist"><a href="#the-pagelist" aria-hidden="true" tabindex="-1"><span></span></a>The PageList</h2>
<p>To understand the bug, we first need to understand how Ghostty manages
terminal memory. Ghostty uses a data structure called the
<a target="_blank" rel="noopener noreferrer" href="https://github.com/ghostty-org/ghostty/blob/main/src/terminal/PageList.zig"><code>PageList</code></a>
to store terminal content. PageList is a doubly-linked list of
memory pages that store the terminal content (characters, styles, hyperlinks,
etc.).</p>
<div><p>PageList: A doubly-linked list of memory pages</p><div><div><p><span>Page 1</span><span>oldest</span><span>scrollback</span></p><svg viewBox="0 0 24 24" fill="none"><path d="M1 8h20m0 0l-4-4m4 4l-4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M23 16H3m0 0l4-4m-4 4l4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg><p><span>Page 2</span></p><svg viewBox="0 0 24 24" fill="none"><path d="M1 8h20m0 0l-4-4m4 4l-4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M23 16H3m0 0l4-4m-4 4l4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg><p><span>Page 3</span></p><svg viewBox="0 0 24 24" fill="none"><path d="M1 8h20m0 0l-4-4m4 4l-4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M23 16H3m0 0l4-4m-4 4l4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg><p><span>Page 4</span><span>newest</span><span>active screen</span></p></div></div></div>
<p>The underlying &#34;pages&#34; are not single <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Page_(computer_memory)">virtual memory pages</a>
but they are a contiguous block of memory aligned to page boundaries
and composed of an even multiple of system pages.<sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref="true" aria-describedby="footnote-label">2</a></sup></p>
<p>These pages are allocated using <code>mmap</code>. <code>mmap</code> isn&#39;t particularly fast,
so to avoid constant syscalls, we use a <strong>memory pool</strong>. When we need
a new page, we pull from the pool. When we&#39;re done with a page, we return
it to the pool for reuse.</p>
<p>The pool uses a <strong>standard size</strong> for pages. Think of it like buying
standard-sized shipping boxes: most things people ship fit in a standard box,
and having a standard box comes with various efficiencies.</p>
<p>But sometimes terminals need more memory than a standard page provides.
If a set of lines has many emoji, styles, or hyperlinks, we need
a larger page. In these cases, we allocate a <strong>non-standard page</strong>
directly with <code>mmap</code>, bypassing the pool entirely. This is typically a
rare scenario.</p>
<div><p>Two types of page allocations</p><div><div><div><p>Standard Pages (from pool)</p><div><p>• Fixed size</p><p>• Returned to pool when freed</p><p>• Reusable for future allocations</p></div></div><div><p>Non-Standard Pages (direct mmap)</p><div><p>• Variable size (larger than standard)</p><p>• Must call munmap to free</p><p>• Cannot be reused</p></div></div></div></div></div>
<p>When we &#34;free&#34; a page, we apply some simple logic:</p>
<ol>
<li>If the page is <code>&lt;= standard size</code>: return it to the pool</li>
<li>If the page is <code>&gt; standard size</code>: call <code>munmap</code> to free it</li>
</ol>
<p>This is the core background for terminal memory management in Ghostty,
and the idea itself is sound. A logic bug around an optimization is
what produced the leak, as we&#39;ll see next.</p>
<hr/>

<p>There&#39;s one more background detail we need to cover to
understand the bug: scrollback pruning.</p>
<p>Ghostty has a <code>scrollback-limit</code> configuration that caps how much history
is retained. When you hit this limit, we delete the oldest pages in
the scrollback buffer to free up memory.</p>
<p>But this often happens in a super hot path (e.g. when outputting large
amounts of data quickly), and allocating and freeing memory pages is
expensive, even with the pool. Therefore, we have an optimization:
<strong>reuse the oldest page as the newest page</strong> when we reach the limit.</p>
<div><p>Scrollback pruning: reusing the oldest page</p><div><div><div><p>Before: at scrollback limit</p></div><div><div><svg fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 14l-7 7m0 0l-7-7m7 7V3"></path></svg><p><span>Remove from front, reuse at back</span></p></div></div><div><p>After: page reused at end</p><div><p><span>Page 2</span><span>now oldest</span></p><svg viewBox="0 0 24 24" fill="none"><path d="M1 8h20m0 0l-4-4m4 4l-4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M23 16H3m0 0l4-4m-4 4l4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg><p><span>Page 3</span></p><svg viewBox="0 0 24 24" fill="none"><path d="M1 8h20m0 0l-4-4m4 4l-4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M23 16H3m0 0l4-4m-4 4l4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg><p><span>Page 4</span></p><svg viewBox="0 0 24 24" fill="none"><path d="M1 8h20m0 0l-4-4m4 4l-4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M23 16H3m0 0l4-4m-4 4l4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg></div></div></div></div></div>
<p>This optimization works great. It requires zero allocations and uses
only some quick pointer manipulations to move the page from the
front to the back of the list. We do some metadata cleanup to &#34;clear&#34; the
page but otherwise leave the previous memory intact.</p>
<p>It&#39;s fast and empirically speeds up scrollback-heavy workloads significantly.</p>
<hr/>
<h2 id="the-bug"><a href="#the-bug" aria-hidden="true" tabindex="-1"><span></span></a>The Bug</h2>
<p>During the scrollback pruning optimization, we always
<strong>resized our page back to standard size</strong>. But we didn&#39;t resize the
underlying memory allocation itself, we only noted the resize in the
metadata. The underlying memory was still the large
non-standard <code>mmap</code> allocation, but now the PageList <em>thought</em> it was standard
sized.</p>
<div><p>How metadata desync causes the leak</p><div><div><div><p>1</p><div><p>Allocate non-standard page</p></div></div><div><p>2</p><div><p>Scrollback prunes &amp; reuses</p><p><strong>BUG:</strong> metadata reset to std_size, but mmap unchanged!</p></div></div><div><p>3</p><div><p>Free the page</p><p>std_size, assume pooled. <strong>munmap never called!</strong></p></div></div><div><p><span><span></span>Standard</span><span><span></span>Non-standard</span><span><span></span>Leaked</span></p></div></div></div></div>
<p>Eventually, we&#39;d free the page under various circumstances (e.g. when
the user closes the terminal, but also other times). At that point,
we&#39;d see the page memory was within the standard size, assume it
was part of the pool, and we would <em>never call <code>munmap</code></em> on it.
A classic leak.</p>
<p>This all seems pretty obvious, but the issue is that non-standard
pages are rare by design. The goal of our design and optimizations is
that standard pages are the common case and provide a fast-path. Only
very specific scenarios produce non-standard pages and they&#39;re usually
not produced in large quantities.</p>
<p>But the rise of <a target="_blank" rel="noopener noreferrer" href="https://claude.com/product/claude-code">Claude Code</a>
changed this. For some reason, Claude Code&#39;s CLI produces a lot of
multi-codepoint grapheme outputs which force Ghostty to regularly
use non-standard pages. Additionally, Claude Code uses the primary screen
and produces a significant amount of scrollback output. These things
combined together created the perfect storm to trigger the leak
in huge quantities.</p>
<div><p>I want to be explicit that this bug is not Claude Code&#39;s fault. Claude Code is simply exercising
Ghostty in a way that exposes this long-standing bug.</p></div>
<hr/>
<h2 id="the-fix"><a href="#the-fix" aria-hidden="true" tabindex="-1"><span></span></a>The Fix</h2>
<p>The fix is conceptually simple: <strong>never reuse non-standard pages</strong>.
If we encounter a non-standard page during scrollback pruning, we
destroy it properly (calling <code>munmap</code>) and allocate a fresh
standard-sized page from the pool.</p>
<p>The core of the fix is in the snippet below, but some extra
work was needed to fix up some other bits of accounting we have:</p>
<div><pre><code><span><span>if</span> <span>(</span>first<span>.</span>data<span>.</span>memory<span>.</span>len <span>&gt;</span> std_size<span>)</span> <span>{</span>
</span><span>    self<span>.</span><span>destroyNode</span><span>(</span>first<span>)</span><span>;</span>
</span><span>    <span>break</span> <span>:</span><span>prune</span><span>;</span>
</span><span><span>}</span>
</span></code></pre></div>
<p>We could&#39;ve also reused the non-standard page and just retained the
large memory size, but until we have data that shows otherwise, we&#39;re
still operating under the assumption that standard pages are the common case
and it makes sense to reset back to a standard pooled page.</p>
<p>Other users have recommended more complex strategies (e.g. maintaining
some metrics on how often non-standard pages are used and adjusting
our assumptions accordingly), but more research is needed before
making those changes. This change is simple, fixes the bug, and aligns
with our current assumptions.</p>
<hr/>

<p>As part of the fix, I added support for virtual memory tags on macOS
provided by the Mach kernel. This lets us tag our PageList memory allocations
with a specific identifier that shows up in various tooling.</p>
<div><pre><code><span><span>inline</span> <span>fn</span> <span>pageAllocator</span><span>(</span><span>)</span> <span>Allocator</span> <span>{</span>
</span><span>    
</span><span>    <span>if</span> <span>(</span>builtin<span>.</span>is_test<span>)</span> <span>return</span> std<span>.</span>testing<span>.</span>allocator<span>;</span>
</span><span>
</span><span>    
</span><span>    <span>if</span> <span>(</span><span>!</span>builtin<span>.</span>target<span>.</span>os<span>.</span>tag<span>.</span><span>isDarwin</span><span>(</span><span>)</span><span>)</span> <span>return</span> std<span>.</span>heap<span>.</span>page_allocator<span>;</span>
</span><span>
</span><span>    
</span><span>    
</span><span>    <span>const</span> mach <span>=</span> <span>@import</span><span>(</span><span>&#34;../os/mach.zig&#34;</span><span>)</span><span>;</span>
</span><span>    <span>return</span> mach<span>.</span><span>taggedPageAllocator</span><span>(</span><span>.</span>application_specific_1<span>)</span><span>;</span>
</span><span><span>}</span>
</span></code></pre></div>
<p>Now when debugging memory on macOS, Ghostty&#39;s PageList memory shows up
with a specific tag instead of being lumped in with everything else.
This made it trivial to identify the leak, associate it with the PageList,
and also verify that the fix worked by observing the tagged memory
being properly freed.</p>
<hr/>
<h2 id="preventing-leaks-in-ghostty"><a href="#preventing-leaks-in-ghostty" aria-hidden="true" tabindex="-1"><span></span></a>Preventing Leaks in Ghostty</h2>
<p>We do a lot of work in the Ghostty project to find and prevent memory leaks:</p>
<ul>
<li>In debug builds and unit tests, we use leak-detecting Zig allocators.</li>
<li>The CI runs <code>valgrind</code> on our full unit test suite on every commit
to find more than just leaks, such as undefined memory usage.</li>
<li>We regularly run the macOS GUI via macOS Instruments to look for
leaks particularly in the Swift codebase.</li>
<li>We run every GTK-related PR using Valgrind (the full GUI) to look
for leaks in the GTK codepath that isn&#39;t unit tested.</li>
</ul>
<p>This has worked really well to date, but unfortunately it didn&#39;t catch
this particular leak because it only triggers under very specific
conditions that our tests didn&#39;t reproduce. The merged PR includes a
test that does reproduce the leak to prevent regressions in the future.</p>
<hr/>
<h2 id="conclusion"><a href="#conclusion" aria-hidden="true" tabindex="-1"><span></span></a>Conclusion</h2>
<p>This was the largest known memory leak in Ghostty to date, and the only
reported leak that has been confirmed by more than a single user.
We&#39;ll continue to monitor and address memory reports as they come in,
but remember that reproduction is the key to diagnosing and fixing memory leaks!</p>
<p>Big thanks to <a target="_blank" rel="noopener noreferrer" href="https://github.com/grishy">@grishy</a> who finally
got me a reliable reproduction so I could analyze the issue myself. Their
own analysis reached the same conclusion as mine, and the reproduction
let me verify both our understandings independently.</p>
<p>Thanks also to everyone who reported this issue with detailed diagnostics.
The community&#39;s analysis, especially around the <code>footprint</code> output and
VM region counting, gave me important clues that pointed toward the PageList
as the culprit.</p>
</div></div>
  </body>
</html>
