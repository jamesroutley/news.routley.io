<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://web.dev/porting-libusb-to-webusb/">Original</a>
    <h1>Porting USB applications to the web. Part 1: libusb</h1>
    
    <div id="readability-page-1" class="page"><article><header><nav aria-label="breadcrumbs"><ul role="list"><li><a href="https://web.dev/" data-category="web.dev" data-label="post, home breadcrumb" data-action="click">Home</a></li><li><a href="https://web.dev/blog" data-category="web.dev" data-label="post, path breadcrumb" data-action="click">All articles</a></li></ul></nav><p>Learn how code that interacts with external devices can be ported to the web with WebAssembly and Fugu APIs.</p><p><time>Jan 20, 2022</time></p></header><p>In <a href="https://web.dev/asyncify/">a previous post</a>, I showed how to port apps using filesystem APIs to the web with <a href="https://web.dev/file-system-access/">File System Access API</a>, WebAssembly and <a href="https://emscripten.org/docs/porting/asyncify.html" rel="noopener">Asyncify</a>. Now I want to continue the same topic of integrating <a href="https://fugu-tracker.web.app/" rel="noopener">Fugu APIs</a> with WebAssembly and porting apps to the web without losing important features.</p><p>I&#39;ll show how apps that communicate with USB devices can be ported to the web by porting <a href="https://libusb.info/" rel="noopener">libusb</a>—a popular USB library written in C—to WebAssembly (via <a href="https://emscripten.org/" rel="noopener">Emscripten</a>), Asyncify and <a href="https://web.dev/usb/">WebUSB</a>.</p><h2 id="first-things-first:-a-demo">First things first: a demo <a href="#first-things-first:-a-demo">#</a></h2><p>The most important thing to do when porting a library is choosing the right demo—something that would showcase the capabilities of the ported library, allowing you to test it in a variety of ways, and be visually compelling at the same time.</p><p>The idea I chose was DSLR remote control. In particular, an open source project <a href="http://gphoto.org/" rel="noopener">gPhoto2</a> has been in this space long enough to reverse-engineer and implement support for a wide variety of digital cameras. It supports several protocols, but the one I was most interested in was USB support, which it performs via libusb.</p><p>I&#39;ll describe the steps for building this demo in two parts. In this blog post, I&#39;ll describe how I ported libusb itself, and what tricks might be necessary to port other popular libraries to Fugu APIs. In the second post, I&#39;ll go into details on porting and integrating gPhoto2 itself.</p><p>In the end, I got a working web application that previews live feed from a DSLR and can control its settings over USB. Feel free to check out the <a href="https://web-gphoto2.rreverser.com/" rel="noopener">live</a> or the pre-recorded demo before reading up on technical details:</p><figure><video controls=""><source src="https://storage.googleapis.com/web-dev-uploads/video/9oK23mr86lhFOwKaoYZ4EySNFp02/4MUKvJhKOPK2CSTkhnEC.mp4" type="video/mp4"/></video><figcaption><a href="https://web-gphoto2.rreverser.com/">The demo</a> running on a laptop connected to a Sony camera.</figcaption></figure><h3 id="note-on-camera-specific-quirks">Note on camera-specific quirks <a href="#note-on-camera-specific-quirks">#</a></h3><p>You might have noticed that changing settings takes a while in the video. Like with most other issues you might see, this is not caused by the performance of WebAssembly or WebUSB, but by how gPhoto2 interacts with the specific camera chosen for the demo.</p><p>Sony a6600 doesn&#39;t expose an API to set values like ISO, aperture or shutter speed directly, and instead only provides commands to increase or decrease them by the specified number of steps. To make matters more complicated, it doesn&#39;t return a list of the actually supported values, either—the returned list seems hardcoded across many Sony camera models.</p><p>When setting one of those values, gPhoto2 has no other choice but to:</p><ol><li>Make a step (or a few) in the direction of the chosen value.</li><li>Wait a bit for the camera to update the settings.</li><li>Read back the value the camera actually landed on.</li><li>Check that the last step didn&#39;t jump over the desired value nor wrapped around the end or the beginning of the list.</li><li>Repeat.</li></ol><p>It can take some time, but if the value is actually supported by the camera, it will get there, and, if not, it will stop on the nearest supported value.</p><p>Other cameras will likely have different sets of settings, underlying APIs, and quirks. Keep in mind that gPhoto2 is an open-source project, and either automated or manual testing of all the camera models out there is simply not feasible, so detailed issue reports and PRs are always welcome (but make sure to reproduce the issues with the official gPhoto2 client first).</p><h3 id="important-cross-platform-compatibility-notes">Important cross-platform compatibility notes <a href="#important-cross-platform-compatibility-notes">#</a></h3><p>Unfortunately, on Windows any &#34;well-known&#34; devices, including DSLR cameras, are assigned a system driver, which is not compatible with WebUSB. If you want to try the demo on Windows, you&#39;ll have to use a tool like <a href="https://zadig.akeo.ie/" rel="noopener">Zadig</a> to override the driver for the connected DSLR to either WinUSB or libusb. This approach works fine for me and many other users, but you should use it at your own risk.</p><p>On Linux, you will likely need to <a href="https://web.dev/build-for-webusb/#linux">set custom permissions</a> to allow access to your DSLR via WebUSB, although this depends on your distribution.</p><p>On macOS and Android, the demo should work out of the box. If you&#39;re trying it on an Android phone, make sure to switch to the landscape mode as I didn&#39;t put much effort into making it responsive (PRs are welcome!):</p><figure><img alt="Android phone connected to a Canon camera via a USB-C cable." height="533" src="https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/POZGEUlnjJeRKvVDFdiR.jpg?auto=format" width="800" decoding="async" sizes="(min-width: 800px) 800px, calc(100vw - 48px)" srcset="https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/POZGEUlnjJeRKvVDFdiR.jpg?auto=format&amp;w=200 200w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/POZGEUlnjJeRKvVDFdiR.jpg?auto=format&amp;w=228 228w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/POZGEUlnjJeRKvVDFdiR.jpg?auto=format&amp;w=260 260w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/POZGEUlnjJeRKvVDFdiR.jpg?auto=format&amp;w=296 296w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/POZGEUlnjJeRKvVDFdiR.jpg?auto=format&amp;w=338 338w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/POZGEUlnjJeRKvVDFdiR.jpg?auto=format&amp;w=385 385w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/POZGEUlnjJeRKvVDFdiR.jpg?auto=format&amp;w=439 439w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/POZGEUlnjJeRKvVDFdiR.jpg?auto=format&amp;w=500 500w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/POZGEUlnjJeRKvVDFdiR.jpg?auto=format&amp;w=571 571w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/POZGEUlnjJeRKvVDFdiR.jpg?auto=format&amp;w=650 650w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/POZGEUlnjJeRKvVDFdiR.jpg?auto=format&amp;w=741 741w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/POZGEUlnjJeRKvVDFdiR.jpg?auto=format&amp;w=845 845w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/POZGEUlnjJeRKvVDFdiR.jpg?auto=format&amp;w=964 964w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/POZGEUlnjJeRKvVDFdiR.jpg?auto=format&amp;w=1098 1098w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/POZGEUlnjJeRKvVDFdiR.jpg?auto=format&amp;w=1252 1252w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/POZGEUlnjJeRKvVDFdiR.jpg?auto=format&amp;w=1428 1428w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/POZGEUlnjJeRKvVDFdiR.jpg?auto=format&amp;w=1600 1600w" loading="lazy"/><figcaption><a href="https://web-gphoto2.rreverser.com/">The same demo</a> running on an Android phone. Picture by <a href="https://twitter.com/DasSurma">Surma</a>.</figcaption></figure><p>For a more in-depth guide on cross-platform usage of WebUSB, see the <a href="https://web.dev/build-for-webusb/#platform-specific-considerations">&#34;Platform-specific considerations&#34; section of &#34;Building a device for WebUSB&#34;</a>.</p><h2 id="adding-a-new-backend-to-libusb">Adding a new backend to libusb <a href="#adding-a-new-backend-to-libusb">#</a></h2><p>Now onto the technical details. While it&#39;s possible to provide a shim API similar to libusb (this has been done by others before) and link other applications against it, this approach is error-prone and makes any further extension or maintenance harder. I wanted to do things right, in a way that could be potentially contributed back upstream and merged into libusb in the future.</p><p>Luckily, the <a href="https://github.com/libusb/libusb/blob/f2b218b61867f27568ba74fa38e156e5f55ed825/README#L13-L15" rel="noopener">libusb README</a> says:</p><p><strong>“libusb is abstracted internally in such a way that it can hopefully be ported to other operating systems. Please see the <a href="https://github.com/libusb/libusb/blob/master/PORTING" rel="noopener">PORTING</a> file for more information.”</strong></p><p>libusb is structured in a way where the public API is separate from &#34;backends&#34;. Those backends are responsible for listing, opening, closing and actually communicating to the devices via the operating system&#39;s low-level APIs. This is how libusb already abstracts away differences between Linux, macOS, Windows, Android, OpenBSD/NetBSD, Haiku and Solaris and works on all these platforms.</p><p>What I had to do was add another backend for the Emscripten+WebUSB &#34;operating system&#34;. The implementations for those backends live in the <a href="https://github.com/libusb/libusb/tree/master/libusb/os" rel="noopener"><code>libusb/os</code></a> folder:</p><web-copy-code><pre><code>~/w/d/libusb $ <span>ls</span> libusb/os</code></pre></web-copy-code><p>Each backend includes the <a href="https://github.com/libusb/libusb/blob/master/libusb/libusbi.h" rel="noopener"><code>libusbi.h</code></a> header with common types and helpers, and needs to expose a <code>usbi_backend</code> variable of type <a href="https://github.com/libusb/libusb/blob/f2b218b61867f27568ba74fa38e156e5f55ed825/libusb/libusbi.h#L886" rel="noopener"><code>usbi_os_backend</code></a>. For example, this is what the <a href="https://github.com/libusb/libusb/blob/6cae9c6dbd74c0840848f343dd605c5ddcef1ad1/libusb/os/windows_common.c#L866-L904" rel="noopener">Windows backend</a> looks like:</p><web-copy-code><pre><code><span>const</span> <span>struct</span> <span>usbi_os_backend</span> usbi_backend <span>=</span> <span>{</span></code></pre></web-copy-code><p>Looking through the properties, we can see that the struct includes the backend name, a set of its capabilities, handlers for various low-level USB operations in form of function pointers, and, finally, sizes to allocate for storing private device-/context-/transfer-level data.</p><p>The private data fields are useful at least for storing OS handles to all those things, as without handles we don&#39;t know which item any given operation applies to. In the web implementation, the OS handles would be the underlying WebUSB JavaScript objects. The natural way to represent and store them in Emscripten is via the <a href="https://emscripten.org/docs/api_reference/val.h.html#_CPPv4N10emscripten10emscripten3valE" rel="noopener"><code>emscripten::val</code></a> class, which is provided as part of <a href="https://emscripten.org/docs/porting/connecting_cpp_and_javascript/embind.html" rel="noopener">Embind</a> (Emscripten&#39;s bindings system).</p><p>Most of the backends in the folder are implemented in C, but a few are implemented in C++. Embind only works with C++, so the choice was made for me and I&#39;ve added <code>libusb/libusb/os/emscripten_webusb.cpp</code> with the required structure and with <code>sizeof(val)</code> for the private data fields:</p><web-copy-code><pre><code><span><span>#</span><span>include</span> <span>&lt;emscripten.h&gt;</span></span></code></pre></web-copy-code><h3 id="storing-webusb-objects-as-device-handles">Storing WebUSB objects as device handles <a href="#storing-webusb-objects-as-device-handles">#</a></h3><p>libusb provides ready-to-use pointers to the allocated area for private data. To work with those pointers as <code>val</code> instances, I&#39;ve added small helpers that construct them in-place, retrieve them as references, and move values out:</p><web-copy-code><pre><code><span>// We store an Embind handle to WebUSB USBDevice in &#34;priv&#34; metadata of</span></code></pre></web-copy-code><h3 id="async-web-apis-in-synchronous-c-contexts">Async web APIs in synchronous C contexts <a href="#async-web-apis-in-synchronous-c-contexts">#</a></h3><p>Now needed a way to handle async WebUSB APIs where libusb expects synchronous operations. For this, I could use Asyncify, or, more specifically, its Embind integration via <a href="https://emscripten.org/docs/api_reference/val.h.html#_CPPv4NK10emscripten10emscripten3val5awaitEv" rel="noopener"><code>val::await()</code></a>.</p><p>I also wanted to correctly handle WebUSB errors and convert them into libusb error codes, but Embind currently doesn&#39;t have any way to handle JavaScript exceptions or <code>Promise</code> rejections from the C++ side. This problem can be worked around by catching a rejection on the JavaScript side and converting the result into an <code>{ error, value }</code> object that can be now safely parsed from the C++ side. I did this with a combination of the <a href="https://emscripten.org/docs/api_reference/emscripten.h.html#c.EM_JS" rel="noopener"><code>EM_JS</code></a> macro and <a href="https://emscripten.org/docs/api_reference/val.h.html#_CPPv4NK10emscripten10emscripten3val9as_handleEv" rel="noopener"><code>Emval.to{Handle, Value}</code></a> APIs:</p><web-copy-code><pre><code><span>EM_JS</span><span>(</span>EM_VAL<span>,</span> em_promise_catch_impl<span>,</span> <span>(</span>EM_VAL handle<span>)</span><span>,</span> <span>{</span></code></pre></web-copy-code><p>Now I could use <code>promise_result::await()</code> on any <code>Promise</code> returned from WebUSB operations and inspect its <code>error</code> and <code>value</code> fields separately.</p><p>For example, retrieving a <code>val</code> representing a <a href="https://developer.mozilla.org/docs/Web/API/USBDevice" rel="noopener"><code>USBDevice</code></a> from <code>libusb_device_handle</code>, calling its <a href="https://developer.mozilla.org/docs/Web/API/USBDevice/open" rel="noopener"><code>open()</code></a> method, awaiting its result, and returning an error code as a libusb status code looks like this:</p><web-copy-code><pre><code><span>int</span> <span>em_open</span><span>(</span>libusb_device_handle <span>*</span>handle<span>)</span> <span>{</span></code></pre></web-copy-code><h3 id="device-enumeration">Device enumeration <a href="#device-enumeration">#</a></h3><p>Of course, before I can open any device, libusb needs to retrieve a list of available devices. The backend must implement this operation via a <code>get_device_list</code> handler.</p><p>The difficulty is that, unlike on other platforms, there is no way to enumerate all the connected USB devices on the web for security reasons. Instead, the flow is split into two parts. First, the web application requests devices with specific properties via <a href="https://developer.mozilla.org/docs/Web/API/USB/requestDevice" rel="noopener"><code>navigator.usb.requestDevice()</code></a> and the user manually chooses which device they want to expose or rejects the permission prompt. Afterwards, the application lists the already approved and connected devices via <a href="https://developer.mozilla.org/docs/Web/API/USB/getDevices" rel="noopener"><code>navigator.usb.getDevices()</code></a>.</p><p>At first I tried to use <code>requestDevice()</code> directly in the implementation of the <code>get_device_list</code> handler. However, showing a permission prompt with a list of connected devices is considered a sensitive operation, and it must be triggered by user interaction (like a button click on a page), otherwise it always returns a rejected promise. libusb applications might often want to list the connected devices upon application start-up, so using <code>requestDevice()</code> was not an option.</p><p>Instead, I had to leave invocation of <code>navigator.usb.requestDevice()</code> to the end developer, and only expose the already approved devices from <code>navigator.usb.getDevices()</code>:</p><web-copy-code><pre><code><span>// Store the global `navigator.usb` once upon initialisation.</span></code></pre></web-copy-code><p>Most of the backend code uses <code>val</code> and <code>promise_result</code> in a similar way as already shown above. There are few more interesting hacks in the data transfer handling code, but those implementation details are less important for the purposes of this article. Make sure to check the code and comments on Github if you&#39;re interested.</p><h2 id="porting-event-loops-to-the-web">Porting event loops to the web <a href="#porting-event-loops-to-the-web">#</a></h2><p>One more piece of the libusb port that I want to discuss is event handling. As described in the previous article, most APIs in system languages like C are synchronous, and event handling is no exception. It&#39;s usually implemented via an infinite loop that &#34;polls&#34; (tries to read data or blocks execution until some data is available) from a set of external I/O sources, and, when at least one of those responds, passes that as an event to the corresponding handler. Once the handler is finished, the control returns to the loop, and it pauses for another poll.</p><p>There are a couple of problems with this approach on the web.</p><p>First, WebUSB doesn&#39;t and cannot expose raw handles of the underlying devices, so polling those directly is not an option. Second, libusb uses <a href="https://man7.org/linux/man-pages/man2/eventfd.2.html" rel="noopener"><code>eventfd</code></a> and <a href="https://man7.org/linux/man-pages/man2/pipe.2.html" rel="noopener"><code>pipe</code></a> APIs for other events as well as for handling transfers on operating systems without raw device handles, but <code>eventfd</code> is not currently supported in Emscripten, and <code>pipe</code>, while supported, <a href="https://github.com/emscripten-core/emscripten/issues/13214" rel="noopener">currently doesn&#39;t conform to the spec</a> and can&#39;t wait for events.</p><p>Finally, the biggest problem is that the web has its own event loop. This global event loop is used for any external I/O operations (including <code>fetch()</code>, timers, or, in this case, WebUSB), and it invokes event or <code>Promise</code> handlers whenever corresponding operations finish. Executing another, nested, infinite event loop will block the browser&#39;s event loop from ever progressing, which means that not only will the UI become unresponsive, but also that the code will never get notifications for the very same I/O events it&#39;s waiting for. This usually results in a deadlock, and that&#39;s what happened when I tried to use libusb in a demo, too. The page froze.</p><p>Like with other blocking I/O, to port such event loops to the web, developers need to find a way to run those loops without blocking the main thread. One way is to refactor the application to handle I/O events in a separate thread and pass the results back to the main one. The other is to use Asyncify to pause the loop and wait for events in a non-blocking fashion.</p><p>I didn&#39;t want to do significant changes to either libusb or gPhoto2, and I&#39;ve already used Asyncify for <code>Promise</code> integration, so that&#39;s the path I&#39;ve chosen. To simulate a blocking variant of <code>poll()</code>, for the initial proof of concept I&#39;ve used a loop as shown below:</p><web-copy-code><pre><code><span><span>#</span><span>ifdef</span> <span>__EMSCRIPTEN__</span></span></code></pre></web-copy-code><p>What it does is:</p><ol><li>Calls <code>poll()</code> to check if any events were reported by the backend yet. If there are some, the loop stops. Otherwise Emscripten&#39;s implementation of <code>poll()</code> will immediately return with <code>0</code>.</li><li>Calls <code>emscripten_sleep(0)</code>. This function uses Asyncify and <code>setTimeout()</code> under the hood and is used here to yield control back to the main browser event loop. This allows the browser to handle any user interactions and I/O events, including WebUSB.</li><li>Check if the specified timeout has expired yet, and, if not, continue the loop.</li></ol><p>As the comment mentions, this approach was not optimal, because it kept saving-restoring the entire call stack with Asyncify even when there were no USB events to handle yet (which is most of the time), and because <code>setTimeout()</code> itself has a minimal duration of 4ms in modern browsers. Still, it worked well enough to produce 13-14 FPS livestream from DSLR in the proof-of-concept.</p><p>Later, I decided to improve it by leveraging the browser event system. There are several ways in which this implementation could be improved further, but for now I&#39;ve chosen to emit custom events directly on the global object, without associating them with a particular libusb data structure. I&#39;ve done so via the following wait and notify mechanism based on the <a href="https://web.dev/emscripten-embedding-js-snippets/#em_async_js-macro"><code>EM_ASYNC_JS</code> macro</a>:</p><web-copy-code><pre><code><span>EM_JS</span><span>(</span><span>void</span><span>,</span> em_libusb_notify<span>,</span> <span>(</span><span>void</span><span>)</span><span>,</span> <span>{</span></code></pre></web-copy-code><p>The <code>em_libusb_notify()</code> function is used whenever libusb tries to report an event, such as data transfer completion:</p><web-copy-code><pre><code><span><span>void</span> <span>usbi_signal_event</span><span>(</span>usbi_event_t <span>*</span>event<span>)</span></span></code></pre></web-copy-code><p>Meanwhile, the <code>em_libusb_wait()</code> part is used to &#34;wake up&#34; from Asyncify sleep when either an <code>em-libusb</code> event is received, or the timeout has expired:</p><web-copy-code><pre><code><span><span>double</span> until_time <span>=</span> <span>emscripten_get_now</span><span>(</span><span>)</span> <span>+</span> timeout_ms<span>;</span></span></code></pre></web-copy-code><p>Due to significant reduction in sleeps and wake-ups, this mechanism fixed the efficiency problems of the earlier <code>emscripten_sleep()</code>-based implementation, and increased the DSLR demo throughput from 13-14 FPS to consistent 30+ FPS, which is enough for a smooth live feed.</p><h2 id="build-system-and-the-first-test">Build system and the first test <a href="#build-system-and-the-first-test">#</a></h2><p>After the backend was done, I had to add it to <code>Makefile.am</code> and <code>configure.ac</code>. The only interesting bit here is Emscripten-specific flags modification:</p><web-copy-code><pre><code>emscripten<span>)</span></code></pre></web-copy-code><p>First, executables on Unix platforms normally don&#39;t have file extensions. Emscripten, however, produces different output depending on which extension you request. I&#39;m using <code>AC_SUBST(EXEEXT, …)</code> to change the executable extension to <code>.html</code> so that any executable within a package—tests and examples—becomes an HTML with Emscripten&#39;s default shell that takes care of loading and instantiating JavaScript and WebAssembly.</p><p>Second, because I&#39;m using Embind and Asyncify, I need to enable those features (<code>--bind -s ASYNCIFY</code>) as well as allow dynamic memory growth (<code>-s ALLOW_MEMORY_GROWTH</code>) via linker parameters. Unfortunately, there is no way for a library to report those flags to the linker, so every application that uses this libusb port will have to add the same linker flags into their build configuration as well.</p><p>Finally, as mentioned earlier, WebUSB requires device enumeration to be done via a user gesture. libusb examples and tests assume that they can enumerate devices at start-up, and fail with an error without changes. Instead, I had to disable automatic execution (<code>-s INVOKE_RUN=0</code>) and expose the manual <code>callMain()</code> method (<code>-s EXPORTED_RUNTIME_METHODS=...</code>).</p><p>Once all of this was done, I could serve the generated files with a static web server, initialize WebUSB, and run those HTML executables manually with the help of DevTools.</p><img alt="Screenshot showing a Chrome window with DevTools open on a locally served `testlibusb` page. DevTools console is evaluating `navigator.usb.requestDevice({ filters: [] })`, which triggered a permission prompt and it&#39;s currently asking the user to choose a USB device that should be shared with the page. ILCE-6600 (a Sony camera) is currently selected." height="626" src="https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/i6dUiRRDtb0ucKX9gHOH.png?auto=format" width="800" decoding="async" sizes="(min-width: 800px) 800px, calc(100vw - 48px)" srcset="https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/i6dUiRRDtb0ucKX9gHOH.png?auto=format&amp;w=200 200w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/i6dUiRRDtb0ucKX9gHOH.png?auto=format&amp;w=228 228w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/i6dUiRRDtb0ucKX9gHOH.png?auto=format&amp;w=260 260w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/i6dUiRRDtb0ucKX9gHOH.png?auto=format&amp;w=296 296w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/i6dUiRRDtb0ucKX9gHOH.png?auto=format&amp;w=338 338w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/i6dUiRRDtb0ucKX9gHOH.png?auto=format&amp;w=385 385w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/i6dUiRRDtb0ucKX9gHOH.png?auto=format&amp;w=439 439w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/i6dUiRRDtb0ucKX9gHOH.png?auto=format&amp;w=500 500w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/i6dUiRRDtb0ucKX9gHOH.png?auto=format&amp;w=571 571w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/i6dUiRRDtb0ucKX9gHOH.png?auto=format&amp;w=650 650w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/i6dUiRRDtb0ucKX9gHOH.png?auto=format&amp;w=741 741w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/i6dUiRRDtb0ucKX9gHOH.png?auto=format&amp;w=845 845w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/i6dUiRRDtb0ucKX9gHOH.png?auto=format&amp;w=964 964w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/i6dUiRRDtb0ucKX9gHOH.png?auto=format&amp;w=1098 1098w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/i6dUiRRDtb0ucKX9gHOH.png?auto=format&amp;w=1252 1252w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/i6dUiRRDtb0ucKX9gHOH.png?auto=format&amp;w=1428 1428w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/i6dUiRRDtb0ucKX9gHOH.png?auto=format&amp;w=1600 1600w" loading="lazy"/> <img alt="Screenshot of the next step, with DevTools still open. After the device was selected, Console has evaluated a new expression `Module.callMain([&#39;-v&#39;])`, which executed the `testlibusb` app in verbose mode. The output shows various detailed information about the previously connected USB camera: manufacturer Sony, product ILCE-6600, serial number, configuration etc." height="824" src="https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/0FhFjozbwA1sqk1Dhx7f.png?auto=format" width="800" decoding="async" sizes="(min-width: 800px) 800px, calc(100vw - 48px)" srcset="https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/0FhFjozbwA1sqk1Dhx7f.png?auto=format&amp;w=200 200w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/0FhFjozbwA1sqk1Dhx7f.png?auto=format&amp;w=228 228w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/0FhFjozbwA1sqk1Dhx7f.png?auto=format&amp;w=260 260w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/0FhFjozbwA1sqk1Dhx7f.png?auto=format&amp;w=296 296w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/0FhFjozbwA1sqk1Dhx7f.png?auto=format&amp;w=338 338w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/0FhFjozbwA1sqk1Dhx7f.png?auto=format&amp;w=385 385w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/0FhFjozbwA1sqk1Dhx7f.png?auto=format&amp;w=439 439w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/0FhFjozbwA1sqk1Dhx7f.png?auto=format&amp;w=500 500w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/0FhFjozbwA1sqk1Dhx7f.png?auto=format&amp;w=571 571w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/0FhFjozbwA1sqk1Dhx7f.png?auto=format&amp;w=650 650w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/0FhFjozbwA1sqk1Dhx7f.png?auto=format&amp;w=741 741w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/0FhFjozbwA1sqk1Dhx7f.png?auto=format&amp;w=845 845w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/0FhFjozbwA1sqk1Dhx7f.png?auto=format&amp;w=964 964w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/0FhFjozbwA1sqk1Dhx7f.png?auto=format&amp;w=1098 1098w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/0FhFjozbwA1sqk1Dhx7f.png?auto=format&amp;w=1252 1252w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/0FhFjozbwA1sqk1Dhx7f.png?auto=format&amp;w=1428 1428w, https://web-dev.imgix.net/image/9oK23mr86lhFOwKaoYZ4EySNFp02/0FhFjozbwA1sqk1Dhx7f.png?auto=format&amp;w=1600 1600w" loading="lazy"/><p>It doesn&#39;t look like much, but, when porting libraries to a new platform, getting to the stage where it produces a valid output for the first time is pretty exciting!</p><h2 id="using-the-port">Using the port <a href="#using-the-port">#</a></h2><p>As mentioned <a href="#build-system-and-the-first-test">above</a>, the port depends on a few Emscripten features that currently need to be enabled at the linking stage of the application. If you want to use this libusb port in your own application, here&#39;s what you&#39;ll need to do:</p><ol><li>Download <a href="https://github.com/RReverser/libusb" rel="noopener">libusb fork</a> either as an archive as part of your build or add it as a git submodule in your project.</li><li>Run <code>autoreconf -fiv</code> in the <code>libusb</code> folder.</li><li>Run <code>emconfigure ./configure –host=wasm32 –prefix=/some/installation/path</code> to initialize the project for cross-compilation and to set a path where you want to put the built artifacts.</li><li>Run <code>emmake make install</code>.</li><li>Point your application or higher-level library to search for the libusb under the earlier chosen path.</li><li>Add the following flags to your application&#39;s link arguments: <code>--bind -s ASYNCIFY -s ALLOW_MEMORY_GROWTH</code>.</li></ol><p>The library currently has a few limitations:</p><ul><li>No transfer cancellation support. This is a limitation of WebUSB, which, in turn, stems from lack of cross-platform transfer cancellation in libusb itself.</li><li>No isochronous transfer support. It shouldn&#39;t be hard to add it by following the implementation of existing transfer modes as examples, but it&#39;s also a somewhat rare mode and I didn&#39;t have any devices to test it on, so for now I left it as unsupported. If you do have such devices, and want to contribute to the library, PRs are welcome!</li><li>The <a href="#important-cross-platform-compatibility-notes">earlier mentioned cross-platform limitations</a>. Those limitations are imposed by operating systems, so not much we can do here, except ask users to override the driver or permissions. However, if you&#39;re porting HID or serial devices, you can follow the libusb example and port some other library to another Fugu API. For example, you could port a C library <a href="https://github.com/libusb/hidapi" rel="noopener">hidapi</a> to <a href="https://web.dev/hid/">WebHID</a> and side-step those issues, associated with low-level USB access, altogether.</li></ul><h2 id="conclusion">Conclusion <a href="#conclusion">#</a></h2><p>In this post I&#39;ve shown how, with the help of Emscripten, Asyncify and Fugu APIs even low-level libraries like libusb can be ported to the web with a few integration tricks.</p><p>Porting such essential and widely used low-level libraries is particularly rewarding, because, in turn, it allows bringing higher-level libraries or even whole applications to the web, too. This opens experiences that were previously limited to users of one or two platforms, to all kinds of devices and operating systems, making those experiences available just a link click away.</p><p>In the next post I&#39;ll walk through the steps involved in building the web gPhoto2 demo which not only retrieves device information, but extensively uses the transfer feature of libusb too. Meanwhile, I hope you found the libusb example inspiring and will try out the demo, play with the library itself, or perhaps even go ahead and port another widely used library to one of the Fugu APIs too.</p><div><p><span>Last updated: <time>Jan 20, 2022</time> </span>— <a href="https://github.com/GoogleChrome/web.dev/blob/main/src/site/content/en/blog/porting-libusb-to-webusb/index.md">Improve article</a></p></div></article></div>
  </body>
</html>
