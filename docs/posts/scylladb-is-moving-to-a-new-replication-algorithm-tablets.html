<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.scylladb.com/2023/07/10/why-scylladb-is-moving-to-a-new-replication-algorithm-tablets/">Original</a>
    <h1>ScyllaDB is Moving to a New Replication Algorithm: Tablets</h1>
    
    <div id="readability-page-1" class="page"><div>
                    <div>
                        <p><strong>How moving from Vnode-based replication to tablets helps dynamically distribute data across the cluster, ultimately increasing ScyllaDB’s elasticity.</strong></p>
<p>Like Apache Cassandra, ScyllaDB has historically decided on replica sets for each partition using Vnodes. The Vnode-based replication strategy tries to evenly distribute the global token space shared by all tables among nodes and shards. It’s very simplistic. Vnodes (token space split points) are chosen randomly, which may cause an imbalance in the actual load on each node. Also, the allocation happens only when adding nodes, and it involves moving large amounts of data, which limits its flexibility. Another problem is that the distribution is shared by all tables in a keyspace, which is not efficient for relatively small tables, whose token space is fragmented into many small chunks.</p>
<p>ScyllaDB now has initial support for a new replication algorithm: <a href="https://github.com/scylladb/scylladb/commit/30cc07b40d6738503074a7d3321a99774a34ada0">tablets</a>. It’s currently in experimental mode.</p>
<p>Tablets allow each table to be laid out differently across the cluster. With tablets, we start from a different side. We divide the resources of the replica-shard into tablets, with a goal of having a fixed target tablet size, and then assign those tablets to serve fragments of tables (also called tablets). This will allow us to balance the load in a more flexible manner by moving individual tablets around. Also, unlike with Vnode ranges, tablet replicas live on a particular shard on a given node, which will allow us to bind Raft groups to tablets.</p>
<p>This new replication algorithm allows each table to make different choices about how it is replicated and for those choices to change dynamically as the table grows and shrinks. It separates the token ownership from servers – ultimately allowing ScyllaDB to scale faster and in parallel.</p>
<p>Tablets require strong consistency from the control plane; this is provided by <a href="https://www.scylladb.com/2023/05/04/scylladbs-path-to-strong-consistency-a-new-milestone/">Raft</a>. We talked about this detail in the ScyllaDB Summit talk below (starting at 17:26).</p>
<p><iframe title="Scylla Summit 2022: The Future of Consensus in ScyllaDB 5.0 and Beyond" width="640" height="360" src="https://www.youtube.com/embed/LoriHUqrzso?start=1046&amp;feature=oembed&amp;enablejsapi=1&amp;origin=https://www.scylladb.com" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe></p>
<h2>Raft vs Lightweight Transactions for Strongly Consistent Tables</h2>
<p>ScyllaDB is in the process of bringing the technology of Raft to user tables and allows users to create strongly consistent tables which are based on Raft. We already provide strong consistency in the form of lightweight transactions, which are Paxos-based, but they have several drawbacks. Generally, lightweight transactions are slow. They require three rounds to replicas for every request and they have poor scaling if there are conflicts between transactions. If there are concurrent conflicting requests, the protocol will retry due to conflict. As a result, they may not be able to make progress. This will not scale well.</p>
<p>Raft doesn’t suffer from this issue. First and foremost, it requires only one round to replicas per-request when you’re on leader or less because it can batch multiple commands in a single request. It also supports pipelining, meaning that it can keep sending commands without waiting for previous commands to be acknowledged. The pipelining goes down to a single CPU on which every following state machine runs. This leads to high throughput.</p>
<p><img decoding="async" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20width=&#39;960&#39;%20height=&#39;540&#39;%20viewBox=&#39;0%200%20960%20540&#39;%3E%3C/svg%3E" alt="" width="960" height="540" data-src="https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT.png" data-srcset="https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT.png 960w, https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-300x169.png 300w, https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-768x432.png 768w" data-sizes="(max-width: 960px) 100vw, 960px"/></p>
<p>But, Raft also has drawbacks in this context. Because there is a single leader, Raft tables may experience latency when the leader dies because the leader has to undergo a failover. Most of the delay is actually due to detection latency because Raft doesn’t switch the leader back and forth so easily. It waits for 1 second until it decides to elect a new leader. Lightweight transactions don’t have this, so they are theoretically more highly available.</p>
<p>Another problem with Raft is that you have to have an extra hop to the leader when the request starts executing not on the leader. This can be remedied by improving drivers to make them leader-aware and route requests to the leader directly. Also, Raft tables require a lot of Raft groups to distribute load among shards evenly. That’s because every request has to go through a single CPU, the leader, and you have to have many such leaders in order to have even load. Lightweight transactions are much easier to distribute.</p>
<p><img decoding="async" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20width=&#39;960&#39;%20height=&#39;540&#39;%20viewBox=&#39;0%200%20960%20540&#39;%3E%3C/svg%3E" alt="" width="960" height="540" data-src="https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-1.png" data-srcset="https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-1.png 960w, https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-1-300x169.png 300w, https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-1-768x432.png 768w" data-sizes="(max-width: 960px) 100vw, 960px"/></p>
<h2>Balancing the Data Across the Cluster</h2>
<p>So let’s take a closer look at this problem. This is how load is distributed currently using our standard partitioning (the Vnode partitioning), which also applies to tables which use lightweight transactions.</p>
<p><img decoding="async" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20width=&#39;960&#39;%20height=&#39;540&#39;%20viewBox=&#39;0%200%20960%20540&#39;%3E%3C/svg%3E" alt="" width="960" height="540" data-src="https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-2.png" data-srcset="https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-2.png 960w, https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-2-300x169.png 300w, https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-2-768x432.png 768w" data-sizes="(max-width: 960px) 100vw, 960px"/></p>
<p>Replication metadata, which is per keyspace, determines the set of replicas for a given key. The request then is routed to every replica. On that replica there is a sharding function which picks the CPU in which the request is served, which owns the data for a given key. The sharding function makes sure that the keys are evenly distributed among CPUs, and this provides good load distribution.</p>
<p><img decoding="async" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20width=&#39;960&#39;%20height=&#39;540&#39;%20viewBox=&#39;0%200%20960%20540&#39;%3E%3C/svg%3E" alt="" width="960" height="540" data-src="https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-3.png" data-srcset="https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-3.png 960w, https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-3-300x169.png 300w, https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-3-768x432.png 768w" data-sizes="(max-width: 960px) 100vw, 960px"/></p>
<p>The story with Raft is a bit different because there is no sharding function which is applied on the replica. Every request which goes to a given Raft group will go to a fixed set of Raft state machines and Raft leader, and their location of CPUs is fixed.</p>
<p><img decoding="async" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20width=&#39;960&#39;%20height=&#39;540&#39;%20viewBox=&#39;0%200%20960%20540&#39;%3E%3C/svg%3E" alt="" width="960" height="540" data-src="https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-4.png" data-srcset="https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-4.png 960w, https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-4-300x169.png 300w, https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-4-768x432.png 768w" data-sizes="(max-width: 960px) 100vw, 960px"/></p>
<p>They have a fixed shard, so the load distribution is not as good as with the sharding function with standard tables.</p>
<p><img decoding="async" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20width=&#39;960&#39;%20height=&#39;540&#39;%20viewBox=&#39;0%200%20960%20540&#39;%3E%3C/svg%3E" alt="" width="960" height="540" data-src="https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-5.png" data-srcset="https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-5.png 960w, https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-5-300x169.png 300w, https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-5-768x432.png 768w" data-sizes="(max-width: 960px) 100vw, 960px"/></p>
<p>The solution to this problem depends on another technology: tablet partitioning.</p>
<h2>Tablet Partitioning</h2>
<p>In tablet partitioning, replication metadata is not per keyspace. Every table has a separate replication metadata. For every table, the range of keys (as with Vnode partitioning) is divided into ranges, and those ranges are called tablets. Every tablet is replicated according to the replication strategy, and the replicas live on a particular shard on the owning node. Unlike with Vnodes, requests will not be routed to nodes which then independently decide on the assignment of the key to the shard, but will rather be routed to specific shards.</p>
<p><img decoding="async" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20width=&#39;960&#39;%20height=&#39;540&#39;%20viewBox=&#39;0%200%20960%20540&#39;%3E%3C/svg%3E" alt="" width="960" height="540" data-src="https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-6.png" data-srcset="https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-6.png 960w, https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-6-300x169.png 300w, https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-6-768x432.png 768w" data-sizes="(max-width: 960px) 100vw, 960px"/></p>
<p>This will give us more control over where data lives, which is managed centrally. This gives us finer control over the distribution of data.</p>
<p>The system will aim to keep the tablets at a manageable size. With too many small tablets, there’s a lot of metadata overhead associated with having tablets. But with too few large tablets, it’s more difficult to balance the load by moving tablets around. A table will start with just a few tablets. For small tables, it may end there. This is a good thing, because unlike with the Vnode partitioning, the data will not be fragmented into many tiny fragments, which adds management overhead and also negatively impacts performance. Data will be localized in large chunks which are easy to process efficiently</p>
<p>As tables grow, as they accumulate data, eventually they will hit a threshold, and will have to be split. Or, the tablet becomes popular with requests hitting it, and it’s beneficial to split it and redistribute the two parts so that the load is more evenly distributed.</p>
<p><img decoding="async" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20width=&#39;960&#39;%20height=&#39;540&#39;%20viewBox=&#39;0%200%20960%20540&#39;%3E%3C/svg%3E" alt="" width="960" height="540" data-src="https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-12.png" data-srcset="https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-12.png 960w, https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-12-300x169.png 300w, https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-12-768x432.png 768w" data-sizes="(max-width: 960px) 100vw, 960px"/></p>
<p>The tablet load balancer decides where to move the tablets, either within the same node to balance the shards or across the nodes to balance the global load in the cluster. This will help to relieve overloaded shards and balance utilization in the cluster, something which current Vnode partitioner cannot do.</p>
<p><img decoding="async" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20width=&#39;960&#39;%20height=&#39;540&#39;%20viewBox=&#39;0%200%20960%20540&#39;%3E%3C/svg%3E" alt="" width="960" height="540" data-src="https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-8.png" data-srcset="https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-8.png 960w, https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-8-300x169.png 300w, https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-8-768x432.png 768w" data-sizes="(max-width: 960px) 100vw, 960px"/></p>
<p>Tablets also help us implement Raft tables. Every Raft group will be associated with exactly one tablet, and the Raft servers will be associated with tablet replicas. Moving a tablet replica also moves the associated Raft server.</p>
<p><img decoding="async" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20width=&#39;960&#39;%20height=&#39;540&#39;%20viewBox=&#39;0%200%20960%20540&#39;%3E%3C/svg%3E" alt="" width="960" height="540" data-src="https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-9.png" data-srcset="https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-9.png 960w, https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-9-300x169.png 300w, https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-9-768x432.png 768w" data-sizes="(max-width: 960px) 100vw, 960px"/></p>
<h2>Additional Benefits: Resharding and Cleanup</h2>
<p>Turns out the tablets will also help with other things. For example, resharding will be very cheap. SSTables are split at the tablet boundary, so resharding is only a logical operation which reassigns tablets to shards.</p>
<p><img decoding="async" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20width=&#39;960&#39;%20height=&#39;540&#39;%20viewBox=&#39;0%200%20960%20540&#39;%3E%3C/svg%3E" alt="" width="960" height="540" data-src="https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-10.png" data-srcset="https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-10.png 960w, https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-10-300x169.png 300w, https://www.scylladb.com/wp-content/uploads/Tomasz-Grabiec-Future-RAFT-10-768x432.png 768w" data-sizes="(max-width: 960px) 100vw, 960px"/></p>
<p>Cleanup is also cheap because cleaning up all data after a topology change is just about deleting the SSTable – there’s no need to rewrite them.</p>
<h2>More from ScyllaDB Engineering</h2>
<h2><img decoding="async" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20width=&#39;300&#39;%20height=&#39;263&#39;%20viewBox=&#39;0%200%20300%20263&#39;%3E%3C/svg%3E" alt="" width="300" height="263" data-src="https://www.scylladb.com/wp-content/uploads/engineering-resources-300x263.png" data-srcset="https://www.scylladb.com/wp-content/uploads/engineering-resources-300x263.png 300w, https://www.scylladb.com/wp-content/uploads/engineering-resources-768x674.png 768w, https://www.scylladb.com/wp-content/uploads/engineering-resources.png 1012w" data-sizes="(max-width: 300px) 100vw, 300px"/></h2>
<p>Want to learn more about what ScyllaDB engineers have been doing with Raft, Rust,and IO scheduling and more  <span>– plus what they’re working on next – take a look at our <a href="https://resources.scylladb.com/scylladb-engineering">library of engineering tech talks and blog</a>.</span></p>

                    </div>
                    
                </div></div>
  </body>
</html>
