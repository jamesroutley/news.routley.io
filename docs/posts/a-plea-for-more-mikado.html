<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dmathieu.com/articles/opinions/mikado/">Original</a>
    <h1>A Plea for More Mikado</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>One of the books that impacted the most my career is probably <a href="https://mikadomethod.info/">The Mikado
Method</a>. I read it almost 10 years ago, and I don’t
practice it explicitly. But I think of the method almost every day, and it has
been impacting how I work ever since.</p><p>And yet, it has remained something quite obscure. Whenever folks suggest
must-read computer science books, it’s never there.
So let’s try to explain it a bit more, and how it can be used every day in the
life of a programmer.</p><p><img src="https://dmathieu.com/images/articles/mikado/mikado.jpg" alt="mikado"/></p><h2 id="what-is-the-mikado-method">What is the Mikado Method?</h2><p>If you ever worked on a large refactoring project, library switch or upgrade,
you may have ended up working in a branch for weeks (or months).</p><p>But somehow you move forward, and one day you are ready to ship that huge change.
The biggest bet still lays ahead of you though: will there be performance
changes? Did we miss something? Were there unknown bugs?</p><p>The Mikado Method is a framework to make that kind of refactoring manageable.</p><p>The idea is to split things into atomic changes. Each of these changes will be
shipped right away, on its own.</p><p>Let’s say you’re working on a Ruby on Rails application which hasn’t been
upgraded in several years. So you need to go from Rails 4 to Rails 7 (wow!).</p><p><img src="https://dmathieu.com/images/articles/mikado/butts.gif" alt="hold onto your butts"/></p><p>Let’s do it with some mikado!</p><p>The first step will be to locally upgrade the rails dependency in your
<code>Gemfile</code> to the final version you want to run on.</p><p>Now, run your unit test suite. Obviously, there will be lots of failures.</p><p>Go through each failure, and for each of them write a new rectangle on the
paper, with a (very) short description of what you would have to do to fix that
issue. If the cause is unknown at that point, you can also write down the
failure itself, to be investigated.</p><p><img src="https://dmathieu.com/images/articles/mikado/graph.png" alt="mikado"/></p><p>Then, <strong>revert your changes</strong>. Delete everything!</p><p><img src="https://dmathieu.com/images/articles/mikado/delete.jpg" alt="delete everything"/></p><p>Now, pick one of the failures you wrote down, any of them and try to fix it in
the current codebase, without the original upgrade.</p><p>And iterate from there against every failure, refactoring or change you need.
If you discover a new issue, write it down and delete everything.</p><p>At some point, you will get a fix which actually works and for which all your
tests pass. <strong>Ship that change</strong>!</p><p><img src="https://dmathieu.com/images/articles/mikado/ship.jpg" alt="ship it"/></p><p>And move on to the next failure.</p><p>Over time, you will get more and more actual fixes, and less and less reverts.
Until all there is left to do is to make the change where you actually change
the content of your Gemfile to upgrade the dependency version.</p><p>At that point, your application supports both versions, making that
change very small and trivial to ship. Do it of course!</p><p>Obviously, the Mikado Method cannot work if you don’t have a good and highly
reliable automated test suite.</p><h2 id="wow-dude-this-is-too-much">Wow dude, this is too much</h2><p>It absolutely is. And I haven’t heard of anyone following this process to the
letter.</p><p>But processes aren’t meant to be followed to the letter. They are meant to
provide a frame.
Once that process is fully understood, getting out of it can be beneficial, to
adapt it to your own needs, while retaining the core ideas and goals of that
process.</p><p>In the case of the Mikado method, I think the biggest takeaways are to ship
atomic changes, and not be afraid to drop things if they derail.</p><h2 id="atomic-everything">Atomic Everything</h2><p>There’s nothing worst (well …) than seeing a Pull Request describing
something, but where other unrelated (yet relevant) changes crept in.</p><p>Whenever I am working on something, and I notice something else in the same bit
of the codebase which should be changed or refactored, I take a note of it, and
come back to it once my original change is ready for review.</p><p><img src="https://dmathieu.com/images/articles/mikado/atomic-pr.jpg" alt="make atomic PRs"/></p><p>One way to cheat about this would be to name the PR “do this and that”. Well,
don’t!</p><p>The gist of it is: split everything you do into the smallest bit possible, and
ship all those bits independently.</p><h3 id="a-failure-of-an-example">A failure of an example</h3><p>Here is an example why thinking about everything atomically is safer.
At $PREVIOUS_EMPLOYER, we wanted to migrate from Opentracing to OpenTelemetry.</p><p>Both libraries are quite similar, but we had some heavy internal things that
couldn’t work exactly the same between both of them, so we wanted to ensure
there were no performance regression with the change.</p><p>I worked for over a month just making the appropriate changes, the PR was huge,
and then I worked for another month just on the benchmarks.</p><p>Due to errors unseen before and uncaught by unit tests, Wwe shipped and
reverted 3 times before deciding to drop a quarter of work and restart from
scratch with small PRs we could ship daily.</p><p>To be fair, this quarter wasn’t entirely lost, since it brought us benchmarks
we wouldn’t have had this soon were it not for a big bang change. But the
frustration was there anyway. And I am sure that if we had decided to keep on
trying to ship that big bang PR, we would have ended up reverting more than 10
times.</p><h2 id="delete-your-wip-code">Delete your WIP code</h2><p>I am sometimes stuck into a fix that seems daunting. The more I fix things, the
more there are to fix, and it seems like I’m never going to get over it.</p><p>Once again, I do mean <strong>delete</strong>. Not squash or branch off of. There is a real
psychological value in deleting a change where you’re stuck to start fresh.</p><p>However, when you do that, you should start working on the new fix right away.
Don’t wait for a couple days.</p><p><img src="https://dmathieu.com/images/articles/mikado/delete-code.jpg" alt="delete code"/></p><p>Said like this, it may seem the need to delete WIP code like this is pretty
exceptional. I’ve personally grown to make it quite standard.</p><p>This can only work because I am a bit extreme about making everything atomic.
So I also very often have something that works and I can commit.</p><h2 id="conclusion">Conclusion</h2><p>Mikado is much like the agile method. It’s something everybody should apply to
some degree, but not follow to the letter.</p><p>It’s probably not something everybody should do as described in the book
(though if you do try it for a large enough project, I’d be happy to hear about
it). But I am convinced that having some experience of it will make anyone a
better developer!</p></div></div></div>
  </body>
</html>
