<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://getboothiq.com/blog/150k-lines-vibe-coded-elixir-good-bad-ugly">Original</a>
    <h1>150k lines of vibe coded Elixir: The good, the bad and the ugly</h1>
    
    <div id="readability-page-1" class="page"><article id="blog-article" phx-hook="CopyHeadingLink">
      <header>
        
        <p><time datetime="2026-01-05">January 05, 2026</time>
          <span>•</span>
          <span>John</span>
        </p>
      </header>

      <nav aria-label="Table of contents">
        
        
      </nav>

      <p><strong>TL;DR:</strong></p><ul><li><strong>Good:</strong> AI is great at Elixir. It gets better as your codebase grows.  </li><li><strong>Bad:</strong> It defaults to defensive, imperative code. You need to be strict about what good Elixir looks like.  </li><li><strong>Ugly:</strong> It can’t debug concurrent test failures. It doesn’t understand that each test runs in an isolated transaction, or that processes have independent lifecycles. It spirals until you step in.  </li><li><strong>Bottom Line:</strong> Even with the drawbacks, the productivity gains are off the charts. I expect it will only get better.  </li></ul><p>
BoothIQ is a universal badge scanner for trade shows. <a href="https://getboothiq.com/blog/we-vibe-coded-our-startup" target="_blank">AI writes 100% of our code</a>. We have 150,000 lines of vibe coded Elixir running in production. Here’s what worked and what didn’t.</p><h3 id="elixir-is-small-it-gets-it-right-the-first-time">
Elixir is Small: It Gets It Right the First Time</h3><p>
Elixir is a small language. Few operators. Small standard library. Only so many ways to control flow. It hasn’t been around for decades. It hasn’t piled up paradigms like .NET or Java, where functional and OOP fight for space.</p><p>
This matters. AI is bad at decisions. If you want your agent to succeed, have it make fewer decisions. With Elixir, Claude doesn’t need to pick between OOP and functional. It doesn’t need to navigate old syntax next to new patterns. There’s one way to skin the cat. Claude finds it.</p><p>
This matters more if you’re adding AI to an existing codebase. In languages where paradigms came and went—often with whatever developer pushed them—Claude tries to match the existing code. The existing code is inconsistent. So Claude is inconsistent.</p><h3 id="elixir-is-terse-longer-sessions-fewer-compactions">
Elixir is Terse: Longer Sessions, Fewer Compactions</h3><p>
Small and terse are related but different. Small means few concepts. Terse means fewer tokens to express the same thing. Go is small but not terse—few concepts, but verbose syntax and explicit error handling everywhere. Elixir is both. We got lucky.</p><p>
Context windows are a real constraint. Elixir uses fewer tokens than most languages. No braces. No semicolons. No verbose boilerplate. I can stay in a working session longer. More iterations. Fewer compactions—those moments when the AI summarizes and forgets earlier context. More context in memory.</p><p>
When I built the React Native version of our app, I hit compactions constantly. JavaScript is small-ish, but it’s not terse. It burns tokens to do what Elixir does with fewer.</p><p>
I also see more compactions when working on heavy HTML and Tailwind in LiveView. Adding, updating, or editing large sections of markup at once. HTML and HEEx templates are token-heavy. But even then, it’s less painful than JavaScript-heavy work.</p><h3 id="tidewave-longer-unassisted-runs">
Tidewave: Longer Unassisted Runs</h3><p><a href="https://github.com/tidewave-ai/tidewave_phoenix" rel="noopener" target="_blank">Tidewave</a> supercharges Elixir-specific context. It lets the agent read logs from the running app—debug, info, error, warning—so you don’t copy/paste logs around. It can query the dev database, see Ecto schemas, and view package documentation. Fewer hallucinations. Longer unassisted runs. The agent can check and validate its own assumptions without human intervention.</p><h3 id="immutability-fewer-decisions-less-code">
Immutability: Fewer Decisions, Less Code</h3><p>
If a variable gets mutated by a function call, AI now has three problems instead of one. The actual feature you want implemented. Whether to work around the mutation or update other call sites to stop mutating. And the mutated data itself—what is it, what was it, what will it be, what can it be?</p><p>
AI ponders all of this and contorts itself into an overly defensive mess. It writes nonsense validation checks and if-statements on mutated data. Defensive code that wouldn’t exist in an immutable language.</p><p>
In Elixir, the data is what it is. It’s not going to change. Fewer decisions. Less code.</p><h3 id="frontend-higher-quality-less-time">
Frontend: Higher Quality, Less Time</h3><p>
I prompt high-level changes—“give the top section more padding”—and Claude does it faster than I could. It’s especially good at modifying or moving large chunks of page structure. Mobile-first views? Easy. Way faster than me, and it’s a better designer than me too.</p><p>
The quality floor has gone way up. You can’t hide behind “I’m not a designer” anymore.</p><h3 id="git-worktrees-build-multiple-features-in-parallel">
Git Worktrees: Build Multiple Features in Parallel</h3><p>
I use three git worktrees, so I can work on up to three features at any given time. Typically a main feature, a slightly less important one, and the third reserved for quick fixes, low priority stuff, or quick experiments.</p><p>
Three is about the limit. Any more and context switching between features becomes the bottleneck.</p><h3 id="ai-cant-organize-architecture-is-still-on-you">
AI Can’t Organize: Architecture Is Still On You</h3><p>
AI is exceptional at churning out lines of code. It’s significantly less exceptional at deciding where those lines should go. It defaults to creating new files everywhere. It repeats code it’s already written. It introduces inconsistencies.</p><p>
This is the “mess” people describe in vibe code projects as they grow. You still need a human making structural decisions.</p><h3 id="trained-on-imperative-it-writes-defensive-code">
Trained on Imperative: It Writes Defensive Code</h3><p>
AI trained mostly on imperative code. Ruby, Python, JavaScript, C#. Elixir looks like Ruby. So Claude writes Ruby-style Elixir—<code>if/then/else</code> chains, defensive nil-checking, early returns that don’t make sense in a functional context.</p><p>
Elixir wants you to be assertive. Pattern match on what you expect. Let it crash if something’s wrong. The process restarts in a good state. This is foreign to most code Claude trained on.</p><p>
This gets better as the codebase grows. Claude sees more assertive patterns. It starts to infer the style. But it still defaults to defensive. I still correct it regularly. Be strict about what good Elixir looks like.</p><h3 id="git-operations-keep-it-out-of-context">
Git Operations: Keep It Out of Context</h3><p>
Every git operation takes context window space. Checking status. Writing commit messages. Describing PRs. That space could go to actual work. Git context goes stale fast—a commit message from 20 minutes ago is worthless after three more changes.</p><p>
When I’m babysitting a feature, I commit manually. Every point I’m happy with. It’s fast. It’s cheap version control. It doesn’t burn context.</p><p>
Claude Code has “checkpoints” now. Internal version control that protects vibe coders without explicit commits. That’s better than AI managing git directly.</p><h3 id="otp-and-async-it-chases-ghosts">
OTP and Async: It Chases Ghosts</h3><p>
Claude is useless for debugging OTP, Task, or async issues. It doesn’t understand how processes, the actor model, and GenServers work together. When it tries to introspect the running system, it feeds itself bad data. It gets very lost.</p><p>
It can course correct when you point out where it went wrong. But on its own, it chases ghosts.</p><h3 id="ecto-sandbox-it-chases-red-herrings">
Ecto Sandbox: It Chases Red Herrings</h3><p>
In Elixir tests, each test runs in a database transaction that rolls back at the end. Tests run async without hitting each other. No test data persists.</p><p>
Claude doesn’t understand this. It uses Tidewave’s dev DB connection and thinks it’s looking at the test DB—which is always empty. A test fails. Claude queries the database. Finds nothing. Thinks there’s a data problem.</p><p>
I’ve watched Claude try to seed the test database so a test will pass. That’s clearly wrong.</p><p>
Other times, two tests insert or query the same schema. Claude doesn’t understand transaction isolation—tests can’t see each other’s data. It confuses itself and recommends disabling async tests altogether. Manageable once you watch for it. But ugly.</p><p>
AI writing all the code has been a massive win. The friction exists, but it’s manageable and doesn’t interfere much with day-to-day work. By far the most important thing: have a consistent, coherent codebase architecture. Without it, you’ll quickly end up with spaghetti code.</p><p>
The goal for this year: automate myself out of a job. That means giving Claude more control over the entire software development lifecycle—from a simple problem statement to a fully tested, working PR that only needs a quick glance before it’s merged and deployed.</p>
    </article></div>
  </body>
</html>
