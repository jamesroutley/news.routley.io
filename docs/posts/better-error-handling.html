<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://meowbark.dev/Better-error-handling">Original</a>
    <h1>Better Error Handling</h1>
    
    <div id="readability-page-1" class="page"><article><p>Bad error handling has cost billions of dollars, crashed planes, killed people, tanked stock markets, wrecked vehicles, and delayed flights. As we reflect on Halloween, it’s fitting to consider these horror stories of software gone wrong. You can read more about them in my <a href="https://meowbark.dev/A-Halloween-scary-story" data-slug="A-Halloween-scary-story">A Halloween scary story</a>, based on true events, or watch this newly minted Fireship video.</p>
<p><iframe allow="fullscreen" frameborder="0" width="600px" src="https://www.youtube.com/embed/Iq_r7IcNmUk"></iframe></p>
<p><em>Thank God I didn’t fly during the CrowStrike incident (see what I did there?).</em></p>
<p>Error handling isn’t just a technical challenge - it’s a critical aspect of software safety and reliability. Yet in TypeScript and JavaScript, it remains something of a wild west. Today, I’ll share an overview of the current landscape and my preferred approaches.</p>

<p>The most common approach is the traditional try/catch method. Everyone is familiar with its basic syntax, which works similarly for both synchronous and asynchronous code:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>async</span><span> function</span><span> fetchUserDataBasic</span><span>(</span><span>userId</span><span>:</span><span> number</span><span>)</span><span>:</span><span> Promise</span><span>&lt;</span><span>UserData</span><span>&gt; {</span></span>
<span data-line=""><span>  try</span><span> {</span></span>
<span data-line=""><span>    const</span><span> profile</span><span> =</span><span> await</span><span> fetchProfileRaw</span><span>(userId);</span></span>
<span data-line=""><span>    const</span><span> posts</span><span> =</span><span> await</span><span> fetchPostsRaw</span><span>(userId);</span></span>
<span data-line=""><span>    return</span><span> { id: userId, profile, posts };</span></span>
<span data-line=""><span>  } </span><span>catch</span><span> (error) {</span></span>
<span data-line=""><span>    throw</span><span> new</span><span> Error</span><span>(</span><span>`Failed to fetch user data: ${</span><span>error</span><span>.</span><span>message</span><span>}`</span><span>);</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>While this works well for simple scenarios, it presents significant challenges when scaled to enterprise-level applications or complex libraries.</p>
<p>For the sake of comparison later with other alternative, let’s consider the scenarios of <strong>API Request Chain with Rate Limiting</strong>.</p>
<p>Consider calling multiple dependent APIs where you need to:</p>
<ul>
<li>Handle rate limit errors specially (by waiting and retrying).</li>
<li>Aggregate errors from multiple calls.</li>
<li>Transform upstream service errors into your API’s error format.</li>
<li>Preserve the original error context for debugging.</li>
</ul>
<p>The code would look somewhat like this:</p>
<figure data-rehype-pretty-code-figure="" id="z3ctgq"><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>// Traditional try/catch approach</span></span>
<span data-line=""><span>type</span><span> UserData</span><span> =</span><span> {</span></span>
<span data-line=""><span>  id</span><span>:</span><span> number</span><span>;</span></span>
<span data-line=""><span>  profile</span><span>:</span><span> string</span><span>;</span></span>
<span data-line=""><span>  posts</span><span>:</span><span> string</span><span>[];</span></span>
<span data-line=""><span>};</span></span>
<span data-line=""> </span>
<span data-line=""><span>type</span><span> ApiError</span><span> =</span><span> { </span><span>type</span><span>:</span><span> &#39;RateLimit&#39;</span><span> } </span><span>|</span><span> { </span><span>type</span><span>:</span><span> &#39;NetworkError&#39;</span><span>; </span><span>message</span><span>:</span><span> string</span><span> };</span></span>
<span data-line=""> </span>
<span data-line=""><span>// Traditional TypeScript with try/catch</span></span>
<span data-line=""><span>// no way to type the possible Error.</span></span>
<span data-line=""><span>async</span><span> function</span><span> fetchUserDataTraditional</span><span>(</span><span>userId</span><span>:</span><span> number</span><span>)</span><span>:</span><span> Promise</span><span>&lt;</span><span>UserData</span><span>&gt; {</span></span>
<span data-line=""><span>  try</span><span> {</span></span>
<span data-line=""><span>    const</span><span> [</span><span>profilePromise</span><span>, </span><span>postsPromise</span><span>] </span><span>=</span><span> [</span></span>
<span data-line=""><span>      fetchProfileRaw</span><span>(userId),</span></span>
<span data-line=""><span>      fetchPostsRaw</span><span>(userId)</span></span>
<span data-line=""><span>    ];</span></span>
<span data-line=""> </span>
<span data-line=""><span>    try</span><span> {</span></span>
<span data-line=""><span>      const</span><span> [</span><span>profile</span><span>, </span><span>posts</span><span>] </span><span>=</span><span> await</span><span> Promise</span><span>.</span><span>all</span><span>([profilePromise, postsPromise]);</span></span>
<span data-line=""><span>      return</span><span> {</span></span>
<span data-line=""><span>        id: userId,</span></span>
<span data-line=""><span>        profile,</span></span>
<span data-line=""><span>        posts,</span></span>
<span data-line=""><span>      };</span></span>
<span data-line=""><span>    } </span><span>catch</span><span> (error) {</span></span>
<span data-line=""><span>      // Handle rate limits by retrying both operations</span></span>
<span data-line=""><span>      if</span><span> (</span><span>isRateLimit</span><span>(error)) {</span></span>
<span data-line=""><span>        await</span><span> delay</span><span>(</span><span>1000</span><span>);</span></span>
<span data-line=""><span>        const</span><span> [</span><span>profile</span><span>, </span><span>posts</span><span>] </span><span>=</span><span> await</span><span> Promise</span><span>.</span><span>all</span><span>([</span></span>
<span data-line=""><span>          fetchProfileRaw</span><span>(userId),</span></span>
<span data-line=""><span>          fetchPostsRaw</span><span>(userId)</span></span>
<span data-line=""><span>        ]);</span></span>
<span data-line=""><span>        return</span><span> {</span></span>
<span data-line=""><span>          id: userId,</span></span>
<span data-line=""><span>          profile,</span></span>
<span data-line=""><span>          posts,</span></span>
<span data-line=""><span>        };</span></span>
<span data-line=""><span>      }</span></span>
<span data-line=""><span>      throw</span><span> error; </span><span>// could have been replaced with anything and no type error!</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>  } </span><span>catch</span><span> (error) {</span></span>
<span data-line=""><span>    throw</span><span> new</span><span> Error</span><span>(</span><span>`Failed to fetch user data: ${</span><span>error</span><span>.</span><span>message</span><span>}`</span><span>);</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>// Helper functions for the traditional approach</span></span>
<span data-line=""><span>async</span><span> function</span><span> fetchProfileRaw</span><span>(</span><span>userId</span><span>:</span><span> number</span><span>)</span><span>:</span><span> Promise</span><span>&lt;</span><span>string</span><span>&gt; {</span></span>
<span data-line=""><span>  const</span><span> result</span><span> =</span><span> await</span><span> fetch</span><span>(</span><span>`/api/profile/${</span><span>userId</span><span>}`</span><span>);</span></span>
<span data-line=""><span>  if</span><span> (</span><span>!</span><span>result.ok) {</span></span>
<span data-line=""><span>    throw</span><span> { </span></span>
<span data-line=""><span>      type: result.status </span><span>===</span><span> 429</span><span> ?</span><span> &#39;RateLimit&#39;</span><span> :</span><span> &#39;NetworkError&#39;</span><span>,</span></span>
<span data-line=""><span>      message: </span><span>await</span><span> result.</span><span>text</span><span>()</span></span>
<span data-line=""><span>    } </span><span>as</span><span> ApiError</span><span>;</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""><span>  return</span><span> result.</span><span>text</span><span>();</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>async</span><span> function</span><span> fetchPostsRaw</span><span>(</span><span>userId</span><span>:</span><span> number</span><span>)</span><span>:</span><span> Promise</span><span>&lt;</span><span>string</span><span>[]&gt; {</span></span>
<span data-line=""><span>  const</span><span> result</span><span> =</span><span> await</span><span> fetch</span><span>(</span><span>`/api/posts/${</span><span>userId</span><span>}`</span><span>);</span></span>
<span data-line=""><span>  if</span><span> (</span><span>!</span><span>result.ok) {</span></span>
<span data-line=""><span>    throw</span><span> { </span></span>
<span data-line=""><span>      type: result.status </span><span>===</span><span> 429</span><span> ?</span><span> &#39;RateLimit&#39;</span><span> :</span><span> &#39;NetworkError&#39;</span><span>,</span></span>
<span data-line=""><span>      message: </span><span>await</span><span> result.</span><span>text</span><span>()</span></span>
<span data-line=""><span>    } </span><span>as</span><span> ApiError</span><span>;</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""><span>  return</span><span> result.</span><span>json</span><span>();</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>

<h2 id="limitations-of-traditional-error-handling">Limitations of Traditional Error Handling<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#limitations-of-traditional-error-handling"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p><em>Previous I made the analogy that try/catch is akin to GOTO statement, which while some agreed, several disagreed. I also mention the analogy to callback hell without going further, which was under explained. I’ve since retracted these comments as it’s not very relevant to the point and is technically not very correct analogies.
While in my humble opinion that error is harder to follow, I’ve realized that good stack trace significantly alleviates the problem of finding the source of error, and so my argument no longer holds a lot of weight.</em></p>
<h3 id="1-type-safety-concerns">1. Type Safety Concerns<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#1-type-safety-concerns"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>While you typically throw Error objects, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/throw">JavaScript allows you to throw anything<svg aria-hidden="true" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a>. This is why in TypeScript, caught errors are typically typed as <code>unknown</code>.</p>
<p>As teams increasingly rely on type-checking for code safety, this limitation becomes more problematic. You can’t be certain what you’re catching, which means your error handling code might itself be prone to errors.</p>
<p>Did you catch the bug in the example above? Hint: it’s line 43
</p><blockquote data-url="Better-error-handling" data-block="#^z3ctgq" data-embed-alias="^z3ctgq"><figure data-rehype-pretty-code-figure="" id="z3ctgq"><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>// Traditional try/catch approach</span></span>
<span data-line=""><span>type</span><span> UserData</span><span> =</span><span> {</span></span>
<span data-line=""><span>  id</span><span>:</span><span> number</span><span>;</span></span>
<span data-line=""><span>  profile</span><span>:</span><span> string</span><span>;</span></span>
<span data-line=""><span>  posts</span><span>:</span><span> string</span><span>[];</span></span>
<span data-line=""><span>};</span></span>
<span data-line=""> </span>
<span data-line=""><span>type</span><span> ApiError</span><span> =</span><span> { </span><span>type</span><span>:</span><span> &#39;RateLimit&#39;</span><span> } </span><span>|</span><span> { </span><span>type</span><span>:</span><span> &#39;NetworkError&#39;</span><span>; </span><span>message</span><span>:</span><span> string</span><span> };</span></span>
<span data-line=""> </span>
<span data-line=""><span>// Traditional TypeScript with try/catch</span></span>
<span data-line=""><span>// no way to type the possible Error.</span></span>
<span data-line=""><span>async</span><span> function</span><span> fetchUserDataTraditional</span><span>(</span><span>userId</span><span>:</span><span> number</span><span>)</span><span>:</span><span> Promise</span><span>&lt;</span><span>UserData</span><span>&gt; {</span></span>
<span data-line=""><span>  try</span><span> {</span></span>
<span data-line=""><span>    const</span><span> [</span><span>profilePromise</span><span>, </span><span>postsPromise</span><span>] </span><span>=</span><span> [</span></span>
<span data-line=""><span>      fetchProfileRaw</span><span>(userId),</span></span>
<span data-line=""><span>      fetchPostsRaw</span><span>(userId)</span></span>
<span data-line=""><span>    ];</span></span>
<span data-line=""> </span>
<span data-line=""><span>    try</span><span> {</span></span>
<span data-line=""><span>      const</span><span> [</span><span>profile</span><span>, </span><span>posts</span><span>] </span><span>=</span><span> await</span><span> Promise</span><span>.</span><span>all</span><span>([profilePromise, postsPromise]);</span></span>
<span data-line=""><span>      return</span><span> {</span></span>
<span data-line=""><span>        id: userId,</span></span>
<span data-line=""><span>        profile,</span></span>
<span data-line=""><span>        posts,</span></span>
<span data-line=""><span>      };</span></span>
<span data-line=""><span>    } </span><span>catch</span><span> (error) {</span></span>
<span data-line=""><span>      // Handle rate limits by retrying both operations</span></span>
<span data-line=""><span>      if</span><span> (</span><span>isRateLimit</span><span>(error)) {</span></span>
<span data-line=""><span>        await</span><span> delay</span><span>(</span><span>1000</span><span>);</span></span>
<span data-line=""><span>        const</span><span> [</span><span>profile</span><span>, </span><span>posts</span><span>] </span><span>=</span><span> await</span><span> Promise</span><span>.</span><span>all</span><span>([</span></span>
<span data-line=""><span>          fetchProfileRaw</span><span>(userId),</span></span>
<span data-line=""><span>          fetchPostsRaw</span><span>(userId)</span></span>
<span data-line=""><span>        ]);</span></span>
<span data-line=""><span>        return</span><span> {</span></span>
<span data-line=""><span>          id: userId,</span></span>
<span data-line=""><span>          profile,</span></span>
<span data-line=""><span>          posts,</span></span>
<span data-line=""><span>        };</span></span>
<span data-line=""><span>      }</span></span>
<span data-line=""><span>      throw</span><span> error; </span><span>// could have been replaced with anything and no type error!</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>  } </span><span>catch</span><span> (error) {</span></span>
<span data-line=""><span>    throw</span><span> new</span><span> Error</span><span>(</span><span>`Failed to fetch user data: ${</span><span>error</span><span>.</span><span>message</span><span>}`</span><span>);</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>// Helper functions for the traditional approach</span></span>
<span data-line=""><span>async</span><span> function</span><span> fetchProfileRaw</span><span>(</span><span>userId</span><span>:</span><span> number</span><span>)</span><span>:</span><span> Promise</span><span>&lt;</span><span>string</span><span>&gt; {</span></span>
<span data-line=""><span>  const</span><span> result</span><span> =</span><span> await</span><span> fetch</span><span>(</span><span>`/api/profile/${</span><span>userId</span><span>}`</span><span>);</span></span>
<span data-line=""><span>  if</span><span> (</span><span>!</span><span>result.ok) {</span></span>
<span data-line=""><span>    throw</span><span> { </span></span>
<span data-line=""><span>      type: result.status </span><span>===</span><span> 429</span><span> ?</span><span> &#39;RateLimit&#39;</span><span> :</span><span> &#39;NetworkError&#39;</span><span>,</span></span>
<span data-line=""><span>      message: </span><span>await</span><span> result.</span><span>text</span><span>()</span></span>
<span data-line=""><span>    } </span><span>as</span><span> ApiError</span><span>;</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""><span>  return</span><span> result.</span><span>text</span><span>();</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>async</span><span> function</span><span> fetchPostsRaw</span><span>(</span><span>userId</span><span>:</span><span> number</span><span>)</span><span>:</span><span> Promise</span><span>&lt;</span><span>string</span><span>[]&gt; {</span></span>
<span data-line=""><span>  const</span><span> result</span><span> =</span><span> await</span><span> fetch</span><span>(</span><span>`/api/posts/${</span><span>userId</span><span>}`</span><span>);</span></span>
<span data-line=""><span>  if</span><span> (</span><span>!</span><span>result.ok) {</span></span>
<span data-line=""><span>    throw</span><span> { </span></span>
<span data-line=""><span>      type: result.status </span><span>===</span><span> 429</span><span> ?</span><span> &#39;RateLimit&#39;</span><span> :</span><span> &#39;NetworkError&#39;</span><span>,</span></span>
<span data-line=""><span>      message: </span><span>await</span><span> result.</span><span>text</span><span>()</span></span>
<span data-line=""><span>    } </span><span>as</span><span> ApiError</span><span>;</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""><span>  return</span><span> result.</span><span>json</span><span>();</span></span>
<span data-line=""><span>}</span></span></code></pre></figure><a href="https://meowbark.dev/Better-error-handling#z3ctgq">Link to original</a></blockquote>
<blockquote data-callout="warning" data-callout-fold="">

<p>The thing that was thrown on line 40 is not an instance of Error, so <code>.message</code> will throw a very unhelpful <code>cannot read property of undefined</code>. Good luck finding out!</p>
</blockquote>
<h3 id="2-lack-of-type-system-integration">2. Lack of Type System Integration<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#2-lack-of-type-system-integration"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>As developers increasingly depend on type-checking, there’s a growing need for the type system to represent potentially throwing code, similar to how <code>Promise</code> indicates asynchronous execution.</p>
<p>Currently, there’s no way to type thrown errors. Code that may throw is indistinguishable from code that won’t. While some developers use <code>@throw</code> in JSDoc comments, relying on optional documentation isn’t a sustainable strategy for critical systems like flight controls or medical devices.</p>

<p>Recent approaches to better error handling share two key principles:</p>
<ol>
<li>Avoid unpredictable control flow jumps</li>
<li>Treat errors as values</li>
</ol>
<p>Instead of throwing errors, these approaches return them, making errors another form of sentinel value (similar to how <code>.indexOf</code> returns <code>-1</code> for failure rather than throwing).</p>
<h2 id="go-style-return-tuples">Go-style: Return Tuples<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#go-style-return-tuples"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Source: <a href="https://go.dev/blog/error-handling-and-go">https://go.dev/blog/error-handling-and-go<svg aria-hidden="true" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a></p>
<p>A very simple example, for starter, could be division by zero.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>type</span><span> Result</span><span>&lt;</span><span>T</span><span>, </span><span>E</span><span>&gt; </span><span>=</span><span> [</span><span>T</span><span>, </span><span>Error</span><span> |</span><span> null</span><span>];</span></span>
<span data-line=""> </span>
<span data-line=""><span>function</span><span> divide</span><span>(</span><span>a</span><span>:</span><span> number</span><span>, </span><span>b</span><span>:</span><span> number</span><span>)</span><span>:</span><span> Result</span><span>&lt;</span><span>number</span><span>&gt; {</span></span>
<span data-line=""><span>  if</span><span> (b </span><span>===</span><span> 0</span><span>) {</span></span>
<span data-line=""><span>    return</span><span> [</span><span>0</span><span>, </span><span>new</span><span> Error</span><span>(</span><span>&#34;Division by zero&#34;</span><span>)];</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""><span>  return</span><span> [a </span><span>/</span><span> b, </span><span>null</span><span>];</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>This approach returns a tuple containing either the result or an error.</p>
<p>Here’s how it looks in a complex scenario.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""> </span>
<span data-line=""><span>// Go-style approach in TypeScript</span></span>
<span data-line=""><span>type</span><span> Result</span><span>&lt;</span><span>T</span><span>&gt; </span><span>=</span><span> [</span><span>T</span><span>, </span><span>ApiError</span><span> |</span><span> null</span><span>];</span></span>
<span data-line=""> </span>
<span data-line=""><span>async</span><span> function</span><span> fetchUserDataGo</span><span>(</span><span>userId</span><span>:</span><span> number</span><span>)</span><span>:</span><span> Promise</span><span>&lt;</span><span>Result</span><span>&lt;</span><span>UserData</span><span>&gt;&gt; {</span></span>
<span data-line=""><span>  // Launch both requests in parallel</span></span>
<span data-line=""><span>  const</span><span> profilePromise</span><span> =</span><span> fetchProfileGo</span><span>(userId);</span></span>
<span data-line=""><span>  const</span><span> postsPromise</span><span> =</span><span> fetchPostsGo</span><span>(userId);</span></span>
<span data-line=""> </span>
<span data-line=""><span>  // Wait for both and check errors</span></span>
<span data-line=""><span>  const</span><span> [</span><span>profileResult</span><span>, </span><span>postsResult</span><span>] </span><span>=</span><span> await</span><span> Promise</span><span>.</span><span>all</span><span>([</span></span>
<span data-line=""><span>    profilePromise,</span></span>
<span data-line=""><span>    postsPromise</span></span>
<span data-line=""><span>  ]);</span></span>
<span data-line=""> </span>
<span data-line=""><span>  const</span><span> [</span><span>profile</span><span>, </span><span>profileErr</span><span>] </span><span>=</span><span> profileResult;</span></span>
<span data-line=""><span>  const</span><span> [</span><span>posts</span><span>, </span><span>postsErr</span><span>] </span><span>=</span><span> postsResult;</span></span>
<span data-line=""> </span>
<span data-line=""><span>  // If either had a rate limit error, retry both after delay</span></span>
<span data-line=""><span>  if</span><span> (profileErr?.type </span><span>===</span><span> &#39;RateLimit&#39;</span><span> ||</span><span> postsErr?.type </span><span>===</span><span> &#39;RateLimit&#39;</span><span>) {</span></span>
<span data-line=""><span>    await</span><span> delay</span><span>(</span><span>1000</span><span>);</span></span>
<span data-line=""><span>    const</span><span> [</span><span>retryProfileResult</span><span>, </span><span>retryPostsResult</span><span>] </span><span>=</span><span> await</span><span> Promise</span><span>.</span><span>all</span><span>([</span></span>
<span data-line=""><span>      fetchProfileGo</span><span>(userId),</span></span>
<span data-line=""><span>      fetchPostsGo</span><span>(userId)</span></span>
<span data-line=""><span>    ]);</span></span>
<span data-line=""> </span>
<span data-line=""><span>    const</span><span> [</span><span>retryProfile</span><span>, </span><span>retryProfileErr</span><span>] </span><span>=</span><span> retryProfileResult;</span></span>
<span data-line=""><span>    const</span><span> [</span><span>retryPosts</span><span>, </span><span>retryPostsErr</span><span>] </span><span>=</span><span> retryPostsResult;</span></span>
<span data-line=""> </span>
<span data-line=""><span>    if</span><span> (retryProfileErr </span><span>!==</span><span> null</span><span>) {</span></span>
<span data-line=""><span>      return</span><span> [</span><span>null</span><span>, retryProfileErr];</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    if</span><span> (retryPostsErr </span><span>!==</span><span> null</span><span>) {</span></span>
<span data-line=""><span>      return</span><span> [</span><span>null</span><span>, retryPostsErr];</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> [{</span></span>
<span data-line=""><span>      id: userId,</span></span>
<span data-line=""><span>      profile: retryProfile,</span></span>
<span data-line=""><span>      posts: retryPosts</span></span>
<span data-line=""><span>    }, </span><span>null</span><span>];</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""> </span>
<span data-line=""><span>  // Check original errors if not rate limited</span></span>
<span data-line=""><span>  if</span><span> (profileErr </span><span>!==</span><span> null</span><span>) {</span></span>
<span data-line=""><span>    return</span><span> [</span><span>null</span><span>, profileErr];</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""><span>  if</span><span> (postsErr </span><span>!==</span><span> null</span><span>) {</span></span>
<span data-line=""><span>    return</span><span> [</span><span>null</span><span>, postsErr];</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""> </span>
<span data-line=""><span>  return</span><span> [{</span></span>
<span data-line=""><span>    id: userId,</span></span>
<span data-line=""><span>    profile,</span></span>
<span data-line=""><span>    posts</span></span>
<span data-line=""><span>  }, </span><span>null</span><span>];</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>// Helper functions for Go style</span></span>
<span data-line=""><span>async</span><span> function</span><span> fetchProfileGo</span><span>(</span><span>userId</span><span>:</span><span> number</span><span>)</span><span>:</span><span> Promise</span><span>&lt;</span><span>Result</span><span>&lt;</span><span>string</span><span>&gt;&gt; {</span></span>
<span data-line=""><span>  try</span><span> {</span></span>
<span data-line=""><span>    const</span><span> result</span><span> =</span><span> await</span><span> fetch</span><span>(</span><span>`/api/profile/${</span><span>userId</span><span>}`</span><span>);</span></span>
<span data-line=""><span>    if</span><span> (</span><span>!</span><span>result.ok) {</span></span>
<span data-line=""><span>      const</span><span> error</span><span>:</span><span> ApiError</span><span> =</span><span> {</span></span>
<span data-line=""><span>        type: result.status </span><span>===</span><span> 429</span><span> ?</span><span> &#39;RateLimit&#39;</span><span> :</span><span> &#39;NetworkError&#39;</span><span>,</span></span>
<span data-line=""><span>        message: </span><span>await</span><span> result.</span><span>text</span><span>()</span></span>
<span data-line=""><span>      };</span></span>
<span data-line=""><span>      return</span><span> [</span><span>&#34;&#34;</span><span>, error];</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    return</span><span> [</span><span>await</span><span> result.</span><span>text</span><span>(), </span><span>null</span><span>];</span></span>
<span data-line=""><span>  } </span><span>catch</span><span> (error) {</span></span>
<span data-line=""><span>    return</span><span> [</span><span>&#34;&#34;</span><span>, { type: </span><span>&#39;NetworkError&#39;</span><span>, message: </span><span>String</span><span>(error) }];</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>async</span><span> function</span><span> fetchPostsGo</span><span>(</span><span>userId</span><span>:</span><span> number</span><span>)</span><span>:</span><span> Promise</span><span>&lt;</span><span>Result</span><span>&lt;</span><span>string</span><span>[]&gt;&gt; {</span></span>
<span data-line=""><span>  try</span><span> {</span></span>
<span data-line=""><span>    const</span><span> result</span><span> =</span><span> await</span><span> fetch</span><span>(</span><span>`/api/posts/${</span><span>userId</span><span>}`</span><span>);</span></span>
<span data-line=""><span>    if</span><span> (</span><span>!</span><span>result.ok) {</span></span>
<span data-line=""><span>      const</span><span> error</span><span>:</span><span> ApiError</span><span> =</span><span> {</span></span>
<span data-line=""><span>        type: result.status </span><span>===</span><span> 429</span><span> ?</span><span> &#39;RateLimit&#39;</span><span> :</span><span> &#39;NetworkError&#39;</span><span>,</span></span>
<span data-line=""><span>        message: </span><span>await</span><span> result.</span><span>text</span><span>()</span></span>
<span data-line=""><span>      };</span></span>
<span data-line=""><span>      return</span><span> [[], error];</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    return</span><span> [</span><span>await</span><span> result.</span><span>json</span><span>(), </span><span>null</span><span>];</span></span>
<span data-line=""><span>  } </span><span>catch</span><span> (error) {</span></span>
<span data-line=""><span>    return</span><span> [[], { type: </span><span>&#39;NetworkError&#39;</span><span>, message: </span><span>String</span><span>(error) }];</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>const</span><span> delay</span><span> =</span><span> (</span><span>ms</span><span>:</span><span> number</span><span>) </span><span>=&gt;</span><span> new</span><span> Promise</span><span>(</span><span>resolve</span><span> =&gt;</span><span> setTimeout</span><span>(resolve, ms));</span></span>
<span data-line=""><span>const</span><span> isRateLimit</span><span> =</span><span> (</span><span>error</span><span>:</span><span> unknown</span><span>)</span><span>:</span><span> error</span><span> is</span><span> ApiError</span><span> =&gt;</span><span> </span></span>
<span data-line=""><span>  (error </span><span>as</span><span> ApiError</span><span>)?.type </span><span>===</span><span> &#39;RateLimit&#39;</span><span>;</span></span></code></pre></figure>
<p>A library that can make this process easier is <a href="https://github.com/thelinuxlich/go-go-try">go-go-try<svg aria-hidden="true" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a>. Theo also covered a proposal to have this approach integrated into the language.</p>
<p><iframe allow="fullscreen" frameborder="0" width="600px" src="https://www.youtube.com/embed/lng6dmrWg8A"></iframe></p>
<h2 id="monadic-style-result-types">Monadic Style: Result Types<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#monadic-style-result-types"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p><img src="https://i.imgflip.com/98lel2.jpg" alt=""/></p>
<p>While “monad” sounds intimidating, think of it as a container for values that might fail - similar to how <code>Promise</code> is a container for a future value. In error handling, this usually takes the form of <code>Either&lt;L,R&gt;</code> (Scala/Haskell) or <code>Result&lt;T,E&gt;</code> (Rust - <a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html">Check guide here<svg aria-hidden="true" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a>).</p>
<p>A brief demo for how it works in simple case.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>import</span><span> { Result, ok, err } </span><span>from</span><span> &#39;neverthrow&#39;</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>// Simple example</span></span>
<span data-line=""><span>function</span><span> divideMonadic</span><span>(</span><span>a</span><span>:</span><span> number</span><span>, </span><span>b</span><span>:</span><span> number</span><span>)</span><span>:</span><span> Result</span><span>&lt;</span><span>number</span><span>, </span><span>Error</span><span>&gt; {</span></span>
<span data-line=""><span>  return</span><span> b </span><span>===</span><span> 0</span></span>
<span data-line=""><span>    ?</span><span> err</span><span>(</span><span>new</span><span> Error</span><span>(</span><span>&#39;Division by zero&#39;</span><span>))</span></span>
<span data-line=""><span>    :</span><span> ok</span><span>(a </span><span>/</span><span> b);</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>// alternative, these system often have a &#34;entrypoint&#34; type of function to convert into the monadic system like so.</span></span>
<span data-line=""><span>function</span><span> divideMonadic2</span><span>(</span><span>a</span><span>:</span><span> number</span><span>, </span><span>b</span><span>:</span><span> number</span><span>)</span><span>:</span><span> Result</span><span>&lt;</span><span>number</span><span>, </span><span>Error</span><span>&gt; {</span></span>
<span data-line=""><span> // entrypoint &#34;fromThrowable&#34; capture the fallible system into the monadic framework.</span></span>
<span data-line=""><span> return</span><span> Result.</span><span>fromThrowable</span><span>(a </span><span>/</span><span> b, () </span><span>=&gt;</span><span> new</span><span> Error</span><span>(</span><span>&#39;Division by zero&#39;</span><span>))</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>// Usage showing composition</span></span>
<span data-line=""><span>const</span><span> result</span><span> =</span><span> divideMonadic</span><span>(</span><span>10</span><span>, </span><span>2</span><span>)</span></span>
<span data-line=""><span>  .</span><span>map</span><span>(</span><span>n</span><span> =&gt;</span><span> n </span><span>*</span><span> 2</span><span>)</span></span>
<span data-line=""><span>  .</span><span>mapErr</span><span>(</span><span>e</span><span> =&gt;</span><span> new</span><span> Error</span><span>(</span><span>`Calculation error: ${</span><span>e</span><span>.</span><span>message</span><span>}`</span><span>));</span></span></code></pre></figure>
<p>Here’s how it looks in practice (using <a href="https://github.com/supermacro/neverthrow"><code>neverthrow</code><svg aria-hidden="true" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a>):</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>import</span><span> { Result, ResultAsync, err } </span><span>from</span><span> &#39;neverthrow&#39;</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>// Types</span></span>
<span data-line=""><span>type</span><span> UserData</span><span> =</span><span> {</span></span>
<span data-line=""><span>  id</span><span>:</span><span> number</span><span>;</span></span>
<span data-line=""><span>  profile</span><span>:</span><span> string</span><span>;</span></span>
<span data-line=""><span>  posts</span><span>:</span><span> string</span><span>[];</span></span>
<span data-line=""><span>};</span></span>
<span data-line=""> </span>
<span data-line=""><span>// It&#39;s typical in these community to have union type that represents all possible way a module can fail.</span></span>
<span data-line=""><span>type</span><span> ApiError</span><span> =</span><span> { </span><span>type</span><span>:</span><span> &#39;RateLimit&#39;</span><span> } </span><span>|</span><span> { </span><span>type</span><span>:</span><span> &#39;NetworkError&#39;</span><span>; </span><span>message</span><span>:</span><span> string</span><span> };</span></span>
<span data-line=""> </span>
<span data-line=""><span>// API functions</span></span>
<span data-line=""><span>function</span><span> fetchProfile</span><span>(</span><span>userId</span><span>:</span><span> number</span><span>)</span><span>:</span><span> ResultAsync</span><span>&lt;</span><span>string</span><span>, </span><span>ApiError</span><span>&gt; {</span></span>
<span data-line=""><span>  // Implementation not shown, but typically these systems provide methods to &#34;enter the Result&#34; system, like fromPromise</span></span>
<span data-line=""><span>  return</span><span> ResultAsync.</span><span>fromPromise</span><span>(</span><span>/* ... */</span><span>);</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>function</span><span> fetchUserPosts</span><span>(</span><span>userId</span><span>:</span><span> number</span><span>)</span><span>:</span><span> ResultAsync</span><span>&lt;</span><span>string</span><span>[], </span><span>ApiError</span><span>&gt; {</span></span>
<span data-line=""><span>  // Implementation not shown</span></span>
<span data-line=""><span>  return</span><span> ResultAsync.</span><span>fromPromise</span><span>(</span><span>/* ... */</span><span>);</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>// Main business logic</span></span>
<span data-line=""><span>function</span><span> fetchUserData</span><span>(</span><span>userId</span><span>:</span><span> number</span><span>)</span><span>:</span><span> ResultAsync</span><span>&lt;</span><span>UserData</span><span>, </span><span>ApiError</span><span>&gt; {</span></span>
<span data-line=""><span>  const</span><span> profileResult</span><span> =</span><span> withRetry</span><span>(</span><span>fetchProfile</span><span>(userId));</span></span>
<span data-line=""><span>  const</span><span> postsResult</span><span> =</span><span> withRetry</span><span>(</span><span>fetchUserPosts</span><span>(userId));</span></span>
<span data-line=""> </span>
<span data-line=""><span>  return</span><span> ResultAsync.</span><span>combine</span><span>([profileResult, postsResult])</span></span>
<span data-line=""><span>    .</span><span>map</span><span>(([</span><span>profile</span><span>, </span><span>posts</span><span>]) </span><span>=&gt;</span><span> ({</span></span>
<span data-line=""><span>      id: userId,</span></span>
<span data-line=""><span>      profile,</span></span>
<span data-line=""><span>      posts,</span></span>
<span data-line=""><span>    }));</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>// Helpers</span></span>
<span data-line=""><span>const</span><span> delay</span><span> =</span><span> (</span><span>ms</span><span>:</span><span> number</span><span>) </span><span>=&gt;</span><span> new</span><span> Promise</span><span>(</span><span>resolve</span><span> =&gt;</span><span> setTimeout</span><span>(resolve, ms));</span></span>
<span data-line=""> </span>
<span data-line=""><span>const</span><span> withRetry</span><span> =</span><span> &lt;</span><span>T</span><span>&gt;(</span><span>ra</span><span>:</span><span> ResultAsync</span><span>&lt;</span><span>T</span><span>, </span><span>ApiError</span><span>&gt;)</span><span>:</span><span> ResultAsync</span><span>&lt;</span><span>T</span><span>, </span><span>ApiError</span><span>&gt; </span><span>=&gt;</span><span> </span></span>
<span data-line=""><span>  // functional style where developer &#34;attach&#34; logic in the form of callbacks</span></span>
<span data-line=""><span>  // orElse: https://github.com/supermacro/neverthrow?tab=readme-ov-file#resultasyncorelse-method</span></span>
<span data-line=""><span>  ra.</span><span>orElse</span><span>(</span><span>error</span><span> =&gt;</span><span> </span></span>
<span data-line=""><span>    error.type </span><span>===</span><span> &#39;RateLimit&#39;</span></span>
<span data-line=""><span>      ?</span><span> delay</span><span>(</span><span>1000</span><span>).</span><span>then</span><span>(() </span><span>=&gt;</span><span> ra)</span></span>
<span data-line=""><span>      :</span><span> err</span><span>(error)</span></span>
<span data-line=""><span>  );</span></span></code></pre></figure>
<p>These system tuck the difficulty of control flow behind a framework (theoretically known as Monad). You as the application developer will work with the data and error through via attaching “callbacks”. Error and data transformation can be done via these methods.</p>
<p>You can find implementations of this pattern in functional programming libraries like <a href="https://effect.website/docs/error-management/expected-errors/"><code>Effect</code><svg aria-hidden="true" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> or <a href="https://www.npmjs.com/package/oxide.ts/v/1.0.0-next.6#new-in-10">Oxide-ts<svg aria-hidden="true" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> and <a href="https://github.com/supermacro/neverthrow">neverthrow<svg aria-hidden="true" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a>.</p>

<p>In discussions with my colleagues at HubSpot, we’ve found that for typical frontend applications - especially those using <code>tanstack/query</code> or <code>apolloClient</code> for network error handling - the traditional try/catch approach often suffices. <strong>The shorter your data journey is to the layer that handles the error, the less useful the other alternatives bring.</strong></p>
<p><img src="https://meowbark.dev/excalidraw/Better-error-handling-2024-11-03-14.30.17.excalidraw.svg" width="auto" height="auto" alt=""/></p>
<p>The Go-style approach offers simplicity and accessibility, though it requires eager error handling which can <strong>result in extreme verbosity</strong>. The monadic style provides more features, like boolean operations and chaining multiple fallible operations, while maintaining lazy evaluation. However, <strong>its learning curve and API complexity can be challenging</strong>, especially for junior developers, or folks who disliked functional programming paradigm.</p>
<p>As one Redditor aptly criticized Effect and similar functional programming tools:</p>
<blockquote>
<p>“…the cognitive burden of this approach is effectively the same as an entirely different programming language. All of the benefits and costs are mostly the same, but because the <em>language</em> stays the same, time isn’t allotted for stuff like the several days it takes to become comfortable with a different mental model like it otherwise would be.
…
If you adopt this, do it with open eyes and be prepared to have ‘TS repos’ and ‘Effect repos’ and engineers who are familiar with one, but not the other, and the necessity of onboarding new engineers as if you were training them in a new programming language.
<strong>Large scale, paradigm-shifting user-space libraries like this are almost never a good choice unless the entire organization is willing to buy into them for every project in the language.</strong>”</p>
<ul>
<li>u/<a href="https://www.reddit.com/user/oorza/">oorza<svg aria-hidden="true" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a></li>
</ul>
</blockquote>
<p>Also, it’s common practice so have a layer somewhere in your codebase that handles the remaining recoverable error. Once an error is caught, it’s possible to identify where it originated from in form of a stack trace. This isn’t something that returning error as value provides, and it can be a bit of a problem to find exactly where the error may comes from, especially if there’s some error mapping somewhere else before it reached this layer.</p>
<p>In Rust, (to the best of my knowledge), only <code>anyhow</code> crates enable back trace for Result type. Otherwise this is not the default behavior.</p>

<p>Reddit: <a href="https://www.reddit.com/r/typescript/comments/1gi5zul/error_handling_in_typescript/">https://www.reddit.com/r/typescript/comments/1gi5zul/error_handling_in_typescript/<svg aria-hidden="true" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a></p>
<h2 id="additional-context-panic-vs-recoverable-errors">Additional Context: Panic vs. Recoverable Errors<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#additional-context-panic-vs-recoverable-errors"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>A significant point raised by the community is the distinction between panic/unrecoverable errors and normal error handling:</p>
<blockquote>
<p>Panics and error return types are two different issues… In Rust you have results that can be an error and you have system failures that can panic. If you have a panic it’s the equivalent of a non catchable error in JS, it will simply kill that program because it doesn’t know what to do.</p>
</blockquote>
<blockquote>
<p>The typical practice is to use errors-as-values for recoverable errors… Irrecoverable errors can still be exceptions. There’s not much you can do except let them bubble up and terminate the program.</p>
</blockquote>
<p>This helps explain why even languages like Go and Rust, which primarily use errors-as-values, still have concepts like <code>panic</code>:</p>
<blockquote>
<p>Go/Rust style error handling sucks and is incomplete. Both of these languages have the concept of a “panic” to deal with the fact that “errors as values” is a broken concept with gaping holes in it.</p>
</blockquote>
<h2 id="the-check-everything-controversy">The “Check Everything” Controversy<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#the-check-everything-controversy"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>An interesting debate emerged about the necessity of checking every possible error:</p>
<blockquote>
<p>The problem with “errors as values” is that literally every single line of code can potentially error. So if you truly want to be absolutely safe, you have to check for an error after every single calculation in your code.</p>
</blockquote>
<p>However, this was contested by others:</p>
<blockquote>
<p>In JS world this could be true, but for Rust (and statically typed compiled languages in general) this is actually not the case… GO pointers are the only exceptions to this. There are no nil check protection at compile level. But Rust, kotlin etc are solid.</p>
</blockquote>
<h2 id="practical-implementation-strategies">Practical Implementation Strategies<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#practical-implementation-strategies"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<blockquote>
<p>Not saying I agree, but if you follow OP’s thinking, runtime errors thrown by external libraries should be caught by your code as soon as possible, then wrapped in whatever data structure you deem appropriate.</p>
</blockquote>
<p>Which explains <code>fromPromise</code> methods (and friends) found in <code>neverthrow</code> implementation.</p>
<h2 id="in-defense-of-trycatch">In Defense of Try/Catch<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#in-defense-of-trycatch"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Several developers make compelling arguments for try/catch:</p>
<blockquote>
<p>The performance cost of throwing an exception matters very little, because you only pay it when an exception is actually thrown. With errors as values, you are ALWAYS paying the performance cost because you have to constantly check for errors even when no error has occurred!</p>
</blockquote>
<blockquote>
<p>If you need to do cleanup, then that is what the finally block is for. Languages like C# has had the using keyword to allow you to automatically do cleanup, and typescript has gotten a very similar using keyword […] which gives you some nice syntactic sugar to do what the finally block is for traditionally.</p>
</blockquote>
<blockquote>
<p>Try/catch/finally has very specific rules on how it works. I find code protected by exceptions a lot easier to reason about than code that has if err plastered all over it.</p>
</blockquote>
<blockquote>
<p>They’re all just patterns that you follow depending on the language implementation. Of course, JS/TS’s try catch implementation is egregiously bad compared to all the rest of them… but… that’s a languiage issue not a “which style is better” issue
As far as I have been able to see, you don’t write any better code if you have a system that throws versus a system that doesn’t, either way, it’s your problem when you write code that fails, and you’ll handle it according to the methods available in the specific language.
You don’t ever have to throw in Javascript. But if you never catch, then you’re going to have the worst error handling.</p>
</blockquote>
<blockquote>
<p>Try catch has a very long history in programming languages.</p>
</blockquote>
<h2 id="arguments-for-alternative-approaches">Arguments for Alternative Approaches<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#arguments-for-alternative-approaches"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>However, many developers recognize limitations with try/catch, particularly in TypeScript:</p>
<blockquote>
<p>In JS/TS you can’t easily distinguish what type of error occurred and thus handle it accordingly. It could truly be anything.</p>
</blockquote>
<blockquote>
<p>In JavaScript you can throw any value. throw 42 is perfectly legal.</p>
</blockquote>
<blockquote>
<p>The typical practice is to use errors-as-values for recoverable errors, like “the user didn’t enter a valid email address” (so we need to handle that error and take a specific action, such as showing them a nice validation error and letting them try again).</p>
</blockquote>
<h2 id="arguments-against-alternative-approaches">Arguments against Alternative approaches<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#arguments-against-alternative-approaches"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>The community highlights important tradeoffs about performance and DX concerns.</p>
<blockquote>
<p>People have benchmarked this. Code that uses errors as values is significantly slower than code that uses exceptions.</p>
</blockquote>
<blockquote>
<p>I write mainly Go code at the moment. A big proportion of the code are the three lines <code>if err != nil { return nil, err }</code>. It really isn’t that great an experience.</p>
</blockquote>
<blockquote>
<p>You want to us to wrap all our return types? This would create massive overhead to handle a very small annoyance.
Also, we still need to handle exceptions which occur due to runtime errors.</p>
</blockquote>

<p>While I personally favor the Rust approach and would use <code>oxide-ts</code> / <code>neverthrow</code> in new projects, the choice of error handling strategy should align with your team’s expertise and project requirements. Simple applications might be well-served by traditional try/catch, while more complex systems might benefit from the type safety and explicitness of Result types.</p>
<p><img src="https://meowbark.dev/excalidraw/Better-error-handling-2024-11-03-15.05.02.excalidraw.svg" width="auto" height="auto" alt=""/>
<strong>Here’s my unhelpful flow chart.</strong></p>
<p><strong>What’s your preferred approach to error handling? Share your thoughts in the comments below!</strong></p></article></div>
  </body>
</html>
