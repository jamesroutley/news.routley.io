<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.natemeyvis.com/writing/on-ankis-database-structure/">Original</a>
    <h1>On Anki&#39;s Database</h1>
    
    <div id="readability-page-1" class="page"><div id="gh-main">
    <article>
        <header>
                <span>
                    By <a href="https://www.natemeyvis.com/author/nate/">Nate Meyvis</a>
                    —
                    <time datetime="2022-02-22">Feb 22, 2022</time>
                </span>

            


        </header>

        <div>
            <p>I am a daily <a href="https://apps.ankiweb.net">Anki</a> user (I describe how and why <a href="https://www.natemeyvis.com/writing/on-using-anki/">here</a> and <a href="https://www.natemeyvis.com/writing/on-anki-again/">here</a>). I&#39;ve been working with my Anki data lately, which has meant exposing and manipulating the <a href="https://www.sqlite.org/index.html">Sqlite</a> database underlying the program. (I&#39;m grateful to the <a href="https://github.com/ankidroid/Anki-Android/wiki/Database-Structure">Ankidroid</a> project and <a href="https://www.reddit.com/r/Anki/">r/anki</a>  for having documented so much about the .apkg format and the database itself.)</p><p>The database structure is fairly typical of data management in long-running projects. And, typically, some of its design looks rough to fresh eyes. When fresh eyes see rough parts of a software project, <a href="https://danluu.com/wat/">it&#39;s important to write about it promptly</a>, and the Anki community is large and dedicated enough that it seems worth doing that writing in public. So here&#39;s what I think could be better.</p><h3 id="caveats">Caveats</h3><ol><li>Anki is, I think, maintained by a very small team. Some of the notes about the intelligibility of the schema matter less if there aren&#39;t many people who need to work with the database every day. You can think of the relevant notes as things that are merely suboptimal now and <em>would</em> be more damaging <em>if</em> the Anki project were to grow.</li><li>The underlying database is, I think, not (or at least not primarily) intended for direct manipulation by program users. So there&#39;s a sense in which it doesn&#39;t matter very much how intelligible <em>I</em> think the data management is. That said, insofar as it affects the accuracy or performance of the software, it certainly matters. And given that people turn over parts of their minds to Anki, it&#39;s especially urgent to document these things.</li><li>Anki is great and all this comes from a place of love.</li></ol><h3 id="principles-behind-these-notes">Principles behind these notes</h3><p>You can think of this as a data-oriented extension of my <a href="https://www.natemeyvis.com/code-review-reference/">code review reference</a>; this is all stuff I find myself saying <em>a lot</em>. Seeing so many of these issues crop up in Anki&#39;s database was one impetus for making a case study of it.</p><ol><li>Try to name columns (or tables, or documents, or whatever) according to <em>what the thing is</em>. Not its domain, not what you want it some day to be, and not even its intended use, but what it <em>is</em>.</li><li>Unless you have a very good reason to <a href="https://en.wikipedia.org/wiki/Denormalization">denormalize</a> your data, represent a given piece of information at most once in your database.</li><li>Unless you <em>really</em> need to optimize something, make a given column represent only one piece of information. (You know those surveys where you rank things on a 1-7 scale, but &#34;4&#34; also means &#34;not applicable&#34;? Do better than that.)</li><li>All else equal (and sometimes even if not), use consistent conventions (e.g., for naming, for delimiters, and for <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUIDs</a>).</li></ol><h3 id="notes">Notes</h3><ol><li>In the <code>cards</code> and <code>notes</code> tables, the <code>id</code> (primary key) field is the number of milliseconds since the epoch when it was created. There are good reasons not to have semantically meaningful information in the <code>id</code> field: in this case, it is entirely possible for several cards to be created at the same millisecond. (The foreseen use case is that of a single human creating cards manually, but what if the system scales to many users with many cards? What if cron jobs that go off at midnight generate new cards? What if cards are created from timestamps that only have second-, hour-, or day-level resolution?)</li><li>In the <code>cards</code> table, the <code>type</code> and <code>queue</code> columns duplicate information and both express what I&#39;d be tempted to call a &#34;learning status&#34; (whether the card is new, is being reviewed, is buried, and so on). The database would be cleaner with these collapsed into a single column with a better name.</li><li>In the <code>cards</code> table, several columns have integers representing times or durations for which the units are different depending on some other feature of the card. For example, the <code>due</code> column is an integer representing either a number of days or a number of seconds, depending on the card status. I could imagine a case for splitting this out into separate columns. It&#39;s also worth considering not explicitly storing the data at all, because it&#39;s a function of other data (and the learning algorithm). Because most decks are not huge, it could probably could be calculated on demand (or, if it really needs to be precomputed, cached elsewhere). </li><li>The <code>cards</code> table has a <code>reps</code> column indicating its number of repetitions. This duplicates information from the <code>revlog</code> table. One could imagine a situation where information needs to be denormalized in this way, but (i) this system is clearly not designed for the sort of scale that would require that (see other notes) and (ii) if so, it would probably be better to keep &#34;source of truth&#34; <code>cards</code> data in a separate table and generate separate denormalized views or tables. Similar comments apply to the <code>lapses</code> column.</li><li>The <code>flags</code> field is only significant mod 8: mod-8 values correspond to various colors of flags or no such flag. This rules out the possibility either of a card&#39;s having several flags set or of there being more than 8 flag-states. Moreover, coders accustomed to &#34;flags&#34; fields will likely anticipate a system where bits of a binary representation correspond to flags&#39; being set. Given that this is an integer field in either case, little would be lost and much gained by adopting a more standard system for representing flag values.</li><li>There is a <code>graves</code> table representing cards, notes, and decks that have been deleted. This is awkward. First, it combines heterogeneous data (data that are different not only in representing different categories of items but also in actually being stored in separate tables in this database when learning circumstances are different). Second, it amounts to moving data from one table to another in the case of a status change; it is usually better to simply make such a change like that in existing status fields. (I often find that solutions like this are attempted compromises by programmers who are pretty sure, but not completely sure, that data should be deleted. It is almost always better to settle that question once and for all--by literally deleting it, by leaving it, or by sending it off to some archive or backup--than to attempt this kind of compromise.) </li><li>The relationship between <code>notes</code> and tags is represented by a text column on <code>notes</code> with a list of tag names, both separated by spaces and with spaces at the end (in order to support <code>LIKE &#34;%tag%&#34;</code> queries, according to the Ankidroid documentation linked above). This is an error-prone way to represent a many-to-many relationship. I&#39;m not an SQLite expert, but I&#39;d imagine it&#39;s inefficient, too. More fundamentally, tags are clearly domain objects that should be properly represented (and probably need their own table). Whenever I&#39;ve tried to keep track of objects like this <em>ad hoc</em> as strings--and I&#39;ve tried this many times!--I&#39;ve regretted it. (Do as I say, not as my past self has done.)</li><li><code>flds</code> (representing a many-to-many relationship between <code>notes</code> and fields) is represented similarly to <code>tags</code>, but separated by <code>0x1f</code>. The comments above apply, and there&#39;s an extra bit of potential confusion because the delimiter is different here. An aside: in this case, using <code>flds</code> instead of <code>fields</code> appears to be abbreviation for abbreviation&#39;s sake, and nothing more. But I often find that abbreviations like this, especially when nearby objects are <em>not</em> abbreviated, correspond to misalignments between the abbreviated word and the data object. So, for example, <code>tmstp</code> might abbreviate &#34;timestamp&#34; but actually mean something closer to &#34;a timestamp but not really.&#34; When you read code, get in the habit of asking whether abbreviated names are subconscious (or conscious) expressions of the fact that the name isn&#39;t quite right.</li><li>The <code>csum</code> (&#34;checksum&#34;) field on <code>notes</code> is (apparently) intended for uniqueness checks. (It&#39;s not clear that this is literally a checksum; see point (8).) This function would be better served by using built-in mechanisms for creating unique <code>id</code>s. (More generally, database software is pretty good at primary key management and generation. Programming is hard enough; leave this sort of thing to the software.)</li><li>In the <code>revlog</code> table, the <code>time</code> field represents a duration, is capped at 60s, and is represented in milliseconds. It&#39;s usually best not to throw away information. (Are you so sure you won&#39;t <em>ever</em> care about the difference between 65 and 75 seconds?) Moreover, this is not a time but a <em>duration</em> and should be so named. And it would probably be best simply to store the beginning and end timestamps of the review and let the calculations be done downstream: this is a subtle form of storing several pieces of information together.</li></ol>
        </div>

            
    </article>
</div></div>
  </body>
</html>
