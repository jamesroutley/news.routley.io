<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.brycekerley.net/2024/04/01/p-langs.html">Original</a>
    <h1>A lazy and flippant classification of programming languages</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  
  

      <div itemprop="articleBody">
    <p>Sometimes I post in an online community of computer touchers, as one does.
When talking flippantly about programming languages,
it’s sometimes useful to glob a bunch of them together based on
characteristics, whether superficial or not.
This started with jokes about common features of “P languages”
like Perl, PHP, Python, JavaScript and Ruby,
but you can classify other languages too.</p>

<p>This classification isn’t intended as the final word or
to be accepted uncritically.
It’s mostly here to get it out of my head,
and if it starts a conversation that’s good too?</p>

<h2 id="p-languages">P-languages</h2>

<p>Perl, PHP, Python, Ruby, Javascript 
(the last two have an honorary “P”) 
are all garbage-collected “scripting”<sup id="fnref:wall" role="doc-noteref"><a href="#fn:wall" rel="footnote">1</a></sup> languages
that let you get stuff done quick, often in web contexts.
They often make sense from the beginning
but get idiosyncratic at the edges.
Often times huge swaths of the standard library will be
very thin wrappers over the C standard library,
system calls,
or other platform libraries.</p>

<h2 id="c-languages">C-languages</h2>

<p>A wise man once said that 
“the C++ spec is a case of regulatory capture by compiler vendors.”
There’re enough cases of “undefined behavior” 
doing something absolutely ridiculous
(like running off the end of an infinite loop
into the next function)
that C-language people have helpfully abbreviated it “UB”
to save time while threatening you that maybe they’ll make
a structural part of your program UB too.</p>

<p>These also have lots of well-named standard library functions
like <code>printf</code>, <code>strcpy</code>, and <code>gets</code>
that give control of your program counter and memory to arbitrary input.
There are functions that supersede or obsolete these,
but the old busted ones have to hang around forever.
For example, C++ added safe ways to access
<code>std::vector</code> and <code>std::array</code>, 
but gave them the name <code>at</code> instead of <code>operator[]</code>
to not break the unsafe version that everyone uses.</p>

<h2 id="j-languages">J-languages</h2>

<p>Java and C#,
these have separate compilation steps that go to a non-native
bytecode that requires some kind of separate executable to run.
They all subscribe to a 
“<a href="https://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html">Kingdom of Nouns</a>” 
vision of “object oriented”
that tends towards lots of gang of four patterns in codebases,
that makes it hard to find the code that actually does stuff.
They also both really like UTF-16.</p>

<h2 id="sql">SQL</h2>

<p>SQL</p>

<h2 id="g-languages">G-languages</h2>

<p>Golang, Rust, Crystal (my beloved),
these are chasing after J-language safety
while targeting native bytecode like a C-language,
with a willingness to make syntax changes
(if not the drastic typing system changes Rust and Crystal make)
from C- and J-languages.</p>

<h2 id="r-languages">R-languages</h2>

<p>Erlang and Elixir are the big ones.
They have the compilation to bytecode step of J-languages,
but instead of calling methods on objects,
you have lightweight processes passing messages around,
and you get to use functional programming stuff too.
Elixir works really hard to be an on-ramp to these
for P-language people, 
but it’s not so much “idiosyncratic” at the edges as
a whole new thing altogether.</p>

<h2 id="f-languages">F-languages</h2>

<p>Haskell, Ocaml, and other languages where
concepts get names like “applicative functor”
and variables get names like <code>v</code> and <code>m</code>.</p>



<p>computers</p>


  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
