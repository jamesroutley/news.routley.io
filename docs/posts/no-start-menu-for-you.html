<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://randomascii.wordpress.com/2023/01/17/no-start-menu-for-you/">Original</a>
    <h1>No Start Menu for You</h1>
    
    <div id="readability-page-1" class="page"><div>
						<p>I tend to launch most programs on my Windows 10 laptop by typing the &lt;Win&gt; key, then a few letters of the program name, and then hitting enter. On my powerful laptop (SSD and 32 GB of RAM) this process usually takes as long as it takes me to type these characters, just a fraction of a second.</p>
<p>Usually.<span id="more-3966"></span></p>
<p>Sometimes, however, it takes longer. A lot longer. As in, tens of seconds. The slowdowns are unpredictable but recently I was able to record an Event Tracing for Windows (ETW) trace of one of these delays. With a bit of help from <a href="https://twitter.com/BruceDawson0xB/status/1613756869876801537">people on twitter</a> I was able to analyze the trace and understand why it took about a minute to launch <em>notepad</em>.</p>
<p>Before I get in to the analysis I have two warnings/disclaimers: 1) I have a good understanding of the problem, but I do not have a solution and 2) if you are seeing identical symptoms that doesn’t mean that your root cause is the same as mine, but I will give some hints on how to see if it is.</p>
<p>My analysis of the trace (<a href="https://drive.google.com/file/d/16x2xRKKiYTA2JaEO60dTUUILfK0-p3Sc/view?usp=share_link">trace is here</a>, <a href="https://randomascii.wordpress.com/2015/09/01/xperf-basics-recording-a-trace-the-ultimate-easy-way/">installer for the analysis tools is here</a>, <a href="https://randomascii.wordpress.com/2015/09/24/etw-central/">analysis tutorials are here</a>, feel free to follow along) started with my looking at the input events and <em>Window in Focus</em> graph in Windows Performance Analyzer (WPA), both shown below (zoomed in a bit for maximum detail):</p>
<p><a href="https://randomascii.files.wordpress.com/2023/01/image_thumb3.png"><img width="639" height="274" title="Input events and Window in Focus graphs in WPA" alt="Input events and Window in Focus graphs in WPA" src="https://randomascii.files.wordpress.com/2023/01/image_thumb3_thumb.png?w=639&amp;h=274"/></a></p>
<p>The first diamond in the <em>Multi-Input</em> row shows when I pressed the Windows key, with subsequent key presses (including pressing enter) clumped together shortly afterwards. The units on the x-axis are seconds so we can see that all of the typing took about 3/4 of a second.</p>
<p>The input events are injected into the trace by my <a href="https://randomascii.wordpress.com/2015/09/01/xperf-basics-recording-a-trace-the-ultimate-easy-way/">UIforETW</a> trace-recording tool. These input events are one of the reasons I prefer UIforETW over Microsoft’s trace-recording tools. I’ve hidden the table-view but it lists which keys were pressed, while anonymizing letters and numbers to prevent UIforETW from being a key logger. Input events can be a critical tool in helping know where/when to look in traces to understand what is happening.</p>
<p>The input events help establish context, but the <em>Window in Focus</em> events really tell the tale. We can see that the SearchApp (start menu?) gains focus as soon as I press the &lt;Win&gt; key but then nothing else happens for more than thirteen seconds. That’s the problem, visualized.</p>
<h4>But why?</h4>
<p>The next step is to see what is causing the delay. A quick glance at the CPU Usage (Precise) and Disk Usage graphs showed that the CPU and disk were almost 100% idle, so the start menu must be waiting on something else:</p>
<p><a href="https://randomascii.files.wordpress.com/2023/01/image_thumb5.png"><img width="637" height="456" title="Window in Focus, CPU Usage (Precise) and Disk Usage graphs in WPA" alt="Window in Focus, CPU Usage (Precise) and Disk Usage graphs in WPA" src="https://randomascii.files.wordpress.com/2023/01/image_thumb5_thumb.png?w=637&amp;h=456"/></a></p>
<p>When a process is idle for a while when you wish that it was doing work then the challenge is to figure out what it was waiting on. I looked at the context-switch events in CPU Usage (Precise). Some of the <em>SearchApp</em> threads were named (yay!) but not all of them were and I couldn’t find the main thread to see what it was waiting on, so I had to poke around and hope something became obvious. I zoomed in on the burst of CPU activity just before notepad launched and I noticed that <em>WerFault.exe</em> and <em>wermgr.exe</em> both started getting busy. <a href="https://xkcd.com/552/">Correlation is not causation</a>, but it sure is suspicious.</p>
<blockquote>
<p>Note that WER stands for Windows Error Reporting – the system that sends crash dumps back to Microsoft for analysis so that software reliability can be improved</p>
</blockquote>
<p>Looking at the <em>Processes</em> table showed me that the command line for <em>WerFault.exe</em> was “<em>C:\WINDOWS\system32\WerFault.exe -u -p 17804 -s 2124</em>”. That suggests that Windows Error Reporting was being asked to record information for crashed process 17804, and when I looked in the <em>Processes</em> table for that Process ID (PID) I found “<em>RuntimeBroker.exe &lt;Microsoft.Windows.Search&gt; (17804)</em>”. Well now. Doesn’t that name look relevant?</p>
<p>A look at all of the “Transient” processes (those that started or ended during the trace timeline) was quite revealing:</p>
<p><a href="https://randomascii.files.wordpress.com/2023/01/image_thumb7.png"><img width="637" height="383" title="Window in Focus and Processes (Lifetime By Process) graphs in WPA" alt="Window in Focus and Processes (Lifetime By Process) graphs in WPA" src="https://randomascii.files.wordpress.com/2023/01/image_thumb7_thumb.png?w=637&amp;h=383"/></a></p>
<p><em>WerFault.exe</em> and <em>RuntimeBroker.exe (17804)</em> (the top of the two <em>RuntimeBroker.exe processes</em>) were both running when I started recording the trace and both ended at about the same time, and <em>WerFault.exe</em> was handling a crash in <em>RuntimeBroker.exe</em>. Notice also that a new copy of <em>RuntimeBroker.exe</em> starts running when the old copy goes away. Now we’re starting to have an explanation:</p>
<ol>
<li><em>RuntimeBroker.exe</em> crashes
</li><li>WerFault.exe deals with the crash, keeping the <em>RuntimeBroker.exe</em> process open
</li><li>Then a new <em>RuntimeBroker.exe</em> launches and provides whatever it is that <em>SearchApp.exe</em> needed</li>
</ol>
<p>Now we have a new question: why is <em>WerFault.exe</em> sitting idle for so long?</p>
<p>I looked at the CPU Usage (Precise) data and saw that <em>WerFault.exe</em> has at least thirteen threads, none of them named (come <em>on</em> Microsoft – thread names are really helpful!) but the main thread was easily identifiable as the one using the most CPU time. I then sorted by <em>Time Since Last</em> and noticed that at one point the main thread had been waiting to run for 15.572 s. In fact it was probably waiting even longer, but the start of its wait was before the start of the trace and therefore unknowable. You can find more details on <a href="https://randomascii.wordpress.com/2012/05/05/xperf-wait-analysisfinding-idle-time/">how to do idle-analysis here</a>.</p>
<p>The stack where the main <em>WerFault.exe</em> thread was waiting for 15.572 s is shown below:</p>
<p><a href="https://randomascii.files.wordpress.com/2023/01/image_thumb9.png"><img width="513" height="316" title="WerFault.exe wait call stack" alt="WerFault.exe wait call stack" src="https://randomascii.files.wordpress.com/2023/01/image_thumb9_thumb.png?w=513&amp;h=316"/></a></p>
<p>The summary would be that it was waiting in <em>UploadReport</em>.</p>
<p><a href="https://randomascii.files.wordpress.com/2023/01/image_thumb13.png"><img width="370" height="214" title="RuntimeBroker.exe crash call stack" alt="RuntimeBroker.exe crash call stack" src="https://randomascii.files.wordpress.com/2023/01/image_thumb13_thumb.png?w=370&amp;h=214"/></a>So now we understand the problem. <em>RuntimeBroker.exe</em> crashed (due to heap corruption, according to the call stack in the <em>RuntimeBroker.exe</em> crash dump, shown to the right) and it took more than 15 seconds to upload the crash dump, presumably due to my flaky hotel WiFi. During this time my start menu was inoperable.</p>
<p>This deserves reiterating. My start menu was hung due to the combination of heap corruption and <em>WerFault.exe</em> deciding that it needed to upload the crash dump before releasing the old process so that a new one could be started.</p>
<p>It took two bugs (the heap corruption and the upload-before-restarting) to make this hang happen, but happen it did.</p>
<p><a href="https://randomascii.files.wordpress.com/2023/01/image_thumb11.png"><img width="459" height="238" title="Secondary WerFault.exe hung thread" alt="Secondary WerFault.exe hung thread" src="https://randomascii.files.wordpress.com/2023/01/image_thumb11_thumb.png?w=459&amp;h=238"/></a>We can even go deeper. The <em>UploadReport</em> function was blocked for 15.567 s and the <em>Readying Process/Readying Thread Id</em> shows us who ultimately unblocked the function. That turned out to be another <em>WerFault.exe</em> thread which was blocked in some <em>CHttpRequest</em> functions, as show above. That doesn’t add significantly to the understanding of the problem, but does demonstrate nicely how you can trace a hang backwards through multiple processes and threads.</p>
<h4>Watching for this problem</h4>
<p>In general if you want to understand why your computer is performing badly you need to record and analyze a trace. However if you want to see if you are hitting this particular problem then there are easier steps that you can follow.</p>
<p>The first step is to <a href="https://learn.microsoft.com/en-us/windows/win32/wer/collecting-user-mode-dumps">configure the local recording of crash dumps</a>. This is a good idea in general because it lets you monitor the stability of your computer over your time.</p>
<p>Then, with crash dumps being recorded if you see a Start Menu hang you can just look in %localappdata%\crashdumps and see if there is a recent <em>RuntimeBroker.exe</em> crash. If so then you are presumably seeing this bug.</p>
<h4>Waiting on upload</h4>
<p>Raymond Chen gives several reasons for <a href="https://devblogs.microsoft.com/oldnewthing/20120611-00/?p=7413">why Windows Error Reporting doesn’t restart crashed processes before uploading the report</a> (circa 2012) but I don’t find those reasons entirely compelling, especially in the start-menu case. As long as you kill the old process before starting the new one – and answer the DLL-version questions from a crash dump – most of the problems he points out are avoidable. Exponential backoff on process restarts can address the rest. And, the consequences of waiting can, as we have seen, be arbitrarily long start-menu hangs, with no indication that a crash is the problem. There is also <a href="https://twitter.com/SteveSyfuhs/status/1613934032756305921">some confusion about the behavior</a> – maybe the design has changed in the last ten years.</p>
<h4>Fixing the crash</h4>
<p><a href="https://randomascii.files.wordpress.com/2023/01/image_thumb21.png"><img width="324" height="186" title="Application verifier settings - pageheap enabled for RuntimeBroker.exe" alt="Application verifier settings - pageheap enabled for RuntimeBroker.exe" src="https://randomascii.files.wordpress.com/2023/01/image_thumb21_thumb.png?w=324&amp;h=186"/></a>Heap corruption bugs can be extremely difficult to find and fix, but this one seems like it might be easy. I turned on <a href="https://randomascii.wordpress.com/2011/12/07/increased-reliability-through-more-crashes/">pageheap</a> on <em>RuntimeBroker.exe</em>, killed the relevant version to get it to restart and apply the <em>pageheap</em> settings and it started crashing every time I opened the start menu. I configured WER to save full crash dumps and soon had a half-dozen crash dumps with full details of what was happening.</p>
<p>The crashes normally happen on this call stack:</p>
<p><a href="https://randomascii.files.wordpress.com/2023/01/image_thumb16.png"><img width="662" height="221" title="Crash with this on the stack: windows_cortana_Desktop!Windows::Cortana::EdgeProfileInfoLifetimeTraits::Destroy&lt;Windows::Cortana::EdgeProfileInfo&gt;" alt="Crash with this on the stack: windows_cortana_Desktop!Windows::Cortana::EdgeProfileInfoLifetimeTraits::Destroy&lt;Windows::Cortana::EdgeProfileInfo&gt;" src="https://randomascii.files.wordpress.com/2023/01/image_thumb16_thumb.png?w=662&amp;h=221"/></a></p>
<p>With pageheap enabled the crash happens on a very similar call stack, but slightly earlier. The crash happens earlier (and more reliably) because with page heap when you free memory it is unmapped, so dereferencing it reliably causes a crash, instead of reading from the freed memory:</p>
<p><a href="https://randomascii.files.wordpress.com/2023/01/image_thumb18.png"><img width="664" height="117" title="Crash with this on the stack: windows_cortana_Desktop!Windows::Cortana::EdgeProfileInfoLifetimeTraits::Destroy&lt;Windows::Cortana::EdgeProfileInfo&gt;" alt="Crash with this on the stack: windows_cortana_Desktop!Windows::Cortana::EdgeProfileInfoLifetimeTraits::Destroy&lt;Windows::Cortana::EdgeProfileInfo&gt;" src="https://randomascii.files.wordpress.com/2023/01/image_thumb18_thumb.png?w=664&amp;h=117"/></a></p>
<p>The crash happens when dereferencing <em>[rcx]</em> so I ran its value through the the !heap command (see my <a href="https://randomascii.wordpress.com/2011/12/07/increased-reliability-through-more-crashes/">pageheap blogpost</a> for details) and got this call stack:</p>
<p><a href="https://randomascii.files.wordpress.com/2023/01/image_thumb20.png"><img width="626" height="189" title="Complicated call stack showing when memory was freed" alt="Complicated call stack showing when memory was freed" src="https://randomascii.files.wordpress.com/2023/01/image_thumb20_thumb.png?w=626&amp;h=189"/></a></p>
<p>The only complication is that this doesn’t happen on all Windows 10 machines. There seems to be some required state that makes it happen or not and I don’t know what is. I will say that I’m happy to share the crash dumps with anyone at Microsoft who wants to investigate.</p>
<p>I don’t know the code and don’t understand what is happening but I’ve dealt with enough use-after-free bugs to say that this is probably straightforward to investigate and fix using the crash dumps. Although, I got a couple of different crash call stacks so there might be multiple bugs.</p>
<h4>Conclusions</h4>
<p>I ended my initial twitter thread by saying that <a href="https://twitter.com/BruceDawson0xB/status/1613756883994804227">these hangs were making me cranky</a> and had me wondering if Windows 10 was abandonware. Since then I’ve been told that people seem to be seeing start-menu hangs on Windows 11, but that is not necessarily the same problem.</p>
<p>To be clear, Microsoft has the technology to record traces on start menu hangs on customer machines. These traces would show roughly the same thing as my trace. They also receive crash dumps from customer machines. They might even have a way of correlating them (if not then they should hook that up). And they created <em>pageheap</em> which makes use-after-free crashes easy to investigate. </p>
<p>So, why hasn’t this been addressed? On my laptop I see that <em>RuntimeBroker.exe</em> has crashed, on average, every second day this year. That is too many start-menu hangs for my tastes. I don’t know how long it has been happening so <a href="https://twitter.com/BrandonLive/status/1613773035793973249">maybe a fix is on the way</a> – if so that would be great to hear. If not then I will continue to be cranky and I hope that this serves as a good reminder of the importance of using all that fancy telemetry to address issues like this.</p>
<p>Or, maybe I’m just unlucky and I’m one of the few people (<a href="https://twitter.com/BenHymers/status/1613888573257748480">not the only person</a>) who is hitting this crash.</p>
<p>In short, I am <em>really</em> pleased with the tools that Microsoft has created and released to let me analyze performance issues such as these. However I wish that I didn’t have to use them so often on Windows itself.</p>
<h2>Online discussion</h2>
<p><a href="https://news.ycombinator.com/item?id=34423557">Hacker news</a></p>
<p><a href="https://twitter.com/BruceDawson0xB/status/1613756869876801537">Initial twitter discussion</a></p>
<p><a href="https://twitter.com/BruceDawson0xB/status/1615563552798175232">Twitter announcement of blogpost</a></p>
											</div></div>
  </body>
</html>
