<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://neodyme.io/blog/csgo_from_zero_to_0day/">Original</a>
    <h1>CS:GO: From Zero to 0-Day</h1>
    
    <div id="readability-page-1" class="page"><div>
			<h2 id="tldr">TL;DR<a aria-hidden="true" tabindex="-1" href="#tldr"><span>¶</span></a></h2>
<p>We identified three independent remote code execution (RCE) vulnerabilities in the popular Counter-Strike: Global Offensive game. Each vulnerability can be triggered when the game client connects to our malicious python CS:GO server. This post details our journey through the CS:GO binary and conducts a technical deep dive into various identified bugs. We conclude by presenting a proof of concept (POC) exploit that leverages four different logic bugs into remote code execution in the game’s client, triggered when a client connects to the server.</p>
<h2 id="introduction">Introduction<a aria-hidden="true" tabindex="-1" href="#introduction"><span>¶</span></a></h2>
<p>The <a href="https://blog.counter-strike.net/index.php/2021/04/33895/">CS:GO patch dated 04/28/2021</a> fixed several critical vulnerabilities, including three critical bugs from us. This post describes our approach and how we discovered three critical vulnerabilities. We present a single bug chain, consisting of four logic bugs, and explain how these led to a remote code execution (RCE) on the client by cleverly combining them. Although the post does explain the four logic vulnerabilities, its focus is on the methodology of our research.</p>
<p>First we look at existing research for the CS:GO game and give a general introduction to make reverse engineering of the complex client less painful. The post then introduces basic concepts of the CS:GO network protocol like <code>fast_dl</code> and <code>Cvars</code> and detail four different logic bugs. Combining the bugs leads to the proof of concept that exploits a CS:GO client by only connecting to a malicous, attacker controlled server.</p>
<h2 id="table-of-contents">Table of contents<a aria-hidden="true" tabindex="-1" href="#table-of-contents"><span>¶</span></a></h2>
<ol>
<li><a href="#csgo">CS:GO</a></li>
<li><a href="#know-your-target">Know your target</a>
<ol>
<li><a href="#software-development-kits">Software Development Kits</a></li>
<li><a href="#public-research">Public Research</a></li>
<li><a href="#cheating-communities">Cheating Communities</a></li>
<li><a href="#debug-symbols">Debug Symbols</a></li>
<li><a href="#fuzzing">Fuzzing</a></li>
</ol>
</li>
<li><a href="#the-discovery-of-four-logic-bugs">The discovery of four logic bugs</a>
<ol>
<li><a href="#bug-1-execution-of-privileged-commands-from-the-server">Bug 1: Execution of privileged commands from the server</a></li>
<li><a href="#bug-2-arbitrary-file-download-due-to-extension-stripping">Bug 2: Arbitrary file download due to extension stripping</a></li>
<li><a href="#bug-3-arbitrary-text-file-write-in-game-directory">Bug 3: Arbitrary text file write in game directory</a></li>
<li><a href="#bug-4-fallback-to-disabled-signature-checks">Bug 4: Fallback to disabled signature checks</a></li>
</ol>
</li>
<li><a href="#full-logic-bug-chain">Full logic bug chain</a>
<ol>
<li><a href="#gameinfotxt">Gameinfo.txt</a></li>
<li><a href="#cvars">CVars</a></li>
<li><a href="#exploit-flow">Exploit flow</a></li>
</ol>
</li>
<li><a href="#video">Video</a></li>
<li><a href="#closing-thoughts">Closing Thoughts</a></li>
<li><a href="#timeline">Timeline</a></li>
</ol>
<h2 id="csgo">CS:GO<a aria-hidden="true" tabindex="-1" href="#csgo"><span>¶</span></a></h2>
<p>The free-to-play game <a href="https://blog.counter-strike.net/">Counter Strike: Global Offensive (CS:GO)</a> continues to experience great popularity with 21 million players per month, not least because of the wide variety of game modes offered by the many <a href="https://www.gametracker.com/search/csgo/DE/">community-hosted servers</a>. The game from 2012 is based on the even older <a href="https://developer.valvesoftware.com/wiki/Source">source engine (2004)</a>, known for games such as <a href="https://en.wikipedia.org/wiki/Portal_(video_game)">Portal</a>, <a href="https://half-life.fandom.com/wiki/Half-Life_2">Half-Life 2</a> and <a href="https://left4dead.fandom.com/wiki/Left_4_Dead">Left 4 Dead</a>. The source engine in turn uses components from its predecessors, <a href="https://developer.valvesoftware.com/wiki/GoldSrc">GoldSrc (1998)</a> and the <a href="https://en.wikipedia.org/wiki/Quake_engine">Quake engine (1996)</a>. This history already indicates that the powerful and complex source engine possesses some components, for which security did not yet stand in the foreground while programming.</p>
<p>The many game modes, community servers and modding support take a toll: a large attack surface. The many file formats such as textures, 3D models and AI navigation points go through a wide variety of parsers with completely attacker-controlled data as the data is shipped directly from the CS:GO server. In addition, the source engine implements its own TCP-like network stack based on UDP with all the associated problems in such a complex implementation. The network implementation has already been exploited in <a href="https://research.checkpoint.com/2020/game-on-finding-vulnerabilities-in-valves-steam-sockets/">other attacks</a>.</p>
<h2 id="know-your-target">Know your target<a aria-hidden="true" tabindex="-1" href="#know-your-target"><span>¶</span></a></h2>
<p>Security research is not about blindly poking around and looking for security gaps. Because: Only when you have fully understood a target, you are in a position to break through the technical restrictions. The first step should therefore be to obtain as much information about the target as possible. The following sections provide ideas for this “recon” phase:</p>
<h3 id="software-development-kits">Software Development Kits<a aria-hidden="true" tabindex="-1" href="#software-development-kits"><span>¶</span></a></h3>
<p>Games with modding support often provide an <a href="https://developer.valvesoftware.com/wiki/SDK_Installation">official software development kit</a> (SDK). While the SDK does not contain the target’s source code, the structures defined there provide valuable information on <a href="https://github.com/SteamDatabase/Protobufs">network packages</a> and class definitions that help to understand the engine. For Valve games in particular, there have also been several source code leaks of the engine or complete games (2003, 2007, and 2020). Although the source code is often outdated and contains many, now fixed, security holes, these leaks are very helpful. Mostly because source code is simply more pleasant to read than compiler-optimized assembly.</p>
<h3 id="public-research">Public Research<a aria-hidden="true" tabindex="-1" href="#public-research"><span>¶</span></a></h3>
<p>CS:GO is well known, thus we were not the first researchers looking for bugs in this game. Therefore, we searched the Internet for <a href="https://phoenhex.re/2018-08-26/csgo-fuzzing-bsp">helpful blogposts</a> and <a href="https://insomnihack.ch/wp-content/uploads/2017/04/AC_remote_exploitation_of_valve_source.pdf">presentations</a> at <a href="https://www.youtube.com/watch?v=4weoWSzuCxs">conferences</a>. The information described in this public research is often reduced to the essentials and makes it easier to find one’s way around a new, complex target.</p>
<h3 id="cheating-communities">Cheating Communities<a aria-hidden="true" tabindex="-1" href="#cheating-communities"><span>¶</span></a></h3>
<p>Super annoying in the game, loved by security researchers: Cheater communities like <a href="https://unknowncheats.me">UnknownCheats</a> exist. These forums provide detailed reverse engineering posts and internals to the engine. In this case, Felipe had already written a <a href="https://www.youtube.com/watch?v=nn_hD1-Xe5Q">Network Cheat</a> that contributed a lot to the understanding of the network protocol.</p>
<h3 id="debug-symbols">Debug Symbols<a aria-hidden="true" tabindex="-1" href="#debug-symbols"><span>¶</span></a></h3>
<p>Debug symbols contain the otherwise unrecognizable function names and class structures that make reverse engineering much more convenient. Sometimes versions of the game are also intentionally shipped with debug symbols to generate better error reports. However, sometimes programmers forget to remove the debug symbols from the final binaries of the game. Programmers are humans, and humans make mistakes.</p>
<center><figure>
						<img src="https://blog.plover.com/blog/csgo_from_zero_to_0day/symbols.png" alt="CS:GO Binary with Debug Symbols"/>
						<figcaption>
							<p>
								CS:GO Binary with Debug Symbols
							</p>
						</figcaption>
					</figure>
					</center>
<p>The CS:GO version for macOS from April 2017 (shown below) contained full debug symbols. Game files with symbols are many times larger than without and can therefore be identified automatically using <a href="https://steamdb.info/app/730/depots/">SteamDB</a> and old repositories.</p>
<pre><code><span><span>2017-04-26T00:15:42+00:00 [M:8167272392035836136]</span></span>
<span><span>csgo/bin/osx64/server.dylib (+9.30 MiB)</span></span>
<span><span>bin/osx64/engine.dylib (+5.17 MiB)</span></span>
<span><span>bin/osx64/scaleformui.dylib (+3.23 MiB)</span></span>
<span><span>csgo/bin/osx64/client.dylib (+12.13 MiB)</span></span>
<span><span>bin/osx64/materialsystem.dylib (+2.18 MiB)</span></span></code></pre>
<p>While in 2021 it was still possible to specifically download old versions using <code>SteamCMD</code>, the feature seems to have been disabled by Valve in the meantime.</p>
<h3 id="fuzzing">Fuzzing<a aria-hidden="true" tabindex="-1" href="#fuzzing"><span>¶</span></a></h3>
<p>Despite all the information, you have to invest many hours in reverse engineering the target. Only once you have fully understood which buffer processes the network data in which virtual function with which arguments you can start doing exciting things. But the effort is worth it: we found instant client crashes using <a href="https://github.com/google/honggfuzz">Hongfuzz</a>, the <a href="https://github.com/SteamDatabase/Protobufs/tree/master/csgo">public protobuf network structures</a>, and <a href="https://github.com/google/libprotobuf-mutator">libprotobuf-mutator</a>. These crashes directly provided <code>instruction pointer</code> control and were thus very likely exploitable! To test the full extent and develop exploit strategies, we decided to implement our own early-stage server in Python.</p>
<h2 id="the-discovery-of-four-logic-bugs">The discovery of four logic bugs<a aria-hidden="true" tabindex="-1" href="#the-discovery-of-four-logic-bugs"><span>¶</span></a></h2>
<p>For a target like CS:GO, due to years of development and public bug bounty program, simple bugs are most likely fixed by now. If you are only looking for stack overflows in random methods of the huge <code>engine.dll</code>, you will quickly give up in frustration. But it is true: every little anomaly can prove to be valuable in combination with other gaps. During the weeks of staring at the CS:GO disassembly and source-code leaks, we constantly asked ourselves the following questions:</p>
<ul>
<li>What primitives do we already have?</li>
<li>What can we do by combining them?</li>
<li>What security mechanisms are there?</li>
<li>What weird edge cases might a developer not have considered?</li>
</ul>
<p>Memory corruption exploitation is hard. Although two of the three full-chain exploits submitted by us to Valve were memory corruptions, that meant extremely high overhead and always the risk that the client would crash because of an unfavorable memory allocation. Starting CS:GO and connecting to a server loading the map took several minutes each time, which made development very tough.</p>
<p>In this post, rather then explaining weird heap feng shui mechanisms, focus on four logic bugs that together led to our goal of remote code execution on the client. The order of discovery was as follows.</p>
<h3 id="bug-1-execution-of-privileged-commands-from-the-server">Bug 1: Execution of privileged commands from the server<a aria-hidden="true" tabindex="-1" href="#bug-1-execution-of-privileged-commands-from-the-server"><span>¶</span></a></h3>
<div>
						<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M13 9h-2V7h2m0 10h-2v-6h2m-1-9A10 10 0 0 0 2 12a10 10 0 0 0 10 10a10 10 0 0 0 10-10A10 10 0 0 0 12 2Z"></path></svg><p>
						 This bug allows the attacker to execute “privileged” commands on the client that usually only work in the single player mode
					</p></div>
				
<p>To verify that our custom python CS:GO server is actually working, we sent the command <code>echo Hello World!</code> to the client via <code>CNETMsg_StringCmd</code> and, as expected, received the output <code>Hello World!</code> on the game console. Randomly, we also tried sending the <code>quit</code> command. And the game closed! We couldn’t believe that a server is allowed to do that. As it turns out, it is usually not allowed to do so: With the help of <a href="https://www.sourcemod.net/">SourceMod</a>, a source engine modding framework that can also send messages to the client, we recreated the same setup with an official and modded server. The result: <code>FCVAR_SERVER_CAN_EXECUTE prevented server running command: quit</code>. Did we find our entry bug? How exactly does the bug occur?</p>
<p>Source engine <em>single-player games</em> internally use a locally hosted source engine server. The single-player client then connects to its own server to join the game. This single-player server should of course have far-reaching rights, e.g., to change the keyboard layout on the client or to take screenshots.</p>
<p>A <em>multi-player server</em> is recognized as a local, and thus privileged, single player server if only a maximum of one client can connect to the server. The vulnerability is in the determination of the server type: The maximal number of clients that can connect to the server is controlled by the variable <code>m_nMaxClients</code> and is received by the client when connecting to a server. By chance, our Python server had set the variable <code>m_nMaxClients</code> to 1. And with this we could execute privileged commands on the client!</p>
<center><figure>
						<img src="https://blog.plover.com/blog/csgo_from_zero_to_0day/max_clients.png" alt="Host_IsSinglePlayerGame Check"/>
						<figcaption>
							<p>
								Host_IsSinglePlayerGame Check
							</p>
						</figcaption>
					</figure>
					</center>
<h3 id="bug-2-arbitrary-file-download-due-to-extension-stripping">Bug 2: Arbitrary file download due to extension stripping<a aria-hidden="true" tabindex="-1" href="#bug-2-arbitrary-file-download-due-to-extension-stripping"><span>¶</span></a></h3>
<div>
						<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M13 9h-2V7h2m0 10h-2v-6h2m-1-9A10 10 0 0 0 2 12a10 10 0 0 0 10 10a10 10 0 0 0 10-10A10 10 0 0 0 12 2Z"></path></svg><p>
						 This bug allows the attacker to download files with arbitrary file extensions, bypassing the extension filter
					</p></div>
				
<p>Source engine servers can send additional game files such as maps or player models to the client. The data transfer can be done either via the source network protocol or HTTP <code>fast_dl</code>. To prevent malicious files from being sent to the client, certain file extensions like <code>*.exe</code>, <code>*.dll</code>, <code>*.ini</code> are blocked.</p>
<p>If the <code>fast_dl</code> option is set, additional content is loaded from a specified HTTP server rather then from the CS:GO server directly. The URL is dynamically generated from the server name and the full file name by the <code>snprintf(p_cResult, 256, &#34;%s/%s&#34;, p_cServerName, p_cFileName)</code> function. The <code>snprintf</code> function limits the length of the resulting string to 256 characters, thus truncating unnecessary characters from the file name. But both <code>p_cServerName</code> and <code>p_cFileName</code> can have a length of 256 characters each!  A file name like <code>././[..]/file.AAA.BBB</code> can be terminated specifically after the <code>.AAA</code> extension, as the <code>.BBB</code> part is truncated by the <code>snprintf</code> function. The filter for potentially dangerous files can thus be bypassed completely!</p>
<p>The following source snipped illustrates that the extension is stripped:</p>
<pre><code><span><span>#include</span><span> </span><span>&lt;stdio.h&gt;</span></span>
<span></span>
<span><span>int</span><span> </span><span>main</span><span>()</span></span>
<span><span>{</span></span>
<span><span>    </span><span>unsigned</span><span> </span><span>char</span><span> </span><span>p_cResult</span><span>[</span><span>32</span><span>];</span></span>
<span></span>
<span><span>    </span><span>// String fits into 32 byte and includes the `.bsp` part</span></span>
<span><span>    </span><span>snprintf</span><span>(p_cResult, </span><span>32</span><span>, </span><span>&#34;</span><span>%s</span><span>/</span><span>%s</span><span>&#34;</span><span>, </span><span>&#34;AAAAAAAAAAAAAAAA&#34;</span><span>, </span><span>&#34;evil.dll.bsp&#34;</span><span>);       </span></span>
<span><span>    </span><span>printf</span><span>(</span><span>&#34;</span><span>%s\n</span><span>&#34;</span><span>, p_cResult);</span><span> // Output: AAAAAAAAAAAAAAAA/evil.dll.bsp</span></span>
<span></span>
<span><span>    </span><span>// Long enough string to truncate the `.bsp` part</span></span>
<span><span>    </span><span>snprintf</span><span>(p_cResult, </span><span>32</span><span>, </span><span>&#34;</span><span>%s</span><span>/</span><span>%s</span><span>&#34;</span><span>, </span><span>&#34;AAAAAAAAAAAAAAAAAAAAAA&#34;</span><span>, </span><span>&#34;evil.dll.bsp&#34;</span><span>); </span></span>
<span><span>    </span><span>printf</span><span>(</span><span>&#34;</span><span>%s\n</span><span>&#34;</span><span>, p_cResult);</span><span> // Output: AAAAAAAAAAAAAAAAAAAAAA/evil.dll</span></span>
<span><span>    </span></span>
<span><span>    </span><span>return</span><span> </span><span>0</span><span>;</span></span>
<span><span>}</span></span></code></pre>
<center><figure>
						<img src="https://blog.plover.com/blog/csgo_from_zero_to_0day/snprintf.png" alt="Vulnerable snprintf function cuts remaining data from string"/>
						<figcaption>
							<p>
								Vulnerable snprintf function cuts remaining data from string
							</p>
						</figcaption>
					</figure>
					</center>
<p>This vulnerability was found through code analysis of the <code>fast_dl</code> protocol, which has not changed much in recent years.</p>
<h3 id="bug-3-arbitrary-text-file-write-in-game-directory">Bug 3: Arbitrary text file write in game directory<a aria-hidden="true" tabindex="-1" href="#bug-3-arbitrary-text-file-write-in-game-directory"><span>¶</span></a></h3>
<div>
						<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M13 9h-2V7h2m0 10h-2v-6h2m-1-9A10 10 0 0 0 2 12a10 10 0 0 0 10 10a10 10 0 0 0 10-10A10 10 0 0 0 12 2Z"></path></svg><p>
						 This bug allows the attacker to (over)write arbitrary files in the game folder
					</p></div>
				
<p>At this point, we were not sure how to combine the two previous bugs. Therefore, we searched the CS:GO binary for helpful privileged commands. With the <code>con_logfile</code> command, we surprisingly discovered that this command could write arbitrary <code>*.log</code> files to arbitrary game folders. Due to a similar extension stripping bug by <code>snprintf</code> it was also possible to specify an arbitrary file extension and thus write text files with arbitrary contents and an arbitrary extension.</p>
<p>Specifically, this bug could be used to create a new configuration file <code>cfg/leak.log</code> with arbitrary CS:GO commands. The <code>leak.log</code> “config” file could then the loaded by the <code>exec leak.log</code> command, reading the file from the <code>cfg</code> folder.</p>
<h3 id="bug-4-fallback-to-disabled-signature-checks">Bug 4: Fallback to disabled signature checks<a aria-hidden="true" tabindex="-1" href="#bug-4-fallback-to-disabled-signature-checks"><span>¶</span></a></h3>
<div>
						<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M13 9h-2V7h2m0 10h-2v-6h2m-1-9A10 10 0 0 0 2 12a10 10 0 0 0 10 10a10 10 0 0 0 10-10A10 10 0 0 0 12 2Z"></path></svg><p>
						 This bug allows the attacker to launch the CS:GO client in the “insecure” mode, allowing to load non-signed game binaries
					</p></div>
				
<p>When starting the CS:GO client, the integrity of the game DLLs is verified via matching hash values. Only after this verification it is possible to play on official servers. If the DLL verification fails, a fallback to the <code>insecure</code> mode occurs. This can also be achieved by the additional command line argument <code>-insecure</code>. Only in this mode, additional DLLs not located in the <code>bin/</code> game path can be loaded. If the attacker succeeds in making the DLL verification fail, they can create their own DLLs, refer to these DLLs in the configuration and achieve command execution. On Windows, an attacker can specify code that is executed when the DLL is loaded into a process. Thus, the attacker can execute arbitrary code on the client system.</p>
<p>Windows prevents the overwriting of DLLs, which are loaded in a running process. Therefore, we had to find a DLL that is verified at game start but is not loaded into the process. Fortunately, we found that the <code>client.dll</code> had been replaced by the <code>client_panorama.dll</code> and is therefore no longer loaded, but is still verified! Overwriting <code>client.dll</code> with arbitrary text (bug 3) thus caused the verification to fail.</p>
<h2 id="full-logic-bug-chain">Full logic bug chain<a aria-hidden="true" tabindex="-1" href="#full-logic-bug-chain"><span>¶</span></a></h2>
<p>The full bug chain uses all four bugs to:</p>
<ol>
<li>execute privileged commands on the client</li>
<li>download a malicious DLL to the game directory</li>
<li>replace the <code>gameinfo.txt</code> so that the malicious DLL is loaded on game startup</li>
<li>corrupt the <code>client.dll</code> to achieve a fallback to the <code>insecure</code> mode</li>
</ol>
<p>To understand the following steps, we still need to introduce two elements typical for source engines: the <code>gameinfo.txt</code> and <code>CVars</code>:</p>
<h3 id="gameinfotxt">Gameinfo.txt<a aria-hidden="true" tabindex="-1" href="#gameinfotxt"><span>¶</span></a></h3>
<p>All source engine based games are actually “add-ons” to the basic Half-Life game. Assets and DLLs for the game are loaded from a special path defined in the file <code>gameinfo.txt</code>:</p>
<pre><code><span><span>&#34;GameInfo&#34;</span></span>
<span><span>{</span></span>
<span><span>	game	</span><span>&#34;Counter-Strike: Global Offensive&#34;</span></span>
<span><span>	title	</span><span>&#34;COUNTER-STRIKE&#39;&#34;</span></span>
<span><span>	title2	</span><span>&#34;GO&#34;</span></span>
<span><span>	type multiplayer_only</span></span>
<span></span>
<span><span>	[ ...]</span></span>
<span></span>
<span><span>	FileSystem</span></span>
<span><span>	{</span></span>
<span><span>		SteamAppId				</span><span>730</span><span>	// This will mount all the GCFs we need (240=CS:S, 220=HL2).</span></span>
<span><span>		ToolsAppId				</span><span>211</span><span>	</span></span>
<span><span>		SearchPaths</span></span>
<span><span>		{</span></span>
<span><span>			Game				</span><span>|</span><span>gameinfo_path</span><span>|/</span><span>exploit</span><span> // NOTE: Added by our exploit</span></span>
<span><span>			Game				</span><span>|</span><span>gameinfo_path</span><span>|</span><span>.</span></span>
<span><span>		}</span></span>
<span><span>	}</span></span>
<span><span>}</span></span></code></pre>
<p>By setting <code>|gameinfo_path|/exploit</code> as first in the <code>FileSystem</code> array, the engine tries to load missing DLLs from this path. Only if the element to be loaded is not found there, the original game path is used. One DLL that is loaded at game start is <code>matchmaking.dll</code>. This means that we can place a new <code>matchmaking.dll</code> and invoke arbitrary code when the CS:GO client loads the DLL.</p>
<h3 id="cvars">CVars<a aria-hidden="true" tabindex="-1" href="#cvars"><span>¶</span></a></h3>
<p><code>CVars</code> are a fundamental concept in SourceEngine games and appear everywhere. These variables control pretty much everything there is to set up in the game: paths, key-binds, the appearance of crosshairs, the game mode, etc. Also the legendary <code>sv_cheats</code> variable, which many Counter Strike players probably have already heard of, is a <code>CVar</code>. Depending on <code>CVar</code>, the settings can also be set by the server and thus override local options.</p>
<p>Upon <strong>connecting</strong>, the client tells the server which local <code>CVars</code> are set at the client, so that the server can react accordingly. For example, the server can kick the client if <code>sv_cheats</code> is set to <code>1</code> at the client. As an attacker, we need to know the installation directory from the CS:GO client so that we can exploit <code>bug 2</code> and <code>bug 4</code> by taking a path that is just the right length. Unfortunately, by default, the client does not send along a <code>CVar</code> that contains the current game directory. We therefore use a trick to set the new <code>CVAR GAMEBIN</code> and have it sent back to the attacker-controlled server. The basic idea:</p>
<ol>
<li>Execute a “script” <code>leak.log</code> to set the <code>CVar GAMEBIN</code></li>
<li>Instruct the client to reconnect to the malicious server</li>
<li>Upon reconnection, all <code>CVars</code> and set back to the malicious server</li>
</ol>
<p>The details involve invoking the <code>path</code> command from a config file to set the <code>CVAR GAMEBIN</code> to the installation path of the game. We leverage the attacker-written config file <code>leak.log</code>, which includes the <code>path</code> command. The client has to execute the config file, otherwise the <code>CVar</code> is not stored persistently during the next server connect. The <code>leak.log</code> file is executed with the <code>exec</code> command. Afterwards the malicous server instructs the client to reconnect. Upon reconnection, the <code>CVar</code> is leaked back to the server.</p>
<h3 id="exploit-flow">Exploit flow<a aria-hidden="true" tabindex="-1" href="#exploit-flow"><span>¶</span></a></h3>
<table><thead><tr><th>Component</th>
<th>Command</th>
<th>Result</th>
<th>Bug</th></tr></thead><tbody><tr><td><p><img src="https://blog.plover.com/blog/csgo_from_zero_to_0day/client.svg"/><span>→</span> <img src="https://blog.plover.com/blog/csgo_from_zero_to_0day/server.svg"/></p></td><td><code>connect</code></td>
<td>Client connects to malicious, attacker controlled server</td><td></td></tr><tr><td><p><img src="https://blog.plover.com/blog/csgo_from_zero_to_0day/server.svg"/><span>→</span> <img src="https://blog.plover.com/blog/csgo_from_zero_to_0day/client.svg"/></p></td><td><code>m_nMaxClients = 1</code></td>
<td>The server can now execute privileged commands on the client</td>
<td><a href="#bug-1-execution-of-privileged-commands-from-the-server">Bug 1</a></td></tr><tr><td><p><img src="https://blog.plover.com/blog/csgo_from_zero_to_0day/server.svg"/><span>→</span> <img src="https://blog.plover.com/blog/csgo_from_zero_to_0day/client.svg"/></p></td><td><code>sv_downloadurl = </code></td>
<td>The client has <code>fast_dl</code> http downloads enabled to download missing assets</td><td></td></tr><tr><td><p><img src="https://blog.plover.com/blog/csgo_from_zero_to_0day/server.svg"/><span>→</span> <img src="https://blog.plover.com/blog/csgo_from_zero_to_0day/client.svg"/></p></td><td><code>con_logfile cfg/leak.log</code></td>
<td>The client executes the <code>path</code> command and stores the result in <code>GAMEBIN</code></td><td></td></tr><tr><td><p><img src="https://blog.plover.com/blog/csgo_from_zero_to_0day/server.svg"/><span>→</span> <img src="https://blog.plover.com/blog/csgo_from_zero_to_0day/client.svg"/></p></td><td><code>reconnect</code></td>
<td>The client reconnects and sends all <code>CVars</code> to the server, leaking the <code>GAMEBIN</code>.
The server then creates the <code>downloadtables</code> with a precisely long filename size such that
the extension is stripped</td>
<td><a href="#bug-2-arbitrary-file-download-due-to-extension-stripping">Bug 2</a></td></tr><tr><td><p><img src="https://blog.plover.com/blog/csgo_from_zero_to_0day/client.svg"/><span>→</span> <img src="https://blog.plover.com/blog/csgo_from_zero_to_0day/server.svg"/></p></td><td><code>&lt;fast_dl download code&gt;</code></td>
<td>The client downloads the malicious <code>exploit/bin/matchmaking.dll</code> and
<code>gameinfo.txt</code> from the HTTP server</td>
<td><a href="#bug-2-arbitrary-file-download-due-to-extension-stripping">Bug 2</a></td></tr><tr><td><p><img src="https://blog.plover.com/blog/csgo_from_zero_to_0day/server.svg"/><span>→</span> <img src="https://blog.plover.com/blog/csgo_from_zero_to_0day/client.svg"/></p></td><td><code>con_logfile ././././[…]/bin/client.dll.log</code></td>
<td>The <code>bin/client.dll</code> is overwritten with a logfile entry (not a valid DLL anymore)</td>
<td><a href="#bug-3-arbitrary-text-file-write-in-game-directory">Bug 3</a></td></tr><tr><td><p><img src="https://blog.plover.com/blog/csgo_from_zero_to_0day/server.svg"/><span>→</span> <img src="https://blog.plover.com/blog/csgo_from_zero_to_0day/client.svg"/></p></td><td><code>crash</code></td>
<td>The client crashes. The user restarts the client.</td><td></td></tr><tr><td><p><img src="https://blog.plover.com/blog/csgo_from_zero_to_0day/client.svg"/></p></td><td><code>&lt;startup&gt;</code></td>
<td>Invalid signature check for overwritten <code>bin/client.dll</code>. </td>
<td><a href="#bug-4-fallback-to-disabled-signature-checks">Bug 4</a></td></tr><tr><td><p><img src="https://blog.plover.com/blog/csgo_from_zero_to_0day/client.svg"/></p></td><td><code>&lt;startup&gt;</code></td>
<td>Search in <code>SearchPaths</code> for <code>matchmaking.dll</code> results in DLL found in
<code>exploit/bin/matchmaking.dll</code>. </td><td></td></tr></tbody></table>
<h2 id="video">Video<a aria-hidden="true" tabindex="-1" href="#video"><span>¶</span></a></h2>
<p>We provide a video of the above outlined chain of the four logic bugs (see below). If you stop the video at 00:29 seconds you can notice interesting output in the CS:GO console and in the exploit server:</p>
<ul>
<li>The leaked <code>GAMEBIN: f:\spiele\steam\steamapps\common\couter-strike global offensive\csgo\bin</code> is retrieved from the exploit server</li>
<li>The CS:GO console shows the very long downloaded files, which succeed for the <code>././[..]/bin/matchmaking.dll.stf</code>  <code>././[..]/gameinfo.txt.stf</code> files. As described above, the <code>.stf</code> extension is stripped during the download, resulting in the download of <code>matchmaking.dll</code> and <code>gameinfo.txt</code>.</li>
</ul>
<center><video controls="" width="900"><source src="/blog/csgo_from_zero_to_0day/poc_rce.mp4" type="video/mp4"/></video></center>
<h2 id="closing-thoughts">Closing Thoughts<a aria-hidden="true" tabindex="-1" href="#closing-thoughts"><span>¶</span></a></h2>
<p>Often people ask us how much time we spent on building this exploit chain. Unfortunately, we can not determine the total time spent. For weeks, we met on Discord in the evening to exchange ideas, programm together and analyze our findings until late in the morning. Alain at that time had roughly 250 hours of gameplay in CS:GO and had not played a single online match. We found the bugs “relatively” quickly, but for their bug bounty program, Valve requires a full-chain exploit demonstrating RCE impact. Without the elaborate demonstration, the research would have been completed after 30% of the time. Hence, we invested quite some time in our RCE demonstration.</p>
<p>Speaking of Valve: We became aware of Valve’s high payouts for CS:GO through <a href="https://hackerone.com/reports/351014">various</a> and <a href="https://hackerone.com/reports/542180">simple looking</a> HackerOne reports. The reports at the time only needed to demonstrate memory corruption to get the full payout. Our initial euphoria quickly sank after our three different reports were quickly declared valid, but still not fixed even after 13 months and multiple requests. After a lot of pressure and the threat of full disclosure, the bugs were finally fixed. The payout was 7.5k per bug, less than we expected. All in all a sobering experience.</p>
<p>For us the CS:GO bug bounty journey was the first time we invested weeks of time into a project together. The takeaways for us personally were mainly:</p>
<ul>
<li>Don’t look for cricitial bugs and quick wins only.</li>
<li>Chain your bugs to unveal their full potential.</li>
<li>Keep your eyes open for edge cases and things devs didn’t think about.</li>
<li>Try harder! If run against a wall search for the hole and don’t give up early.</li>
</ul>
<h2 id="timeline">Timeline<a aria-hidden="true" tabindex="-1" href="#timeline"><span>¶</span></a></h2>

















































































<table><thead><tr><th>Date</th><th>Action</th></tr></thead><tbody><tr><td><strong>01.03.2020</strong></td><td>We send the initial Report with PoC video and exploit setup</td></tr><tr><td><strong>01.03.2020</strong></td><td>H1 has troubles to reproduce the issue</td></tr><tr><td><strong>03.03.2020</strong></td><td>We provide an exploit Docker setup for easier reproducability</td></tr><tr><td><strong>06.03.2020</strong></td><td>H1 still has troubles to reproduce the issue</td></tr><tr><td><strong>21.03.2020</strong></td><td>We provide a full server setup with OpenVPN for even easier reproducability</td></tr><tr><td><strong>21.03.2020</strong></td><td>H1 successfully reproduces the issue(s) and marks the report as triaged</td></tr><tr><td><strong>01.06.2020</strong></td><td>We ask for an update</td></tr><tr><td><strong>03.06.2020</strong></td><td>H1 states they are still looking into the report</td></tr><tr><td><strong>18.09.2020</strong></td><td>We ask for an update, as a total of half a year has passed by</td></tr><tr><td><strong>22.10.2020</strong></td><td>We ask again for an update</td></tr><tr><td><strong>27.10.2020</strong></td><td>H1 states that Valve is still looking into the reports</td></tr><tr><td><strong>01.03.2021</strong></td><td>We say “Happy Anniversary” and ask for an update</td></tr><tr><td><strong>March 2021</strong></td><td>We contact other researchers who submitted bugs to Valve and think about complaining in our reports as collective</td></tr><tr><td><strong>22.04.2021</strong></td><td>We write a statement about our dissatisfaction with the process and “reserve the right to disclose the findings in the upcoming weeks”</td></tr><tr><td><strong>26.04.2021</strong></td><td>H1 states that they flagged the report to “internal managers” and try to speed up the process</td></tr><tr><td><strong>30.04.2021</strong></td><td>We notice that the issues have been fixed and ask for coordinated disclosure with Valve</td></tr><tr><td><strong>01.05.2021</strong></td><td>H1 says “Thanks for the report” and we receive our bounty</td></tr><tr><td><strong>29.03.2022</strong></td><td>We request report disclosure, no response so far</td></tr></tbody></table>
		</div></div>
  </body>
</html>
