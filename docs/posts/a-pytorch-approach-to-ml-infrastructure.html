<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.run.house/blog/a-pytorch-approach-to-ml-infrastructure">Original</a>
    <h1>A PyTorch Approach to ML Infrastructure</h1>
    
    <div id="readability-page-1" class="page"><div><p>Platform overhead occupies 50-75% of ML engineers’ and researchers’ time. Runhouse is a PyTorch-like unified interface to solve that.</p><p><span>Published <!-- -->June 29, 2023</span></p><div><div><p><img src="https://cdn.sanity.io/images/cefqallt/production/071842e2a6d7b225d30b4c091eba6fe614f32539-2698x1446.png" alt="An image of a woman running in a field, overlayed by the text &#34;.to(&#39;cuda&#39;)&#34; with the word &#34;cuda&#34; crossed out and replaced with &#34;anywhere&#34;"/></p></div></div></div><div><div><p>In my experience, every machine learning project marches one-way from iterable and debuggable Python toward rigid, boiler-plate-ridden <em>platform code</em>. The march is toward more powerful infra - training on greater compute, testing on realer data, or deploying for live consumption - but the increasingly constrained debugging interfaces, translation into platform-specific APIs, and hour or longer iteration loops take velocity to a crawl.</p><p>As the product lead for PyTorch, I was baffled and frustrated by the universality of this phenomenon. PyTorch had produced a unified modeling language across research and production, OSS and private, and even different hardware types, and yet users would still spend 50-75% of their time trying to wrestle that code into their infra - in dependency hell, distributed hell, or CUDA hell; packaging their code into docker containers, CLIs, orchestration DAGs, or inference endpoints; and debugging from afar in notebooks, Slurm, or orchestrators. Users were frustrated that writing the modeling code was only a fraction of their time compared to learning these systems, debugging them, and translating from one to another.</p><div><p><img src="https://cdn.sanity.io/images/cefqallt/production/5ae9667d7beaad9a55db832e970202c95f264de3-938x196.png" alt="A tweet by @hingeloss: &#34;everybody wants to do ml until it&#39;s time to do ml infra&#34;"/></p></div><p>I spent years talking to hundreds of PyTorch users about these problems. They take many forms, but overwhelmingly stem from “fragmentation” or “silos” in ML, or the breakdowns as you move code across different compute and data infra. To be more specific, they fall in three categories:</p><ol><li><strong>Research and Production silos:</strong> Researchers have Pythonic, iterable, and easy-to-debug interfaces for fast experimentation, but are at arm’s length from the real compute and data infra used to power production. Meanwhile, production code runs on powerful infra but is hard to debug and has poor developer experience. Translating research into production (R2P) can be a 6-12 month activity, while there might not even be a path that takes production ML back to local Python for further development (P2R).</li><li><strong>External and Internal silos:</strong> Adapting external code for your own infra, or packaging your code to share with others, is a months-long undertaking. Simply not knowing what infra was used underneath some code you find in OSS or elsewhere in your company can lend it inaccessible to you.</li><li><strong>Infra silos:</strong> Every compute or data system has its own APIs and behavior, and even moving between systems within the same provider (e.g. EC2 → Sagemaker → EKS) can take months of code translation. The different visibility and management systems (or lack thereof) across providers and on-prem is a tentpole problem for many VPs of Data and ML. Models and data are lost on random servers, lineage and provenance is limited, resources exist without clear owners, and little is shared between teams.</li></ol><div><p><img src="https://cdn.sanity.io/images/cefqallt/production/eda1e7e9ed938b59287a16df29e509b1c75de5f1-916x198.png" alt="Tweet by @__usemah__: &#34;Mlops more like yaml hell&#34;"/></p></div><h2>Why can’t we have nice things?</h2><p>Over the last few years the broader software world has arrived at a golden age of developer experience, but two essential differences drove ML off that road.<br/></p><p><strong>Hardware-specificity</strong></p><p>Docker largely put the final nail in the coffin of code importability in traditional software. But ML code is highly hardware-specific and optimized, down to the <a href="https://twitter.com/nearcyan/status/1619141963843866630" target="_blank" rel="noopener noreferrer">CUDA minor version</a> and <a href="https://twitter.com/cHHillee/status/1630274862345490432" target="_blank" rel="noopener noreferrer">GPU layout</a>, so if you move your code to new hardware it will break no matter how many containers it’s wrapped in. If you stumble upon some Javascript code published with a dockerfile, you could probably run it within the hour. In ML you’d probably spend the hour Googling if this model runs on V100s, A10s, or A100s, and take weeks to get it running if it’s distributed or written for different hardware than yours.<br/></p><p><strong>Hardware-heterogeneity</strong></p><p>A single ML program often requires multiple types of hardware, and it’s expensive and wasteful to occupy that hardware for the life of the program. For this we use ML pipeline DAGs, but they have an interesting backstory. From 2012-2015, ML at big tech companies was CPU-centric and geographically distributed. They needed a way to ship ML algorithms to wherever on earth data were and run reproducibly. A pipeline of container images is a great way to do that, and Google, Facebook, and Uber widely announced their pipeline-centric ML platforms. Nowadays, everyone runs their code near the GPUs and the containers can’t simply be sprinkled on pools of datacenter CPU compute, but we’ve kept the pipeline DAGs. We take a massive iterability and debugging hit in exchange for running different pieces of the program on different hardware. DAGs are crucial and great for certain things - scheduling, caching results, monitoring, and handling failures - but they’re meant to do so for <strong>fully working programs</strong>. Imagine debugging a SQL statement by continually rerunning the full pipeline it’s contained in, instead of getting it working and then scheduling it in the pipeline. That’s what we do in ML.</p><h2>Unified interfaces solve silos</h2><p>The stories of notebooks, pipelines, and PyTorch point in the right direction for solving ML fragmentation: unified interfaces. Many researchers would prefer not to exclusively work in notebooks, but are happy for them to serve as a consistent high-iteration interface whether they run on Databricks, Sagemaker, Vertex, Azure ML, Kubeflow, etc. Similarly, orchestrators give the relief of abstracting away the compute underneath each node (e.g. on-prem, cloud VMs, Kuberenetes, serverless). PyTorch broke down silos between research/production and internal/OSS by providing a unified modeling interface.</p><p><strong>So what if there were a PyTorch for the infra too?</strong></p><h2>Runhouse: A unified interface into ML infra</h2><p>Over the last 8 months, I’ve teamed up with some old friends, <a href="https://www.linkedin.com/in/joshua-lewittes/" target="_blank" rel="noopener noreferrer">Josh</a> and <a href="https://www.linkedin.com/in/caroline-chen/" target="_blank" rel="noopener noreferrer">Caroline</a>, to work on <a href="https://github.com/run-house/runhouse" target="_blank" rel="noopener noreferrer">Runhouse</a>, an OSS unified Python interface into compute and data infra, built on the following principles:</p><p><strong>Infra Agnostic: </strong>ML platform teams sprung up everywhere from 2020-2022, and they want direct control of the infra. They don’t want to be disintermediated from the underlying infra, forgo control over which systems and tools they can use, or adopt a one-size-fits-most platform which introduces a new silo.</p><p><strong>A la carte: </strong>The onboarding lift (and subsequent vendor fatigue) in ML tooling is insane. Everyone is tired of 9 month trial integrations. Incremental adoption and not needing to migrate data, compute, or code is critical. A 10 minute time-to-wow is ideal.</p><p><strong>Python-generic: </strong>Many ML tools have been built with assumptions about how AI is done which go stale within a year or two as the field progresses. Being Python-generic but batteries-included for AI is much more durable, and avoids walling off non-AI teams.</p><h2>How it works</h2><p>Just as PyTorch lets you send a model <code>.to(&#34;cuda&#34;)</code>, Runhouse enables hardware heterogeneity by letting you send your code (or dataset, environment, pipeline, etc) <code>.to(“cloud_instance”, “on_prem”, “data_store”...)</code>, all from inside a Python notebook or script. There’s no need to manually move the code and data around, package into docker containers, or translate into a pipeline DAG.</p><div><p><span><code>gpu = rh.cluster(&#34;rh-a100&#34;, instance_type=&#34;A100:1&#34;, provider=&#34;cheapest&#34;)
inference_fn_gpu = rh.function(inference_fn).to(gpu, env=[&#39;./&#39;, &#39;torch&#39;])

result = inference_fn_gpu(prompt=&#39;A hot dog made of matcha powder.&#39;)
result.show()</code></span></p></div><p>I can send my function to an existing IP or pull instances fresh from any major cloud provider (AWS, GCP, Azure, Lambda, and more), all from inside my notebook or script. When I call this remote function, my inputs are sent to the server, the function is run, and the results are sent back to me. The function essentially became a service I can call over and over. If you think about the difference between what we call an “ML pipeline” and a simple Python script, the pipeline is a living system which is run repeatedly and updated over time. So doesn’t it make more sense to modularize it into smaller living systems, i.e. microservices, rather than slice it into docker images which each contain non-reusable glue code? That way, I can selectively send out the functions which need to run on remote infra, and leave the glue code where it is.</p><div><p><span><code># Create microservices for pipeline components, sending them to desired cluster to be run on
preproc_data = rh.function(fn=preproc_data).to(cpu, env=[&#34;datasets&#34;, &#34;transformers&#34;])
fine_tune = rh.function(fine_tune).to(gpu, env=[&#34;reqs:./&#34;])
eval_model = rh.function(eval_model).to(gpu)

with rh.run(name=&#34;exp_20230612&#34;, path=&#34;~/rh/logs/exp_20230612&#34;):
    train_data, test_data = preproc_data(remote_raw_data)  # runs on cpu
    trained_model = fine_tune(pretrained, train_data)  # runs on gpu
    accuracy = eval_model(trained_model, test_data)  # runs on gpu</code></span></p></div><p>You can think of Runhouse as an “eager-mode orchestrator,” comparable to a DAG based pipeline as PyTorch is to Tensorflow. It can traverse the same flexible, abstracted set of compute, but is executed by your local Python, and doesn’t need to be “submitted for execution” to a remote engine. It’s debuggable, DSL-free, and has a simple and predictable execution flow. You can use your orchestrator for what it’s good at, and slot your fully working program into it with minimal bundling or debugging (the services run exactly the same whether called from your notebook or orchestrator!).</p><div><p><img src="https://cdn.sanity.io/images/cefqallt/production/ecaf9034a85f6b31fd27bb982acfb9a3a3973ede-1358x930.png" alt="An ML pipeline flowing through multiple types of compute and data storage all in Python using Runhouse, and then being slotted in full into a single orchestrator node."/></p></div><p>There was once a claim that beyond a certain “scale” translating into pipeline DAGs is simply necessary. Directly disproving that claim, Uber recently announced that they’ve rearchitected their entire ML platform to call into the infra in Python in this way, instead of breaking up their code into pipeline DAGs. Runhouse uses this same approach built on Ray, but delivers it in a simple, incrementally adoptable interface that anyone can pick up and try.</p><div><p><img src="https://cdn.sanity.io/images/cefqallt/production/4b3d7f07ba51f25a0faf46fd51f897d98ad63a7f-1074x586.jpg" alt="A training pipeline at Uber running within a single Python file using Ray, rather than being broken up into nodes in an orchestrator."/></p></div><p><em>(image from <a href="https://www.uber.com/blog/horovod-ray/" target="_blank" rel="noopener noreferrer">2021 Uber blog post</a>)</em></p><p>We emphasize that Runhouse is an <em>interface</em> rather than a <em>platform</em> because it layers on top of your own existing compute and provider accounts. Your existing groups, quota, permissions, and networking remain unchanged, and we simply unify the surface with which you interact with them. That way, you can adopt it incrementally without vendor approvals, being disintermediated from the underlying infra, or creating a new silo. Data Scientists, Researchers, and ML Engineers can try Runhouse without needing to request vendor approvals or asking an infra team to integrate it into “the stack.”</p><div><p><img src="https://cdn.sanity.io/images/cefqallt/production/ca4fe5b4827aa43c82ce9e3f99206b86082dac13-1744x870.png" alt="A diagram showing how Runhouse can take a single function or table and send it many kinds of compute or data infrastructure."/></p></div><h2>OSS reproducibility &amp; accessibility</h2><p>The ability to program your infra from Python is especially powerful for OSS maintainers. Instead of publishing dozens of CLI commands and README instructions to reproduce a program, OSS maintainers can publish their actual multi-hardware code, including the exact hardware and dependencies. This alone can improve reproducibility, but by supporting a flexible set of infra behind the APIs, anyone can pick up the code and run it on their own infra. I can say firsthand that the top source of issues and questions for many AI OSS maintainers is setup, and many repos try to include detailed instructions for different cloud providers or usage scenarios. With Runhouse, OSS maintainers can build setup scripts and integrations once, and through Runhouse’s abstractions support all the major cloud providers, on-prem, and a continually growing set of infra underneath. In fact, Runhouse is used within Hugging Face <a href="https://github.com/huggingface/transformers/blob/main/examples/README.md#running-the-examples-on-remote-hardware-with-auto-setup" target="_blank" rel="noopener noreferrer">Transformers</a>, <a href="https://github.com/huggingface/accelerate/blob/main/examples/README.md#simple-multi-gpu-hardware-launcher" target="_blank" rel="noopener noreferrer">Accelerate</a>, and <a href="https://python.langchain.com/docs/modules/model_io/models/llms/integrations/runhouse.html" target="_blank" rel="noopener noreferrer">Langchain</a> in exactly that way.</p><h2>Runhouse Den: Making infra multiplayer</h2><p>We certainly can’t adapt code to any hardware, nor are we claiming to solve dependency hell. But ideally, once code is working on particular hardware, many can benefit. If you’ve sent your BERT fine-tuning function to 4 GPUs, gotten it running and optimized the speed and memory consumption, Runhouse allows you to save and persist that microservice for further use. You can load and call the service from your pipeline to make it even lighter and easier to maintain, and know that it’s calling the same exact code on the same exact hardware as your notebook did. And further, you can share it with your team or company as a common BERT fine-tuning service, which can be versioned and updated over time. The same can be said for other cloud resources like your preprocessed table, model checkpoint, or inference function. </p><p>Runhouse includes a free DNS-like service called <a href="https://www.run.house/" target="_blank" rel="noopener noreferrer">Den</a> which allows this type of multiplayer resource sharing and management (only sharing a minimal amount of metadata while the resources stay in your own doors), think <strong>Google Drive for your ML resources</strong>. Google spent years convincing everyone to migrate their files to the cloud to facilitate the sharing and accessibility of Google Drive. Compute and data resources already live in the cloud, so it’s crazy that we can’t already share and access them just as easily. Den provides this accessibility and sharing layer across infra and providers, allowing ML teams to build a common ML corpus across research and production.</p><h2>What Runhouse is not</h2><p>We want to be clear that Runhouse is not a system that you need to migrate to from whatever infra or tooling you use today. It doesn’t have a clear analogue in the ecosystem and is largely complementary to the existing stack. For example, you can use Runhouse with your orchestrator by writing and iterating on your heterogeneous ML programs in Python and then slotting them into an orchestration node in full to schedule and monitor them. You can save Runhouse resources to your experiment management system to improve reproducibility and ease of retrieving the original resources. Runhouse can also allow you to more easily try and onboard to new compute platforms (e.g. Anyscale, Sagemaker, Modal, etc.) by giving you a consistent interface and convenient defaults across paradigms which minimize change to your code.</p><h2>Building in the open</h2><p>Runhouse is in the relatively early stages considering the long list of infra we’d like to support. We feel it’s crucial that the project is built transparently and in the open to maximize its applicability to the broadest range of usage scenarios and remains low-lift to adopt. You can find our currently supported infra types and providers in our <a href="https://github.com/run-house/runhouse" target="_blank" rel="noopener noreferrer">README</a>, as well as upcoming additions. If you’re aligned with the vision above (or vehemently oppose it) we strongly welcome input, contributions, and opportunities to partner, and can be reached in <a href="https://github.com/run-house/runhouse" target="_blank" rel="noopener noreferrer">Github</a>, over email (first name at run.house), or in our <a href="https://discord.gg/RnhB6589Hs" target="_blank" rel="noopener noreferrer">Discord</a>.</p></div></div></div>
  </body>
</html>
