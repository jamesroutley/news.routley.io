<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://serokell.io/blog/rust-vs-haskell">Original</a>
    <h1>Rust vs. Haskell</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Rust and Haskell don’t shy away from powerful features. As a result, both languages have steep learning curves compared with other languages. Trying to learn Rust or Haskell can be frustrating, especially in the first couple of months.</p>
<p>But if you already know Rust, you have a head start with Haskell; and vice versa.</p>
<p>In this article, we want to show how knowledge of one of these languages can help you get up to speed with another.</p>
<p>We won’t cover all the similarities or differences and won’t talk about language domains. Our main goal is to show the bridge between the languages; you can decide whether you want to walk it.</p>
<p>We won’t cover syntax as well, but get ready to switch between indentation and braces, as well as read code in opposite directions. 😉</p>
<h2 id="basic-concepts"><p>Basic concepts</p></h2>
<p>Haskell and Rust have both been influenced by the <a href="https://en.wikipedia.org/wiki/ML_(programming_language)">ML</a> programming language. ML has strong static typing with type inference, and so do Haskell and Rust.</p>
<p>There are other similarities:</p>
<ul>
<li>algebraic data types;</li>
<li>pattern matching;</li>
<li>parametric polymorphism;</li>
<li>ad-hoc polymorphism.</li>
</ul>
<p>We’ll cover all of these later in the article, but first, let’s talk about compilers. Both languages focus on safety – they are extremely good at compile-time checks.</p>
<h3 id="type-system"><p>Type system</p></h3>
<p>If you’re coming from one of these languages, we don’t have to convince you that types are our friends: they help us avoid silly mistakes and reduce the number of bugs.</p>
<p>Rust and Haskell have similar type systems. Both support conventional basic types, such as integers, floats, booleans, strings, etc. Both make it easy to create new types, use newtypes, and type aliases.</p>
<hr/>
<p>🙂 When using strings, Rust beginners puzzle over <code>String</code> vs. <code>&amp;str</code>, and Haskell beginners puzzle over <code>String</code> vs. <code>Text</code> vs. <code>ByteString</code>.</p>
<hr/>
<p>Rust can infer types when possible.</p>
<pre><code><span>let</span> <span>bools</span> = <span>vec!</span>[<span>true</span>, <span>false</span>, <span>true</span>];
<span>let</span> <span>not_head</span> = bools[<span>0</span>].<span>not</span>(); 
</code></pre>
<p>But omitting function parameter types is not allowed.</p>
<pre><code><span>fn</span> <span>get_double_head</span>(ints) {




    ints[<span>0</span>] * <span>2</span>
}
</code></pre>
<p>Omitting function return types is also not allowed.</p>
<pre><code><span>fn</span> <span>get_double_head</span>(ints: <span>Vec</span>&lt;<span>i32</span>&gt;) {
    ints[<span>0</span>] * <span>2</span>


}
</code></pre>
<p>In Rust, we always have to specify both:</p>
<pre><code><span>fn</span> <span>get_double_head</span>(ints: <span>Vec</span>&lt;<span>i32</span>&gt;) <span>-&gt;</span> <span>i32</span> {
    ints[<span>0</span>] * <span>2</span>
}
</code></pre>
<p>Haskell can infer types when they’re not ambiguous.</p>
<pre><code><span>let</span> bools = [<span>True</span>, <span>False</span>, <span>True</span>]
<span>let</span> notHead = not (head bools) 
</code></pre>
<p>We don’t have to annotate function parameters and return types.</p>
<pre><code><span>getDoubleHead</span> ints =
  head ints * <span>2</span>
</code></pre>
<p>But it usually results in a warning, and adding a type signature is a good practice.</p>
<pre><code><span>getDoubleHead</span> :: [<span>Integer</span>] -&gt; <span>Integer</span>
<span>getDoubleHead</span> ints =
  head ints * <span>2</span>
</code></pre>
<hr/>
<p>💡 <strong>Note:</strong> You can test the Haskell code snippets by pasting them in the <a href="https://downloads.haskell.org/ghc/latest/docs/users_guide/ghci.html">REPL</a>. Rust doesn’t have an interactive environment, so you have to reorganize the snippets and use the <code>main</code> function if you want to give them a try.</p>
<hr/>
<h3 id="variables-and-mutability"><p>Variables and mutability</p></h3>
<p>Rust variables are, by default, immutable – when you want a mutable variable, you have to be explicit.</p>
<pre><code><span>let</span> <span>immutable_x</span>: <span>i32</span> = <span>3</span>;
    immutable_x = <span>1</span>;

</code></pre>
<pre><code><span>let</span> <span>mut </span><span>mutable_x</span> = <span>3</span>; 
mutable_x = <span>1</span>;         
mutable_x += <span>4</span>;        
</code></pre>
<p>There are no mutable variables in Haskell – the syntax has no such thing as a reassignment statement. However, the value to which the variable is bound may be a mutable cell, such as <a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Data-IORef.html"><code>IORef</code></a>, <a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Data-STRef.html"><code>STRef</code></a>, or <a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Control-Concurrent-MVar.html"><code>MVar</code></a>. The type system tracks mutability, and Haskell does not require a separate <code>mut</code> keyword.</p>
<hr/>
<p>💡 Note that Haskell allows name shadowing. But it’s discouraged and can be caught with a warning.</p>
<pre><code><span>let</span> immutable_x = <span>3</span>
<span>let</span> immutable_x = <span>1</span>


</code></pre>
<p>In Rust, name shadowing is considered idiomatic. For example, the following code snippet reuses <code>x</code> and <code>y</code>:</p>
<pre><code>
<span>let</span> (x, y) = s.<span>split_once</span>(<span>&#39;,&#39;</span>).<span>unwrap</span>();
<span>let</span> <span>x</span>: <span>i32</span> = x.<span>parse</span>().<span>unwrap</span>();
<span>let</span> <span>y</span>: <span>i32</span> = y.<span>parse</span>().<span>unwrap</span>();
</code></pre>
<hr/>
<p>Haskell relies heavily on purely functional data structures, operations on which return new versions of data structures, while the original reference stays unmodified and valid.</p>
<p>For example, if we have a map and want to do some operation on a slightly modified map, we can have a value that keeps the old map but also works with the new map (without much performance cost).</p>
<pre><code><span>import</span> <span>qualified</span> Data.HashMap.Strict <span>as</span> HashMap

<span>let</span> old = <span>HashMap</span>.fromList [(<span>&#34;Donut&#34;</span>, <span>1.0</span>), (<span>&#34;Cake&#34;</span>, <span>1.2</span>)]
<span>let</span> new = <span>HashMap</span>.insert <span>&#34;Cinnamon roll&#34;</span> <span>2.25</span> old

<span>print</span> old

<span>print</span> new

</code></pre>
<hr/>
<p>💡 Yes, that’s how Haskell prints a map. Yes, it’s weird.</p>
<p>The <a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Prelude.html#v:print"><code>print</code></a> function converts values to strings by using <a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Prelude.html#v:show"><code>show</code></a> and outputs it to the standard output. The result of <a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Prelude.html#t:Show"><code>show</code></a> is a syntactically correct Haskell expression, which can be pasted right into the code.</p>
<hr/>
<p>In Rust, standard operations mutate the collection, so there’s no way to access its state before the modification.</p>
<pre><code><span>use</span> std::collections::HashMap;

<span>let</span> <span>mut </span><span>prices</span> = HashMap::<span>from</span>([(<span>&#34;Cake&#34;</span>, <span>1.2</span>), (<span>&#34;Donut&#34;</span>, <span>1.0</span>)]);
prices.<span>insert</span>(<span>&#34;Cinnamon roll&#34;</span>, <span>2.25</span>);

<span>println!</span>(<span>&#34;{:?}&#34;</span>, prices); 

</code></pre>
<hr/>
<p><strong>💡 What is <code>{:?}</code>?</strong></p>
<p>We can use it to debug-format any type. It relies on the <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>fmt::Debug</code></a> trait, which <strong>should</strong> be implemented for all public types.</p>
<hr/>
<p>If we want to emulate Haskell when working with default collections, we have to <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>clone</code></a> the old one.</p>
<pre><code><span>use</span> std::collections::HashMap;

<span>let</span> <span>old</span> = HashMap::<span>from</span>([(<span>&#34;Cake&#34;</span>, <span>1.2</span>), (<span>&#34;Donut&#34;</span>, <span>1.0</span>)]);
<span>let</span> <span>mut </span><span>new</span> = HashMap::<span>new</span>();

new.<span>clone_from</span>(&amp;old);
new.<span>insert</span>(<span>&#34;Cinnamon roll&#34;</span>, <span>2.25</span>);

<span>println!</span>(<span>&#34;{:?}&#34;</span>, old); 

<span>println!</span>(<span>&#34;{:?}&#34;</span>, new); 

</code></pre>
<hr/>
<p>💡 Note that persistent data structures in Haskell are usually designed for cheap cloning, so most operations have <code>O(log n)</code> complexity. In Rust, we don’t tend to clone that often, so access and mutation typically have <code>O(1)</code> and cloning – <code>O(n)</code>.</p>
<hr/>
<p>💡 Haskell has mutable constructs (such as <a href="https://hackage.haskell.org/package/array-0.5.4.0/docs/Data-Array-ST.html"><code>STArray</code></a> and <a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Data-IORef.html"><code>IORef</code></a>), which you can use when you need mutability.</p>
<hr/>
<h2 id="algebraic-data-types-(adts)"><p>Algebraic data types (ADTs)</p></h2>
<p>In simple terms, ADTs are a way to construct types. Haskell uses the single keyword <code>data</code> to declare product and sum types, while Rust uses <code>struct</code> and <code>enum</code>.</p>
<p>To learn more about algebraic data types, check out our <a href="https://serokell.io/blog/algebraic-data-types-in-haskell">article on ADTs</a> in Haskell.</p>
<h3 id="product-types-(structs)"><p>Product types (structs)</p></h3>
<p>In Rust, product types are represented by structs, which come in two forms:</p>
<ul>
<li>tuple structs;</li>
<li>structs with named fields.</li>
</ul>
<pre><code>
<span>struct</span> <span>SimpleItem</span>(<span>String</span>, <span>f64</span>);


<span>#[derive(Debug)]</span>
<span>struct</span> <span>Item</span> {
    name: <span>String</span>,
    price: <span>f64</span>,
}
</code></pre>
<p>Which is quite similar to Haskell’s datatypes and records.</p>
<pre><code>
<span><span>data</span> <span>SimpleItem</span> = <span>SimpleItem</span> <span>String</span> <span>Double</span></span>


<span><span>data</span> <span>Item</span> = <span>Item</span></span>
  { name :: <span>String</span>
  , price :: <span>Double</span>
  }
  <span>deriving</span> (<span>Show</span>)
</code></pre>
<p>Note that <code>#[derive(Debug)]</code> corresponds to <code>deriving (Show)</code>.</p>
<p>In Haskell, we have to provide a type constructor (the name of our type) and a data constructor (used to construct new instances of the type), which are the same as in the previous snippet.</p>
<h4 id="creating-instances-of-types"><p>Creating instances of types</p></h4>
<p>We can create instances of product types. In Rust:</p>
<pre><code>
<span>let</span> <span>simple_donut</span> = <span>SimpleItem</span>(<span>&#34;Donut&#34;</span>.<span>to_string</span>(), <span>1.0</span>);


<span>let</span> <span>cake</span> = Item {
    name: <span>&#34;Cake&#34;</span>.<span>to_string</span>(),
    price: <span>1.2</span>,
};
</code></pre>
<p>In Haskell:</p>
<pre><code>
<span>let</span> simpleDonut = <span>SimpleItem</span> <span>&#34;Donut&#34;</span> <span>1.0</span>


<span>let</span> donut = <span>Item</span> <span>&#34;Donut&#34;</span> <span>1.0</span>
<span>let</span> cake = <span>Item</span>{name = <span>&#34;Cake&#34;</span>, price = <span>1.2</span>}
</code></pre>
<p>We can use either the ordinary syntax or the record syntax to create records in Haskell.</p>
<h4 id="getting-field-values"><p>Getting field values</p></h4>
<p>In Rust, we can get the value of a field by using dot notation.</p>
<pre><code><span>let</span> <span>cake_price</span> = cake.price;
<span>println!</span>(<span>&#34;It costs {}&#34;</span>, cake_price); 

</code></pre>
<p>In Haskell, we have been using field accessors (basically, getters), such as <code>price</code>:</p>
<pre><code><span>let</span> cakePrice = price cake
<span>print</span> $ <span>&#34;It costs &#34;</span> ++ show cakePrice 

</code></pre>
<p>But since GHC 9.2, we can use dot notation as well.</p>
<hr/>
<p>💡GHC is the Glasgow Haskell Compiler, the most commonly used Haskell compiler.</p>
<hr/>
<pre><code><span>let</span> cakePrice = cake.price
<span>print</span> $ <span>&#34;It costs &#34;</span> ++ show cakePrice 

</code></pre>
<hr/>
<p><strong>🤑 What is <code>$</code>?</strong></p>
<p>We use the dollar sign (<code>$</code>) to avoid parentheses.</p>
<p>Function application has higher precedence than most binary operators. The following usage results in a compilation error:</p>
<pre><code>
<span>print</span> <span>&#34;It costs &#34;</span> ++ show cakePrice

(print <span>&#34;It costs &#34;</span>) ++ (show cakePrice)
</code></pre>
<p><code>$</code> is also a function application operator (<code>f $ x</code> is the same as <code>f x</code>). But it has very low precedence. The following usage works:</p>
<pre><code>
<span>print</span> $ <span>&#34;It costs &#34;</span> ++ show cakePrice

<span>print</span> (<span>&#34;It costs &#34;</span> ++ show cakePrice)
</code></pre>
<hr/>
<h4 id="updating-field-values"><p>Updating field values</p></h4>
<p>In Rust, if the struct variable is mutable, we can change its values.</p>
<pre><code><span>let</span> <span>mut </span><span>cake</span> = Item {
    name: <span>&#34;Cake&#34;</span>.<span>to_string</span>(),
    price: <span>1.2</span>,
};

cake.price = <span>1.4</span>;

<span>println!</span>(<span>&#34;{:?}&#34;</span>, cake); 

</code></pre>
<p>In Haskell, a record update returns another record, and the original one stays unchanged (as we’ve covered in the mutability section).</p>
<pre><code><span>let</span> cake = <span>Item</span>{name = <span>&#34;Cake&#34;</span>, price = <span>1.2</span>}

<span>let</span> updatedCake = cake{price = <span>1.4</span>}

<span>print</span> cake

<span>print</span> updatedCake

</code></pre>
<p>If we want to do something similar in Rust, we can use struct update syntax to copy and modify a struct.</p>
<pre><code><span>let</span> <span>pricy_cake</span> = Item { price: <span>1.6</span>, ..cake };

<span>println!</span>(<span>&#34;{:?}&#34;</span>, pricy_cake);

</code></pre>
<p>Both languages have a simplified field initialization syntax if there are matching names in scope:</p>
<pre><code><span>let</span> <span>name</span> = <span>&#34;Cinnamon roll&#34;</span>.<span>to_string</span>();
<span>let</span> <span>price</span> = <span>2.25</span>;

<span>let</span> <span>cinnamon_roll</span> = Item { name, price }; 
</code></pre>
<p>To use it in Haskell, you have to enable <a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/control.html#extension-GHC2021"><code>GHC2021</code></a> or the <a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/record_puns.html"><code>NamedFieldPuns</code></a> extension.</p>
<pre><code><span>let</span> name = <span>&#34;Cinnamon roll&#34;</span>
<span>let</span> price = <span>2.25</span>

<span>let</span> cinnamonRoll = <span>Item</span>{name, price} 
</code></pre>
<h3 id="sum-types-(enums)"><p>Sum types (enums)</p></h3>
<p>Here is an example of a simple sum type:</p>
<pre><code><span>#[derive(Debug)]</span>
<span>enum</span> <span>DonutType</span> {
    Regular,
    Twist,
    ButtermilkBar,
}

<span>let</span> <span>twist</span> = DonutType::Twist;
</code></pre>
<pre><code><span><span>data</span> <span>DonutType</span> = <span>Regular</span> | <span>Twist</span> | <span>ButtermilkBar</span></span>
  <span>deriving</span> (<span>Show</span>)

<span>let</span> twist = <span>Twist</span>
</code></pre>
<p>The variants don’t have to be boring and can contain fields (which can be unnamed or named).</p>
<p>For example, we can have a <code>Donut</code> with <code>DonutType</code>:</p>
<pre><code><span>#[derive(Debug)]</span>
<span>enum</span> <span>Pastry</span> {
    <span>Donut</span>(DonutType),
    Croissant,
    CinnamonRoll,
}

<span>let</span> <span>twist_donut</span> = Pastry::<span>Donut</span>(DonutType::Twist);
</code></pre>
<pre><code><span><span>data</span> <span>Pastry</span></span>
  = <span>Donut</span> <span>DonutType</span>
  | <span>Croissant</span>
  | <span>CinnamonRoll</span>
  <span>deriving</span> (<span>Show</span>)

<span>let</span> twistDonut = <span>Donut</span> <span>Twist</span>
</code></pre>
<h4 id="partial-field-accessors"><p>Partial field accessors</p></h4>
<p>Haskell allows partial field accessors, while Rust does not.</p>
<p>For example, let’s take <code>Croissant</code>: the <code>price</code> field is present in both constructors, while <code>filling</code> is present only in <code>WithFilling</code>. In Rust, we get a compilation error when we try to access the filling of a plain croissant. In Haskell, we get a runtime error.</p>
<pre><code><span>enum</span> <span>Croissant</span> {
    Plain { price: <span>f64</span> },
    WithFilling { filling: <span>String</span>, price: <span>f64</span> },
}

<span>let</span> <span>plain</span> = Croissant::Plain { price: <span>1.75</span> };

<span>println!</span>(<span>&#34;{}&#34;</span>, plain.price)


</code></pre>
<pre><code><span><span>data</span> <span>Croissant</span></span>
  = <span>Plain</span> {price :: <span>Double</span>}
  | <span>WithFilling</span> {filling :: <span>String</span>, price :: <span>Double</span>}

<span>let</span> plain = <span>Plain</span> <span>1.75</span>


<span>print</span> $ price plain



<span>print</span> $ filling plain

</code></pre>
<h3 id="pattern-matching"><p>Pattern matching</p></h3>
<p>We could have used pattern matching to deconstruct values in the previous snippets. To illustrate this, let’s create a function that returns a receipt for a croissant.</p>
<pre><code><span>fn</span> <span>to_receipt</span>(croissant: Croissant) <span>-&gt;</span> <span>String</span> {
    <span>match</span> croissant {
        Croissant::Plain { price } =&gt; <span>format!</span>(<span>&#34;Plain croissant: ${price}&#34;</span>),
        Croissant::WithFilling { filling: _, price } =&gt; {
            <span>format!</span>(<span>&#34;Croissant with filling: ${}&#34;</span>, price)
        }
    }
}

<span>let</span> <span>croissant</span> = Croissant::WithFilling {
    filling: <span>&#34;Ham &amp; Cheese&#34;</span>.<span>to_string</span>(),
    price: <span>3.35</span>,
};
<span>println!</span>(<span>&#34;{:?}&#34;</span>, <span>to_receipt</span>(croissant));

</code></pre>
<pre><code><span>toReceipt</span> :: <span>Croissant</span> -&gt; <span>String</span>
<span>toReceipt</span> croissant = <span>case</span> croissant <span>of</span>
  <span>Plain</span> price -&gt; <span>&#34;Plain croissant: $&#34;</span> &lt;&gt; show price
  <span>WithFilling</span> _ price -&gt; <span>&#34;Croissant with filling: $&#34;</span> &lt;&gt; show price

<span>print</span> $ toReceipt $ <span>WithFilling</span> <span>&#34;Ham &amp; Cheese&#34;</span> <span>3.35</span>

</code></pre>
<p>Haskell also allows an alternative syntax:</p>
<pre><code><span>toReceipt</span> :: <span>Croissant</span> -&gt; <span>String</span>
<span>toReceipt</span> (<span>Plain</span> price) = <span>&#34;Plain croissant: $&#34;</span> &lt;&gt; show price
<span>toReceipt</span> (<span>WithFilling</span> _ price) = <span>&#34;Croissant with filling: $&#34;</span> &lt;&gt; show price
</code></pre>
<h4 id="partial-patterns"><p>Partial patterns</p></h4>
<p>Rust is strict about pattern matches being complete.</p>
<pre><code><span>fn</span> <span>to_receipt</span>(croissant: Croissant) <span>-&gt;</span> <span>String</span> {
    <span>match</span> croissant {

        Croissant::Plain { price } =&gt; <span>format!</span>(<span>&#34;Plain croissant: ${}&#34;</span>, price),
    }
}


</code></pre>
<p>While Haskell allows partial pattern matches:</p>
<pre><code><span>toReceipt</span> :: <span>Croissant</span> -&gt; <span>String</span>
<span>toReceipt</span> croissant = <span>case</span> croissant <span>of</span>
  (<span>PlainCroissant</span> price) -&gt; <span>&#34;Plain croissant: $&#34;</span> &lt;&gt; show price

<span>print</span> $ toReceipt $ <span>WithFilling</span> <span>&#34;Ham &amp; Cheese&#34;</span> <span>3.35</span>

</code></pre>
<p>But it’s highly discouraged, and a warning can catch this at compile time.</p>
<pre><code>Pattern match(es) are non-exhaustive
In a case alternative:
  Patterns of type ‘Croissant’ not matched: WithFilling _ _
</code></pre>
<h2 id="failure-handling"><p>Failure handling</p></h2>
<p>Now, let’s look at two commonly used ADTs: <code>Option</code> / <code>Maybe</code> and <code>Result</code> / <code>Either</code>, as well as the standard ways of dealing with errors.</p>
<h3 id="option-%2F-maybe-and-result-%2F-either"><p><code>Option</code> / <code>Maybe</code> and <code>Result</code> / <code>Either</code></p></h3>
<p><code>Option</code> has two variants: <code>None</code> or <code>Some</code>; <code>Maybe</code>: <code>Nothing</code> or <code>Just</code>.</p>
<pre><code>
<span>enum</span> <span>Option</span>&lt;T&gt; {
    <span>None</span>,
    <span>Some</span>(T),
}

<span>let</span> <span>head</span> = [<span>&#34;Donut&#34;</span>, <span>&#34;Cake&#34;</span>, <span>&#34;Cinnamon roll&#34;</span>].<span>get</span>(<span>0</span>);
<span>println!</span>(<span>&#34;{:?}&#34;</span>, head);


<span>let</span> <span>no_head</span>: <span>Option</span>&lt;&amp;<span>i32</span>&gt; = [].<span>get</span>(<span>0</span>);
<span>println!</span>(<span>&#34;{:?}&#34;</span>, no_head);

</code></pre>
<pre><code>
<span><span>data</span> <span>Maybe</span> a = <span>Just</span> a | <span>Nothing</span></span>

<span>safeHead</span> :: [a] -&gt; <span>Maybe</span> a
<span>safeHead</span> (x : _) = <span>Just</span> x
<span>safeHead</span> [] = <span>Nothing</span>

<span>print</span> $ safeHead [<span>&#34;Donut&#34;</span>, <span>&#34;Cake&#34;</span>, <span>&#34;Cinnamon roll&#34;</span>]


<span>print</span> $ safeHead []

</code></pre>
<p><code>Result</code> also has two variants: <code>Ok</code> or <code>Err</code>; <code>Either</code>: <code>Right</code> and <code>Left</code> (by convention, <code>Right</code> is success and <code>Left</code> is failure).</p>
<pre><code>
<span>enum</span> <span>Result</span>&lt;T, E&gt; {
    <span>Ok</span>(T),
    <span>Err</span>(E),
}

<span>#[derive(Debug)]</span>
<span>struct</span> <span>DivideByZero</span>;

<span>fn</span> <span>safe_division</span>(x: <span>i32</span>, y: <span>i32</span>) <span>-&gt;</span> <span>Result</span>&lt;<span>i32</span>, DivideByZero&gt; {
    <span>match</span> y {
        <span>0</span> =&gt; <span>Err</span>(DivideByZero),
        _ =&gt; <span>Ok</span>(x / y),
    }
}

<span>println!</span>(<span>&#34;{:?}&#34;</span>, <span>safe_division</span>(<span>4</span>, <span>2</span>));


<span>println!</span>(<span>&#34;{:?}&#34;</span>, <span>safe_division</span>(<span>4</span>, <span>0</span>))

</code></pre>
<pre><code>
<span><span>data</span> <span>Either</span> a b = <span>Left</span> a | <span>Right</span> b</span>
<span><span>data</span> <span>DivideByZero</span> = <span>DivideByZero</span></span>
  <span>deriving</span> (<span>Show</span>)

<span>safeDivision</span> :: <span>Int</span> -&gt; <span>Int</span> -&gt; <span>Either</span> <span>DivideByZero</span> <span>Int</span>
<span>safeDivision</span> x y = <span>case</span> y <span>of</span>
  <span>0</span> -&gt; <span>Left</span> <span>DivideByZero</span>
  _ -&gt; <span>Right</span> $ x `div` y

<span>print</span> $ safeDivision <span>4</span> <span>2</span>
// <span>Prints</span>: <span>Right</span> <span>2</span>

<span>print</span> $ safeDivision <span>4</span> <span>0</span>
// <span>Prints</span>: <span>Left</span> <span>DivideByZero</span>
</code></pre>
<p>When we work with either of the types, it’s common to pattern match to deal with different cases. Because it can be tiresome, both languages provide alternatives. Let’s check them out first.</p>
<p>In Rust, we can get a value from an <code>Option</code> or a <code>Result</code> by calling <code>unwrap</code>.</p>
<pre><code><span>println!</span>(<span>&#34;{:?}&#34;</span>, <span>safe_division</span>(<span>4</span>, <span>2</span>).<span>unwrap</span>());


<span>println!</span>(<span>&#34;{:?}&#34;</span>, <span>safe_division</span>(<span>4</span>, <span>0</span>).<span>unwrap</span>());

</code></pre>
<p>Calling it on a <code>None</code> or <code>Error</code> will <a href="https://doc.rust-lang.org/std/macro.panic.html">panic</a> the program, defeating the purpose of error handling.</p>
<hr/>
<p><strong>💡 What happens when a panic occurs?</strong></p>
<p>By default, panics will print a failure message, unwind, clean up the stack, and abort the process. You can also configure Rust to display the call stack.</p>
<hr/>
<p>We can use <code>unwrap_or()</code> to safely unwrap values.</p>
<pre><code><span>let</span> <span>item</span> = [].<span>get</span>(<span>0</span>).<span>unwrap_or</span>(&amp;<span>&#34;Plain donut&#34;</span>);

<span>println!</span>(<span>&#34;I got: {}&#34;</span>, item);

</code></pre>
<hr/>
<p>💡 There are a couple of ways to safely unwrap values:</p>
<ul>
<li><code>unwrap_or()</code>, which eagerly evaluates the default value;</li>
<li><code>unwrap_or_else()</code>, which lazily evaluates the default value;</li>
<li><code>unwrap_or_default()</code>, which relies on the type’s <code>Default</code> trait implementation.</li>
</ul>
<hr/>
<p>It’s not very idiomatic to get things out of things in Haskell, but the standard library provides a similar function called <code>fromMaybe</code>.</p>
<pre><code><span>import</span> Data.Maybe (<span>fromMaybe</span>)

<span>let</span> item = fromMaybe <span>&#34;Plain donut&#34;</span> $ safeHead []

<span>print</span> $ <span>&#34;I got: &#34;</span> ++ item

</code></pre>
<p>We prefer to chain things together in Haskell.</p>
<p>We can chain multiple enums and operations in Rust using the <code>and_then()</code> method. For example, we can sequence a few safe divisions:</p>
<pre><code><span>let</span> <span>eighth</span> = <span>safe_division</span>(<span>128</span>, <span>2</span>)
    .<span>and_then</span>(|x| <span>safe_division</span>(x, <span>2</span>))
    .<span>and_then</span>(|x| <span>safe_division</span>(x, <span>2</span>));

<span>println!</span>(<span>&#34;{:?}&#34;</span>, eighth); 


<span>let</span> <span>failure</span> = <span>safe_division</span>(<span>128</span>, <span>0</span>).<span>and_then</span>(|x| <span>safe_division</span>(x, <span>2</span>));
<span>println!</span>(<span>&#34;{:?}&#34;</span>, failure);

</code></pre>
<hr/>
<p>💡 These are lambdas (we’ll cover them in detail later):</p>
<pre><code>|x| x + <span>2</span>
</code></pre>
<pre><code>\x -&gt; x + <span>2</span>
</code></pre>
<hr/>
<p>In Haskell, we use the bind (<code>&gt;&gt;=</code>) operator.</p>
<pre><code><span>let</span> eighth = 
      safeDivision <span>128</span> <span>2</span> &gt;&gt;= \x -&gt;
          safeDivision x <span>2</span> &gt;&gt;= \x -&gt;
            safeDivision x <span>2</span>

<span>print</span> eighth 

<span>let</span> failure = safeDivision <span>128</span> <span>0</span> &gt;&gt;= \x -&gt; safeDivision x <span>2</span>
<span>print</span> failure

</code></pre>
<p>And last but not least, Rust provides the question mark operator (<code>?</code>) to deal with <code>Result</code> and <code>Option</code>.</p>
<pre><code><span>use</span> std::collections::HashMap;

<span>let</span> <span>prices</span> = HashMap::<span>from</span>([(<span>&#34;Cake&#34;</span>, <span>1.2</span>), (<span>&#34;Donut&#34;</span>, <span>1.0</span>), (<span>&#34;Cinnamon roll&#34;</span>, <span>2.25</span>)]);

<span>fn</span> <span>order_sweets</span>(prices: HashMap&lt;&amp;<span>str</span>, <span>f64</span>&gt;) <span>-&gt;</span> <span>Option</span>&lt;<span>f64</span>&gt; {
    <span>let</span> <span>donut_price</span> = prices.<span>get</span>(<span>&#34;Donut&#34;</span>)?;  
    <span>let</span> <span>cake_price</span> = prices.<span>get</span>(<span>&#34;Cake&#34;</span>)?;  
    <span>Some</span>(donut_price + cake_price)
}

<span>let</span> <span>total_price</span> = <span>order_sweets</span>(prices);
<span>println!</span>(<span>&#34;{:?}&#34;</span>, total_price); 

</code></pre>
<p>The operation short-circuits in case of failure. For example, if we try to look up and use a non-existing item:</p>
<pre><code><span>fn</span> <span>order_sweets</span>(prices: HashMap&lt;&amp;<span>str</span>, <span>f64</span>&gt;) <span>-&gt;</span> <span>Option</span>&lt;<span>f64</span>&gt; {
    <span>let</span> <span>donut_price</span> = prices.<span>get</span>(<span>&#34;Donut&#34;</span>)?;
    <span>let</span> <span>cake_price</span> = prices.<span>get</span>(<span>&#34;Cake&#34;</span>)?;
    <span>let</span> <span>missing_price</span> = prices.<span>get</span>(<span>&#34;Something random&#34;</span>)?; 

    <span>Some</span>(donut_price + cake_price + missing_price)
}

<span>let</span> <span>total_price</span> = <span>order_sweets</span>(prices);
<span>println!</span>(<span>&#34;{:?}&#34;</span>, total_price); 

</code></pre>
<p>And in Haskell, we favor do-notation (syntactic sugar to chain special expressions; we are big fans of these).</p>
<pre><code><span>import</span> Data.HashMap.Strict (<span>HashMap</span>)
<span>import</span> <span>qualified</span> Data.HashMap.Strict <span>as</span> HashMap

<span>let</span> prices = <span>HashMap</span>.fromList [(<span>&#34;Donut&#34;</span>, <span>1.0</span>), (<span>&#34;Cake&#34;</span>, <span>1.2</span>), (<span>&#34;Cinnamon roll&#34;</span>, <span>2.25</span>)]
 
<span>orderSweets</span> :: <span>HashMap</span> <span>String</span> <span>Double</span> -&gt; <span>Maybe</span> <span>Double</span>
<span>orderSweets</span> prices = <span>do</span>
  donutPrice &lt;- <span>HashMap</span>.lookup <span>&#34;Donut&#34;</span> prices  
  cakePrice &lt;- <span>HashMap</span>.lookup <span>&#34;Cake&#34;</span> prices  
  <span>Just</span> $ donutPrice + cakePrice

<span>let</span> totalPrice = orderSweets prices
<span>print</span> totalPrice

</code></pre>
<p>And as expected, if one lookup fails, the whole function fails:</p>
<pre><code><span>orderSweets</span> :: <span>HashMap</span> <span>String</span> <span>Double</span> -&gt; <span>Maybe</span> <span>Double</span>
<span>orderSweets</span> prices = <span>do</span>
  donutPrice &lt;- <span>HashMap</span>.lookup <span>&#34;Donut&#34;</span> prices
  cakePrice &lt;- <span>HashMap</span>.lookup <span>&#34;Cake&#34;</span> prices
  missingPrice &lt;- <span>HashMap</span>.lookup <span>&#34;Something random&#34;</span> prices 
  <span>Just</span> $ donutPrice + cakePrice + missingPrice

<span>let</span> totalPrice = orderSweets prices
<span>print</span> totalPrice

</code></pre>
<h3 id="general-failure-philosophy"><p>General failure philosophy</p></h3>
<p>We can split errors into two categories:</p>
<ul>
<li>recoverable errors or regular errors (such as a “file not found” error);</li>
<li>unrecoverable errors or programmer mistakes (aka bugs, such as the “dividing by zero” error).</li>
</ul>
<p>As we review in the previous section, the first category can be covered by enums. It’s the errors that we either want to handle, report to the user, or retry the operation that caused them.</p>
<p>Let’s look into unrecoverable errors. Rust has a <code>panic!</code> macro that stops program execution in case of an unrecoverable error.</p>
<pre><code>
<span>fn</span> <span>optimistic_division</span>(x: <span>i32</span>, y: <span>i32</span>) <span>-&gt;</span> <span>i32</span> {
    <span>match</span> y {
        <span>0</span> =&gt; <span>panic!</span>(<span>&#34;This should never happen&#34;</span>),
        _ =&gt; x / y,
    }
}

<span>optimistic_division</span>(<span>2</span>, <span>0</span>);

</code></pre>
<p>Even though it’s possible, code like this is generally discouraged in Rust.</p>
<p>Haskell developers painstakingly try to use types to avoid the need for errors in the first place. If you get approvals from at least two other developers and CTO, you can use <code>error</code> (or <code>impureThrow</code>):</p>
<pre><code>
<span>optimisticDivision</span> :: <span>Int</span> -&gt; <span>Int</span> -&gt; <span>Int</span>
<span>optimisticDivision</span> _ <span>0</span> = error <span>&#34;This should never happen&#34;</span>
<span>optimisticDivision</span> x y = x `div` y

<span>optimisticDivision</span> <span>2</span> <span>0</span>


</code></pre>
<p>But let’s be honest: we’re all prone to think that we’re smarter than the compiler, which leads to an occasional “this should never happen” error message in the logs. Both standard libraries expose functions that can panic/error (for instance, accessing elements of the standard vector/list by index).</p>
<hr/>
<p>💡 Haskell adds another dimension to failure handling by distinguishing pure functions from potentially impure ones. We’ll cover this later in the article.</p>
<hr/>
<h2 id="polymorphism"><p>Polymorphism</p></h2>
<p>Most polymorphism falls into one of two broad categories: parametric polymorphism (same behavior for different types) and ad-hoc polymorphism (different behavior for different types).</p>
<h3 id="parametric-polymorphism"><p>Parametric polymorphism</p></h3>
<p>Rust supports two types of generic code:</p>
<ul>
<li>compile-time generics, similar to C++ templates;</li>
<li>run-time generics, similar to virtual functions in C++ and generics in Java.</li>
</ul>
<p>Using <a href="https://serokell.io/blog/rust-generics">compile-time generics</a> (which we just call generics) is similar to using types with type variables in Haskell. For example, we can write a generic function that reverses any type of vector.</p>
<pre><code>
<span>fn</span> <span>reverse</span>&lt;T&gt;(vector: &amp;<span>mut</span> <span>Vec</span>&lt;T&gt;) {
    <span>let</span> <span>mut </span><span>new_vector</span> = <span>Vec</span>::<span>new</span>();

    <span>while</span> <span>let</span> <span>Some</span>(last) = vector.<span>pop</span>() {
        new_vector.<span>push</span>(last);
    }

    *vector = new_vector;
}




</code></pre>
<hr/>
<p>💡 We can use any identifier to signify a type parameter in Rust.</p>
<p>It’s common to name generic types starting from the <code>T</code> and continuing alphabetically. Sometimes the names can be more meaningful, for example, the types of keys and values: <code>HashMap&lt;K, V&gt;</code>.</p>
<hr/>
<p>The <code>reverse</code> function iterates over the elements of a vector using the <code>while</code> loop. We get the elements in the reverse order because <code>pop</code> removes the last element from a vector and returns it. We can use this function with any vector:</p>
<pre><code><span>let</span> <span>mut </span><span>price_vector</span>: <span>Vec</span>&lt;<span>f64</span>&gt; = <span>vec!</span>[<span>1.0</span>, <span>1.2</span>, <span>2.25</span>];
<span>reverse</span>(&amp;<span>mut</span> price_vector);
<span>println!</span>(<span>&#34;{:?}&#34;</span>, price_vector);


<span>let</span> <span>mut </span><span>items_vector</span>: <span>Vec</span>&lt;&amp;<span>str</span>&gt; = <span>vec!</span>[<span>&#34;Donut&#34;</span>, <span>&#34;Cake&#34;</span>, <span>&#34;Cinnamon roll&#34;</span>];
<span>reverse</span>(&amp;<span>mut</span> items_vector);
<span>println!</span>(<span>&#34;{:?}&#34;</span>, items_vector);

</code></pre>
<p>We can write a similar function for Haskell lists. Note that the Rust function reverses the vector in place, while the Haskell function returns a new list.</p>
<pre><code>
<span>reverseList</span> :: [a] -&gt; [a]
<span>reverseList</span> = go []
 <span>where</span>
  go accumulator [] = accumulator
  go accumulator (current : rest) = go (current : accumulator) rest



</code></pre>
<p>We use the intermediate <code>go</code> function to recursively go over the original list and accumulate its elements in reverse order.</p>
<hr/>
<p>💡 Type variable names in Haskell start with a lowercase letter.</p>
<p>Conventions:</p>
<ul>
<li>Ordinary type variables with no particular meaning: <code>a</code>, <code>b</code>, <code>c</code>, etc.</li>
<li>Errors: <code>e</code>.</li>
<li>Famous typeclasses: <code>f</code> (functors, applicatives), <code>m</code> (monads), etc.</li>
</ul>
<hr/>
<p>We can use this function with any list:</p>
<pre><code><span>let</span> priceList = [<span>1.0</span>, <span>1.2</span>, <span>2.25</span>]
<span>print</span> $ reverseList priceList


<span>let</span> itemsList = [<span>&#34;Donut&#34;</span>, <span>&#34;Cake&#34;</span>, <span>&#34;Cinnamon roll&#34;</span>]
<span>print</span> $ reverseList itemsList

</code></pre>
<h3 id="ad-hoc-polymorphism"><p>Ad-hoc polymorphism</p></h3>
<p><a href="https://serokell.io/blog/rust-traits">Rust traits</a> and <a href="https://serokell.io/blog/haskell-typeclasses">Haskell typeclasses</a> are siblings – their methods can have different implementations for different types.</p>
<p>We’ve already seen (and even derived) one standard trait and typeclass: <code>Debug</code> and <code>Show</code>, which allow us to convert types to strings for debugging. Let’s derive and use another one for comparing values.</p>
<pre><code><span>#[derive(Debug, PartialEq)]</span>
<span>struct</span> <span>Item</span> {
    name: <span>String</span>,
    price: <span>f64</span>,
}

<span>let</span> <span>donut</span> = Item {
    name: <span>&#34;Donut&#34;</span>.<span>to_string</span>(),
    price: <span>1.0</span>,
};

<span>let</span> <span>cake</span> = Item {
    name: <span>&#34;Cake&#34;</span>.<span>to_string</span>(),
    price: <span>1.2</span>,
};

<span>println!</span>(<span>&#34;{}&#34;</span>, donut == cake); 


<span>println!</span>(<span>&#34;{}&#34;</span>, donut == donut); 

</code></pre>
<hr/>
<p><strong>💡<code>PartialEq</code> and <code>Eq</code>.</strong></p>
<p>We can’t derive <code>Eq</code> for <code>Item</code> in Rust because <code>Eq</code> is not implemented for <code>f64</code> (because <code>NaN != NaN</code>).</p>
<hr/>
<pre><code><span><span>data</span> <span>Item</span> = <span>Item</span></span>
  { name :: <span>String</span>
  , price :: <span>Double</span>
  }
  <span>deriving</span> (<span>Show</span>, <span>Eq</span>)

<span>let</span> donut = <span>Item</span> <span>&#34;Donut&#34;</span> <span>1.0</span>
<span>let</span> cake = <span>Item</span> <span>&#34;Cake&#34;</span> <span>1.2</span>

<span>print</span> $ donut == cake


<span>print</span> $ donut == donut

</code></pre>
<p>It shouldn’t be surprising that we can also define our own typeclasses and traits. For example, let’s create one to tax data.</p>
<pre><code><span>trait</span> <span>Taxable</span> {
    <span>fn</span> <span>tax</span>(&amp;<span>self</span>) <span>-&gt;</span> <span>f64</span>;
}


<span>impl</span> <span>Taxable</span> <span>for</span> <span>Item</span> {
    <span>fn</span> <span>tax</span>(&amp;<span>self</span>) <span>-&gt;</span> <span>f64</span> {
        <span>self</span>.price * <span>0.1</span>
    }
}

<span>println!</span>(<span>&#34;{}&#34;</span>, donut.<span>tax</span>());

</code></pre>
<p>In Rust, we <strong>implement</strong> the <code>Taxable</code> trait for the <code>Item</code> struct; in Haskell, we create an <strong>instance</strong> of the <code>Taxable</code> typeclass for the <code>Item</code> datatype.</p>
<hr/>
<p>💡 <code>tax</code> is an instance method – a trait method that requires an instance of the implementing type via the <code>&amp;self</code> argument. The <code>self</code> is an instance of the implementing type that gives us access to its internals.</p>
<hr/>
<pre><code><span><span>class</span> <span>Taxable</span> a <span>where</span></span>
  tax :: a -&gt; <span>Double</span>


<span><span>instance</span> <span>Taxable</span> <span>Item</span> <span>where</span></span>
  tax (<span>Item</span> _ price) = price * <span>0.1</span>

<span>print</span> $ tax donut

</code></pre>
<p>We can implement functions that rely on typeclasses and traits. Such as a function that returns a sum of taxes for a collection of taxable elements.</p>
<pre><code><span>fn</span> <span>tax_all</span>&lt;T: Taxable&gt;(items: <span>Vec</span>&lt;T&gt;) <span>-&gt;</span> <span>f64</span> {
    items.<span>iter</span>().<span>map</span>(|x| x.<span>tax</span>()).<span>sum</span>()
}

<span>println!</span>(<span>&#34;{}&#34;</span>, <span>tax_all</span>(<span>vec!</span>[donut, cake])); 

</code></pre>
<p>In Rust, we use trait bounds to restrict generics: <code>&lt;T: Taxable&gt;</code> declares a generic type parameter with a trait bound. In Haskell, we use (typeclass) constraints to restrict type variables; in the following snippet, it’s <code>Taxable a</code>.</p>
<pre><code><span>taxAll</span> :: <span>Taxable</span> a =&gt; [a] -&gt; <span>Double</span>
<span>taxAll</span> items = sum $ map tax items

<span>print</span> $ taxAll [donut, cake]

</code></pre>
<hr/>
<p>💡 We can use multiple constraints in both languages:</p>
<pre><code><span>fn</span> <span>tax_everything</span>&lt;T: Taxable, U: Taxable + <span>Eq</span>&gt;(items: <span>Vec</span>&lt;T&gt;, special: U) <span>-&gt;</span> <span>f64</span>
</code></pre>
<pre><code><span>taxEverything</span> :: (<span>Taxable</span> a, <span>Taxable</span> b, <span>Eq</span> b) =&gt; [a] -&gt; b -&gt; <span>Double</span>
</code></pre>
<hr/>
<p>On the surface, these mechanisms are quite similar, but there are some differences. Rust doesn’t allow orphan instances – a trait implementation must appear in the same crate (package) as either the type or trait definition. This prevents different crates from independently defining conflicting implementations (instances).</p>
<p>In Haskell, we should define instances in the same module where the type is declared or in the module where the typeclass is. Otherwise, Haskell emits a warning.</p>
<p>Also, Rust refuses to accept code with overlapping (ambiguous duplicate) instances. At the same time, Haskell allows several instances that apply to the same type – compilation fails only when we try to use an ambiguous instance.</p>
<hr/>
<p>💡 <strong>Fun fact:</strong> Haskell also has a mechanism called <a href="https://wiki.haskell.org/GHC.Generics">Generics</a>.</p>
<p>The <a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/GHC-Generics.html#t:Generic"><code>Generic</code></a> typeclass allows us to define polymorphic functions for a variety of data types based on their generic representations – we can ignore the actual datatypes and work with their “shapes” or “structure” (that consists, for example, of constructors and fields).</p>
<hr/>
<h2 id="advanced-topics"><p>Advanced topics</p></h2>
<p>We can’t go too deep on these topics because each deserves more attention, but we’ll provide basic comparisons and pointers for further learning.</p>
<h3 id="metaprogramming"><p>Metaprogramming</p></h3>
<p>The next abstraction level is compile-time metaprogramming, which helps generate boilerplate code and is represented by macros and Template Haskell.</p>
<p>Macros in Rust are built into the language. They come in two different flavors: declarative and procedural macros (which cover function-like macros, custom derives, and custom attributes). Declarative macros are the most widely used; they are referred to as “macros by example” or, more often, as plain “macros”.</p>
<p>Let’s use them to make pairs.</p>
<pre><code><span>macro_rules!</span> pair {
    ($x:expr) =&gt; {
        ($x, $x)
    };
}
</code></pre>
<p>The syntax for calling macros looks almost the same as for calling functions.</p>
<hr/>
<p>💡 We’ve been using the <code>println!</code> macro throughout the article.</p>
<hr/>
<pre><code><span>let</span> <span>pair_ints</span>: (<span>i32</span>, <span>i32</span>) = pair!(<span>1</span>);
<span>println!</span>(<span>&#34;{:?}&#34;</span>, pair_ints);


<span>let</span> <span>pair_strs</span>: (&amp;<span>str</span>, &amp;<span>str</span>) = pair!(<span>&#34;two&#34;</span>);
<span>println!</span>(<span>&#34;{:?}&#34;</span>, pair_strs);

</code></pre>
<p>Template Haskell, also known as TH, is a language extension; the <a href="https://hackage.haskell.org/package/template-haskell"><code>template-haskell</code></a> package exposes a set of functions and datatypes for it.</p>
<p>Let’s use it to make pairs.</p>
<pre><code><span>import</span> Language.Haskell.TH

<span>pair</span> :: <span>ExpQ</span>
<span>pair</span> = [e|\x -&gt; (x, x)|]
</code></pre>
<p>We have to define it in another module because top-level splices, quasi-quotes, and annotations must be imported, not defined locally. To use Template Haskell, we have to enable the <a href="https://downloads.haskell.org/~ghc/9.2.1/docs/html/users_guide/exts/template_haskell.html#extension-TemplateHaskell"><code>TemplateHaskell</code></a> extension.</p>
<pre><code><span>{-# LANGUAGE TemplateHaskell #-}</span>

<span>let</span> pairInts :: (<span>Int</span>, <span>Int</span>) = $pair <span>1</span>
<span>print</span> pairInts


<span>let</span> pairStrs :: (<span>String</span>, <span>String</span>) = $pair <span>&#34;two&#34;</span>
<span>print</span> pairStrs

</code></pre>
<p>Template Haskell doesn’t have a spotless reputation: it introduces extra syntax, increases complexity, and in the past, considerably affected compilation speed (it’s way better these days). Some people prefer to use alternative methods of reducing boilerplate, such as <a href="https://wiki.haskell.org/GHC.Generics">Generics</a> (<a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/GHC-Generics.html#t:Generic"><code>Generic</code></a> typeclass).</p>
<hr/>
<p>💡 Later versions of GHC support <a href="https://serokell.io/blog/typed-template-haskell-overview">typed Template Haskell</a>, which type-checks the expressions at their definition site rather than at their usage (like regular TH).</p>
<hr/>
<h3 id="runtime-and-concurrency"><p>Runtime and concurrency</p></h3>
<p>Rust has no built-in runtime (scheduler). The standard library allows using OS threads directly through <a href="https://doc.rust-lang.org/std/thread/"><code>std::thread</code></a>. For example, we can spawn a thread:</p>
<pre><code><span>use</span> std::thread;
<span>use</span> std::time::Duration;

thread::<span>spawn</span>(|| {
    thread::<span>sleep</span>(Duration::<span>from_secs</span>(<span>1</span>));
    <span>println!</span>(<span>&#34;Hello from the spawned thread!&#34;</span>);
});
<span>println!</span>(“Spawned a thread”);

thread::<span>sleep</span>(Duration::<span>from_secs</span>(<span>2</span>));
<span>println!</span>(<span>&#34;Hello from the main thread!&#34;</span>);
</code></pre>
<p>The Rust language defines <code>async/await</code> but no concrete execution strategy.</p>
<pre><code><span>#[derive(Debug)]</span>
<span>struct</span> <span>Donut</span>;

<span>async</span> <span>fn</span> <span>order_donut</span>() <span>-&gt;</span> Donut {
    <span>println!</span>(<span>&#34;Ordering a donut&#34;</span>);
    Donut
}

<span>async</span> <span>fn</span> <span>eat</span>(donut: Donut) {
    <span>println!</span>(<span>&#34;Eating a donut {:?}&#34;</span>, donut)
}

<span>async</span> <span>fn</span> <span>order_and_consume</span>() {
    
    
    <span>let</span> <span>donut</span> = <span>order_donut</span>().<span>await</span>;
    <span>eat</span>(donut).<span>await</span>;
}


<span>use</span> futures::executor::block_on;
<span>block_on</span>(<span>order_and_consume</span>());
</code></pre>
<p>We use the standard <a href="https://docs.rs/futures/"><code>futures</code></a>, which has its own executor but is not a full runtime. To get an asynchronous runtime in Rust, we have to use external libraries, such as <a href="https://tokio.rs/"><code>Tokio</code></a> and <a href="https://async.rs/"><code>async-std</code></a>.</p>
<p>Here is a snippet of code that uses <code>Tokio</code> to do some concurrent work using three different services and then either collect the successful result or return a timeout error (all the other errors are ignored for simplicity):</p>
<pre><code><span>use</span> tokio::time::timeout;




<span>async</span> <span>fn</span> <span>concurrent_program</span>(work: &amp;Work) <span>-&gt;</span> <span>Result</span> {
    <span>timeout</span>(Duration::<span>from_secs</span>(<span>2</span>), <span>async</span> {
        tokio::join!(
            <span>do_work</span>(work, &amp;Service::ServiceA),
            <span>do_work</span>(work, &amp;Service::ServiceB),
            <span>do_work</span>(work, &amp;Service::ServiceC)
        )
    })
    .<span>await</span>
    .<span>map</span>(|(a, b, c)| <span>Result</span>::<span>Success</span>(<span>vec!</span>[a, b, c]))
    .<span>unwrap_or_else</span>(|_| <span>Result</span>::Timeout)
}


<span>concurrent_program</span>(&amp;some_work).<span>await</span>;
</code></pre>
<p><em>Note that this will run all the work concurrently on the same task. If we want to do the job simultaneously or in parallel, we need to call <code>tokio::spawn</code> for each of the tasks to spawn and run it.</em></p>
<hr/>
<p>💡 Rust doesn’t oblige you to stick to one type of concurrency model (such as threads, async, etc.). You can use any if you find a suitable crate (library).</p>
<hr/>
<p>Haskell has green threads – the runtime system manages threads (instead of directly using native OS threads). The essential operation is forking a thread with <code>forkIO</code>:</p>
<pre><code><span>import</span> Control.Concurrent (<span>threadDelay</span>, <span>forkIO</span>)

<span>forkIO</span> $ <span>do</span>
  threadDelay $ <span>1000</span> * <span>1000</span>
  print <span>&#34;Hello from the spawned thread!&#34;</span>

<span>print</span> <span>&#34;Spawned a thread&#34;</span>

<span>threadDelay</span> $ <span>2</span> * <span>1000</span> * <span>1000</span>
<span>print</span> <span>&#34;Hello from the main thread!&#34;</span>
</code></pre>
<p>Various libraries in Haskell take advantage of green threads to provide powerful and composable APIs. For example, the <a href="https://hackage.haskell.org/package/async"><code>async</code></a> package (library). The following snippet uses <code>async</code> to do concurrent work with three services and then assembles the result.</p>
<pre><code><span>import</span> Control.Concurrent (<span>threadDelay</span>)
<span>import</span> Control.Concurrent.Async (<span>mapConcurrently</span>)
<span>import</span> System.Timeout (<span>timeout</span>)




<span>concurrentProgram</span> :: <span>Work</span> -&gt; <span>IO</span> <span>Result</span>
<span>concurrentProgram</span> work = <span>do</span>
  results &lt;-
    timeout twoSeconds $
      mapConcurrently (doWork work) [<span>ServiceA</span>, <span>ServiceB</span>, <span>ServiceC</span>]
  pure $ <span>case</span> results <span>of</span>
    <span>Just</span> success -&gt; <span>Success</span> success
    <span>Nothing</span> -&gt; <span>Timeout</span>
 <span>where</span>
  twoSeconds = <span>1000</span> * <span>1000</span>


<span>concurrentProgram</span> someWork
</code></pre>
<p>And we have to mention the <a href="https://hackage.haskell.org/package/stm">Software Transactional Memory (STM)</a> abstraction in Haskell, which allows us to group multiple state-changing operations and perform them as a single atomic operation.</p>
<p>Imagine the situation: I have $0 and want to buy a donut for $3; also, I earn $1 per second. I can keep trying to buy a donut until I have sufficient funds. We have a typical money transfer transaction, which needs to be retried and can be simulated using STM. We don’t need to worry about transaction rollbacks or retries – STM handles all of these for us.</p>
<pre><code><span>runSimulation</span> :: <span>IO</span> ()
<span>runSimulation</span> = <span>do</span>
  
  wallet &lt;- newTVarIO <span>0</span>
  cashRegister &lt;- newTVarIO <span>100</span>

  
  _ &lt;- forkIO $ getPaid wallet

  
  atomically $ <span>do</span>
    myCash &lt;- readTVar wallet
    
    check $ myCash &gt;= donutPrice
    
    writeTVar wallet (myCash - donutPrice)
    storeCash &lt;- readTVar cashRegister
    
    writeTVar cashRegister (storeCash + donutPrice)

  myFinal &lt;- readTVarIO wallet
  print $ <span>&#34;I have: $&#34;</span> ++ show myFinal

  storeFinal &lt;- readTVarIO cashRegister
  print $ <span>&#34;Cash register: $&#34;</span> ++ show storeFinal
<span>where</span>
  donutPrice = <span>3</span>


<span>getPaid</span> :: <span>TVar</span> <span>Int</span> -&gt; <span>IO</span> ()
<span>getPaid</span> wallet = forever $ <span>do</span>
  threadDelay $ <span>1000</span> * <span>1000</span>
  atomically $ modifyTVar wallet (+ <span>1</span>)
  print <span>&#34;I earned a dollar&#34;</span>
</code></pre>
<hr/>
<p>💡 <a href="https://hackage.haskell.org/package/stm-2.5.1.0/docs/Control-Concurrent-STM-TVar.html"><code>TVar</code></a> stands for transactional variable, which we can read or write to within STM, using operations such as <a href="https://hackage.haskell.org/package/stm-2.5.1.0/docs/Control-Concurrent-STM-TVar.html#v:readTVar"><code>readTVar</code></a> and <a href="https://hackage.haskell.org/package/stm-2.5.1.0/docs/Control-Concurrent-STM-TVar.html#v:writeTVar"><code>writeTVar</code></a>. We can perform a computation in the STM using the <a href="https://hackage.haskell.org/package/stm-2.5.1.0/docs/Control-Monad-STM.html#v:atomically"><code>atomically</code></a> function.</p>
<hr/>
<p>When we run the program, we see that I must be paid at least three times before the transaction succeeds:</p>
<pre><code><span>runSimulation</span>






</code></pre>
<h2 id="functions-and-functional-programming"><p>Functions and functional programming</p></h2>
<p>Functions are widespread in both languages. Haskell and Rust support higher-order functions. Haskell is always functional, and functional Rust is frequently just proper, idiomatic Rust.</p>
<h3 id="lambdas-and-closures"><p>Lambdas and closures</p></h3>
<p>A lambda is an anonymous function that can be treated like a value. We can use lambdas as arguments for higher-order functions.</p>
<p>In Rust:</p>
<pre><code><span>let</span> <span>bump</span> = |i: <span>f64</span>| i + <span>1.0</span>;
<span>println!</span>(<span>&#34;{}&#34;</span>, <span>bump</span>(<span>1.2</span>));


<span>let</span> <span>bump_inferred</span> = |i| i + <span>1.0</span>;
<span>println!</span>(<span>&#34;{}&#34;</span>, <span>bump_inferred</span>(<span>1.2</span>));

</code></pre>
<p>In Haskell:</p>
<pre><code><span>let</span> bump = \(i :: <span>Double</span>) -&gt; i + <span>1.0</span>
<span>print</span> $ bump <span>1.2</span>


<span>let</span> bumpInferred = \i -&gt; i + <span>1.0</span>
<span>print</span> $ bumpInferred <span>1.2</span>

</code></pre>
<hr/>
<p>💡 Note that annotating a type variable might require the <a href="https://downloads.haskell.org/ghc/latest/docs/users_guide/exts/scoped_type_variables.html#extension-ScopedTypeVariables"><code>ScopedTypeVariables</code></a> extension, depending on your usage. But also, writing lambdas like that can be redundant in Haskell. We could have written a normal function:</p>
<pre><code><span>let</span> bump :: <span>Double</span> -&gt; <span>Double</span>
    bump i = i + <span>1.0</span>
</code></pre>
<hr/>
<p>We can use closures to capture values from the scope/environment in which they’re defined. For example, we can define a simple closure that captures the <code>outside</code> variable:</p>
<pre><code>|x| x + outside
</code></pre>
<pre><code>\x -&gt; x + outside
</code></pre>
<p>In Rust, each value has a lifetime. Because closures capture environment values, we have to deal with their ownership and lifetimes. For example, let’s write a function that returns a greeting function:</p>
<pre><code><span>fn</span> <span>create_greeting</span>() <span>-&gt;</span> <span>impl</span> <span>Fn</span>(&amp;<span>str</span>) <span>-&gt;</span> <span>String</span> {
    <span>let</span> <span>greet</span> = <span>&#34;Hello,&#34;</span>;
    <span>move</span> |name: &amp;<span>str</span>| <span>format!</span>(<span>&#34;{greet} {name}!&#34;</span>)
}

<span>let</span> <span>greeting_function</span> = <span>create_greeting</span>();

<span>println!</span>(<span>&#34;{}&#34;</span>, <span>greeting_function</span>(<span>&#34;Rust&#34;</span>));

</code></pre>
<p>We use <code>move</code> to force the closure to take ownership of the <code>greet</code> variable.</p>
<hr/>
<p>💡 If we forget to use <code>move</code>, we get an error.</p>
<pre><code>
</code></pre>
<pre><code>error[E0373]: closure may outlive the current function, but it borrows `greet`, which is owned by the current function
   |
   |         |name: &amp;str| format!(&#34;{greet} {name}!&#34;)
   |         ^^^^^^^^^^^^           ----- `greet` is borrowed here
   |         |
   |         may outlive borrowed value `greet`
   |
note: closure is returned here
   |
   |         |name: &amp;str| format!(&#34;{greet} {name}!&#34;)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: to force the closure to take ownership of `greet` (and any other referenced variables), use the `move` keyword
   |
   |         move |name: &amp;str| format!(&#34;{greet} {name}!&#34;)
   |         ++++
</code></pre>
<hr/>
<p><strong>💡 What is <code>Fn</code>?</strong></p>
<p>How a closure captures and handles values from the environment determines which traits (one, two, or all three) it implements and how the closure can be used. There are three traits:</p>
<ul>
<li><a href="https://doc.rust-lang.org/stable/std/ops/trait.FnOnce.html"><code>FnOnce</code></a> (can be called once);</li>
<li><a href="https://doc.rust-lang.org/stable/std/ops/trait.FnMut.html"><code>FnMut</code></a> (can be called more than once, may mutate state);</li>
<li><a href="https://doc.rust-lang.org/stable/std/ops/trait.Fn.html"><code>Fn</code></a> (can be called more than once, no state mutation).</li>
</ul>
<hr/>
<p>In Haskell, we don’t worry much about closures.</p>
<h3 id="currying-and-partial-application"><p>Currying and partial application</p></h3>
<p>Currying is converting a function that takes multiple arguments into a function that takes them one at a time. Each time we call a function, we pass it one argument, and it returns another function that also takes one argument until all arguments are passed.</p>
<p>In Haskell, all functions are considered curried, which might not be obvious because it’s hidden in the syntax: <code>Double -&gt; Double -&gt; Double</code> is actually <code>Double -&gt; (Double -&gt; Double)</code> and <code>add x y</code> is actually <code>(add x) y</code>.</p>
<pre><code><span>add</span> :: <span>Double</span> -&gt; <span>Double</span> -&gt; <span>Double</span>
<span>add</span> x y = x + y

<span>bump</span> :: <span>Double</span> -&gt; <span>Double</span> 
<span>bump</span> = add <span>1.0</span>

<span>full</span> :: <span>Double</span> 
<span>full</span> = add <span>1.0</span> <span>1.2</span>
</code></pre>
<p>When we pass <code>1.0</code> to <code>add</code>, we get another function, <code>bump</code>, which takes a double, adds 1 to it, and returns that sum as a result.</p>
<pre><code><span>add</span> x y = x + y
<span>bump</span> = add <span>1.0</span>

<span>print</span> $ bump <span>1.2</span>

</code></pre>
<p><code>bump</code> is the result of partial application, which means we pass less than the total number of arguments to a function that takes multiple arguments.</p>
<p>We can do this in Rust, but it’s not idiomatic.</p>
<pre><code><span>fn</span> <span>add</span>(x: <span>f64</span>) <span>-&gt;</span> <span>impl</span> <span>Fn</span>(<span>f64</span>) <span>-&gt;</span> <span>f64</span> {
    <span>move</span> |y| x + y
}

<span>let</span> <span>bump</span> = <span>add</span>(<span>1.0</span>);

<span>println!</span>(<span>&#34;{}&#34;</span>, <span>bump</span>(<span>1.2</span>)); 

</code></pre>
<p>There are crates that make it easier like <a href="https://crates.io/crates/partial_application">partial_application</a>:</p>
<pre><code><span>use</span> partial_application::partial;

<span>fn</span> <span>add</span>(x: <span>f64</span>, y: <span>f64</span>) <span>-&gt;</span> <span>f64</span> {
    x + y
}

<span>let</span> <span>bump2</span> = partial!(add =&gt; <span>1.0</span>, _);

<span>println!</span>(<span>&#34;{}&#34;</span>, <span>bump</span>(<span>1.2</span>)); 

</code></pre>
<p>Currying and partial application are convenient when we pass functions around as values and allows us to use neat features, such as composition.</p>
<h3 id="function-composition"><p>Function composition</p></h3>
<p>In Haskell, we can use function composition, which pipes the result of one function to the input of another, creating an entirely new function.</p>
<hr/>
<p>💡 We use the dot operator (<code>.</code>) to implement function composition in Haskell.</p>
<hr/>
<p>For example, we can compose three functions to get a maximum price from the list and negate it.</p>
<pre><code><span>import</span> <span>qualified</span> Data.HashMap.Strict <span>as</span> HashMap





<span>negativeMaxPrice</span> :: <span>HashMap</span> <span>String</span> <span>Double</span> -&gt; <span>Double</span>
<span>negativeMaxPrice</span> = negate . maximum . <span>HashMap</span>.elems

<span>let</span> prices = <span>HashMap</span>.fromList [(<span>&#34;Donut&#34;</span>, <span>1.0</span>), (<span>&#34;Cake&#34;</span>, <span>1.2</span>)]
<span>print</span> $ negativeMaxPrice prices 

</code></pre>
<p>We can technically do it in Rust, but it’s not commonly used and not part of the standard library.</p>
<h3 id="iterators"><p>Iterators</p></h3>
<p>In Rust, the iterator pattern allows us to traverse collections. Iterators are responsible for the logic of iterating over each item and determining when the sequence has finished.</p>
<p>For example, let’s use iterators to get the total price of all the products except for donuts:</p>
<pre><code><span>use</span> std::collections::HashMap;

<span>let</span> <span>prices</span> = 
  HashMap::<span>from</span>([(<span>&#34;Donut&#34;</span>, <span>1.0</span>), (<span>&#34;Cake&#34;</span>, <span>1.2</span>), (<span>&#34;Cinnamon roll&#34;</span>, <span>2.25</span>)]);

<span>let</span> <span>total</span>: <span>f64</span> = prices
    .<span>into_iter</span>()
    .<span>filter</span>(|&amp;(name, _)| name != <span>&#34;Donut&#34;</span>)
    .<span>map</span>(|(_, price)| price)
    .<span>sum</span>();

<span>println!</span>(<span>&#34;{}&#34;</span>, total); 

</code></pre>
<p>Iterators are lazy — they don’t do anything unless they are consumed. We can also use <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect"><code>collect</code></a> to transform an iterator into another collection. For example, we can return the prices instead:</p>
<pre><code><span>use</span> std::collections::HashMap;

<span>let</span> <span>prices</span> = 
  HashMap::<span>from</span>([(<span>&#34;Donut&#34;</span>, <span>1.0</span>), (<span>&#34;Cake&#34;</span>, <span>1.2</span>), (<span>&#34;Cinnamon roll&#34;</span>, <span>2.25</span>)]);

<span>let</span> <span>other_prices</span>: <span>Vec</span>&lt;<span>f64</span>&gt; = prices
    .<span>into_iter</span>()
    .<span>filter</span>(|&amp;(name, _)| name != <span>&#34;Donut&#34;</span>)
    .<span>map</span>(|(_, price)| price)
    .<span>collect</span>();

<span>println!</span>(<span>&#34;{:?}&#34;</span>, other_prices);

</code></pre>
<p>In Haskell, we work with collections directly.</p>
<pre><code><span>import</span> <span>qualified</span> Data.HashMap.Strict <span>as</span> HashMap

<span>let</span> prices = 
      <span>HashMap</span>.fromList [(<span>&#34;Donut&#34;</span>, <span>1.0</span>), (<span>&#34;Cake&#34;</span>, <span>1.2</span>), (<span>&#34;Cinnamon roll&#34;</span>, <span>2.25</span>)]

<span>let</span> total =
	    sum
	      $ <span>HashMap</span>.elems
	      $ <span>HashMap</span>.filterWithKey (\name _ -&gt; name /= <span>&#34;Donut&#34;</span>)
	      $ prices

<span>print</span> total 

</code></pre>
<pre><code><span>import</span> <span>qualified</span> Data.HashMap.Strict <span>as</span> HashMap

<span>let</span> prices = 
      <span>HashMap</span>.fromList [(<span>&#34;Donut&#34;</span>, <span>1.0</span>), (<span>&#34;Cake&#34;</span>, <span>1.2</span>), (<span>&#34;Cinnamon roll&#34;</span>, <span>2.25</span>)]

<span>let</span> otherPrices =
      <span>HashMap</span>.elems $
        <span>HashMap</span>.filterWithKey (\name _ -&gt; name /= <span>&#34;Donut&#34;</span>) prices

<span>print</span> otherPrices 

</code></pre>
<h3 id="associated-functions-and-methods"><p>Associated functions and methods</p></h3>
<p>In Rust, we can connect functions to particular types — via associated functions or methods. Associated functions are called on the type, and methods are called on a particular instance of a type.</p>
<pre><code><span>struct</span> <span>Item</span> {
    name: <span>String</span>,
    price: <span>f64</span>,
}

<span>impl</span> <span>Item</span> {
    <span>fn</span> <span>free</span>(name: <span>String</span>) <span>-&gt;</span> Item {
        Item { name, price: <span>0.0</span> }
    }

    <span>fn</span> <span>print_receipt</span>(&amp;<span>self</span>) {
        <span>println!</span>(<span>&#34;{}: ${}&#34;</span>, <span>self</span>.name, <span>self</span>.price);
    }
}


<span>let</span> <span>free_donut</span> = Item::<span>free</span>(<span>&#34;Regular donut&#34;</span>.<span>to_string</span>());


free_donut.<span>print_receipt</span>(); 

</code></pre>
<p>In Haskell, we can’t and don’t.</p>
<h2 id="things-we-worry-about-in-rust"><p>Things we worry about in Rust</p></h2>
<p>Speaking of the things we don’t do in Haskell. It shouldn’t be a surprise that the feature that sets Rust apart is its ownership model and the borrow checker.</p>
<p>Remember how we used <code>move</code> to force the closure to take ownership of the variable?</p>
<pre><code><span>fn</span> <span>create_greeting</span>() <span>-&gt;</span> <span>impl</span> <span>Fn</span>(&amp;<span>str</span>) <span>-&gt;</span> <span>String</span> {
    <span>let</span> <span>greet</span> = <span>&#34;Hello,&#34;</span>;
    <span>move</span> |name: &amp;<span>str</span>| <span>format!</span>(<span>&#34;{greet} {name}!&#34;</span>)
}
</code></pre>
<p>Rust is a statically memory-managed language, which requires us to think about the lifetimes of values.</p>
<hr/>
<p>💡 If you want to learn more about this topic, check out the <a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html#understanding-ownership">Understanding Ownership</a> chapter of the Rust book.</p>
<hr/>
<p>And in Haskell? In Haskell, we have space leaks (but we usually don’t worry about those). 😉</p>
<h2 id="things-we-worry-about-in-haskell"><p>Things we worry about in Haskell</p></h2>
<h3 id="laziness"><p>Laziness</p></h3>
<p>Haskell programs are executed using lazy evaluation, which doesn’t perform a computation until its result is required and avoids unnecessary computation.</p>
<p>Laziness encourages programming in a modular style without worrying about intermediate data and allows working with infinite structures. Let’s illustrate this by writing a function that returns the first prime number larger than <code>10 000</code>. We can start with an infinite list of naturals, filter the prime numbers, and take the first prime after <code>10 000</code>.</p>
<pre><code><span>naturals</span> :: [<span>Int</span>]
<span>naturals</span> = [<span>1</span> ..]


<span>isPrime</span> :: <span>Int</span> -&gt; <span>Bool</span>
<span>isPrime</span> n = null [number | number &lt;- [<span>2</span> .. n - <span>1</span>], n `mod` number == <span>0</span>]

<span>print</span> $ take <span>1</span> $ filter (&gt; <span>10000</span>) $ filter isPrime naturals

</code></pre>
<p>Because of laziness, the work stops right after it finds the correct prime number – no need to calculate the rest of the list or the rest of the primes.</p>
<p>This computation takes <code>~40MB</code> of memory <em>(YMMV)</em>, primarily the runtime overhead. If we increase the number to <code>100 000</code>, the memory usage stays the same.</p>
<p>All good so far. What if we try something else? Let’s take <code>1 000 000</code> naturals and return their sum along with the length of the list.</p>
<pre><code><span>let</span> nums = take <span>10000000</span> naturals
<span>print</span> $ (sum nums, length nums)

</code></pre>
<p>This computation takes <code>~129MB</code> of memory <em>(YMMV)</em>. And if we take <code>10 000 000</code> – the memory usage goes up to <code>~1.376GB</code>. Oops.</p>
<hr/>
<p><strong>💡 Why does it happen?</strong></p>
<p>Because the <code>nums</code> list is used for both <code>sum</code> and <code>length</code> computations, the compiler can’t discard list elements until it evaluates both.</p>
<p>Note that <code>sum $ take 10000000 naturals</code> runs in constant memory.</p>
<hr/>
<p>💡 If you want to learn more, check out <a href="https://www.youtube.com/watch?v=DSy7bscJL7k">our videos on laziness</a>.</p>
<hr/>
<p>So, it’s favorable to be mindful of how expressions are evaluated when working with data in Haskell to avoid space leaks.</p>
<h3 id="purity"><p>Purity</p></h3>
<p>Haskell is pure – invoking a function with the same arguments always returns the same result.</p>
<p>As a consequence, in Haskell, there is no distinction between a zero-argument function and a constant.</p>
<pre><code><span>f</span>(x, y) 
<span>f</span>(x)    
<span>f</span>()     
C       
</code></pre>
<pre><code><span>f</span> x y 
<span>f</span> x   
<span>F</span>     
<span>c</span>     -– zero argument / constant
</code></pre>
<hr/>
<p>💡 Pure functions do not have side effects.</p>
<hr/>
<p>Purity, together with laziness, raises some challenges. Without digging too deep into the rabbit hole, let’s look at an example pseudo-Haskell code. The following impure example reads 2 integers from the standard input and returns them as a list (pay attention to the order):</p>
<pre><code>


<span>pseudoComputation</span> =
  <span>let</span> first = readNumber
  <span>let</span> second = readNumber
  print [second, first]
</code></pre>
<p>As we’ve learned, because of laziness, Haskell doesn’t evaluate an expression until it is needed: evaluation of <code>first</code> and <code>second</code> is postponed until they are used, and when it starts forcing the list, it starts with reading the <code>second</code> number and then <code>first</code>. Which is the opposite of what we want and expect.</p>
<p>To deal with this mess, Haskell has <code>IO</code> – a special datatype that offers better control over its execution. <code>IO</code> is a description of a computation. When executed, it can perform arbitrary effects before returning a value of type <code>a</code>.</p>
<hr/>
<p>💡 Executing <code>IO</code> is not the same as evaluating it. Evaluating an <code>IO</code> expression is pure – it returns the same description. For example, <code>io1</code> and <code>io2</code> are guaranteed to be the same:</p>
<pre><code>


<span>let</span> variable = doSomeAction <span>&#34;parameter&#34;</span>
<span>let</span> io1 = (var, var)
</code></pre>
<pre><code><span>let</span> io2 = (doSomeAction <span>&#34;parameter&#34;</span>, doSomeAction <span>&#34;parameter&#34;</span>)
</code></pre>
<hr/>
<p>We’ve been using the <code>print</code> function to print things out; here is its type signature:</p>
<pre><code><span>print</span> :: <span>Show</span> a =&gt; a -&gt; <span>IO</span> ()
</code></pre>
<p>We can’t print outside of <code>IO</code>. We get a compilation error if we try otherwise:</p>
<pre><code><span>noGreet</span> :: <span>String</span> -&gt; <span>String</span>
<span>noGreet</span> name = print $ <span>&#34;Hello, &#34;</span> &lt;&gt; name



</code></pre>
<p>Okay, we have an <code>IO</code> function. How do we run it? We need to define the program’s <code>main</code> <code>IO</code> function – the program entry point – which the Haskell runtime will execute. Let’s look at the executable module example: it asks the user for the name, reads it, and prints the greeting.</p>
<pre><code><span>module</span> Main <span>where</span> 

<span>greet</span> :: <span>String</span> -&gt; <span>IO</span> ()
<span>greet</span> name = print $ <span>&#34;Hello, &#34;</span> &lt;&gt; name

<span>main</span> :: <span>IO</span> ()
<span>main</span> = <span>do</span>
  print <span>&#34;What&#39;s your name?&#34;</span>
  name &lt;- getLine
  greet name
</code></pre>
<hr/>
<p>💡 Remember the do-notation syntax that we used with <code>Maybe</code> and <code>Either</code>? We can use it with <code>IO</code> as well! It’s convenient to put actions together.</p>
<hr/>
<p>This differs from all the languages in which we can perform side effects anywhere and anytime.</p>
<p>For completeness, this is how a main module looks like in Rust:</p>
<pre><code><span>fn</span> <span>main</span>() {
    <span>let</span> <span>two</span> = <span>one</span>() + <span>one</span>();
    <span>println!</span>(<span>&#34;Hello from main and {}&#34;</span>, two);
}

<span>fn</span> <span>one</span>() <span>-&gt;</span> <span>i32</span> {
    <span>println!</span>(<span>&#34;Hello from one&#34;</span>);
    <span>1</span>
}
</code></pre>
<p>Note that we can execute arbitrary side effects.</p>
<h3 id="higher-order-programming"><p>Higher-order programming</p></h3>
<p>In Haskell, we prefer general solutions for common patterns. For example, do-notation is syntactic sugar for the bind operator (<code>&gt;&gt;=</code>), which is overloaded for a bunch of types: <code>Maybe</code>, <code>Either e</code>, <code>[]</code>, <code>State</code>, <code>IO</code>, etc.</p>
<pre><code><span>do</span>
  x &lt;- action1
  y &lt;- action2
  f x y
</code></pre>
<pre><code>
<span>action1</span> &gt;&gt;= \x -&gt;
  action2 &gt;&gt;= \y -&gt;
    f x y
</code></pre>
<p>As a result, we can use the notation to express many problems and deal with many use cases: optionality, non-determinism, error handling, state mutation, concurrency, etc.</p>
<pre><code>
<span>maybeSweets</span> :: <span>HashMap</span> <span>String</span> <span>Double</span> -&gt; <span>Maybe</span> <span>Double</span>
<span>maybeSweets</span> prices = <span>do</span>
  donutPrice &lt;- <span>HashMap</span>.lookup <span>&#34;Donut&#34;</span> prices
  cakePrice &lt;- <span>HashMap</span>.lookup <span>&#34;Cake&#34;</span> prices
  <span>Just</span> $ donutPrice + cakePrice


<span>ioSweets</span> :: <span>Statistics</span> -&gt; <span>SweetsService</span> -&gt; <span>IO</span> <span>Double</span>
<span>ioSweets</span> statistics sweets = <span>do</span>
  print <span>&#34;Fetching sweets from external service&#34;</span>
  prices &lt;- fetchPrices sweets
  updateCounters statistics prices
  pure prices
</code></pre>
<p>This is one of the design patterns for structuring code in Haskell. We implement them using typeclasses, and they are supported by laws (a whole different topic). When Haskell developers see that the library provides a datatype or an interface related to one of these typeclasses, they have some expectations and guarantees about its behavior.</p>
<hr/>
<p>💡 Top 7 useful typeclasses everyone should know about:</p>
<p><code>Semigroup</code>, <code>Monoid</code>, <code>Functor</code>, <code>Applicative</code>, <code>Monad</code>, <code>Foldable</code>, and <code>Traversable</code>.</p>
<hr/>
<p>Higher-kinded types are the basis for these typeclasses. A higher-kinded type is a type that abstracts over some polymorphic type. Take, for instance, <code>f</code> in the following <code>Functor</code> definition:</p>
<pre><code><span><span>class</span> <span>Functor</span> f <span>where</span></span>
  fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p><code>f</code> can be <code>Option</code>, <code>[]</code>, <code>IO</code>, etc.; while <code>f a</code> can be <code>Option Int</code>, <code>[String]</code>, <code>IO Bool</code>, etc.</p>
<p>You can check out <a href="https://serokell.io/blog/kinds-and-hkts-in-haskell">Kinds and Higher-Kinded Types</a> for a more detailed explanation.</p>
<hr/>
<p>Rust doesn’t support higher-kinded types (yet), and it’s more complex to implement concepts such as monads and their friends. Instead, Rust provides alternative approaches to solve the problems that these typeclasses solve in Haskell:</p>
<ul>
<li>If you want to deal with optionality or error handling, you can use <code>Option</code>/<code>Result</code> with the <code>?</code> operator.</li>
<li>If you want to deal with async code – <code>async</code>/<code>.await</code>.</li>
<li>etc.</li>
</ul>
<h2 id="conclusion"><p>Conclusion</p></h2>
<p>Turns out Rust and Haskell have a lot in common: both languages have a lot of features and can be frustrating to learn. Luckily they share a lot of concepts, and knowledge of one language can be helpful while pursuing another.</p>
<p>And please remember that in both cases, the compiler has your back, so don’t forget that compilers are your friends. 😉</p>
<p>For more articles on Haskell and Rust, follow us on <a href="https://twitter.com/serokell">Twitter</a> or subscribe to the newsletter via the form below.</p></div></div>
  </body>
</html>
