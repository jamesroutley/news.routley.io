<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nuxx.net/blog/2025/10/14/wireshark-4-6-0-supports-macos-pktap-metadata-pid-process-name-etc/">Original</a>
    <h1>Wireshark 4.6.0 Supports macOS Pktap Metadata (PID, Process Name, etc.)</h1>
    
    <div id="readability-page-1" class="page"><div>
								<div>
<figure><a href="https://nuxx.net/blog/wp-content/uploads/2025/10/image.png"><img fetchpriority="high" decoding="async" width="1024" height="502" src="https://nuxx.net/blog/wp-content/uploads/2025/10/image-1024x502.png" alt="" srcset="https://nuxx.net/blog/wp-content/uploads/2025/10/image-1024x502.png 1024w, https://nuxx.net/blog/wp-content/uploads/2025/10/image-300x147.png 300w, https://nuxx.net/blog/wp-content/uploads/2025/10/image-768x377.png 768w, https://nuxx.net/blog/wp-content/uploads/2025/10/image-1536x754.png 1536w, https://nuxx.net/blog/wp-content/uploads/2025/10/image-2048x1005.png 2048w" sizes="(max-width: 1024px) 100vw, 1024px"/></a></figure></div>


<p>Four years after my post on doing <a href="https://nuxx.net/blog/2021/10/29/network-capture-with-process-name-and-pid-on-macos/" data-type="post" data-id="19460">network captures on macOS with Process ID</a>, <a href="https://www.wireshark.org/docs/relnotes/wireshark-4.6.0.html">Wireshark 4.6.0 has been released</a> which includes support for parsing this extra metadata, including the process info.</p>



<p>So how do you do it? Easy! You just need the <code>pktap</code> interface parameter.</p>



<p>From the <a href="https://manp.gs/mac/1/tcpdump">tcpdump(1) man page</a>:</p>



<blockquote>
<p>Alternatively, to capture on more than one interface at a time, one may use “pktap” as the <em>interface</em> parameter followed by an optional list of comma separated interface names to include. For example, to capture on the loopback and en0 interface:</p>



<pre>tcpdump -i pktap,lo0,en0</pre>



<p>An <em>interface</em> argument of “all” or “pktap,all” can be used to capture packets from all interfaces, including loopback and tunnel interfaces. A pktap pseudo interface provides for packet metadata using the default PKTAP data link type and files are written in the Pcap-ng file format. The RAW data link type must be used to force to use the legacy <strong>pcap-savefile</strong>(5) file format with a ptkap pseudo interface. Note that captures on a ptkap pseudo interface will not be done in promiscuous mode.</p>
</blockquote>



<p>Therefore, we just need something like:</p>



<pre><code>tcpdump -i pktap,en0 -w outfile.pcapng</code></pre>



<p>or</p>



<pre><code>tcptump -i pktap,all host 192.168.0.6 -w outfile.pcapng</code></pre>



<p>And then open <code>outfile.pcapng</code> in <em>Wireshark </em>and under <em>Frame </em>→ <em>Process Information</em> you can find the process name, PID, etc. (See screenshot above.)</p>



<p>Filtering can be done with <code>frame.darwin.process_info</code> as listed <a href="https://www.wireshark.org/docs/dfref/f/frame.html">here</a>. For example:</p>



<pre><code>frame.darwin.process_info.pname == &#34;firefox&#34;</code></pre>



<p>or</p>



<pre><code>frame.darwin.process_info.pid == 92046</code></pre>



<p>This is super helpful to figure out both what unexpected network traffic is being generated by and the inverse, what a process is doing on the network. And now thanks to Wireshark 4.6.0 it’s even easier.</p>
											</div></div>
  </body>
</html>
