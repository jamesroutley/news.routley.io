<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eli.thegreenplace.net/2019/faster-xml-stream-processing-in-go/">Original</a>
    <h1>Faster XML Stream Processing in Go (2019)</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                <p>XML processing was all the rage 15 years ago; while it&#39;s less
prominent these days, it&#39;s still an important task in some application domains.
In this post I&#39;m going to compare the speed of stream-processing huge XML files
in Go, Python and C and finish up with a new, minimal module that uses C to
accelerate this task for Go. All the code shown throughout this post is
available <a href="https://github.com/eliben/code-for-blog/tree/main/2019/xml-stream">in this GitHub repository</a> the new
Go module <a href="https://github.com/eliben/gosax">is here</a>.</p>
<div id="what-does-xml-stream-processing-mean">
<h2>What does XML stream processing mean?</h2>
<p>First, let&#39;s define the problem at hand in more detail. Roughly speaking, there
are two ways we can process data from a file:</p>
<ol>
<li>Read the whole file into memory at once, and then proces the data in
memory.</li>
<li>Read the file in chunks, process each chuck, without having the whole data
in memory at any given time.</li>
</ol>
<p>In many ways, (1) is more convenient because we can easily go back to any part
of the file. However, in some situations (2) is essential; specifically, when
the file is very large. This is where <em>stream</em> processing comes in. If our input
file is 500 GiB, we&#39;re unlikely to be able to read it into memory and have to
process it in parts. Even for smaller files that would theoretically fit into
RAM, it&#39;s not always a good idea to read them wholly; this dramatically
increases the active heap size and can cause performance issues in
garbage-collected languages.</p>
</div>
<div id="the-task">
<h2>The task</h2>
<p>For this benchmark, I&#39;m using <a href="https://github.com/eliben/xmlgen">xmlgen</a> to
create a 230 MiB XML file <a href="#footnote-1" id="footnote-reference-1">[1]</a>. A tiny fragment of the file may look like this:</p>
<div><pre><span></span>&lt;?xml version=&#34;1.0&#34; standalone=&#34;yes&#34;?&gt;
&lt;site&gt;
  &lt;regions&gt;
    &lt;asia&gt;
      &lt;item id=&#34;item0&#34;&gt;
        &lt;location&gt;United States&lt;/location&gt;
        &lt;quantity&gt;1&lt;/quantity&gt;
        &lt;name&gt;duteous nine eighteen &lt;/name&gt;
        &lt;payment&gt;Creditcard&lt;/payment&gt;
        ...
      &lt;/item&gt;
    &lt;/asia&gt;
  &lt;/regions&gt;
&lt;/site&gt;
</pre></div>
<p>The task is to find how many times &#34;Africa&#34; appears in the data of the
<tt>&lt;location&gt;</tt> tag throughout the document.</p>
</div>
<div id="baseline-using-the-go-standard-library">
<h2>Baseline - using the Go standard library</h2>
<p>Let&#39;s start with a baseline implementation - using the standard library&#39;s
<tt>encoding/xml</tt> package. While the package&#39;s <tt>Unmarshal</tt> mode will parse the
whole file in one go, it can also be used to process XML token by token and
selectively parse interesting elements. Here is the code:</p>
<div><pre><span></span><span>package</span><span> </span><span>main</span><span></span>

<span>import</span><span> </span><span>(</span><span></span>
<span>  </span><span>&#34;encoding/xml&#34;</span><span></span>
<span>  </span><span>&#34;fmt&#34;</span><span></span>
<span>  </span><span>&#34;io&#34;</span><span></span>
<span>  </span><span>&#34;log&#34;</span><span></span>
<span>  </span><span>&#34;os&#34;</span><span></span>
<span>  </span><span>&#34;strings&#34;</span><span></span>
<span>)</span><span></span>

<span>type</span><span> </span><span>location</span><span> </span><span>struct</span><span> </span><span>{</span><span></span>
<span>  </span><span>Data</span><span> </span><span>string</span><span> </span><span>`xml:&#34;,chardata&#34;`</span><span></span>
<span>}</span><span></span>

<span>func</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span><span></span>
<span>  </span><span>f</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>os</span><span>.</span><span>Open</span><span>(</span><span>os</span><span>.</span><span>Args</span><span>[</span><span>1</span><span>])</span><span></span>
<span>  </span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span></span>
<span>    </span><span>log</span><span>.</span><span>Fatal</span><span>(</span><span>err</span><span>)</span><span></span>
<span>  </span><span>}</span><span></span>
<span>  </span><span>defer</span><span> </span><span>f</span><span>.</span><span>Close</span><span>()</span><span></span>

<span>  </span><span>d</span><span> </span><span>:=</span><span> </span><span>xml</span><span>.</span><span>NewDecoder</span><span>(</span><span>f</span><span>)</span><span></span>
<span>  </span><span>count</span><span> </span><span>:=</span><span> </span><span>0</span><span></span>
<span>  </span><span>for</span><span> </span><span>{</span><span></span>
<span>    </span><span>tok</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>d</span><span>.</span><span>Token</span><span>()</span><span></span>
<span>    </span><span>if</span><span> </span><span>tok</span><span> </span><span>==</span><span> </span><span>nil</span><span> </span><span>||</span><span> </span><span>err</span><span> </span><span>==</span><span> </span><span>io</span><span>.</span><span>EOF</span><span> </span><span>{</span><span></span>
<span>      </span><span>// EOF means we&#39;re done.</span><span></span>
<span>      </span><span>break</span><span></span>
<span>    </span><span>}</span><span> </span><span>else</span><span> </span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span></span>
<span>      </span><span>log</span><span>.</span><span>Fatalf</span><span>(</span><span>&#34;Error decoding token: %s&#34;</span><span>,</span><span> </span><span>err</span><span>)</span><span></span>
<span>    </span><span>}</span><span></span>

<span>    </span><span>switch</span><span> </span><span>ty</span><span> </span><span>:=</span><span> </span><span>tok</span><span>.(</span><span>type</span><span>)</span><span> </span><span>{</span><span></span>
<span>    </span><span>case</span><span> </span><span>xml</span><span>.</span><span>StartElement</span><span>:</span><span></span>
<span>      </span><span>if</span><span> </span><span>ty</span><span>.</span><span>Name</span><span>.</span><span>Local</span><span> </span><span>==</span><span> </span><span>&#34;location&#34;</span><span> </span><span>{</span><span></span>
<span>        </span><span>// If this is a start element named &#34;location&#34;, parse this element</span><span></span>
<span>        </span><span>// fully.</span><span></span>
<span>        </span><span>var</span><span> </span><span>loc</span><span> </span><span>location</span><span></span>
<span>        </span><span>if</span><span> </span><span>err</span><span> </span><span>=</span><span> </span><span>d</span><span>.</span><span>DecodeElement</span><span>(</span><span>&amp;</span><span>loc</span><span>,</span><span> </span><span>&amp;</span><span>ty</span><span>);</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span></span>
<span>          </span><span>log</span><span>.</span><span>Fatalf</span><span>(</span><span>&#34;Error decoding item: %s&#34;</span><span>,</span><span> </span><span>err</span><span>)</span><span></span>
<span>        </span><span>}</span><span></span>
<span>        </span><span>if</span><span> </span><span>strings</span><span>.</span><span>Contains</span><span>(</span><span>loc</span><span>.</span><span>Data</span><span>,</span><span> </span><span>&#34;Africa&#34;</span><span>)</span><span> </span><span>{</span><span></span>
<span>          </span><span>count</span><span>++</span><span></span>
<span>        </span><span>}</span><span></span>
<span>      </span><span>}</span><span></span>
<span>    </span><span>default</span><span>:</span><span></span>
<span>    </span><span>}</span><span></span>
<span>  </span><span>}</span><span></span>

<span>  </span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;count =&#34;</span><span>,</span><span> </span><span>count</span><span>)</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>I made sure to double check that the memory usage of this program stays bounded
and low while processing a large file - the maximum RSS was under 7 MiB while
processing our 230 MiB input file. I&#39;m verifying this for all the programs
presented in this post using <tt>/usr/bin/time <span>-v</span></tt> on Linux.</p>
<p>This program takes 6.24 seconds to process the whole file and print out the
result.</p>
</div>
<div id="python-implementation">
<h2>Python implementation</h2>
<p>The first Python implementation uses the <tt>xml.etree.ElementTree</tt> module from
the standard library:</p>
<div><pre><span></span><span>import</span> <span>sys</span>
<span>import</span> <span>xml.etree.ElementTree</span> <span>as</span> <span>ET</span>

<span>count</span> <span>=</span> <span>0</span>
<span>for</span> <span>event</span><span>,</span> <span>elem</span> <span>in</span> <span>ET</span><span>.</span><span>iterparse</span><span>(</span><span>sys</span><span>.</span><span>argv</span><span>[</span><span>1</span><span>],</span> <span>events</span><span>=</span><span>(</span><span>&#34;end&#34;</span><span>,)):</span>
    <span>if</span> <span>event</span> <span>==</span> <span>&#34;end&#34;</span><span>:</span>
        <span>if</span> <span>elem</span><span>.</span><span>tag</span> <span>==</span> <span>&#39;location&#39;</span> <span>and</span> <span>elem</span><span>.</span><span>text</span> <span>and</span> <span>&#39;Africa&#39;</span> <span>in</span> <span>elem</span><span>.</span><span>text</span><span>:</span>
            <span>count</span> <span>+=</span> <span>1</span>
        <span>elem</span><span>.</span><span>clear</span><span>()</span>

<span>print</span><span>(</span><span>&#39;count =&#39;</span><span>,</span> <span>count</span><span>)</span>
</pre></div>
<p>The key here is the <tt>elem.clear()</tt> call. It ensures that each element gets
discarded afer parsing it fully, so the memory usage won&#39;t grow linearly with
the size of the file (unless the file is pathological). This program takes 3.7
seconds to process the whole file - much faster than our Go program. Why is
that?</p>
<p>While the Go program uses 100% Go code for the task (<tt>encoding/xml</tt> is
implemented entirely in Go), the Python program is using a C extension (most of
<tt>ElementTree</tt> is written in C) wrapping a fast XML parser in C - <a href="https://github.com/libexpat/libexpat">libexpat</a>. The bulk of the work here is done in
C, which is faster than Go.
The performance of <tt>encoding/xml</tt> is further discussed in
<a href="https://github.com/golang/go/issues/21823">this issue</a>, though it&#39;s an
old one and the performance has been somewhat optimized since then.</p>
<p>An alternative XML parsing library for Python is <a href="https://github.com/lxml/lxml">lxml</a>,
which uses <a href="https://www.xmlsoft.org/">libxml</a> underneath. Here&#39;s a Python
version using lxml:</p>
<div><pre><span></span><span>import</span> <span>sys</span>
<span>from</span> <span>lxml</span> <span>import</span> <span>etree</span>

<span>count</span> <span>=</span> <span>0</span>
<span>for</span> <span>event</span><span>,</span> <span>elem</span> <span>in</span> <span>etree</span><span>.</span><span>iterparse</span><span>(</span><span>sys</span><span>.</span><span>argv</span><span>[</span><span>1</span><span>],</span> <span>events</span><span>=</span><span>(</span><span>&#34;end&#34;</span><span>,)):</span>
    <span>if</span> <span>event</span> <span>==</span> <span>&#34;end&#34;</span><span>:</span>
        <span>if</span> <span>elem</span><span>.</span><span>tag</span> <span>==</span> <span>&#39;location&#39;</span> <span>and</span> <span>elem</span><span>.</span><span>text</span> <span>and</span> <span>&#39;Africa&#39;</span> <span>in</span> <span>elem</span><span>.</span><span>text</span><span>:</span>
            <span>count</span> <span>+=</span> <span>1</span>
        <span>elem</span><span>.</span><span>clear</span><span>()</span>

<span>print</span><span>(</span><span>&#39;count =&#39;</span><span>,</span> <span>count</span><span>)</span>
</pre></div>
<p>This looks very similar to the previous version, and that&#39;s on purpose. lxml
has an <tt>etree</tt>-compatible API to make transition from the standard library
smoother. This version also takes around 3.7 seconds for our 230 MiB file.</p>
<p>The reason I&#39;m including lxml here is that it will run faster than
<tt>xml.etree.ElementTree</tt> when slurping the whole file, for our particular file
size. I want to highlight that this is outside of the scope for my experiment,
because I only care about streaming processing. The only way (that I&#39;m aware
of!) to successfully process a 500 GiB file with lxml would be by using
<tt>iterparse</tt>.</p>
</div>
<div id="how-fast-can-it-run">
<h2>How fast can it run?</h2>
<p>Based on the measurements presented here, Go is about 68% slower than Python for
parsing a large XML file in a streaming fashion. While Go usually compiles to
a much faster code than pure Python, the Python implementations have the backing
of efficient C libraries with which it&#39;s difficult to compete. I was curious
to know how fast it could be, in theory <a href="#footnote-2" id="footnote-reference-2">[2]</a>.</p>
<p>To answer this question, I implemented the same program using pure C with
libxml, which has a <a href="https://en.wikipedia.org/wiki/Simple_API_for_XML">SAX API</a>. I won&#39;t paste it wholly
here because it&#39;s longer, but you can find the <a href="https://github.com/eliben/code-for-blog/tree/main/2019/xml-stream/c-libxmlsax-count">full source code on GitHub</a>.
It takes just 0.56 seconds to process our 230 MiB input file, which is very
impressive given the other results, but also not very surprising. This is C,
after all.</p>
<p>You may wonder - if lxml uses libxml underneath, why is it so much slower than
the pure C version? The answer is Python call overhead. The lxml version calls
back into Python <em>for every parsed element</em>, which incurs a significant
cost <a href="#footnote-3" id="footnote-reference-3">[3]</a>. Another reason is that my C implementation doesn&#39;t actually parse an
element - it&#39;s just a simple event-based state machine, so there&#39;s less extra
work being done.</p>
</div>
<div id="using-libxml-from-go">
<h2>Using libxml from Go</h2>
<p>To recap where we are so far:</p>
<ol>
<li>Python libraries based on underlying C implementations are faster than
pure Go.</li>
<li>Pure C is much faster still.</li>
</ol>
<p>We have two options: we can either try to optimize Go&#39;s <tt>encoding/xml</tt>
package, or we can try to wrap a fast C library with Go. While the former is a
worthy goal, it involves a large effort and should be a topic for a separate
post. Here, I&#39;ll go for the latter.</p>
<p>Seaching around the web, I found a few wrappers around libxml. Two that seemed
moderately popular and maintained are <a href="https://github.com/lestrrat-go/libxml2">https://github.com/lestrrat-go/libxml2</a>
and <a href="https://github.com/moovweb/gokogiri">https://github.com/moovweb/gokogiri</a>. Unfortunately, neither of these (or
the other bindings I found) are exposing the SAX API of libxml; instead, they
focus on the DOM API, where the whole document is parsed by the underlying
library and a tree is returned. As mentioned above, we need the SAX interface
to process huge files.</p>
</div>
<div id="gosax">
<h2>gosax</h2>
<p>It&#39;s time to roll our own :-) I wrote the <a href="https://github.com/eliben/gosax">gosax</a> module, which uses Cgo to call into libxml
and exposes a SAX interface <a href="#footnote-4" id="footnote-reference-4">[4]</a>. Implementing it was an interesting exercise
in Cgo, because it requires some non-trivial concepts like
<a href="https://eli.thegreenplace.net/2019/passing-callbacks-and-pointers-to-cgo/">registering Go callbacks with C</a>.</p>
<p>Here&#39;s a version of our program using gosax:</p>
<div><pre><span></span><span>package</span><span> </span><span>main</span><span></span>

<span>import</span><span> </span><span>(</span><span></span>
<span>  </span><span>&#34;fmt&#34;</span><span></span>
<span>  </span><span>&#34;os&#34;</span><span></span>
<span>  </span><span>&#34;strings&#34;</span><span></span>

<span>  </span><span>&#34;github.com/eliben/gosax&#34;</span><span></span>
<span>)</span><span></span>

<span>func</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span><span></span>
<span>  </span><span>counter</span><span> </span><span>:=</span><span> </span><span>0</span><span></span>
<span>  </span><span>inLocation</span><span> </span><span>:=</span><span> </span><span>false</span><span></span>

<span>  </span><span>scb</span><span> </span><span>:=</span><span> </span><span>gosax</span><span>.</span><span>SaxCallbacks</span><span>{</span><span></span>
<span>    </span><span>StartElement</span><span>:</span><span> </span><span>func</span><span>(</span><span>name</span><span> </span><span>string</span><span>,</span><span> </span><span>attrs</span><span> </span><span>[]</span><span>string</span><span>)</span><span> </span><span>{</span><span></span>
<span>      </span><span>if</span><span> </span><span>name</span><span> </span><span>==</span><span> </span><span>&#34;location&#34;</span><span> </span><span>{</span><span></span>
<span>        </span><span>inLocation</span><span> </span><span>=</span><span> </span><span>true</span><span></span>
<span>      </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span>
<span>        </span><span>inLocation</span><span> </span><span>=</span><span> </span><span>false</span><span></span>
<span>      </span><span>}</span><span></span>
<span>    </span><span>},</span><span></span>

<span>    </span><span>EndElement</span><span>:</span><span> </span><span>func</span><span>(</span><span>name</span><span> </span><span>string</span><span>)</span><span> </span><span>{</span><span></span>
<span>      </span><span>inLocation</span><span> </span><span>=</span><span> </span><span>false</span><span></span>
<span>    </span><span>},</span><span></span>

<span>    </span><span>Characters</span><span>:</span><span> </span><span>func</span><span>(</span><span>contents</span><span> </span><span>string</span><span>)</span><span> </span><span>{</span><span></span>
<span>      </span><span>if</span><span> </span><span>inLocation</span><span> </span><span>&amp;&amp;</span><span> </span><span>strings</span><span>.</span><span>Contains</span><span>(</span><span>contents</span><span>,</span><span> </span><span>&#34;Africa&#34;</span><span>)</span><span> </span><span>{</span><span></span>
<span>        </span><span>counter</span><span>++</span><span></span>
<span>      </span><span>}</span><span></span>
<span>    </span><span>},</span><span></span>
<span>  </span><span>}</span><span></span>

<span>  </span><span>err</span><span> </span><span>:=</span><span> </span><span>gosax</span><span>.</span><span>ParseFile</span><span>(</span><span>os</span><span>.</span><span>Args</span><span>[</span><span>1</span><span>],</span><span> </span><span>scb</span><span>)</span><span></span>
<span>  </span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span></span>
<span>    </span><span>panic</span><span>(</span><span>err</span><span>)</span><span></span>
<span>  </span><span>}</span><span></span>

<span>  </span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;counter =&#34;</span><span>,</span><span> </span><span>counter</span><span>)</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>As you can see, it implements a state machine that remembers being inside
a <tt>location</tt> element, where the character data is checked. This program
takes 4.03 seconds to process our input file. Not bad! But we can do a bit
better, and <a href="https://github.com/eliben/code-for-blog/blob/main/2019/xml-stream/gosax-count/gosax-count.go">with a couple of optimizations</a>
I managed to bring it down to 3.68 seconds - about the same speed as the Python
implementations!</p>
<p>IMHO the roughly similar run times here are a coincidence, because the Python
programs are different from my approach in that they expose a higher-level API
than pure SAX. Recall that <tt>iterparse</tt> returns a parsed element, and we
can access its <tt>text</tt> attribute, etc. In gosax, we have to do this much more
manually. Since the the <a href="https://about.sourcegraph.com/go/gophercon-2018-adventures-in-cgo-performance">cost of calls between Cgo and Go is rather high</a>,
there is an optimization opportunity here for gosax. We could do more work in
C - parsing a full element, and returning it wholly to Go. This would move work
from the Go side to the C side, as well as reduce the number of cross-language
calls. But this is a task for another day.</p>
</div>
<div id="conclusion">
<h2>Conclusion</h2>
<p>Well, this was fun :-) There are 5 different implementations of the same simple
task described here, in 3 different programming languages. Here is a summary
of the speed measurements we got:</p>
<p><img alt="Performance comparison chart" src="https://eli.thegreenplace.net/images/2019/xml-sax-comparison.png"/></p><p>Python&#39;s performance story has always been - &#34;it&#39;s probably fast enough, and in
the rare cases where it isn&#39;t, use a C extension&#34;. In Go the narrative is
somewhat different: in most cases, the Go compiler produces fairly fast code.
Pure Go code is significantly faster than Python and often faster than Java.
Even so, every once in a while it may be useful to dip into C or C++ for
performance, and in these cases Cgo is a good approach.</p>
<p>It&#39;s obvious that <tt>encoding/xml</tt> <a href="https://github.com/golang/go/issues/21823">needs some work w.r.t. performance</a>, but until that happens - there
are good alternatives! Leveraging the speed of libxml has been possible for the
DOM API, and now is possible for the SAX API as well. In the long run, I believe
that serious performance work on <tt>encoding/xml</tt> can make it go faster than
the libxml wrappers because it would elimitate the high cost of C-to-Go calls.</p>
<hr/>




</div>

            </div></div>
  </body>
</html>
