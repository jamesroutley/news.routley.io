<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/pietroborrello/CustomProcessingUnit">Original</a>
    <h1>Custom Processing Unit: Hook, patch, and trace microcode at the software level</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/pietroborrello/CustomProcessingUnit/blob/master/images/cpu_logo.svg"><img src="https://github.com/pietroborrello/CustomProcessingUnit/raw/master/images/cpu_logo.svg" width="150"/></a></p>
<p dir="auto">Custom Processing Unit is the first dynamic analysis framework able to hook, patch and trace CPU microcode at the software level.</p>
<p dir="auto">It works by leveraging <a href="https://github.com/chip-red-pill/udbgInstr">undocumented instructions</a> in Intel CPUs that allow access to the CRBUS.
Using our <a href="https://github.com/pietroborrello/ghidra-atom-microcode">microcode decompiler</a> we reverse engineered how the CPU uses the CRBUS and by replicating the interactions we have full control of the CPU.</p>
<p dir="auto">Find the static analysis framework at <a href="https://github.com/pietroborrello/ghidra-atom-microcode">https://github.com/pietroborrello/ghidra-atom-microcode</a>.</p>
<p dir="auto">Check out our slides describing this work <a href="https://github.com/pietroborrello/CustomProcessingUnit/blob/master/slides.pdf">here</a>.</p>
<p dir="auto"><strong>Note</strong>: Custom Processing Unit requires a Red-Unlocked CPU: currently, only <a href="https://en.wikipedia.org/wiki/Goldmont" rel="nofollow">Goldmont CPUs</a> (GLM) have a <a href="https://github.com/ptresearch/IntelTXE-PoC">public Red Unlock</a>. We tested Gigabyte GB-BPCE-3350C with CPU stepping 0x9 and 0xa (cpuid 0x000506C9 and 0x000506CA).</p>
<p dir="auto">Custom Processing Unit is made up of a UEFI application and a few libraries. The UEFI application interacts with the GLM CPU, while the libraries provide different helpers to compile microcode into the UEFI application and analyze its output.</p>
<h2 dir="auto"><a id="user-content-prerequisites" aria-hidden="true" href="#prerequisites"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Prerequisites</h2>
<ol dir="auto">
<li>Follow the steps to red unlock your Goldmont CPU from <a href="https://github.com/ptresearch/IntelTXE-PoC">https://github.com/ptresearch/IntelTXE-PoC</a>.</li>
<li>Create a bootable USB key with an EFI shell</li>
<li>Install <a href="https://wiki.osdev.org/GNU-EFI" rel="nofollow">gnu-efi</a> on your main host</li>
</ol>
<h2 dir="auto"><a id="user-content-setup" aria-hidden="true" href="#setup"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Setup</h2>
<div data-snippet-clipboard-copy-content="GNU_EFI_DIR=&lt;path_to_gnu_efi&gt; make"><pre><code>GNU_EFI_DIR=&lt;path_to_gnu_efi&gt; make
</code></pre></div>
<p dir="auto">This will build the source microcode files and the UEFI application into <code>cpu.efi</code>.
Copy <code>cpu.efi</code> into the <code>\EFI\</code> folder of the USB key, plug it in the GLM and boot into the EFI shell.</p>
<p dir="auto">Run <code>map -r</code> in the efi shell to identify the USB key device and <code>&lt;deviceid&gt;:</code> to mount it.</p>
<h2 dir="auto"><a id="user-content-run-custom-processing-unit" aria-hidden="true" href="#run-custom-processing-unit"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Run Custom Processing Unit</h2>
<p dir="auto">Run <code>./cpu.efi</code> to print the help:</p>
<div data-snippet-clipboard-copy-content="Usage:
  patch:        &lt;tool&gt; p
  patch &amp; exec: &lt;tool&gt; x
  perf:         &lt;tool&gt; f
  zero out m&amp;p: &lt;tool&gt; z
  hook:         &lt;tool&gt; h  [m&amp;p idx] [uop addr] [patch addr]
  template:     &lt;tool&gt; m
  dump imms:    &lt;tool&gt; di
  dump rom:     &lt;tool&gt; dr
  dump msrs:    &lt;tool&gt; dm
  dump SMM:     &lt;tool&gt; ds [address] [size]
  cpuid:        &lt;tool&gt; c  [rax] [rcx]
  rdmsr:        &lt;tool&gt; rm [msr]
  wrmsr:        &lt;tool&gt; wm [msr]
  read:         &lt;tool&gt; r  [cmd] [addr]
  write:        &lt;tool&gt; w  [cmd] [addr] [value]
  invoke:       &lt;tool&gt; i  [addr]
  update ucode: &lt;tool&gt; u  [size]
  ldat read:    &lt;tool&gt; lr [port] [array] [bank] [idx] [addr] [optional size]
  ldat write:   &lt;tool&gt; lw [port] [array] [bank] [idx] [addr] [value]"><pre><code>Usage:
  patch:        &lt;tool&gt; p
  patch &amp; exec: &lt;tool&gt; x
  perf:         &lt;tool&gt; f
  zero out m&amp;p: &lt;tool&gt; z
  hook:         &lt;tool&gt; h  [m&amp;p idx] [uop addr] [patch addr]
  template:     &lt;tool&gt; m
  dump imms:    &lt;tool&gt; di
  dump rom:     &lt;tool&gt; dr
  dump msrs:    &lt;tool&gt; dm
  dump SMM:     &lt;tool&gt; ds [address] [size]
  cpuid:        &lt;tool&gt; c  [rax] [rcx]
  rdmsr:        &lt;tool&gt; rm [msr]
  wrmsr:        &lt;tool&gt; wm [msr]
  read:         &lt;tool&gt; r  [cmd] [addr]
  write:        &lt;tool&gt; w  [cmd] [addr] [value]
  invoke:       &lt;tool&gt; i  [addr]
  update ucode: &lt;tool&gt; u  [size]
  ldat read:    &lt;tool&gt; lr [port] [array] [bank] [idx] [addr] [optional size]
  ldat write:   &lt;tool&gt; lw [port] [array] [bank] [idx] [addr] [value]
</code></pre></div>
<h3 dir="auto"><a id="user-content-simple-instructions" aria-hidden="true" href="#simple-instructions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Simple instructions</h3>
<p dir="auto"><code>cpu</code> provides helpers to run simple instructions from the command line:</p>
<ul dir="auto">
<li>cpuid</li>
<li>rdmsr</li>
<li>wrmsr</li>
</ul>
<h3 dir="auto"><a id="user-content-complex-actions" aria-hidden="true" href="#complex-actions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Complex actions</h3>
<p dir="auto"><code>cpu</code> provides interfaces to complex CPU routines that are interesting to execute to study cpu behavior:</p>
<ul dir="auto">
<li><code>u</code>: update the CPU ucode with the provided (signed) patch</li>
<li><code>f</code>: collect performance counters while running microcode</li>
</ul>
<h3 dir="auto"><a id="user-content-raw-udbgrd-and-udbwr" aria-hidden="true" href="#raw-udbgrd-and-udbwr"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Raw udbgrd and udbwr</h3>
<p dir="auto"><code>cpu</code> provides raw interfaces to the undocumented instructions <code>udbrd</code> and <code>udbgwr</code>.
The most interesting commands they provide are:</p>
<ul dir="auto">
<li>0x0:  access CRBUS</li>
<li>0x10: access UROM</li>
<li>0x40: access stgbuf</li>
<li>0xd8: invoke ucode routine from address</li>
</ul>
<h3 dir="auto"><a id="user-content-ldat-access" aria-hidden="true" href="#ldat-access"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>LDAT access</h3>
<p dir="auto"><code>cpu</code> exposes LDAT access routines to read and write. Specify the parameters  <code>[port] [array] [bank] [idx] [addr]</code> to read or write there.
Interesting ports are:</p>
<ul dir="auto">
<li>0x6a0: microcode sequencer, which has access to the internal the ucode ROM and RAM</li>
<li>0x120: load/store buffers</li>
<li>0x3c0: instruction cache</li>
<li>0x630: ITLB</li>
</ul>
<p dir="auto">Please notice that accessing some of these internal components may cause the CPU to freeze.</p>
<h3 dir="auto"><a id="user-content-patch-microcode" aria-hidden="true" href="#patch-microcode"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Patch microcode</h3>
<p dir="auto"><code>cpu</code> provides functionalities to install patches in the microcode.</p>
<ol dir="auto">
<li>Write your microcode patch in <code>bios/ucode_patches/ucode_patch.u</code> (look at the other patches for examples)</li>
<li>Build the UEFI application</li>
<li>Execute <code>cpu.efi p</code> to install the patch at the address provided in <code>.org</code>.</li>
</ol>
<p dir="auto">Notice that in the microcode, only the addresses between 0x7c00 and 0x7e00 are writable and meaningful to patch.</p>
<p dir="auto">Running <code>cpu.efi x</code>, it will also execute the microcode patched and print the <code>rax, rbx, rcx, rdx</code> registers as result.</p>
<h3 dir="auto"><a id="user-content-match--patch" aria-hidden="true" href="#match--patch"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Match &amp; Patch</h3>
<p dir="auto">To automatically execute microcode at certain CPU events or microcode points, <code>cpu</code> leverages the Match and Patch.
It defines a microcode address to hook and the microcode address to jump to when the hook is triggered.</p>
<ul dir="auto">
<li><code>z</code>: resets all the match &amp; patch.</li>
<li><code>h</code>: installs an hook, given an index (0-0x20), an address to hook (0-0x7c00) and a target address to execute (0x7c00-0x7e00).</li>
</ul>
<h3 dir="auto"><a id="user-content-tracing-microcode" aria-hidden="true" href="#tracing-microcode"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Tracing microcode</h3>
<p dir="auto">By installing multiple hooks and continuously executing an instruction, <code>cpu</code> is able to trace the microoperations performed by such an instruction, and dump them. To trace:</p>
<ol dir="auto">
<li>Write the instruction to be traced after the <code>// [TRACED INSTRUCTION HERE]</code> in <code>get_trace_clock_at()</code>.</li>
<li>Build the UEFI application.</li>
<li>Trace with: <code>cpu.efi m</code>.
It will create a <code>trace.txt</code> file that contains all the addresses that have been hit.</li>
<li>Execute <code>uasm-lib/uasm.py -t trace.txt &gt; parsed_trace.txt</code>.
It will generate a full trace of the microcode executed during the instruction.</li>
</ol>
<p dir="auto">Notice that <code>uasm.py</code> will leverage the <code>ms_arrayX.txt</code> files in its folder to generate a disassembly of the microinstructions executed. These are for GLM with stepping 0x9 (cpuid 0x000506C9). Please generate the proper arrays in case you have a different stepping.
You can use the LDAT dump functionalities for this purpose.</p>
<h3 dir="auto"><a id="user-content-secret-memory-dumpers" aria-hidden="true" href="#secret-memory-dumpers"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Secret memory dumpers</h3>
<p dir="auto">The CPU has different inaccessible buffers from the architecture, for which we provide routines to dump:</p>
<ul dir="auto">
<li><code>smm</code>: SMROM (or any other address while disabling SMM protection)</li>
<li><code>rom</code>: internal ROM</li>
<li><code>imms</code>: CPU hardcoded immediates</li>
<li><code>msrs</code>: internal MSRs configurations</li>
</ul>
<h3 dir="auto"><a id="user-content-writing-microcode-patches" aria-hidden="true" href="#writing-microcode-patches"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Writing microcode patches</h3>
<p dir="auto">We provide an assembler that generates header files to be compiled into the <code>cpu.efi</code> UEFI application.
Look into the provided patches in <code>bios/ucode_patches</code> for the syntax.
It supports simple operations and labels.
Assemble a microcode patch with <code>uasm.py -i ucode_patch.u -o ucode_patch.h</code>.
<code>cpu.efi</code> will be compiled and automatically include the microcode patch that you want to apply.</p>
<h4 dir="auto"><a id="user-content-example" aria-hidden="true" href="#example"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Example</h4>
<p dir="auto">file: <code>code_patch.u</code></p>
<div data-snippet-clipboard-copy-content=".org 0x7c00

rax:= ZEROEXT_DSZ32(0x00001337)
rbx:= ZEROEXT_DSZ32(0x00001337)
rcx:= ZEROEXT_DSZ32(0x00001337)
rdx:= ZEROEXT_DSZ32(0x00001337)"><pre><code>.org 0x7c00

rax:= ZEROEXT_DSZ32(0x00001337)
rbx:= ZEROEXT_DSZ32(0x00001337)
rcx:= ZEROEXT_DSZ32(0x00001337)
rdx:= ZEROEXT_DSZ32(0x00001337)
</code></pre></div>
<p dir="auto">recompile, then run in the GLM:</p>
<div data-snippet-clipboard-copy-content="cpu.efi z # zero out match &amp; patch
cpu.efi p # apply the patch
cpu.efi h 0 0x0428 0x7c00 # rdrand entry point"><pre><code>cpu.efi z # zero out match &amp; patch
cpu.efi p # apply the patch
cpu.efi h 0 0x0428 0x7c00 # rdrand entry point
</code></pre></div>
<p dir="auto">now every time <code>rdrand</code> is executed, it will return <code>0x1337</code> in the registers.</p>
</article>
          </div></div>
  </body>
</html>
