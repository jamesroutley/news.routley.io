<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/fastserial/lite3">Original</a>
    <h1>Lite^3, a JSON-compatible zero-copy serialization format</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><em>Parse no more—the wire format is the memory format.</em></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://palomakop.tv/fastserial/lite3/blob/main/img/lite3_landing_page.png"><img src="https://palomakop.tv/fastserial/lite3/raw/main/img/lite3_landing_page.png" alt=""/></a>
<a target="_blank" rel="noopener noreferrer" href="https://palomakop.tv/fastserial/lite3/blob/main/img/lite3_infographic_dark.png"><img src="https://palomakop.tv/fastserial/lite3/raw/main/img/lite3_infographic_dark.png" alt=""/></a></p>



<p dir="auto">Lite³ is a zero-copy binary serialization format encoding data as a B-tree inside a single contiguous buffer, allowing access and mutation on any arbitrary field in <code>O(log n)</code> time. Essentially, it functions as a <em>serialized dictionary</em>.</p>
<p dir="auto">As a result, the serialization boundary has been broken: &#39;parsing&#39; or &#39;serializing&#39; in the traditional sense is no longer necessary. Lite³ structures can be read and mutated directly similar to hashmaps or binary trees, and since they exist in a single contiguous buffer, they always remain ready to send.</p>
<p dir="auto">Compared to other binary formats, Lite³ is schemaless, self-describing (no IDL or schema definitons required) and <strong>supports conversion to/from JSON</strong>, enabling compatibility with existing datasets/APIs and allowing for easy debugging/inspecting of messages.</p>
<p dir="auto">Thanks to the cache-friendly properties of the B-tree and the very minimalistic C implementation (9.3 kB), Lite³ outperforms the fastest JSON libraries (that make use of SIMD) by up to 120x depending on the benchmark. It also outperforms schema-only formats, such as Google Flatbuffers (242x). Lite³ is possibly the fastest schemaless data format in the world.</p>
<p dir="auto">Example to illustrate:</p>
<ol dir="auto">
<li>A Lite³ message is received from a socket</li>
<li>Without doing any parsing, the user can immediately:
<ul dir="auto">
<li>Lookup keys and read values via zero-copy pointers</li>
<li>Insert/overwrite arbitrary key/value entries</li>
</ul>
</li>
<li>After all operations are done, the structure can be transmitted &#39;as-is&#39; (no serialization required, just <code>memcpy()</code>)</li>
<li>The receiver then has access to all the same operations</li>
</ol>
<p dir="auto">Typically, in such a scenario a distinct &#39;serializing&#39; and &#39;deserializing&#39; step would be required.
However Lite³ blurs the line between memory and wire formats, allowing direct access, traversal and mutation of a serialized buffer.</p>

<ul dir="auto">
<li>Schemaless &amp; self-describing, no IDL or schema definitons required</li>
<li>Zero-copy reads + writes of any data size</li>
<li>Lives on OSI layer 6 (transport/protocol agnostic)</li>
<li>O(log n) amortized time complexity for all IOPS</li>
<li>Built-in pointer validation</li>
<li>Low memory profile</li>
<li>Predictable latency</li>
<li>No <code>malloc()</code> API, caller provides buffer</li>
<li>Library size 9.3 kB (core) and dependency-free</li>
<li>Written in C11 using GNU C syntax</li>
<li>Optional subdependency (yyjson) to support conversion to/from JSON</li>
<li>MIT license</li>
</ul>

<p dir="auto">Lite³ is a binary format, but the examples print message data as JSON to <code>stdout</code> for better readability.</p>
<p dir="auto">Here is an example with error handling omitted for brevity, taken from <code>examples/buffer_api/01-building-messages.c</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdbool.h&gt;

#include &#34;lite3.h&#34;


static unsigned char buf[1024], rx[1024];

int main() {
        size_t buflen = 0;
        size_t bufsz = sizeof(buf);

        // Build message
        lite3_init_obj(buf, &amp;buflen, bufsz);
        lite3_set_str(buf, &amp;buflen, 0, bufsz, &#34;event&#34;, &#34;lap_complete&#34;);
        lite3_set_i64(buf, &amp;buflen, 0, bufsz, &#34;lap&#34;, 55);
        lite3_set_f64(buf, &amp;buflen, 0, bufsz, &#34;time_sec&#34;, 88.427);
        printf(&#34;buflen: %zu\n&#34;, buflen);
        lite3_json_print(buf, buflen, 0); // Print Lite³ as JSON

        printf(&#34;\nUpdating lap count\n&#34;);
        lite3_set_i64(buf, &amp;buflen, 0, bufsz, &#34;lap&#34;, 56);
        printf(&#34;Data to send:\n&#34;);
        printf(&#34;buflen: %zu\n&#34;, buflen);
        lite3_json_print(buf, buflen, 0);
        
        // Transmit
        size_t rx_buflen = buflen;
        size_t rx_bufsz = sizeof(rx);
        memcpy(rx, buf, buflen);
        
        // Mutate (zero-copy, no parsing)
        printf(&#34;\nVerifying fastest lap\n&#34;);
        lite3_set_str(rx, &amp;rx_buflen, 0, rx_bufsz, &#34;verified&#34;, &#34;race_control&#34;);
        lite3_set_bool(rx, &amp;rx_buflen, 0, rx_bufsz, &#34;fastest_lap&#34;, true);
        printf(&#34;Modified data:\n&#34;);
        printf(&#34;rx_buflen: %zu\n&#34;, rx_buflen);
        lite3_json_print(rx, rx_buflen, 0);

        // Ready to send:
        // send(sock, rx, rx_buflen, 0);

        return 0;
}"><pre><span>#include</span> <span>&lt;stdio.h&gt;</span>
<span>#include</span> <span>&lt;string.h&gt;</span>
<span>#include</span> <span>&lt;stdbool.h&gt;</span>

<span>#include</span> <span>&#34;lite3.h&#34;</span>


<span>static</span> <span>unsigned <span>char</span></span> <span>buf</span>[<span>1024</span>], <span>rx</span>[<span>1024</span>];

<span>int</span> <span>main</span>() {
        <span>size_t</span> <span>buflen</span> <span>=</span> <span>0</span>;
        <span>size_t</span> <span>bufsz</span> <span>=</span> <span>sizeof</span>(<span>buf</span>);

        <span>// Build message</span>
        <span>lite3_init_obj</span>(<span>buf</span>, <span>&amp;</span><span>buflen</span>, <span>bufsz</span>);
        <span>lite3_set_str</span>(<span>buf</span>, <span>&amp;</span><span>buflen</span>, <span>0</span>, <span>bufsz</span>, <span>&#34;event&#34;</span>, <span>&#34;lap_complete&#34;</span>);
        <span>lite3_set_i64</span>(<span>buf</span>, <span>&amp;</span><span>buflen</span>, <span>0</span>, <span>bufsz</span>, <span>&#34;lap&#34;</span>, <span>55</span>);
        <span>lite3_set_f64</span>(<span>buf</span>, <span>&amp;</span><span>buflen</span>, <span>0</span>, <span>bufsz</span>, <span>&#34;time_sec&#34;</span>, <span>88.427</span>);
        <span>printf</span>(<span>&#34;buflen: %zu\n&#34;</span>, <span>buflen</span>);
        <span>lite3_json_print</span>(<span>buf</span>, <span>buflen</span>, <span>0</span>); <span>// Print Lite³ as JSON</span>

        <span>printf</span>(<span>&#34;\nUpdating lap count\n&#34;</span>);
        <span>lite3_set_i64</span>(<span>buf</span>, <span>&amp;</span><span>buflen</span>, <span>0</span>, <span>bufsz</span>, <span>&#34;lap&#34;</span>, <span>56</span>);
        <span>printf</span>(<span>&#34;Data to send:\n&#34;</span>);
        <span>printf</span>(<span>&#34;buflen: %zu\n&#34;</span>, <span>buflen</span>);
        <span>lite3_json_print</span>(<span>buf</span>, <span>buflen</span>, <span>0</span>);
        
        <span>// Transmit</span>
        <span>size_t</span> <span>rx_buflen</span> <span>=</span> <span>buflen</span>;
        <span>size_t</span> <span>rx_bufsz</span> <span>=</span> <span>sizeof</span>(<span>rx</span>);
        <span>memcpy</span>(<span>rx</span>, <span>buf</span>, <span>buflen</span>);
        
        <span>// Mutate (zero-copy, no parsing)</span>
        <span>printf</span>(<span>&#34;\nVerifying fastest lap\n&#34;</span>);
        <span>lite3_set_str</span>(<span>rx</span>, <span>&amp;</span><span>rx_buflen</span>, <span>0</span>, <span>rx_bufsz</span>, <span>&#34;verified&#34;</span>, <span>&#34;race_control&#34;</span>);
        <span>lite3_set_bool</span>(<span>rx</span>, <span>&amp;</span><span>rx_buflen</span>, <span>0</span>, <span>rx_bufsz</span>, <span>&#34;fastest_lap&#34;</span>, true);
        <span>printf</span>(<span>&#34;Modified data:\n&#34;</span>);
        <span>printf</span>(<span>&#34;rx_buflen: %zu\n&#34;</span>, <span>rx_buflen</span>);
        <span>lite3_json_print</span>(<span>rx</span>, <span>rx_buflen</span>, <span>0</span>);

        <span>// Ready to send:</span>
        <span>// send(sock, rx, rx_buflen, 0);</span>

        <span>return</span> <span>0</span>;
}</pre></div>
<p dir="auto">Output:</p>
<div data-snippet-clipboard-copy-content="buflen: 154
{
    &#34;lap&#34;: 55,
    &#34;event&#34;: &#34;lap_complete&#34;,
    &#34;time_sec&#34;: 88.427
}

Updating lap count
Data to send:
buflen: 154
{
    &#34;lap&#34;: 56,
    &#34;event&#34;: &#34;lap_complete&#34;,
    &#34;time_sec&#34;: 88.427
}

Verifying fastest lap
Modified data:
rx_buflen: 197
{
    &#34;lap&#34;: 56,
    &#34;event&#34;: &#34;lap_complete&#34;,
    &#34;time_sec&#34;: 88.427,
    &#34;fastest_lap&#34;: true,
    &#34;verified&#34;: &#34;race_control&#34;
}"><pre><code>buflen: 154
{
    &#34;lap&#34;: 55,
    &#34;event&#34;: &#34;lap_complete&#34;,
    &#34;time_sec&#34;: 88.427
}

Updating lap count
Data to send:
buflen: 154
{
    &#34;lap&#34;: 56,
    &#34;event&#34;: &#34;lap_complete&#34;,
    &#34;time_sec&#34;: 88.427
}

Verifying fastest lap
Modified data:
rx_buflen: 197
{
    &#34;lap&#34;: 56,
    &#34;event&#34;: &#34;lap_complete&#34;,
    &#34;time_sec&#34;: 88.427,
    &#34;fastest_lap&#34;: true,
    &#34;verified&#34;: &#34;race_control&#34;
}
</code></pre></div>
<p dir="auto">Lite³ provides an alternative API called the &#39;Context API&#39; where memory management is abstracted away from the user.</p>
<p dir="auto">This example is taken from <code>examples/context_api/04-nesting.c</code>. Again, with error handling omitted for brevity:</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include &#34;lite3_context_api.h&#34;


int main() {
        lite3_ctx *ctx = lite3_ctx_create();
        
        // Build message
        lite3_ctx_init_obj(ctx)
        lite3_ctx_set_str(ctx, 0, &#34;event&#34;, &#34;http_request&#34;)
        lite3_ctx_set_str(ctx, 0, &#34;method&#34;, &#34;POST&#34;)
        lite3_ctx_set_i64(ctx, 0, &#34;duration_ms&#34;, 47)

        // Set headers
        size_t headers_ofs;
        lite3_ctx_set_obj(ctx, 0, &#34;headers&#34;, &amp;headers_ofs)
        lite3_ctx_set_str(ctx, headers_ofs, &#34;content-type&#34;, &#34;application/json&#34;)
        lite3_ctx_set_str(ctx, headers_ofs, &#34;x-request-id&#34;, &#34;req_9f8e2a&#34;)
        lite3_ctx_set_str(ctx, headers_ofs, &#34;user-agent&#34;, &#34;curl/8.1.2&#34;)

        lite3_ctx_json_print(ctx, 0) // Print Lite³ as JSON

        // Get user-agent
        lite3_str user_agent;
        size_t ofs;
        lite3_ctx_get_obj(ctx, 0, &#34;headers&#34;, &amp;ofs)
        lite3_ctx_get_str(ctx, ofs, &#34;user-agent&#34;, &amp;user_agent)
        printf(&#34;User agent: %s\n&#34;, LITE3_STR(ctx-&gt;buf, user_agent));

        lite3_ctx_destroy(ctx);
        return 0;
}"><pre><span>#include</span> <span>&lt;stdio.h&gt;</span>
<span>#include</span> <span>&lt;string.h&gt;</span>

<span>#include</span> <span>&#34;lite3_context_api.h&#34;</span>


<span>int</span> <span>main</span>() {
        <span>lite3_ctx</span> <span>*</span><span>ctx</span> <span>=</span> <span>lite3_ctx_create</span>();
        
        <span>// Build message</span>
        <span>lite3_ctx_init_obj</span>(<span>ctx</span>)
        <span>lite3_ctx_set_str</span>(<span>ctx</span>, <span>0</span>, &#34;<span>event</span>&#34;, &#34;<span>http_request</span>&#34;)
        <span>lite3_ctx_set_str</span>(<span>ctx</span>, <span>0</span>, &#34;<span>method</span>&#34;, &#34;<span>POST</span>&#34;)
        <span>lite3_ctx_set_i64</span>(<span>ctx</span>, <span>0</span>, &#34;<span>duration_ms</span>&#34;, <span>47</span>)

        <span>// Set headers</span>
        <span>size_t</span> <span>headers_ofs</span>;
        <span>lite3_ctx_set_obj</span>(<span>ctx</span>, <span>0</span>, &#34;<span>headers</span>&#34;, <span>&amp;</span><span>headers_ofs</span>)
        <span>lite3_ctx_set_str</span>(<span>ctx</span>, <span>headers_ofs</span>, &#34;<span>content</span><span>-</span><span>type</span>&#34;, &#34;<span>application</span>/<span>json</span>&#34;)
        <span>lite3_ctx_set_str</span>(<span>ctx</span>, <span>headers_ofs</span>, &#34;<span>x</span><span>-</span><span>request</span><span>-</span><span>id</span>&#34;, &#34;<span>req_9f8e2a</span>&#34;)
        <span>lite3_ctx_set_str</span>(<span>ctx</span>, <span>headers_ofs</span>, &#34;<span>user</span><span>-</span><span>agent</span>&#34;, &#34;<span>curl</span>/<span>8.1</span><span>.2</span>&#34;)

        <span>lite3_ctx_json_print</span>(<span>ctx</span>, <span>0</span>) <span>// Print Lite³ as JSON</span>

        <span>// Get user-agent</span>
        <span>lite3_str</span> <span>user_agent</span>;
        <span>size_t</span> <span>ofs</span>;
        <span>lite3_ctx_get_obj</span>(<span>ctx</span>, <span>0</span>, &#34;<span>headers</span>&#34;, <span>&amp;</span><span>ofs</span>)
        <span>lite3_ctx_get_str</span>(<span>ctx</span>, <span>ofs</span>, &#34;<span>user</span><span>-</span><span>agent</span>&#34;, <span>&amp;</span><span>user_agent</span>)
        <span>printf</span>(&#34;<span>User</span> <span>agent</span>: %<span>s</span>\<span>n</span>&#34;, <span>LITE3_STR</span>(<span>ctx</span><span>-</span><span>&gt;</span><span>buf</span>, <span>user_agent</span>));

        <span>lite3_ctx_destroy</span>(<span>ctx</span>);
        <span>return</span> <span>0</span>;
}</pre></div>
<p dir="auto">Output:</p>
<div data-snippet-clipboard-copy-content="{
    &#34;method&#34;: &#34;POST&#34;,
    &#34;event&#34;: &#34;http_request&#34;,
    &#34;duration_ms&#34;: 47,
    &#34;headers&#34;: {
        &#34;user-agent&#34;: &#34;curl/8.1.2&#34;,
        &#34;x-request-id&#34;: &#34;req_9f8e2a&#34;,
        &#34;content-type&#34;: &#34;application/json&#34;
    }
}
User agent: curl/8.1.2"><pre><code>{
    &#34;method&#34;: &#34;POST&#34;,
    &#34;event&#34;: &#34;http_request&#34;,
    &#34;duration_ms&#34;: 47,
    &#34;headers&#34;: {
        &#34;user-agent&#34;: &#34;curl/8.1.2&#34;,
        &#34;x-request-id&#34;: &#34;req_9f8e2a&#34;,
        &#34;content-type&#34;: &#34;application/json&#34;
    }
}
User agent: curl/8.1.2
</code></pre></div>
<p dir="auto">For a complete How-to Guide with examples, see <a href="https://lite3.io/how_to_guides.html" rel="nofollow">the documentation</a>.</p>


<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>make all</code></td>
<td>Build the static library with -O2 optimizations (default)</td>
</tr>
<tr>
<td><code>make tests</code></td>
<td>Build and run all tests</td>
</tr>
<tr>
<td><code>make examples</code></td>
<td>Build all examples</td>
</tr>
<tr>
<td><code>make install</code></td>
<td>Install library in <code>/usr/local</code> (for pkg-config)</td>
</tr>
<tr>
<td><code>make uninstall</code></td>
<td>Uninstall library</td>
</tr>
<tr>
<td><code>make clean</code></td>
<td>Remove all build artifacts</td>
</tr>
<tr>
<td><code>make help</code></td>
<td>Show this help message</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>

<p dir="auto">A gcc or clang compiler is required due to the use of various builtins.</p>
<p dir="auto">First clone the repository:</p>
<div data-snippet-clipboard-copy-content="git clone https://github.com/fastserial/lite3.git
cd lite3/"><pre><code>git clone https://github.com/fastserial/lite3.git
cd lite3/
</code></pre></div>
<p dir="auto">Then choose between installation via <code>pkg-config</code> or manual linking.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Installation via pkg-config (easiest)</h4><a id="user-content-installation-via-pkg-config-easiest" aria-label="Permalink: Installation via pkg-config (easiest)" href="#installation-via-pkg-config-easiest"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Inside the project root, run:</p>
<div data-snippet-clipboard-copy-content="sudo make install -j
sudo ldconfig"><pre><code>sudo make install -j
sudo ldconfig
</code></pre></div>
<p dir="auto">This will build the static library, then install it to <code>/usr/local</code> and refresh the <code>pkg-config</code> cache. If installation was successful, you should be able to check the library version like so:</p>
<div data-snippet-clipboard-copy-content="pkg-config --modversion lite3"><pre><code>pkg-config --modversion lite3
</code></pre></div>
<p dir="auto">You can now compile using these flags:</p>
<div data-snippet-clipboard-copy-content="$(pkg-config --libs --cflags --static lite3)"><pre><code>$(pkg-config --libs --cflags --static lite3)
</code></pre></div>
<p dir="auto">For example, to compile a single file <code>main.c</code>:</p>
<div data-snippet-clipboard-copy-content="gcc -o main main.c $(pkg-config --libs --cflags --static lite3)"><pre><code>gcc -o main main.c $(pkg-config --libs --cflags --static lite3)
</code></pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">Installation via manual linking</h4><a id="user-content-installation-via-manual-linking" aria-label="Permalink: Installation via manual linking" href="#installation-via-manual-linking"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">First build the library inside project root:</p>

<p dir="auto">Then in your main program:</p>
<ol dir="auto">
<li>Link against <code>build/liblite3.a</code></li>
<li>And include: <code>include/lite3.h</code> + <code>include/lite3_context_api.h</code></li>
</ol>
<p dir="auto">For example, to compile a single file <code>main.c</code>:</p>
<div data-snippet-clipboard-copy-content="gcc -o main main.c -I/path/to/lite3/include /path/to/lite3/build/liblite3.a"><pre><code>gcc -o main main.c -I/path/to/lite3/include /path/to/lite3/build/liblite3.a
</code></pre></div>


<p dir="auto">The Buffer API provides the most control, utilizing caller-supplied buffers to support environments with custom allocation patterns, avoiding the use of <code>malloc()</code>.</p>
<p dir="auto">The Context API is a wrapper aound the Buffer API where memory allocations are hidden from the user, presenting a more accessible interface. If you are using Lite³ for the first time, it is recommmended to start with the Context API.</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &#34;lite3.h&#34;              // Buffer API
#include &#34;lite3_context_api.h&#34;  // Context API"><pre><span>#include</span> <span>&#34;lite3.h&#34;</span>              <span>// Buffer API</span>
<span>#include</span> <span>&#34;lite3_context_api.h&#34;</span>  <span>// Context API</span></pre></div>
<p dir="auto">There is no need to include both headers, only the API you intend to use.</p>

<p dir="auto">By default, library error messages are disabled. However it is recommended to enable them to receive feedback during development. To do this, either:</p>
<ol dir="auto">
<li>uncomment the line <code>// #define LITE3_ERROR_MESSAGES</code> inside the header file: <code>include/lite3.h</code></li>
<li>build the library using compilation flag <code>-DLITE3_ERROR_MESSAGES</code></li>
</ol>
<p dir="auto">If you installed using <code>pkg-config</code>, you may need to reinstall the library to apply the changes. To do this, run:</p>
<div data-snippet-clipboard-copy-content="sudo make uninstall
sudo make clean
sudo make install
sudo ldconfig"><pre><code>sudo make uninstall
sudo make clean
sudo make install
sudo ldconfig
</code></pre></div>

<p dir="auto">Examples can be found in separate directories for each API:</p>
<ul dir="auto">
<li><code>examples/buffer_api/*</code></li>
<li><code>examples/context_api/*</code></li>
</ul>
<p dir="auto">To build the examples, inside the project root run:</p>

<p dir="auto">To run an example:</p>
<div data-snippet-clipboard-copy-content="./build/examples/context_api/01-building-messages"><pre><code>./build/examples/context_api/01-building-messages
</code></pre></div>
<p dir="auto">For learning how to use Lite³, it is recommended to follow the <a href="https://lite3.io/how_to_guides.html" rel="nofollow">How-to Guide series</a>.</p>

<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Format name</th>
<th>Schemaless</th>
<th>Zero-copy reads<sup><a href="#user-content-fn-1-d3dfdd2a911448e11b35672261b9d755" id="user-content-fnref-1-d3dfdd2a911448e11b35672261b9d755" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup></th>
<th>Zero-copy writes<sup><a href="#user-content-fn-2-d3dfdd2a911448e11b35672261b9d755" id="user-content-fnref-2-d3dfdd2a911448e11b35672261b9d755" data-footnote-ref="" aria-describedby="footnote-label">2</a></sup></th>
<th>Human-readable<sup><a href="#user-content-fn-3-d3dfdd2a911448e11b35672261b9d755" id="user-content-fnref-3-d3dfdd2a911448e11b35672261b9d755" data-footnote-ref="" aria-describedby="footnote-label">3</a></sup></th>
</tr>
</thead>
<tbody>
<tr>
<td>Lite³</td>
<td>✅</td>
<td>✅ O(log n)</td>
<td>✅ O(log n)</td>
<td><g-emoji alias="warning">⚠️</g-emoji> (convertable to JSON)</td>
</tr>
<tr>
<td>JSON</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>BSON</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td><g-emoji alias="warning">⚠️</g-emoji> (convertable to JSON)</td>
</tr>
<tr>
<td>MessagePack</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td><g-emoji alias="warning">⚠️</g-emoji> (convertable to JSON)</td>
</tr>
<tr>
<td>CBOR</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td><g-emoji alias="warning">⚠️</g-emoji> (convertable to JSON)</td>
</tr>
<tr>
<td>Smile</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td><g-emoji alias="warning">⚠️</g-emoji> (convertable to JSON)</td>
</tr>
<tr>
<td>Ion (Amazon)</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td><g-emoji alias="warning">⚠️</g-emoji> (convertable to JSON)</td>
</tr>
<tr>
<td>Protobuf (Google)</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>❌<sup><a href="#user-content-fn-4-d3dfdd2a911448e11b35672261b9d755" id="user-content-fnref-4-d3dfdd2a911448e11b35672261b9d755" data-footnote-ref="" aria-describedby="footnote-label">4</a></sup></td>
</tr>
<tr>
<td>Apache Arrow (based on Flatb.)</td>
<td>❌</td>
<td>✅ O(1)</td>
<td>❌ (immutable)</td>
<td>❌</td>
</tr>
<tr>
<td>Flatbuffers (Google)</td>
<td>❌</td>
<td>✅ O(1)</td>
<td>❌ (immutable)</td>
<td>❌</td>
</tr>
<tr>
<td>Flexbuffers (Google)</td>
<td>✅</td>
<td>✅<sup><a href="#user-content-fn-5-d3dfdd2a911448e11b35672261b9d755" id="user-content-fnref-5-d3dfdd2a911448e11b35672261b9d755" data-footnote-ref="" aria-describedby="footnote-label">5</a></sup></td>
<td>❌ (immutable)</td>
<td><g-emoji alias="warning">⚠️</g-emoji> (convertable to JSON)</td>
</tr>
<tr>
<td>Cap&#39;n Proto (Cloudflare)</td>
<td>❌</td>
<td>✅ O(1)</td>
<td><g-emoji alias="warning">⚠️</g-emoji> (in-place only)</td>
<td>❌</td>
</tr>
<tr>
<td>Thrift (Facebook)</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>Avro (Apache)</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>Bond (Microsoft, discontinued)</td>
<td>❌</td>
<td><g-emoji alias="warning">⚠️</g-emoji> (limited)</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>DER (ASN.1)</td>
<td>❌</td>
<td><g-emoji alias="warning">⚠️</g-emoji> (limited)</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>SBE</td>
<td>❌</td>
<td>✅ O(1)</td>
<td><g-emoji alias="warning">⚠️</g-emoji> (in-place only)</td>
<td>❌</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">Remember that we judge the behavior of formats by their implementation rather than by their official spec. This is because we cannot judge the behavior of hypothetical non-existent implementations.</p>

<div dir="auto"><h3 tabindex="-1" dir="auto">Simdjson Twitter API Data Benchmark</h3><a id="user-content-simdjson-twitter-api-data-benchmark" aria-label="Permalink: Simdjson Twitter API Data Benchmark" href="#simdjson-twitter-api-data-benchmark"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This benchmark by the authors of <a href="https://github.com/simdjson/simdjson">the official simdjson respository</a>
was created to compare JSON parsing performance for different C/C++ libraries.</p>
<p dir="auto">An input dataset <code>twitter.json</code> is used, consisting ~632 kB of real twitter API data to perform a number of tasks, each having its own category:</p>
<ol dir="auto">
<li><strong>top_tweet</strong>: Find the tweet with the most number of retweets.</li>
<li><strong>partial_tweets</strong>: Iterate over all tweets, extracting only a number of fields and storing it inside an <code>std::vector</code>.</li>
<li><strong>find_tweet</strong>: Find a tweet inside the dataset with a specific ID.</li>
<li><strong>distinct_user_id</strong>: Collect all unique user IDs inside the dataset and store it inside an <code>std::vector&lt;uint64_t&gt;</code>.</li>
</ol>
<p dir="auto">While these tasks are intended to compare JSON parsing performance, they represent real patterns inside applications in which data might be queried.</p>
<p dir="auto">Text formats do not contain enough information for a parser to know the structure of the document immediately.
This structure must be &#39;discovered&#39; by finding brackets, commas, semicolons etc.
Through this process, the parser acquires information necessary for traversal.
An unfortunate result of this, is that typically the entire dataset must be fed through the CPU, even if a query is only interested in a subset or single field.</p>
<p dir="auto">A zero-copy format will approach each problem in a different way.
It already contains all the information necessary to find internal fields.
Only some index structure is required, along with fields of interest. The rest of the dataset is irrelevant to the CPU and might never even enter cache.
Therefore to answer a query like &#39;find tweet by ID&#39;, the actual bytes read may be counted only in the hundreds or low thousands out of ~632 kB.</p>
<p dir="auto">Converting the dataset to Lite³ (a zero-copy format) to answer the exact same queries
presents an opportunity to quantify this advantage and reveal something about the cost of text formats.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://palomakop.tv/fastserial/lite3/blob/main/img/lite3_benchmark_simdjson_twitter_api_data.png"><img src="https://palomakop.tv/fastserial/lite3/raw/main/img/lite3_benchmark_simdjson_twitter_api_data.png" alt=""/></a></p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Format</th>
<th>top_tweet</th>
<th>partial_tweets</th>
<th>find_tweet</th>
<th>distinct_user_id</th>
</tr>
</thead>
<tbody>
<tr>
<td>yyjson</td>
<td>205426 ns</td>
<td>-</td>
<td>203147 ns</td>
<td>207233 ns</td>
</tr>
<tr>
<td>simdjson On-Demand</td>
<td>91184 ns</td>
<td>91090 ns</td>
<td>53937 ns</td>
<td>85036 ns</td>
</tr>
<tr>
<td>simdjson DOM</td>
<td>147264 ns</td>
<td>153397 ns</td>
<td>143567 ns</td>
<td>150541 ns</td>
</tr>
<tr>
<td>RapidJSON</td>
<td>1081987 ns</td>
<td>1091551 ns</td>
<td>1075215 ns</td>
<td>1085541 ns</td>
</tr>
<tr>
<td>Lite³ Context API</td>
<td>2285 ns</td>
<td>17820 ns</td>
<td>456 ns</td>
<td>11869 ns</td>
</tr>
<tr>
<td>Lite³ Buffer API</td>
<td>2221 ns</td>
<td>17659 ns</td>
<td>448 ns</td>
<td>11699 ns</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto"><strong>To be clear: the other formats are parsing JSON.</strong></p>
<p dir="auto">This benchmark is open source and can be replicated <a href="https://github.com/fastserial/simdjson">here</a>.</p>

<p dir="auto"><a href="https://github.com/kostya/benchmarks">A somewhat popular benchmark</a> comparing the performance of different programming languages.
In the JSON category, a ~115 MB JSON document is generated consisting of many floating point numbers representing coordinates.
The program will be timed for how long it takes to sum all the numbers.</p>
<p dir="auto">The aim for this test is similar: quantifying the advantage of a zero-copy format.
This time, reading the entire dataset is unavoidable to produce a correct result.
So instead, the emphasis will be on text-to-binary conversion.
Because Lite³ stores numbers natively in 64 bits, there is no need to parse and convert ASCII-decimals.
This conversion can be tricky for floating point numbers in particular.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://palomakop.tv/fastserial/lite3/blob/main/img/lite3_benchmark_kostya_json_execution_time.png"><img src="https://palomakop.tv/fastserial/lite3/raw/main/img/lite3_benchmark_kostya_json_execution_time.png" alt=""/></a>
<a target="_blank" rel="noopener noreferrer" href="https://palomakop.tv/fastserial/lite3/blob/main/img/lite3_benchmark_kostya_json_memory_usage.png"><img src="https://palomakop.tv/fastserial/lite3/raw/main/img/lite3_benchmark_kostya_json_memory_usage.png" alt=""/></a></p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Language / Library</th>
<th>Execution Time</th>
<th>Memory Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td>C++/g++ (DAW JSON Link)</td>
<td>0.094 s</td>
<td>113 MB</td>
</tr>
<tr>
<td>C++/g++ (RapidJSON)</td>
<td>0.1866 s</td>
<td>238 MB</td>
</tr>
<tr>
<td>C++/g++ (gason)</td>
<td>0.1462 s</td>
<td>209 MB</td>
</tr>
<tr>
<td>C++/g++ (simdjson DOM)</td>
<td>0.1515 s</td>
<td>285 MB</td>
</tr>
<tr>
<td>C++/g++ (simdjson On-Demand)</td>
<td>0.0759 s</td>
<td>173 MB</td>
</tr>
<tr>
<td>C/gcc (lite3)</td>
<td>0.027 s</td>
<td>203 MB</td>
</tr>
<tr>
<td>C/gcc (lite3_context_api)</td>
<td>0.027 s</td>
<td>203 MB</td>
</tr>
<tr>
<td>Go (Sonic)</td>
<td>0.2246 s</td>
<td>121 MB</td>
</tr>
<tr>
<td>Rust (Serde Custom)</td>
<td>0.113 s</td>
<td>111 MB</td>
</tr>
<tr>
<td>Zig</td>
<td>0.2493 s</td>
<td>147 MB</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto"><strong>To be clear: the other formats are parsing JSON.</strong></p>
<p dir="auto">This benchmark is open source and can be replicated <a href="https://github.com/fastserial/kostya-benchmark">here</a>.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Cpp Serialization Benchmark</h3><a id="user-content-cpp-serialization-benchmark" aria-label="Permalink: Cpp Serialization Benchmark" href="#cpp-serialization-benchmark"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">It is to be expected that binary formats will perform well compared to text formats.
The comparison however is not entirely unwarranted.
Pure binary formats present another category, typically requiring schema files and extra tooling.
They are chosen by those who value performance over other considerations.
In doing so, trade-offs are made in usability and flexibility.</p>
<p dir="auto">Lite³ also being a binary format, rather opts for a schemaless design.
This produces a more balanced set of trade-offs with the notable feature of JSON-compatibility.</p>
<p dir="auto">Performance of course will remain a strong selling point.
This next benchmark originates from the <a href="https://github.com/felixguendling/cpp-serialization-benchmark">Cista++ serialization library</a> to compare several binary formats, including zero-copy formats.
The measurements cover the time required to serialize, deserialize and traverse a graph consisting of nodes and edges.
The Cista++ authors created three variants for their format, notably the &#39;offset&#39; and &#39;offset slim&#39; variants
where the edges use indices to reference nodes instead of pointers.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://palomakop.tv/fastserial/lite3/blob/main/img/lite3_benchmark_cpp_serialization.png"><img src="https://palomakop.tv/fastserial/lite3/raw/main/img/lite3_benchmark_cpp_serialization.png" alt=""/></a></p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Name</th>
<th>Serialize + Deserialize</th>
<th>Deserialize</th>
<th>Serialize</th>
<th>Traverse</th>
<th>Deserialize and traverse</th>
<th>Message size</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cap’n Proto</td>
<td><strong>66.55 ms</strong></td>
<td>0 ms</td>
<td>66.55 ms</td>
<td>210.1 ms</td>
<td>211 ms</td>
<td>50.5093 MB</td>
</tr>
<tr>
<td>cereal</td>
<td><strong>229.16 ms</strong></td>
<td>98.76 ms</td>
<td>130.4 ms</td>
<td>79.17 ms</td>
<td>180.7 ms</td>
<td>37.829 MB</td>
</tr>
<tr>
<td>Cista++ (offset)</td>
<td><strong>913.2 ms</strong></td>
<td>274.1 ms</td>
<td>639.1 ms</td>
<td>79.59 ms</td>
<td>80.02 ms</td>
<td>176.378 MB</td>
</tr>
<tr>
<td>Cista++ (offset slim)</td>
<td><strong>3.96 ms</strong></td>
<td>0.17 ms</td>
<td>3.79 ms</td>
<td>79.99 ms</td>
<td>80.46 ms</td>
<td>25.317 MB</td>
</tr>
<tr>
<td>Cista++ (raw)</td>
<td><strong>947.4 ms</strong></td>
<td>289.2 ms</td>
<td>658.2 ms</td>
<td>81.53 ms</td>
<td>113.3 ms</td>
<td>176.378 MB</td>
</tr>
<tr>
<td>Flatbuffers</td>
<td><strong>1887.49 ms</strong></td>
<td>41.69 ms</td>
<td>1845.8 ms</td>
<td>90.53 ms</td>
<td>90.35 ms</td>
<td>62.998 MB</td>
</tr>
<tr>
<td>Lite³ Buffer API</td>
<td><strong>7.79 ms</strong></td>
<td>4.77 ms</td>
<td>3.02 ms</td>
<td>79.39 ms</td>
<td>84.92 ms</td>
<td>38.069 MB</td>
</tr>
<tr>
<td>Lite³ Context API</td>
<td><strong>7.8 ms</strong></td>
<td>4.76 ms</td>
<td>3.04  ms</td>
<td>79.59 ms</td>
<td>84.13 ms</td>
<td>38.069 MB</td>
</tr>
<tr>
<td>zpp::bits</td>
<td><strong>4.66 ms</strong></td>
<td>1.9 ms</td>
<td>2.76 ms</td>
<td>78.66 ms</td>
<td>81.21 ms</td>
<td>37.8066 MB</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">This benchmark is open source and can be replicated <a href="https://github.com/fastserial/cpp-serialization-benchmark">here</a>.</p>

<p dir="auto">Lite³ is designed to handle untrusted messages. Being a pointer chasing format, special attention is paid to security. Some measures include:</p>
<ul dir="auto">
<li>Pointer dereferences preceded by overflow-protected bounds checks.</li>
<li>Runtime type safety.</li>
<li>Max recursion limits.</li>
<li>Generational pointer macro to prevent dangling pointers into Lite³ buffers.</li>
</ul>
<p dir="auto">If you suspect to have found a security vulnerability, please <a href="mailto:elias@fastserial.com">contact the developer</a>.</p>

<p dir="auto"><strong>Q: Should I use this instead of JSON in my favorite programming language?</strong></p>
<p dir="auto"><strong>Q: Should I use this instead of Protocol Buffers (or any other binary format)?</strong></p>
<p dir="auto"><strong>Q: Can I use this in production?</strong></p>
<p dir="auto"><strong>Q: Can I use this in embedded / ARM?</strong></p>

<ul>
<li> Optimize build and add support for <code>-flto</code></li>
<li> Built-in defragmentation with GC-index</li>
<li> Full JSON interoperability with arrays &amp; nested objects</li>
<li> Opt-out compilation flag for <code>yyjson</code></li>
<li> Handling key collisions</li>
<li> Size benchmark for compression ratios using different codecs</li>
<li> Add language bindings</li>
<li> Write formal spec</li>
</ul>

<p dir="auto">If you would like to be part of developer discussions with the project author, consider joining the mailing list:</p>
<p dir="auto"><code>devlist@fastserial.com</code></p>
<p dir="auto">To join, <a href="mailto:devlist-subscribe@fastserial.com">send a mail</a> to <code>devlist-subscribe@fastserial.com</code> with non-empty subject.
You will receive an email with instructions to confirm your subscription.</p>
<p dir="auto">Reply is set to the entire list, though with moderation enabled.</p>
<p dir="auto">To quit the mailing list, simply mail <code>devlist-unsubscribe@fastserial.com</code></p>

<p dir="auto">This project was inspired by a paper published in 2024 as <em>Lite²</em>:</p>
<blockquote>
<p dir="auto">Tianyi Chen †, Xiaotong Guan †, Shi Shuai †, Cuiting Huang † and Michal Aibin †</p>
</blockquote>
<p dir="auto">A serialization format is described where all entries are organized as key-value pairs inside of a B-tree. The paper authors got their idea from SQL databases. They noticed how it is possible to insert arbitrary keys, therefore being schemaless. Also, performing a key lookup can be done without loading the entire DB in memory, thus being zero-copy.</p>
<p dir="auto">They theorized that it would be possible to remove all the overhead associated with a full-fledged database system, such that it would be lightweight enough to be used as a serialization format. They chose the name <em>Lite²</em> since their format is lighter than SQLite.</p>
<p dir="auto">The Lite³ project is an independent interpretation and implementation, with no affiliations or connections to the authors of the original Lite² paper.</p>

<p dir="auto">The name <strong>Lite³</strong> was chosen since it is lighter than Lite².</p>
<blockquote>
<p dir="auto">TIP: To type <code>³</code> on your keyboard on Linux hold <code>Ctrl</code>+<code>Shift</code>+<code>U</code> then type <code>00B3</code>. On Windows, use <code>Alt</code>+(numpad)<code>0179</code>.</p>
</blockquote>

<p dir="auto">Lite³ is released under the MIT License. Refer to the LICENSE file for details.</p>
<p dir="auto">For JSON conversion, Lite³ also includes <code>yyjson</code>, the fastest JSON library in C.
<code>yyjson</code> is written by YaoYuan and also released under the MIT License.</p>
<p dir="auto">@tableofcontents</p>
<section data-footnotes="">
<ol dir="auto">
<li id="user-content-fn-1-d3dfdd2a911448e11b35672261b9d755">
<p dir="auto">Zero-copy reads: The ability to perform arbitrary lookups inside the structure without deserializing or parsing it first. <a href="#user-content-fnref-1-d3dfdd2a911448e11b35672261b9d755" data-footnote-backref="" aria-label="Back to reference 1">↩</a></p>
</li>
<li id="user-content-fn-2-d3dfdd2a911448e11b35672261b9d755">
<p dir="auto">Zero-copy writes: The ability to perform arbitrary mutations inside the structure without deserializing or parsing it first. <a href="#user-content-fnref-2-d3dfdd2a911448e11b35672261b9d755" data-footnote-backref="" aria-label="Back to reference 2">↩</a></p>
</li>
<li id="user-content-fn-3-d3dfdd2a911448e11b35672261b9d755">
<p dir="auto">To be considered human-readable, all necessary information must be provided in-band (no outside schema). <a href="#user-content-fnref-3-d3dfdd2a911448e11b35672261b9d755" data-footnote-backref="" aria-label="Back to reference 3">↩</a></p>
</li>
<li id="user-content-fn-4-d3dfdd2a911448e11b35672261b9d755">
<p dir="auto">Protobuf can optionally send messages in &#39;ProtoJSON&#39; format for debugging, but in production systems they are still sent as binary and not inspectable without schema. Other binary formats also support similar features, however we do not consider these formats &#39;human-readable&#39; since they rely on out-of-band information. <a href="#user-content-fnref-4-d3dfdd2a911448e11b35672261b9d755" data-footnote-backref="" aria-label="Back to reference 4">↩</a></p>
</li>
<li id="user-content-fn-5-d3dfdd2a911448e11b35672261b9d755">
<p dir="auto">Flexbuffer access to scalars and vectors is <code>O(1)</code> (ints, floats, etc.). For maps, access is <code>O(log n)</code>. <a href="#user-content-fnref-5-d3dfdd2a911448e11b35672261b9d755" data-footnote-backref="" aria-label="Back to reference 5">↩</a></p>
</li>
</ol>
</section>
</article></div></div>
  </body>
</html>
