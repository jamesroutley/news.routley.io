<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.orange.tw/posts/2025-01-worstfit-unveiling-hidden-transformers-in-windows-ansi/">Original</a>
    <h1>WorstFit: Unveiling Hidden Transformers in Windows ANSI</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <p><img src="https://blog.orange.tw/posts/2025-01-worstfit-unveiling-hidden-transformers-in-windows-ansi/fb7a21f99453ce05667ddab5a.jpg" alt="preview"/></p>
<p><em>📌 This is a cross-post from <a target="_blank" rel="noopener" href="https://devco.re/blog/2025/01/09/worstfit-unveiling-hidden-transformers-in-windows-ansi">DEVCORE</a>. The research was first published at <a target="_blank" rel="noopener" href="https://www.blackhat.com/eu-24/briefings/schedule/index.html#worstfit-unveiling-hidden-transformers-in-windows-ansi-42637">Black Hat Europe 2024</a>. Personally, I would like to thank <a target="_blank" rel="noopener" href="https://x.com/_splitline_">splitline</a>, the co-author of this research &amp; article, whose help and idea were invaluable. Please also give him a big shout-out!</em></p>
<h2 id="TL-DR"><a href="#TL-DR" title="TL;DR"></a>TL;DR</h2><blockquote>
<p>The research unveils a new attack surface in Windows by exploiting <strong>Best-Fit</strong>, an internal charset conversion feature. Through our work, we successfully transformed this feature into several practical attacks, including Path Traversal, Argument Injection, and even RCE, affecting numerous well-known applications!</p>
</blockquote>
<hr/>
<p>Let’s imagine that: you’re a pentester, and your target website is running the following code. Can you pop a <code>calc.exe</code> with that? <!-- You can have a quick try on your own. --></p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>&lt;?php</span></span></pre></td></tr></tbody></table></figure>

<p>You can have a quick try on your own. The PHP code uses a secure way to spawn the command. Looks a bit hard, right?</p>
<p>Well, today, we would like to present a new technique to break through it!</p>
<h2 id="Outline"><a href="#Outline" title="Outline"></a>Outline</h2><ul>
<li><a href="#outline">Outline</a></li>
<li><a href="#Decoding-the-Windows-Encodings">Decoding the Windows Encodings</a><ul>
<li><a href="#The-Early-Days-ANSI-and-Code-Pages">The Early Days: ANSI and Code Pages</a></li>
<li><a href="#The-Unicode-Era-UTF-16">The Unicode Era: UTF-16</a></li>
<li><a href="#The-Dual-Era-of-Encoding">The Dual Era of Encoding</a></li>
</ul>
</li>
<li><a href="#It-was-the-Best-of-Fit">It was the Best of Fit</a></li>
<li><a href="#It-was-the-Worst-of-Fit-%E2%80%93-The-novel-attack-surface-on-Windows">It was the Worst of Fit – The novel attack surface on Windows</a><ul>
<li><a href="#%F0%9F%94%A5-The-nightmare-of-East-Asia-CVE-2024-4577">🔥 The nightmare of East-Asia - CVE-2024-4577</a></li>
<li><a href="#%F0%9F%94%A5-Filename-Smuggling">🔥 Filename Smuggling</a></li>
<li><a href="#%F0%9F%94%A5-Argument-Splitting">🔥 Argument Splitting</a></li>
<li><a href="#-environment-variable-confusion">🔥 Environment Variable Confusion</a></li>
</ul>
</li>
<li><a href="#The-Dusk%E2%80%93or-Dawn%E2%80%93of-the-WorstFit">The Dusk–or Dawn–of the WorstFit</a></li>
<li><a href="#Epilogue">Epilogue</a><ul>
<li><a href="#Mitigations">Mitigations</a></li>
<li><a href="#Conclusion">Conclusion</a></li>
</ul>
</li>
</ul>
<h2 id="Decoding-the-Windows-Encodings"><a href="#Decoding-the-Windows-Encodings" title="Decoding the Windows Encodings"></a>Decoding the Windows Encodings</h2><p>If you are a Windows user, you’re probably aware that the Windows operating system supports Unicode. This means we can seamlessly put emojis ✅, áccènted letters, 𝒻𝒶𝓃𝒸𝓎 𝕤𝕪𝕞𝕓𝕠𝕝𝕤 and CJK <abbr title="CHARACTERS">匚卄八尺八匚ㄒヨ尺丂</abbr> pretty much anywhere — like file names, file contents, or even environment variables. But have you ever wondered how Windows manages to handle those non-ASCII characters?</p>
<p>Well, to describe this, let’s dive into the history of encoding in Windows first to understand how it handles.</p>
<p><img src="https://blog.orange.tw/posts/2025-01-worstfit-unveiling-hidden-transformers-in-windows-ansi/fb7a21f99453ce05667ddab2e.png"/></p>
<h3 id="The-Early-Days-ANSI-and-Code-Pages"><a href="#The-Early-Days-ANSI-and-Code-Pages" title="The Early Days: ANSI and Code Pages"></a>The Early Days: ANSI and Code Pages</h3><table>
<thead>
<tr>
<th><strong>Code Page</strong></th>
<th><strong>Language</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1250</td>
<td>Central / Eastern European languages (e.g., Polish, Czech)</td>
</tr>
<tr>
<td>1251</td>
<td>Cyrillic-based languages (e.g., Russian, Bulgarian)</td>
</tr>
<tr>
<td>1252</td>
<td>Western European languages (e.g., English, German, French)</td>
</tr>
<tr>
<td>1253</td>
<td>Greek</td>
</tr>
<tr>
<td>1254</td>
<td>Turkish</td>
</tr>
<tr>
<td>1255</td>
<td>Hebrew</td>
</tr>
<tr>
<td>1256</td>
<td>Arabic</td>
</tr>
<tr>
<td>1257</td>
<td>Baltic languages (e.g., Estonian, Latvian, Lithuanian)</td>
</tr>
<tr>
<td>1258</td>
<td>Vietnamese</td>
</tr>
<tr>
<td>932</td>
<td>Japanese</td>
</tr>
<tr>
<td>936</td>
<td>Simplified Chinese</td>
</tr>
<tr>
<td>949</td>
<td>Korean</td>
</tr>
<tr>
<td>950</td>
<td>Traditional Chinese</td>
</tr>
<tr>
<td>874</td>
<td>Thai</td>
</tr>
</tbody></table>
<p>Windows initially used ANSI encoding, which relied on code pages such as the one shown above. It used 8 to 16 bits to represent a single character. While these mappings were effective for certain languages, they were unable to accommodate mixed or universal character sets.</p>
<p>For instance, back in the day, as a Taiwanese, if my Japanese friend sent me an article written on their Windows computer, I’d probably end up with a scrambled mess of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Mojibake">mojibake</a> because my code page 950 system couldn’t properly interpret the Japanese 932 code page.</p>
<p>To handle different encoding needs, Windows doesn’t rely on just one type of code page — there are actually two:</p>
<ul>
<li><strong>ACP</strong> (ANSI Code Page): Used for most applications and system settings, such as file operations or managing environment variables. Our research here primarily focuses on this type of code page, as it significantly impacts the scenarios we’ll examine.</li>
<li><strong>OEMCP</strong> (Original Equipment Manufacturer Code Page): Mainly used for device communication, such as reading or writing to the console.</li>
</ul>
<p>To check which ACP (ANSI code page) you’re using, consider these methods:</p>
<ol>
<li><strong>Using PowerShell</strong>   <figure><table><tbody><tr><td><pre><span>1</span><br/></pre></td><td><pre><span>powershell.exe [<span>Console</span>]::OutputEncoding.WindowsCodePage</span><br/></pre></td></tr></tbody></table></figure></li>
<li><strong>From the Registry</strong>   <figure><table><tbody><tr><td><pre><span>1</span><br/></pre></td><td><pre><span>reg query HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Nls\CodePage /v ACP</span><br/></pre></td></tr></tbody></table></figure></li>
</ol>
<p>Additionally, you might also heard of <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/chcp"><code>chcp</code></a>. However, be aware that <code>chcp</code> displays the <strong>OEMCP</strong>  rather than the ACP, which is the focus of our research here.</p>
<h3 id="The-Unicode-Era-UTF-16"><a href="#The-Unicode-Era-UTF-16" title="The Unicode Era: UTF-16"></a>The Unicode Era: UTF-16</h3><p>To address the limitations of code pages, Windows transitioned to Unicode in the mid-1990s. Unlike code pages, Unicode could represent characters from nearly all languages in a single standard.</p>
<p>Initially, Windows used UCS-2 for Unicode but soon upgraded to <strong>UTF-16</strong>, which uses 16 bits for most characters and expands to 32 bits for rarer ones (e.g., emojis, ancient scripts). Windows also switched to <strong>wide characters</strong> for core APIs like file systems, system information, and text processing.</p>
<p>Now you might be wondering: Hey, what about the most popular Unicode encoding nowadays: <strong>UTF-8</strong>? Well, it’s already there, but still in a sort of beta phase. For most languages, the UTF-8 feature sadly isn’t enabled by default.</p>
<p><img src="https://blog.orange.tw/posts/2025-01-worstfit-unveiling-hidden-transformers-in-windows-ansi/e330dc0d5ca8487bae61ecd08.png"/></p>
<h3 id="The-Dual-Era-of-Encoding"><a href="#The-Dual-Era-of-Encoding" title="The Dual Era of Encoding"></a>The Dual Era of Encoding</h3><p>Even though Unicode became the backbone of Windows, Windows still need to do what they always do: backward compatible. They still need to support the old ANSI code pages. To achieve this, Windows implemented two different versions of APIs:</p>
<ul>
<li><strong>ANSI APIs</strong>: A Windows code page version with the letter “A” postfix used to indicate “ANSI”. For example, <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/processenv/nf-processenv-getenvironmentvariablea"><code>GetEnvironmentVariableA</code></a> function.</li>
<li><strong>Unicode APIs</strong>: A Unicode version with the letter “W” postfix used to indicate “wide (character)”. For example, <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/processenv/nf-processenv-getenvironmentvariablew"><code>GetEnvironmentVariableW</code></a> function.</li>
</ul>
<p>This approach allows developers to easily obtain their desired data format by simply switching between the A-postfix and W-postfix APIs.</p>
<p>It sounds perfect – But wait, so how can a wide character UTF-16 string also be in the ANSI format? Aren’t they fundamentally different?</p>
<p>To illustrate this, let’s explore an example. Imagine we’re on an English (<strong>Windows-1252</strong> code page) system with an environment variable <code>ENV=Hello</code> stored in the system. The data is internally stored as <strong>UTF-16</strong> (wide character format), but we can retrieve it using both Unicode and ANSI APIs:</p>
<ul>
<li><strong>Unicode API</strong>: <code>GetEnvironmentVariableW(L&#34;ENV&#34;)</code> ⭢ <code>L&#34;Hello&#34;</code> (Hex: <code>4800 6500 6C00 6C00 6F00</code> in UTF-16LE).  </li>
<li><strong>ANSI API</strong>: <code>GetEnvironmentVariableA(&#34;ENV&#34;)</code> — <code>RtlUnicodeStringToAnsiString</code> ⭢ <code>&#34;Hello&#34;</code> (Hex: <code>48 65 6C 6C 6F</code> in ANSI).</li>
</ul>
<p>For the <strong>Unicode API</strong>, there’s no problem—Unicode in, Unicode out, with no conversion needed. For the <strong>ANSI API</strong>, Windows applies an implicit conversion by calling <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-rtlunicodestringtoansistring"><code>RtlUnicodeStringToAnsiString</code></a> (or sometimes <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-widechartomultibyte"><code>WideCharToMultiByte</code></a>) to convert the original Unicode string to an ANSI string. Since <code>&#34;Hello&#34;</code> consists only of ASCII characters, everything works perfectly and as expected. </p>
<p>But what happens if the environment variable contains a more complex string, like <strong><code>√π⁷≤∞</code></strong>, with a lot of non-ASCII characters?</p>
<ul>
<li><strong>Unicode API</strong>: <code>GetEnvironmentVariableW(L&#34;ENV&#34;)</code> ⭢ <code>L&#34;√π⁷≤∞&#34;</code> (Hex: <code>1a22 c003 7720 6422 1e22</code> in UTF-16LE).</li>
</ul>
<p>The <strong>Unicode API</strong> correctly returns the original string as we expected. </p>
<p>Now, what happens with the ANSI API? Are you able to guess the result?</p>
<ul>
<li><strong>ANSI API</strong>: <code>GetEnvironmentVariableA(&#34;ENV&#34;)</code> — <code>RtlUnicodeStringToAnsiString</code> ⭢ <code>&#34;vp7=8&#34;</code> (Hex: <code>76 70 37 3D 38</code> in ANSI) 🤯</li>
</ul>
<p>Yep, the output is <strong><code>vp7=8</code></strong>. A strange result, right? I guess you can’t even figure out the connection between the original characters and their character codes!</p>
<p>This bizarre transformation is what’s known as <strong>“Best-Fit”</strong> behavior. As a result, the original string <code>√π⁷≤∞</code> transforms into a nonsensical <code>&#34;vp7=8&#34;</code>. This behavior highlights the pitfalls of relying on ANSI APIs when handling non-ASCII characters.</p>
<p>And actually, it’s not just when using Windows APIs directly — this behaviour also occurs when using non-wide-character version CRT (C runtime) functions like <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/getenv-wgetenv"><code>getenv</code></a>. Surprisingly, even when you receive arguments or environment variables through a seemingly straightforward non-wide-character <code>main</code> function like:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>#<span>include</span> <span>&lt;stdio.h&gt;</span></span></span></pre></td></tr></tbody></table></figure>

<p>The same Best-Fit behavior applies to both the arguments and the environment variables. Here’s what happens when we run this code:</p>
<p><img src="https://blog.orange.tw/posts/2025-01-worstfit-unveiling-hidden-transformers-in-windows-ansi/fb7a21f99453ce05667ddab57.png"/></p>
<p>This happens because, during compilation, the compiler inserts several functions and links the CRT DLLs for you, which internally rely on ANSI Windows APIs. As a result, the same Best-Fit behavior is triggered implicitly.</p>
<p>We keep talking about Best-Fit, but how does this quirky behavior actually work in the end?</p>
<h2 id="It-was-the-Best-of-Fit"><a href="#It-was-the-Best-of-Fit" title="It was the Best of Fit"></a>It was the Best of Fit</h2><p>In Windows, “Best-Fit” character conversion is a way the operating system handles situations where it needs to convert characters from UTF-16 to ANSI, but the exact character doesn’t exist in the target code page. </p>
<p>For instance, the <code>∞</code> (<a target="_blank" rel="noopener" href="https://www.compart.com/en/unicode/U+221E">U+221E</a>) symbol isn’t part of the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Windows-1252#Codepage_layout">Windows-1252 code page</a>, so Microsoft decided to map it to the “<strong>closest</strong>“ character—<code>8</code> (<a target="_blank" rel="noopener" href="https://worst.fit/mapping/#CP%3A1252%20FROM%3A0x221e">🔍</a>). Uh, okay. Yeah I guess they kinda look similar, but I thought they should be still completely different things…</p>
<p>Anyway, obviously there’s no strict formula for Best-Fit mapping – what Microsoft do is more about making characters look, or even “feel” somewhat alike.</p>
<p>Also, different language configurations (code pages) handle mappings differently. For instance, the yen sign (<code>U+00A5</code>) is mapped to a backslash (<code>\</code>) on the Japanese (932) code page, to a “Y” on the Central European (1250) code page, and remains unchanged on most other code pages. This variability will play a significant role in how exploits behave across different system settings. </p>
<p>If you’re curious about the specifics, you can check out our <a target="_blank" rel="noopener" href="https://worst.fit/mapping/">Best-fit Mapping Grepper</a> tool or dive into the raw mapping data on <a target="_blank" rel="noopener" href="https://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WindowsBestFit/readme.txt">Unicode.org</a> by yourself.</p>
<p>Interestingly, during our research we found that this <strong>Best-Fit</strong> behavior was already mentioned back in Black Hat USA 2009 during Chris Weber’s presentation, <a target="_blank" rel="noopener" href="https://www.blackhat.com/presentations/bh-usa-09/WEBER/BHUSA09-Weber-UnicodeSecurityPreview-SLIDES.pdf">“Unicode Security”</a>. However, he only briefly touched on how this feature could be exploited to bypass simple blacklist.</p>
<p>But this time, we’re taking big steps forward – showing how those sneaky Best-Fit conversions can operate on a <strong>system-wide level</strong>, leading to even more impactful exploits, all unfolding right under your nose.</p>
<p>Now, it’s time to turn this quirky behaviour into something more impactful: <strong>real WorstFit vulnerabilities</strong>.</p>
<h2 id="It-was-the-Worst-of-Fit-–-The-novel-attack-surface-on-Windows"><a href="#It-was-the-Worst-of-Fit-–-The-novel-attack-surface-on-Windows" title="It was the Worst of Fit – The novel attack surface on Windows"></a>It was the Worst of Fit – The novel attack surface on Windows</h2><p>By delving into the Best-Fit feature, we can harness this unexpected character transformation as a brand-new attack surface on Windows systems. Here, we’ll explore three intriguing attack techniques that exploit this behavior: <strong>Filename Smuggling</strong>, <strong>Argument Splitting</strong> and <strong>Environment Variable Confusion</strong>.</p>
<p>Let’s dive into each of these techniques to see how this seemingly thoughtful (at least, from Microsoft’s perspective at the time) feature can lead to critical vulnerabilities!</p>
<h3 id="🔥-The-nightmare-of-East-Asia-CVE-2024-4577"><a href="#🔥-The-nightmare-of-East-Asia-CVE-2024-4577" title="🔥 The nightmare of East-Asia - CVE-2024-4577"></a>🔥 The nightmare of East-Asia - CVE-2024-4577</h3><p>The first ever WorstFit attack is CVE-2024-4577. This vulnerability allows attackers to compromise any PHP-CGI server configured with Chinese or Japanese code pages using nothing more than a <code>?%ADs</code> request!</p>
<p>➡️ <strong>Affected Code Pages</strong>: 932 (Japanese), 936 (Simplified Chinese), 950 (Traditional Chinese)</p>
<p>Back in 2012, a vulnerability in PHP-CGI was discovered. The issue stemmed from Apache automatically treating the query string as the first argument for the CGI program. Exploitation was straightforward – argument injection. By appending <code>?-s</code> to a request, attackers could leak the page’s source code. Furthermore, it’s also possible to achieve Remote Code Execution (RCE).</p>
<p>Of course, PHP quickly patched the issue. The fix was also simple: stop parsing arguments if the query string starts with a dash.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>if</span>((qs = <span>getenv</span>(<span>&#34;QUERY_STRING&#34;</span>)) != <span>NULL</span> &amp;&amp; <span>strchr</span>(qs, <span>&#39;=&#39;</span>) == <span>NULL</span>) {</span></pre></td></tr></tbody></table></figure>

<p>The patch worked well, and no one broke it for the past 12 years. However, while reviewing the patch, we couldn’t help but feel that this blacklist approach seemed weak. After some quick fuzzing, we discovered a simple bypass: appending <code>?%ADs</code> to the query string effortlessly!</p>
<p>As investigating more, we discovered that U+00AD (soft hyphen) is mapped to a dash (-) on Chinese (936, 950) and Japanese (932) code pages due to <strong>Best-Fit</strong> behavior, which explains how the bypass works. </p>
<p>This is the first time we’ve encountered the term “Best-Fit”. We found it super interesting, which motivated us to take a deeper look.</p>
<h3 id="🔥-Filename-Smuggling"><a href="#🔥-Filename-Smuggling" title="🔥 Filename Smuggling"></a>🔥 Filename Smuggling</h3><p>The next attack we would like to introduce is the WorstFit in the filename processing. Here, we focus on characters that mapped to either <strong>“/“ (0x2F)</strong> or <strong>“\“ (0x5C)</strong>, such as the currency symbol <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Won_sign">Yen (¥)</a>, and <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Yen_and_yuan_sign">Won (₩)</a> used in Japanese and Korean Code Pages, as well as the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Halfwidth_and_Fullwidth_Forms_(Unicode_block)">fullwidth</a> version of the (back-)slash in most Code Pages. You can check the affected characters and Code Pages on our <a target="_blank" rel="noopener" href="https://worst.fit/mapping/">Best-fit Mapping Grepper</a> tool!</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://worst.fit/mapping/#to%3A0x2f">Characters mapped to “/“ (0x2F)</a></li>
<li><a target="_blank" rel="noopener" href="https://worst.fit/mapping/#to%3A0x5c">Characters mapped to “\“ (0x5C)</a></li>
</ul>
<p>➡️ <strong>Relevant API</strong>: <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcurrentdirectory"><code>GetCurrentDirectoryA</code></a>, <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/getcwd?view=msvc-170"><code>getcwd</code></a>, <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-findfirstfilea"><code>FindFirstFileA</code></a>, <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/findfirst-functions?view=msvc-170"><code>findfirst*</code></a>, <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfullpathnamea"><code>GetFullPathNameA</code></a>, …</p>
<p>Let’s start with a simple case. In Chrome V8, the underlying implementation of its Developer Shell (<code>d8.exe</code>) uses the ANSI API <code>GetCurrentDirectoryA()</code> to obtain the current working directory. This means that if we can have a working direcotry with malicious Unicode characters, these characters will automatically be converted into path traversal payloads when accessed via the ANSI API. As a result, it leads to an unintended file access.</p>
<p><img src="https://blog.orange.tw/posts/2025-01-worstfit-unveiling-hidden-transformers-in-windows-ansi/fb7a21f99453ce05667ddab07.png"/></p>
</div></div>
  </body>
</html>
