<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://taylor.town/scrapscript-000">Original</a>
    <h1>Lil&#39; Fun Langs</h1>
    
    <div id="readability-page-1" class="page"><div><table>
<thead>
<tr>
<th id=""></th>
<th id=""></th>
<th id="loc">LOC</th>
<th id="host">Host</th>
<th id="hm">HM</th>
<th id="adts">ADTs</th>
<th id="match">Match</th>
<th id="cl.">Cl.</th>
<th id="target">Target</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#hirrolots-coc">Hirrolot&#39;s CoC</a></td>
<td><a href="https://gist.github.com/Hirrolot/27e6b02a051df333811a23b97c375196">src</a></td>
<td>~70</td>
<td>OCaml</td>
<td>âœ—</td>
<td>âœ—</td>
<td>âœ—</td>
<td>âœ“</td>
<td>Interpreter</td>
</tr>
<tr>
<td><a href="#harrop-miniml">Harrop MiniML</a></td>
<td><a href="https://gist.github.com/jdh30/6130c615b5945fd57fc0ea74fcb87e05">src</a></td>
<td>~100</td>
<td>OCaml</td>
<td>âœ—</td>
<td>âœ—</td>
<td>âœ—</td>
<td>âœ—</td>
<td>LLVM â†’ native</td>
</tr>
<tr>
<td><a href="#algorithm-w">Algorithm W</a></td>
<td><a href="https://github.com/mgrabmueller/AlgorithmW">src</a></td>
<td>~300</td>
<td>Haskell</td>
<td>âœ“</td>
<td>âœ—</td>
<td>âœ—</td>
<td>âœ—</td>
<td>Type checker only</td>
</tr>
<tr>
<td><a href="#type-systems">tomprimozic/type-systems</a></td>
<td><a href="https://github.com/tomprimozic/type-systems">src</a></td>
<td>~300</td>
<td>OCaml</td>
<td>âœ“</td>
<td>âœ—</td>
<td>âœ—</td>
<td>âœ—</td>
<td>Type checker only</td>
</tr>
<tr>
<td><a href="#lambda-calculus-hs">lambda-calculus-hs</a></td>
<td><a href="https://github.com/solomon-b/lambda-calculus-hs">src</a></td>
<td>~200â€“900</td>
<td>Haskell</td>
<td>âœ—</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>Interpreter</td>
</tr>
<tr>
<td><a href="#thih">THIH</a></td>
<td><a href="https://hackage.haskell.org/package/thih">src</a></td>
<td>~429</td>
<td>Haskell</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ—</td>
<td>Type checker only</td>
</tr>
<tr>
<td><a href="#simple-sub">Simple-sub</a></td>
<td><a href="https://github.com/LPTK/simple-sub">src</a></td>
<td>~500</td>
<td>Scala</td>
<td>âœ“</td>
<td>âœ—</td>
<td>âœ—</td>
<td>âœ“</td>
<td>Type checker only</td>
</tr>
<tr>
<td><a href="#plzoo-poly">PLZoo <code>poly</code></a></td>
<td><a href="https://github.com/andrejbauer/plzoo">src</a></td>
<td>~500</td>
<td>OCaml</td>
<td>âœ“</td>
<td>âœ—</td>
<td>âœ—</td>
<td>âœ“</td>
<td>Interpreter</td>
</tr>
<tr>
<td><a href="#eyg">EYG</a></td>
<td><a href="https://github.com/CrowdHailer/eyg-lang">src</a></td>
<td>~500</td>
<td>Gleam</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>Interpreter</td>
</tr>
<tr>
<td><a href="#pico-ml">Pico-ml</a></td>
<td><a href="https://github.com/Quramy/pico-ml">src</a></td>
<td>~500</td>
<td>TypeScript</td>
<td>âœ“</td>
<td>âœ—</td>
<td>âœ—</td>
<td>âœ“</td>
<td>WebAssembly</td>
</tr>
<tr>
<td><a href="#tinyml">TinyML</a></td>
<td><a href="http://lambda-the-ultimate.org/node/2683">src</a></td>
<td>&lt;700</td>
<td>SML</td>
<td>âœ“</td>
<td>âœ—</td>
<td>âœ—</td>
<td>âœ“</td>
<td>Interpreter</td>
</tr>
<tr>
<td><a href="#eff">Eff</a></td>
<td><a href="https://github.com/matijapretnar/eff">src</a></td>
<td>~1â€“2K</td>
<td>OCaml</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>Interpreter</td>
</tr>
<tr>
<td><a href="#frank">Frank</a></td>
<td><a href="https://github.com/frank-lang/frank">src</a></td>
<td>~1â€“2K</td>
<td>Haskell</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>Interpreter</td>
</tr>
<tr>
<td><a href="#grace">Grace</a></td>
<td><a href="https://github.com/Gabriella439/grace">src</a></td>
<td>~1â€“3K</td>
<td>Haskell</td>
<td>âœ“</td>
<td>âœ—</td>
<td>âœ—</td>
<td>âœ“</td>
<td>Interpreter</td>
</tr>
<tr>
<td><a href="#hackett">Hackett</a></td>
<td><a href="https://github.com/lexi-lambda/hackett">src</a></td>
<td>~1â€“3K</td>
<td>Racket</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>Racket runtime</td>
</tr>
<tr>
<td><a href="#scrapscript">Scrapscript</a></td>
<td><a href="https://github.com/tekknolagi/scrapscript">src</a></td>
<td>~1â€“3K</td>
<td>Python</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>C/WASM/Cosmo native</td>
</tr>
<tr>
<td><a href="#mincaml">MinCaml</a></td>
<td><a href="https://github.com/esumii/min-caml">src</a></td>
<td>~2,000</td>
<td>OCaml</td>
<td>âœ“</td>
<td>âœ—</td>
<td>âœ—</td>
<td>âœ“</td>
<td>x86/SPARC/PPC native</td>
</tr>
<tr>
<td><a href="#ben-lynn">Ben Lynn</a></td>
<td><a href="https://github.com/blynn/compiler">src</a></td>
<td>~2,000</td>
<td>Haskell/C</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>Combinators â†’ C VM</td>
</tr>
<tr>
<td><a href="#1ml">1ML</a></td>
<td><a href="https://github.com/rossberg/1ml">src</a></td>
<td>~3â€“5K</td>
<td>OCaml</td>
<td>âœ“</td>
<td>âœ—</td>
<td>âœ—</td>
<td>âœ“</td>
<td>Interpreter</td>
</tr>
<tr>
<td><a href="#mlml">mlml</a></td>
<td><a href="https://github.com/coord-e/mlml">src</a></td>
<td>~3â€“5K</td>
<td>OCaml</td>
<td>âœ—</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>x86-64 native</td>
</tr>
<tr>
<td><a href="#dhall">Dhall</a></td>
<td><a href="https://github.com/dhall-lang/dhall-haskell">src</a></td>
<td>~4K</td>
<td>Haskell</td>
<td>âœ—</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>Normalizer</td>
</tr>
<tr>
<td><a href="#ante">Ante</a></td>
<td><a href="https://github.com/jfecher/ante">src</a></td>
<td>~5â€“10K</td>
<td>Rust</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>Cranelift â†’ native</td>
</tr>
<tr>
<td><a href="#tao">Tao</a></td>
<td><a href="https://github.com/zesterer/tao">src</a></td>
<td>~5â€“10K</td>
<td>Rust</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>Bytecode interpreter</td>
</tr>
<tr>
<td><a href="#austral">Austral</a></td>
<td><a href="https://github.com/austral/austral">src</a></td>
<td>~5â€“10K</td>
<td>OCaml</td>
<td>âœ—</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>C</td>
</tr>
<tr>
<td><a href="#aqaml">AQaml</a></td>
<td><a href="https://github.com/ushitora-anqou/aqaml">src</a></td>
<td>~5â€“8K</td>
<td>OCaml</td>
<td>âœ—</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>x86-64 native</td>
</tr>
<tr>
<td><a href="#borgo">Borgo</a></td>
<td><a href="https://github.com/borgo-lang/borgo">src</a></td>
<td>~5â€“10K</td>
<td>Rust</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>Go source</td>
</tr>
<tr>
<td><a href="#polytt">polytt</a></td>
<td><a href="https://github.com/ToposInstitute/polytt">src</a></td>
<td>~5â€“10K</td>
<td>OCaml</td>
<td>âœ—</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>Interpreter</td>
</tr>
<tr>
<td><a href="#newt">Newt</a></td>
<td><a href="https://github.com/dunhamsteve/newt">src</a></td>
<td>~7K</td>
<td>Newt</td>
<td>âœ—</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>JavaScript</td>
</tr>
<tr>
<td><a href="#hamlet">HaMLet</a></td>
<td><a href="https://github.com/rossberg/hamlet">src</a></td>
<td>~10â€“15K</td>
<td>SML</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>Interpreter</td>
</tr>
<tr>
<td><a href="#sosml">SOSML</a></td>
<td><a href="https://github.com/SOSML/SOSML">src</a></td>
<td>~10â€“15K</td>
<td>TypeScript</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>Browser interpreter</td>
</tr>
<tr>
<td><a href="#microhs">MicroHs</a></td>
<td><a href="https://github.com/augustss/MicroHs">src</a></td>
<td>~15â€“30K</td>
<td>Haskell/C</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>âœ“</td>
<td>Combinators â†’ C/JS</td>
</tr>
</tbody>
</table>

<p>I adore small programming languages.
<a href="https://web.archive.org/web/20181024173237/http://www.nyu.edu/projects/barker/Iota/">Iota</a>
is two combinators.
<a href="https://github.com/Robert-van-Engelen/tinylisp/blob/main/tinylisp.pdf">tinylisp</a>
is 99 lines of C. <a href="https://github.com/fuzzballcat/milliForth">milliForth</a> is 340
<em>bytes</em>. <a href="https://wiki.xxiivv.com/site/fractran.html">Fractran</a> multiplies
fractions. Oh, <a href="https://needleful.net/blog/2024/01/arthur_whitney.html">K</a>?</p>
<p>I&#39;ve encountered tiny implementations of Forth, Lisp, C, Prolog, etc., but never
&#34;milliHaskell&#34;.</p>

<p><a href="https://en.wikipedia.org/wiki/ML_(programming_language)">ML-style</a> languages
carry a pungent monad odor that attracts mathochists. Notable examples include
Haskell, Elm, F#, Scala, and OCaml. They&#39;re &#34;Lambda Calculus with syntactic
sugar&#34;, i.e. <a href="https://en.wikipedia.org/wiki/Functional_programming">functional</a>
and <a href="https://en.wikipedia.org/wiki/Type_system#STATIC">statically-typed</a>. Most
implementations extend
<a href="https://en.wikipedia.org/wiki/Hindleyâ€“Milner_type_system">Hindley-Milner type inference</a>
with <a href="https://en.wikipedia.org/wiki/Abstract_type">algebraic data types</a>,
pattern matching, and closures:</p>
<table>
<thead>
<tr>
<th id="feature">Feature</th>
<th id="loc">LOC</th>
<th id="dependencies">Dependencies</th>
<th id="references">References</th>
</tr>
</thead>
<tbody>
<tr>
<td>Integer arithmetic</td>
<td>~50</td>
<td>Parser, codegen</td>
<td>MinCaml</td>
</tr>
<tr>
<td>Floating-point</td>
<td>~100</td>
<td>Parser, codegen (SSE/NEON)</td>
<td>MinCaml</td>
</tr>
<tr>
<td>Booleans + if/then/else</td>
<td>~50</td>
<td>Parser, codegen</td>
<td>Everything</td>
</tr>
<tr>
<td>Let bindings</td>
<td>~30</td>
<td>Parser, normalization</td>
<td>Everything</td>
</tr>
<tr>
<td>First-class functions (closures)</td>
<td>~200</td>
<td>Closure conversion, runtime</td>
<td>MinCaml</td>
</tr>
<tr>
<td>Recursive functions (let rec)</td>
<td>~50</td>
<td>Type inference (occurs check), codegen</td>
<td>MinCaml</td>
</tr>
<tr>
<td>Tuples</td>
<td>~100</td>
<td>Parser, type inference, codegen</td>
<td>MinCaml</td>
</tr>
<tr>
<td>Arrays</td>
<td>~100</td>
<td>Parser, runtime (bounds checking)</td>
<td>MinCaml</td>
</tr>
<tr>
<td>Monomorphic type inference</td>
<td>~100</td>
<td>Unification</td>
<td>MinCaml</td>
</tr>
<tr>
<td>Polymorphic type inference (HM)</td>
<td>~300</td>
<td>Generalization, instantiation</td>
<td>Algorithm W, PLZoo</td>
</tr>
<tr>
<td>Algebraic data types</td>
<td>~200â€“400</td>
<td>Parser, type checker, runtime (tagging)</td>
<td>HaMLet, Tao</td>
</tr>
<tr>
<td>Pattern matching (basic)</td>
<td>~200</td>
<td>Exhaustiveness check, case trees</td>
<td>Tao, Ante</td>
</tr>
<tr>
<td>Pattern matching (optimized)</td>
<td>~400â€“600</td>
<td>Maranget&#39;s algorithm</td>
<td>OCaml, Rust</td>
</tr>
<tr>
<td>Type classes</td>
<td>~500â€“2000</td>
<td>Dictionary passing, instance resolution</td>
<td>MicroHs, Ben Lynn</td>
</tr>
<tr>
<td>Modules (basic)</td>
<td>~500â€“1000</td>
<td>Namespace management</td>
<td>HaMLet</td>
</tr>
<tr>
<td>Modules (functors/signatures)</td>
<td>~2000â€“5000</td>
<td>Type-level computation</td>
<td>HaMLet, 1ML</td>
</tr>
<tr>
<td>Row polymorphism</td>
<td>~300â€“800</td>
<td>Extended unification</td>
<td>EYG, type-systems</td>
</tr>
<tr>
<td>Algebraic effects</td>
<td>~500â€“1500</td>
<td>Effect typing, runtime support</td>
<td>Eff, Frank, Ante</td>
</tr>
<tr>
<td>Algebraic subtyping</td>
<td>~500</td>
<td>Polar types, biunification</td>
<td>Simple-sub</td>
</tr>
<tr>
<td>Linear types</td>
<td>~600</td>
<td>Linearity checker</td>
<td>Austral</td>
</tr>
<tr>
<td>Lazy evaluation</td>
<td>~300â€“500</td>
<td>Thunks, memoization runtime</td>
<td>MicroHs, Ben Lynn</td>
</tr>
<tr>
<td>Garbage collection (Cheney)</td>
<td>~200</td>
<td>Runtime system</td>
<td>Most</td>
</tr>
<tr>
<td>Tail call optimization</td>
<td>~50â€“100</td>
<td>Codegen (jump instead of call)</td>
<td>MinCaml</td>
</tr>
<tr>
<td>Inline expansion</td>
<td>~100</td>
<td>Normalization pass</td>
<td>MinCaml</td>
</tr>
<tr>
<td>Dead code elimination</td>
<td>~50</td>
<td>Free variable analysis</td>
<td>MinCaml</td>
</tr>
<tr>
<td>Totality checking</td>
<td>~300â€“500</td>
<td>Coverage analysis, termination checker</td>
<td>Tao, Dhall</td>
</tr>
</tbody>
</table>
<p>Further reading:</p>
<ul>
<li><a href="http://dev.stephendiehl.com/fun/">Write You a Haskell</a> (and
<a href="https://github.com/JKTKops/Write-You-a-Haskell-2">sequel</a>): builds a Haskell
subset incrementally: lambda calculus â†’ STLC â†’ HM inference â†’ ADTs â†’ pattern
matching â†’ type classes â†’ STG â†’ LLVM.</li>
<li><a href="https://www.microsoft.com/en-us/research/publication/implementing-functional-languages-a-tutorial/">Implementing Functional Languages: a tutorial</a>
by Simon Peyton Jones &amp; David Lester: complete implementations of template
instantiation, G-Machine, TIM, and parallel G-Machine for a lazy Core
language.
<a href="https://danilafe.com/blog/00_compiler_intro/">Reimplemented in C++ with LLVM</a>
by Daniel Fedorin.</li>
<li><a href="https://xavierleroy.org/publi/ZINC.pdf">The ZINC experiment</a>: the
foundational paper behind OCaml&#39;s bytecode compiler. The ZINC abstract machine
uses ~140 instructions and 7 registers. Implementations include OMicroB
(running OCaml bytecode on PIC18 microcontrollers with &lt;10KB RAM) and
HardCaml-Zinc (hardware implementation).</li>
<li><a href="https://github.com/AndrasKovacs/elaboration-zoo">Elaboration Zoo</a>:
progressive dependent type checking implementations, each a single Haskell
file of 200â€“800 lines, from basic NbE through holes, implicit arguments, and
first-class polymorphism. The best resource for understanding modern
elaboration. Its companion <a href="https://github.com/AndrasKovacs/smalltt">smalltt</a>
(~1â€“2K LOC Haskell) is a complete dependent type elaborator with
normalization-by-evaluation.</li>
<li><a href="https://en.wikipedia.org/wiki/Modern_Compiler_Implementation_in_ML">Modern Compiler Implementation in ML</a>:
the Tiger language compiler covers every phase from lexing through
graph-coloring register allocation in ~5,000â€“8,000 LOC of SML. Multiple GitHub
implementations target x86-64 and RISC-V.</li>
</ul>
<p>If you want a milliHaskell, all your inspiration/ingredients are right here.</p>
<hr/>
<h2 id="hirrolots-coc">Hirrolot&#39;s CoC</h2>
<blockquote>
  <p>ðŸ¤– The most extreme capability-to-size ratio in this list â€” a complete
  Calculus of Constructions (the type theory at the top of the lambda cube) with
  bidirectional typing, dependent function types, and a type-in-type universe,
  all in a single OCaml gist of ~60â€“80 lines. It can express length-indexed
  vectors and other dependently typed programs. Not ML-family per se, but it
  demonstrates that full dependent types need not be complex to implement.</p>
</blockquote>
<ul>
<li><strong>Gist</strong>:
<a href="https://gist.github.com/Hirrolot/27e6b02a051df333811a23b97c375196">gist.github.com/Hirrolot/27e6b02a051df333811a23b97c375196</a></li>
</ul>
<h2 id="harrop-miniml">Harrop MiniML</h2>
<blockquote>
  <p>ðŸ¤– MiniML demonstrates the absolute floor for a native-code ML compiler. Using
  Camlp4 for parsing and OCaml&#39;s LLVM bindings, it supports integer arithmetic,
  conditionals, and recursive first-order functions. Xavier Leroy noted the
  critical caveat: this is not truly &#34;Mini-ML&#34; since it lacks higher-order
  first-class functions â€” adding closures and garbage collection would
  significantly expand the codebase. Still, it shows what LLVM enables in ~100
  lines.</p>
</blockquote>
<ul>
<li><strong>Gist</strong>:
<a href="https://gist.github.com/jdh30/6130c615b5945fd57fc0ea74fcb87e05">gist.github.com/jdh30/6130c615b5945fd57fc0ea74fcb87e05</a></li>
</ul>
<h2 id="algorithm-w">Algorithm W</h2>
<blockquote>
  <p>ðŸ¤– <strong>Algorithm W Step by Step</strong> by Martin GrabmÃ¼ller (~300 LOC, literate
  Haskell) is the canonical educational implementation of Algorithm W for
  Hindley-Milner type inference. Self-contained, well-commented, and widely
  referenced â€” this is where most people first implement HM inference.</p>
</blockquote>
<ul>
<li><strong>Repo</strong>:
<a href="https://github.com/mgrabmueller/AlgorithmW">github.com/mgrabmueller/AlgorithmW</a></li>
</ul>
<h2 id="type-systems">tomprimozic/type-systems</h2>
<blockquote>
  <p>ðŸ¤– A collection of standalone implementations of several inference algorithms
  in OCaml (~300â€“600 LOC total): basic Algorithm W, <strong>row polymorphism</strong> (the
  technique foundational to Elm&#39;s original type system), and HMF (first-class
  polymorphism with partial inference). Each variant is self-contained in a
  single directory. Where Algorithm W Step by Step teaches you <em>one</em> algorithm
  well, this repository shows you what changes when you swap in more powerful
  type system features.</p>
</blockquote>
<ul>
<li><strong>Repo</strong>:
<a href="https://github.com/tomprimozic/type-systems">github.com/tomprimozic/type-systems</a></li>
</ul>
<h2 id="lambda-calculus-hs">lambda-calculus-hs</h2>
<blockquote>
  <p>ðŸ¤– A progressive collection of single-file lambda calculus implementations in
  Haskell (~200â€“900 LOC each) by Solomon Bothwell. Starts with simply typed
  evaluation and builds incrementally through bidirectional typechecking,
  normalization by evaluation (NbE), System T, records with depth subtyping, and
  nominal inductive types with dependent pattern matching. Each implementation
  is self-contained. Where tomprimozic/type-systems varies the <em>inference
algorithm</em>, this repository varies the <em>type system</em> while keeping
  bidirectional checking as the constant.</p>
</blockquote>
<ul>
<li><strong>Repo</strong>:
<a href="https://github.com/solomon-b/lambda-calculus-hs">github.com/solomon-b/lambda-calculus-hs</a></li>
</ul>
<h2 id="thih">THIH</h2>
<blockquote>
  <p>ðŸ¤– <strong>Typing Haskell in Haskell</strong> by Mark P. Jones is the definitive executable
  specification of Haskell 98&#39;s complete type system in just <strong>429 lines of core
Haskell</strong>. It covers kinds, qualified types, type classes, pattern matching
  types, binding groups, mutual recursion, and defaulting. For context, the Hugs
  type checker implementing the same semantics spans 90+ pages of C. THIH is a
  type checker only (no evaluation), but its density of specification per line
  of code is unmatched.</p>
</blockquote>
<ul>
<li><strong>Paper</strong>: <a href="https://web.cecs.pdx.edu/~mpj/thih/">web.cecs.pdx.edu/~mpj/thih/</a></li>
<li><strong>Hackage</strong>:
<a href="https://hackage.haskell.org/package/thih">hackage.haskell.org/package/thih</a></li>
</ul>
<h2 id="simple-sub">Simple-sub</h2>
<blockquote>
  <p>ðŸ¤– <strong>~500 LOC of Scala.</strong> Lionel Parreaux&#39;s clean reimplementation of Stephen
  Dolan&#39;s MLsub â€” algebraic subtyping that adds union and intersection types to
  Hindley-Milner while preserving principal types. No annotations required. The
  original MLsub won POPL 2017; Simple-sub distills it into an ICFP 2020 Pearl
  that&#39;s small enough to read in one sitting. The ancestor of MLscript, which
  grows the idea into a full language with OOP and TypeScript interop.</p>
</blockquote>
<ul>
<li><strong>Repo</strong>: <a href="https://github.com/LPTK/simple-sub">github.com/LPTK/simple-sub</a></li>
<li><strong>Paper</strong>: &#34;The Simple Essence of Algebraic Subtyping&#34; (ICFP 2020)</li>
</ul>
<h2 id="plzoo-poly">PLZoo <code>poly</code></h2>
<blockquote>
  <p>ðŸ¤– <strong>~400â€“600 LOC, OCaml.</strong> Implements a lazy, purely functional language
  with parametric polymorphism and HM type inference. Its sibling <code>miniml</code>
  (~300â€“500 LOC) includes a compiler targeting an abstract machine. Both are
  part of Andrej Bauer&#39;s Programming Languages Zoo, which contains 12+ miniature
  language implementations, each a few hundred lines of OCaml, covering
  everything from untyped lambda calculus to call-by-push-value.</p>
</blockquote>
<ul>
<li><strong>Website</strong>: <a href="https://plzoo.andrej.com/">plzoo.andrej.com</a></li>
<li><strong>Repo</strong>: <a href="https://github.com/andrejbauer/plzoo">github.com/andrejbauer/plzoo</a></li>
</ul>
<h2 id="eyg">EYG</h2>
<blockquote>
  <p>ðŸ¤– <strong>~500 LOC JavaScript interpreter</strong>, full implementation in Gleam. EYG
  (&#34;Eat Your Greens&#34;) by Peter Saxton prioritizes predictability, portability,
  and crash-free programs. It uses row-typed inference (HM extended with row
  polymorphism), algebraic effects as the sole FFI mechanism, and closure
  serialization â€” functions can be sent to other machines for tierless
  client/server programming. The most distinctive feature: programs are stored
  as JSON ASTs, not text files. A structural editor makes it impossible to write
  syntactically invalid programs.</p>
</blockquote>
<ul>
<li><strong>Repo</strong>:
<a href="https://github.com/CrowdHailer/eyg-lang">github.com/CrowdHailer/eyg-lang</a></li>
<li><strong>Website</strong>: <a href="https://eyg.run/">eyg.run</a></li>
<li><strong>Talk</strong>: SPLASH/LIVE 2024</li>
</ul>
<h2 id="pico-ml">Pico-ml</h2>
<blockquote>
  <p>ðŸ¤– An OCaml subset with HM type inference that compiles to WebAssembly,
  implemented in TypeScript. Small and self-contained â€” unusual for having a
  TypeScript host language rather than the OCaml/Haskell norm. A good starting
  point if you want to understand ML compilation targeting the browser.</p>
</blockquote>
<ul>
<li><strong>Repo</strong>: <a href="https://github.com/Quramy/pico-ml">github.com/Quramy/pico-ml</a></li>
</ul>
<h2 id="tinyml">TinyML</h2>
<blockquote>
  <p>ðŸ¤– <strong>&lt;700 LOC, Standard ML.</strong> Packs a lexer, parser, interpreter, and full
  polymorphic HM type checker into under 700 lines of SML. Referenced on Lambda
  the Ultimate, this may be the <strong>smallest complete implementation with genuine
Hindley-Milner inference</strong>, though the original download link appears to have
  gone stale.</p>
</blockquote>
<ul>
<li><strong>Reference</strong>:
<a href="http://lambda-the-ultimate.org/node/2683">lambda-the-ultimate.org/node/2683</a></li>
</ul>
<h2 id="eff">Eff</h2>
<blockquote>
  <p>ðŸ¤– The original algebraic effects language (2012) by Andrej Bauer and Matija
  Pretnar. OCaml syntax with effect handlers as first-class constructs â€” you
  declare effect operations, then install handlers that give them meaning. This
  is where the idea was first made concrete in a running implementation. Koka,
  Frank, OCaml 5&#39;s effect handlers, and virtually every subsequent algebraic
  effects system trace lineage here.</p>
</blockquote>
<ul>
<li><strong>Repo</strong>: <a href="https://github.com/matijapretnar/eff">github.com/matijapretnar/eff</a></li>
<li><strong>Paper</strong>: &#34;Programming with Algebraic Effects and Handlers&#34; (2012)</li>
</ul>
<h2 id="frank">Frank</h2>
<blockquote>
  <p>ðŸ¤– <strong>&#34;Do Be Do Be Do&#34;</strong> (POPL 2017) by Sam Lindley, Conor McBride, and Craig
  McLaughlin. A strict effectful functional language where functions are
  handlers that handle zero effects â€” and multihandlers generalize function
  abstraction to handle multiple effect interfaces simultaneously. The insight:
  the boundary between &#34;function&#34; and &#34;effect handler&#34; is artificial.
  Implemented in Haskell. Lindley describes it as &#34;the one I&#39;m most fond of&#34;
  while noting it&#39;s &#34;basically unmaintained.&#34; That tension between conceptual
  elegance and practical neglect is the story of many languages on this list.</p>
</blockquote>
<ul>
<li><strong>Repo</strong>: <a href="https://github.com/frank-lang/frank">github.com/frank-lang/frank</a></li>
<li><strong>Paper</strong>: &#34;Do Be Do Be Do&#34; (POPL 2017)</li>
</ul>
<h2 id="grace">Grace</h2>
<blockquote>
  <p>ðŸ¤– A JSON superset with bidirectional type checking and row polymorphism, by
  Gabriella Gonzalez (author of Dhall). Designed explicitly as a
  <strong>&#34;ready-to-fork&#34; language skeleton</strong> â€” if you need a typed DSL, clone Grace
  and customize it. Has open records, open unions (polymorphic variants), and a
  clean Haskell codebase that reads like a tutorial. No Hindley-Milner per se
  (bidirectional instead), but closely related.</p>
</blockquote>
<ul>
<li><strong>Repo</strong>:
<a href="https://github.com/Gabriella439/grace">github.com/Gabriella439/grace</a></li>
<li><strong>Blog</strong>:
<a href="https://www.haskellforall.com/2021/09/fall-from-grace-ready-to-fork.html">haskellforall.com/2021/09/fall-from-grace-ready-to-fork.html</a></li>
</ul>
<h2 id="hackett">Hackett</h2>
<blockquote>
  <p>ðŸ¤– A Haskell-like language implemented entirely as <strong>Racket macros</strong> via the
  &#34;Type Systems as Macros&#34; technique, by Alexis King. Bidirectional type
  inference, algebraic datatypes, pattern matching, typeclasses, higher-kinded
  types, and higher-rank polymorphism â€” all implemented not as a separate
  type-checker pass but as macro expansion. The meta-angle is the story: types
  as macros rather than a traditional elaboration pipeline.</p>
</blockquote>
<ul>
<li><strong>Repo</strong>:
<a href="https://github.com/lexi-lambda/hackett">github.com/lexi-lambda/hackett</a></li>
<li><strong>Paper</strong>: &#34;Type Systems as Macros&#34; (POPL 2017)</li>
</ul>
<h2 id="scrapscript">Scrapscript</h2>
<blockquote>
  <p>ðŸ¤– A content-addressable pure functional language where every expression
  reduces to a cryptographic hash, stored in a decentralized &#34;scrapyard&#34;
  registry and referenced by hash or alias. The implementation is a
  <strong>~1,300-line dependency-free Python interpreter in a single file</strong>, with a
  baseline compiler to C (~500 LOC) and an SSA IR with SCCP/DCE optimization
  (~1,000 LOC). Pattern matching is the sole control-flow mechanism. Compiles to
  C, WebAssembly, and Cosmopolitan portable executables. Implemented primarily
  by Max Bernstein.</p>
</blockquote>
<ul>
<li><strong>Repo</strong>:
<a href="https://github.com/tekknolagi/scrapscript">github.com/tekknolagi/scrapscript</a></li>
<li><strong>Blog series</strong>: Max Bernstein&#39;s implementation walkthroughs at
<a href="https://bernsteinbear.com/blog/scrapscript/">bernsteinbear.com/blog/scrapscript/</a></li>
</ul>
<h2 id="mincaml">MinCaml</h2>
<blockquote>
  <p>ðŸ¤– <strong>~2,000 LOC, OCaml â†’ native code.</strong> The gold standard for
  capability-to-code-size ratio. Written by Eijiro Sumii at Tohoku University,
  it implements a strict, higher-order functional language with type inference,
  closures, tuples, arrays, tail-call optimization, inline expansion, constant
  folding, and graph-coloring register allocation. It compiles to SPARC,
  PowerPC, and x86 assembly. On benchmarks including a ray tracer,
  <strong>MinCaml-compiled code runs within 2Ã— of GCC and OCaml&#39;s <code>ocamlopt</code></strong> â€”
  sometimes faster. The deliberate trade-off: it omits polymorphism, algebraic
  data types, and pattern matching. Used in undergraduate compiler courses at
  the University of Tokyo since 2001, where students build ray tracers compiled
  by their own compilers running on custom CPUs.</p>
</blockquote>
<ul>
<li><strong>Repo</strong>: <a href="https://github.com/esumii/min-caml">github.com/esumii/min-caml</a></li>
<li><strong>Paper</strong>: &#34;MinCaml: A Simple and Efficient Compiler for a Minimal Functional
Language&#34; (FDPE 2005)</li>
<li><strong>Forks</strong>: <a href="https://github.com/rhysd/gocaml">gocaml</a> (Go + LLVM
reimplementation), <a href="https://github.com/cmaes/miniml">miniml</a> (OCaml + LLVM,
~1,500 LOC, adds LLVM backend to MinCaml&#39;s architecture)</li>
</ul>
<h2 id="ben-lynn">Ben Lynn</h2>
<blockquote>
  <p>ðŸ¤– <strong>~2,000 lines of Haskell + 350 lines of C.</strong> Arguably the most remarkable
  bootstrapping achievement in this space. Starting from a 350-SLOC C runtime
  that interprets combinatory logic, Lynn builds a chain of approximately 20
  progressively more capable compilers, each written in the subset of Haskell
  that the previous compiler can handle. The final compiler supports type
  inference, type classes, algebraic data types, pattern matching, guards, where
  clauses, monadic I/O, modules, and layout parsing â€” approaching <strong>Haskell 98
coverage</strong>. It compiles Haskell to combinatory logic via Kiselyov&#39;s bracket
  abstraction algorithm, with graph reduction evaluation. Later stages even
  target WebAssembly. The entire bootstrapping chain is reproducible from just a
  C compiler.</p>
</blockquote>
<ul>
<li><strong>Repo</strong>: <a href="https://github.com/blynn/compiler">github.com/blynn/compiler</a></li>
<li><strong>Website</strong>:
<a href="https://crypto.stanford.edu/~blynn/compiler/">crypto.stanford.edu/~blynn/compiler/</a>
â€” &#34;Compiler Quest,&#34; an extraordinary walkthrough of each bootstrapping stage</li>
<li><strong>Annotated fork</strong>:
<a href="https://github.com/siraben/mini-haskell">github.com/siraben/mini-haskell</a>
(~1,500 LOC Haskell + 350 LOC C, MIT-licensed, well-commented)</li>
</ul>
<h2 id="1ml">1ML</h2>
<blockquote>
  <p>ðŸ¤– <strong>~3,000â€“5,000 LOC, OCaml.</strong> Andreas Rossberg unified ML&#39;s core and module
  layers into a single language where modules are first-class values, types are
  values, and functors are ordinary functions. It elaborates to System FÏ‰ with
  HM-style inference. Won the <strong>ICFP Most Influential Paper Award in 2025</strong>. A
  proof-of-concept interpreter, not optimized, but a conceptual breakthrough in
  minimal surface area.</p>
</blockquote>
<ul>
<li><strong>Repo</strong>: <a href="https://github.com/rossberg/1ml">github.com/rossberg/1ml</a></li>
<li><strong>Paper</strong>: &#34;1ML â€” Core and modules united&#34; (ICFP 2015, JFP 2018)</li>
</ul>
<h2 id="mlml">mlml</h2>
<blockquote>
  <p>ðŸ¤– A self-hosting OCaml subset compiler targeting native x86-64. ~3,000â€“5,000
  LOC. Supports pattern matching, algebraic data types, recursive functions, and
  closures. Does not implement type inference â€” it demonstrates the minimum
  OCaml subset needed for self-compilation.</p>
</blockquote>
<ul>
<li><strong>Repo</strong>: <a href="https://github.com/coord-e/mlml">github.com/coord-e/mlml</a></li>
</ul>
<h2 id="dhall">Dhall</h2>
<blockquote>
  <p>ðŸ¤– A total (non-Turing-complete) typed configuration language. ~4K LOC core
  Haskell. Normalization is guaranteed to terminate â€” you can always reduce a
  Dhall expression to a normal form, which means imports resolve, functions
  inline, and what you get is plain data. Based on a
  Calculus-of-Constructions-derived type theory with records, unions, and
  natural numbers. Has a formal specification and implementations in Haskell,
  Rust, Go, and Clojure.</p>
</blockquote>
<ul>
<li><strong>Repo</strong>:
<a href="https://github.com/dhall-lang/dhall-haskell">github.com/dhall-lang/dhall-haskell</a></li>
<li><strong>Website</strong>: <a href="https://dhall-lang.org/">dhall-lang.org</a></li>
</ul>
<h2 id="ante">Ante</h2>
<blockquote>
  <p>ðŸ¤– Combines HM type inference, algebraic data types, pattern matching,
  algebraic effects, and an ownership-like system for shared mutability. Written
  in Rust, it uses <strong>Cranelift</strong> for native code generation. Actively developed,
  aiming to bridge the Rust/OCaml divide.</p>
</blockquote>
<ul>
<li><strong>Repo</strong>: <a href="https://github.com/jfecher/ante">github.com/jfecher/ante</a></li>
</ul>
<h2 id="tao">Tao</h2>
<blockquote>
  <p>ðŸ¤– Surprisingly feature-rich for its size: generics, typeclasses, sum types,
  pattern matching, first-class functions, currying, algebraic effects,
  associated types, and totality checking. Its pipeline runs from lexing through
  HIR type inference to MIR monomorphization and bytecode execution. Written in
  Rust.</p>
</blockquote>
<ul>
<li><strong>Repo</strong>: <a href="https://github.com/zesterer/tao">github.com/zesterer/tao</a></li>
</ul>
<h2 id="austral">Austral</h2>
<blockquote>
  <p>ðŸ¤– A systems language with <strong>linear types</strong> and capability-based security. The
  linear type checker is ~600 lines. OCaml bootstrap compiler targeting C.
  Designed by Fernando Borretti to fit in one person&#39;s head â€” the spec is
  deliberately small enough that a single developer can understand the entire
  language. Not functional in the Haskell sense, but linear types make it
  adjacent. An experiment in &#34;what if we took linear types seriously but kept
  the language small.&#34;</p>
</blockquote>
<ul>
<li><strong>Repo</strong>: <a href="https://github.com/austral/austral">github.com/austral/austral</a></li>
<li><strong>Website</strong>: <a href="https://austral-lang.org/">austral-lang.org</a></li>
</ul>
<h2 id="aqaml">AQaml</h2>
<blockquote>
  <p>ðŸ¤– A self-hosting OCaml subset compiler targeting native x86-64. ~5,000â€“8,000
  LOC. Adds records, variants, references, and garbage collection beyond what
  mlml supports. Triple self-hosting verified. Like mlml, it omits type
  inference â€” demonstrating the minimum OCaml needed for self-compilation.</p>
</blockquote>
<ul>
<li><strong>Repo</strong>:
<a href="https://github.com/ushitora-anqou/aqaml">github.com/ushitora-anqou/aqaml</a></li>
</ul>
<h2 id="borgo">Borgo</h2>
<blockquote>
  <p>ðŸ¤– Adds ML-family features (algebraic data types, exhaustive pattern matching,
  Result/Option types) to Go&#39;s ecosystem by compiling to Go source code with
  Rust-like syntax. Written in Rust.</p>
</blockquote>
<ul>
<li><strong>Repo</strong>: <a href="https://github.com/borgo-lang/borgo">github.com/borgo-lang/borgo</a></li>
</ul>
<h2 id="polytt">polytt</h2>
<blockquote>
  <p>ðŸ¤– A research experiment from the Topos Institute extending Martin-LÃ¶f Type
  Theory with native, first-class polynomial functors â€” the mathematical objects
  underlying deterministic state machines and interactive systems. Written in
  OCaml with Menhir parsing. Custom syntax for polynomial types (<code>y^n</code>),
  morphism arrows, and wiring operators. Dependent types (Pi, Sigma), finite-set
  ADTs, and pattern matching via case elimination. An ended experiment, but a
  unique point in the design space: what happens when you make polynomial
  functors a language primitive rather than an encoding.</p>
</blockquote>
<ul>
<li><strong>Repo</strong>:
<a href="https://github.com/ToposInstitute/polytt">github.com/ToposInstitute/polytt</a></li>
</ul>
<h2 id="newt">Newt</h2>
<blockquote>
  <p>ðŸ¤– <strong>~7K LOC, self-hosted, compiles to JavaScript.</strong> A dependently typed
  language with Agda/Idris/Haskell-like syntax by Steve Dunham. Bidirectional
  typechecking with normalization by evaluation (based on Elaboration Zoo),
  typeclasses, ADTs with dependent pattern matching, case tree compilation,
  trampoline-based TCO for mutually tail-recursive functions, and erasure of
  compile-time-only values (0/Ï‰ quantities). Has a web playground and an LSP.
  The compiler is written in Newt itself. Built as a learning exercise, but the
  feature set â€” self-hosting, dependent types, typeclasses, erasure, LSP â€” puts
  it well beyond most pedagogical implementations.</p>
</blockquote>
<ul>
<li><strong>Repo</strong>: <a href="https://github.com/dunhamsteve/newt">github.com/dunhamsteve/newt</a></li>
<li><strong>Playground</strong>:
<a href="https://dunhamsteve.github.io/newt">dunhamsteve.github.io/newt</a></li>
</ul>
<h2 id="hamlet">HaMLet</h2>
<blockquote>
  <p>ðŸ¤– <strong>~10,000â€“15,000 LOC, SML.</strong> Andreas Rossberg&#39;s most faithful
  implementation of the Definition of Standard ML. It implements <strong>all of SML
&#39;97</strong> including the full module system (signatures, structures, functors),
  mapping rule-by-rule to the formal Definition. Jeremy Yallop recommends it as
  the most readable SML implementation. It can be bundled into a single SML file
  and compiled by any SML implementation. A <code>compile-js</code> branch demonstrates
  compilation to JavaScript.</p>
</blockquote>
<ul>
<li><strong>Repo</strong>: <a href="https://github.com/rossberg/hamlet">github.com/rossberg/hamlet</a></li>
</ul>
<h2 id="sosml">SOSML</h2>
<blockquote>
  <p>ðŸ¤– <strong>~10,000â€“15,000 LOC, TypeScript.</strong> Implements the full SML core language
  in the browser: val/fun/datatype declarations, pattern matching, HM type
  inference, exceptions, and references. Used for teaching at Saarland
  University.</p>
</blockquote>
<ul>
<li><strong>Website</strong>: <a href="https://sosml.org">sosml.org</a></li>
<li><strong>Repo</strong>: <a href="https://github.com/SOSML/SOSML">github.com/SOSML/SOSML</a></li>
</ul>
<h2 id="microhs">MicroHs</h2>
<blockquote>
  <p>ðŸ¤– By Lennart Augustsson (one of GHC&#39;s original creators) â€” the most complete
  &#34;small&#34; Haskell compiler alive today. It compiles an extended subset of
  <strong>Haskell 2010</strong> including type classes, do-notation, deriving, record syntax,
  overloaded literals, and modules. It is fully self-hosting and â€” critically â€”
  <strong>bootstrappable from only a C compiler</strong> (no pre-existing Haskell toolchain
  required). MicroHs translates Haskell to combinators executed by a C runtime.
  It has a JavaScript runtime target, a package manager (<code>mcabal</code>), and can
  compile real Hackage packages like QuickCheck. The codebase is not trivially
  small (estimated <strong>15,000â€“30,000 lines</strong> across compiler, libraries, and
  runtime), but for what it does â€” a near-complete Haskell compiler
  bootstrappable from C â€” it is remarkably compact.</p>
</blockquote>
<ul>
<li><strong>Repo</strong>: <a href="https://github.com/augustss/MicroHs">github.com/augustss/MicroHs</a></li>
<li><strong>Paper</strong>: &#34;MicroHs: A Small Compiler for Haskell&#34; (Haskell Symposium 2024)</li>
</ul></div></div>
  </body>
</html>
