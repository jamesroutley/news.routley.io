<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://catfox.life/2022/04/16/the-musl-preprocessor-debate/">Original</a>
    <h1>The Musl Preprocessor Debate</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>Today, I would like to discuss a project that I care very deeply about: the <a href="http://musl.libc.org/">musl libc</a>.  One of the most controversial and long-standing debates in the musl community is that musl does not define a preprocessor macro.</p>



<h2>What’s in a macro?</h2>



<p>Simply put, preprocessor macros allow C code to build parts of itself conditionally.  For example, the GNU libc defines the “__GLIBC__” macro.  If your code needs to do something specific to function properly on systems using that library, it can conditionally build that code using “#ifdef __GLIBC__”.</p>



<p>The authors of musl have said that they will not add a preprocessor macro identifying the platform as musl because:</p>



<blockquote><p>It’s a bug to assume a certain implementation has particular properties rather than testing.</p><cite>Rich Felker, “<a href="https://www.openwall.com/lists/musl/2013/03/29/13">Re: #define __MUSL__ in features.h</a>”, 2013-03-29</cite></blockquote>



<p>I agree with this sentiment in theory, and in an idealised world this would hold up.  However, I’d like to discuss why I think this may need to be reconsidered moving forward.</p>



<h2>Sometimes you can’t test</h2>



<p>One major reason this is an issue is that sometimes it is not possible to do what the authors consider the “correct” form of testing, which is compile-testing.</p>



<p>This practice requires you to build a small test program, determine whether it built properly, determine its runtime characteristics, and then use the results of that test to influence how your actual software is built.  This is an alternative to using the conditional code with preprocessor macros.</p>



<p>However, there are many reasons you may not be able to successfully perform such testing.  Cross compilation is a large gap here.  In fact, many years ago when I was starting the Adélie project, this caused failures in the base image I was building.</p>



<p>The Bash shell could not perform any compile-time or run-time checks because it was being cross-compiled from a GNU libc system to a musl libc system.  This caused it to use “fallback” code that worked improperly.  If musl had defined a __MUSL__ macro, Bash would not have needed to assume it was running on a pre-POSIX system.</p>



<p>Similarly, the <a href="https://www.openwall.com/lists/musl/2022/04/16/1">mailing list thread</a> that made me feel strongly enough to write this article involves a header-only library.  These types of libraries are meant to be “drop-in” and function without any changes to a developer’s build system.  If header-only libraries start requiring you to use build-time tests, you lose the main reason to use them in the first place.</p>



<p>The author of this thread correctly points out that FreeBSD <a href="https://docs.freebsd.org/en/books/porters-handbook/versions/">versions their API with a preprocessor macro</a>.  Any software that requires a certain API can simply ensure that __FreeBSD_version is defined as greater-or-equal than the versions that introduced that API.</p>



<p>The main reason that the musl project is fearful of this approach, at least to my observation, is that features or APIs (or indeed, bug fixes) can be backported to prior versions.  I feel very strongly that this is <strong><span>not</span></strong> the responsibility of the libc.</p>



<p>If a distribution backports a feature, API, or patch to an older version of a library, it is that distribution’s responsibility to ensure that the software they build against it continues to function.  When I backported an API from Qt 5.10 to 5.9 to ensure KDE continued building for Adélie, it was my responsibility as maintainer of those packages to keep them building properly.  It certainly does not mean Qt should stop defining a preprocessor macro to determine the version being built against.</p>



<p>Additionally, some APIs are privileged.  Determining whether these APIs work correctly using run-time testing can prevent CI/CD from working properly because the CI user does not have permission to use them.</p>



<h2>A versioned macro like FreeBSD’s makes sense</h2>



<p>I feel that the best way forward for musl is to define a macro like FreeBSD’s.  It monotonically increases as APIs or features are added.</p>



<p>I agree that simple bug fixes, and even behavioural changes, probably should not be tracked with this macro.  However, this would make it significantly easier to use new APIs as they are introduced.</p>



<p>It also makes builds more efficient.  The cost of compile-time tests racks up quickly.  On my POWER9 Talos workstation, typical ./configure runs take longer than the builds themselves.  This is because fork+exec is still a slow path on POWER.  It is similar on ARM, MIPS, and many other RISC architectures.</p>



<p>Macros like these don’t fully eliminate the need for ./configure, but they lessen the workload.  Compile-time tests make sense for behaviour detection, but they do <em>not</em> make sense for API detection.</p>
			</div></div>
  </body>
</html>
