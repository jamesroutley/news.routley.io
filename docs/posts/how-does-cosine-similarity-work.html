<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tomhazledine.com/cosine-similarity/">Original</a>
    <h1>How does cosine similarity work?</h1>
    
    <div id="readability-page-1" class="page"><div><div id="content"><p>Look up <em>&#34;how to compare vectors&#34;</em> and <strong>cosine similarity</strong> will be the most common (if not the <em>only</em>) approach you will see. I&#39;ve been working with vectors <a href="https://pjg1.site/llm-related-posts/">a lot</a> <a href="https://pjg1.site/mapping-llm-embeddings-in-3d/">lately</a> in the context of LLM embeddings, and being able to measure how similar any two embeddings are has become an important part of my workflow. But how does the <em>cosine similarity</em> process actually work?</p><p>I&#39;ve been relying on copy/pasting cosine similarity code without really understanding how it works. To give myself a deeper understanding, I want to answer the following questions:</p><ol><li>How does the cosine similarity formula work?</li><li>What do the different parts of it <em>mean</em>?</li><li>Why is this a useful method for comparing LLM embeddings?</li></ol><h2 id="what-do-we-mean-by-vectors">What do we mean by &#34;vectors&#34;?</h2><p>Before getting too deep, it&#39;s worth clarifying what we mean by &#34;vectors&#34;. For my projects I&#39;m using the terms &#34;embedding&#34; and &#34;vector&#34; interchangeably. To quote a <a href="https://pjg1.site/llm-related-posts/#so-what-are-embeddings">previous post of mine</a>:</p><blockquote><p>The general concept of &#34;embeddings&#34; is an offshoot of the Large Language Model (LLM) technology that makes tools like ChatGPT work. The basic idea is that you can take a piece of text (a blog post, for example) and turn it into a vector (an array of numbers). This vector is called an &#34;embedding&#34; and it represents the &#34;meaning&#34; of the text.</p></blockquote><p>In short, embeddings are vectors and vectors are lists of numbers. If, like me, you translate all code into JavaScript, we&#39;re talking about arrays. <code>const vector = [0.1, 0.2, 0.3, 0.4, 0.5];</code> is a vector.</p><p>The vectors created for LLM embeddings are very long arrays of numbers. An embedding created by OpenAI&#39;s <code>ada-002</code> model contains 1,536 numbers. Mathematically that can be described as a vector in 1,536-dimensional space. 2D vectors (that is to say, arrays with only 2 numbers) are much less useful in the context of embeddings, but the same principles apply, and we can use them to illustrate how cosine similarity works.</p><h2 id="why-is-cosine-similarity-useful-when-comparing-vectors">Why is cosine similarity useful when comparing vectors?</h2><p>Being able to compare how similar two vectors are is a key part of working with embeddings. Cosine similarity is the recommended way to do this.</p><p>If we picture a super-simplified 2D space where all our vectors have only two values, the angle between two vectors is the angle between the two lines they represent. The lines are drawn from the origin (0, 0) to the end of the vector, treating the two vector numbers as x/y co-ordinates.</p><blockquote><p><strong>Note:</strong> if we had vectors with three values, we&#39;d be working in 3D space. Four values, 4D space, and so on. The principles of cosine similarity remain the same no matter how many dimensions you&#39;re working in.</p></blockquote><figure><div></div><figcaption>Simplified examples showing the angle <span>θ</span> between two vectors in 2D space.</figcaption></figure><p>The <span>θ</span> (theta) value is the angle between the two vectors. This is the angle required to rotate one vector to align with the other. The cosine of that angle (<span>cos(θ)</span>) gives us the cosine similarity: a number between -1 and 1.</p><p>If the directions of the vectors are identical, the cosine similarity is 1. If they&#39;re orthogonal (at right angles), the cosine similarity is 0. If they&#39;re opposite, the cosine similarity is -1.</p><blockquote><h4 id="cosine-similarity-ignores-the-magnitude-of-the-vectors">Cosine similarity ignores the magnitude of the vectors</h4><p>The cosine similarity formula only cares about the angle between the vectors, not their length. This means that vectors of different lengths can still have a cosine similarity of <code>1</code> if they&#39;re pointing in the same direction.</p></blockquote><h2 id="digging-into-the-cosine-similarity-formula">Digging into the cosine similarity formula</h2><p>The mathematical formula itself (as cribbed from <a href="https://en.wikipedia.org/wiki/Cosine_similarity">Wikipedia</a>) looks like this:</p><p><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>Cosine Similarity</mtext><mo>=</mo><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi mathvariant="bold">A</mi><mo>⋅</mo><mi mathvariant="bold">B</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi mathvariant="bold">A</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mo>×</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi mathvariant="bold">B</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\text{Cosine Similarity} = \cos(\theta) = \frac{\mathbf{A} \cdot \mathbf{B}}{||\mathbf{A}|| \times ||\mathbf{B}||}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>Cosine Similarity</span></span><span></span><span>=</span><span></span></span><span><span></span><span>cos</span><span>(</span><span>θ</span><span>)</span><span></span><span>=</span><span></span></span><span><span></span><span><span></span><span><span><span><span><span><span></span><span><span><span>∣∣</span><span>A</span><span>∣∣</span><span>×</span><span>∣∣</span><span>B</span><span>∣∣</span></span></span></span><span><span></span><span></span></span><span><span></span><span><span><span>A</span><span>⋅</span><span>B</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span></span></span></span></span></p><blockquote><p>where:</p><ul><li><span>A⋅B</span> is the dot product of vectors <span>A</span> and <span>B</span>.</li><li><span>∣∣A∣∣</span> is the magnitude of vector <span>A</span>.</li><li><span>∣∣B∣∣</span> is the magnitude of vector <span>A</span>.</li><li><span>θ</span> is the angle between the two vectors.</li></ul></blockquote><p>That seems straightforward enough, but to translate it into a useable JavaScript function I&#39;ll need to answer a few followup questions:</p><h3 id="what-is-the-dot-product-of-two-vectors">What is the &#34;dot product&#34; of two vectors?</h3><p>&#34;Dot product&#34; basically means &#34;multiply and add&#34;. The dot product of two vectors is the sum of the products of their corresponding elements.</p><p><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mo>⋅</mo><mi mathvariant="bold">B</mi><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>b</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>+</mo><mo>…</mo><mo>+</mo><msub><mi>a</mi><mi>n</mi></msub><msub><mi>b</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\mathbf{A} \cdot \mathbf{B} = a_1 b_1 + a_2 b_2 + \ldots + a_n b_n</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span><span></span><span>⋅</span><span></span></span><span><span></span><span>B</span><span></span><span>=</span><span></span></span><span><span></span><span><span>a</span><span><span><span><span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span><span>b</span><span><span><span><span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>+</span><span></span></span><span><span></span><span><span>a</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span><span>b</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>+</span><span></span></span><span><span></span><span>…</span><span></span><span>+</span><span></span></span><span><span></span><span><span>a</span><span><span><span><span><span><span></span><span><span>n</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span><span>b</span><span><span><span><span><span><span></span><span><span>n</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></p><p>For example, the dot product of the vectors <code>[1, 2, 3]</code> and <code>[4, 5, 6]</code> is <span>1 × 4 + 2 × 5 + 3 × 6 = 4 + 10 + 18 = 32</span>. Given vectors <code>a</code> and <code>b</code>, the dot product can be calculated in JS like this:</p><pre><code><span>const</span> dotProduct = a.<span>reduce</span>(<span>(<span>acc, cur, i</span>) =&gt;</span> acc + cur * b[i], <span>0</span>);
</code></pre><h3 id="what-is-the-magnitude-of-a-vector">What is the &#34;magnitude&#34; of a vector?</h3><p>In simple language, the &#34;magnitude&#34; of a vector is its length. In mathematical terms, it&#39;s the square root of the sum of the squares of its elements.</p><p><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∥</mi><mi mathvariant="bold">v</mi><mi mathvariant="normal">∥</mi><mo>=</mo><msqrt><mrow><msubsup><mi>v</mi><mn>1</mn><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>v</mi><mn>2</mn><mn>2</mn></msubsup><mo>+</mo><mo>…</mo><mo>+</mo><msubsup><mi>v</mi><mi>n</mi><mn>2</mn></msubsup></mrow></msqrt></mrow><annotation encoding="application/x-tex">\|\mathbf{v}\| = \sqrt{v_1^2 + v_2^2 + \ldots + v_n^2}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>∥</span><span>v</span><span>∥</span><span></span><span>=</span><span></span></span><span><span></span><span><span><span><span><span><span></span><span><span><span>v</span><span><span><span><span><span><span></span><span><span>1</span></span></span><span><span></span><span><span>2</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>+</span><span></span><span><span>v</span><span><span><span><span><span><span></span><span><span>2</span></span></span><span><span></span><span><span>2</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>+</span><span></span><span>…</span><span></span><span>+</span><span></span><span><span>v</span><span><span><span><span><span><span></span><span><span>n</span></span></span><span><span></span><span><span>2</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span><span><span></span><span><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.28em" viewBox="0 0 400000 1296" preserveAspectRatio="xMinYMin slice"><path d="M263,681c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l0 -0
c4.7,-7.3,11,-11,19,-11
H40000v40H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M1001 80h400000v40h-400000z"></path></svg></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></p><p>For example, the magnitude of the vector <code>[1, 2, 3]</code> is <span>√(1<sup>2</sup> + 2<sup>2</sup> + 3<sup>2</sup>) = √(1 + 4 + 9) = √14</span>. Given a vector <code>a</code>, the magnitude can be calculated in JS like this:</p><pre><code><span>const</span> magnitude = <span>Math</span>.<span>sqrt</span>(a.<span>reduce</span>(<span>(<span>acc, cur</span>) =&gt;</span> acc + cur ** <span>2</span>, <span>0</span>));
</code></pre><blockquote><h4 id="but-arent-we-ignoring-the-magnitude-of-the-vectors">But aren&#39;t we ignoring the magnitude of the vectors?</h4><p>Calculating the magnitudes of the vectors feels counterintuitive given we want to ignore it. But by including the <strong>product</strong> of the magnitudes the formula can normalize the dot product, ensuring the similarity measure is independent of the vectors&#39; lengths.</p></blockquote><h3 id="the-full-cosine-similarity-function-in-javascript">The full <em>Cosine Similarity</em> function in JavaScript</h3><p>Now that we&#39;ve unpicked all the parts of the formula, we can put them together to create a JavaScript function that calculates the cosine similarity of any two vectors.</p><p><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi mathvariant="bold">A</mi><mo>⋅</mo><mi mathvariant="bold">B</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi mathvariant="bold">A</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mo>×</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi mathvariant="bold">B</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\cos(\theta) = \frac{\mathbf{A} \cdot \mathbf{B}}{||\mathbf{A}|| \times ||\mathbf{B}||}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>cos</span><span>(</span><span>θ</span><span>)</span><span></span><span>=</span><span></span></span><span><span></span><span><span></span><span><span><span><span><span><span></span><span><span><span>∣∣</span><span>A</span><span>∣∣</span><span>×</span><span>∣∣</span><span>B</span><span>∣∣</span></span></span></span><span><span></span><span></span></span><span><span></span><span><span><span>A</span><span>⋅</span><span>B</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span></span></span></span></span></p><pre><code><span>export</span> <span>const</span> <span>cosineSimilarity</span> = (<span>a, b</span>) =&gt; {
    <span>const</span> dotProduct = a.<span>reduce</span>(<span>(<span>acc, cur, i</span>) =&gt;</span> acc + cur * b[i], <span>0</span>);
    
    <span>const</span> magnitudeA = <span>Math</span>.<span>sqrt</span>(a.<span>reduce</span>(<span>(<span>acc, cur</span>) =&gt;</span> acc + cur ** <span>2</span>, <span>0</span>));
    <span>const</span> magnitudeB = <span>Math</span>.<span>sqrt</span>(b.<span>reduce</span>(<span>(<span>acc, cur</span>) =&gt;</span> acc + cur ** <span>2</span>, <span>0</span>));
    
    <span>const</span> magnitudeProduct = magnitudeA * magnitudeB;
    <span>if</span> (magnitudeProduct === <span>0</span>) <span>return</span> <span>0</span>; 
    
    <span>const</span> similarity = dotProduct / magnitudeProduct;
    <span>return</span> similarity;
};
</code></pre><blockquote><h4 id="why-doesnt-this-function-use-mathcos">Why doesn&#39;t this function use <code>Math.cos()</code>?</h4><p>Given how much we&#39;ve been talking about &#34;cosines&#34;, it&#39;s surprising that our <code>cosineSimilarity</code> function doesn&#39;t make use of JavaScript&#39;s built-in <code>Math.cos()</code> function. This is because our function directly computes the cosine of the angle without needing to determine the angle itself. Using <code>Math.cos()</code> would require first calculating the angle using an inverse trigonometric function like <code>Math.acos()</code>, which is unnecessary and computationally more expensive.</p></blockquote><hr/><h2 id="so-why-is-cosine-similarity-useful-for-comparing-llm-embeddings">So why is cosine similarity useful for comparing LLM embeddings?</h2><p>There&#39;s a reason cosine similarity is the recommended way to compare LLM embeddings. The important part of an embedding is its <em>direction</em>, not its <em>length</em>. If two embeddings are pointing in the same direction, then according to the model they represent the same &#34;meaning&#34;.</p><p>Because cosine similarity measures the similarity of two vectors based on their direction, ignoring their length, it&#39;s the perfect tool for comparing embeddings. It&#39;s also computationally cheap, which is a bonus. And, <a href="#the-full-cosine-similarity-function-in-javascript">as we&#39;ve seen</a>, can be implemented in just a few lines of JavaScript.</p><p>The power of embeddings comes from their multidimensionality. The vectors are long, and the relationships between the numbers in the vectors are complex. But the principles of cosine similarity remain the same, no matter how many dimensions you&#39;re working in. It&#39;s a simple and effective way to compare vectors.</p><h2 id="are-there-alternatives-to-cosine-similarity">Are there alternatives to cosine similarity?</h2><p>Cosine similarity is the most common way to compare vectors, but it&#39;s not the only way. I&#39;ll be exploring alternatives in next month&#39;s post, so pop your email in the box below if you want to be notified when it&#39;s published.</p></div></div><div><div><h2>Related posts</h2><p>If you enjoyed this article, <strong><em>RoboTom 2000™️</em></strong> (an LLM-powered bot) thinks you might be interested in these related posts:</p></div></div></div>
  </body>
</html>
