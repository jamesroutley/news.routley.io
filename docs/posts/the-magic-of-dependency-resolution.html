<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ochagavia.nl/blog/the-magic-of-dependency-resolution/">Original</a>
    <h1>The magic of dependency resolution</h1>
    
    <div id="readability-page-1" class="page"><div>
  <p>Dependency resolution is something programmers usually take for granted. Be it <code>cargo</code>, <code>npm</code>, or whatever package manager you use, no one is actually surprised when this black-box figures out, all by itself, the specific set of packages that should be installed.</p>
<p>To me, though, it is a fascinating feat. It feels magical when a machine solves an abstract problem like that, with minimal input from me as a user! I was, therefore, delighted when the nice folks at <a href="https://prefix.dev">Prefix.dev</a> hired me to create an open-source dependency solver for the Conda package ecosystem. Not that I am an expert in the topic (far from it!), but I <em>do</em> know my Rust and I‚Äôm a <a href="https://ochagavia.nl/blog/on-being-paid-to-learn/">quick learner</a>. In fact, after 5 weeks the new solver is finally available as an experimental option in the <a href="https://github.com/mamba-org/rattler">rattler</a><sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> project!</p>
<p>Credit where credit‚Äôs due, I was able to build on Prefix‚Äôs amazing work on rattler, and on the relentless testing of <a href="https://github.com/wolfv">@wolfv</a>, who managed to break my solver again and again‚Ä¶ Until it finally worked!</p>
<p>And now, if you are interested, you can follow me down the dependency resolution rabbit hole. There‚Äôs plenty of interesting stuff to look at down there!</p>
<h2 id="1-context">1. Context</h2>
<p><em>Feel free to skip this section if you want to go straight to the SAT solver stuff.</em></p>
<h3 id="didnt-rattler-already-have-a-dependency-solver">Didn‚Äôt rattler already have a dependency solver?</h3>
<p>Yes, it is a fork of <a href="https://github.com/openSUSE/libsolv">libsolv</a>, but it is proving challenging to maintain and extend, because it is written in very low-level C.</p>
<h3 id="so-you-rewrote-it-in-rust">So you ‚Äúrewrote it in Rust‚Äù?</h3>
<p>Yes, thanks to a generous grant by <a href="https://numfocus.org/programs/small-development-grants">NumFOCUS</a>. We called the resulting library <code>libsolv_rs</code>, because it‚Äôs mostly a port of the libsolv C library, though it currently only supports solving Conda packages.</p>
<h3 id="what-do-you-mean-by-dependency-resolution">What do you mean by dependency resolution?</h3>
<p>You have probably seen something like a <code>Cargo.toml</code> file, shown below (most package managers have their own custom configuration format, but the idea is the same):</p>
<div><pre tabindex="0"><code data-lang="toml"><span><span>[<span>package</span>]
</span></span><span><span><span>name</span> = <span>&#34;foo&#34;</span>
</span></span><span><span><span>version</span> = <span>&#34;0.1.0&#34;</span>
</span></span><span><span><span>edition</span> = <span>&#34;2021&#34;</span>
</span></span><span><span>
</span></span><span><span>[<span>dependencies</span>]
</span></span><span><span><span>rand</span> = <span>&#34;*&#34;</span>
</span></span></code></pre></div><p>Here we are specifying that our project requires the <code>rand</code> package (<em>crate</em>, in Rust parlance), and that we are interested in any version. When I run <code>cargo build</code> on this project, cargo <em>resolves</em> the <code>rand</code> dependency to the highest available version, which at the time of this writing is <code>0.8.5</code>. It will also find suitable versions for <code>rand</code>‚Äôs dependencies, their dependencies, and so on (the whole list of resolved dependencies will then be stored in <code>Cargo.lock</code>).</p>
<p>The process of going from dependency requirements (e.g. install any version of <code>rand</code>) to a concrete tree of packages (e.g. install <code>rand</code> version <code>0.8.5</code>, with its dependency <code>x</code> at version <code>0.2</code>, etc.) is called dependency resolution. It might look trivial in this example, but it is certainly not! (If you don‚Äôt believe me, read on üòâ)</p>
<h2 id="2-the-new-dependency-solver">2. The new dependency solver</h2>
<p>We have mentioned the word ‚Äúsolver‚Äù, but what do we mean by that? In a general sense, I‚Äôd say a solver is a program that receives a mathematical problem as input, and returns the solution as output. That makes it a solver, right? Its aim in life is to <em>solve</em>.</p>
<p>In the world of dependency resolution, the solver is the engine that constructs the concrete dependency tree based on a few top-level dependency specifications. In many cases, like ours, an actual <a href="https://en.wikipedia.org/wiki/SAT_solver">SAT solver</a> (more on that below) is used behind the scenes. That makes the name solver even more suitable!</p>
<h3 id="from-required-dependencies-to-sat">From required dependencies to SAT</h3>
<p>Let‚Äôs start with an example. I have a package, called <code>foo 0.0.1</code>, which depends on <code>bar</code> (any version will do). To be able to run my package, I need an installed version of <code>bar</code>, including its transitive dependencies. The solver should tell me, then, which exact versions of <code>bar</code> and its dependencies to install. Below follows a somewhat informal definition of the ‚Äúdependency resolution problem‚Äù:</p>
<ul>
<li>My package <code>foo 0.0.1</code> depends on any version of <code>bar</code></li>
<li>There are two versions of <code>bar</code> available in the package repository:
<ul>
<li><code>bar 0.1.0</code>, which depends on <code>baz 0.1.0</code></li>
<li><code>bar 0.2.0</code>, which depends on <code>baz 0.2.0</code></li>
</ul>
</li>
<li><code>baz 0.2.0</code> has been recently removed from the package repository</li>
<li>I want to know which concrete packages should be installed so <code>foo</code>‚Äôs dependencies are available</li>
</ul>
<p>The description above is too informal for the computer, but we can transform it into a <a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem">boolean satisfiability problem</a> (often abreviated as SAT). For that, you need to create a list of boolean clauses that represent the problem (the idea is that each clause should evaluate to true). Here‚Äôs the list of clauses derived<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup> from the description above, where every variable corresponds to a package that could be installed:</p>
<ol>
<li><code>(foo 0.0.1)</code>: the root package <code>foo 0.0.1</code> must always be installed</li>
<li><code>(foo 0.0.1 =&gt; bar 0.1.0 ‚à® bar 0.2.0)</code>: if <code>foo 0.0.1</code> is installed, then at least one package for its <code>bar</code> dependency must be installed</li>
<li><code>(bar 0.1.0 =&gt; baz 0.1.0)</code>: if <code>bar 0.1.0</code> is installed, then <code>baz 0.1.0</code> must be installed too</li>
<li><code>(bar 0.2.0 =&gt; baz 0.2.0)</code>: if <code>bar 0.2.0</code> is installed, then <code>baz 0.2.0</code> must be installed too</li>
<li><code>(¬¨bar 0.1.0 ‚à® ¬¨bar 0.2.0)</code>: you can have at most one version of <code>bar</code> installed</li>
<li><code>(¬¨baz 0.1.0 ‚à® ¬¨baz 0.2.0)</code>: you can have at most one version of <code>baz</code> installed</li>
<li><code>(¬¨baz 0.2.0)</code>: you cannot install <code>baz 0.2.0</code>, because it‚Äôs not present in the package repository</li>
</ol>
<p>What should the solver do with the clauses? It must find values (true or false) for each variable, in such a way that each clause (from 1 to 7) evaluates to true. When the solver is done, the dependency tree consists of all variables that have been set to true. Let‚Äôs work out the previous clauses, to see it in action:</p>
<ul>
<li>Assign <code>true</code> to <code>foo 0.1.0</code>, per clause 1 (there is no other way to make clause 1 evaluate to true)</li>
<li>Assign <code>false</code> to <code>baz 0.2.0</code>, per clause 7 (there is no other way to make clause 7 evaluate to true)</li>
<li>Assign <code>false</code> to <code>bar 0.2.0</code>, per clause 4 (there is no other way to make clause 4 evaluate to true, given the previous variable assignments)</li>
<li>Assign <code>true</code> to <code>bar 0.1.0</code>, per clause 2 (there is no other way to make clause 2 evaluate to true, given the previous variable assignments)</li>
<li>Assign <code>true</code> to <code>baz 0.1.0</code>, per clause 3 (there is no other way to make clause 3 evaluate to true, given the previous variable assignments)</li>
<li>Finish, because all clauses evaluate to true</li>
</ul>
<p>Which packages are included in the dependency tree then? Those that have were set to true: <code>foo 0.1.0</code> -&gt; <code>bar 0.1.0</code> -&gt; <code>baz 0.1.0</code>.</p>
<h3 id="sat-solving">SAT solving</h3>
<p>Since we are able to express the dependency resolution problem in boolean clauses (such as those listed above), we can feed them<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup> to a SAT solving algorithm to obtain the solution.</p>
<p>The example above is, however, not representative of the complexity involved in solving a real-world dependency problem. Until now we have only looked at the process of assigning values to variables when a clause ‚Äúforces‚Äù us to do so (i.e. the assignment is required, because otherwise the clause would evaluate to false). This is also known as <a href="https://en.wikipedia.org/wiki/Unit_propagation">unit propagation</a> and is one of the core algorithms used in SAT solvers (implementing it efficiently requires some clever tricks such as <a href="https://cse.unl.edu/~choueiry/S18-235H/files/SATslides07.pdf">watched literals</a>, as you will find out if you read the <a href="http://minisat.se/downloads/MiniSat.pdf">MiniSAT paper</a>).</p>
<p>Unit propagation is not enough to drive the SAT solving process to completion, though. Most real-world scenarios allow multiple solutions, so there is often no ‚Äúlogical necessity‚Äù to set a variable‚Äôs value. You can compare it to solving a Sudoku: sometimes you know that, by necessity, a number should go in a particular cell. Other times you have to guess and hope your guess is right (you might find out later that your guess was actually wrong, because it led to inconsistencies down the road, in which case you need to backtrack).</p>
<p>With that in mind, here‚Äôs the real algorithm we use:</p>
<ol>
<li><strong>Initial unit propagation</strong>. There are always at least a few values that can be propagated at the beginning, such as the fact that the root package should be installed (i.e. its variable should be set to true). If propagation encounters a conflicting assignment<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup> at this stage, that means the original requirements are impossible to fulfill (e.g. the user wants to install packages that don‚Äôt exist, or are incompatible with each other).</li>
<li><strong>Solver loop</strong>:
<ol>
<li><strong>Stopping condition</strong>: If all clauses evaluate to true, we are done.</li>
<li><strong>Set</strong>: Arbitrarily assign a value to a variable that hasn‚Äôt been assigned yet.</li>
<li><strong>Propagate</strong>: Perform unit propagation. If propagation finished without conflicts, go back to 1.</li>
<li><strong>Learn and backtrack</strong>: Find the combination of assignments that caused the conflict and learn from them, so we do not repeat them in the future. If the conflict is unrecoverable, it means the original problem is unsolvable. If it is recoverable, backtrack and go back to step 1 of the solver loop.</li>
</ol>
</li>
</ol>
<p>Again, the Rust code is well documented and makes use of abstractions that can guide you through it, so don‚Äôt hesitate to <a href="https://github.com/mamba-org/rattler/blob/aaf4ced6426ccdb258f5ca51edf1b750be57a525/crates/libsolv_rs/src/solver/mod.rs#L224-L245">have a look</a> if you want to know <em>exactly</em> how things work under the hood.</p>
<h3 id="some-more-details-on-learning">Some more details on learning</h3>
<p>What does it mean for the solver to ‚Äúlearn‚Äù from the conflicts it sees? And how is it able to find the causes of a conflict? The answer to those questions is too long for this already long post, but here are a some pointers to pursue if you are determined to find out: the SAT solving algorithm we are using is called <a href="https://en.wikipedia.org/wiki/Conflict-driven_clause_learning">conflict-driven clause learning (CDCL)</a>. The <a href="http://minisat.se/downloads/MiniSat.pdf">MiniSAT paper</a> offers a great introduction to it, and even has <a href="https://cse.unl.edu/~choueiry/S18-235H/files/SATslides06.pdf">accompanying slides</a> on the topic of learning and backtracking. The gist of it is that, whenever a conflict is reached, a clause is generated that prevents the conflict from happening again.</p>
<h3 id="what-about-performance">What about performance?</h3>
<p>My first implementation was a tad slower than libsolv, but <a href="https://github.com/baszalmstra/">@baszalmstra</a> quickly generated a couple of <a href="https://github.com/flamegraph-rs/flamegraph#systems-performance-work-guided-by-flamegraphs">flamegraphs</a> and <a href="https://github.com/mamba-org/rattler/pull/251">refactored a bottleneck</a> to achieve performance parity. The benchmark results in the <a href="https://github.com/mamba-org/rattler/pull/251">pull request</a> even show slightly <em>better</em> performance for libsolv_rs!</p>
<p>Note that performance in SAT solvers is not dominated by low-level tricks, but by the algorithms used. SAT solvers have been studied for decades in Computer Science, and CDCL has established itself as an efficient algorithm even though the original problem is <a href="https://en.wikipedia.org/wiki/NP-completeness">NP-complete</a> (it finds solutions in milliseconds or a few seconds, at least in the specific domain of dependency resolution). We are truly standing on the shoulders of giants here.</p>
<h2 id="3-epilogue-on-trains-and-solvers">3. Epilogue: on trains and solvers</h2>
<p>Back to the fascination I mentioned in the introduction, I couldn‚Äôt close this article without quoting Chesterton‚Äôs ‚ÄúThe man who was Thursday‚Äù. In this fragment of the book, the poet Gabriel Syme gives a laudatory speech about the wonders of the train, which you could as well apply to computers in general!</p>
<blockquote>
<p>The rare, strange thing is to hit the mark; the gross, obvious thing is to miss it. We feel it is epical when man with one wild arrow strikes a distant bird. Is it not also epical when man with one wild engine strikes a distant station? Chaos is dull; because in chaos the train might indeed go anywhere, to Baker Street or to Bagdad. But man is a magician, and his whole magic is in this, that he does say Victoria, and lo! it is Victoria.</p>
</blockquote>
<p>Here‚Äôs my alternative closing of the quote:</p>
<blockquote>
<p>But the programmer is a magician, and his whole magic is in this, that he does say ‚Äúgive me the dependency tree for <code>x</code>, <code>y</code>, <code>z</code>‚Äù, and lo! it is the dependency tree for <code>x</code>, <code>y</code>, <code>z</code>.</p>
</blockquote>


</div></div>
  </body>
</html>
