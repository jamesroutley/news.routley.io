<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/raaidrt/tacopy">Original</a>
    <h1>Show HN: Tacopy – Tail Call Optimization for Python</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><strong>Tail-Call Optimization for Python</strong></p>
<p dir="auto">Tacopy is a Python library that provides a decorator to optimize tail-recursive functions by transforming them into iterative loops. This eliminates the risk of stack overflow errors for deep recursion.</p>

<ul dir="auto">
<li><strong>Automatic Tail-Call Optimization</strong>: Transforms tail-recursive functions into efficient loops</li>
<li><strong>Stack Overflow Prevention</strong>: Handle arbitrarily deep recursion without hitting Python&#39;s recursion limit</li>
<li><strong>Significant Performance Gains</strong>: <strong>1.41x-2.88x faster</strong> than regular recursion (see <a href="#performance-benchmarks">benchmarks</a>)</li>
<li><strong>Validation</strong>: Ensures functions are properly tail-recursive before transformation</li>
<li><strong>No Runtime Overhead</strong>: Optimization happens once at decoration time</li>
<li><strong>Preservation of Function Metadata</strong>: Keeps docstrings, type hints, and other metadata intact</li>
</ul>

<div dir="auto" data-snippet-clipboard-copy-content="# Using uv (recommended for development)
uv add tacopy-optimization

# Using pip
pip install tacopy-optimization"><pre><span><span>#</span> Using uv (recommended for development)</span>
uv add tacopy-optimization

<span><span>#</span> Using pip</span>
pip install tacopy-optimization</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="from tacopy import tacopy

@tacopy
def factorial_mod_k(acc: int, n: int, k: int) -&gt; int:
    &#34;&#34;&#34;Calculate (acc * n!) mod k using tail recursion.&#34;&#34;&#34;
    if n == 0:
        return acc % k
    return factorial_mod_k(acc * n % k, n - 1, k)

# This would normally cause a stack overflow, but works with @tacopy
result = factorial_mod_k(1, 1_000_000, 79)
print(result)  # Output: 0"><pre><span>from</span> <span>tacopy</span> <span>import</span> <span>tacopy</span>

<span>@<span>tacopy</span></span>
<span>def</span> <span>factorial_mod_k</span>(<span>acc</span>: <span>int</span>, <span>n</span>: <span>int</span>, <span>k</span>: <span>int</span>) <span>-&gt;</span> <span>int</span>:
    <span>&#34;&#34;&#34;Calculate (acc * n!) mod k using tail recursion.&#34;&#34;&#34;</span>
    <span>if</span> <span>n</span> <span>==</span> <span>0</span>:
        <span>return</span> <span>acc</span> <span>%</span> <span>k</span>
    <span>return</span> <span>factorial_mod_k</span>(<span>acc</span> <span>*</span> <span>n</span> <span>%</span> <span>k</span>, <span>n</span> <span>-</span> <span>1</span>, <span>k</span>)

<span># This would normally cause a stack overflow, but works with @tacopy</span>
<span>result</span> <span>=</span> <span>factorial_mod_k</span>(<span>1</span>, <span>1_000_000</span>, <span>79</span>)
<span>print</span>(<span>result</span>)  <span># Output: 0</span></pre></div>

<p dir="auto">Tacopy uses AST (Abstract Syntax Tree) transformation to convert tail-recursive functions into iterative loops. For example:</p>
<p dir="auto"><strong>Original function:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="@tacopy
def factorial(n: int, acc: int = 1) -&gt; int:
    if n == 0:
        return acc
    return factorial(n - 1, acc * n)"><pre><span>@<span>tacopy</span></span>
<span>def</span> <span>factorial</span>(<span>n</span>: <span>int</span>, <span>acc</span>: <span>int</span> <span>=</span> <span>1</span>) <span>-&gt;</span> <span>int</span>:
    <span>if</span> <span>n</span> <span>==</span> <span>0</span>:
        <span>return</span> <span>acc</span>
    <span>return</span> <span>factorial</span>(<span>n</span> <span>-</span> <span>1</span>, <span>acc</span> <span>*</span> <span>n</span>)</pre></div>
<p dir="auto"><strong>Transformed to (conceptually):</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="def factorial(n: int, acc: int = 1) -&gt; int:
    _n = n
    _acc = acc
    while True:
        if _n == 0:
            return _acc
        _n, _acc = _n - 1, _acc * _n"><pre><span>def</span> <span>factorial</span>(<span>n</span>: <span>int</span>, <span>acc</span>: <span>int</span> <span>=</span> <span>1</span>) <span>-&gt;</span> <span>int</span>:
    <span>_n</span> <span>=</span> <span>n</span>
    <span>_acc</span> <span>=</span> <span>acc</span>
    <span>while</span> <span>True</span>:
        <span>if</span> <span>_n</span> <span>==</span> <span>0</span>:
            <span>return</span> <span>_acc</span>
        <span>_n</span>, <span>_acc</span> <span>=</span> <span>_n</span> <span>-</span> <span>1</span>, <span>_acc</span> <span>*</span> <span>_n</span></pre></div>
<p dir="auto">The transformation:</p>
<ol dir="auto">
<li>Hoists parameters to uniquely-named local variables (using UUIDs to avoid collisions)</li>
<li>Wraps the function body in a <code>while True</code> loop</li>
<li>Replaces tail-recursive calls with variable assignments and <code>continue</code> statements</li>
</ol>


<div dir="auto" data-snippet-clipboard-copy-content="@tacopy
def fibonacci(n: int, a: int = 0, b: int = 1) -&gt; int:
    &#34;&#34;&#34;Calculate the nth Fibonacci number.&#34;&#34;&#34;
    if n == 0:
        return a
    if n == 1:
        return b
    return fibonacci(n - 1, b, a + b)

# Calculate very large Fibonacci numbers
fib_5000 = fibonacci(5000)"><pre><span>@<span>tacopy</span></span>
<span>def</span> <span>fibonacci</span>(<span>n</span>: <span>int</span>, <span>a</span>: <span>int</span> <span>=</span> <span>0</span>, <span>b</span>: <span>int</span> <span>=</span> <span>1</span>) <span>-&gt;</span> <span>int</span>:
    <span>&#34;&#34;&#34;Calculate the nth Fibonacci number.&#34;&#34;&#34;</span>
    <span>if</span> <span>n</span> <span>==</span> <span>0</span>:
        <span>return</span> <span>a</span>
    <span>if</span> <span>n</span> <span>==</span> <span>1</span>:
        <span>return</span> <span>b</span>
    <span>return</span> <span>fibonacci</span>(<span>n</span> <span>-</span> <span>1</span>, <span>b</span>, <span>a</span> <span>+</span> <span>b</span>)

<span># Calculate very large Fibonacci numbers</span>
<span>fib_5000</span> <span>=</span> <span>fibonacci</span>(<span>5000</span>)</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Greatest Common Divisor (GCD)</h3><a id="user-content-greatest-common-divisor-gcd" aria-label="Permalink: Greatest Common Divisor (GCD)" href="#greatest-common-divisor-gcd"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="@tacopy
def gcd(a: int, b: int) -&gt; int:
    &#34;&#34;&#34;Calculate GCD using Euclidean algorithm.&#34;&#34;&#34;
    if b == 0:
        return a
    return gcd(b, a % b)

print(gcd(1071, 462))  # Output: 21"><pre><span>@<span>tacopy</span></span>
<span>def</span> <span>gcd</span>(<span>a</span>: <span>int</span>, <span>b</span>: <span>int</span>) <span>-&gt;</span> <span>int</span>:
    <span>&#34;&#34;&#34;Calculate GCD using Euclidean algorithm.&#34;&#34;&#34;</span>
    <span>if</span> <span>b</span> <span>==</span> <span>0</span>:
        <span>return</span> <span>a</span>
    <span>return</span> <span>gcd</span>(<span>b</span>, <span>a</span> <span>%</span> <span>b</span>)

<span>print</span>(<span>gcd</span>(<span>1071</span>, <span>462</span>))  <span># Output: 21</span></pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="@tacopy
def sum_to_n(n: int, acc: int = 0) -&gt; int:
    &#34;&#34;&#34;Calculate sum from 1 to n.&#34;&#34;&#34;
    if n == 0:
        return acc
    return sum_to_n(n - 1, acc + n)

print(sum_to_n(100))  # Output: 5050"><pre><span>@<span>tacopy</span></span>
<span>def</span> <span>sum_to_n</span>(<span>n</span>: <span>int</span>, <span>acc</span>: <span>int</span> <span>=</span> <span>0</span>) <span>-&gt;</span> <span>int</span>:
    <span>&#34;&#34;&#34;Calculate sum from 1 to n.&#34;&#34;&#34;</span>
    <span>if</span> <span>n</span> <span>==</span> <span>0</span>:
        <span>return</span> <span>acc</span>
    <span>return</span> <span>sum_to_n</span>(<span>n</span> <span>-</span> <span>1</span>, <span>acc</span> <span>+</span> <span>n</span>)

<span>print</span>(<span>sum_to_n</span>(<span>100</span>))  <span># Output: 5050</span></pre></div>
<div dir="auto"><h2 tabindex="-1" dir="auto">Requirements for Tail Recursion</h2><a id="user-content-requirements-for-tail-recursion" aria-label="Permalink: Requirements for Tail Recursion" href="#requirements-for-tail-recursion"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">For a function to be optimizable with <code>@tacopy</code>, it must be <strong>properly tail-recursive</strong>:</p>
<ol dir="auto">
<li><strong>Module-level function</strong> - The function must be defined at module level, not nested inside another function</li>
<li><strong>All recursive calls must be in tail position</strong> - the return value of the recursive call must be immediately returned, with no further operations</li>
<li><strong>No async functions</strong> - Async functions are not supported due to potential issues with shared state</li>
</ol>

<div dir="auto" data-snippet-clipboard-copy-content="@tacopy
def valid(n, acc):
    if n == 0:
        return acc
    return valid(n - 1, acc + n)  # � Tail call - immediately returned"><pre><span>@<span>tacopy</span></span>
<span>def</span> <span>valid</span>(<span>n</span>, <span>acc</span>):
    <span>if</span> <span>n</span> <span>==</span> <span>0</span>:
        <span>return</span> <span>acc</span>
    <span>return</span> <span>valid</span>(<span>n</span> <span>-</span> <span>1</span>, <span>acc</span> <span>+</span> <span>n</span>)  <span># � Tail call - immediately returned</span></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Invalid (Non-Tail) Recursion</h3><a id="user-content-invalid-non-tail-recursion" aria-label="Permalink: Invalid (Non-Tail) Recursion" href="#invalid-non-tail-recursion"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="@tacopy
def invalid(n):
    if n == 0:
        return 1
    return n * invalid(n - 1)  # � NOT tail recursive - multiplication after call"><pre><span>@<span>tacopy</span></span>
<span>def</span> <span>invalid</span>(<span>n</span>):
    <span>if</span> <span>n</span> <span>==</span> <span>0</span>:
        <span>return</span> <span>1</span>
    <span>return</span> <span>n</span> <span>*</span> <span>invalid</span>(<span>n</span> <span>-</span> <span>1</span>)  <span># � NOT tail recursive - multiplication after call</span></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Nested Functions Not Allowed</h3><a id="user-content-nested-functions-not-allowed" aria-label="Permalink: Nested Functions Not Allowed" href="#nested-functions-not-allowed"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="def outer():
    @tacopy  # ❌ Error: nested functions cannot use @tacopy
    def helper(n, acc):
        if n == 0:
            return acc
        return helper(n - 1, acc + n)
    return helper(10, 0)

# ✅ Correct: Extract to module level
@tacopy
def helper(n, acc):
    if n == 0:
        return acc
    return helper(n - 1, acc + n)

def outer():
    return helper(10, 0)"><pre><span>def</span> <span>outer</span>():
    <span>@<span>tacopy</span>  <span># ❌ Error: nested functions cannot use @tacopy</span></span>
    <span>def</span> <span>helper</span>(<span>n</span>, <span>acc</span>):
        <span>if</span> <span>n</span> <span>==</span> <span>0</span>:
            <span>return</span> <span>acc</span>
        <span>return</span> <span>helper</span>(<span>n</span> <span>-</span> <span>1</span>, <span>acc</span> <span>+</span> <span>n</span>)
    <span>return</span> <span>helper</span>(<span>10</span>, <span>0</span>)

<span># ✅ Correct: Extract to module level</span>
<span>@<span>tacopy</span></span>
<span>def</span> <span>helper</span>(<span>n</span>, <span>acc</span>):
    <span>if</span> <span>n</span> <span>==</span> <span>0</span>:
        <span>return</span> <span>acc</span>
    <span>return</span> <span>helper</span>(<span>n</span> <span>-</span> <span>1</span>, <span>acc</span> <span>+</span> <span>n</span>)

<span>def</span> <span>outer</span>():
    <span>return</span> <span>helper</span>(<span>10</span>, <span>0</span>)</pre></div>
<p dir="auto">The decorator will raise a <code>TailRecursionError</code> if the function is not properly tail-recursive or if it is nested inside another function.</p>

<p dir="auto">You can view the transformed code without executing it:</p>
<div dir="auto" data-snippet-clipboard-copy-content="from tacopy import show_transformed_code

def factorial(n: int, acc: int = 1) -&gt; int:
    if n == 0:
        return acc
    return factorial(n - 1, acc * n)

print(show_transformed_code(factorial))"><pre><span>from</span> <span>tacopy</span> <span>import</span> <span>show_transformed_code</span>

<span>def</span> <span>factorial</span>(<span>n</span>: <span>int</span>, <span>acc</span>: <span>int</span> <span>=</span> <span>1</span>) <span>-&gt;</span> <span>int</span>:
    <span>if</span> <span>n</span> <span>==</span> <span>0</span>:
        <span>return</span> <span>acc</span>
    <span>return</span> <span>factorial</span>(<span>n</span> <span>-</span> <span>1</span>, <span>acc</span> <span>*</span> <span>n</span>)

<span>print</span>(<span>show_transformed_code</span>(<span>factorial</span>))</pre></div>

<p dir="auto">Tacopy provides significant performance improvements over regular recursion. Below are benchmark results comparing tail-recursive functions with and without the <code>@tacopy</code> decorator (100 runs each, recursion depth of 1000):</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Function</th>
<th>Without tacopy</th>
<th>With tacopy</th>
<th>Speedup</th>
<th>Performance Change</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>factorial(1000)</code></td>
<td>0.000230 ± 0.000117s</td>
<td>0.000163 ± 0.000019s</td>
<td><strong>1.41x faster</strong></td>
<td>29.2% faster</td>
</tr>
<tr>
<td><code>fibonacci(1000)</code></td>
<td>0.000083 ± 0.000008s</td>
<td>0.000045 ± 0.000013s</td>
<td><strong>1.86x faster</strong></td>
<td>46.4% faster</td>
</tr>
<tr>
<td><code>sum_to_n(1000)</code></td>
<td>0.000074 ± 0.000013s</td>
<td>0.000026 ± 0.000002s</td>
<td><strong>2.88x faster</strong></td>
<td>65.2% faster</td>
</tr>
<tr>
<td><code>power(2, 1000)</code></td>
<td>0.000087 ± 0.000008s</td>
<td>0.000044 ± 0.000008s</td>
<td><strong>1.97x faster</strong></td>
<td>49.3% faster</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>

<ul dir="auto">
<li><strong>1.41x-2.88x speedup</strong> for typical tail-recursive functions</li>
<li><strong>Eliminates stack overflow</strong>: Regular Python recursion is limited to 1000 calls, while tacopy can handle millions</li>
<li><strong>Lower variance</strong>: Tacopy-optimized functions show more consistent performance (lower standard deviation)</li>
</ul>

<p dir="auto">You can run the benchmarking suite yourself:</p>
<div dir="auto" data-snippet-clipboard-copy-content="uv run python benchmarking/benchmark.py"><pre>uv run python benchmarking/benchmark.py</pre></div>
<p dir="auto">The benchmarks use a recursion depth of 1000 for non-tacopy functions and pure integer arithmetic in the sample implementations. See <a href="https://github.com/raaidrt/tacopy/blob/main/benchmarking/README.md">benchmarking/README.md</a> for more details.</p>


<div dir="auto" data-snippet-clipboard-copy-content="# Clone the repository
git clone https://github.com/yourusername/tacopy.git
cd tacopy

# Install dependencies using uv
uv sync

# Activate virtual environment
source .venv/bin/activate  # On Unix/macOS
# or
.venv\Scripts\activate  # On Windows"><pre><span><span>#</span> Clone the repository</span>
git clone https://github.com/yourusername/tacopy.git
<span>cd</span> tacopy

<span><span>#</span> Install dependencies using uv</span>
uv sync

<span><span>#</span> Activate virtual environment</span>
<span>source</span> .venv/bin/activate  <span><span>#</span> On Unix/macOS</span>
<span><span>#</span> or</span>
.venv<span>\S</span>cripts<span>\a</span>ctivate  <span><span>#</span> On Windows</span></pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="# Run all tests
pytest tests/ -v

# Run with coverage
pytest tests/ --cov=tacopy --cov-report=html

# Update snapshots (if you&#39;ve changed transformation logic)
pytest tests/ --snapshot-update"><pre><span><span>#</span> Run all tests</span>
pytest tests/ -v

<span><span>#</span> Run with coverage</span>
pytest tests/ --cov=tacopy --cov-report=html

<span><span>#</span> Update snapshots (if you&#39;ve changed transformation logic)</span>
pytest tests/ --snapshot-update</pre></div>

<div data-snippet-clipboard-copy-content="tacopy/
├── src/
│   └── tacopy/
│       ├── __init__.py      # Main decorator and public API
│       ├── validator.py     # Tail recursion validation
│       ├── transformer.py   # AST transformation logic
│       └── unparser.py      # AST to code conversion
├── tests/
│   ├── test_validator.py    # Validator unit tests
│   ├── test_transformer.py  # Transformer unit tests
│   └── test_integration.py  # End-to-end integration tests
├── main.py                  # Example usage
├── DESIGN.md                # Design document
└── README.md                # This file"><pre><code>tacopy/
├── src/
│   └── tacopy/
│       ├── __init__.py      # Main decorator and public API
│       ├── validator.py     # Tail recursion validation
│       ├── transformer.py   # AST transformation logic
│       └── unparser.py      # AST to code conversion
├── tests/
│   ├── test_validator.py    # Validator unit tests
│   ├── test_transformer.py  # Transformer unit tests
│   └── test_integration.py  # End-to-end integration tests
├── main.py                  # Example usage
├── DESIGN.md                # Design document
└── README.md                # This file
</code></pre></div>

<ol dir="auto">
<li><strong>Module-level functions only</strong>: The decorator can only be applied to functions defined at module level, not nested inside other functions. If you need to optimize a helper function, extract it to module level.</li>
<li><strong>Async functions not supported</strong>: The decorator will raise an error if applied to async functions</li>
<li><strong>Source code required</strong>: The function&#39;s source code must be accessible via <code>inspect.getsource()</code></li>
<li><strong>No mutual recursion</strong>: Only direct self-recursion is optimized</li>
<li><strong>Python 3.10+</strong>: Requires Python 3.10 or higher</li>
</ol>

<p dir="auto">Contributions are welcome! Please feel free to submit a Pull Request.</p>

<p dir="auto">This project is licensed under the GNU General Public License v3.0 - see the <a href="https://github.com/raaidrt/tacopy/blob/main/LICENSE">LICENSE</a> file for details.</p>

<ul dir="auto">
<li><a href="https://github.com/raaidrt/tacopy/blob/main/DESIGN.md">DESIGN.md</a> - Detailed design document</li>
<li><a href="https://docs.python.org/3/library/ast.html" rel="nofollow">Python AST Documentation</a></li>
</ul>
</article></div></div>
  </body>
</html>
