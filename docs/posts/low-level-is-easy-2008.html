<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://yosefk.com/blog/low-level-is-easy.html">Original</a>
    <h1>Low-level is easy (2008)</h1>
    
    <div id="readability-page-1" class="page"><div>
				<p>My previous entry has the amazingly interesting title &#34;Blogging is hard&#34;. Gee, what a wuss, says the occasional passer-by. Gotta fix my image, fast. Think, think, think! OK, here&#39;s what I&#39;m going to tell you: low-level programming is easy. Compared to higher-level programming, that is. I&#39;m serious.</p>
<p>For starters, here&#39;s a story about an amazing developer, who shall rename nameless for the moment. See, I know this amazing developer. Works for Google now. Has about 5 years of client-side web programming under his belt. And the word &#34;nevermore&#34; tattooed all over his body (in the metaphorical sense; I think; I haven&#39;t really checked). One time, I decided that I have to understand this nevermore business. &#34;Amazing Developer&#34;, I said, &#34;why have you quit the exciting world of web front-ends?&#34; &#34;I don&#39;t like it&#34;, says the Amazing Developer. &#34;But, but! What about The Second Dot Com Bubble? VC funds will beg you to take their $1M to develop the next <a title="Arsebook" href="http://facebook.com">Arsebook</a> or what-not. Don&#39;t you wanna be rich?&#34; <em>&#34;I really don&#39;t like web front-ends very much&#34;</em>, he kept insisting. Isn&#39;t that strange? How do you explain it? I just kept asking.</p>
<p>Now that I think of it, he probably was a little bit irritated at this point. &#34;Look, pal&#34;, he said (in the metaphorical sense; he didn&#39;t actually say it like that; he&#39;s very polite). &#34;I have a license to drive a 5-ton truck. But I don&#39;t want a career in truck driving. Hope this clarifies things&#34;. He also said something about your average truck driver being more <em>something </em>than your typical web developer, but I don&#39;t remember the exact insult.</p>
<p>Now, I&#39;ve been working with bare metal hardware for the last 4 years. No OS, no drivers, nothing. In harsh environments in terms of hardware, by comparison. For example, in multi-core desktops, when you modify a cached variable, the cache of the other processor sees the update. In our chips? Forget it. Automatic hardware-level maintenance of memory coherency is pretty fresh news in these markets. And it <em>sucks </em>when you change a variable and then the other processor decides to write back its outdated cache line, overwriting your update. It totally sucks.</p>
<p>A related data point: I&#39;m a whiner, by nature. Whine whine whine. You&#39;ve probably found this blog through the <a title="C++ FQA" href="http://yosefk.com/c++fqa">C++ FQA</a>, so you already know all about my whining. And it&#39;s not like I haven&#39;t been burnt by low-level bugs. Oh, I had that. Right before deadlines. Weekends of fun. So how come I don&#39;t run away from this stuff screaming and shouting? Heck, I don&#39;t mind dealing with bare metal machines for the rest of my career. Well, trying out other stuff instead can be somewhat more interesting, but bare metal beats truck driving, I can tell you that. To be fair, I can&#39;t really be sure about that last point – I can&#39;t drive. At all. Maybe that explains everything?</p>
<p>I&#39;ll tell you how I really explain all of this. No, not right in this next sentence; there&#39;s a truckload of reasons (about 5 tons), so it might take some paragraphs. Fasten your seatbelts.</p>
<p>What does &#34;high level&#34; basically mean? The higher your level, the more levels you have below you. This isn&#39;t supposed to matter in the slightest: at your level, you are given a set of ways to manipulate the existing lower-level environment, and you build your stuff on top of that. Who cares about the number of levels below? The important thing is, how easily can I build my new stuff? If I mess with volatile pointers and hardware registers and overwrite half the universe upon the slightest error, it sucks. If I can pop up a window using a single function, that&#39;s the way I like it. Right? Well, it is roughly so, but there are problems.</p>
<p><strong>Problem 1</strong>: the stuff below you is huge at higher levels. In my humble opinion, HTML, CSS, JavaScript, XML and DOM are a lot of things. Lots of spec pages. A CPU is somewhat smaller. You have the assembly commands needed to run C (add/multiply, load/store, branch). You have the assembly commands needed to run some sort of OS (move to/from system co-processor register; I dunno, tens of flavors per mid-range RISC core these days?). And you have the interrupt handling rules (put the reset handler here, put the data abort handler here, the address which caused the exception can be obtained thusly). That&#39;s all.</p>
<p>I keep what feels like most of ARM946E-S in my brain; stuff that&#39;s still outside of my brain probably never got in my way. It&#39;s not a particularly impressive result; for example, the fellow sitting next to me can beat me (&#34;physically and intellectually&#34;, as the quote by Muhammad Ali goes; in his case, the latter was a serious exaggeration – he was found too dumb for the US army, but I digress). Anyway, this guy next to me has a MIPS 34Kf under his skull, and he looks like he&#39;s having fun. That&#39;s somewhat more complicated than ARM9. And I worked on quite some MFC-based GUIs (<em>ewww</em>) back in the Rich Client days; at no point I felt like keeping most of MFC or COM or Win32 in my head. I doubt it would fit.</p>
<p><strong>Problem 2</strong>: the stuff below you is broken. I&#39;ve seen hardware bugs; 1 per 100 low-level software bugs and per 10000 high-level software bugs. I think. I feel. I didn&#39;t count. But you probably trust me on this one, anyway. How many problems did you have with hardware compared to OS compared to end-user apps? According to most evidence I got, JavaScript does whatever the hell it wants at each browser. Hardware is not like that. CPUs from the same breed will run the user-level instructions identically or get off the market. Memory-mapped devices following a hardware protocol for talking to the bus will actually follow it, damn it, or get off the market.</p>
<p>Low-level things are likely to work correctly since there&#39;s tremendous pressure for them to do so. Because otherwise, <em>all </em>the higher-level stuff will collapse, and everybody will go &#34;AAAAAAAAAA!!&#34; Higher-level things carry less weight. OK, so five web apps are broken by this browser update (or an update to a system library used by the browser or any other part of the pyramid). If your web app broke, your best bet is to fix it, not to wait until the problem is resolved at the level below. The higher your level, the loner you become. Not only do you depend on more stuff that can break, there are less people who care in each particular case.</p>
<p><strong>Problem 3</strong>: you can rarely fix the broken things below your level. Frequently you don&#39;t have the source. Oh, the browser is open source? Happy, happy, joy, joy! You can actually dive into the huge code base (working below your normal level of abstraction where you at least know the vocabulary), fix the bug and… And hope everyone upgrades soon enough. Is this always a smart bet? You can have open source hardware, you know. Hardware is written in symbolic languages, with structured flow and everything. The only trouble is, people at home can&#39;t recompile their CPUs. Life cycle. It&#39;s all about life cycle. Your higher-level thingie wants to be out there in the wild <em>now, </em>and all those other bits and pieces live according to their own schedules. You end up working around the bug at your end. Sometimes preventing the lower-level component author from fixing the bug, since that would break yours and everybody else&#39;s workaround. Whoopsie.</p>
<p>How complicated is your workaround going to be? The complexity raises together with your level of abstraction, too. That&#39;s because higher-level components process more complicated inputs. Good workarounds are essentially ways to avoid inputs which break the buggy implementation. Bad workarounds are ways to feed inputs which <em>shouldn&#39;t</em> result in the right behavior, but <em>do </em>lead to it with the buggy implementation. Good workarounds are better than bad workarounds because bad workarounds break when the implementation is fixed. But either way, you have to constrain or transform the inputs. Primitive sets of inputs are easier to constrain or transform than complicated sets of inputs. Therefore, low-level bugs are easier to work around. QED.</p>
<p>Low-level: &#34;Don&#39;t write that register twice in a row; issue a read between the writes&#34;. *Grump* stupid hardware. OK, done. Next.</p>
<p>High-level: &#34;Don&#39;t do something, um, shit, I don&#39;t know <em>what </em>exactly, well, <em>something</em> to interactive OLE rectangle trackers; they will repaint funny&#34;. I once worked on an app for editing forms, much like the Visual Studio 6 resource editor. In my final version, the RectTracker would repaint funny, <em>exactly </em>the way it would in Visual Studio 6 in similar cases. I think I understood the exact circumstances back then, but haven&#39;t figured out a reasonable way to avoid them. Apparently the people working at that abstraction level at Microsoft couldn&#39;t figure it out, either. What&#39;s that? Microsoft software is always crap? You&#39;re a moron who thinks everything is absolutely trivial to get right because you&#39;ve never done anything worthwhile in your entire life. Next.</p>
<p><strong>Problem 4</strong>: at higher levels, you can&#39;t even understand what&#39;s going on. With bare metal machines, you just stop the processor, physically (nothing runs), and then read every bit of memory you want. All the data is managed by a single program, so you can display every variable and see the source code of every function. The ultimate example of the fun that is higher-level debugging is a big, slow, hairy shell script. &#34;rm: No match.&#34; Who the hell said <em>that</em>, and how am I supposed to find out? It could be ten sub-shells below. Does it even matter? So what if I couldn&#39;t remove some files? Wait, but why were they missing – <em>someone </em>thought they should be there? Probably based on the assumption that a program should have generated them previously, so <em>that </em>program is broken. Which program? AAARGH!!</p>
<p>OK, so shell scripts aren&#39;t the best example of high-level languages. Or maybe you think they are; have fun. I don&#39;t care. I had my share of language wars. This isn&#39;t about languages. I want to move on to the next example. No shell scripts. You have JavaScript (language 1) running inside HTML/CSS (languages 2 &amp; 3) under Firefox (written in language 4) under Windows (no source code), talking to a server written in PHP (language 5, one good one) under Linux (yes source code, but no way to do symbolic debugging of the kernel nonetheless). I think it somewhat complicates the debugging process; surely no single debugger will ever be able to make sense of <em>that</em>.</p>
<p><strong>Problem 5</strong>: as you climb higher, the amount of options grows exponentially. A tree has one root, a few thick branches above it, and thousands of leaves at the top. Bend the root and the tree falls. But leaves, those can grow in whichever direction they like.</p>
<p>Linkers are <em>so low-level</em> that they&#39;re practically <em>portable</em>, and they&#39;re all alike. What can you come up with when you swim that low? Your output is a memory map. A bunch of segments. Base, size, bits, base, size, bits. Kinda limits your creativity. GUI toolkits? The next one is of course easier to master than the first one, but they are <em>really </em>different. What format do you use to specify layouts, which part is data-driven and which is spelled as code? How do you handle the case where the GUI is running on a remote machine? Which UI components are built-in? Do you have a table control with cell joining and stuff or just a list control? Does your edit box check spelling? How? I want to use my own dictionary! Which parts of the behavior of existing controls can be overridden and how? Do you use native widgets on each host, surprising users who switch platforms, or roll your own widgets, surprising the users who don&#39;t?</p>
<p>HTML and Qt are both essentially UI platforms. Counts as &#34;different enough&#34; for me. Inevitably, both suck in different ways which you find out after choosing the wrong one (well, it may be obvious with those two from the very beginning; Qt and gtk are probably a better example). Porting across them? Ha.</p>
<p>The fundamental issue is, for many lower-level problems there&#39;s The Right Answer (IEEE floating point). Occasionally The Wrong Answer gains some market share and you have to live with that (big endian; lost some market share recently). With higher-level things, it&#39;s virtually impossible to define which answer is right. This interacts badly with the ease of hacking up your own incompatible higher-level nightmare. Which brings us to…</p>
<p><strong>Problem 6</strong>: everybody thinks high-level is easy, on the grounds that it&#39;s visibly <em>faster</em>. You sure can develop more high-level functionality in a given time slot compared to the lower-level kind. So what? You can drive faster than you can walk. But driving isn&#39;t <em>easier</em>; everybody can walk, but to drive, you need a <em>license</em>. Perhaps that was the thing mentioned by the Awesome (Ex-Web) Developer: at least truck drivers have licenses. But I&#39;m not sure that&#39;s what he said. I&#39;ll tell you what I do know for sure: every second WordPress theme I tried was broken out of the box, in one of three ways: (1) PHP error, (2) SQL error and (3) a link pointing to a missing page. WordPress themes are written in CSS and PHP. Every moron can pick up CSS and PHP; apparently, every moron <em>did </em>pick them up. Couldn&#39;t they keep the secret at least from some of them? Whaaaam! The speedy 5-ton truck goes right into the tree. Pretty high-level leaves fall off, covering the driver&#39;s bleeding corpse under the tender rays of sunset. And don&#39;t get me started about the WordPress entry editing window.</p>
<p>Now, while every moron tries his luck with higher-level coding, it&#39;s not like everyone doing high-level coding is… you get the idea. The other claim is not true. In fact, this entry is <em>all about</em> how the other claim isn&#39;t true. There are lots of brilliant people working on high-level stuff. The problem is, they are not alone. The higher your abstraction level, the lower the quality of the average code snippet you bump into. Because it&#39;s easy to hack up by the copy-and-paste method, it sorta works, and if it doesn&#39;t, it seems to do, on average, and if it broke your stuff, it quite likely <em>your </em>problem, remember?</p>
<p><strong>Problem 7</strong>: it&#39;s not just the developers who think it&#39;s oh-so-easy. Each and every end user thinks he knows exactly what features you need. Each and every manager thinks so, too. Sometimes they disagree, and no, the manager doesn&#39;t always think that &#34;the customer is always right&#34;. But that&#39;s another matter. The point here is that when you do something &#34;easy&#34;, too many people will tell you how it sucks, and you have to just live with that (of course having 100 million users can comfort you, but that is still another matter, and there are times when you can&#39;t count on that).</p>
<p>I maintain low-level code, and people are sort of happy with it. Sometimes I think it has sucky bits, which get in your way. In these cases, I actually have to <em>convince </em>people that these things should be changed, because everybody is afraid to break something at that level. Hell, even bug fixes are treated like something nice you&#39;ve done, as if you weren&#39;t supposed to fix your goddamn bugs. Low-level is intimidating. BITS! REGISTERS! HEXADECIMAL! HELP!!</p>
<p>Some people abuse their craft and actively intimidate others. I&#39;m not saying you should do that; in fact, this entry is <em>all about </em>how you shouldn&#39;t do that. The people who do it are bastards. I&#39;ve known such a developer; I call him The Bastard. I might publish the adventures of The Bastard some day, but I need to carefully consider this. I&#39;m pretty sure that the Awesome Developer won&#39;t mind if someone recognizes him in a publicly available page, but I&#39;m not so sure about The Bastard for some reason or other.</p>
<p>What I&#39;m saying is, maintaining high-level code is extremely hard. Making a change is easy; making it right without breaking anything isn&#39;t. You can drive into a tree in no time. High-level code has a zillion of requirements, and as time goes by, the chance that many of them are implicit and undocumented and nobody even remembers them grows. People don&#39;t get it. It&#39;s a big social problem. As a low-level programmer, you have to convince people not to be afraid when you give them something. As a high-level programmer, you have to convince them that you can&#39;t just give them more and <em>more </em>and MORE. Guess which is easier. It&#39;s like paying, which is always less hassle than getting paid. Even if you deal with a Large, Respectful Organization. Swallowing is easier than spitting, even for respectful organizations. Oops, there&#39;s an unintended connotation in there. Fuck that. I&#39;m not editing this out. I want to be through with this. Let&#39;s push forward.</p>
<p>The most hilarious myth is that &#34;software is easy to fix&#34;; of course it refers to application software, not &#34;system&#34; software. Ever got an e-mail with a &#34;&gt;From&#34; at the beginning of a line? I keep getting those once in a while. Originally, the line said &#34;From&#34; and then it got quoted by sendmail or a descendant. The bug has been around for decades. The original hardware running sendmail is dead. And that hardware had no bugs. The current hardware running sendmail has no bugs, either. Those bugs were fixed somewhere during the testing phase. Application software is <em>never </em>tested like hardware. I know, because I&#39;ve spent about 9 months, the better part of 2007, writing hardware tests. Almost no features; testing, exclusively. And I was just one of the few people doing testing. You see, you <em>can&#39;t</em> fix a hardware bug; it will cost you $1M, at least. The result is that you test the hardware model before manufacturing, and you <em>do </em>fix the bug. But with software, you can always change it later, so you don&#39;t do testing. In hardware terms, the testing most <em>good</em> software undergoes would be called &#34;no testing&#34;. And then there&#39;s already a large installed base, plus quick-and-dirty mailbox-parsing scripts people wrote, and all those mailboxes lying around, and no way to make any sense of them without maintaining bugward compatibility (the term belongs to a colleague of mine, who – guess what – maintains a high-level code base). So you never fix the bug. And most higher-level code is <em>portable</em>; its bugs can live <em>forever</em>.</p>
<p>And the deadlines. The amount of versions of software you can release. 1.0, 1.1, 1.1.7, 1.1.7.3… The higher your abstraction level, the more changes they want, the more intermediate versions and branches you&#39;ll wind up with. And then you have to support <em>all of them</em>. Maybe they have to be able to read each other&#39;s data files. Maybe they need to load each other&#39;s modules. And they are high-level. Lots of stuff below each of them, lots of functionality in them. Lots of modules and data files.<em> </em>Lots of developers, some of whom mindlessly added features which grew important and must be supported.<em> Damn…</em></p>
<p>I bet that you&#39;re convinced that &#34;lower-level&#34; correlates with &#34;easier&#34; by now. Unless you got tired and moved elsewhere, in which case I&#39;m not even talking to you. QED.</p>
<p>Stay tuned for The Adventures of The Bastard.</p>
							</div></div>
  </body>
</html>
