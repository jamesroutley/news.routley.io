<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ssg.dev/safe-zero-copy-operations-in-c/">Original</a>
    <h1>Safe zero-copy operations in C#</h1>
    
    <div id="readability-page-1" class="page"><section>
            <p>C# is a versatile language. You can write mobile apps, desktop apps, games, websites, services and APIs with it. You can write it like Java with all the abstractions and <code>AbstractionFactoryClassProvider</code>s. But differently from Java, you can write low-level and unsafe code too. When I say low-level, I mean without the GC, with raw pointers. </p><p>Low-level code is usually required for performance or interoperability with C libraries or the operating system. The reason low-level code helps with performance is that it can be used to eliminate runtime checks on memory accesses.</p><p><strong>Array element accesses are bounds-checked in C# for safety</strong>. But, that means that there&#39;s performance impact unless the compiler can eliminate a bounds-checking operation. The bounds-checking elimination logic needs to ensure that the array index was already bounds-checked before, or can be assured to be inside bounds during the compile-time. For example, take this simple function:</p><pre><code>int sum(int[] array)
{
  int sum = 0;
  for (int i = 0; i &lt; array.Length; i++)
  {
    sum += array[i];
  }
  return sum;
}</code></pre><p>That&#39;s an ideal situation for bounds-checking elimination because the index variable <code>i</code> is created with known boundaries, and it depends on the array&#39;s length. The index variable&#39;s lifetime is shorter than the array&#39;s lifetime and it&#39;s guaranteed to be contained valid values throughout the function. The native code produced for <code>sum</code> has no bounds-checking:</p><pre><code>L0000	xor	    eax, eax
L0002	xor	    edx, edx
L0004	mov     r8d, [rcx+8]          ; read length
L0008	test    r8d, r8d              ; is empty?
L000b	jle	    short L001c           ; skip the loop
L000d	mov	    r10d, edx
L0010	add	    eax, [rcx+r10*4+0x10] ; sum += array[i];
L0015	inc	    edx                   ; i++
L0017	cmp	    r8d, edx              ; compare length with i
L001a	jg	    short L000d           ; loop if still greater
L001c	ret	</code></pre><p>But, what if the function signature was slightly different?</p><pre><code>int sum(int[] array, int startIndex, int endIndex)
{
  int sum = 0;
  for (int i = startIndex; i &lt;= endIndex; i++)
  {
    sum += array[i];
  }
  return sum;
}</code></pre><p>Now, the C# compiler doesn&#39;t have a way to know if the passed <code>startIndex</code> and <code>endIndex</code> values are inside the boundaries of <code>array</code> because their lifetimes are distinct. So the native assembly produced becomes way more involved with bounds-checking operations:</p><pre><code>L0000	sub		rsp, 0x28				
L0004	xor		eax, eax			; sum = 0
L0006	cmp		edx, r8d			; startIndex &gt; endIndex?
L0009	jg		short L0045			; then skip the entire function
L000b	test	rcx, rcx			; array is null?
L000e	je		short L0031			; then cause NullReferenceException
L0010	mov		r10d, edx
L0013	or		r10d, r8d
L0016	jl		short L0031
L0018	cmp		[rcx+8], r8d		; array.Length &lt;= endIndex ?
L001c	jle		short L0031			; then do bounds-checking
L001e	xchg	ax, ax				; alignment NOP
L0020	mov		r10d, edx
L0023	add		eax, [rcx+r10*4+0x10]   ; sum += array[i]
L0028	inc		edx					; consider i + 1
L002a	cmp		edx, r8d			; i &gt; endIndex?
L002d	jle		short L0020			; no, go on
L002f	jmp		short L0045			; return
L0031	cmp		edx, [rcx+8]		; i &gt; array.Length?
L0034	jae		short L004a			; bounds-checking failed. go to ----+
L0036	mov		r10d, edx												|
L0039	add		eax, [rcx+r10*4+0x10]	; sum += array[i]				|
L003e	inc		edx					; i++								|
L0040	cmp		edx, r8d			; i &lt;= endIndex ?					|
L0043	jle		short L0031			; continue for loop					|
L0045	add		rsp, 0x28												|
L0049	ret							; return sum						|
L004a	call	0x00007ff857ec6200	; throw IndexOutOfRangeException &lt;--+
</code></pre><p>We could use low-level unsafe functions and pointers in C# (yes, C# supports raw pointers!) to avoid bounds-checking altogether, like this:</p><pre><code>unsafe int sum(int* ptr, int length)
{
  int* end = ptr + length;
  int sum = 0;
  for (; ptr &lt; end; ptr++)
  {
    sum += *ptr;
  }
  return sum;
}</code></pre><p>That also creates a <em>very </em>optimized code that supports passing along a sub-portion of an array:</p><pre><code>L0000	movsxd	rax, edx        
L0003	lea	rax, [rcx+rax*4]    ; end = ptr + length
L0007	xor	edx, edx            ; sum = 0
L0009	cmp	rcx, rax            ; ptr &gt;= end ?
L000c	jae	short L0019         ; then return
L000e	add	edx, [rcx]          ; sum += *ptr
L0010	add	rcx, 4              ; ptr += sizeof(int)
L0014	cmp	rcx, rax            ; ptr &lt; end?
L0017	jb	short L000e         ; then keep looping
L0019	mov	eax, edx
L001b	ret	                    ; return sum</code></pre><p>Unsafe code and pointer-arithmetic can be very performant as you can see. The problem is that it&#39;s too dangerous. With incorrect values of length, you don&#39;t simply get an <code>IndexOutOfRangeException</code> but instead your app either crashes, or returns incorrect results. If your code happened to modify the memory region instead of just reading it, then you could have a nice entry point for a buffer overflow security vulnerability in your app too. Not to mention that all the callers of that function will have to have unsafe blocks too.</p><p>But it&#39;s possible to handle this safe and fast in C# without resorting to esoteric rituals like that. First, how do you solve this problem of indexes to describe a portion of an array and actual boundaries of the array being disconnected from each other? You create a new immutable type that holds these values together. And that type is called a <em>span</em> in C#. Other programming languages may call it a <em>slice</em>. Declaration of <code>Span</code> type resembles something like this. Well, it&#39;s not exactly this, but I want you to understand the concept first:</p><pre><code>readonly struct Span&lt;T&gt;
{
  readonly T* _ptr;
  readonly int _len;
}</code></pre><p>It&#39;s basically an immutable pointer with length. The great thing about a type like this is that the compiler can assure that once an immutable Span is initialized with correct bounds, it will always be safe to access without any bounds-checking. That means, you can pass around sub-views of arrays or even other spans safely and quickly without the performance overhead.</p><p>But, how can it be safe? What if the GC decides to throw away the structure that <code>ptr</code> points to? Well, that&#39;s where &#34;ref types&#34; come into play in C#.</p><p>A ref type is a type that can&#39;t leave the stack and escape to the heap, so it&#39;s always guaranteed that a <code>T</code> type will outlive a <code>Span&lt;T&gt;</code> instance. That&#39;s why the actual <code>Span&lt;T&gt;</code> declaration looks like this:</p><pre><code>readonly ref struct Span&lt;T&gt;  // notice &#34;ref&#34; 
{
  readonly ref T _ptr;        // notice &#34;ref&#34;
  readonly int _len;
}</code></pre><p>Since a ref type can only live in stack, it can&#39;t be a member of a class, nor can it be assigned to a non-ref variable, like, it can&#39;t be boxed either. A ref type can only be contained inside another ref type. It&#39;s ref types all the way.</p><p>Span-based version of our <code>sum</code> function can eliminate bounds-checking despite that it can now have several super powers. The first one is that it can receive a sub-view of an array too with specific indices:</p><pre><code>int sum(Span&lt;int&gt; span)
{
  int sum = 0;
  for (int i = 0; i &lt; span.Length; i++)
  {
    sum += span[i];
  }
  return sum;
}</code></pre><p>For instance you can call this function with <code>sum(array)</code> or you can call it with a sub-view of an array like <code>sum(array[startIndex..endIndex])</code>. That wouldn&#39;t incur new bounds-checking operations other than when you&#39;re trying to slice the array using the range operator. See how the generated assembly code for <code>sum</code> becomes optimized again:</p><pre><code>L0000	mov	rax, [rcx]
L0003	mov	ecx, [rcx+8]
L0006	xor	edx, edx            ; sum = 0
L0008	xor	r8d, r8d            ; i = 0
L000b	test	ecx, ecx		; span.Length == 0?
L000d	jle	short L001e
L000f	mov	r10d, r8d
L0012	add	edx, [rax+r10*4]    ; sum += span[i]
L0016	inc	r8d                 ; i++
L0019	cmp	r8d, ecx            ; i &lt; Length?
L001c	jl	short L000f         ; then keep looping
L001e	mov	eax, edx            
L0020	ret						; return sum</code></pre><p>Another superpower you get is that the ability to declare the data structure you receive immutable in your function signature, so your function is guaranteed not to touch it, and you can find bugs instantly. All you need to do is to replace <code>Span&lt;T&gt;</code> with <code>ReadOnlySpan&lt;T&gt;</code>. Then your attempts to modify the span contents will immediately cause a compiler error. Something impossible with regular arrays, even if you declare them <code>readonly</code>. The <code>readonly</code> directive only protects the reference from modification not the contents of the data structure.</p><p>Passing along a smaller portion of a larger data structure to relevant APIs used to involve either copying or passing the relevant part&#39;s offset and length values along with that data structure. It required the API to support calls with larger structures with offsets. It was impossible to guarantee the safety of such APIs as the relationship between parameters couldn&#39;t be established by the compiler or the runtime.</p><p>It&#39;s now both easy and expressive to implement zero-copy operations safely using spans. Consider a <a href="https://en.wikipedia.org/wiki/Quicksort?ref=ssg.dev" rel="noreferrer">Quicksort</a> implementation for instance; it usually has a function like this that works with portions of a given array:</p><pre><code>int partition(int[] array, int low, int high)
{
  int midpoint = (high + low) / 2; // I know, we&#39;ll get there!
  int mid = array[midpoint];

  // tuple swaps in C#! (&#34;..^1&#34; means &#34;Length - 1&#34;)
  (array[midpoint], array[^1]) = (array[^1], array[midpoint]);
  int pivotIndex = 0;
  for (int i = low; i &lt; high - 1; i++)
  {
     if (array[i] &lt; mid)
     {
       (array[i], array[pivotIndex]) = (array[pivotIndex], array[i]);
       pivotIndex += 1;
     }
  }
  (array[midpoint], array[^1]) = (array[^1], array[midpoint]);
  return pivotIndex;
}</code></pre><p>This function receives an array and offsets that designate a part of it, and rearranges the items based on a picked value in it. Values smaller than it move to the left, larger than it move to the right.</p><p>The <code>mid = array[midpoint]</code> has to be bounds-checked because the compiler can&#39;t know if the index is inside the bounds of this array. The <code>for</code> loop also performs bounds-check for array accesses in the loop, which some of them can be eliminated, but not fully guaranteed. </p><p>There is also an overflow error because we pass array ranges using <code>high</code> and <code>low</code> values: <code>(high+low)</code> can overflow for very large arrays, and the results would be catastrophic, can even cause buffer overflow exceptions.</p><p>The <code>partition</code> function gets recursively called many times by <code>Quicksort</code> function below, so that means bounds-checking can be a performance issue. </p><pre><code>void Quicksort(int[] array, int low, int high)
{
  if (array.Length &lt;= 1)
  {
    return;
  }

  int pivot = partition(array, low, high);
  Quicksort(span, low, pivot - 1);
  Quicksort(span, pivot + 1, high);
}</code></pre><p>With spans, the same Quicksort function looks like this:</p><pre><code>void Quicksort(Span&lt;int&gt; span)
{
  if (span.Length &lt;= 1)
  {
    return;
  }

  int pivot = partition(span);
  Quicksort(span[..pivot]);
  Quicksort(span[(pivot + 1)..]);
}</code></pre><p>See how expressive using spans are especially with the range syntax? It lets you get a new span out of an existing span or an array using double dots (<code>..</code>)? And the partition function even looks much better too:</p><pre><code>int partition(Span&lt;int&gt; span)
{
  int midpoint = span.Length / 2; // look ma, no buffer overflows!
  int mid = span[midpoint];
  (span[midpoint], span[^1]) = (span[^1], span[midpoint]);
  int pivotIndex = 0;
  for (int i = 0; i &lt; span.Length - 1; i++)
  {
     if (span[i] &lt; mid)
     {
       (span[i], span[pivotIndex]) = (span[pivotIndex], span[i]);
       pivotIndex += 1;
     }
  }
  (span[midpoint], span[^1]) = (span[^1], span[midpoint]);
  return pivotIndex;
}</code></pre><p>Because C# spans are also zero-based, it&#39;s harder to have buffer overflow problems caused by formulae like <code>(low + high) / 2</code>. Now, the implementation is as fast as an unsafe implementation with raw pointers, but still extremely safe.</p><h2 id="new-zero-copy-operations-in-net-runtime">New zero-copy operations in .NET runtime</h2><p>I used a recursive example here to show how sub-portions of a larger data structure can be passed to another function, but spans can be used almost everywhere, and now .NET runtime supports zero-copy alternatives of popular functions too.</p><p>Take <code>String.Split</code> for example. You can now split a string without creating new copies of every split portion of the string. You can split a CSV line into its parts like this:</p><pre><code>string csvLine = // .. read CSV line
string[] parts = csvLine.Split(&#39;,&#39;);

foreach (string part in parts)
{
  Console.WriteLine(part);
}</code></pre><p>The problem with that is, now you&#39;re dealing with newly created 5 buffers with varying lengths. .NET allocates new memory for them, GC keeps track of them. It&#39;s slow, it hogs memory. It&#39;s problematic especially in loops, and can create GC pressure, slowing your app even more.</p><p>You can instead cast your CSV line into a <code>ReadOnlySpan&lt;char&gt;</code> and iterate over its components to write it to the output:</p><figure><pre><code>string csvLine = // .. read CSV line

var span = csvLine.AsSpan();
var parts = span.Split(&#39;,&#39;);
foreach (var range in parts)
{
  Console.Out.WriteLine(span[range]);
}</code></pre><figcaption><p><span>Note that we use a small detour to use </span><code spellcheck="false"><span>Console.Out.WriteLine</span></code><span> instead of </span><code spellcheck="false"><span>Console.WriteLine</span></code><span> because </span><code spellcheck="false"><span>Console</span></code><span> class lacks an overload to output a </span><code spellcheck="false"><span>ReadOnlySpan&lt;char&gt;</span></code><span> like a string.</span></p></figcaption></figure><p>The great ROI of that experiment is making zero memory allocations after reading CSV line into memory. A similar logic that improves performance and memory efficiency can be applied everywhere that can receive a <code>Span&lt;T&gt;</code>/<code>ReadOnlySpan&lt;T&gt;</code> instead of an array.</p><h2 id="embrace-the-future">Embrace the future</h2><p>Spans and slice-like structures in are the future of safe memory operations in modern programming languages. Embrace them. The quick takeaways are: </p><ul><li>Use spans over arrays in your function declarations unless you explicitly require a standalone array in your function for some reason. Such a change opens your API into zero-copy optimization scenarios, and calling code will be more expressive.</li><li>Don&#39;t bother with unsafe/pointers if you can code the same logic with spans. You can still perform low-level memory operations without wandering into the dangerous parts of the forest. Your code will still be fast, and yet safer.</li></ul><p>Use spans, wherever possible, mostly readonly.</p>
        </section></div>
  </body>
</html>
