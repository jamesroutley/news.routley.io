<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tenderlovemaking.com/2024/09/29/eliminating-intermediate-array-allocations/">Original</a>
    <h1>Eliminating Intermediate Array Allocations</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>Recently I gave a talk at <a href="https://rubyonrails.org/world/2024">RailsWorld</a> (hopefully they’ll post the video soon), and part of my presentation was about eliminating allocations in tokenizers.
I presented a simple function for measuring allocations:</p>
<div><pre tabindex="0"><code data-lang="ruby"><span><span><span>def</span> <span>allocations</span>
</span></span><span><span>  x <span>=</span> <span>GC</span><span>.</span>stat(<span>:total_allocated_objects</span>)
</span></span><span><span>  <span>yield</span>
</span></span><span><span>  <span>GC</span><span>.</span>stat(<span>:total_allocated_objects</span>) <span>-</span> x
</span></span><span><span><span>end</span>
</span></span></code></pre></div><p>Everything in Ruby is an object, but not all objects actually make allocations.
We can use the above function to measure allocations made in a block.
Here are some examples of code that never allocate:</p>
<div><pre tabindex="0"><code data-lang="ruby"><span><span>p allocations { <span>true</span> }                  <span># =&gt; 0</span>
</span></span><span><span>p allocations { <span>false</span> }                 <span># =&gt; 0</span>
</span></span><span><span>p allocations { <span>nil</span> }                   <span># =&gt; 0</span>
</span></span><span><span>p allocations { <span>:hello</span> }                <span># =&gt; 0</span>
</span></span><span><span>p allocations { <span>1</span> }                     <span># =&gt; 0</span>
</span></span><span><span>p allocations { <span>2</span><span>.</span><span>3</span> }                   <span># =&gt; 0</span>
</span></span><span><span>p allocations { <span>0xFFFF_FFFF_FFFF_FFFF</span> } <span># =&gt; 0</span>
</span></span></code></pre></div><p>Literals like booleans, nil, symbols, integers, and floats are represented internally to CRuby as “tagged pointers” and they don’t allocate anything when executed.</p>
<p>Here is an example of code that sometimes allocates:</p>
<div><pre tabindex="0"><code data-lang="ruby"><span><span><span># Depends on the size of the number</span>
</span></span><span><span>p allocations { <span>1</span> <span>+</span> <span>2</span> }                     <span># =&gt; 0</span>
</span></span><span><span>p allocations { <span>0x3FFF_FFFF_FFFF_FFFF</span> <span>+</span> <span>1</span> } <span># =&gt; 1</span>
</span></span><span><span>
</span></span><span><span><span># Depends on `frozen_string_literal`</span>
</span></span><span><span>p allocations { <span>&#34;hello!&#34;</span> }                  <span># =&gt; 0 or 1</span>
</span></span></code></pre></div><p>Math on integers generally doesn’t allocate anything, but it depends on the integer.
When a number gets large enough, CRuby will allocate an object to represent that number.
On 64 bit platforms, the largest whole number we can represent without allocating is 0x3FFF_FFFF_FFFF_FFFF.</p>
<p>String literals will sometimes allocate, but it depends on the <code>frozen_string_literal</code> setting in your program.</p>
<p>Here is an example of code that always allocates:</p>
<div><pre tabindex="0"><code data-lang="ruby"><span><span>p allocations { <span>[</span><span>1</span>, <span>2</span><span>]</span> }      <span># =&gt; 1</span>
</span></span><span><span>p allocations { { <span>a</span>: <span>:b</span> } }   <span># =&gt; 1</span>
</span></span><span><span>p allocations { <span>Object</span><span>.</span>new }  <span># =&gt; 1</span>
</span></span><span><span>p allocations { <span>&#34;foo&#34;</span><span>[</span><span>0</span>, <span>1</span><span>]</span> } <span># =&gt; 1</span>
</span></span></code></pre></div><p>Hopefully these examples are fairly straightforward.
Arrays, hashes, objects, string slices, etc will allocate an object.</p>

<p>At the <a href="https://rubyonrails.org/world/2024/day-2/closing-party">Shopify after-party at RailsWorld</a>, someone asked me a really great question.
Their codebase has a RuboCop rule that says that when doing min or max calculations, you should always have code like this:</p>
<div><pre tabindex="0"><code data-lang="ruby"><span><span><span>def</span> <span>foo</span>(x, y)
</span></span><span><span>  <span>[</span>x, y<span>].</span>max
</span></span><span><span><span>end</span>
</span></span></code></pre></div><p>They were concerned this is wasteful as it has an Array literal, so it will be allocating an array every time!</p>
<p>I think this is a really great question, and if you read my earlier allocation measurement examples, I think it’s a very reasonable conclusion.
However, it’s actually not the case.
This code in particular will <em>not</em> allocate an array, and I thought we’d look in to how that works.</p>
<p>The compiler in Ruby is able to tell a few important things about this code.
First, we’re calling a method on an array <em>literal</em> which means that we’re guaranteed that the <code>max</code> method will be sent to an array object.
Second, we know statically that we’re calling the <code>max</code> method.
Third, the <code>max</code> method that is implemented in core Ruby will not mutate its receiver, and it returns some value (an integer) that <em>isn’t</em> the array literal.</p>
<p>Since the compiler knows that the array literal is ephemeral, it allocates the array on the stack, does the <code>max</code> calculation, then throws away the array, never asking the GC for a new object.</p>
<p>To get a more concrete picture, lets look at the instruction sequences for the above code:</p>
<div><pre tabindex="0"><code data-lang="ruby"><span><span><span>def</span> <span>foo</span>(x, y)
</span></span><span><span>  <span>[</span>x, y<span>].</span>max
</span></span><span><span><span>end</span>
</span></span><span><span>
</span></span><span><span>insn <span>=</span> <span>RubyVM</span><span>::</span><span>InstructionSequence</span><span>.</span>of(method(<span>:foo</span>))
</span></span><span><span>puts insn<span>.</span>disasm
</span></span></code></pre></div><pre tabindex="0"><code>== disasm: #&lt;ISeq:foo@x.rb:1 (1,0)-(1,30)&gt;
local table (size: 2, argc: 2 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])
[ 2] x@0&lt;Arg&gt;   [ 1] y@1&lt;Arg&gt;
0000 getlocal_WC_0                          x@0                       (   1)[LiCa]
0002 getlocal_WC_0                          y@1
0004 opt_newarray_send                      2, 1
0007 leave                                  [Re]
</code></pre><p>The first two instructions fetch the locals <code>x</code> and <code>y</code>, and push them on the stack.
Next we have a special instruction <code>opt_newarray_send</code>.
This instruction takes two parameters, <code>2, 1</code>.
It’s a bit cryptic, but the <code>2</code> means that this instruction is going to operate on two stack elements.
The <code>1</code> is an enum and means “we want to call the <code>max</code> method”.</p>
<p>The <code>opt_newarray_send</code> instruction will first check to see if <code>Array#max</code> has been monkey patched.
If it has been monkey patched, then the instruction will allocate a regular array and call the monkey patched method.
If it <em>hasn’t</em> been monkey patched, then it calls a “max” function which uses Ruby’s stack as an array buffer.</p>
<p>Here is what the stack looks like before executing <code>opt_newarray_send</code>:</p>
<pre tabindex="0"><code>+----+-------------+-------------+
|    | Stack Index | Stack Value |
+----+-------------+-------------+
|    | -2          | x           |
|    | -1          | y           |
| SP | 0           | Undef       |
+----+-------------+-------------+
</code></pre><p>The <code>opt_newarray_send</code> instruction was passed the value 2, so it knows to start the array at <em>negative</em> 2 relative to the stack pointer (SP).
Since the stack is just an array, it calls the same function that the <code>max</code> function would normally call, popping 2 values from the stack, then pushing the return value of the max function.</p>
<p>In this way we can calculate the max value without allocating the intermediate array.</p>
<p>If we use our allocations function, we can confirm that the <code>foo</code> method indeed does not allocate anything:</p>
<div><pre tabindex="0"><code data-lang="ruby"><span><span><span>def</span> <span>foo</span>(x, y)
</span></span><span><span>  <span>[</span>x, y<span>].</span>max
</span></span><span><span><span>end</span>
</span></span><span><span>
</span></span><span><span>allocations { foo(<span>3</span>, <span>4</span>) } <span># heat inline caches</span>
</span></span><span><span>p allocations { foo(<span>3</span>, <span>4</span>) } <span># =&gt; 0</span>
</span></span></code></pre></div><h2 id="aarons-opinion-corner">Aaron’s Opinion Corner</h2>
<p>I don’t really know RuboCop very well, but I think that in cases like this it would be really helpful if the linter were to tell you <em>why</em> a particular rule is a rule.
Personally, I dislike following rules unless I understand the reason behind them.
Even if the reasoning is simply “this is just how our team styles our code”.
If such a feature is already available in RuboCop, then please feel free to link to this blog post for this particular rule.</p>
<p>I can only assume the rule that enforced this style was “performance” related.
I’m not a huge fan of linting, but I’m even less of a fan when it comes to rules around “performance”.
If idiomatic Ruby is not performant, then I think there can be a strong case to be made that the CRuby team (which I am a part of) should make that code performant.
If the CRuby team <em>does</em> make the code performant, then there is no need for the performance rule because most people write idiomatic Ruby code (by definition).</p>
<p>Of course there are cases where you may need to write non-idiomatic Ruby for performance reasons, but hopefully those cases are few and far between.
Should the time arrive when you need to write odd code for performance reasons, it will require knowledge, experience, and nuance that neither a linter nor an AI can provide.
Fortunately, this is a case where idiomatic Ruby is also “the fast way to do things”, so I definitely recommend people use the <code>[x, y].max</code> pattern.</p>
<h2 id="more-stuff">More Stuff</h2>
<p><code>Array#max</code> isn’t the only method that uses this trick.
It works with <code>Array#min</code>, <code>Array#pack</code> and <code>Array#hash</code>.
If you need to implement a custom <code>hash</code> method on an object, then I highly recommend doing something like this:</p>
<div><pre tabindex="0"><code data-lang="ruby"><span><span><span>def</span> <span>hash</span>
</span></span><span><span>  <span>[</span>@ivar1, @ivar2, <span>...].</span>hash
</span></span><span><span><span>end</span>
</span></span></code></pre></div><p>Finally, there are cases where CRuby <em>won’t</em> apply this trick.
Lets look at the instructions for the following method:</p>
<div><pre tabindex="0"><code data-lang="ruby"><span><span><span>def</span> <span>foo</span>
</span></span><span><span>  <span>[</span><span>3</span>, <span>4</span><span>].</span>max
</span></span><span><span><span>end</span>
</span></span><span><span>
</span></span><span><span>insn <span>=</span> <span>RubyVM</span><span>::</span><span>InstructionSequence</span><span>.</span>of(method(<span>:foo</span>))
</span></span><span><span>puts insn<span>.</span>disasm
</span></span></code></pre></div><pre tabindex="0"><code>== disasm: #&lt;ISeq:foo@x.rb:1 (1,0)-(3,3)&gt;
0000 duparray                               [3, 4]                    (   2)[LiCa]
0002 opt_send_without_block                 &lt;calldata!mid:max, argc:0, ARGS_SIMPLE&gt;
0004 leave                                                            (   3)[Re]
</code></pre><p>If you read these instructions carefully, you’ll see it has a <code>duparray</code> instruction.
This instruction <strong>allocates an array</strong>, and then we call the <code>max</code> method on the array.</p>
<p>When all of the elements of the array are static, CRuby applies an optimization to allocate the array once, embed it in the instructions, and then do a <code>dup</code> on the array.
Copying an existing array is much faster than allocating a new one.
Unfortunately, this optimization is applied <em>before</em> the “max” method optimization, so it doesn’t apply both.</p>
<p>For those of you at home saying “the compiler could calculate the max of <code>[3, 4]</code> and eliminate the array all together!” just remember that someone could monkey patch <code>Array#max</code> and we’d need to respect it.  Argh!!
Fixing this particular case is not worth the code complexity, in my opinion.
We all know that 4 is greater than 3, so we could “manually inline” this case and just write <code>4</code>.</p>
<p>Anyway, all this to say is that these optimizations are context dependent.
Attempting to “prescribe” more optimal code seems like it could become a hairy situation, especially since the linter can’t know what the Ruby compiler will do.</p>
<p>I do like the idea of language servers possible suggesting <em>possibly</em> faster code, but only as a teaching opportunity for the developer.
The real goal should be to help build understanding so that this type of linting becomes unnecessary.</p>
<p>Anyway, I had a really great time at RailsWorld.
I am very happy I got this question, and I hope that this post helps someone!</p>

    </div></div>
  </body>
</html>
