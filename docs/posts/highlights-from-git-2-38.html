<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.blog/2022-10-03-highlights-from-git-2-38/">Original</a>
    <h1>Highlights from Git 2.38</h1>
    
    <div id="readability-page-1" class="page"><div>
  <div>
    


<main role="main" id="post-67386">
  
<p>The open source Git project just <a href="https://lore.kernel.org/git/xmqqmtacu8bw.fsf@gitster.g/">released Git 2.38</a>, with features and bug fixes from over 92 contributors, 24 of them new. We last caught up with you on the latest in Git back <a href="https://github.blog/2022-06-27-highlights-from-git-2-37/">when 2.37 was released</a>.</p>
<p>To celebrate this most recent release, here’s GitHub’s look at some of the most interesting features and changes introduced since last time.</p>

<p>We talk a lot about performance in Git, especially in the context of large repositories. Returning readers of these blog posts will no doubt be familiar with the dozens of performance optimizations that have landed in Git over the years.</p>
<p>But with so many features to keep track of, it can be easy to miss out some every now and then (along with their corresponding performance gains).</p>
<p>Git’s new built-in repository management tool, Scalar, attempts to solve that problem by curating and configuring a uniform set of features with the biggest impact on large repositories. To start using it, you can either clone a new repository with <code>scalar clone</code>:</p>
<pre><code>$ scalar clone /path/to/repo
</code></pre>
<p>Or, you can use the <code>--full-clone</code> option if you don’t want to start out with a sparse checkout. To apply Scalar’s recommended configuration to a clone you already have, you can instead run:</p>
<pre><code>$ cd /path/to/repo
$ scalar register
</code></pre>
<p>At the time of writing, Scalar’s default configured features include:</p>
<ul>
<li><a href="https://github.blog/2022-06-29-improve-git-monorepo-performance-with-a-file-system-monitor/">Built-in filesystem monitor</a></li>
<li><a href="https://github.blog/2021-04-29-scaling-monorepo-maintenance/">Multi-pack index</a></li>
<li><a href="https://github.blog/2022-08-30-gits-database-internals-ii-commit-history-queries/#gits-commit-graph-file">Commit graphs</a></li>
<li><a href="https://github.blog/2021-03-15-highlights-from-git-2-31/#introducing-git-maintenance">Scheduled background maintenance</a></li>
<li><a href="https://github.blog/2020-12-21-get-up-to-speed-with-partial-clone-and-shallow-clone/">Partial cloning</a></li>
<li><a href="https://github.blog/2020-01-17-bring-your-monorepo-down-to-size-with-sparse-checkout/#cone-mode-restricted-patterns-improve-performance">Cone mode sparse-checkout</a></li>
</ul>
<p>Scalar’s configuration is updated as new (even experimental!) features are introduced to Git. To make sure you’re always using the latest and greatest, be sure to run <code>scalar reconfigure /path/to/repo</code> after a new release to update your repository’s config (or <code>scalar reconfigure -a</code> to update all of your Scalar-registered repositories at once).</p>
<p>Git 2.38 is the first time Scalar has been included in the release, but it has actually <a href="https://devblogs.microsoft.com/devops/introducing-scalar/">existed for much longer</a>. Check back soon for a blog post on how Scalar came to be—from its early days as a standalone .NET application to its journey into core Git!</p>
<p>[<a href="https://github.com/git/git/compare/9d58241ee4e2c603404e028204221e508bb73644...9eb7a73158bdc91892a6b9a0b43b8f954b1e39e2">source</a>]</p>
<h2 id="rebase-dependent-branches-with-update-refs">Rebase dependent branches with –update-refs<a href="#rebase-dependent-branches-with-update-refs" aria-label="Rebase dependent branches with –update-refs"></a></h2>
<p>When working on a large feature, it’s often helpful to break up the work across multiple branches that build on each other.</p>
<p>But these branches can become cumbersome to manage when you need to rewrite history in an earlier branch. Since each branch depends on the previous ones, rewriting commits in one branch will leave the subsequent branches disconnected from history after rewriting.</p>
<p>In case that didn’t quite make sense, let’s walk through an example.</p>
<p>Suppose that you are working on a feature (<code>my-feature</code>), but want to break it down into a few distinct parts (maybe for ease of review, or to ensure you’re deploying it safely, etc.). Before you share your work with your colleagues, you build the entire feature up front to make sure that the end-result is feasible, like so.</p>
<pre><code>$ git log --oneline origin/main..HEAD
741a3174683 (HEAD -&gt; my-feature/part-three) Part 3: all done!
1ff073007eb Part 3: step two
880c07e326f Part 3: step one
40529bd11dc (my-feature/part-two) Part 2: step two
0a92cc3acd8 Part 2: step one
eed018043ba (my-feature/part-one) Part 1: step three
646c870d69e Part 1: step two
9147f6d2eb4 Part 1: step one
</code></pre>
<p>In the example below, the <code>my-feature/part-three</code> branch resembles what you imagine the final state will look like. But the intermediate check-points (<code>my-feature/part-one</code>, and so on) represent the chunks you intend to submit for code review.</p>
<p>After you submit everything, what happens if you want to make a change to one of the patches in part one?</p>
<p>You might create a <code>fixup!</code> commit on top, but squashing that patch into the one you wanted to change from part one will cause parts two and three to become disconnected:</p>
<p><img src="https://github.blog/wp-content/uploads/2022/09/git238-1.gif" alt="Creating a fixup commit that causes parts two and three to become disconnected" loading="lazy"/></p>
<p>Notice that after we squashed our fix into “Part 1: step one,” the subsequent branches vanished from history. That’s because they didn’t get updated to depend on the updated tip of <code>my-feature/part-one</code> after rebasing.</p>
<p>You could go through and manually checkout each branch, resetting each to the right commit. But this can get cumbersome quickly if you have a lot of branches, are making frequent changes, or both.</p>
<p>Git 2.38 ships with a new option to <code>git rebase</code> called <code>--update-refs</code> that knows how to perform these updates for you. Let’s try that same example again with the new version of Git.</p>
<p><img src="https://github.blog/wp-content/uploads/2022/09/git238-2.gif" alt="Rebasing with the new viersion of Git, which updates each branch for you." loading="lazy"/></p>
<p>Because we used <code>--update-refs</code>, <code>git rebase</code> knew to update our dependent branches, so our history remains intact without having to manually update each individual branch.</p>
<p>If you want to use this option every time you rebase, you can run <code>git config --global rebase.updateRefs true</code> to have Git act as if the <code>--update-refs</code> option is always given.</p>
<p>[<a href="https://github.com/git/git/compare/e59acea3f0752ddfdcaab08b54dc0f84c7ab66e6...4611884ea883908a9638cafbd824c401c41cf7f6">source</a>]</p>
<h2 id="tidbits">Tidbits<a href="#tidbits" aria-label="Tidbits"></a></h2>
<p>This release coincides with the <a href="https://summerofcode.withgoogle.com/programs/2022/organizations/git">Git project’s participation</a> in the annual <a href="https://summerofcode.withgoogle.com/">Google Summer of Code</a> program. This year, the Git project mentored two students, <a href="https://github.com/ffyuanda">Shaoxuan Yuan</a>, and <a href="https://github.com/Abhra303">Abhradeep Chakraborty</a>, working on <a href="https://summerofcode.withgoogle.com/programs/2022/projects/hz4rcOUB">sparse index integration</a> and various <a href="https://summerofcode.withgoogle.com/programs/2022/projects/UPtA6qdf">improvements to reachability bitmaps</a>, respectively.</p>
<ul>
<li>Shaoxuan’s first contribution was integrating the <code>git rm</code> command with the <a href="https://github.blog/2021-11-10-make-your-monorepo-feel-small-with-gits-sparse-index/">sparse index</a>. The sparse index is a relatively new Git feature that enables Git to shrink the size of its index data structure to only track the contents of your sparse checkout, instead of the entire repository. Long-time readers will <a href="https://github.blog/2021-11-15-highlights-from-git-2-34/#sparse-index">remember</a> that Git commands have been converted to be compatible with the sparse-index one-by-one. Commands that aren’t compatible with the sparse index need to temporarily expand the index to cover the entire repository, leading to slow-downs when working in a large repository.
<p>Shaoxuan’s work made the <code>git rm</code> command compatible with the sparse index, causing it to only expand the index when necessary, bringing Git closer to having all commands be compatible with the sparse index by default.</p>
<p>[<a href="https://github.com/git/git/compare/80ffc849bdd5ed111a2ec070856ef67e075572c6...ede241c7154929c5c80fb784daa79de6103bf048">source</a>]</p>
</li>
<li>
<p>Shaoxuan also worked on improving <code>git mv</code>‘s behavior when moving a path from within the sparse checkout definition (sometimes called a “cone”) to outside of the sparse checkout. There were a number of corner cases that required careful reasoning, and curious readers can learn more about exactly how this was implemented in the patches linked below.</p>
<p>[<a href="https://github.com/git/git/compare/d3fa443f97e3a8d75b51341e2d5bac380b7422df...7ead46810b507828c1481eaea6d64b9ed635b8b7">source</a>]</p>
</li>
<li>
<p>Abhradeep worked on adding a new “lookup table” extension to Git’s <a href="https://git-scm.com/docs/bitmap-format">reachability bitmap index</a>. For those unfamiliar, this index (stored in a <code>.bitmap</code> file) associates a set of commits to a set of bitmaps, where each bit position corresponds to an object. A <code>1</code> bit indicates that a commit can reach the object specified by that bit position, and a <code>0</code> indicates that it cannot.</p>
<p>But <code>.bitmap</code> files <a href="https://git-scm.com/docs/bitmap-format#_on_disk_format">do not list their selected commits</a> in a single location. Instead, they prefix each bitmap with the object ID of the commit it corresponds to. That means that in order to know what set of commits are covered by a <code>.bitmap</code>, Git must read the entire contents of the file to discover the set of bitmapped commits.</p>
<p>Abhradeep addressed this shortcoming by adding an optional “lookup table” at the end of the .bitmap format, which provides a concise list of selected commits, as well as the offset of their corresponding bitmaps within the file. This provided <a href="https://github.com/git/git/commit/761416ef91d819d84a11222ec5bc3cbc66d3ddac">some speed-ups</a> across a handful of benchmarks, making bitmaps faster to load and use, especially for large repositories.</p>
<p>[<a href="https://github.com/git/git/compare/cf98b69053996728f131671ed7ff9581b0e8943a...969a5645876ccf368ed74fde2c5dc9b5432b7bb0">source</a>]</p>
</li>
<li>
<p>Abhradeep also worked on sprucing up <a href="https://git-scm.com/docs/bitmap-format#_on_disk_format">the technical documentation</a> for the .bitmap format. So if you have ever been curious about or want to hack on Git’s bitmap internals, now is the time!</p>
<p>[<a href="https://github.com/git/git/compare/2c8c0b48434c3ff31cfee254d306e6a42dfa2463...ac7667bd44acd0e192e1783862ca5382ccbb2fcb">source</a>]</p>
</li>
</ul>
<p>For more about these projects, you can check out each contributor’s final blog posts <a href="https://ffyuanda.github.io/blog/GSoC-final-blog/">here</a> and <a href="https://medium.com/@abhra303/gsoc-final-report-feaaacfae737">here</a>. Thank you, Shaoxuan, and Abhradeep!</p>
<p>Now that we’ve covered a handful of changes contributed by Google Summer of Code students, let’s take a look at some changes in this release of Git from other Git contributors.</p>
<ul>
<li>You may not be familiar with Git’s <code>merge-tree</code> command, which historically was used to compute trivial three-way merges using Git’s recursive merge strategy. In Git 2.38, this command now knows how to integrate with the new ort merge strategy, allowing it to compute non-trivial merges without touching the index or working copy.
<p>The existing mode is still available behind a (deprecated) <code>--trivial-merge</code> option. When the new <code>--write-tree</code> mode is used, <code>merge-tree</code> takes two branches to merge, and computes the result using the ort strategy, all without touching the working copy or index. It outputs the resulting tree’s object ID, along with some information about any conflicts it encountered.</p>
<p>As an aside, we at GitHub recently <a href="https://github.blog/changelog/2022-09-12-merge-commits-now-created-using-the-merge-ort-strategy/">started using</a> to compute merges on GitHub.com more than an order of magnitude faster than before. We had previously used the implementation in libgit2 in order to compute merges without requiring a worktree, since GitHub stores repositories as bare, meaning we do not have a worktree to rely on. These changes will make their way to GitHub Enterprise beginning with verion 3.7.</p>
<p>[<a href="https://github.com/git/git/compare/dc6315e1fc1d5c0d7afd3fe20cf192bd4c484930...7260e87248e743b197d34c1caf3949ae4fa3bc12">source</a>]</p>
</li>
<li>
<p><a href="https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefbarerepositoryabarerepository">Bare Git repositories</a> can be stored in and distributed with other Git repositories. This is often convenient, for example, as an easy mechanism to distribute Git repositories for use as <a href="https://en.wikipedia.org/wiki/Test_fixture#Software">test fixtures</a>.</p>
<p>When using repositories from less-than-trustworthy sources, this can also present a security risk. Git repositories often execute user-defined programs specified via the <code>$GIT_DIR/config</code> file. For example, <code>[core.pager](https://git-scm.com/docs/git-config#Documentation/git-config.txt-coreeditor)</code> defines which pager program Git uses, and <code>[core.editor](https://git-scm.com/docs/git-config#Documentation/git-config.txt-corepager)</code> defines which editor Git opens when you want to write a commit message (among other things).</p>
<p>There are other examples, but an often-discussed one is <a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt-corefsmonitor">the core.fsmonitor configuration</a>, which can be used to specify a path to a <a href="https://git-scm.com/docs/githooks#_fsmonitor_watchman">filesystem monitoring hook</a>. Because Git often needs to query the state of the filesystem, this hook (when configured) is invoked many times, including from <code>git status</code>, which people commonly script around in their shell prompt.</p>
<p>This means that it’s possible to convince a victim to run arbitrary code by convincing them to clone a repository with a malicious bare repository embedded inside of it. If they change their working directory into the malicious repository within (since you cannot embed a bare repository at the top-level directory of a repository) and run some Git command, then they are likely to execute the script specified by core.fsmonitor (or any other configuration that specifies a command to execute).</p>
<p>For this reason, the new <code>[safe.bareRepository configuration](https://git-scm.com/docs/git-config#Documentation/git-config.txt-safebareRepository)</code> was introduced. When set to “explicit,” Git will only work with bare repositories specified by the top-level –git-dir argument. Otherwise, when set to “all” (which is the default), Git will continue to work with all bare repositories, embedded or not.</p>
<p>It is worth noting that setting <code>safe.bareRepository</code> to “explicit” is only required if you worry that you may be cloning malicious repositories and executing Git commands in them.</p>
<p>[<a href="https://github.com/git/git/compare/e72d93e88cb20b06e88e6e7d81bd1dc4effe453f...8d1a7448206e11cdea657c35b04cc49db39be933">source</a>]</p>
</li>
<li>
<p><code>git grep</code> learned a new <code>-m</code> option (short for <code>--max-count</code>), which behaves like GNU <code>grep</code>‘s options of the same name. This new option limits the number of matches shown per file. This can be especially useful when combined with other options, like <code>-C</code> or <code>-p</code> (which show code context, or the name of the function which contains each match).</p>
<p>You could, for example, combine all three of these options to show a summary of how some function is called by many different files in your project. Git has a handful of objects that contain the substring <code>oid_object_info</code>. If you want to look at how callers across different files are structured without seeing more than one example from the same file, you can now run:</p>
<p><code>$ git grep -C3 -p -m1 oid_object_info</code></p>
<p>[<a href="https://github.com/git/git/compare/884339a15fea479e98477cca018711d77f08b053...68437ede53dccd1dea9e44e831a59de274d389de">source</a>]</p>
</li>
<li>
<p>If you’ve ever scripted around the directory contents of your Git repository, there’s no doubt that you’ve encountered the <code>git ls-files</code> command. Unlike <code>ls-tree</code> (which lists the contents of a tree object), <code>ls-files</code> lists the contents of the index, the working directory, or both.</p>
<p>There are already lots of options which can further specify what does or doesn’t get printed in <code>ls-files</code>‘s output. But its output was not easily customizable without additional scripting.</p>
<p>In Git 2.38, that is no longer the case, with <code>ls-files</code>‘s new <code>--format</code> option. You can now customize how each entry is printed, with fields to print an object’s name and mode, as well as more esoteric options, like its stage in the index, or end-of-line (EOL) behavior.</p>
<p>[<a href="https://github.com/git/git/compare/37e4bdd5ee5d6a7e09feaf5857299aac8fd56aeb...ce74de931d7aea9746e37632534eacc63b0c1a90">source</a>]</p>
</li>
<li>
<p><code>git cat-file</code> also learned a new option to respect the mailmap when printing the contents of objects with identifiers in them. This feature was contributed by <a href="https://summerofcode.withgoogle.com/programs/2022/projects/yaKP2iJK">another Google Summer of Code student</a>, this time working on behalf of GitLab!</p>
<p>For the uninitiated, the <a href="https://git-scm.com/docs/gitmailmap">mailmap</a> is a feature which allows mapping name and email pairs to their canonical values, which can be useful if you change your name or email and want to retain authorship over historical commits without rewriting history.</p>
<p><code>git show</code>, and many other tools already understand how to remap identities under the mailmap (for example, <code>git show</code>‘s <code>%aN</code> and <code>%aE</code> format placeholders print the mailmapped author name and email, respectively, as opposed to <code>%an</code> and <code>%ae</code>, which don’t respect the mailmap). But <code>git cat-file</code>, which is a low-level command which prints the contents of objects, did not know how to perform this conversion.</p>
<p>That meant that if you wanted to print a stream of objects, but transform any author, committer, or tagger identities according to the mailmap, you would have to pipe their contents through git show or similar. This is no longer the case, since git cat-file now understands the <code>--[no]-use-mailmap</code> option, meaning this transformation can be done before printing out object contents.</p>
<p>[<a href="https://github.com/git/git/compare/8e56affcb52e2cf344437a892356a419985ea4ba...ec031da9f97a2545601304b5ac1e93fee09425b4">source</a>]</p>
</li>
<li>
<p>Finally, Git’s developer documentation got an improvement in this most recent release, by adding a codified version of the Git community’s guidelines for code review. This document is a helpful resource for new and existing contributors to learn about the cultural norms around reviewing patches on the Git mailing list.</p>
<p>If you’ve ever had the itch to contribute to the Git project, I highly encourage you to read <a href="https://github.com/git/git/blob/v2.38.0/Documentation/ReviewingGuidelines.txt">the new reviewing guidelines</a> (as well as <a href="https://github.com/git/git/blob/v2.38.0/Documentation/CodingGuidelines">the coding guidelines</a>, and the <a href="https://github.com/git/git/blob/v2.38.0/Documentation/MyFirstContribution.txt">“My First Contribution”</a> document) and get started!</p>
<p>[<a href="https://github.com/git/git/compare/86c108a8a2c66ee38ab92a35c9acc3206377e264...e01b851923d43cbd3c5b7055f689cc18283591b9">source</a>]</p>
</li>
</ul>
<h2 id="the-rest-of-the-iceberg">The rest of the iceberg<a href="#the-rest-of-the-iceberg" aria-label="The rest of the iceberg"></a></h2>
<p>That’s just a sample of changes from the latest release. For more, check out the <a href="https://github.com/git/git/blob/v2.38.0/Documentation/RelNotes/2.38.0.txt">release notes for 2.38</a>, or <a href="https://github.com/git/git/tree/v2.38.0/Documentation/RelNotes">any previous version</a> in <a href="https://github.com/git/git">the Git repository</a>.</p>

      
  </main>


  </div>
</div></div>
  </body>
</html>
