<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dev.to/redbar0n/features-of-a-dream-programming-language-cio">Original</a>
    <h1>Features of a dream programming language</h1>
    
    <div id="readability-page-1" class="page"><p>So, from various sources of inspiration, and these principles in mind, here is the list of features that my dream programming language would have.</p><p>Features in <strong>bold</strong> are considered most important.</p><div>
<li>
<p><strong>Readability and reasonability</strong> as top priority. Reduce dev mind cycles &gt; reduce CPU cycles. Human-oriented and DX-oriented. Willing to sacrifice some performance, but not much, and not to overly gain comparability with natural language (counter-inspired by SQL; inspired by Cypher). Willing to sacrifice immediate power in the language itself, esp. if that can be achieved through abstracted-away libraries.</p>

<ul>
<li>Should always be able to be read top-to-bottom, left-to-right. No <code>&lt;expression&gt; if &lt;condititonal&gt;</code> like in Ruby.</li>
<li>Readability should not imply a one to one match with natural language (counter-inspired by SQL), since natural language is inconsistent, duplicitous, ambivalent and multi-faceted. Consistency is key to a programming language. But it should borrow some similarities from natural language (like its popular Subject-Verb-Object structure) to make adoption easier (more at-hand/intuitive).</li>
<li>
<strong>Encapsulation</strong>. Everything should be able to be encapsulated (all code, whether on back-end and front-end), since <strong>encapsulation affords reasonability</strong> (and testability), by limiting places bugs can hide. Counter-inspired by Rails views (sharing a global scope) and instance variables. Inspired by testability of React components.</li>
<li>No need to keep things in human memory for more than about 20 lines of code at a time. If extending that, then there should be an conceptual model which can be carried forward incrementally in the programmer&#39;s mind (implying state and mutation at the conceptual level, but not necessarily implemented as such).</li>
<li>No need to manipulate data structures in the human mind. Programmer should always be able to <strong><em>see</em> the data 
structure</strong> he/she is working on, at any given time, in the code. Inspired by <a href="http://worrydream.com">Bret Victor</a>, and Smalltalk. So the language should make that easy for tooling to support. But without being a whole isolated universe in its own right like a VM. Counter-inspired by Smalltalk. Some have described this as <a href="https://purelyfunctional.tv/lesson/what-is-repl-driven-development/">REPL-driven-development</a>, or interactive-programming. Inspired by Clojure. But without having to leave your IDE to code in a console/prompt/terminal. Inspired by <a href="https://quokkajs.com/">QuokkaJS</a>.</li>
<li>Params: Function parameters must be named, but no need to repeat yourself, if the argument is named the same as the parameter (i.e. <a href="https://bugs.ruby-lang.org/issues/14579">keyword arguments can be omitted</a>). Inspired by JS object params, and Ruby. Counter-inspired by the <a href="https://www.codeproject.com/Articles/1186940/Lisps-Mysterious-Tuple-Problem">Mysterious Tuple Problem</a> in Lisp. If currying, then input params should be explicit at every step (for clarity and refactorability). Counter-inspired by Point-free style in FP (since &#34;explicit is better than implicit&#34;, inspired by Python).</li>
<li>No <a href="https://youtu.be/YR5WdGrpoug?t=1213">Place-oriented programming (PLOP)</a>, iow. avoid order-dependence at almost any cost, since it isn&#39;t adaptable/scalable. This goes for parameter lists to functions etc. Don&#39;t want to have to use a &#39;<em>&#39; placeholder for places where there _could</em> be a parameter, just because you didn&#39;t supply one. Consequence: use primitive data structures like dictionaries over records/fields. Inspired by Clojure.</li>
<li>No <code>unless</code> or other counter-intuitive-prone operators. Counter-inspired by Ruby.</li>
<li>No abstract mathematical jargon. Counter-inspired by Haskell. Should be accessible for as wide a community as possible, with as little foreknowledge as possible. Inspired by <a href="https://quorumlanguage.com/">Quorum</a>.</li>
<li>Do not presume contextual knowledge. In UX this is known as &#34;No modes!&#34;. Code should be able to be read A to B without having been educated/preloaded with any foreknowledge (like &#39;in this context, you have these things implicitly available&#39;). Counter-inspired by class inheritance and Ruby magic, and JavaScript&#39;s <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this">runtime bound</a> <code>this</code> keyword and associated <a href="https://kentcdodds.com/blog/classes-complexity-and-functional-programming">scoping problems</a>. Turns out too much dynamism (runtime contextualisation) can be harmful.</li>
<li>Should facilitate and nudge programming in the language towards code with low <a href="https://www.sonarsource.com/docs/CognitiveComplexity.pdf">Cognitive Complexity</a> score.</li>
<li>
<strong>Dynamic Verboseness</strong>: Should be able to show more/less of syntax terms in the code. Beginners will want more explicity, as code can be more self-explaining. Whereas professionals will want to write less and have more implicit/hidden from sight, so they can focus on their the problem domain without clutter from the language. See: content-addressable code.</li>
</ul>


</li>
<li><p>Not indentation based (counter-inspired by Python), since it is brittle. But also not require semicolons. Inspired by Ruby, and semi-colon-free JS.</p></li>
<li>

<p>Fast feedback to the programmer is second top priority. Inspired by TypeScript hints, <a href="https://quokkajs.com/">QuokkaJS</a> (!), Webpack Hot Reload, and Expo Live Reload.</p>

<ul>
<li>REPL / interactive shell. Can be done even if compiled, by having an interpreter on top of a VM to the compiler.</li>
</ul>


</li>
<li>

<p><strong>Refactorability / change-ability.</strong></p>

<ul>
<li>Similar-looking and non-interacting code-lines should be able to change place without breaking anything. Counter-inspired by not able to add comma to last line in JSON, not being able to reorder/extract from comma-separated multi-line variable declarations in JS, and also counter-inspired by the contextualised expression terminators in Erlang.</li>
<li>
<strong>Backward-compatible and forward-compatible</strong>. Should be able to not worry about (or make poor future tradeoffs due to) backwards-compatibility. (<a href="https://maggiepint.com/2017/04/11/fixing-javascript-date-web-compatibility-and-reality/">Counter-inspired by ECMAScript</a>.) To make the language optimally and freelly evolvable, and worriless to upgrade. <a href="https://en.wikipedia.org/wiki/Backward_compatibility">Backwards-compatibility</a> and <a href="https://en.wikipedia.org/wiki/Forward_compatibility">Forwards-compatibility</a>: Code in a one language version should be transformable (in a legible way) to another version (both ways; backwards and forwards).
Solutions could be to either: have simple CLI tools to <strong>automatically refactor old code to new language versions</strong>, to always stay optimally <strong>adaptable</strong>, without having breaking changes. Maybe using some form of <strong>built-in self-to-self transpilation</strong>. Will likely need to be able to treat code-as-data. Might need compile-time macros. Or a solution could be to: with every breaking language revision, include an incremental language adapter, which would allow upgrading whilst ensuring backwards compatibility. Could be solved with <a href="https://go.dev/blog/gofmt">Mechanical Source Transformation</a>, enabled by gofmt, so developers can use <a href="https://go.dev/blog/introducing-gofix">gofix</a> to automatically rewrite programs that use old APIs to use newer ones. Which is crucial in <strong>managing breaking changes</strong>. A breaking (aka. widely deviating) change, should in effect, not actually break anything (that current languages and systems do, is considered a &#34;pretty costly&#34; design flaw).</li>
<li>
<a href="https://youtu.be/ltCgzYcpFUI?t=1317">A language for library authors</a>. Inspired by the success of C++. The language should be able to <strong>evolve by community convention, not by centralised specification</strong>: the language itself should be extensible with libraries (would probably need to have compile-time macros).</li>
<li>
<a href="https://youtu.be/gCWtkvDQ2ZI?t=170">Content-addressable code</a>: names of functions are simply a uniquely identifiable hash of their contents. The name (and the type) is only materialized in a single place, and stored alongside the AST in the codebase. Avoids renaming leading to breaking third-parties, and avoids defensively supporting and deprecating several versions of functions. Avoids codebase-wide text-manipulation, eliminates builds and dependency conflicts, robustly supports dynamic code deployment. Code would also need to be stored immutably and append-only for this to work. All inspired by <a href="https://www.unisonweb.org/">Unison</a>.</li>
<li>Convention over configuration (CoC). The language should be &#34;open to extension&#34; by any community, without permission. So that it can evolve and converge to a consensus, based on real-world experience and feedback. Not being completely and statically &#34;configured&#34; up front, which would entail predicting future uses, and consequences of those uses. (Thus, the feature-list you are now reading would thus just be a first draft, of course.) This is mirrored in the important talk <a href="https://www.youtube.com/watch?v=_ahvzDzKdB0">Growing a Language, by Guy Steele</a>, and the point on <a href="https://www.youtube.com/watch?v=_ahvzDzKdB0">crucial evolvability</a>. NB: &#34;if you apply [CoC] dogmatically you end up with an awful lot of convention that you have to keep in your head. It&#39;s always a question of balance; Hard Coding vs. Configuring vs. Convention, and it&#39;s not easy to hit the optimum (which depends on the circumstances).&#34; as <a href="https://dev.to/peerreynders/comment/1j4c4">Peer Reynders reminded us</a>.</li>
</ul>


</li>
<li><p>Modularity. Module system which is sensible. Inspired by the NodeJS controversy. Code-splittable and <a href="https://blog.cleancoder.com/uncle-bob/2018/04/13/FPvsOO.html">tree-shakeable</a>. Inspired by Rollup.</p></li>
<li>

<p><strong>Quick to get started and produce something.</strong> Inspired by JS. Counter-inspired by JS tooling.</p>

<ul>
<li>Not too unfamiliar (to a large group of programmers, and to what they teach in universities). &#34;Familiarity and a smooth upgrade path is a really big deal.&#34; <a href="https://youtu.be/QyJZzq0v7Z4?t=1997">source</a>
</li>
</ul>


</li>
<li><p>Sensible, friendly, and directly helpful error messages. Inspired by Elm.</p></li>
<li>

<p><strong>Struct-Oriented Functional Programming (SOFP)</strong>. Mimics the style of object-orientation, but is simply structs and functions under-the-hood. (Also: functional programming patterns over procedural code.) Because it is human to see the world in terms of verbs and objects. Focusing to heavily on only one of the paradigms (OOP or FP) will either lead to anti-patterns (God classes/objects, Factory objects, and Singletons, in OOP), or program structures far removed from the business domain model which also has linguistically unintuitive syntax (since only 12% of natural languages start with the verb, either Verb-Subject-Object or Verb-Object-Subject, <a href="https://en.wikipedia.org/wiki/Subject%E2%80%93verb%E2%80%93object">ref</a>), as in pure FP. So <a href="https://en.wikipedia.org/wiki/Subject%E2%80%93verb%E2%80%93object">Subject-Verb-Object</a> should be preferred. (88% of natural languages start with something concrete, the Subject/Object, which I think is a reason for OOP&#39;s success; it is more intuitive for beginners, which is vitally important for onboarding &amp; growth.) &#34;Objects and methods&#34; could be merely syntax sugar for structs and functions (see: <a href="https://youtu.be/QyJZzq0v7Z4?t=1343">interchangeability of method-style and procedure-call-style</a>, or the <a href="https://rescript-lang.org/docs/manual/v8.0.0/pipe">pipe first operator</a> in ReScript, which also illustrates <em>emulating object-oriented programming</em>), if one leaves out troublesome inheritance (which might be good, since composition &gt; inheritance). Inspired by Golang.</p>

<ul>
<li>Functional programming patterns like <code>.map</code>, <code>.filter</code>, over procedural code like <code>for-loops</code> etc., since the latter would encourage mutating state, and we want immutability.</li>
<li>
<a href="https://medium.com/@Rich_Harris/tree-shaking-versus-dead-code-elimination-d3765df85c80">Tree-shakeable code</a> (for client-server webapps). So it should need a source code dependency between the calling code and the called function. Which makes the language more FP than OOP, according to one <a href="https://blog.cleancoder.com/uncle-bob/2018/04/13/FPvsOO.html">definition of FP vs. OOP</a>. In general, shifting concerns from runtime to compile-time is considered a good thing, as it makes the language more predictable, optimizable, and affords helpful coding tools. Having consequences of code changes appear at runtime is a bad thing (see: <a href="https://en.wikipedia.org/wiki/Fragile_base_class">The Fragile Base Class problem of OOP</a>)</li>
<li>
<a href="https://medium.com/@olxc/referential-transparency-93352c2dd713">Referentially transparent expressions</a>. Which means variables cannot be reassigned, so a name will always refer to the same value (see principle: &#34;Things that are different should look different&#34;). Inspired by Haskell. This feature should also lead to easy automatic parallelization and memoization.</li>
<li>
<a href="https://youtu.be/yiiDFRs62lQ?t=1290">Formally verifiable</a> / provable. Nice-to-have, not must-have.</li>
</ul>


</li>
<li><p>Parallelization made natural. <a href="https://en.wikipedia.org/wiki/Purely_functional_programming#Parallel_computing">Aided by pure functions</a>. The language should make it easy/natural for programmers to use parallelism (nudges), through language constructs (like <a href="https://youtu.be/XlvfHOrF26M?t=109">executing several sequential lines simultaneously</a>), to avoid <a href="https://news.ycombinator.com/item?id=28213940">overly sequential thinking</a>, which leads to suboptimal performance due to the fact that programmers/humans think sequentially. Inspired by <a href="https://en.wikipedia.org/wiki/Verilog#Fork/join">Verilog&#39;s fork/join</a> construct. But as opposed to the fork/join example, the language should enforce a deterministic order, guaranteed implicitly by the lines sequential top-down order of appearance in the code (a novel idea, which would need to be experimented with thoroughly..). Alternatively, take <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">inspiration from Golang&#39;s elimination of the sync/async distinction</a> and allow programming everything in a sequential manner, but do parallelism under the hood. The sync/async barrier elimination, however, doesn&#39;t necessarily nudge programmers towards using parallelization (spinning off new threads) within the context of a program (thread). That style might conflict, or it might be synergistic with the goal of nudging programmers towards making more use of parallelization. Ideally, the language runtime should be able to use parallelization to handle multiple independent processes (like client/server requests; goroutines for concurrency), but also <em>automatically distribute a single program across multiple CPU cores (without special directives, like thread/go)</em> when those cores are idle. To do that, the language should nudge towards natural use of multi-threading instead of single-threading. But not at the expense of readability/reasonability, which is the top priority. The programmer should be concerned with, and simply describe independent sets of causal/logical connections, and the language runtime should automatically take care of as much parallelization as possible/needed.</p></li>
<li>

<p>Compiled, but also interpreted and/or incrementally compiled (for dev mode). Inspired by C++ and JS.</p>

<ul>
<li>Interpreted / incrementally compiled: So developer can write quick scripts and get fast feedback. Sacrifices runtime speed for compile-speed. Except it also needs quick startup/load time.</li>
<li>Compiled: For production. Sacrifices compile-speed for runtime speed. Compiles to a binary. Inspired by <a href="https://youtu.be/SYkzk_j3yb0?t=1334">Deno</a>.</li>
<li>
<a href="https://youtu.be/yiiDFRs62lQ?t=1167">Small core language</a>: Compiled down to a small instructions set, which can be used/targeted as a starting point to generate code for other programming languages (i.e. generate JS).</li>
<li>
<a href="https://youtu.be/yiiDFRs62lQ?t=1245">Portability</a>: Be able to target and run on multiple computer architectures.</li>
</ul>


</li>
<li><p><strong>Mutable API, but immutable under-the-hood</strong>. Immutable/<a href="https://en.m.wikipedia.org/wiki/Persistent_data_structure">persistent data structures</a> (like <a href="https://bendyworks.com/blog/leveling-clojures-hash-maps">Lean-HAMT</a>) and structural sharing, to allow incremental update, while also avoiding duplication of data. Inspired by Clojure. Alternatively: <a href="https://docs.rs/im/13.0.0/im/#in-place-mutation">In-place mutation</a>, where data structures only become immutable when they&#39;re shared (presumes keeping track of borrowing / reference counting). Inspired by Rust. The immutability will also facilitate concurrency and avoid race-conditions. As a bonus you could get time-series and thus time-travel for data. The desirability of a mutable API (mutating objects instead of always having to pass in functions) is inspired by the JS libraries <a href="https://immerjs.github.io/immer/">Immer</a> and <a href="https://codesandbox.io/s/zustand-valtio-jotai-counters-my6np?file=/src/ValtioCounter.tsx:181-205">Valtio</a>.</p></li>
<li>

<p><strong>Very constrained.</strong> Since <a href="https://www.sicpers.info/2020/10/discipline-doesnt-scale/">discipline doesn&#39;t scale</a>. Inspired by Golang. Should assume the developer is an <em>unexperienced, lazy, (immediately) forgetful, and habitual</em> creature. As long as software development is done by mere humans. This assumption sets the bar (the worst case), and is a good principle for DX, as well as UX. The constrained nature of the language should allow for quick learning and proficiency. Complexity should lie in the system and domain, not the language. When the language restricts what <em>can</em> be done, it&#39;s easier to understand what <em>was</em> done (a smaller space of possibilities reduces ambiguity and increases predictability, which gives speed for everyone, at a small initial learning cost). No <em>alias names</em> in the language, except for in documentation. Inspired by <a href="https://www.python.org/dev/peps/pep-0020/">Python</a> (explicit over implicit, one way over multiple ways). Counter-inspired by <a href="http://www.wall.org/~larry/pm.html">Perl</a> (postmodern plurality) and <em>aliasing</em> in the <a href="https://github.com/ramda/ramda/issues/297">Ramda</a> library. The language should favor one consistent vocabulary, since it increases predictability and reduces variability. Names should not mimic any other language per se, but attempt to cater to complete beginners, because <a href="https://quorumlanguage.com/evidence.html">notation has a large impact on novices</a>, a principle inspired by <a href="https://quorumlanguage.com/">Quorum</a>.</p>

<ul>
<li>&#34;<em><code>&lt;insert your favorite programming paradigm here&gt;</code> works extremely well if used correctly.&#34;</em> as <a href="https://medium.com/@willy.schott/one-can-say-the-same-about-fp-ca7b3944a32b">Willy Schott said</a>. The ideal programming language should both <strong>work extremely well even when used incorrectly</strong> (which all powerful tools will be), but first and foremost <strong>be extremely hard to use incorrectly</strong>.</li>
<li>Not overly terse. Counter-inspired by C. Maybe give compiler warnings if the programmer writes names with less than about 4 characters. <strong>Reading &gt;&gt;&gt; writing</strong>, since time spent reading is well over 10x time spent writing (inspired by <a href="https://www.goodreads.com/quotes/835238-indeed-the-ratio-of-time-spent-reading-versus-writing-is">Robert C. Martin</a>), and writing can be alleviated with auto-complete, <a href="https://www.trankynam.com/atext/">text macro expansions</a>, and <a href="https://code.visualstudio.com/docs/editor/userdefinedsnippets">snippets</a>, in the IDE.</li>
<li>No runtime reflection. Counter-inspired by meta-programming and runtime type inspection in Ruby.</li>
<li>Not overly verbose. Counter-inspired by XML and Java. Maybe compiler warnings if the programmer writes names with more than about 20 characters.</li>
<li>
<a href="https://www.w3.org/2001/tag/doc/leastPower.html">The Rule of Least Power</a> (by WC3), suggest a language should be the least powerful language still suited for its purpose. To minimise its complexity and surface-area. For better reuse, but more importantly: to make programs, data, and (I will include) <em>data flows</em>, easier to analyse and predict. Inspired by <a href="https://en.wikipedia.org/wiki/Finite-state_machine">FSM</a> &amp; <a href="https://xstate.js.org/">XState</a>. It needs, however, to be just powerful enough to be generally useful (and not limited to a DSL). Possibly Turing-complete. Given these considerations, a Lisp-style language comes to mind. But there&#39;s reasons Lisp never became hugely popular. My guess: readability. So while it could be a Lisp-language (or compile to one), it should read better than one.</li>
<li>It should be small, but extensible by using simple primitives. Preferably, the language should be <a href="https://github.com/nagydani/seedling/blob/master/RATIONALE.md#self-hosting">self-hosting</a>, but if not, then probably built using <a href="https://qr.ae/pGz7Uh">OCaml</a>, <a href="https://news.ycombinator.com/item?id=24224837">Rust</a>, <a href="%5BRacket%5D(https://felleisen.org/matthias/manifesto/sec_pl-pl.html)">Racket</a> or <a href="https://qr.ae/pGz7Og">maybe</a> Haskell (LLVM has bindings to these languages). Should do more with less. Inspired by Lisp. Since predictability is good for humans reading, and for machines interpreting, and if it&#39;s predictable to machines, humans also benefit. <strong>Important</strong>: <em>&#34;As one adds features to a language, it ramps up the complexity of the interpreter. The complexity of an analyzer rises in tandem.&#34;</em> - <a href="http://matt.might.net/articles/intro-static-analysis/">Matt Might, on static analysis</a>
</li>
<li>
<strong>Code-Formatter</strong>, like <a href="https://go.dev/blog/gofmt">gofmt</a>, inspired by Golang. A tool to auto-format code into a standard. Since standardisation creates readability and faster onboarding of new developers. It also enables mechanical source transformation, which is crucial for language evolvability.</li>
</ul>


</li>
<li>

<p>Containability and explicitness. Inspired by <strong>pure functions</strong>. Perhaps the language should even restrict a function&#39;s scope only to what&#39;s sent in through its parameters. So no one can reference <a href="http://blog.jenkster.com/2015/12/what-is-functional-programming.html">hidden inputs</a> (i.e. side-causes). Thus enforcing more predictable functions, where it is always apparent where it is used: what the function takes in and what it returns. So to achieve partial application of functions (i.e. useful closures), without addressing the outer scope implicitly, could be to supply constants from the outer scope as default/preset/front-loaded parameters. Since &#34;explicit is better than implicit&#34; (inspired by <a href="https://www.python.org/dev/peps/pep-0020/">Python&#39;s principles</a>). That way, they would be declared in the function signature, so you don&#39;t have to dive into the function to discover/investigate them. With the added benefit that the function could be customized by the caller through overriding the defaults.</p>

<ul>
<li>Memoization automatically. Aided by pure functions. The programmer shouldn&#39;t have to think about <a href="https://en.wikipedia.org/wiki/Memoization">memoization</a> when programming, but should be able to tune the degree of memoization (since it is a space/time tradeoff) through general configuration, for advanced cases not optimal from the default. Run time optimisations such as these are not critical features, but certainly nice to have, and should be considered in the language design.</li>
</ul>


</li>
<li><p>Pattern-matching. Inspired by Elixir. The expression-oriented nature of the language should make this natural, without extra/fancy syntax.</p></li>
<li><p>Not file boundary dependent. Can be split into files, but execution shouldn&#39;t be dependent on file boundaries. So the programmer is free to keep code tightly together. Inspired by SolidJS.</p></li>
<li>

<p>No magic / hidden control. Control-flow should be easy to trace, because it makes it easy to understand and debug. Less magic. Counter-inspired by Ruby on Rails. Inspired by Elixir <a href="https://dockyard.com/blog/2015/11/18/phoenix-is-not-rails">Phoenix routing / endpoint plugs</a>. Testing isolated parts is made possible by explicitness. Explicit is better than implicit. Inspired by <a href="https://www.python.org/dev/peps/pep-0020/">Python&#39;s principle</a>. Explicitness makes testing isolated parts of the system possible. So Explicit &gt; Implicit, almost always. (Although implicitness is preferred when one may intuitively and robustly determine the convention through the context. E.g. Needing <code>self.</code> references to access class variables inside the class methods would just be <a href="https://stackoverflow.com/q/68461184/380607">noise</a>. This is counter-inspired by Python, and inspired by Ruby. However, using <code>self</code> and <code>this</code> are considered <a href="https://kentcdodds.com/blog/classes-complexity-and-functional-programming">an anti-pattern</a> in general.)</p>

<ul>
<li>Make Inversion of Control (IoC) hard/impossible (?). Should ideally always return control to the programmer, not take it away. To enable the programmer to always follow the control-flow by simply reading and following references. Thus, <code>yield</code> should also be avoided (counter-inspired by Ruby). Problem: Could make domain code dependent on integrations which goes against <a href="https://khalilstemmler.com/articles/enterprise-typescript-nodejs/clean-nodejs-architecture/">the dependency inversion rule</a>. So other patterns, like containing integration coupling in an intermediary abstraction (&#39;port/adapter&#39; function or library, or &#39;channels&#39;), would need to be developed.</li>
<li>Libraries over frameworks, as a <a href="http://tomasp.net/blog/2015/library-frameworks/">strongly recommended</a> community convention (because frameworks cannot be prevented by a language, afaik). Frameworks utilise inversion of control. That creates Stack Traces which are really hard to debug, because they reference the framework and not your own code, <a href="https://youtu.be/PNx9WqQ9QeA?t=646">esp. problematic with concurrency</a>. And when yielding control to various (micro-) frameworks, compatibility becomes a specific issue. The programmer shouldn&#39;t ever have to ask: &#34;Is this library/framework compatible with this other one?&#34;.  Counter-inspired by JS (&#34;JS Fatigue&#34;). Or have to ask &#34;Where is the execution path of this program?&#34;. Counter-inspired by the magic of Ruby on Rails. When the control is always returned to the programmer (no IoC), he/she may likely mix and match more as pleased, without up-front worrying about compatibility (leading to analysis paralysis).</li>
<li>Meta-programming: No first-class macros (runtime), since it is a too powerful footgun. But should have compile-time macros. Inspired by Clojure. So that the language can be extended by the community, and so that legacy code could be updated to latest language version by processing the code with macros to transform the syntax.</li>
<li>
<strong>Expressions over statements</strong>. The calling code should always get something back (<a href="https://biblehub.com/isaiah/55-11.htm">Is. 55:11</a>). Because the returned object can be further chained. Inspired by Clojure <a href="https://blog.jle.im/entry/first-class-statements.html">and Haskell</a>. Counter-inspired by JavaScript. <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=513379#c21">Statements suck</a>, as even Brendan Eich, the inventor of JS, admits. A goal should be to eliminate the subjective/anthropocentric bias that afflicts programming (especially the Imperative kind), because: <em>It is not you, the programmer, which is, or should be, calling code, but code should be calling code (and not terminating in the void, like as if it&#39;s you the programmer who is acting on the machine).</em>
</li>
</ul>


</li>
<li>

<p>Abstractions which are powerful, made from simple primitives. <em>Maybe</em> homoiconicity... since it would make writing the compiler easier, and making the language more readily available to evolve in the community on its own (permissionless). Inspired by Lisp and Clojure&#39;s Rich Hickey.</p>

<ul>
<li>But this would allow meta-programming, and the associated complexity..?</li>
<li>The language should maybe also not be so powerful that programs become entirely composed by very high-level domain-specific abstractions, since it encourages esotericity and sociolects, but most importantly: code indirection when reading/browsing. Coding should not feel like designing an AST, so should try to encourage keeping the code flattened (by piping perhaps?) and as down-to-earth as possible. Could maybe be alleviated by an IDE plugin which would allow temporary automatic code inlining (editable previews).</li>
</ul>


</li>
<li>

<p><strong>Reversible debugging / time-travel debugging (TTD)</strong>. “Reverse debugging is the ability of a debugger to stop after a failure in a program has been observed and go back into the history of the execution to uncover the reason for the failure.” <a href="https://undo.io/resources/reverse-debugging-time-travel-debugging-brief-hist/">Jakob Engblom</a>. Inspired by <a href="https://www.youtube.com/watch?v=Agu6jipKfYw">Elm</a>. Re: Accounting for human limitations and affording the most natural way of thinking: <em>&#34;The problem you are trying to fix is at the end of a trail of breadcrumbs in the program’s execution history. You know the endpoint but you need to find where the beginning is, so working backwards is the logical approach.&#34;</em> <a href="https://undo.io/resources/reverse-debugging-time-travel-debugging-brief-hist/">source</a>. Should at least have this. Could be enabled by, but not necessarily need:</p>

<ul>
<li>Reversible / invertible control flow: &#34;A reversible programming language produces code that can be stopped at any point, reversed to any point and executed again. Every state change can be undone.&#34; <a href="https://wiki.c2.com/?ReversibleProgrammingLanguage">source</a>. Maybe. Might not be feasible, or desirable, when it comes down to it. Might be aided by immutability, and persistent data structures (if they are extended with history-traversal / operation logging features, in addition to structural sharing).</li>
</ul>


</li>
<li>

<p><strong>Transpiler, configurable</strong>, so it could translate between all language dialects and variations. So that the language could evolve in multiple directions, and consolidate later, without harm.</p>

<ul>
<li>Homoiconicity could perhaps enable this.</li>
</ul>


</li>
<li>

<p><strong>Async: blocking/sync interface, but non-blocking I/O</strong>. Inspired by Golang, and to lesser extent JS / Node.js too. Should not have to litter code with async/await repeatedly (see: <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">what color is your function?</a> and <a href="http://pchiusano.blogspot.com/2009/05/optional-laziness-doesnt-quite-cut-it.html">the problem with function annotations</a>, and <a href="http://joeduffyblog.com/2015/11/19/asynchronous-everything/">async everything</a>). NB: But hiding the async nature with synchronous seeming abstractions could create a dangerous model-code gap with a potential impedance-mismatch and cause for design errors and bugs (<a href="https://youtu.be/5OjqD-ow8GE?t=2768">inspired by Simon Brown</a>). So the language should make some abstractions around async simple (like channels and goroutines in Golang). But also inspired by declarative and easily statically analysable async contexts, made with JSX, like Suspense (async if-statement), in React and SolidJS.</p>

<ul>
<li>
<strong>Ease of reasonability is first priority</strong>, and I believe it is best afforded by <strong>simple and clear abstractions</strong> (without model/code impedance mismatch, as made important by failures of ORM&#39;s and distributed contexts). The choice of sync interface here as opposed to async, is similar to how the wish for <a href="https://en.wikipedia.org/wiki/Lazy_evaluation">lazy evaluation</a> by default was discarded for eager evaluation by default. One <a href="https://mappingthejourney.com/single-post/2017/08/31/episode-8-interview-with-ryan-dahl-creator-of-nodejs/">argument by Ryan Dahl of Node.js</a> is that sync by default with explicit async (he mentiones goroutines in Go) is a nicer programming model than async everything (like in Node). Because it&#39;s easier to think through what you&#39;re doing than jumping into other function calls like in Node.js. Reasonability is a top priority.</li>
<li>
<a href="https://youtu.be/drmNlZVkUeE?t=1845">Rich Hickey also has some good arguments against async by default</a> (when implemented with callbacks), namely that it:

<ul>
<li>fragments your logic (spread out into handlers), instead of keeping it together. Programmer has to deal with multiple contexts at once (complicated), instead of one overarching context (simple).</li>
<li>callback handlers perform some action once in the future, but the state they are operating on may have mutated in the meanwhile. So it may give a false confidence in being able to get back to the state as it were when the callback was made. Want to avoid the dreaded <a href="https://youtu.be/PNx9WqQ9QeA?t=90">Shared Mutable State</a>. May be solved with only allowing immutable constructs.</li>
</ul>


</li>
<li>On the other hand, having sync by default, and <em>async through <a href="https://tour.golang.org/concurrency/2">Channels</a></em>:

<ul>
<li>gives the control back immediately (in line with functional composition) instead of functions that effectively evoke side-effects on the real world on the other end (as callback handlers do).  In line with our principle: Always give control back to the programmer.</li>
<li>channels are generalized pieces of code that can handle many connections (pub/sub).</li>
<li>channels afford safe concurrency (thread handling), whilst with callback handlers (unless used in an event-loop system such as JS) the programmer has to ensure safe concurrency (which we <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">don&#39;t want</a>).</li>
<li>channels afford choice on when to handle an event, whereas with a callback it gets called whenever it gets called (event-loop). Channels work in line with our principle: Always give control back to the programmer.</li>
</ul>


</li>
<li>All of the above have implications for reasonability. Needs to be investigated further... Golang&#39;s way of handling async seems to be <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">the current gold standard</a>, touted by many bright people, since <em>&#34;Golang has eliminated the distinction between synchronous and asynchronous code&#34;</em> (by letting the programmer code everything in a sync fashion, but doing async I/O under the hood). Golang&#39;s principle of <em>&#34;Don&#39;t communicate by sharing memory; share memory by communicating.&#34;</em> avoids the dreaded <a href="https://youtu.be/PNx9WqQ9QeA?t=90">Shared Mutable State</a> and affords itself better to ensure <strong>simple, safe, and scalable modes of thinking</strong> (our core principle): It&#39;s hard to think of something, if it has changed the next time you think about it (thus: immutability). Or if thinking about it changes it (manifesting in code the cognitive equivalent of <a href="https://en.wikipedia.org/wiki/Heisenbug">Heisenbug</a>&#39;s): Programmers need to be able to reason about a program&#39;s state without simultaneously modifying that state (<a href="https://en.wikipedia.org/wiki/Command%E2%80%93query_separation#Connection_with_design_by_contract">inspired by CQRS</a>).</li>
</ul>
</li>
<li>

<p><strong>Concurrency. For Multi-Core and Distributed.</strong> Probably a CSP model, or a similar or novel model, due to easier to <a href="https://youtu.be/PNx9WqQ9QeA?t=646">debug concurrency</a>. Inspired by Go.</p>

<ul>
<li>Async: Concurrency should integrate well with the async feature of the language. Default should be to easily ship tasks off to be completed elsewhere (other thread/process/worker/server). Inspired by Golang and JS.</li>
<li>Probably not implemented as an Actor Model. Since sending events may be harder to reason about than stricter promise-based operations (using callbacks under-the-hood). Counter-inspired by StimulusJS. Inspired by ReactJS.</li>
</ul>


</li>
<li>

<p><strong>Scalable</strong>: From single core to multiple core CPUs, and from one to a distributed set of machines. Inspired by the purpose of the <a href="https://www.brianstorti.com/the-actor-model/">Actor Model</a>, from Erlang/Elixir. But rather implemented with &#34;Machines&#34; which is a novel concept that combines a Mailbox with a stateless function (executed asynchronously), as the universal primitive of concurrent operation. That way, instead of functions calling functions directly, which strongly couples them, which is bad, they call each other by sending Messages (containing the parameters) to the other function&#39;s Mailbox. We call such functions &#34;Machines&#34;. Each of them are in fact a mini-computer, or a computer-within-the-computer, if you will. Such Machines should be able to be moved to distributed systems without rewriting the code (inspired by Actor Model systems).</p>

<ul>
<li>Ideally, for performance, when code is compiled to be run on a single machine, the compiler should be able to be optimise away the Mailboxes, so that Machines can be turned into (simpler and faster) synchronously executed functions.</li>
<li>The language should facilitate and nudge developers&#39;s towards creating &#34;Functional Core, Imperative Shell&#34; architectures (inspired by <a href="https://www.destroyallsoftware.com/talks/boundaries">Bernhardt at 31:56 in his Boundaries talk</a>), to preserve the purity of functions as far as possible, while also <strong>containing side-effects</strong>:

<ul>
<li>By semantic rules: A function should <em>either return a value, or don&#39;t return anything</em> (i.e. be simply a void procedure). And a procedure can never be placed within a function.</li>
<li>Alternatively: use <a href="https://blog.jle.im/entry/io-monad-considered-harmful">an IO action of an IO type</a> (inaccurately named &#34;IO Monad&#34; at 30:44 in the <a href="https://www.destroyallsoftware.com/talks/boundaries">Boundaries talk</a>), transparently (without actually having to <a href="https://www.google.com/search?q=what+is+a+monad+meme&amp;client=firefox-b-e&amp;source=lnms&amp;tbm=isch&amp;sa=X&amp;ved=2ahUKEwjdu9i0ocXyAhWZS_EDHdiqDZcQ_AUoAXoECAEQAw&amp;biw=1512&amp;bih=833">deal with the concept of a Monad</a>). Where you effectively construct a sequence of I/O operations to be executed later. Inspired by Haskell. Something like this is needed because the Mailbox is stateful (it is constructive/destructive, like a queue), and I/O messaging would be a side-effect. The Machine/Mailbox is inspired by the Actor Model from Erlang.</li>
<li>Alternative to use of Monads and Immutability: Use <a href="http://lambda-the-ultimate.org/node/2708">Uniqueness Type</a>, which allows mutability and pass-by-value while also preserving referential transparency (since side-effects are ok in a pure language as long as variables are never used more than once). Inspired by <a href="https://en.wikipedia.org/wiki/Clean_(programming_language)">Clean</a> and <a href="https://www.idris-lang.org/">Idris</a>. Possibly use <a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.142.5413&amp;rep=rep1&amp;type=pdf">Simplified Uniqueness Typing</a>, inspired by <a href="https://www.openhub.net/p/12489">Morrow</a>.</li>
</ul>


</li>
</ul>
</li>
<li><p>Reactive. Inspired by <a href="https://www.youtube.com/watch?v=Agu6jipKfYw">Functional Reactive Programming, and Elm</a>, and <a href="https://www.reactivemanifesto.org/">The Reactive Manifesto</a>. Though the latter is geared at distributed systems, it could also be a model for local computation (rf. Actor model, and <a href="https://akka.io/">Akka</a>). The programming language should make default and implicit the features of reactivity and streaming, as opposed to preloading and batch processing. (Reactive Streaming Data: Asynchronous non-blocking stream processing with backpressure.)</p></li>
<li><p>No single-threaded event loop that can block the main thread. Counter-inspired by JS.</p></li>
<li><p><a href="https://medium.com/javascript-scene/transducers-efficient-data-processing-pipelines-in-javascript-7985330fe73d">Transducers</a>, under-the-hood, to compose and collate/reduce transformation functions (chains of map, filter etc. turn into a single function, <a href="https://web.archive.org/web/20190316032907/https://medium.com/@roman01la/understanding-transducers-in-javascript-3500d3bd9624">visualised here</a>). Chaining function calls should use language-supported transducers implicitly. Language should not require special <code>compose</code> syntax.</p></li>
<li><p>Eager evaluation, generally. Since it is more straightforward to reason about in most cases, simpler to analyze/monitor, and spreads memory consumption out more in time, than <a href="https://en.wikipedia.org/wiki/Lazy_evaluation">lazy evaluation</a> which would pile up work and in worst case could <a href="https://prog21.dadgum.com/40.html">overflow memory at an unexpected time</a> (in any case, the programmer shouldn&#39;t have to worry about evaluation strategies, including <a href="http://pchiusano.blogspot.com/2011/12/future-of-programming.html">space usage performance and evaluation stack usage</a>). But should use the more efficient lazy evaluation when currying functions or chaining methods, unless intermediate error-handling or similar requires value realization (and even here, transducers could potentially alleviate unnecessary value realization).  Inspired by Lazy.js. But this is an optimisation that could wait. Concurrent operations across threads/processes should never be lazy. Counter-inspired by Haskell.</p></li>
<li>

<p>Gradually typed, as types can be boilerplate and create noise in the code (counter-inspired by TypeScript, and inspired by Elm). Most types should be inferred (inspired by Haskell and TypeScript).</p>

<ul>
<li>No runtime type errors. Inspired by Elm (and Haskell). See &#39;Error Handling &amp; Nullability&#39;.</li>
<li>Types should be associative/commutative/composable/symmetric, inspired by Dotty/Scala3, and the <a href="https://youtu.be/YR5WdGrpoug?t=623">&#39;Maybe Not&#39; talk by Rich Hickey</a>.</li>
<li>Types should be enforced statically at program exit boundaries (so external libraries or outgoing I/O are ensured existing typings).</li>
<li>Strongly typed (checked at compile time), not weakly typed, since implicit type coercion (at runtime) can be unpredictable. Inspired by TypeScript. Counter-inspired by JavaScript.</li>
<li>Structurally typed (inspired by TypeScript, OCaml), instead of nominally typed (counter-inspired by <a href="https://www.youtube.com/watch?v=aSEQfqNYNAc">Java</a> and <a href="https://lexi-lambda.github.io/blog/2020/01/19/no-dynamic-type-systems-are-not-inherently-more-open/#footnote-ref-2-1">Haskell</a>).</li>
<li>No <a href="https://research.swtch.com/generic">generics</a>, but static analysis of functions based on structural typing on the partial structure used (anywhere) inside it (disregarding dynamic/conditional use). If passing in dynamic values to a function, type would need to be statically declared <em>where it is passed in</em>, so static analysis at compile time can determine if those types match the partial structural types used within.</li>
<li>Type inference, fully decidable. Inspired by OCaml. For increased readability and convenience (though not essential, cf. popularity of Rust). To not have to declare types everywhere. But local type inference for the body of functions are what&#39;s most important.</li>
</ul>


</li>
<li><p><strong>Composable.</strong> Favour composition over inheritance. Inspired by Robert C. Martin, Martin Fowler, and <a href="https://reactjs.org/docs/composition-vs-inheritance.html">JSX in React</a>. Composability entails it should be easy to write code that is <em>declarative</em>, <em>isolated</em> and <em>order-independent</em>. See &#34;strongly typed&#34;.</p></li>
<li>

<p>Memory safe, ergonomic, and fast. should be safely and implicitly handled by the language, without a runtime GC.</p>

<ul>
<li>No Garbage-Collector (GC), but also no garbage. Deterministic Object lifetimes, and Ownership tracking (affinity type system). Inspired by Rust and <a href="https://github.com/carp-lang/Carp">Carp</a>.</li>
<li>Memory-safe. Maybe a Borrow Checker and Reference Counting. Inspired by Rust. But ideally, <a href="https://blog.logrocket.com/introducing-the-rust-borrow-checker/">Ownership and Borrowing</a> should be implicit by the programming language, so the programmer wouldn&#39;t have to think about low-level concerns such as memory management. To avoid conceptual overhead of manual memory management (as with explicit borrowing semantics), the language should perhaps use or take inspiration from <a href="https://koka-lang.github.io/koka/doc/book.html#why-perceus">Koka&#39;s Perceus Optimized Reference Counting</a>. Koka apparently allows even more <a href="https://www.microsoft.com/en-us/research/publication/perceus-garbage-free-reference-counting-with-reuse/">precise reference counting (see sect: 2.2)</a> than Rust.</li>
</ul>


</li>
<li><p>Secure from the start. Secure runtime. Inspired by Deno. Safety has to be a built-in design-goal from the start, it cannot be added on later. As evidenced by the justification of existence of Deno (Node was unsafe), and Rust (C++ was unsafe). Also, see: memory safe.</p></li>
<li>

<p>Few core primitives, and based on very few fundamental concepts to learn. Inspired by Lisp. No limiting distinctions like only half-way interchangeable expressions vs. statements in JS.</p>

<ul>
<li>But avoid mini-languages/DSL&#39;s. Dialects/sociolects hinder generalised understanding and learnability (adds knowledge debt). Counter-inspired by Lisp and Ruby. Even though it might be true that “Domain-Specific Languages are the ultimate abstractions.” as Paul Hudak put it in 1998, some cross-domain terms are usually helpful for onboarding programmers, since they afford familiar knobs on which to hang the other unfamiliar code. Even if you don&#39;t understand the domain (or its plethora of abstractions), you would at least understand <em>something</em>. From where you could build your further understanding.</li>
</ul>


</li>
<li><p>Ergonomic to type. Prefer text over special characters like curly brackets (they are hard to tell apart from parentheses in JS). No littering of parentheses. Inspired by Ruby. Counter-inspired by JavaScript, Lisp, and JSON.</p></li>
<li><p>No super-powerful tools which may hurt you or others in the long run. Counter-inspired by meta-programming in Ruby.</p></li>
<li><p>Crash-safe. Can crash at any time and resume computation at exact same spot when restarted. Inspired by Erlang.</p></li>
<li><p>Piping, or some form of it. But always top-to-bottom or left-to-right. Inspired by Bash, and functional programming with pipes (Elixir, BuckleScript, and <a href="https://mobily.github.io/ts-belt/">ts-belt</a>). <a href="https://www.javierchavarri.com/data-first-and-data-last-a-comparison/">Data-first instead of data-last</a>.</p></li>
<li>

<p>No Exceptions. Inspired by Go. But Recoverable and Unrecoverable errors. Inspired by Rust. (Definitely <a href="http://literatejava.com/exceptions/checked-exceptions-javas-biggest-mistake/">no checked exceptions</a>, as it breaks encapsulation by imposing behavior on the callee. Counter-inspired by Java).</p>

<ul>
<li>Result data type, for error handling and validation. Inspired by Result from Rust and F#, and <a href="https://blog.thomasheartman.com/posts/haskells-maybe-and-either-types">Either from Haskell</a> and Elm, although it should not be called Either, as <a href="https://youtu.be/YR5WdGrpoug?t=623">Either is a confusing misnomer</a>.</li>
</ul>


</li>
<li>

<p>Error handling &amp; Nullability: No explicit <code>null</code> or <code>nil</code> value. Meaning no Null Errors (typically occurring far removed from their point of inception). Inspired by Elm and Rust. But without having to explicitly declare <code>Maybe</code> or <code>Option</code> types (inspired by Hickey&#39;s <a href="https://youtu.be/YR5WdGrpoug?t=623">Maybe Not</a>). Instead, <em>automatically but statically</em> infer and create/augment a function&#39;s return type to a &#34;nullable reference type&#34; indicated by a <code>?</code> after the typename, whenever there is an unhandled condition that could result in a null value. Or <em>automatically</em> create a <code>NullObject</code> (see: <a href="https://youtu.be/OMPfEXIlTVE?t=904">NullObject pattern</a>) of the function&#39;s declared return type (which with type inference can avoid some timid coding patterns, like always checking for null, counter-inspired by Golang). Maybe even better, <a href="https://twitter.com/magnemg/status/1417517013321273345?s=20">let every type declare and handle their own empty state</a>. If all types are <a href="https://twitter.com/magnemg/status/1429914312211054602?s=20">defined in terms of Monoids</a>, then <strong><em>null</em> can be replaced by the identity value (of each Monoid)</strong>, so that combinations within that type never fail, and never alter the result. Resulting in no more <a href="https://youtu.be/T8J0j2xJFgQ?t=151">timid coding patterns</a> like null checks. Furthermore, the return type from functions using I/O (like <code>IOMonad</code> in Haskell), should always be augmented/inferred from static analysis. </p>

<ul>
<li>
<em>Variant Types</em> for error-handling using return values (like <code>Result&lt;Type, Error&gt;</code>, inspired by Rust), instead of special syntax. <a href="https://qr.ae/pGPMUk">Counter-inspired by Golang</a>.</li>
<li>So that <a href="https://overreacted.io/the-bug-o-notation/">you have less avenues to explore when debugging</a> and <a href="https://lispcast.com/why-are-corner-cases-the-devil-%f0%9f%98%88/">fewer branches to check when programming</a>, so you can write <a href="https://www.youtube.com/watch?v=T8J0j2xJFgQ">Confident Code</a> focused on the happy-path.</li>
<li>No possibility of failing silently during runtime (due to syntax errors). Counter-inspired by JS.</li>
</ul>


</li>
<li><p>Compilation should be able to target some popular language &amp; ecosystem, like <strong>transpile to JavaScript or <a href="https://dev.to/taybenlor/web-assembly-should-be-a-default-binary-target-44m6">compile to WASM</a></strong>, or potentially even the JVM, to get cross-platform interoperability. But not any target for any cost, if it would put unwieldy constraints on the language design. WASM seems like the best candidate.</p></li>
<li><p>Small standard library. To have some common ground of consolidation, and to provide the basic and most common utils. So usage will be fairly standard, and coming into a new codebase not feel too foreign.</p></li>
<li><p>Single package directory: Some sort of singular reference to a library package information service. So the community can organise around one common point, instead of scattering. Inspired by NPM. But doesn&#39;t necessarily need to be centralised package download/storage, the storage/download could be decentralised. But would need to be safe. Cert signing?</p></li>
<li><p>Runtime environment: Be able to run on some existing popular cross-platform runtime (like WASM or the JVM?). Inspired by Clojure. And/Or have a very minimal programming language runtime (without a GC). Inspired by Rust. But the runtime should in any case handle the scheduling of goroutines, inspired by Go.</p></li>
<li><p><strong>Ecosystem: Interoperable</strong> with one or more existing programming language ecosystems. To import or reuse libraries. Without too much ceremony. So the ecosystem doesn&#39;t have to start from scratch.</p></li>
<li><p>Be <a href="https://github.com/nagydani/seedling/blob/master/RATIONALE.md">general purpose enough</a> to at least write scripts and CLIs, but also web servers/clients.</p></li>
<li><p>Editor integration: Should afford simple integration into editors/IDEs like VS Code. Syntax highlighting, a <a href="https://code.visualstudio.com/api/language-extensions/language-server-extension-guide">language server</a> (for autocomplete, error-checking (diagnostics), jump-to-definition etc.), via the <a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol (LSP)</a>.</p></li>
<li><p>Well-documented. Documentation on language syntax should be accessible from the editor/IDE, vha. the LSP.</p></li>
<li><p>Well-tested.</p></li>
<li><p>All the while, the language should avoid the <a href="https://www.youtube.com/watch?v=ltCgzYcpFUI">fate of the Vasa</a>.😂 Which means a feature creep resistant <em>core language</em>. (I am aware the irony of this feature list, but read on...) Which should be designed and decided upon as early as possible (when the degrees of freedom in the design space is as wide as possible), with a holistic view. Boring &gt; clever. Designed to reach a 80% <a href="https://youtu.be/ltCgzYcpFUI?t=2244">sweet spot of most important features</a>, foregoing the most exotic and esoteric features, and foregoing the ability to solve edge-cases (such should be relegated to interoperability with other more specialized programming languages). Since 80% of the work and complexity would come from the last 20% (<a href="https://www.investopedia.com/terms/1/80-20-rule.asp">The Pareto Principle</a>).</p></li>
</div><p>One or more of these requirements might be conflicting / mutually exclusive. Maybe. But maybe not?</p><p>One can always dream.</p><p>This is a list of my preferences. Some would probably be quite controversial. Like my dislike for certain features, which a lot of other people like (e.g. meta-programming). I might just not be familiar enough with them to have developed an appreciation for them.</p><p>I will try to keep this list updated if and when I change my mind on any point, which I am open to doing. I have already changed my mind from negative to positive on pattern-matching.</p></div>
  </body>
</html>
