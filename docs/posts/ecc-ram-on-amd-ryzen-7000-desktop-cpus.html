<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sunshowers.io/posts/am5-ryzen-7000-ecc-ram/">Original</a>
    <h1>ECC RAM on AMD Ryzen 7000 Desktop CPUs</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>One of the coolest features of AMD’s Ryzen desktop CPUs, and historically a great reason to get them
over the competition, was the official support for error-corrected memory (ECC RAM)<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>. With most Ryzen
1000 through 5000 series CPUs and the right motherboards, ordinary users could get ECC RAM going
without having to spring for more expensive workstation-grade CPUs.</p><figure><a href="https://sunshowers.io/images/b550-specs.png"><img src="https://sunshowers.io/images/b550-specs.png" alt="Screenshot of B550 Steel Legend specification page, showing support for ECC &amp; non-ECC, unbuffered memory"/></a><figcaption>Specification page for the B550 Steel Legend motherboard.</figcaption></figure><p>For example, here’s the <a href="https://www.asrock.com/mb/AMD/B550%20Steel%20Legend/index.asp#Specification">specification
page</a> for the ASRock
B550 Steel Legend motherboard. This is a mainstream “B” series motherboard which lists detailed
compatibility information for ECC RAM by processor generation.</p><p>(To my knowledge ASRock has had the best support for ECC RAM in Ryzen motherboards, and I’ve been
very happy with their motherboards in general.)</p><hr/><figure><a href="https://sunshowers.io/images/x670e-specs.png"><img src="https://sunshowers.io/images/x670e-specs.png" alt="Screenshot of X670E Taichi specification page, without support for ECC memory"/></a><figcaption>Specification page for the X670E Taichi motherboard, with no mention of ECC support.</figcaption></figure><p>Unfortunately, when the AMD Ryzen 7000 “Raphael” CPUs were launched along with the brand new <a href="https://en.wikipedia.org/wiki/Socket_AM5">Socket
AM5</a>, all mention of ECC support was gone. The
<a href="https://www.asrock.com/mb/AMD/X670E%20Taichi/index.asp#Specification">specification page</a> for the
ASRock X670E Taichi, one of the most expensive AM5 motherboards you can buy, has <strong>no mention of ECC
support</strong> as of the date of writing this.</p><p>I still decided to upgrade to a Ryzen 7950X, and overall I’ve been happy with the performance of the new processor. But the lack of ECC was a huge bummer at the time of purchasing my system.</p><p>A couple months ago I came across <a href="https://forum.asrock.com/forum_posts.asp?TID=24901">a topic on the ASRock
forums</a> talking about ECC support on AM5
motherboards, in which a user called ApplesOfEpicness said that they’d worked with an AMD engineer
to get ECC RAM going within AMD’s AGESA firmware. They’d claimed to have tested it on an ASRock
motherboard with an updated UEFI, by shorting ground and data pins, and seeing errors be reported up
to the OS.</p><p>I was intrigued by this! Even though I didn’t have the same motherboard that ApplesOfEpicness did, I
had chosen an ASRock board (the <a href="https://pg.asrock.com/mb/AMD/B650E%20PG%20Riptide%20WiFi/index.asp">B650E PG
Riptide</a>)—I had figured that
if ECC was possible on any AM5 board at all, it would be supported on ASRock. So based on the forum
post, last week I ordered <a href="https://v-color.net/products/ddr5-ecc-udimm-servermemory?variant=43445581906087">a pair of 32 GB server-grade ECC sticks from
v-color</a>.</p><p>I updated my motherboard’s UEFI to the latest version (version 1.28 with AGESA 1.0.0.7b), and then
replaced my existing RAM with the new sticks. I started up the system, and after a very long <a href="https://www.allaboutcircuits.com/news/boosing-memory-performance-age-ddr5-introduction-ddr-training-modes/">link
training</a>
process<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>… it booted up!</p><p>On the Linux side, all indications were that the ECC memory was functioning correctly. <code>sudo dmidecode -t memory</code> reported:</p><pre tabindex="0"><code>% sudo dmidecode -t memory
Physical Memory Array
	Location: System Board Or Motherboard
	Use: System Memory
	Error Correction Type: Multi-bit ECC

... &lt;snip&gt; ...

Handle 0x0033, DMI type 17, 92 bytes
Memory Device
        Array Handle: 0x002E
        Error Information Handle: 0x0032
        Total Width: 72 bits
        Data Width: 64 bits
</code></pre><p>(The “Total Width” field is the important one here. For non-ECC RAM it read 64 bits, but in my case it was 72 bits because 64-bit ECC RAM has an <a href="https://www.anandtech.com/show/43/6">extra 8 bits</a> of parity data.)</p><p>Also, the Linux kernel reported that its error detection and correction subsystem,
<a href="https://docs.kernel.org/driver-api/edac.html">EDAC</a>, was enabled:</p><pre tabindex="0"><code>% sudo dmesg | grep -i EDAC
[    0.444842] EDAC MC: Ver: 3.0.0
[   25.042690] EDAC MC0: Giving out device to module amd64_edac controller F19h_M60h: DEV 0000:00:18.3 (INTERRUPT)
[   25.042693] EDAC amd64: F19h_M60h detected (node 0).
[   25.042696] EDAC MC: UMC0 chip selects:
[   25.042697] EDAC amd64: MC: 0:     0MB 1:     0MB
[   25.042699] EDAC amd64: MC: 2: 16384MB 3: 16384MB
[   25.042702] EDAC MC: UMC1 chip selects:
[   25.042703] EDAC amd64: MC: 0:     0MB 1:     0MB
[   25.042704] EDAC amd64: MC: 2: 16384MB 3: 16384MB
</code></pre><p>Looking good so far!</p><p>At this point it’s worth asking about the source of these messages. Where is the data coming from
and why should we believe it?</p><p>Let’s look at <code>dmidecode</code> first. <code>man dmidecode</code> <a href="https://linux.die.net/man/8/dmidecode">starts with</a>:</p><blockquote><p>dmidecode is a tool for dumping a computer’s DMI (some say SMBIOS) table contents in a human‐readable format. This table contains a description of the system’s hardware components, as well as other useful pieces of information such as serial numbers and BIOS revision. Thanks to this table, you can retrieve this information without having to probe for the actual hardware. While this is a good point in terms of report speed and safeness, this also makes the presented information possibly unreliable.</p></blockquote><p>Oh, interesting, “possibly unreliable” is a little concerning! What is this SMBIOS thing anyway? <a href="https://en.wikipedia.org/wiki/System_Management_BIOS">Wikipedia says</a>:</p><blockquote><p>In computing, the System Management BIOS (SMBIOS) specification defines data structures (and access methods) that can be used to read management information produced by the BIOS of a computer. This eliminates the need for the operating system to probe hardware directly to discover what devices are present in the computer.</p></blockquote><p>So the data presented by <code>dmidecode</code> is coming from the <em>UEFI</em>, not from the processor<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>. What this means is that the memory is ECC-<em>capable</em>, but not necessarily that it is <em>active</em>. Whether ECC is active is ultimately determined by the <a href="https://en.wikipedia.org/wiki/Memory_controller">memory controller</a> on the system.</p><p>When I mentioned setting up ECC at <a href="https://oxide.computer/">work</a>, <a href="https://fingolfin.org/blog/">Robert
Mustacchi</a> pointed me to the excellent <a href="https://github.com/oxidecomputer/illumos-gate/blob/5f01ecd8941eadb64bc15b1a02c468604c1a503e/usr/src/uts/intel/sys/amdzen/umc.h#L22">illumos documentation about
AMD’s Unified Memory
Controller</a>.
I did some reading and learned that essentially, AMD processors expose a bus called the System
Management Network (SMN). Among other things, this bus can be used to query and configure the AMD
Unified Memory Controller (UMC).</p><div><p><strong>NOTE:</strong> The information in the rest of this section is not part of the public AMD Processor
Programming Reference, but can be gleaned from the source code for the open-source Linux and
illumos kernels.</p><p><strong>WARNING:</strong> Accessing the SMN directly, and especially sending write commands to it, is dangerous
and can <strong>severely damage</strong> your computer. Do not write to the SMN unless you know what you’re
doing.</p></div><p>The idea is that we can ask the UMC the question “is ECC enabled” directly, by sending a read
request over the SMN to what is called the <code>UmcCapHi</code> register. The exact addresses involved are a
little bit magical, but on illumos with a Ryzen 7000 processor, here’s how you would query the UMC
over the SMN bus (channel 0 and channel 1 are the two memory channels on the system, and each
channel has one of the 32GB sticks plugged into it.)</p><div><pre tabindex="0"><code data-lang="sh"><span><span><span># Query the UMC at address 0x50df4, representing channel 0</span>
</span></span><span><span>$ pfexec /usr/lib/usmn -d /devices/pseudo/amdzen@0/usmn@2:usmn.0 0x50df4
</span></span><span><span>0x50df4: 0x40000030
</span></span><span><span>
</span></span><span><span><span># Query the UMC at address 0x150df4, representing channel 1</span>
</span></span><span><span>$ pfexec /usr/lib/usmn -d /devices/pseudo/amdzen@0/usmn@2:usmn.0 0x150df4
</span></span><span><span>0x150df4: 0x40000030
</span></span></code></pre></div><p>(<code>pfexec</code> is the illumos equivalent to <code>sudo</code>.)</p><p>Also, illumos comes with a really nice way to break up a hex value into bits:</p><pre tabindex="0"><code>$ mdb -e &#39;0x40000030=j&#39;
                1000000000000000000000000110000
                |                        ||
                |                        |+------ bit 4  mask 0x00000010
                |                        +------- bit 5  mask 0x00000020
                +-------------------------------- bit 30 mask 0x40000000
</code></pre><p>The bit we’re interested in here is bit 30. If it’s set, then ECC is enabled in the memory controller.</p><h2 id="accessing-the-smn-on-linux-with-the-ryzen_smu-driver">Accessing the SMN on Linux with the <code>ryzen_smu</code> driver<a href="#accessing-the-smn-on-linux-with-the-ryzen_smu-driver" arialabel="Anchor">⌗</a></h2><p>Can we replicate this query on Linux? Turns out we can! There’s a neat little driver called
<a href="https://gitlab.com/leogx9r/ryzen_smu"><code>ryzen_smu</code></a> which provides access to the SMN bus. It’s easy
to download and install (though on my system I needed to <a href="https://gitlab.com/leogx9r/ryzen_smu/-/merge_requests/10">apply a
patch</a>).</p><p>The driver exposes a <a href="https://gitlab.com/leogx9r/ryzen_smu#syskernelryzen_smu_drvsmn">file called
<code>/sys/kernel/ryzen_smu_drv/smn</code></a>
which can be used to perform a query over the SMN bus. The documentation says that to perform a
query, we must write 4 bytes to the file in <a href="https://www.section.io/engineering-education/what-is-little-endian-and-big-endian/">little-endian
format</a>, and
then read 4 bytes from the output in little-endian format. This isn’t convenient to do via the
command line, so let’s write a small Python script:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span># smn-query-ecc.py</span>
</span></span><span><span><span># Licensed under CC0-1.0</span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>query</span>(hex_str):
</span></span><span><span>    <span># Convert hex string to bytes in little-endian</span>
</span></span><span><span>    decoded <span>=</span> int(hex_str, <span>16</span>)<span>.</span>to_bytes(<span>4</span>, byteorder<span>=</span><span>&#39;little&#39;</span>)
</span></span><span><span>    <span>assert</span> len(decoded) <span>==</span> <span>4</span>
</span></span><span><span>
</span></span><span><span>    <span># Write 4 bytes to the SMN file</span>
</span></span><span><span>    open(<span>&#34;/sys/kernel/ryzen_smu_drv/smn&#34;</span>, <span>&#34;wb&#34;</span>)<span>.</span>write(decoded)
</span></span><span><span>
</span></span><span><span>    <span># Read 4 bytes from the SMN file, representing the return value</span>
</span></span><span><span>    ret <span>=</span> open(<span>&#34;/sys/kernel/ryzen_smu_drv/smn&#34;</span>, <span>&#34;rb&#34;</span>)<span>.</span>read(<span>4</span>)
</span></span><span><span>
</span></span><span><span>    <span># Print ret as a hex string in little-endian order</span>
</span></span><span><span>    ret_hex_str <span>=</span> hex(int<span>.</span>from_bytes(ret, byteorder<span>=</span><span>&#39;little&#39;</span>))
</span></span><span><span>    print(<span>f</span><span>&#34;returned value for </span><span>{</span>hex_str<span>}</span><span> is </span><span>{</span>ret_hex_str<span>}</span><span>&#34;</span>)
</span></span><span><span>
</span></span><span><span><span>def</span> <span>main</span>():
</span></span><span><span>    hex_str <span>=</span> <span>&#34;0x00050df4&#34;</span>
</span></span><span><span>    query(<span>&#34;0x00050df4&#34;</span>)  <span># channel 0</span>
</span></span><span><span>    query(<span>&#34;0x00150df4&#34;</span>)  <span># channel 1</span>
</span></span><span><span>
</span></span><span><span><span>if</span> __name__ <span>==</span> <span>&#39;__main__&#39;</span>:
</span></span><span><span>    main()
</span></span></code></pre></div><p>Running this script, I got:</p><pre tabindex="0"><code>$ sudo python3 smn-query-ecc.py
return value for 0x00050df4 is 0x40000000
return value for 0x00150df4 is 0x40000000
</code></pre><p>Bit 30 (the first nibble’s <code>4</code>) is set, which means the memory controller is reporting that ECC is
enabled.</p><p>This query should also be possible on Windows, perhaps using <a href="https://github.com/irusanov/SMUDebugTool">this
tool</a>, though I can’t vouch for it.</p><div><p>The most foolproof way to test whether ECC is working is to introduce an error somehow.</p><ul><li>ApplesOfEpicness did so by shorting a data and ground pin on their motherboard.</li><li>Another way would be to try and overclock the RAM until it gets to an unstable point.</li></ul><p>I don’t quite have the courage to physically short pins, nor the patience to slowly overclock my
RAM, waiting multiple minutes for DDR5 link training each time. So instead, I’m content with knowing that the memory controller is reporting that ECC is enabled.</p><p>Organically, I haven’t seen any errors so far. If a correctable or uncorrectable error does occur at
some point, I’ll update this post with that information.</p></div><p>Earlier in this post I’d mentioned that the Linux kernel reported that EDAC was enabled. I was
curious what the data source for <em>that</em> was, so I dug into the Linux kernel source code.</p><p>Being generally unfamiliar with the Linux codebase, I used the tried and tested strategy of
searching for strings that get logged. In this case:</p><ul><li>Searching for <code>Giving out device to module</code> led me to find <a href="https://github.com/torvalds/linux/blob/82714078aee4ccbd6ee7579d5a21f8a72155d0fb/drivers/edac/edac_mc.c#L665-L668">this line</a> inside <code>edac_mc_add_mc_with_groups</code>.</li><li>This function is called <a href="https://github.com/torvalds/linux/blob/82714078aee4ccbd6ee7579d5a21f8a72155d0fb/drivers/edac/amd64_edac.c#L4212">here</a> inside <code>init_one_instance</code>.</li><li><code>init_one_instance</code> <a href="https://github.com/torvalds/linux/blob/82714078aee4ccbd6ee7579d5a21f8a72155d0fb/drivers/edac/amd64_edac.c#L4285">is only called</a> if <code>pvt-&gt;ops-&gt;ecc_enabled</code> returns true.</li><li>What is <code>ecc_enabled</code>? It is set to a function called <code>umc_ecc_enabled</code> in <a href="https://github.com/torvalds/linux/blob/82714078aee4ccbd6ee7579d5a21f8a72155d0fb/drivers/edac/amd64_edac.c#L3985-L3991">this code</a>. And <code>pvt-&gt;ops</code> is set to <code>umc_ops</code> <a href="https://github.com/torvalds/linux/blob/82714078aee4ccbd6ee7579d5a21f8a72155d0fb/drivers/edac/amd64_edac.c#L4023-L4024">when the processor family is &gt;= 0x17</a>. Ryzen 7000 (Zen 4) is <a href="https://en.wikipedia.org/wiki/List_of_AMD_CPU_microarchitectures#Nomenclature">family 0x19</a>.</li></ul><p>Going by just the name, <code>umc_ecc_enabled</code> sounds like it would be querying the UMC. So let’s look at <a href="https://github.com/torvalds/linux/blob/94f6f0550c625fab1f373bb86a6669b45e9748b3/drivers/edac/amd64_edac.c#L3619C51-L3619C51">what it does</a>. It looks like it’s checking that <code>umc_cap_hi</code>’s <code>UMC_ECC_ENABLED</code> bit is set.</p><p>And what is <code>UMC_ECC_ENABLED</code>? It’s <a href="https://github.com/torvalds/linux/blob/94f6f0550c625fab1f373bb86a6669b45e9748b3/drivers/edac/amd64_edac.h#L272">bit 30</a>!</p><p>So it looks like the <code>EDAC</code> messages are only shown if the UMC reports that ECC is enabled. This
means that, at least on AMD processors, the Linux kernel message <code>EDAC MC0: Giving out device to module amd64_edac</code> is a reliable indicator that ECC is enabled.</p><p>ECC RAM is great, and you can easily get it working on Ryzen 7000 desktop CPUs, at least with ASRock
motherboards. I learned a ton of low-level processor interface details along the way.</p><p>Thanks again to <a href="https://fingolfin.org/blog/">Robert</a> for teaching me about a lot of the details here!</p></div></div></div>
  </body>
</html>
