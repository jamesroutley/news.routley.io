<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bakpakin.com/writing/how-janets-peg-works.html">Original</a>
    <h1>How Janet&#39;s PEG module works</h1>
    
    <div id="readability-page-1" class="page"><div>
        

<p>In making Janet, I was inspired by the
<a href="http://www.rebol.com/docs/core23/rebolcore-15.html">REBOL</a> Parse module
and <a href="http://www.inf.puc-rio.br/~roberto/lpeg/">LPeg</a> to include a
versatile library for parsing text and any sequence of bytes based on Parsing
Expression Grammars, or PEGs. I was also willing to exclude other forms of
parsing tools such as regular expressions from the core library, as PEGs are
more general than regular expression, or easier to read, and can capture error
locations when matching text. The development of PEGs in Janet went
particularly smoothly, made possible by the simple PEG formalism, Janet&#39;s basic
data structures, and a very straight-forward subroutine threaded interpreter.
While much of Janet&#39;s PEG module could be implemented in any language, Janet&#39;s
C API and rich set of core data structures made it easy to implement PEGs in
Janet.
</p>
<p>This post is about how the Janet PEG engine is implemented; it is not a guide on using pegs.
Although the code is written in <a href="https://janet-lang.org">Janet</a>, It can
be translated directly to most programming languages as we make no special use of any
data structures besides arrays and hashtables. For information about using Janet&#39;s PEG module, see <a href="https://janet-lang.org/docs/peg.html">the Janet PEG documentation</a>.
</p>
<h2>A Quick PEG Overview
</h2>
<p>The Parsing Expression Grammar formalism has it&#39;s roots in a
<a href="http://bford.info/pub/lang/peg.pdf">2004 Paper by Bryan Ford</a>, who
presents both the model and an algorithm for recognizing any PEG grammar in
linear time. Our PEG engine will not parser all patterns in linear time, but
will use similar semantics for defining our grammar. One difference between
PEGs and more traditional parser generators, such as those used by YACC and
Bison, is the ordered choice operator. For the purposes of this post, <code>+</code>
is the ordered choice operator. For example, using a pseudo-syntax for PEG
grammars where the <code>MAIN</code> rule is the entry point of the grammar, we can
write a grammar that matches any text that starts with a, b, or c.
</p>
<pre><code>MAIN: &#34;a&#34; + &#34;b&#34; + &#34;c&#34;</code></pre><p>This grammar will match &#34;apple pie&#34;, &#34;banana split&#34;, and &#34;coconut cluster&#34;, but
not &#34;orange soda&#34;, &#34;watermelon taffy&#34;, or &#34;lemon snap&#34;.
</p>
<p>It&#39;s also easy to write redundant grammars with the ordered choice operator.
The following grammar will match on the first &#34;a&#34; only, and never &#34;ab&#34; or &#34;abc&#34;.
Anything that starts with &#34;ab&#34; or &#34;abc&#34; also starts with &#34;a&#34;, so they could be removed
from the grammar without changing its behavior.
</p>
<pre><code>MAIN: &#34;a&#34; + &#34;ab&#34; + &#34;abc&#34;</code></pre><p>The ordered property of the <code>+</code> operator means that all PEG grammars are
deterministic - if they match a string, they will only match it one way. This
also means there is a direct correspondence between a PEG and a 
parser. This is very convenient when writing PEGs, as your specification
and parser can often be one and the same.
Traditional parser generators are non-deterministic, and additional
rules are needed to resolve ambiguity.
</p>
<p>To complete our PEG model, we only need a few more operators. Below are all operators and
features needed for the PEG formalism to be as general as possible.
</p>
<pre><code>&#34;...&#34; - string literal
+ - choice operator
* - sequence operator (implicit in our pseudo-syntax)
! - Boolean inversion</code></pre><p>The above features, along with recursion introduced by a top level grammar, can express all PEGs. This
is a trimmed down version of the what&#39;s presented in the original paper, but other operators can be substituted
for combinations of the above operators. The other very important feature needed for matching context free grammars is
recursion, or otherwise our model would be limited to matching regular expressions.
</p>
<p>Using this formalism, we can write a simple grammar that matches dates in ISO 8601 format. Such a date looks like
</p>
<pre><code>2019-06-10</code></pre><p>A naive grammar that matches dates (but does not validate dates - 9999-99-99 would match) is presented below. This also requires years to be specified with 4 digits.
</p>
<pre><code>DIGIT: &#34;0&#34; + &#34;1&#34; + &#34;2&#34; + &#34;3&#34; + &#34;4&#34; + &#34;5&#34; + &#34;6&#34; + &#34;7&#34; + &#34;8&#34; + &#34;9&#34;
YEAR: DIGIT DIGIT DIGIT DIGIT
MONTH: DIGIT DIGIT
DAY: DIGIT DIGIT
MAIN: YEAR &#34;-&#34; MONTH &#34;-&#34; DAY</code></pre><p>This looks very similar to a context free grammar, and in simple cases, the grammar is identical.
</p>
<h2>A simple PEG engine in code
</h2>
<p>Using our PEG definition above, we can write a simple
<code>match-peg</code> function that takes a rule and a string to match against
and tests if string matches the rule. If there is a match, the number of bytes matched will
be returned to help us find where to begin the next match. Otherwise, we will
return nil, or some token to indicate that there is no match. This code will be
written in Janet, but could be very easily written in any language. We are using
Janet&#39;s match macro here, which does pattern matching on arguments.
</p>
<pre><code data-language="janet">(<span>defn</span> <span>match-peg</span>
 [<span>peg</span> <span>text</span>]
 (<span>match</span> <span>peg</span>
   @[<span>:!</span> <span>x</span>] (<span>unless</span> (<span>match-peg</span> <span>x</span> <span>text</span>) <span>0</span>)
   @[<span>:+</span> <span>x</span> <span>y</span>] (<span>or</span> (<span>match-peg</span> <span>x</span> <span>text</span>) (<span>match-peg</span> <span>y</span> <span>text</span>))
   @[<span>:*</span> <span>x</span> <span>y</span>] (<span>if-let</span> [<span>lenx</span> (<span>match-peg</span> <span>x</span> <span>text</span>)]
                (<span>if-let</span> [<span>leny</span> (<span>match-peg</span> <span>y</span> (<span>string/slice</span> <span>text</span> <span>lenx</span>))]
                 (<span>+</span> <span>lenx</span> <span>leny</span>)))
    
   (<span>and</span> (<span>string/has-prefix?</span> <span>peg</span> <span>text</span>) (<span>length</span> <span>peg</span>))))</code></pre><p>This is a very simple but effective peg implementation. It does not support
captures, various other operators, but captures the basics of
PEGs in about 10 lines of code, and can even be used for recursive grammars.
</p>
<pre><code data-language="janet">(<span>def</span> <span>digits</span> [<span>:+</span> <span>&#34;0&#34;</span> [<span>:+</span> <span>&#34;1&#34;</span> [<span>:+</span> <span>&#34;2&#34;</span> [<span>:+</span> <span>&#34;3&#34;</span>
   [<span>:+</span> <span>&#34;4&#34;</span> [<span>:+</span> <span>&#34;5&#34;</span> [<span>:+</span> <span>&#34;6&#34;</span> [<span>:+</span> <span>&#34;7&#34;</span> [<span>:+</span> <span>&#34;8&#34;</span> <span>&#34;9&#34;</span>]]]]]]]]])
(<span>def</span> <span>year</span> [<span>:*</span> <span>digits</span> [<span>:*</span> <span>digits</span> [<span>:*</span> <span>digits</span> <span>digits</span>]]])
(<span>def</span> <span>month</span> [<span>:*</span> <span>digits</span> <span>digits</span>])
(<span>def</span> <span>day</span> <span>month</span>)
(<span>def</span> <span>iso-date</span> [<span>:*</span> <span>year</span> [<span>:*</span> <span>&#34;-&#34;</span> <span>:*</span> <span>month</span> [<span>:*</span> <span>&#34;-&#34;</span> <span>day</span>]]])

(<span>match-peg</span> <span>iso-date</span> <span>&#34;2019-06-10&#34;</span>) 
(<span>match-peg</span> <span>iso-date</span> <span>&#34;201-06-10&#34;</span>) </code></pre><p>This implementation is very similar to a
<a href="https://www.craftinginterpreters.com/a-tree-walk-interpreter.html">tree
walk interpreter</a>, and is the simplest way to implement a PEG. Janet&#39;s peg
implementation does something very similar to this, although the syntax tree is
first compiled to a bytecode form and validate for better speed.
</p>
<h3>Making Operators Variadic
</h3>
<p>Although not strictly necessary, we would like operators to look and behave more
like lisp operators that are variadic. This will make long sequences or chains
of choices easier to write.
</p>
<pre><code data-language="janet">(<span>defn</span> <span>match-peg</span>
 [<span>peg</span> <span>text</span>]
 (<span>match</span> <span>peg</span>
   @[<span>:!</span> <span>x</span>] (<span>unless</span> (<span>match-peg</span> <span>x</span> <span>text</span>) <span>0</span>)
   @[<span>:+</span>] (<span>some</span> (<span>fn</span> [<span>x</span>] (<span>match-peg</span> <span>x</span> <span>text</span>)) (<span>tuple/slice</span> <span>peg</span> <span>1</span>))
   @[<span>:*</span>] (<span>do</span>
       (<span>var</span> <span>len</span> <span>0</span>)
       (<span>var</span> <span>subtext</span> <span>text</span>)
       (<span>var</span> <span>ok</span> <span>true</span>)
       (<span>loop</span> [<span>x</span> <span>:in</span> (<span>tuple/slice</span> <span>peg</span> <span>1</span>) 
              <span>:let</span> [<span>lenx</span> (<span>match-peg</span> <span>x</span> <span>subtext</span>)
                    <span>_</span> (<span>set</span> <span>ok</span> <span>lenx</span>)]
              <span>:while</span> <span>ok</span>]
          (<span>set</span> <span>subtext</span> (<span>string/slice</span> <span>subtext</span> <span>lenx</span>))
          (<span>+=</span> <span>len</span> <span>lenx</span>))
       (<span>if</span> <span>ok</span> <span>len</span>))
    
   (<span>and</span> (<span>string/has-prefix?</span> <span>peg</span> <span>text</span>) (<span>length</span> <span>peg</span>))))</code></pre><p>Our ISO-date grammar from can be modified to look a bit more natural.
</p>
<pre><code data-language="janet">(<span>def</span> <span>digits</span> [<span>:+</span> <span>&#34;0&#34;</span> <span>&#34;1&#34;</span> <span>&#34;2&#34;</span> <span>&#34;3&#34;</span> <span>&#34;4&#34;</span> <span>&#34;5&#34;</span> <span>&#34;6&#34;</span> <span>&#34;7&#34;</span> <span>&#34;8&#34;</span> <span>&#34;9&#34;</span>])
(<span>def</span> <span>year</span> [<span>:*</span> <span>digits</span> <span>digits</span> <span>digits</span> <span>digits</span>])
(<span>def</span> <span>month</span> [<span>:*</span> <span>digits</span> <span>digits</span>])
(<span>def</span> <span>day</span> <span>month</span>)
(<span>def</span> <span>iso-date</span> [<span>:*</span> <span>year</span> <span>&#34;-&#34;</span> <span>month</span> <span>&#34;-&#34;</span> <span>day</span>])

(<span>match-peg</span> <span>iso-date</span> <span>&#34;2019-06-10&#34;</span>) 
(<span>match-peg</span> <span>iso-date</span> <span>&#34;201-06-10&#34;</span>) </code></pre><h3>Adding Recursion
</h3>
<p>Earlier I stated that recursion is important to make PEGs useful, and although
we can do recursion in ad hoc manner, we can make our recursive grammars look
more like our original grammar using Janet tables. We can create a table
mapping keywords to PEG expressions, and if <code>peg</code> is a keyword, we lookup
its definition in the grammar table. We can add an extra argument to
<code>match-peg</code> that will be our grammar table.
</p>
<pre><code data-language="janet">(<span>defn</span> <span>match-peg</span>
 [<span>peg</span> <span>text</span> <span>grammar</span>]
 (<span>match</span> <span>peg</span>
   @[<span>:!</span> <span>x</span>] (<span>unless</span> (<span>match-peg</span> <span>x</span> <span>text</span> <span>grammar</span>) <span>0</span>)
   @[<span>:+</span>] (<span>some</span> (<span>fn</span> [<span>x</span>] (<span>match-peg</span> <span>x</span> <span>text</span> <span>grammar</span>)) (<span>tuple/slice</span> <span>peg</span> <span>1</span>))
   @[<span>:*</span>] (<span>do</span>
       (<span>var</span> <span>len</span> <span>0</span>)
       (<span>var</span> <span>subtext</span> <span>text</span>)
       (<span>var</span> <span>ok</span> <span>true</span>)
       (<span>loop</span> [<span>x</span> <span>:in</span> (<span>tuple/slice</span> <span>peg</span> <span>1</span>) 
              <span>:let</span> [<span>lenx</span> (<span>match-peg</span> <span>x</span> <span>subtext</span> <span>grammar</span>)
                    <span>_</span> (<span>set</span> <span>ok</span> <span>lenx</span>)]
              <span>:while</span> <span>ok</span>]
          (<span>set</span> <span>subtext</span> (<span>string/slice</span> <span>subtext</span> <span>lenx</span>))
          (<span>+=</span> <span>len</span> <span>lenx</span>))
       (<span>if</span> <span>ok</span> <span>len</span>))
   (<span>x</span> (<span>keyword?</span> <span>x</span>)) (<span>match-peg</span> (<span>grammar</span> <span>x</span>) <span>text</span> <span>grammar</span>)
    
   (<span>and</span> (<span>string/has-prefix?</span> <span>peg</span> <span>text</span>) (<span>length</span> <span>peg</span>))))</code></pre><p>With our grammar table, we can define our grammar in a single structure.
</p>
<pre><code data-language="janet">(<span>def</span> <span>grammar</span>
 {<span>:digit</span> [<span>:+</span> <span>&#34;0&#34;</span> <span>&#34;1&#34;</span> <span>&#34;2&#34;</span> <span>&#34;3&#34;</span> <span>&#34;4&#34;</span> <span>&#34;5&#34;</span> <span>&#34;6&#34;</span> <span>&#34;7&#34;</span> <span>&#34;8&#34;</span> <span>&#34;9&#34;</span>]
  <span>:year</span> [<span>:*</span> <span>:digit</span> <span>:digit</span> <span>:digit</span> <span>:digit</span>]
  <span>:month</span> [<span>:*</span> <span>:digit</span> <span>:digit</span>]
  <span>:day</span> [<span>:*</span> <span>:digit</span> <span>:digit</span>]
  <span>:main</span> [<span>:*</span> <span>:year</span> <span>&#34;-&#34;</span> <span>:month</span> <span>&#34;-&#34;</span> <span>:day</span>]})

(<span>match-peg</span> (<span>grammar</span> <span>:main</span>) <span>&#34;2019-06-10&#34;</span> <span>grammar</span>) </code></pre><h3>Adding Rules
</h3>
<p>So far, our <code>match-peg</code> function has not been very expressive. Where
are our character classes, optional matches, and other fancy features from regular
expressions?
While we could simply add terms to our grammar for each character class
(:d for digits, :w for alphanumerics), there are other features we would like as
as well, such as the Kleene star, character sets, etc.
Fortunately, it is very easy to add functionality to tree-walk interpreters.
We can add as many operators as we like. For example, we can add the <code>:set</code> operator
that will match 1 character if it occurs in a set.
</p>
<pre><code data-language="janet">(<span>defn</span> <span>match-peg</span>
 [<span>peg</span> <span>text</span> <span>grammar</span>]
 (<span>match</span> <span>peg</span>
   @[<span>:set</span> <span>chars</span>] (<span>if</span> (<span>string/check-set</span> <span>chars</span> <span>text</span>) <span>1</span>)
   @[<span>:!</span> <span>x</span>] (<span>unless</span> (<span>match-peg</span> <span>x</span> <span>text</span> <span>grammar</span>) <span>0</span>)
   @[<span>:+</span>] (<span>some</span> (<span>fn</span> [<span>x</span>] (<span>match-peg</span> <span>x</span> <span>text</span> <span>grammar</span>)) (<span>tuple/slice</span> <span>peg</span> <span>1</span>))
   @[<span>:*</span>] (<span>do</span>
       (<span>var</span> <span>len</span> <span>0</span>)
       (<span>var</span> <span>subtext</span> <span>text</span>)
       (<span>var</span> <span>ok</span> <span>true</span>)
       (<span>loop</span> [<span>x</span> <span>:in</span> (<span>tuple/slice</span> <span>peg</span> <span>1</span>) 
              <span>:let</span> [<span>lenx</span> (<span>match-peg</span> <span>x</span> <span>subtext</span> <span>grammar</span>)
                    <span>_</span> (<span>set</span> <span>ok</span> <span>lenx</span>)]
              <span>:while</span> <span>ok</span>]
          (<span>set</span> <span>subtext</span> (<span>string/slice</span> <span>subtext</span> <span>lenx</span>))
          (<span>+=</span> <span>len</span> <span>lenx</span>))
       (<span>if</span> <span>ok</span> <span>len</span>))
   (<span>x</span> (<span>keyword?</span> <span>x</span>)) (<span>match-peg</span> (<span>grammar</span> <span>x</span>) <span>text</span> <span>grammar</span>)
    
   (<span>and</span> (<span>string/has-prefix?</span> <span>peg</span> <span>text</span>) (<span>length</span> <span>peg</span>))))</code></pre><p>Our date grammar will then become clearer as well.
</p>
<pre><code data-language="janet">(<span>def</span> <span>grammar</span>
 {<span>:digit</span> [<span>:set</span> <span>&#34;0123456789&#34;</span>]
  <span>:year</span> [<span>:*</span> <span>:digit</span> <span>:digit</span> <span>:digit</span> <span>:digit</span>]
  <span>:month</span> [<span>:*</span> <span>:digit</span> <span>:digit</span>]
  <span>:day</span> [<span>:*</span> <span>:digit</span> <span>:digit</span>]
  <span>:main</span> [<span>:*</span> <span>:year</span> <span>&#34;-&#34;</span> <span>:month</span> <span>&#34;-&#34;</span> <span>:day</span>]})

(<span>match-peg</span> (<span>grammar</span> <span>:main</span>) <span>&#34;2019-06-10&#34;</span> <span>grammar</span>) </code></pre><p>Most PEG libraries have several more rules to make it easier to write useful
grammars, but all rules can be written pretty much the same way, as cases in
our top level match expression. Our PEG engine is also missing captures, is
rather slow, does not do tail-call optimization, and lacks many features that
are present in other PEG engines such as those in Janet or REBOL. But for all
its issues, <code>match-peg</code> is a good start to a general purpose pattern
matching function.
</p>
      </div></div>
  </body>
</html>
