<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://webup.org/blog/the-high-risk-refactoring/">Original</a>
    <h1>The High-Risk Refactoring</h1>
    
    <div id="readability-page-1" class="page"><article>
                    <hgroup>
                        
                        <p>
                        
                        <small>February 13, 2024</small>
                        
                        </p>
                    </hgroup>
                    <p>
    <span>
        <img src="https://webup.org/blog/the-high-risk-refactoring/risky-refactoring.jpg" alt="The challenging code refactoring by AI"/>
    </span>
</p>

<p>Code refactoring may cost a fortune if not done right. A dysfunctional revamped system or new features coupled with incorrect rewrite is, with no doubt, damaging. One can argue to what extent.</p>
<hr/>

            <h2 id="every-refactoring-hides-risks">
              Every Refactoring Hides Risks
              <a href="#every-refactoring-hides-risks">#</a>
            </h2><p>Code improvements are risky as they aim to change a working system. That&#39;s true. However, in many situations, developers can mitigate the risk via different activities and make it bearable.</p>
<p>Some refactoring tasks are larger and affect many subsystems. Others, in contrast, are constrained within a single component but may unforeseeably affect other parts of the whole system and cause breakdown in vital business operations. E.g. an existing purchasing flow of a core product. A third category is for improvements, &#34;making room&#34; for new features‚Äîe.g., changing a single product purchase flow to support more items and adding a new one after.</p>
<p>The commonality between all three cases is that they imply <strong>high risk</strong>. (1) If done wrong, such an improvement will hurt the business (revenue loss, customer attrition), the team (trust, motivation), or any related features (development blocked). (2) On the other hand, executing it is costly as it requires extra care, effort, and time. Experienced developers with domain knowledge are also preferable for that kind of tasks.</p>

            <h2 id="addressing-risk-checklist-">
              Addressing Risk (Checklist):
              <a href="#addressing-risk-checklist-">#</a>
            </h2><p>‚úÖ Define constraints. <em>How far should I go</em>. </p>
<p>‚ùå Do not skip tests. <em>Don&#39;t be lazy</em>.</p>
<p>Sometimes is obvious, what improvements are required and where in the codebase. Moving some code out of a component or additional cleanup so new features are not walking on broken glass. For a developer, this may feel like something to address sooner than later. But the challenging refactoring (especially), hides pitfalls‚Äîverifying the change is not straightforward due to dev env impediments, dependencies, DB/APIs, flaky tests, or lack of time. Things will also break often throughout the improvement process. How does one catch the failures early?</p>
<p>It&#39;s tempting to simply start on the rewrite, but...</p>

            <h2 id="-hold-on">
              ‚úã Hold On
              <a href="#-hold-on">#</a>
            </h2><ol>
<li>Evaluate how risky (expensive) the change is upfront‚Äîfrom a dev and business perspective.</li>
</ol>
<p><strong>What will happen if buggy code gets shipped?</strong> Broken business goals, user churn, blaming, or loss of trust are serious issues to consider. Thinking about the possible negative outcome, is a good first stopper. Maybe don&#39;t refactor in the first place.</p>
<ol start="2">
<li>Consider if the improvement is a standalone task or part of another feature.</li>
</ol>
<p>Fx. a new feature implementation reveals an obvious candidate for system refactoring where the feature itself will benefit directly. In this case, it&#39;s practical to do-it-now while being in the context. Usually ‚ÄúLater‚Äù never comes.</p>
<p>But. Separating the cleanup from the main feature work‚Äîso they can be reviewed and QA-ed individually‚Äîis a good approach in general. Especially if the improvement is expected to cause side effects or is difficult to verify.</p>
<ol start="3">
<li>Prove the system is working beforehand.</li>
</ol>
<p>Before starting any work, it&#39;s crucial to validate that all related parts are functioning. Having all the app tests pass is not enough. These tests cover specific user flows, but may miss others, so the mission here is to fill the gaps with <a href="https://css-tricks.com/react-component-tests-for-humans/#aa-approaching-react-component-tests">appropriate tests</a>.</p>

            <h2 id="-this-refactoring-is-a-big-deal">
              üèãÔ∏è This Refactoring is a Big Deal
              <a href="#-this-refactoring-is-a-big-deal">#</a>
            </h2><p>As such it&#39;s highly important to ensure the <strong>system works the same way after the swap</strong> with the new code. In that regard, <strong>immediately spotting when something breaks</strong> throughout the whole refactoring process is very helpful. No one wants to find that out in production. Therefore. Write comprehensive tests. This should be a core activity from beginning to end.</p>
<p>Use breadcrumbs in the form of tests:</p>
<ul>
<li>unit and high-level integration.</li>
<li>no implementation details.</li>
<li>test as much as possible to build confidence (aka <a href="https://martinsson-johan.blogspot.com/2022/11/breaking-out-of-legacy-with-3p.html">test everything</a>).</li>
</ul>
<blockquote>
<p>Integration tests are very practical here and can catch leaking component side effects.</p>
</blockquote>

        <div>
          <pre><code>

<span>it</span>(<span>&#34;should show all addons&#34;</span>, <span>() =&gt;</span> {
  
  
  server.<span>get</span>(endpoints.<span>loadAddonsData</span>, { <span>addons</span>: [<span>&#34;addon1&#34;</span>, <span>&#34;addon2&#34;</span>] });
  
  props.<span>shouldShowMoreAddons</span> = <span>true</span>;

  
  <span>render</span>(<span><span>&lt;<span>Addons</span> {<span>...props</span>} /&gt;</span></span>);

  
  fireEvent.<span>click</span>(screen.<span>getByRole</span>(<span>&#34;button&#34;</span>));

  
  <span>await</span> <span>waitFor</span>(<span>() =&gt;</span> {
    <span>expect</span>(screen.<span>queryByRole</span>(<span>&#34;list&#34;</span>)).<span>toBeInTheDocument</span>();
  });
})
</code></pre>

        </div>
      <p>Once everything is green ‚úÖ, hand it over to QA for next-level verification. We are human.</p>

            <h2 id="-refactoring-coupled-with-a-feature">
              ü™° Refactoring Coupled with a Feature
              <a href="#-refactoring-coupled-with-a-feature">#</a>
            </h2><p>If time is pressing, <strong>release the feature separately and handle the refactoring later</strong>. It will require QA to retest parts of the feature, but this is better than releasing too many things, at once.</p>
<p>Evaluate and choose <strong>not to refactor alongside new code if that hides too many unknowns</strong>, costs, or increased risks that can&#39;t be afforded. Otherwise, <a href="http://pushtrain.club/#028">ensure the system is working on the I/O</a>. Little improvements are just fine.</p>

            <h2 id="-examples-code-">
              {} Examples (Code)
              <a href="#-examples-code-">#</a>
            </h2><p>The example below illustrates a Dashboard React component that renders some widgets and an upsell box (<code>&lt;UpsellBox1 /&gt;</code>) which data dependents on a backend call (<code>loadUpsell1Data()</code>).</p>

        <div>
          <pre><code>
<span>export</span> <span>function</span> <span>Dashboard</span>(<span>{ data }</span>) {
  
  <span>const</span> [shouldShowUpsell1, setShouldShowUpsell1] = <span>useState</span>(<span>false</span>);
  <span>const</span> [upsell1Data, setUpsell1Data] = <span>useState</span>(<span>null</span>);

  
  
  
  

  <span>useEffect</span>(<span>() =&gt;</span> {
    
    <span>if</span> (condition1 &amp;&amp; condition2 &amp;&amp; !condition3) {
      <span>setShouldShowUpsell1</span>(<span>true</span>);

      <span>loadUpsell1Data</span>().<span>then</span>(<span>(<span>bannerData</span>) =&gt;</span> {
        <span>setUpsell1Data</span>(bannerData);
      });
    }
  }, [...]);

  <span>return</span> (
    <span><span>&lt;<span>div</span>&gt;</span>
      <span>&lt;<span>Widget1</span> /&gt;</span>
      <span>&lt;<span>Widget2</span> /&gt;</span>
      ...
      {shouldShowUpsell1 &amp;&amp; <span>&lt;<span>UpsellBox1</span> <span>data</span>=<span>{upsell1Data}</span> /&gt;</span>}
    <span>&lt;/<span>div</span>&gt;</span></span>
  );
}
</code></pre>

        </div>
      <p>Imagine the new task is to render a second upsell (<code>&lt;UpsellBox2 /&gt;</code>), and if both are present, put them in a carousel.</p>

        <div>
          <pre><code><span>return</span> (
  <span><span>&lt;<span>div</span>&gt;</span>
    <span>&lt;<span>Widget1</span> /&gt;</span>
    <span>&lt;<span>Widget2</span> /&gt;</span>
    ...
    
    {shouldShowUpsell1 &amp;&amp; shouldShowUpsell2 &amp;&amp; (
      <span>&lt;<span>UpsellSlider</span>&gt;</span>
        <span>&lt;<span>UpsellBox1</span> <span>data</span>=<span>{upsell1Data}</span> /&gt;</span>
        <span>&lt;<span>UpsellBox2</span> <span>data</span>=<span>{upsell2Data}</span> /&gt;</span>
      <span>&lt;/<span>UpsellSlider</span>&gt;</span>
    )}
    
    {shouldShowUpsell1 &amp;&amp; <span>&lt;<span>UpsellBox1</span> <span>data</span>=<span>{upsell1Data}</span> /&gt;</span>}
    
    {shouldShowUpsell2 &amp;&amp; <span>&lt;<span>UpsellBox2</span> <span>data</span>=<span>{upsell2Data}</span> /&gt;</span>}
  <span>&lt;/<span>div</span>&gt;</span></span>
);
</code></pre>

        </div>
      <p>Since there are two upsells (probably more in future), the logic in <code>&lt;Dashboard /&gt;</code> is growing. It makes sense to move the upsell code out‚Äîin a custom hook <code>useUpsellData</code> (not in <code>&lt;UpsellSlider /&gt;</code>) as to not sacrifice explicitness‚Äîbut this is tricky as widgets and upsells data mix together.</p>
<p>Here is how the component may look like after the change:</p>

        <div>
          <pre><code>
<span>export</span> <span>function</span> <span>Dashboard</span>(<span>{ data }</span>) {
  
  
  

  
  
  
  
  
  
  <span>const</span> {
    <span>upsell1</span>: { shouldShowUpsell1, upsell1Data },
    <span>upsell2</span>: { shouldShowUpsell2, upsell2Data },
  } = <span>useUpsellData</span>(conditions);

  
  
  
  

  
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  

  <span>return</span> (
    <span><span>&lt;<span>div</span>&gt;</span>
      
      <span>&lt;<span>Widget1</span> /&gt;</span>
      <span>&lt;<span>Widget2</span> /&gt;</span>
      ...
      
      {shouldShowUpsell1 &amp;&amp; shouldShowUpsell2 &amp;&amp; (
        <span>&lt;<span>UpsellSlider</span>&gt;</span>
          <span>&lt;<span>UpsellBox1</span> <span>data</span>=<span>{upsell1Data}</span> /&gt;</span>
          <span>&lt;<span>UpsellBox2</span> <span>data</span>=<span>{upsell2Data}</span> /&gt;</span>
        <span>&lt;/<span>UpsellSlider</span>&gt;</span>
      )}
      
      {shouldShowUpsell1 &amp;&amp; <span>&lt;<span>UpsellBox1</span> <span>data</span>=<span>{upsell1Data}</span> /&gt;</span>}
      
      {shouldShowUpsell2 &amp;&amp; <span>&lt;<span>UpsellBox2</span> <span>data</span>=<span>{upsell2Data}</span> /&gt;</span>}
    <span>&lt;/<span>div</span>&gt;</span></span>
  );
}
</code></pre>

        </div>
      <p>The purpose with these examples is to illustrate how shaky refactoring can be if combined with new features within a busy component. The challenges mainly arise from the tightly coupled nature of <code>&lt;Dashboard /&gt;</code>&#39;s business logic that handles many widgets and sections as its direct children.</p>

            <h2 id="-should-i-refactor">
              üëç Should I Refactor
              <a href="#-should-i-refactor">#</a>
            </h2><p>üëç Refactor if things are getting too complicated, but üëé stop if can&#39;t prove it works.</p>
<p>üëç Accompany new features with refactoring for areas you foresee to be subject to a change, but üëé copy-pasting is ok until patterns arise.</p>
<p>üëç Be proactive in finding new ways to ensure refactoring predictability, but üëé be conservative about the assumption QA will find all the bugs.</p>
<p>üëç Move business logic out of busy components, but üëé be brave enough to keep the legacy code intact if the only argument is <em>&#34;this code looks wrong&#34;</em>.</p>

                </article></div>
  </body>
</html>
