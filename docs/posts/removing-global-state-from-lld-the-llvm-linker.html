<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://maskray.me/blog/2024-11-17-removing-global-state-from-lld">Original</a>
    <h1>Removing global state from LLD, the LLVM linker</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://lld.llvm.org/">LLD, the LLVM linker</a>, is a mature
and fast linker supporting multiple binary formats (ELF, Mach-O,
PE/COFF, WebAssembly). Designed as a standalone program, the code base
relies heavily on global state, making it less than ideal for library
integration. As outlined in <a target="_blank" rel="noopener" href="https://discourse.llvm.org/t/rfc-revisiting-lld-as-a-library-design/58445">RFC:
Revisiting LLD-as-a-library design</a>, two main hurdles exist:</p>
<ul>
<li>Fatal errors: they exit the process without returning control to the
caller. This was actually addressed for most scenarios in 2020 by
utilizing <code>llvm::sys::Process::Exit(val, /*NoCleanup=*/true)</code>
and <code>CrashRecoveryContext</code> (<code>longjmp</code> under the
hood).</li>
<li>Global variable conflicts: shared global variables do not allow two
concurrent invocation.</li>
</ul>
<p>I understand that calling a linker API could be convenient,
especially when you want to avoid shipping another executable (which can
be large when you link against LLVM statically). However, I believe that
invoking LLD as a separate process remains the recommended approach.
There are several advantages:</p>
<ul>
<li>Build system control: Build systems gain greater control over
scheduling and resource allocation for LLD. In an edit-compile-link
cycle, the link could need more resources and threading is more
useful.</li>
<li>Better parallelism management</li>
<li>Global state isolation: LLVM&#39;s global state (primarily
<code>cl::opt</code> and <code>ManagedStatic</code>) is isolated.</li>
</ul>
<p>While spawning a new process offers build system benefits, the issue
of global state usage within LLD remains a concern. This is a factor to
consider, especially for advanced use cases. Here are global variables
in the LLD 15 code base.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>% rg &#39;^extern [^(]* \w+;&#39; lld/ELF</span></pre></td></tr></tbody></table></figure>
<p>Some global states exist as static member variables.</p>
<h2 id="cleaning-up-global-variables">Cleaning up global variables</h2>
<p>LLD has been undergoing a transformation to reduce its reliance on
global variables. This improves its suitability for library
integration.</p>
<ul>
<li>In 2020, <a target="_blank" rel="noopener" href="https://reviews.llvm.org/D70378">[LLD][COFF] Cover
usage of LLD as a library</a> enabled running the LLD driver multiple
times even if there is a fatal error.</li>
<li>In 2021, global variables were <a target="_blank" rel="noopener" href="https://reviews.llvm.org/D108850">removed from
<code>lld/Common</code></a>.</li>
<li>The COFF port followed suite, <a target="_blank" rel="noopener" href="https://reviews.llvm.org/D109634">eliminating most of its global
variables</a>.</li>
</ul>
<p>Inspired by theseadvancements, I conceived a plan to eliminate global
variables from the ELF port. In 2022, as part of the work to enable
parallel section initialization, I <a target="_blank" rel="noopener" href="https://reviews.llvm.org/D120626">introduced a class
<code>struct Ctx</code></a> to <code>lld/ELF/Config.h</code>. Here is my
plan:</p>
<ul>
<li>Global variables will be migrated into <code>Ctx</code>.</li>
<li>Functions will be modified to accept a new <code>Ctx &amp;ctx</code>
parameter.</li>
<li>The previously global variable lld::elf::ctx will be transformed
into a local variable within <code>lld::elf::link</code>.</li>
</ul>
<h2 id="encapsulating-global-variables-into-ctx">Encapsulating global
variables into <code>Ctx</code></h2>
<p>Over the past two years and a half, I have migrated global variables
into the <code>Ctx</code> class, <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/commit/e980f16d52196fb2bc672ecb87e0f622253addec">e.g.</a>.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>diff --git a/lld/ELF/Config.h b/lld/ELF/Config.h</span></pre></td></tr></tbody></table></figure>
<p>I did not do anything thing with the global variables in 2024. The
work was resumed in July 2024. I moved <code>TarWriter</code>,
<code>SymbolAux</code>, <code>Out</code>, <code>ElfSym</code>,
<code>outputSections</code>, etc into <code>Ctx</code>.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>struct</span> <span>Ctx</span> {</span></pre></td></tr></tbody></table></figure>
<p>The <code>config</code> variable, used to store command-line options,
was pervasive throughout lld/ELF. To enhance code clarity and
maintainability, I renamed it to <code>ctx.arg</code> (mold naming).</p>
<p>I&#39;ve removed other instances of static storage variables throught
lld/ELF, e.g.</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/commit/f2b01338584c90f48dba1a937bf5b1da8dcedbd5">static
member <code>LinkerDriver::nextGroupId</code></a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/commit/33ff9e43b4c5bdc3da31c6b11ad51d35a69bec5f">static
member <code>SharedFile::vernauxNum</code></a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/commit/4092c0deef466e5b96a221e4066a78ae72efa7af"><code>sectionMap</code>
in <code>lld/ELF/Arch/ARM.cpp</code></a></li>
</ul>
<h2 id="passing-ctx-ctx-as-parameters">Passing <code>Ctx &amp;ctx</code>
as parameters</h2>
<p>The subsequent phase involved adding <code>Ctx &amp;ctx</code> as a
parameter to numerous functions and classes, gradually eliminating
references to the global <code>ctx</code>.</p>
<p>I incorporated <code>Ctx &amp;ctx</code> as a member variable to a
few classes (e.g. <code>SyntheticSection</code>,
<code>OutputSection</code>) to minimize the modifications to member
functions. This approach was not suitable for <code>Symbol</code> and
<code>InputSection</code>, since even a single word could increase
memory consumption significantly.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span></span></pre></td></tr></tbody></table></figure>
<h2 id="eliminating-the-global-ctx-variable">Eliminating the global
<code>ctx</code> variable</h2>
<p>Once the global <code>ctx</code> variable&#39;s reference count reached
zero, it was time to remove it entirely. I implemented the change on
November 16, 2024.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span></span></pre></td></tr></tbody></table></figure>
<p>Prior to this modification, the cleanupCallback function was
essential for resetting the global ctx when lld::elf::link was called
multiple times.</p>
<p>Previously, <code>cleanupCallback</code> was essential for resetting
the global <code>ctx</code> when <code>lld::elf::link</code> was invoked
multiple times. With the removal of the global variable, this callback
is no longer necessary. We can now rely on the constructor to initialize
<code>Ctx</code> and avoid the need for a <code>reset</code>
function.</p>
<h2 id="removing-global-state-from-lldcommon">Removing global state from
<code>lld/Common</code></h2>
<p>While significant progress has been made to <code>lld/ELF</code>,
<code>lld/Common</code> needs a lot of work as well. A lot of shared
utility code (diagnostics, bump allocator) utilizes the global
<code>lld::context()</code>.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span></span></pre></td></tr></tbody></table></figure>
<p>Although thread-local variables are an option, worker threads spawned
by <code>llvm/lib/Support/Parallel.cpp</code> don&#39;t inherit their values
from the main thread. Given our direct access to
<code>Ctx &amp;ctx</code>, we can leverage context-aware APIs as
replacements.</p>
<p><a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/pull/112319">https://github.com/llvm/llvm-project/pull/112319</a>
introduced context-aware diagnostic utilities:</p>
<ul>
<li><code>log(&#34;xxx&#34;)</code> =&gt;
<code>Log(ctx) &lt;&lt; &#34;xxx&#34;</code></li>
<li><code>message(&#34;xxx&#34;)</code> =&gt;
<code>Msg(ctx) &lt;&lt; &#34;xxx&#34;</code></li>
<li><code>warn(&#34;xxx&#34;)</code> =&gt;
<code>Warn(ctx) &lt;&lt; &#34;xxx&#34;</code></li>
<li><code>errorOrWarn(toString(f) + &#34;xxx&#34;)</code> =&gt;
<code>Err(ctx) &lt;&lt; f &lt;&lt; &#34;xxx&#34;</code></li>
<li><code>error(toString(f) + &#34;xxx&#34;)</code> =&gt;
<code>ErrAlways(ctx) &lt;&lt; f &lt;&lt; &#34;xxx&#34;</code></li>
<li><code>fatal(&#34;xxx&#34;)</code> =&gt;
<code>Fatal(ctx) &lt;&lt; &#34;xxx&#34;</code></li>
</ul>
<p>As of Nov 16, 2024, I have eliminated
<code>log/warn/error/fatal</code> from lld/ELF.</p>
<p>The underlying functions <code>lld::ErrorHandler::fatal</code>, and
<code>lld::ErrorHandler::error</code> when the error limit is hit and
<code>exitEarly</code> is true, call <code>exitLld(1)</code>.</p>
<p><code>lld::make</code> from <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/blob/main/lld/include/lld/Common/Memory.h"><code>lld/include/lld/Common/Memory.h</code></a>
is an allocation function that uses the global context. When the
ownership is clear, <code>std::make_unique</code> might be a better
choice.</p>
<p>Guideline:</p>
<ul>
<li>Avoid <code>lld::saver</code></li>
<li>Avoid
<code>void message(const Twine &amp;msg, llvm::raw_ostream &amp;s = outs());</code>,
which utilizes <code>lld::outs()</code></li>
<li>Avoid <code>lld::make</code> from <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/blob/main/lld/include/lld/Common/Memory.h"><code>lld/include/lld/Common/Memory.h</code></a></li>
<li>Avoid fatal error in a half-initialized object, e.g. fatal error in
a base class constructor (<code>ELFFileBase::init</code>) (<a target="_blank" rel="noopener" href="https://reviews.llvm.org/D88348">[LLD][COFF] When using
LLD-as-a-library, always prevent re-entrance on failures</a>)</li>
</ul>
<h2 id="global-state-in-llvm">Global state in LLVM</h2>
<p>LTO link jobs utilize LLVM. Understanding its global state is
crucial.</p>
<p>While LLVM allows for multiple <code>LLVMContext</code> instances to
be allocated and used concurrently, it&#39;s important to note that these
instances share certain global states, such as <code>cl::opt</code> and
<code>ManagedStatic</code>. Specifically, it&#39;s not possible to run two
concurrent LLVM compilations (including LTO link jobs) with distinct
sets of <code>cl::opt</code> option values. To link with distinct
<code>cl::opt</code> values, even after removing LLD&#39;s global state,
you&#39;ll need to spawn a new LLD process.</p>
<p>Any proposal that moves away from global state seems to complicate
<code>cl::opt</code> usage, making it impractical.</p>
<p>LLD also utilizes functions from <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/Support/Parallel.h"><code>llvm/Support/Parallel.h</code></a>
for parallelism. These functions rely on global state like
<code>getDefaultExecutor</code> and
<code>llvm::parallel::strategy</code>. Ongoing work by Alexandre Ganea
aims to make these functions context-aware. (It&#39;s nice to meet you in
person in LLVM Developers&#39; Meeting last month)</p>
<h2 id="supported-library-usage-scenarios">Supported library usage
scenarios</h2>
<p>You can repeatedly call <code>lld::lldMain</code> from <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/blob/main/lld/include/lld/Common/Driver.h"><code>lld/Common/Driver.h</code></a>.
If <code>fatal</code> has been invoked, it will not be safe to call
<code>lld::lldMain</code> again in certain rare scenarios. Running
<code>lld::lldMain</code> concurrently in two threads is not
supported.</p>
<p>The command <code>LLD_IN_TEST=3 lld-link ...</code> runs the link
process three times, but only the final invocation outputs diagnostics
to stdout/stderr. <code>lld/test/lit.cfg.py</code> has configured the
COFF port to run tests twice (<a target="_blank" rel="noopener" href="https://reviews.llvm.org/D112898">[lld] Add test suite mode for
running LLD main twice</a>). Other ports need work to make this mode
work.</p>

      
    </div></div>
  </body>
</html>
