<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.philipzucker.com/sql_graph_csp/">Original</a>
    <h1>SQL, Homomorphisms and Constraint Satisfaction Problems</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>Database queries are a pretty surprisingly powerful tool that can solve seemingly intractable problems.</p>

<p>It is a fun coding challenge to do things in SQL. I’ve seen people solve sudokus or do <a href="https://github.com/mitchellh/advent-2021-sql">advent of code</a>, or you can build a datalog on SQL with a little metaprogramming (maybe even fully internally). It is also possible to build a <a href="https://github.com/awto/chr2sql">CHR (constraint handling rules) system on SQL</a> or a graph rewriting system on SQL. Here I talk about how one can use SQL queries to do graph instruction matching <a href="https://www.philipzucker.com/imatch-datalog/">https://www.philipzucker.com/imatch-datalog/</a> .</p>

<p>SQL is a feature rich language, it is not surprising that you can do these things from that perspective, using this and that odd feature. But even the simple idealized “SELECT FROM WHERE” core of SQL has a lot of power.</p>

<p>From a logical perspective, this core is basically conjunctive queries <a href="https://en.wikipedia.org/wiki/Conjunctive_query#Relationship_to_other_query_languages">https://en.wikipedia.org/wiki/Conjunctive_query#Relationship_to_other_query_languages</a> . Each table is a logical predicate, each variable is bound to a row of a column. The SELECT fields are bits that aren’t being existentially bound and therefore hidden, aka free variables.</p>

<p>$\exists y. edge(x,y) \land path(y,z)$ is the predicate form of the query <code>SELECT edge.a, path.b from edge, path WHERE edge.b = path.a</code>. There is a little bit of rearrangement from the entry centric view of predicates to the row centric view of SQL. I am not aware of a way to easily give a name to a particular entry in sql. I used this correspondence to describe how to either build a datalog engine on sql, or hand compile your datalog rules to sql <a href="https://www.philipzucker.com/tiny-sqlite-datalog/">https://www.philipzucker.com/tiny-sqlite-datalog/</a> .</p>



<p>From a more imperative perspective, SELECT-FROM-WHERE statements are basically for loops. SQL is an odd language in that the FROM comes after the SELECT. This puts a row variables binding site after their usage points. Maybe this isn’t <em>that</em> crazy considering set comprehension <code>{x for x in A if x &gt; 0}</code> is quite similar.</p>

<table>
  <tbody>
    <tr>
      <td>SQL</td>
      <td>Python</td>
    </tr>
    <tr>
      <td><code>FROM mytable as row_a</code></td>
      <td><code>for row_a in mytable:</code></td>
    </tr>
    <tr>
      <td><code>WHERE row_a.col1 = rowa.col2</code></td>
      <td><code>if row_a.col1 == row_a.col2:</code></td>
    </tr>
    <tr>
      <td><code>SELECT row_a.col1, row_a.col2</code></td>
      <td><code>yield row_a.col1, row_a.col2</code></td>
    </tr>
  </tbody>
</table>

<p>A thing SQL engines do is that they rearrange and optimize these loops and refactor them into joins and other things. Python for loops however execute just like you say it (slowly).</p>

<p>Search problems over finite spaces can be solved by brute force loops. Enumerate all possibilities and take the ones that work.</p>

<p>So in this manner SQL is a constraint solver.</p>

<p>An example constraint satisfaction puzzle is the send more money puzzle <a href="https://en.wikipedia.org/wiki/Verbal_arithmetic">https://en.wikipedia.org/wiki/Verbal_arithmetic</a> in which we need to find digits <code>S,E,N,D,M,O,R,Y</code> such that <code>SEND + MORE = MONEY</code>.
A pure python version of the send more money puzzle with simplistic pruning is</p>

<div><div><pre><code><span>def</span> <span>solve_send_money</span><span>():</span>
    <span>for</span> <span>s</span> <span>in</span> <span>range</span><span>(</span><span>1</span><span>,</span> <span>10</span><span>):</span>  <span># S must be non-zero
</span>        <span>for</span> <span>e</span> <span>in</span> <span>range</span><span>(</span><span>10</span><span>):</span>
            <span>if</span> <span>e</span> <span>==</span> <span>s</span><span>:</span>
                <span>continue</span>
            <span>for</span> <span>n</span> <span>in</span> <span>range</span><span>(</span><span>10</span><span>):</span>
                <span>if</span> <span>n</span> <span>in</span> <span>(</span><span>s</span><span>,</span> <span>e</span><span>):</span>
                    <span>continue</span>
                <span>for</span> <span>d</span> <span>in</span> <span>range</span><span>(</span><span>10</span><span>):</span>
                    <span>if</span> <span>d</span> <span>in</span> <span>(</span><span>s</span><span>,</span> <span>e</span><span>,</span> <span>n</span><span>):</span>
                        <span>continue</span>
                    <span>for</span> <span>m</span> <span>in</span> <span>range</span><span>(</span><span>1</span><span>,</span> <span>10</span><span>):</span>  <span># M must be non-zero
</span>                        <span>if</span> <span>m</span> <span>in</span> <span>(</span><span>s</span><span>,</span> <span>e</span><span>,</span> <span>n</span><span>,</span> <span>d</span><span>):</span>
                            <span>continue</span>
                        <span>for</span> <span>o</span> <span>in</span> <span>range</span><span>(</span><span>10</span><span>):</span>
                            <span>if</span> <span>o</span> <span>in</span> <span>(</span><span>s</span><span>,</span> <span>e</span><span>,</span> <span>n</span><span>,</span> <span>d</span><span>,</span> <span>m</span><span>):</span>
                                <span>continue</span>
                            <span>for</span> <span>r</span> <span>in</span> <span>range</span><span>(</span><span>10</span><span>):</span>
                                <span>if</span> <span>r</span> <span>in</span> <span>(</span><span>s</span><span>,</span> <span>e</span><span>,</span> <span>n</span><span>,</span> <span>d</span><span>,</span> <span>m</span><span>,</span> <span>o</span><span>):</span>
                                    <span>continue</span>
                                <span>for</span> <span>y</span> <span>in</span> <span>range</span><span>(</span><span>10</span><span>):</span>
                                    <span>if</span> <span>y</span> <span>in</span> <span>(</span><span>s</span><span>,</span> <span>e</span><span>,</span> <span>n</span><span>,</span> <span>d</span><span>,</span> <span>m</span><span>,</span> <span>o</span><span>,</span> <span>r</span><span>):</span>
                                        <span>continue</span>
                                    <span># Convert SEND, MORE, and MONEY to integers
</span>                                    <span>send</span> <span>=</span> <span>1000</span> <span>*</span> <span>s</span> <span>+</span> <span>100</span> <span>*</span> <span>e</span> <span>+</span> <span>10</span> <span>*</span> <span>n</span> <span>+</span> <span>d</span>
                                    <span>more</span> <span>=</span> <span>1000</span> <span>*</span> <span>m</span> <span>+</span> <span>100</span> <span>*</span> <span>o</span> <span>+</span> <span>10</span> <span>*</span> <span>r</span> <span>+</span> <span>e</span>
                                    <span>money</span> <span>=</span> <span>10000</span> <span>*</span> <span>m</span> <span>+</span> <span>1000</span> <span>*</span> <span>o</span> <span>+</span> <span>100</span> <span>*</span> <span>n</span> <span>+</span> <span>10</span> <span>*</span> <span>e</span> <span>+</span> <span>y</span>
                                    
                                    <span>if</span> <span>send</span> <span>+</span> <span>more</span> <span>==</span> <span>money</span><span>:</span>
                                        <span>return</span> <span>(</span><span>s</span><span>,</span><span>e</span><span>,</span><span>n</span><span>,</span><span>d</span><span>,</span><span>m</span><span>,</span><span>o</span><span>,</span><span>r</span><span>,</span><span>e</span><span>,</span><span>m</span><span>,</span><span>o</span><span>,</span><span>n</span><span>,</span><span>e</span><span>,</span><span>y</span><span>),</span> <span>send</span><span>,</span> <span>more</span><span>,</span> <span>money</span>

</code></pre></div></div>

<div><div><pre><code><span>%%</span><span>timeit</span> 
<span>solve_send_money</span><span>()</span>
</code></pre></div></div>

<div><div><pre><code>762 ms ± 35 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
</code></pre></div></div>

<h4 id="sql-send-more-money">SQL Send More Money</h4>

<p>We can write the same thing in SQL and execute using duckdb or sqlite. Duckdb is a bit faster and is faster than the pure python version.</p>

<div><div><pre><code><span>import</span> <span>sqlite3</span>
<span>import</span> <span>duckdb</span>
<span>query</span> <span>=</span> <span>&#34;&#34;&#34;
WITH RECURSIVE digits(digit) AS (
    SELECT 0
    UNION ALL
    SELECT digit + 1
    FROM digits
    WHERE digit &lt; 9
)
SELECT s.digit AS S, e.digit AS E, n.digit AS N, d.digit AS D,
       m.digit AS M, o.digit AS O, r.digit AS R, y.digit AS Y
FROM digits s, digits e, digits n, digits d, digits m, digits o, digits r, digits y
WHERE s.digit &lt;&gt; e.digit AND s.digit &lt;&gt; n.digit AND s.digit &lt;&gt; d.digit AND s.digit &lt;&gt; m.digit AND
      s.digit &lt;&gt; o.digit AND s.digit &lt;&gt; r.digit AND s.digit &lt;&gt; y.digit AND
      e.digit &lt;&gt; n.digit AND e.digit &lt;&gt; d.digit AND e.digit &lt;&gt; m.digit AND
      e.digit &lt;&gt; o.digit AND e.digit &lt;&gt; r.digit AND e.digit &lt;&gt; y.digit AND
      n.digit &lt;&gt; d.digit AND n.digit &lt;&gt; m.digit AND n.digit &lt;&gt; o.digit AND
      n.digit &lt;&gt; r.digit AND n.digit &lt;&gt; y.digit AND
      d.digit &lt;&gt; m.digit AND d.digit &lt;&gt; o.digit AND d.digit &lt;&gt; r.digit AND
      d.digit &lt;&gt; y.digit AND
      m.digit &lt;&gt; o.digit AND m.digit &lt;&gt; r.digit AND m.digit &lt;&gt; y.digit AND
      o.digit &lt;&gt; r.digit AND o.digit &lt;&gt; y.digit AND
      r.digit &lt;&gt; y.digit AND
      s.digit &lt;&gt; 0 AND m.digit &lt;&gt; 0 AND
      (1000 * s.digit + 100 * e.digit + 10 * n.digit + d.digit) +
      (1000 * m.digit + 100 * o.digit + 10 * r.digit + e.digit) =
      (10000 * m.digit + 1000 * o.digit + 100 * n.digit + 10 * e.digit + y.digit);
&#34;&#34;&#34;</span>
<span>conn</span> <span>=</span> <span>sqlite3</span><span>.</span><span>connect</span><span>(</span><span>&#34;:memory:&#34;</span><span>)</span>
<span>conn</span><span>.</span><span>execute</span><span>(</span><span>query</span><span>).</span><span>fetchall</span><span>()</span>

</code></pre></div></div>

<div><div><pre><code>[(9, 5, 6, 7, 1, 0, 8, 2)]
</code></pre></div></div>

<div><div><pre><code><span>%%</span><span>timeit</span>
<span>conn</span> <span>=</span> <span>sqlite3</span><span>.</span><span>connect</span><span>(</span><span>&#34;:memory:&#34;</span><span>)</span>
<span>conn</span><span>.</span><span>execute</span><span>(</span><span>query</span><span>).</span><span>fetchone</span><span>()</span>
</code></pre></div></div>

<div><div><pre><code>969 ms ± 74.5 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
</code></pre></div></div>

<div><div><pre><code><span>%%</span><span>timeit</span>
<span>conn</span> <span>=</span> <span>duckdb</span><span>.</span><span>connect</span><span>()</span> <span># not really a noticeable part of benchmark
</span><span>conn</span><span>.</span><span>execute</span><span>(</span><span>query</span><span>).</span><span>fetchone</span><span>()</span>
</code></pre></div></div>

<div><div><pre><code>240 ms ± 16.7 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
</code></pre></div></div>

<h4 id="bonus-c-send-more-money">Bonus: C Send More Money</h4>

<p>This does raise the question of comparing to a C version. Quite a bit faster indeed.</p>

<div><div><pre><code><span>%%</span><span>file</span> <span>/</span><span>tmp</span><span>/</span><span>money</span><span>.</span><span>c</span>
<span>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
</span><span>int</span> <span>main</span><span>()</span> <span>{</span>
    <span>clock_t</span> <span>start_time</span> <span>=</span> <span>clock</span><span>();</span>
    <span>//</span><span>int</span> <span>niter</span> <span>=</span> <span>0</span><span>;</span> <span>Adding</span> <span>this</span> <span>slows</span> <span>clang</span> <span>down</span> <span>quite</span> <span>a</span> <span>bit</span>
    <span>for</span> <span>(</span><span>int</span> <span>s</span> <span>=</span> <span>1</span><span>;</span> <span>s</span> <span>&lt;</span> <span>10</span><span>;</span> <span>s</span><span>++</span><span>)</span> <span>{</span> <span>//</span> <span>S</span> <span>must</span> <span>be</span> <span>non</span><span>-</span><span>zero</span>
        <span>for</span> <span>(</span><span>int</span> <span>e</span> <span>=</span> <span>0</span><span>;</span> <span>e</span> <span>&lt;</span> <span>10</span><span>;</span> <span>e</span><span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>e</span> <span>==</span> <span>s</span><span>)</span> <span>continue</span><span>;</span>
            <span>for</span> <span>(</span><span>int</span> <span>n</span> <span>=</span> <span>0</span><span>;</span> <span>n</span> <span>&lt;</span> <span>10</span><span>;</span> <span>n</span><span>++</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span><span>n</span> <span>==</span> <span>s</span> <span>||</span> <span>n</span> <span>==</span> <span>e</span><span>)</span> <span>continue</span><span>;</span>
                <span>for</span> <span>(</span><span>int</span> <span>d</span> <span>=</span> <span>0</span><span>;</span> <span>d</span> <span>&lt;</span> <span>10</span><span>;</span> <span>d</span><span>++</span><span>)</span> <span>{</span>
                    <span>if</span> <span>(</span><span>d</span> <span>==</span> <span>s</span> <span>||</span> <span>d</span> <span>==</span> <span>e</span> <span>||</span> <span>d</span> <span>==</span> <span>n</span><span>)</span> <span>continue</span><span>;</span>
                    <span>for</span> <span>(</span><span>int</span> <span>m</span> <span>=</span> <span>1</span><span>;</span> <span>m</span> <span>&lt;</span> <span>10</span><span>;</span> <span>m</span><span>++</span><span>)</span> <span>{</span> <span>//</span> <span>M</span> <span>must</span> <span>be</span> <span>non</span><span>-</span><span>zero</span>
                        <span>if</span> <span>(</span><span>m</span> <span>==</span> <span>s</span> <span>||</span> <span>m</span> <span>==</span> <span>e</span> <span>||</span> <span>m</span> <span>==</span> <span>n</span> <span>||</span> <span>m</span> <span>==</span> <span>d</span><span>)</span> <span>continue</span><span>;</span>
                        <span>for</span> <span>(</span><span>int</span> <span>o</span> <span>=</span> <span>0</span><span>;</span> <span>o</span> <span>&lt;</span> <span>10</span><span>;</span> <span>o</span><span>++</span><span>)</span> <span>{</span>
                            <span>if</span> <span>(</span><span>o</span> <span>==</span> <span>s</span> <span>||</span> <span>o</span> <span>==</span> <span>e</span> <span>||</span> <span>o</span> <span>==</span> <span>n</span> <span>||</span> <span>o</span> <span>==</span> <span>d</span> <span>||</span> <span>o</span> <span>==</span> <span>m</span><span>)</span> <span>continue</span><span>;</span>
                            <span>for</span> <span>(</span><span>int</span> <span>r</span> <span>=</span> <span>0</span><span>;</span> <span>r</span> <span>&lt;</span> <span>10</span><span>;</span> <span>r</span><span>++</span><span>)</span> <span>{</span>
                                <span>if</span> <span>(</span><span>r</span> <span>==</span> <span>s</span> <span>||</span> <span>r</span> <span>==</span> <span>e</span> <span>||</span> <span>r</span> <span>==</span> <span>n</span> <span>||</span> <span>r</span> <span>==</span> <span>d</span> <span>||</span> <span>r</span> <span>==</span> <span>m</span> <span>||</span> <span>r</span> <span>==</span> <span>o</span><span>)</span> <span>continue</span><span>;</span>
                                <span>for</span> <span>(</span><span>int</span> <span>y</span> <span>=</span> <span>0</span><span>;</span> <span>y</span> <span>&lt;</span> <span>10</span><span>;</span> <span>y</span><span>++</span><span>)</span> <span>{</span>
                                    <span>if</span> <span>(</span><span>y</span> <span>==</span> <span>s</span> <span>||</span> <span>y</span> <span>==</span> <span>e</span> <span>||</span> <span>y</span> <span>==</span> <span>n</span> <span>||</span> <span>y</span> <span>==</span> <span>d</span> <span>||</span> <span>y</span> <span>==</span> <span>m</span> <span>||</span> <span>y</span> <span>==</span> <span>o</span> <span>||</span> <span>y</span> <span>==</span> <span>r</span><span>)</span> <span>continue</span><span>;</span>

                                    <span>//</span> <span>Calculate</span> <span>SEND</span><span>,</span> <span>MORE</span><span>,</span> <span>and</span> <span>MONEY</span>
                                    <span>int</span> <span>send</span> <span>=</span> <span>1000</span> <span>*</span> <span>s</span> <span>+</span> <span>100</span> <span>*</span> <span>e</span> <span>+</span> <span>10</span> <span>*</span> <span>n</span> <span>+</span> <span>d</span><span>;</span>
                                    <span>int</span> <span>more</span> <span>=</span> <span>1000</span> <span>*</span> <span>m</span> <span>+</span> <span>100</span> <span>*</span> <span>o</span> <span>+</span> <span>10</span> <span>*</span> <span>r</span> <span>+</span> <span>e</span><span>;</span>
                                    <span>int</span> <span>money</span> <span>=</span> <span>10000</span> <span>*</span> <span>m</span> <span>+</span> <span>1000</span> <span>*</span> <span>o</span> <span>+</span> <span>100</span> <span>*</span> <span>n</span> <span>+</span> <span>10</span> <span>*</span> <span>e</span> <span>+</span> <span>y</span><span>;</span>
                                    <span>//</span><span>niter</span><span>++</span><span>;</span>

                                    <span>if</span> <span>(</span><span>send</span> <span>+</span> <span>more</span> <span>==</span> <span>money</span><span>)</span> <span>{</span>
                                        <span>clock_t</span> <span>end_time</span> <span>=</span> <span>clock</span><span>();</span>
                                        <span>double</span> <span>time_taken</span> <span>=</span> <span>((</span><span>double</span><span>)(</span><span>end_time</span> <span>-</span> <span>start_time</span><span>))</span> <span>/</span> <span>CLOCKS_PER_SEC</span><span>;</span>
                                        <span>printf</span><span>(</span><span>&#34;Time taken by loops: %.6f seconds</span><span>\n</span><span>&#34;</span><span>,</span> <span>time_taken</span><span>);</span>
                                        <span>printf</span><span>(</span><span>&#34;SEND = %d, MORE = %d, MONEY = %d</span><span>\n</span><span>&#34;</span><span>,</span> <span>send</span><span>,</span> <span>more</span><span>,</span> <span>money</span><span>);</span>
                                        <span>//</span><span>printf</span><span>(</span><span>&#34;Tests: %d</span><span>\n</span><span>&#34;</span><span>,</span> <span>niter</span><span>);</span>
                                        <span>return</span> <span>0</span><span>;</span>
                                    <span>}</span>
                                <span>}</span>
                            <span>}</span>
                        <span>}</span>
                    <span>}</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>1</span><span>;</span>
<span>}</span>
</code></pre></div></div>



<div><div><pre><code><span>!</span> <span>clang</span> <span>-</span><span>O3</span> <span>-</span><span>march</span><span>=</span><span>native</span> <span>-</span><span>o</span> <span>/</span><span>tmp</span><span>/</span><span>money</span> <span>/</span><span>tmp</span><span>/</span><span>money</span><span>.</span><span>c</span> <span>&amp;&amp;</span> <span>/</span><span>tmp</span><span>/</span><span>money</span>
</code></pre></div></div>

<div><div><pre><code>Time taken by loops: 0.003991 seconds
SEND = 9567, MORE = 1085, MONEY = 10652
</code></pre></div></div>

<div><div><pre><code><span>!</span> <span>gcc</span> <span>-</span><span>O3</span> <span>-</span><span>march</span><span>=</span><span>native</span> <span>-</span><span>o</span> <span>/</span><span>tmp</span><span>/</span><span>money</span> <span>/</span><span>tmp</span><span>/</span><span>money</span><span>.</span><span>c</span> <span>&amp;&amp;</span> <span>/</span><span>tmp</span><span>/</span><span>money</span>
</code></pre></div></div>

<div><div><pre><code>Time taken by loops: 0.019185 seconds
SEND = 9567, MORE = 1085, MONEY = 10652
</code></pre></div></div>

<p>Hmm. My system clang vs gcc is another 5x? That’s kind of surprising. I have a new clang (20) and an old gcc 11.4. Maybe that’s enough. The thing also that it may be rearranging the loops? If I try to add a counter, clang slows down to about gcc. Very interesting.</p>



<p>There is another perspective on what SQL is doing. It is finding a mapping (a <a href="https://en.wikipedia.org/wiki/Homomorphism">homomorphism</a>) between the query and the database.</p>

<p>We have intuition about databases that comes from typically thinking about small queries (&lt; 100 tables referenced in FROM statements) and big databases (millions, billions or more of rows).</p>

<p>The running time of naive nested loops is exponential in the number of loops. Considered as a function of the size the of query, database queries are quite computationally expensive.</p>

<p><a href="https://en.wikipedia.org/wiki/Graph_homomorphism">Graph homomorphisms</a> are a particular familiar case of a homomorphism. Graphs can be easily mapped into database tables as an edge table with two columns.</p>

<p>I have heard that I should be scared of <a href="https://en.wikipedia.org/wiki/Subgraph_isomorphism_problem">subgraph matching</a> or <a href="https://en.wikipedia.org/wiki/Graph_isomorphism">graph isomorphism</a> because they are NP ish. But in many common cases, the size of the patterns is pretty small, and the size of the database is pretty big. So the problem is not that hard.</p>

<p>Here for example I can turn a networkx graph into a sqlite table</p>

<div><div><pre><code><span>import</span> <span>sqlite3</span>
<span>import</span> <span>networkx</span> <span>as</span> <span>nx</span>
<span>def</span> <span>db_of_graph</span><span>(</span><span>conn</span><span>,</span> <span>G</span><span>):</span>
    <span>con</span><span>.</span><span>executemany</span><span>(</span><span>&#34;INSERT INTO nodes VALUES (?)&#34;</span><span>,</span> <span>map</span><span>(</span><span>lambda</span> <span>v</span> <span>:</span> <span>(</span><span>v</span><span>,),</span>  <span>G</span><span>.</span><span>nodes</span><span>))</span>
    <span>con</span><span>.</span><span>executemany</span><span>(</span><span>&#34;INSERT INTO edges VALUES (?, ?)&#34;</span><span>,</span> <span>G</span><span>.</span><span>edges</span><span>)</span>
    <span>if</span> <span>not</span> <span>G</span><span>.</span><span>is_directed</span><span>():</span>
        <span>con</span><span>.</span><span>executemany</span><span>(</span><span>&#34;INSERT INTO edges VALUES (?, ?)&#34;</span><span>,</span> <span>[(</span><span>j</span><span>,</span><span>i</span><span>)</span> <span>for</span> <span>i</span><span>,</span><span>j</span> <span>in</span> <span>G</span><span>.</span><span>edges</span><span>])</span>
</code></pre></div></div>

<p>And conversely export the edge table back out into a networkx graph.</p>

<div><div><pre><code><span>def</span> <span>graph_of_db</span><span>(</span><span>con</span><span>):</span>
    <span>G</span> <span>=</span> <span>nx</span><span>.</span><span>DiGraph</span><span>()</span>
    <span>res</span> <span>=</span> <span>con</span><span>.</span><span>execute</span><span>(</span><span>&#34;SELECT * FROM nodes&#34;</span><span>)</span>
    <span>G</span><span>.</span><span>add_nodes_from</span><span>(</span><span>map</span><span>(</span><span>lambda</span> <span>x</span><span>:</span> <span>x</span><span>[</span><span>0</span><span>],</span> <span>res</span><span>.</span><span>fetchall</span><span>()))</span>
    <span>res</span> <span>=</span> <span>con</span><span>.</span><span>execute</span><span>(</span><span>&#34;SELECT * FROM edges&#34;</span><span>)</span>
    <span>G</span><span>.</span><span>add_edges_from</span><span>(</span><span>res</span><span>.</span><span>fetchall</span><span>())</span>
    <span>return</span> <span>G</span>
</code></pre></div></div>

<p>The form of these simple <code>FROM-SELECT-WHERE</code> queries (conjuctive queries) is remarkably similar to a database itself, but with symbolic entries. Each FROM would become a row in this symbolic database. We can for example convert a graph also into a query that will find the image of the graph in the database. The solutions to this query are graph homomorphisms. When codegenning SQL I find maintaining separate <code>select</code> <code>from</code> <code>where</code> lists to be a useful thing.</p>

<div><div><pre><code><span>def</span> <span>query_of_graph</span><span>(</span><span>G</span><span>,</span><span>unique</span><span>=</span><span>False</span><span>):</span>
    <span>&#34;&#34;&#34;Unique will give subgraph isomorphism&#34;&#34;&#34;</span>
    <span>selects</span> <span>=</span> <span>[]</span>
    <span>froms</span> <span>=</span> <span>[]</span>
    <span>wheres</span> <span>=</span> <span>[]</span>
    <span>for</span> <span>node</span> <span>in</span> <span>G</span><span>:</span>
        <span>froms</span> <span>+=</span> <span>[</span><span>f</span><span>&#34;nodes AS v</span><span>{</span><span>node</span><span>}</span><span>&#34;</span><span>]</span>
        <span>selects</span> <span>+=</span> <span>[</span><span>f</span><span>&#34;v</span><span>{</span><span>node</span><span>}</span><span>.v AS v</span><span>{</span><span>node</span><span>}</span><span>&#34;</span><span>]</span>
    <span>for</span> <span>i</span><span>,</span> <span>(</span><span>a</span><span>,</span><span>b</span><span>)</span> <span>in</span> <span>enumerate</span><span>(</span><span>G</span><span>.</span><span>edges</span><span>):</span>
        <span>froms</span> <span>+=</span> <span>[</span><span>f</span><span>&#34;edges as e</span><span>{</span><span>i</span><span>}</span><span>&#34;</span><span>]</span>
        <span>wheres</span> <span>+=</span> <span>[</span><span>f</span><span>&#34;e</span><span>{</span><span>i</span><span>}</span><span>.src = v</span><span>{</span><span>a</span><span>}</span><span>.v&#34;</span>  <span>,</span> <span>f</span><span>&#34;e</span><span>{</span><span>i</span><span>}</span><span>.dst = v</span><span>{</span><span>b</span><span>}</span><span>.v&#34;</span><span>]</span>
    <span>if</span> <span>unique</span><span>:</span>
        <span>for</span> <span>node</span> <span>in</span> <span>G</span><span>:</span>
            <span>for</span> <span>node2</span> <span>in</span> <span>G</span><span>:</span>
                <span>if</span> <span>node</span> <span>!=</span> <span>node2</span><span>:</span>
                    <span>wheres</span> <span>+=</span> <span>[</span><span>f</span><span>&#34;v</span><span>{</span><span>node</span><span>}</span><span> != v</span><span>{</span><span>node2</span><span>}</span><span>&#34;</span><span>]</span>
    <span>sql</span> <span>=</span> <span>&#34;SELECT &#34;</span> <span>+</span> <span>&#34;, &#34;</span><span>.</span><span>join</span><span>(</span><span>selects</span><span>)</span> <span>+</span> \
          <span>&#34;</span><span>\n</span><span>FROM &#34;</span> <span>+</span>  <span>&#34;, &#34;</span><span>.</span><span>join</span><span>(</span><span>froms</span><span>)</span> <span>+</span> \
          <span>&#34;</span><span>\n</span><span>WHERE &#34;</span> <span>+</span> <span>&#34; AND &#34;</span><span>.</span><span>join</span><span>(</span><span>wheres</span><span>)</span>
    <span>return</span> <span>sql</span>
<span>def</span> <span>clear_db</span><span>(</span><span>con</span><span>):</span>
    <span>con</span><span>.</span><span>execute</span><span>(</span><span>&#34;DELETE FROM nodes&#34;</span><span>)</span>
    <span>con</span><span>.</span><span>execute</span><span>(</span><span>&#34;DELETE FROM edges&#34;</span><span>)</span>
<span>con</span> <span>=</span> <span>sqlite3</span><span>.</span><span>connect</span><span>(</span><span>&#34;:memory:&#34;</span><span>)</span>
<span>con</span><span>.</span><span>execute</span><span>(</span><span>&#34;CREATE TABLE nodes(v)&#34;</span><span>)</span>
<span>con</span><span>.</span><span>execute</span><span>(</span><span>&#34;CREATE TABLE edges(src,dst)&#34;</span><span>)</span>
</code></pre></div></div>

<div><div><pre><code>&lt;sqlite3.Cursor at 0x7b99507714c0&gt;
</code></pre></div></div>

<h4 id="some-examples">Some Examples</h4>

<p>We can make a graph and insert the appropriate edge table into the database.</p>

<div><div><pre><code><span>G</span> <span>=</span> <span>nx</span><span>.</span><span>path_graph</span><span>(</span><span>7</span><span>,</span> <span>create_using</span><span>=</span><span>nx</span><span>.</span><span>DiGraph</span><span>)</span>
<span>nx</span><span>.</span><span>draw</span><span>(</span><span>G</span><span>,</span> <span>with_labels</span><span>=</span><span>True</span><span>)</span>
</code></pre></div></div>

<p><img src="https://www.philipzucker.com/pynb/2024-11-18-sql_graph_csp_files/2024-11-18-sql_graph_csp_19_0.png" alt="png"/></p>

<div><div><pre><code><span>db_of_graph</span><span>(</span><span>con</span><span>,</span> <span>G</span><span>)</span>
<span>con</span><span>.</span><span>execute</span><span>(</span><span>&#34;SELECT * from edges&#34;</span><span>).</span><span>fetchall</span><span>()</span>
</code></pre></div></div>

<div><div><pre><code>[(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]
</code></pre></div></div>

<p>We can seek out the smaller pattern graph from the larger graph</p>

<div><div><pre><code><span>lhs</span> <span>=</span> <span>nx</span><span>.</span><span>path_graph</span><span>(</span><span>3</span><span>,</span> <span>create_using</span><span>=</span><span>nx</span><span>.</span><span>DiGraph</span><span>)</span>
<span>nx</span><span>.</span><span>draw</span><span>(</span><span>lhs</span><span>,</span> <span>with_labels</span><span>=</span><span>True</span><span>)</span>
</code></pre></div></div>

<p><img src="https://www.philipzucker.com/pynb/2024-11-18-sql_graph_csp_files/2024-11-18-sql_graph_csp_22_0.png" alt="png"/></p>

<div><div><pre><code><span>print</span><span>(</span><span>query_of_graph</span><span>(</span><span>lhs</span><span>))</span>
</code></pre></div></div>

<div><div><pre><code>SELECT v0.v AS v0, v1.v AS v1, v2.v AS v2
FROM nodes AS v0, nodes AS v1, nodes AS v2, edges as e0, edges as e1
WHERE e0.src = v0.v AND e0.dst = v1.v AND e1.src = v1.v AND e1.dst = v2.v
</code></pre></div></div>

<div><div><pre><code><span>con</span><span>.</span><span>execute</span><span>(</span><span>query_of_graph</span><span>(</span><span>lhs</span><span>)).</span><span>fetchall</span><span>()</span>
</code></pre></div></div>

<div><div><pre><code>[(0, 1, 2), (1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)]
</code></pre></div></div>

<h4 id="automorphisms">Automorphisms</h4>

<p>We can also find all homomorphisms of the graph into itself, of which there is only one for the directed graph.</p>

<div><div><pre><code><span>con</span><span>.</span><span>execute</span><span>(</span><span>query_of_graph</span><span>(</span><span>G</span><span>)).</span><span>fetchall</span><span>()</span>
</code></pre></div></div>



<p>For the undirected graph, there are more homomorphisms.</p>

<div><div><pre><code><span>clear_db</span><span>(</span><span>con</span><span>)</span>
<span>G</span> <span>=</span> <span>nx</span><span>.</span><span>path_graph</span><span>(</span><span>4</span><span>)</span> <span># undirected
</span><span>db_of_graph</span><span>(</span><span>con</span><span>,</span> <span>G</span><span>)</span>
<span>res</span> <span>=</span> <span>con</span><span>.</span><span>execute</span><span>(</span><span>query_of_graph</span><span>(</span><span>G</span><span>))</span>
<span>res</span><span>.</span><span>fetchall</span><span>()</span>

</code></pre></div></div>

<div><div><pre><code>[(1, 0, 1, 0),
 (1, 0, 1, 2),
 (0, 1, 0, 1),
 (0, 1, 2, 1),
 (0, 1, 2, 3),
 (2, 1, 0, 1),
 (2, 1, 2, 1),
 (2, 1, 2, 3),
 (1, 2, 1, 0),
 (1, 2, 1, 2),
 (1, 2, 3, 2),
 (3, 2, 1, 0),
 (3, 2, 1, 2),
 (3, 2, 3, 2),
 (2, 3, 2, 1),
 (2, 3, 2, 3)]
</code></pre></div></div>

<p>A homomorphism into yourself is not an isomorphism. You need a uniqueness constraint also for that, which can easily be expressed in SQL. The undirected path graph has 2 automorphisms, the identity and the reversal.</p>

<div><div><pre><code><span>res</span> <span>=</span> <span>con</span><span>.</span><span>execute</span><span>(</span><span>query_of_graph</span><span>(</span><span>G</span><span>,</span><span>unique</span><span>=</span><span>True</span><span>))</span>
<span>res</span><span>.</span><span>fetchall</span><span>()</span>
</code></pre></div></div>

<div><div><pre><code>[(0, 1, 2, 3), (3, 2, 1, 0)]
</code></pre></div></div>

<h4 id="graph-coloring">Graph Coloring</h4>

<p>We can also implement a coloring as an homomorphism into the fully connected graph, representing the colors and allowed edges between colors.</p>

<div><div><pre><code><span>clear_db</span><span>(</span><span>con</span><span>)</span>
<span>colors</span> <span>=</span> <span>nx</span><span>.</span><span>complete_graph</span><span>(</span><span>2</span><span>)</span> <span># a two coloring graph
</span><span>db_of_graph</span><span>(</span><span>con</span><span>,</span><span>colors</span><span>)</span>
<span>res</span> <span>=</span> <span>con</span><span>.</span><span>execute</span><span>(</span><span>&#34;SELECT * FROM edges&#34;</span><span>)</span>
<span>res</span> <span>=</span> <span>print</span><span>(</span><span>res</span><span>.</span><span>fetchall</span><span>())</span>
</code></pre></div></div>



<div><div><pre><code><span>res</span> <span>=</span> <span>con</span><span>.</span><span>execute</span><span>(</span><span>query_of_graph</span><span>(</span><span>G</span><span>))</span> <span># two dimer colorings
</span><span>print</span><span>(</span><span>res</span><span>.</span><span>fetchall</span><span>())</span>
</code></pre></div></div>

<div><div><pre><code>[(1, 0, 1, 0), (0, 1, 0, 1)]
</code></pre></div></div>



<p><a href="https://dl.acm.org/doi/pdf/10.1145/335168.335209">https://dl.acm.org/doi/pdf/10.1145/335168.335209</a> Constraint Satisfaction and Database Theory: a Tutorial Moshe Y. Vardi</p>

<p><a href="https://users.soe.ucsc.edu/~kolaitis/talks/csp-oxford.pdf">https://users.soe.ucsc.edu/~kolaitis/talks/csp-oxford.pdf</a>  Constraint Satisfaction and Logic Phokion G. Kolaitis</p>

<p><a href="https://berkeley-cs294-248.github.io/">https://berkeley-cs294-248.github.io/</a>  CS294-248: Topics in Database Theory</p>

<p>Alice book <a href="http://webdam.inria.fr/Alice/">http://webdam.inria.fr/Alice/</a> Foundations of Databases. I know there is some discussion of query containment involvinf something like a “symbolic” database corresponding to a query.</p>

<p>Have you tried rubbing a database on it? <a href="https://www.hytradboi.com/">https://www.hytradboi.com/</a> Databases used for sometimes unusual purposes</p>

<p><a href="https://www.youtube.com/watch?v=mykR7mP5Zdk&amp;t=269s&amp;ab_channel=SimonsInstitute">https://www.youtube.com/watch?v=mykR7mP5Zdk&amp;t=269s&amp;ab_channel=SimonsInstitute</a>  Logic and Databases Phokion Kolaitis</p>

<p><a href="https://dl.acm.org/doi/10.1145/3018882.3018893">https://dl.acm.org/doi/10.1145/3018882.3018893</a> Language-integrated query with ordering, grouping and outer joins  <a href="https://okmij.org/ftp/meta-programming/index.html#SQUR">https://okmij.org/ftp/meta-programming/index.html#SQUR</a></p>

<p>Note newtorkx has its own homomorphism and ismorphisms functionality. Going to SQl may or may not be more efficient. <a href="https://networkx.org/documentation/stable/reference/algorithms/isomorphism.html">https://networkx.org/documentation/stable/reference/algorithms/isomorphism.html</a> <a href="https://networkx.org/documentation/stable/reference/algorithms/isomorphism.vf2.html#graph-matcher">https://networkx.org/documentation/stable/reference/algorithms/isomorphism.vf2.html#graph-matcher</a> Everything has bindings to sqlite though. Pretty convenient and flexible.
<a href="https://pallini.di.uniroma1.it/">https://pallini.di.uniroma1.it/</a> nauty and traces are high performance isomorphism / automorphism/ canonization solvers</p>

<p>Query containment. Since you can make a sql query to find homomorphisms, you can check query containment as a sql query itself. Isn’t that fun?</p>

<p>The symbolic database as a herbrand model.</p>

<p>Gra</p>

<p>I’ve never seriously used a graph database, but I kind of can’t see the appeal for this reason. I find pretty often modelling domains as graphs to not actually map that well because I want a notion of ordering.</p>

<p>I really had this one rotting in my draft backlog for a long time. Good to just dump stuff out.</p>



<p>SQL is a model checker for first order logic. SQL + something like NOT and EXISTS statements can express any first order logic statement.</p>

<p>Model checking has a connotation of being about temporal logic, or software system checking. But the term itself is talking about literally checking a model satisfies a formula <code>M |= t</code>. Model checking is a general concept that can be applied to any logic with a notion of smenantics.</p>

<p>Model checking is also kind of saying there is a kind of homomorphism between the syntax and semantics.</p>

<p>This is also a confusion that we have in talking about the “complexity” of a logic. The ocmplexity depends on which question we are asking. Are me asking satisfiability or model checking? Satisfiiability is also aasking about the <code>M |= t</code> models question, but it is of the form <code>formula -&gt; option model</code> rather than the form <code>model -&gt; formula -&gt; bool</code>. The moding of the question is different.</p>

<p>When people talk about SAT being NP, they are talking about the satisfiability problem.
When they talk about existential second order logic being NP, they are talking about the model checking problem <a href="https://en.wikipedia.org/wiki/Fagin%27s_theorem">https://en.wikipedia.org/wiki/Fagin%27s_theorem</a> <a href="https://en.wikipedia.org/wiki/Descriptive_complexity_theory">https://en.wikipedia.org/wiki/Descriptive_complexity_theory</a></p>

<p>When people talk about datalog being PSPACE co</p>

<p>Tree decomposition for dynamic programming</p>

<h2 id="csp">CSP</h2>

<p>SQL queries are enumerating homomorphisms between the query and the database. This perspective puts the query and the database on smilar footing, which feels odd.</p>

<p>As a subcase of this capability, if the database is holding an edge table and attributes, then a query is a graph homomorphism solver.
If we dymmetrically place two graphs into the database and in a query, we can enumerate isomoprhisms. Isn’t that fun?</p>

<p>Another perspective is that the query is a formula, and the database is a model of the formula.</p>

<p>We are used to small queries and large databases, but this is not a definition</p>

<p>A perspective on what a constraint satisfaction problem is is that is is a homomorphism problem.
For example, graph coloring is a homomorphism from a graph to a complete graph of colors (with no self edges).</p>

<p>Constraint satisfaction is an assignment to variables values frm their domain subject to constraints. The particular connectivty of a problem can be represented by a hypergraph. The target structure represents the domains the variables can take on, and the constraint hyperedges map to a relation representing the constraint.
A class of CSP problems is allowing the connecvtivity graph to vary, while keeping the target (the types of constraints fixed). Is this a useful characterization? Eh. It’s interesting that it ties into other mathemtical topicas.</p>

<p>The naive solution of a constraint satsifaction problem is to just make a big sequence of loops, pruning / breaking with checks that constraint are satisifed. We want to push the checks as high as possible.
This a a very static perspective.
More dynammically, we want to pick the variable ordering inside the choice branches. This is more of a backtracking feel. We do proppagation to disallow subchoices</p>

<p>A problem that is easy to embed into database queries is graph homomomorphism. Queries and databases feel very different, but they are more symettric than you might think.</p>

<p>In typical usage, queries are small and databases are large.
A graph coloring problem can be mdelled as fnding a graph homomorphism into a complete graph. This flips the intuition on it’s head with a large query and small database. Examples like these are better served probably by a constraint satisfaction solver or SAT style techniques.</p>

<p>The middle ground of roughly equal graphs is a graph isomorphism problem. Custom solvers like nauty exist for this case too.</p>

<div><div><pre><code><span>import</span> <span>sqlite3</span>
<span>import</span> <span>networkx</span> <span>as</span> <span>nx</span>
<span>def</span> <span>db_of_graph</span><span>(</span><span>conn</span><span>,</span> <span>G</span><span>):</span>
    <span>con</span><span>.</span><span>executemany</span><span>(</span><span>&#34;INSERT INTO nodes VALUES (?)&#34;</span><span>,</span> <span>map</span><span>(</span><span>lambda</span> <span>v</span> <span>:</span> <span>(</span><span>v</span><span>,),</span>  <span>G</span><span>.</span><span>nodes</span><span>))</span>
    <span>con</span><span>.</span><span>executemany</span><span>(</span><span>&#34;INSERT INTO edges VALUES (?, ?)&#34;</span><span>,</span> <span>G</span><span>.</span><span>edges</span><span>)</span>
<span>def</span> <span>graph_of_db</span><span>(</span><span>con</span><span>):</span>
    <span>G</span> <span>=</span> <span>nx</span><span>.</span><span>DiGraph</span><span>()</span>
    <span>res</span> <span>=</span> <span>con</span><span>.</span><span>execute</span><span>(</span><span>&#34;SELECT * FROM nodes&#34;</span><span>)</span>
    <span>G</span><span>.</span><span>add_nodes_from</span><span>(</span><span>map</span><span>(</span><span>lambda</span> <span>x</span><span>:</span> <span>x</span><span>[</span><span>0</span><span>],</span> <span>res</span><span>.</span><span>fetchall</span><span>()))</span>
    <span>res</span> <span>=</span> <span>con</span><span>.</span><span>execute</span><span>(</span><span>&#34;SELECT * FROM edges&#34;</span><span>)</span>
    <span>G</span><span>.</span><span>add_edges_from</span><span>(</span><span>res</span><span>.</span><span>fetchall</span><span>())</span>
    <span>return</span> <span>G</span>
<span>def</span> <span>query_of_graph</span><span>(</span><span>G</span><span>):</span>
    <span>selects</span> <span>=</span> <span>[]</span>
    <span>froms</span> <span>=</span> <span>[]</span>
    <span>wheres</span> <span>=</span> <span>[]</span>
    <span>for</span> <span>node</span> <span>in</span> <span>G</span><span>:</span>
        <span>froms</span> <span>+=</span> <span>[</span><span>f</span><span>&#34;nodes AS v</span><span>{</span><span>node</span><span>}</span><span>&#34;</span><span>]</span>
        <span>selects</span> <span>+=</span> <span>[</span><span>f</span><span>&#34;v</span><span>{</span><span>node</span><span>}</span><span>.v AS v</span><span>{</span><span>node</span><span>}</span><span>&#34;</span><span>]</span>
    <span>for</span> <span>i</span><span>,</span> <span>(</span><span>a</span><span>,</span><span>b</span><span>)</span> <span>in</span> <span>enumerate</span><span>(</span><span>G</span><span>.</span><span>edges</span><span>):</span>
        <span>froms</span> <span>+=</span> <span>[</span><span>f</span><span>&#34;edges as e</span><span>{</span><span>i</span><span>}</span><span>&#34;</span><span>]</span>
        <span>wheres</span> <span>+=</span> <span>[</span><span>f</span><span>&#34;e</span><span>{</span><span>i</span><span>}</span><span>.src = v</span><span>{</span><span>a</span><span>}</span><span>.v&#34;</span>  <span>,</span> <span>f</span><span>&#34;e</span><span>{</span><span>i</span><span>}</span><span>.dst = v</span><span>{</span><span>b</span><span>}</span><span>.v&#34;</span><span>]</span>
    <span>sql</span> <span>=</span> <span>&#34;SELECT &#34;</span> <span>+</span> <span>&#34;, &#34;</span><span>.</span><span>join</span><span>(</span><span>selects</span><span>)</span> <span>+</span> \
          <span>&#34;</span><span>\n</span><span>FROM &#34;</span> <span>+</span>  <span>&#34;, &#34;</span><span>.</span><span>join</span><span>(</span><span>froms</span><span>)</span> <span>+</span> \
          <span>&#34;</span><span>\n</span><span>WHERE &#34;</span> <span>+</span> <span>&#34; AND &#34;</span><span>.</span><span>join</span><span>(</span><span>wheres</span><span>)</span>
    <span>return</span> <span>sql</span>
<span>G</span> <span>=</span> <span>nx</span><span>.</span><span>path_graph</span><span>(</span><span>7</span><span>,</span> <span>create_using</span><span>=</span><span>nx</span><span>.</span><span>DiGraph</span><span>)</span>
<span>lhs</span> <span>=</span> <span>nx</span><span>.</span><span>path_graph</span><span>(</span><span>3</span><span>,</span> <span>create_using</span><span>=</span><span>nx</span><span>.</span><span>DiGraph</span><span>)</span>
<span>con</span> <span>=</span> <span>sqlite3</span><span>.</span><span>connect</span><span>(</span><span>&#34;:memory:&#34;</span><span>)</span>

<span>con</span><span>.</span><span>execute</span><span>(</span><span>&#34;CREATE TABLE nodes(v)&#34;</span><span>)</span>
<span>con</span><span>.</span><span>execute</span><span>(</span><span>&#34;CREATE TABLE edges(src,dst)&#34;</span><span>)</span>
<span>db_of_graph</span><span>(</span><span>con</span><span>,</span> <span>G</span><span>)</span>
<span>res</span> <span>=</span> <span>con</span><span>.</span><span>execute</span><span>(</span><span>query_of_graph</span><span>(</span><span>lhs</span><span>))</span>
<span>print</span><span>(</span><span>res</span><span>.</span><span>fetchall</span><span>())</span>
<span># Result: [(0, 1, 2), (1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)]
</span>
<span>print</span><span>(</span><span>graph_of_db</span><span>(</span><span>con</span><span>))</span>
<span>&#34;DELETE FROM nodes WHERE nodes.v = ?&#34;</span>
<span>&#34;DELETE FROM edges where edges.src = ? OR edges.dst = ?&#34;</span>

<span>con</span><span>.</span><span>execute</span><span>(</span><span>&#34;DELETE FROM nodes&#34;</span><span>)</span>
<span>con</span><span>.</span><span>execute</span><span>(</span><span>&#34;DELETE FROM edges&#34;</span><span>)</span>
<span>colors</span> <span>=</span> <span>nx</span><span>.</span><span>complete_graph</span><span>(</span><span>2</span><span>)</span> <span># a two coloring
</span><span>db_of_graph</span><span>(</span><span>con</span><span>,</span><span>colors</span><span>)</span>
<span># symmetrize. Maybe db_of_graph should do this. if not isinstanc(G,nx.DiGraph)
</span><span>con</span><span>.</span><span>execute</span><span>(</span><span>&#34;INSERT INTO edges SELECT edges.dst, edges.src FROM edges&#34;</span><span>)</span>

<span>res</span> <span>=</span> <span>con</span><span>.</span><span>execute</span><span>(</span><span>&#34;SELECT * FROM edges&#34;</span><span>)</span>
<span>res</span> <span>=</span> <span>print</span><span>(</span><span>res</span><span>.</span><span>fetchall</span><span>())</span>
<span>res</span> <span>=</span> <span>con</span><span>.</span><span>execute</span><span>(</span><span>query_of_graph</span><span>(</span><span>G</span><span>))</span>
<span>print</span><span>(</span><span>res</span><span>.</span><span>fetchall</span><span>())</span>
<span># [(1, 0, 1, 0, 1, 0, 1), (0, 1, 0, 1, 0, 1, 0)]
</span></code></pre></div></div>

<p>Graph coloring can be solved through dynamic programming. If we cut up a graph, we only need to know if it can be colored with particular choices at interfaces. Choosing interfaces like this is a graph partitioning problem, but also is a tree decomposition.</p>

<p>One of the things that I found appealing about category theory is that it presents a design methodology to convert things that look graph-like like string diagrams into term-like expresssions of combinators.</p>

<p>Hmm. python-metis is not a thing anymore? Just pip install metis, it works with networkx anyway</p>

<div><div><pre><code><span>import</span> <span>metis</span>

<span>import</span> <span>networkx</span> <span>as</span> <span>nx</span>
<span>G</span> <span>=</span> <span>nx</span><span>.</span><span>path_graph</span><span>(</span><span>7</span><span>)</span>
<span>edgecuts</span><span>,</span> <span>parts</span> <span>=</span> <span>metis</span><span>.</span><span>part_graph</span><span>(</span><span>G</span><span>,</span><span>3</span><span>)</span>
<span>print</span><span>(</span><span>edgecuts</span><span>,</span> <span>parts</span><span>)</span>

<span>print</span><span>(</span><span>nx</span><span>.</span><span>community</span><span>.</span><span>kernighan_lin_bisection</span><span>(</span><span>G</span><span>))</span> <span># anneal a cut by node swapping
</span><span>print</span><span>(</span><span>list</span><span>(</span><span>nx</span><span>.</span><span>community</span><span>.</span><span>girvan_newman</span><span>(</span><span>G</span><span>)))</span> <span># remove edges from graph
</span></code></pre></div></div>

<p>Recursively partition to build query plan (?)</p>

<p>You can build a query plan using these graph partitioners
but also query planners can be used to find partitions / tree decompositions.</p>

<p>There are also custom solvers for this.</p>

<p>graph datastructure</p>

<p><code>[(v1,v2)]</code></p>

<div><div><pre><code>Node(outs,ins)
= [(outs,ins)]
out, inner , in

</code></pre></div></div>

<p>dynamic tree decomposition
hyprgraph data structure</p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
