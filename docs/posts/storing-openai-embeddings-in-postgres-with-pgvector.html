<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://supabase.com/blog/openai-embeddings-postgres-vector">Original</a>
    <h1>Storing OpenAI embeddings in Postgres with pgvector</h1>
    
    <div id="readability-page-1" class="page"><article><div><p><span><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></p><p>A new PostgreSQL extension is now available in Supabase: <a href="https://github.com/pgvector/pgvector"><code>pgvector</code></a>, an open-source vector similarity search.</p>
<p>The exponential progress of AI functionality over the past year has inspired many new real world applications. One specific challenge has been the ability to store and query <em>embeddings</em> at scale.
In this post we&#39;ll explain what embeddings are, why we might want to use them, and how we can store and query them in PostgreSQL using <code>pgvector</code>.</p>
<h2 id="what-are-embeddings">What are embeddings?</h2>
<p>Embeddings capture the “relatedness” of text, images, video, or other types of information. This relatedness is most commonly used for:</p>
<ul>
<li><strong>Search:</strong> how similar is a search term to a body of text?</li>
<li><strong>Recommendations:</strong> how similar are two products?</li>
<li><strong>Classifications:</strong> how do we categorize a body of text?</li>
<li><strong>Clustering:</strong> how do we identify trends?</li>
</ul>
<p>Let&#39;s explore an example of text embeddings. Say we have three phrases:</p>
<ol>
<li>“The cat chases the mouse”</li>
<li>“The kitten hunts rodents”</li>
<li>“I like ham sandwiches”</li>
</ol>
<p>Your job is to group phrases with similar meaning. If you are a human, this should be obvious. Phrases 1 and 2 are almost identical, while phrase 3 has a completely different meaning.</p>
<p>Although phrases 1 and 2 are similar, they share no common vocabulary (besides “the”). Yet their meanings are nearly identical. How can we teach a computer that these are the same?</p>
<h2 id="human-language">Human language</h2>
<p>Humans use words and symbols to communicate language. But words in isolation are mostly meaningless - we need to draw from shared knowledge &amp; experience in order to make sense of them. The phrase “You should Google it” only makes sense if you know that Google is a search engine and that people have been using it as a verb.</p>
<p>In the same way, we need to train a neural network model to understand human language. An effective model should be trained on millions of different examples to understand what each word, phrase, sentence, or paragraph could mean in different contexts.</p>
<p>So how does this relate to embeddings?</p>
<h2 id="how-do-embeddings-work">How do embeddings work?</h2>
<p>Embeddings compress discrete information (words &amp; symbols) into distributed continuous-valued data (vectors). If we took our phrases from before and plot them on a chart, it might look something like this:</p>
<p><span><span><img alt="Vector similarity" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></span></p>
<p>Phrases 1 and 2 would be plotted close to each other, since their meanings are similar. We would expect phrase 3 to live somewhere far away since it isn&#39;t related. If we had a fourth phrase, “Sally ate Swiss cheese”, this might exist somewhere between phrase 3 (cheese can go on sandwiches) and phrase 1 (mice like Swiss cheese).</p>
<p>In this example we only have 2 dimensions: the X and Y axis. In reality, we would need many more dimensions to effectively capture the complexities of human language.</p>
<h2 id="openai-embeddings">OpenAI embeddings</h2>
<p>OpenAI offers an <a href="https://platform.openai.com/docs/guides/embeddings">API</a> to generate embeddings for a string of text using its language model. You feed it any text information (blog articles, documentation, your company&#39;s knowledge base), and it will output a vector of floating point numbers that represents the “meaning” of that text.</p>
<p>Compared to our 2-dimensional example above, their latest embedding model <code>text-embedding-ada-002</code> will output 1536 dimensions.</p>
<p>Why is this useful? Once we have generated embeddings on multiple texts, it is trivial to calculate how similar they are using vector math operations like cosine distance. A perfect use case for this is search. Your process might look something like this:</p>
<ol>
<li>Pre-process your knowledge base and generate embeddings for each page</li>
<li>Store your embeddings to be referenced later (more on this)</li>
<li>Build a search page that prompts your user for input</li>
<li>Take user&#39;s input, generate a one-time embedding, then perform a similarity search against your pre-processed embeddings.</li>
<li>Return the most similar pages to the user</li>
</ol>
<h2 id="embeddings-in-practice">Embeddings in practice</h2>
<p>At a small scale, you could store your embeddings in a CSV file, load them into Python, and use a library like <code>numPy</code> to calculated similarity between them using something like cosine distance or dot product. OpenAI has a cookbook <a href="https://github.com/openai/openai-cookbook/blob/main/examples/Semantic_text_search_using_embeddings.ipynb">example</a> that does just that. Unfortunately this likely won&#39;t scale well:</p>
<ul>
<li>What if I need to store and search over a large number of documents and embeddings (more than can fit in memory)?</li>
<li>What if I want to create/update/delete embeddings dynamically?</li>
<li>What if I&#39;m not using Python?</li>
</ul>
<h3 id="using-postgresql">Using PostgreSQL</h3>
<p>Enter <a href="https://github.com/pgvector/pgvector"><code>pgvector</code></a>, an extension for PostgreSQL that allows you to both store and query vector embeddings within your database. Let&#39;s try it out.</p>
<p>First we&#39;ll enable the <strong>Vector</strong> extension. In Supabase, this can be done from the web portal through <code>Database</code> → <code>Extensions</code>. You can also do this in SQL by running:</p>

<p>Next let&#39;s create a table to store our documents and their embeddings:</p>

<p><code>pgvector</code> introduces a new data type called <code>vector</code>. In the code above, we create a column named <code>embedding</code> with the <code>vector</code> data type. The size of the vector defines how many dimensions the vector holds. OpenAI&#39;s <code>text-embedding-ada-002</code> model outputs 1536 dimensions, so we will use that for our vector size.</p>
<p>We also create a <code>text</code> column named <code>content</code> to store the original document text that produced this embedding. Depending on your use case, you might just store a reference (URL or foreign key) to a document here instead.</p>
<p>Soon we&#39;re going to need to perform a similarity search over these embeddings. Let&#39;s create a function to do that:</p>

<p><code>pgvector</code> introduces 3 new operators that can be used to calculate similarity:</p>
<table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td><code>&lt;-&gt;</code></td><td>Euclidean distance</td></tr><tr><td><code>&lt;#&gt;</code></td><td>negative inner product</td></tr><tr><td><code>&lt;=&gt;</code></td><td>cosine distance</td></tr></tbody></table>
<p>OpenAI recommends cosine similarity on their embeddings, so we will use that here.</p>
<p>Now we can call <code>match_documents()</code>, pass in our embedding, similarity threshold, and match count, and we&#39;ll get a list of all documents that match. And since this is all managed by Postgres, our application code becomes very simple.</p>
<h3 id="indexing">Indexing</h3>
<p>Once your table starts to grow with embeddings, you will likely want to add an index to speed up queries. Vector indexes are particularly important when you&#39;re ordering results because vectors are not grouped by similarity, so finding the closest by sequential scan is a resource-intensive operation.</p>
<p>Each distance operator requires a different type of index. We expect to order by cosine distance, so we need <code>vector_cosine_ops</code> index. A good starting number of lists is 4 * sqrt(table_rows):</p>

<p>You can read more about indexing on <code>pgvector</code>&#39;s GitHub page <a href="https://github.com/pgvector/pgvector#indexing">here</a>.</p>
<h3 id="generating-embeddings">Generating embeddings</h3>
<p>Let&#39;s use JavaScript to generate embeddings and store them in Postgres:</p>

<h3 id="building-a-simple-search-function">Building a simple search function</h3>
<p>Finally, let&#39;s create an <a href="https://supabase.com/docs/guides/functions">Edge Function</a> to perform our similarity search:</p>

<h3 id="building-a-smarter-search-function">Building a smarter search function</h3>
<p>ChatGPT doesn&#39;t just return existing documents. It&#39;s able to assimilate a variety of information into a single, cohesive answer. To do this, we need to provide GPT with some relevant documents, and a prompt that it can use to formulate this answer.</p>
<p>One of the biggest challenges of OpenAI&#39;s <code>text-davinci-003</code> <a href="https://beta.openai.com/docs/guides/completion">completion model</a> is the 4000 token limit. You must fit both your prompt and the resulting completion within the 4000 tokens. This makes it challenging if you wanted to prompt GPT-3 to answer questions about your own custom knowledge base that would never fit in a single prompt.</p>
<p>Embeddings can help solve this by splitting your prompts into a two-phased process:</p>
<ol>
<li>Query your embedding database for the most relevant documents related to the question</li>
<li>Inject these documents as context for GPT-3 to reference in its answer</li>
</ol>
<p>Here&#39;s another Edge Function that expands upon the simple example above:</p>

<h3 id="streaming-results">Streaming results</h3>
<p>OpenAI API responses take longer to depending on the length of the “answer”. ChatGPT has a nice UX for this by streaming the response to the user immediately. You can see a similar effect for the Supabase docs:</p>
<video width="99%" controls=""><source src="/images/blog/embeddings/embeddings.mp4" type="video/mp4"/></video>
<p>The OpenAI API supports <a href="https://platform.openai.com/docs/api-reference/completions/create#completions/create-stream">completion streaming</a> with Server Side Events. Supabase Edge Functions are run Deno, which also supports <a href="https://deno.com/blog/deploy-streams#server-sent-events">Server Side Events</a>. Check out <a href="https://github.com/supabase/supabase/pull/12056/commits/bd83e9ba2f7263440888228e3b29007604d94841">this commit</a> to see how we modified the Function above to build a streaming interface.</p>
<h2 id="wrap-up">Wrap up</h2>
<p>Storing embeddings in Postgres opens a world of possibilities. You can combine your search function with telemetry functions, add an user-provided feedback (thumbs up/down), and make your search feel more integrated with your products.</p>
<p>Tomorrow we&#39;ll be releasing our own version of this interface in the Supabase docs, to provide Supabase-specific answers.</p>
<p>The pgvector extension is available on all new Supabase projects today. If you want to try it out, launch a new Postgres database today: <a href="https://database.new">database.new</a></p></div></article></div>
  </body>
</html>
