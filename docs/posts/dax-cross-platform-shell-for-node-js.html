<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://david.deno.dev/posts/dax-node-js/">Original</a>
    <h1>Dax â€“ Cross-platform shell for Node.js</h1>
    
    <div id="readability-page-1" class="page"><article>
  

  <div>
    <p>In <a href="https://david.deno.dev/posts/dax">July 2022</a>, I released <a href="https://github.com/dsherret/dax">dax</a>
for <a href="https://github.com/denoland/deno">Deno</a> providing a cross-platform shell
for JavaScript written in JavaScript:</p>
<pre><code><span>const</span> data = $.<span>path</span>(<span>&#34;data.json&#34;</span>).<span>readJsonSync</span>();
<span>await</span> $<span>`git add . &amp;&amp; git commit -m &#34;Release <span>${data.version}</span>&#34;`</span>;
</code></pre>
<p>This is similar and inspired by <a href="https://github.com/google/zx">zx</a>, but because
it uses a cross-platform shell with common built-in cross-platform commands,
more code is going to work the same way on different operating systems.</p>
<p>Initially, I wrote dax for Deno because Deno is by far the best JavaScript
runtime for single file scriptingâ€”all dependencies can be expressed in the
script file itself including npm dependencies; there&#39;s no <code>node_modules</code> folder
(less clutter), and no separate install command necessary.</p>
<p>Once written, dax used APIs that only worked on Deno and creating a Node.js
distribution was a decent amount of work.</p>
<p>Nowadays, Node.js has improved in its support for Web APIs and improvements to
<a href="https://github.com/denoland/dnt">dnt</a> (a tool I created for building Deno
modules for Node) have made maintaining a Node.js distribution much easier.</p>
<p>Due to this, I&#39;m happy to say that dax is now available on npm for users of
Node.js:</p>
<pre><code>
<span>import</span> $ <span>from</span> <span>&#34;dax-sh&#34;</span>;

<span>await</span> $<span>`echo &#39;Hello from dax!&#39;`</span>;
</code></pre>
<pre><code><span>$ </span><span>npm install --save-dev dax-sh</span>
<span>$ </span><span>node example.mjs</span>
Hello from dax!
<span>$ </span><span>time node example.mjs</span>
Hello from dax!
node example.mjs 0.08s user 0.01 system 98% cpu 0.090 total
</code></pre>
<p>You can check out dax&#39;s documentation here for more details:</p>
<p><a href="https://github.com/dsherret/dax">https://github.com/dsherret/dax</a></p>
<h2 id="a-long-aside%3A-build-dax-into-deno%3F" tabindex="-1"><a href="#a-long-aside%3A-build-dax-into-deno%3F">A long aside: build dax into Deno?</a></h2>
<p>Part of what kicked off my desire to create a Node.js distribution for dax was
the release of <a href="https://bun.sh/blog/the-bun-shell" rel="nofollow">Bun&#39;s
shell</a>, which
<a href="https://github.com/oven-sh/bun/blob/b433beb016470b87850f3c018974de5f2e355d52/docs/runtime/shell.md?plain=1#L359" rel="nofollow">credits
dax</a> as a source of inspiration.</p>
<p>This led to requests for dax to be baked into Deno&#39;s runtime.</p>
<p>
  <img src="https://david.deno.dev/posts/dax-node-js/dax-runtime.png" alt="Discord message saying: &#39;Hope this means dax gets introduced into the runtime, you love to see it&#39;"/>
</p>
<p>In my opinion, this would be a step backwards for dax and not a good long term
decision for Deno.</p>
<p>I want to explain why I think this and it would be interesting to hear your
feedback. Note these are my personal opinions and not the opinions of the Deno
team (which I&#39;m a member, but dax is a personal project I work on in my personal
time).</p>
<h3 id="runtime-coupling" tabindex="-1"><a href="#runtime-coupling">Runtime coupling</a></h3>
<p>Coupling a complex API like dax to the runtime means you can no longer upgrade
them independently. Being able to depend on a specific version of dax and a
specific version of your runtime is a massive benefit. It means you can freely
upgrade your runtime version and the code using dax will mostly likely keep
working tooâ€”the chance of encountering a new dax bug while upgrading your
runtime is very low because they&#39;re decoupled.</p>
<p>Additionally, it also means when you upgrade your runtime, you don&#39;t need to
also upgrade all your dax code at the same time in case there&#39;s a breaking
change.</p>
<p>It also means you likely don&#39;t need to tell people to use a certain version of
Deno in order to get the latest dax features (&#34;hey, why doesn&#39;t this work? Oh,
that dax feature is only in Deno version x.x.x&#34;). Instead, the code specifies
the dax version it depends on so when you execute it, it likely works or dax can
provide specific error messages for the runtime when not.</p>
<h3 id="vendor-lock-in" tabindex="-1"><a href="#vendor-lock-in">Vendor Lock-in</a></h3>
<p>Being able to use the same API in different runtimes is a massive benefit. It
lowers vendor lock-in risk and lowers the complexity when working with multiple
runtimes because the APIs you&#39;re using are the same. It also means when the next
great runtime comes around you&#39;re not locked in with all this code depending on
a specific runtime (or a specific version of a specific runtime ðŸ˜±).</p>
<p>When dax is published as a library, you can switch runtimes and still depend on
the same version of dax.</p>
<h3 id="scope" tabindex="-1"><a href="#scope">Scope</a></h3>
<p>Dax is not only a shell, but a collection shell tools. It&#39;s a swiss army knife
that provides opinionated ways of doing common tasks you need to do in
automation scripts. It has APIs for...</p>
<ol>
<li>progress and selection,</li>
<li>making URL requests,</li>
<li>logging,</li>
<li>dealing with paths,</li>
<li>and in the future, CLI argument parsing and work caching.</li>
</ol>
<p>All these APIs work together with each other and the shell. They&#39;re opinionated
for simplicity. Baking opinionated APIs into a runtime wouldn&#39;t be a good idea
because people have different opinions and opinions change over time. In the
case of dax being a library, someone else can come along and improve on its API
or make something better in the future, at which point dax can become a relic
just like old JS frameworks.</p>
<p>One suggestion is to cut the scope of dax back to a shell only rather than a
collection of shell tools, but the shell is still quite large. For example, you
can build your own custom <code>$</code> to suite your needs and inject your own custom
shell commands written in JavaScript.</p>
<p>Cutting it back further to not include that and some other features is possible,
but the shell itself is still quite intricate and there&#39;s lots of tiny design
decisions that are better left to a library like dax to get wrong and then be
improved upon by a future library or future major version of dax. Also at a
certain point scope gets cut back enough that it starts becoming less useful.</p>
<h3 id="built-in-runtime-apis-should-be-permanent" tabindex="-1"><a href="#built-in-runtime-apis-should-be-permanent">Built-in runtime APIs should be permanent</a></h3>
<p>I&#39;m still slowly figuring out an appropriate API for dax. I don&#39;t believe
anything is going to change drastically, but making a mistake if it were a
built-in runtime API would be fatal. Built-in APIs and the decisions made should
ideally be permanent. When they&#39;re not permanent or get removed, that creates a
lot of headaches.</p>
<p>When it&#39;s in a library, it&#39;s behind a separately versioned API, so the chance of
your code not working with the runtime anymore is slim, and making breaking
changes in library that&#39;s behind a versioned API is much more manageable.</p>
<p>Imagine if a similar API to dax had been integrated into the runtime that made
the mistake of spawning the system shell because we hadn&#39;t thought to make it
cross platform yet? Image what other possibilities for this API we&#39;ll discover
in the future and be glad we can easily make the changes to improve it because
it exists as a library.</p>
<h3 id="performance%3F" tabindex="-1"><a href="#performance%3F">Performance?</a></h3>
<p>Part of the argument to integrate this API into the runtime is for performance,
but dax starts up in 90ms on my machine in Node.js and 70ms in Deno. It executes
commands almost as fast as using Deno&#39;s <code>Command</code> API (2ms slower on my
machine). Could it be faster? Probably... I haven&#39;t done any extensive
benchmarking on dax because I develop it in my free time around all the other
projects I do.</p>
<p>It&#39;s fast enough for my needs. You&#39;d definitely be able to show it being slower
than some native code in a hot loop, but generally automation scripts only
execute a handful of commands (maybe ~10 commands) and spend most of their time
waiting for long complex tasks to finish (for me, stuff like <code>cargo build</code>), so
gaining some milliseconds by it being built-in and native doesn&#39;t help much in
most real world scripts.</p>
<p>Plus being less productive writing automation scripts with a less featureful API
will use up far more of your time than the few milliseconds saved with it being
built-in, which won&#39;t even be meaningfully saved in most real world scenarios.</p>
<p>If we&#39;re optimizing for performance only, dax actually doesn&#39;t need to be
built-in and could go native using Deno&#39;s FFI support, but in my opinion
creating less portable less auditable code written in a language not as many
people understand to have a slightly better performance experience is a bad
trade.</p>
<h3 id="convenience-of-no-dependency%3F" tabindex="-1"><a href="#convenience-of-no-dependency%3F">Convenience of no dependency?</a></h3>
<p>I wouldn&#39;t categorize having no dependency as a convenience because the runtime
coupling I talked about in a previous section leads to inconvenience. Maybe it&#39;s
slightly annoying in Node.js because it requires adding `dax-sh`` to a
package.json and installing it, but in Deno you can just write:</p>
<pre><code><span>#!/usr/bin/env -S deno run -A</span>
<span>import</span> $ <span>from</span> <span>&#34;https://deno.land/x/dax/0.39.0/mod.ts&#34;</span>;

<span>await</span> $<span>`echo Hello`</span>;
</code></pre>
<p>Is writing that difficult? I don&#39;t believe so, and now my script has all the
information to know what version of dax to use or I can swap it out for a
similar dependency that has the API I like instead.</p>
<p>It&#39;s great in Deno because I don&#39;t even need to run a separate install scriptâ€”I
just run that script directly and it will use the version I specified. Of
course, I could use a bare specifier like <code>&#34;dax&#34;</code> by creating a deno.json with
an embedded <a href="https://github.com/WICG/import-maps">import map</a> to make
<code>import $ from &#34;dax&#34;;</code> work:</p>
<pre><code><span>{</span>
  <span>&#34;imports&#34;</span><span>:</span> <span>{</span>
    <span>&#34;dax&#34;</span><span>:</span> <span>&#34;https://deno.land/x/dax/0.39.0/mod.ts&#34;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<h3 id="jsr%3A%40deno%2Fshell%401%3F" tabindex="-1"><a href="#jsr%3A%40deno%2Fshell%401%3F"><code>jsr:@deno/shell@1</code>?</a></h3>
<p>Overall, I get the desire for having dax built-in, but I don&#39;t believe it&#39;s the
right long term decision. Perhaps if there&#39;s a desire for a shell only and not a
swiss army knife of automation scripts, then the core functionality in dax could
be extracted out to a simpler package on the upcoming
<a href="https://jsr.io">JSR registry</a> behind its own versioned API.</p>
<pre><code><span>import</span> $ <span>from</span> <span>&#34;jsr:@deno/shell@1&#34;</span>;

<span>await</span> $<span>`echo &#39;Hello there!&#39;`</span>;
</code></pre>
<p>Let me know if there&#39;s a desire for a less functional, more lightweight version
of dax like that and I&#39;ll look into making it happen.</p>
<p>Again, you can now install dax via <code>npm install --save-dev dax-sh</code> and use it in
Node.js. Read the documentation here:
<a href="https://github.com/dsherret/dax">https://github.com/dsherret/dax</a></p>

  </div>
</article></div>
  </body>
</html>
