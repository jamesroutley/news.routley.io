<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://projects.blender.org/blender/blender-addons/issues/91180">Original</a>
    <h1>Blender: Low-degree semi-structured splines for interactive modeling</h1>
    
    <div id="readability-page-1" class="page"><div><details open=""><summary>Table of Contents</summary></details><p>This is the second installment of <a target="_blank" rel="noopener noreferrer" href="https://heneli.dev/blog/fearless-tinkering-is-functional">Fearless Tinkering is Functional</a> and can be read standalone:</p><ol><li><a target="_blank" rel="noopener noreferrer" href="https://heneli.dev/blog/fearless-tinkering-is-functional">Fearless Tinkering is Functional</a></li><li>Fearless Tinkering with Nix üëà</li><li>Fearless Tinkering with Haskell</li><li>Fearless Tinkering is Algebraic</li><li>Fearless Functional Future</li></ol><h2 id="fearless-in-practice"><a href="#fearless-in-practice" aria-hidden="true" tabindex="-1"><span></span></a>Fearless in Practice</h2><hr/><blockquote><p>Beyond the right tool for the job, it is the right values for the job‚Ä¶ and then the right software for the values.</p><ul><li>Bryan Cantrill @ Node Summit 2017, <a target="_blank" rel="noopener noreferrer" href="https://vimeo.com/230142234">Platform as a Reflection of Values</a></li></ul></blockquote><p>Programmers make mistakes. As such, our tools should aspire not to punish us for unfamiliarity or occasional incorrectness. Too often, users stumble into a tool&#39;s legitimate accidental complexity, only to be chided for ‚Äúholding it wrong‚Äù as if they should feel guilty for letting the tool paint them into a corner. Of course, tools that overreact to surface considerations can be just as problematic. No one wants an overzealous tool that ‚Äúhelpfully‚Äù enacts what hasn‚Äôt been asked for. Instead, tools should focus on preventing unrecoverable choices from being made too casually or too late. When a situation calls for an action with serious implications, our tools should help us feel the weight of our request. Uniformly presenting every possibility will mislead users into thinking that every action is reasonable or fallible. Tools should immediately report suspected incorrectness. Discovering mistakes while constructing a new home is much less painful than making the same discoveries after a family has moved into it.</p><p>Approaches that meet each critique with an independent solution are prone to local maxima. Breakthroughs require recognition of the systemic complexities underpinning individual occurrences. Ideally, tools should proactively seek out their fundamental weaknesses rather than waiting to reactively patch ailments.<sup><a href="#user-content-fn-1" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-1">1</a></sup> Hence, selecting tools by their <strong>structural guarantees</strong> is about using one&#39;s <strong>values</strong> to elect the ways in which their software <em>can‚Äôt</em> go wrong.</p><p>In this and upcoming posts, I‚Äôll introduce several functional technologies and illustrate how their structural properties enable <strong>fearless tinkering</strong>. These alone won‚Äôt do functional ecosystems justice.<sup><a href="#user-content-fn-2" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-2">2</a></sup> Even amongst the tools mentioned, there are plenty of assurances I won&#39;t cover. Conversely, I won&#39;t spend much time on their structural deficiencies or notable footguns<sup><a href="#user-content-fn-3" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-3">3</a></sup>. Much more important than any specific technology are the ideas that underlie them. Calling out the need for safe approaches to common pain points will help future technologies incorporate the relevant structural guarantees.</p><h2 id="nix--nixos"><a href="#nix--nixos" aria-hidden="true" tabindex="-1"><span></span></a>Nix &amp; NixOS</h2><p>The entropy of modern software is staggering. Programs inside programs directing separate programs exist, with each layer containing its own digital metropolis. Whether it&#39;s the shear connectors in the bridges, building codes of the plumbing networks, or the newest floor plan atop a towering skyscraper, every software artifact reflects a choice made by someone somewhere. The feats of modern software could not be made if every virtual wheel needed reinventing. A global and communal project of shared decisions is harnessed to base, tweak, and publish new constructions.</p><p>Interacting with outside software remains a tremendous challenge despite how foundational accessing external developments is. Every piece of software has its own installation manual and distribution strategy. Attaining pre-built infrastructure or the materials to create one‚Äôs own means traversing complicated and intersecting digital supply chains. Brittle runbooks, non-reproducible scripts, and imperative packaging tools that freely step on each other‚Äôs work lead to uniquely broken and divergent systems. Fundamental issues like build-time variability, unspecified dependencies, and implicit mutation of shared libraries can turn one-off upgrades into intractable archeological treasure hunts. When stuck in dependency hell, a teammate voicing that some software ‚Äúworks on their machine‚Äù offers more dread than helpfulness.</p><p>Nix attempts to solve these problems by introducing a purely functional DevOps ecosystem. By representing all software components in an immutable graph, Nix can offer rich queries about one‚Äôs system and defang what were previously panic-inducing deployments. With a declarative language for reproducible system configurations, installing software simply becomes the act of writing a Nix expression that describes a target system with that package installed. This process is valid for applying parameter configurations, upgrades, uninstallations, patches, or any deployment action. Instead of divining sequential migration paths, developers and operators can focus solely on what they want their end system to look like. The evolution of traditional infrastructure is contrasted with Nix below.</p><h3 id="road-to-reproducibility"><a href="#road-to-reproducibility" aria-hidden="true" tabindex="-1"><span></span></a>Road to Reproducibility</h3><p>For many developers, infrastructure is an uncomfortable area. Whether it‚Äôs the state of a cluster on <code>us-east-1</code> or a <a target="_blank" rel="noopener noreferrer" href="https://utcc.utoronto.ca/~cks/space/blog/sysadmin/ReportConfigFileLocations">configuration</a> outside one‚Äôs project repository, reasoning about <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Action_at_a_distance_%28computer_programming%29">action at a distance</a> can be treacherous. Further, the stakes are often high when managing software deployments. A tangled web of mutual, implicit dependencies means modifying one‚Äôs system could lead to invalid and unrecoverable states. Tolerating a ‚Äúworking‚Äù yet unsatisfactory environment is frequently preferable to the risks of transitioning to something better. As experimentation with alternatives is difficult, iterating is normally restricted to when one‚Äôs hand is forced, or the alternative has already been intimately understood. Even the modern practice of automated upgrades for existing dependencies is <a target="_blank" rel="noopener noreferrer" href="https://arxiv.org/abs/2109.11921v1">fraught</a>. Tools for managing remote infrastructure tend to remain unfamiliar as the consequences of trying them out might yield an expensive <code>$CLOUD_PROVIDER</code> bill.</p><p>A horrible culmination of these frictions is found in operational firefighting. Operators are tasked with debugging a live system whose interface, tools, and symptoms are typically only practiced against when problems occur. Even in organizations with significant platform investments, the exploratory surface of test deployments rarely reflects the time and space pollution built up across all contributing local developer and remote production environments.</p><p>Application programming, in contrast, can give developers a sense of power and ease. Assuming a stable working environment, the behavior and outputs of a local program are far more observable. Equipped with a test harness, REPL, and breakpoints, an interactive view of one‚Äôs program, including local bindings and available operations, can be explored. An application programmer can wield static analyzers, linters, IDE feedback, and all their most familiar tools to iteratively coax their programs into the desired shape. The ultimate execution of their developments can be safely gated behind various evaluation stages like continuous integration, peer review, staging deployments, and quality assurance.</p><p>The extent to which work is disposable is the extent to which work is safe to do. While it may mean tremendous pain in the short term, application programmers can usually throw their hands up and start over from scratch when a local problem arises. If developers tie their local project repository into a knot, they can blow it away and pull down a fresh copy from version control. During development, application programmers regularly break their domain in ways that would be intolerable anywhere else. Though the behavior of real-world programs are inseparable from their execution environments, application programmers can approximate control over time and space by fixing their efforts against their own environment.</p><p>Can the boons of application programming extend to infrastructure? <em>Containers</em> and <em>Infrastructure as Code</em> (IaC) are frequently touted as solutions, yet their standard implementations fall short. Containers and microVMs offer <a target="_blank" rel="noopener noreferrer" href="https://fly.io/blog/sandboxing-and-workload-isolation/">various levels of isolation</a>; however, these &#34;encapsulated&#34; environments lack innate compositionality and reproducibility. Docker, for instance, is <a target="_blank" rel="noopener noreferrer" href="https://youtu.be/0uixRE8xlbY">&#34;repeatable, but not reproducible.&#34;</a> Delineating the steps for constructing an image and subsequently executing those steps won&#39;t guarantee a uniform result. At most, a <code>Dockerfile</code> in version control can be nominally linked to an image within a container registry. Although containers can mitigate configuration drift when the same image is employed, they don&#39;t ensure consistency when creating a new image or even rebuilding an existing one. The mutable nature of prevalent base images propels users onto unstable grounds and introduces numerous compliance issues. Even more troubling is the fact that standard auditing methods, such as container vulnerability scanners, are <a target="_blank" rel="noopener noreferrer" href="https://youtu.be/9weGi0csBZM">easily thwarted</a>. Containers merely shift around the complexities of imperativity rather than discharging them. Instead of &#34;works on my machine,&#34; containers settle for &#34;works with my image.&#34;</p><p>Similarly, IaC solutions that advertise themselves as &#34;immutable infrastructure&#34;, yet don&#39;t offer compositionality or reproducibility, leave a lot to be desired. These tools introduce an inconsistent experience, where environments are delivered declaratively but developed imperatively. Masking a leaky abstraction like mutation with a &#39;declarative&#39; interface obscures pathologies and undermines the original appeal: simplicity.</p><p>Meanwhile, Nix has developed to fill these gaps. Nix can fit neatly within existing infrastructure, letting engineers recover <a target="_blank" rel="noopener noreferrer" href="https://nixos.org/manual/nix/stable/language/index.html">compositionality</a> and <a target="_blank" rel="noopener noreferrer" href="https://r13y.com/">reproducibility</a> while using <a target="_blank" rel="noopener noreferrer" href="https://nix.dev/tutorials/nixos/build-and-deploy/deploying-nixos-using-terraform">IaC</a>, <a target="_blank" rel="noopener noreferrer" href="https://floxdev.com/blog/flox-and-containers">containers</a>, and other solutions. Nix can also subsume various existing tools with alternatives like NixOS, Home-Manager, Cachix, Hydra, and <code>deploy-rs</code>. This versatility allows Nix to be introduced piecemeal into projects and organizations.</p><h3 id="nix-a-minimal-primer"><a href="#nix-a-minimal-primer" aria-hidden="true" tabindex="-1"><span></span></a>Nix: A Minimal Primer</h3><blockquote><p>Move fast and save things.</p><ul><li>Mark Functorberg on immutability, probably</li></ul></blockquote><p>In the Nix language, everything is an expression. This includes Nix&#39;s central data structure, the <a target="_blank" rel="noopener noreferrer" href="https://zero-to-nix.com/concepts/derivations">derivation</a>. <strong>Derivations</strong> can be thought of as recipes for building software components. These recipes include stable references to the nested build plans of their direct dependencies. A crucial part of keeping Nix &#34;purely functional&#34; is the separation of evaluation and execution. This distinction is shown by the two steps that make up a Nix build:</p><ol><li><a target="_blank" rel="noopener noreferrer" href="https://comono.id/posts/2020-03-20-how-nix-instantiation-works/"><em><strong>Instantiation</strong></em></a> - pure evaluation of Nix expression for assembling a derivation</li><li><a target="_blank" rel="noopener noreferrer" href="https://zero-to-nix.com/concepts/realisation"><em><strong>Realisation</strong></em></a> - execution of derivation&#39;s instructions + addition of outputted component to the Nix Store</li></ol><p>The <strong>Nix Store</strong> is an append-only graph database that stores software components in the host&#39;s file system (typically under <code>/nix/store</code>). Every package, service, and configuration is stored in an immutable way, meaning it cannot be modified after creation. Instead, changes result in new component versions, leaving the previous ones intact.</p><p>The location of a component in the Nix Store is determined by the <a target="_blank" rel="noopener noreferrer" href="https://samwho.dev/hashing/">hash</a> of its derivation. As a derivation contains references to its exact inputs, Nix can ensure that a given component is built the same way every time. This property is called <em>input-addressable</em> and is how Nix works by default. For example, a <code>foo</code> component whose derivation hashes to <code>9fjirpbq</code> will be stored at <code>/nix/store/9fjirpbq-foo</code>. Any change to a transitive dependency in the Nix expression defining <code>foo</code> will result in a different derivation and, thus, a new component being written to the Nix Store (ex. <code>/nix/store/3wby0ym3-foo</code>).</p><p>The Nix literature defines <a target="_blank" rel="noopener noreferrer" href="https://books.google.ca/books?id=gP2kAAAACAAJ">&#34;correct deployments&#34;</a> as software deployments that &#34;given identical inputs, should behave the same on an end-user machine as on the developer machine.&#34; This is a useful albeit weaker notion of reproducibility than <a target="_blank" rel="noopener noreferrer" href="https://reproducible-builds.org/docs/definition/">bit-for-bit reproducibility</a>. While Nix can ensure builds are executed with the same steps and inputs, it can&#39;t guarantee a deterministic output if the underlying package requires being built with non-deterministic tooling. Rather than storing components by the hash of their build plan, support is progressing for storing components by the hash of their build outputs. This property is called <em>content-addressable</em> and enables reduced recompilation via <a target="_blank" rel="noopener noreferrer" href="https://www.microsoft.com/en-us/research/uploads/prod/2018/03/build-systems.pdf"><em>early cutoff</em></a>. For obvious reasons, bit-for-bit reproducibility is useful for content-addressable builds.</p><p>Nix offers a <a target="_blank" rel="noopener noreferrer" href="https://arxiv.org/abs/2004.05688">rich set of structural properties</a> and shares a lot in common with other Merkle structures like <code>git</code>. While useful on their own, Nix&#39;s properties provide more significant benefits together than the sum of their parts.</p><h3 id="fearless-environments"><a href="#fearless-environments" aria-hidden="true" tabindex="-1"><span></span></a>Fearless Environments</h3><blockquote><p>The <u>world</u> is all that is the case. A <u>computation</u> is any action taken by a programmable device. An <u>environment</u> is the set of all past and present worlds that a computation can observe. An <u>effect</u> is a computation that depends on or changes the program‚Äôs environment. We run programs to produce effects in the world around us.</p><ul><li>Patrick Thomson @ Strange Loop 2019, definitions from <a target="_blank" rel="noopener noreferrer" href="https://youtu.be/vfDazZfxlNs?t=145">&#34;Building Haskell Programs with Fused Effects&#34;</a></li></ul></blockquote><p>Nix&#39;s package manager is <em>transactional</em>. Package state is <em>isolated</em>, state transitions are <em>atomic</em>, and these state transitions are <em>consistent</em>. Builds are uniquely addressed, immutable, reproducibly resourced, and <a target="_blank" rel="noopener noreferrer" href="https://www.infoq.com/articles/configuration-management-with-nix/">always safe to interrupt, restart, or run in parallel.</a> As elaborated below, these essential properties form transactional boundaries within which programmers can fearlessly develop environments.</p><h4 id="atomic"><a href="#atomic" aria-hidden="true" tabindex="-1"><span></span></a>Atomic</h4><p>Whether installing a new package or upgrading one&#39;s system, changes through Nix happen all at once or not at all. Even if a deployment operation is interrupted, users are never left in a partially updated state. If a completed upgrade causes issues, one can immediately return to their previous configuration. As a result, iterating on one&#39;s environment can be done without commitment. Users can trial packages using <a target="_blank" rel="noopener noreferrer" href="https://nixos.org/manual/nix/stable/command-ref/nix-shell.html">ephemeral shells</a> that don&#39;t pollute their environments. Build-time dependencies and binaries for one-off commands can be pruned beyond their usage. The combination of rollbacks and version control lets one recreate their environment from any point in the past. If one no longer needs a component, they can confidently remove it without fear of changing their mind. This results in less package hoarding and more minimal configurations.</p><h4 id="isolated"><a href="#isolated" aria-hidden="true" tabindex="-1"><span></span></a>Isolated</h4><p>As each package is stored in a <em>unique</em> path, different versions or variants can coexist without conflict. Users can create and modify multiple developer environments for multiple projects without breaking one another. One could define a completely isolated developer environment for a project containing all tooling, like local commands, fully-configured editors, local databases, and more. Alternatively, one could factor general system configuration into a top-level repository, allowing other projects to inherit configurations while remaining explicit.</p><h4 id="immutable"><a href="#immutable" aria-hidden="true" tabindex="-1"><span></span></a>Immutable</h4><p>Nix uses top-level views called <a target="_blank" rel="noopener noreferrer" href="https://nixos.org/manual/nix/unstable/package-management/profiles.html">profiles</a> to present <em>immutable</em> environments to users. These views provide a native user experience through symlinks to store paths. For example, a user with a Python package in their profile can simply type <code>python</code> into their shell instead of a fully qualified path like <code>/nix/store/7fkcip5k-python3-3.11.3/bin/python</code>. While these top-level views exhibit a form of mutability, modifications can be reliably reverted. Changing a user&#39;s environment will result in a new Nix Store component that is then pointed to by the user&#39;s current view. Environments that share the same lineage are called &#39;generations&#39;, and can be &#39;rolled back&#39; using Nix&#39;s CLI to recover a previous profile.</p><h3 id="fearless-sharing"><a href="#fearless-sharing" aria-hidden="true" tabindex="-1"><span></span></a>Fearless Sharing</h3><blockquote><p>When you share code with the world, how are they supposed to build it? Are they sure that they are running the same code that you, the author and builder, intended for them to run?</p><p>As engineers, we would love for all these to be true: I show up in a README, it&#39;s one command to build the project, run it, and it&#39;s built in the exact same way that the developer intended. There&#39;s nothing hidden about the build process and I can see that it&#39;s repeatable. This is transparency and this is what open source is all about.</p><ul><li>Julien Urraca @ Open Source 101 2023, <a target="_blank" rel="noopener noreferrer" href="https://youtu.be/onBQhwuPOAc?t=231">&#34;From Nix to Docker - Everything You Need to Know About Polygot Package Management&#34;</a></li></ul></blockquote><p>The classic advice to &#34;look both ways before crossing&#34; is extremely applicable to software development. Most programmers are both producers <em>and</em> consumers of software. Without transparent views upstream and downstream, maintenance strategies are tricky and individualized. Untracked mutability creates a <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Anti-pattern#Big_ball_of_mud">big ball of mud</a> that rolls downstream and quickly grows out of control until explicitly confronted.</p><p>Sharing is intrinsic to Nix&#39;s programming model. Nix allows users to handle internal and external dependency relations in an explicit and uniform manner. Package users can be sure that package authors aren&#39;t implicitly offloading upstream problems onto them, while authors can expect the same of their dependencies. As identically-built artifacts appear in identical locations, the sum cost of immutability is negligible. These properties enable programmers to fearlessly contribute, distribute, and inherit software.</p><h4 id="transparent"><a href="#transparent" aria-hidden="true" tabindex="-1"><span></span></a>Transparent</h4><p>Open source is critical to most commercial software. As such, supply chain security is an increasingly prevalent concern. Across 1,703 commercial codebases scanned in Synopsys&#39; <a target="_blank" rel="noopener noreferrer" href="https://www.synopsys.com/content/dam/synopsys/sig-assets/reports/rep-ossra-2023.pdf">2023 OSSRA Report</a>:</p><ul><li>76% of code in codebases came from open source</li><li>54% of codebases had license conflicts</li><li>89% of codebases contained open-source code more than four years out-of-date</li><li>48% of codebases contained high-risk vulnerabilities<sup><a href="#user-content-fn-4" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-4">4</a></sup></li></ul><p>It is clear that programmers need better tools for safely working with external software. Programmers need to be able to easily audit their supply chain and get actionable feedback without relying on specialized security researchers. Nix is no silver bullet, but it does provide supply chain transparency. Every artifact in a Nix environment has a traceable origin, a property otherwise known as <a target="_blank" rel="noopener noreferrer" href="https://zero-to-nix.com/concepts/provenance"><em>provenance</em></a>. Fixed-output derivations, or <a target="_blank" rel="noopener noreferrer" href="https://bmcgee.ie/posts/2023/02/nix-what-are-fixed-output-derivations-and-why-use-them/">FODS</a>, make fetching software over the internet more secure by requiring that the received contents have a matching hash to that of the expected contents.</p><h4 id="mutual"><a href="#mutual" aria-hidden="true" tabindex="-1"><span></span></a>Mutual</h4><p><a target="_blank" rel="noopener noreferrer" href="https://zero-to-nix.com/concepts/reproducibility"><em>Reproducibility</em></a> enables the reliable distribution of Nix-based infrastructure. Nix enables <a target="_blank" rel="noopener noreferrer" href="https://www.microsoft.com/en-us/research/uploads/prod/2018/03/build-systems.pdf"><em>cloud builds</em></a>, meaning that native builds are amortized across machines. Whether from <a target="_blank" rel="noopener noreferrer" href="https://search.nixos.org/packages">Nixpkgs</a>, a CI server, or a developer machine, packages can be built once and shared anywhere. Nix can recover sharing benefits within an infrastructure that isn&#39;t Nix-based, like with <a target="_blank" rel="noopener noreferrer" href="https://grahamc.com/blog/nix-and-layered-docker-images/">optimally-layered docker images</a> and <a target="_blank" rel="noopener noreferrer" href="https://nix-bazel.build/">system-pinned Bazel builds</a>. Additionally, Nix has <a target="_blank" rel="noopener noreferrer" href="https://nix.dev/tutorials/cross-compilation#cross-compilation">world-class support for cross-compilation</a>.</p><p>With Nix, code sharing extends beyond the mere transfer of source files. Environments are authenticated by their derivations and encompass the entire context within which the code is intended to run. Nix ensures <a target="_blank" rel="noopener noreferrer" href="https://zero-to-nix.com/concepts/hermeticity"><em>hermetic</em></a> and <a target="_blank" rel="noopener noreferrer" href="https://zero-to-nix.com/concepts/reproducibility"><em>reproducible</em></a> build inputs through <em>input-addressable</em> storage. Support for <em>content-addressable</em> storage in the future will make components self-authenticating and enable greater de-duplication.</p><p>Building from source provides greater trustworthiness, availability, and configurability while incurring greater retrieval, compute, and storage costs. Binary caches are cheaper by comparison but require users that only need what&#39;s available. The reproducibility of Nix allows it to blend source and binary deployment models&#39; best aspects while dodging their respective drawbacks.</p><h4 id="persistent"><a href="#persistent" aria-hidden="true" tabindex="-1"><span></span></a>Persistent</h4><p>Nix&#39;s <a target="_blank" rel="noopener noreferrer" href="https://www.cambridge.org/core/books/purely-functional-data-structures/0409255DA1B48FA731859AC72E34D494"><em>persistent</em></a> data model allows components to safely and efficiently share dependencies. When multiple local projects require an identically-built executable, Nix will know to never unnecessarily rebuild or redownload it across projects. As the shared executable is protected within an <em>immutable</em> component store, any changes to a project containing the mutual dependency won&#39;t affect the others. Packages can be shared, modified, and upgraded, all without risk of conflict or interference.</p><h3 id="supplementary-examples"><a href="#supplementary-examples" aria-hidden="true" tabindex="-1"><span></span></a>Supplementary Examples</h3><details><summary>Package Management</summary><p>The preferred method for installing packages with Nix is <a target="_blank" rel="noopener noreferrer" href="https://github.com/hkailahi/dotnix/blob/c59b2e2654f8a84cab1ac59ab72e991ffe84ca70/home.nix#L20">declaratively with a configuration file</a>. This can be done at the project-level or globally within a system configuration file.</p><p>For example, let&#39;s say I needed to install <a target="_blank" rel="noopener noreferrer" href="https://search.nixos.org/packages?channel=23.05&amp;show=firefox&amp;from=0&amp;size=50&amp;sort=relevance&amp;type=packages&amp;query=firefox"><code>firefox</code></a> and upgrade my global <a target="_blank" rel="noopener noreferrer" href="https://search.nixos.org/packages?channel=23.05&amp;show=python311&amp;from=0&amp;size=50&amp;sort=relevance&amp;type=packages&amp;query=python311"><code>python</code></a> installation. Regardless of whether my system configuration was specified with <a target="_blank" rel="noopener noreferrer" href="https://nixos.org/manual/nixos/stable/#sec-declarative-package-mgmt">NixOS</a>, <a target="_blank" rel="noopener noreferrer" href="https://nix-community.github.io/home-manager/index.html#sec-usage-configuration">Home-Manager</a>, or <a target="_blank" rel="noopener noreferrer" href="https://daiderd.com/nix-darwin/">Nix-Darwin</a>, the corresponding configuration change would look something like:</p><div><pre><code><span><span><span> </span><span>   environment.systemPackages = with pkgs; [
</span></span></span><span><span><span></span></span><span><span>-</span><span>      python310
</span></span></span><span><span><span></span></span><span><span>+</span><span>      python311
</span></span></span><span><span><span></span><span>+</span><span>      firefox
</span></span></span><span><span><span></span></span><span><span> </span><span>   ];
</span></span></span></code></pre></div><p>You can check out the <a target="_blank" rel="noopener noreferrer" href="https://github.com/hkailahi/dotnix/tree/main">system configuration for my 2019 MacBook Pro</a> on Github along with <a target="_blank" rel="noopener noreferrer" href="https://github.com/search?q=dotfiles+language%3ANix&amp;type=repositories&amp;l=Nix">countless others</a>.</p></details></div></div>
  </body>
</html>
