<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://marma.dev/articles/2025/under-the-hood-vec-t">Original</a>
    <h1>Vec&lt;T&gt;</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p>TL;DR</p><p>We explore the internal structure of Rust&#39;s <code>Vec&lt;T&gt;</code>, expecting to find simple <code>ptr</code>, <code>len</code>, and <code>capacity</code> fields. Instead, we uncover a series of nested types, each adding a layer of safety and abstraction on top of a raw pointer (<code>*const u8</code>). This deep dive reveals that Vec is built from components like <code>NonNull</code>, <code>RawVec</code> and others (which we explain layer by layer) to form the safe, user-friendly API that we love.</p></div><p>As I was reading the Rust API documentation for <a target="_blank" rel="noopener noreferrer" href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html">std::vec::Vec</a>, something interesting caught my eye in the <code>Vec</code> struct definition.</p><div><pre><code><span><span>pub</span> <span>struct</span> <span>Vec</span><span>&lt;</span><span>T</span><span>,</span> <span>A</span> <span>=</span> <span>Global</span><span>&gt;</span>
</span><span><span>where</span>
</span><span>    <span>A</span><span>:</span> <span>Allocator</span><span>,</span>
</span><span>    <span>{</span>  <span>}</span>
</span></code></pre></div><p>I am looking at you <code>{ /* private fields */ }</code> ! <em>&#34;What are you trying to hide from me?&#34;</em> I thought. Was I being sucked into a grand conspiracy? The documentation gives no hints as to what these fields are other than giving us a visual representation of the data structure:</p><div><pre><code><span>            ptr      len  capacity
</span><span>       +--------+--------+--------+
</span><span>       | 0x0123 |      2 |      4 |
</span><span>       +--------+--------+--------+
</span><span>            |
</span><span>            v
</span><span>Heap   +--------+--------+--------+--------+
</span><span>       |    &#39;a&#39; |    &#39;b&#39; | uninit | uninit |
</span><span>       +--------+--------+--------+--------+
</span></code></pre></div><p>Surely we will find that our <code>Vec</code> has three fields <code>ptr</code> <code>len</code> and <code>capacity</code>. But to be sure we have to go straight to the source. Are you ready to come with me down the rabbit hole and see if we can uncover an age-old mystery?</p><p>Diving into the struct definition of <code>Vec</code> in <code>std::vec</code> this is what we find:</p><div><pre><code><span><span>pub</span> <span>struct</span> <span>Vec</span><span>&lt;</span><span>T</span><span>,</span> <span>A</span><span>:</span> <span>Allocator</span> <span>=</span> <span>Global</span><span>&gt;</span> <span>{</span>
</span><span>   buf<span>:</span> <span>RawVec</span><span>&lt;</span><span>T</span><span>,</span> <span>A</span><span>&gt;</span><span>,</span>
</span><span>   len<span>:</span> <span>usize</span><span>,</span>
</span><span><span>}</span>
</span></code></pre></div><div dir="auto"><p dir="auto"><svg viewBox="0 0 16 16" aria-hidden="true" height="16" width="16"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>NOTE</p><p>We will be ignoring the <code>Allocator</code> type entirely. This is a topic worth of its own article.</p></div><p>Yay, we have <code>len</code>! Okay... that was easy. Now we only need <code>ptr</code> and <code>capacity</code>. We might be home very early, right?</p><p><em>&#34;What is this misterious <code>RawVec&lt;T, A&gt;</code>?&#34;</em> you rightly ask yourself and where the hell is the <code>ptr</code> and the <code>capacity</code>? Well, let&#39;s follow the breadcrumbs!</p><p>If we type <code>RawVec</code> into the search field of the Rust API documentation we find... nothing!?</p><p>Okay, okay... stay calm, don&#39;t stress it! Let&#39;s take a deep breath and look at the source code:</p><div><pre><code><span><span>pub</span><span>(</span><span>crate</span><span>)</span> <span>struct</span> <span>RawVec</span><span>&lt;</span><span>T</span><span>,</span> <span>A</span><span>:</span> <span>Allocator</span> <span>=</span> <span>Global</span><span>&gt;</span> <span>{</span>
</span><span>    inner<span>:</span> <span>RawVecInner</span><span>&lt;</span><span>A</span><span>&gt;</span><span>,</span>
</span><span>    _marker<span>:</span> <span>PhantomData</span><span>&lt;</span><span>T</span><span>&gt;</span><span>,</span>
</span><span><span>}</span>
</span></code></pre></div><p>Ah, so that&#39;s why we can&#39;t find it in the documentation, it is only public within its crate <code>pub(crate)</code> and not accessible from outside. Good, one mistery solved but what in the world is the <code>RawVecInner&lt;A&gt;</code> type now and what is <code>PhantomData&lt;T&gt;</code><sup><a href="#user-content-fn-1" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-1">1</a></sup>!? How deep does this rabbit hole go?</p><p>Looking at <code>RawVecInner&lt;A&gt;</code> we get a clearer picture:</p><div><pre><code><span><span>struct</span> <span>RawVecInner</span><span>&lt;</span><span>A</span><span>:</span> <span>Allocator</span> <span>=</span> <span>Global</span><span>&gt;</span> <span>{</span>
</span><span>    ptr<span>:</span> <span>Unique</span><span>&lt;</span><span>u8</span><span>&gt;</span><span>,</span>
</span><span>    cap<span>:</span> <span>Cap</span><span>,</span>
</span><span>    alloc<span>:</span> <span>A</span><span>,</span>
</span><span><span>}</span>
</span></code></pre></div><p>Haha, no, we don&#39;t... Well at least somewhat. We finally found our lost <code>ptr</code> and <code>cap</code>acity! But both of them are defined by new types. We&#39;re three layers deep now, with no end in sight. But we&#39;ve come this far we&#39;re not stopping now, are we?</p><div dir="auto"><p dir="auto"><svg viewBox="0 0 16 16" aria-hidden="true" height="16" width="16"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>NOTE</p><p><code>Cap</code> is just a type which manages its min and max bounds so we won&#39;t go deep into this one. But you can check it out <a target="_blank" rel="noopener noreferrer" href="https://github.com/rust-lang/rust/blob/2ebb1263e3506412889410b567fa813ca3cb5c63/library/alloc/src/raw_vec/mod.rs#L40">here</a> and <a target="_blank" rel="noopener noreferrer" href="https://github.com/rust-lang/rust/blob/2ebb1263e3506412889410b567fa813ca3cb5c63/library/core/src/num/niche_types.rs#L140">here</a></p></div><p>So what is <code>Unique&lt;u8&gt;</code>?</p><div><pre><code><span><span>pub</span> <span>struct</span> <span>Unique</span><span>&lt;</span><span>T</span><span>:</span> <span>PointeeSized</span><span>&gt;</span> <span>{</span>
</span><span>    pointer<span>:</span> <span>NonNull</span><span>&lt;</span><span>T</span><span>&gt;</span><span>,</span>
</span><span>    _marker<span>:</span> <span>PhantomData</span><span>&lt;</span><span>T</span><span>&gt;</span><span>,</span>
</span><span><span>}</span>
</span></code></pre></div><p>No surprises here, just another wrapper Type <code>NonNull&lt;T&gt;</code>.</p><div><pre><code><span><span>pub</span> <span>struct</span> <span>NonNull</span><span>&lt;</span><span>T</span><span>:</span> <span>PointeeSized</span><span>&gt;</span> <span>{</span>
</span><span>    pointer<span>:</span> <span>*</span><span>const</span> <span>T</span><span>,</span>
</span><span><span>}</span>
</span></code></pre></div><p>Wait?! Are we done? I think we are! Hallelujah, we now have a broad overview of the whole <code>Vec</code> stack! Let&#39;s try to unravel it&#39;s secrets, shall we?</p><h2 id="understanding-vecs-layers">Understanding vecs layers<a href="#understanding-vecs-layers" aria-hidden="true" tabindex="-1"></a></h2><p>Our journey looked something like this:</p><ul><li><code>Vec&lt;T&gt;</code> holds a...</li><li><code>RawVec&lt;T&gt;</code> which holds a...</li><li><code>RawVecInner</code> which holds a...</li><li><code>Unique&lt;u8&gt;</code> which holds a...</li><li><code>NonNull&lt;u8&gt;</code> which holds a...</li><li><code>*const u8</code> (a raw pointer)</li></ul><p>Phew, a lot of abstractions. But what does this tell us? To understand why the engineering team behind the standard library chose to go this route we first need to learn each layers purpose. We will start at the bottom and climb our way up until we reach the top of our <code>Vec&lt;Mountain&gt;</code>!</p><p>We start at the very bottom, our foundation is our constant basecamp which defines our entire structure: <a target="_blank" rel="noopener noreferrer" href="https://doc.rust-lang.org/std/primitive.pointer.html">*const u8</a>.</p><p><span>This is the most primitive way to refer to a location in memory</span> and is also called a raw pointer. It is just plain memory address, a number. The official documentation tells us it&#39;s a risky tool since it can be null, dangle, or be unaligned. It doesn&#39;t have any lifetime information, so the compiler can&#39;t know if the data it points to is still valid.</p><p>Using it requires stepping into an unsafe block, telling the compiler, <em>&#34;I know what I&#39;m doing.&#34;</em> It&#39;s the necessary starting point because, to manage memory, you must first be able to talk about memory addresses directly.</p><div dir="auto"><p dir="auto"><svg viewBox="0 0 16 16" aria-hidden="true" height="16" width="16"><path d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z"></path></svg>GOOD TO KNOW</p><p>A good question was asked in the <a target="_blank" rel="noopener noreferrer" href="https://www.reddit.com/r/rust/comments/1nlw8u0/comment/nf8jobd/?utm_source=share&amp;utm_medium=web3x&amp;utm_name=web3xcss&amp;utm_term=1&amp;utm_content=share_button">Reddit thread for this post</a> where a user <em>(u/Anaxamander57)</em> asked <em>&#39;why is the pointer u8?&#39;</em> since pointers in Rust are based on usize.</p><p>The answer is: Yes, the value of a pointer (the adress) is based on usize but the pointer points to a single byte (u8) in memory (the starting point of the data). In fact these are &#39;type erased&#39; bytes (thank you <em>u/Hy-o-pye)</em>.</p><p>Why type-erased? Because at this level we do not care about the type of the data. It is just a growable buffer of memory.</p></div><p>The first step in adding security in our ascension is to make sure we have all our necessary tools at hand! So we check our tool belt and see if it is <a target="_blank" rel="noopener noreferrer" href="https://github.com/rust-lang/rust/blob/f13ef0d75d834c826c9479a5d244bcfb9891df45/library/core/src/ptr/non_null.rs#L12">NonNull&lt;u8&gt;</a>.</p><p>A simple but incredibly important wrapper that now secures our <code>*const u8</code> and provides one crucial guarantee: <span>the pointer is never null</span>. Null pointers are the source of countless bugs and crashes in other languages (the infamous &#34;billion-dollar mistake&#34;). By encoding the non-null guarantee directly into the type system, Rust can eliminate this entire class of errors.</p><p>This also unlocks a fantastic compiler optimization. Since a <code>NonNull&lt;T&gt;</code> can never be null, the compiler knows it can use the 0 address to represent the None variant when it sees an <code>Option&lt;NonNull&lt;T&gt;&gt;</code>. This means <code>Option&lt;NonNull&lt;T&gt;&gt;</code> takes up the exact same amount of space as a regular raw pointer! It&#39;s the first step in building our safe abstraction which is also a zero-cost one at that.</p><p>Continuing our way up we come across a seemingly <a target="_blank" rel="noopener noreferrer" href="https://github.com/rust-lang/rust/blob/f13ef0d75d834c826c9479a5d244bcfb9891df45/library/core/src/ptr/unique.rs#L7">Unique&lt;u8&gt;</a> path (at least the sign is telling us so)... It looks very dangerous because it is sooooo slim. Only one Person can safely travel this path at a time!</p><p><code>Unique&lt;T&gt;</code> is a crucial (internal) building block that sits between raw pointers and safe abstractions like <code>RawVecInner&lt;A&gt;</code>. It builds on <code>NonNull</code> by adding a powerfull and very needed concept: <span>a signal of ownership</span>.</p><p>It is not a guard that enforces ownership rules but more of a sign held by a type like <code>RawVecInner&lt;A&gt;</code> to tell the compiler two things:</p><ul><li><em>&#34;I am the sole owner of the data this sign points to.&#34;</em></li><li><em>&#34;I am responsible for <code>Drop</code>ing that data when I go out of scope.&#34;</em></li></ul><p>What&#39;s interesting here is that you can create a <code>Unique&lt;T&gt;</code> pointer and another mutable reference pointing to the same data and the compiler won&#39;t complain!</p><p>MIND BLOWN! I know, right?! So why is that?</p><p>The creation of <code>Unique&lt;T&gt;</code> is safe because you cannot cause undefined behaviour just by creating it. The safety boundary is drawn at a different place, namely <em>while accessing the data</em>. The safety concern arises when we want to <em>use the value</em> the pointer points to.</p><p>When you want to use the pointer to read or write memory (<code>as_mut()</code> or <code>as_ref()</code>), you must enter an unsafe block. And from now on you are on your own :). Wild West baby!</p><p>You as the implementor need to make the following promise: <em>&#34;I know what I am doing and I guarantee that no other pointer is being used to access this memory.&#34;</em></p><p>By upholding this promise (with a little sweat and work) you get compile time guarantees in return (like borrow checking and data race prevention). It&#39;s a zero cost contract that makes Rust&#39;s memory safety possible.</p><p>After the engraving (why would we do this in the middle of a climb?!) we are out of breath and need help from the top. In order to send us down a rope, the helpful people at the top need to first ask for one.</p><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/rust-lang/rust/blob/f13ef0d75d834c826c9479a5d244bcfb9891df45/library/alloc/src/raw_vec/mod.rs#L51">RawVec&lt;T&gt;</a> is a &#34;low-level utility for managing a buffer of memory.&#34; <span>It&#39;s the component that actually talks to the memory allocator</span> by handling the allocation and asking the allocator for a block of memory on the heap, growing it when needed (usually by doubling the capacity), and, crucially, deallocating it when the Vec is dropped.</p><p>As we have learned already, this one only knows about the capacity (the total allocated space). It does not track how many elements are actually initialized and in use. This deliberate separation of concerns makes RawVec a perfect, reusable building block. Other collection types in the standard library that also need a growable buffer of memory, like <a target="_blank" rel="noopener noreferrer" href="https://github.com/rust-lang/rust/blob/7ad23f43a225546c095123de52cc07d8719f8e2b/library/alloc/src/collections/vec_deque/mod.rs#L101">VecDeque&lt;T&gt;</a>, can reuse this component instead of reinventing the wheel.</p><div dir="auto"><p dir="auto"><svg viewBox="0 0 16 16" aria-hidden="true" height="16" width="16"><path d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z"></path></svg>GOOD TO KNOW</p><p>Remember that <code>RawVecInner</code> type we saw? That&#39;s a clever compile-time optimization. By splitting the logic, the part that isn&#39;t generic over T (RawVecInner) doesn&#39;t get duplicated for every Vec&lt;T&gt; you create, which helps speed up compilation.</p></div><p>At last, we arrive at the <a target="_blank" rel="noopener noreferrer" href="https://github.com/rust-lang/rust/blob/f13ef0d75d834c826c9479a5d244bcfb9891df45/library/alloc/src/vec/mod.rs#L173">Vec&lt;Top&gt;</a>, time to plant some flags!</p><p>This is the one that brings everything together. It holds the RawVec (which manages the memory) and adds the final piece of information: <code>len</code>.</p><p><span>This acts as the public API that hides all the unsafe complexity</span> we&#39;ve just learned about. The Vec knows how many elements are initialized (len) within the allocated block (capacity). It&#39;s responsibility is to ensure that you can only access initialized elements. This gives us the safe methods we love to use every day: <code>push</code>, <code>pop</code>, <code>insert</code>, indexing, and so on.</p><p>Each level builds upon the last, adding new guarantees and responsibilities, until we have a completely safe, efficient, and powerful data structure.</p><p>Seems like my life remains somewhat uneventful. There is no big conspiracy and no hidden truth to be found... just very good engineering.</p><p>While we were digging deep to learn what <code>Vec&lt;T&gt;</code>&#39;s private fields are, we uncovered something very interesting: good API design. We saw how Rust&#39;s engineers built one of its most common types from the ground up, starting with an unsafe pointer and carefully wrapping it, layer by layer, until it&#39;s perfectly safe and ergonomic.</p><p>Every layer is crucial for <code>Vec</code>&#39;s contract to be fulfilled. It’s a testament to the power of abstraction and separation of concerns. The &#34;conspiracy&#34; was about managing complexity, allowing each piece of the puzzle to do one thing and do it well. And in doing so, it provides reusable types that power other parts of the standard library.</p><p>Maybe next time, when you push an element to a vector, you&#39;ll know about the stack of abstractions working under the hood to make it all happen safely and efficiently. And that, in itself, is a pretty cool secret to have uncovered.</p><p>Uncovering <code>Vec</code>&#39;s inner structure helped me a lot to understand a little more what happens behind the scene in the standard library.</p><p>Unfortunately we only touched on a fraction of the complex structure that forms <code>Vec</code> (but I hope enough, to have a better understanding). Explaining every little bit in detail would be too much for this post, so maybe there will be more <em>Under the hood</em> articles which explain Rust&#39;s inner life even better since obvious questions already arise while reading this article: &#34;How does <code>NonNull</code> guarantee its promise?&#34; or &#34;How does <code>RawVec</code> manage memory?&#34;</p><p>Each type we learned about in this article is worth its own post, including the ones we only briefly mentioned (<code>Allocator</code>, <code>PhantomData</code>), so I encourage everyone check these types out for themselves. Rust&#39;s documentation is phenomenal and with modern IDE features like <em>go to definition</em> you can easily jump back and forth until you get a clearer picture of the parts that form the public Rust API.</p></div></div></div>
  </body>
</html>
