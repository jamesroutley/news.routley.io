<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://adam.chlipala.net/mlcomp/">Original</a>
    <h1>Comparing Objective Caml and Standard ML</h1>
    
    <div id="readability-page-1" class="page"><div width="100%">

<tbody><tr>
<td></td>
<td></td>
</tr>

<tr><td colspan="2"><h2>Syntax</h2></td></tr>
<tr><td colspan="2">See <a href="http://www.mpi-sws.mpg.de/~rossberg/sml-vs-ocaml.html">this syntax comparison</a> for more details.</td></tr>
<tr><td colspan="2"></td></tr>

<tr><td colspan="2"><h3>Array/string shorthands</h3></td></tr>
<tr>
<td>Special syntactic sugar is defined for array and string accesses.</td>
<td>These operations receive no special treatment.</td>
</tr>
<tr>
<td><pre>let arr = [| 1; 2; 3 |];;
let two = arr.(1);;
arr.(2) &lt;- 6;;

let str = &#34;Hello&#34;;;
let e = str.[1];;</pre></td>
<td><pre>val arr = Array.fromList [1, 2, 3];
val two = Array.sub (arr, 1);
Array.update (arr, 2, 6);

val str = &#34;Hello&#34;;
val e = String.sub (str, 1);</pre></td>
</tr>
<tr>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/hardhat.png" width="53" height="99"/></td>
<td>Arrays and strings are central data structures of &#34;practical programming,&#34; so they should be as usable as we can make them.</td>
</tr></tbody></table>
</td>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/scientist.png" width="58" height="91"/></td>
<td>More syntactic sugar clutters the language definition. Arrays and strings show up infrequently in traditional functional programming applications, and many new ML programmers accustomed to array-based work could quite profitably switch to datatype-based solutions instead.</td>
</tr></tbody></table>
</td>
</tr>

<tr><td colspan="2"><h3>Character literals</h3></td></tr>
<tr>
<td>Uses <code>&#39;c&#39;</code></td>
<td>Uses <code>#&#34;c&#34;</code></td>
</tr>
<tr>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/hardhat.png" width="53" height="99"/></td>
<td>OCaml&#39;s syntax is shorter and follows the &#34;standard&#34; set by C.</td>
</tr></tbody></table>
</td>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/scientist.png" width="58" height="91"/></td>
<td>Apostrophes mean &#34;type variable&#34; or &#34;prime&#34; in SML and are parts of identifiers; they shouldn&#39;t be confused with character literals. Many symbolically-oriented SML programs don&#39;t manipulate individual characters, so we shouldn&#39;t complicate the lexer to support related features. (Consider <code>&#39;a&#39;</code>, which could be either a type variable or a character literal, depending on where it appers.)</td>
</tr></tbody></table>
</td>
</tr>

<tr><td colspan="2"><h3>Identifier conventions</h3></td></tr>
<tr>
<td><b>Module, module type, and constructor names must start in capital letters</b> and <b>other identifiers can&#39;t</b></td>
<td>No capitalization convention</td>
</tr>
<tr>
<td><pre>type myType =
    A
  | B;;

let f = function
    A&#39; -&gt; 0 (* A&#39; is signaled as an unbound constructor. *)
  | B -&gt; 1;;</pre></td>
<td><pre>datatype myType =
    a
  | b;

val f = fn
    a&#39; =&gt; 0 (* a&#39; is processed as a variable. *)
  | b =&gt; 1; (* This case is signaled as redundant. *)</pre></td>
</tr>
<tr>
<td>
This convention stops a very nasty class of pattern matching bugs involving confusion between variables and variant constructors. It also eases the tasks of text editor syntax highlighters, making it easy to distinguish between module and variable names by color, for example.
</td>
<td>
More flexibility can&#39;t hurt if you&#39;re careful, right? In actuality, most SML programmers with opinions would prefer the OCaml convention.
</td>
</tr>

<tr><td colspan="2"><h3>Let-binding syntax</h3></td></tr>
<tr>
<td>Separate <b>top-level <code>let</code></b> and <b><code>let</code> expressions</b></td>
<td>Syntactic class of <b>declarations</b> and <b><code>let..in..end</code> construct</b> for binding them</td>
</tr>
<tr>
<td><pre>let six = 6
let rec fact x = if x = 0 then 1 else x * fact (x - 1)

let six_fact =
  let six = 6 in
  let rec fact x = if x = 0 then 1 else x * fact (x - 1) in
  fact 6</pre></td>
<td><pre>val six = 6
fun fact x = if x = 0 then 1 else x * fact (x - 1)

val six_fact =
  let
    val six = 6
    fun fact x = if x = 0 then 1 else x * fact (x - 1)
  in
    fact 6
  end</pre></td>
</tr>
<tr>
<td>
In practice, this approach leads to some very confusing error messages, since the compiler is less able to predict what grouping you <i>really</i> intended.
</td>
<td>
Having a unified mechanism for top-level and local bindings leads to less duplication of functionality, and <tt>let..in..end</tt> seems empirically to lead to clearer error messages.
</td>
</tr>

<tr><td colspan="2"><h3>Overloaded &#34;minus&#34;</h3></td></tr>
<tr>
<td>The standard - symbol is used for <b>both negation and subtraction</b>.</td>
<td><b>Tilde (~) is used for negation</b>.</td>
</tr>
<tr>
<td><pre>1 - 2;;
1 + -2;;</pre></td>
<td><pre>1 - 2;
1 + ~2;</pre></td>
</tr>
<tr>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/hardhat.png" width="53" height="99"/></td>
<td>Lots of programmers would be confused by throwing over this long-standing convention.</td>
</tr></tbody></table>
</td>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/scientist.png" width="58" height="91"/></td>
<td>Differentiating subtraction and negation upholds the SML position that operators are just identifiers like any others that happen to be used via special syntax. Modulo the overloading of binary arithmetic operators, SML avoids situations where an identifier means different things in different contexts.</td>
</tr></tbody></table>
</td>
</tr>

<tr><td colspan="2"><h3>Semicolon precedence</h3></td></tr>
<tr>
<td>Semicolon binds <b>more tightly</b> than <code>match</code> bodies and anonymous functions</td>
<td>Semicolon binds <b>less tightly</b> than <code>case</code> bodies and anonymous functions</td>
</tr>
<tr>
<td><pre>match x with
    0 -&gt; print_endline &#34;It&#39;s zero!&#34;;
         true
  | _ -&gt; print_endline &#34;It&#39;s not!&#34;;
         false;;

fun s -&gt; print_string s; s;;

begin match x with
    0 -&gt; print_endline &#34;It&#39;s zero!&#34;
  | _ -&gt; print_endline &#34;It&#39;s not!&#34;
end;
print_endline &#34;The End&#34;;;
</pre></td>
<td><pre>case x of
    0 =&gt; (print &#34;It&#39;s zero!\n&#34;;
          true)
  | _ =&gt; (print &#34;It&#39;s not!\n&#34;;
          false);

fn s =&gt; (print s; s);

case x of
    0 =&gt; print &#34;It&#39;s zero!\n&#34;
  | _ =&gt; print &#34;It&#39;s not!\n&#34;;
print &#34;The End\n&#34;;</pre></td>
</tr>
<tr>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/hardhat.png" width="53" height="99"/></td>
<td>The OCaml precedence rules favor imperative code, expecting semicolons to be used as sequencers in many places.</td>
</tr></tbody></table>
</td>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/scientist.png" width="58" height="91"/></td>
<td>The SML precedence rules favor pure functional code, requiring parentheses around many places where semicolons might be used.</td>
</tr></tbody></table>
</td>
</tr>

<tr><td colspan="2"><h3>User-defined infix operators</h3></td></tr>
<tr>
<td><b>Fixed precedence rules</b> for infix operators; <b>curried</b> arguments</td>
<td><b>User-defined precedence rules</b> for infix operators; <b>tupled</b> arguments</td>
</tr>
<tr>
<td><pre>let (++) x y = x + y + y;;

1 ++ 2;;

List.map ((++) 1) [1; 2; 3]</pre></td>
<td><pre>fun op++ (x, y) = x + y + y;
infix 6 ++;

1 ++ 2;

map (fn x =&gt; 1 ++ x) [1, 2, 3]</pre></td>
</tr>
<tr>
<td>
There is never any doubt on seeing an OCaml program about how to parse an expression that includes infix operators. However, sometimes the inflexibility of precedences forces use of &#34;extra&#34; parentheses. Curried operators make it easy to use partial applications as arguments to higher-order functions.
</td>
<td>
User-specified precedences make it easier to implement nicer-looking embedded languages. However, <code>infix</code> declarations were never integrated well with the module system, meaning that client code can&#39;t import fixities from a library module.
</td>
</tr>

<tr><td colspan="2"><h2>Operators</h2></td></tr>

<tr><td colspan="2"><h3>Arithmetic operators</h3></td></tr>
<tr>
<td><b>Different operators</b> for arithmetic over different built-in numerical types</td>
<td><b>Overloaded operators</b> that handle several built-in numerical types</td>
</tr>
<tr>
<td><pre>let four_int = 2 + 2
let four_float = 2.0 +. 2.0</pre></td>
<td><pre>val four_int = 2 + 2
val four_float = 2.0 + 2.0</pre></td>
</tr>
<tr>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/scientist.png" width="58" height="91"/></td>
<td>Apparently following a &#34;<a href="http://en.wikipedia.org/wiki/Type_classes">principled overloading</a> or none at all&#34; philosophy, OCaml breaks with a convention found in most other languages.</td>
</tr></tbody></table>
</td>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/hardhat.png" width="53" height="99"/></td>
<td>SML overloads the arithmetic operators in an ad-hoc way. This has some unfortunate interactions with type inference, like inferring by default that a variable used in arithmetic has type <code>int</code>.</td>
</tr></tbody></table>
</td>
</tr>

<tr><td colspan="2"><h3>Equality</h3></td></tr>
<tr>
<td>Equality <b>works on any type</b> but may raise run-time exceptions.</td>
<td><b>Equality types</b> characterize valid equality arguments.</td>
</tr>
<tr>
<td><pre>let member (x : &#39;a) (ls : &#39;a list) : bool =
  List.exists ((=) x) ls;;

member 2 [1; 2; 3];;
member false [true; false; true];;
member (fun () -&gt; ()) [fun () -&gt; ()];; (* Exception *)</pre></td>
<td><pre>fun member (x : &#39;&#39;a) (ls : &#39;&#39;a list) : bool =
  List.exists (fn y =&gt; x = y) ls;

member 2 [1, 2, 3];
member false [true, false, true];
member (fn () =&gt; ()) [fn () =&gt; ()]; (* Type error *)</pre></td>
</tr>
<tr>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/hardhat.png" width="53" height="99"/></td>
<td>It&#39;s very convenient to be able to compare values for equality without having to track whether or not they&#39;re comparable, and the lack of equality types simplifies the language. However, run-time type errors on bad equality comparisons are no fun.</td>
</tr></tbody></table>
</td>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/scientist.png" width="58" height="91"/></td>
<td>With SML, it&#39;s clear at compile time that no equality operation will fail with a run-time type error, and the types of functions that use equality clearly state that fact, removing a need for informal documentation. SML equality types are often criticized as a special case of <a href="http://en.wikipedia.org/wiki/Type_classes">type classes</a> that ought to be replaced with that more general mechanism.</td>
</tr></tbody></table>
</td>
</tr>

<tr><td colspan="2"><h2>Standard libraries</h2></td></tr>

<tr><td colspan="2"><h3>Arrays vs. vectors</h3></td></tr>
<tr>
<td>A single array type family</td>
<td><b>Distinguishes between (imperative) arrays and (functional) vectors</b></td>
</tr>
<tr>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/hardhat.png" width="53" height="99"/></td>
<td>Programmers used to C and its ilk don&#39;t want to have to worry about whether or not their arrays are functional.</td>
</tr></tbody></table>
</td>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/scientist.png" width="58" height="91"/></td>
<td>Isolating impure behavior as much as possible is very helpful at making programs easy to understand. A function taking a vector as input is guaranteed not to &#34;change&#34; it, and the function&#39;s type broadcasts that fact.</td>
</tr></tbody></table>
</td>
</tr>

<tr><td colspan="2"><h3>Currying vs. tupling</h3></td></tr>
<tr>
<td>All standard library functions are <b>curried</b>.</td>
<td>Higher-order functions are usually curried, with <b>tupling</b> the default elsewhere.</td>
</tr>
<tr>
<td><pre>List.iter (output_string ch) [&#34;Hello&#34;; &#34; there!&#34;];;

List.iter (fun (ch, s) -&gt; output_string ch s) [(ch1, &#34;A&#34;); (ch2, &#34;B&#34;)];;</pre></td>
<td><pre>app (fn s =&gt; TextIO.output (ch, s)) [&#34;Hello&#34;, &#34; there!&#34;];

app TextIO.output [(ch1, &#34;A&#34;), (ch2, &#34;B&#34;)];</pre></td>
</tr>
<tr>
<td>
Currying makes it easy to pass partial applications as arguments to higher-order functions.
</td>
<td>
Tupling makes it easy to treat entire function argument lists as first-class values.
</td>
</tr>

<tr><td colspan="2"><h3>Exceptions vs. option types</h3></td></tr>
<tr>
<td>Most standard library functions indicate conditions like &#34;end of file&#34; by <b>throwing exceptions</b>.</td>
<td>Most standard library functions indicate conditions like &#34;end of file&#34; by <b>returning NONE</b>.</td>
</tr>
<tr>
<td>
Using exceptions provides uniformity with other uses of exceptions to signal more traditional &#34;error&#34; conditions. This choice also makes it easier to use multiple-return-status functions in situations where you know that they will encounter the common case.
</td>
<td>
Giving multiple-return-status functions <code>option</code> return types makes their potential behavior clear, without requiring the programmer to consult informal documentation to learn that.
</td>
</tr>

<tr><td colspan="2"><h3>Generic functions</h3></td></tr>
<tr>
<td>Standard library contains <b>generic functions that couldn&#39;t be implemented in OCaml</b>, like comparison and hashing.</td>
<td>Equality is the only generic function of this kind, and it&#39;s built into the language.</td>
</tr>
<tr>
<td><pre>1 &lt; 2;;
[1; 2; 3] &lt; [4; 5; 6];;
(fun () -&gt; ()) &lt; (fun () -&gt; ());; (* Exception *)</pre></td>
<td><pre>1 &lt; 2;
[1, 2, 3] &lt; [4, 5, 6]; (* Type error *)
(fn () =&gt; ()) &lt; (fn () =&gt; ());; (* Type error *)</pre></td>
</tr>
<tr>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/hardhat.png" width="53" height="99"/></td>
<td>It&#39;s very convenient to implement container structures and other functionality without having to worry about passing around comparison or hashing functions. Some of the generic operations, like comparison, can raise run-time type errors.</td>
</tr></tbody></table>
</td>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/scientist.png" width="58" height="91"/></td>
<td>SML avoids features like this whose formalization would require considerable extra work.</td>
</tr></tbody></table>
</td>
</tr>

<tr><td colspan="2"><h3>Mutability of strings</h3></td></tr>
<tr>
<td>Strings are <b>mutable.</b></td>
<td>Strings are <b>immutable</b> (and in fact the string type is defined as a synonym for a vector type).</td>
</tr>
<tr>
<td>
Mutating strings can be convenient.
</td>
<td>
One often performs purely functional string manipulations, and it&#39;s useful for program understanding to have types that reflect that. If you want mutable &#34;strings&#34;, use the <code>CharArray</code> module. By defining strings as vectors, we avoid including another primitive base type that goes unused in many programs, like OCaml does.
</td>
</tr>

<tr><td colspan="2"><h2>Data types</h2></td></tr>

<tr><td colspan="2"><h3>Algebraic datatype constructors</h3></td></tr>
<tr>
<td><b>Second-class constructors</b> that duplicate some tuple functionality</td>
<td><b>First-class constructors</b></td>
</tr>
<tr>
<td><pre>List.map (fun x -&gt; Some x) [1; 2; 3];;

type (&#39;a, &#39;b) pair = Pair of &#39;a * &#39;b;;

match e with
    Pair p -&gt; p (* Type error *)</pre></td>
<td><pre>map Some [1, 2, 3];

datatype (&#39;a, &#39;b) pair = Pair of &#39;a * &#39;b;

case e of
    Pair p =&gt; p</pre></td>
</tr>
<tr>
<td>
This scheme is easier to compile efficiently in the absence of dataflow analysis. However, by not treating variant constructors as functions, OCaml forces the use of wrappers as arguments to higher-order functions. By not treating multiple arguments to constructors as tuples, OCaml creates feature overlap between variants and tuples, making it hard to convert between them.
</td>
<td>
SML avoids the two problems mentioned for OCaml. Using dataflow analysis, SML compilers like <a href="http://mlton.org/">MLton</a> compile uses of multiple-argument constructors efficiently.
</td>
</tr>

<tr><td colspan="2"><h3>Format strings</h3></td></tr>
<tr>
<td><code>printf</code>- and <code>scanf</code>-style <b>format strings are built into the language</b>.</td>
<td>No format strings</td>
</tr>
<tr>
<td><pre>Printf.printf &#34;%s, %d\n&#34; &#34;Hello&#34; 1234;</pre></td>
<td></td>
</tr>
<tr>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/hardhat.png" width="53" height="99"/></td>
<td>Format strings have proved to be a useful enough idiom that special language support is justified.</td>
</tr></tbody></table>
</td>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/scientist.png" width="58" height="91"/></td>
<td>It would go against the SML philosophy to include such a complicated type system feature that most parts of most programs wouldn&#39;t use. It also turns out that SML is already sufficient to implement <a href="http://mlton.org/Printf">something almost identical to <code>printf</code></a>.</td>
</tr></tbody></table>
</td>
</tr>

<tr><td colspan="2"><h3>Labeled function arguments</h3></td></tr>
<tr>
<td>Has them</td>
<td>Doesn&#39;t have them</td>
</tr>
<tr>
<td><pre>let name ~firstName ~lastName = firstName ^ &#34; &#34; ^ lastName;;

name ~lastName:&#34;Doe&#34; ~firstName:&#34;John&#34;;;</pre></td>
<td><pre>fun name {firstName, lastName} = firstName ^ &#34; &#34; ^ lastName;

name {lastName = &#34;Doe&#34;, firstName = &#34;John&#34;};</pre></td>
</tr>
<tr>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/hardhat.png" width="53" height="99"/></td>
<td>Labeled arguments remove the need to keep track of which arguments go in which positions.</td>
</tr></tbody></table>
</td>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/scientist.png" width="58" height="91"/></td>
<td>Labeled arguments complicate the language definition, and their benefits can often be attained through other means. OCaml&#39;s lack of anonymous record types seems to explain much of the rationale for including labeled arguments.</td>
</tr></tbody></table>
</td>
</tr>

<tr><td colspan="2"><h3>Mutable fields</h3></td></tr>
<tr>
<td>Record fields may be marked mutable.</td>
<td>No concept of mutable fields</td>
</tr>
<tr>
<td><pre>type mut_pair = {mutable x : int; mutable y : int};;

let myPair = {x = 1; y = 2};
myPair.x &lt;- 3;;</pre></td>
<td><pre>type mut_pair = {x : int ref, y : int ref};

val myPair = {x = ref 1, y = ref 2};
#x myPair := 3;</pre></td>
</tr>
<tr>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/hardhat.png" width="53" height="99"/></td>
<td>Mutable fields make imperative programming more convenient, and they have a more natural efficient compilation strategy in the absence of dataflow analysis.</td>
</tr></tbody></table>
</td>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/scientist.png" width="58" height="91"/></td>
<td><code>ref</code> types are a simpler feature and can be used to implement a work-alike to mutable fields. With dataflow analysis, SML compilers like <a href="http://mlton.org/">MLton</a> produce efficient binaries from code that uses <code>ref</code>s to implement mutable fields.</td>
</tr></tbody></table>
</td>
</tr>

<tr><td colspan="2"><h3>Optional function arguments</h3></td></tr>
<tr>
<td>Has them</td>
<td>Doesn&#39;t have them</td>
</tr>
<tr>
<td><pre>let printIt ?(prefix = &#34;Hello, &#34;) s = print_endline (prefix ^ s);;

printIt &#34;world&#34;;;
printIt ~prefix:&#34;1&#34; &#34;2&#34;;;</pre></td>
<td><pre>fun printIt (prefix, s) =
  print (Option.getOpt (prefix, &#34;Hello, &#34;) ^ s ^ &#34;\n&#34;);

printIt (NONE, &#34;world&#34;);
printIt (SOME &#34;1&#34;, &#34;2&#34;);</pre></td>
</tr>
<tr>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/hardhat.png" width="53" height="99"/></td>
<td>Optional arguments make it easy to have highly-configurable functions that can be called succinctly in the common case.</td>
</tr></tbody></table>
</td>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/scientist.png" width="58" height="91"/></td>
<td>Optional arguments complicate the language definition, and their uses tend in practice to be implementable in other, not much more verbose ways.</td>
</tr></tbody></table>
</td>
</tr>

<tr><td colspan="2"><h3>Polymorphic variants</h3></td></tr>
<tr>
<td>Has them</td>
<td>Doesn&#39;t have them</td>
</tr>
<tr>
<td><pre>let getNum = function
    `Num n -&gt; Some n
  | _ -&gt; None;;

type t1 = [`Num of int | `Other of string];;
getNum (`Num 6 : t1);;

type t2 = [`Num of float | `Something of bool];;
getNum (`Num 6.0 : t2);;</pre></td>
<td><pre>datatype (&#39;a, &#39;b) base =
    Num of &#39;a
  | Rest of &#39;b;

type t1 = (int, string) base;
getNum (Num 6 : t1);

type t2 = (real, bool) base;
getNum (Num 6.0 : t2);</pre></td>
</tr>
<tr>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/hardhat.png" width="53" height="99"/></td>
<td>Polymorphic variants enable greater degrees of genericity than regular variants do.</td>
</tr></tbody></table>
</td>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/scientist.png" width="58" height="91"/></td>
<td>Polymorphic variants can lead to some quite confusing error messages, and static checking is a less effective bug-finder in a program that uses them. Newcomers to OCaml often fall into using polymorphic variants by default, since they have a lower cost of entry than regular variants, even though most ML programmers agree that regular variants are more desirable when applicable.</td>
</tr></tbody></table>
</td>
</tr>

<tr><td colspan="2"><h3>Records</h3></td></tr>
<tr>
<td><b>Declared, generative record types</b> where field names can shadow others</td>
<td><b>Anonymous record types</b></td>
</tr>
<tr>
<td><pre>type coord = {x : int; y : int};;

let addCoord c = c.x + c.y;;

type coord&#39; = {x : int; y : int};;

addCoord {x = 1; y = 2};; (* Type error *)

type unrelated = {x : float; y : bool; z : string};;

let myCoord = {x = 1; y = 2};; (* Type error *)</pre></td>
<td><pre>fun addCoord (c : {x : int, y : int}) = #x c + #y c;

type unrelated = {x : real, y : bool, z : string};

val myCoord = {x = 1, y = 2};</pre></td>
</tr>
<tr>
<td>
By looking at just a single field of a valid record construction expression, the expression&#39;s type is uniquely determined, which makes type inference easier compared to anonymous record types. However, namespace management of fields can be arduous. To use a record type declared in another module, one must either open that module or reference a field with a full path that includes the module name. It&#39;s also easy to unintentionally shadow a field name with a new record type declaration.
</td>
<td>
In general, anonymous record types are a lightweight feature that avoids the problems mentioned for OCaml&#39;s records. On the other hand, type inference for anonymous record types can be tricky, often prompting SML programmers to include type annotations on record arguments to functions or wrap record types inside single-constructor datatypes.
</td>
</tr>

<tr><td colspan="2"><h3>Recursive types</h3></td></tr>
<tr>
<td><b>Any mutually recursive type definitions</b> are allowed, as long as a cycle-detection algorithm accepts them.</td>
<td><b>All recursion goes through algebraic datatypes</b>.</td>
</tr>
<tr>
<td><pre>type &#39;a tree = {data : &#39;a; children : &#39;a tree list};;

type &#39;a btree =
    Leaf of &#39;a
  | Node of &#39;a forests * &#39;a forests
 and &#39;a forest = &#39;a btree list
 and &#39;a forests = &#39;a forest list;;</pre></td>
<td><pre>datatype &#39;a tree = Tree of {data : &#39;a, children : &#39;a tree list};

datatype &#39;a btree =
    Leaf of &#39;a
  | Node of &#39;a forests * &#39;a forests
 withtype &#39;a forest = &#39;a btree list
      and &#39;a forests = &#39;a btree list list;
      (* Definition of forest must be substituted *)</pre></td>
</tr>
<tr>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/hardhat.png" width="53" height="99"/></td>
<td>OCaml features a single mutually-recursive <code>type</code> syntax, overloaded to cover synonyms, record types, and variants. Most reasonable definitions just work.</td>
</tr></tbody></table>
</td>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/scientist.png" width="58" height="91"/></td>
<td>By forcing all type recursion to go through <code>datatype</code> declarations, SML simplifies its formal semantics to only have to deal with recursive types &#34;in one place,&#34; without sacrificing any expressivity.</td>
</tr></tbody></table>
</td>
</tr>

<tr><td colspan="2"><h2>Pattern matching</h2></td></tr>

<tr><td colspan="2"><h3>Guards</h3></td></tr>
<tr>
<td>Has them</td>
<td>Doesn&#39;t have them</td>
</tr>
<tr>
<td><pre>let f x = function
    Some y when y &lt; x -&gt; y
  | _ -&gt; 0;;</pre></td>
<td><pre>fun f x = fn
    SOME y =&gt;
    if y &lt; x then
      y
    else
      0
  | _ =&gt; 0;</pre></td>
</tr>
<tr>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/hardhat.png" width="53" height="99"/></td>
<td>These can be a significant code-space saver.</td>
</tr></tbody></table>
</td>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/scientist.png" width="58" height="91"/></td>
<td>Let&#39;s not clutter up the language definition, eh? You can always define a local function that you call in the several cases to which you must compile a single guard use.</td>
</tr></tbody></table>
</td>
</tr>

<tr><td colspan="2"><h3>&#34;Or&#34; patterns</h3></td></tr>
<tr>
<td>Has them</td>
<td>Doesn&#39;t have them</td>
</tr>
<tr>
<td><pre>let f = function
    0 | 1 -&gt; true
  | _ -&gt; false;;</pre></td>
<td><pre>val f = fn
    0 =&gt; true
  | 1 =&gt; true
  | _ =&gt; false;</pre></td>
</tr>
<tr>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/hardhat.png" width="53" height="99"/></td>
<td>These can be a significant code-space saver.</td>
</tr></tbody></table>
</td>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/scientist.png" width="58" height="91"/></td>
<td>Let&#39;s not clutter up the language definition, eh? You can always define a local function that you call in all the branches you would have lumped together with an &#34;or&#34; pattern. (An SML/NJ extension allows &#34;or&#34; patterns.)</td>
</tr></tbody></table>
</td>
</tr>

<tr><td colspan="2"><h2>Modules and classes</h2></td></tr>

<tr><td colspan="2"><h3>First-class functors and signatures</h3></td></tr>
<tr>
<td>Allows <b>functors that return functors or take them as arguments</b>, <b>functors and signatures in modules</b>, etc.</td>
<td>Doesn&#39;t allow these</td>
</tr>
<tr>
<td><pre>module F (A : sig end) (B : sig end) = struct end;;

module M = struct
  module type S = sig end
end;;</pre></td>
<td><pre>functor F (A : sig end) (B : sig end) = struct end;
(* SML/NJ only *)

(* No counterpart to second example *)</pre></td>
</tr>
<tr>
<td>
Both of these features have many nice uses.
</td>
<td>
It&#39;s almost always possible to work around these omissions, and an SML/NJ extension supports higher-order functors.
</td>
</tr>

<tr><td colspan="2"><h3>Object-oriented features</h3></td></tr>
<tr>
<td><b>Novel object system</b></td>
<td>No special features</td>
</tr>
<tr>
<td><pre>class type counter = object (&#39;self)
  method get : int
  method set : int -&gt; unit
  method inc : &#39;self
end;; 

class myCounter init : counter = object
  val mutable count = init
  method get = count
  method set n = count &lt;- n
  method inc = {&lt; count = count + 1 &gt;}
end;;

let c = new myCounter 23;;
c#set 42;;


class type counter&#39; = object
  inherit counter
  method zero : unit
end;;

class myCounter&#39; init : counter&#39; = object (self)
  inherit myCounter init
  method zero = self#set 0
end;;</pre></td>
<td><pre>datatype counter = Counter of {
  get : unit -&gt; int,
  set : int -&gt; unit,
  inc : unit -&gt; counter
};
(* Notice that inc&#39;s type only reflects that _some_
 * counter is returned, not necessarily &#34;the same
 * type of&#34; counter. *)

fun myCounter init =
  let
    val count = ref init
  in
    Counter {get = fn () =&gt; !count,
             set = fn n =&gt; count := n,
             inc = fn () =&gt; myCounter (!count + 1) }
  end;

val c = myCounter 23;
case c of Counter {set, ...} =&gt; set 42;


datatype counter&#39; = Counter&#39; of {
  get : unit -&gt; int,
  set : int -&gt; unit,
  inc : unit -&gt; counter&#39;,
  zero : unit -&gt; unit
};

fun myCounter&#39; init =
  let
    val Counter {get, set, inc} = myCounter init
  in
    Counter&#39; {get = get,
              set = set,
              inc = fn () =&gt; myCounter&#39; (get () + 1),
              zero = fn () =&gt; set 0 }
  end;</pre></td>
</tr>
<tr>
<td>
For some situations, objects are the clear right implementation technique, and OCaml makes them convenient to use.
</td>
<td>
Most of the individual features that go into a typical concept of &#34;object orientation&#34; are available separately in core ML. The main omissions are succinct mechanisms to implement inheritance and self types. As far as education and training go, lack of &#34;OO&#34; features in SML can be a blessing, since new OCaml programmers often latch onto the object system as the default means of abstraction, missing oftentimes more appropriate features in the module system and elsewhere.
</td>
</tr>

<tr><td colspan="2"><h3><code>open</code> in signatures</h3></td></tr>
<tr>
<td><code>open</code> <b>is allowed in signatures</b>.</td>
<td><code>open</code> <b>is not allowed in signatures</b>.</td>
</tr>
<tr>
<td><pre>module type S = sig
  open M
  val x : t
end;;</pre></td>
<td><pre>signature S = sig
  val x : M.t
end;</pre></td>
</tr>
<tr>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/hardhat.png" width="53" height="99"/></td>
<td>This can save a lot of time in defining signatures that use many types defined elsewhere.</td>
</tr></tbody></table>
</td>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/scientist.png" width="58" height="91"/></td>
<td>Just another feature to avoid having to include in the formal language definition!</td>
</tr></tbody></table>
</td>
</tr>

<tr><td colspan="2"><h3>Separate compilation conventions</h3></td></tr>
<tr>
<td><b>Filenames imply module names</b></td>
<td>No standard separate compilation scheme</td>
</tr>
<tr>
<td>
When using OCaml as a compiler, every <code>.ml</code> file is treated as a separate module, with its interface optionally given by a corresponding <code>.mli</code> file. This usually works well, but there are some problems. First, the &#34;signatures&#34; defined by <code>.mli</code> files aren&#39;t first-class module system signatures, so they can&#39;t be referenced anywhere else. This means that multiple source-file-level modules can&#39;t share a signature, and that signatures must always live inside of modules. Of course, one could always put all of his modules in a single file and avoid this problem, but splitting into files is a standard technique for facilitating good interaction with editors, source control, and so on. There is an analogous problem for functors, leading to examples like <code>Map.Make</code> in the standard library, as opposed to the work-alike <code>BinaryMapFn</code> in the <a href="https://www.smlnj.org/doc/smlnj-lib/">SML/NJ library</a>.
</td>
<td>
Candidate tools related to SML separate compilation system and project management include the SML/NJ <a href="http://www.smlnj.org/doc/CM/index.html">Compilation Manager</a> and the MLton <a href="http://mlton.org/MLBasis">ML Basis system</a>. Both of these are essentially file agnostic after all of the appropriate files have been found (and possibly assigned some compilation flags), effectively concatenating the files together and imposing visibility restrictions at the module level.
</td>
</tr>

<tr><td colspan="2"><h2>Tools</h2></td></tr>

<tr><td colspan="2"><h3>Build system</h3></td></tr>
<tr>
<td>Command-line tools with help generating dependency information</td>
<td>SML/NJ&#39;s Compilation Manager; whole-program compilation with MLton</td>
</tr>
<tr>
<td>
OCaml integrates well into traditional UNIX build systems. The <a href="https://caml.inria.fr/pub/docs/manual-ocaml/depend.html">ocamldep</a> program builds dependency information for use by Makefiles, and the popular (but separately-distributed) <a href="https://github.com/mmottl/ocaml-makefile">OCamlMakefile</a> ties it all together.
</td>
<td>
SML/NJ&#39;s <a href="http://www.smlnj.org/doc/CM/index.html">Compilation Manager</a> makes it extremely easy and convenient to compile projects that don&#39;t use much non-SML code, including integrated support for ml-lex/yacc. It also has some namespace management features for building and packaging libraries. Build management issues aren&#39;t that big a deal for MLton, which must compile whole programs at once, anyway.
</td>
</tr>

<tr><td colspan="2"><h3>Bytecode compiler</h3></td></tr>
<tr>
<td><a href="https://caml.inria.fr/pub/docs/manual-ocaml/comp.html">Included</a> with the main distribution</td>
<td>Present in some systems, including <a href="https://mosml.org/">Moscow ML</a> and the <a href="https://wiki.c2.com/?MlKit">ML Kit</a></td>
</tr>
<tr>
<td colspan="2"></td>
</tr>

<tr><td colspan="2"><h3>Compilation to .NET</h3></td></tr>
<tr>
<td><a href="http://research.microsoft.com/fsharp/">F#</a></td>
<td><a href="http://www.cl.cam.ac.uk/research/tsg/SMLNET/">SML.NET</a></td>
</tr>
<tr>
<td>
F# starts with OCaml, drops the object system and some other features (like parts of the module system), and adds .NET-style OO that interoperates seamlessly with other .NET languages. There is Visual Studio support as well. Lately, there&#39;s been a lot of hype surrounding F#.
</td>
<td>
SML.NET matches most of the main advantages of F# but doesn&#39;t seem to end up with as many neat experimental features. On the other hand, unlike F# for OCaml, it implements all of Standard ML. It also somehow can&#39;t match F#&#39;s hype level.
</td>
</tr>

<tr><td colspan="2"><h3>Compilation to Java bytecode</h3></td></tr>
<tr>
<td><a href="http://www.ocamljava.org/">OCaml-Java</a></td>
<td><a href="http://www.dcs.ed.ac.uk/home/mlj/">MLj</a></td>
</tr>
<tr>
<td>
</td>
<td>
.NET seems to be the managed platform of choice these days for functional programmers, and interest has shifted from MLj to SML.NET.
</td>
</tr>

<tr><td colspan="2"><h3>Debugger</h3></td></tr>
<tr>
<td><b>Backtracking debugger</b></td>
<td>Only <a href="http://www.polyml.org/">Poly/ML</a> includes a mature debugger.</td>
</tr>
<tr>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/hardhat.png" width="53" height="99"/></td>
<td>OCaml features a <a href="https://caml.inria.fr/pub/docs/manual-ocaml/debugger.html">debugger</a> in the tradition of GDB, plus some novel features like backtracking.</td>
</tr></tbody></table>
</td>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/scientist.png" width="58" height="91"/></td>
<td>What, you&#39;re still using a debugger instead of unit tests? <tt>;-)</tt></td>
</tr></tbody></table>
</td>
</tr>

<tr><td colspan="2"><h3>Extensible parsing</h3></td></tr>
<tr>
<td><b>camlp4 extensible grammar tool</b> integrates with OCaml compilation</td>
<td>No equivalent</td>
</tr>
<tr>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/hardhat.png" width="53" height="99"/></td>
<td><a href="http://caml.inria.fr/pub/docs/manual-camlp4/index.html">camlp4</a> allows dynamic extension of grammars by adding new non-terminals, in contrast to well-known &#34;macro systems&#34; based around tokens or s-expressions. Not only does camlp4 integrate with the OCaml compiler, allowing language extension along the lines of traditional macro uses, but it can also be used separately. For instance, <a href="http://coq.inria.fr/">Coq</a> uses campl4 to let users add new commands and tactics implemented in OCaml.</td>
</tr></tbody></table>
</td>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/scientist.png" width="58" height="91"/></td>
<td>General objections about macros apply: we would like to keep it as simple as possible for both humans and programs to parse arbitrary SML programs, making it undesirable to allow customized grammar extensions. Most common uses of macros in C and Lisp are better handled with other SML features.</td>
</tr></tbody></table>
</td>
<td>
</td></tr>

<tr><td colspan="2"><h3>Emacs modes</h3></td></tr>
<tr>
<td>caml-mode and <a href="https://github.com/ocaml/tuareg">tuareg-mode</a></td>
<td><a href="http://www.smlnj.org/doc/Emacs/sml-mode.html">sml-mode</a></td>
</tr>
<tr>
<td colspan="2">
</td>
</tr>

<tr><td colspan="2"><h3>Foreign function interfaces</h3></td></tr>
<tr>
<td><b>Lightweight FFI supported by added language constructs</b></td>
<td>Semi-standardized <b>No Longer Foreign Function Interface</b>, plus MLton&#39;s lower-level FFI for interfacing with C code directly</td>
</tr>
<tr>
<td>
The <a href="https://caml.inria.fr/pub/docs/manual-ocaml/intfc.html">FFI</a> is relatively simple to use once you figure out linking, but the C-level view is one of specialized OCaml types instead of &#34;native C&#34; types. This can make it cumbersome to interface with existing C code. Also, the programmer needs to write the correct types for external functions manually.
</td>
<td>
The <a href="http://mlton.org/MLNLFFI">NLFFI</a> embeds most of the C type system in SML, letting the SML compiler type-check appropriate usage and catch many nasty classes of bugs. The <code>ml-nlffigen</code> program builds SML wrappers automatically from C header files. The NLFFI tools are available for both <a href="http://www.smlnj.org/">SML/NJ</a> and <a href="http://mlton.org/">MLton</a>, making it largely seamless to build an FFI-using project with both. The tools take care of adapting to the compilers&#39; different &#34;under the hood&#34; conventions. See also <a href="http://mlton.org/ForeignFunctionInterface">MLton&#39;s lower-level FFI</a>.
</td>
</tr>

<tr><td colspan="2"><h3>HTML documentation generation from source code</h3></td></tr>
<tr>
<td><a href="https://caml.inria.fr/pub/docs/manual-ocaml/ocamldoc.html">ocamldoc</a></td>
<td>Some tool is available and used to generate the Standard Basis documentation, but where is it?</td>
</tr>
<tr>
<td colspan="2">
Evaluation pending more information on SML tools
</td>
</tr>

<tr><td colspan="2"><h3>Optimizing native-code compiler</h3></td></tr>
<tr>
<td>Native code compiler does very little program analysis</td>
<td><b>Whole-program optimizing compiler</b> (<a href="http://mlton.org/">MLton</a>)</td>
</tr>
<tr>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/scientist.png" width="58" height="91"/></td>
<td>OCaml has gotten by quite well by choosing an efficient <a href="https://caml.inria.fr/pub/docs/manual-ocaml/native.html">base compilation strategy</a>. Development focus seems to be on adding new language features instead of improving compilation.</td>
</tr></tbody></table>
</td>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/hardhat.png" width="53" height="99"/></td>
<td>MLton is one of the best open-source optimizing compilers available. The <a href="http://shootout.alioth.debian.org/">Computer Language Shootout</a> has it in 7th place currently for <a href="http://shootout.alioth.debian.org/debian/benchmark.php?test=all&amp;lang=all&amp;calc=Calculate&amp;xfullcpu=1&amp;xmem=0&amp;xloc=0">execution speed</a>, behind D, C, C++, Eiffel, Pascal, and Ada compilers and just ahead of OCaml. The Shootout only measures microbenchmarks, and MLton&#39;s whole-program optimization can be expected to produce a marked efficiency advantage over native OCaml programs for large projects that make good use of abstraction and modularity.  [Note in 2020: the Shootout was replaced with <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/">The Computer Language Benchmarks Game</a>, which doesn&#39;t list SML anymore.]</td>
</tr></tbody></table>
</td>
</tr>

<tr><td colspan="2"><h3>Parser generators</h3></td></tr>
<tr>
<td><a href="https://caml.inria.fr/pub/docs/manual-ocaml/lexyacc.html">ocamllex and ocamlyacc</a></td>
<td><a href="http://www.smlnj.org/doc/ML-Lex/manual.html">ml-lex</a> and <a href="http://www.smlnj.org/doc/ML-Yacc/index.html">ml-yacc</a></td>
</tr>
<tr>
<td colspan="2"></td>
</tr>

<tr><td colspan="2"><h3>Performance profiling</h3></td></tr>
<tr>
<td><b>Direct profiling of execution counts for bytecode programs</b> and <b>indirect gprof-based profiling of time for native code programs</b></td>
<td>In <a href="http://mlton.org/">MLton</a>, <b>direct profiling of execution counts, time, and allocation for native code programs</b></td>
</tr>
<tr>
<td>

</td>
<td>

</td>
<td>
</td></tr>

<tr><td colspan="2"><h3>Source/interface browser</h3></td></tr>
<tr>
<td><a href="https://caml.inria.fr/pub/docs/manual-ocaml/browser.html">ocamlbrowser</a></td>
<td>No equivalent</td>
</tr>
<tr>
<td>
ocamlbrowser provides a specialized GUI for navigating through OCaml code.
</td>
<td>
It&#39;s unclear whether many people find ocamlbrowser significantly more helpful than Emacs plus highly-hyperlinked HTML documentation.
</td>
</tr>

<tr><td colspan="2"><h3>Standard library</h3></td></tr>
<tr>
<td><a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/">Standard library</a> plus several other libraries packaged with the main distribution</td>
<td><a href="http://www.standardml.org/Basis/">The Standard Basis</a> plus the <a href="https://www.smlnj.org/doc/smlnj-lib/">SML/NJ library</a></td>
</tr>
<tr>
<td colspan="2">
Taking the SML/NJ library into account since it is now distributed with MLton as well as SML/NJ, there is no clear winner in standard library coverage between OCaml and SML. Each has all the basics, as well as some gems that the other lacks.
</td>
</tr>

<tr><td colspan="2"><h3>Toplevel interactive system</h3></td></tr>
<tr>
<td>Present</td>
<td>Present in all SML compilers but MLton</td>
</tr>
<tr>
<td colspan="2">
</td>
</tr>

<tr><td colspan="2"><h2>Social factors</h2></td></tr>

<tr><td colspan="2"><h3>Community contributions to implementations</h3></td></tr>
<tr>
<td>Contributions to the OCaml implementation are tightly regulated, and patches are often rejected.</td>
<td>Generally open community approach. MLton&#39;s Subversion repository allows commits by any well-established community member who asks for permission.</td>
</tr>
<tr>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/scientist.png" width="58" height="91"/></td>
<td>This aspect of OCaml philosophy seems oriented towards research projects and makes it hard to take advantage of contributions from well-meaning hackers outside the project.</td>
</tr></tbody></table>
</td>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/hardhat.png" width="53" height="99"/></td>
<td>ML programmers on average are quite knowledgeable and skilled at development, so it is advantageous to tap the whole community in developing implementations and standard distributions.</td>
</tr></tbody></table>
</td>
</tr>

<tr><td colspan="2"><h3>Cute logos</h3></td></tr>
<tr>
<td>Caml has the camel: <img src="http://adam.chlipala.net/mlcomp/caml.gif" width="80" height="30"/></td>
<td>Nothing worth mentioning!</td>
</tr>
<tr>
<td>
</td></tr>

<tr><td colspan="2"><h3>Historical roots</h3></td></tr>
<tr>
<td>Historical association with theorem proving tools based on type theory and proof terms</td>
<td>Historical association with theorem proving tools in the <a href="http://en.wikipedia.org/wiki/LCF_theorem_prover">LCF</a> tradition</td>
</tr>
<tr>
<td>
Caml was developed to use in implementing the <a href="http://coq.inria.fr/">Coq</a> theorem prover, as related in <a href="http://www.pps.jussieu.fr/~cousinea/Caml/caml_history.html">this account</a>.
</td>
<td>
The ML family in general owes its origins to the LCF system. Today, SML is associated with successors like <a href="http://www.cl.cam.ac.uk/research/hvg/Isabelle/">Isabelle</a>.
</td>
</tr>

<tr><td colspan="2"><h3>Implementation diversity</h3></td></tr>
<tr>
<td><b>A single implementation</b> of the full language</td>
<td><b>Many Definition-compliant implementations</b>, including <a href="https://people.mpi-sws.org/~rossberg/hamlet/">HaMLet</a>, <a href="http://www.mlton.org/">MLton</a>, <a href="https://wiki.c2.com/?MlKit">ML Kit</a>, <a href="https://mosml.org/">Moscow ML</a>, <a href="http://www.polyml.org/">Poly/ML</a>, <a href="http://www.cl.cam.ac.uk/research/tsg/SMLNET/">SML.NET</a>, <a href="http://www.smlnj.org">Standard ML of New Jersey</a>, and <a href="https://github.com/RobertHarper/TILT-Compiler">TILT</a></td>
</tr>
<tr>
<td colspan="2"></td>
</tr>

<tr><td colspan="2"><h3>Language design</h3></td></tr>
<tr>
<td>Ad-hoc process similar to most &#34;open source programming languages&#34;</td>
<td><b>Language definition with formal semantics</b></td>
</tr>
<tr>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/hardhat.png" width="53" height="99"/></td>
<td>OCaml picks up new features agilely, without any heavyweight standardization or formalization process needed for the entirety of the revised language before a release is made. The language is in effect defined by some combination of <a href="http://caml.inria.fr/pub/docs/manual-ocaml/index.html">the manual</a> and the implementation.</td>
</tr></tbody></table>
</td>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/scientist.png" width="58" height="91"/></td>
<td>The existence of a <a href="https://mitpress.mit.edu/books/definition-standard-ml-revised-edition">language definition</a> helps language implementers keep in sync and discourages feature bloat. The formal semantics provides a concrete starting point for formal methods. On the other hand, these aspects discourage the adoption of new language features that the community might agree on as worthwhile. The new <a href="https://smlfamily.github.io/successor-ml/">Successor ML</a> project aims to overcome this stagnation, hopefully using more agile processes in the long term.</td>
</tr></tbody></table>
</td>
</tr>

<tr><td colspan="2"><h3>Learning materials</h3></td></tr>
<tr>
<td>Commercial books include <a href="http://caml.inria.fr/pub/docs/oreilly-book/">Developing Applications with Objective Caml</a>, <a href="https://www.amazon.com/Practical-OCaml-Joshua-B-Smith/dp/159059620X">Practical OCaml</a>, and <a href="http://www.ffconsultancy.com/products/ocaml_for_scientists/">OCaml for Scientists</a>. Part I of <a href="http://caml.inria.fr/pub/docs/manual-ocaml/index.html">the OCaml manual</a> contains a tutorial.</td>
<td>Commercial books include <a href="https://www.amazon.com/Introduction-Programming-International-Computer-Science/dp/0201398206">Introduction to Programming using SML</a>, <a href="http://infolab.stanford.edu/~ullman/emlp.html">Elements of ML Programming</a>, and <a href="http://www.cl.cam.ac.uk/~lp15/MLbook/">ML for the Working Programmer</a>. Online introductions include <a href="http://www.cs.cmu.edu/~rwh/isml/book.pdf">Programming in Standard ML</a> and <a href="http://www.dcs.ed.ac.uk/home/stg/NOTES/">Programming in Standard ML &#39;97: An On-Line Tutorial</a>.
</td></tr>
<tr>
<td colspan="2"></td>
</tr>

<tr><td colspan="2"><h3>Library availability</h3></td></tr>
<tr>
<td>Relatively many libraries available</td>
<td>Relatively few libraries available</td>
</tr>
<tr>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/hardhat.png" width="53" height="99"/></td>
<td>OCaml has had the fundamental tools in place to be regarded as a &#34;serious programming language&#34; for longer than SML has, and its significantly greater number of freely available libraries today reflects that. <a href="http://caml.inria.fr/cgi-bin/hump.cgi">The Caml Hump</a> collects links to these libraries in one place.  [Note in 2020: that site is gone now, but <a href="https://opam.ocaml.org/">OPAM</a> got popular.]</td>
</tr></tbody></table>
</td>
<td>
<table><tbody><tr>
<td><img src="http://adam.chlipala.net/mlcomp/scientist.png" width="58" height="91"/></td>
<td>SML has historically been more the domain of scientists with narrow interests in programming languages and formal methods, and so fewer libraries are available in general. However, particularly in the <a href="http://mlton.org/">MLton</a> community, this deficiency is recognized, and directed efforts are underway both to draft an enriched &#34;standard library&#34; and to create useful special-purpose libraries.</td>
</tr></tbody></table>
</td>
</tr>

<tr><td colspan="2"><h3>Packaging</h3></td></tr>
<tr>
<td><a href="http://packages.debian.org/search?keywords=ocaml&amp;searchon=names&amp;suite=all&amp;section=all">Pre-built packages</a> available for <a href="http://www.debian.org/">Debian Linux</a> and many other UNIX-like systems.</td>
<td><a href="http://packages.debian.org/search?keywords=mlton&amp;searchon=names&amp;suite=all&amp;section=all">MLton</a> and <a href="http://packages.debian.org/search?keywords=smlnj&amp;searchon=names&amp;suite=all&amp;section=all">SML/NJ</a> packages available for Debian.</td>
</tr>
<tr>
<td colspan="2"></td>
</tr>

<tr><td colspan="2"><h3>Research projects extending the language (not just implemented with it)</h3></td></tr>
<tr>
<td><a href="http://cristal.inria.fr/~fpottier/alphaCaml/">Cαml</a>, <a href="http://cristal.inria.fr/~simonet/soft/flowcaml/">Flow Caml</a>, <a href="http://research.microsoft.com/fsharp/">F#</a>, <a href="http://web.yl.is.s.u-tokyo.ac.jp/~furuse/gcaml/">G&#39;Caml</a>, <a href="http://moscova.inria.fr/jocaml/">JoCaml</a>, <a href="http://okmij.org/ftp/ML/MetaOCaml.html">MetaOCaml</a>, <a href="http://www.cduce.org/ocaml">OCamlDuce</a></td>
<td><a href="https://www.ps.uni-saarland.de/alice/">Alice</a>, <a href="http://cml.cs.uchicago.edu/">Concurrent ML</a>, <a href="http://www.cs.bu.edu/~hwxi/DML/DML.html">Dependent ML</a>, <a href="https://link.springer.com/chapter/10.1007/10704973_5">MetaML</a>, <a href="http://www.dcs.ed.ac.uk/home/mlj/">MLj</a>, <a href="http://www.cl.cam.ac.uk/research/tsg/SMLNET/">SML.NET</a></td>
</tr>
<tr>
<td colspan="2"></td>
</tr>

</tbody></div></div>
  </body>
</html>
