<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fizzixnerd.com/blog/2024-06-24-announcing-godotcaml/">Original</a>
    <h1>Godotcaml for Godot 4.2</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p>Hello!  Today I’m releasing a project on which I’ve been working, that is in an early stage of development, into the open source world.  It is integration and bindings to Godot (currently just 4.2) from a new language: OCaml.  It is called Godotcaml.  Details below!</p>
<h2 id="why-godot">Why Godot?</h2>
<p>There are many reasons to choose Godot, but the reason I’ll focus on is that it provides a full game-development IDE from which you can develop production quality 2D and 3D games.  It’s suitable for small-to-medium-sized teams, quite mature, and very fun to use; I think most devs have a secret inclination to “one day” make a video game.  If there is one piece of advice I could give to those devs, it’s choose a good engine that already exists, unless you want to be stuck in Vulkan hell for 6-12 months.  Godot is a good engine, and happily, already exists, and is free and open source — so is a good first choice, even if you abandon it for something different later.</p>
<h2 id="why-ocaml">Why OCaml?</h2>
<p>While my greatest loved language is Haskell, there are some specific reasons that it is somewhat unsuitable for game development.  Instead of listing those, however, I will instead take a more positive approach and talk about why OCaml is an excellent language for game development.</p>
<ul>
<li>
<p><strong>Garbage Collected by Default:</strong> This may shock game devs used to the C++ lyfe, but will come as no surprise to people who’ve used Godot and/or Unity.  Programmers are just more productive when there is a garbage collector, and programmer time is what is usually most valuable — not machine time.  Now, you can write some pretty cool allocation-free OCaml code too — but that’s an optimization that you should measure your need for before you commit to it.</p>
</li>
<li>
<p><strong>Functional by Default:</strong> I love functional programming, and I love the kind of code you can write in an ML-like curried functional language (such as OCaml or Haskell).  So <em>if</em> I were to bind Godot to a new language, it would have to be a functional one.  However, excellent bindings (<code>gdext</code>) for Rust already exist, and it can be used as a workable functional language.  That being said, Rust has the borrowchecker and an aversion to garbage collection, and put simply, I don’t think it makes a particularly good game scripting language, even though it is a wonderful systems programming language.  I think OCaml can one day prove to be a more efficient vehicle for experienced functional programmers to create a game in.  (No hate intended!  This is just how I <em>feel</em>.)</p>
</li>
<li>
<p><strong>Eager by Default:</strong> I absolutely adore lazy APIs.  I might actually be in the minority now in the Haskell community that I think that laziness was not a mistake, but was an excellent choice because of the ergonomics it provides.  However, it’s definitely true that it makes it somewhat less straight-forward to reason about the runtime performance of your code, and indeed to debug it — at least without specialized knowledge that is, in my experience, rather rare to have.  OCaml is eager by default, and I think that’s probably better for a soft-realtime system, unless you’re using some specialized framework (e.g. one that I don’t know whether exists or not!).</p>
</li>
<li>
<p><strong>Side-effects for When You Need Them:</strong> If the world was all written in one language, Haskell would make a pretty good choice — not perfect by any stretch, but pretty good.  However, we live in the real world, where a C FFI is the glue holding this pot of spaghetti we call an operating system together.  Because of that, when doing FFI heavy code, a beautiful language that makes it slightly more tedious to work with side-effects is less preferable in my experience than a language that simply encourages you to think before you use them, but still easily allows you to do things like have global mutable references at the top level.</p>
</li>
<li>
<p><strong>PPXes For CodeGen Help:</strong> I’m not totally sold on the pervasive use of PPXes for OCaml code, but one thing they are definitely useful for is code gen, and you would need a <em>lot</em> of tedious hand-written code if you wanted to interact with Godot directly by hand.  PPXes lie somewhere between Rust macros and TemplateHaskell in their power, but most problems with codegen were able to be solved to my satisfaction using the wonderful PpxLib and context-free extenders.  For example, here is the definition of a simple Godot class that inherits from the stock <code>Node</code> class, and provides a successor function for Godot <code>int</code>s:</p>
</li>
</ul>
<pre is:raw="" tabindex="0"><code><span><span>module</span><span>%</span><span>gclass </span><span>MyClass</span><span> </span><span>=</span><span> struct</span></span>
<span><span>  </span><span>[</span><span>%%</span><span>ginherits </span><span>Node]</span></span>
<span></span>
<span><span>  </span><span>let</span><span>%</span><span>gfunc </span><span>succ</span><span> </span><span>=</span><span> </span></span>
<span><span>    </span><span>[|</span><span> </span><span>ClassMethodFlags</span><span>.</span><span>default </span><span>|]</span></span>
<span><span>      (module </span><span>BuiltinClass0</span><span>.</span><span>Int</span><span>)</span></span>
<span><span>      (module </span><span>Class</span><span>.</span><span>Node</span><span>)</span></span>
<span><span>      (module </span><span>BuiltinClass0</span><span>.</span><span>Int</span><span>) </span></span>
<span><span>      (</span><span>fun</span><span> </span><span>i</span><span> </span><span>_self</span><span> </span><span>-&gt;</span><span> </span><span>Int64</span><span>.</span><span>(i </span><span>+</span><span> </span><span>1</span><span>L))</span></span>
<span><span>end</span></span></code></pre>
<p>Whether or not you like the use of PPXes in general, it is tough to argue that this code isn’t at least <em>short</em>, especially if I were to show you the amount of work you’d have to do without those <code>%</code>s!</p>
<ul>
<li><strong>More:</strong> If you’re reading this post, you probably already like OCaml already, so I’ll leave it there at “it’s a really nice pragmatic functional language, and I thought it would be a good candidate”!</li>
</ul>
<h2 id="what-can-it-do">What Can It Do?</h2>
<p>This is an extremely early stage of development, but basically at this point it is possible to:</p>
<ol>
<li>Call any builtin Godot utility function or method (static, virtual, or otherwise) from OCaml easily, and with documentation comments for the original function intact an available through your favourite OCaml LSP implementation.</li>
<li>Use Godot (binary) operators in a natural way from OCaml. (Unary operators are currently broken, which I will be investigating!)</li>
<li>Construct Godot values from OCaml easily, and from OCaml analogues if they exist (e.g. I incur a dependency on <code>Gg</code> for low-dimensional vector math)</li>
<li>Marshalling in and out of all these functions to/from the OCaml analogues.  That is, a method that is in Godot on an object of type <code>ClassyClass</code> taking an <code>int</code> parameter and returning an <code>int</code> will appear in Godotcaml as <code>int64 -&gt; ClassyClass.t structure ptr -&gt; int64</code>, where the <code>ClassyClass.t structure ptr</code> is the “pointer to the Godot object”, commonly called <code>self</code>.  (Note that this is always the <em>last</em> argument, to facilitate pipeline-style programming when GDScript programmers have a method-chaining interface.)</li>
<li>Naturally define a new Godot class in OCaml that inherits from an existing Godot-registered class.  (Currently NOT tested with classes defined in GDScript and/or externally.)</li>
<li>Most of the code-gen for custom engines that define new stock/builtin types and classes, etc.</li>
<li>Simulated inheritence for stock (and easily extendable to user-defined) classes using module inclusion:  That is if <code>Derived</code> inherits from <code>Base</code>, then simply include <code>Base</code> in the module representing <code>Derived</code>, and you get access to all the methods from <code>Base</code> without explicit casting (or in the case of Rust’s <code>gdext</code>, object composition).</li>
<li>Naturally define a new Godot method in OCaml and have it called from GDScript or another Godot-bound language. (ergonomics still WIP).</li>
</ol>
<h2 id="todo-or-what-cant-it-do">TODO (Or, What Can’t It Do):</h2>
<ol>
<li><strong>Signals:</strong> I’m still cooking ideas for how best to do this, but user-defined signals are not currently nicely supported, and even built in ones are not nice to call or interact with right now.  I’d also like them to be type-safe, so there’s that.  Very WIP, but fixable with some thought and work.</li>
<li><strong>Garbage Collection:</strong> Right now, if a OCaml reference is stored in a, say, GDScript variable, and contains no references in the OCaml world, then it might be collected out from under you.  This is fixable because of Godot’s wonderful reference-counting hooks and OCaml finalisers, I just haven’t gotten around to it yet.</li>
<li><strong>Nice Interface to Various Kinds of Methods:</strong> As of the writing of this blog post, it is only possible to define methods of arity <code>1 + Self</code> from OCaml.  No static methods, no virtual methods  This will be fixed soon, but I wanted to get the stuff in the hands of interested enthusiasts as soon as I was able to call OCaml functions from Godot.</li>
<li><strong>Real First Class Modules for Method Definitions:</strong> Taking again the example above, we can write</li>
</ol>
<pre is:raw="" tabindex="0"><code><span><span>let</span><span>%</span><span>gfunc </span><span>f</span><span> </span><span>=</span><span> </span></span>
<span><span>  </span><span>[|</span><span> </span><span>ClassMethodFlags</span><span>.</span><span>default </span><span>|]</span></span>
<span><span>  (module </span><span>ArgumentGodotTypeModule</span><span>)</span></span>
<span><span>  (module </span><span>SelfGodotTypeModule</span><span>)</span></span>
<span><span>  (module </span><span>ReturnValueGodotTypeModule</span><span>)</span></span>
<span><span>  (</span><span>fun</span><span> </span><span>x</span><span> </span><span>self</span><span> </span><span>-&gt;</span><span> </span><span>(* implementation here ...*)</span><span> </span><span>()</span><span>)</span></span></code></pre>
<p>making it seem like you could write, say</p>
<pre is:raw="" tabindex="0"><code><span><span>let</span><span> </span><span>m</span><span> </span><span>=</span><span> (module </span><span>SomeGodotTypeModule</span><span>)</span></span>
<span></span>
<span><span>let</span><span>%</span><span>gfunc </span><span>g</span><span> </span><span>=</span><span> </span><span>[|</span><span> </span><span>ClassMethodFlags</span><span>.</span><span>default </span><span>|]</span><span> m m m (</span><span>fun</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>-&gt;</span><span> x)</span></span></code></pre>
<p>or something, but that wouldn’t work.  This is due to the way I generate code, but basically you have to consider the <code>module</code> as part of the “syntax” for <code>gfunc</code>; it directly takes the packed module out of the expression and codegens using whatever the <code>module</code> operator is applied to (i.e. at <em>parse</em> time, not <em>run</em> time).  This is pretty messed up and not ideal, but the way I justify it to myself is that <code>let%gfunc</code> introduces it’s own syntactic form for declaring a <em>type signature</em> and <em>implementation</em> of a method.  This is, as far as I can tell, <em>not fixable</em>, but I’d love to hear your thoughts if you think it is.  (Briefly, the problem is that if you try to use real first-class modules, their types escape the scope of the function because the implementation function contains them.)</p>
<ol start="5">
<li><strong>General Clean-up:</strong> This implementation was designed sort of ad-hoc and in-the-moment, so some of the stuff doesn’t quite make sense in the module architecture.  This is fixable but lower priority until I iron out the rest of the implementation details of the other features.</li>
<li><strong>Better Build System Integration:</strong> I don’t know dune very well, so I got it <em>working</em>, but it’s not exactly nice to use and develop on.  Lots of ad-hoc calls to <code>dune exec ./gen_api.exe</code> when something has changed, and then trying to remember to format with <code>ocamlformat -i *.ml</code> — that sort of thing; I’m sure dune can help with it, but I didn’t invest the time into learning properly (but I will).  Fixable.</li>
<li><strong>Hot-Reloading:</strong> This should be possible, as Rust somehow manages it in Godot 4.2+ but I haven’t even begun to look into it.  Right now, if you change an OCaml file and recompile the extension, you probably need to restart the editor to see the effects.  Fixable.</li>
<li><strong>Name-mangling for Custom Operators:</strong> I just haven’t done this, but it wouldn’t be hard (and would probably make a good first issue, if you’re looking to contribute).  Right now custom operators defined as <code>gfunc</code> methods in OCaml probably can’t be used from GDScript, or most other languages.  Perhaps at all!  I haven’t even tried.  Fixable.</li>
<li><strong>Finishing the C API:</strong> These represent a work-in-progress set of bindings that are by no means complete at the moment.  That needs to change eventually.  Fixable.</li>
<li><strong>Embedding a TopLevel:</strong> I’d like to be able to interact with the Godot world, well, interactively, from an OCaml Toplevel.  This is on my backburner, but it’s harder than it looks at first, because the shared_object you have to build must of course be native code, but Toplevel and friends are (seemingly?) only available as bytecode.  Ping me if you have ideas here! Fixability unknown!</li>
<li><strong>Reliably Not Segfault:</strong> This is an unsafe C api, and so it’s extremely sharp, and the interface is very rough around the edges, as I figure out what exactly each value is supposed to actually do.  DO NOT TRY TO MAKE A PRODUCTION GAME IN GODOTCAML RIGHT NOW!  I’m going to fix things, but they definitely aren’t ready for prime-time at the moment.  This is fixable, but will take time and testing.</li>
<li><strong>Testing:</strong> Speaking of testing, I have none.  If you’d like to contribute here, I’d be happy to hear from you; I’m personally going to prioritize other above areas until things are a little more stable in the API, so I’m not constantly changing things and fixing <em>broken tests</em> (i.e. as opposed to <em>broken code that is being tested</em>).  Fixable.</li>
<li><strong>Type Safety Concerns:</strong> Right now all classes have the same object type.  This makes it nice for when you’re inheriting from them, as module inclusion “just works”, but obviously have negative effects on the type safety of the system.  Destructive updates of the module types during inclusion is one possible solution, but this requires you to have a module type for every Godot class from which you wish to inherit — a tall order.  I believe this is fixable with some thought — and indeed, it <em>must</em> be fixed in my eyes, even if it means more code gen for the module signatures — but I haven’t given it much thought beyond that.</li>
<li><strong>Support Multiple Native Type Sizes:</strong> Godot’s api supports multiple configurations, depending on if you want float64 or float32, and 64-bit and 32-bit systems.  Right now, I’m concentrating on the float64 + 64-bit configuration, but this should be expanded at some point in the future.  Fixable.</li>
</ol>
<p>For more, check the issue page on GitHub, as that is where I’ll be doing the development.</p>
<h2 id="to-be-continued">To Be Continued</h2>
<p>More details and a setup guide to come!  If you’d like to get involved, I’d love to hear from you — best place to find me is either GitHub or the OCaml Discourse currently.  Beware, the code is pretty funky at the moment, but it’ll get there!</p>
<p>Best,</p>
<p><em>Matt</em></p>

        <p><span>#open-source</span><span>#ocaml</span><span>#godot</span><span>#godotcaml</span><span>#announcement</span>
        </p>
      </div><div>
  <div>
    <p><img alt="Author Photo" width="96" height="96" src="https://fizzixnerd.com/_astro/fizzixnerd_Z1RMnIC.png" loading="eager" decoding="async"/>
    </p>
    <div>
      <p>
          About Matt Walker
        </p>
      <p>Matt Walker is a software engineer with a love for all things Functional, DevOps, and Typed, currently residing in Toronto, Canada.</p>
    </div>
  </div>
</div></div>
  </body>
</html>
