<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/guzba/mummy">Original</a>
    <h1>Mummy – web server written in Nim that returns to the ancient ways of threads</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto"><code>nimble install mummy</code></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/guzba/mummy/workflows/Github%20Actions/badge.svg"><img src="https://github.com/guzba/mummy/workflows/Github%20Actions/badge.svg" alt="Github Actions"/></a></p>
<p dir="auto"><a href="https://nimdocs.com/guzba/mummy" rel="nofollow">API reference</a></p>
<p dir="auto">Mummy is a multi-threaded HTTP 1.1 and WebSocket server written entirely in Nim.</p>
<p dir="auto"><em>A return to the ancient ways of threads.</em></p>
<p dir="auto">Mummy has been written specifically to maximize the performance of your server hardware without compromising on programmer happiness.</p>
<ul dir="auto">
<li>Supports HTTP keep-alive and gzip response compression automatically.</li>
<li>Built-in first-class WebSocket support.</li>
<li>Multiplexed socket IO without the <code>{.async.}</code> price.</li>
</ul>
<p dir="auto"><g-emoji alias="warning" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png">⚠️</g-emoji> Mummy is brand new so please exercise reasonable caution!</p>
<p dir="auto">Mummy requires <code>--threads:on</code> and <code>--mm:orc</code> or <code>--mm:arc</code>.</p>
<p dir="auto">The Mummy name refers to <a href="https://github.com/guzba/mummy/blob/master/docs/mummy.jpg">historical Egypt stuff</a>.</p>
<h2 dir="auto"><a id="user-content-sites-using-mummy" aria-hidden="true" href="#sites-using-mummy"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Sites using Mummy</h2>
<ul dir="auto">
<li><a href="https://nimdocs.com" rel="nofollow">NimDocs.com</a> - view the <a href="https://github.com/treeform/nimdocs/blob/master/src/nimdocs.nim">source code here</a></li>
</ul>
<h2 dir="auto"><a id="user-content-how-is-mummy-different" aria-hidden="true" href="#how-is-mummy-different"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>How is Mummy different?</h2>
<p dir="auto">Mummy operates with this basic model: handle all socket IO on one thread and dispatch incoming HTTP requests and WebSocket events to a pool of worker threads. Your HTTP handlers probably won&#39;t even need to think about threads at all.</p>
<p dir="auto">This model has many great benefits and is ready to take advantage of continued server core count increases (AMD just announced a 96 core 192 thread server CPU!).</p>
<h2 dir="auto"><a id="user-content-why-use-mummy-instead-of-async" aria-hidden="true" href="#why-use-mummy-instead-of-async"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Why use Mummy instead of async?</h2>
<ul dir="auto">
<li>
<p dir="auto">No more needing to use <code>{.async.}</code>, <code>Future[]</code>, <code>await</code> etc and deal with <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/" rel="nofollow">functions having colors</a>.</p>
</li>
<li>
<p dir="auto">Maintain the same excellent throughput of multiplexed nonblocking socket IO.</p>
</li>
<li>
<p dir="auto">No concern that one blocking or expensive call will stall your entire server.</p>
</li>
<li>
<p dir="auto">Async blocks on surprising things like DNS resolution and file reads which will stall all request handling.</p>
</li>
<li>
<p dir="auto">Simpler to write request handlers. Blocking the thread is totally fine! Need to make a Postgres query? No problem, just wait for the results.</p>
</li>
<li>
<p dir="auto">There is substantial advantage to writing simpler code vs theoretically fast but possibly convoluted and buggy code.</p>
</li>
<li>
<p dir="auto">Much simpler debugging. Async stack traces are huge and confusing.</p>
</li>
<li>
<p dir="auto">Easier error handling, just <code>try except</code> like you normally do. Uncaught exceptions in Mummy handlers also do not bring down your entire server.</p>
</li>
<li>
<p dir="auto">Mummy handles the threading and dispatch so your handlers may not need to think about threads at all.</p>
</li>
<li>
<p dir="auto">Takes advantage of multiple cores and the amazing work of the Nim team on ARC / ORC and Nim 2.0.</p>
</li>
</ul>
<h2 dir="auto"><a id="user-content-why-prioritize-websockets" aria-hidden="true" href="#why-prioritize-websockets"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Why prioritize WebSockets?</h2>
<p dir="auto">WebSockets are wonderful and can have substantial advantages over more traditional API paradigms like REST and various flavors of RPC.</p>
<p dir="auto">Unfortunately, most HTTP servers pretend WebSockets don&#39;t exist.</p>
<p dir="auto">This means developers need to hack support in through additional dependencies, hijacking connections etc and it all rarely adds up into something really great.</p>
<p dir="auto">I see no reason why Websockets should not work exceptionally well right out of the box, saving developers a lot of uncertainty and time researching which of the possible ways to wedge WebSocket support in to an HTTP server is &#34;best&#34;.</p>
<h2 dir="auto"><a id="user-content-what-is-mummy-not-great-for" aria-hidden="true" href="#what-is-mummy-not-great-for"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>What is Mummy not great for?</h2>
<p dir="auto">Everything comes with trade-offs. Mummy is focused on being an exceptional API server. Think REST, JSON, RPC, WebSockets, HTML from templates etc.</p>
<p dir="auto">The property these share in common is they are all relatively memory-light. Most things are, which is great, but if you&#39;re specifically going to be serving a lot of very large files or expect large file uploads, Mummy is probably not the best choice unless your server has the RAM to handle the large files.</p>
<p dir="auto">Why is Mummy not great for large files? This is because Mummy dispatches fully received in-memory requests to worker threads and sends in-memory responses. This is great for everything except very large files.</p>
<h2 dir="auto"><a id="user-content-example-http-server" aria-hidden="true" href="#example-http-server"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Example HTTP server</h2>
<div dir="auto" data-snippet-clipboard-copy-content="import mummy, mummy/routers

proc indexHandler(request: Request) =
  var headers: HttpHeaders
  headers[&#34;Content-Type&#34;] = &#34;text/plain&#34;
  request.respond(200, headers, &#34;Hello, World!&#34;)

var router: Router
router.get(&#34;/&#34;, indexHandler)

let server = newServer(router)
echo &#34;Serving on http://localhost:8080&#34;
server.serve(Port(8080))"><pre><span>import</span> mummy, mummy/routers

<span>proc</span> <span>indexHandler</span>(request: <span>Request</span>) <span>=</span>
  <span>var</span> headers: <span>HttpHeaders</span>
  headers[<span>&#34;Content-Type&#34;</span>] <span>=</span> <span>&#34;text/plain&#34;</span>
  request.<span>respond</span>(<span>200</span>, headers, <span>&#34;Hello, World!&#34;</span>)

<span>var</span> router: <span>Router</span>
router.<span>get</span>(<span>&#34;/&#34;</span>, indexHandler)

<span>let</span> server = <span>newServer</span>(router)
<span>echo</span> <span>&#34;Serving on http://localhost:8080&#34;</span>
server.<span>serve</span>(<span>Port</span>(<span>8080</span>))</pre></div>
<p dir="auto"><code>nim c --threads:on --mm:orc -r examples/basic_router.nim</code></p>
<h2 dir="auto"><a id="user-content-example-websocket-server" aria-hidden="true" href="#example-websocket-server"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Example WebSocket server</h2>
<div dir="auto" data-snippet-clipboard-copy-content="import mummy, mummy/routers

proc indexHandler(request: Request) =
  var headers: HttpHeaders
  headers[&#34;Content-Type&#34;] = &#34;text/html&#34;
  request.respond(200, headers, &#34;&#34;&#34;
  &lt;script&gt;
    var ws = new WebSocket(&#34;ws://localhost:8080/ws&#34;);
    ws.onmessage = function (event) {
      document.body.innerHTML = event.data;
    };
  &lt;/script&gt;
  &#34;&#34;&#34;)

proc upgradeHandler(request: Request) =
  let websocket = request.upgradeToWebSocket()
  websocket.send(&#34;Hello world from WebSocket!&#34;)

proc websocketHandler(
  websocket: WebSocket,
  event: WebSocketEvent,
  message: Message
) =
  case event:
  of OpenEvent:
    discard
  of MessageEvent:
    echo message.kind, &#34;: &#34;, message.data
  of ErrorEvent:
    discard
  of CloseEvent:
    discard

var router: Router
router.get(&#34;/&#34;, indexHandler)
router.get(&#34;/ws&#34;, upgradeHandler)

let server = newServer(router, websocketHandler)
echo &#34;Serving on http://localhost:8080&#34;
server.serve(Port(8080))"><pre><span>import</span> mummy, mummy/routers

<span>proc</span> <span>indexHandler</span>(request: <span>Request</span>) <span>=</span>
  <span>var</span> headers: <span>HttpHeaders</span>
  headers[<span>&#34;Content-Type&#34;</span>] <span>=</span> <span>&#34;text/html&#34;</span>
  request.<span>respond</span>(<span>200</span>, headers, <span>&#34;&#34;&#34;</span>
<span>  &lt;script&gt;</span>
<span>    var ws = new WebSocket(&#34;ws://localhost:8080/ws&#34;);</span>
<span>    ws.onmessage = function (event) {</span>
<span>      document.body.innerHTML = event.data;</span>
<span>    };</span>
<span>  &lt;/script&gt;</span>
<span>  &#34;&#34;&#34;)</span>

<span>proc</span> <span>upgradeHandler</span>(request: <span>Request</span>) <span>=</span>
  <span>let</span> websocket = request.<span>upgradeToWebSocket</span>()
  websocket.<span>send</span>(<span>&#34;Hello world from WebSocket!&#34;</span>)

<span>proc</span> <span>websocketHandler</span>(
  websocket: <span>WebSocket</span>,
  event: <span>WebSocketEvent</span>,
  message: <span>Message</span>
) <span>=</span>
  <span>case</span> event:
  <span>of</span> <span>OpenEvent</span>:
    <span>discard</span>
  <span>of</span> <span>MessageEvent</span>:
    <span>echo</span> message.kind, <span>&#34;: &#34;</span>, message.data
  <span>of</span> <span>ErrorEvent</span>:
    <span>discard</span>
  <span>of</span> <span>CloseEvent</span>:
    <span>discard</span>

<span>var</span> router: <span>Router</span>
router.<span>get</span>(<span>&#34;/&#34;</span>, indexHandler)
router.<span>get</span>(<span>&#34;/ws&#34;</span>, upgradeHandler)

<span>let</span> server = <span>newServer</span>(router, websocketHandler)
<span>echo</span> <span>&#34;Serving on http://localhost:8080&#34;</span>
server.<span>serve</span>(<span>Port</span>(<span>8080</span>))</pre></div>
<p dir="auto">See the examples/ folder for more sample code, including an example WebSocket chat server.</p>
<p dir="auto"><code>nim c --threads:on --mm:orc -r examples/basic_websockets.nim</code></p>
<h2 dir="auto"><a id="user-content-performance" aria-hidden="true" href="#performance"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Performance</h2>
<p dir="auto">Benchmarking HTTP servers is a bit like benchmarking running shoes.</p>
<p dir="auto">Certainly, there are some terrible shoes to run in (heels, clogs, etc), but once you&#39;re in a reasonable pair of shoes it is the runner that&#39;s going to matter, not the shoes.</p>
<p dir="auto">In this analogy, the runner is what your handlers are actually doing and the shoes are the HTTP server choice.</p>
<p dir="auto">With that in mind, I suggest three priorities:</p>
<ol dir="auto">
<li>
<p dir="auto">Ensure your HTTP server choice does not unnecessarily hamper performance.</p>
</li>
<li>
<p dir="auto">Avoid HTTP servers that have easy performance vulnerabilities.</p>
</li>
<li>
<p dir="auto">Prioritize what will enable you to write and maintain performant and reliable handlers.</p>
</li>
</ol>
<p dir="auto">I believe Mummy clears all three priorities:</p>
<ol dir="auto">
<li>
<p dir="auto">Mummy prioritizes efficiency in receiving and dispatching incoming requests and sending outgoing responses. This means things like avoiding unnecessary memory copying, ensuring the CPU spends all of its time in your handlers.</p>
</li>
<li>
<p dir="auto">Because Mummy uses multiplexed IO just like async, Mummy is not vulnerable to attacks like low-and-slow which traditionally multi-threaded servers are vulnerable to. Additionally, while a single blocking or CPU heavy operation can stall an entire async server, this is not a problem for Mummy.</p>
</li>
<li>
<p dir="auto">Request handlers with Mummy are just plain-old inline Nim code. They have a straightforward request-in-response-out API. Keeping things simple is great for maintenance, reliability and performance.</p>
</li>
</ol>
<h2 dir="auto"><a id="user-content-benchmarks" aria-hidden="true" href="#benchmarks"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Benchmarks</h2>
<p dir="auto">Benchmarking was done on an Ubuntu 22.04 server with a 4 core / 8 thread CPU.</p>
<p dir="auto">The tests/wrk_ servers that are being benchmarked attempt to simulate requests that take ~10ms to complete.</p>
<p dir="auto">All benchmarks were tested by:</p>
<p dir="auto"><code>wrk -t10 -c100 -d10s http://localhost:8080</code></p>
<p dir="auto">The exact commands for each server are:</p>
<h3 dir="auto"><a id="user-content-mummy-1" aria-hidden="true" href="#mummy-1"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Mummy</h3>
<p dir="auto"><code>nim c --mm:orc --threads:on -d:release -r tests/wrk_mummy.nim</code></p>
<p dir="auto">Requests/sec: 9,547.56</p>
<h3 dir="auto"><a id="user-content-asynchttpserver" aria-hidden="true" href="#asynchttpserver"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>AsyncHttpServer</h3>
<p dir="auto"><code>nim c --mm:orc --threads:off -d:release -r tests/wrk_asynchttpserver.nim</code></p>
<p dir="auto">Requests/sec: 7,979.67</p>
<h3 dir="auto"><a id="user-content-httpbeast" aria-hidden="true" href="#httpbeast"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>HttpBeast</h3>
<p dir="auto"><code>nim c --mm:orc --threads:on -d:release -r tests/wrk_httpbeast.nim</code></p>
<p dir="auto">Requests/sec: 9,862.00</p>
<h3 dir="auto"><a id="user-content-jester" aria-hidden="true" href="#jester"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Jester</h3>
<p dir="auto"><code>nim c --mm:orc --threads:off -d:release -r tests/wrk_jester.nim</code></p>
<p dir="auto">Requests/sec: 9,692.81</p>
<h3 dir="auto"><a id="user-content-prologue" aria-hidden="true" href="#prologue"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Prologue</h3>
<p dir="auto"><code>nim c --mm:orc --threads:off -d:release -r tests/wrk_prologue.nim</code></p>
<p dir="auto">Requests/sec: 9,749.22</p>
<h3 dir="auto"><a id="user-content-nodejs" aria-hidden="true" href="#nodejs"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>NodeJS</h3>
<p dir="auto"><code>node tests/wrk_node.js</code></p>
<p dir="auto">Requests/sec:   8,544.60</p>
<h3 dir="auto"><a id="user-content-go" aria-hidden="true" href="#go"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Go</h3>
<p dir="auto"><code>go run tests/wrk_go.go</code></p>
<p dir="auto">Requests/sec:   9,171.55</p>
<h2 dir="auto"><a id="user-content-testing" aria-hidden="true" href="#testing"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Testing</h2>
<p dir="auto">A fuzzer has been run against Mummy&#39;s socket reading and parsing code to ensure Mummy does not crash or otherwise misbehave on bad data from sockets. You can run the fuzzer any time by running <code>nim c -r tests/fuzz_recv.nim</code>.</p>
</article>
          </div></div>
  </body>
</html>
