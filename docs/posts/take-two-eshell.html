<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://yummymelon.com/devnull/take-two-eshell.html">Original</a>
    <h1>Take Two: Eshell</h1>
    
    <div id="readability-page-1" class="page"><div>
<p><em>This is a contribution to the <a href="https://christiantietze.de/posts/2025/06/emacs-carnival-2025-06-take-two/">Emacs Carnival 2025-06: Take Two</a> collection of posts on Christian Tietze’s blog.</em></p>
<p>My first take with <a href="https://www.gnu.org/software/emacs/manual/html_node/eshell/">Eshell</a> many years back did not leave a good impression. My early expectations was that it should act like any other shell, only to be unpleasantly surprised by it. It took a long time for me to warm up to Eshell. Upon reflection, it was because I wasn’t ready for it.</p>
<p>Now Eshell is an inseparable part of my Emacs experience. Paradoxically though, I find little occasion to use Eshell in the same way I’ve used shells in the past. Much of what I used to use the shell for, I do today with Emacs modes instead.</p>
<p>It was not always this way. Like so many users who started Unix computing in the 80’s, I started with the command line (for myself <code>ksh</code> and later <code>bash</code>), studiously internalizing command line tools and their arcane syntaxes to support file management, running programs, and systems administration. Overwhelmingly though, it was file management and running programs that I did through the command line.</p>
<p>For file management these days, <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html">Dired</a> is my interface of choice. It is simply the more elegant tool for the job.</p>
<p>Case in point: renaming a bunch of files in a directory to arbitrary names. With a shell, my standard approach would have been to run some variant of <code>ls -1 &gt; foo.sh</code>, edit <code>foo.sh</code> to insert <code>mv</code> on each line to a renamed target file, <code>chmod u+x foo.sh</code> to be executable, run <code>foo.sh</code>, delete <code>foo.sh</code> and call it a day.</p>
<p>With Dired, the above steps are replaced as such: make the buffer writable (via <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Wdired.html">Wdired</a>). Change the target filenames to a desired result, then commit the changes. This is even easier if there is a pattern you can use a regexp for. Unsurprisingly, all the basic file management operations that you would want are supported by Dired. Add <a href="https://github.com/kickingvegas/casual/blob/main/docs/dired.org">Casual Dired</a> to help make these operations discoverable and you’ll soon consider how quaint using <code>mv</code>, <code>cp</code>, <code>rm</code>, and <code>ls</code> are.</p>
<p>Running a simple command on a file? Again, you can do that with Dired. Move the point to the Dired line containing the file. Type “!” and enter a command in the prompt. You can optionally reference the filename in the command with the “?” character if you want to redirect its output to a file (e.g. <code>cmd ? &gt; outfile</code>).</p>
<p>Taking file management and running simple commands out of what you would use a shell for, what’s left over? Source code management (SCM)?</p>
<p>Like for many others, <code>git</code> is my goto tool for SCM.  Much has been said about the terrible user experience of the <code>git</code> command line and for years I suffered with its design decisions. Thankfully for Emacs users, there is Magit and VC mode which both provide a saner experience for it.</p>
<p>Running a Makefile? Use Emacs <code>compile</code>, which provides command completion for the targets defined in the Makefile and error/warning navigation if needed. (Try out <a href="https://github.com/kickingvegas/casual/blob/main/docs/make-mode.org">Casual Make</a> for editing Makefiles in Emacs.)</p>
<p>Do you need to run a command with arcane arguments repeatedly? Again, Makefile + <code>compile</code> to the rescue where it can be used as a task runner for that command.</p>
<p>Need robust terminal emulation? Eshell will fail you here and you are likely better off using a dedicated terminal emulator app, separate from Emacs. That said, I’ve found the built-in <code>term</code> to be good enough for many curses-style utilities.</p>
<p>Mining data files with piped commands? Eshell is a power tool here: used wrongly and you could figuratively cut off a limb. But used cleverly, Eshell offers great value. More on this later.</p>
<p>So with all these use cases described, why even use Eshell?</p>
<p>Using Eshell becomes a win only if you know <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/">Elisp</a>. With that, you can think of Eshell as an Elisp REPL that can secondarily act as a shell.</p>
<p>Let’s not mince words. For many users this is a high bar, as it takes into account <em>a lot</em> of prerequisite knowledge. That said, learning basic Elisp is trivial for readers already conversant with programming and manageable for those that aren’t. Personally, I was very late (decades!) in taking the time to learn Elisp because I didn’t see the reward in it and so, prioritized accordingly. That hesitancy turned out to be unfounded. Elisp is easy to learn and the reward (or punishment) for knowing it is having the ability to really <em>use</em> the full capabilities of Emacs. (Know Python? Here’s a <a href="https://github.com/kickingvegas/elisp-for-python">cheatsheat for Elisp</a> that I wrote, hop in, the water’s fine…)</p>
<p>Once gained, bringing Elisp knowledge to using Eshell gives you a command line super power: the ability to improvise shell commands with Elisp functions.</p>
<p>Consider the following Eshell example where we wish to apply a command on a set of <code>png</code> files in a directory. Let’s start with a simple example that simply echoes filenames with suffix <code>.png</code>.</p>
<div><pre><span></span><code>$<span> </span><span>for</span><span> </span>i<span> </span><span>in</span><span> </span>*.png<span> </span><span>{</span><span> </span><span>echo</span><span> </span><span>$i</span><span> </span><span>}</span>
</code></pre></div>

<p>In Eshell, you can replace <code>echo $i</code> with an Elisp expression.</p>
<div><pre><span></span><code>$<span> </span><span>for</span><span> </span>i<span> </span><span>in</span><span> </span>*.png<span> </span><span>{</span><span> </span><span>(</span>format<span> </span><span>&#34;%s&#34;</span><span> </span>i<span>)</span><span> </span><span>}</span>
</code></pre></div>

<p>You can also mix shell commands and Elisp via <a href="https://www.gnu.org/software/emacs/manual/html_node/eshell/Dollars-Expansion.html">dollar ($) expansion</a>. Note that $ expansion in Eshell is <em>different</em> from other shells. A deeper reading is on it is recommended to avoid confusion with what works in conventional shells.</p>
<div><pre><span></span><code>$<span> </span><span>for</span><span> </span>i<span> </span><span>in</span><span> </span>*.png<span> </span><span>{</span><span> </span><span>echo</span><span> </span><span>$(</span>format<span> </span><span>&#34;%s&#34;</span><span> </span>i<span>)</span><span> </span><span>}</span>
</code></pre></div>

<p>If you have ImageMagick, installed, you can use the <code>convert</code> utility to change this to a <code>jpeg</code> file, using the Elisp <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/File-Name-Components.html">file name components functions</a> to do the work of getting a desired target name.</p>
<div><pre><span></span><code>$<span> </span><span>for</span><span> </span>i<span> </span><span>in</span><span> </span>*.png<span> </span><span>{</span><span> </span>convert<span> </span><span>$i</span><span> </span><span>$(</span>file-name-with-extension<span> </span>i<span> </span><span>&#34;jpg&#34;</span><span>)</span><span> </span><span>}</span>
</code></pre></div>

<p>Contrast this with the equivalent expression in Bash which I consider to have much more forgettable syntax.</p>
<div><pre><span></span><code>$<span> </span><span>for</span><span> </span>i<span> </span><span>in</span><span> </span>*.png<span>;</span><span> </span><span>do</span><span> </span>convert<span> </span><span>$i</span><span> </span><span>${</span><span>i</span><span>/.png/.jpg</span><span>}</span><span>;</span><span> </span><span>done</span>
</code></pre></div>

<p>Another significance with mixing shell commands and Elisp together is the ability to incorporate Emacs <em>buffers</em> into an improvised workflow. Shell commands are typically designed to work with data organized as files. In contrast, Elisp (rather, Emacs) treats files as a persisted, secondary form of data. Instead, <em>Buffers</em> are the primary data type in Emacs.</p>
<p>Recall the Dired naming example above? Consider the added steps due to using a temporary <em>file</em> <code>foo.sh</code> compared to using a writeable Dired buffer.</p>
<p>Eshell shifts you into thinking differently about working with a prompt, where instead of thinking of output being only a file or (<code>stdout</code>, <code>stderr</code>), the output could also be an Emacs <code>buffer</code>.</p>
<p>With that change in thinking, Eshell is better thought of as a “prompt” interface for Emacs which in turn serves as the interface to all the command line utilities made available to it. In this light, a whole swath of common shell workflows get replaced by Emacs.</p>
<table>


<colgroup>
<col/>

<col/>

<col/>
</colgroup>
<thead>
<tr>
<th scope="col">Workflow</th>
<th scope="col">Shell</th>
<th scope="col">Eshell</th>
</tr>
</thead>
<tbody>
<tr>
<td>File management</td>
<td>Orchestrate <code>cd</code>, <code>ls</code>, <code>cp</code>, <code>rm</code>, <code>mv</code></td>
<td>Run <code>dired {optional path}</code></td>
</tr>

<tr>
<td>View a file</td>
<td>Run <code>more</code> or <code>less</code></td>
<td>Run <code>view-file</code></td>
</tr>

<tr>
<td>SCM with git</td>
<td>Run <code>git</code> command(s)</td>
<td>Run <code>magit {optional path}</code></td>
</tr>

<tr>
<td>View man page</td>
<td>Run <code>man</code></td>
<td>Run Emacs <code>man</code></td>
</tr>

<tr>
<td>Run Makefile</td>
<td>Run <code>make</code></td>
<td>Run <code>make &amp;</code> to send output to a <code>compile</code> buffer</td>
</tr>

<tr>
<td>Remote login</td>
<td>Run <code>ssh</code></td>
<td>Run Eshell Tramp</td>
</tr>

<tr>
<td>Edit a file</td>
<td>Run <code>$EDITOR</code></td>
<td>Run <code>find-file</code></td>
</tr>

<tr>
<td>Manage processes</td>
<td>Run <code>htop</code></td>
<td>Run <code>proced</code></td>
</tr>

<tr>
<td>Search for pattern in a file</td>
<td>Run <code>grep</code></td>
<td>Run Eshell <code>grep</code> to send output to a <code>compile</code> buffer</td>
</tr>

<tr>
<td>Locate a file</td>
<td>Run <code>locate</code></td>
<td>Run Eshell <code>locate</code> to send output to <code>locate</code> buffer</td>
</tr>
</tbody>
</table>

<p>Suffice to say, Eshell reinforces and rewards keeping Emacs users only in Emacs.</p>
<p>Another common shell workflow is using <code>grep</code> with pipes (<code>|</code>) for data mining files. For example:</p>
<div><pre><span></span><code>$<span> </span>grep<span> </span><span>{</span>pat1<span>}</span><span> </span><span>{</span>file<span>}</span><span> </span><span>|</span><span> </span>grep<span> </span>-v<span> </span><span>{</span>pat2<span>}</span><span> </span><span>|</span><span> </span>grep<span> </span><span>{</span>pat3<span>}</span><span> </span>&gt;outfile
</code></pre></div>

<p>Using this pattern indiscriminately in Eshell is a recipe for unpleasant surprise if the <code>file</code> to be mined is large. This is because Eshell will ingest said <code>file</code> <a href="https://www.gnu.org/software/emacs/manual/html_node/eshell/Pipelines.html">into Emacs as part of the pipeline processing</a>. This will be slow. To avoid this, you can prefix each <code>|</code> with an <code>*</code> as follows:</p>
<div><pre><span></span><code>$<span> </span>grep<span> </span><span>{</span>pat1<span>}</span><span> </span><span>{</span>file<span>}</span><span> </span>*<span>|</span><span> </span>grep<span> </span>-v<span> </span><span>{</span>pat2<span>}</span><span> </span>*<span>|</span><span> </span>grep<span> </span><span>{</span>pat3<span>}</span><span> </span>&gt;outfile
</code></pre></div>

<p>Why store a result in a file (<code>outfile</code>) that you have to open to see it and may not care to keep around? Here Eshell gives you the ability to redirect to a <em>buffer</em>.</p>
<div><pre><span></span><code>$<span> </span>grep<span> </span><span>{</span>pat1<span>}</span><span> </span><span>{</span>file<span>}</span><span> </span>*<span>|</span><span> </span>grep<span> </span>-v<span> </span><span>{</span>pat2<span>}</span><span> </span>*<span>|</span><span> </span>grep<span> </span><span>{</span>pat3<span>}</span><span> </span>&gt;#&lt;buffer<span> </span><span>&#34;*my grep results*&#34;</span>&gt;
</code></pre></div>

<p>Note that Eshell supports creating/overwriting (<code>&gt;</code>) and appending (<code>&gt;&gt;</code>) for redirection. Use <code>&gt;</code> with care when working with an existing buffer.</p>
<p>What about piping shell command output to an Elisp function? At the time of this writing, you really can’t though according to <a href="https://www.reddit.com/r/emacs/comments/1llg33y/how_can_i_write_a_function_into_which_i_can_pipe/?utm_source=share&amp;utm_medium=web3x&amp;utm_name=web3xcss&amp;utm_term=1&amp;utm_content=share_button">this Reddit thread</a>, this may change in the future.</p>
<p>If you are used to workflows that bleed out megabytes of data to <code>stdout</code>, you really shouldn’t use Eshell. But with some cleverness, Eshell can help you get insights to your data faster by leveraging all the tools Emacs can offer for this (occur, highlighting, grep, etc.).</p>

<p>IMHO, Eshell is best thought primarily as a prompt for Elisp/Emacs functionality with the secondary benefit of running command line utilities with a “shell-like” experience. It should not be thought of as a “drop-in” replacement for an actual terminal shell. If full terminal emulation is desired, my guidance is to run a dedicated terminal emulator outside of Emacs.</p>
<p>To get the full benefit of using Eshell, you really need to be conversant with Elisp. That said, Eshell is actually a great way to start learning Elisp as it provides you a prompt interface (REPL) in much the same way that other languages like Python, JavaScript, Ruby, Java, Swift, etc do.<sup><a id="fnr.repl" href="#fn.repl" role="doc-backlink">1</a></sup> Especially if you are comfortable with programming, take a day to learn Elisp. You won’t regret it.</p>
<p>Bringing Eshell into my Emacs journey has been amazing and I’m happy to have given it a second take.</p>
<p>Thanks to all the <a href="https://www.gnu.org/software/emacs/manual/html_node/eshell/Contributors-to-Eshell.html">contributors of Eshell</a>.</p>

<p><sup><a id="fn.1" href="#fnr.1">1</a></sup> To clarify, these languages adopted the <a href="https://en.wikipedia.org/wiki/Read–eval–print_loop">idea of a REPL from Lisp development</a> which Elisp is descended from.</p>
<p>
 <a href="http://yummymelon.com/devnull/tag/emacs.html">emacs</a>
</p>
</div></div>
  </body>
</html>
