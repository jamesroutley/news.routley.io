<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://interjectedfuture.com/when-declarative-systems-break/">Original</a>
    <h1>When declarative systems break</h1>
    
    <div id="readability-page-1" class="page"><div>

    <article>

        <header>

                <a href="https://interjectedfuture.com/tag/essays/">Essays</a>
            

            <div>
                <p><a href="https://interjectedfuture.com/author/wil/">
                                <img src="https://www.gravatar.com/avatar/915aac3dfde2fb502ce415d77643a72d?s=250&amp;r=x&amp;d=mp" alt="Wil Chung"/>
                            </a>
                </p>
                <div>
                    
                    <p><time datetime="2025-02-27">27 Feb 2025</time>
                            <span><span>‚Äî</span> 10 min read</span>
                    </p>
                </div>
            </div>

                <figure>
        <img srcset="/content/images/size/w320/2025/02/DALL-E-2025-02-27-12.37.07---A-fluid-watercolor-painting-illustrating-the-contrast-between-order-and-breakage-in-a-declarative-system.-One-side-of-the-image-is-smooth--structured--1.jpeg 320w,
                    /content/images/size/w600/2025/02/DALL-E-2025-02-27-12.37.07---A-fluid-watercolor-painting-illustrating-the-contrast-between-order-and-breakage-in-a-declarative-system.-One-side-of-the-image-is-smooth--structured--1.jpeg 600w,
                    /content/images/size/w960/2025/02/DALL-E-2025-02-27-12.37.07---A-fluid-watercolor-painting-illustrating-the-contrast-between-order-and-breakage-in-a-declarative-system.-One-side-of-the-image-is-smooth--structured--1.jpeg 960w,
                    /content/images/size/w1200/2025/02/DALL-E-2025-02-27-12.37.07---A-fluid-watercolor-painting-illustrating-the-contrast-between-order-and-breakage-in-a-declarative-system.-One-side-of-the-image-is-smooth--structured--1.jpeg 1200w,
                    /content/images/size/w2000/2025/02/DALL-E-2025-02-27-12.37.07---A-fluid-watercolor-painting-illustrating-the-contrast-between-order-and-breakage-in-a-declarative-system.-One-side-of-the-image-is-smooth--structured--1.jpeg 2000w" sizes="(max-width: 1200px) 100vw, 1120px" src="https://interjectedfuture.com/content/images/size/w1200/2025/02/DALL-E-2025-02-27-12.37.07---A-fluid-watercolor-painting-illustrating-the-contrast-between-order-and-breakage-in-a-declarative-system.-One-side-of-the-image-is-smooth--structured--1.jpeg" alt="When declarative systems break"/>
    </figure>

        </header>

        <section>
            <p>A couple of months ago, I had to <a href="https://interjectedfuture.com/r/b66d864c?m=2d0405f3-21cb-4ebd-b053-487f02a00e90">reload everything I knew about reactivity</a> back into my head. I discovered that I missed a large corner of the development around <a href="https://interjectedfuture.com/r/cf91cfb7?m=2d0405f3-21cb-4ebd-b053-487f02a00e90">unstructured reactivity</a>, by way of Signals. From arguments about signals vs. functional components on <a href="https://interjectedfuture.com/r/b999d7a9?m=2d0405f3-21cb-4ebd-b053-487f02a00e90" rel="noreferrer">Twitter</a> and in <a href="https://interjectedfuture.com/r/915c00de?m=2d0405f3-21cb-4ebd-b053-487f02a00e90" rel="noreferrer">post comments</a>, it sounds like the issue concerns developer affordances of different APIs. From the marketing of signal-based frameworks, it sounds like the issue is a <a href="https://interjectedfuture.com/r/c0326bb4?m=2d0405f3-21cb-4ebd-b053-487f02a00e90" rel="noreferrer">matter of performance</a>.</p><p>But the reasons why you&#39;d choose signals over functional component-based frameworks like React have more to do with two things: the shape mismatch between the application data and the UI view and whether the performance requirements can tolerate the mismatch.</p><p>For most web apps with median performance requirements, functional component-based frameworks like React work really well, especially when your application state closely matches your UI structure. The declarative API makes maintenance and the mental model easier than it would be otherwise.</p><p><strong>However, if the gap between the shape of application state and shape of UI views grows, React‚Äôs declarative execution model can lead to inefficient updates, hurting performance.</strong> Without built-in escape hatches, developers facing these mismatches turn to Signals‚Äîtrading some of React‚Äôs declarative reasoning for more precise and performant state updates.</p><h2 id="the-unspoken-assumption">The Unspoken Assumption </h2><p>What happens when a piece of application state needs to be rendered by two sibling UI components? React&#39;s common advice is to <a href="https://interjectedfuture.com/r/63afc986?m=2d0405f3-21cb-4ebd-b053-487f02a00e90" rel="noreferrer">pull that state up to the closest common ancestor</a> and pass that state down as props to the children.</p><p>The fundamental assumption of React is that the shape of your state dependency graph is similar to your component tree. If that&#39;s the case, then the affordances of React and the granularity of reactivity are in alignment. That might hold for many apps, but when it doesn‚Äôt, you end up forcing your component hierarchy to revolve around these shared state.</p><figure><img src="https://interjectedfuture.com/content/images/2025/02/image-18.png" alt="" loading="lazy" width="1600" height="901" srcset="https://interjectedfuture.com/content/images/size/w600/2025/02/image-18.png 600w, https://interjectedfuture.com/content/images/size/w1000/2025/02/image-18.png 1000w, https://interjectedfuture.com/content/images/2025/02/image-18.png 1600w" sizes="(min-width: 720px) 720px"/><figcaption><a href="https://interjectedfuture.com/r/0f92e0a5?m=2d0405f3-21cb-4ebd-b053-487f02a00e90" target="_blank" rel="noreferrer"><span>A talk on recoil.js illustrates an instance where app state mismatches the UI view</span></a></figcaption></figure><p>Imagine a canvas application with sidebars, toolbars, and overlays. An object in this common visual-editing app needs to be represented in both left and right sidebars and the middle canvas. The object is rendered visually on the canvas, as a part of an object hierarchy on the left sidebar, and with its properties on the right sidebar. Each region of the UI might need to observe and mutate the same piece of data, but they all live in different parts of the component tree. Following React‚Äôs recommendation, you keep lifting state until everything that needs to access it can do so.</p><p>Unfortunately, that may mean large swaths of the UI re-render every time the state changes. If your components are mostly functional, that might not be so bad, but if they contain effects (useEffect) or memoization (useMemo), every change can trigger a wave of potential re-computations and callback closures. It‚Äôs error-prone and easy to lose track of dependencies. React also opts for correctness over performance by default, so it&#39;ll default to re-rendering. Makes sense as a design goal, if one considers how confusing it is when an incremental system updates halfway, and functions are considered cheap to run. However, this can also be a source of frustration when the app seems to keep slowing down and you have to keep providing hints to the runtime via dependency lists and various hooks to not over-render. It can be hard to discern why multiple renders occur without profiling tools. In practice, if the users are performance sensitive, it can feel like you&#39;re spending all your time on the submerged mechanics of hinting the declarative runtime instead of touching the viewable components delivering value to users.</p><p>Part of the issue is the double-edge of declarative APIs. They&#39;re great for reducing complexity in the average case, because the developer <em>only</em> needs to declare the intended goal state. There is nothing else. The system figures out <em>how</em> to find and traverse the path from the current state to the goal state. This frees the developer from keeping track of the previous state in order to compute the next state, and managing state is often the source of bugs.</p><p>Unfortunately, every declarative system embeds assumptions about how to traverse the state space during computation from the current state to the goal state. When those assumptions fail, performance suffers because the chosen path from the current state to the goal state is inefficient. Most declarative systems offer no escape hatch or way to influence the execution policy. At least SQL provides EXPLAIN so you can see its plan‚Äîmany others don‚Äôt even offer that. As a result, when performance is critical and these assumptions break, developers often have no choice but to abandon the system entirely and build a new solution from scratch.</p><p>Signals is one dominant alternative. It lets you define a separate dependency graph that tracks how state updates should flow, independent of the UI view tree. Whenever a signal changes, only the specific parts of your interface that depend on it need to re-render. This can lead to substantial performance improvements in applications that have complex or cross-cutting state.</p><p>The trade-off is that freely accessible signals can get messy if every component in the UI view tree can update them. That‚Äôs why library authors often offer namespacing or scoping for signals, so you can define how far their influence extends without losing track of where updates come from. In addition, it leaves behind all the affordances of a declarative API, where the developer only has to declare the intended goal. Hence, developers might need extra help reasoning about state updates, such as a <a href="https://interjectedfuture.com/r/b9fb5e92?m=2d0405f3-21cb-4ebd-b053-487f02a00e90" rel="noreferrer">visual debugger for the state dependency computational graph</a>.</p><p>For developers weighing their options, the trade-off is pretty clear: stick with React if your data aligns well with your UI and you value a straightforward, mature ecosystem. But if you repeatedly find your data graph crossing multiple parts of the UI, or you need to avoid re-renders at all costs, Signals could be your best bet. This can be hard to tell a priori, as both can evolve over time as the understanding of the domain changes and hence the requirements change. In the end, it&#39;s trade-offs.</p><h2 id="declarative-escape-hatches">Declarative escape hatches</h2><p>This question transcends React and Signals. This trade-off plays itself out across the programming landscape: retained mode vs immediate mode, functional vs object-oriented, and in declarative vs imperative configuration management. Even in the world of database queries, where SQL wins by a large margin, there are still skirmishes with imperative alternatives like PL/SQL and Transact-SQL. In almost all cases, the desire for reduced complexity in managing state draws developers towards declarative systems, and the desire for performance pulls them away. Can a declarative system‚Äîone that focuses on describing the end state rather than step-by-step updates‚Äîbe extended to handle edge cases requiring more granular performance?</p><h3 id="improving-execution-internals">Improving execution internals</h3><p>One angle of attack is to keep the declarative API as is, and just improve a declarative system&#39;s ability to judge which computational branch to go down to get to the goal state. The current ability of React to judge what branch to examine is hampered by the limitations of Javascript in this regard.</p><ul><li><strong>Dynamic Types and References</strong>: JS arrays and objects are reference-based, lacking an efficient built-in mechanism for detecting which nested properties have changed. Structural equality checks grow expensive and quickly become impractical for large data.</li><li><strong>Immutable-by-Convention</strong>: React and similar frameworks rely on immutability so they can compare references for performance. Yet even with disciplined immutability, the system can‚Äôt know exactly which pieces of your state changed unless you manually break them into discrete atoms or rely on advanced libraries.</li><li><strong>Component Granularity</strong>: React treats a function or class as the smallest unit of re-render. Fine-grained updates would require skipping parts of a single function‚Äôs output‚Äîsomething that clashes with the idea of purely atomic render functions.</li></ul><p>Let&#39;s try tackling each of these in turn.</p><p>What if we had true immutable complex values? A truly immutable language or runtime, like Clojure or Haskell, can efficiently detect changes via structural sharing. It knows exactly when something has changed, and can avoid computational branches it knows for sure hasn&#39;t changed. The system wouldn&#39;t need heuristics to guess or require hints from the developer. The downside is that immutable values are grow-only, and most languages don&#39;t support their semantics by default. Hence, there would have to be some kind of expiration policy for the history of changes in an immutable value.</p><p>Perhaps instead, we can use version clocks to indicate change internally? Imagine attaching a version clock to each field or sub-object. When that field changes, its clock increments. This allows a more direct mapping of ‚Äòproperty changed ‚Üí which UI depends on it.‚Äô In essence, it introduces partial reactivity: your runtime or compiler can skip re-renders for unaffected properties. On the plus side, this structure isn&#39;t ever-growing, like immutable data structures. And if everything is truly pure and transparent, you won‚Äôt get the wrong computations‚Äîat least in theory. But real apps often have side effects, dynamic property usage, concurrency concerns, or incomplete signals about <em>exactly</em> which bits of code are dependent on which state. That‚Äôs how ‚Äúwrong‚Äù decisions or extra re-renders slip in, even in a system with perfectly immutable data or carefully maintained version vectors.</p><p>Even if branch prediction is solved with immutable values or version vectors that <em>something</em> changed, if your declarative system is still re-running entire ‚Äòcomponents‚Äô or top-level functions, then you only solve half the problem. You know something changed, but you still lack a built-in way to skip re-rendering subparts of the UI unless you subdivide your data into separate states, each pinned to a unique piece of UI.</p><p>What about using algebraic effects for finer granularity than a single functional component? Algebraic effects could theoretically let you intercept specific sub-expressions within a single rendering function. Each sub-expression might read from a piece of state and produce an effect, so if that piece of state doesn‚Äôt change, the runtime can skip re-running that sub-expression. Hence, any state changes within a component are yielding effects that alter a UI View. I think if you squint a little, this is along the lines of what Signal-based frameworks do.</p><p>Lastly, there are algebraic incremental approaches like differential dataflow and DBSP that restrict operations for moving state to those that can be defined incrementally; for any previous input <code>x</code>, if I change the input to <code>x + ùö´</code>, we can compute <code>f(x + ùö´)</code> without recomputing <code>f(x)</code> all over again. This approach seems very promising, but I suspect there is a different kind of alignment problem here. Just like in CRDTs, while the merge might be algebraically correct, you might get semantically nonsense merges. I suspect it might be the same for these algebraic incremental approaches.</p><h3 id="giving-declarative-policy-hints">Giving declarative policy hints</h3><p>Perhaps any domain will have edge cases that need to be nudged by the developer. But instead of diving into the minutiae of when to re-render each sub-expression imperatively as an escape-hatch, one could imagine a higher-level, purely declarative policy system. In this approach, you‚Äôd define explicit relationships among various state slices and UI views. For instance, you might declare, ‚ÄúThese three states are tightly coupled and should always update together,‚Äù or ‚ÄúThis component‚Äôs render only depends on fields A, B, and C from the global state.‚Äù</p><p>The runtime could then use those policies to group updates intelligently, determining which components can or should re-render at the same time. This is less about micromanaging the <em>exact lines of code</em> to skip and more about giving the framework a bird‚Äôs-eye view of <em>which parts of the data graph belong together.</em></p><p>In principle, this moves some complexity from low-level reactivity (like signals) into a set of higher-level declarations‚Äîan attempt to keep the developer experience more ‚Äòbig picture‚Äô rather than diving into partial reactivity on a field-by-field basis. But implementing such a policy system is still far from trivial.</p><p>One major challenge is the need for a purely declarative way to define how state partitions map to UI partitions, so the runtime or compiler can interpret those policy statements and assemble an efficient dependency graph. Even then, developers typically end up labeling or grouping their data‚Äîa practice that feels a lot like signals, just at a coarser level‚Äîrevealing how much low-level reactivity logic still lurks behind the declarative veneer.</p><p>It‚Äôs an intriguing middle ground. By defining relationships‚Äîrather than line-by-line checks‚Äîyou‚Äôre nudging the system to do partial updates without stepping fully into an imperative approach. Yet, you still risk complexity if policies become too fragmented or if states have inter-dependencies that defy simple grouping. Ultimately, it remains an open question whether any such policy system could achieve the fine-grained performance benefits of Signals without reintroducing a fair amount of ‚Äòreactivity bookkeeping‚Äô behind the scenes.</p><h3 id="the-tension-in-declarative-systems">The Tension in Declarative Systems</h3><p>Ultimately, any purely declarative system is predicated on the idea that you describe <em>what</em> you want, and the framework figures out <em>how</em> to accomplish it. Once you start dictating precisely <em>which parts</em> of the system can skip reprocessing‚Äîand under what conditions‚Äîyou‚Äôre veering into partial reactivity. You‚Äôre effectively telling the system how it should schedule updates, imposing custom rules on the execution plan.</p><p>Of course, you can graft fine-grained controls onto a declarative model, but each addition gradually erodes its simplicity. You might need to annotate or restructure code so the runtime can pinpoint which sub-expressions rely on specific pieces of data, while the framework itself maintains a specialized ‚Äúupdate graph‚Äù‚Äîmuch like Signals. Inevitably, you‚Äôve stepped away from a purely declarative approach into a hybrid that merges declarative goals with partial reactivity under the hood.</p><p>You can approach this issue asymptotically, but there‚Äôs no free lunch: staying fully declarative often means accepting broad recomputations that go beyond what‚Äôs strictly necessary, while trying to micro-optimize every expression leads you into describing <em>how</em> sub-expressions should update‚Äîedging into partial reactivity. Put differently, the deeper you dive into fine-grained updates, the less you can rely on a purely declarative ‚Äúdescribe the goal‚Äù style, because you inevitably end up declaring <em>which pieces</em> of your code need to update and <em>when</em>, rather than just <em>what</em> the final state should be.</p><p>In other words, <strong>the more the system needs to handle fine-grained updates, the less purely declarative it becomes.</strong> You can blend paradigms, but that hybrid approach often demands more mental overhead and/or compile-time machinery.</p><h3 id="end-of-the-day">End of the day</h3><p>So, is it <em>impossible</em> for a declarative system to handle all edge cases with top-tier performance? Not strictly. You <em>can</em> embed partial reactivity or Signals-like mechanisms via deep immutability, version clocks, algebraic effects, or advanced compile steps. But each move in that direction redefines the purity of your declarative abstraction and ushers in added complexity.</p><p>If your data shape aligns with your UI and you don‚Äôt need hyper-optimized updates, a declarative framework remains a wonderful solution. But for edge cases‚Äîlike real-time apps with interwoven data dependencies‚Äîother paradigms do a better job of pinpointing precisely what changed and when. After all, it‚Äôs hard to remain ‚Äòpurely declarative‚Äô once you start asking the system to skip internal steps under certain conditions.</p><p>That‚Äôs the central tension: declarative frameworks elegantly solve the common case but inevitably bump into scenarios that push them beyond their comfort zone. There‚Äôs no perfect solution that‚Äôs both purely declarative and infinitely adaptable. As soon as you need the latter, you‚Äôre knocking on the door of an imperative stance on updates.</p>
        </section>

    </article>


</div></div>
  </body>
</html>
