<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://belkadan.com/blog/2020/04/Swift-on-Mac-OS-9/">Original</a>
    <h1>Swift on Mac OS 9 (2020)</h1>
    
    <div id="readability-page-1" class="page"><div>
		<p>It’s April 1, and that means it’s both <a href="https://en.wikipedia.org/wiki/April_Fools&#39;_Day">April Fools’ Day</a> and <a href="https://en.wikipedia.org/wiki/History_of_Apple_Inc.">the anniversary of the founding of Apple Inc.</a> While this year is a sober one due to <a href="https://staythefuckhome.com">current events</a>, I think a lot of people still appreciate what people are creating and sharing to keep spirits up, whether that be music or art or…impractical programming projects. And while <em>pranks</em> on April Fools’ seem less and less fun<sup id="fnref:harder" role="doc-noteref"><a href="#fn:harder">1</a></sup>, obvious jokes and whimsy, not at anyone’s expense, are still something I believe in…and even better if they actually work.</p>

<p>Last year I implemented <a href="https://forums.swift.org/t/new-code-visualizer-for-swift-source-is-view/22454">the world’s best code visualizer</a>. This year I decided to seriously attempt something that I’d thought about in the past: getting a <a href="https://swift.org">Swift</a> program to run on Mac OS 9.<!--more--></p>

<h3 id="whats-a-mac-osnbsp9">What’s a Mac OS 9?</h3>

<p><img src="https://belkadan.com/blog/2020/04/Swift-on-Mac-OS-9/macos9.png" alt="" title="Image from MacintoshRepository.org"/></p>

<p>Twenty (!) years ago, before the macOS<sup id="fnref:names-osx" role="doc-noteref"><a href="#fn:names-osx">2</a></sup> we know today, there was another operating system known as “Mac OS”.<sup id="fnref:names-classic" role="doc-noteref"><a href="#fn:names-classic">3</a></sup> It was one of the first OSs to use a GUI at all, something that we pretty much take for granted these days. It also dates from the days when only one program could run at a time; because of that, even the latest version uses <em>cooperative multitasking</em> to run multiple programs—that is, a program has to yield its time to let others run.<sup id="fnref:MultiFinder" role="doc-noteref"><a href="#fn:MultiFinder">4</a></sup> If a program crashed or overwrote memory it wasn’t supposed to, there was a good chance you’d have to restart the whole system.</p>

<p>Mac OS 9 ran on <a href="https://en.wikipedia.org/wiki/PowerPC">PowerPC</a> processors, which were also used in the GameCube, PS3, <em>and</em> Xbox 360; earlier versions of the OS had started on Motorola’s <a href="https://en.wikipedia.org/wiki/Motorola_68000_series">68k</a> CPU series. Its successor Mac OS X<sup id="fnref:ten" role="doc-noteref"><a href="#fn:ten">5</a></sup> also ran on PowerPC when it first launched; it wasn’t until 10.4 that Apple began to switch to Intel processors instead, and 10.6 when PowerPC was finally dropped.</p>

<p>Mac OS X was a huge step forward from Mac OS 9 in a number of ways, including <em>preemptive multitasking</em> so that you could <em>actually</em> run multiple things at once. But Apple didn’t want to just leave OS 9 programs behind, so they did two things:</p>

<ul>
  <li>
    <p>The <em><a href="https://en.wikipedia.org/wiki/List_of_macOS_components#Classic">Classic environment</a></em> set up a sandbox that looked enough like Mac OS 9 to run Classic Mac OS programs directly in Mac OS X. Because the Classic environment was itself an app, all the programs that ran inside it were protected from interfering with other Mac OS X programs and vice versa. It really was quite effective, and actually survived longer than booting into Mac OS 9 (which never received support for newer PowerPC processors). But its life ended with the switch to Intel-powered Macs—Classic was built on running the instructions in the original apps directly, only having to provide compatibility shims for libraries. Think of it like <a href="https://www.winehq.org">Wine</a> / <a href="https://www.codeweavers.com">CrossOver</a> rather than <a href="https://www.virtualbox.org">VirtualBox</a> / <a href="https://www.parallels.com/products/desktop/">Parallels</a>.<sup id="fnref:Rosetta" role="doc-noteref"><a href="#fn:Rosetta">6</a></sup></p>
  </li>
  <li>
    <p><em><a href="https://en.wikipedia.org/wiki/Carbon_(API)">Carbon</a></em> was a packaged-up version of the old Mac OS <em>Toolbox</em> APIs so that you could write Mac OS X apps the same way you always had. You basically just recompiled your app and added an extra annotation saying you were “Carbonized”. (<a href="https://developer.apple.com/mac-catalyst/">Sound familiar?</a> <sup id="fnref:catalyst" role="doc-noteref"><a href="#fn:catalyst">7</a></sup>) Fun aside: This is the reason (one of the reasons?) <a href="https://developer.apple.com/documentation/corefoundation">Core Foundation</a> exists—to <a href="https://youtu.be/NTGJm2BdqSU">provide a common interface between Carbon and Cocoa</a>. (h/t <a href="https://twitter.com/llahsram/status/1246118151118450690">Marshall Elfstrand</a> for the video link.)</p>
  </li>
</ul>

<p>Classic ended with the switch to Intel processors back in the 2000s, but Carbon worked all the way up to last year, macOS Mojave. Apple never released a 64-bit version of Carbon, presumably to encourage developers to move to Cocoa, and with last year’s macOS Catalina, support for 32-bit apps was dropped <del>entirely</del> with very few exceptions.<sup id="fnref:32-bit" role="doc-noteref"><a href="#fn:32-bit">8</a></sup></p>

<h3 id="whats-the-goal">What’s the goal?</h3>

<p>Since I learned to program on Classic Mac OS, and years later spent a good chunk of my career working on <a href="https://swift.org">Swift</a>, I’ve had the tantalizing thought that I’d like to <strong>write a program in Swift and run it on Mac OS 9.</strong> That is,</p>

<ul>
  <li>I write Swift source code that calls Carbon / Toolbox APIs.</li>
  <li>I compile it for PowerPC with (a version of) the Swift compiler.</li>
  <li>I package it up as necessary for Mac OS 9.</li>
  <li>Profit!</li>
</ul>

<p>Is this useful? No! Absolutely not! But neither was <a href="https://belkadan.com/blog/2020/01/ROSE-8/">ROSE-8</a>, and yet I still learned a lot doing it.</p>

<p>As you probably guessed, I managed to accomplish this, or I wouldn’t be writing this blog post. So, without further ado, here’s a picture of a Swift Toolbox app running on Mac OS 9.2, on my friend Nadine’s Power Mac G4. (Check out that blazing fast 400MHz processor!)</p>

<p><a href="https://belkadan.com/blog/2020/04/Swift-on-Mac-OS-9/running.jpg">
	<img src="https://belkadan.com/blog/2020/04/Swift-on-Mac-OS-9/running.jpg" alt="You can see BitPaint running in the middle, and the Classic version of Apple System Profiler showing that yes, this is Mac OS 9.2."/>
</a></p>

<p>I assume a good number of people reading this would like to know how to do it too!</p>

<ul>
  <li>
    <p><strong>If you want to build your own PPC-capable Swift compiler</strong>, check out the following repositories:</p>

    <pre><code>git clone https://belkadan.com/source/ppc-swift-project
cd ppc-swift-project
git clone -b ppc-swift https://belkadan.com/source/swift
git clone -b ppc-swift https://belkadan.com/source/llvm-project
git clone https://github.com/apple/swift-cmark cmark
make  # quick start to build swiftc and the stripped-down stdlib
</code></pre>

    <p>Note the directory and branch names of the sub-repos, and note that they should be nested inside the ppc-swift-project repo. <strong>You will also need the <a href="https://github.com/ksherlock/mpw"><code>mpw</code></a> emulator and a copy of the <a href="https://en.wikipedia.org/wiki/Macintosh_Programmer%27s_Workshop">Macintosh Programmer’s Workshop</a> tools<sup id="fnref:mpw-img" role="doc-noteref"><a href="#fn:mpw-img">9</a></sup></strong> to build an actual app using modern macOS.</p>
  </li>
  <li>
    <p><strong>If you want a prebuilt PPC-capable Swift toolchain</strong>, here’s one: <a href="https://www.dropbox.com/s/g3c6tnsg08z6zgv/ppc-swift-toolchain.zip?dl=1">ppc-swift-toolchain</a>. Note that while I’ve put a built Swift.o in this toolchain, you’ll probably only have success with optimized code that doesn’t actually have any remaining links to the stdlib (i.e. everything is inlined away). <strong>You will also need the <a href="https://github.com/ksherlock/mpw"><code>mpw</code></a> emulator and a copy of the <a href="https://en.wikipedia.org/wiki/Macintosh_Programmer%27s_Workshop">Macintosh Programmer’s Workshop</a> tools.<sup id="fnref:mpw-img:1" role="doc-noteref"><a href="#fn:mpw-img">9</a></sup></strong></p>

    <p>You may still want to check out the example in the <a href="https://belkadan.com/source/ppc-swift-project">ppc-swift-project</a> repo. The required flags for <code>swiftc</code>, <code>PPCLink</code>, and <code>Rez</code> can be a little finicky. (And note that the <code>SIZE</code> and <code>carb</code> resources are required for any Carbon app, so you can’t just skip the Rez part if you actually want to run your app.)</p>
  </li>
  <li>
    <p><strong>If you just want to try a built version of BitPaint</strong>, here’s one: <a href="https://belkadan.com/blog/2020/04/Swift-on-Mac-OS-9/BitPaint-swift.hqx">BitPaint-swift.hqx</a>.</p>

    <p><a href="https://en.wikipedia.org/wiki/BinHex"><img src="https://belkadan.com/blog/2020/04/Swift-on-Mac-OS-9/obi-wan.jpg" alt="(&#34;.hqx. Now that&#39;s an extension I haven&#39;t heard in a long time.&#34;)"/></a></p>
  </li>
</ul>

<p>I’d like to hear about anything you make with these tools! Meanwhile, if you’d like to hear how I made this work, read on.</p>

<h3 id="gathering-materials">Gathering materials</h3>

<p>The last time I was building Classic Mac OS apps, I was using <a href="https://www.macintoshrepository.org/577-codewarrior-pro-6">CodeWarrior</a>. Actually, calling that “building Classic Mac OS apps” was a stretch; I was learning C and using CodeWarrior’s terminal I/O library to get a stdin/stdout interface that Classic Mac OS didn’t have natively. (Remember, no command line!) I could try to get some version of CodeWarrior running again, but that didn’t seem like the most convenient thing. I didn’t think I’d be able to get the Swift <em>compiler</em> running on Classic, so I’d be shuttling object files back and forth between OSs to get anything done.</p>

<p>Fortunately for me, I’m not the only one interested in building Classic apps on modern macOS. At some point I found about the <a href="https://github.com/ksherlock/mpw"><code>mpw</code></a> project: an emulator specifically for running Apple’s <a href="https://en.wikipedia.org/wiki/Macintosh_Programmer%27s_Workshop">Macintosh Programmer’s Workshop</a> tools. And I knew it was going to work, too, because Steve Troughton-Smith, (in)famous in the Apple community for finding undocumented and prerelease features in Apple’s OSs, had <a href="https://www.highcaffeinecontent.com/blog/20150124-MPW,-Carbon-and-building-Classic-Mac-OS-apps-in-OS-X">written up his experiences</a> building an app with <code>mpw</code> that ran on System 1 all the way up to modern Mac OS X, just by building with the appropriate compiler and against the appropriate libraries.</p>

<p>If you’re interested in all this, I highly recommend checking out his <a href="https://www.highcaffeinecontent.com/blog/20150124-MPW,-Carbon-and-building-Classic-Mac-OS-apps-in-OS-X">blog post</a>. Not only was this the reference I used to get started, but the app you see running in the above picture, BitPaint, is Troughton-Smith’s test app, ported to Swift. (I did ask him ahead of time if it was okay to use his app for a hobbyist project.) Longtime Mac developer Gwynne Raskind also gave a two-part high-level tour of the Toolbox APIs on Mike Ash’s blog several years ago (<a href="https://mikeash.com/pyblog/friday-qa-2012-01-13-the-mac-toolbox.html">part 1</a> | <a href="https://mikeash.com/pyblog/the-mac-toolbox-followup.html">part 2</a>); fortunately, Carbon takes care of a fair amount for us even on Mac OS 9.</p>

<p>So okay. What does MPW give us?</p>

<ul>
  <li>A PowerPC compiler</li>
  <li>A PowerPC assembler</li>
  <li>A PowerPC linker</li>
  <li>The Classic Mac OS header files</li>
  <li>The Classic Mac OS library stubs, for linking against</li>
  <li>A bunch of object and binary inspection tools, which we don’t need for the finished product but which I made a lot of use of when trying to <a href="#a-week-of-mysterious-failures">debug mystery misbehavior</a></li>
</ul>

<p>That’s pretty good; as Troughton-Smith’s blog post shows, it’s enough to build an entire app that’ll run on Classic. My idea was to take object files produced by a modern compiler and feed them to the PowerPC linker, which means I’ll additionally need:</p>

<ul>
  <li>A modified version of the Swift compiler that supports emitting MPW-compatible object files</li>
  <li>Some stripped-down form of the Swift standard library and runtime (enough to read in and interact with Carbon headers, at least)</li>
  <li>An actual machine running Mac OS 9. I <em>have</em> one, but not the charger for it, and so I did most of my testing using <a href="https://sheepshaver.cebix.net">SheepShaver</a>. My friend Nadine provided some testing on actual machines once things were working.</li>
</ul>

<p>And, well, that should be it! So, off we go.</p>

<h3 id="modern-compiler-classic-linker">Modern compiler, classic linker</h3>

<p>To make things more manageable, I set an intermediate goal: build an app using <em>Clang,</em> the modern C compiler that ships with Xcode. Clang uses the same <a href="http://llvm.org">LLVM</a> infrastructure as the Swift compiler, so I figured I could deal with all the object format and workflow issues in Clang, and then move on to the Swift-specific parts.</p>

<p>The first thing I did was try to figure out what the file format was for PowerPC object files. It turns out it’s a format called XCOFF; searching for modern documentation on this turned up an <a href="https://www.ibm.com/support/knowledgecenter/ssw_aix_71/filesreference/XCOFF.html">IBM reference doc</a>. Pretty much no one else uses this format, which was not encouraging. The first time I started looking into this project, I was worried I’d have to have my compiler write out assembly code and then send <em>that</em> through the MPW PowerPC assembler…after fixing it up to account for the differences in how LLVM and MPW print PowerPC assembly.</p>

<p>However, when I checked to see if LLVM supported XCOFF, I was in for a stroke of luck. It turns out IBM has started adding support for XCOFF to LLVM just last year, as part of <a href="https://lists.llvm.org/pipermail/llvm-dev/2019-February/130175.html">adding support for their AIX OS</a>…<em>which runs on PowerPC.</em> So I could ask Clang to generate XCOFF files for AIX, which means it should only be a short step to making it generate XCOFF files for Classic Mac OS.</p>

<p>At this point I remembered a bit of trivia. <a href="https://en.wikipedia.org/wiki/AIM_alliance">Apple and IBM used to have a close partnership, along with Motorola.</a> They’d even made some common standards that were used across platforms and CPUs, though perhaps with less impact than they’d hoped. Was it possible that AIX and Classic Mac OS used the same calling conventions for their procedures, and they could just interoperate without any extra work?</p>

<p>I got lucky: the answer is (nearly) yes. The <a href="https://www.ibm.com/support/knowledgecenter/en/ssw_aix_72/assembler/idalangref_reg_use_conv.html">AIX register conventions</a> and <a href="https://www.ibm.com/support/knowledgecenter/en/ssw_aix_72/assembler/idalangref_runtime_process.html">stack conventions</a> match up with the ones in the <a href="https://developer.apple.com/library/archive/documentation/mac/pdf/MacOS_RT_Architectures.pdf">Mac OS Runtime Architectures</a> guide. That meant I could feed object files produced by Clang directly into MPW’s <code>PPCLink</code> and get a working Classic Mac OS binary out.</p>

<p>I’m pretty sure my mouth fell open when I first saw this work.</p>

<pre><code>% clang -c test.c \
    -target powerpc-ibm-aix-xcoff \
    -isystem ${MPW}/Interfaces/CIncludes \
    -integrated-as \
    -fpascal-strings
% mpw PPCLink test.o ${PPC_LIBRARIES} -o Test
</code></pre>

<p>That should work with just top-of-master-branch LLVM/Clang (and a very simple test.c). I did end up needing to change LLVM in a few ways in the end, but it’s really fairly minimal, so much thanks to the IBM folks for doing the hard part of the work for me!</p>

<h3 id="now-do-swift">Now do Swift</h3>

<p>Being able to compile a simple test program was a great milestone, but I had to do a fair bit of work before I could get swiftc to compile a whole BitPaint. Here are some of the highlights:</p>

<ul>
  <li>
    <p><strong>Teach Swift about the PPC/AIX target.</strong> This mostly involved adding <code>ppc</code> and <code>AIX</code> cases to switch statements across the Swift compiler, but also involved making a simple description of the Swift calling conventions for Clang (which I cribbed from the 32-bit ARM implementation) and then assuring the PPC/AIX backend that this was an okay calling convention to be using. I got lucky in the amount of work I had to do here because Swift already supports 32-bit ARM, little-endian 64-bit PowerPC (when running Linux), and big-endian 64-bit s390x (another IBM architecture); all the pieces were already in place.</p>
  </li>
  <li>
    <p><strong>Add support for Pascal strings.</strong> The Mac’s first high-level programming language was Pascal, not C! As such, the default format for strings throughout the Toolbox APIs was <em>Pascal strings</em> (a length byte followed by string data) rather than <em>C strings</em> (string data followed by a null byte). With the <code>-fpascal-strings</code> command-line flag, Clang supports static Pascal strings with the syntax <code>&#34;\pHello World&#34;</code>. The <code>\p</code> would be replaced by the length of the string (which must be no more than 255 bytes) so that you didn’t have to count it yourself. <a href="https://belkadan.com/source/swift/commitdiff/293d4b39ab9bbfd3f0762b6883da860e3601d373">I hacked this into Swift as well</a>, and while my implementation probably has problems<sup id="fnref:utf-8" role="doc-noteref"><a href="#fn:utf-8">10</a></sup>, it was enough to get simple things working.</p>
  </li>
  <li>
    <p><strong>Turn off reflection support and nearly all runtime metadata.</strong> The Swift runtime is very powerful, but I didn’t want to write much of a runtime for this project, which was primarily about calling a bunch of C functions. Beyond that, though, the default format for Swift metadata makes heavy use of <em>relative addressing</em> (mainly to reduce startup time, but <a href="https://youtu.be/G3bpj-4tWVU">learn more here</a>) as well as symbols pointing inside of a global, and the LLVM XCOFF implementation doesn’t (yet?) support either. So to get to a working proof-of-concept, I aggressively commented out parts of IRGen that made use of either feature. I’d like to get some of the static metadata back at some point, but reflection’s not something I’m ever interested in. Probably.</p>
  </li>
  <li>
    <p><strong>Make a smol stdlib.</strong> The full Swift standard library has a <em>lot</em> of things in it I don’t need, and some that I wouldn’t even know <em>how</em> to implement. (What’s a String in a world that can’t assume Unicode?) But all the logic to integrate with C code is based on having some basic types in the standard library (like Int16 and UnsafeMutablePointer). What I ended up doing was taking a subset of the standard library sources, and then adding additional files and commenting things out until it worked.</p>

    <p>…haha, nope, even that wasn’t good enough. My early attempts at this compiled okay, but they managed to crash PPCLink when I tried to write a test program, presumably because there’s just <em>too many symbols</em> in the standard library. So I cut things down to an even <em>smaller</em> subset, and that (eventually) worked. Of course, I was working on this at the same time as I was modifying the compiler to get to a working proof-of-concept, so I think I ultimately went further than I needed to. (A bunch of symbols are only used for runtime metadata purposes.) As mentioned above, non-optimized builds of non-trivial programs don’t work yet, so I don’t know if I’m in the danger zone or not, but I might try to add a few more things back in.</p>

    <p>Rather than modify the actual Swift repo for this, I decided to keep my stripped-down standard library separate, so you can find it in the <a href="https://belkadan.com/source/ppc-swift-project">ppc-swift-project</a> repo. <strong>This might be a good reference for someone looking for a C-compatible, runtime-less subset of Swift</strong>, perhaps for an embedded or other resource-constrained environment.</p>
  </li>
  <li>
    <p><strong>Disable jump tables.</strong> LLVM optimizes switch statements into <em><a href="https://en.wikipedia.org/wiki/Branch_table">jump tables</a></em> when it looks like it’ll help performance and/or code size, but its default implementations of jump tables also weren’t supported in the LLVM XCOFF implementation. I imagine the AIX folks will get around to implementing this sooner or later, but for now I just disabled jump tables entirely, forcing the compiler to emit switches as a series of <code>if</code>s instead.</p>
  </li>
</ul>

<p>You can check out all the changes in the <a href="https://belkadan.com/source/swift/shortlog/refs/heads/ppc-swift">swift</a> and <a href="https://belkadan.com/source/llvm-project/shortlog/refs/heads/ppc-swift">llvm-project</a> repos, if you’re curious. Very few are appropriate for upstreaming to their respective projects, but I’ll try to get the ones that <em>are</em> relevant upstreamed at some point.</p>

<h3 id="a-week-of-mysterious-failures">A week of mysterious failures</h3>

<p>Having made all the changes above, I had an app that worked! In Swift!</p>

<p>…except, it only worked some of the time. I’d change something arbitrary and suddenly events wouldn’t register any more. It got so bad that I added a counter: after <em>any</em> ten events, exit the app. Without that, I’d get trapped, unable to even quit without restarting the (virtual) machine. Even in a seemingly working version, my friend Nadine reported that trying to use the Reset command caused the app to crash. What was going on?</p>

<p>I decided I had to get to the bottom of something strange I’d seen earlier: even the <em>Clang</em> version of the program didn’t work correctly when I turned on optimizations. It’s possible that that was a bug in IBM’s newly-added AIX support, or 32-bit PowerPC support since it’s not such a common platform, or even LLVM’s optimizations. It could be that AIX and Classic Mac OS really weren’t as similar as I thought they were, and so my code wasn’t agreeing with the system code on how things were supposed to work. And it could be that the optimized code was using an instruction that SheepShaver didn’t support, though that didn’t really seem to match the symptoms.</p>

<p>And the symptoms were weird. Some local variables were getting corrupted, but others weren’t. So I started testing everything I could think of:</p>

<ul>
  <li>was the stack aligned properly?</li>
  <li>was the stack pointer somehow not getting restored properly?</li>
  <li>was the glue code for cross-library calls trashing other data?<sup id="fnref:indirect" role="doc-noteref"><a href="#fn:indirect">11</a></sup> (see the <a href="https://developer.apple.com/library/archive/documentation/mac/pdf/MacOS_RT_Architectures.pdf">Mac OS Runtime Architectures</a> guide)</li>
  <li>was there something causing the Code Fragment Manager (dynamic linker) to put the wrong address in for cross-library calls?</li>
</ul>

<p>Without being able to rely on logging, I made the simplest textual debug output facility I could: modifying the title of a menu. (It later turned out that writing to stdout in Mac OS 9 automatically results in a file being created, so I could have used that instead.) I wrote C functions that tracked the current stack pointer to make sure it was getting restored properly; I made good use of the <code>DumpXCOFF</code> and <code>DumpPEF</code> tools that came with MPW; I learned how PEF “pidata” (“pattern-initialized data”) worked and tried to step through CFM relocations by hand (again, see the <a href="https://developer.apple.com/library/archive/documentation/mac/pdf/MacOS_RT_Architectures.pdf">Mac OS Runtime Architectures</a> guide). I even started trying to decompile some of the actual system libraries to see if they were doing anything suspicious, even though a bug in the actual Mac OS 9 seemed incredibly unlikely. This led all the way to learning about the “toolbox ROM”, which isn’t actually ROM at all: it’s a boot script and a compressed set of system libraries. (It’s called that because it’s content that <em>used</em> to be in ROM.) Fortunately <a href="https://github.com/cebix/macemu/blob/2e302d60a337daa252c6992335e6365a9beac83f/SheepShaver/src/rom_patches.cpp#L148">SheepShaver already knows how to load it</a>, which meant that I could do the same decompression and then manually split out the individual libraries.</p>

<p>Yeah, I got way off in the weeds. I learned a lot, though!</p>

<p>Finally, I looked at the decompiled optimized code—the C version, not the Swift version. I observed that the variable getting corrupted was in general-purpose register 13. That’s supposed to be an okay place to put data in Classic Mac OS (and in 32-bit AIX, and in 32-bit Mac OS X), but I decided I didn’t trust that, particularly because that register had been used to track thread-local storage in 64-bit AIX. So I marked r13 as reserved…</p>

<p>…and the problems went away. Optimized, non-optimized, even with <a href="https://clang.llvm.org/docs/ClangCommandLineReference.html#cmdoption-clang-fstack-protector"><code>-fstack-protector-all</code></a> on. And Swift.</p>

<p>(Debugging this took about a week, unfortunately, which led to this project being a little less ambitious than I originally wanted.)</p>

<h3 id="future-directions">“Future directions”</h3>

<p>What didn’t I get to? An awful lot, actually.</p>

<ul>
  <li>There’s no runtime at all, which means no dynamic allocation (among other things).</li>
  <li>There’s no type metadata, which means no generics (that aren’t optimized away).</li>
  <li>There’s no field metadata, which means no key paths (that aren’t optimized away).</li>
  <li>There’s no Unicode support, so no Strings. Arguably I could make a String without Characters, or a String using <a href="https://en.wikipedia.org/wiki/Mac_OS_Roman">MacRoman</a> as the native encoding, but it wouldn’t necessarily look much like today’s Swift.String.</li>
  <li>There are a bunch of other standard library things missing because I wanted to get the proof-of-concept working, but also because <code>PPCLink</code> was choking on large object files. If I do get more standard library stuff working, I’ll probably split it out of the ‘Swift’ module somehow.</li>
  <li>I had to mess with <a href="https://en.wikipedia.org/wiki/Linkage_(software)">linkage</a> in a number of ways to make the LLVM XCOFF backend happy, so I’m not sure multi-file builds would work. I didn’t even test it.</li>
  <li>I’m using Carbon, which means that my program <em>ought</em> to work on older versions of Mac OS X as well, but my friend Nadine tried and it didn’t, and it wasn’t a priority to figure out.</li>
  <li>I wanted to try making nice abstractions on top of the some of the Toolbox APIs.</li>
  <li>I wanted to make more complicated example apps!</li>
</ul>

<p>Maybe I’ll follow up on some of these, but I’ve been putting a lot of effort into making sure I could finish this by April 1, so I should probably get to some of the things I’ve been neglecting in favor of this project instead.</p>

<h3 id="summary">Summary</h3>

<p>This project took a lot of time, even though I (1) know a lot about compilers and (2) hacked my way to success instead of being careful and maintaining proper software development practices. But I learned a lot, and I accomplished a goal I’ve had in the back of my mind for a long time.</p>

<p>If you made it all the way to the end of the article, here’s a reward: BitPaint running under Classic on Mac OS X 10.2 (also courtesy of Nadine).</p>

<p><a href="https://belkadan.com/blog/2020/04/Swift-on-Mac-OS-9/classic.jpg">
	<img src="https://belkadan.com/blog/2020/04/Swift-on-Mac-OS-9/classic.jpg" alt="You can see BitPaint running in the middle, and the Classic version of Apple System Profiler...but also the Mac OS X &#34;About This Computer&#34; box showing 10.2.8."/>
</a></p>

<p>Stay safe, everyone, and help the people around you when you can. And if anybody makes something with this project, I want to hear about it!</p>




		<p>
			This entry was posted on
			<a href="https://belkadan.com/blog/2020/04">April</a>
			01,
			
				<a href="https://belkadan.com/blog/2020">2020</a>
				and is filed under
				<a href="https://belkadan.com/blog/technical">Technical</a>.
			
			
			
				Tags:
				
					<a href="https://belkadan.com/blog/tags/swift">Swift</a>, 
				
					<a href="https://belkadan.com/blog/tags/mac-os-classic">Mac OS Classic</a>, 
				
					<a href="https://belkadan.com/blog/tags/compilers">Compilers</a>
				
			
		</p>
	</div></div>
  </body>
</html>
