<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://trace.yshui.dev/2024-05-copilot.html#did-github-copilot-really-increase-my-productivity">Original</a>
    <h1>Did GitHub Copilot increase my productivity?</h1>
    
    <div id="readability-page-1" class="page"><div>
                        
<p>I had free access to GitHub Copilot for about a year, I used it, got used to it, and slowly started to take it for granted, until one day it was taken away. I had to re-adapt to a life without Copilot, but it also gave me a chance to look back at how I used Copilot, and reflect - had Copilot actually been helpful to me?</p>
<p>Copilot definitely feels a little bit magical when it works. It&#39;s like it plucked code straight from my brain and put it on the screen for me to accept. Without it, I find myself getting grumpy a lot more often when I need to write boilerplate code - &#34;Ugh, Copilot would have done it for me!&#34;, and now I have to type it all out myself. That being said, the answer to my question above is a very definite &#34;no, I am more productive without it&#34;. Let me explain.</p>
<p><strong>Disclaimer!</strong> This article only talks about my own personal experiences, as you will be able to see, the kind of code I ask Copilot to write is probably a little bit atypical. Still, if you are contemplating if you should pay for Copilot, I hope this article can serve as a data point. Also, I want to acknowledge that generative AI is a hot-potato topic right now - Is it morally good? Is it infringing copyright? Is it fair that companies train their model on open source code then benefit from it? Which are all very very important problems. However please allow me to put all that aside for this article, and talk about productivity only.</p>
<p>OK, let me give you some background first. For reasons you can probably guess, I do not use Copilot for my day job. I use it for my own projects only, and nowadays most of my free time is spent on a singular project - <a href="https://github.com/yshui/picom">picom</a>, a X11 compositor, which I am a maintainer of. I am not sure how many people reading this will know what a &#34;compositor&#34; is. It really is a dying breed after all, given the fact X11 is pretty much at its end-of-life, and everyone is slowly but surely moving to wayland. Yes, each of the major desktop environments comes with its own compositor, but if you want something that is not attached to any DE, picom is pretty much the only option left. Which is to say, it is a somewhat &#34;one of a kind&#34; project.</p>
<p>Of course, as is the case with any software projects, you will be able to find many commonly seen components in picom: a logging system, string manipulation functions, sorting, etc. But how they all fit together in picom is pretty unique. As a consequence, large scale reasoning of the codebase with Copilot is out of the window. Since it has not seen a project like this during training, it&#39;s going to have a really hard time understanding what it&#39;s doing. Which means my usage of Copilot is mostly limited to writing boilerplates, repetitive code, etc. To give a concrete example, say you need to <a href="https://github.com/yshui/picom/blob/311225be4d9187cbadf7388af87946d9fa62a924/src/c2.c#L1044">parse an escaped character</a>:</p>
<pre><code>if (pattern[offset] == &#39;\\&#39;) {
	switch (pattern[offset + 1]) {
	case &#39;t&#39;: *(output++) = &#39;\t&#39;; break;
	// ????
	}
}
</code></pre>
<p>If you put your cursor at the position indicated by <code>????</code>, you can pretty reliably expect Copilot to write the rest of the code for you. Other examples include <a href="https://github.com/yshui/picom/blob/311225be4d9187cbadf7388af87946d9fa62a924/src/c2.c#L238">mapping enums to strings</a>, <a href="https://github.com/yshui/picom/blob/311225be4d9187cbadf7388af87946d9fa62a924/src/dbus.c#L1421">write glue functions that have a common pattern</a>, etc. In other words, the most simple and boring stuff. Which is very good. See, I am someone who wants programming to be fun, and writing these boring, repetitive code is the least fun part of programming for me. I am more than delighted to have someone (or rather, something) take it away from me.</p>
<p>So, what is wrong then? Why did I say I am more productive without Copilot? Well, that&#39;s because Copilot has two glaring problems:</p>
<h3 id="1-copilot-is-unpredictable"><a href="#1-copilot-is-unpredictable"><strong>1. Copilot is unpredictable</strong></a></h3>
<p>Copilot can be really really helpful when it gets things right, however, it&#39;s really difficult to predict what it will get right, and what it won&#39;t. After a year of working with Copilot, I would say I am better at that than when I first started using it, but I have yet to fully grasp all the intricacies. It is easy to fall into the trap of anthropomorphising Copilot, and trying to gauge its ability like you would a human. For instance, you might think, &#34;Hmm, it was able to write that function based on my comments, so it must be able to write this too&#34;. But you are more than likely to be proven wrong by the chunk of gibberish Copilot throws at you. This is because, Artificial Intelligence is very much unlike Human Intelligence. The intuition you&#39;ve developed through a lifetime&#39;s interaction with other humans, is not going to work with an AI. Which means, short of letting Copilot actually try, there is oftentimes no surefire way to know whether it&#39;s going to work or not. And this problem is compounded by the other big problem of Copilot:</p>
<h3 id="2-copilot-is-slooooow"><a href="#2-copilot-is-slooooow"><strong>2. Copilot is <em>slooooow</em></strong></a></h3>
<p><code>clangd</code>, my C language server of choice, is very fast. It&#39;s faster than I can type, which means practically speaking, its suggestions are instant. Even when the suggestions are unhelpful, it costs me nothing. I don&#39;t have to pause, or wait, so my flow is uninterrupted. Compared to that, Copilot is much <em>much</em> slower. I would wait at least 2~3 seconds to get <em>any</em> suggestion from Copilot. If Copilot decided, for whatever reason, to write a large chunk of code, it would take a lot longer. And in many instances I would wait all those seconds only to see Copilot spit out unusable code. And I would have to decide if I need to refine the instructions in comments and try again; or partially accept the suggestion and do the rest myself. Even though this doesn&#39;t happen <em>that</em> often, (after you have gotten to know Copilot a bit better), much time is wasted in the back-and-forth.</p>
<hr/>
<p>So yeah, that&#39;s pretty much all I have to say. At least at this very moment, I do not think Copilot will improve my productivity, so I definitely wouldn&#39;t be paying for it. If GitHub&#39;s plan was to give me a year&#39;s free access of Copilot to get me addicted, then their plot has conclusively failed. But that being said, if Copilot is a little bit smarter, or several times faster than it currently is, maybe the scale will tip the other way.</p>
<p>Hmm, should I be scared?</p>

                    </div></div>
  </body>
</html>
