<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://brightprogrammer.in/posts/fixing-recursions-in-grammar/">Original</a>
    <h1>Fixing Left and Mutual Recursions in Grammars</h1>
    
    <div id="readability-page-1" class="page"><article><p><a href="#further-reading">\[
\text{A long-standing issue regarding algorithms that manipulate} \\
\text{context-free grammars (CFGs) in a “top-down” left-to-right fashion} \\
\text{is that left recursion can lead to nontermination.} ^{\text{[1]}}
\]</a></p><p>A grammar is left recursive if it comes in the following form</p><p>\[
\langle S \rangle ::= \langle S \rangle \ a \mid b
\]</p><p>When parsing or generating a string using this grammar (using a backtracking algorithm),
where $ \langle S \rangle $ is the start symbol, you
are likely to enter a state of infinite recursion. Any ideas on how to fix this?</p><p>\[
\langle S \rangle ::= b \mid \langle S \rangle \ a
\]</p><p>Rewriting it in above form won’t change a thing, except the fact that it’ll try to read or
generate the terminal $b$ first. How do we fix this then? The root of our problem is
left recursion, so if we can somehow make it right recursive then it’ll fix our issue.
Before reading any further, give it a try yourself.</p><center><p>---
title: example string &#34;aaa&#34;
---
stateDiagram-v2
[*] --&gt; S
S --&gt; b
S --&gt; Sa
Sa --&gt; S
b --&gt; [*]</p></center><p>For given example string $\text{aaa}$ the parser will never terminate. Not even to inform
us that the string does not belong to language generated by corresponding grammar.</p><h2 id="language-analysis">Language Analysis</h2><p>Let’s start by generating some sample strings in the given language, and try to discover
a pattern. The following are expansion paths for $ \langle S \rangle $ :</p><p>\[
\begin{align}
L(S) &amp;= b \\
L(S) &amp;= \langle S \rangle a \rightarrow
\langle S \rangle \ a \ a \rightarrow
\langle S \rangle \ a \ a \ … \ a \rightarrow
b \ a \ a \ … \ a
\end{align}
\]</p><p>So we have two possible expansions $b$ or $b \ a^*$. The symbol $*$ means as many repetitions
of anything that comes before it. It can be nothing, like an empty string, or it can be
something. So, this lets us know that a left recursive grammar always starts with $b$,
and then you generate or match as many $a$ as possible. The interesting thing about $a^*$
is that it can be generated with right recursion as well, with a rule like :</p><p>\[
\langle N \rangle = a \langle N \rangle \mid \epsilon
\]</p><center><p>stateDiagram-v2
[*] --&gt; N
N --&gt; aN : prepend a
aN --&gt; N : expand N
N --&gt; [*]</p></center><p>Now this can also be generated with a left recursion as well, but we’re doing all this
just to avoid it, so we only care about right recursion. Now combining all the information
we’ve gather up until now, we can</p><p>\[
\begin{align}
\langle S \rangle &amp;::= b \langle S’ \rangle \\
\langle S’ \rangle &amp;::= a \langle S’ \rangle \mid a
\end{align}
\]</p><p>This grammar as you can see is completely right recursive.</p><center><p>---
title: example string &#34;aaa&#34;
---
stateDiagram-v2
[*] --&gt; S
S --&gt; bS&#39;
S&#39; --&gt; aS&#39;
S&#39; --&gt; a
bS&#39; --&gt; S&#39;
aS&#39; --&gt; S&#39;
a --&gt; [*]</p></center><p>This new machine will quickly terminate when it notices that the example string $ \text{aaa} $ does not start
with $b$ like in our language.</p><h2 id="real-life-example">Real Life Example</h2><p>So, I’ve been (re)writing a C++ demangler for RizinOrg’s <a href="https://github.com/rizinorg/rz-libdemangle/pull/69">rz-libdemangle</a>
which was previously licensed to GPL, and I’m re-writing it to relicense it to LGPL v3, which is more
permissive for commercial usage. You are allowed to link to precompiled binaries licensed with LGPLv3.</p><p>While re-writing grammar for <a href="https://files.brightprogrammer.in/cxx-abi/abi.html">Itanium ABI</a>, I encountered
a left recursive grammar.</p><p>\[
\begin{align}
\langle \text{prefix} \rangle &amp;::= \langle \text{unqualified-name} \rangle \\
&amp;\quad \mid \langle \text{prefix} \rangle \langle \text{unqualified-name} \rangle \\
&amp;\quad \mid \langle \text{template-prefix} \rangle \langle \text{template-args} \rangle \\
&amp;\quad \mid \langle \text{closure-prefix} \rangle \\
&amp;\quad \mid \langle \text{template-param} \rangle \\
&amp;\quad \mid \langle \text{decltype} \rangle \\
&amp;\quad \mid \langle \text{substitution} \rangle
\end{align}
\]</p><p>Notice how production number $6$ is left recursive in nature. Wanna know how I fixed it in code?
You’ll have to follow this post a bit more. Real life examples are bit more complex than theory.
Life happend here as well, and made some things not-so-straightforward.</p><p>A mutual left recursion happens when two rules mutually call each other by expanding
first non terminal as other rule. It generally looks like this :</p><p>\[
\begin{align}
\langle S \rangle &amp;::= \langle A \rangle \mid \langle B \rangle \\
\langle A \rangle &amp;::= \langle B \rangle k \mid X \\
\langle B \rangle &amp;::= \langle A \rangle m \mid Y
\end{align}
\]</p><p>Notice how production $13$ and $14$ call each other, making it a mutual recursion.
Using a similar analysis as done for simple left recursion, we can remove left recursion
here as well, by making each rule right recursion only.</p><center><p>stateDiagram-v2
[*] --&gt; S
S --&gt; A
S --&gt; B
A --&gt; Bk
Bk --&gt; B
B --&gt; Am
Am --&gt; A
A --&gt; X
B --&gt; Y
X --&gt; [*]
Y --&gt; [*]</p></center><p>You can visually see the mutual recursion in path $ \textbf{A} \rightarrow \text{Bk} \rightarrow \textbf{B} \rightarrow \text{Am} \rightarrow \textbf{A} $,
wherein $A$ ends up calling $B$ which eventually calls $A$.</p><h2 id="language-analysis-1">Language Analysis</h2><p>If you try to follow the pattern, then you’ll get the following possible languages</p><p>\[
\begin{align}
L(A) &amp;= X (mk)^* \\
L(A) &amp;= Y k(mk)^* \\
L(B) &amp;= Y (km)^* \\
L(B) &amp;= X m(km)^*
\end{align}
\]</p><p>Noticing this pattern again, I can clearly see the right recursion this time again,
so, I’ll re-write the mutually left recursive grammar as follows</p><p>\[
\begin{align}
\langle S \rangle &amp; ::= &amp; \langle S1 \rangle \mid \langle S2 \rangle \\
\langle S1 \rangle &amp; ::= &amp; \langle A \rangle \mid \langle A \rangle \langle R1 \rangle \\
\langle S2 \rangle &amp; ::= &amp; \langle B \rangle \mid \langle B \rangle \langle R2 \rangle \\
\langle A \rangle &amp; ::= &amp; X \mid Y k \\
\langle B \rangle &amp; ::= &amp; Y \mid X m \\
\langle R1 \rangle &amp; ::= &amp; m k \langle R1 \rangle \mid m k \\
\langle R2 \rangle &amp; ::= &amp; k m \langle R2 \rangle \mid k m
\end{align}
\]</p><p>Again, notice that since the only recursive productions $20$ and $21$ are right
recursive only, the whole grammar is right recursive, and at the same time,
the grammar is no more mutually left recursive.</p><center><p>stateDiagram-v2
[*] --&gt; S
S --&gt; S1
S --&gt; S2
S1 --&gt; A
S1 --&gt; AR1
AR1 --&gt; R1 : expand R1
R1 --&gt; mkR1
mkR1 --&gt; R1
S2 --&gt; B
S2 --&gt; BR2
BR2 --&gt; R2 : expand R2
R2 --&gt; kmR2
kmR2 --&gt; R2
A --&gt; X
A --&gt; Yk
B --&gt; Y
B --&gt; Xm
X --&gt; [*]
Y --&gt; [*]
Yk --&gt; [*]
Xm --&gt; [*]
R1 --&gt; mk
R2 --&gt; km
mk --&gt; [*]
km --&gt; [*]</p></center><h2 id="real-life-example-1">Real Life Example</h2><p>So, while (re)writing the demangler, I came across some rules that are mutually
recursive. Take a look at the following grammar, and comment what you see :</p><p>\[
\begin{align}
\langle \text{prefix} \rangle &amp;::= \langle \text{unqualified-name} \rangle \\
&amp;\quad \mid \langle \text{prefix} \rangle \langle \text{unqualified-name} \rangle \\
&amp;\quad \mid \langle \text{template-prefix} \rangle \langle \text{template-args} \rangle \\
&amp;\quad \mid \langle \text{closure-prefix} \rangle \\
&amp;\quad \mid \langle \text{template-param} \rangle \\
&amp;\quad \mid \langle \text{decltype} \rangle \\
&amp;\quad \mid \langle \text{substitution} \rangle
\end{align}
\]</p><p>\[
\begin{align}
\langle \text{template-prefix} \rangle &amp;::= \langle \text{template unqualified-name} \rangle \\
&amp;\quad \mid \langle \text{prefix} \rangle \langle \text{template unqualified-name} \rangle \\
&amp;\quad \mid \langle \text{template-param} \rangle \\
&amp;\quad \mid \langle \text{substitution} \rangle
\end{align}
\]</p><p>\[
\begin{align}
\langle \text{closure-prefix} \rangle &amp;::= [ \langle \text{prefix} \rangle ] \langle \text{variable or member unqualified-name} \rangle M \\
&amp;\quad \mid \langle \text{variable template template-prefix} \rangle \langle \text{template-args} \rangle M
\end{align}
\]</p><p>Did you notice it? $\langle \text{prefix} \rangle$ is mutually left recursive with $\langle \text{template-prefix} \rangle$
and $\langle \text{closure-prefix} \rangle$ at the same time, and this is where things get a bit complicated.
The solution is not hard, it’s really simple though. I’ll have to show my original solution though.</p><p>For making things easy while writing the demangler, and for easy implementation of grammar rules
and productions, I’ve devised some macros that make it look like I’m using a DSL to write the demangler.
So, to help you understand, I’ll just show you the before and after code, and leave you to diff these out
by yourself to understand. You can see the complete source code in the PR, or in source code of
<a href="https://github.com/rizinorg/rz-libdemangle">rz-libdemangle</a> after my PR is merged.</p><h2 id="before-solving-anything">Before Solving Anything</h2><p>Before I’ve made any fixes to the grammar, here’s how the productions look in code :</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>DECL_RULE</span><span>(</span><span>prefix</span><span>);</span>
</span></span><span><span><span>DECL_RULE</span><span>(</span><span>template_prefix</span><span>);</span>
</span></span><span><span><span>DECL_RULE</span><span>(</span><span>closure_prefix</span><span>);</span>
</span></span><span><span>
</span></span><span><span><span>DEFN_RULE</span> <span>(</span><span>prefix</span><span>,</span> <span>{</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>unqualified_name</span><span>));</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>prefix</span><span>)</span> <span>&amp;&amp;</span> <span>RULE</span> <span>(</span><span>unqualified_name</span><span>));</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>template_prefix</span><span>)</span> <span>&amp;&amp;</span> <span>RULE</span> <span>(</span><span>template_args</span><span>));</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>closure_prefix</span><span>));</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>template_param</span><span>));</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>decltype</span><span>));</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>substitution</span><span>));</span>
</span></span><span><span><span>});</span>
</span></span><span><span>
</span></span><span><span><span>DEFN_RULE</span><span>(</span><span>template_prefix</span><span>,</span> <span>{</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>template_unqualified_name</span><span>));</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>prefix</span><span>)</span> <span>&amp;&amp;</span> <span>RULE</span> <span>(</span><span>template_unqualified_name</span><span>));</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>template_param</span><span>));</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>substitution</span><span>));</span>
</span></span><span><span><span>});</span>
</span></span><span><span>
</span></span><span><span><span>DEFN_RULE</span><span>(</span><span>closure_prefix</span><span>,</span> <span>{</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE_OPTIONAL</span> <span>(</span><span>prefix</span><span>)</span> <span>&amp;&amp;</span> <span>RULE</span> <span>(</span><span>variable_or_member_unqualified_name</span><span>)</span> <span>&amp;&amp;</span> <span>READ</span> <span>(</span><span>&#39;M&#39;</span><span>));</span> 
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>variable_template_template_name</span><span>)</span> <span>&amp;&amp;</span> <span>RULE</span> <span>(</span><span>template_args</span><span>)</span> <span>&amp;&amp;</span> <span>READ</span> <span>(</span><span>&#39;M&#39;</span><span>));</span> 
</span></span><span><span><span>});</span>
</span></span></code></pre></div><p>So? Do you notice many mutual recursions at the same time. How do we fix this?
To be honest, at the time of writing this, I haven’t checked the code, but I’m pretty sure
that my theory is right.</p><h2 id="after-the-changes">After The Changes</h2><div><pre tabindex="0"><code data-lang="c"><span><span><span>DEFN_RULE</span> <span>(</span><span>prefix_X</span><span>,</span> <span>{</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>unqualified_name</span><span>));</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>template_param</span><span>));</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>decltype</span><span>));</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>substitution</span><span>));</span>
</span></span><span><span><span>});</span>
</span></span><span><span>
</span></span><span><span><span>DEFN_RULE</span> <span>(</span><span>prefix_Yk_template_prefix</span><span>,</span> <span>{</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>template_unqualified_name</span><span>)</span> <span>&amp;&amp;</span> <span>RULE</span> <span>(</span><span>template_args</span><span>));</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>template_param</span><span>)</span> <span>&amp;&amp;</span> <span>RULE</span> <span>(</span><span>template_args</span><span>));</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>substitution</span><span>)</span> <span>&amp;&amp;</span> <span>RULE</span> <span>(</span><span>template_args</span><span>));</span>
</span></span><span><span><span>});</span>
</span></span><span><span>
</span></span><span><span><span>DEFN_RULE</span> <span>(</span><span>prefix_A_template_prefix</span><span>,</span> <span>{</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>prefix_X</span><span>));</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>prefix_Yk_template_prefix</span><span>));</span>
</span></span><span><span><span>});</span>
</span></span><span><span>
</span></span><span><span><span>DEFN_RULE</span> <span>(</span><span>prefix_mk_template_prefix</span><span>,</span> <span>{</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>template_unqualified_name</span><span>)</span> <span>&amp;&amp;</span> <span>RULE</span> <span>(</span><span>template_args</span><span>));</span>
</span></span><span><span><span>});</span>
</span></span><span><span>
</span></span><span><span><span>DEFN_RULE</span> <span>(</span><span>prefix_S1_template_prefix</span><span>,</span> <span>{</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>prefix_A_template_prefix</span><span>)</span> <span>&amp;&amp;</span> <span>RULE_MANY</span> <span>(</span><span>prefix_mk_template_prefix</span><span>));</span>
</span></span><span><span><span>});</span>
</span></span><span><span>
</span></span><span><span><span>DEFN_RULE</span> <span>(</span><span>prefix_Yk_closure_prefix</span><span>,</span> <span>{</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>variable_template_template_prefix</span><span>)</span> <span>&amp;&amp;</span> <span>RULE</span> <span>(</span><span>template_args</span><span>)</span> <span>&amp;&amp;</span> <span>READ</span> <span>(</span><span>&#39;M&#39;</span><span>));</span>
</span></span><span><span><span>});</span>
</span></span><span><span>
</span></span><span><span><span>DEFN_RULE</span> <span>(</span><span>prefix_A_closure_prefix</span><span>,</span> <span>{</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>prefix_X</span><span>));</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>prefix_Yk_closure_prefix</span><span>));</span>
</span></span><span><span><span>});</span>
</span></span><span><span>
</span></span><span><span><span>DEFN_RULE</span> <span>(</span><span>prefix_mk_closure_prefix</span><span>,</span> <span>{</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>variable_or_member_unqualified_name</span><span>)</span> <span>&amp;&amp;</span> <span>READ</span> <span>(</span><span>&#39;M&#39;</span><span>));</span>
</span></span><span><span><span>});</span>
</span></span><span><span>
</span></span><span><span><span>DEFN_RULE</span> <span>(</span><span>prefix_S1_closure_prefix</span><span>,</span> <span>{</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>prefix_A_closure_prefix</span><span>)</span> <span>&amp;&amp;</span> <span>RULE_MANY</span> <span>(</span><span>prefix_mk_closure_prefix</span><span>));</span>
</span></span><span><span><span>});</span>
</span></span><span><span>
</span></span><span><span><span>DEFN_RULE</span> <span>(</span><span>prefix</span><span>,</span> <span>{</span>
</span></span><span><span>    <span>// fix left-recursion
</span></span></span><span><span><span></span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>prefix_X</span><span>)</span> <span>&amp;&amp;</span> <span>RULE_MANY</span> <span>(</span><span>unqualified_name</span><span>));</span>
</span></span><span><span>
</span></span><span><span>    <span>// fix mutual-recursions
</span></span></span><span><span><span></span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>prefix_S1_template_prefix</span><span>));</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>prefix_S1_closure_prefix</span><span>));</span>
</span></span><span><span><span>});</span>
</span></span></code></pre></div><p>The changes made for $ \langle \text{closure-prefix} \rangle $ :</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>DEFN_RULE</span> <span>(</span><span>closure_prefix_Y</span><span>,</span> <span>{</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>variable_template_template_prefix</span><span>)</span> <span>&amp;&amp;</span> <span>RULE</span> <span>(</span><span>template_args</span><span>)</span> <span>&amp;&amp;</span> <span>READ</span> <span>(</span><span>&#39;M&#39;</span><span>));</span>
</span></span><span><span><span>});</span>
</span></span><span><span>
</span></span><span><span><span>DEFN_RULE</span> <span>(</span><span>closure_prefix_Xm_prefix</span><span>,</span> <span>{</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>unqualified_name</span><span>)</span> <span>&amp;&amp;</span> <span>RULE</span> <span>(</span><span>variable_or_member_unqualified_name</span><span>)</span> <span>&amp;&amp;</span> <span>READ</span> <span>(</span><span>&#39;M&#39;</span><span>));</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>template_param</span><span>)</span> <span>&amp;&amp;</span> <span>RULE</span> <span>(</span><span>variable_or_member_unqualified_name</span><span>)</span> <span>&amp;&amp;</span> <span>READ</span> <span>(</span><span>&#39;M&#39;</span><span>));</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>decltype</span><span>)</span> <span>&amp;&amp;</span> <span>RULE</span> <span>(</span><span>variable_or_member_unqualified_name</span><span>)</span> <span>&amp;&amp;</span> <span>READ</span> <span>(</span><span>&#39;M&#39;</span><span>));</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>substitution</span><span>)</span> <span>&amp;&amp;</span> <span>RULE</span> <span>(</span><span>variable_or_member_unqualified_name</span><span>)</span> <span>&amp;&amp;</span> <span>READ</span> <span>(</span><span>&#39;M&#39;</span><span>));</span>
</span></span><span><span><span>});</span>
</span></span><span><span>
</span></span><span><span><span>DEFN_RULE</span> <span>(</span><span>closure_prefix_km_prefix</span><span>,</span> <span>{</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>variable_template_template_prefix</span><span>)</span> <span>&amp;&amp;</span> <span>RULE</span> <span>(</span><span>template_args</span><span>)</span> <span>&amp;&amp;</span> <span>READ</span> <span>(</span><span>&#39;M&#39;</span><span>));</span>
</span></span><span><span><span>});</span>
</span></span><span><span>
</span></span><span><span><span>DEFN_RULE</span> <span>(</span><span>closure_prefix_B</span><span>,</span> <span>{</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>closure_prefix_Y</span><span>));</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>closure_prefix_Xm_prefix</span><span>));</span>
</span></span><span><span><span>});</span>
</span></span><span><span>
</span></span><span><span><span>DEFN_RULE</span> <span>(</span><span>closure_prefix_S2_prefix</span><span>,</span> <span>{</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>closure_prefix_B</span><span>)</span> <span>&amp;&amp;</span> <span>RULE_MANY</span> <span>(</span><span>closure_prefix_km_prefix</span><span>));</span>
</span></span><span><span><span>});</span>
</span></span><span><span>
</span></span><span><span><span>DEFN_RULE</span> <span>(</span><span>closure_prefix</span><span>,</span> <span>{</span> <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>closure_prefix_S2_prefix</span><span>));</span> <span>});</span>
</span></span></code></pre></div><p>The changes made for $ \langle \text{template-prefix} \rangle $ :</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>DEFN_RULE</span> <span>(</span><span>template_prefix_Y</span><span>,</span> <span>{</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>template_unqualified_name</span><span>));</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>template_param</span><span>));</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>substitution</span><span>));</span>
</span></span><span><span><span>});</span>
</span></span><span><span>
</span></span><span><span><span>DEFN_RULE</span> <span>(</span><span>template_prefix_Xm_prefix</span><span>,</span> <span>{</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>unqualified_name</span><span>)</span> <span>&amp;&amp;</span> <span>RULE</span> <span>(</span><span>template_unqualified_name</span><span>));</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>template_param</span><span>)</span> <span>&amp;&amp;</span> <span>RULE</span> <span>(</span><span>template_unqualified_name</span><span>));</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>decltype</span><span>)</span> <span>&amp;&amp;</span> <span>RULE</span> <span>(</span><span>template_unqualified_name</span><span>));</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>substitution</span><span>)</span> <span>&amp;&amp;</span> <span>RULE</span> <span>(</span><span>template_unqualified_name</span><span>));</span>
</span></span><span><span><span>});</span>
</span></span><span><span>
</span></span><span><span><span>DEFN_RULE</span> <span>(</span><span>template_prefix_km_prefix</span><span>,</span> <span>{</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>template_args</span><span>)</span> <span>&amp;&amp;</span> <span>RULE</span> <span>(</span><span>template_unqualified_name</span><span>));</span>
</span></span><span><span><span>});</span>
</span></span><span><span>
</span></span><span><span><span>DEFN_RULE</span> <span>(</span><span>template_prefix_B</span><span>,</span> <span>{</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>template_prefix_Y</span><span>));</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>template_prefix_Xm_prefix</span><span>));</span>
</span></span><span><span><span>});</span>
</span></span><span><span>
</span></span><span><span><span>DEFN_RULE</span> <span>(</span><span>template_prefix_S2_prefix</span><span>,</span> <span>{</span>
</span></span><span><span>    <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>template_prefix_B</span><span>)</span> <span>&amp;&amp;</span> <span>RULE_MANY</span> <span>(</span><span>template_prefix_km_prefix</span><span>));</span>
</span></span><span><span><span>});</span>
</span></span><span><span>
</span></span><span><span><span>DEFN_RULE</span> <span>(</span><span>template_prefix</span><span>,</span> <span>{</span> <span>MATCH</span> <span>(</span><span>RULE</span> <span>(</span><span>template_prefix_S2_prefix</span><span>));</span> <span>});</span>
</span></span></code></pre></div><p>This is my current fix. This fixed any recursion issues for now. Previously I was getting
stack overflow, because the stack frames just kept getting growing up and up. For those of you
who are not comfortable with the code, here’s the grammar form :</p><p>\[
\begin{align}
\langle \text{prefix-X} \rangle &amp; ::= &amp; \langle \text{unqualified-name} \rangle \\
&amp; \quad \mid &amp; \langle \text{template-param} \rangle \\
&amp; \quad \mid &amp; \langle \text{decltype} \rangle \\
&amp; \quad \mid &amp; \langle \text{substitution} \rangle
\end{align}
\]</p><p>\[
\begin{align}
\langle \text{prefix-Yk-template-prefix} \rangle &amp; ::= &amp; \langle \text{template-unqualified-name} \rangle \ \langle \text{template-args} \rangle \\
&amp; \quad \mid &amp; \langle \text{template-param} \rangle \ \langle \text{template-args} \rangle \\
&amp; \quad \mid &amp; \langle \text{substitution} \rangle \ \langle \text{template-args} \rangle \\
\langle \text{prefix-A-template-prefix} \rangle &amp; ::= &amp; \langle \text{prefix-X} \rangle \\
&amp; \quad \mid &amp; \langle \text{prefix-Yk-template-prefix} \rangle \\
\langle \text{prefix-mk-template-prefix} \rangle &amp; ::= &amp; \langle \text{template-unqualified-name} \rangle \ \langle \text{template-args} \rangle \\
\langle \text{prefix-S1-template-prefix} \rangle &amp; ::= &amp; \langle \text{prefix-A-template-prefix} \rangle \ \langle \text{prefix-mk-template-prefix} \rangle ^*
\end{align}
\]</p><p>\[
\begin{align}
\langle \text{prefix-Yk-closure-prefix} \rangle &amp; ::= &amp; \langle \text{variable-template-template-prefix} \rangle \ \langle \text{template-args} \rangle \ M \\
\langle \text{prefix-A-closure-prefix} \rangle &amp; ::= &amp; \langle \text{prefix-X} \rangle \\
&amp; \quad \mid &amp; \langle \text{prefix-Yk-closure-prefix} \rangle \\
\langle \text{prefix-mk-closure-prefix} \rangle &amp; ::= &amp; \langle \text{variable-or-member-unqualified-name} \rangle \ M \\
\langle \text{prefix-S1-closure-prefix} \rangle &amp; ::= &amp; \langle \text{prefix-A-closure-prefix} \rangle \ \langle \text{prefix-mk-closure-prefix} \rangle ^*
\end{align}
\]</p><p>\[
\begin{align}
\langle \text{prefix} \rangle &amp; ::= &amp; \langle \text{prefix-X} \rangle \ {\langle \text{unqualified-name} \rangle ^*} \\
&amp; \mid &amp; \langle \text{prefix-S1-template-prefix} \rangle \\
&amp; \mid &amp; \langle \text{prefix-S1-closure-prefix} \rangle
\end{align}
\]</p><p>The changes made for $ \langle \text{closure-prefix} \rangle $ :</p><p>\[
\begin{align}
\langle \text{closure-prefix-Y} \rangle &amp; ::= &amp; \langle \text{variable-template-template-prefix} \rangle \ \langle \text{template-args} \rangle \ M
\end{align}
\]</p><p>\[
\begin{align}
\langle \text{closure-prefix-Xm-prefix} \rangle &amp; ::= &amp; \langle \text{unqualified-name} \rangle \ \langle \text{variable-or-member-unqualified-name} \rangle \ M \\
&amp; \quad \mid &amp; \langle \text{template-param} \rangle \ \langle \text{variable-or-member-unqualified-name} \rangle \ M \\
&amp; \quad \mid &amp; \langle \text{decltype} \rangle \ \langle \text{variable-or-member-unqualified-name} \rangle \ M \\
&amp; \quad \mid &amp; \langle \text{substitution} \rangle \ \langle \text{variable-or-member-unqualified-name} \rangle \ M
\end{align}
\]</p><p>\[
\begin{align}
\langle \text{closure-prefix-B} \rangle &amp; ::= &amp; \langle \text{closure-prefix-Y} \rangle \\
&amp; \quad \mid &amp; \langle \text{closure-prefix-Xm-prefix} \rangle
\end{align}
\]</p><p>\[
\begin{align}
\langle \text{closure-prefix-km-prefix} \rangle ::= \langle \text{variable or member unqualified-name} \rangle M
\end{align}
\]</p><p>\[
\begin{align}
\langle \text{closure-prefix-S2-prefix} \rangle &amp; ::= &amp; \langle \text{closure-prefix-B} \rangle \ \langle \text{closure-prefix-km-prefix} \rangle ^*
\end{align}
\]</p><p>\[
\begin{align}
\langle \text{closure-prefix} \rangle &amp; ::= &amp; \langle \text{closure-prefix-S2-prefix} \rangle
\end{align}
\]</p><p>The changes made for $ \langle \text{template-prefix} \rangle $ :</p><p>\[
\begin{align}
\langle \text{template-prefix-Y} \rangle &amp; ::= &amp; \langle \text{template-unqualified-name} \rangle \\
&amp; \quad \mid &amp; \langle \text{template-param} \rangle \\
&amp; \quad \mid &amp; \langle \text{substitution} \rangle
\end{align}
\]</p><p>\[
\begin{align}
\langle \text{template-prefix-Xm-prefix} \rangle &amp; ::= &amp; \langle \text{unqualified-name} \rangle \ \langle \text{template-unqualified-name} \rangle \\
&amp; \quad \mid &amp; \langle \text{template-param} \rangle \ \langle \text{template-unqualified-name} \rangle \\
&amp; \quad \mid &amp; \langle \text{decltype} \rangle \ \langle \text{template-unqualified-name} \rangle \\
&amp; \quad \mid &amp; \langle \text{substitution} \rangle \ \langle \text{template-unqualified-name} \rangle
\end{align}
\]</p><p>\[
\begin{align}
\langle \text{template-prefix-B} \rangle &amp; ::= &amp; \langle \text{template-prefix-Y} \rangle \\
&amp; \quad \mid &amp; \langle \text{template-prefix-Xm-prefix} \rangle
\end{align}
\]</p><p>\[
\begin{align}
\langle \text{template-prefix-km-prefix} \rangle ::= \langle \text{template-args} \rangle \langle \text{template-unqualified-name} \rangle
\end{align}
\]</p><p>\[
\begin{align}
\langle \text{template-prefix-S2-prefix} \rangle &amp; ::= &amp; \langle \text{template-prefix-B} \rangle \ \langle \text{template-prefix-km-prefix} \rangle ^*
\end{align}
\]</p><p>\[
\begin{align}
\langle \text{template-prefix} \rangle &amp; ::= &amp; \langle \text{template-prefix-S2-prefix} \rangle
\end{align}
\]</p><p>Grammars are very hard to get right in the first try. You are basically developing your
own language. It takes experience, which basically demands you beforehand about what you
want and what you don’t want. The other way is doing it iteratively, which is another
name for trial-and-error (and as I said, hard to get right in first try). The final grammar
we see here can be further simplified using some normalization algorithms to generate a normalized
form of this grammar. These normalized forms generally do transformations to original grammar
to remove redundancy, and help the actual parsing algorithm make correct decisions faster.</p><p>Did you like the post? Drop in a comment! If you find any error in this post, I’m only a human,
and I’ll accept my mistakes, and make any changes if required.</p><ul><li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2000/04/naacl2k-proc-rev.pdf">[1]</a> - Removing Left Recursion from Context-Free Grammars</li></ul></article></div>
  </body>
</html>
