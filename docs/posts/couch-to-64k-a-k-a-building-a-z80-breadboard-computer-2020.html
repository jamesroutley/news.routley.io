<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://bread80.com/2020/07/24/couch-to-64k-a-k-a-building-a-z80-breadboard-computer-part-1-pins/">Original</a>
    <h1>Couch to 64k, a.k.a. Building a Z80 Breadboard Computer (2020)</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>A lot of people build <a href="https://en.wikipedia.org/wiki/Zilog_Z80">Z80</a> based computers. They build something with some <a href="https://www.youtube.com/watch?v=AZb4NLXx1aM">flashing LEDs</a>, some buttons, and maybe even a <a href="http://www.searle.wales">serial port</a>. But the computers I loved as a kid had <a href="http://www.computinghistory.org.uk/det/2805/Amstrad-CPC-464/">high-resolution displays</a>, and <a href="http://www.computinghistory.org.uk/det/424/Sinclair-ZX-Spectrum-48k/">keyboards</a>, and <a href="https://www.retrogames.co.uk/009699/Other-Formats/Quickshot-2-Joystick-by-Spectravideo">joysticks</a> attached. And you could spend your days playing <a href="https://www.youtube.com/watch?v=aBBrKcBfmkk">games</a> on them.</p>



<p>So, I’m going to attempt to build a Z80 based computer, on <a href="https://en.wikipedia.org/wiki/Breadboard">breadboards</a>, with some <a href="https://www.youtube.com/watch?v=xVAOxb0N3pg">fun</a> factor involved. And learn about hardware and software development at the same time.</p>



<p>Now, I’ll admit, that at the moment I don’t actually have a fully sketched out plan for how I’m going to do this, or what the final computer will look like or be able to do. But I plan to have some fun in the process.</p>



<p>You’re more than welcome to follow along.</p>



<h2>Getting started</h2>



<p>Having promised you fun and excitement I’m now going to start you off with something really boring. Yeah, I know, but we have to understand the basics before we can get to the good stuff.</p>



<p>For this step you will need (see the end of the article for buying advice and some affiliate links for readers who can tolerate me earning a few pennies):</p>



<ul><li>A Z80 processor. I bet you weren’t expecting that.</li><li>Two breadboards.</li><li>An Arduino. The Arduino Nano is ideal as you can push it into a breadboard, but any one will work.</li><li>Some breadboarding wire.</li><li>Some form of 5V power supply.</li><li>Eight 1k or similar resistors.</li><li>A handful of 470ohm or similar resistors.</li><li>A handful of LEDs (or an LED barcode if you have one).</li><li>A couple of Dupont style wires.</li><li>A Z80 pinout diagram. Here’s a handy one for you:</li></ul>



<figure><img loading="lazy" width="350" height="414" src="http://bread80.com/wp50/wp-content/uploads/2020/07/Z80Pinout.png" alt="Pinout of the Z-80" srcset="http://bread80.com/wp50/wp-content/uploads/2020/07/Z80Pinout.png 350w, http://bread80.com/wp50/wp-content/uploads/2020/07/Z80Pinout-254x300.png 254w, http://bread80.com/wp50/wp-content/uploads/2020/07/Z80Pinout-230x272.png 230w" sizes="(max-width: 350px) 100vw, 350px"/><figcaption>P<em>inout of the Z-80, from the </em><a href="http://www.classiccmp.org/cini/pdf/Zilog/Zilog%20Data%20Book.PDF">Zilog Data Book</a><em>.</em></figcaption></figure>



<h2>Basic Connections</h2>



<ul><li>Pop your Z80 into the breadboard.</li><li>Pop your Arduino into another breadboard.</li><li>Wire up the 5V and Ground pins of both the Z80 and the Arduino. And, while you’re there join together the power and ground rails on the breadboards. If you have one of those nasty boards with a split in the power rails now would be a great time to wire across those too.</li><li>On the Z80 wire up the INT, NMI, BUSRQ and WAIT signals to the 5V supply. These are input signals that make the Z80 do interesting things. They’ll also screw up this demo if they aren’t connected to 5V.</li><li>Place resistors between each of the D0 to D7 pins and the ground rail. The resistors should be about 1k but the exact value doesn’t matter. Use whatever you have handy. (The blue resistors in the photos).</li><li>Connect a longer lead or dupont lead to the RESET pin. This will be needed to reset the Z80 to start it operating. If you have any sense connect it via a momentary push button switch with a pull-up resistor to 5V. I’m connecting it to the 5V rail.</li><li>Connect some resistors and LEDs to the A0 and upwards lines. I’d recommend connecting at least 8 lines here so we can get a good idea of what’s happening. Resistors should be between 220 ohm and 1k ohm. The exact values aren’t critical. <em>But</em> I’m wiring the cathode side of the LEDs all to a single breadboard line and then connecting that line to ground, rather than wiring them directly to ground. There is a <em>very</em> good reason for this which will soon become apparent.</li><li>Wire the Clock pin of the Z80 (pin 6, the one with the weird symbol on it) to the D13 pin on the Arduino. This is also the pin which flashes the Arduino’s LED so you’ll be able to see when something <em>should</em> be happening.</li></ul>



<p>If everything’s gone to plan you should have something which looks vaguely like this photo:</p>



<figure><img loading="lazy" width="1024" height="683" src="http://bread80.com/wp50/wp-content/uploads/2020/07/IMG_2217Breadboard-1024x683.jpg" alt="Photo of the Z80 wired up as described" srcset="http://bread80.com/wp50/wp-content/uploads/2020/07/IMG_2217Breadboard-1024x683.jpg 1024w, http://bread80.com/wp50/wp-content/uploads/2020/07/IMG_2217Breadboard-300x200.jpg 300w, http://bread80.com/wp50/wp-content/uploads/2020/07/IMG_2217Breadboard-768x512.jpg 768w, http://bread80.com/wp50/wp-content/uploads/2020/07/IMG_2217Breadboard-1536x1024.jpg 1536w, http://bread80.com/wp50/wp-content/uploads/2020/07/IMG_2217Breadboard-2048x1365.jpg 2048w, http://bread80.com/wp50/wp-content/uploads/2020/07/IMG_2217Breadboard-830x553.jpg 830w, http://bread80.com/wp50/wp-content/uploads/2020/07/IMG_2217Breadboard-230x153.jpg 230w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption>The Z80, wired up and ready for action.</figcaption></figure>



<p>And, if you must, here’s a schematic:</p>



<figure><img loading="lazy" width="586" height="1024" src="http://bread80.com/wp50/wp-content/uploads/2020/07/BreadboardZ80-Part1-Schematic-1-586x1024.png" alt="Schematic for the breadboard Z80" srcset="http://bread80.com/wp50/wp-content/uploads/2020/07/BreadboardZ80-Part1-Schematic-1-586x1024.png 586w, http://bread80.com/wp50/wp-content/uploads/2020/07/BreadboardZ80-Part1-Schematic-1-172x300.png 172w, http://bread80.com/wp50/wp-content/uploads/2020/07/BreadboardZ80-Part1-Schematic-1-768x1342.png 768w, http://bread80.com/wp50/wp-content/uploads/2020/07/BreadboardZ80-Part1-Schematic-1-230x402.png 230w, http://bread80.com/wp50/wp-content/uploads/2020/07/BreadboardZ80-Part1-Schematic-1.png 769w" sizes="(max-width: 586px) 100vw, 586px"/><figcaption>Schematic for our breadboard Z80.</figcaption></figure>



<h2>Gettin’ Sketchy</h2>



<p>We’re now ready to write an Arduino sketch to generate the clock signal. We’ll set the pin to output and then just toggle it on and off. Start with a value for wait of about 10ms. You can, of course, adjust this if you need to make your life easier.</p>



<pre><code>#include &#34;Arduino.h&#34;

#define LED 13

void setup() {
  Serial.begin(115200);

  pinMode(LED,OUTPUT);
}

int wait = 10;

void loop() {
  digitalWrite(LED,HIGH);
  delay(wait);
  digitalWrite(LED,LOW);
  delay(wait);
}</code></pre>



<p>Switch on the power. Connect the RESET wire to ground for a moment, (or push your reset button).</p>



<p>If all goes to plan you should see the address lines counting in binary.</p>



<figure><video controls="" loop="" muted="" src="http://bread80.com/wp50/wp-content/uploads/2020/07/MVI_2218-NOP-GND-converted.mp4"></video><figcaption>The Z80 execuing NOP instructions.</figcaption></figure>



<p>What’s happening here? The Z80 is reading instructions and data from the D0 to D7 lines. It has a <em>program counter</em> which records the address the instructions are coming from. It outputs this address on the address bus (lines A0 to A15) and reads in the data at that address. This data is the <em>opcode</em> or command to be executed. Because we’ve connected all the data pins to ground (via the resistors) the Z80 is reading all zeroes. Opcode $00 is the NOP instruction. NOP stands for No OPeration and literally means, do nothing.</p>



<p>So, the processor reads in the opcode and does nothing. Well, technically it does quite a few things even for a NOP opcode, but it doesn’t do any useful work that’s worth describing here. The Z80 then adds one to the <em>program counter</em> and repeats the process for the next opcode.</p>



<h2>It’s Working! … Let’s Break It!</h2>



<p>Good. Now power down the system and change the resistors on the data pins so they connect to the 5V rail instead of the ground rail. Power up and reset again. Now what happens?</p>



<figure><video controls="" loop="" muted="" src="http://bread80.com/wp50/wp-content/uploads/2020/07/MVI_2219-FF-GND-converted.mp4"></video><figcaption>The Z80 running the $FF opcode (RST $38)</figcaption></figure>



<p>You should see that it all seems to have gone wrong. Those nicely counting addresses are now mangled. This is the point where most people take to an internet forum to ask if their Z80 is broken. No, it isn’t.</p>



<p>Remember we connected all our LEDs to ground via a single wire? Remember I said the reason for this would become apparent later? Well, that time is now.</p>



<p>Remove that connection from ground and plug it into the REFRESH (or RFSH) pin of the Z80. If you didn’t short anything out by doing this while your computer was powered up you should see that the counting is now working properly again. …But if you leave it long enough you’ll notice it’s only counting the first seven bits of the address.</p>



<figure><video controls="" loop="" muted="" src="http://bread80.com/wp50/wp-content/uploads/2020/07/MVI_2220-FF-RFSH-converted.mp4"></video><figcaption>The Z80’s address output while RFSH is active while executing $FF opcode (RST $38).</figcaption></figure>



<p>You’ll also notice that the LEDs are flickering, sometimes showing the address, and sometimes showing nothing. The REFRESH line is <em>active low</em>. That means it defaults to outputting 5V, but when the signal is active it outputs zero volts. By connecting the cathode of our LEDS to it we only see output on the LEDs when the signal is active.</p>



<h2>Promiscuous With Pins</h2>



<p>Now try connecting the LED ground wire to each of the other outputs in turn: M1, WR, RD, IORQ and MREQ. What happens?</p>



<p>You’ll probably see that some of them never show anything and others do, but different pins show different things.</p>



<p>By feeding in $FF to the data lines we’re feeding in an opcode which transfers execution to memory address hex $38. Don’t worry for now exactly what that opcode is doing or why it might be useful. Let’s run through some of the pins and what they’re actually showing:</p>



<figure><video controls="" loop="" muted="" src="http://bread80.com/wp50/wp-content/uploads/2020/07/MVI_2221-FF-M1-converted.mp4"></video><figcaption>The Z80’s address output while M1 is active while executing $FF opcode (RST $38).</figcaption></figure>



<p><strong>M1</strong>: For the $38 opcode the address lines should always be showing binary 00111000 when M1 is active. This is because M1 is active whenever the Z80 is reading an opcode. Binary 00111000 is also $38 hex. Remember from the paragraph above that the $FF opcode jumps to memory address $38. So the processor is continuously jumping back to the address $38, and so we always see that address for the M1 state.</p>



<figure><video controls="" loop="" muted="" src="http://bread80.com/wp50/wp-content/uploads/2020/07/MVI_2224-FF-RD-converted.mp4"></video><figcaption>The Z80’s address output while RD is active while executing $FF opcode (RST $38).</figcaption></figure>



<p><strong>RD</strong> is the <em>read</em> signal. It’s active whenever the Z80 is reading data, In this case the only reading that the Z80 is doing is for the opcode. Other opcodes may read further bytes as part of the instruction or data (or both).</p>



<figure><video controls="" loop="" muted="" src="http://bread80.com/wp50/wp-content/uploads/2020/07/MVI_2222-FF-WR-converted.mp4"></video><figcaption>The Z80’s address output while WR is active while executing $FF opcode (RST $38).</figcaption></figure>



<p><strong>WR</strong> is the <em>write</em> signal. It’s active whenever the Z80 is writing data. The NOP instruction doesn’t write any data so never activates this signal. The $FF opcode does write some data. If you watch the LEDs while it executes you should see decreasing binary numbers. I’ll leave what’s actually happening here for you to investigate in your own time.</p>



<figure><video controls="" loop="" muted="" src="http://bread80.com/wp50/wp-content/uploads/2020/07/MVI_2225-FF-MREQ-converted.mp4"></video><figcaption>The Z80’s address output while MREQ is active while executing $FF opcode (RST $38).</figcaption></figure>



<p><strong>MREQ</strong> is the <em>memory request</em> signal and it’s active whenever the Z80 is accessing <em>memory</em>, either reading or writing.</p>



<p><strong>IORQ</strong> won’t actually show you anything useful at the moment. It’s the <em>I/O request</em> signal. It’s similar to the MREQ signal but is active when the processor is accessing input or output devices.</p>



<h2>Let’s Refresh Our Memories</h2>



<p>All of which brings us back to the RFSH signal.</p>



<p>Computer memory tends to, actually, be very bad at remembering things. If you left a memory chip powered up but on it’s own for more than a few microseconds it would forget everything it ever knew It needs constant care and attention with something called a ‘refresh cycle’. Do you remember those variety acts with plates spinning on the top of sticks? And the performer had to keep going back to the start of the line to respin each plate before it fell off? Well, that’s how the high tech world of memory works. We need to keep sending addresses to the memory chips so they can start respinning each plate in turn. Did I say plate? I meant each block of memory. Sorry.</p>



<p>In many old school computers the designer had to build a separate circuit to do this refreshing. The Z80 put that circuitry on board. When the RFSH pin is active it outputs the refresh address on the address lines. And that address only counts seven bits because that was all that the memory chips of the day needed.</p>



<p>And with that nugget of information you now know more about the Z80 than 95% of the people who know nothing about the Z80. Well done.</p>



<h2>Opcode Playtime</h2>



<p>Anyway, lets get back to playing with opcodes. (And see, we did get to do some playing after all!) Have a look at a<a href="http://clrhome.org/table/"> table of Z80 opcodes</a> and try plugging them into the data lines by connecting your data pin resistors to 5V or ground as appropriate and see what happens.</p>



<p>(And note here that the data lines are actually in a jumble rather than a line – take care).</p>



<p>I can particularly recommend the JP nn opcode at hex $C3. This is a three byte opcode. The initial $C3 byte is followed by a two byte, 16-bit address to jump to. But since we’re passing $C3 as every input byte it will always jump to address $00C3. You’ll notice the program counter (RD pin) counting from $C3 to $C4 and $C5 as it reads those three bytes. The M1 pin will always show $C3 but show it a lot less often. (The first byte is the opcode, the other two are the data for the opcode so reading them doesn’t generate the M1 signal.)</p>



<p>Opcode $0A reads a byte from memory, so you’ll see the address it’s reading from being output. Opcode $02 does the opposite and writes a byte to a memory address, so you’ll see some memory writes.</p>



<p>Many opcodes are only a single byte and perform internal operations so you won’t see any more happening than with a NOP. But some of them take longer to do that so you’ll see a longer pause between reads and M1 states. A good example of this is the $09 opcode.</p>



<p>And, if you want something to ponder, try hex $18 opcode and see if you can work out what’s happening to the program counter.</p>



<p>Until next time, have fun.</p>



<h2>Buying Links and Advice</h2>



<p>You don’t need me to explain what an affiliate link is. They’re marked with (Aff) here.</p>







<h2>Footnotes</h2>

<!-- AI CONTENT END 1 -->
			</div></div>
  </body>
</html>
