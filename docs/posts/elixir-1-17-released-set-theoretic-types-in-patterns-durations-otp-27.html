<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://elixir-lang.org/blog/2024/06/12/elixir-v1-17-0-released/">Original</a>
    <h1>Elixir 1.17 released: set-theoretic types in patterns, durations, OTP 27</h1>
    
    <div id="readability-page-1" class="page"><div id="main">


<div id="content">
  <div>
  <div>
    <div>
      

      <div>
        <p>Elixir v1.17 has just been released. üéâ</p>

<p>This release introduces set-theoretic types into a handful of language constructs. While there are still <a href="https://elixir-lang.org/blog/2023/06/22/type-system-updates-research-dev/">many steps ahead of us</a>, this important milestone already brings benefits to developers in the form of new warnings for common mistakes. This new version also adds support for <a href="https://www.erlang.org/downloads/27">Erlang/OTP 27</a>, the latest and greatest Erlang release. You‚Äôll also find a new calendar-related data type (<code>Duration</code>) and a <code>Date.shift/2</code> function.</p>

<p>Let‚Äôs dive in.</p>

<h2 id="warnings-from-gradual-set-theoretic-types">Warnings from gradual set-theoretic types</h2>

<p>This release introduces gradual set-theoretic types to infer types from patterns and use them to type check programs, enabling the Elixir compiler to find faults and bugs in codebases without requiring changes to existing software. The underlying principles, theory, and roadmap of our work have been outlined in <a href="https://arxiv.org/abs/2306.06391">‚ÄúThe Design Principles of the Elixir Type System‚Äù by Giuseppe Castagna, Guillaume Duboc, Jos√© Valim</a>.</p>

<p>At the moment, Elixir developers will interact with set-theoretic types only through <strong>warnings</strong> found by the type system. The current implementation models all data types in the language:</p>

<ul>
  <li>
    <p><code>binary()</code>, <code>integer()</code>, <code>float()</code>, <code>pid()</code>, <code>port()</code>, <code>reference()</code> - these
types are indivisible. This means both <code>1</code> and <code>13</code> get the same <code>integer()</code>
type.</p>
  </li>
  <li>
    <p><code>atom()</code> - it represents all atoms and it is divisible. For instance, the
atom <code>:foo</code> and <code>:hello_world</code> are also valid (distinct) types.</p>
  </li>
  <li>
    <p><code>map()</code> and structs - maps can be ‚Äúclosed‚Äù or ‚Äúopen‚Äù. Closed maps only allow
the specified keys, such as <code>%{key: atom(), value: integer()}</code>. Open maps
support any other keys in addition to the ones listed and their definition
starts with <code>...</code>, such as <code>%{..., key: atom(), value: integer()}</code>. Structs
are closed maps with the <code>__struct__</code> key.</p>
  </li>
  <li>
    <p><code>tuple()</code>, <code>list()</code>, and <code>function()</code> - currently they are modelled as
indivisible types. The next Elixir versions will also introduce fine-grained
support to them.</p>
  </li>
</ul>

<p>We focused on <em>atoms</em> and <em>maps</em> on this initial release as they are respectively the simplest and the most complex types representations, so we can stress the performance of the type system and quality of error messages. Modelling these types will also provide the most immediate benefits to Elixir developers. Assuming there is a variable named <code>user</code>, holding a <code>%User{}</code> struct with a <code>address</code> field, Elixir v1.17 will emit the following warnings at compile-time:</p>

<ul>
  <li>
    <p>Pattern matching against a map or a struct that does not have the given key,
such as <code>%{adress: ...} = user</code> (notice <code>address</code> vs <code>adress</code>).</p>
  </li>
  <li>
    <p>Accessing a key on a map or a struct that does not have the given key, such
as <code>user.adress</code>.</p>
  </li>
  <li>
    <p>Invoking a function on non-modules, such as <code>user.address()</code>.</p>
  </li>
  <li>
    <p>Capturing a function on non-modules, such as <code>&amp;user.address/0</code>.</p>
  </li>
  <li>
    <p>Attempting to call an anonymous function without an actual function, such as
<code>user.()</code>.</p>
  </li>
  <li>
    <p>Performing structural comparisons between structs, such as <code>my_date &lt;
~D[2010-04-17]</code>.</p>
  </li>
  <li>
    <p>Performing structural comparisons between non-overlapping types, such as
<code>integer &gt;= string</code>.</p>
  </li>
  <li>
    <p>Building and pattern matching on binaries without the relevant specifiers,
such as <code>&lt;&lt;name&gt;&gt;</code> (this warns because by default it expects an integer, it
should have been <code>&lt;&lt;name::binary&gt;&gt;</code> instead).</p>
  </li>
  <li>
    <p>Attempting to rescue an undefined exception or a struct that is not an
exception.</p>
  </li>
  <li>
    <p>Accessing a field that is not defined in a rescued exception.</p>
  </li>
</ul>

<p>Here‚Äôs an example of how the warning for accessing a misspelled field of a
struct looks like:</p>

<p><img src="https://elixir-lang.org/images/contents/type-warning-on-struct-field.png" alt="Example of a warning when accessing a mispelled struct field"/></p>

<p>Another example, this time it‚Äôs a warning for structural comparison across two
<code>Date</code> structs:</p>

<p><img src="https://elixir-lang.org/images/contents/type-warning-on-date-comparison.png" alt="Example of a warning when comparing two structs with &#34;&gt;&#34;"/></p>

<p>These warnings also work natively in text editors, as they are standard Elixir
compiler warnings:</p>

<p><img src="https://elixir-lang.org/images/contents/type-warning-in-editor.png" alt="Example of a type warning inline in an editor"/></p>

<p>These new warnings will help Elixir developers find bugs earlier and give more
confidence when refactoring code, especially around maps and structs. While
Elixir already emitted some of these warnings in the past, those were discovered
using syntax analysis. The new warnings are more reliable, precise, and with
better error messages. Keep in mind, however, that the Elixir typechecker only
infers types from patterns within the same function at the moment. Analysis from
guards and across function boundaries will be added in future releases. For more
details, see our new <a href="https://hexdocs.pm/elixir/gradual-set-theoretic-types.html">reference document on gradual set-theoretic
types</a>.</p>

<p>The type system was made possible thanks to a partnership between
<a href="https://www.cnrs.fr/">CNRS</a> and <a href="https://remote.com/">Remote</a>. The development
work is currently sponsored by <a href="https://www.fresha.com/">Fresha</a>
(<a href="https://www.fresha.com/careers/openings?department=engineering">they are hiring!</a>),
<a href="https://starfish.team/">Starfish*</a>, and <a href="https://dashbit.co/">Dashbit</a>.</p>

<h2 id="erlangotp-support">Erlang/OTP support</h2>

<p>This release adds support for Erlang/OTP 27 and drops support for Erlang/OTP 24.
We recommend Elixir developers to migrate to Erlang/OTP 26 or later, especially
on Windows. Support for WERL (a graphical user interface for the Erlang terminal
on Windows) will be removed in Elixir v1.18.</p>

<p>You can read more about Erlang/OTP 27 in <a href="https://www.erlang.org/downloads/27">their release
announcement</a>. The bits that are
particularly interesting for Elixir developers are the addition of a <a href="https://erlang.org/documentation/doc-15.0-rc3/lib/stdlib-6.0/doc/html/json.html"><code>json</code>
module</a>
and process labels (<code>proc_lib:set_label/1</code>). The latter will also be available
in this Elixir release as <code>Process.set_label/1</code>.</p>

<h2 id="new-duration-data-type-and-shifting-functions">New <code>Duration</code> data type and shifting functions</h2>

<p>This Elixir version introduces the <code>Duration</code> data type and APIs to shift dates,
times, and date times by a given duration, considering different calendars and
time zones.</p>

<div><div><pre><code><span>iex</span><span>&gt;</span> <span>Date</span><span>.</span><span>shift</span><span>(</span><span>~D[2016-01-31]</span><span>,</span> <span>month:</span> <span>2</span><span>)</span>
<span>~D[2016-03-31]</span>
</code></pre></div></div>

<p>We chose the name <em>‚Äúshift‚Äù</em> for this operation (instead of ‚Äúadd‚Äù) since working
with durations does not obey properties such as <strong>associativity</strong>. For instance,
adding one month and then one month does not give the same result as adding two
months:</p>

<div><div><pre><code><span>iex</span><span>&gt;</span> <span>~D[2016-01-31]</span> <span>|&gt;</span> <span>Date</span><span>.</span><span>shift</span><span>(</span><span>month:</span> <span>1</span><span>)</span> <span>|&gt;</span> <span>Date</span><span>.</span><span>shift</span><span>(</span><span>month:</span> <span>1</span><span>)</span>
<span>~D[2016-03-29]</span>
</code></pre></div></div>

<p>Still, durations are essential for building intervals, recurring events, and
modelling scheduling complexities found in the world around us. For <code>DateTime</code>s,
Elixir will correctly deal with time zone changes (such as Daylight Saving
Time). However, provisions are also available in case you want to surface
conflicts, such as shifting to a wall clock that does not exist, because the
clock has been moved forward by one hour. See <code>DateTime.shift/2</code> for examples.</p>

<p>Finally, we added a new <code>Kernel.to_timeout/1</code> function, which helps developers
normalize durations and integers to a timeout used by many APIs‚Äîlike <code>Process</code>,
<code>GenServer</code>, and more. For example, to send a message after one hour, you can
now write:</p>

<div><div><pre><code><span>Process</span><span>.</span><span>send_after</span><span>(</span><span>pid</span><span>,</span> <span>:wake_up</span><span>,</span> <span>to_timeout</span><span>(</span><span>hour:</span> <span>1</span><span>))</span>
</code></pre></div></div>

<h2 id="learn-more">Learn more</h2>

<p>Here are other notable changes in this release:</p>

<ul>
  <li>
    <p>There are new <code>Keyword.intersect/2,3</code> functions to mirror the equivalent in
the <code>Map</code> module.</p>
  </li>
  <li>
    <p>A new Mix profiler was added, <code>mix profile.tprof</code>, which lets you use the
new <a href="https://www.erlang.org/doc/apps/tools/tprof.html">tprof</a>
profiler released with Erlang/OTP 27. This profiler leads to the
soft-deprecation of <code>mix profile.cprof</code> and <code>mix profile.eprof</code>.</p>
  </li>
  <li>
    <p>We added <code>Kernel.is_non_struct_map/1</code>, a new guard to help with the common
pitfall of matching on <code>%{}</code>, which also successfully matches structs (as
they are maps underneath).</p>
  </li>
  <li>
    <p>Elixir‚Äôs Logger now formats
<a href="https://www.erlang.org/doc/apps/stdlib/gen_statem.html"><code>gen_statem</code></a>
reports and includes Erlang/OTP 27 <em>process labels</em> in logger events.</p>
  </li>
</ul>

<p>For a complete list of all changes, see the
<a href="https://github.com/elixir-lang/elixir/releases/tag/v1.17.0">full release notes</a>.</p>

<p>Check <a href="https://elixir-lang.org/install.html">the Install section</a> to get Elixir installed and
read our <a href="https://hexdocs.pm/elixir/introduction.html">Getting Started guide</a>
to learn more.</p>

<p>Happy learning!</p>

      </div>

      <!-- <div class="entry-meta">
      </div> -->
    </div>
  </div>
</div>

</div><!-- #content -->



      </div></div>
  </body>
</html>
