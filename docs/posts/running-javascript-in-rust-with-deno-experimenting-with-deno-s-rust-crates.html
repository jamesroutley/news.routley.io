<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://austinpoor.com/blog/js-in-rs">Original</a>
    <h1>Running JavaScript in Rust with Deno: Experimenting with Deno&#39;s Rust Crates</h1>
    
    <div id="readability-page-1" class="page"><article>
    <div>
      
      <h2>
          Exploring Deno&#39;s JavaScript Runtime in a Proof-of-Concept Rust Application for Filtering Text with JS Expressions
        </h2>
      <p>
        Written by Austin Poor
      </p>
      <p>
        Published 2023-05-03
        
      </p>
    </div>

    <div>
      <figure>
        <img src="https://austinpoor.com/images/dalle-deno-dino-with-crab.webp" alt="The Deno dinosaur sitting in a field in Pangea -- with a small Rust colored crab in the foreground (Generated by DALL-E)"/>
        
        <figcaption>
            The Deno dinosaur sitting in a field in Pangea -- with a small Rust colored crab in the foreground (Generated by DALL-E)
          </figcaption>
      </figure>
    </div>

    <p>When I saw that Deno has open source Rust crates for running JavaScript code in a Rust application I wanted to give it a try for myself, so I created a basic, proof-of-concept project called <code>js-in-rs</code> to get a feel for using Deno’s crates in a Rust program — specifically the <code>deno_core</code> crate.</p>
<h2 id="what-does-it-do">What Does it Do?</h2>
<p>The goal of <code>js-in-rs</code> is to be a CLI, written in Rust, for filtering files using JavaScript expressions. It’s like the tool <code>grep</code> except where grep uses regular expressions, <code>js-in-rs</code> uses JavaScript.</p>
<p>The <code>js-in-rs</code> CLI takes two arguments — a path to an input file that will be filtered and a JavaScript expression where the the value <code>line</code> will be set to the value of each line in the input file and the expression’s truthiness will determine if the line should be printed.</p>
<p>Here’s an example of what it might look like in practice:</p>
<pre is:raw=""><code><span><span>js-in-rs example.txt </span><span>&#39;line.length &gt; 5&#39;</span></span></code></pre>
<p>If the contents of the file <code>example.txt</code> looked like this:</p>
<pre is:raw=""><code><span><span>A</span></span>
<span><span>BBBBBB</span></span>
<span><span>CCC</span></span>
<span><span>DDDDD</span></span>
<span><span>EEEEEEE</span></span></code></pre>
<p>The output of our command would be:</p>
<pre is:raw=""><code><span><span>BBBBBB</span></span>
<span><span>EEEEEEE</span></span></code></pre>
<p>Only the lines of the file with more than 5 characters would be printed.</p>
<p>This is a pretty simple example of a JavaScript filter but due to the versitility of JavaScript, this tool is able to represent much more complex filtering logic. In many cases filters would be very hard if not impossible to express using regular expressions. Not only is JavaScript more readable but it can also be more expressive.</p>
<p>Say you had the following filter conditions:</p>
<ul>
<li>If the line is <code>foo</code>, print it</li>
<li>If the line has 10-20 characters, excluding leading or trailing spaces, print it</li>
<li>Otherwise, don’t print it</li>
</ul>
<p>Now say we have the following input file, <code>sample.txt</code>:</p>
<pre is:raw=""><code><span><span> foo</span></span>
<span><span>foo</span></span>
<span><span>  short</span></span>
<span><span>    this is a long line</span></span>
<span><span> this line is too long, though</span></span></code></pre>
<p>We could use the following <code>grep</code> command (I’m using the <code>-P</code> flag for Perl-compatable regex expressions):</p>
<pre is:raw=""><code><span><span>grep -P </span><span>&#39;^(foo|\s*.{10,20}?\s*)$&#39;</span><span> sample.txt</span></span></code></pre>
<p>And we would correctly get the following output:</p>
<pre is:raw=""><code><span><span>foo</span></span>
<span><span>    this is a long line</span></span></code></pre>
<p>Even in this example, we’re running into issues of readability for the regular expression and, as the discerning reader may have noticed, this regex pattern doesn’t account for all edge cases (eg trailing spaces).</p>
<p>By contrast, using <code>js-in-rs</code> we could write the command as follows:</p>
<pre is:raw=""><code><span><span>js-in-rs sample.txt \</span></span>
<span><span>  </span><span>&#39;line == &#34;foo&#34; || (line.trim().length &gt;= 10 &amp;&amp; line.trim().length &lt;= 20)&#39;</span></span></code></pre>
<p>I would argue that this is much easier to read than the revious regex pattern but even still, we could take it a step further and split it out into multiple lines — including variable assignments and comments:</p>
<pre is:raw=""><code><span><span>js-in-rs sample.txt </span><span>&#34;$(cat </span><span>&lt;&lt;EOF</span></span>
<span><span>{</span></span>
<span><span>  // Is the line &#34;foo&#34;?</span></span>
<span><span>  if (line === &#34;foo&#34;) return true;</span></span>
<span></span>
<span><span>  // Is the line&#39;s length (excluding lead-/trail-ing ws) in [10,20]</span></span>
<span><span>  const trimLine = line.trim();</span></span>
<span><span>  if (trimLine.length &gt;= 10 &amp;&amp; trimLine.length &lt;= 20) {</span></span>
<span><span>    return true;</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  // Otherwise, don&#39;t print...</span></span>
<span><span>  return false;</span></span>
<span><span>}</span></span>
<span><span>EOF</span></span>
<span><span>)&#34;</span></span></code></pre>
<p>Sure enough this gives us the same result:</p>
<pre is:raw=""><code><span><span>foo</span></span>
<span><span>    this is a long line</span></span></code></pre>
<p>Now if you’re looking back through your bash history after a month or two, you’ll have a much easier time remembering what that command does.</p>
<p>What if you wanted to only show lines where at least 50% of the characters in the line are uppercase? I have no idea how to do that using regular expressions. Here’s what the JavaScript filter might look like using <code>js-in-rs</code>:</p>
<pre is:raw=""><code><span><span>line.</span><span>length</span><span> </span><span>&gt;</span><span> </span><span>0</span><span> </span><span>&amp;&amp;</span><span> (</span></span>
<span><span>  Array.</span><span>from</span><span>(line)</span></span>
<span><span>    .</span><span>map</span><span>(</span><span>c</span><span> </span><span>=&gt;</span><span> c </span><span>===</span><span> c.</span><span>toUpperCase</span><span>())</span></span>
<span><span>    .</span><span>reduce</span><span>((</span><span>a</span><span>, </span><span>b</span><span>) </span><span>=&gt;</span><span> a </span><span>+</span><span> b) </span></span>
<span><span>  </span><span>/</span><span> line.</span><span>length</span><span>) </span><span>&gt;</span><span> </span><span>0.5</span></span></code></pre>
<p>Thanks to JavaScript and the Deno runtime, <code>js-in-rs</code> is able to be more expressive and more versitile than grep and yet simpler than writing out a full script in JavaScript and running it yourself with Node or Deno.</p>
<h2 id="show-me-the-rust">Show Me the Rust!</h2>
<p>Using the Deno repository’s examples as reference I was able to get a simple example up and running without much of an issue.</p>
<p>After parsing the command line arguments and reading in the source file to be filtered, the program creates a single instance of the <code>deno_core::JsRuntime</code> that will then be reused throughout the application.</p>
<pre is:raw=""><code><span><span>let</span><span> </span><span>mut</span><span> runtime </span><span>=</span><span> </span><span>JsRuntime</span><span>::</span><span>new</span><span>(</span></span>
<span><span>  </span><span>RuntimeOptions</span><span>::</span><span>default</span><span>(),</span></span>
<span><span>);</span></span></code></pre>
<p>It then iterates through the source file, line-by-line, formatting the filter into a JavaScript expression that defines an anonymous function and calls it using the source file’s line as the argument (see the above section’s explanation).</p>
<p>That expression is then evaluated using the JS runtime and the result is captured.</p>
<pre is:raw=""><code><span><span>let</span><span> result </span><span>=</span><span> runtime</span><span>.</span><span>execute_script</span><span>(</span></span>
<span><span>  </span><span>&#34;matcher.js&#34;</span><span>,</span></span>
<span><span>  js_matcher</span><span>.</span><span>into</span><span>(),</span></span>
<span><span>);</span></span></code></pre>
<p>The result returned can then be deserialized as a <code>serde_json::Value</code> enum which is <em>expected</em> to be a boolean value.</p>
<pre is:raw=""><code><span><span>let</span><span> scope </span><span>=</span><span> </span><span>&amp;mut</span><span> runtime</span><span>.</span><span>handle_scope</span><span>();</span></span>
<span><span>let</span><span> local </span><span>=</span><span> </span><span>v8</span><span>::</span><span>Local</span><span>::</span><span>new</span><span>(scope, global);</span></span>
<span><span>let</span><span> deserialized_value </span><span>=</span><span> </span><span>serde_v8</span><span>::</span><span>from_v8</span><span>::</span><span>&lt;</span><span>serde_json</span><span>::</span><span>Value</span><span>&gt;(scope, local);</span></span></code></pre>
<p>Assuming a boolean type <em>is</em> returned, its value will determine if the line should be printed.</p>
<pre is:raw=""><code><span><span>match</span><span> value {</span></span>
<span><span>  </span><span>serde_json</span><span>::</span><span>Value</span><span>::</span><span>Bool</span><span>(b) </span><span>=&gt;</span><span> {</span></span>
<span><span>    </span><span>if</span><span> b {</span></span>
<span><span>      </span><span>println!</span><span>(</span><span>&#34;{}&#34;</span><span>, line);</span></span>
<span><span>    }</span></span>
<span><span>  },</span></span>
<span><span>  _ </span><span>=&gt;</span><span> </span><span>return</span><span> </span><span>Err</span><span>(</span><span>Error</span><span>::</span><span>msg</span><span>(</span><span>format!</span><span>(</span></span>
<span><span>    </span><span>&#34;JS matcher must return a boolean value!&#34;</span><span>,</span></span>
<span><span>  ))),</span></span>
<span><span>}</span></span></code></pre>
<p>The <code>deno_core</code> crate does a good job of passing along error messages which can come in quite handy. For example, say you accidentially add a semicolon in the middle of your filter expression:</p>
<pre is:raw=""><code><span><span>js-in-rs src/main.rs \</span></span>
<span><span>  </span><span>&#39;line.trim().length &gt; 20 &amp;;&amp; line.trim().length &lt; 50&#39;</span></span></code></pre>
<p>You would get a handy error message like the following:</p>
<pre is:raw=""><code><span><span>Error: Eval error: Uncaught SyntaxError: Unexpected token &#39;;&#39;</span></span>
<span><span>    at matcher.js:1:39</span></span></code></pre>
<p>Admitidly the line numbers may not match up completely, given the fact that the Rust application inserts the filter into a larger expression and error references the file <code>matcher.js</code> which isn’t real, but it is a good enough starting point to debug the issue.</p>
<h2 id="socan-i-rm-usrbingrep">So…can I <code>&#34;rm /usr/bin/grep&#34;</code>?</h2>
<p>By now you’re probably all-in on <code>js-in-rs</code> and ready to delete <code>grep</code> entirely but before you do, remember that this is just a proof of concept. It’s very light on features, light on testing, and there’s room for improvement on the performance.</p>
<p>Even if this project were to continue on to add features, add tests, and boost the performance, you may be better off using a tool written entirely in Rust or entirely in JavaScript.</p>
<p>Rathar than embedding a JavaScript runtime in Rust, the whole tool could be written in JavaScript and <a href="https://deno.com/manual@v1.32.5/tools/compiler">compiled into a self-contained executable using Deno</a>. Though, with that said, the compiled version of <code>js-in-rs</code> ends up being about half the size of the pure-JS Deno-compiled version — the release build of <code>js-in-rs</code> is <code>54 MB</code>, <code>grep</code> is <code>179 KB</code>, and a basic <em>hello world</em> JS application compiled using Deno is <code>103 MB</code>.</p>
<h2 id="takeaways-recommendations--conclusions">Takeaways, Recommendations &amp; Conclusions</h2>
<p>Working with Deno in rust was a lot of fun. The documentation was a bit sparce but what they do have, combined with the examples they provide, was enough to get me up and running to create this small PoC that I’m calling <code>js-in-rs</code>.</p>
<p>While I don’t expect <code>js-in-rs</code> to unseat <code>grep</code> as the go-to command line tool for filtering text — and don’t even really plan to continue developing it — the experience was more than enough to pique my interest and get me thinking about all kinds of other possible applications for running JavaScript in Rust using Dino.</p>
<p>Rust is fast and safe but a bit slower to write and with a bit steaper of a learning curve while JavaScript is well-known language that’s fast to write but that generally runs more slowly — the two languages can fit together synergistically.</p>
<p>Here are a few possible applications that could benefit from running JavaScript in Rust:</p>
<ul>
<li>Web-Servers/APIs with the power and performance of Rust that can be customized using JavaScript</li>
<li>Data pipelines (eg Apache Airflow) where the orchestration is handled by Rust but the high-level business logic is defined using JavaScript</li>
<li>User Defined Functions (UDFs) for databases where Rust can run JS functions in a safe sandbox</li>
</ul>
<p>The Deno runtime also has an interesting approach to permissions where it allows users to turn on/off runtime features like network access, file system access, FFI access, environment variable access, etc. to help prevent nefarious code from accessing resources it shouldn’t. While I didn’t get a chance to explore it in this application, it’s on my list to try in the future.</p>
<p>If you found this interesting I highly recommend trying it out yourself. Play around with Deno’s Rust crates, create your own applications that integrate JavaScript, and if you can, document it to help build the collective knowlege base!</p>
<h2 id="references">References</h2>
<ul>
<li><a href="https://github.com/a-poor/js-in-rs"><code>js-in-rs</code> GitHub Repo</a></li>
<li><a href="https://deno.com/runtime">Deno Runtime</a></li>
<li><a href="https://deno.com/runtime">Deno GitHub Repo</a></li>
<li><a href="https://docs.rs/deno_core/latest/deno_core/"><code>deno_core</code> Docs</a></li>
<li><a href="https://github.com/denoland/deno/tree/main/core/examples"><code>deno_core</code> Examples</a></li>
<li><a href="https://deno.com/manual@v1.32.5/tools/compiler">Deno Compile</a></li>
</ul>

  </article></div>
  </body>
</html>
