<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://erikarow.land/notes/erlang-serve-static-directory">Original</a>
    <h1>Serve a Static Directory with Erlang</h1>
    
    <div id="readability-page-1" class="page"><section id="Serve-a-Static-Directory-with-Erlang">

<p>For a long time, I’ve been serving static files to locally test this website using <code>python3 -m http.server</code>.<label for="fn1"></label><span><span>Actually, I used a custom script that overrode the <code>Handler</code> class to set the mimetype for files without an extension to <code>&#34;text/html&#34;</code>, since I use that to get clean urls without <code>.html</code> on the end.</span></span> I’ve wanted to do this with Erlang for a long time, after I found out that Erlang has a built in <a href="https://www.erlang.org/doc/apps/inets/http_server"><code>httpd</code> server</a>.</p>
<p>Recently, I found out<label for="fn2"></label><span><span>Thank you to someone on the <a href="https://gleam.run/">Gleam</a> discord who pointed this out to me!</span></span> that a short command like the python one will be added in <a href="https://github.com/erlang/otp/pull/7299">OTP 27</a><label for="fn3"></label><span><span>Investigating the origin of the pull request, I found <a href="https://gist.github.com/willurd/5720255">this list</a> of “serve this directory of static files” commands across a variety of languages. If Erlang isn’t your jam, enjoy!</span></span>. Soon you will be able to invoke <code>erl -S httpd</code> to serve static files locally. Looking at the <a href="https://github.com/erlang/otp/pull/7299/files#diff-d8239d05391b50fc317f0ce1f9ea048a8011210ebd3361e31f60e379c970fe13">diff</a> I was able to write an Elixir script that serves a static directory for me now.</p>
<section id="The-Script">
<h2>The Script</h2>
<p>The core of the script is powered by <code>:httpd.start_service/1</code> which takes a proplist of settings that configure the httpd server. I always found the list of configuration options intimidating, so I was glad to have a place to start with from the diff.</p>
<section id="Required-Property">
<h3>Required Property</h3>
<p>Four properties are required:</p>
<pre><code>[
  {:port, 8008},
  {:server_name, &#39;localhost&#39;},
  {:server_root, absolute_path},
  {:document_root, absolute_path}
]
</code></pre>
<p>A few notes:</p>
<ul>
<li>
All string properties need to be single-quoted Elixir charlists, because <code>:httpd</code> is expecting Erlang strings, not Elixir binaries.<label for="fn4"></label><span><span>From the Elixir <a href="https://hexdocs.pm/elixir/1.12/List.html#module-charlists">documentation</a>: “The rationale behind this behaviour is to better support Erlang libraries which may return text as charlists instead of Elixir strings.”</span></span>
</li>
<li>
I had to set <code>:server_name</code> to exactly <code>&#39;localhost&#39;</code>, in order to get my websites relative links to work correctly. So far I can tell, I can run multiple versions of <code>:httpd</code> on different ports with the same name without issue.
</li>
<li>
<code>absolute_path</code>, like the diff, I used an absolute_path path generated using some Erlang functions instead of a local path, but I believe a relative path would work.
</li>
<li>
<code>:server_root</code> is the root directory that all other properties are relative to.
</li>
<li>
<code>:document_root</code> is what I actually want to serve my static files.
</li>
</ul>
</section>
<section id="Additional-Properties">
<h3>Additional Properties</h3>
<p>I also set some additional properties for my needs:</p>
<section id="bind_address">
<h4><code>:bind_address</code></h4>
<p>The default value is set to <code>:any</code>, I specifically set mine to <code>{127, 0, 0, 1}</code>. I think this would be the same as the <code>:any</code> behavior, but better safe than sorry.</p>
</section>
<section id="mime_types">
<h4><code>:mime_types</code></h4>
<p>Like I did with Python, I was able to set the mimetype for no extension to <code>text/html</code> by adding <code>{&#39;&#39;, &#39;text/html&#39;}</code> to my list of mimetypes, which I otherwise took from the diff.</p>
</section>
<section id="default_type">
<h4><code>:default_type</code></h4>
<p>This undocumented<label for="fn5"></label><span><span>The <a href="https://www.erlang.org/doc/man/httpd#prop_mime_type">documentation</a> says to use <code>mime_type</code>, but I found that when I set this to <code>&#39;text/html&#39;</code>, my extensionless files still were rendered as plain text. After investigation, I found that <code>mime_type</code> <a href="https://github.com/erlang/otp/issues/7827">does nothing</a> and hasn’t since at least OTP-17.0.</span><span>The <code>default_type</code> property does do what <code>mime_type</code> claims, but isn’t mentioned in the documentation.</span></span> property sets the default mimetype for files that don’t match the existing <code>:mime_types</code>.</p>
</section>
<section id="directory_index">
<h4><code>:directory_index</code></h4>
<p>Idiosyncratically, I use <code>home</code> instead of <code>index.html</code> for my folder indexes on my website, Erlang easily let me set this with <code>{:directory_index, [&#39;home&#39;]}</code>.<label for="fn6"></label><span><span>I don’t remember where I picked this up from, but I’ve used in my last 3 static site generators.</span></span></p>
</section>
<section id="modules">
<h4><code>:modules</code></h4>
<p><code>:httpd</code> comes with a number of <a href="https://www.erlang.org/doc/apps/inets/http_server#inets-web-server-modules">modules</a><label for="fn7"></label><span><span>There’s a <code>mod_trace</code> module that enables support for the TRACE request type. I didn’t know these existed, but apparently they’re included in HTTP/1.1. It’s even listed on <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/TRACE">MDN</a>!?</span></span> to extend its behavior. For my script, I enabled the same three as the diff:</p>
<ul>
<li>
<code>:mod_alias</code>, I believe this enables the directory index behavior.
</li>
<li>
<code>:mod_dir</code>, will generate an Apache style file listing, if a directory index isn’t found, though this shouldn’t apply for my website.
</li>
<li>
<code>:mod_get</code>, which enables GET requests for regular files, which is what I want to a static directory being served.
</li>
</ul>
</section>
</section>
<section id="Other-Details">
<h3>Other Details</h3>
<section id="inetsstart0">
<h4><code>:inets.start/0</code></h4>
<p>The <code>:inets</code> service must be started before <code>:httpd</code> can work. So my script includes a call to <code>:inets.start()</code> before <code>:httpd.start_service/1</code>.</p>
</section>
<section id="no-halt">
<h4><code>no-halt</code></h4>
<p>The <code>:inets</code> <a href="https://www.erlang.org/doc/apps/inets/http_server#getting-started">Getting Started</a> suggests that after starting <code>:inets</code>, you can start an <code>:httpd</code> server by calling <code>:inets.start(:httpd, config)</code>. This does start a httpd server, but in my script it immediately ended because the main process no longer had any work.</p>
<p>I can avoid this behavior by passing <code>--no-halt</code> when calling my script, but I chose to mimic the diff, by setting up a <code>receive do</code> which blocks until it receives a message that the server is down. This gives the same effect, without needing to pass additional arguments on invocation.</p>
</section>
</section>
</section>
<section id="Takeaways">
<h2>Takeaways</h2>
<p>I’m glad to hear that Erlang is soon going to get the ability to quickly and easily host a static directory like Python. If you’re interested in this ability now, I’ve put my script <a href="https://paste.sr.ht/~erikareads/72a9c6c9c77731bfe2945c1a9984b9ad0af668f6">here</a>.<label for="fn8"></label><span><span>If you would prefer the escript, I’ve created that <a href="https://paste.sr.ht/~erikareads/fb242336227367307acc88cbb721d1ef114b44ef">here</a>. I prefer the Elixir syntax, but the escript version has the benefit of only needing Erlang to run.</span></span></p>
</section>
</section></div>
  </body>
</html>
