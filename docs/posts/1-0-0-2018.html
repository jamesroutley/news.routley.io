<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.hillelwayne.com/post/divide-by-zero/">Original</a>
    <h1>1/0 = 0 (2018)</h1>
    
    <div id="readability-page-1" class="page"><article lang="en">
    

    
    

    <div>
  

<p>Have a tweet:</p>



<p><img src="https://www.hillelwayne.com/post/divide-by-zero/tweet.png" alt="Picture of original tweet, name blacked out"/></p>

<p>I have no idea if <a href="https://www.ponylang.org/">Pony</a> is making the right choice here, I don’t know Pony, and I don’t have any interest in learning Pony. But this tweet raised my hackles for two reasons:</p>

<ol>
<li>It’s pretty smug. I have very strong opinions about programming, but one rule I try to follow is <em>do not mock other programmers</em>. Programming is too big and I’m too small to understand everything. Disagreeing is fine, laying out why people are wrong is fine, making fun of them is not fine.</li>
<li>It’s saying that Pony is <em>mathematically</em> wrong. This is objectively false.</li>
</ol>

<p>I tweeted a thing about why <code>1/0 = 0</code> is mathematically sound. Some people agreed, some people agreed with caveats, and some people called it bunk. A few people said it’s clear I don’t know real mathematics, because a real mathematician would never make such a mistake.</p>

<p>So in this post I’d like to clearly, formally lay out why it’s consistent to say that <code>1/0 = 0</code>, why some of the common objections don’t apply, and what the real mathematicians say. Fair warning, this post is going to be a little more mathematically dense than my usual stuff. I’ve tried to make it clear but, well, math.</p>

<h2 id="consistency">Consistency</h2>

<p>First we need to explain what we mean by “consistency”. The formalism is <strong>sound</strong> if you can only use it to prove true statements. To say <code>1/0 = 0</code> is unsound is to either say that we can prove <code>1/0 ≠ 0</code> or that, given <code>1/0 = 0</code>, we can prove something that’s false. These are actually equivalent statements but it’ll be useful to treat them as distinct for teaching purposes.</p>

<p>Next we need to explain what we mean by “division”. But to do that, I need to introduce <strong>fields</strong>.</p>

<h2 id="fields">Fields</h2>

<p>A field is a set of elements (S) along with an <strong>addition operator</strong> (<code>+</code>) and a <strong>multiplication operator</strong> (<code>*</code>) that follow some properties:</p>

<ol>
<li>The set is <strong>closed</strong> under both operations. If <code>x</code> is an element of S and <code>y</code> is an element of S, then both <code>x + y</code> and <code>x * y</code> are elements of S.</li>
<li>Both operations are <strong>commutative</strong>. <code>a + b = b + a</code>, and <code>a * b = b * a</code>.</li>
<li>Both operations are <strong>associative</strong>. <code>a + (b + c) = (a + b) + c</code>, and <code>a * (b * c) = (a * b) * c</code>.</li>
<li>Multiplication is distributive. <code>a * (b + c) = a * b + a * c</code>.</li>
<li>There is an element that is the <strong>additive identity</strong>, or <code>0</code>, such that <code>a + 0 = a</code>.</li>
<li>There is an element that is the <strong>multiplicative identity</strong>, or <code>1</code>, such that <code>a * 1 = a</code>.</li>
<li>The two identities are different elements. <code>1 ≠ 0</code>.</li>
<li>Every element has an <strong>additive inverse</strong>, <code>-a</code>, such that <code>a + (-a) = 0</code>.</li>
<li>Every element EXCEPT 0 has a <strong>multiplicative inverse</strong>, <code>a⁻</code>, such that <code>a*a⁻ = 1</code>.</li>
</ol>

<p>These are all of the rules of a field. We can define S, +, and * any way we want, as long as all of the rules are followed. The real numbers, along with our conventional notion of addition and multiplication, form a field. This gives us the building blocks to discover properties of our system. In order to prove a <strong>theorem</strong>, we need to be able to derive it solely through the definitions of <code>S/+/*</code>, the definition of a field, and any axioms we have. For example, we can prove that for all <code>a</code>, <code>a * 0 = 0</code>:</p>

<ol>
<li>By the additive identity, <code>0 + 0 = 0</code>, so <code>a * 0 = a * (0 + 0)</code></li>
<li>By the distributive property, <code>a * (0 + 0) = a * 0 + a * 0</code></li>
<li>By the additive inverse property, there is some <code>- (a * 0)</code> such that <code>- (a * 0) + (a * 0) = 0</code>.</li>
<li>Combining (1) and (2), we get <code>a * 0 = a * 0 + a * 0</code>.</li>
<li>Combining (3) and (4), we get  <code>- (a * 0) + (a * 0) = - (a * 0) + a * 0 + a * 0</code>.</li>
<li>Evaluating (5) gives us <code>0 = a * 0</code>. QED.</li>
</ol>

<p>Now that we have this as a theorem, we can use it to prove other theorems. Given this property, we can immediately show that there is no multiplicative inverse of 0:</p>

<ol>
<li>If 0 had a multiplicative inverse <code>0⁻</code>, then <code>0 * 0⁻ = 1</code>.</li>
<li>For all real numbers, <code>a * 0 = 0</code>.</li>
<li>Since <code>1 ≠ 0</code>, there is no multiplicative inverse of <code>0⁻</code>.</li>
</ol>

<p>Okay, now we can talk about division in the reals.</p>

<h2 id="division">Division</h2>

<p>The field definition does <em>not</em> include division, nor do our definitions of addition or multiplication. This means we are free to define division however we want. We want to define it in a way that <em>mostly</em> follows our intuition and is sound. I say <em>mostly</em> because our intuition doesn’t generalize. As an example, we intuitively think of <code>a * b</code> as “<code>a</code> summed up <code>b</code> times”. So what’s <code>-1 * π</code>? How do you sum up something π times? While it would be nice if division didn’t have any “oddness” to it, we can’t guarantee that without kneecapping mathematics.</p>

<p>The intuitive definition of division is multiplying by the inverse. <code>a/2 = a * 2⁻</code>. Under this definition, we can get all of the properties of division we’re used to by proving that they hold. For example,</p>

<ul>
<li>Theorem: <code>a/a = 1</code>. Proof: <code>a/a = a * a⁻ = 1</code>.</li>
<li>Theorem: <code>a * (b/c) = b * (a/c)</code>. Proof:  <code>a * (b/c) = a * (b * c⁻)</code>. Since multiplication is commutative and associative, we can rearrange this to get <code>b * (a * c⁻) = b * (a/c)</code>.</li>
</ul>

<p>This is all great, except for one problem: <strong>0 does not have a multiplicative inverse</strong>. Both of those proofs are invalid: if I write <code>0/0</code>, I get <code>0 * 0⁻</code>, which is an invalid equation. So we <em>cannot</em> prove that <code>a/a = 1</code>. We <em>can</em>, however, prove something weaker:</p>

<ul>
<li>Theorem: IF <code>a ≠ 0</code>, THEN <code>a/a = 1</code>. Proof: same.</li>
<li>Theorem: IF <code>c ≠ 0</code>, THEN <code>a * (b/c) = b * (a/c)</code>. Proof: same.</li>
</ul>

<p>Note this does <em>not</em> go both ways: it does <em>not</em> follow that <code>0/0 ≠ 1</code>. All we know is we cannot use <em>this</em> theorem to prove that <code>0/0 = 1</code>. So we do not have that <code>0/0 ≠ 1</code>. For any given number, we <em>cannot</em> prove that <code>0/0</code> is not that number! Since we’ve defined division as multiplying by the inverse, and zero does not have an inverse, our definition of division does not cover dividing by zero. It does not say anything about it, leaving it “undefined” if you will.</p>

<p>Since this form of division is not defined for 0, it is a <strong>partial function</strong> over the reals: there is some value in its domain that we have not specified. Practically, this is <em>fine</em>: we’re used to thinking of <code>1/0</code> as an impossible operation. But this has some weird consequences: one of our axioms is everything is equal to itself. So does <code>1/0 = 1/0</code>? If you say that’s silly, we no longer have <code>a = a</code>! And even if you’re fine with that, what about the statement <code>TRUE \/ (1/0 = 1/0)</code>? It shouldn’t matter what the second clause is, because that statement should be true. But by the axiom of the excluded middle, we’d then <em>have</em> to say the second clause is either true or false. When trying to formalize math and logic, we have to find some way to address what happens if you write <code>1/0</code>. So there’s generally three things mathematicians can do:</p>

<ul>
<li>We can say nope, sorry, you can’t even write <code>1/0</code>, much less give it a value. This is what we do in our day-to-day lives, and the way that Agda and Idris handle division.</li>
<li>We can choose some value that isn’t a real number, such as “undefined” or infinity, and say <code>x/0 = &lt;whatever&gt;</code>. This is what some mathematicians do with the Riemann sphere.</li>
<li>We could choose some real number, like 19, and say that <code>x/0 = 19</code>. This is what Isabelle, Lean and Coq do.</li>
</ul>

<p>All of these have tradeoffs. We already talked about some of the headaches with banning equations like <code>1/0</code>. With an “undefined” value, division is no longer closed on the reals. In the last case, you explode everybody’s intuitive notion of division. But <em>all of these are sound.</em> Since our original notion of division does not say anything about dividing by zero, it does not <em>rule out</em> anything. None of these extensions lead to a contradiction.</p>

<p>The controversy is over the last case, so let’s focus on that. We’ll define division as follows: <code>IF b = 0 THEN a/b = 1 ELSE a/b = a * b⁻</code>.</p>

<p>Something I need to emphasize here: <strong>this does not give us an inverse of 0.</strong> <code>1/0</code> is not <code>0⁻</code>. This means that while <code>0/0 = 1</code>, <code>0 * 1/0 = 0</code>. Division is only “multiply by the inverse” when the denominator isn’t 0. All we’ve done is special case dividing by zero and nothing else. And doing so is mathematically consistent, because <em>under this definition of division</em> you can’t take <code>1/0 = 1</code> and prove something false.</p>

<h2 id="objections">Objections</h2>

<p>Here’s where a lot of people objected. They would take the fact <code>1/0 = 1</code> and prove something false, usually <code>1 = 0</code>. None of these proofs, however, are sound. To see why, let’s dig into a couple example proofs and show where they break down.</p>

<p>Here’s a common argument:</p>

<ol>
<li><code>1/0 = 1</code></li>
<li><code>1/0 * 0 = 1 * 0</code></li>
<li><code>1 * 0/0 = 0</code></li>
<li><code>1 = 0</code></li>
</ol>

<p>The problem is in step (3): our division theorem is only valid for <code>c ≠ 0</code>, so you can’t go from <code>1/0 * 0</code> to <code>1 * 0/0</code>. The “denominator is nonzero” clause prevents us from taking our definition and reaching this contradiction.</p>

<p>Here’s where people got tripped up. They assume we needed the nonzero clause on our division theorems because <code>x/0</code> is undefined. “If <code>x/0</code> is a value, then the theorem should extend to <code>c=0</code>, too.” <strong>This is wrong.</strong> The problem is <em>not</em> that <code>1/0</code> was undefined. The problem was that our proof uses the multiplicative inverse, and there is no multiplicative inverse of 0. Under our modified definition of division, we <em>still</em> don’t have <code>0⁻</code>, which means our proof <em>still</em> does not work for dividing by zero. We still need the condition. So it is <em>not</em> a theorem that <code>a * (b / 0) = b * (a / 0)</code>.</p>

<p>To be clear, this does <em>not</em> mean they must be different! All we know is that we cannot use <em>this</em> theorem to argue they <em>are</em> equal. Since the “proof” that <code>1 = 0</code> used that theorem, the proof is unsound.</p>

<p>Pretty much every counterargument makes this exact same mistake: it assumes that because <code>1/0</code> is now defined, there is now some <code>0⁻</code> that generalizes our theorems. But there’s not.</p>

<p>Another common objection is that if <code>1/0 = 1</code>, then multiplicative inverses are no longer unique: <code>2/2 = 1</code>, but also <code>2/0 = 1</code>, so now 2 has two inverses. This, again, confuses cause and effect. <code>1/2</code> is the inverse of 2 <strong>not</strong> because of how we define inverses, but how we defined division. <code>2/2 = 1</code> because <code>2/2 = 2 * 2⁻</code>. But, again, zero does not have an inverse, and <code>2/0</code> is not <code>2 * 0⁻</code>. Since <code>0⁻</code> does not exist, it is not an inverse of 2, and every nonzero number still has a unique inverse.</p>

<p>If you want to prove that <code>1/0 = 1</code> leads to a contradiction, you must explicitly list every step you take and show that none of them assume that <code>0⁻</code> exists.</p>

<h2 id="1-0-0"><code>1/0 = 0</code></h2>

<p><del>We’ve now established</del> Let’s assume for now that if we choose some constant <code>C</code>, then defining division such that <code>x/0 = C</code> does not lead to any inconsistencies. It turns out that for certain choices of C, specifically 0, we can make some theorems <em>stronger</em>. We can do this by removing the conditions on (some of) our division theorems, and then add a special case to the proof itself. For example:</p>

<ul>
<li>Theorem: <code>a * (b/c) = b * (a/c)</code>. Proof: we already proved this for <code>c ≠ 0</code>. Now let <code>c = 0</code>. Then <code>a * (b/0) = a * 0 = 0</code>, and <code>b * (a/0) = b * 0 = 0</code>, and <code>0 = 0</code>.</li>
</ul>

<p>Under this definition of division step (3) in the counterargument above is now valid: we <em>can</em> say that <code>1/0 * 0 = 1 * 0/0</code>. However, in step (4) we say that <code>0/0 = 1</code>. This theorem does not get stronger:</p>

<ul>
<li>“Theorem”: <code>a/a = 1</code>. Proof: we already proved this for <code>a ≠ 0</code>. Now let <code>a = 0</code>. Then <code>a/a = 0/0 = 0</code>, so <code>1 = 0</code> and wait shit nevermind</li>
</ul>

<p>This is why Lean and Isabelle define <code>1/0</code> this way. Coq does it too, but as far as I can tell they don’t use it as an optimization.</p>

<h2 id="the-real-mathematicians">The Real Mathematicians</h2>

<p>A final objection is that I’m a CS person, not a mathmatician, so I don’t understand the math here. But what do the PhDs say?</p>

<p><a href="https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2018-February/msg00128.html">Lawrence Paulson</a>, professor of computational logic and inventor of Isabelle:</p>

<blockquote>
<p>A bit of history: the first logic supported within Isabelle was Martin-Löf’s constructive type theory, and it is still there (CTT). And while developing arithmetic within that formalisation, I came up with a definition (necessarily primitive recursive and executable) of division. It delivered n/0 = 0. Since then a number of people have noticed that defining x/0 = 0 is convenient. This identity holds in quite a few different proof assistants now.</p>

<p>These things are conventions, exactly the same as announcing that x^-n = 1/x^n and that x^0 = 0 [sic].</p>
</blockquote>

<p><a href="https://lamport.azurewebsites.net/pubs/lamport-types.pdf">Leslie Lamport</a>, Math PhD and winner of the 2013 Turing Award:</p>

<blockquote>
<p>[In ZF set theory] Since 0 is not in the domain of <em>recip</em>, we know nothing about the value of <code>1 / 0</code>; it might equal <code>√2</code>, it might equal R, or it might equal anything else.</p>
</blockquote>

<p><a href="http://storm-country.com/blog/">Matt Noonan</a>, Math PhD and introducer of <a href="http://kataskeue.com/gdp.pdf">Ghost Proofs</a> to Haskell:</p>

<blockquote>
<p>looks all fine to me!</p>
</blockquote>

<p>Arthur Azevedo de Amorim, an author of the <a href="https://softwarefoundations.cis.upenn.edu/">introductory Coq textbook</a>, reconstructs the same argument I did <a href="https://stackoverflow.com/questions/29282819/coq-qarith-division-by-zero-is-zero-why/29286440#29286440">here</a>.</p>

<p>I also chatted with a few math graduate student friends and emailed a couple of postdocs I know. So far people nobody’s said that letting <code>1/0 = 0</code> is unsound. If any end up getting back to me with that I will include their refutation of this post.</p>

<h2 id="conclusions">Conclusions</h2>

<p>This was originally motivated by how Pony does division. So, is Pony doing the right thing here? No clue. Pony is a programming language, not a formal mathematical system. Consistency is less important than safety, convenience, and context. As a programmer, I don’t like it.</p>

<p>But is Pony doing something unsound? Absolutely not. It is <em>totally fine</em> to define <code>1/0 = 0</code>. Nothing breaks and you can’t prove something false. Everybody who was making fun of Pony programmers for being ‘bad at math’ doesn’t actually understand the math behind it.</p>

<p>Don’t make fun of other people. The world is big and we are small.</p>

<p><em>Thanks to Watson Ladd, <a href="http://storm-country.com/blog/">Matt Noonan</a>, <a href="https://pron.github.io/">Ron Pressler</a>, Josh Lieber, and Edwin Brady for feedback.</em></p>

<h2 id="update-8-12-2018">Update 8/12/2018</h2>

<p>Some people pointed out I was using some terms ambiguously, which I’ve done my best to fix. A bunch of people also sent in more counterarguments, most of which fell along common themes.</p>

<blockquote>
<p><code>ab = cb =&gt; a = c</code> but with division by zero we have <code>1 * 0 = 2 * 0 =&gt; 1 = 2</code>.</p>
</blockquote>

<p>This is a common mistake a lot of people made: assuming that some property of division is somehow part of the definition, not something we have to show is true. But division has no “innate” properties: everything manipulation we make involving it is something we have to prove is a valid manipulation. For any contradiction, you must list out, for every manipulation of the equation you make, the theorem that makes that manipulation valid, and show that the proof of that theorem does not use <code>0⁻</code>.</p>

<blockquote>
<p>Letting <code>1/0 = 0</code> will lead to hidden errors in your program.</p>
</blockquote>

<p>As mentioned before, <em>this is not a post about what’s practically a good idea.</em> All I’m arguing is that mathematically, we can extend division in this way without leading to a contradiction. Programming languages are different from mathematical formalisms, and <em>should</em> be different. I prefer that <code>1/0</code> is an error, because I’m not using my program to prove theories.</p>

<p>All languages need to make sacrifices of mathematical soundness in favor of safety, practicality, and predictability. It’s the same reason why, in almost every practically-used language, <code>head</code> has type <code>[a] -&gt; a</code>, not <code>[a] -&gt; Maybe a</code>.</p>

<blockquote>
<p>We no longer have that division is the inverse of multiplication over its whole domain.</p>
</blockquote>

<p>This is a common argument, and arguably is more about the “aesthetics” of division than what’s formalizable. This happens a lot when we extend functions. For example, over the naturals, <code>a * b</code> is just repeated addition. But if we extend multiplication over the rationals, then we lose that nice definition.</p>

<p>In general, I aesthetically “dislike” definitions and theorems that explicitly include a dependence on a function’s domain, because it leads to “side effects” when we extend them.</p>

<blockquote>
<p>If <code>0/0 = 0</code> then <code>lim_(x -&gt; 0) sin(x) / x = sin(0) / 0 = 0</code>, but by L’Hospitals’ Rule  <code>lim_(x -&gt; 0) sin(x) / x = lim_(x -&gt; 0) cos(x) / 1 = 1</code>. So we have <code>0 = 1</code>.</p>
</blockquote>

<p>This was a really clever one. The issue is that the counterargument assumes that if the limit exists and <code>f(0)</code> is defined, then <code>lim_(x -&gt; 0) f(x) = f(0)</code>. This isn’t always true: take a continuous function and add a point discontinuity. The limit of <code>sin(x) / x</code> is not <code>sin(0) / 0</code>, because <code>sin(x) / x</code> is discontinuous at 0. For the unextended division it’s because <code>sin(0) / 0</code> is undefined, while for our extended division it’s a point discontinuity. Funnily enough if we instead picked <code>x/0 = 1</code> then <code>sin(x) / x</code> would be continuous everywhere.</p>

<p>A couple of other people brought up limit arguments, but they all are addressed in a similar way.</p>

<blockquote>
<p>It’s icky.</p>
</blockquote>

<p>Don’t disagree.</p>

<h2 id="update-10-23-19">Update 10/23/19</h2>

<p>I’ve been informed that Pony <a href="https://tutorial.ponylang.io/expressions/arithmetic.html#partial-and-checked-arithmetic">now supports partial division</a>.</p>


</div>

    



  </article></div>
  </body>
</html>
