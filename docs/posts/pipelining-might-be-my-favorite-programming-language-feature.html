<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://herecomesthemoon.net/2025/04/pipelining/">Original</a>
    <h1>Pipelining might be my favorite programming language feature</h1>
    
    <div id="readability-page-1" class="page"><div>
      <article>
        <section id="content">
          
          <div>
            <p>
              <em><strong>Epistemic status:</strong> Don’t take it too seriously. Or do. idk, I can’t stop you.</em>
            </p>
            <div>
              <figure data-imgstate="dither">
                <img alt="Pop culture reference." data-dither="/2025/04/pipelining/images/dithers/neat2_dithered.png" data-original="https://herecomesthemoon.net/2025/04/pipelining/images/neat2_hu11050317627517953672.webp" loading="lazy" src="https://herecomesthemoon.net/2025/04/pipelining/images/dithers/neat2_dithered.png"/>
                <div>
                  <figcaption>
                    <span> Pop culture reference. </span>
                    <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                      <rect height="24.28" width="24.28" x="13.51" y="13.58"></rect>
                      <rect height="24.28" width="24.28" x="37.93" y="37.86"></rect>
                      <rect height="24.28" width="24.28" x="62.21" y="13.58"></rect>
                      <rect height="24.28" width="24.28" x="13.51" y="62.14"></rect>
                      <rect height="24.28" width="24.28" x="62.21" y="62.14"></rect>
                    </svg>
                    <p><span> Toggle original/dithered image </span>
                    </p>
                  </figcaption>
                </div>
              </figure>
            </div>
            <p>Pipelining might be my favorite programming language feature.</p>
            <p>
              What is pipelining? Pipelining is the feature that allows you to omit a single argument from your
              parameter list, by instead passing the previous value.
            </p>
            <p>When I say pipelining, I’m talking about the ability to write code like this:</p>
            <div>
              <pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>get_ids</span>(data: <span>Vec</span><span>&lt;</span>Widget<span>&gt;</span>)<span> </span>-&gt; <span>Vec</span><span>&lt;</span>Id<span>&gt;</span><span> </span>{<span>
</span></span></span><span><span><span>    </span>data.iter()<span>              </span><span>// get iterator over elements of the list
</span></span></span><span><span><span></span><span>        </span>.filter(<span>|</span>w<span>|</span><span> </span>w.alive)<span> </span><span>// use lambda to ignore tombstoned widgets
</span></span></span><span><span><span></span><span>        </span>.map(<span>|</span>w<span>|</span><span> </span>w.id)<span>       </span><span>// extract ids from widgets
</span></span></span><span><span><span></span><span>        </span>.collect()<span>           </span><span>// assemble iterator into data structure (Vec)
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre>
            </div>
            <p>
              As opposed to code like this. (This is not real Rust code. Quick challenge for the curious Rustacean, can
              you explain why we cannot rewrite the above code like this, even if we import all of the symbols?)
            </p>
            <div>
              <pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>get_ids</span>(data: <span>Vec</span><span>&lt;</span>Widget<span>&gt;</span>)<span> </span>-&gt; <span>Vec</span><span>&lt;</span>Id<span>&gt;</span><span> </span>{<span>
</span></span></span><span><span><span>    </span>collect(map(filter(iter(data),<span> </span><span>|</span>w<span>|</span><span> </span>w.alive),<span> </span><span>|</span>w<span>|</span><span> </span>w.id))<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre>
            </div>
            <p>
              I honestly feel like this should be so obvious that it shouldn’t even be up for debate. The first code
              example—with its nice ‘pipelining’ or ‘method chaining’ or whatever you want to call it—it
              <em>just works</em>. It can be read line-by-line. It’s easy to annotate it with comments. It doesn’t
              require introduction of new variables to become more readable since it’s already readable as is.
            </p>
            <p>
              As opposed to, y’know,
              <em>the first word in the line describing the final action our function performs</em>.
            </p>
            <p>
              Let me make it very clear: This is an <del>article</del> <em>hot take</em> about syntax. In practice,
              <em>semantics beat syntax every day of the week</em>. In other words, don’t take it too seriously.
            </p>
            <p>
              Second, this is not about imperative vs. functional programming. This article takes for granted that
              you’re already on board with concepts such as ‘map’ and ‘filter’. It’s possible to overuse that style, but
              I won’t talk about it here.
            </p>
            <ul>
              <li><a href="#you-already-agree-with-me">You already agree with me</a></li>
              <li><a href="#code-discovery">Code Discovery</a></li>
              <li><a href="#editing-benefits">Editing Benefits</a></li>
              <li><a href="#sql">SQL</a></li>
              <li><a href="#the-builder-pattern">The Builder Pattern</a></li>
              <li><a href="#rusts-pipelining-is-pretty-neat">Rust’s pipelining is pretty neat</a></li>
              <li><a href="#conclusion">Conclusion</a></li>
            </ul>
            <h2 id="you-already-agree-with-me">You already agree with me</h2>
            <p>
              Here is a feature that’s so bog-standard in modern programming languages that it barely feels like a
              feature at all. Member access for structs or classes with our beloved friend the <code>.</code>-operator.
            </p>
            <p>
              This is a form of pipelining. It puts the data first, the operator in the middle, and concludes with the
              action (restricting to a member field). That’s an instance of what I call pipelining.
            </p>
            <div>
              <pre tabindex="0"><code data-lang="go"><span><span><span>type</span> Bar <span>struct</span> {
</span></span><span><span>	field <span>int</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>get_field</span>(bar Bar) <span>int</span> {
</span></span><span><span>	<span>return</span> bar.field
</span></span><span><span>}
</span></span><span><span><span>// vs. syntax like that of Python&#39;s `getattr` function
</span></span></span><span><span><span></span><span>func</span> <span>get_field</span>(bar Bar) <span>int</span> {
</span></span><span><span>	<span>return</span> <span>getattr</span>(bar, <span>&#34;field&#34;</span>)
</span></span><span><span>}
</span></span></code></pre>
            </div>
            <p>
              You see what I am getting at, right? It’s the same principle. One of the reasons why
              <code>x.y</code>-style member access syntax (and <code>x.y()</code>-style method call syntax!) is popular
              is since it’s easy to read and chains easily.
            </p>
            <p>
              Let’s make the comparison slightly more fair, and pretend that we have to write <code>x.get(y)</code>.
              Compare:
            </p>
            <div>
              <pre tabindex="0"><code data-lang="go"><span><span>fizz.<span>get</span>(bar).<span>get</span>(buzz).<span>get</span>(foo)
</span></span><span><span><span>// vs.
</span></span></span><span><span><span></span><span>get</span>(<span>get</span>(<span>get</span>(fizz, bar), buzz), foo)
</span></span></code></pre>
            </div>
            <p>
              Which one of these is easier to read? The pipelined syntax, obviously. This example is easy to parse
              either way, but imagine you’d like to blend out some information and purely focus on the final operation.
            </p>
            <div>
              <pre tabindex="0"><code data-lang="go"><span><span>&lt;previous stuff&gt;.<span>get</span>(foo)
</span></span><span><span><span>// vs.
</span></span></span><span><span><span></span><span>get</span>(&lt;previous stuff&gt;, foo)
</span></span></code></pre>
            </div>
            <p>
              You see the problem, right? In the first example, we have ‘all of the previous stuff’ and then
              <em>apply another operation</em> to it. In the second example, the operation which we want to perform
              (<code>get</code>) and the new operand (<code>foo</code>) are spread out with ‘all of the previous stuff’
              sitting between them.
            </p>
            <p>Looking back at our original example, the problem should be obvious:</p>
            <div>
              <pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>get_ids</span>(data: <span>Vec</span><span>&lt;</span>Widget<span>&gt;</span>)<span> </span>-&gt; <span>Vec</span><span>&lt;</span>Id<span>&gt;</span><span> </span>{<span>
</span></span></span><span><span><span>    </span>collect(map(filter(iter(data),<span> </span><span>|</span>w<span>|</span><span> </span>w.alive),<span> </span><span>|</span>w<span>|</span><span> </span>w.id))<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span></span><span>-----------------------------</span><span>1</span><span> </span><span>// it&#39;s fun to parse the whole line to find the start
</span></span></span><span><span><span></span><span>------------------------</span><span>2</span><span>
</span></span></span><span><span><span></span><span>-----------------</span><span>3</span><span>
</span></span></span><span><span><span></span><span>---------------------------------------</span><span>4</span><span> </span><span>// all the way back to find the second arg
</span></span></span><span><span><span></span><span>-------------</span><span>5</span><span>
</span></span></span><span><span><span></span><span>------------------------------------------------------</span><span>6</span><span> </span><span>// and all the way back again
</span></span></span><span><span><span></span><span>-----</span><span>7</span><span> </span><span>// okay the final step is the first word in the line that makes sense
</span></span></span></code></pre>
            </div>
            <p>
              I cannot deny the allegations: I just don’t think it makes sense to write code like that as long as a
              clearly better option exists.
            </p>
            <p>
              Why would I have to parse the whole line just to figure out where my input comes in, and why is the data
              flow ‘from the inside to the outside’? It’s kind of silly, if you ask me.
            </p>
            <h2 id="editing-benefits">Editing Benefits</h2>
            <div>
              <figure data-imgstate="dither">
                <img alt="The experience of trying to use pipelining syntax in Python." data-dither="/2025/04/pipelining/images/dithers/pipe-rock_dithered.png" data-original="https://herecomesthemoon.net/2025/04/pipelining/images/pipe-rock_hu14726779274674611026.webp" loading="lazy" src="https://herecomesthemoon.net/2025/04/pipelining/images/dithers/pipe-rock_dithered.png"/>
                <div>
                  <figcaption>
                    <span> The experience of trying to use pipelining syntax in Python. </span>
                    <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                      <rect height="24.28" width="24.28" x="13.51" y="13.58"></rect>
                      <rect height="24.28" width="24.28" x="37.93" y="37.86"></rect>
                      <rect height="24.28" width="24.28" x="62.21" y="13.58"></rect>
                      <rect height="24.28" width="24.28" x="13.51" y="62.14"></rect>
                      <rect height="24.28" width="24.28" x="62.21" y="62.14"></rect>
                    </svg>
                    <p><span> Toggle original/dithered image </span>
                    </p>
                  </figcaption>
                </div>
              </figure>
            </div>
            <p>
              Readability is nice, and I could add add a whole section complaining about the mess that’s Python’s
              ‘functional’ features.
            </p>
            <p>
              However, let’s take a step back and talk about ease of editing. Going back to the example above, imagine
              you’d like to add another <code>map</code> (or any other function call) in the middle there. How easy is
              this?
            </p>
            <div>
              <pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>get_ids</span>(data: <span>Vec</span><span>&lt;</span>Widget<span>&gt;</span>)<span> </span>-&gt; <span>Vec</span><span>&lt;</span>Id<span>&gt;</span><span> </span>{<span>
</span></span></span><span><span><span>    </span>collect(map(filter(map(iter(data),<span> </span><span>|</span>w<span>|</span><span> </span>w.toWingding()),<span> </span><span>|</span>w<span>|</span><span> </span>w.alive),<span> </span><span>|</span>w<span>|</span><span> </span>w.id))<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre>
            </div>
            <p>Consider:</p>
            <ol>
              <li>
                You’ll have to parse through the line, counting commas and parentheses to find the exact place to add
                the closing parenthesis.
              </li>
              <li>
                The <code>git diff</code> of this is going to be basically unreadable, everything is crammed onto one
                line.
              </li>
              <li>This line is getting long and unreadable, and at that point you’ll want to refactor it anyway!</li>
            </ol>
            <div>
              <pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>get_ids</span>(data: <span>Vec</span><span>&lt;</span>Widget<span>&gt;</span>)<span> </span>-&gt; <span>Vec</span><span>&lt;</span>Id<span>&gt;</span><span> </span>{<span>
</span></span></span><span><span><span>    </span>data.iter()<span>
</span></span></span><span><span><span>        </span>.map(<span>|</span>w<span>|</span><span> </span>w.toWingding())<span>
</span></span></span><span><span><span>        </span>.filter(<span>|</span>w<span>|</span><span> </span>w.alive)<span>
</span></span></span><span><span><span>        </span>.map(<span>|</span>w<span>|</span><span> </span>w.id)<span>
</span></span></span><span><span><span>        </span>.collect()<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre>
            </div>
            <p>
              This is adding a single line of code. No parentheses counting. It’s easy and obvious. It’s easy to write
              and easy to review. Perhaps most importantly, it shows up <em>incredibly nicely</em> in the
              <code>blame</code> layer of whatever editor or code exploration tool you’re using.
            </p>
            <p>
              You might think that this issue is <em>just</em> about trying to cram everything onto a single line, but
              frankly, trying to move away from that doesn’t help much. It will still mess up your git diffs and the
              blame layer.
            </p>
            <p>
              You can, of course, just assign the result of every <code>filter</code> and <code>map</code> call to a
              helper variable, and I will (begrudgingly) acknowledge that that works, and is
              <em>significantly</em> better than trying to do absurd levels of nesting.
            </p>
            <h2 id="code-discovery">Code Discovery</h2>
            <p>
              When you press <code>.</code> in your IDE, it will show a neat little pop-up that tells you which methods
              you can call or which fields you can access.
            </p>
            <p>
              This is probably the single IDE feature with the biggest value add, and if not that, then at least the
              single most frequently used one. Some people will tell you that static analysis for namespace or
              module-level code discovery is useless in the age of AI autocompletion and vibe coding, but I very much
              disagree.<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>
            </p>
            <p>A <a href="https://grugbrain.dev/" target="_blank">wise shaman once said</a>:</p>
            <blockquote>
              <p>
                “grug very like type systems make programming easier. for grug, type systems most value when grug hit
                dot on keyboard and list of things grug can do pop up magic. this 90% of value of type system or more to
                grug” — grug
              </p>
            </blockquote>
            <p>
              Words to live by. What he’s describing here is something that essentially <em>requires</em> pipelining to
              work at all. (And types or type annotation, but having those is the direction the industry is moving in
              anyway.)
            </p>
            <p>
              It doesn’t matter if it’s the trusty <code>.</code> operator, C++’s <code>-&gt;</code>, or if it’s
              something more bespoke such as Elm’s or Gleam’s <code>|&gt;</code> or Haskell’s <code>&amp;</code>. In the
              end, it’s a pipeline operator—the same principle applies. If your
              <a href="https://en.wikipedia.org/wiki/Language_Server_Protocol" target="_blank">LSP</a> knows the type of
              what’s on the left, it <em>should</em> in principle be able to offer suggestions for what to do next.
            </p>
            <p>
              If your favorite language’s LSP/IDE does a poor job at offering suggestions during pipelining, then it’s
              probably one of the following reasons:
            </p>
            <ol>
              <li>
                You don’t know which type you’re even holding. This happens most often when the language is dynamically
                typed, ’types’ are hard to deduce with static analysis, and you’re touching/writing code without type
                annotations. (e.g. Python)
              </li>
              <li>
                The ecosystem and LSP just didn’t have enough time put into them, or most active users don’t care
                enough. (e.g. any sufficiently obscure language)
              </li>
              <li>
                You are in a situation in which even looking up which methods are available is hard, often due to a
                bespoke build process that confuses the editor. (e.g. basically any build or runtime generation of code,
                or bespoke loading/selection of libraries).
              </li>
            </ol>
            <p>
              In either case, great editor/LSP support is more or less considered mandatory for modern programming
              languages. And of course, this is where pipelining shines.
            </p>
            <p>
              Ask any IDE, autocompleting <code>fizz.bu... -&gt; fizz.buzz()</code> is <em>much easier</em> than
              autocompleting <code>bu... -&gt; buzz(...)</code>, for the obvious reason that you
              <em>didn’t even write <code>fizz</code> in the second example yet</em>, so your editor has less
              information to work with.
            </p>
            <h2 id="sql">SQL</h2>
            <p>
              Pipelining is <em>amazing</em> at data processing, and allows you to transform code that’s commonly
              written with ‘inside-out’ control flow into ’line-by-line’ transformations.
            </p>
            <p>
              Where could this possibly be more clear than in SQL, the presumably single most significant language for
              querying and aggregating complex large-scale datasets?
            </p>
            <p>
              You’ll be pleased to hear that, yes, people are in fact working on bringing pipelining to SQL. (Whether
              it’s actually going to happen in this specific form
              <a href="https://sqlite.org/forum/forumpost/2d2720461b82f2fd" target="_blank">is a different question</a>,
              let’s not get too carried away here.)
            </p>
            <p>
              Unless you’re one of those people who spends so much time dealing with SQL that it’s become second nature,
              and the thought that the control flow of nested queries is hard to follow for the average non-database
              engineer is incomprehensible to you, I guess.
            </p>
            <p>Personally, I’m a fan.</p>
            <p>
              Anyway, if you’re interested, listen to this
              <a href="https://www.hytradboi.com/2025/f8582cd3-1e39-43a8-8749-46817b2910cf-pipe-syntax-in-sql-its-time" target="_blank">ten minute talk presented at HYTRADBOI 2025</a>.
            </p>
            <p>I’ll put their example of how a standard nested query can be simplified here, for convenience:</p>
            <div>
              <pre tabindex="0"><code data-lang="sql"><span><span><span>SELECT</span><span> </span>c_count,<span> </span><span>COUNT</span>(<span>*</span>)<span> </span><span>AS</span><span> </span>custdist<span>
</span></span></span><span><span><span>  </span><span>FROM</span><span>
</span></span></span><span><span><span>  </span>(<span>
</span></span></span><span><span><span>    </span><span>SELECT</span><span> </span>c_custkey,<span> </span><span>COUNT</span>(o_orderkey)<span> </span>c_count<span>
</span></span></span><span><span><span>    </span><span>FROM</span><span> </span>customer<span>
</span></span></span><span><span><span>    </span><span>LEFT</span><span> </span><span>OUTER</span><span> </span><span>JOIN</span><span> </span>orders<span>
</span></span></span><span><span><span>      </span><span>ON</span><span> </span>c_custkey<span> </span><span>=</span><span> </span>o_custkey<span>
</span></span></span><span><span><span>      </span><span>AND</span><span> </span>o_comment<span> </span><span>NOT</span><span> </span><span>LIKE</span><span> </span><span>&#39;%unusual%&#39;</span><span>
</span></span></span><span><span><span>    </span><span>GROUP</span><span> </span><span>BY</span><span> </span>c_custkey<span>
</span></span></span><span><span><span>  </span>)<span> </span><span>AS</span><span> </span>c_orders<span>
</span></span></span><span><span><span></span><span>GROUP</span><span> </span><span>BY</span><span> </span>c_count<span>
</span></span></span><span><span><span></span><span>ORDER</span><span> </span><span>BY</span><span> </span>custdist<span> </span><span>DESC</span>;<span>
</span></span></span></code></pre>
            </div>
            <p>Versus the SQL Syntax she told you not to worry about:</p>
            <div>
              <pre tabindex="0"><code data-lang="sql"><span><span><span>FROM</span><span> </span>customer<span>
</span></span></span><span><span><span></span><span>|&gt;</span><span> </span><span>LEFT</span><span> </span><span>OUTER</span><span> </span><span>JOIN</span><span> </span>orders<span>
</span></span></span><span><span><span>    </span><span>ON</span><span> </span>c_custkey<span> </span><span>=</span><span> </span>o_custkey<span>
</span></span></span><span><span><span>    </span><span>AND</span><span> </span>o_comment<span> </span><span>NOT</span><span> </span><span>LIKE</span><span> </span><span>&#39;%unusual%&#39;</span><span>
</span></span></span><span><span><span></span><span>|&gt;</span><span> </span><span>AGGREGATE</span><span> </span><span>COUNT</span>(o_orderkey)<span> </span><span>AS</span><span> </span>c_count<span>
</span></span></span><span><span><span>  </span><span>GROUP</span><span> </span><span>BY</span><span> </span>c_custkey<span>
</span></span></span><span><span><span></span><span>|&gt;</span><span> </span><span>AGGREGATE</span><span> </span><span>COUNT</span>(<span>*</span>)<span> </span><span>AS</span><span> </span>custdist<span>
</span></span></span><span><span><span>  </span><span>GROUP</span><span> </span><span>BY</span><span> </span>c_count<span>
</span></span></span><span><span><span></span><span>|&gt;</span><span> </span><span>ORDER</span><span> </span><span>BY</span><span> </span>custdist<span> </span><span>DESC</span>;<span>
</span></span></span></code></pre>
            </div>
            <p>
              Less nesting. More aligned with other languages and
              <a href="https://learn.microsoft.com/en-us/dotnet/csharp/linq/" target="_blank">LINQ</a>. Can easily be
              read line-by-line.
            </p>
            <p>
              Here’s a more
              <a href="https://www.linkedin.com/pulse/not-so-good-idea-pipe-syntax-sql-franck-pachot-dx6he" target="_blank">skeptical voice (warning, LinkedIn!)</a>. Franck Pachot raises the great point that the <code>SELECT</code> statement at the top of a query is
              (essentially) its function signature and specifies the return type. With pipe syntax, you lose some of
              this readability.
            </p>
            <p>I agree, but that seems like a solvable problem to me.</p>
            <h2 id="the-builder-pattern">The Builder pattern</h2>
            <div>
              <figure data-imgstate="dither">
                <img alt="A picture of some pipes half-way through to break up the text and make the article less monotonous." data-dither="/2025/04/pipelining/images/dithers/pipes_dithered.png" data-original="https://herecomesthemoon.net/2025/04/pipelining/images/pipes_hu12084032218752212129.webp" loading="lazy" src="https://herecomesthemoon.net/2025/04/pipelining/images/dithers/pipes_dithered.png"/>
                <div>
                  <figcaption>
                    <span>
                      A picture of some pipes half-way through to break up the text and make the article less
                      monotonous.
                    </span>
                    <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                      <rect height="24.28" width="24.28" x="13.51" y="13.58"></rect>
                      <rect height="24.28" width="24.28" x="37.93" y="37.86"></rect>
                      <rect height="24.28" width="24.28" x="62.21" y="13.58"></rect>
                      <rect height="24.28" width="24.28" x="13.51" y="62.14"></rect>
                      <rect height="24.28" width="24.28" x="62.21" y="62.14"></rect>
                    </svg>
                    <p><span> Toggle original/dithered image </span>
                    </p>
                  </figcaption>
                </div>
              </figure>
            </div>
            <p>
              Out of the Gang of Four
              <a href="https://en.wikipedia.org/wiki/Design_Patterns" target="_blank">Design Patterns</a>, the
              <a href="https://en.wikipedia.org/wiki/Builder_pattern" target="_blank">builder pattern</a> is one that
              isn’t completely irredeemable.
            </p>
            <p>
              And—surprise, surprise—it fits pretty well into pipelining. Any situation where you need to construct a
              complex, stateful object (e.g. a client or runtime), it’s a great way to feed complex, optional arguments
              into an object.
            </p>
            <p>
              Some people say they prefer optional/named arguments, but honestly, I don’t understand why: An optional
              named <code>foo</code> parameter is harder to track down in code (and harder to mark as deprecated!) than
              all instances of a <code>.setFoo()</code> builder function.
            </p>
            <p>
              If you have no clue what I’m talking about, this here is the type of pattern I’m talking about. You have a
              ‘builder’ object, call some methods on it to configure it, and finally <code>build()</code> the object
              you’re actually interested in.
            </p>
            <div>
              <pre tabindex="0"><code data-lang="rs"><span><span><span>use</span><span> </span>tokio::runtime::Builder;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>main</span>()<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>// build runtime
</span></span></span><span><span><span></span><span>    </span><span>let</span><span> </span>runtime<span> </span><span>=</span><span> </span>Builder::new_multi_thread()<span>
</span></span></span><span><span><span>        </span>.worker_threads(<span>4</span>)<span>
</span></span></span><span><span><span>        </span>.thread_name(<span>&#34;my-custom-name&#34;</span>)<span>
</span></span></span><span><span><span>        </span>.thread_stack_size(<span>3</span><span> </span><span>*</span><span> </span><span>1024</span><span> </span><span>*</span><span> </span><span>1024</span>)<span>
</span></span></span><span><span><span>        </span>.build()<span>
</span></span></span><span><span><span>        </span>.unwrap();<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// use runtime ...
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre>
            </div>
            <p>This too, is pipelining.</p>
            <h2 id="making-haskell-slightly-more-readable">Making Haskell (slightly more) readable</h2>
            <p>Haskell is hard to read.</p>
            <p>
              It has these weird operators like <code>&lt;$&gt;</code>, <code>&lt;*&gt;</code>, <code>$</code>, or
              <code>&gt;&gt;=</code> and when you ask Haskell programmers about what they mean, they say something like
              “Oh, this is just a special case of the generalized
              <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#v:-62--61--62-" target="_blank">Kleisli Monad Operator</a>
              <code>&gt;=&gt;</code> in the category of endo-pro-applicatives over a locally small poset.” and your eyes
              have glazed over before they’ve even finished the sentence.
            </p>
            <p>(It also doesn’t help that Haskell allows you to define custom operators however you please, yes.)</p>
            <p>
              If you’re wondering “How could a language have so many bespoke operators?”, my understanding is that most
              of them are just fancy ways of telling Haskell to compose some functions in a highly advanced way. Here’s
              the second-most basic<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>
              example, the <code>$</code> operator.
            </p>
            <p>
              Imagine you have functions <code>foo</code>, <code>bar</code>, and some value <code>data</code>. In a
              “““normal””” language you might write <code>foo(data)</code>. In Haskell, this is written as
              <code>foo data</code>. This is since <code>foo</code> will automatically ‘grab’ values to the right as its
              arguments, so you don’t need the parentheses.
            </p>
            <p>
              A consequence of this is that <code>bar(foo(data))</code> is written as <code>bar (foo data)</code> in
              Haskell. If you wrote <code>bar foo data</code>, the compiler will interpret it as
              <code>bar(foo)(data)</code>, which would be wrong. This is what people mean when they say that Haskell’s
              function call syntax is
              <a href="https://en.wikipedia.org/wiki/Associative_property" target="_blank">left-associative</a>.
            </p>
            <p>
              The <code>$</code> operator is <em>nothing but syntactic sugar</em> that allows you to write
              <code>bar $ foo data</code> instead of having to write <code>bar (foo data)</code>. That’s it. People were
              fed-up with having to put parens everywhere, I guess.
            </p>
            <p>If your eyes glazed over at this point, I can’t blame you.</p>
            <p>Let’s get back on track.</p>
            <p>
              Talking about any of the fancier operators would be punching well above my weight-class, so I’ll just
              stick to what I’ve been saying throughout this entire post already. Here’s a stilted Haskell toy example,
              intentionally not written in
              <a href="https://wiki.haskell.org/Pointfree" target="_blank">pointfree</a> style.
            </p>
            <div>
              <pre tabindex="0"><code data-lang="haskell"><span><span><span>-- Take an input string `content`</span>
</span></span><span><span><span>-- Split into lines, check whether each line is a palindrome and stringify</span>
</span></span><span><span><span>-- Ex. &#34;foo\nradar&#34; -&gt; &#34;False\nTrue&#34;</span>
</span></span><span><span><span>checkPalindromes</span> <span>::</span> <span>String</span> <span>-&gt;</span> <span>String</span>
</span></span><span><span><span>checkPalindromes</span> content <span>=</span> unlines <span>$</span> map (show <span>.</span> isPalindrome) <span>$</span> lines <span>$</span> map toLower content
</span></span><span><span>  <span>where</span>
</span></span><span><span>    isPalindrome xs <span>=</span> xs <span>==</span> reverse xs
</span></span></code></pre>
            </div>
            <p>
              If you want to figure out the flow of data, this whole function body has to be read
              <em>right-to-left</em>.
            </p>
            <p>
              To make things even funnier, you need to start with the <code>where</code> clause to figure out which
              local “variables” are being defined. This happens (for whatever reason) at the end of the function instead
              of at the start. (Calling <code>isPalindrome</code> a variable is misleading, but that’s besides the
              point.)
            </p>
            <p>
              At this point you might wonder if Haskell has some sort of pipelining operator, and yes, it turns out that
              one was
              <a href="https://github.com/haskell/core-libraries-committee/issues/78#issuecomment-1183568372" target="_blank">added in 2014</a>! That’s pretty late considering that Haskell exists since 1990. This allows us to refactor the above
              code as follows:
            </p>
            <div>
              <pre tabindex="0"><code data-lang="haskell"><span><span><span>checkPalindromes</span> <span>::</span> <span>String</span> <span>-&gt;</span> <span>String</span>
</span></span><span><span><span>checkPalindromes</span> content <span>=</span>
</span></span><span><span>  content
</span></span><span><span>    <span>&amp;</span> map toLower
</span></span><span><span>    <span>&amp;</span> lines
</span></span><span><span>    <span>&amp;</span> map (show <span>.</span> isPalindrome)
</span></span><span><span>    <span>&amp;</span> unlines
</span></span><span><span>  <span>where</span>
</span></span><span><span>    isPalindrome xs <span>=</span> xs <span>==</span> reverse xs
</span></span></code></pre>
            </div>
            <p>Isn’t that way easier to read?</p>
            <p>
              <em>This</em> is code which you can show to an enterprise Java programmer, tell them that they’re looking
              at
              <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" target="_blank">Java Streams</a>
              with slightly weird syntax, and they’ll get the idea.
            </p>
            <p>
              Of course, in reality nothing is as simple. The Haskell ecosystem seems to be split between users of
              <code>$</code>, users of <code>&amp;</code>, and users of the
              <a href="https://hackage.haskell.org/package/flow-2.0.0.0/docs/Flow.html#g:1" target="_blank">Flow</a>-provided operators, which allow the same functionality, but allow you to write
              <code>|&gt;</code> instead of <code>&amp;</code>.<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>
            </p>
            <p>
              I don’t know what to say about that, other than that—not entirely unlike C++—Haskell has its own share of
              operator-related and cultural historical baggage, and a split ecosystem, and this makes the language
              significantly less approachable than it has to be.
            </p>
            <h2 id="rusts-pipelining-is-pretty-neat">Rust’s pipelining is pretty neat</h2>
            <div>
              <figure data-imgstate="dither">
                <img alt="Pop(?) culture reference." data-dither="/2025/04/pipelining/images/dithers/magrittepipe_dithered.png" data-original="https://herecomesthemoon.net/2025/04/pipelining/images/magrittepipe_hu2509665480992580595.webp" loading="lazy" src="https://herecomesthemoon.net/2025/04/pipelining/images/dithers/magrittepipe_dithered.png"/>
                <div>
                  <figcaption>
                    <span> Pop(?) culture reference. </span>
                    <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                      <rect height="24.28" width="24.28" x="13.51" y="13.58"></rect>
                      <rect height="24.28" width="24.28" x="37.93" y="37.86"></rect>
                      <rect height="24.28" width="24.28" x="62.21" y="13.58"></rect>
                      <rect height="24.28" width="24.28" x="13.51" y="62.14"></rect>
                      <rect height="24.28" width="24.28" x="62.21" y="62.14"></rect>
                    </svg>
                    <p><span> Toggle original/dithered image </span>
                    </p>
                  </figcaption>
                </div>
              </figure>
            </div>
            <p>
              In the beginning I said that ‘Pipelining is the feature that allows you to omit a single argument from
              your parameter list, by instead passing the previous value.’
            </p>
            <p>
              I still think that this is true, but it doesn’t get across the whole picture. If you’ve paid attention in
              the previous sections, you’ll have noticed that <code>object.member</code> and
              <code>iterator &amp; map</code> share basically <em>nothing</em> in common outside of the order of
              operations.
            </p>
            <p>
              In the first case, we’re accessing a value that’s <em>scoped</em> to the object. In the second, we’re
              ‘just’ passing an expression to a free-standing function.
            </p>
            <p>
              Or in other words, pipelining is not the same as pipelining. Even from an IDE-perspective, they’re
              different. In Java, your editor will look for methods associated with an object and walk up the
              inheritance chain. In Haskell, your editor will put a so-called
              <a href="https://downloads.haskell.org/~ghc/7.10.3-rc1/users_guide/typed-holes.html" target="_blank">’typed hole’</a>, and try to deduce which functions have a type that ‘fits’ into the hole using
              <a href="https://herecomesthemoon.net/2025/01/type-inference-in-rust-and-cpp/" target="_blank">Hindley-Milner Type Inference</a>.
            </p>
            <p>
              Personally, I like type inference (and
              <a href="https://en.wikipedia.org/wiki/Type_class" target="_blank">type classes</a>), but I also like if
              types have a namespace attached to them, with methods and associated functions. I am pragmatic like that.
            </p>
            <p>
              What I like about Rust is that it gives me the best out of both worlds here: You get traits and type
              inference without needing to wrap your head around a fully functional, immutable, lazy, monad-driven
              programming paradigm, and you get methods and associated values without the absolute dumpster fire of
              complex inheritance chains or AbstractBeanFactoryConstructors.
            </p>
            <p>
              I’ve not seen any other language that even comes close to the convenience of Rust’s pipelines, and its
              lack of higher-kinded types or inheritance did not stop it. Quite the opposite, if anything.
            </p>
            <h2 id="conclusion">Conclusion</h2>
            <p>
              I like pipelining. That’s the one thing that definitely should be obvious if you’ve read all the way
              through this article.
            </p>
            <p>I just think they’re neat, y’know?</p>
            <p>I like reading my code top-to-bottom, left-to-right instead of from-the-inside-to-the-outside.</p>
            <p>
              I like when I don’t need to count arguments and parentheses to figure out which value is the first
              argument of the second function, and which is the second argument of the first function.
            </p>
            <p>
              I like when my editor can show me all fields of a struct, and all methods or functions associated with a
              value, just when I press <code>.</code> on my keyboard. It’s great.
            </p>
            <p>
              I like when <code>git diff</code> and the <code>blame</code> layer of the code repository don’t look like
              complete ass.
            </p>
            <p>
              I like when adding a function call in the middle of a process doesn’t require me to parse the whole line
              to add the closing parenthesis, and doesn’t require me to adjust the nesting of the whole block.
            </p>
            <p>
              I like when my functions distinguish between ‘a main value which we are acting upon’ and ‘secondary
              arguments’, as opposed to treating them all as the same.
            </p>
            <p>
              I like when I don’t have to pollute my namespaces with a ton of helper variables or free-standing
              functions that I had to pull in from somewhere.
            </p>
            <p>
              If you’re writing pipelined code—and not trying overly hard to fit everything into a single, convoluted,
              nested pipeline—then your functions will naturally split up into a few pipeline chunks.
            </p>
            <p>
              Each chunk starts with a piece of ‘main data’ that travels on a conveyer belt, where every line performs
              exactly one action to transform it. Finally, a single value comes out at the end and gets its own name, so
              that it may be used later.
            </p>
            <p>
              And that is—in my humble opinion—exactly how it should be. Neat, convenient, separated ‘chunks’, each of
              which can easily be understood in its own right.
            </p>
            <p>
              Idk, subscribe to my <a href="https://buttondown.com/mond" target="_blank">newsletter</a> or something.
            </p>
            <p><em>Thanks to kreest for proofreading this article.</em></p>
          </div>
        </section>
        <section id="reference">
          
        </section>
      </article>
    </div></div>
  </body>
</html>
