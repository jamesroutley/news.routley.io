<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.claudiu-ivan.com/writing/search-dsl">Original</a>
    <h1>A Principled Approach to Querying Data – A Type-Safe Search DSL</h1>
    
    <div id="readability-page-1" class="page"><article> <p>The rise of local-first web applications demands a rethinking of traditional client-server architectures. Users expect near-native responsiveness, even when offline. This necessitates efficient, client-side data processing, including search. The techniques presented in this article, while discussed in a local-first context, are equally applicable to server-side systems.  We’ll explore a type-driven approach, leveraging a Domain-Specific Language (DSL), to create a powerful and maintainable search system.</p>
<p>The complete, dependency-free code for this article is available on <a href="https://gist.github.com/kioku/3350e4c4f1aac5d3f5f53e68923cb35a">GitHub</a>.</p>
<h2 id="domain-specific-languages-dsls">Domain-Specific Languages (DSLs)</h2>
<p>Our approach centers around a DSL tailored to the specifics of searching “issues” – a common concept in project management and bug tracking. A DSL provides a specialized language for expressing search intent, offering several key advantages. Consider these example queries:</p>
<ul>
<li><code>is:open label:bug</code></li>
<li><code>author:alice (type:feature type:enhancement)</code></li>
<li><code>is:closed milestone:v1.0 assignee:bob</code></li>
</ul>
<p>The expressiveness and clarity of a well-designed Domain-Specific Language (DSL) are evident across many successful systems. Examples include Lucene/Elasticsearch, which utilizes a query string DSL for full-text search. SQL employs its <code>WHERE</code> clause as a DSL for filtering data, and GraphQL defines a query language for fetching data from APIs. The reader might observe the similarity of the proposed DSL to the one used by GitHub in their issue search functionality.</p>
<p>The benefits of using a DSL are multifaceted. It provides controlled complexity by limiting the scope of possible queries and ensures domain alignment by mirroring the domain’s concepts in its vocabulary. This, in turn, enhances usability, allowing users to query using familiar terms. Furthermore, a formal grammar simplifies maintainability and extensibility, making modification and expansion more manageable.</p>
<h2 id="defining-the-domain">Defining the domain</h2>
<p>The structure of the dataset is usually inferred from the constraints of the business domain being modeled. In this case, we have chosen an issue tracking system, so the basic value we’ll be working with is represented by the <code>Issue</code> interface.</p>
<pre tabindex="0" data-language="typescript"><code><span><span>type</span><span> IssueStatus</span><span> =</span><span> &#34;open&#34;</span><span> |</span><span> &#34;closed&#34;</span><span>;</span></span>
<span><span>type</span><span> IssueType</span><span> =</span><span> &#34;bug&#34;</span><span> |</span><span> &#34;feature&#34;</span><span> |</span><span> &#34;docs&#34;</span><span> |</span><span> &#34;enhancement&#34;</span><span>;</span></span>
<span></span>
<span><span>interface</span><span> Issue</span><span> {</span></span>
<span><span>  id</span><span>:</span><span> string</span><span>;</span></span>
<span><span>  title</span><span>:</span><span> string</span><span>;</span></span>
<span><span>  status</span><span>:</span><span> IssueStatus</span><span>;</span></span>
<span><span>  author</span><span>:</span><span> string</span><span>;</span></span>
<span><span>  labels</span><span>:</span><span> string</span><span>[];</span></span>
<span><span>  milestone</span><span>:</span><span> string</span><span> |</span><span> null</span><span>;</span></span>
<span><span>  assignee</span><span>:</span><span> string</span><span> |</span><span> null</span><span>;</span></span>
<span><span>  type</span><span>:</span><span> IssueType</span><span>;</span></span>
<span><span>  updatedAt</span><span>:</span><span> number</span><span>;</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>This is just <em>one example</em>. The same principles can be applied to many other domains: document management, customer relationship management, product lists, application logs, etc.</p>
<h2 id="error-handling">Error Handling</h2>
<p>Before we dive into parsing, we need a robust way to handle potential errors. The <code>Either</code> type, a cornerstone of functional programming, provides this mechanism. It is used to represent a value that can be the “success” (<code>Right</code> case) or the “failure” (<code>Left</code> case) of applying an operation.</p>
<pre tabindex="0" data-language="typescript"><code><span><span>type</span><span> Either</span><span>&lt;</span><span>L</span><span>, </span><span>R</span><span>&gt; </span><span>=</span><span> Left</span><span>&lt;</span><span>L</span><span>&gt; </span><span>|</span><span> Right</span><span>&lt;</span><span>R</span><span>&gt;;</span></span>
<span></span>
<span><span>class</span><span> Left</span><span>&lt;</span><span>L</span><span>&gt; {</span></span>
<span><span>  constructor</span><span>(</span><span>readonly</span><span> value</span><span>:</span><span> L</span><span>) {}</span></span>
<span><span>  isLeft</span><span>()</span><span>:</span><span> this</span><span> is</span><span> Left</span><span>&lt;</span><span>L</span><span>&gt; {</span></span>
<span><span>    return</span><span> true</span><span>;</span></span>
<span><span>  }</span></span>
<span><span>  isRight</span><span>()</span><span>:</span><span> this</span><span> is</span><span> Right</span><span>&lt;</span><span>never</span><span>&gt; {</span></span>
<span><span>    return</span><span> false</span><span>;</span></span>
<span><span>  }</span></span>
<span><span>}</span></span>
<span></span>
<span><span>class</span><span> Right</span><span>&lt;</span><span>R</span><span>&gt; {</span></span>
<span><span>  constructor</span><span>(</span><span>readonly</span><span> value</span><span>:</span><span> R</span><span>) {}</span></span>
<span><span>  isLeft</span><span>()</span><span>:</span><span> this</span><span> is</span><span> Left</span><span>&lt;</span><span>never</span><span>&gt; {</span></span>
<span><span>    return</span><span> false</span><span>;</span></span>
<span><span>  }</span></span>
<span><span>  isRight</span><span>()</span><span>:</span><span> this</span><span> is</span><span> Right</span><span>&lt;</span><span>R</span><span>&gt; {</span></span>
<span><span>    return</span><span> true</span><span>;</span></span>
<span><span>  }</span></span>
<span><span>}</span></span>
<span></span>
<span><span>const</span><span> success</span><span> =</span><span> &lt;</span><span>T</span><span>&gt;(</span><span>value</span><span>:</span><span> T</span><span>) </span><span>=&gt;</span><span> new</span><span> Right</span><span>(value);</span></span>
<span><span>const</span><span> failure</span><span> =</span><span> &lt;</span><span>E</span><span>&gt;(</span><span>error</span><span>:</span><span> E</span><span>) </span><span>=&gt;</span><span> new</span><span> Left</span><span>(error);</span></span>
<span></span></code></pre>
<p>Throughout the program, we’ll use <code>Either</code> to propagate results. If a parsing step succeeds, it returns a <code>Right</code> containing the parsed value and the remaining input. If it fails, it returns a <code>Left</code> containing an error object. This explicit error handling is crucial for building a reliable system.</p>
<h2 id="parsing-with-precision">Parsing with precision</h2>
<p>To process queries, we employ parser combinators. They are a powerful technique from functional programming, often used in compiler design, for building parsers in a modular, composable, and declarative way.</p>
<p>In essence, a parser combinator is a higher-order function: it takes one or more parsers as input and returns a <em>new</em> parser. Each parser attempts to match a portion of the input string. If successful, it returns a <code>Right</code> containing the parsed value and the remaining input string. If it fails, it returns a <code>Left</code> with an error.</p>
<pre tabindex="0" data-language="typescript"><code><span><span>type</span><span> ParserError</span><span> =</span><span> {</span></span>
<span><span>  code</span><span>:</span></span>
<span><span>    |</span><span> &#34;INVALID_TOKEN&#34;</span></span>
<span><span>    |</span><span> &#34;MISSING_VALUE&#34;</span></span>
<span><span>    |</span><span> &#34;INVALID_STATUS&#34;</span></span>
<span><span>    |</span><span> &#34;INVALID_TYPE&#34;</span></span>
<span><span>    |</span><span> &#34;INVALID_TIME_FILTER&#34;</span><span>;</span></span>
<span><span>  message</span><span>:</span><span> string</span><span>;</span></span>
<span><span>  position</span><span>:</span><span> number</span><span>;</span></span>
<span><span>  input</span><span>:</span><span> string</span><span>;</span></span>
<span><span>};</span></span>
<span></span>
<span><span>type</span><span> ParserResult</span><span>&lt;</span><span>T</span><span>&gt; </span><span>=</span><span> Either</span><span>&lt;</span><span>ParserError</span><span>, [</span><span>T</span><span>, </span><span>string</span><span>]&gt;;</span></span>
<span><span>type</span><span> Parser</span><span>&lt;</span><span>T</span><span>&gt; </span><span>=</span><span> (</span><span>input</span><span>:</span><span> string</span><span>) </span><span>=&gt;</span><span> ParserResult</span><span>&lt;</span><span>T</span><span>&gt;;</span></span>
<span></span></code></pre>
<p>This implementation uses several fundamental combinators.</p>
<pre tabindex="0" data-language="typescript"><code><span><span>/** Matches a literal string. */</span></span>
<span><span>const</span><span> lit</span><span> =</span><span> (</span><span>match</span><span>:</span><span> string</span><span>)</span><span>:</span><span> Parser</span><span>&lt;</span><span>string</span><span>&gt; </span><span>=&gt;</span><span> (</span><span>input</span><span>) </span><span>=&gt;</span><span> { </span><span>...</span><span> };</span></span>
<span></span>
<span><span>/** Parses a sequence of alphanumeric characters. */</span></span>
<span><span>const</span><span> word</span><span> =</span><span> ()</span><span>:</span><span> Parser</span><span>&lt;</span><span>string</span><span>&gt; </span><span>=&gt;</span><span> (</span><span>input</span><span>:</span><span> string</span><span>) </span><span>=&gt;</span><span> { </span><span>...</span><span> };</span></span>
<span></span>
<span><span>/**</span></span>
<span><span> * Tries multiple parsers in sequence, returning the result of the first one that succeeds.</span></span>
<span><span> * This allows for choices in the grammar (e.g., `is:open` OR `is:closed`).</span></span>
<span><span> */</span></span>
<span><span>const</span><span> alt</span><span> =</span><span> &lt;</span><span>T</span><span>&gt;(</span><span>...</span><span>parsers</span><span>:</span><span> Parser</span><span>&lt;</span><span>T</span><span>&gt;[])</span><span>:</span><span> Parser</span><span>&lt;</span><span>T</span><span>&gt; </span><span>=&gt;</span><span> (</span><span>input</span><span>) </span><span>=&gt;</span><span> { </span><span>...</span><span> };</span></span>
<span></span>
<span><span>/**</span></span>
<span><span> * Applies multiple parsers sequentially, succeeding only if *all* of them succeed.</span></span>
<span><span> * This is used to build up complex structures from simpler parts (e.g., `is:` followed by `open`).</span></span>
<span><span> */</span></span>
<span><span>const</span><span> seq</span><span> =</span><span> &lt;</span><span>T</span><span> extends</span><span> unknown</span><span>[]&gt;(</span><span>...</span><span>parsers</span><span>:</span><span> { [</span><span>K</span><span> in</span><span> keyof</span><span> T</span><span>]</span><span>:</span><span> Parser</span><span>&lt;</span><span>T</span><span>[</span><span>K</span><span>]&gt; })</span><span>:</span><span> Parser</span><span>&lt;</span><span>T</span><span>&gt; </span><span>=&gt;</span><span> (</span><span>input</span><span>) </span><span>=&gt;</span><span> { </span><span>...</span><span> };</span></span>
<span></span>
<span><span>/** Applies a parser zero or more times, collecting the results into an array. */</span></span>
<span><span>const</span><span> many</span><span> =</span><span> &lt;</span><span>T</span><span>&gt;(</span><span>parser</span><span>:</span><span> Parser</span><span>&lt;</span><span>T</span><span>&gt;)</span><span>:</span><span> Parser</span><span>&lt;</span><span>T</span><span>[]&gt; </span><span>=&gt;</span><span> (</span><span>input</span><span>:</span><span> string</span><span>) </span><span>=&gt;</span><span> { </span><span>...</span><span> };</span></span>
<span></span>
<span><span>/** Transforms the result of a successful parse using a provided function. Required to build the AST. */</span></span>
<span><span>const</span><span> map</span><span> =</span><span> &lt;</span><span>T</span><span>, </span><span>U</span><span>&gt;(</span><span>parser</span><span>:</span><span> Parser</span><span>&lt;</span><span>T</span><span>&gt;, </span><span>fn</span><span>:</span><span> (</span><span>value</span><span>:</span><span> T</span><span>) </span><span>=&gt;</span><span> U</span><span>)</span><span>:</span><span> Parser</span><span>&lt;</span><span>U</span><span>&gt; </span><span>=&gt;</span><span> (</span><span>input</span><span>) </span><span>=&gt;</span><span> { </span><span>...</span><span> };</span></span>
<span></span></code></pre>
<p>We start with simple parsers (like <code>lit</code> and <code>word</code>) and combine them using combinators like <code>seq</code>, <code>alt</code>, and <code>many</code> to build increasingly complex parsers. The <code>map</code> combinator is important for transforming the raw parsed strings into a more structured representation – our Abstract Syntax Tree. This recursive nature of building complex structures from simpler ones is a hallmark of functional programming.</p>
<p>Composition is amazing. It’s remarkable what unexpected elegance emerges from combining simple elements. In this simplicity lies the beauty of parser combinators.</p>
<h2 id="structuring-the-query">Structuring the query</h2>
<p>The responsibility of the parser, is not to directly execute the query, it is to transform the input string into an Abstract Syntax Tree (AST). The AST is a structured, hierarchical representation of the query, independent of its specific syntax. This decoupling is essential for several reasons:</p>
<ol>
<li><strong>Separation of Concerns:</strong> Parsing (syntax) is separated from evaluation (semantics).</li>
<li><strong>Optimization:</strong> The AST can be analyzed and optimized before execution.</li>
<li><strong>Flexibility:</strong> The AST can be used for multiple purposes (e.g., generating queries for different backends).</li>
</ol>
<pre tabindex="0" data-language="typescript"><code><span><span>type</span><span> FilterNodeType</span><span> =</span></span>
<span><span>  |</span><span> &#34;status&#34;</span></span>
<span><span>  |</span><span> &#34;author&#34;</span></span>
<span><span>  |</span><span> &#34;label&#34;</span></span>
<span><span>  |</span><span> &#34;type&#34;</span></span>
<span><span>  |</span><span> &#34;updated&#34;</span></span>
<span><span>  |</span><span> &#34;and&#34;</span></span>
<span><span>  |</span><span> &#34;or&#34;</span><span>;</span></span>
<span></span>
<span><span>type</span><span> LeafFilterNode</span><span> =</span><span> {</span></span>
<span><span>  readonly</span><span> type</span><span>:</span><span> FilterNodeType</span><span>;</span></span>
<span><span>  readonly</span><span> value</span><span>:</span><span> string</span><span>;</span></span>
<span><span>};</span></span>
<span></span>
<span><span>type</span><span> FilterNode</span><span> =</span></span>
<span><span>  |</span><span> LeafFilterNode</span></span>
<span><span>  |</span><span> {</span></span>
<span><span>      type</span><span>:</span><span> &#34;and&#34;</span><span> |</span><span> &#34;or&#34;</span><span>;</span></span>
<span><span>      value</span><span>:</span><span> FilterNode</span><span>[];</span></span>
<span><span>    };</span></span>
<span></span></code></pre>
<p>The AST consists of <code>FilterNode</code> objects. Leaf nodes (<code>LeafFilterNode</code>) represent individual filters (e.g., <code>status:open</code>), while <code>and</code> / <code>or</code> nodes represent boolean combinations.</p>
<p>The final <code>searchQueryParser</code> is obtained by composing the combinators.</p>
<pre tabindex="0" data-language="typescript"><code><span><span>const</span><span> searchQueryParser</span><span>:</span><span> Parser</span><span>&lt;</span><span>FilterNode</span><span>&gt; </span><span>=</span><span> map</span><span>(</span></span>
<span><span>  many</span><span>(</span><span>alt</span><span>(statusParser, authorParser, labelParser, typeParser, timeFilterParser, orParser)),</span></span>
<span><span>  (</span><span>filters</span><span>) </span><span>=&gt;</span><span> { </span><span>...</span><span> }</span></span>
<span><span>);</span></span>
<span></span></code></pre>
<p>While the individual filter parsers like <code>statusParser</code> are defined as follows.</p>
<pre tabindex="0" data-language="typescript"><code><span><span>const</span><span> statusParser</span><span> =</span><span> map</span><span>(</span></span>
<span><span>  seq</span><span>(</span><span>lit</span><span>(</span><span>&#34;is:&#34;</span><span>), </span><span>alt</span><span>(</span><span>lit</span><span>(</span><span>&#34;open&#34;</span><span>), </span><span>lit</span><span>(</span><span>&#34;closed&#34;</span><span>))),</span></span>
<span><span>  ([</span><span>_</span><span>, </span><span>status</span><span>]) </span><span>=&gt;</span><span> ({ type: </span><span>&#34;status&#34;</span><span>, value: status } </span><span>as</span><span> const</span><span>)</span></span>
<span><span>);</span></span>
<span></span></code></pre>
<h2 id="evaluating-the-query">Evaluating the query</h2>
<p>With the AST in hand, we can transform it into a <em>predicate function</em>.</p>
<pre tabindex="0" data-language="typescript"><code><span><span>type</span><span> IssuePredicate</span><span> =</span><span> (</span><span>issue</span><span>:</span><span> Issue</span><span>) </span><span>=&gt;</span><span> boolean</span><span>;</span></span>
<span></span></code></pre>
<p>We define predicate-building functions for each filter type, including input validation.</p>
<pre tabindex="0" data-language="typescript"><code><span><span>const</span><span> isValidIssueStatus</span><span> =</span><span> (</span><span>value</span><span>:</span><span> string</span><span>)</span><span>:</span><span> value</span><span> is</span><span> IssueStatus</span><span> =&gt;</span><span> {</span></span>
<span><span>  return</span><span> [</span><span>&#34;open&#34;</span><span>, </span><span>&#34;closed&#34;</span><span>].</span><span>includes</span><span>(value);</span></span>
<span><span>};</span></span>
<span><span>const</span><span> matchStatus</span><span> =</span><span> (</span><span>status</span><span>:</span><span> string</span><span>)</span><span>:</span><span> IssuePredicate</span><span> =&gt;</span><span> {</span></span>
<span><span>  if</span><span> (</span><span>isValidIssueStatus</span><span>(status)) {</span></span>
<span><span>    return</span><span> (</span><span>issue</span><span>) </span><span>=&gt;</span><span> issue.status </span><span>===</span><span> status;</span></span>
<span><span>  }</span></span>
<span><span>  console.</span><span>error</span><span>(</span><span>`Invalid status: ${</span><span>status</span><span>}`</span><span>);</span></span>
<span><span>  return</span><span> matchNone</span><span>();</span></span>
<span><span>};</span></span>
<span></span>
<span><span>// ... similar functions each filter type</span></span>
<span></span></code></pre>
<p>The <code>createPredicate</code> function recursively traverses the AST, creating and combining predicates.</p>
<pre tabindex="0" data-language="typescript"><code><span><span>const</span><span> createPredicate</span><span> =</span><span> (</span><span>node</span><span>:</span><span> FilterNode</span><span>)</span><span>:</span><span> IssuePredicate</span><span> =&gt;</span><span> {</span></span>
<span><span>  switch</span><span> (node.type) {</span></span>
<span><span>    case</span><span> &#34;status&#34;</span><span>:</span></span>
<span><span>      return</span><span> isValidIssueStatus</span><span>(node.value)</span></span>
<span><span>        ?</span><span> matchStatus</span><span>(node.value)</span></span>
<span><span>        :</span><span> matchNone</span><span>();</span></span>
<span><span>    // ... other cases</span></span>
<span><span>    case</span><span> &#34;and&#34;</span><span>:</span></span>
<span><span>      return</span><span> and</span><span>(</span><span>...</span><span>(node.value </span><span>as</span><span> FilterNode</span><span>[]).</span><span>map</span><span>(createPredicate));</span></span>
<span><span>    // ...</span></span>
<span><span>  }</span></span>
<span><span>};</span></span>
<span></span>
<span><span>const</span><span> and</span><span> =</span></span>
<span><span>  (</span><span>...</span><span>preds</span><span>:</span><span> IssuePredicate</span><span>[])</span><span>:</span><span> IssuePredicate</span><span> =&gt;</span></span>
<span><span>  (</span><span>issue</span><span>) </span><span>=&gt;</span></span>
<span><span>    preds.</span><span>every</span><span>((</span><span>p</span><span>) </span><span>=&gt;</span><span> p</span><span>(issue));</span></span>
<span></span></code></pre>
<p>This recursive structure elegantly handles complex boolean logic that will be applied to the dataset.</p>
<h2 id="query-execution">Query execution</h2>
<p>We define an <code>executeQuery</code> function to orchestrate the entire process.</p>
<pre tabindex="0" data-language="typescript"><code><span><span>const</span><span> executeQuery</span><span> =</span><span> (</span><span>query</span><span>:</span><span> string</span><span>, </span><span>issues</span><span>:</span><span> Issue</span><span>[])</span><span>:</span><span> Issue</span><span>[] </span><span>=&gt;</span><span> {</span></span>
<span><span>  const</span><span> parsedQuery</span><span> =</span><span> searchQueryParser</span><span>(query);</span></span>
<span></span>
<span><span>  if</span><span> (parsedQuery.</span><span>isLeft</span><span>()) {</span></span>
<span><span>    console.</span><span>error</span><span>(</span><span>`Parse Error: ${</span><span>parsedQuery</span><span>.</span><span>value</span><span>.</span><span>message</span><span>}`</span><span>);</span></span>
<span><span>    return</span><span> []; </span><span>// Return empty array on parse failure</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  const</span><span> ast</span><span> =</span><span> parsedQuery.value[</span><span>0</span><span>];</span></span>
<span><span>  const</span><span> predicate</span><span> =</span><span> createPredicate</span><span>(ast);</span></span>
<span><span>  return</span><span> issues.</span><span>filter</span><span>(predicate);</span></span>
<span><span>};</span></span>
<span></span></code></pre>
<p>The body of the function gracefully handles parsing errors, returning an empty result set and logging the error. In a production system, this error could be logged and surfaced through a variety of mechanisms, depending on the context.</p>
<h2 id="the-path-forward">The path forward</h2>
<p>It could be argued that other solutions might be more adequate for large datasets. For example, IndexedDB or SQLite could be used for data storage and querying. However, this does not negate the value of the techniques presented here. A database solution can be used as the storage layer, while the methods described in this article can be used to construct queries from the input of the system.</p>
<p>With that in mind, we should examine the performance of this system and explore potential improvements. Using the provided helper utilities within the linked code, a superficial performance evaluation was conducted. The following results were obtained on a test machine using a simulated dataset of 1 million issues.</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>Search Results for: &#34;is:open&#34;</span></span>
<span><span>----------------------------------------</span></span>
<span><span>Matching issues: 499344</span></span>
<span><span>Search time: 20.77ms</span></span>
<span><span></span></span>
<span><span>Search Results for: &#34;is:closed&#34;</span></span>
<span><span>----------------------------------------</span></span>
<span><span>Matching issues: 500656</span></span>
<span><span>Search time: 20.06ms</span></span>
<span><span></span></span>
<span><span>Search Results for: &#34;is:open label:bug&#34;</span></span>
<span><span>----------------------------------------</span></span>
<span><span>Matching issues: 210988</span></span>
<span><span>Search time: 76.44ms</span></span>
<span><span></span></span>
<span><span>Search Results for: &#34;author:alice type:feature&#34;</span></span>
<span><span>----------------------------------------</span></span>
<span><span>Matching issues: 63052</span></span>
<span><span>Search time: 67.80ms</span></span>
<span><span></span></span>
<span><span>Search Results for: &#34;label:documentation type:docs&#34;</span></span>
<span><span>----------------------------------------</span></span>
<span><span>Matching issues: 105336</span></span>
<span><span>Search time: 52.06ms</span></span>
<span><span></span></span>
<span><span>Search Results for: &#34;is:open (author:charlie author:alice) label:enhancement&#34;</span></span>
<span><span>----------------------------------------</span></span>
<span><span>Matching issues: 105326</span></span>
<span><span>Search time: 81.30ms</span></span>
<span><span></span></span></code></pre>
<p>These results indicate that the system can handle a decent number of records and execute queries with acceptable performance. However, it’s important to recognize that the current implementation relies on a linear scan.</p>
<p>Therefore, for real-world applications dealing with intrinsic or imposed constraints, indexing becomes essential to maintain acceptable performance. A common choice for text fields, such as <code>title</code>, is an inverted index, which maps words to the IDs of the issues containing them. For other fields, simpler map-based indexes may suffice.</p>
<p>Beyond indexing, several other optimizations can be applied:</p>
<ul>
<li><strong>Query Optimization:</strong> Analyzing the AST to determine the most efficient order to apply filters. For example, applying the most selective filters (those that are likely to eliminate the most issues) first can significantly reduce the workload.</li>
<li><strong>Query Planning:</strong> In more complex scenarios, a query planner could choose between different indexes and execution strategies based on the query structure and data statistics.</li>
<li><strong>Caching</strong> can be applied at multiple levels:
<ul>
<li><strong>Parsed Queries:</strong> Caching the AST for frequently used queries avoids repeated parsing.</li>
<li><strong>Predicates:</strong> Caching the generated predicate function can also save computation.</li>
<li><strong>Query Results:</strong> Caching the results of entire queries can be beneficial if the data doesn’t change frequently.</li>
</ul>
</li>
</ul>
<p>These optimizations can provide a path forward for scaling the system to handle a large amount of data and complex queries, and their implementation is left as an exercise for the reader.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This article has detailed a principled approach to querying data: a comprehensive system built on type safety, functional programming, and a clear separation of concerns. We’ve leveraged TypeScript, parser combinators, and an AST to create a search DSL that is not only functional but also robust, maintainable, and extensible.</p>
<p>It’s worth mentioning that the <code>Either</code> type is an example of a <em>monad</em> – a fundamental concept in functional programming. Monads provide a way to structure computations that involve sequencing operations and handling potential failures or side effects. While a deep dive into monad theory is beyond the scope of this article, recognizing this connection can open doors to a deeper understanding of functional programming principles, and maybe even lessen the barries of entry.</p>
<p>The techniques presented here provide a strong foundation for building advanced search capabilities, applicable to both local-first web applications and large-scale server-side systems. By adopting the principles outlined in this approach, developers can design search experiences that are both powerful and user-friendly.</p>
<h2 id="references-and-further-reading">References and Further Reading</h2>
<ul>
<li><a href="https://craftinginterpreters.com/">Crafting Interpreters</a> by Robert Nystrom</li>
<li><a href="https://www.cs.nott.ac.uk/~pszgmh/pearl.pdf">Functional Parsing</a> by Graham Hutton and Erik Meijer</li>
<li><a href="https://www.microsoft.com/en-us/research/publication/parsec-direct-style-monadic-parser-combinators-for-the-real-world/">Parsec: Direct Style Monadic Parser Combinators For The Real World</a> by Daan Leijen and Erik Meijer</li>
<li><a href="https://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf">Monads for Functional Programming</a> by Philip Wadler</li>
<li><a href="http://learnyouahaskell.com/a-fistful-of-monads">Learn You a Haskell for Great Good!</a> (Chapter on Monads)</li>
<li><a href="https://martinfowler.com/books/dsl.html">Domain-Specific Languages</a> by Martin Fowler</li>
<li><a href="https://mostly-adequate.gitbook.io/mostly-adequate-guide/">Professor Frisby’s Mostly Adequate Guide to Functional Programming</a></li>
<li><a href="https://www.inkandswitch.com/local-first/">Local-first software: You own your data, in spite of the cloud</a> by Martin Kleppmann et al.</li>
</ul> </article></div>
  </body>
</html>
