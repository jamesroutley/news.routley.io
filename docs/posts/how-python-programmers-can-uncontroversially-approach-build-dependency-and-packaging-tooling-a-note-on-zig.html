<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://amontalenti.com/2022/10/09/python-packaging-and-zig">Original</a>
    <h1>How Python programmers can uncontroversially approach build, dependency, and packaging tooling (&#43; a note on Zig)</h1>
    
    <div id="readability-page-1" class="page"><article id="post-3290">
	
	<!-- .entry-header -->

	<div>
		<p>A few years back, I published <a href="https://github.com/amontalenti/elements-of-python-style" target="_blank"><em>The Elements of Python Style</em></a>, a popular Python code style guide. Since publishing it, friends of mine in the Python community have wondered if I might consider adding a section about package installation, dependency management, and other similar “tooling concerns”.</p>
<p>I took a stab at this in a <a href="https://github.com/amontalenti/elements-of-python-style/pull/50">pull request here</a>, but then abandoned my attempt. The length of this “section” started to approach the length of the overall style guide itself! So, I gave up on that. I decided to turn the section into this blog post here, instead. Then, I’ll share one thought about how emerging programming language communities, such as <a href="https://ziglang.org/">Zig’s</a>, could learn from the Python experience.</p>
<h2>On “Standard” Tools</h2>
<p>There’s a zoo of tooling options out there, and no “standard” Python tooling beyond the <code>python</code> executable, and, perhaps, <code>pip</code> (for installing packages, which was semi-formalized in Python 3.x with <a href="https://peps.python.org/pep-0453/">PEP 453</a> and <a href="https://peps.python.org/pep-0508/">PEP 508</a>). Here, we’ll discuss an opinionated (yet uncontroversial) approach to standard tooling with Python.</p>

<h3>Build and deploy</h3>
<p>It’s generally unnecessary to use any sort of “build tool” with Python, since development usually involves running <code>python</code> commands against your source tree directly. However, as will be described below, it is very common to include a <code>setup.py</code> file in your source root as an entry point for building packages from your source code.</p>
<p>That said, you’ll often find very simple and minimalistic <a href="https://www.gnu.org/software/make/manual/make.html#Overview">GNU <code>make</code></a> files (named <code>Makefile</code>) in use on Python projects. These are usually small files that simply list commands for finding dependencies, packaging, linting, testing, and so on.</p>
<p>I’d recommend <em>against</em> coupling your Python project to one of the myriad generic build tools out there, like Scons or Bazel. That is, if it can be avoided.</p>
<p>When you need to automate deployment for your Python project (e.g. for web applications), you’re likely going to adopt something like <a href="http://www.fabfile.org/">Fabric</a> or <a href="https://docs.ansible.com/">Ansible</a>, which offers something akin to <code>make</code> but with the added capabilities of a full-blown Python API and the ability to manage remote servers via SSH.</p>
<h3>Linting and formatting</h3>
<p><a href="https://flake8.pycqa.org/en/latest/"><code>flake8</code> is a good choice</a> for linting, as it combines <code>pep8</code> with <code>pyflakes</code> and that’s usually all you need on the linting side.</p>
<p>It’s very common in the community to use the <a href="https://black.readthedocs.io/en/stable/"><code>black</code> formatter</a>, which is similar in principle to the <a href="https://man.archlinux.org/man/gofmt.1.en">Golang code formatter</a>. But this is optional.</p>
<h3>Testing</h3>
<p>The <a href="https://docs.pytest.org/en/stable/"><code>pytest</code> framework</a> is totally fine and very popular, but you also won’t get any odd looks for sticking with <code>unittest</code>, and especially <a href="https://docs.python.org/3/library/doctest.html"><code>doctest</code></a>, in the stdlib.</p>
<p>For property-based testing (aka “Quickcheck”-style testing), you can layer on <a href="https://hypothesis.readthedocs.io/en/latest/"><code>hypothesis</code></a>. For code coverage statistics on your tests, you can layer on <a href="https://pytest-cov.readthedocs.io/en/latest/readme.html"><code>pytest-cov</code></a>.</p>
<h3>Environments</h3>
<p>Because operating systems differ dramatically in what version of Python they run, and how they manage Python dependencies, you’ll very likely find yourself in need of an environment manager for your Python code.</p>
<p>For local development &amp; local dependency environments, <a href="https://github.com/pyenv/pyenv/blob/master/README.md"><code>pyenv</code></a> is the gold standard. When used together with its included <code>pyenv-virtualenv</code> plugin, it is very future-proof and solid.</p>
<p>This is because <code>pyenv</code> can manage plain CPython installations, both future ones and historical ones; it can manage Conda environments via <code>miniconda</code>; it lets you run Python 2 and Python 3 side-by-side; it even supports PyPy, for situations where you need that; and, via <code>pyenv-virtualenv</code>, it lets you layer “virtual environments” over your installed Python versions. This lets you isolate dependencies between your several Python projects. It’s also a good choice for simple Python “environment-based” deployments to remote servers. You can read <a href="https://stackoverflow.com/questions/41573587/what-is-the-difference-between-venv-pyvenv-pyenv-virtualenv-virtualenvwrappe/41573588#41573588">this detailed StackOverflow answer</a> on why this is a solid choice.</p>
<h3>Dependencies</h3>
<p>For installing dependencies, you’ll want to avoid the debates going on in the community related to <code>pipenv</code> &amp; <code>poetry</code>, and stick with <code>pip</code>.</p>
<p>Most Pythonistas, upon cloning a Python project, instinctively look for a <code>requirements.txt</code> file so that they can run the incantation <code>pip install -r requirements.txt</code> to fetch your dependencies.</p>
<p>You can also  layer on <a href="https://github.com/jazzband/pip-tools"><code>pip-tools</code></a> if you need version pinning; it is being actively maintained, and its logic is even re-used by some other dependency manager projects. It has some <a href="https://pip-tools.readthedocs.io/en/latest/#pip-tools-pip-compile-pip-sync">great docs with usage instructions</a>.</p>
<h3>Packaging</h3>
<p>Creating a <code>setup.py</code> file and using <code>setuptools</code> is a good idea if you’re publishing your library as a formal dependency to a private or public PyPI server.</p>
<p>Yes, it involves some boilerplate to set up initially, but it’s generally a “set-it-and-forget-it” thing. Don’t overthink it. The Python Packaging Authority (PyPA) has <a href="https://packaging.python.org/tutorials/packaging-projects/">a nice packaging tutorial</a> that covers this ground.</p>
<p>If you need binary distribution, <code>wheel</code> is a good choice; it is supported by the Python community through <a href="https://www.python.org/dev/peps/pep-0427/">PEP 427</a>, and the <a href="https://wheel.readthedocs.io/en/stable/">PyPA maintains the wheel project</a>.</p>
<h3>Some historical commentary on packaging in Python</h3>
<p>There’s quite a lot of history behind Python’s packaging options — spanning dependency management, resolution, code packaging, and deployment. This makes sense, given that packaging was never taken up by the Python core team, and thus developed in the open among many open source communities. This has, however, provided a confusing message to new users about “what is standard”.</p>
<p>Python started with <code>setuptools</code> and <code>easy_install</code>, later added <code>pip</code>, which definitely improved over <code>easy_install</code>. But then, later, people realized pinning was useful for the way Python was deployed, so someone built <code>pip-tools</code>. Around the same time, Anaconda, one of the commercial sponsors of the scientific Python community that often faced dependency hell, worked on <code>conda</code>, which solved some very important dependency management issues “in anger” for the Python scientific and numerical computing community. Even Guido van Rossum, Python’s creator, once told the Anaconda team that packaging was “uninteresting” to the core team, and thus greenlit the development of <code>conda</code> as an on-going project in the community.</p>
<p>Then in the last couple years, a couple of well-known Python F/OSS folks built <code>poetry</code> and <code>pipenv</code>. They are great projects, but they are new alternatives to <code>pip</code>. So, we face a paradox of choice. It’s just the free-wheeling nature of a very open F/OSS community, especially since the Python core team has decided not to “bless” any one or another packaging/installer tool (though they have ratified <code>pyproject.toml</code> for packaging and <code>wheel</code> as a distribution format via <a href="https://peps.python.org/pep-0518/">PEP 518</a>).</p>
<p>When one really thinks about it, though, the only “schism” in the community is between PyPI and Conda.</p>
<p>PyPI definitively holds the equivalent role in the Python community that npmjs.com does in JavaScript or that maven.org does in Java. Conda, on the other hand, is an “alternative packaging ecosystem” that is trying to focus on more complex setup and deployment scenarios, especially those in data science or scientific computing.</p>
<p>For example, if you want to install <code>pyspark</code>, the Python API for <a href="https://spark.apache.org/">Apache Spark</a>, you’ll find very different results between PyPI and conda-forge. <a href="https://pypi.org/">In the case of PyPI</a>, installing <code>pyspark</code> only installs the Python code necessary to run <code>import pyspark</code> successfully. But it won’t install the “implied dependencies”, such as Java/JDK, Scala, and the Apache Spark framework itself. <a href="https://anaconda.org/conda-forge/pyspark">In the case of conda-forge</a>, however, installing <code>pyspark</code> gives you that Python code, as well as the full-blown managed installation of Java/JDK, Scala, and Apache Spark.</p>
<p>So, one other way to think about is that PyPI manages “only” Python projects, whereas conda-forge manages many Python projects, plus many other Python-affiliated projects, regardless of underlying language or implementation, with a bias toward supporting scientific computing packages especially well. This might be very convenient if you’re a data scientist, but using <code>conda</code> is overkill for <em>most</em> Python projects.</p>
<h3>Conclusion, and a note on Zig</h3>
<p>The truth is, it’d be better for the Python community if dependency and environment management were handled in the core. Though not having this solved in the core has led to a lot of experimentation in the broader Python open source community, it has also led to a lot of fragmentation. To such an extent that I can’t even make concise and clear recommendations in a Python style guide about it without exploding the size of the style guide by a factor of two.</p>
<p>For Python, it’s too late now. We are where we are.</p>
<p>But, other emerging programming languages like <a href="https://ziglang.org/">Zig</a> can learn from this experience. It’s worth it to solve this problem in the core. This will save fragmentation pain and allow for clear recommendations for beginning programmers. But, it’s also important to solve it <em>well</em> in the core, as the world’s experience with Node.js, <code>npm</code>, <code>left-pad</code>, <code>.node_modules</code>, and super-deep dependency trees has made clear.</p>
<p>Perhaps by combining the ideas of “dependency rejection” common in the C community with the spirit of open sharing that pervades the Python community (<a href="https://pypi.org/">via PyPI</a>), a new programming language like Zig can carve a new path that prevents community-wide tooling fragmentation, while still enabling community-wide sharing and code re-use. This is a magic moment to <a href="https://sycl.it/agenda/day1/package-wars-andrew-strikes-back/">tackle the dependency and packaging tooling problem from scratch</a>. Zig has already done so well on standard build and code formatting tooling. It has a great opportunity to get it right.</p>
<hr/>
<p><small>Here is a quick list of the Python dependency and package management tools discussed in this post. The recommended “uncontroversial” or “minimalist” tools: <a href="https://pip.pypa.io/en/stable/user_guide/">pip</a>; <a href="https://github.com/pyenv/pyenv#what-pyenv-does">pyenv</a>; <a href="https://github.com/pyenv/pyenv-virtualenv#pyenv-virtualenv">pyenv-virtualenv</a>; <a href="https://pip-tools.readthedocs.io/en/latest/">pip-tools</a>. Fancier tools from the wider community, showcasing the tooling fragmentation: <a href="https://docs.conda.io/projects/conda/en/latest/index.html">conda</a>; <a href="https://docs.conda.io/en/latest/miniconda.html">miniconda</a>; <a href="https://pipenv.pypa.io/en/latest/">Pipenv</a>; <a href="https://python-poetry.org/docs/">Poetry</a>.</small></p>
	</div><!-- .entry-content -->

	
	<!-- .entry-footer -->

</article></div>
  </body>
</html>
