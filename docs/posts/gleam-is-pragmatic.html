<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.drewolson.org/gleam-is-pragmatic/">Original</a>
    <h1>Gleam Is Pragmatic</h1>
    
    <div id="readability-page-1" class="page"><div>

<article>
   
  <div><p>I’ve spent the past several years working with functional programming languages
in my free time – primarily Haskell and OCaml. I love both languages but also
find aspects of each frustrating.</p>
<p>Haskell is terse and elegant with type classes providing a powerful mechanism
for ad-hoc polymorphism. However, it can also be confusingly implicit and I
personally find lazy evaluation to have more downsides than upsides.</p>
<p>OCaml is explicit and powerful with a best-in-class module system. However, I
believe it is often exhaustingly explicit, especially when dealing with custom
data types in generic containers.</p>
<p>Over the past few months I’ve been experimenting with the
<a href="https://gleam.run/">Gleam</a> programming language and I’ve been very impressed. I
believe it makes three very interesting design choices that provide the best of
Haskell and OCaml, with relatively few downsides.</p>
<ol>
<li><code>use</code> expressions, which are syntactic sugar for
callback-style APIs</li>
<li>Structural equality for all types, including user-defined types</li>
<li>No ad-hoc polymorphism</li>
</ol>
<p>I’ll explore the implications of these design decisions in this post, comparing
Gleam with Haskell and OCaml. I’ll be using only the standard libraries of each
language.</p>
<h2 id="brief-gleam-overview">Brief Gleam Overview</h2>
<p>Gleam is a strongly-typed functional programming language. It targets both the
BEAM (Erlang’s virtual machine) and JavaScript. It is impure (allowing untracked
side effects) and all data structures provided by the standard library are
immutable.</p>
<p>Here’s an example Gleam program that adds up the numbers in a list and prints
the result:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span>import gleam<span>/</span>int
</span></span><span><span>import gleam<span>/</span>io
</span></span><span><span>import gleam<span>/</span>list
</span></span><span><span>
</span></span><span><span><span>fn</span> <span>add</span>(sum: <span>Int</span>, n: <span>Int</span>) -&gt; <span>Int</span> {
</span></span><span><span>  sum <span>+</span> n
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>pub</span> <span>fn</span> <span>main</span>() {
</span></span><span><span>  <span>let</span> items <span>=</span> [<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>]
</span></span><span><span>
</span></span><span><span>  items
</span></span><span><span>  <span>|&gt;</span> list.fold(<span>0</span>, add)
</span></span><span><span>  <span>|&gt;</span> int.to_string
</span></span><span><span>  <span>|&gt;</span> io.println
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// 15
</span></span></span></code></pre></div><p>This simple program demonstrates some important parts of Gleam’s design:</p>
<ul>
<li>Optional type annotations (encouraged on top-level functions) with type
inference</li>
<li>First-class functions</li>
<li>Explicit imports</li>
<li>Visibility modifiers for functions (<code>pub</code> for public, default is private)</li>
<li>List literal syntax</li>
<li>The <code>|&gt;</code> operator for function pipelines (<code>a |&gt; f(b)</code> is equivalent to <code>f(a, b)</code>)</li>
</ul>
<p>Here’s a slightly more complicated program:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span>import gleam<span>/</span>int
</span></span><span><span>import gleam<span>/</span>io
</span></span><span><span>import gleam<span>/</span>list
</span></span><span><span>import gleam<span>/</span>string
</span></span><span><span>
</span></span><span><span><span>pub</span> <span>type</span> <span>Color</span> {
</span></span><span><span>  Brown
</span></span><span><span>  White
</span></span><span><span>  Other
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>pub</span> <span>type</span> <span>Pet</span> {
</span></span><span><span>  Dog(color: <span>Color</span>, name: String)
</span></span><span><span>  Cat(age: <span>Int</span>, name: String)
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>fn</span> <span>color_to_string</span>(color: <span>Color</span>) -&gt; String {
</span></span><span><span>  case color {
</span></span><span><span>    Brown -&gt; <span>&#34;brown&#34;</span>
</span></span><span><span>    White -&gt; <span>&#34;white&#34;</span>
</span></span><span><span>    Other -&gt; <span>&#34;other&#34;</span>
</span></span><span><span>  }
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>fn</span> <span>pet_to_string</span>(pet: <span>Pet</span>) -&gt; String {
</span></span><span><span>  case pet {
</span></span><span><span>    Dog(color, name) -&gt; <span>name</span> <span>&lt;&gt;</span> <span>&#34; is &#34;</span> <span>&lt;&gt;</span> color_to_string(color)
</span></span><span><span>    Cat(age, name) -&gt; <span>name</span> <span>&lt;&gt;</span> <span>&#34; is &#34;</span> <span>&lt;&gt;</span> int.to_string(age)
</span></span><span><span>  }
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>pub</span> <span>fn</span> <span>main</span>() {
</span></span><span><span>  <span>let</span> pets <span>=</span> [Dog(color: <span>Brown</span>, name: <span>&#34;Hobbes&#34;</span>), Cat(age: <span>5</span>, name: <span>&#34;Garfield&#34;</span>)]
</span></span><span><span>
</span></span><span><span>  pets
</span></span><span><span>  <span>|&gt;</span> list.map(pet_to_string)
</span></span><span><span>  <span>|&gt;</span> string.join(<span>&#34;, &#34;</span>)
</span></span><span><span>  <span>|&gt;</span> io.println
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// Hobbes is brown, Garfield is 5
</span></span></span></code></pre></div><p>In this example, we see even more cool features:</p>
<ul>
<li>Custom types, with multiple constructors</li>
<li>Exhaustive pattern matching</li>
<li>Polymorphic functions (<code>list.map</code> works with any type)</li>
<li>A string concatenation operator (<code>&lt;&gt;</code>)</li>
</ul>
<p>That’s enough Gleam to get into the rest of the post.</p>
<h2 id="monadic-style-apis">Monadic-style APIs</h2>
<p>I won’t fall into the trap of trying to define Monads in this post. Instead,
let’s talk about monadic-style APIs – that is, APIs that allow you to do a
bunch of things one after another, with the ability to use the result of a
previous computation in the next computation, and also allows some logic to
happen between steps.</p>
<p>A subset of these of APIs are often called <a href="https://fsharpforfunandprofit.com/rop/">“railway oriented
programming”</a> – you do a bunch of
steps, each which may fail, and if they all succeed you do something with the
results. We’ll focus on this use case for the rest of this section.</p>
<p>Let’s built a program that fetches several values from a key/value data
structure and, if all the values are present, adds them up. The second value we
fetch will depend on the first value we fetch.</p>
<p>Here’s an example in Haskell:</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>module</span> Main (<span>main</span>) <span>where</span>
</span></span><span><span>
</span></span><span><span><span>import</span> Data.Map (<span>Map</span>)
</span></span><span><span><span>import</span> Data.Map qualified as <span>Map</span>
</span></span><span><span>
</span></span><span><span><span>doStuff</span> <span>::</span> <span>Map</span> <span>String</span> <span>Int</span> <span>-&gt;</span> <span>Maybe</span> <span>Int</span>
</span></span><span><span><span>doStuff</span> items <span>=</span> <span>do</span>
</span></span><span><span>  a <span>&lt;-</span> <span>Map</span><span>.</span>lookup <span>&#34;a&#34;</span> items
</span></span><span><span>  b <span>&lt;-</span> <span>Map</span><span>.</span>lookup (show a) items
</span></span><span><span>
</span></span><span><span>  return (a <span>+</span> b)
</span></span><span><span>
</span></span><span><span><span>main</span> <span>::</span> <span>IO</span> ()
</span></span><span><span><span>main</span> <span>=</span> <span>do</span>
</span></span><span><span>  <span>let</span> items <span>=</span> <span>Map</span><span>.</span>fromList [(<span>&#34;a&#34;</span>, <span>1</span>), (<span>&#34;1&#34;</span>, <span>2</span>)]
</span></span><span><span>  <span>let</span> result <span>=</span> doStuff items
</span></span><span><span>
</span></span><span><span>  putStrLn (show result)
</span></span><span><span>
</span></span><span><span><span>-- Just 3</span>
</span></span></code></pre></div><p>The <code>Map.lookup</code> function has the following type:</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>ghci</span><span>&gt;</span> <span>:</span>t <span>Map</span><span>.</span>lookup
</span></span><span><span><span>Map</span><span>.</span>lookup <span>::</span> <span>Ord</span> k <span>=&gt;</span> k <span>-&gt;</span> <span>Map</span> k a <span>-&gt;</span> <span>Maybe</span> a
</span></span></code></pre></div><p>That is, given an key that is ordered and a map, it possibly returns a value.
The <code>Maybe</code> type represents a value that may or may not be present in Haskell.</p>
<p>There’s a few important things to notice about this program:</p>
<ul>
<li>Haskell’s <code>Map</code> type “just works” with <code>String</code> keys because <code>String</code> is
ordered.</li>
<li>Haskell’s <code>Maybe</code> type “just works” with the do-notation. If a function
returns <code>Nothing</code>, the do-notation short-circuits and the whole function
returns <code>Nothing</code>. However, it’s not obvious to the programmer <em>how</em> this
works or <em>what function specifically</em> is being called.</li>
<li>The <code>return</code> function “just works” to return a <code>Just</code> value. Again, this is
non-obvious to the programmer.</li>
<li>The <code>show</code> function automatically knows how to turn a <code>Maybe Int</code> into a
<code>String</code>.</li>
</ul>
<p>Here’s a roughly equivalent example in OCaml:</p>
<div><pre tabindex="0"><code data-lang="ocaml"><span><span><span>module</span> <span>StringMap</span> <span>=</span> Map.<span>Make</span> <span>(</span><span>String</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>module</span> <span>Syntax</span> <span>=</span> <span>struct</span>
</span></span><span><span>  <span>let</span> <span>(</span> <span>let</span><span>*</span> <span>)</span> <span>=</span> Option.bind
</span></span><span><span>  <span>let</span> return x <span>=</span> <span>Some</span> x
</span></span><span><span><span>end</span>
</span></span><span><span>
</span></span><span><span><span>let</span> do_stuff items <span>=</span>
</span></span><span><span>  <span>let</span> <span>open</span> <span>Syntax</span> <span>in</span>
</span></span><span><span>  <span>let</span><span>*</span> a <span>=</span> StringMap.find_opt <span>&#34;a&#34;</span> items <span>in</span>
</span></span><span><span>  <span>let</span><span>*</span> b <span>=</span> StringMap.find_opt <span>(</span>string_of_int a<span>)</span> items <span>in</span>
</span></span><span><span>  return <span>(</span>a <span>+</span> b<span>)</span>
</span></span><span><span><span>;;</span>
</span></span><span><span>
</span></span><span><span><span>let</span> option_to_string <span>=</span> <span>function</span>
</span></span><span><span>  <span>|</span> <span>None</span> <span>-&gt;</span> <span>&#34;None&#34;</span>
</span></span><span><span>  <span>|</span> <span>Some</span> n <span>-&gt;</span> Printf.sprintf <span>&#34;Some(%i)&#34;</span> n
</span></span><span><span><span>;;</span>
</span></span><span><span>
</span></span><span><span><span>let</span> () <span>=</span>
</span></span><span><span>  <span>let</span> items <span>=</span> StringMap.of_list <span>[</span> <span>&#34;a&#34;</span><span>,</span> 1<span>;</span> <span>&#34;1&#34;</span><span>,</span> 2 <span>]</span> <span>in</span>
</span></span><span><span>  items <span>|&gt;</span> do_stuff <span>|&gt;</span> option_to_string <span>|&gt;</span> print_endline
</span></span><span><span><span>;;</span>
</span></span><span><span>
</span></span><span><span><span>(* Some(3) *)</span>
</span></span></code></pre></div><p>The <code>StringMap.find_opt</code> function has the following type:</p>
<div><pre tabindex="0"><code data-lang="ocaml"><span><span><span>val</span> find_opt <span>:</span> key <span>-&gt;</span> <span>&#39;</span>a t <span>-&gt;</span> <span>&#39;</span>a option
</span></span></code></pre></div><p>Some important things to notice here:</p>
<ul>
<li>You must explicitly create a <code>Map</code> with your chosen key type (in this case
<code>String</code>).</li>
<li>You must explicit create a module that represents the <code>let*</code> and <code>return</code>
functions for the <code>Option</code> type.</li>
<li>This <code>Syntax</code> module must be locally in-scope to use the appropriate
implementation of <code>let*</code> in the body of <code>do_stuff</code>. This means an explicit
local <code>open</code> of the <code>Syntax</code> module.</li>
<li>It’s very obvious to the programmer what implementation of <code>let*</code> and <code>return</code>
are being used in a given context.</li>
<li>You need to manually tell OCaml how to print a <code>int option</code>.</li>
</ul>
<p>Now, let’s look at two examples of the same program in Gleam. Here’s the first
one:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span>import gleam<span>/</span>dict.{<span>type</span> <span>Dict</span>}
</span></span><span><span>import gleam<span>/</span>int
</span></span><span><span>import gleam<span>/</span>io
</span></span><span><span>import gleam<span>/</span>result
</span></span><span><span>import gleam<span>/</span>string
</span></span><span><span>
</span></span><span><span><span>fn</span> <span>do_stuff</span>(items: <span>Dict</span>(String, Int)) -&gt; Result(Int, Nil) {
</span></span><span><span>  items
</span></span><span><span>  <span>|&gt;</span> dict.get(<span>&#34;a&#34;</span>)
</span></span><span><span>  <span>|&gt;</span> result.<span>try</span>(<span>fn</span>(a) {
</span></span><span><span>    items
</span></span><span><span>    <span>|&gt;</span> dict.get(int.to_string(a))
</span></span><span><span>    <span>|&gt;</span> result.<span>try</span>(<span>fn</span>(b) { Ok(a <span>+</span> b) })
</span></span><span><span>  })
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>pub</span> <span>fn</span> <span>main</span>() {
</span></span><span><span>  <span>let</span> items <span>=</span> dict.from_list([#(<span>&#34;a&#34;</span>, <span>1</span>), #(<span>&#34;1&#34;</span>, <span>2</span>)])
</span></span><span><span>
</span></span><span><span>  items
</span></span><span><span>  <span>|&gt;</span> do_stuff
</span></span><span><span>  <span>|&gt;</span> string.inspect
</span></span><span><span>  <span>|&gt;</span> io.println
</span></span><span><span>}
</span></span><span><span><span>// Ok(3)
</span></span></span></code></pre></div><p>There are two important types in the above program. First, <code>dict.get</code>:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span> <span>fn</span> <span>get</span>(from: <span>Dict</span>(a, b), get: <span>a</span>) -&gt; Result(b, Nil)
</span></span></code></pre></div><p>And second, <code>result.try</code>:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span> <span>fn</span> <span>try</span>(
</span></span><span><span>  result: Result(a, b),
</span></span><span><span>  fun: <span>fn</span>(a) -&gt; Result(c, b),
</span></span><span><span>) -&gt; Result(c, b)
</span></span></code></pre></div><p>Things to note:</p>
<ul>
<li><code>Dict</code> “just works” with <code>String</code> keys.</li>
<li>All function calls are explicit, along with their namespaces.</li>
<li>The nesting of <code>result.try</code> calls is a bit of a pain.</li>
<li><code>string.inspect</code> can automatically turn a <code>Result(Int, Nil)</code> into a <code>String</code>.</li>
</ul>
<p>This example has a bunch of the good features from Haskell and OCaml – generic
collections “just work”, it’s obvious what functions are being called, and
string conversion is convenient via <code>string.inspect</code>.</p>
<p>However, the “callback hell” pyramid of doom is not great. This is where <code>use</code>
comes to the rescue!</p>
<p>In Gleam, <code>use</code> is a mechanism for rewriting callback-based APIs in a flat
style. The following two blocks of code are equivalent:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>// standard callback
</span></span></span><span><span><span></span>f(a, <span>fn</span>(b) { g(b) })
</span></span><span><span>
</span></span><span><span><span>// with use
</span></span></span><span><span><span></span><span>use</span> b <span>&lt;-</span> f(a)
</span></span><span><span>g(b)
</span></span></code></pre></div><p>We can employ <code>use</code> to remove the nesting from our previous example:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span>import gleam<span>/</span>dict.{<span>type</span> <span>Dict</span>}
</span></span><span><span>import gleam<span>/</span>int
</span></span><span><span>import gleam<span>/</span>io
</span></span><span><span>import gleam<span>/</span>result
</span></span><span><span>import gleam<span>/</span>string
</span></span><span><span>
</span></span><span><span><span>fn</span> <span>do_stuff</span>(items: <span>Dict</span>(String, Int)) -&gt; Result(Int, Nil) {
</span></span><span><span>  <span>use</span> a <span>&lt;-</span> result.<span>try</span>(dict.get(items, <span>&#34;a&#34;</span>))
</span></span><span><span>  <span>use</span> b <span>&lt;-</span> result.<span>try</span>(dict.get(items, int.to_string(a)))
</span></span><span><span>
</span></span><span><span>  Ok(a <span>+</span> b)
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>pub</span> <span>fn</span> <span>main</span>() {
</span></span><span><span>  <span>let</span> items <span>=</span> dict.from_list([#(<span>&#34;a&#34;</span>, <span>1</span>), #(<span>&#34;1&#34;</span>, <span>2</span>)])
</span></span><span><span>
</span></span><span><span>  items
</span></span><span><span>  <span>|&gt;</span> do_stuff
</span></span><span><span>  <span>|&gt;</span> string.inspect
</span></span><span><span>  <span>|&gt;</span> io.println
</span></span><span><span>}
</span></span><span><span><span>// Ok(3)
</span></span></span></code></pre></div><p>This example retains all of the previous advantages <em>and</em> removes the nested
callbacks. Very nice.</p>
<h2 id="custom-types">Custom Types</h2>
<p>Let’s say we want to rewrite our above examples, but this time our keys will be
a custom type rather than <code>String</code>s. Haskell first:</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>module</span> Main (<span>main</span>) <span>where</span>
</span></span><span><span>
</span></span><span><span><span>import</span> Data.Map (<span>Map</span>)
</span></span><span><span><span>import</span> Data.Map qualified as <span>Map</span>
</span></span><span><span>
</span></span><span><span><span>data</span> <span>Person</span> <span>=</span> <span>Person</span>
</span></span><span><span>  { name <span>::</span> <span>String</span>,
</span></span><span><span>    age <span>::</span> <span>Int</span>
</span></span><span><span>  }
</span></span><span><span>  <span>deriving</span> (<span>Eq</span>, <span>Ord</span>)
</span></span><span><span>
</span></span><span><span><span>drew</span> <span>::</span> <span>Person</span>
</span></span><span><span><span>drew</span> <span>=</span> <span>Person</span> {name <span>=</span> <span>&#34;Drew&#34;</span>, age <span>=</span> <span>42</span>}
</span></span><span><span>
</span></span><span><span><span>jane</span> <span>::</span> <span>Person</span>
</span></span><span><span><span>jane</span> <span>=</span> <span>Person</span> {name <span>=</span> <span>&#34;Jane&#34;</span>, age <span>=</span> <span>61</span>}
</span></span><span><span>
</span></span><span><span><span>doStuff</span> <span>::</span> <span>Map</span> <span>Person</span> <span>Int</span> <span>-&gt;</span> <span>Maybe</span> <span>Int</span>
</span></span><span><span><span>doStuff</span> items <span>=</span> <span>do</span>
</span></span><span><span>  a <span>&lt;-</span> <span>Map</span><span>.</span>lookup drew items
</span></span><span><span>  b <span>&lt;-</span> <span>Map</span><span>.</span>lookup jane items
</span></span><span><span>
</span></span><span><span>  return (a <span>+</span> b)
</span></span><span><span>
</span></span><span><span><span>main</span> <span>::</span> <span>IO</span> ()
</span></span><span><span><span>main</span> <span>=</span> <span>do</span>
</span></span><span><span>  <span>let</span> items <span>=</span> <span>Map</span><span>.</span>fromList [(drew, <span>1</span>), (jane, <span>2</span>)]
</span></span><span><span>  <span>let</span> result <span>=</span> doStuff items
</span></span><span><span>
</span></span><span><span>  putStrLn (show result)
</span></span><span><span>
</span></span><span><span><span>-- Just 3</span>
</span></span></code></pre></div><p>This works pretty much the same as our previous example, except we need to tell
Haskell that our <code>Person</code> can be compared for equality and is ordered (<code>deriving (Eq, Ord)</code>).</p>
<p>Next, here’s OCaml:</p>
<div><pre tabindex="0"><code data-lang="ocaml"><span><span><span>module</span> <span>Person</span> <span>=</span> <span>struct</span>
</span></span><span><span>  <span>type</span> t <span>=</span>
</span></span><span><span>    <span>{</span> name <span>:</span> <span>string</span>
</span></span><span><span>    <span>;</span> age <span>:</span> <span>int</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>  <span>let</span> compare p1 p2 <span>=</span>
</span></span><span><span>    <span>match</span> compare p1<span>.</span>name p2<span>.</span>name <span>with</span>
</span></span><span><span>    <span>|</span> 0 <span>-&gt;</span> compare p1<span>.</span>age p2<span>.</span>age
</span></span><span><span>    <span>|</span> other <span>-&gt;</span> other
</span></span><span><span>  <span>;;</span>
</span></span><span><span><span>end</span>
</span></span><span><span>
</span></span><span><span><span>let</span> drew <span>=</span> Person.<span>{</span> name <span>=</span> <span>&#34;Drew&#34;</span><span>;</span> age <span>=</span> 42 <span>}</span>
</span></span><span><span><span>let</span> jane <span>=</span> Person.<span>{</span> name <span>=</span> <span>&#34;Jane&#34;</span><span>;</span> age <span>=</span> 61 <span>}</span>
</span></span><span><span>
</span></span><span><span><span>module</span> <span>PersonMap</span> <span>=</span> Map.<span>Make</span> <span>(</span><span>Person</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>module</span> <span>Syntax</span> <span>=</span> <span>struct</span>
</span></span><span><span>  <span>let</span> <span>(</span> <span>let</span><span>*</span> <span>)</span> <span>=</span> Option.bind
</span></span><span><span>  <span>let</span> return x <span>=</span> <span>Some</span> x
</span></span><span><span><span>end</span>
</span></span><span><span>
</span></span><span><span><span>let</span> do_stuff items <span>=</span>
</span></span><span><span>  <span>let</span> <span>open</span> <span>Syntax</span> <span>in</span>
</span></span><span><span>  <span>let</span><span>*</span> a <span>=</span> PersonMap.find_opt drew items <span>in</span>
</span></span><span><span>  <span>let</span><span>*</span> b <span>=</span> PersonMap.find_opt jane items <span>in</span>
</span></span><span><span>  return <span>(</span>a <span>+</span> b<span>)</span>
</span></span><span><span><span>;;</span>
</span></span><span><span>
</span></span><span><span><span>let</span> option_to_string <span>=</span> <span>function</span>
</span></span><span><span>  <span>|</span> <span>None</span> <span>-&gt;</span> <span>&#34;None&#34;</span>
</span></span><span><span>  <span>|</span> <span>Some</span> n <span>-&gt;</span> Printf.sprintf <span>&#34;Some(%i)&#34;</span> n
</span></span><span><span><span>;;</span>
</span></span><span><span>
</span></span><span><span><span>let</span> () <span>=</span>
</span></span><span><span>  <span>let</span> items <span>=</span> PersonMap.of_list <span>[</span> drew<span>,</span> 1<span>;</span> jane<span>,</span> 3 <span>]</span> <span>in</span>
</span></span><span><span>  items <span>|&gt;</span> do_stuff <span>|&gt;</span> option_to_string <span>|&gt;</span> print_endline
</span></span><span><span><span>;;</span>
</span></span><span><span>
</span></span><span><span><span>(* Some(3) *)</span>
</span></span></code></pre></div><p>This has quite a bit more boilerplate than our previous OCaml example. When we
want a custom type to be the key of a <code>Map</code>, we must manually implement the
<code>compare</code> function (as noted earlier, I’m sticking to standard libraries, so no
<code>ppx_deriving</code>).</p>
<p>Finally, here’s Gleam:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span>import gleam<span>/</span>dict.{<span>type</span> <span>Dict</span>}
</span></span><span><span>import gleam<span>/</span>io
</span></span><span><span>import gleam<span>/</span>result
</span></span><span><span>import gleam<span>/</span>string
</span></span><span><span>
</span></span><span><span><span>type</span> <span>Person</span> {
</span></span><span><span>  Person(name: String, age: <span>Int</span>)
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>const</span> drew <span>=</span> Person(name: <span>&#34;Drew&#34;</span>, age: <span>42</span>)
</span></span><span><span>
</span></span><span><span><span>const</span> jane <span>=</span> Person(name: <span>&#34;Jane&#34;</span>, age: <span>61</span>)
</span></span><span><span>
</span></span><span><span><span>fn</span> <span>do_stuff</span>(items: <span>Dict</span>(Person, Int)) -&gt; Result(Int, Nil) {
</span></span><span><span>  <span>use</span> a <span>&lt;-</span> result.<span>try</span>(dict.get(items, drew))
</span></span><span><span>  <span>use</span> b <span>&lt;-</span> result.<span>try</span>(dict.get(items, jane))
</span></span><span><span>
</span></span><span><span>  Ok(a <span>+</span> b)
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>pub</span> <span>fn</span> <span>main</span>() {
</span></span><span><span>  <span>let</span> items <span>=</span> dict.from_list([#(drew, <span>1</span>), #(jane, <span>2</span>)])
</span></span><span><span>
</span></span><span><span>  items
</span></span><span><span>  <span>|&gt;</span> do_stuff
</span></span><span><span>  <span>|&gt;</span> string.inspect
</span></span><span><span>  <span>|&gt;</span> io.println
</span></span><span><span>}
</span></span><span><span><span>// Ok(3)
</span></span></span></code></pre></div><p>Note that I don’t need to do <em>anything</em> to allow my custom <code>Person</code> type to be a
key in a <code>Dict</code>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Gleam has made some very interesting decisions in the functional programming
design space. I believe it has pragmatically taken the best of Haskell and
OCaml with very few downsides.</p>
<p>I’m surprised at how versatile <code>use</code> can be, especially given Gleam’s lack of
ad-hoc polymorphism or a module system. Folks have already made lovely <a href="https://hexdocs.pm/party/">parser
combinators</a>, <a href="https://hexdocs.pm/toy/">decoders</a>,
and more. I even wrote a <a href="https://hexdocs.pm/clip/">CLI option parsing library</a>
myself.</p>
<p>I’m excited to continue working with Gleam and believe it has a bright future
for functional programming newcomers and old timers alike.</p>


  </div>

  
</article>
    </div></div>
  </body>
</html>
