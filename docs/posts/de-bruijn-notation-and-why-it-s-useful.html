<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blueberrywren.dev/blog/debruijn-explanation/">Original</a>
    <h1>De Bruijn notation, and why it&#39;s useful</h1>
    
    <div id="readability-page-1" class="page"><section>
    <div>


      



  <meta property="og:title" content="Debruijn indexes + levels, and why they&#39;re handy"/>
  <title> Debruijn indexes + levels, and why they&#39;re handy </title>




<p>
  <strong>2025-05-26</strong>
  </p>


<h2 id="assumed-knowledge">Assumed knowledge</h2>
<p>At least a familiarity with the lambda calculus, including how it is evaluated. Some base knowledge of programming languages is also assumed.</p>
<h2 id="the-problem">The problem</h2>
<p>Let&#39;s look at a little imaginary term, in some lambda-calculus-like language. For future note, we call the lambda a &#34;binder&#34;, as it binds a variable. There are other types of binders, e.g. <code>let</code>, but we will only consider lambdas for the moment.</p>
<pre data-lang="hs"><code data-lang="hs"><span>λ f</span><span>.</span><span> (λ y f</span><span>.</span><span> (f y)) f
</span></code></pre>
<p>We can perform what&#39;s called &#34;beta reduction&#34; on this term — essentially, function application, applying <code>f</code> to the lambda.</p>
<pre data-lang="hs"><code data-lang="hs"><span>λ f</span><span>.</span><span> (λ y f</span><span>.</span><span> (f y)) (f)
</span><span>
</span><span>substitute [y </span><span>:=</span><span> f] </span><span>in</span><span> λ y f</span><span>.</span><span> (f y)
</span><span>
</span><span>λ f</span><span>.</span><span> (λ f</span><span>.</span><span> f f)
</span></code></pre>
<p>Uh oh. We&#39;ve accidentally captured a variable! Instead of <code>f</code> referring to the outer <code>f</code>, now it refers to the inner <code>f</code>. This is &#34;the capture problem&#34;, and it is quite annoying. Generally to avoid this, we need to rename <em>everything</em> in our &#34;substituted&#34; term to names that are free (do not occur) in the &#34;subsitutee&#34; so nothing is accidentally captured. What if we could introduce a notation that avoids this?</p>
<h2 id="presenting-de-bruijn-indexes">Presenting: De Bruijn Indexes!</h2>
<p>De Bruijn indexes are a naming scheme where:</p>
<ul>
<li>We use natural numbers to refer to lambdas, and</li>
<li>Zero refers to the &#34;most recent&#34; lambda; one refers to the second most recent, etc.</li>
</ul>
<p>Let&#39;s rewrite that term above using this system:</p>
<pre data-lang="hs"><code data-lang="hs"><span>λ (λ λ (</span><span>0 1</span><span>)) </span><span>0
</span></code></pre>
<p>Here&#39;s some ascii art showing what refers to what:</p>
<pre data-lang="hs"><code data-lang="hs"><span> λ   (λ   λ   (</span><span>0   1</span><span>))   </span><span>0
</span><span> </span><span>|    |    \</span><span>———</span><span>/   |     |
</span><span> </span><span>|    |            |     |
</span><span> </span><span>|    \</span><span>————————————</span><span>/     |
</span><span> </span><span>\</span><span>———————————————————————</span><span>/
</span></code></pre>
<p>Now, how does this help us with our substituion problem? Surely if we naively subtitute we will still have binding issues - and indeed we do:</p>
<pre data-lang="hs"><code data-lang="hs"><span>λ (λ λ (</span><span>0 1</span><span>)) </span><span>0
</span><span>-&gt;
</span><span>λ (λ (</span><span>0 0</span><span>))
</span></code></pre>
<p>No good!</p>
<p>What De Bruijn indexes allow us to do is simply avoid capturing. The rule is simple: Every time we go past a binder when substituting, we increment every free variable in our substituted term by one, to avoid the new binder. Just once, we decrement every free varible in the substitutee, to account for the removal of the binder:</p>
<pre data-lang="hs"><code data-lang="hs"><span> λ (λ λ (</span><span>1 2</span><span>)) </span><span>0
</span><span> ^  ^ ^
</span><span> a  b c
</span><span> </span><span>-&gt;
</span><span> λ (λ (</span><span>1 1</span><span>))
</span><span> ^  ^  ^ ^ 
</span><span> a  b  </span><span>| \</span><span> decremented by one
</span><span>       </span><span>|
</span><span>       </span><span>\</span><span> incremented by one when we passed </span><span>&#34;through&#34;</span><span> lambda c
</span></code></pre>
<p>Now we&#39;re cool! Everything works as expected, and it takes much less work (and is much more predictable!).</p>
<p>At the bottom of this post there&#39;s a little widget that can convert terms to de Bruijn for you, if you want to play around!</p>
<h2 id="presenting-de-bruijn-levels">Presenting: De Bruijn levels!</h2>
<p>De Bruijn levels work similar to De Bruijn indexes, in that we use numbers to refer to binders. However, in De Bruijn levels, the lowest number refers to the <em>least</em> recently bound item.</p>
<p>Recall that:</p>
<pre data-lang="hs"><code data-lang="hs"><span>Named</span><span>:</span><span>   λ f</span><span>.</span><span> (λ y f</span><span>.</span><span> (f y)) f
</span><span>Indexes</span><span>:</span><span> λ (λ λ (</span><span>0 1</span><span>)) </span><span>0
</span></code></pre>
<p>Now, with levels:</p>
<pre data-lang="hs"><code data-lang="hs"><span>Levels</span><span>:</span><span>  λ (λ λ (</span><span>2 1</span><span>)) </span><span>0
</span></code></pre>
<p>This has the same diagram of what refers to what:</p>
<pre data-lang="hs"><code data-lang="hs"><span> λ   (λ   λ   (</span><span>2   1</span><span>))   </span><span>0
</span><span> </span><span>|    |    \</span><span>———</span><span>/   |     |
</span><span> </span><span>|    |            |     |
</span><span> </span><span>|    \</span><span>————————————</span><span>/     |
</span><span> </span><span>\</span><span>———————————————————————</span><span>/
</span></code></pre>
<p>(As it should! These two representations represent the same term.)</p>
<p>As you might expect, de Bruijn indexes and levels are each beneficial in their own situations.</p>
<p>Generally, De Bruijn indexes are &#34;more useful&#34; than De Bruijn levels, as they&#39;re &#34;more local&#34;. In order to work with levels, you need to know &#34;how deep&#34; you are in a term at all times.</p>
<p>De Bruijn indexes give us the advantage that we can freely create new binders without the need for any information about where in a term we are, whereas de Bruijn levels give us the advantage when moving a term under a binder, free variables in said term do not need to be modified. Generally, one has many more free variables in a term than bound ones.</p>
<pre data-lang="hs"><code data-lang="hs"><span> λ (λ λ (</span><span>2 1</span><span>)) </span><span>0
</span><span>               ^ this zero</span><span>...
</span><span> </span><span>-&gt;
</span><span> λ (λ (</span><span>1 0</span><span>))
</span><span>       ^ ^ is still zero</span><span>!
</span><span>       </span><span>|
</span><span>       </span><span>\</span><span> we had to modify this one though
</span></code></pre>
<h2 id="other-advantages">Other advantages</h2>
<p>Something that can come up quite a lot in various contexts is comparing whether two terms are equal or not. There are many complicated ways to do so, but de Bruijn gives us an advantage in a critical one, called &#34;alpha-equivalence&#34;. Consider the following two terms:</p>
<pre data-lang="hs"><code data-lang="hs"><span>λf</span><span>.</span><span> λx</span><span>.</span><span> f x
</span><span>λg</span><span>.</span><span> λy</span><span>.</span><span> g y
</span></code></pre>
<p>These terms should clearly be equal, right? They do the exact same thing. In this case, we consider them &#34;alpha-equivalent&#34;, meaning they are equal up to the names of variables. Alpha renaming is the process of renaming one term to match the names of another, so that they are &#34;clearly&#34; equal.</p>
<p>Let us consider the de Bruijn index representation of both of these terms:</p>
<pre data-lang="hs"><code data-lang="hs"><span>λf</span><span>.</span><span> λx</span><span>.</span><span> f x </span><span>=&gt;</span><span> λ λ </span><span>1 0
</span><span>λg</span><span>.</span><span> λy</span><span>.</span><span> g y </span><span>=&gt;</span><span> λ λ </span><span>1 0
</span></code></pre>
<p>Isn&#39;t that nice? They&#39;ve gone from being alpha-equivalent, but not quite equal, to being equal. de Bruijn gives us the ability to compare terms for equality without having to consider alpha-equivalence at all.</p>
<h2 id="wrapup">Wrapup</h2>
<p>De Bruijn indexes and levels can also be summed up via the following:</p>
<pre data-lang="hs"><code data-lang="hs"><span>λa</span><span>.</span><span> λb</span><span>.</span><span> λc</span><span>.</span><span> c
</span><span>
</span><span>indexes</span><span>:
</span><span>λ λ λ </span><span>0
</span><span>^ ^ ^
</span><span>2 1 0
</span><span>
</span><span>levels</span><span>:
</span><span>λ λ λ </span><span>2
</span><span>^ ^ ^
</span><span>0 1 2
</span></code></pre>
<p>if you’re “here”</p>
<pre><code><span>  v
</span><span>λ λ λ
</span></code></pre>
<ul>
<li>Using indexes, adding any binders further left doesn’t affect the current binder&#39;s variables, or any further right.</li>
<li>Using levels, adding any binders further right doesn’t affect the current binder&#39;s variables, or any further left.</li>
</ul>

<p>Try it out! Some example terms to try:</p>
<pre><code><span>\f x. f x
</span><span>\x x. x
</span><span>\x. (x (\y. y))
</span><span>
</span><span>\x. \y. y x -- will not work
</span><span>do \x. (\y. y x) or \x y. y x instead
</span></code></pre>
<p>(sorry, it does over-parenthesize a bit :P)</p>
<pre data-lang="hs"><code data-lang="hs" id="goober">
</code></pre>

<h2 id="alternatives">Alternatives</h2>
<p>It is worth noting that there are several other methods for gaining the same, or similar, advantages as de Bruijn gives. This post is not intended to explain them, but I will list several here so that the curious reader may read further (tip: when searching, append &#34;lambda calculus&#34; to find the right results quicker):</p>
<ul>
<li>HOAS, or &#34;Higher Order Abstract Syntax&#34;</li>
<li>PHOAS, or &#34;Parametric HOAS&#34;</li>
<li>Locally nameless</li>
<li>Nominal signatures</li>
<li>Well-scoped de Bruijn indices</li>
<li>Well-scoped names</li>
<li><a href="http://doi.acm.org/10.1145/2034773.2034817">“Nameless,
Painless”</a></li>
<li>Abstract scope graphs</li>
<li>Abstract Binding Trees</li>
<li>Co-de Bruijn indices</li>
</ul>
<p>As you can see, there are many approaches! Jesper Cockx has an excellent summary of almost all of these, which can be found <a href="https://jesper.sikanda.be/posts/1001-syntax-representations.html">here.</a> Notably, many are intended for formalization efforts rather than for computational usage.</p>






      </div>
  </section></div>
  </body>
</html>
