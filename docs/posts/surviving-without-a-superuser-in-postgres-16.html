<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://rhaas.blogspot.com/2023/01/surviving-without-superuser-coming-to.html">Original</a>
    <h1>Surviving without a superuser in Postgres 16</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-1616893523180862762" itemprop="description articleBody"><p>
As <a href="https://rhaas.blogspot.com/2020/12/cve-2019-9193.html" target="_blank">I&#39;ve written about before</a>, a PostgreSQL superuser always has the ability to take over the operating system account in which PostgreSQL is running, but <a href="https://rhaas.blogspot.com/2021/12/surviving-without-superuser-part-one.html" target="_blank">sometimes you&#39;d like</a> to <a href="https://rhaas.blogspot.com/2022/01/surviving-without-superuser-part-two.html" target="_blank">have a role</a> that can administer the database but not break out of it. In existing releases, there&#39;s no good way to accomplish that. You can either make a new role so weak that it can&#39;t perform ordinary administration tasks, or you can make it so strong that it can easily break into the operating system account and thus take over the superuser role as well. Unless you hack the source code, which some people have done, there&#39;s no real way to set up an account that has enough power to usefully administer the database in meaningful ways but yet not enough power to take over everything. I&#39;ve committed a number of patches to v16 to try to improve the situation, and I think that we can look forward to big improvements in this area once it is released.<span><a name="more"></a></span></p><p>One way that you can make a PostgreSQL role very powerful is to give it the <span>CREATEROLE</span> property, either by creating it using a command like <span>CREATE USER alice CREATEROLE</span>, or by adding that property later using a command like <span>ALTER ROLE alice CREATEROLE</span>. Unfortunately, in existing releases, that&#39;s both too much and not enough. As you would expect from the name, the <span>CREATEROLE</span> property allows a role to create new roles. Less obviously, it also allows a role to manage other roles, for example by using <span>ALTER ROLE</span> to set the <span>CONNECTION LIMIT</span> for other roles or even to use <span>ALTER ROLE</span> to change the password for other roles, provided that those roles are not superusers or users with the <span>REPLICATION</span> property. All of this is great: a user who is an administrator ought to be able to create new roles and managing existing roles, and they should also be prevented from breaking into superuser accounts if they&#39;re not a superuser. Unfortunately, a <span>CREATEROLE</span> user is also empowered to add any role as a member of any other role, including predefined roles, which means that they can create a new account and assign it the <span>pg_execute_server_programs</span> role, after which they can use the new account to get control of the OS account, after which they can hack superuser. Thus, in existing releases, <span>CREATEROLE</span> is basically useless, at least in any kind of security-sensitive environment.</p><p>In the master branch that will become v16, <a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=cf5eb37c5ee0cc54c80d95c1695d7fca1f7c68cb" target="_blank">this is fixed</a>. <span>CREATEROLE</span> users no longer have the ability to hand out membership in any role to anyone; instead, like other users, they can only hand out memberships in roles for which they possess <span>ADMIN OPTION</span>. Similarly, they can hand out the sensitive role properties <span>CREATEDB</span>, <span>REPLICATION</span>, and <span>BYPASSRLS</span> <a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=f1358ca52dd7b8cedd29c6f2f8c163914f03ea2e">only if they possess those properties themselves</a> -- previously, they could give <span>CREATEDB</span> without having it, and could never give the other two. Moreover, the ability of <span>CREATEROLE</span> users to manage other users has been somewhat restricted: they can still perform user management tasks,Â but now only for roles that they created, or for roles that they&#39;ve been given the ability to manage by some other role that already has permission to manage them. Now, when a <span>CREATEROLE</span> user creates a new role, they are automatically granted <span>ADMIN OPTION</span> on that new role, which allows them to do things like change the password or connection limit for that role, or even drop it. To be clear, <span>ADMIN OPTION </span>on a role isn&#39;t by itself sufficient to perform user management tasks: you need that plus <span>CREATEROLE</span>. The upshot of all of this is that the superuser can control exactly which accounts can be managed by a <span>CREATEROLE</span> user. Instead of being able to manage every non-superuser, non-replication role in the system, a <span>CREATEROLE</span> user will just be able to manage the accounts they created or for which they have been given admin rights.</p><p>At this point, you might be wondering whether I&#39;ve forgotten about the fact that superusers can do a whole lot of things other than just manage roles. Because superusers bypass all permission checks, a superuser can do everything that any other user on the system can do. They can <span>SET ROLE</span> to any user. Even without doing so, they can use arbitrary DML and DDL commands on any SQL object in the system. In my opinion, this is the core of the superuser experience: to be able to select from somebody else&#39;s tables, or alter them, or drop them, or whatever you want to do, without even having to <span>SET ROLE,</span> unless you feel like it. The master branch now has a way to make this work for <span>CREATEROLE</span> users, too, but with the very important restriction that it only applies to roles created by that role, and not every role in the system, else it would be insecure. It&#39;s not the default behavior and must be enabled, because some people might want to have <span>CREATEROLE</span> users that are just intended to create new roles and not to access the privileges of those roles e.g. a user-creation bot. However, I think for many people, the new option will be convenient.</p><p>Lest it seem a bit too magical, let me explain how it works. As I mentioned above, when a <span>CREATEROLE</span> user create a new role, they automatically get <span>ADMIN OPTION</span> on it. However, they do not automatically inherit the privileges of that role, nor do they automatically gain the ability to <span>SET ROLE</span> to it. Therefore, they are only able to administer the role, not use its privileges. This, however, is something that can easily be changed. One of the privileges that you get from having <span>ADMIN OPTION</span> on a role is the ability to add members to it. So, a <span>CREATEROLE</span> user could just use the new extensions to the <span>GRANT</span> syntax which are committed to master to <span>GRANT the_new_account TO my_self WITH INHERIT TRUE, SET TRUE</span> and then they&#39;d be able to <span>SET ROLE </span>to the new account and would inherit all of its privileges.</p><p>However, <a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=e5b8a4c098ad6add39626a14475148872cd687e0" target="_blank">we&#39;ve also got a way to make this automatic</a>. There is a new parameter <span>createrole_self_grant</span> which, if set to a non-empty value, will cause any new roles you create using the <span>CREATEROLE</span> privilege to also be granted back to you with the options that you specify. If you configure <span>createrole_self_grant = &#39;set, inherit&#39;</span> and then create a bunch of new roles, you may be surprised by the degree to which you feel just like a superuser! You&#39;ll have all the privileges of those roles and can <span>SET ROLE </span>to all of them freely and can drop them and change their passwords and all that good stuff. The experience will be even better if you own the database that you&#39;re accessing, since that will allow you to do things like create new schemas and give them to whichever users you like, or grant <span>CREATE</span> privileges on the existing <span>public</span> schema.</p><p>Depending on the situation, the superuser might also choose to give a <span>CREATEROLE</span> user the <span>REPLICATION</span>, <span>CREATEDB</span>, or <span>BYPASSRLS</span> role properties; might choose to grant some predefined roles to them for additional privileges; or might use <span>GRANT ALTER SYSTEM ON PARAMETER</span> to allow them to tweak <span>postgresql.conf.auto</span>. This both allows for non-superuser administrators to be quite powerful, and at the same time allows the superuser to control how powerful they are.</p><p>If you&#39;ve followed PostgreSQL development for a while, you know that the project believes deeply in the idea of incremental development, which is a nice way of saying that this new system is not going to solve all the problems. For example, I&#39;m a bit concerned about the ability of such a user to take a full dump the database with <span>pg_dump</span>. It does basically work pretty much the same way that it would for a superuser, but if there are any tables in the database being dumped which the administrator role can&#39;t access, then it&#39;s going to fail with a permission denied error when that table is reached. That could be worked around by either giving the administrator access to all the tables or by the administrator using the <span>-T</span> option to <span>pg_dump</span> to exclude them, but maybe that won&#39;t be convenient enough to make everyone happy. Or perhaps it&#39;s fine: I&#39;m not sure.</p><p>Also, there&#39;s currently no way to delegate the ability to issue <span>CREATE SUBSCRIPTION</span> or <span>CREATE EVENT TRIGGER</span> to a non-superuser. This won&#39;t be a problem for everyone. Many people probably don&#39;t use event triggers at all. Subscriptions are likely more heavily used, but some superusers may want control over subscriptions to remain with the superuser rather than being delegated, in which they won&#39;t care. In cases where it&#39;s desirable to delegate control over logical replication, some workaround will be needed unless and until we can get further changes made in PostgreSQL itself. <a href="https://www.postgresql.org/message-id/flat/9DFC88D3-1300-4DE8-ACBC-4CEF84399A53%40enterprisedb.com" target="_blank">There&#39;s currently a discussion on the mailing list about how to get some form of delegation up and working</a>, but it hasn&#39;t reached any definite conclusions yet and I don&#39;t know whether it will do so before we hit feature freeze for v16.</p><p>There are, likely, some other problems as well. But there is also a lot of stuff that now does work and, I think, in a pretty usable form. I&#39;m excited about that, and I&#39;d love to hear what you think. Comment below!</p>

</div></div>
  </body>
</html>
