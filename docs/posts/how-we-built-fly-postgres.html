<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fly.io/blog/how-we-built-fly-postgres/">Original</a>
    <h1>How We Built Fly Postgres</h1>
    
    <div id="readability-page-1" class="page"><article> <dl> <dt>Author</dt> <dd> <img src="https://fly.io/static/images/chris-n.jpg" alt="Chris Nicoll" srcset=""/> <dl> <dt>Name</dt> <dd> Chris Nicoll </dd> <dt>Twitter</dt> <dd> <a href="https://twitter.com/beepcat" target="_blank"> @beepcat </a> </dd> </dl> </dd> <dt>Author</dt> <dd> <img src="https://fly.io/static/images/shaun.jpg" alt="Shaun Davis" srcset=""/> <dl> <dt>Name</dt> <dd> Shaun Davis </dd> <dt>Twitter</dt> <dd> <a href="https://twitter.com/davissp14" target="_blank"> @davissp14 </a> </dd> </dl> </dd> </dl> <section> <figure> <img src="https://fly.io/blog/2022-11-29/keepers-proxies-cover.jpg" alt="A robot emits an instruction, in the form of exclamation points, to a set of other robots holding stacks of cartoon disk platters. One replies with checkmarks. A figure on a hill in the background holds a sign with an arrow pointing right. Airships fill the sky."/> <figcaption> <span>Image by</span> <svg role="img" style="pointer-events: none; width: 17px; height: 17px;" viewBox="0 0 20 20" fill="currentColor" fill-rule="evenodd"> <g buffered-rendering="static"> <path fill-rule="evenodd" d="M1 8a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 018.07 3h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0016.07 6H17a2 2 0 012 2v7a2 2 0 01-2 2H3a2 2 0 01-2-2V8zm13.5 3a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0zM10 14a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd"></path> </g> </svg> Annie Ruygt </figcaption> </figure> <p> Like many public cloud platforms, Fly.io has a database offering. Where AWS has RDS, and Heroku has Heroku Postgres, Fly.io has Fly Postgres. You can spin up a Postgres database, or a whole cluster, with just a couple of commands. <a href="https://fly.io/docs/speedrun/">Sign up for Fly.io</a> and launch a full-stack app in minutes!</p><p>Fly.io is an ambivalent database provider—one might even use the word &#34;reluctant&#34;. The reasons for that are interesting, as is the way Fly Postgres works. When we relate this in conversations online, people are often surprised. So we thought we&#39;d take a few minutes to lay out where we&#39;re coming from with databases.</p> <p>We started Fly.io without durable storage. We were a platform for &#34;edge apps&#34;, which is the very 2019 notion of carving slices off of big applications, leaving the bulk running in Northern Virginia, and running the slices on small machines all around the world. In an &#34;edge app&#34; world, not having durable storage makes some sense: the real data store is in <code>us-east-1</code>, and the slices are chosen carefully to speed the whole app up (by caching, running an ML model, caching, serving images, and caching).</p> <p>Of course, people asked for databases from day one. But, on days one through three hundred thirty-one, we held the line.</p> <p>Somewhere around day fifteen, we grew out of the idea of building a platform exclusively for edge apps, and started looking for ways to get whole big crazy things running on Fly.io. We flirted with the idea of investing in a platform built-in database. We rolled out an (ultimately cursed) shared Redis. We even toyed with the idea of offering a managed <a href="https://github.com/cockroachdb/cockroach">CockroachDB</a>; like us, Cockroach is designed to run globally distributed.</p> <p>And then we snapped out of it. Databases! Feh!</p> <p>Here&#39;s our 2020 reasoning, for posterity: just because we didn&#39;t offer durable storage on the platform didn&#39;t mean that apps running on Fly.io needed to be stateless. Rather, they just needed to use off-platform database services, like RDS, CrunchyData, or PlanetScale. Hooking globally distributed applications up to RDS was (and remains) something ordinary teams do all the time. What did we want to spend our time building? Another RDS, or the best platform ever for you to run stuff close to your users?</p> <p>By day two hundred and ninety or so, the appeal of articulating and re-articulating the logic of a stateless global platform for stateful global apps began to wear off. RDS! Feh! Somewhere around then, Jerome and Steve figured out LVM2, <a href="https://fly.io/blog/persistent-storage-and-fast-remote-builds/">gave all our apps attached disk storage</a>, and killed off the stateless platform talking point.</p> <p>Now, disk storage is just one of the puzzle pieces for giving apps a reliable backing store. Storage capabilities or not, we still didn&#39;t want to be in the business of replicating all of RDS. So we devised a cunning plan: Build the platform out so it can run a database app, build a friendly database app for customers to deploy on it, and add some convenience commands to deploy and manage the app.</p> <p>We wouldn&#39;t have a managed database.</p> <p>No, we have an automated database.</p> <p>Postgres is a good database for this. It&#39;s familiar and just works with the migration tools baked into full-stack frameworks.</p> <p>In January 2021, we <a href="https://community.fly.io/t/early-look-postgresql-on-fly-we-want-your-opinions/537/18">soft-launched</a> a <code>fly pg create</code> command that would deploy an automagically configured two-node Postgres cluster complete with metrics, health checks, and alerts. (The alerts were as cursed as our shared Redis.) This was a big-deal effort for us. Back in 2020, we were really small. Almost everyone here had a hand in it.</p> <p>When Shaun arrived at Fly.io later that year, he took over the job of making Fly Postgres more reliable and more convenient to manage—still in hard mode: developing and shipping features that make the platform better for apps <em>like</em> Fly Postgres, and making Fly Postgres plug into those.</p> <p>This post is mostly ancient history! Shaun&#39;s no longer a team of one, and lots has happened since this post should have been written and shipped. Everything still holds; it&#39;s just more and better now.</p> <h2 id="postgres-is-really-cool-all-by-itself"><a href="#postgres-is-really-cool-all-by-itself" aria-label="Anchor"></a>Postgres Is Really Cool All by Itself</h2><p>Here&#39;s a way you can run Postgres on Fly.io: point <code>fly launch</code> at the latest official <a href="https://hub.docker.com/_/postgres">Postgres Docker image</a>. Remove the default services in <code>fly.toml</code>, since this isn&#39;t a public app. Provision and mount a volume. Store <code>POSTGRES_PASSWORD</code> as a Fly Secret. Deploy.</p> <p>(Then <code>fly ssh</code> in and create a database and user for your app.)</p> <p>If you&#39;ll only ever want this one instance, this is pretty good. If anything happens to your lonely node, though, your Postgres service—and so, your app—is down (and you may have lost data).</p> <p>Here&#39;s a better setup: one primary, or leader, instance that deals with all the requests, and one replica instance nearby (but preferably on different hardware!) that stays quietly up to date with the latest transactions. And if the leader goes down, you want that replica to take over automatically. Then you have what you can call a high-availability (HA) cluster.</p> <p>Postgres has a lot of levers and buttons built right in. You can deploy two Postgres VMs configured so one&#39;s a writable leader and the other is a standby replica staying up to date by <a href="https://www.postgresql.org/docs/current/warm-standby.html">asynchronous streaming replication</a>.</p> <p>What Postgres itself doesn&#39;t have is a way to adapt cluster configuration on the fly. It can&#39;t notify a replica that the primary has failed and it should take over, and it certainly can&#39;t independently elect a new leader if there&#39;s more than one eligible replica that could take over. Something else has to manipulate the Postgres controls to get HA clustering behaviour.</p> <p>That&#39;s where <a href="https://github.com/sorintlab/stolon">Stolon</a> comes in.</p> <div> <h3 id="postgres-wal-and-streaming-replication"><a href="#postgres-wal-and-streaming-replication" aria-label="Anchor"></a>Postgres, WAL, and Streaming Replication</h3><p><a href="https://www.postgresql.org/docs/current/wal-intro.html">Write-Ahead Logging</a> (WAL): Before a transaction is applied to tables and indexes on the primary (or only) instance, it&#39;s written to nonvolatile storage, in the Write-Ahead Log. This means you can afford not to write changes to every affected data file on disk after every single transaction; if data pages in memory are lost, they can be reconstructed by replaying transactions from the WAL.</p> <p><a href="https://www.postgresql.org/docs/current/warm-standby.html#STREAMING-REPLICATION">Postgres streaming replication</a> sends each WAL record along to the replica right after the transaction is committed on the leader. As the record is received, it&#39;s replayed to bring the replica up to date.</p> <p>We have some heartier, SQLite-flavoured WAL content <a href="https://fly.io/blog/sqlite-internals-wal/">around here somewhere</a>.</p> </div><h2 id="clustering-with-stolon"><a href="#clustering-with-stolon" aria-label="Anchor"></a>Clustering With Stolon</h2><p>Stolon is a Golang Postgres manager. We chose it for a few reasons: it&#39;s open source, it&#39;s easy to build and embed in a Docker image, and it can use Consul as its backend KV store (we&#39;re good at Consul).</p> <p>We spun up a Consul cluster for Fly Postgres to use, and since it was there, we also <a href="https://community.fly.io/t/sneak-peak-global-lock-service/554">made it available for any Fly app that wanted a locking service.</a></p> <p>Stolon comes with three components that run alongside Postgres in each instance&#39;s VM: a sentinel, a keeper, and a proxy.</p> <ul> <li>The lead sentinel keeps an eye on the cluster state as recorded by keepers in the Consul store, and decides if leadership needs to change. </li><li>Keepers each manage their local Postgres instance, making sure it behaves as a writable leader or a read-only replica (as dictated by the leader sentinel), and update Consul with their latest state. </li><li>Proxies are there to route all incoming client connections to the current leader, as recorded in the store (and only if it&#39;s healthy). </li></ul> <p>If the leader instance fails, the proxies start dropping all connections and Stolon elects a new leader, using Consul to lock the database in the meantime. If both (all) your instances fail, the database is unavailable until one or the other recovers. New connections go to the new leader as soon as it&#39;s ready, without rebooting clients or changing their config.</p> <p>If you’ve ever received a late-night email from Heroku saying your DB was replaced, you know why this is awesome.</p> <h2 id="stolon-consul-intensifies"><a href="#stolon-consul-intensifies" aria-label="Anchor"></a>Stolon + Consul Intensifies</h2><p>Stolon is chatty as hell with Consul, and this can be a problem.</p> <p>Keepers, sentinels, and proxies do all their communication via the Consul leader. If a Stolon component can&#39;t reach Consul, it repeats its request until it can. A single flapping Stolon cluster, early on, could saturate our Consul connections.</p> <p>Meanwhile, if a Stolon proxy can&#39;t reach Consul, it throws its hands in the air and drops all client connections until it can. We had several Postgres outages traceable to either Consul falling over or faraway Postgres nodes not being able to connect to it.</p> <p>The more Postgres clusters people spun up, the more of a problem this was.</p> <h2 id="less-consul-with-haproxy"><a href="#less-consul-with-haproxy" aria-label="Anchor"></a>Less Consul With HAProxy</h2><p>The Stolon proxy relies on Consul to know which instance to route connections to.</p> <p>But Consul isn&#39;t the intrinsic authority on who the leader is: Postgres on every instance knows its own role. If we can replace the Stolon proxy with one that can just ask the nodes who&#39;s leader, that&#39;s less load on our shared Consul cluster, and if there&#39;s trouble with Consul there&#39;s one component fewer to freak out about it.</p> <p>It&#39;s <a href="https://github.com/sorintlab/stolon/blob/master/doc/faq.md#why-didnt-you-use-an-already-existing-proxy-like-haproxy">not exactly supported</a>, but it&#39;s possible to use HAProxy with Stolon, and we did.</p> <p>Here&#39;s how we&#39;ve got HAProxy set up:</p> <ul> <li>HAProxy listens on port 5432 on all Fly Postgres instances for read or write requests. </li><li>When you create a Fly Postgres cluster using <code>fly postgres create</code>, it&#39;s configured with a <code>PRIMARY_REGION</code> environment variable. HAProxy gets the list of candidates from our internal DNS server using <code>$PRIMARY_REGION.$FLY_APP_NAME.internal</code>. </li><li>Then, every two seconds, it asks the HTTP health check server on each of these nodes for its role. </li><li>HAProxy marks the replicas as unhealthy and removes them from its list; it won&#39;t pass any requests to them. </li><li>If the incumbent leader fails its role check by returning &#34;replica&#34; or &#34;offline&#34;, or not responding at all, HAProxy drains connections from it while Stolon sorts out a new leader. </li><li>If there&#39;s a healthy leader, HAProxy routes all requests to it, on port 5433 (where the keeper has told actual Postgres to listen). </li></ul> <p>We also added Consul clusters in a couple more regions. This spreads the burden on Consul, but crucially, it puts Consul clusters close to people&#39;s primary Postgres VMs. Network flakiness between Stolon and Consul breaks Stolon. The internet is flaky. The less internet we can span, the happier Stolon is.</p> <p>Stolon and Consul are still intense: we&#39;ve been adding new Consul clusters ever since to keep up.</p> <h2 id="here-s-the-fly-postgres-app"><a href="#here-s-the-fly-postgres-app" aria-label="Anchor"></a>Here&#39;s the Fly Postgres App</h2><p>We&#39;re running a few things on each Fly Postgres VM:</p> <ul> <li>Stolon keeper </li><li>Stolon sentinel </li><li>HAProxy </li><li>Postgres </li><li>a cornucopia of internal commands and health checks </li><li>HTTP server to serve the command and health check endpoints </li><li>Golang supervisor code </li></ul> <p>This is a pretty deluxe Postgres cluster app. You can shell into a running instance and add a database, restart the PG process, trigger a failover, run stolonctl commands directly, and more.</p> <p>Our Golang supervisor, flypg, glues the other processes together and does nice things like try to recover from individual process crashes before giving up and letting the whole VM get rescheduled.</p> <p><a href="https://www.postgresql.org/">All</a> <a href="https://github.com/sorintlab/stolon">the</a> <a href="https://docs.haproxy.org/2.6/intro.html">parts</a> are open source; you can <a href="https://github.com/fly-apps/postgres-ha">fork</a> it and add <a href="https://www.pgbouncer.org/">PgBouncer</a> or whatever.</p> <p>So that&#39;s the Fly Postgres app. You can deploy it with <code>fly launch</code> like any Fly app, straight from a clone of the <a href="https://github.com/fly-apps/postgres-ha">postgres-ha repo</a>. It is faster to deploy the built <a href="https://hub.docker.com/r/flyio/postgres/tags">image</a> straight from Docker Hub, and the image has version metadata you can use to upgrade later.</p> <p>The following will create a 2-instance HA cluster that apps on your org&#39;s internal WireGuard network can connect to:</p> <ol> <li>Copy fly.toml from the postgres-ha repo </li><li>Edit fly.toml to set the <code>PRIMARY_REGION</code> environment variable to match the region you&#39;re about to deploy to </li><li><code>fly apps create</code> a new app </li><li>Create a volume </li><li>Set passwords as secrets on the newly-created app: <code>SU_PASSWORD</code>, <code>REPL_PASSWORD</code>, and <code>OPERATOR_PASSWORD</code> </li><li><code>fly deploy --image=flyio/postgres:14</code> </li><li>Create a second volume </li><li>Add a replica by scaling up to 2 instances </li></ol> <p>Then, to let an app use this Postgres:</p> <ol> <li>Use aforementioned in-VM commands on the Postgres leader to create a new user and database for the consuming app (you find the leader by running <code>fly ssh console -C &#34;pg-role&#34; -s</code> on each instance until you hit the one with the <code>&#34;leader&#34;</code> role) </li><li>Then set a connection string, containing the new user and password, as a <code>DATABASE_URL</code> secret on the consuming app. </li></ol> <p>Now I don&#39;t know if I made that look complicated or simple!</p> <p>It&#39;s simple for what you get. Every instance of your postgres-ha app is a magical cluster building block! Add an instance and it automatically becomes a member of the cluster and starts replicating from the leader. If it&#39;s in the <code>PRIMARY_REGION</code>, it&#39;s eligible to participate in leader elections. You can add nodes in other regions, too; they can&#39;t become leader, but you can read from them directly on port 5433. It&#39;s all inside the app. <a href="https://fly.io/blog/globally-distributed-postgres/">Get a bit fancier with the Fly-Replay header</a> in your consuming app, and you can do your reads from the closest instance and send your writes to the primary region.</p> <p>But yeah, this isn&#39;t <em>quite</em> the Fly Postgres experience. Since we expect lots of people to deploy this exact app, it was reasonable to bundle up that mild cluster-creation rigamarole into a <code>fly pg create</code> command, which is much like <code>fly launch</code> with one of our more mature framework launchers. There are similar <a href="https://fly.io/docs/flyctl/postgres/">nuggets of flyctl convenience</a> for managing your <code>fly pg create</code>d database cluster.</p> <figure> <figcaption> <p> Use it in something awesome!</p><p><a href="https://fly.io/docs/speedrun/"> Launch a full-stack app now  <span>→</span> </a></p> </figcaption><p><img src="https://fly.io/static/images/cta-kitty.jpg" srcset="/static/images/cta-kitty@2x.jpg 2x" alt=""/></p></figure><h2 id="an-observation"><a href="#an-observation" aria-label="Anchor"></a>An Observation</h2><p>We&#39;ve mentioned that continual reliance on Consul is something of an Achilles&#39; heel for Stolon-managed clusters. It&#39;s not unique to Stolon and Consul, but a matter of needing a separate backend store for cluster state: in return for high availability and Borg-like assimilation of new instances, we accept an additional failure mode.</p> <p>If you&#39;re running a single node, and you&#39;re never going to add another one to make a cluster, there&#39;s no upside to this high-availability machinery. A lone node is more reliable without any of it.</p> <p>But quite a lot of people do run Fly Postgres on a single instance (just for development, right??). It&#39;s still automated, and you still get the knowledge that you&#39;re in good company and deploying a maintained app.</p> <p>The great thing is: if you really want the simpler setup, you can just deploy your own Postgres app. It&#39;s all apps on Fly.io!</p> <h2 id="snapshots-and-restores"><a href="#snapshots-and-restores" aria-label="Anchor"></a>Snapshots and Restores</h2><p>You can, and should, make your own backups of data that&#39;s important to you. That being said, a restore-your-database feature is guaranteed to make people&#39;s lives easier.</p> <p>If you&#39;re shipping Postgres as a Service and don&#39;t care about the underlying infrastructure, you&#39;ll do Postgres native backups, copy data files and the WAL to object storage somewhere, then restore from those. Stolon will manage this for you.</p> <p>But if you&#39;re building infrastructure that can run databases, this doesn&#39;t move you forward: every database has its own mechanism for backing up individual files. Some require data dumps using specific tools, some let you copy files out of the file system, etc.</p> <p>Volumes, which hold users&#39; persistent data—for Postgres, SQLite, or whatever—are logical volumes on SSDs physically installed in our servers. We have low-level block device powers and the ability to take consistent, block-level snapshots of a disk.</p> <p>So that&#39;s how we back up a Postgres database: by periodically grabbing a point-in-time version of the raw block device it&#39;s on. You recover a database by restoring this to an entirely new block device and deploying a Postgres instance to use it.</p> <p>Conveniently, that approach works for pretty much anything that writes to a file system, solving backups for anything you want to run on Fly.io.</p> <p>Once we got user-facing snapshot restores working for Postgres apps, we could generalize that to Volumes at large. Which is good, because people run every database you can think of on Fly.io.</p> <p>This is a good example of &#34;Postgres&#34; work that was actually platform work with an elephant face taped on. Like persistent storage itself, shared Consul, our crap health-check alerts, image version updates, and countless &#34;how should flyctl and the platform behave&#34; minutiae.</p> <h2 id="back-to-fly-postgres-vs-managed-databases"><a href="#back-to-fly-postgres-vs-managed-databases" aria-label="Anchor"></a>Back to Fly Postgres vs. Managed Databases</h2><p>So Fly Postgres is an app, not a database service. This is not a bummer: it&#39;s fascinating, I tell you! Working on this one app helps us work through what we want the platform to offer to apps and how to implement that. It&#39;s an intrinsic part of the process of building a platform you could run <em>your</em> fully managed database service on.</p> <p>Meanwhile, we don&#39;t blame you if you&#39;d actually prefer a boring managed database over our fascinating app. We love boring! Boring can be the best experience! We think the best solution to this is to partner with service providers to do integrations that really nail the Postgres, or MySQL, or Redis(!), or whatever, UX on Fly.io. After all, there&#39;s no single best database for everyone.</p> <p>And for all that, heading for 2023, Fly Postgres is doing the job for lots of apps! Automated Postgres turned out more useful than we&#39;d have predicted.</p>  </section> <dl> <dt> Previous post  ↓ </dt> <dd> <a href="https://fly.io/blog/replicache-machines-demo/"> Real-Time Collaboration with Replicache and Fly-Replay </a> </dd> </dl> </article></div>
  </body>
</html>
