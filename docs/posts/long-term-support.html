<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.sqlite.org/lts.html">Original</a>
    <h1>Long Term Support</h1>
    
    <div id="readability-page-1" class="page"><div>






<p>
The intent of the developers is to support SQLite through
the year 2050.

</p><p>
At this writing, 2050 is still 25 years in the future.
Nobody knows what will happen in that time, and we cannot
absolutely promise that SQLite will be viable or useful that
far out.
But we can promise this: we plan as if we will be
supporting SQLite until 2050.
That long-term outlook affects our
decisions in important ways.

</p><ul>
<li><p>
<b>Cross-platform Code</b> →
SQLite runs on any platform with an 8-bit byte,
two&#39;s complement 32-bit and 64-bit integers, 
and a C compiler.  It is actively
tested on all currently popular CPUs and operating
systems.
The extreme portability of the SQLite code and file
format will help it remain viable on future platforms.

</p></li><li><p>
<b>Stable, Cross-platform Database Files</b> →
SQLite <a href="https://www.sqlite.org/fileformat2.html">database files</a> are bit-for-bit identical on
32-bit, 64-bit, big-endian, and little-endian platforms.  You
can copy an SQLite database file from one system to another
without having to translate or convert the database.
Furthermore, the file format is well documented and stable.
Database files created today will be readable and writable by
future versions of SQLite decades in the future.

</p></li><li><p>
<b><a href="https://www.sqlite.org/testing.html">Aviation-grade testing</a></b> →
Every machine-code branch instruction is tested in both
directions.  Multiple times.  On multiple platforms and with
multiple compilers.  This helps make the code robust for
future migrations.  The intense testing also means that new
developers can make experimental enhancements to SQLite and,
assuming legacy tests all pass, be reasonably sure that the
enhancement does not break legacy.

</p></li><li><p>
<b>Extensive, detailed documentation</b> →
SQLite has candid, developer-friendly,
and open-source documentation.  Docs are written by and
for programmers.
(A few examples:
<a href="https://www.sqlite.org/arch.html">[1]</a>
<a href="https://www.sqlite.org/fileformat.html">[2]</a>
<a href="https://www.sqlite.org/queryplanner.html">[3]</a>
<a href="https://www.sqlite.org/opcode.html">[4]</a>
<a href="https://www.sqlite.org/compile.html">[5]</a>
<a href="https://www.sqlite.org/malloc.html">[6]</a>
<a href="https://www.sqlite.org/debugging.html">[7]</a>
<a href="https://www.sqlite.org/howtocorrupt.html">[8]</a>)
The extensive documentation helps new developers
come up to speed on SQLite very quickly.

</p></li><li><p>
<b>Heavily commented source code</b> →
The SQLite source code is over 35% comment.  Not boiler-plate
comments, but useful comments that explain the meaning of variables
and objects and the intent of methods and procedures.  
The code is designed
to be accessible to new programmers and maintainable over a span
of decades.

</p></li><li><p>
<b>Disaster planning</b> →
Every byte of source-code history for SQLite is cryptographically
protected and is automatically replicated to multiple
geographically separated servers, in datacenters 
owned by different companies.
Thousands of additional clones exist on private servers around the
world.
The primary developers of SQLite live in different regions of the world.
SQLite can survive a continental catastrophe.

</p></li><li><p>
<b>Old school</b> →
Nobody is completely immune to trends and fads, but the SQLite
developers work hard to avoid being sucked into the latest programming
fashion.  Our aim is to produce timeless code that will be
readable, understandable, and maintainable by programmers 
who have not yet been born.
</p></li></ul>

<p>
In addition to &#34;supporting&#34; SQLite through the year 2050, the developers
also promise to keep the SQLite 
<a href="https://www.sqlite.org/cintro.html">C-language API</a> and <a href="https://www.sqlite.org/fileformat2.html">on-disk format</a> 
fully backwards compatible.
This means that application written to use SQLite today should be able to
link against and use future versions of SQLite released decades in the
future.

</p><p>
Our goal is to make the content you store in SQLite today as 
easily accessible to your grandchildren as it is to you.

</p><p>
<b>Update on 2018-05-31:</b>
Our goal of supporting SQLite long-term have apparently come to the
notice of the preservationist at the 
<a href="https://www.loc.gov">US Library Of Congress</a> who have identified
SQLite as a <a href="https://www.sqlite.org/locrsf.html">recommended storage format</a> for the preservation of
digital content.
</p><p><small><i>This page last modified on  <a href="https://sqlite.org/docsrc/honeypot" id="mtimelink" data-href="https://sqlite.org/docsrc/finfo/pages/lts.in?m=22831a019f">2025-05-31 13:08:22</a> UTC </i></small></p>

</div></div>
  </body>
</html>
