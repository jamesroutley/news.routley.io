<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cursor.com/blog/scaling-agents">Original</a>
    <h1>Scaling long-running autonomous coding</h1>
    
    <div id="readability-page-1" class="page"><div><p>We&#39;ve been experimenting with running coding agents autonomously for weeks.</p>
<p>Our goal is to understand how far we can push the frontier of agentic coding for projects that typically take human teams months to complete.</p>
<p>This post describes what we&#39;ve learned from running hundreds of concurrent agents on a single project, coordinating their work, and watching them write over a million lines of code and trillions of tokens.</p>
<h2 id="the-limits-of-a-single-agent"><a href="#the-limits-of-a-single-agent" aria-label="Link to this section"><span aria-hidden="true">#</span></a>The limits of a single agent</h2>
<p>Today&#39;s agents work well for focused tasks, but are slow for complex projects. The natural next step is to run multiple agents in parallel, but figuring out how to coordinate them is challenging.</p>
<p>Our first instinct was that planning ahead would be too rigid. The path through a large project is ambiguous, and the right division of work isn&#39;t obvious at the start. We began with dynamic coordination, where agents decide what to do based on what others are currently doing.</p>
<h2 id="learning-to-coordinate"><a href="#learning-to-coordinate" aria-label="Link to this section"><span aria-hidden="true">#</span></a>Learning to coordinate</h2>
<p>Our initial approach gave agents equal status and let them self-coordinate through a shared file. Each agent would check what others were doing, claim a task, and update its status. To prevent two agents from grabbing the same task, we used a locking mechanism.</p>
<p>This failed in interesting ways:</p>
<ol>
<li>
<p>Agents would hold locks for too long, or forget to release them entirely. Even when locking worked correctly, it became a bottleneck. Twenty agents would slow down to the effective throughput of two or three, with most time spent waiting.</p>
</li>
<li>
<p>The system was brittle: agents could fail while holding locks, try to acquire locks they already held, or update the coordination file without acquiring the lock at all.</p>
</li>
</ol>
<p>We tried replacing locks with optimistic concurrency control. Agents could read state freely, but writes would fail if the state had changed since they last read it. This was simpler and more robust, but there were still deeper problems.</p>
<p>With no hierarchy, agents became risk-averse. They avoided difficult tasks and made small, safe changes instead. No agent took responsibility for hard problems or end-to-end implementation. This lead to work churning for long periods of time without progress.</p>
<h2 id="planners-and-workers"><a href="#planners-and-workers" aria-label="Link to this section"><span aria-hidden="true">#</span></a>Planners and workers</h2>
<p>Our next approach was to separate roles. Instead of a flat structure where every agent does everything, we created a pipeline with distinct responsibilities.</p>
<ul>
<li>
<p><strong>Planners</strong> continuously explore the codebase and create tasks. They can spawn sub-planners for specific areas, making planning itself parallel and recursive.</p>
</li>
<li>
<p><strong>Workers</strong> pick up tasks and focus entirely on completing them. They don&#39;t coordinate with other workers or worry about the big picture. They just grind on their assigned task until it&#39;s done, then push their changes.</p>
</li>
</ul>
<p>At the end of each cycle, a judge agent determined whether to continue, then the next iteration would start fresh. This solved most of our coordination problems and let us scale to very large projects without any single agent getting tunnel vision.</p>
<h2 id="running-for-weeks"><a href="#running-for-weeks" aria-label="Link to this section"><span aria-hidden="true">#</span></a>Running for weeks</h2>
<p>To test this system, we pointed it at an ambitious goal: building a web browser from scratch. The agents ran for close to a week, writing over 1 million lines of code across 1,000 files. You can explore the <a href="https://github.com/wilsonzlin/fastrender" rel="noopener noreferrer" target="_blank">source code on GitHub</a>.</p>
<p>Despite the codebase size, new agents can still understand it and make meaningful progress. Hundreds of workers run concurrently, pushing to the same branch with minimal conflicts.</p>
<figure><div></div></figure>
<p>While it might seem like a simple screenshot, building a browser from scratch is extremely difficult.</p>
<p>Another experiment was doing an in-place migration of Solid to React in the Cursor codebase. It took over 3 weeks with +266K/-193K edits. As we&#39;ve started to test the changes, we do believe it&#39;s possible to merge this change.</p>
<figure><p><img alt="Pull request showing Solid to React migration" loading="lazy" width="800" height="450" decoding="async" data-nimg="1" srcset="/marketing-static/_next/image?url=https%3A%2F%2Fptht05hbb1ssoooe.public.blob.vercel-storage.com%2Fassets%2Fblog%2Flong-running-agents-pr.png&amp;w=828&amp;q=70 1x, /marketing-static/_next/image?url=https%3A%2F%2Fptht05hbb1ssoooe.public.blob.vercel-storage.com%2Fassets%2Fblog%2Flong-running-agents-pr.png&amp;w=1920&amp;q=70 2x" src="https://cursor.com/marketing-static/_next/image?url=https%3A%2F%2Fptht05hbb1ssoooe.public.blob.vercel-storage.com%2Fassets%2Fblog%2Flong-running-agents-pr.png&amp;w=1920&amp;q=70"/></p></figure>
<p>Another experiment was to improve an upcoming product. A long-running agent made video rendering 25x faster with an efficient Rust version. It also added support to zoom and pan smoothly with natural spring transitions and motion blurs, following the cursor. This code was merged and will be in production soon.</p>
<p>We have a few other interesting examples still running:</p>
<ul>
<li><a href="https://github.com/wilson-anysphere/indonesia" rel="noopener noreferrer" target="_blank">Java LSP</a>: 7.4K commits, 550K LoC</li>
<li><a href="https://github.com/wilsonzlin/aero" rel="noopener noreferrer" target="_blank">Windows 7 emulator</a>: 14.6K commits, 1.2M LoC</li>
<li><a href="https://github.com/wilson-anysphere/formula" rel="noopener noreferrer" target="_blank">Excel</a>: 12K commits, 1.6M LoC</li>
</ul>
<h2 id="what-weve-learned"><a href="#what-weve-learned" aria-label="Link to this section"><span aria-hidden="true">#</span></a>What we&#39;ve learned</h2>
<p>We&#39;ve deployed billions of tokens across these agents toward a single goal. The system isn&#39;t perfectly efficient, but it&#39;s far more effective than we expected.</p>
<p>Model choice matters for extremely long-running tasks. We found that GPT-5.2 models are much better at extended autonomous work: following instructions, keeping focus, avoiding drift, and implementing things precisely and completely.</p>
<p>Opus 4.5 tends to stop earlier and take shortcuts when convenient, yielding back control quickly. We also found that different models excel at different roles. GPT-5.2 is a better planner than GPT-5.1-codex, even though the latter is trained specifically for coding. We now use the model best suited for each role rather than one universal model.</p>
<p>Many of our improvements came from removing complexity rather than adding it. We initially built an integrator role for quality control and conflict resolution, but found it created more bottlenecks than it solved. Workers were already capable of handling conflicts themselves.</p>
<p>The best system is often simpler than you&#39;d expect. We initially tried to model systems from distributed computing and organizational design. However, not all of them work for agents.</p>
<p>The right amount of structure is somewhere in the middle. Too little structure and agents conflict, duplicate work, and drift. Too much structure creates fragility.</p>
<p>A surprising amount of the system&#39;s behavior comes down to how we prompt the agents. Getting them to coordinate well, avoid pathological behaviors, and maintain focus over long periods required extensive experimentation. The harness and models matter, but the prompts matter more.</p>
<h2 id="whats-next"><a href="#whats-next" aria-label="Link to this section"><span aria-hidden="true">#</span></a>What&#39;s next</h2>
<p>Multi-agent coordination remains a hard problem. Our current system works, but we&#39;re nowhere near optimal. Planners should wake up when their tasks complete to plan the next step. Agents occasionally run for far too long. We still need periodic fresh starts to combat drift and tunnel vision.</p>
<p>But the core question, can we scale autonomous coding by throwing more agents at a problem, has a more optimistic answer than we expected. Hundreds of agents can work together on a single codebase for weeks, making real progress on ambitious projects.</p>
<p>The techniques we&#39;re developing here will eventually inform Cursor&#39;s agent capabilities. If you&#39;re interested in working on the hardest problems in AI-assisted software development, we&#39;d love to hear from you at <a href="mailto:hiring@cursor.com" rel="noopener noreferrer" target="_blank">hiring@cursor.com</a>.</p></div></div>
  </body>
</html>
