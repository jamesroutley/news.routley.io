<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://venki.dev/notes/google-gemini-is-bad">Original</a>
    <h1>Google Gemini has the worst LLM API</h1>
    
    <div id="readability-page-1" class="page"><div><main><p>Google is on the frontier with recent Gemini releases. They now have:</p><ul><li>A competitive coding &amp; reasoning model (Gemini-2.5-pro)</li></ul><ul><li>The longest-context frontier models (1 or 2M context - OAI just achieved parity since GPT-4.1 has a 1M context too)</li></ul><ul><li>The best frontier audio, video &amp; document multimodal models. (Some others support audio but at a much higher cost)</li></ul><ul><li>The best long-context fine-tuning offering (Gemini-2.0-flash can be tuned at 131k, <a target="_blank" rel="noopener noreferrer" href="https://venki.dev/notes/llm-fine-tuning">others top out earlier</a>)</li></ul><ul><li>The best multimodal fine-tuning offering (Gemini-2.0-flash can be tuned with audio, image &amp; documents)</li></ul><p>And yet these models hide behind the poorest developer experience in the market.</p><p><b>1. The Gemini API is available in two places, with differing functionality</b></p><p>You can use Gemini via either Vertex AI, or Google AI Studio. Google Developer Advocates will tell you: if you’re a startup or hobbyist, you should use Google AI Studio, as Vertex AI is more enterprise-focused.</p><p>That makes sense: it parallels the distinction between the OpenAI API and the Azure OpenAI API. Or Anthropic API vs Amazon Bedrock Claude. </p><p>It’s not unusual to offer an enterprise API with stronger security or compliance guarantees, but slower feature roll-out.</p><figure><p><img src="https://www.notion.so/image/attachment%3Ac43c790e-5add-4226-b5a9-6ea8779f3470%3Aimage.png%3FspaceId%3Dd3658b9a-e072-4310-bfa2-ac54e0c811ae?table=block&amp;id=1e57c5ab-9bae-800b-a39e-f8c368cf7643&amp;cache=v2" alt="notion image" loading="lazy" decoding="async"/></p></figure><p>But unfortunately that comparison doesn’t hold. Functionality is released to AI Studio &amp; Vertex AI at different times, and some functionality never comes to AI Studio. </p><p>This often becomes a dealbreaker and you end up needing to juggle both options as a startup.</p><p><b>2. The documentation is bad</b></p><p>There are two documentation sites for AI Studio vs Vertex. You will land on the wrong one.</p><p>This gets worse due to the non-equivalent functionality.  For example, AI Studio’s docs may lead you to believe that Google only supports fine-tuning for Gemini 1.5. But, Vertex AI supports fine-tuning for Gemini 2.0, it’s just that AI Studio does not.</p><p>In general, the docs are worse than most. Much of the AI Studio docs still refer to Gemini 1.5, which is now deprecated &amp; make it generally unclear whether Gemini 2.5 still supports the same features. </p><p>The API is also the quirkiest around. For example, there are “safety settings” that reject certain requests by default, but can be disabled. There is an OpenAI-compatible SDK for Google AI Studio (not for Vertex AI), but it doesn’t support multimodality. You should probably avoid it.</p><p><b>3. The Vertex AI SDK doesn’t support API key authentication</b></p><p>Most LLM providers use bearer authentication with an API key. Not Vertex AI SDK, you’re going to need to figure out their auth methods and the right way to store their credentials.json file in your secrets system. </p><p>This gets messier if you’re eg: using a router that lets you bring-your-own-key.</p><p><b>4. The official Vertex AI TS SDK can’t use fine-tuned models (!!)</b></p><p>Let’s say you go fine-tune a Gemini-2.0-Flash model with Vertex AI. </p><p>The process is a little more annoying than with OpenAI. </p><ul><li>You need to manually deploy an endpoint vs just training a model &amp; using it. </li></ul><ul><li>Naming the deployed endpoint anything but the default name seems to throw an error of “Internal error occurred. Contact Vertex AI”.</li></ul><ul><li>You get a less-readable 18-digit endpoint ID to call, instead of a readable model name with a configurable suffix. </li></ul><p>But - the biggest gotcha comes at the very end. You try swapping in your fine-tuned endpoint ID in your TypeScript SDK, and it just isn’t supported. </p><p>It’s not like the TS SDK offers a different function for fine-tuned models, to the best of my knowledge, it doesn’t support fine-tuned models at all. The best they can offer is a <a target="_blank" rel="noopener noreferrer" href="https://cloud.google.com/vertex-ai/generative-ai/docs/models/gemini-use-supervised-tuning#test_the_tuned_model_with_a_prompt">REST API</a>.</p><p>It’s in fact easier to use a fine-tuned Vertex AI model with a third-party router, such as the <a target="_blank" rel="noopener noreferrer" href="https://sdk.vercel.ai/docs/introduction">Vercel AI SDK.</a></p><p><b>5. The prefix caching offering is very developer-unfriendly</b></p><p>Prefix caching lets you reduce costs when the same prefix is re-used in multiple requests. Consider three API designs for prefix caching:</p><ol start="1"><li>The provider automatically caches &amp; reuses prefixes found in LLM completion requests.</li></ol><ol start="2"><li>The developer marks sections which should be cached in a LLM completion request, and the provider caches them &amp; reuses them in subsequent requests.</li></ol><ol start="3"><li>The developer sends prefixes to be cached to a separate API endpoint, receiving a cache ID. The developer then includes a cache ID with a request if that cache entry ought to be used, and then the provider uses that cached prefix.</li></ol><p>If you didn’t guess: 1 is OpenAI, 2 is Anthropic, and 3 is Gemini.</p><p>Setting up prefix caching can save you quite a bit - but for Gemini it’s a whole process of it’s own. The moment you’re dealing with large contexts that are dynamic but re-used, you need to build your own system to keep track of what caches correspond to what data.</p><p>Gemini caches also don’t have their TTL re-upped upon hit, so you need to manually call an API to keep the cache entry around for longer.</p><h3 data-id="1e57c5ab9bae80cdb0dbc7061224dcc4"><span><a href="#1e57c5ab9bae80cdb0dbc7061224dcc4" title="How to use Gemini anyways"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span>How to use Gemini anyways</span></span></h3><p>You likely still need to use Gemini. Their models are the cheapest long-context &amp; multi-modal models around.</p><p>You should probably start with Vertex AI and assume that it’ll be the main surface you use, but integrate with Google AI Studio as well, just in case.</p><p>You should use an LLM router to integrate with both Google AI Studio &amp; Vertex AI SDK, and also sidestep the APIs being unusual. </p><p><a target="_blank" rel="noopener noreferrer" href="https://sdk.vercel.ai/docs/introduction">Vercel AI SDK</a> is my default option, as it’s local &amp; maintained by Vercel. </p><div><p><a target="_blank" rel="noopener noreferrer" href="https://openrouter.ai/">OpenRouter</a> is cool, especially since they now offer to <a target="_blank" rel="noopener noreferrer" href="https://openrouter.ai/docs/features/prompt-caching#google-gemini">handle the Gemini prompt caching</a> for you too. But they charge a 5% markup.</p></div><p>Other notable options include LiteLLM, Helicone, Keywords</p><h3 data-id="1e57c5ab9bae80b4824dccee2cb62cba"><span><a href="#1e57c5ab9bae80b4824dccee2cb62cba" title="Appendix: Using fine-tuned Gemini models with the Vercel AI SDK"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span>Appendix: Using fine-tuned Gemini models with the Vercel AI SDK</span></span></h3><p>Vercel’s AI SDK still needs a little bit of patching to use a model fine-tuned via Vertex AI. Here’s how you do it:</p><pre><code>// Patch Vercel AI SDK

function patchedFetchForFinetune(
  requestInfo: RequestInfo | URL,
  requestInit?: RequestInit
): Promise&lt;Response&gt; {
  function patchString(str: string) {
    return str.replace(`/publishers/google/models`, `/endpoints`)
  }

  if (requestInfo instanceof URL) {
    let patchedUrl = new URL(requestInfo)
    patchedUrl.pathname = patchString(patchedUrl.pathname)
    return fetch(patchedUrl, requestInit)
  }
  if (requestInfo instanceof Request) {
    let patchedUrl = patchString(requestInfo.url)
    let patchedRequest = new Request(patchedUrl, requestInfo)
    return fetch(patchedRequest, requestInit)
  }
  if (typeof requestInfo === &#39;string&#39;) {
    let patchedUrl = patchString(requestInfo)
    return fetch(patchedUrl, requestInit)
  }
  // Should never happen
  throw new Error(&#39;Unexpected requestInfo type: &#39; + typeof requestInfo)
}

const vertexFinetuned = createVertex({
  project: VERTEX_PROJECT,
  location: VERTEX_LOCATION,
  fetch: patchedFetchForFinetune as unknown as typeof globalThis.fetch,
})

const model = vertexFinetuned(VERTEX_ENDPOINT_ID)</code></pre></main></div></div>
  </body>
</html>
