<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bagerbach.com/books/grokking-simplicity">Original</a>
    <h1>Grokking Simplicity: Taming complex software with functional thinking</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="what-is-functional-programming"><a href="https://bagerbach.com/books/grokking-simplicity#what-is-functional-programming"><span></span></a>What is functional programming?</h2>
<p>Functional programming is a programming paradigm that uses mathematical functions &amp; aims to avoid side effects by using pure functions.</p>
<p><strong>Side effects</strong> are anything a function does other than returning a value. For example:</p>
<ul>
<li>Sending an email</li>
<li>Reading a file</li>
<li>Blinking a light</li>
<li>Making a web request</li>
<li>Applying the brakes in a car</li>
</ul>
<p>Side effects can be problematic, as they occur every time the function is called. So if you need the return value, but not the side effect, you&#39;ll cause things to happen unintentionally.</p>
<p>Functional programmers try to avoid unnecessary side effects.</p>
<p><strong>Pure functions</strong> are functions that only depend on their arguments and have no side effects.
Given the same arguments, they produce the same return value. These can be considered <em>mathematical functions</em>, to distinguish them from language functions.</p>
<p>Functional programmers aim to use pure functions, as they are clearer and easier to control.</p>
<p>It&#39;s not true the functional programmers completely avoid side effects and only use pure functions. Otherwise, how would you ever get anything done?
We run our software to get side effects. We want to send emails, update databases, make web requests, etc.</p>
<p><strong>Functional thinking</strong> is the set of skills and ideas used by functional programmers to solve problems with software.</p>
<p><strong>This book presents:</strong></p>
<ol>
<li>Distinguishing actions, calculations, and data.</li>
<li>Using first-class abstractions.</li>
</ol>
<h2 id="actions-calculations-and-data"><a href="https://bagerbach.com/books/grokking-simplicity#actions-calculations-and-data"><span></span></a>Actions, calculations, and data</h2>
<p>We classify code into 3 categories.</p>
<ol>
<li><strong>Actions</strong>: depend on when they are called or how many times they are called. E.g. you wouldn&#39;t want to call a function that makes a web request twice unintentionally, that could be costly.</li>
<li><strong>Calculations</strong>: no matter how many times you call these or when you call them, given the same inputs, they&#39;ll give the same outputs.</li>
<li><strong>Data</strong> is simply raw data.</li>
</ol>
<p>You want to separate calculations from actions.</p>
<p>Actions have implicit inputs and outputs. E.g. reading / modifying global variables. Calculations do not have these.</p>
<p>You can often replace implicit inputs with arguments, and implicit outputs by return values.</p>
<p>This makes your code more testable, and you often increase code quality (more separation of concerns, better cohesion, etc.).</p>
<p><strong>Design is about pulling things apart.</strong> And a good way to do this is through functions. Functions can help us separate concerns.</p>
<p>We should aim for small, simple functions as they are easier to reuse. They make fewer assumptions overall, which is more maintainable.
They&#39;re also easier to maintain just because they have less code.
And they&#39;re easier to test. You just have to test one thing---because they do only one thing.</p>
<h2 id="stratified-design"><a href="https://bagerbach.com/books/grokking-simplicity#stratified-design"><span></span></a>Stratified design</h2>
<p>In stratified design, each layer builds on those beneath it.</p>
<p>Towards the top layers, changes occur frequently.
Towards the bottom layers, changes are seldom.
The main layers are business rules (top) → domain rules (mid) → tech stack (bot).</p>
<p>Business rules can change frequently, whereas the rules for the domain change less frequently.
And finally, the rules for the tech stack rarely changes... e.g. JS objects, which rarely change (not the object instances, but the concept of objects).</p>
<p>By having code that changes frequently on the top layer of our stratified design, we can move faster.
It&#39;s much slower &amp; harder to change code that other parts of the program rely on. Having to frequently change low-level aspects would mean moving very show.</p>
<p>The longer the arrow (dependency between layers) is (more layers between dependencies), the harder it is to change. If something on the top layer relies on something on the bottom layer directly, then the bottom layer code becomes very hard to change.</p>
<p>Testing the bottom layers is higher ROI than testing those at the top layers.</p>
<ol>
<li>Code at the top layers change frequently. The tests would have to change frequently, too, then.</li>
<li>Testing bottom-level code means every layer above becomes more reliable, because the bottom layer is more reliable. It&#39;s like having a solid base / foundation.</li>
</ol>
<p>Code at the bottom is more reusable as well. As you move further up, the code becomes increasingly more niche to particular business rules &amp; logic.</p>
<p>And code reuse is great because it saves time and money.</p>
<h3 id="pattern-1-straightforward-implementations"><a href="https://bagerbach.com/books/grokking-simplicity#pattern-1-straightforward-implementations"><span></span></a>Pattern 1: Straightforward implementations</h3>
<p>As noted previously, stratified design uses layers to distinguish between functionality.</p>
<p>The first pattern that is discussed for stratified design is <em>straightforward implementations</em>. An important principle to this pattern is to only call functions from similar layers of abstraction.
The presented example showed operations on a data structure (abstracted; e.g. <code>add_item()</code> to add items to the data structure) vs. language features (<code>for</code> loop, for example). These shouldn&#39;t be in the same function.
I think the point here is that you shouldn&#39;t have arrows from e.g. the business rules layer to the bottom layer. Arrows should only have length = 1 (or something).</p>
<p>Straightforward implementation means the problem the function signature presents is solved at the right level of detail in the function body. If there&#39;s too much detail, that&#39;s a code smell.</p>
<p>Correction on the arrow length: it should be that all arrows are of the same length, not necessarily length = 1.
When arrows of a layer are of the same length, you are working at the same level of detail across the layer you&#39;re zooming in on.</p>
<h3 id="pattern-2-abstraction-barrier"><a href="https://bagerbach.com/books/grokking-simplicity#pattern-2-abstraction-barrier"><span></span></a>Pattern 2: Abstraction barrier</h3>
<p>The second pattern is abstraction barrier. This is about hiding implementation details. They help us write higher-level code to free up mental capacity.</p>
<p>This is a layer of functions, acting as a barrier that hides the implementation, so you can forget about the lower-level details (e.g. data structures used, etc.).</p>
<p>Basically, provide a simple API that doesn&#39;t require knowledge of implementation details of the API internals.</p>
<h3 id="pattern-3-minimal-interface"><a href="https://bagerbach.com/books/grokking-simplicity#pattern-3-minimal-interface"><span></span></a>Pattern 3: Minimal interface</h3>
<p>This is about finding the minimal interface to cover the necessary operations for important business concepts.</p>
<p>Every other operation should be defined in terms of these.</p>
<h3 id="pattern-4-comfortable-layers"><a href="https://bagerbach.com/books/grokking-simplicity#pattern-4-comfortable-layers"><span></span></a>Pattern 4: Comfortable layers</h3>
<p>This is about investing time into getting the layers into a state that helps us deliver high quality software faster. Layers are not added without reason. They should feel <em>comfortable</em>.</p>
<p>But it&#39;s also about stopping when you feel comfortable. You <em>can</em> over-design. Optimize prematurely.
Spending too much time on this delays actual value-creating tasks for the business, and that&#39;s no good.
If you are comfortable working with the layers, you can relax. And when you, at some point, feel uncomfortable, you can start applying the patterns again. You&#39;re never at some ideal point &amp; stay there. It&#39;s like a bounded area you strive to stay within.</p>
<h2 id="immutability"><a href="https://bagerbach.com/books/grokking-simplicity#immutability"><span></span></a>Immutability</h2>
<h3 id="copy-on-write"><a href="https://bagerbach.com/books/grokking-simplicity#copy-on-write"><span></span></a>Copy-on-write</h3>
<p>Implementing copy-on-write operations can help with immutability.</p>
<p>E.g. for adding items to arrays: slice the array (to copy), push the item to the array copy, and return the copied array.</p>
<p>Then you avoid modifying the original.</p>
<p>The basic steps of implementing copy-on-write are:</p>
<ol>
<li>Make a copy</li>
<li>Modify copy as you like</li>
<li>Return copy</li>
</ol>
<p>Using copy-on-write, you convert write operation into read operations - you never modify the original data.</p>
<p>You can generalize most of these operations, so you don&#39;t have to implement copy &amp; return every time you wish to modify something.
Take for example this removeItems operation, which is the copy-on-write version of splice:</p>
<pre><code><span><span>function</span> <span>removeItems</span><span>(</span><span>array<span>,</span> idx<span>,</span> count</span><span>)</span> <span>{</span>
</span><span>    <span>const</span> copy <span>=</span> array<span>.</span><span>slice</span><span>(</span><span>)</span><span>;</span>
</span><span>    copy<span>.</span><span>splice</span><span>(</span>idx<span>,</span> count<span>)</span><span>;</span>
</span><span>    <span>return</span> copy<span>;</span>
</span><span><span>}</span>
</span></code></pre>
<p>How do you make something that both reads and writes copy-on-write?
Take <code>Array.shift</code> for example.
You can either split the function into read &amp; write, or you can return two values from the function.
The former is preferable.
<code>shift</code> shifts an array one to the left, i.e. it drops the 0 index element and then returns it. You can imitate the latter part of that operation by simply returning <code>array[0]</code>.
You can convert the dropping of the 0th element to copy-on-write quite trivially as well: make a copy, use <code>shift</code> on the copy, and then return the copy.</p>
<p>And this is what the copy-on-write <code>shift</code> operation returning two values would look like:</p>
<pre><code><span><span>function</span> <span>shift</span><span>(</span><span>array</span><span>)</span> <span>{</span>
</span><span>    <span>const</span> array_copy <span>=</span> array<span>.</span><span>slice</span><span>(</span><span>)</span><span>;</span>
</span><span>    <span>const</span> first <span>=</span> array_copy<span>.</span><span>shift</span><span>(</span><span>)</span><span>;</span>
</span><span>    <span>return</span> <span>{</span>first<span>,</span> <span>array</span><span>:</span> array_copy<span>}</span><span>;</span>
</span><span><span>}</span>
</span></code></pre>
<p><strong>The idea behind all this:</strong> turning writes to reads - and reads to immutable data structures are calculations. Which is great!
Reads to mutable data are actions, as per the definition of an action.</p>
<p>Okay, so let&#39;s address the elephant in the room: performance.
Yes. Immutable data structures <em>do</em> use more memory, and they <em>are</em> slower to operate on. However, they are fast enough. The book claims that even some high-frequency trading systems use them, where speed is vital.
Some arguments:</p>
<ul>
<li>Be careful of premature optimization. Do you want to trade performance for complexity before even knowing whether the optimization is needed? If it&#39;s too slow, you can optimize later.</li>
<li>Garbage collectors are fast.</li>
<li>You aren&#39;t copying as much as you think. Most of the copies shown in the examples above are <em>shallow copies</em>, meaning only references are copied. This is pretty cheap.</li>
</ul>
<p>You might also think: if we&#39;re just copying references, can&#39;t it end badly if the elements of the arrays are references? No. Not if the actions performed are use immutability. Structural sharing (two pieces of nested data sharing some references) is safe when it&#39;s all immutable. It uses less memory and is faster than copying.
By &#34;it&#39;s all immutable&#34;, I mean that every operation is immutable. This is what makes the operations safe. By copying, then modifying, and then updating <em>references</em> in copied objects, even nested modifications are fine.</p>
<p><strong>What about objects?</strong></p>
<p><strong>Arrays</strong></p>
<pre><code><span><span>function</span> <span>withArrayCopy</span><span>(</span><span>array<span>,</span> modify</span><span>)</span> <span>{</span>
</span><span>    <span>const</span> copy <span>=</span> array<span>.</span><span>slice</span><span>(</span><span>)</span><span>;</span>
</span><span>    <span>modify</span><span>(</span>copy<span>)</span><span>;</span>
</span><span>    <span>return</span> copy<span>;</span>
</span><span><span>}</span>
</span></code></pre>
<p>This reduces code duplication in a ton of functions, where you&#39;d have to do the CoW logic (copy, modify return).
This uses the concept of higher order functions and functions as first-class values. I.e. functions returning/taking in functions and functions being passed as e.g. parameters.</p>
<h3 id="defensive-copying"><a href="https://bagerbach.com/books/grokking-simplicity#defensive-copying"><span></span></a>Defensive copying</h3>
<p>So, how do you deal with codebases that only partially have immutability (with copy-on-write)?</p>
<p>You do defensive copying.</p>
<p>For this, you create two copies of the data. When you get mutable data, make a deep copy and throw away the mutable original (since the untrusted code has a reference to it).
And when data leaves your immutable-data-adhering-code, you make another deep copy and send the copy to the untrusted code.</p>
<p>Here&#39;s how to implement deep copying in JS.</p>
<pre><code><span><span>function</span> <span>deepCopy</span><span>(</span><span>thing</span><span>)</span> <span>{</span>
</span><span>    <span>if</span> <span>(</span><span>Array</span><span>.</span><span>isArray</span><span>(</span>thing<span>)</span><span>)</span> <span>{</span>
</span><span>        <span>const</span> copy <span>=</span> <span>[</span><span>]</span><span>;</span>
</span><span>        <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> thing<span>.</span><span>length</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
</span><span>            copy<span>.</span><span>push</span><span>(</span><span>deepCopy</span><span>(</span>thing<span>[</span>i<span>]</span><span>)</span><span>)</span><span>;</span>
</span><span>        <span>}</span>
</span><span>        <span>return</span> copy<span>;</span>
</span><span>    <span>}</span> <span>else</span> <span>if</span> <span>(</span>thing <span>===</span> <span>null</span><span>)</span> <span>{</span>
</span><span>        <span>return</span> <span>null</span><span>;</span>
</span><span>    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>typeof</span> thing <span>===</span> <span>&#34;object&#34;</span><span>)</span> <span>{</span>
</span><span>        <span>const</span> copy <span>=</span> <span>{</span><span>}</span><span>;</span>
</span><span>        <span>for</span> <span>(</span><span>const</span> key <span>in</span> thing<span>)</span> <span>{</span>
</span><span>            copy<span>[</span>key<span>]</span> <span>=</span> <span>deepCopy</span><span>(</span>thing<span>[</span>key<span>]</span><span>)</span><span>;</span>
</span><span>        <span>}</span>
</span><span>        <span>return</span> copy<span>;</span>
</span><span>    <span>}</span> <span>else</span> <span>{</span>
</span><span>        <span>return</span> thing<span>;</span>
</span><span>    <span>}</span>
</span><span><span>}</span>
</span></code></pre>
<p>But it isn&#39;t complete. <code>structuredClone</code> is better. This just illustrates the principles.</p>

<p>Functional iteration chapter covers <code>map</code>, <code>filter</code>, and <code>reduce</code>. The book provides a fantastic explanation of them, which isn&#39;t included in these notes.</p>
<p>The book presents some functional tools in JavaScript, e.g. <code>pluck</code>, <code>concat</code>, <code>frequencies</code>, and <code>groupBy</code>. I&#39;ve converted them to typescript here:</p>
<pre><code><span><span>function</span> <span><span>pluck</span><span><span>&lt;</span><span>T</span><span>,</span> <span>K</span> <span>extends</span> <span>keyof</span> <span>T</span><span>&gt;</span></span></span><span>(</span>arr<span>:</span> <span>T</span><span>[</span><span>]</span><span>,</span> key<span>:</span> <span>K</span><span>)</span> <span>{</span>
</span><span>    <span>return</span> arr<span>.</span><span>map</span><span>(</span><span>(</span>item<span>)</span> <span>=&gt;</span> item<span>[</span>key<span>]</span><span>)</span><span>;</span>
</span><span><span>}</span>
</span><span>
</span><span><span>function</span> <span><span>concat</span><span><span>&lt;</span><span>T</span><span>&gt;</span></span></span><span>(</span>arr<span>:</span> <span>T</span><span>[</span><span>]</span><span>[</span><span>]</span><span>)</span><span>:</span> <span>T</span><span>[</span><span>]</span> <span>{</span>
</span><span>    <span>return</span> arr<span>.</span><span>reduce</span><span>(</span><span>(</span>acc<span>,</span> item<span>)</span> <span>=&gt;</span> <span>{</span>
</span><span>        acc <span>=</span> <span>[</span><span>...</span>acc<span>,</span> <span>...</span>item<span>]</span><span>;</span>
</span><span>        <span>return</span> acc<span>;</span>
</span><span>    <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>
</span><span><span>}</span>
</span><span>
</span><span><span>function</span> <span><span>frequenciesBy</span><span><span>&lt;</span>
</span></span></span><span><span><span>    <span>T</span> <span>extends</span> Record<span>&lt;</span><span>string</span><span>,</span> <span>unknown</span><span>&gt;</span><span>,</span>
</span></span></span><span><span><span>    <span>U</span> <span>extends</span> <span>T</span><span>[</span><span>keyof</span> <span>T</span><span>]</span> <span>&amp;</span> <span>(</span><span>string</span> <span>|</span> <span>number</span> <span>|</span> <span>symbol</span><span>)</span>
</span></span></span><span><span><span><span>&gt;</span></span></span><span>(</span>arr<span>:</span> <span>T</span><span>[</span><span>]</span><span>,</span> <span>f</span><span>:</span> <span>(</span>item<span>:</span> <span>T</span><span>)</span> <span>=&gt;</span> <span>U</span><span>)</span><span>:</span> Record<span>&lt;</span><span>U</span><span>,</span> <span>number</span><span>&gt;</span> <span>{</span>
</span><span>    <span>return</span> arr<span>.</span><span>reduce</span><span>(</span><span>(</span>acc<span>,</span> item<span>)</span> <span>=&gt;</span> <span>{</span>
</span><span>        <span>const</span> key <span>=</span> <span>f</span><span>(</span>item<span>)</span><span>;</span>
</span><span>
</span><span>        acc<span>[</span>key<span>]</span> <span>=</span> <span>(</span>acc<span>[</span>key<span>]</span> <span>??</span> <span>0</span><span>)</span> <span>+</span> <span>1</span>
</span><span>
</span><span>        <span>return</span> acc<span>;</span>
</span><span>    <span>}</span><span>,</span> <span>{</span><span>}</span> <span>as</span> Record<span>&lt;</span><span>U</span><span>,</span> <span>number</span><span>&gt;</span><span>)</span><span>;</span>
</span><span><span>}</span>
</span><span>
</span><span><span>function</span> <span><span>groupBy</span><span><span>&lt;</span><span>T</span> <span>extends</span> Record<span>&lt;</span><span>string</span><span>,</span> <span>unknown</span><span>&gt;</span><span>,</span> <span>K</span> <span>extends</span> <span>T</span><span>[</span><span>keyof</span> <span>T</span><span>]</span> <span>&amp;</span> <span>(</span><span>string</span> <span>|</span> <span>number</span> <span>|</span> <span>symbol</span><span>)</span><span>&gt;</span></span></span><span>(</span>arr<span>:</span> <span>T</span><span>[</span><span>]</span><span>,</span> <span>f</span><span>:</span> <span>(</span>item<span>:</span> <span>T</span><span>)</span> <span>=&gt;</span> <span>K</span><span>)</span> <span>{</span>
</span><span>    <span>return</span> arr<span>.</span><span>reduce</span><span>(</span><span>(</span>acc<span>,</span> item<span>)</span> <span>=&gt;</span> <span>{</span>
</span><span>        <span>const</span> key <span>=</span> <span>f</span><span>(</span>item<span>)</span><span>;</span>
</span><span>
</span><span>        <span>if</span> <span>(</span><span>!</span>Object<span>.</span><span>hasOwn</span><span>(</span>acc<span>,</span> key<span>)</span><span>)</span>
</span><span>            acc<span>[</span>key<span>]</span> <span>=</span> <span>[</span><span>]</span><span>;</span>
</span><span>
</span><span>        acc<span>[</span>key<span>]</span><span>.</span><span>push</span><span>(</span>item<span>)</span><span>;</span>
</span><span>
</span><span>        <span>return</span> acc<span>;</span>
</span><span>    <span>}</span><span>,</span> <span>{</span><span>}</span> <span>as</span> Record<span>&lt;</span><span>K</span><span>,</span> <span>T</span><span>[</span><span>]</span><span>&gt;</span><span>)</span>
</span><span><span>}</span>
</span></code></pre>
<h3 id="chaining-functional-tools"><a href="https://bagerbach.com/books/grokking-simplicity#chaining-functional-tools"><span></span></a>Chaining functional tools</h3>
<p>Basically, this chapter (chaining functional tools) presented how to combine the functional iteration tools from the previous chapter. You combine them into a chain, e.g. <code>arr.filter(...).map(...)</code>.</p>
<p>Also showed how you can use reduce to build a data structure. In this case, it looked like they used event data (adding / removing items to / from a shopping cart) to build a shopping cart DS. Array was an array of <code>[[&#39;add&#39;, &#39;shoes&#39;], ...]</code> which let the <code>reduce</code> build the cart from that. Supposedly, this is called event sourcing.</p>
<h3 id="dealing-with-nested-data"><a href="https://bagerbach.com/books/grokking-simplicity#dealing-with-nested-data"><span></span></a>Dealing with nested data</h3>
<p>Presents functional tools for nested data (e.g. objects/hash maps).</p>
<p>First, <code>update</code>. Takes <code>Record&lt;string, unknown&gt;</code> (object), <code>string</code> (field name), and a function to modify the value. It starts by grabbing the value in the object, i.e. <code>const value = obj[field]</code>. Then it calls <code>modify</code> (callback fn) on <code>value</code>. Lastly, it uses <code>objectSet</code> to return a new object with the value set (for immutability; CoW).</p>
<p>But obviously, <code>update</code> doesn&#39;t work on nested data.
So here&#39;s <code>nestedUpdate()</code>:</p>
<pre><code><span><span>function</span> <span>nestedUpdate</span><span>(</span><span>object<span>,</span> keys<span>,</span> modify</span><span>)</span> <span>{</span>
</span><span>    <span>if</span> <span>(</span>keys<span>.</span><span>length</span> <span>===</span> <span>0</span><span>)</span>
</span><span>        <span>return</span> <span>modify</span><span>(</span>object<span>)</span><span>;</span>
</span><span>    <span>const</span> key1 <span>=</span> keys<span>[</span><span>0</span><span>]</span><span>;</span>
</span><span>    <span>const</span> restOfKeys <span>=</span> <span>drop_first</span><span>(</span>keys<span>)</span><span>;</span>
</span><span>    <span>return</span> <span>update</span><span>(</span>object<span>,</span> key1<span>,</span> <span>function</span><span>(</span><span>value1</span><span>)</span> <span>{</span>
</span><span>        <span>return</span> <span>nestedUpdate</span><span>(</span>value1<span>,</span> restOfKeys<span>,</span> modify<span>)</span><span>;</span>
</span><span>    <span>}</span><span>)</span><span>;</span>
</span><span><span>}</span>
</span></code></pre>
<h3 id="handling-async-tasks"><a href="https://bagerbach.com/books/grokking-simplicity#handling-async-tasks"><span></span></a>Handling async tasks</h3>
<p>The book provides a nice &amp; concise description of the JavaScript event loop and job queue.</p>
<p>Jobs are added to the queue in the order the events happen. The queue ensures jobs are handled in the order they come in (FIFO). When you call asynchronous operations, the callback is added to the queue as a job.
The event loop takes the front job from the queue and executes it to completion(!), then grabs the next.
This means all your code is run in the event loop thread.</p>
<p>One of these chapters also present a queue which facilitates task running in order. The queue helps us share resources safely across timelines. I&#39;ve built a TypeScript implementation:</p>
<pre><code><span><span>function</span> Queue<span>&lt;</span>
</span><span>    TData<span>,</span>
</span><span>    TCallback <span>extends</span> <span>&lt;</span><span>T</span><span>&gt;</span><span>(</span>arg<span>?</span><span>:</span> <span>T</span><span>)</span> <span>=&gt;</span> <span>void</span><span>,</span>
</span><span>    TItem <span>extends</span> <span>{</span> data<span>:</span> TData<span>;</span> callback<span>:</span> TCallback <span>}</span><span>,</span>
</span><span>    TWorkerFn <span>extends</span> <span>(</span>data<span>:</span> TData<span>,</span> done<span>:</span> TCallback<span>)</span> <span>=&gt;</span> <span>void</span>
</span><span><span>&gt;</span><span>(</span>worker<span>:</span> TWorkerFn<span>)</span> <span>{</span>
</span><span>    <span>const</span> queueItems<span>:</span> TItem<span>[</span><span>]</span> <span>=</span> <span>[</span><span>]</span><span>;</span>
</span><span>    <span>let</span> working <span>=</span> <span>false</span><span>;</span>
</span><span>
</span><span>    <span>function</span> <span>runNext</span><span>(</span><span>)</span> <span>{</span>
</span><span>        <span>if</span> <span>(</span>working<span>)</span> <span>return</span><span>;</span>
</span><span>        <span>if</span> <span>(</span>queueItems<span>.</span>length <span>===</span> <span>0</span><span>)</span> <span>return</span><span>;</span>
</span><span>
</span><span>        working <span>=</span> <span>true</span><span>;</span>
</span><span>        <span>const</span> item <span>=</span> queueItems<span>.</span><span>shift</span><span>(</span><span>)</span> <span>as</span> TItem<span>;</span> 
</span><span>
</span><span>        <span>worker</span><span>(</span>item<span>.</span>data<span>,</span> <span>function</span> <span>(</span>val<span>)</span> <span>{</span>
</span><span>            working <span>=</span> <span>false</span><span>;</span>
</span><span>            <span>setTimeout</span><span>(</span>item<span>.</span>callback<span>,</span> <span>0</span><span>,</span> val<span>)</span><span>;</span>
</span><span>            <span>runNext</span><span>(</span><span>)</span><span>;</span>
</span><span>        <span>}</span> <span>as</span> TCallback<span>)</span><span>;</span>
</span><span>    <span>}</span>
</span><span>
</span><span>    <span>return</span> <span>function</span> <span>(</span>data<span>:</span> TData<span>,</span> callback<span>:</span> TCallback<span>)</span> <span>{</span>
</span><span>        queueItems<span>.</span><span>push</span><span>(</span><span>{</span>
</span><span>            data<span>,</span>
</span><span>            callback<span>,</span>
</span><span>        <span>}</span> <span>as</span> TItem<span>)</span><span>;</span>
</span><span>
</span><span>        <span>setTimeout</span><span>(</span>runNext<span>,</span> <span>0</span><span>)</span><span>;</span>
</span><span>    <span>}</span><span>;</span>
</span><span><span>}</span>
</span></code></pre>
<p>They also present a <code>DroppingQueue</code>. This fixes the issue of, when queue items take a long time, but write over each other, then you only want to keep the latest item. So you pass a <code>max</code> to the queue, which it uses to drop items until there&#39;s only that many items left in the queue. I.e. put a <code>while (queueItems.length &gt; max) queueItems.unshift()</code> in the returned function, after adding the new item to the queue.</p>
<h2 id="reactive--onion-architectures"><a href="https://bagerbach.com/books/grokking-simplicity#reactive--onion-architectures"><span></span></a>Reactive &amp; Onion Architectures</h2>
<h2 id="reactive"><a href="https://bagerbach.com/books/grokking-simplicity#reactive"><span></span></a>Reactive</h2>
<p>Chapter <code>Reactive and onion architectures</code> present the two architectures.</p>
<p>Now, I&#39;m particularly interested in the reactive architecture.
You structure your application &amp; its logic such that events facilitate actions. &#34;When X happens, do Y, Z, A, and C.&#34;</p>
<p>This is particularly interesting to me, because it&#39;s how the web is currently converging on UI frameworks. React, for example... it&#39;s in the name!
But also in how we manage our state. For example, later in this chapter, they present a <code>ValueCell</code> method of handling data &amp; updates to them. In other words, first-class state management.</p>
<p>Here&#39;s a TypeScript implementation:</p>
<pre><code><span><span>function</span> ValueCell<span>&lt;</span>TData<span>,</span> TWatcher <span>extends</span> <span>(</span>value<span>:</span> TData<span>)</span> <span>=&gt;</span> <span>void</span><span>&gt;</span><span>(</span>
</span><span>    initialValue<span>:</span> TData
</span><span><span>)</span> <span>{</span>
</span><span>    <span>let</span> currentValue <span>=</span> initialValue<span>;</span>
</span><span>    <span>const</span> watchers<span>:</span> TWatcher<span>[</span><span>]</span> <span>=</span> <span>[</span><span>]</span><span>;</span>
</span><span>
</span><span>    <span>return</span> <span>{</span>
</span><span>        <span>value</span><span>:</span> <span>(</span><span>)</span> <span>=&gt;</span> currentValue<span>,</span>
</span><span>        <span>update</span><span>:</span> <span>(</span><span>f</span><span>:</span> <span>(</span>oldValue<span>:</span> TData<span>)</span> <span>=&gt;</span> TData<span>)</span> <span>=&gt;</span> <span>{</span>
</span><span>            <span>const</span> oldValue <span>=</span> currentValue<span>;</span>
</span><span>            <span>const</span> newValue <span>=</span> <span>f</span><span>(</span>oldValue<span>)</span><span>;</span>
</span><span>
</span><span>            <span>if</span> <span>(</span>oldValue <span>!==</span> newValue<span>)</span> <span>{</span>
</span><span>                currentValue <span>=</span> newValue<span>;</span>
</span><span>
</span><span>                watchers<span>.</span><span>forEach</span><span>(</span><span>(</span>watcher<span>)</span> <span>=&gt;</span> <span>watcher</span><span>(</span>newValue<span>)</span><span>)</span><span>;</span>
</span><span>            <span>}</span>
</span><span>        <span>}</span><span>,</span>
</span><span>        <span>addWatcher</span><span>:</span> <span>(</span>f<span>:</span> TWatcher<span>)</span> <span>=&gt;</span> <span>{</span>
</span><span>            watchers<span>.</span><span>push</span><span>(</span>f<span>)</span><span>;</span>
</span><span>        <span>}</span><span>,</span>
</span><span>    <span>}</span><span>;</span>
</span><span><span>}</span>
</span></code></pre>
<p>The name, <code>ValueCell</code> comes from spreadsheet applications. A value cell just has a plain value, as opposed to formula cells, which calculate derived values, based on value cells.</p>
<p>Here is a TypeScript implementation of the <code>FormulaCell</code>:</p>
<pre><code><span><span>function</span> <span><span>FormulaCell</span><span><span>&lt;</span>
</span></span></span><span><span><span>    TCell <span>extends</span> ReturnType<span>&lt;</span><span>typeof</span> ValueCell<span>&gt;</span><span>,</span>
</span></span></span><span><span><span>    TData <span>extends</span> ReturnType<span>&lt;</span>TCell<span>[</span><span>&#34;value&#34;</span><span>]</span><span>&gt;</span>
</span></span></span><span><span><span><span>&gt;</span></span></span><span>(</span>upstreamCell<span>:</span> TCell<span>,</span> <span>calc</span><span>:</span> <span>(</span>value<span>:</span> TData<span>)</span> <span>=&gt;</span> TData<span>)</span> <span>{</span>
</span><span>    <span>const</span> myCell <span>=</span> <span>ValueCell</span><span>(</span><span>calc</span><span>(</span>upstreamCell<span>.</span><span>value</span><span>(</span><span>)</span> <span>as</span> TData<span>)</span><span>)</span><span>;</span>
</span><span>    upstreamCell<span>.</span><span>addWatcher</span><span>(</span><span>function</span> <span>(</span>newUpstreamValue<span>)</span> <span>{</span>
</span><span>        myCell<span>.</span><span>update</span><span>(</span><span>function</span> <span>(</span>_<span>)</span> <span>{</span>
</span><span>            <span>return</span> <span>calc</span><span>(</span>newUpstreamValue <span>as</span> TData<span>)</span><span>;</span>
</span><span>        <span>}</span><span>)</span><span>;</span>
</span><span>    <span>}</span><span>)</span><span>;</span>
</span><span>
</span><span>    <span>return</span> <span>{</span>
</span><span>        val<span>:</span> myCell<span>.</span>value<span>,</span>
</span><span>        addWatcher<span>:</span> myCell<span>.</span>addWatcher<span>,</span>
</span><span>    <span>}</span><span>;</span>
</span><span><span>}</span>
</span></code></pre>
<p>Equivalents of these are seen in many languages &amp; frameworks. In React, we have Redux stores &amp; Recoil atoms, for example.</p>
<p><strong>Why the reactive architecture is good</strong></p>
<ol>
<li>Decouples cause and effect; by using the observer pattern, you don&#39;t have to call various elements where they don&#39;t belong.</li>
<li>Treats steps as pipelines. Data flows naturally through, like with promises in JS. There are frameworks that can help, e.g. RxJs.</li>
<li>Creates timeline flexibility (if desired). The timelines are shorter, and there are no shared resources between them. This prevents many common issues, e.g. race conditions, etc.</li>
</ol>
<h3 id="onion"><a href="https://bagerbach.com/books/grokking-simplicity#onion"><span></span></a>Onion</h3>
<p>The onion architecture is a set of concentric layers:</p>
<ul>
<li>(innermost) Language layer, for language and utility libraries.</li>
<li>(middle) Domain layer, for calculations that define the rules of your business.</li>
<li>(outer) Interaction layer, for actions that are affected by or affect the outside world.</li>
</ul>
<p>This is not set in stone. The layers don&#39;t need to be exactly like that, but onion architectures generally follow these three large groupings.</p>
<p><strong>Rules:</strong></p>
<ol>
<li>Interaction with the world is done exclusively in the interaction layer.</li>
<li>Layers call in toward the center.</li>
<li>Layers don&#39;t know about layers outside of themselves.</li>
</ol>
<p>This presents an idealized view. It may not always be good to chase that kind of ideal. Sometimes you have to make tradeoffs between conforming to such principles, and real-world concerns.</p>
<p>Actions can be more readable than a calculation counterpart.
There are nuances—reasons to pick one over the other—nd we must be aware of that.
Readability, development speed, system performances. These are some nuances that can make you bend the rules a bit. And that can be OK, too.</p>
<p>The guidelines can help you recover when things get a bit sour from technical debt.</p></div></div>
  </body>
</html>
