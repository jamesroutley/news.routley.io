<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://iconsolutions.com/blog/i-got-opentelemetry-to-work-but-why-was-it-so-complicated/">Original</a>
    <h1>I got OpenTelemetry to work. But why was it so complicated?</h1>
    
    <div id="readability-page-1" class="page"><div>
                      <p>A number of our customers have recently been asking whether we support <a href="https://opentelemetry.io/docs/" rel="nofollow">OpenTelemetry</a>, the observability framework and toolkit. When the first member of the team who’s client-facing asked me – the go-to guy for metrics and logging at IPF – I barely let them finish: “of course! That’s just Prometheus and Jaeger, right? We’ve supported that for years!”</p>
<p>Well, it turns out I was more or less wrong on all counts. Yay! Let’s get into it.</p>
<h2 id="IgotOpenTelemetrytowork.Butwhywasitsocomplicated?-OTel?">OTel?</h2>
<p>As I mentioned up there, OpenTelemetry, or OTel, is an observability <em>framework</em> and <em>toolkit</em>. What does this mean? Well, to start, let’s think about the sort of tools that predated OTel in this space. A nice triad you could use to get started could be:</p>
<ul>
<li><strong>Prometheus</strong> for metrics</li>
<li>Things like <strong>Logstash</strong> for exporting logs to a central aggregator like <strong>Elasticsearch</strong> (other log exporters and aggregators are available)</li>
<li><strong>OpenTracing</strong> for distributed tracing</li>
</ul>
<p>These are three different standards from three different organisations. OpenTelemetry tries to round up, and – more importantly – standardise the tooling in this space by codifying it under three so-called signals: <strong>metrics</strong>, <strong>logs</strong> and <strong>traces</strong>. In addition to just providing a specification, they have created:</p>
<ul>
<li>The OpenTelemetry Protocol (OTLP) which allows applications to report data on the aforementioned primitives to what is known as the…</li>
<li>…OpenTelemetry Collector: a  “Vendor-agnostic way to receive, process and export telemetry data.”</li>
<li>Language SDKs for 10+ languages which implement OTLP and exporting of telemetry data</li>
</ul>
<p>These are the core components they have created. There are others, but this will do for now. If you’re confused, here’s a diagram from their root docs page (which is in itself a tell!)</p>
<p><span><img decoding="async" draggable="false" src="https://opentelemetry.io/img/otel-diagram.svg" alt="OpenTelemetry Reference Architecture" width="877" height="582" data-image-src="https://opentelemetry.io/img/otel-diagram.svg"/></span></p>
<p>As we can see, “microservices” (remember those?) can report signals to the OTel Collector using auto-instrumentation (“zero code”), the API, or one of the language SDKs. But it’s not restricted to your applications: your infrastructure can also send signals to the OTel Collector!</p>
<p>So this sounds well and good, and indeed a noble cause. As a bonus it ticks all the buzzword boxes: open-source, vendor-agnostic, language-agnostic, distributed, <a href="https://opentelemetry.io/docs/zero-code/" rel="nofollow">zero-code</a> (conditions apply; see below).</p>
<p>So what’s wrong?</p>
<h2 id="IgotOpenTelemetrytowork.Butwhywasitsocomplicated?-Nostrangerstoobservability">No strangers to observability</h2>
<p>We are not new to this space. We’ve had docs on these topics for a while now, and our customers have used these in production for some time. Want to <a href="https://docs.ipfdev.co.uk/core/IPF_RELEASE_2024.2.0/flo-starter/features/monitoring.html#option-1-elasticsearchlogstashkibana" rel="nofollow">get IPF to report to an ELK Stack</a>? No problem. General docs on <a href="https://docs.ipfdev.co.uk/core/IPF_RELEASE_2024.2.0/flo-starter/features/monitoring.html" rel="nofollow">monitoring and observability</a>? Sure thing!</p>
<p>As a  know what environment an app using our libraries is going to be deployed  to stay abstract and never make any vendor-specific choices one way or another. I’m starting to sound like the OTel people. This means we have to spend a lot of time building in overrideable sensible defaults, abstractions (ensuring they are not crappy and/or leaky ones), and so on.</p>
<p>Having said that,  we <em>can</em> make recommendations: we usually recommend that logs are pushed to some aggregator like Elasticsearch, LogScale, etc, and by default we enable and support Prometheus metrics as  become a <em>de facto</em> standard.  OTel came along.</p>
<h2 id="IgotOpenTelemetrytowork.Butwhywasitsocomplicated?-Easywins:logsandmetrics">Easy wins: logs and metrics</h2>
<p>While logs and metrics are a fairly well-known quantity amongst our customers, tracing is not. There must be something in the water, because we got three almost simultaneous requests asking about tracing with OTel. And while you’re using OTel for tracing, you might as well use it for the other two things as well!</p>
<p>It was fairly easy for our customers to move logs and  to OTel, since to enable logs and metrics you just need to add a new appender and some new config respectively. But what do we do for tracing?</p>
<h2 id="IgotOpenTelemetrytowork.Butwhywasitsocomplicated?-Tracingmyheadache">Tracing my headache</h2>
<p>When you trace a transaction through a distributed system, you need to pass some information between the systems to correlate a specific invocation with a specific transaction. This is known as <a href="https://opentelemetry.io/docs/concepts/context-propagation/" rel="nofollow">context propagation</a>.</p>
<p>A <em>trace</em> is a parent/wrapper for a set of individual units of work, called <em>spans</em>. A trace can contain multiple spans, and spans can be nested. Imagine an e-commerce website: clicking the “buy now” button initiates a trace involving the frontend talking to the backend in one span, the backend activates a new child span to talk to the payment/shipping/order management services, and each one of those may activate a new child span to talk to some other downstream system further down. All the distributed services report their part of the trace to the OTel collector (if using OTel) and OTel builds a holistic view under a single trace ID. Well, that’s the theory anyway.</p>
<p>In a typical fashion in our industry where we have the opportunity to gather around one standard for context propagation, we decided to make several. Obligatory reference to the XKCD comic: <a href="https://xkcd.com/927/" rel="nofollow">Standards</a>. The context propagation implementations that OTel MUST(!) support are:</p>
<ul>
<li><a href="https://github.com/openzipkin/b3-propagation" rel="nofollow">b3</a></li>
<li><a href="https://www.w3.org/TR/trace-context/" rel="nofollow">W3C Trace Context</a></li>
<li><a href="https://www.w3.org/TR/baggage/" rel="nofollow">W3C Baggage</a></li>
<li><a href="https://www.jaegertracing.io/docs/1.63/client-libraries/#propagation-format" rel="nofollow">Jaeger</a></li>
</ul>
<p>I don’t really understand why there are four, but I think what’s happened is <a href="https://en.wikipedia.org/wiki/Convergent_evolution" rel="nofollow">convergent evolution</a>: different sets of people – unaware of one another – came to a shared conclusion regarding how to solve a specific problem. Honourable mention for W3C creating <em>two</em> standards for the same thing. Actually, if you read the Baggage spec, they claim that it’s independent of Trace Context. So why does OTel let me propagate the Trace Context over Baggage? I have no idea. Let me know in the comments. Does our blog have comments?</p>
<p>Now, we already had support for the now-deprecated OpenTracing within the Akka parts of our app using <a href="https://developer.lightbend.com/docs/telemetry/current//extensions/opentracing/opentracing.html" rel="nofollow">Lightbend Telemetry support for OpenTracing</a>. Then it got better: in version 2.20.0 of that library, they introduced support for OpenTelemetry logs/events and metrics, but – crucially – <strong>not tracing</strong>! Theoretically this doesn’t matter, because OTel tracing is really just a rebranding of OpenTracing, and Lightbend Telemetry’s OpenTracing supports context propagation using the above four methods anyway. So it should just work…right?</p>
<p>Of course not. We have a new fly in the ointment.</p>
<h2 id="IgotOpenTelemetrytowork.Butwhywasitsocomplicated?-ClashofAPIs">Clash of APIs</h2>
<p>IPF makes use of both Spring and Akka for different purposes: we use Spring Boot – and Spring IoC in general – to bootstrap the application and its config, build a set of dependencies, and so on. We use Akka for pretty much everything else: event sourcing, scheduling, clustering, sharding, integration, and so on. But of course we can’t stop customers from doing whatever they want, and so some of them tend to use – for example – a Spring REST controller, or perhaps a <code>@KafkaListener</code>-annotated method to initiate payment flows.</p>
<p>Without OTel, up until now, this was <em>fine</em>:</p>
<ul>
<li><strong>Metrics</strong>: Spring and Akka expose different Prometheus endpoints so won’t step on each other’s toes</li>
<li><strong>Logs</strong>: We use SLF4J and Logback which is common to both frameworks</li>
<li><strong>Traces</strong>: Both used OpenTracing</li>
</ul>
<p>When using OTel, metrics and logs were still being sent through fine based on the fact that Spring and Akka were operating independently of one another. However, when it comes to tracing, we need them to be aware of one another so that they can propagate the trace context within the JVM. The problem is now that there are two different APIs being used <strong>inside the app</strong> to reflect the same thing, and guess what: they aren’t talking to one another. Here’s a diagram if you’re struggling (I certainly am):</p>

<p><img decoding="async" src="https://iconsolutions.com/wp-content/uploads/2024/12/tracing-apis-clash.png" alt="tracing APIs clash" width="1281" height="321" srcset="https://iconsolutions.com/wp-content/uploads/2024/12/tracing-apis-clash.png 1281w, https://iconsolutions.com/wp-content/uploads/2024/12/tracing-apis-clash-300x75.png 300w, https://iconsolutions.com/wp-content/uploads/2024/12/tracing-apis-clash-1024x257.png 1024w, https://iconsolutions.com/wp-content/uploads/2024/12/tracing-apis-clash-768x192.png 768w" sizes="(max-width: 1281px) 100vw, 1281px"/></p>

<p> The correct behaviour would be for the Akka HTTP client to reuse the same trace ID <code>123</code> from the left hand side, but make a new span ID to indicate that a new unit of work has started  is part of the same <code>123</code> trace.  completely different traces with no relation to one another.</p>
<p>The silver lining is that It looks like the OTel people were aware of this, and created <a href="https://github.com/open-telemetry/opentelemetry-java/tree/main/opentracing-shim" rel="nofollow"><code>opentracing-shim</code></a>: a way for you to dress up an OTel <a href="https://javadoc.io/doc/io.opentelemetry/opentelemetry-api/latest/io/opentelemetry/api/trace/Tracer.html" rel="nofollow"><code>Tracer</code></a> as an OpenTracing <a href="https://javadoc.io/static/io.opentracing/opentracing-api/0.33.0/io/opentracing/Tracer.html" rel="nofollow"><code>Tracer</code></a>. , because Lightbend Telemetry uses a custom Tracer implementation which makes the shim <strong>and </strong>Jaeger freak out, and, instead of any of these things doing their job and propagating a trivial string-string map, spams the log with:</p>
<div data-hasbody="true" data-macro-name="code">
<div>
<div>
<div id="highlighter_134516">
<div>
<div title="Hint: double-click to select code">
<p><code>Expected to have an OpenTelemetry Span but got cinnamon.opentracing.TraceLocal$ContextOnlySpan</code></p>
</div>
</div>
</div>
</div>
</div>
</div>
<p>And in Jaeger’s case:</p>
<div data-hasbody="true" data-macro-name="code">
<div>
<div>
<div id="highlighter_807539">
<div>
<div title="Hint: double-click to select code">
<p><code>Expected to have a JaegerSpanContext but got io.opentelemetry.opentracingshim.SpanContextShim</code></p>
</div>
</div>
</div>
</div>
</div>
</div>
<p>So Jaeger is freaking out because it’s getting OTel, and OTel is freaking out because it’s getting Lightbend. Why is everybody so precious about their own implementations?! All to move around a map with four scalar values?</p>
<h2 id="IgotOpenTelemetrytowork.Butwhywasitsocomplicated?-Intotheweeds">Into the weeds</h2>
<p>Both OTel and Lightbend Telemetry instrumentation use a <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.instrument/java/lang/instrument/package-summary.html" rel="nofollow">Java Agent</a> which hooks into specific method calls of specific classes and reports on their activity to the tracer. The Lightbend Telemetry  instrumentation is not open source, so I had to do a bit of digging into decompiled tracer code to figure out what on earth is going on.</p>
<p>I built a cut-down reproducer which replicates the diagram above, in which I attempted to see where exactly between the green and red box the trace context is being dropped, and see if I could help it along manually.</p>
<p>The first thing I did was set up a breakpoint on the Jaeger freak-out point (<a href="https://github.com/jaegertracing/jaeger-client-java/blob/v1.6.0/jaeger-core/src/main/java/io/jaegertracing/internal/JaegerTracer.java#L285" rel="nofollow">here</a>, if you want to play along) where it’s complaining that it’s getting a shim and not real OpenTracing. My thought process was: okay, this is close to what I want to happen (Jaeger to adopt the OTel context), so can I do something shim-free to help it along?</p>
<p>The caller that was causing it to freak out was <code>OpenTracingAkkaPersistenceActorInstrumentation.class</code>, a proprietary Lightbend Telemetry instrumentation class. I traced the Jaeger breakpoint to this point in the stack which looks promising:</p>
<p><span><img decoding="async" draggable="false" src="https://confluence.iconsolutions.com/download/attachments/415702396/image-2024-11-14_20-12-47.png?version=1&amp;modificationDate=1731575567742&amp;api=v2" alt="" data-image-src="/download/attachments/415702396/image-2024-11-14_20-12-47.png?version=1&amp;modificationDate=1731575567742&amp;api=v2" data-unresolved-comment-count="0" data-linked-resource-id="415702752" data-linked-resource-version="1" data-linked-resource-type="attachment" data-linked-resource-default-alias="image-2024-11-14_20-12-47.png" data-base-url="https://confluence.iconsolutions.com" data-linked-resource-content-type="image/png" data-linked-resource-container-id="415702396" data-linked-resource-container-version="16"/></span></p>
<p>It was line 153 that calls into Jaeger and upsets it, but the first clue was on line 152: if <code>var5</code> – an OpenTracing <a href="https://www.javadoc.io/static/io.opentracing/opentracing-api/0.33.0/io/opentracing/SpanContext.html" rel="nofollow"><code>SpanContext</code></a> – is not null, we attach our new span as a child of the current active span. If <code>var5</code> is null, the span has no relationship to the existing trace, and if <code>var5</code> is not a Jaeger SpanContext then Jaeger freaks out. So how can we make <code>var5</code> something that is both null and Jaeger-friendly?</p>
<p>On line 147, the <code>SpanContext</code> is being populated from <code>this.traceLocal.currentContext()</code> . So can I access this from outside somehow and just create a new Jaeger SpanContext myself and stop using the shim?</p>
<p>I then breakpointed on the constructor of <code>OpenTracingAkkaPersistenceActorInstrumentation</code> to see how <code>traceLocal</code> is initialised. Behold another decompiled wonder:</p>
<p><span><img decoding="async" draggable="false" src="https://confluence.iconsolutions.com/download/attachments/415702396/image-2024-11-14_20-19-29.png?version=1&amp;modificationDate=1731575969827&amp;api=v2" alt="" data-image-src="/download/attachments/415702396/image-2024-11-14_20-19-29.png?version=1&amp;modificationDate=1731575969827&amp;api=v2" data-unresolved-comment-count="0" data-linked-resource-id="415702771" data-linked-resource-version="1" data-linked-resource-type="attachment" data-linked-resource-default-alias="image-2024-11-14_20-19-29.png" data-base-url="https://confluence.iconsolutions.com" data-linked-resource-content-type="image/png" data-linked-resource-container-id="415702396" data-linked-resource-container-version="16"/></span></p>
<p>Okay, <code>var4</code> is an <code>ExtendedTracer</code>, and from my extensive trawling of Lightbend Telemetry docs, I remembered <a href="https://developer.lightbend.com/docs/telemetry/current//extensions/opentracing/api.html#globalextendedtracer-active-context" rel="nofollow">they had written</a> that it’s possible to access this ExtendedTracer programmatically using the following magical incantation:</p>
<div data-hasbody="true" data-macro-name="code">
<div>
<div>
<div id="highlighter_631775">
<div>
<div title="Hint: double-click to select code">
<p><code>GlobalExtendedTracer.get()</code></p>
</div>
</div>
</div>
</div>
</div>
</div>
<p>Things are so simple once you know what you’re doing!</p>
<p>This returns an <code>ExtendedTracer</code> and indeed calling <code>local()</code> returns the same <code>TraceLocal</code> that is being used by the instrumentation library. I also noticed that this <code>TraceLocal</code> has an <code>activateContext</code> method which takes an OpenTracing <code>SpanContext</code>. So if I ditch the shim and manually convert the OpenTelemetry Context into a Jaeger SpanContext, then:</p>
<ul>
<li>Jaeger will be happy because it gets its own SpanContext implementation</li>
<li>The shim will be happy because…it’s not being used</li>
<li>I will be happy because the trace ID should be propagated (albeit manually) between OTel and OpenTracing</li>
</ul>
<p>We can convert an OTel context into a OpenTracing one manually using the <a href="https://opentelemetry.io/docs/specs/otel/context/api-propagators/#operations" rel="nofollow">inject and extract operations</a> from the propagators API: I tell OTel to populate (“inject”) a generic Java Map with the context, and I then populate (“extract”) the Jaeger SpanContext with the values of the map.</p>
<p>Here’s what it all it looks like if you’re technically oriented (you must be if you’ve read all the way down here):</p>
<div>
<pre>//make an empty map to populate
var otelContext = new HashMap&lt;&gt;();
//inject OTel context into the map
GlobalOpenTelemetry.get().getPropagators().getTextMapPropagator().inject(Context.current(), otelContext, (carrier, key, value) -&gt; carrier.put(key, value));
//populate new JaegerSpanContext from aforementioned map 
var openTracingContext = new TextMapCodec(false).extract(new TextMapAdapter(otelContext));
//activate this new context before going into Akka
GlobalExtendedTracer.get().local().activateContext(openTracingContext);
//do stuff here - either OTel or Akka - because they should both be sharing the same context now</pre>
</div>
<p>Okay, let’s spin it up, and:</p>
<div id="drawio-macro-content-5f7187e0-ae96-4723-a83f-818ccebdd6df" data-macroid="5f7187e0-ae96-4723-a83f-818ccebdd6df" data-buildnum="9012">

<div>
<div data-drawio-colors="color: rgb(0, 0, 0); ">
<p><img loading="lazy" decoding="async" src="https://iconsolutions.com/wp-content/uploads/2024/12/otel-works.png" alt="oTel works" width="1839" height="889" srcset="https://iconsolutions.com/wp-content/uploads/2024/12/otel-works.png 1839w, https://iconsolutions.com/wp-content/uploads/2024/12/otel-works-300x145.png 300w, https://iconsolutions.com/wp-content/uploads/2024/12/otel-works-1024x495.png 1024w, https://iconsolutions.com/wp-content/uploads/2024/12/otel-works-768x371.png 768w, https://iconsolutions.com/wp-content/uploads/2024/12/otel-works-1536x743.png 1536w" sizes="(max-width: 1839px) 100vw, 1839px"/></p>
</div>
</div>
</div>
<p>Yes! We can see that it’s working correctly and ticking all the boxes:</p>
<ul>
<li>We have a single trace connecting everything from the initial Spring REST call to <code>/submit</code></li>
<li>We can mix usages of stuff instrumented by OTel and OpenTracing APIs</li>
<li>The trace is propagated across an HTTP boundary (bottom two spans)</li>
</ul>
<p>I gave the two different instrumentations two different names above to highlight that they are two kinds of tracing. But in real life we’d recommend to customers that they line up the <code>otel.service.name</code> and the <code>cinnamon.application</code> to appear as one application to the outside world.</p>
<h2 id="IgotOpenTelemetrytowork.Butwhywasitsocomplicated?-Reflections">Reflections</h2>
<p>From looking at the decompiled Lightbend Telemetry library, I can see that rewriting it to use OTel APIs would be a big effort: they would have to port their <a href="https://developer.lightbend.com/docs/telemetry/current/instrumentations/instrumentations.html" rel="nofollow">many instrumentations</a> – which are currently tied to the Jaeger API – to use the OTel API. But the silver bullet for them is that the OTel Collector supports collecting traces in the legacy Zipkin format, so they could release complete OTel support by relying on the legacy support, and they probably don’t have too many customers like us who are having this kind of clash.</p>
<p>To answer the titular question of why it was so complicated, I guess the short answer is that it’s self-inflicted: by trying to combine two different instrumentations which use two different tracing libraries we’re kind of asking for trouble. I think the OTel project has done a good job of attempting to apply some standardisation in this space (see for example semantic conventions). It starts off a little bit complex to wrap your head around, but I believe it’s a great FOSS project full of great people doing good things.</p>
<p>I am a little bit concerned about how or if Akka will correctly pass the trace context between threads inside its actor model. It seems to be working as expected from my small amount of load testing, but I have opened a ticket with them and can update this if there’s enough demand!</p>
<p>I hope that this will be of help to somebody. And if not, thanks for the free therapy session. Until next time!</p>
                    </div></div>
  </body>
</html>
