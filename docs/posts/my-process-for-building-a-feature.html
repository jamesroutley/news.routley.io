<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://simonwillison.net/2022/Jan/12/how-i-build-a-feature/">Original</a>
    <h1>My process for building a feature</h1>
    
    <div id="readability-page-1" class="page"><div id="primary">

<div>




<p>I’m maintaining <a href="https://github.com/simonw/simonw/blob/main/releases.md">a lot of different projects</a> at the moment. I thought it would be useful to describe the process I use for adding a new feature to one of them, using the new <a href="https://sqlite-utils.datasette.io/en/stable/cli.html#cli-create-database">sqlite-utils create-database</a> command as an example.</p>
<p>I like each feature to be represented by what I consider to be the <strong>perfect commit</strong>—one that bundles together the implementation, the tests, the documentation and a link to an external issue thread.</p>
<p>The <code>sqlite-utils create-database</code> command is very simple: it creates a new, empty SQLite database file. You use it like this:</p>
<pre><code>% sqlite-utils create-database empty.db
</code></pre>
<h4>Everything starts with an issue</h4>
<p>Every piece of work I do has an associated issue. This acts as ongoing work-in-progress notes and lets me record decisions, reference any research, drop in code snippets and sometimes even add screenshots and video—stuff that is really helpful but doesn’t necessarily fit in code comments or commit messages.</p>
<p>Even if it’s a tiny improvement that’s only a few lines of code, I’ll still open an issue for it—sometimes just a few minutes before closing it again as complete.</p>
<p>Any commits that I create that relate to an issue reference the issue number in their commit message. GitHub does a great job of automatically linking these together, bidirectionally so I can navigate from the commit to the issue or from the issue to the commit.</p>
<p>Having an issue also gives me something I can link to from my release notes.</p>
<p>In the case of the <code>create-database</code> command, I opened <a href="https://github.com/simonw/sqlite-utils/issues/348">this issue</a> in November when I had the idea for the feature.</p>
<p>I didn’t do the work until over a month later—but because I had designed the feature in the issue comments I could get started on the implementation really quickly.</p>
<h4>Development environment</h4>
<p>Being able to quickly spin up a development environment for a project is crucial. All of my projects have a section in the README or the documentation describing how to do this—here’s <a href="https://sqlite-utils.datasette.io/en/stable/contributing.html">that section for sqlite-utils</a>.</p>
<p>On my own laptop each project gets a directory, and I use <code>pipenv shell</code> in that directory to activate a directory-specific virtual environment, then <code>pip install -e &#39;.[test]&#39;</code> to install the dependencies and test dependencies.</p>
<h4>Automated tests</h4>
<p>All of my features are accompanied by automated tests. This gives me the confidence to boldly make changes to the software in the future without fear of breaking any existing features.</p>
<p>This means that writing tests needs to be as quick and easy as possible—the less friction here the better.</p>
<p>The best way to make writing tests easy is to have a great testing framework in place from the very beginning of the project. My cookiecutter templates (<a href="https://github.com/simonw/python-lib">python-lib</a>, <a href="https://github.com/simonw/datasette-plugin">datasette-plugin</a> and <a href="https://github.com/simonw/click-app">click-app</a> all configure <a href="https://docs.pytest.org/">pytest</a> and add a <code>tests/</code> folder with a single passing test, to give me something to start adding tests to.</p>
<p>I can’t say enough good things about pytest. Before I adopted it, writing tests was a chore. Now it’s an activity I genuinely look forward to!</p>
<p>I’m not a religious adherent to writing the tests first—see <a href="https://simonwillison.net/2020/Feb/11/cheating-at-unit-tests-pytest-black/">How to cheat at unit tests with pytest and Black</a> for more thoughts on that—but I’ll write the test first if it’s pragmatic to do so.</p>
<p>In the case of <code>create-database</code>, writing the test first felt like the right thing to do. Here’s the test I started with:</p>
<pre><span>def</span> <span>test_create_database</span>(<span>tmpdir</span>):
    <span>db_path</span> <span>=</span> <span>tmpdir</span> <span>/</span> <span>&#34;test.db&#34;</span>
    <span>assert</span> <span>not</span> <span>db_path</span>.<span>exists</span>()
    <span>result</span> <span>=</span> <span>CliRunner</span>().<span>invoke</span>(
        <span>cli</span>.<span>cli</span>, [<span>&#34;create-database&#34;</span>, <span>str</span>(<span>db_path</span>)]
    )
    <span>assert</span> <span>result</span>.<span>exit_code</span> <span>==</span> <span>0</span>
    <span>assert</span> <span>db_path</span>.<span>exists</span>()</pre>
<p>This test uses the <a href="https://docs.pytest.org/en/6.2.x/tmpdir.html#the-tmpdir-fixture">tmpdir pytest fixture</a> to provide a temporary directory that will be automatically cleaned up by pytest after the test run finishes.</p>
<p>It checks that the <code>test.db</code> file doesn’t exist yet, then uses the Click framework’s <a href="https://click.palletsprojects.com/en/8.0.x/testing/">CliRunner utility</a> to execute the create-database command. Then it checks that the command didn’t throw an error and that the file has been created.</p>
<p>The I run the test, and watch it fail—because I haven’t built the feature yet!</p>
<pre><code>% pytest -k test_create_database

============ test session starts ============
platform darwin -- Python 3.8.2, pytest-6.2.4, py-1.10.0, pluggy-0.13.1
rootdir: /Users/simon/Dropbox/Development/sqlite-utils
plugins: cov-2.12.1, hypothesis-6.14.5
collected 808 items / 807 deselected / 1 selected                           

tests/test_cli.py F                                                   [100%]

================= FAILURES ==================
___________ test_create_database ____________

tmpdir = local(&#39;/private/var/folders/wr/hn3206rs1yzgq3r49bz8nvnh0000gn/T/pytest-of-simon/pytest-659/test_create_database0&#39;)

    def test_create_database(tmpdir):
        db_path = tmpdir / &#34;test.db&#34;
        assert not db_path.exists()
        result = CliRunner().invoke(
            cli.cli, [&#34;create-database&#34;, str(db_path)]
        )
&gt;       assert result.exit_code == 0
E       assert 1 == 0
E        +  where 1 = &lt;Result SystemExit(1)&gt;.exit_code

tests/test_cli.py:2097: AssertionError
========== short test summary info ==========
FAILED tests/test_cli.py::test_create_database - assert 1 == 0
===== 1 failed, 807 deselected in 0.99s ====
</code></pre>
<p>The <code>-k</code> option lets me run any test that match the search string, rather than running the full test suite. I use this all the time.</p>
<p>Other pytest features I often use:</p>
<ul>
<li>
<code>pytest -x</code>: runs the entire test suite but quits at the first test that fails</li>
<li>
<code>pytest --lf</code>: re-runs any tests that failed during the last test run</li>
<li>
<code>pytest --pdb -x</code>: open the Python debugger at the first failed test (omit the <code>-x</code> to open it at every failed test). This is the main way I interact with the Python debugger. I often use this to help write the tests, since I can add <code>assert False</code> and get a shell inside the test to interact with various objects and figure out how to best run assertions against them.</li>
</ul>
<h4>Implementing the feature</h4>
<p>Test in place. It’s time to implement the command. I added this code to my existing <a href="https://github.com/simonw/sqlite-utils/blob/3.20/sqlite_utils/cli.py">cli.py module</a>:</p>
<pre><span>@<span>cli</span>.<span>command</span>(<span>name</span><span>=</span><span>&#34;create-database&#34;</span>)</span>
<span>@<span>click</span>.<span>argument</span>(</span>
<span>    <span>&#34;path&#34;</span>,</span>
<span>    <span>type</span><span>=</span><span>click</span>.<span>Path</span>(<span>file_okay</span><span>=</span><span>True</span>, <span>dir_okay</span><span>=</span><span>False</span>, <span>allow_dash</span><span>=</span><span>False</span>),</span>
<span>    <span>required</span><span>=</span><span>True</span>,</span>
<span>)</span>
<span>def</span> <span>create_database</span>(<span>path</span>):
    <span>&#34;Create a new empty database file.&#34;</span>
    <span>db</span> <span>=</span> <span>sqlite_utils</span>.<span>Database</span>(<span>path</span>)
    <span>db</span>.<span>vacuum</span>()</pre>
<p>(I happen to know that the quickest way to create an empty SQLite database file is to run <code>VACUUM</code> against it.)</p>
<p>The test now passes!</p>
<p>I iterated on this implementation a little bit more, to add the <code>--enable-wal</code> option I had designed <a href="https://github.com/simonw/sqlite-utils/issues/348#issuecomment-983120066">in the issue comments</a>—and updated the test to match. You can see the final implementation in this commit: <a href="https://github.com/simonw/sqlite-utils/commit/1d64cd2e5b402ff957f9be2d9bb490d313c73989">1d64cd2e5b402ff957f9be2d9bb490d313c73989</a>.</p>
<p>If I add a new test and it passes the first time, I’m always suspicious of it. I’ll deliberately break the test (change a 1 to a 2 for example) and run it again to make sure it fails, then change it back again.</p>
<h4>Code formatting with Black</h4>
<p><a href="https://github.com/psf/black">Black</a> has increased my productivity as a Python developer by a material amount. I used to spend a whole bunch of brain cycles agonizing over how to indent my code, where to break up long function calls and suchlike. Thanks to Black I never think about this at all—I instinctively run <code>black .</code> in the root of my project and accept whatever style decisions it applies for me.</p>
<h4>Linting</h4>
<p>I have a few linters set up to run on every commit. I can run these locally too—how to do that is <a href="https://sqlite-utils.datasette.io/en/stable/contributing.html#linting-and-formatting">documented here</a>—but I’m often a bit lazy and leave them to <a href="https://github.com/simonw/sqlite-utils/blob/main/.github/workflows/test.yml">run in CI</a>.</p>
<p>In this case one of my linters failed! I accidentally called the new command function <code>create_table()</code> when it should have been called <code>create_database()</code>. The code worked fine due to how the <code>cli.command(name=...)</code> decorator works but <code>mypy</code> <a href="https://github.com/simonw/sqlite-utils/runs/4754944593?check_suite_focus=true">complained about</a> the redefined function name. I fixed that in <a href="https://github.com/simonw/sqlite-utils/commit/2f8879235afc6a06a8ae25ded1b2fe289ad8c3a6#diff-76294b3d4afeb27e74e738daa01c26dd4dc9ccb6f4477451483a2ece1095902e">a separate commit</a>.</p>
<h4>Documentation</h4>
<p>My policy these days is that if a feature isn’t documented it doesn’t exist. Updating existing documentation isn’t much work at all if the documentation already exists, and over time these incremental improvements add up to something really comprehensive.</p>
<p>For smaller projects I use a single <code>README.md</code> which gets displayed on both GitHub and PyPI (and the Datasette website too, for example on <a href="https://datasette.io/tools/git-history">datasette.io/tools/git-history</a>).</p>
<p>My larger projects, such as <a href="https://docs.datasette.io/">Datasette</a> and <a href="https://sqlite-utils.datasette.io/">sqlite-utils</a>, use <a href="https://readthedocs.org/">Read the Docs</a> and <a href="https://www.sphinx-doc.org/en/master/usage/restructuredtext/basics.html">reStructuredText</a> with <a href="https://www.sphinx-doc.org/">Sphinx</a> instead.</p>
<p>I like reStructuredText mainly because it has really good support for internal reference links—something that is missing from Markdown, though it can be enabled using <a href="https://myst-parser.readthedocs.io">MyST</a>.</p>
<p><code>sqlite-utils</code> uses Sphinx. I have the <a href="https://github.com/executablebooks/sphinx-autobuild">sphinx-autobuild</a> extension configured, which means I can run a live reloading server with the documentation like so:</p>
<pre><code>cd docs
make livehtml
</code></pre>
<p>Any time I’m working on the documentation I have that server running, so I can hit “save” in VS Code and see a preview in my browser a few seconds later.</p>
<p>For Markdown documentation I use the VS Code preview pane directly.</p>
<p>The moment the documentation is live online, I like to add a link to it in a comment on the issue thread.</p>
<h4>Committing the change</h4>
<p>I run <code>git diff</code> a LOT while hacking on code, to make sure I haven’t accidentally changed something unrelated. This also helps spot things like rogue <code>print()</code> debug statements I may have added.</p>
<p>Before my final commit, I sometimes even run <code>git diff | grep print</code> to check for those.</p>
<p>My goal with the commit is to bundle the test, documentation and implementation. If those are the only files I’ve changed I do this:</p>
<pre><code>git commit -a -m &#34;sqlite-utils create-database command, closes #348&#34;
</code></pre>
<p>If this completes the work on the issue I use &#34;<code>closes #N</code>“, which causes GitHub to close the issue for me. If it’s not yet ready to close I use ”<code>refs #N</code>&#34; instead.</p>
<p>Sometimes there will be unrelated changes in my working directory. If so, I use <code>git add &lt;files&gt;</code> and then commit just with <code>git commit -m message</code>.</p>
<h4>Branches and pull requests</h4>
<p><code>create-database</code> is a good example of a feature that can be implemented in a single commit, with no need to work in a branch.</p>
<p>For larger features, I’ll work in a feature branch:</p>
<pre><code>git checkout -b my-feature
</code></pre>
<p>I’ll make a commit (often just labelled “WIP prototype, refs #N”) and then push that to GitHub and open a pull request for it:</p>
<pre><code>git push -u origin my-feature 
</code></pre>
<p>I ensure the new pull request links back to the issue in its description, then switch my ongoing commentary to comments on the pull request itself.</p>
<p>I’ll sometimes add a task checklist to the opening comment on the pull request, since tasks there get reflected in the GitHub UI anywhere that links to the PR. Then I’ll check those off as I complete them.</p>
<p>An example of a PR I used like this is <a href="https://github.com/simonw/sqlite-utils/pull/361">#361: --lines and --text and --convert and --import</a>.</p>
<p>I don’t like merge commits—I much prefer to keep my <code>main</code> branch history as linear as possible. I usually merge my PRs through the GitHub web interface using the squash feature, which results in a single, clean commit to main with the combined tests, documentation and implementation. Occasionally I will see value in keeping the individual commits, in which case I will rebase merge them.</p>
<p>Another goal here is to keep the <code>main</code> branch releasable at all times. Incomplete work should stay in a branch. This makes turning around and releasing quick bug fixes a lot less stressful!</p>
<h4>Release notes, and a release</h4>
<p>A feature isn’t truly finished until it’s been released to <a href="https://pypi.org/">PyPI</a>.</p>
<p>All of my projects are configured the same way: they use GitHub releases to trigger a GitHub Actions workflow which publishes the new release to PyPI. The <code>sqlite-utils</code> workflow for that <a href="https://github.com/simonw/sqlite-utils/blob/main/.github/workflows/publish.yml">is here in publish.yml</a>.</p>
<p>My <a href="https://cookiecutter.readthedocs.io/">cookiecutter</a> templates for new projects set up this workflow for me. I just need to create a PyPI token for the project and assign it as a repository secret. See the <a href="https://github.com/simonw/python-lib">python-lib cookiecutter README</a> for details.</p>
<p>To push out a new release, I need to increment the version number in <a href="https://github.com/simonw/sqlite-utils/blob/main/setup.py">setup.py</a> and write the release notes.</p>
<p>I use <a href="https://semver.org/">semantic versioning</a>—a new feature is a minor version bump, a breaking change is a major version bump (I try very hard to avoid these) and a bug fix or documentation-only update is a patch increment.</p>
<p>Since <code>create-database</code> was a new feature, it went out in <a href="https://github.com/simonw/sqlite-utils/releases/3.21">release 3.21</a>.</p>
<p>My projects that use Sphinx for documentation have <a href="https://github.com/simonw/sqlite-utils/blob/main/docs/changelog.rst">changelog.rst</a> files in their repositories. I add the release notes there, linking to the relevant issues and cross-referencing the new documentation. Then I ship a commit that bundles the release notes with the bumped version number, with a commit message that looks like this:</p>
<pre><code>git commit -m &#34;Release 3.21

Refs #348, #364, #366, #368, #371, #372, #374, #375, #376, #379&#34;
</code></pre>
<p>Here’s <a href="https://github.com/simonw/sqlite-utils/commit/7c637b11805adc3d3970076a7ba6afe8e34b371e">the commit for release 3.21</a>.</p>
<p>Referencing the issue numbers in the release automatically adds a note to their issue threads indicating the release that they went out in.</p>
<p>I generate that list of issue numbers by pasting the release notes into an Observable notebook I built for the purpose: <a href="https://observablehq.com/@simonw/extract-issue-numbers-from-pasted-text">Extract issue numbers from pasted text</a>. Observable is really great for building this kind of tiny interactive utility.</p>
<p>For projects that just have a README I write the release notes in Markdown and paste them directly into the GitHub “new release” form.</p>
<p>I like to duplicate the release notes to GiHub releases for my Sphinx changelog projects too. This is mainly so the <a href="https://datasette.io/">datasette.io</a> website will display the release notes on its homepage, which is populated <a href="https://simonwillison.net/2020/Dec/13/datasette-io/">at build time</a> using the GitHub GraphQL API.</p>
<p>To convert my reStructuredText to Markdown I copy and paste the rendered HTML into this brilliant <a href="https://euangoddard.github.io/clipboard2markdown/">Paste to Markdown</a> tool by <a href="https://github.com/euangoddard">Euan Goddard</a>.</p>
<h4>A live demo</h4>
<p>When possible, I like to have a live demo that I can link to.</p>
<p>This is easiest for features in Datasette core. Datesette’s main branch gets <a href="https://github.com/simonw/datasette/blob/0.60a1/.github/workflows/deploy-latest.yml#L51-L73">deployed automatically</a> to <a href="https://latest.datasette.io/">latest.datasette.io</a> so I can often link to a demo there.</p>
<p>For Datasette plugins, I’ll deploy a fresh instance with the plugin (e.g. <a href="https://datasette-graphql-demo.datasette.io/">this one for datasette-graphql</a>) or (more commonly) add it to my big <a href="https://latest-with-plugins.datasette.io/">latest-with-plugins.datasette.io</a> instance—which tries to demonstrate what happens to Datasette if you install dozens of plugins at once (so far it works OK).</p>
<p>Here’s a demo of the <a href="https://datasette.io/plugins/datasette-copyable">datasette-copyable plugin</a> running there:  <a href="https://latest-with-plugins.datasette.io/github/commits.copyable">https://latest-with-plugins.datasette.io/github/commits.copyable</a></p>
<h4>Tell the world about it</h4>
<p>The last step is to tell the world (beyond the people who meticulously read the release notes) about the new feature.</p>
<p>Depending on the size of the feature, I might do this with a tweet <a href="https://twitter.com/simonw/status/1455266746701471746">like this one</a>—usually with a screenshot and a link to the documentation. I often extend this into a short Twitter thread, which gives me a chance to link to related concepts and demos or add more screenshots.</p>
<p>For larger or more interesting feature I’ll blog about them. I may save this for my weekly <a href="https://simonwillison.net/tags/weeknotes/">weeknotes</a>, but sometimes for particularly exciting features I’ll write up a dedicated blog entry. Some examples include:</p>
<ul>
<li><a href="https://simonwillison.net/2020/Sep/23/sqlite-advanced-alter-table/">Executing advanced ALTER TABLE operations in SQLite</a></li>
<li><a href="https://simonwillison.net/2020/Jul/30/fun-binary-data-and-sqlite/">Fun with binary data and SQLite</a></li>
<li><a href="https://simonwillison.net/2020/Sep/23/sqlite-utils-extract/">Refactoring databases with sqlite-utils extract</a></li>
<li><a href="https://simonwillison.net/2021/Jun/19/sqlite-utils-memory/">Joining CSV and JSON data with an in-memory SQLite database</a></li>
<li><a href="https://simonwillison.net/2021/Aug/6/sqlite-utils-convert/">Apply conversion functions to data in SQLite columns with the sqlite-utils CLI tool</a></li>
</ul>
<p>I may even assemble a full set of <a href="https://simonwillison.net/tags/annotatedreleasenotes/">annotated release notes</a> on my blog, where I quote each item from the release in turn and provide some fleshed out examples plus background information on why I built it.</p>
<p>If it’s a new Datasette (or Datasette-adjacent) feature, I’ll try to remember to write about it in the next edition of the <a href="https://datasette.substack.com/">Datasette Newsletter</a>.</p>
<p>Finally, if I learned a new trick while building a feature I might extract that into <a href="https://til.simonwillison.net/">a TIL</a>. If I do that I’ll link to the new TIL from the issue thread.</p>
<h4>More examples of this pattern</h4>
<p>Here are a bunch of examples of commits that implement this pattern, combining the tests, implementation and documentation into a single unit:</p>
<ul>
<li>sqlite-utils: <a href="https://github.com/simonw/sqlite-utils/commit/324ebc31308752004fe5f7e4941fc83706c5539c">adding —limit and —offset to sqlite-utils rows</a>
</li>
<li>sqlite-utils: <a href="https://github.com/simonw/sqlite-utils/commit/d83b2568131f2b1cc01228419bb08c96d843d65d">--where and -p options for sqlite-utils convert</a>
</li>
<li>s3-credentials: <a href="https://github.com/simonw/s3-credentials/commit/905258379817e8b458528e4ccc5e6cc2c8cf4352">s3-credentials policy command</a>
</li>
<li>datasette: <a href="https://github.com/simonw/datasette/commit/5cadc244895fc47e0534c6e90df976d34293921e">db.execute_write_script() and db.execute_write_many()</a>
</li>
<li>datasette: <a href="https://github.com/simonw/datasette/commit/992496f2611a72bd51e94bfd0b17c1d84e732487">?_nosuggest=1 parameter for table views</a>
</li>
<li>datasette-graphql: <a href="https://github.com/simonw/datasette-graphql/commit/2d8c042e93e3429c5b187121d26f8817997073dd">GraphQL execution limits: time_limit_ms and num_queries_limit</a>
</li>
</ul>




</div>

</div></div>
  </body>
</html>
