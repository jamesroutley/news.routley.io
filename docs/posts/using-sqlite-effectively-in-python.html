<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://iafisher.com/blog/2021/10/using-sqlite-effectively-in-python">Original</a>
    <h1>Using SQLite effectively in Python</h1>
    
    <div id="readability-page-1" class="page"><div class="page">
  
  

  <p>I use <a href="https://sqlite.org/index.html">SQLite</a> as the database for my personal projects in Python. It is <a href="https://sqlite.org/serverless.html">lightweight</a>, <a href="https://sqlite.org/hirely.html">reliable</a>, <a href="https://sqlite.org/lang.html">well-documented</a>, and <a href="https://sqlite.org/appfileformat.html">better than the filesystem</a> for persistent storage. I&#39;d like to share a few lessons I have learned on using SQLite effectively in Python.</p>
<p>The official documentation for Python&#39;s <code>sqlite3</code> module already has a section on <a href="https://docs.python.org/3/library/sqlite3.html#using-sqlite3-efficiently">&#34;Using <code>sqlite3</code> efficiently&#34;</a>. It&#39;s worth reading that first, as this post covers different topics.</p>
<h2>Turn on foreign key enforcement</h2>
<p>Foreign key constraints are not enforced by default in SQLite. If you want the database to prevent you from inserting invalid foreign keys, then you must run <code>PRAGMA foreign_keys = 1</code> to turn enforcement on. Note that this pragma command must be run <strong>outside of a transaction</strong>; if you run it while a transaction is active, it will <a href="https://sqlite.org/pragma.html#pragma_foreign_keys">silently do nothing</a>.</p>
<p>Since I prefer for my database to detect invalid foreign keys for me, and since (as we&#39;ll see below) the Python&#39;s <code>sqlite3</code> module will sometimes open transactions implicitly, I run <code>PRAGMA foreign_keys = 1</code> right after I open the connection to the database.</p>
<h2>Manage your transactions explicitly</h2>
<p>By default, the underlying SQLite library operates in <code>autocommit</code> mode, in which changes are committed immediately unless a transaction has been opened with <code>BEGIN</code> or <code>SAVEPOINT</code>. You can verify this by opening the same database file with the <code>sqlite3</code> command-line shell in two different terminals at the same time, and observing that, e.g., a row inserted in one terminal will be returned by a <code>SELECT</code> statement run in the other. Once you open a transaction with <code>BEGIN</code>, however, subsequent changes will <em>not</em> be visible to the other terminal until you commit the transaction with <code>COMMIT</code>.</p>
<p>Python&#39;s <code>sqlite3</code> module <a href="https://docs.python.org/3/library/sqlite3.html#controlling-transactions">does not</a> operate in <code>autocommit</code> mode. Instead, it will start a transaction before data manipulation language (DML) statements<sup id="fnref:dml"><a href="#fn:dml">1</a></sup> such as <code>INSERT</code> and <code>UPDATE</code>, and, until Python 3.6, data definition language (DDL) statements such as <code>CREATE TABLE</code>.</p>
<p>Opening a transaction in SQLite has several implications:</p>
<ol>
<li>You will not be able to open a transaction in the same process with <code>BEGIN</code>.</li>
<li>You will not be able to open a write transaction in a different process, since by default SQLite only allows <a href="https://sqlite.org/lang_transaction.html">one write transaction at a time</a>.</li>
<li>You will not be able to enable or disable foreign key constraint enforcement.</li>
</ol>
<p>These consequences can come as a surprise when <code>sqlite3</code> has silently opened a transaction without your knowledge. Even worse, the <code>Connection.close</code> method <a href="https://docs.python.org/3/library/sqlite3.html#sqlite3.Connection.close">will not commit an open transaction</a>, so you have to manually commit the transaction that <code>sqlite3</code> automatically opened.</p>
<p>I prefer to manage my transactions explicitly. To do so, pass <code>isolation_level=None</code> as an argument to <code>sqlite3.connect</code>, which will leave the database in the default <code>autocommit</code> mode and allow you to issue <code>BEGIN</code>, <code>COMMIT</code>, and <code>ROLLBACK</code> statements yourself.</p>
<h2>Use adapters and converters (with caution)</h2>
<p>Python&#39;s <code>sqlite3</code> module allows you to register <strong>adapters</strong> to convert Python objects to SQLite values, and <strong>converters</strong> to convert SQLite values to Python objects (based on the type of the column). <code>sqlite3</code> <a href="https://docs.python.org/3/library/sqlite3.html#default-adapters-and-converters">automatically registers</a> converters for <code>DATE</code> and <code>TIMESTAMP</code> columns, and corresponding adapters for Python <code>date</code> and <code>datetime</code> objects. Adapters are enabled by default, while converters must be explicitly enabled with the <code>detect_types</code> parameter to <code>sqlite3.connect</code>.</p>
<p>In addition to the default converters, I register my own for <code>DECIMAL</code>, <code>BOOLEAN</code>, and <code>TIME</code> columns, to convert them to <code>decimal.Decimal</code>, <code>bool</code>, and <code>datetime.time</code> values, respectively.</p>
<p>Python&#39;s default <code>TIMESTAMP</code> converter <a href="https://bugs.python.org/issue45335">ignores UTC offsets</a> in the database row and always returns a <a href="https://docs.python.org/3/library/datetime.html#aware-and-naive-objects">naive</a> datetime object. If your <code>TIMESTAMP</code> rows contain UTC offsets, you can register your own converter to return aware datetime objects:<sup id="fnref:fromisoformat"><a href="#fn:fromisoformat">2</a></sup></p>
<div><pre><span></span><code><span>import</span> <span>datetime</span>
<span>import</span> <span>sqlite3</span>

<span>sqlite3</span><span>.</span><span>register_converter</span><span>(</span><span>&#34;TIMESTAMP&#34;</span><span>,</span> <span>datetime</span><span>.</span><span>datetime</span><span>.</span><span>fromisoformat</span><span>)</span>
</code></pre></div>

<p>Keep in mind that it is <a href="https://stackoverflow.com/a/33465436/">generally considered</a> better practice to store time zone information as a string identifier from the <a href="https://www.iana.org/time-zones">IANA time zone database</a> in a separate column, rather than use UTC offsets, which change often (e.g., due to daylight saving time).</p>
<p>Adapters and converters are registered globally, not per-database. Be warned that some Python libraries, like Django, <a href="https://github.com/django/django/blob/stable/3.2.x/django/db/backends/sqlite3/base.py#L75-L80">register their own adapters and converters</a> which will apply even if you use the raw <code>sqlite3</code> interface instead of, e.g., Django&#39;s ORM.</p>
<h2>Beware of column affinity</h2>
<p>SQLite lets you declare columns with any type that you want (or none at all). This can work nicely with Python&#39;s converters and adapters; for example, in one of my projects, I had columns of type <code>CSV</code> and used a converter and an adapter to transparently convert them to Python lists and back.</p>
<p>Although SQLite is flexible with typing, ultimately it must choose a <a href="https://sqlite.org/datatype3.html#storage_classes_and_datatypes">storage class</a> for data, either <code>TEXT</code>, <code>NUMERIC</code>, <code>INTEGER</code>, <code>REAL</code>, or <code>BLOB</code>. Columns have a &#34;type affinity&#34; which determines the preferred storage class for a column through a <a href="https://sqlite.org/datatype3.html#determination_of_column_affinity">somewhat arbitrary set of rules</a>. This ensures that inserting a string into an <code>INT</code> column will convert the string to an integer, for compatibility with other, rigidly-typed database engines.</p>
<p>A corollary of SQLite&#39;s flexible typing is that <a href="https://www.sqlite.org/datatype3.html">different values in the same column can have different type affinities</a>:</p>
<blockquote>
<p>In SQLite, the datatype of a value is associated with the value itself, not with its container.</p>
</blockquote>
<p>This can cause problems. I once wanted to copy some rows from one table to another. My rows had <code>TIMESTAMP</code> columns, and since, as we saw, Python will silently drop UTC offsets, I replaced Python&#39;s <code>TIMESTAMP</code> converter with one that simply returns the bytes object unchanged:</p>
<div><pre><span></span><code><span>sqlite3</span><span>.</span><span>register_converter</span><span>(</span><span>&#34;TIMESTAMP&#34;</span><span>,</span> <span>lambda</span> <span>b</span><span>:</span> <span>b</span><span>)</span>
</code></pre></div>

<p>Unfortunately, this converter resulted in the new <code>TIMESTAMP</code> columns having <code>BLOB</code> affinity instead of <code>TEXT</code>. This was a problem, because some SQL operations are sensitive to the affinities of their operands. One of them is <code>LIKE</code>, which does not work on blob values:</p>
<div><pre><span></span><code><span>sqlite</span><span>&gt;</span> <span>SELECT</span> <span>&#39;a&#39;</span> <span>LIKE</span> <span>&#39;a&#39;</span><span>;</span>
<span>1</span>
<span>sqlite</span><span>&gt;</span> <span>SELECT</span> <span>X</span><span>&#39;61&#39;</span><span>;</span>  <span>-- 0x61 is the hexadecimal value of ASCII &#39;a&#39;</span>
<span>a</span>
<span>sqlite</span><span>&gt;</span> <span>SELECT</span> <span>X</span><span>&#39;61&#39;</span> <span>LIKE</span> <span>&#39;a&#39;</span><span>;</span>
<span>0</span>
</code></pre></div>

<p>Consequently, the query <code>SELECT * FROM table WHERE date LIKE &#39;2019%&#39;</code> did not return any of the inserted rows because they all had <code>BLOB</code> affinity and the <code>LIKE</code> comparison always failed. Only when I ran <code>SELECT typeof(date) FROM table</code> did I discover that some of the values in the same column had different affinities.</p>
<p>The correct procedure would have been to register the converter as <code>lambda b: b.decode()</code> so that Python would insert string values with <code>TEXT</code> affinity.<sup id="fnref:why-converters"><a href="#fn:why-converters">3</a></sup></p>
<h2>Conclusion</h2>
<p>Because I use SQLite in Python so often, I wrote my own library, <a href="https://github.com/iafisher/isqlite">isqlite</a>, that handles most of these issues for me, and also provides a more convenient Python API and many other useful features. You can read about isqlite in <a href="https://iafisher.com/blog/2021/10/isqlite">next week&#39;s blog post</a>. ∎</p>


  

  <hr/>
  <p><strong>Disclaimer:</strong> I occasionally make corrections and changes to posts after I publish them. You can view
    the full history of this post <a href="https://github.com/iafisher/blog/commits/master/2021-10-using-sqlite-in-python.md">on
    GitHub</a>.
  </p>
</div></div>
  </body>
</html>
