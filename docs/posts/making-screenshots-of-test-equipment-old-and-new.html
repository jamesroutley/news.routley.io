<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tomverbeure.github.io/2024/11/29/Making-Screenshots-of-Test-Equipment.html">Original</a>
    <h1>Making Screenshots of Test Equipment Old and New</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <ul id="markdown-toc">
  <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li>
  <li><a href="#screenshot-capturing-interfaces" id="markdown-toc-screenshot-capturing-interfaces">Screenshot Capturing Interfaces</a></li>
  <li><a href="#hardware-and-software-tools" id="markdown-toc-hardware-and-software-tools">Hardware and Software Tools</a></li>
  <li><a href="#capturing-gpib-data-in-talk-only-mode" id="markdown-toc-capturing-gpib-data-in-talk-only-mode">Capturing GPIB data in Talk Only mode</a></li>
  <li><a href="#tds-540-oscilloscope---gpib---pcl-output" id="markdown-toc-tds-540-oscilloscope---gpib---pcl-output">TDS 540 Oscilloscope - GPIB - PCL Output</a></li>
  <li><a href="#hp-54542a-oscilloscope---parallel-port---pcl-or-hpgl-output" id="markdown-toc-hp-54542a-oscilloscope---parallel-port---pcl-or-hpgl-output">HP 54542A Oscilloscope - Parallel Port - PCL or HPGL Output</a></li>
  <li><a href="#hp-inifinium-54825a-oscilloscope---parallel-port---encapsulated-postscript" id="markdown-toc-hp-inifinium-54825a-oscilloscope---parallel-port---encapsulated-postscript">HP Inifinium 54825A Oscilloscope - Parallel Port - Encapsulated Postscript</a></li>
  <li><a href="#tds-684b---parallel-port---pcx-color-output" id="markdown-toc-tds-684b---parallel-port---pcx-color-output">TDS 684B - Parallel Port - PCX Color Output</a></li>
  <li><a href="#advantest-r3273-spectrum-analyzer---parallel-port---pcl-output" id="markdown-toc-advantest-r3273-spectrum-analyzer---parallel-port---pcl-output">Advantest R3273 Spectrum Analyzer - Parallel Port - PCL Output</a></li>
  <li><a href="#hp-8753c-vector-network-analyzer---gpib---hp-8753-companion" id="markdown-toc-hp-8753c-vector-network-analyzer---gpib---hp-8753-companion">HP 8753C Vector Network Analyzer - GPIB - HP 8753 Companion</a></li>
  <li><a href="#siglent-sds-2304x-oscilloscope---usb-drive-ethernet-or-usb" id="markdown-toc-siglent-sds-2304x-oscilloscope---usb-drive-ethernet-or-usb">Siglent SDS 2304X Oscilloscope - USB Drive, Ethernet or USB</a></li>
</ul>



<p>Last year, I created <a href="https://tomverbeure.github.io/2023/01/24/Fake-Parallel-Printer-Capture-Tool-HW.html">Fake Parallel Printer</a>,
a tool to capture the output of the parallel printer port of old-ish test equipment so that
it can be converted into screenshots for blog posts etc.</p>

<p><img src="https://tomverbeure.github.io/assets/parallelprintcap/fake_printer_v1_assembled.jpg" alt="Fake parallel printer photo"/></p>

<p>It’s definitely a niche tool, but of all the projects that I’ve done, it’s definitely
the one that has seen the most amount of use.</p>

<p>One issue is that converting the captured raw printing data to a bitmap requires recipes
that may need quite a bit of tuning. Some equipment uses HP PCL, other Encapsulated 
Postscript (EPS), if you’re lucky the output is a standard bitmap format like PCX.</p>

<p>In the blog post, I describe the procedures to create screenshots of the test equipment 
that I personally own, so that I don’t need to figure it out again when I use the device a
year later.</p>

<p>That doesn’t make it all that useful for others, but somebody may benefit from it when googling
for it… As always, I’m using Linux so the software used below reflects that.</p>



<p>Here are some common ways to transfer screenshots from test equipment to your PC:</p>

<ul>
  <li>
    <p>USB flash drive</p>

    <p>Usually the least painless by far, but it only works on modern equipment.</p>
  </li>
  <li>
    <p>USB cable</p>

    <p>Requires some effort to set the right <code>udev</code> driver permissions and a script that 
  sends commands that are device specific. But it generally works fine.</p>
  </li>
  <li>
    <p>Ethernet</p>

    <p>Still requires slightly modern equipment, and there’s often some configuration pain
  involved.</p>
  </li>
  <li>
    <p>RS-232 serial</p>

    <p>Reliable, but often slow.</p>
  </li>
  <li>
    <p>Floppy disk</p>

    <p>I have a bunch of test equipment with a floppy drive and I also have a USB floppy drive
  for my PC. However, the drives on all this equipment is broken, in the sense that it can’t
  correctly write data to a disc. There must be some kind of contamination going on when a
  floppy drive head isn’t used for decades.</p>
  </li>
  <li>
    <p>GPIB</p>

    <p>Requires an expensive interface dongle and I’ve yet to figure out how to make it
  work for all equipment. Below, I was able to make it work for a TDS 540 oscilloscope, but not for
  an HP 54532A oscilloscope, for example.</p>
  </li>
  <li>
    <p>Parallel printer port</p>

    <p>Available on a lot of old equipment, but it normally can’t be captured by a PC unless
  you use <a href="https://tomverbeure.github.io/2023/01/24/Fake-Parallel-Printer-Capture-Tool-HW.html">Fake Parallel Printer</a>.</p>

    <p>We’re now more than a year later, and I use it all the time. I find it to be the easiest
  to use of all the printer interfaces.</p>
  </li>
</ul>



<p><strong>GPIB to USB Dongle</strong></p>

<p>If you want to print to GPIB, you’ll need a PC to GPIB interface. These days, the cheapest and
most common are GPIB to USB dongles. I’ve written about those <a href="https://tomverbeure.github.io/2020/06/27/Tektronix-TDS420A-Remote-Control-over-GPIB.html">here</a>
and <a href="https://tomverbeure.github.io/2023/01/29/Installing-Linux-GPIB-Drivers-for-the-Agilent-82357B.html">here</a>.</p>

<p><img src="https://tomverbeure.github.io/assets/agilent_gpib/agilent_82357b.jpg" alt="Agilent 82357B GPIB to USB dongle"/></p>

<p>The biggest take-away is that they’re expensive (&gt;$100 second hand) and hard to configure when using
Linux. And as mentioned above, I have only had limited success at using them in printer mode.</p>

<p><strong>ImageMagick</strong></p>

<p>ImageMagick is the swiss army knife of bitmap file processing. It has a million features,
but I primarily use it for file format conversion and image cropping.</p>

<p>I doubt that there’s any major Linux distribution that doesn’t have it as a standard
package…</p>

<div><div><pre><code><span>sudo </span>apt <span>install </span>imagemagick
</code></pre></div></div>

<p><strong>GhostPCL</strong></p>

<p>GhostPCL is used to decode PCL files. On many old machines, these files are created
when printing to Thinkjet, Deskjet or Laserjet.</p>

<p>Installation:</p>

<ul>
  <li>Download the <a href="https://www.ghostscript.com/releases/gpcldnld.html">GhostPCL/GhostPDL source code</a>.</li>
  <li>Compile</li>
</ul>

<div><div><pre><code><span>cd</span> ~/tools
<span>tar </span>xfv ~/Downloads/ghostpdl-10.03.0.tar.gz
<span>cd </span>ghostpdl-10.03.0/
./configure <span>--prefix</span><span>=</span>/opt/ghostpdl
make <span>-j</span><span>$(</span><span>nproc</span><span>)</span>
<span>export </span><span>PATH</span><span>=</span><span>&#34;/opt/ghostpdl/bin:</span><span>$PATH</span><span>&#34;</span>
</code></pre></div></div>

<ul>
  <li>Install</li>
</ul>



<p>A whole bunch of tools will now be available in <code>/opt/ghostpdl/bin</code>, including
<code>gs</code> (Ghostscript) and <code>gpcl6</code>.</p>

<p><strong>hp2xx</strong></p>

<p>hp2xx converts HPGL files, originally intended for HP plotter, to bitmaps, EPS etc.</p>

<p>It’s available as a standard package for Ubuntu:</p>



<p><strong>Inkscape</strong></p>

<p><a href="https://inkscape.org/">Inkscape</a> is full-featured vector drawing app, but it can also
be used as a command line tool to convert vector content to bitmaps. I use it to
convert Encapsulated Postscript file (EPS) to bitmaps.</p>

<p>Like other well known tools, installation on Ubuntu is simple:</p>

<div><div><pre><code><span>sudo </span>apt <span>install </span>inkscape
</code></pre></div></div>

<p><strong>HP 8753C Companion</strong></p>

<p>This tool is specific to HP 8753 vector network analyzers. It captures HPGL
plotter commands, extracts the data, recreates what’s displayed on the screen,
and allow you to interact with it.</p>

<p>It’s available on <a href="https://github.com/VK2BEA/HP8753-Companion">GitHub</a>.</p>



<p>Some devices will only print to GPIB in Talk Only mode, or sometimes it’s just
easier to use that way.</p>

<p>When the device is in Talk Only mode, the PC GPIB controller becomes a Listen Only device,
a passive observer that doesn’t initiate commands but just receives data.</p>

<p><img src="https://tomverbeure.github.io/assets/print_file_conversion/tds540_talk_only_mode.png" alt="TDS540 in talk-only mode"/></p>

<p>I wrote the following script to record the printing data and save it to 
a file:</p>

<p><a href="https://tomverbeure.github.io/assets/print_file_conversion/gpib_talk_to_file.py"><code>gpib_talk_to_file.py</code></a>:
<em>(Click to download)</em></p>
<div><div><pre><code><span>#! /usr/bin/env python3
</span>
<span>import</span> <span>sys</span>
<span>import</span> <span>pyvisa</span>

<span>gpib_addr</span>       <span>=</span> <span>int</span><span>(</span><span>sys</span><span>.</span><span>argv</span><span>[</span><span>1</span><span>])</span>
<span>output_filename</span> <span>=</span> <span>sys</span><span>.</span><span>argv</span><span>[</span><span>2</span><span>]</span>

<span>rm</span> <span>=</span> <span>pyvisa</span><span>.</span><span>ResourceManager</span><span>()</span>

<span>inst</span> <span>=</span> <span>rm</span><span>.</span><span>open_resource</span><span>(</span><span>f</span><span>&#39;GPIB::</span><span>{</span><span>gpib_addr</span><span>}</span><span>&#39;</span><span>)</span>

<span>try</span><span>:</span>
    <span># Read data from the device
</span>    <span>data</span> <span>=</span> <span>inst</span><span>.</span><span>read_raw</span><span>()</span>

    <span>with</span> <span>open</span><span>(</span><span>output_filename</span><span>,</span> <span>&#39;wb&#39;</span><span>)</span> <span>as</span> <span>file</span><span>:</span>
        <span>file</span><span>.</span><span>write</span><span>(</span><span>data</span><span>)</span>

<span>except</span> <span>pyvisa</span><span>.</span><span>VisaIOError</span> <span>as</span> <span>e</span><span>:</span>
    <span>print</span><span>(</span><span>f</span><span>&#34;Error: </span><span>{</span><span>e</span><span>}</span><span>&#34;</span><span>)</span>
</code></pre></div></div>

<p>Pyvisa is a universal library to talk to test equipement. I wrote about
it <a href="https://tomverbeure.github.io/2020/06/07/Making-Sense-of-Test-and-Measurement-Protocols.html#visa---one-api-that-rules-them-all">here</a>.
It will quickly time out when no data arrives in Talk Only mode, but since
all data transfers happen with a valid-ready protocol, you can avoid time-out
issues by pressing the hardcopy or print button on your oscilloscope first, and
only then launch the script above.</p>

<p>This will work as long as the printing device doesn’t go silent while in the middle
of printing a page.</p>



<p><img src="https://tomverbeure.github.io/assets/print_file_conversion/TDS540.jpg" alt="TDS540 oscilloscope"/></p>

<p>My old TDS 540 oscilloscope doesn’t have a printer port, so I had to make do with
GPIB. Unlike later version of the TDS series, it also doesn’t have the ability to 
export bitmaps directly, but it has outputs for:</p>

<ul>
  <li>Thinkjet, Deskjet, and Laserjet in PCL format</li>
  <li>Epson in ESC/P format</li>
  <li>Interleaf format</li>
  <li>EPS Image format</li>
  <li>HPGL plotter format</li>
</ul>

<p>The TDS 540 has a screen resolution of 640x480. I found the Thinkjet output format,
with a DPI of 75x75, easiest to deal with. The device adds a margin of 20 pixels to the left,
and 47 pixels at the top, but those can be removed with ImageMagick.</p>

<p>With a GPIB address of 11, the overall recipe looks like this:</p>

<div><div><pre><code><span># Capture the PCL data</span>
gpib_talk_to_file.py 11 tds540.thinkjet.pcl
<span># Convert PCL to png </span>
gpcl6 <span>-dNOPAUSE</span> <span>-sOutputFile</span><span>=</span>tds540.png <span>-sDEVICE</span><span>=</span>png256 <span>-g680x574</span> <span>-r75x75</span> tds540.thinkjet.pcl
<span># Remove the margins and crop the image to 640x480</span>
convert tds540.png <span>-crop</span> 640x480+20+47 tds540.crop.png
</code></pre></div></div>

<p>The end result looks like this:</p>

<p><img src="https://tomverbeure.github.io/assets/print_file_conversion/tds540.crop.png" alt="TDS540 screenshot"/></p>



<p>This oscilloscope was an ridiculous $20 bargain at the 
<a href="https://www.electronicsfleamarket.com/">Silicon Valley Electronics Flea Market</a>
and it’s the one I love working with the most: the user interface is just so
smooth and intuitive. Like all other old oscilloscopes, the biggest thing going against
it is the amount of desk space it requires.</p>

<p><img src="https://tomverbeure.github.io/assets/print_file_conversion/54542A.jpg" alt="HP 54542A oscilloscope"/></p>

<p>It has a GPIB, RS-232, and Centronics parallel port, and all 3 can be used for printing.</p>

<p>I tried to get printing to GPIB to work but wasn’t successful: I’m able to
talk to the device and send commands like “*IDN?” and get a reply just fine, but 
the GPIB script that works fine with the TDS 540 always times out eventually.</p>

<p>I switched to my always reliable Fake Parallel Printer and that worked fine. There’s also 
the option to use the serial cable.</p>

<p>The printer settings menu can by accessed by pressing the Utility button and then 
the top soft-button with the name “HPIB/RS232/CENT CENTRONICS”.</p>

<p><img src="https://tomverbeure.github.io/assets/print_file_conversion/hp54542a_printing_options.png" alt="HP 54542A printing options"/></p>

<p>You have the following options:</p>

<ul>
  <li>ThinkJet</li>
  <li>DeskJet75dpi, DeskJet100dpi, DeskJet150dpi, DeskJet300dpi</li>
  <li>LaserJet</li>
  <li>PaintJet</li>
  <li>Plotter</li>
</ul>

<p>Unlike the TDS 540 I wasn’t able to get the <em>ThinkJet</em> option to convert into anything, but
the <em>DeskJet75dpi</em> option worked fine with this recipe:</p>

<div><div><pre><code>~/projects/fake_parallel_printer/fake_printer.py <span>-i</span> <span>-p</span> /dev/ttyACM0 <span>-f</span> hp54542a_ <span>-s</span> deskjet.pcl <span>-v</span>
gpcl6 <span>-dNOPAUSE</span> <span>-sOutputFile</span><span>=</span>hp54542a.png <span>-sDEVICE</span><span>=</span>png256 <span>-g680x700</span> <span>-r75x75</span> hp54542a_0.deskjet.pcl
convert hp54542a.png <span>-crop</span> 640x388+19+96 hp54542a.crop.png
</code></pre></div></div>
<p>The 54542A doesn’t just print out the contents of the screen, it also prints the date and adds 
the settings for the channels that are enabled, trigger options etc. The size of these additional
values depends on how many channels and other parameters are enabled.</p>

<p><img src="https://tomverbeure.github.io/assets/print_file_conversion/hp54542a_additional_info.png" alt="HP 54542A with additional info"/></p>

<p>When you select <em>PaintJet</em> or <em>Plotter</em> as output device, you have the option to select
different colors for regular channels, math channels, graticule, markers etc. So it is
possible to create nice color screenshots from this scope, even if the CRT is monochrome.</p>

<p>I tried the <em>PaintJet</em> option, and while gcpl6 was able to extract an image, the output was
much worse than the DeskJet option.</p>

<p>I had more success using the <em>Plotter</em> option. It prints out a file in HPGL format that can
be converted to a bitmap with <code>hp2xx</code>. The following recipe worked for me:</p>

<div><div><pre><code>~/projects/fake_parallel_printer/fake_printer.py <span>-i</span> <span>-p</span> /dev/ttyACM0 <span>-f</span> hp54542a_ <span>-s</span> plotter.hpgl <span>-v</span>
hp2xx <span>-m</span> png <span>-a</span> 1.4 <span>--width</span> 250 <span>--height</span> 250 <span>-c</span> 12345671 <span>-p</span> 11111111 hp54542a_0.plotter.hpgl
</code></pre></div></div>

<p>I’m not smitten with the way it looks, but if you want color, this is your best option. 
The command line options of <code>hp2xx</code> are not intuitive. Maybe it’s possible to get this to look a bit
better with some other options.</p>

<p><a href="https://tomverbeure.github.io/assets/print_file_conversion/hp54542a_0.plotter.png"><img src="https://tomverbeure.github.io/assets/print_file_conversion/hp54542a_0.plotter.png" alt="HP plotter output"/></a>
<em>Click to enlarge</em></p>



<p><img src="https://tomverbeure.github.io/assets/tdr/pulse_hp_setup_with_bnc_adaptor.jpg" alt="HP 54825A oscilloscope"/></p>

<p>This indefinite-loaner-from-a-friend oscilloscope has a small PC in it that runs an old version
of Windows. It can be connected to Ethernet, but I’ve never done that: capturing parallel printer
traffic is just too convenient.</p>

<p>On this oscilloscope, I found that printing things out as Encapsulated Postscript was the
best option. I then use inkscape to convert the screenshot to PNG:</p>

<div><div><pre><code>./fake_printer.py <span>--port</span><span>=</span>/dev/ttyACM0 <span>-t</span> 2 <span>-v</span> <span>--prefix</span><span>=</span>hp_osc_ <span>-s</span> eps
inkscape <span>-f</span> ./hp_osc_0.eps <span>-w</span> 1580 <span>-y</span><span>=</span>255 <span>-e</span> hp_osc_0.png
convert hp_osc_0.png <span>-crop</span> 1294x971+142+80 hp_osc_0_cropped.png
</code></pre></div></div>

<p>Ignore the part circled in red, that was added in post for an earlier article:</p>

<p><img src="https://tomverbeure.github.io/assets/tdr/hp_no_probe_short_pulse.png" alt="HP 54825A screenshot"/>
<em>Click to enlarge</em></p>



<p>I replaced my TDS 540 oscilloscope with a TDS 684B.</p>

<p><img src="https://tomverbeure.github.io/assets/tds_button/tds684b_front.jpg" alt="TDS 684B"/></p>

<p>On the outside they look identical. They also have the same core user interface, but the 648B 
has a color screen, a bandwidth of 1GHz, and a sample rate of 5 Gsps.</p>

<p><strong>Print formats</strong></p>

<p>The 684B also has a lot more output options:</p>

<ul>
  <li>Thinkjet, Deskjet, DeskjetC (color), Laserjet output in PCL format</li>
  <li>Epson in ESC/P format</li>
  <li>DPU thermal printer</li>
  <li>PC Paintbrush mono and color in PCX file format</li>
  <li>TIFF file format</li>
  <li>BMP mono and color format</li>
  <li>RLE color format</li>
  <li>EPS mono and color printer format</li>
  <li>EPS mono and color plotter format</li>
  <li>Interleaf .img format</li>
  <li>HPGL color plot</li>
</ul>

<p>Phew.</p>

<p>Like the HP 54542A, my unit has GPIB, parallel port, and serial port. It can also write out
the files to floppy drive.</p>

<p>So which one to use?</p>

<p>BMP is an obvious choice and supported natively by all modern PCs. The only issue is that
it gets written out without any compression so it takes over 130 seconds to capture with fake printer.
PCX is a very old bitmap file format, I used it way back in 1988 on my first Intel 8088 PC, but it
compresses with <a href="https://en.wikipedia.org/wiki/Run-length_encoding">run length encoding</a> which works
great on oscilloscope screenshots. It only take 22 seconds to print.</p>

<p>I tried the TIFF option and was happy to see that it only took 17 seconds, but the output was 
monochrome. So for color bitmap files, PCX is the way to go. The recipe:</p>

<div><div><pre><code>~/projects/fake_parallel_printer/fake_printer.py <span>-i</span> <span>-p</span> /dev/ttyACM0 <span>-f</span> tds684_ <span>-s</span> pcx <span>-v</span>
convert tds684_0.pcx tds684.png
</code></pre></div></div>

<p><img src="https://tomverbeure.github.io/assets/print_file_conversion/tds684_normal.png" alt="TDS 684B PCX screenshot with normal colors"/></p>

<p>The screenshot above uses the <em>Normal</em> color setting. The scope also has a <em>Bold</em> color
setting:</p>

<p><img src="https://tomverbeure.github.io/assets/print_file_conversion/tds684_bold.png" alt="TDS 684B screenshot with bold colors"/></p>

<p>There’s a <em>Hardcopy</em> option as well:</p>

<p><img src="https://tomverbeure.github.io/assets/print_file_conversion/tds684_hardcopy.png" alt="TDS 684B screenshot with hardcopy colors"/></p>

<p>It’s a matter of personal taste, but my preference is the <em>Normal</em> option.</p>



<p>Next up is my Advantest R3273 spectrum analyzer.</p>

<p><img src="https://tomverbeure.github.io/assets/print_file_conversion/R3273.jpg" alt="R3273 spectrum analyzer"/></p>

<p>It has a printer port, a separate parallel port that I don’t know what it’s used for, a
serial port, a GPIB port, and floppy drive that refuses to work. However, in the menus
I can only configure prints to go to floppy or to the parallel port, so fake parallel
printer is what I’m using.</p>

<p>The print configuration menu can be reached by pressing: [Config] - [Copy Config] -&gt; [Printer]:</p>

<p><img src="https://tomverbeure.github.io/assets/print_file_conversion/advantest_r3273_printer_config.png" alt="Advantest R3273 printer configuration screen"/></p>

<p>The R3273 supports a bunch of formats, but I had the hardest time getting it to create a color bitmap.
After a lot of trial and error, I ended up with this:</p>

<div><div><pre><code>~/projects/fake_parallel_printer/fake_printer.py <span>-i</span> <span>-p</span> /dev/ttyACM0 <span>-f</span> r3273_ <span>-s</span> pcl <span>-v</span>
gpcl6 <span>-dNOPAUSE</span> <span>-sOutputFile</span><span>=</span>r3273_tmp.png <span>-sDEVICE</span><span>=</span>png256 <span>-g4000x4000</span> <span>-r600x600</span> r3273_0.pcl
convert r3273_tmp.png <span>-filter</span> point <span>-resize</span> 1000 r3273_filt.png
<span>rm </span>r3273_tmp.png
convert r3273_filt.png <span>-crop</span> 640x480+315+94 r3273.png
<span>rm </span>r3273_filt.png
</code></pre></div></div>

<p>The conversion loses something in the process. The R3273 hardcopy mimics the shades of 
depressed buttons with a 4x4 pixel dither pattern:</p>

<p><img src="https://tomverbeure.github.io/assets/print_file_conversion/r3273_dither_pattern.png" alt="R3273 dither pattern"/></p>

<p>If you use a 4x4 pixel box filter and downsample by a factor of 4, this dither pattern converts
to a nice uniform gray, but the actual spectrum data gets filtered down as well:</p>

<p><img src="https://tomverbeure.github.io/assets/print_file_conversion/r3273_box_filter.png" alt="R3273 box filtered"/></p>

<p>With the recipe above, I’m using 4x4 to 1 pixel point-sampling instead, with a phase that is chosen
just right so that the black pixels of the dither pattern get picked. The highlighted buttons are now
solid black and everything looks good.</p>



<p><img src="https://tomverbeure.github.io/assets/print_file_conversion/HP8753C.jpg" alt="HP8753C"/></p>

<p>My HP 8753C VNA only has a GPIB interface, so there’s not a lot of choice there.</p>

<p>I’m using <a href="https://github.com/VK2BEA/HP8753-Companion">HP 8753 Companion</a>. It can be
used for much more than just grabbing screenshots: you can save the measured data to
a filter, upload calibration kit data and so on. It’s great!</p>

<p>You can render the screenshot the way it was plotted by the HP 8753C, like this:</p>

<p><a href="https://tomverbeure.github.io/assets/print_file_conversion/hp8753c_hpgl.png"><img src="https://tomverbeure.github.io/assets/print_file_conversion/hp8753c_hpgl.png" alt="HP 8753C HPGL screenshot"/></a>
<em>Click to enlarge</em></p>

<p>Or you can display it as in a high resolution mode, like this:</p>

<p><a href="https://tomverbeure.github.io/assets/print_file_conversion/hp8753c_hires.png"><img src="https://tomverbeure.github.io/assets/print_file_conversion/hp8753c_hires.png" alt="HP 8753C high resolution screenshot"/></a>
<em>Click to enlarge</em></p>

<p>Default color settings for the HPGL plot aren’t ideal, but everything is configurable.</p>

<p>If you don’t have one, the existence of <em>HP 8753 Companion</em> alone is a good reason to buy
a USB-to-GPIB dongle.</p>

<p><a href="https://tomverbeure.github.io/assets/print_file_conversion/hp8753c_smith_hires.png"><img src="https://tomverbeure.github.io/assets/print_file_conversion/hp8753c_smith_hires.png" alt="HP 8753C high resolution Smith chart screenshot"/></a>
<em>Click to enlarge</em></p>



<p><img src="https://tomverbeure.github.io/assets/print_file_conversion/siglent_sds2304x.jpg" alt="Siglent SDS2304X"/></p>

<p>My Siglent SDS 2304X was my first oscilloscope. It was designed 20 years later than all
the other stuff, with a modern UI and modern interfaces such as USB and Ethernet. There is
no GPIB, parallel or RS-232 serial port to be found.</p>

<p>I don’t love the scope. The UI can become slow when you’re displaying a bunch of data on the
screen and selecting something from a menu with a detentless rotary knob can be the most
infuriating experience. But it’s my daily driver because it’s not a boat anchor: even on my
messy desk I can usually create room to put it down without too much effort.</p>

<p>You’d think that I use USB or Ethernet to grab screenshots, but most of the time I just
use a USB stick and shuttle it back and forth between the scope and the PC. That’s because
setting up the connection is always a bit of pain. However, if you insist, you can set things 
up this way:</p>

<p><strong>Ethernet</strong></p>

<p>To configure Ethernet, you need to go to [Utility] -&gt; [Next Page] -&gt; [I/O] -&gt; [LAN].</p>

<p>Unlike my <a href="https://tomverbeure.github.io/2023/12/26/Controlling-an-HP-1670G-with-Your-Linux-PC-X-Server.html">HP 1670G logic analyzer</a>,
the Siglent supports DHCP but when writing this blog post, the scope refused to grab an IP
address on my network. No amount of rebooting, disabling and re-enabling DHCP helped.</p>

<p>I have gotten it to work in the past, but today it just wasn’t happening. You’ll probably understand
why using a zero-configuration USB stick becomes an attractive alternative.</p>

<p><strong>USB</strong></p>

<p>If you want to use USB, you need an old relic of a USB-B cable. It shows up like this:</p>



<div><div><pre><code>[314170.674538] usb 1-7.1: new full-speed USB device number 11 using xhci_hcd
[314170.856450] usb 1-7.1: not running at top speed; connect to a high speed hub
[314170.892455] usb 1-7.1: New USB device found, idVendor=f4ec, idProduct=ee3a, bcdDevice= 2.00
[314170.892464] usb 1-7.1: New USB device strings: Mfr=1, Product=2, SerialNumber=3
[314170.892469] usb 1-7.1: Product: SDS2304X
[314170.892473] usb 1-7.1: Manufacturer: Siglent Technologies Co,. Ltd.
[314170.892476] usb 1-7.1: SerialNumber: SDS2XJBD1R2754
</code></pre></div></div>

<p>Note 3 key parameters:</p>

<ul>
  <li>USB vendor ID: f4ec</li>
  <li>USB product ID: ee3a</li>
  <li>Product serial number: SDS2XJBD1R2754</li>
</ul>

<p>Set udev rules so that you can access this device of USB without requiring root permission by
creating an <code>/etc/udev/rules.d/99-usbtmc.rules</code> file and adding the following line:</p>

<div><div><pre><code>SUBSYSTEM==&#34;usb&#34;, ATTR{idVendor}==&#34;f4ec&#34;, ATTR{idProduct}==&#34;ee3a&#34;, MODE=&#34;0666&#34;
</code></pre></div></div>

<p>You should obviously replace the vendor ID and product ID with the one of your case.</p>

<p>Make the new udev rules active:</p>

<div><div><pre><code>sudo udevadm control --reload-rules
sudo udevadm trigger
</code></pre></div></div>

<p>You can now download screenshots with the following script:</p>

<p><a href="https://tomverbeure.github.io/2024/11/29/assets/print_file_conversion/siglent_screenshot_usb.py"><code>siglent_screenshot_usb.py</code></a>: <em>(Click to download)</em></p>
<div><div><pre><code><span>#!/usr/bin/env python3
</span>
<span>import</span> <span>argparse</span>
<span>import</span> <span>io</span>
<span>import</span> <span>pyvisa</span>
<span>from</span> <span>pyvisa.constants</span> <span>import</span> <span>StatusCode</span>

<span>from</span> <span>PIL</span> <span>import</span> <span>Image</span>

<span>def</span> <span>screendump</span><span>(</span><span>filename</span><span>):</span>
    <span>rm</span> <span>=</span> <span>pyvisa</span><span>.</span><span>ResourceManager</span><span>(</span><span>&#39;&#39;</span><span>)</span>

    <span># Siglent SDS2304X
</span>    <span>scope</span> <span>=</span> <span>rm</span><span>.</span><span>open_resource</span><span>(</span><span>&#39;USB0::0xF4EC::0xEE3A::SDS2XJBD1R2754::INSTR&#39;</span><span>)</span>
    <span>scope</span><span>.</span><span>read_termination</span> <span>=</span> <span>None</span>

    <span>scope</span><span>.</span><span>write</span><span>(</span><span>&#39;SCDP&#39;</span><span>)</span>
    <span>data</span> <span>=</span> <span>scope</span><span>.</span><span>read_raw</span><span>(</span><span>2000000</span><span>)</span>
    <span>image</span> <span>=</span> <span>Image</span><span>.</span><span>open</span><span>(</span><span>io</span><span>.</span><span>BytesIO</span><span>(</span><span>data</span><span>))</span>
    <span>image</span><span>.</span><span>save</span><span>(</span><span>filename</span><span>)</span>
    <span>scope</span><span>.</span><span>close</span><span>()</span>
    <span>rm</span><span>.</span><span>close</span><span>()</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#39;__main__&#39;</span><span>:</span>

    <span>parser</span> <span>=</span> <span>argparse</span><span>.</span><span>ArgumentParser</span><span>(</span>
        <span>description</span><span>=</span><span>&#39;Grab a screenshot from a Siglent DSO.&#39;</span><span>)</span>
    <span>parser</span><span>.</span><span>add_argument</span><span>(</span><span>&#39;--output&#39;</span><span>,</span> <span>&#39;-o&#39;</span><span>,</span> <span>dest</span><span>=</span><span>&#39;filename&#39;</span><span>,</span> <span>required</span><span>=</span><span>True</span><span>,</span>
        <span>help</span><span>=</span><span>&#39;the output filename&#39;</span><span>)</span>
    
    <span>args</span> <span>=</span> <span>parser</span><span>.</span><span>parse_args</span><span>()</span>
    <span>screendump</span><span>(</span><span>args</span><span>.</span><span>filename</span><span>)</span>
</code></pre></div></div>

<p>Once again, take note of this line</p>

<div><div><pre><code>    <span>scope</span> <span>=</span> <span>rm</span><span>.</span><span>open_resource</span><span>(</span><span>&#39;USB0::0xF4EC::0xEE3A::SDS2XJBD1R2754::INSTR&#39;</span><span>)</span>
</code></pre></div></div>

<p>and don’t forget to replace <code>0xF4EC</code>, <code>0xEE3A</code>, and <code>SDS2XJBD1R2754</code> by the correct
USB product ID, vendor ID and serial number.</p>

<p>Call the script like this:</p>

<div><div><pre><code>./siglent_screenshot_usb.py <span>-o</span> siglent_screenshot.png
</code></pre></div></div>

<p>If all goes well, you’ll get something like this:</p>

<p><img src="https://tomverbeure.github.io/assets/print_file_conversion/siglent_screenshot.png" alt="Siglent SDS2304X screenshot"/></p>


  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
