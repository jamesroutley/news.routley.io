<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.mgaudet.ca/technical/2022/8/9/faster-ruby-thoughts-from-the-outside">Original</a>
    <h1>Faster Ruby: Thoughts from the Outside</h1>
    
    <div id="readability-page-1" class="page"><div><div data-layout-label="Post Body" data-type="item" data-updated-on="1660066143428" id="item-62f298db3439a3137f850586"><div><div><div data-block-type="44" id="block-yui_3_17_2_1_1660066002795_10108"><div><p>As someone who comes from a compiler background, when asked to make a language fast, I’m sympathetic to the reaction: “Just throw a compiler at it!”. However, working on SpiderMonkey, I’ve come to the conclusion that a fast language implementation has many moving parts, and a compiler is just one part of it. </p>
<p>I’m going to get to Ruby, but before I get there, I want to take a tour briefly of some bits and pieces of SpiderMonkey that help make it a fast JavaScript engine; from that story, you may be able to intuit some of my suggestions for how Ruby ought to move forward! </p>
<h2 id="good-bones-in-a-runtime">Good Bones in a Runtime</h2>
<p>It’s taken me many years of working on SpiderMonkey to internalize some of the implications of various design choices, and how they drive good performance.  For example, let’s discuss <strong>the object model</strong>: </p>
<p>In SpiderMonkey, a JavaScript Object consists of two pieces: A set of slots, which store values, and a shape, which describes the layout of the object (which property ends up in which slot)</p>
<p>Shapes are shared across many objects with the same layout: </p>
<pre><code>var a = [];
for (var i = 0; i &lt; 1000; i++) { 
    var o = {a: 1, b: 2};
  a.push(o)
}</code></pre><p>In the above example, there are a thousand objects in the array, but all those objects share the same shape. </p>
<p>Recall as well, that JavaScript is a <a href="https://en.wikipedia.org/wiki/Prototype-based_programming">prototype language</a>; each object has a prototype; so there’s a design decision: for a given object, where do you store the prototype? </p>
<p>It could well be in a slot on the object, but that would bloat objects. Similar to how layouts are shared across many different objects, there are many objects that share a prototype. In the above example, every object in the array has a prototype of <code>Object.protoype</code>. We therefore associate the prototype of an objet not with the object itself, but rather with the shape of the object. This means that when you mutate the prototype of an object (<code>Object.setPrototypeOf</code>), we have to change the shape of the object. </p>
<p>Given that all property lookup is based on either the properties of an object, or the prototype chain of an object, we now have an excellent key upon which to build a cache for property access. In SpiderMonkey, <a href="https://www.mgaudet.ca/technical/2018/6/5/an-inline-cache-isnt-just-a-cache">these inline caches</a> are associated with property access bytecodes; each stub in the inline cache chain for a bytecode trying to do a property load like <code>o.b</code> ends up looking like this: </p>
<pre><code>if (!o.hasShape(X)) { try next stub; } 
return o.slots(X.slotOf(&#39;b&#39;))</code></pre><h2 id="inline-caches-are-stonkingly-effective">Inline Caches are Stonkingly Effective</h2>
<p>I’ve been yammering on about inline caches to pretty much anyone who will listen for years. Ever since I finally understood the power of <a href="https://jandemooij.nl/blog/cacheir/">SpiderMonkey’s CacheIR system</a>, I’ve realized that inline caches are not just a powerful technique for making method dispatch fast, but they’re actually fundamental primitives for handling a dynamic language’s dynamism. </p>
<p>So let’s look briefly at the performance possibilities brought by Inline Caches:</p>
<pre><code>Octane Scores (higher is better):
Interpreter, CacheIR, Baseline, Ion: 34252  (3.5x) (46x total)
Interpreter, CacheIR, Baseline:      9887   (2.0x) (13x total)
Interpreter, CacheIR:                4890   (6.6x)
Interpreter:                         739</code></pre><p>Now: Let me first say outright, Octane is a bad benchmark suite, and not really representative of the real web… but it runs fast and produces good enough results to share in a blog post (details <a href="https://gist.github.com/mgaudet/907610416c44357aad930458c2ef2417">here</a>).</p>
<p>With that caveat however, you can see the point of this section: well designed inline caches can be STONKINGLY EFFECTIVE: just adding our inline caches improves performance by more than 6x on this benchmark!</p>
<p>The really fascinating thing about inline caches, as they exist in SpiderMonkey, is that they serve to accelerate not just property accesses, but also most places where the dynamism of JavaScript rears its head. For example: </p>
<pre><code>function add(a,b) { return a + b; } 
var a = add(1,1);
var b = add(1,&#34;1&#34;);
var c = add(&#34;1&#34;,&#34;1&#34;);
var d = add(1.5,1);</code></pre><p>All these different cases have to be handled by the same bytecode op, <code>Add</code>. </p>
<pre><code>loc     op
——   ——
main:
00000:  GetArg 0                        # a
00003:  GetArg 1                        # a b
00006:  Add                             # (a + b)
00007:  Return                          #</code></pre><p>So, in order to make this fast, we add an Inline Cache to <code>Add</code>, where we attach a list of type-specialized stubs. So the first stub would be be specialized to the <code>Int32+Int32</code> case, the second to the <code>Int32+String</code> and so on and so forth. </p>
<p>Since typically types are relatively stable at a particular bytecode op, this strategy is very effective for speeding up execution time. </p>
<h2 id="making-ruby-fast-key-pieces">Making Ruby Fast: Key Pieces</h2>
<p>Given the above story, you would be unsurprised to hear that I would suggest starting with improving the Ruby Object model, providing shapes. </p>
<p>The good news for Ruby is that there are people from Shopify pushing this exact thing. This blog post, <a href="https://chrisseaton.com/truffleruby/rubykaigi21/">The Future Shape of Ruby Objects</a>, from Chris Seaton is a far more comprehensive and Ruby focused introduction to shapes than I wrote above, and the bug tracking this is <a href="https://bugs.ruby-lang.org/issues/18776">here</a>. </p>
<p>The second thing I’d do is invest in just enough JIT compilation technology to allow the creation of easy to reason about inline caches. Because I come from SpiderMonkey, I would almost certainly <strong>shamelessly</strong> steal the general shape of <a href="https://jandemooij.nl/blog/cacheir/">CacheIR</a>, as I think Jan de Mooij has really hit on something special with it’s design. This would likely be a very simple template-JIT, done method-at-a-time. </p>
<p>When I worked on Ruby+OMR I didn’t have a good answer for how to handle the dynamism of Ruby, due to a lack of practical experience. There was a fair amount of hope that we could recycle the JIT profiling architecture from J9, accumulating data from injected counters in a basic compilation of a method, and feeding into a higher-optimizing recompilation that would specialize further. It’s quite possible that this could work! However, having seen the inline caching architecture of SpiderMonkey, I realize now that JIT profiling would have been maybe the costliest way we could generate the data we would need for type specialization. I may well have read <a href="https://link.springer.com/chapter/10.1007/BFb0057013">this paper</a>, but I don’t think I <em>understood</em> it. </p>
<p>Today in SpiderMonkey, all our type profiling is done through our inline caches. Our top tier compiler frontend, WarpBuilder, analyzes the inline cache chains to determine what is the actual important cases we should speculate on.  We even do <a href="https://searchfox.org/mozilla-central/rev/c0bed29d643393af6ebe77aa31455f283f169202/js/src/jit/TrialInlining.h#29-48">a neat trick with ICs to power smart inlining</a>. Today, the thing I wish a project like OMR would provide most is the building blocks for a powerful inline cache system. </p>
<p>In the real world, <a href="https://pointersgonewild.com/2021/06/02/yjit-building-a-new-jit-compiler-inside-cruby/">YJIT</a> is a really interesting JIT for Ruby being built around the fascinating <a href="https://arxiv.org/pdf/1411.0352v2.pdf">Basic Block Versioning</a> (BBV) architecture that Maxime Chevalier-Boisvert built during her PhD, an architecture I and other people who have worked on SpiderMonkey really admired as innovative.  As I understand it, YJIT doesn’t need to lean on inline caching nearly as much as SpiderMonkey does, as much of the optimizations provided naturally fall out of the versioning of basic blocks. Still, in her blog post introducing YJIT, Maxime does say that even YJIT would benefit from shapes, something I definitely can believe. </p>
<h3 id="open-questions-to-me-at-least">Open Questions, to me at least</h3>
<ul>
<li><p>Does Ruby in 2022 still have problems with C-extensions? Once upon a time we were really concerned about how opaque C-extensions were. TruffleRuby used <a href="https://github.com/oracle/graal/tree/master/sulong">the really neat Sulong technology</a> to solve this. </p>
<p>Does the C-extension API need to be improved to allow a fast implementation to exist? Unsure. </p>
<p>SpiderMonkey has the advantage of working in a ‘closed world’ mostly, where native code integrations are fairly tightly coupled. This doesn’t describe Ruby Gems that lean on the C-APIs. </p>
</li>
<li><p>What kind of speedup is available for big Rails applications? If 90% of the time in an application is spent in database calls, then there’s little opportunity for improvement via JIT technologies. </p>
</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>I’ve been out of the Ruby game for a long time.  Despite that, I find myself thinking back to it frequently. Ruby+OMR was, in hindsight, perhaps a poor architectural fit. As dynamic as Java is, languages like JavaScript and Ruby mean that the pressure on compilation technology is appreciably different. </p>
<p>With the lessons I’ve learned, it seems to me that a pretty fast Ruby is probably possible. JavaScript is a pretty terrible language to make fast, and it’s achieved it (having a <a href="https://en.wikipedia.org/wiki/Browser_wars">huge performance war</a> between implementations, causing huge corporations to pour resources into JS performance helped… maybe Ruby needs a performance war). I’m glad to see the efforts coming out of Shopify — I really think they’ll pay huge dividends over the next few years. I wish that team much luck. </p>

</div></div></div></div></div></div></div>
  </body>
</html>
