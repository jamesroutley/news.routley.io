<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.instantdb.dev/essays/datalogjs">Original</a>
    <h1>Datalog in JavaScript</h1>
    
    <div id="readability-page-1" class="page"><div><p>Query engines make me feel like a wizard. I cast my incantation: ‚ÄúGive me all the directors and the movies where Arnold Schwarzenegger was a cast member‚Äù. Then charges zip through wires, algorithms churn on CPUs, and voila, an answer bubbles up.</p>
<p>How do they work? In this essay, we will build a query engine from scratch and find out. In 100 lines of Javascript, we‚Äôll supports joins, indexes, <em>and</em> find our answer for Arnold! Let‚Äôs get into it.</p>

<p>Our first step is to choose which language we‚Äôll support. SQL is the most popular, but we wouldn‚Äôt get far in 100 lines. I suggest we amble off the beaten path and make Datalog instead.</p>
<p>If you haven‚Äôt heard of Datalog, you‚Äôre in for a treat. It‚Äôs a logic-based query language that‚Äôs as powerful as SQL. We won‚Äôt cover it completely, but we‚Äôll cover enough to fit a good weekend‚Äôs worth of hacking. </p>
<p>To grok Datalog, we need to understand three ideas:</p>

<p>The first idea is about how we store data.</p>
<h2 id="sql-tables">SQL Tables</h2>
<p>SQL databases store data in different tables: </p>
<p><img src="https://paper-attachments.dropbox.com/s_FD7FF9539594E6B532630EAEC892A2984C0B1FD8174F6609827754AA4559A821_1650557040594_image.png" alt=""/></p>
<p>Here we have a <code>movie</code> table, which stores one movie per row. The record with the id <code>200</code> is <code>&#34;The Terminator&#34;</code>. </p>
<p>Notice the <code>director_id</code>. This points to a row in yet another <code>person</code> table, which keeps the director‚Äôs name, and so on.</p>
<h2 id="datalog-triples">Datalog Triples</h2>
<p>In Datalog databases, there are no tables. Or really everything is just stored in one table, the <code>triple</code> table:</p>
<p><img src="https://paper-attachments.dropbox.com/s_FD7FF9539594E6B532630EAEC892A2984C0B1FD8174F6609827754AA4559A821_1650653844960_image.png" alt=""/></p>
<p>A <code>triple</code> is a row with an <code>id</code>, <code>attribute</code>, and <code>value</code>. Triples have a curious property; with just these three columns, they can describe any kind of information! </p>
<p>How? Imagine describing a movie to someone:</p>
<blockquote>
<p>It&#39;s called &#34;The Terminator&#34;
It was released in 1987</p>
</blockquote>
<p>Those sentences conveniently translate to triples:</p>
<pre><code>[200, movie/title, &#34;The Terminator&#34;]
[200, movie/year, 1987]
</code></pre>
<p>And those sentences have a general structure; if you can describe a movie this way, you can describe tomatoes or airplanes just as well.</p>

<p>The second idea is about how we search for information. </p>
<h2 id="sql-algebra">SQL Algebra</h2>
<p>SQL has roots in relational algebra. You give the query engine a combination of clauses and statements, and it gets you back your data:</p>
<pre><code>SELECT id FROM movie WHERE year = 1987
</code></pre>
<p>This returns:</p>
<pre><code>[{id: 202}, {id: 203}, {id: 204}]
</code></pre>
<p>Voila, the movie ids for Predator, Lethal Weapon, and RoboCop. </p>
<h2 id="datalog-pattern-matching">Datalog Pattern Matching</h2>
<p>Datalog databases rely on pattern matching. We create ‚Äúpatterns‚Äù that match against triples. For example, to find all the movies released in 1987, we could use this pattern:</p>
<pre><code>[?id, movie/year, 1987]
</code></pre>
<p>Here, <code>?id</code> is a variable: we‚Äôre telling the query engine that it can be <em>any</em> value. But, the <code>attribute</code> <em>must</em> be <code>movie/year</code>, and the <code>value</code> <em>must</em> be <code>1987</code>. </p>
<p><img src="https://paper-attachments.dropbox.com/s_FD7FF9539594E6B532630EAEC892A2984C0B1FD8174F6609827754AA4559A821_1650395773008_image.png" alt=""/></p>
<p>Our query engine runs through triple after triple. Since <code>?id</code> can be anything, this matches every triple. But, the attribute <code>movie/year</code> and the value <code>1987</code> filter us down to <em>just</em> the triples we care about:</p>
<pre><code>[
  [202, movie/year, 1987],
  [203, movie/year, 1987],
  [204, movie/year, 1987],
]
</code></pre>
<p>Notice the <code>?id</code> portion; those are the ids for Predator, Lethal Weapon, and RoboCop!</p>
<h2 id="datalog-find">Datalog <code>find</code></h2>
<p>In SQL, we <em>just</em> got back ids though, while our query engine returned more. How can we support returning ids only? Let‚Äôs adjust our syntax; here‚Äôs <code>find</code>:</p>
<pre><code>{ find: [?id], 
  where: [
    [?id, movie/year, 1987]
  ] }
</code></pre>
<p>Our query engine can now use the <code>find</code> section to return what we care about. If we implement this right, we should get back:</p>
<pre><code>[[202], [203], [204]]
</code></pre>
<p>And now we‚Äôre as dandy as SQL.</p>

<p>The third idea is about how joins work. Datalog and SQL‚Äôs magic comes from them.</p>
<h2 id="sql-clauses">SQL clauses</h2>
<p>In SQL, if we wanted to find ‚ÄúThe Terminator‚Äôs‚Äù director, we could write:</p>
<pre><code>SELECT 
  person.name
FROM movie
JOIN person ON movie.director_id = person.id
WHERE movie.title = &#34;The Terminator&#34;
</code></pre>
<p>Which gets us:</p>
<pre><code>[{name: &#34;James Cameron&#34;}]
</code></pre>
<p>Pretty cool. We used the <code>JOIN</code> clause to connect the movie table with the person table, and bam, we got our director‚Äôs name.</p>
<h2 id="datalogpattern-matching">Datalog‚Ä¶Pattern Matching</h2>
<p>In Datalog, we still rely on pattern matching. The trick is to match <em>multiple</em> patterns:</p>
<pre><code>{
  find: [?directorName],
  where: [
    [?movieId, movie/title, &#34;The Terminator&#34;],
    [?movieId, movie/director, ?directorId],
    [?directorId, person/name, ?directorName],
  ],
}
</code></pre>
<p>Here we tell the query engine to match <em>three</em> patterns. The first pattern produces a list of successful triples. For each successful triple, we search again with the <em>second</em> pattern, and so on. Notice how the <code>?movieId</code> and <code>?directorId</code> are repeated; this tells our query engine that for a successful match, those values would need to be the <em>same</em> across our different searches. </p>
<p>What do I mean? Let‚Äôs make this concrete; here‚Äôs how our query engine could find The Terminator‚Äôs director:</p>
<p><img src="https://paper-attachments.dropbox.com/s_FD7FF9539594E6B532630EAEC892A2984C0B1FD8174F6609827754AA4559A821_1650461792727_image.png" alt=""/></p>
<p>The first pattern finds: </p>
<pre><code>[200, movie/title, &#34;The Terminator&#34;]. 
</code></pre>
<p>We bind <code>?movieId</code> to <code>200</code>. Now we start searching for the second pattern: </p>
<pre><code>[?movieId, movie/director, ?directorName].
</code></pre>
<p>Since <code>?movieId</code> needs to be <code>200</code>, this finds us </p>
<pre><code>[200, movie/director, 100]
</code></pre>
<p>And we can now bind <code>?directorId</code> to <code>100</code>. Time for the third pattern:</p>
<pre><code>[?directorId, person/name, ?directorName] 
</code></pre>
<p>Because <code>?directorId</code> has to be <code>100</code>, our engine finds us: </p>
<pre><code>[100, person/name, &#34;James Cameron&#34;]
</code></pre>
<p>And perfecto, the <code>?directorName</code>  is now bound to <code>&#34;James Cameron&#34;</code>! The <code>find</code> section would then return <code>[&#34;James Cameron&#34;]</code>.</p>
<hr/>
<p>Oky doke, now we grok the basics of Datalog! Let‚Äôs get to the code.</p>

<p>First things first, we need a way to represent this syntax. If you look at: </p>
<pre><code>{ find: [?id], 
  where: [
    [?id, movie/year, 1987]
  ] }
</code></pre>
<p>We could <em>almost</em> write this in Javascript. We use objects and arrays, but <code>?id</code> and <code>movie/year</code> get in the way; they would throw an error. We can fix this with a hack: let‚Äôs turn them into strings.</p>
<pre><code>{ find: [&#34;?id&#34;], 
  where: [
    [&#34;?id&#34;, &#34;movie/year&#34;, 1987]
  ] }
</code></pre>
<p>It‚Äôs less pretty, but we can now express our queries without fanfare. If a string begins with a question mark, it‚Äôs a variable. An attribute is just a string; it‚Äôs a good idea to include a namespace like <code>&#34;movie/*&#34;</code>, but we won‚Äôt force our users.</p>

<p>The next thing we‚Äôll need is sample data to play with. There‚Äôs a great datalog tutorial [1], which has the movie dataset we‚Äôve been describing. I‚Äôve taken it and adapted it to Javascript. <a href="https://github.com/stopachka/datalogJS/blob/main/src/exampeTriples.js">Here‚Äôs the file</a>.</p>
<pre><code>// exampleTriples.js
export default [
  [100, &#34;person/name&#34;, &#34;James Cameron&#34;],
  [100, &#34;person/born&#34;, &#34;1954-08-16T00:00:00Z&#34;],
  // ...
]
</code></pre>
<p>Let‚Äôs plop this in and require it: </p>
<pre><code>import exampleTriples from &#39;./exampleTriples&#39;;
</code></pre>
<p>Now for our query engine!</p>

<h2 id="goal">Goal</h2>
<p>Our first goal is to match <em>one</em> pattern with <em>one</em> triple. Here‚Äôs an example:</p>
<p><img src="https://paper-attachments.dropbox.com/s_FD7FF9539594E6B532630EAEC892A2984C0B1FD8174F6609827754AA4559A821_1650419195277_image.png" alt=""/></p>
<p>We have some variable bindings: <code>{&#34;?movieId&#34;: 200}</code>. Let‚Äôs call this a <code>context</code>.</p>
<p>Our goal is to take a pattern, a triple, and a context. We‚Äôll either return a new context:</p>
<pre><code>{&#34;?movieId&#34;: 200, &#34;?directorId&#34;: 100}
</code></pre>
<p>Or a failure. We can just say <code>null</code> means failure. </p>
<p>This could be the test we play with:</p>
<pre><code>expect(
  matchPattern(
    [&#34;?movieId&#34;, &#34;movie/director&#34;, &#34;?directorId&#34;],
    [200, &#34;movie/director&#34;, 100],
    { &#34;?movieId&#34;: 200 }
  )
).toEqual({ &#34;?movieId&#34;: 200, &#34;?directorId&#34;: 100 });
expect(
  matchPattern(
    [&#34;?movieId&#34;, &#34;movie/director&#34;, &#34;?directorId&#34;],
    [200, &#34;movie/director&#34;, 100],
    { &#34;?movieId&#34;: 202 }
  )
).toEqual(null);
</code></pre>
<h2 id="code">Code</h2>
<p>Nice, we have a plan. Let‚Äôs write the larger function first:</p>
<pre><code>function matchPattern(pattern, triple, context) {
  return pattern.reduce((context, patternPart, idx) =&gt; {
    const triplePart = triple[idx];
    return matchPart(patternPart, triplePart, context);
  }, context);
}
</code></pre>
<p>We take our pattern, and compare each part to the corresponding one in our triple:</p>
<p><img src="https://paper-attachments.dropbox.com/s_FD7FF9539594E6B532630EAEC892A2984C0B1FD8174F6609827754AA4559A821_1650457636669_image.png" alt=""/></p>
<p>So, we‚Äôd compare <code>&#34;?movieId&#34;</code> with <code>200</code>, and so on. </p>
<h2 id="matchpart">matchPart</h2>
<p>We can delegate this comparison to <code>matchPart</code>:</p>
<pre><code>function matchPart(patternPart, triplePart, context) {
  if (!context) return null;
  if (isVariable(patternPart)) {
    return matchVariable(patternPart, triplePart, context);
  }
  return patternPart === triplePart ? context : null;
}
</code></pre>
<p>First we address <code>context</code>; if <code>context</code> was <code>null</code> we must have failed before, so we just return early.</p>
<h2 id="isvariable">isVariable</h2>
<p>Next, we check if we‚Äôre looking at a variable. <code>isVariable</code> is simple enough: </p>
<pre><code>function isVariable(x) {
  return typeof x === &#39;string&#39; &amp;&amp; x.startsWith(&#34;?&#34;);
}
</code></pre>
<h2 id="matchvariable">matchVariable</h2>
<p>Now, if we <em>are</em> looking at a variable, we‚Äôd want to handle it especially: </p>
<pre><code>function matchVariable(variable, triplePart, context) {
  if (context.hasOwnProperty(variable)) {
    const bound = context[variable];
    return matchPart(bound, triplePart, context);
  }
  return { ...context, [variable]: triplePart };
}
</code></pre>
<p>We would check if we <em>already</em> have a binding for this variable. For example, when comparing <code>?movieId</code>, we‚Äôd already have the binding: ‚Äú<code>200</code>‚Äù. In this case, we just compare the bound value with what‚Äôs in our triple.</p>
<pre><code>// ...
if (context.hasOwnProperty(variable)) {
  const bound = context[variable];
  return matchPart(bound, triplePart, context);
}
// ...
</code></pre>
<p>When we compare <code>?directorId</code> though, we‚Äôd see that this variable wasn‚Äôt bound. In this case, we‚Äôd want to <em>expand</em> our context. We‚Äôd attach <code>?directorId</code> to the corresponding part in our triple (<code>100</code>).</p>
<pre><code>return { ...context, [variable]: triplePart };
</code></pre>
<p>Finally, if we weren‚Äôt looking at a variable, we would have skipped this and just checked for equality. If the pattern part and the triple part match, we keep the context; otherwise we return null: </p>
<pre><code>// ...
return patternPart === triplePart ? context : null;
// ...
</code></pre>
<p>And with that, <code>matchPattern</code> works as we like!</p>

<h2 id="goal-1">Goal</h2>
<p>Now for our second goal. We can already match one pattern with one triple. Let‚Äôs now match <em>one</em> pattern with <em>multiple</em> triples. Here‚Äôs the idea:</p>
<p><img src="https://paper-attachments.dropbox.com/s_FD7FF9539594E6B532630EAEC892A2984C0B1FD8174F6609827754AA4559A821_1650458051668_image.png" alt=""/></p>
<p>We‚Äôll have <em>one</em> pattern and a database of triples. We‚Äôll want to return the contexts for all the successful matches. Here‚Äôs the test we can play with:</p>
<pre><code>expect(
  querySingle([&#34;?movieId&#34;, &#34;movie/year&#34;, 1987], exampleTriples, {})
).toEqual([{ &#34;?movieId&#34;: 202 }, { &#34;?movieId&#34;: 203 }, { &#34;?movieId&#34;: 204 }]);
</code></pre>
<h2 id="code-1">Code</h2>
<p>Well, much of the work comes down to <code>matchPattern</code>. Here‚Äôs all <code>querySingle</code> needs to do:</p>
<pre><code>function querySingle(pattern, db, context) {
  return db
    .map((triple) =&gt; matchPattern(pattern, triple, context))
    .filter((x) =&gt; x);
}
</code></pre>
<p>We go over each triple and run <code>matchPattern</code>. This would return either a <code>context</code> (it‚Äôs a match!), or <code>null</code> (it‚Äôs a failure). We <code>filter</code> to remove the failures, and querySingle works like a charm! </p>

<h2 id="goal-2">Goal</h2>
<p>Closer and closer. Now to support joins. We need to handle <em>multiple</em> patterns:</p>
<p><img src="https://paper-attachments.dropbox.com/s_FD7FF9539594E6B532630EAEC892A2984C0B1FD8174F6609827754AA4559A821_1650462526590_image.png" alt=""/></p>
<p>So we go pattern by pattern, and find successful triples. For each successful triple, we apply the next pattern. At the end, we‚Äôll have produced progressively larger contexts.</p>
<p>Here‚Äôs the test we can play with: </p>
<pre><code>expect(
  queryWhere(
    [
      [&#34;?movieId&#34;, &#34;movie/title&#34;, &#34;The Terminator&#34;],
      [&#34;?movieId&#34;, &#34;movie/director&#34;, &#34;?directorId&#34;],
      [&#34;?directorId&#34;, &#34;person/name&#34;, &#34;?directorName&#34;],
    ],
    exampleTriples,
    {}
  )
).toEqual([
  { &#34;?movieId&#34;: 200, &#34;?directorId&#34;: 100, &#34;?directorName&#34;: &#34;James Cameron&#34; },
]);
</code></pre>
<h2 id="code-2">Code</h2>
<p>This too, is not so difficult. Here‚Äôs queryWhere: </p>
<pre><code>function queryWhere(patterns, db) {
  return patterns.reduce(
    (contexts, pattern) =&gt; {
      return contexts.flatMap((context) =&gt; querySingle(pattern, db, context));
    },
    [{}]
  );
}
</code></pre>
<p>We start off with one empty context. We then go pattern by pattern; for each pattern, we find all the successful contexts. We then take those contexts, and use them for the next pattern. By the end, we‚Äôll have all the expanded contexts, and <code>queryWhere</code> works like a charm too!</p>

<h2 id="goal-3">Goal</h2>
<p>And now we‚Äôve just about built ourselves the whole query engine! Next let‚Äôs handle <code>where</code> and <code>find</code>. </p>
<p>This could be the test we can play with:</p>
<pre><code>expect(
  query(
    {
      find: [&#34;?directorName&#34;],
      where: [
        [&#34;?movieId&#34;, &#34;movie/title&#34;, &#34;The Terminator&#34;],
        [&#34;?movieId&#34;, &#34;movie/director&#34;, &#34;?directorId&#34;],
        [&#34;?directorId&#34;, &#34;person/name&#34;, &#34;?directorName&#34;],
      ],
    },
    exampleTriples
  )
).toEqual([[&#34;James Cameron&#34;]]);
</code></pre>
<h2 id="code-3">Code</h2>
<p>Here‚Äôs <code>query</code>:</p>
<pre><code>function query({ find, where }, db) {
  const contexts = queryWhere(where, db);
  return contexts.map((context) =&gt; actualize(context, find));
}
</code></pre>
<p>Our <code>queryWhere</code> returns all the successful contexts. We can then map those, and <code>actualize</code> our <code>find</code>: </p>
<pre><code>function actualize(context, find) {
  return find.map((findPart) =&gt; {
    return isVariable(findPart) ? context[findPart] : findPart;
  });
}
</code></pre>
<p>All <code>actualize</code> does is handle variables; if we see a variable in find, we just replace it with its bound value. [^2]</p>

<p>And voila! We have a query engine. Let‚Äôs see what we can do.</p>
<p><strong>When was Alien released?</strong></p>
<pre><code>query(
  {
    find: [&#34;?year&#34;],
    where: [
      [&#34;?id&#34;, &#34;movie/title&#34;, &#34;Alien&#34;],
      [&#34;?id&#34;, &#34;movie/year&#34;, &#34;?year&#34;],
    ],
  },
  exampleTriples
)
</code></pre>
<pre><code>[[1979]]
</code></pre>
<p><strong>What do I know about the entity with the id <code>200</code> ?</strong> </p>
<pre><code>query(
  {
    find: [&#34;?attr&#34;, &#34;?value&#34;],
    where: [[200, &#34;?attr&#34;, &#34;?value&#34;]],
  },
  exampleTriples
)
</code></pre>
<pre><code>[
  [&#34;movie/title&#34;, &#34;The Terminator&#34;],
  [&#34;movie/year&#34;, 1984],
  [&#34;movie/director&#34;, 100],
  [&#34;movie/cast&#34;, 101],
  [&#34;movie/cast&#34;, 102],
  [&#34;movie/cast&#34;, 103],
  [&#34;movie/sequel&#34;, 207],
]
</code></pre>
<p>And, last by not least‚Ä¶</p>
<p><strong>Which directors shot Arnold for which movies?</strong></p>
<pre><code>query(
  {
    find: [&#34;?directorName&#34;, &#34;?movieTitle&#34;],
    where: [
      [&#34;?arnoldId&#34;, &#34;person/name&#34;, &#34;Arnold Schwarzenegger&#34;],
      [&#34;?movieId&#34;, &#34;movie/cast&#34;, &#34;?arnoldId&#34;],
      [&#34;?movieId&#34;, &#34;movie/title&#34;, &#34;?movieTitle&#34;],
      [&#34;?movieId&#34;, &#34;movie/director&#34;, &#34;?directorId&#34;],
      [&#34;?directorId&#34;, &#34;person/name&#34;, &#34;?directorName&#34;],
    ],
  },
  exampleTriples
)
</code></pre>
<p>ü§Ø</p>
<pre><code>[
  [&#34;James Cameron&#34;, &#34;The Terminator&#34;],
  [&#34;John McTiernan&#34;, &#34;Predator&#34;],
  [&#34;Mark L. Lester&#34;, &#34;Commando&#34;],
  [&#34;James Cameron&#34;, &#34;Terminator 2: Judgment Day&#34;],
  [&#34;Jonathan Mostow&#34;, &#34;Terminator 3: Rise of the Machines&#34;],
]
</code></pre>
<p>Now this is cool!</p>

<h2 id="problem">Problem</h2>
<p>Okay, but you may have already been thinking, ‚ÄúOur query engine will get slow‚Äù. </p>
<p>Let‚Äôs remember <code>querySingle</code>:</p>
<pre><code>function querySingle(pattern, db, context) {
  return db
    .map((triple) =&gt; matchPattern(pattern, triple, context))
    .filter((x) =&gt; x);
}
</code></pre>
<p>This is fine and dandy, but consider this query: </p>
<pre><code>querySingle([200, &#34;movie/title&#34;, ?movieTitle], db, {})
</code></pre>
<p>We want to find the movie title for the entity with the id <code>200</code>. SQL would have used an index to quickly nab this for us. </p>
<p>But what about our query engine? It‚Äôll have to search every single triple in our database!</p>
<h2 id="goal-4">Goal</h2>
<p>Let‚Äôs solve that. We shouldn‚Äôt need to search <em>every</em> triple for a query like this; it‚Äôs time for indexes. </p>
<p>Here‚Äôs what we can do; Let‚Äôs create <code>entity</code>, <code>attribute</code>, and <code>value</code> indexes. Something like:</p>
<pre><code>{
  entityIndex: {
    200: [
      [200, &#34;movie/title&#34;, &#34;The Terminator&#34;], [200, &#34;movie/year&#34;, 1984],
      //...
    ],
    // ...
  },
  attrIndex: {
    &#34;movie/title&#34;: [
      [200, &#34;movie/title&#34;, &#34;The Terminator&#34;],
      [202, &#34;movie/title&#34;, &#34;Predator&#34;],
      // ...
    ],
    // ...
  },
}
</code></pre>
<p>Now, if we had a pattern like this:</p>
<pre><code>[200, &#34;movie/title&#34;, ?movieTitle]
</code></pre>
<p>We could be smart about how to get all the relevant triples: since <code>200</code> isn‚Äôt a variable, we could just use the <code>entityIndex</code>. We‚Äôd grab <code>entityIndex[200]</code> , and voila we‚Äôd have reduced our search to just 7 triples! </p>
<p>We can do more, but with this we‚Äôd already have a big win.</p>
<h2 id="createdb">createDB</h2>
<p>Okay, let‚Äôs turn this into reality. We can start with a proper <code>db</code> object. We were just using <code>exampleTriples</code> before; now we‚Äôll want to keep track of indexes too. Here‚Äôs what we can do: </p>
<pre><code>function createDB(triples) {
  return {
    triples,
    entityIndex: indexBy(triples, 0),
    attrIndex: indexBy(triples, 1),
    valueIndex: indexBy(triples, 2),
  }
}
</code></pre>
<p>We‚Äôll take our triples, and start to index them.</p>
<h2 id="indexby">indexBy</h2>
<p>And <code>indexBy</code> will handle that. It can just take the triples and create a mapping:</p>
<pre><code>function indexBy(triples, idx) {
  return triples.reduce((index, triple) =&gt; {
    const k = triple[idx];
    index[k] = index[k] || [];
    index[k].push(triple);
    return index;
  }, {});
}
</code></pre>
<p>Here <code>idx</code> represents the position in the triple; 0 would be <code>entity</code>, 1 would be <code>attribute</code>, 2 would be <code>value</code>.</p>
<h2 id="querysingle-updated">querySingle, updated</h2>
<p>Now that we have indexes, we can use them in querySingle: </p>
<pre><code>export function querySingle(pattern, db, context) {
  return relevantTriples(pattern, db)
    .map((triple) =&gt; matchPattern(pattern, triple, context))
    .filter((x) =&gt; x);
}
</code></pre>
<p>The only change is <code>relevantTriples</code>. We‚Äôll lean on it to figure out which index to use.</p>
<h2 id="relevanttriples">relevantTriples</h2>
<p>Here‚Äôs all relevantTriples does: </p>
<pre><code>function relevantTriples(pattern, db) {
  const [id, attribute, value] = pattern;
  if (!isVariable(id)) {
    return db.entityIndex[id];
  }
  if (!isVariable(attribute)) {
    return db.attrIndex[attribute];
  }
  if (!isVariable(value)) {
    return db.valueIndex[value];
  }
  return db.triples;
}
</code></pre>
<p>We take the pattern. We check the id, attribute, and the value. If <em>any</em> of them aren‚Äôt variables, we can safely use the corresponding index. </p>
<p>With that, we‚Äôve made our query engine faster üôÇ</p>

<p>I hope you had a blast making this and got a sense of how query engines work to boot. If you‚Äôd like to see the source in one place, <a href="https://github.com/stopachka/datalogJS/blob/main/src/index.js">here it is</a>.</p>
<h2 id="more">More</h2>
<p>This is just the beginning. How about functions like ‚Äúgreater than‚Äù or ‚Äúsmaller than‚Äù? How about an ‚Äúor‚Äù query? Let‚Äôs not forget aggregate functions. If you‚Äôre curious about this, I‚Äôd suggest three things: </p>
<p>First go through the <a href="http://www.learndatalogtoday.org/">Learn Datalog</a> website; that‚Äôll give you a full overview Datalog. Next, I‚Äôd suggest you go through the <a href="https://sarabander.github.io/sicp/html/4_002e4.xhtml#g_t4_002e4">SICP chapter on logic programming</a>. They go much further than this essay. Finally, you can look at Nikita Tonsky‚Äôs <a href="https://tonsky.me/blog/datascript-internals/">datascript internals</a>, for what a true production version could look like.</p>
<h2 id="credits">Credits</h2>
<p>Huge credit goes to SICP. When I completed their logic chapter, I realized that query languages didn&#39;t have to be so daunting. This essay is just a simplification of their chapter, translated into Javascript. The second credit needs to go to Nikita Tonsky‚Äôs essays. His <a href="https://tonsky.me/blog/unofficial-guide-to-datomic-internals/">Datomic</a> and <a href="https://tonsky.me/blog/datascript-internals/">Datascript</a> internals essays are a goldmine. Finally, I really enjoyed <a href="http://www.learndatalogtoday.org/">Learn Datalog</a>, and used their dataset for this essay.</p>
<p><em>Thanks to Joe Averbukh, Irakli Safareli, Daniel Woelfel, Mark Shlick, Alex Reichert, Ian Sinnott, for reviewing drafts of this essay.</em></p>
<p>[1]: ‚Äã‚Äã<a href="http://www.learndatalogtoday.org/">Learn Datalog Today</a> ‚Äî very fun!</p>
<p>[2]: You may be wondering, won‚Äôt <code>find</code> always have variables? Well, not always. You could include some constant, like <code>{find: [&#34;movie/title&#34;, &#34;?title&#34;]}</code></p>
<hr/>
<p>This ideas was born from research into Instant. Joe and I plan to bring a powerful, reactive query engine to web and mobile. If this sounds exciting to you, sign up for our waitlist. We‚Äôre looking for hackers who are up to play with a version zero : ).</p>
</div></div>
  </body>
</html>
