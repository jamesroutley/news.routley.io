<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.instantdb.dev/essays/datalogjs">Original</a>
    <h1>Datalog in JavaScript</h1>
    
    <div id="readability-page-1" class="page"><div><p>Query engines make me feel like a wizard. I cast my incantation: “Give me all the directors and the movies where Arnold Schwarzenegger was a cast member”. Then charges zip through wires, algorithms churn on CPUs, and voila, an answer bubbles up.</p>
<p>How do they work? In this essay, we will build a query engine from scratch and find out. In 100 lines of Javascript, we’ll supports joins, indexes, <em>and</em> find our answer for Arnold! Let’s get into it.</p>

<p>Our first step is to choose which language we’ll support. SQL is the most popular, but we wouldn’t get far in 100 lines. I suggest we amble off the beaten path and make Datalog instead.</p>
<p>If you haven’t heard of Datalog, you’re in for a treat. It’s a logic-based query language that’s as powerful as SQL. We won’t cover it completely, but we’ll cover enough to fit a good weekend’s worth of hacking. </p>
<p>To grok Datalog, we need to understand three ideas:</p>

<p>The first idea is about how we store data.</p>
<h2 id="sql-tables">SQL Tables</h2>
<p>SQL databases store data in different tables: </p>
<p><img src="https://paper-attachments.dropbox.com/s_FD7FF9539594E6B532630EAEC892A2984C0B1FD8174F6609827754AA4559A821_1650557040594_image.png" alt=""/></p>
<p>Here we have a <code>movie</code> table, which stores one movie per row. The record with the id <code>200</code> is <code>&#34;The Terminator&#34;</code>. </p>
<p>Notice the <code>director_id</code>. This points to a row in yet another <code>person</code> table, which keeps the director’s name, and so on.</p>
<h2 id="datalog-triples">Datalog Triples</h2>
<p>In Datalog databases, there are no tables. Or really everything is just stored in one table, the <code>triple</code> table:</p>
<p><img src="https://paper-attachments.dropbox.com/s_FD7FF9539594E6B532630EAEC892A2984C0B1FD8174F6609827754AA4559A821_1650653844960_image.png" alt=""/></p>
<p>A <code>triple</code> is a row with an <code>id</code>, <code>attribute</code>, and <code>value</code>. Triples have a curious property; with just these three columns, they can describe any kind of information! </p>
<p>How? Imagine describing a movie to someone:</p>
<blockquote>
<p>It&#39;s called &#34;The Terminator&#34;
It was released in 1987</p>
</blockquote>
<p>Those sentences conveniently translate to triples:</p>
<pre><code>[200, movie/title, &#34;The Terminator&#34;]
[200, movie/year, 1987]
</code></pre>
<p>And those sentences have a general structure; if you can describe a movie this way, you can describe tomatoes or airplanes just as well.</p>

<p>The second idea is about how we search for information. </p>
<h2 id="sql-algebra">SQL Algebra</h2>
<p>SQL has roots in relational algebra. You give the query engine a combination of clauses and statements, and it gets you back your data:</p>
<pre><code>SELECT id FROM movie WHERE year = 1987
</code></pre>
<p>This returns:</p>
<pre><code>[{id: 202}, {id: 203}, {id: 204}]
</code></pre>
<p>Voila, the movie ids for Predator, Lethal Weapon, and RoboCop. </p>
<h2 id="datalog-pattern-matching">Datalog Pattern Matching</h2>
<p>Datalog databases rely on pattern matching. We create “patterns” that match against triples. For example, to find all the movies released in 1987, we could use this pattern:</p>
<pre><code>[?id, movie/year, 1987]
</code></pre>
<p>Here, <code>?id</code> is a variable: we’re telling the query engine that it can be <em>any</em> value. But, the <code>attribute</code> <em>must</em> be <code>movie/year</code>, and the <code>value</code> <em>must</em> be <code>1987</code>. </p>
<p><img src="https://paper-attachments.dropbox.com/s_FD7FF9539594E6B532630EAEC892A2984C0B1FD8174F6609827754AA4559A821_1650395773008_image.png" alt=""/></p>
<p>Our query engine runs through triple after triple. Since <code>?id</code> can be anything, this matches every triple. But, the attribute <code>movie/year</code> and the value <code>1987</code> filter us down to <em>just</em> the triples we care about:</p>
<pre><code>[
  [202, movie/year, 1987],
  [203, movie/year, 1987],
  [204, movie/year, 1987],
]
</code></pre>
<p>Notice the <code>?id</code> portion; those are the ids for Predator, Lethal Weapon, and RoboCop!</p>
<h2 id="datalog-find">Datalog <code>find</code></h2>
<p>In SQL, we <em>just</em> got back ids though, while our query engine returned more. How can we support returning ids only? Let’s adjust our syntax; here’s <code>find</code>:</p>
<pre><code>{ find: [?id], 
  where: [
    [?id, movie/year, 1987]
  ] }
</code></pre>
<p>Our query engine can now use the <code>find</code> section to return what we care about. If we implement this right, we should get back:</p>
<pre><code>[[202], [203], [204]]
</code></pre>
<p>And now we’re as dandy as SQL.</p>

<p>The third idea is about how joins work. Datalog and SQL’s magic comes from them.</p>
<h2 id="sql-clauses">SQL clauses</h2>
<p>In SQL, if we wanted to find “The Terminator’s” director, we could write:</p>
<pre><code>SELECT 
  person.name
FROM movie
JOIN person ON movie.director_id = person.id
WHERE movie.title = &#34;The Terminator&#34;
</code></pre>
<p>Which gets us:</p>
<pre><code>[{name: &#34;James Cameron&#34;}]
</code></pre>
<p>Pretty cool. We used the <code>JOIN</code> clause to connect the movie table with the person table, and bam, we got our director’s name.</p>
<h2 id="datalogpattern-matching">Datalog…Pattern Matching</h2>
<p>In Datalog, we still rely on pattern matching. The trick is to match <em>multiple</em> patterns:</p>
<pre><code>{
  find: [?directorName],
  where: [
    [?movieId, movie/title, &#34;The Terminator&#34;],
    [?movieId, movie/director, ?directorId],
    [?directorId, person/name, ?directorName],
  ],
}
</code></pre>
<p>Here we tell the query engine to match <em>three</em> patterns. The first pattern produces a list of successful triples. For each successful triple, we search again with the <em>second</em> pattern, and so on. Notice how the <code>?movieId</code> and <code>?directorId</code> are repeated; this tells our query engine that for a successful match, those values would need to be the <em>same</em> across our different searches. </p>
<p>What do I mean? Let’s make this concrete; here’s how our query engine could find The Terminator’s director:</p>
<p><img src="https://paper-attachments.dropbox.com/s_FD7FF9539594E6B532630EAEC892A2984C0B1FD8174F6609827754AA4559A821_1650461792727_image.png" alt=""/></p>
<p>The first pattern finds: </p>
<pre><code>[200, movie/title, &#34;The Terminator&#34;]. 
</code></pre>
<p>We bind <code>?movieId</code> to <code>200</code>. Now we start searching for the second pattern: </p>
<pre><code>[?movieId, movie/director, ?directorName].
</code></pre>
<p>Since <code>?movieId</code> needs to be <code>200</code>, this finds us </p>
<pre><code>[200, movie/director, 100]
</code></pre>
<p>And we can now bind <code>?directorId</code> to <code>100</code>. Time for the third pattern:</p>
<pre><code>[?directorId, person/name, ?directorName] 
</code></pre>
<p>Because <code>?directorId</code> has to be <code>100</code>, our engine finds us: </p>
<pre><code>[100, person/name, &#34;James Cameron&#34;]
</code></pre>
<p>And perfecto, the <code>?directorName</code>  is now bound to <code>&#34;James Cameron&#34;</code>! The <code>find</code> section would then return <code>[&#34;James Cameron&#34;]</code>.</p>
<hr/>
<p>Oky doke, now we grok the basics of Datalog! Let’s get to the code.</p>

<p>First things first, we need a way to represent this syntax. If you look at: </p>
<pre><code>{ find: [?id], 
  where: [
    [?id, movie/year, 1987]
  ] }
</code></pre>
<p>We could <em>almost</em> write this in Javascript. We use objects and arrays, but <code>?id</code> and <code>movie/year</code> get in the way; they would throw an error. We can fix this with a hack: let’s turn them into strings.</p>
<pre><code>{ find: [&#34;?id&#34;], 
  where: [
    [&#34;?id&#34;, &#34;movie/year&#34;, 1987]
  ] }
</code></pre>
<p>It’s less pretty, but we can now express our queries without fanfare. If a string begins with a question mark, it’s a variable. An attribute is just a string; it’s a good idea to include a namespace like <code>&#34;movie/*&#34;</code>, but we won’t force our users.</p>

<p>The next thing we’ll need is sample data to play with. There’s a great datalog tutorial [1], which has the movie dataset we’ve been describing. I’ve taken it and adapted it to Javascript. <a href="https://github.com/stopachka/datalogJS/blob/main/src/exampeTriples.js">Here’s the file</a>.</p>
<pre><code>// exampleTriples.js
export default [
  [100, &#34;person/name&#34;, &#34;James Cameron&#34;],
  [100, &#34;person/born&#34;, &#34;1954-08-16T00:00:00Z&#34;],
  // ...
]
</code></pre>
<p>Let’s plop this in and require it: </p>
<pre><code>import exampleTriples from &#39;./exampleTriples&#39;;
</code></pre>
<p>Now for our query engine!</p>

<h2 id="goal">Goal</h2>
<p>Our first goal is to match <em>one</em> pattern with <em>one</em> triple. Here’s an example:</p>
<p><img src="https://paper-attachments.dropbox.com/s_FD7FF9539594E6B532630EAEC892A2984C0B1FD8174F6609827754AA4559A821_1650419195277_image.png" alt=""/></p>
<p>We have some variable bindings: <code>{&#34;?movieId&#34;: 200}</code>. Let’s call this a <code>context</code>.</p>
<p>Our goal is to take a pattern, a triple, and a context. We’ll either return a new context:</p>
<pre><code>{&#34;?movieId&#34;: 200, &#34;?directorId&#34;: 100}
</code></pre>
<p>Or a failure. We can just say <code>null</code> means failure. </p>
<p>This could be the test we play with:</p>
<pre><code>expect(
  matchPattern(
    [&#34;?movieId&#34;, &#34;movie/director&#34;, &#34;?directorId&#34;],
    [200, &#34;movie/director&#34;, 100],
    { &#34;?movieId&#34;: 200 }
  )
).toEqual({ &#34;?movieId&#34;: 200, &#34;?directorId&#34;: 100 });
expect(
  matchPattern(
    [&#34;?movieId&#34;, &#34;movie/director&#34;, &#34;?directorId&#34;],
    [200, &#34;movie/director&#34;, 100],
    { &#34;?movieId&#34;: 202 }
  )
).toEqual(null);
</code></pre>
<h2 id="code">Code</h2>
<p>Nice, we have a plan. Let’s write the larger function first:</p>
<pre><code>function matchPattern(pattern, triple, context) {
  return pattern.reduce((context, patternPart, idx) =&gt; {
    const triplePart = triple[idx];
    return matchPart(patternPart, triplePart, context);
  }, context);
}
</code></pre>
<p>We take our pattern, and compare each part to the corresponding one in our triple:</p>
<p><img src="https://paper-attachments.dropbox.com/s_FD7FF9539594E6B532630EAEC892A2984C0B1FD8174F6609827754AA4559A821_1650457636669_image.png" alt=""/></p>
<p>So, we’d compare <code>&#34;?movieId&#34;</code> with <code>200</code>, and so on. </p>
<h2 id="matchpart">matchPart</h2>
<p>We can delegate this comparison to <code>matchPart</code>:</p>
<pre><code>function matchPart(patternPart, triplePart, context) {
  if (!context) return null;
  if (isVariable(patternPart)) {
    return matchVariable(patternPart, triplePart, context);
  }
  return patternPart === triplePart ? context : null;
}
</code></pre>
<p>First we address <code>context</code>; if <code>context</code> was <code>null</code> we must have failed before, so we just return early.</p>
<h2 id="isvariable">isVariable</h2>
<p>Next, we check if we’re looking at a variable. <code>isVariable</code> is simple enough: </p>
<pre><code>function isVariable(x) {
  return typeof x === &#39;string&#39; &amp;&amp; x.startsWith(&#34;?&#34;);
}
</code></pre>
<h2 id="matchvariable">matchVariable</h2>
<p>Now, if we <em>are</em> looking at a variable, we’d want to handle it especially: </p>
<pre><code>function matchVariable(variable, triplePart, context) {
  if (context.hasOwnProperty(variable)) {
    const bound = context[variable];
    return matchPart(bound, triplePart, context);
  }
  return { ...context, [variable]: triplePart };
}
</code></pre>
<p>We would check if we <em>already</em> have a binding for this variable. For example, when comparing <code>?movieId</code>, we’d already have the binding: “<code>200</code>”. In this case, we just compare the bound value with what’s in our triple.</p>
<pre><code>// ...
if (context.hasOwnProperty(variable)) {
  const bound = context[variable];
  return matchPart(bound, triplePart, context);
}
// ...
</code></pre>
<p>When we compare <code>?directorId</code> though, we’d see that this variable wasn’t bound. In this case, we’d want to <em>expand</em> our context. We’d attach <code>?directorId</code> to the corresponding part in our triple (<code>100</code>).</p>
<pre><code>return { ...context, [variable]: triplePart };
</code></pre>
<p>Finally, if we weren’t looking at a variable, we would have skipped this and just checked for equality. If the pattern part and the triple part match, we keep the context; otherwise we return null: </p>
<pre><code>// ...
return patternPart === triplePart ? context : null;
// ...
</code></pre>
<p>And with that, <code>matchPattern</code> works as we like!</p>

<h2 id="goal-1">Goal</h2>
<p>Now for our second goal. We can already match one pattern with one triple. Let’s now match <em>one</em> pattern with <em>multiple</em> triples. Here’s the idea:</p>
<p><img src="https://paper-attachments.dropbox.com/s_FD7FF9539594E6B532630EAEC892A2984C0B1FD8174F6609827754AA4559A821_1650458051668_image.png" alt=""/></p>
<p>We’ll have <em>one</em> pattern and a database of triples. We’ll want to return the contexts for all the successful matches. Here’s the test we can play with:</p>
<pre><code>expect(
  querySingle([&#34;?movieId&#34;, &#34;movie/year&#34;, 1987], exampleTriples, {})
).toEqual([{ &#34;?movieId&#34;: 202 }, { &#34;?movieId&#34;: 203 }, { &#34;?movieId&#34;: 204 }]);
</code></pre>
<h2 id="code-1">Code</h2>
<p>Well, much of the work comes down to <code>matchPattern</code>. Here’s all <code>querySingle</code> needs to do:</p>
<pre><code>function querySingle(pattern, db, context) {
  return db
    .map((triple) =&gt; matchPattern(pattern, triple, context))
    .filter((x) =&gt; x);
}
</code></pre>
<p>We go over each triple and run <code>matchPattern</code>. This would return either a <code>context</code> (it’s a match!), or <code>null</code> (it’s a failure). We <code>filter</code> to remove the failures, and querySingle works like a charm! </p>

<h2 id="goal-2">Goal</h2>
<p>Closer and closer. Now to support joins. We need to handle <em>multiple</em> patterns:</p>
<p><img src="https://paper-attachments.dropbox.com/s_FD7FF9539594E6B532630EAEC892A2984C0B1FD8174F6609827754AA4559A821_1650462526590_image.png" alt=""/></p>
<p>So we go pattern by pattern, and find successful triples. For each successful triple, we apply the next pattern. At the end, we’ll have produced progressively larger contexts.</p>
<p>Here’s the test we can play with: </p>
<pre><code>expect(
  queryWhere(
    [
      [&#34;?movieId&#34;, &#34;movie/title&#34;, &#34;The Terminator&#34;],
      [&#34;?movieId&#34;, &#34;movie/director&#34;, &#34;?directorId&#34;],
      [&#34;?directorId&#34;, &#34;person/name&#34;, &#34;?directorName&#34;],
    ],
    exampleTriples,
    {}
  )
).toEqual([
  { &#34;?movieId&#34;: 200, &#34;?directorId&#34;: 100, &#34;?directorName&#34;: &#34;James Cameron&#34; },
]);
</code></pre>
<h2 id="code-2">Code</h2>
<p>This too, is not so difficult. Here’s queryWhere: </p>
<pre><code>function queryWhere(patterns, db) {
  return patterns.reduce(
    (contexts, pattern) =&gt; {
      return contexts.flatMap((context) =&gt; querySingle(pattern, db, context));
    },
    [{}]
  );
}
</code></pre>
<p>We start off with one empty context. We then go pattern by pattern; for each pattern, we find all the successful contexts. We then take those contexts, and use them for the next pattern. By the end, we’ll have all the expanded contexts, and <code>queryWhere</code> works like a charm too!</p>

<h2 id="goal-3">Goal</h2>
<p>And now we’ve just about built ourselves the whole query engine! Next let’s handle <code>where</code> and <code>find</code>. </p>
<p>This could be the test we can play with:</p>
<pre><code>expect(
  query(
    {
      find: [&#34;?directorName&#34;],
      where: [
        [&#34;?movieId&#34;, &#34;movie/title&#34;, &#34;The Terminator&#34;],
        [&#34;?movieId&#34;, &#34;movie/director&#34;, &#34;?directorId&#34;],
        [&#34;?directorId&#34;, &#34;person/name&#34;, &#34;?directorName&#34;],
      ],
    },
    exampleTriples
  )
).toEqual([[&#34;James Cameron&#34;]]);
</code></pre>
<h2 id="code-3">Code</h2>
<p>Here’s <code>query</code>:</p>
<pre><code>function query({ find, where }, db) {
  const contexts = queryWhere(where, db);
  return contexts.map((context) =&gt; actualize(context, find));
}
</code></pre>
<p>Our <code>queryWhere</code> returns all the successful contexts. We can then map those, and <code>actualize</code> our <code>find</code>: </p>
<pre><code>function actualize(context, find) {
  return find.map((findPart) =&gt; {
    return isVariable(findPart) ? context[findPart] : findPart;
  });
}
</code></pre>
<p>All <code>actualize</code> does is handle variables; if we see a variable in find, we just replace it with its bound value. [^2]</p>

<p>And voila! We have a query engine. Let’s see what we can do.</p>
<p><strong>When was Alien released?</strong></p>
<pre><code>query(
  {
    find: [&#34;?year&#34;],
    where: [
      [&#34;?id&#34;, &#34;movie/title&#34;, &#34;Alien&#34;],
      [&#34;?id&#34;, &#34;movie/year&#34;, &#34;?year&#34;],
    ],
  },
  exampleTriples
)
</code></pre>
<pre><code>[[1979]]
</code></pre>
<p><strong>What do I know about the entity with the id <code>200</code> ?</strong> </p>
<pre><code>query(
  {
    find: [&#34;?attr&#34;, &#34;?value&#34;],
    where: [[200, &#34;?attr&#34;, &#34;?value&#34;]],
  },
  exampleTriples
)
</code></pre>
<pre><code>[
  [&#34;movie/title&#34;, &#34;The Terminator&#34;],
  [&#34;movie/year&#34;, 1984],
  [&#34;movie/director&#34;, 100],
  [&#34;movie/cast&#34;, 101],
  [&#34;movie/cast&#34;, 102],
  [&#34;movie/cast&#34;, 103],
  [&#34;movie/sequel&#34;, 207],
]
</code></pre>
<p>And, last by not least…</p>
<p><strong>Which directors shot Arnold for which movies?</strong></p>
<pre><code>query(
  {
    find: [&#34;?directorName&#34;, &#34;?movieTitle&#34;],
    where: [
      [&#34;?arnoldId&#34;, &#34;person/name&#34;, &#34;Arnold Schwarzenegger&#34;],
      [&#34;?movieId&#34;, &#34;movie/cast&#34;, &#34;?arnoldId&#34;],
      [&#34;?movieId&#34;, &#34;movie/title&#34;, &#34;?movieTitle&#34;],
      [&#34;?movieId&#34;, &#34;movie/director&#34;, &#34;?directorId&#34;],
      [&#34;?directorId&#34;, &#34;person/name&#34;, &#34;?directorName&#34;],
    ],
  },
  exampleTriples
)
</code></pre>
<p>🤯</p>
<pre><code>[
  [&#34;James Cameron&#34;, &#34;The Terminator&#34;],
  [&#34;John McTiernan&#34;, &#34;Predator&#34;],
  [&#34;Mark L. Lester&#34;, &#34;Commando&#34;],
  [&#34;James Cameron&#34;, &#34;Terminator 2: Judgment Day&#34;],
  [&#34;Jonathan Mostow&#34;, &#34;Terminator 3: Rise of the Machines&#34;],
]
</code></pre>
<p>Now this is cool!</p>

<h2 id="problem">Problem</h2>
<p>Okay, but you may have already been thinking, “Our query engine will get slow”. </p>
<p>Let’s remember <code>querySingle</code>:</p>
<pre><code>function querySingle(pattern, db, context) {
  return db
    .map((triple) =&gt; matchPattern(pattern, triple, context))
    .filter((x) =&gt; x);
}
</code></pre>
<p>This is fine and dandy, but consider this query: </p>
<pre><code>querySingle([200, &#34;movie/title&#34;, ?movieTitle], db, {})
</code></pre>
<p>We want to find the movie title for the entity with the id <code>200</code>. SQL would have used an index to quickly nab this for us. </p>
<p>But what about our query engine? It’ll have to search every single triple in our database!</p>
<h2 id="goal-4">Goal</h2>
<p>Let’s solve that. We shouldn’t need to search <em>every</em> triple for a query like this; it’s time for indexes. </p>
<p>Here’s what we can do; Let’s create <code>entity</code>, <code>attribute</code>, and <code>value</code> indexes. Something like:</p>
<pre><code>{
  entityIndex: {
    200: [
      [200, &#34;movie/title&#34;, &#34;The Terminator&#34;], [200, &#34;movie/year&#34;, 1984],
      //...
    ],
    // ...
  },
  attrIndex: {
    &#34;movie/title&#34;: [
      [200, &#34;movie/title&#34;, &#34;The Terminator&#34;],
      [202, &#34;movie/title&#34;, &#34;Predator&#34;],
      // ...
    ],
    // ...
  },
}
</code></pre>
<p>Now, if we had a pattern like this:</p>
<pre><code>[200, &#34;movie/title&#34;, ?movieTitle]
</code></pre>
<p>We could be smart about how to get all the relevant triples: since <code>200</code> isn’t a variable, we could just use the <code>entityIndex</code>. We’d grab <code>entityIndex[200]</code> , and voila we’d have reduced our search to just 7 triples! </p>
<p>We can do more, but with this we’d already have a big win.</p>
<h2 id="createdb">createDB</h2>
<p>Okay, let’s turn this into reality. We can start with a proper <code>db</code> object. We were just using <code>exampleTriples</code> before; now we’ll want to keep track of indexes too. Here’s what we can do: </p>
<pre><code>function createDB(triples) {
  return {
    triples,
    entityIndex: indexBy(triples, 0),
    attrIndex: indexBy(triples, 1),
    valueIndex: indexBy(triples, 2),
  }
}
</code></pre>
<p>We’ll take our triples, and start to index them.</p>
<h2 id="indexby">indexBy</h2>
<p>And <code>indexBy</code> will handle that. It can just take the triples and create a mapping:</p>
<pre><code>function indexBy(triples, idx) {
  return triples.reduce((index, triple) =&gt; {
    const k = triple[idx];
    index[k] = index[k] || [];
    index[k].push(triple);
    return index;
  }, {});
}
</code></pre>
<p>Here <code>idx</code> represents the position in the triple; 0 would be <code>entity</code>, 1 would be <code>attribute</code>, 2 would be <code>value</code>.</p>
<h2 id="querysingle-updated">querySingle, updated</h2>
<p>Now that we have indexes, we can use them in querySingle: </p>
<pre><code>export function querySingle(pattern, db, context) {
  return relevantTriples(pattern, db)
    .map((triple) =&gt; matchPattern(pattern, triple, context))
    .filter((x) =&gt; x);
}
</code></pre>
<p>The only change is <code>relevantTriples</code>. We’ll lean on it to figure out which index to use.</p>
<h2 id="relevanttriples">relevantTriples</h2>
<p>Here’s all relevantTriples does: </p>
<pre><code>function relevantTriples(pattern, db) {
  const [id, attribute, value] = pattern;
  if (!isVariable(id)) {
    return db.entityIndex[id];
  }
  if (!isVariable(attribute)) {
    return db.attrIndex[attribute];
  }
  if (!isVariable(value)) {
    return db.valueIndex[value];
  }
  return db.triples;
}
</code></pre>
<p>We take the pattern. We check the id, attribute, and the value. If <em>any</em> of them aren’t variables, we can safely use the corresponding index. </p>
<p>With that, we’ve made our query engine faster 🙂</p>

<p>I hope you had a blast making this and got a sense of how query engines work to boot. If you’d like to see the source in one place, <a href="https://github.com/stopachka/datalogJS/blob/main/src/index.js">here it is</a>.</p>
<h2 id="more">More</h2>
<p>This is just the beginning. How about functions like “greater than” or “smaller than”? How about an “or” query? Let’s not forget aggregate functions. If you’re curious about this, I’d suggest three things: </p>
<p>First go through the <a href="http://www.learndatalogtoday.org/">Learn Datalog</a> website; that’ll give you a full overview Datalog. Next, I’d suggest you go through the <a href="https://sarabander.github.io/sicp/html/4_002e4.xhtml#g_t4_002e4">SICP chapter on logic programming</a>. They go much further than this essay. Finally, you can look at Nikita Tonsky’s <a href="https://tonsky.me/blog/datascript-internals/">datascript internals</a>, for what a true production version could look like.</p>
<h2 id="credits">Credits</h2>
<p>Huge credit goes to SICP. When I completed their logic chapter, I realized that query languages didn&#39;t have to be so daunting. This essay is just a simplification of their chapter, translated into Javascript. The second credit needs to go to Nikita Tonsky’s essays. His <a href="https://tonsky.me/blog/unofficial-guide-to-datomic-internals/">Datomic</a> and <a href="https://tonsky.me/blog/datascript-internals/">Datascript</a> internals essays are a goldmine. Finally, I really enjoyed <a href="http://www.learndatalogtoday.org/">Learn Datalog</a>, and used their dataset for this essay.</p>
<p><em>Thanks to Joe Averbukh, Irakli Safareli, Daniel Woelfel, Mark Shlick, Alex Reichert, Ian Sinnott, for reviewing drafts of this essay.</em></p>
<p>[1]: ​​<a href="http://www.learndatalogtoday.org/">Learn Datalog Today</a> — very fun!</p>
<p>[2]: You may be wondering, won’t <code>find</code> always have variables? Well, not always. You could include some constant, like <code>{find: [&#34;movie/title&#34;, &#34;?title&#34;]}</code></p>
<hr/>
<p>This ideas was born from research into Instant. Joe and I plan to bring a powerful, reactive query engine to web and mobile. If this sounds exciting to you, sign up for our waitlist. We’re looking for hackers who are up to play with a version zero : ).</p>
</div></div>
  </body>
</html>
