<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://emilygorcenski.com/post/owning-my-own-data-part-1-integrating-a-self-hosted-calendar-solution/">Original</a>
    <h1>Owning my own data, part 1: Integrating a self-hosted calendar solution</h1>
    
    <div id="readability-page-1" class="page"><div>


<p>My calendar is a true nightmare. I travel a lot, some of it for my job, some of it for fun, and some of it because I’ve been managing a long distance relationship for years. Traveling a lot means it’s always hard for your loved ones or coworkers to know what time zone you’re in or when you’re on a plane. Managing a relationship across timezones means having to do constant mental math that is way harder than it needs to be. And because I don’t have an assistant, I’ve become frustrated with double entry of flights, trains, blockers for boarding flights or traveling to the airport, and so on.</p>
<p>As someone who travels a lot, it’s also one of those things where statistically speaking, the chances of me being on a plane whenever some newsworthy event happens is higher than for the average person. I want my wife, friends, coworkers to know what flights I’m on and what cities I’m in. I’ve survived one terror attack, nearly dodged two others and a mass shooting. It’s one of those things where I want to make sure people who care about me can check in easily to see where I am.</p>
<p>The thing is, calendar systems suck. All of them. The standards are a holdover from two computing generations ago, the frontend ecosystem is a mess of rent-seeking monthly subscription mobile apps with dubious features, and the user experience for most systems is pretty much terrible. Just as an example: if I book a flight, my email provider makes a calendar entry, but it often misses the connection flight or gets the timezones wrong, and even if it doens’t fail, it doesn’t make me the organizer, meaning I can’t share or modify it. The entire calendar ecosystem is a nightmare.</p>
<p>The sad thing is that in the entire space there’s really two good products: Google Calendar has basically captured the market for diary entries, and Facebook Events would be an admirable tool if it wasn’t attached to a company and service fuelled with undistilled demon blood. I’m trying to break off of big tech as much as I can, so I needed some kind of solution.</p>
<p>So I built my own. Kind of. I intend this to be the first part of a long-running series of how I’m building my own tech to regain control of my data.</p>

<p>My core requirements:</p>
<ul>
<li>Allow events to show up as blockers in my work calendar;</li>
<li>Allow my wife to subscribe to the calendar;</li>
<li>Enter events at most once;</li>
<li>Allow editing from multiple devices;</li>
<li>Fully control my own data;</li>
<li>Cannot solve problem by sharing work calendar with my wife.</li>
</ul>
<p>Additional requirements:</p>
<ul>
<li>Import .ics attachments from email;</li>
<li>Import .ics over HTTP from my <a href="https://emilygorcenski.com/post/lingoda-review/">language school</a> calendar;</li>
<li>Import data automatically from my self-hosted flight tracker, <a href="https://github.com/johanohly/AirTrail/">Airtrail</a>;</li>
<li>Color code events in my work calendar;</li>
<li>Allow some events to be flagged as private for my work calendar;</li>
<li>Refresh frequently;</li>
<li>Use any front end.</li>
</ul>

<p>The big problem with existing calendar sharing solutions is that they require everyone to be on a common platform, like the broader Gmail or Outlook.com ecosystems, or share accounts in the same environment, like an Exchange environment, in order to have full functionality. The two common workarounds for this is either to publish a calendar in a “read only” mode by serving iCal data over HTTP, or to email iCal .ics files to recipients over email.</p>
<p>For my beta version of this calendar system I chose the former: I would host an .ics file on my website under a public but secret and unguessable URL, or actually multiple URLs for different use cases. I could then share the link or subscribe to it with my work account. To populate the calendar, I started writing out events in YAML and would generate a URL for each person I wanted to share it with:</p>
<div><pre tabindex="0"><code data-lang="yaml">- <span>name</span>: <span>World Aviation Festival</span>
  <span>begin</span>: <span>2024-10-07</span>
  <span>end</span>: <span>2024-10-10</span>
  <span>city</span>: <span>Amsterdam</span>
  <span>event</span>:
    <span>name</span>: <span>World Aviation Festival Conference Day</span>
    <span>type</span>: <span>CONFERENCE</span>
    <span>begin</span>: <span>2024-10-08T08:30:00</span><span>+02</span>:<span>00</span>
    <span>end</span>: <span>2024-10-08T18:00:00</span><span>+02</span>:<span>00</span>
    <span>location</span>: |<span>
</span><span>      RAI Exhibition and Convention Centre
</span><span>      Halls 1 &amp; 5 | Europaplein 24, Amsterdam</span>      
    <span>repeat</span>:
      <span>count</span>: <span>3</span>
      <span>frequency</span>: <span>daily</span>
  <span>flights</span>:
    - <span>flight number</span>: <span>LH2310</span>
      <span>departure</span>:
        <span>airport</span>: <span>MUC</span>
        <span>time</span>: <span>2024-10-07T20:05:00</span><span>+02</span>:<span>00</span>
      <span>arrival</span>:
        <span>airport</span>: <span>AMS</span>
        <span>time</span>: <span>2024-10-07T21:40:00</span><span>+02</span>:<span>00</span>
    - <span>flight number</span>: <span>LH2305</span>
      <span>departure</span>:
        <span>airport</span>: <span>AMS</span>
        <span>time</span>: <span>2024-10-10T15:40:00</span><span>+02</span>:<span>00</span>
      <span>arrival</span>:
        <span>airport</span>: <span>MUC</span>
        <span>time</span>: <span>2024-10-10T17:05:00</span><span>+02</span>:<span>00</span>
    - <span>flight number</span>: <span>LH1952</span>
      <span>departure</span>:
        <span>airport</span>: <span>MUC</span>
        <span>time</span>: <span>2024-10-10T18:00:00</span><span>+02</span>:<span>00</span>
      <span>arrival</span>:
        <span>airport</span>: <span>BER</span>
        <span>time</span>: <span>2024-10-10T19:05:00</span><span>+02</span>:<span>00</span>
  <span>hotel</span>:
    - <span>name</span>: <span>Sheraton Amsterdam Airport Hotel And Conference Center</span>
      <span>address</span>: <span>Schiphol Boulevard 101, Schiphol, 1, Netherlands 1118</span>
  <span>share</span>:
    - <span>Christine</span>
    - <span>Work</span>
    - <span>Em</span>
</code></pre></div><p>I’d take this YAML file and wrote a small script to re-serialize it as an ICS file in my CI/CD pipeline.</p>
<p>This worked for a while, but it got unweildly. Hand-writing YAML is fine for prototyping, but at scale it was too frequent that I would make mistakes, and this was a lot of work for what should be a fairly low-effort exercise. I needed a new solution.</p>

<p>For my new solution, I knew I would need to move away from my static solution and would need to run something hosted. Even though that would cost me more, I’ve come to accept that moving off of big tech will eventually require me to host my own solutions for a variety of needs. So I decided to jump into the world of CalDAV.</p>
<p>CalDAV is an extension of the WebDAV distributed authoring specification with specific functionality relevant to calendar applications. WebDAV was an idea that emerged from the 90s, when web development was still very synchronous and web development felt more like software development. Nevertheless, it’s one of the few available solutions for running a self-hosted calendaring system.</p>
<p>Aside: This is an area begging for disruption. Just look at <a href="https://en.wikipedia.org/wiki/Comparison_of_CalDAV_and_CardDAV_implementations">this list of CalDAV and CardDAV implementations</a> on Wikipedia. It’s bleak out there, folks. No wonder why data aggregators under the guise of third party tools like Calendly and Doodle are so popular. The landscape is flat awful. Anyways.</p>
<p>With a CalDAV server, I can connect to it with frontend apps of my choosing from multiple devices. This will allow me to view and manage events from my laptop, phone, or whatever. But few CalDAV servers allow authentication-free subscriptions to the calendar with any ease. So I’ll need to have a script that regularly polls the server, extracts the events, and publishes them as an iCal file through my website.</p>
<p>Moreover, I’ll want to connect to various other data sources, some of which I control and others I do not. These include my flight tracker (self-hosted), my email (paid hosting), and my language school (external). The flow that I’ll build will look something like this:</p>
<ul>
<li>poll data sources for events</li>
<li>publish events programmatically to CalDAV</li>
<li>fetch all events from CalDAV and write to an .ics file</li>
<li>serve .ics file over HTTP</li>
</ul>
<p>To accomplish this, I’ve designed an architecture that looks something like this:</p>
<p><img src="https://emilygorcenski.com/photo-gallery/writing/cal-arch.png" alt="Calendar system architecture"/></p>

<p>My tool of choice was <a href="https://sabre.io/baikal/">Baïkal</a>, a lightweight, self-hostable CalDAV (and CardDAV) server for managing calendars and contacts. Setting up the service was easy with Docker Compose:</p>
<div><pre tabindex="0"><code data-lang="yaml"><span>services</span>:
  <span>baikal</span>:
    <span>image</span>: <span>ckulka/baikal:0.9.5</span>
    <span>restart</span>: <span>always</span>
    <span>ports</span>:
      - <span>&#34;XXXX:80&#34;</span>
    <span>volumes</span>:
      - <span>/mnt/baikal/data:/var/www/baikal/config</span>
      - <span>/mnt/baikal/data:/var/www/baikal/Specific</span>

<span>volumes</span>:
  <span>config</span>:
  <span>data</span>:
</code></pre></div><p>You can configure Baïkal to use MySQL, but it also works fine with SQLLite, and this simplifies its administration. Set the port and modify the local volume if you want and start this with a simple <code>docker compose up -d</code>.</p>
<p>To make this available to the web, I’m running an nginx reverse proxy with a pretty basic configuration:</p>
<pre tabindex="0"><code>server {
    server_name MYDOMAIN;

    location / {
        proxy_pass http://localhost:XXXX;
        proxy_set_header Host $http_host;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location /.well-known/caldav {
       return 301 https://MYDOMAIN/dav.php;
    }

    listen 80;
    listen [::]:80;
}
</code></pre><p>Of course, I used Let’s Encrypt to get this served securely, but I omitted this for simplicity. If you want to do the same, replace <code>MYDOMAIN</code> with whatever your subdomain/domain is.</p>
<p>One note: you’ll notice the <code>location</code> directive that performs a 301 redirect to <code>dav.php</code>. This <code>/.well-known/caldav</code> redirect is needed if you want to add this calendar to your iPhone or Mac calendar apps. When eventually setting up your calendar on MacOS or iOS, you’ll want to use manual settings, not automatic (and not advanced—I’m not sure why I couldn’t get the advanced settings to work when the manual settings worked fine).</p>
<p>I set up DNS and used <code>certbot</code> to generate a Let’s Encrypt certificate for my domain and it updated the nginx config file automatically.</p>
<p>Once this is up and running, I was able to navigate to my domain in my browser to set up an admin account. From there, I configured a user for myself and created a calendar. Theoretically, I could create multiple calendars if I chose to, for instance if I wanted to have a special calendar for travel or whatnot. But I didn’t find that necessary, as my goal is at-most-once data entry. To get the URL for my calendar, I had to navigate through to my user page, click the “Calendars” button, and then found it under the little info icon.</p>
<p><img src="https://emilygorcenski.com/photo-gallery/writing/baikal.png" alt="Baikal admin page showing calendar icon"/></p>
<p>I hooked this up to my iOS and MacOS default calendar apps and everything went swimmingly.</p>

<p>I’ll take a little detour here for another rant. The <a href="https://icalendar.org/RFC-Specifications/iCalendar-RFC-5545/">iCalendar specification</a> includes a provision for <a href="https://icalendar.org/iCalendar-RFC-5545/3-8-1-2-categories.html">an optional <code>CATEGORIES</code> property</a> for the <code>EVENT</code> component. The intention of this property appears to be to provide the ability for a user to categorize an event, such as an appointment, meeting, etc. This would be a really useful feature in a calendar frontend; I could easily search for and find a doctor appointment in a busy week, for instance. However, most frontends and calendar apps simply do not implement this feature in any way. MacOS Calendar does not. iOS Calendar does not. Google Calendar does not. Every tool I’ve used has completely ignored this otherwise useful field.</p>
<p>I want to use this field.</p>
<p>But there’s an issue with free text taxonimization: it sucks. It’s really hard to keep it consistent. It’s really hard to make it contextual meaningful while also being unambiguous, let alone universally understandable. So I need to do something about this.</p>
<p>Since I’m going to need to write some python scripts to extract calendar events anyways, it makes sense that I could try to encode these event types in a data model. So I wrote a little data model for this using python enums, an excerpt of which is here, forgive the random German:</p>
<div><pre tabindex="0"><code data-lang="python"><span>from</span> enum <span>import</span> Enum

<span>class</span> <span>TerminType</span>(Enum):
    MEETUP <span>=</span> <span>1</span>
    CONFERENCE <span>=</span> <span>2</span>
    CLASS <span>=</span> <span>3</span>
    TRAINING <span>=</span> <span>4</span>
    APPOINTMENT <span>=</span> <span>10</span> <span># values 10 or higher are set private for my work calendar</span>
    MEETING <span>=</span> <span>11</span>
    EXAM <span>=</span> <span>12</span>
    HEARING <span>=</span> <span>13</span>
    INTERVIEW <span>=</span> <span>14</span>

    <span>def</span> __str__(self):
        <span>return</span> self<span>.</span>name
    
<span>class</span> <span>CultureType</span>(Enum):
    MOVIE <span>=</span> <span>1</span>
    CONCERT <span>=</span> <span>2</span>
    SPORTS <span>=</span> <span>3</span>
    MUSEUM <span>=</span> <span>4</span>
    ENTERTAINMENT <span>=</span> <span>5</span>

    <span>def</span> __str__(self):
        <span>return</span> self<span>.</span>name

<span>class</span> <span>SocialType</span>(Enum):
    <span>...</span>

<span>class</span> <span>AwayType</span>(Enum):
    <span>...</span>

<span>class</span> <span>TransportType</span>(Enum):
    <span>...</span>

all_event_names <span>=</span> set(TerminType<span>.</span>_member_names_) \
                    <span>.</span>union(set(CultureType<span>.</span>_member_names_)) \
                    <span>.</span>union(set(SocialType<span>.</span>_member_names_)) \
                    <span>.</span>union(set(AwayType<span>.</span>_member_names_)) \
                    <span>.</span>union(set(TransportType<span>.</span>_member_names_))
</code></pre></div><p>There’s no real reason for breaking things down like this, except that it helps conceptually organize the types of events. Moreover, I do implement a little bit of hidden business logic: double-digit enum values are private by default for my work calendar.</p>
<p>Building this taxonomy will help me to implement an <em>ad hoc</em> solution to the problem described before: it will help me make events more searchable or visible at a glance for front-ends that allow you to color code events.</p>

<p>I’ve said a few times that I want to do “at most once” data entry. This means that there are many events I don’t want to have to enter data for at all, such as scheduled classes with my online language school (which hosts an ICS file of my classes) or events extracted from my email. But to automate getting this data I need to poll these endpoints, as they don’t really publish events when new ones are added or old ones are deleted. This means I’ll need to write a little python script and hook it up to a cron job.</p>
<p>The python script needs a few components:</p>
<ul>
<li>a component for fetching events from my email over IMAP;</li>
<li>a component for extracting events from my flight tracker’s API;</li>
<li>a component for fetching events from my language school’s hosted ICS files;</li>
<li>a component for pushing all of these events to Baïkal; and</li>
<li>a component for fetching all events from Baïkal and re-serializing them to one or more sharable ICS files published undiscoverably on the web.</li>
</ul>
<p>The IMAP part is really nice, this provides Google Calendar-like functionality to this system. If someone emails me a calendar invite, this script fetches it and adds it to my calendar automatically.</p>
<p>This is a lot of code, most of it ad hoc, I won’t share it here all but it’s not so hard to write. What I will share is the entrypoint script for the cron job:</p>
<div><pre tabindex="0"><code data-lang="python"><span>from</span> enum <span>import</span> Enum
<span>from</span> ics <span>import</span> Calendar, Event

<span>import</span> event_types <span>as</span> Categories
<span>import</span> airtrail
<span>import</span> baikal
<span>import</span> imap

<span>def</span> <span>is_work_public</span>(event : Event) <span>-&gt;</span> bool:
    <span>def</span> <span>get_value</span>(type : Enum, category):
        <span>try</span>:
            <span>return</span> type[category]<span>.</span>value <span>&lt;</span> <span>10</span>
        <span>except</span>:
            <span>return</span> <span>False</span>
        
    <span>if</span> <span>not</span> event<span>.</span>categories:
        <span>return</span> <span>False</span>
    
    <span>return</span> all((get_value(Categories<span>.</span>TerminType, c) <span>|</span>
                get_value(Categories<span>.</span>AwayType, c) <span>|</span>
                get_value(Categories<span>.</span>TransportType, c))
               <span>for</span> c <span>in</span> event<span>.</span>categories)

<span>if</span> __name__ <span>==</span> <span>&#34;__main__&#34;</span>:
    family <span>=</span> Calendar()
    work <span>=</span> Calendar()

    <span># these add events to baikal directly</span>
    airtrail<span>.</span>fetch_airtrail_events()
    imap<span>.</span>fetch_email_events()
    <span># I left out my language school fetcher because it&#39;s not active at the moment</span>

    events <span>=</span> baikal<span>.</span>fetch_remote_events()

    <span>for</span> event <span>in</span> events:
        family<span>.</span>events<span>.</span>add(event)

        <span>if</span> <span>&#34;work.email@example.com&#34;</span> <span>not</span> <span>in</span> event<span>.</span>serialize():
            <span>if</span> is_work_public(event):
                event<span>.</span>classification <span>=</span> <span>&#34;PUBLIC&#34;</span>
            <span>else</span>:
                event<span>.</span>classification <span>=</span> <span>&#34;PRIVATE&#34;</span>
            work<span>.</span>events<span>.</span>add(event)

    <span>try</span>:
        <span>with</span> open(<span>&#34;/www/calendar/emilygorcenski.ics&#34;</span>, <span>&#34;wt&#34;</span>) <span>as</span> ics_file:
            ics_file<span>.</span>write(family<span>.</span>serialize())
        <span>with</span> open(<span>&#34;/www/calendar/emilygorcenski_work.ics&#34;</span>, <span>&#34;wt&#34;</span>) <span>as</span> ics_file:
            ics_file<span>.</span>write(work<span>.</span>serialize())
    <span>except</span>:
        <span>pass</span>
</code></pre></div><p>And the script to interface with Baïkal:</p>
<div><pre tabindex="0"><code data-lang="python"><span>import</span> os
<span>import</span> re
<span>import</span> requests
<span>import</span> xml.etree.ElementTree <span>as</span> ET
<span>from</span> dotenv <span>import</span> load_dotenv
<span>from</span> ics <span>import</span> Calendar, Event
<span>from</span> requests.auth <span>import</span> HTTPDigestAuth
<span>from</span> event_types <span>import</span> all_event_names

load_dotenv()

<span># Baikal server information</span>
USERNAME <span>=</span> os<span>.</span>environ[<span>&#34;BAIKAL_USERNAME&#34;</span>]
PASSWORD <span>=</span> os<span>.</span>environ[<span>&#34;BAIKAL_PASSWORD&#34;</span>]
BASE_URL <span>=</span> os<span>.</span>environ[<span>&#34;BAIKAL_URL&#34;</span>]

HEADERS <span>=</span> {
    <span>&#34;Content-Type&#34;</span>: <span>&#34;application/xml; charset=utf-8&#34;</span>,
    <span>&#34;Depth&#34;</span>: <span>&#34;infinity&#34;</span>
}

PROPFIND_BODY <span>=</span> <span>&#34;&#34;&#34;&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;
</span><span>&lt;d:propfind xmlns:d=&#34;DAV:&#34; xmlns:c=&#34;urn:ietf:params:xml:ns:caldav&#34;&gt;
</span><span>    &lt;d:prop&gt;
</span><span>        &lt;d:displayname/&gt;
</span><span>        &lt;c:calendar-data/&gt;
</span><span>    &lt;/d:prop&gt;
</span><span>&lt;/d:propfind&gt;
</span><span>&#34;&#34;&#34;</span>

<span>def</span> <span>categorize</span>(event : Event) <span>-&gt;</span> Event:
    <span># ignores any user-input values that we don&#39;t care about, and focuses on what we do</span>
    <span># this is to convert the description field in an event into categories fields</span>
    <span># this allows manual categorization by editing the event description</span>
    <span>if</span> <span>not</span> event<span>.</span>description:
        <span>return</span> event
    category_match <span>=</span> re<span>.</span>search(<span>r</span><span>&#39;\b(CATEGORIES:)(\S+)\b&#39;</span>, event<span>.</span>description)
    <span>if</span> category_match:
        label <span>=</span> category_match<span>.</span>group(<span>1</span>) <span># this should always be &#34;CATEGORIES:&#34;&#34;</span>
        cat_list <span>=</span> category_match<span>.</span>group(<span>2</span>)
        categories <span>=</span> set(cat_list<span>.</span>split(<span>&#34;,&#34;</span>))
        event<span>.</span>categories <span>=</span> categories<span>.</span>intersection(all_event_names)
        event<span>.</span>description <span>=</span> event<span>.</span>description \
                                 <span>.</span>replace(label <span>+</span> cat_list, <span>&#34;&#34;</span>) \
                                 <span>.</span>replace(<span>&#34;  &#34;</span>, <span>&#34; &#34;</span>) \
                                 <span>.</span>strip()
    <span>return</span> event

<span>def</span> <span>fetch_remote_events</span>() <span>-&gt;</span> list[Event]:
    response <span>=</span> requests<span>.</span>request(<span>&#34;PROPFIND&#34;</span>,
                                BASE_URL,
                                headers<span>=</span>HEADERS,
                                data<span>=</span>PROPFIND_BODY,
                                auth<span>=</span>HTTPDigestAuth(USERNAME, PASSWORD))

    <span>if</span> response<span>.</span>ok:
        root <span>=</span> ET<span>.</span>fromstring(response<span>.</span>content)

        propstats       <span>=</span> [r<span>.</span>find(<span>&#39;</span><span>{DAV:}</span><span>propstat&#39;</span>)
                           <span>for</span> r <span>in</span> root<span>.</span>findall(<span>&#39;</span><span>{DAV:}</span><span>response&#39;</span>)]
        calendar_data   <span>=</span> [p
                           <span>.</span>find(<span>&#39;</span><span>{DAV:}</span><span>prop&#39;</span>)
                           <span>.</span>find(<span>&#39;{urn:ietf:params:xml:ns:caldav}calendar-data&#39;</span>)
                           <span>for</span> p <span>in</span> filter(<span>lambda</span> x: x <span>is</span> <span>not</span> <span>None</span>, propstats)]
        events          <span>=</span> [categorize(event)
                           <span>for</span> data <span>in</span> filter(<span>lambda</span> x: x <span>is</span> <span>not</span> <span>None</span>, calendar_data)
                           <span>for</span> event <span>in</span> Calendar(data<span>.</span>text)<span>.</span>events]
        <span>return</span> events
    <span>return</span> []

<span>def</span> <span>add_event</span>(filename : str, event_ics : str):
    header <span>=</span> {
        <span>&#34;Content-Type&#34;</span>: <span>&#34;text/calendar; charset=utf-8&#34;</span>
    }
    event_ics <span>=</span> event_ics<span>.</span>replace(<span>&#34;METHOD:REQUEST</span><span>\r\n</span><span>&#34;</span>, <span>&#34;&#34;</span>)

    r <span>=</span> requests<span>.</span>put(<span>f</span><span>&#34;</span><span>{</span>BASE_URL<span>}{</span>filename<span>}</span><span>&#34;</span>,
                     data<span>=</span>event_ics,
                     headers<span>=</span>header,
                     auth<span>=</span>HTTPDigestAuth(USERNAME, PASSWORD))
    <span>return</span> r<span>.</span>status_code
</code></pre></div><p>Note how I make sure that certain kinds of events (e.g. doctor appointments) are marked private and serialized to a separate file in my work calendar.</p>
<p>I then set up a redirect in nginx for serving these files via an unfindable URL, generated from a random, hashed and salted string.</p>
<p>I run this via a cron job every 15 minutes.</p>

<p>The whole point of this exercise wasn’t just that <em>I</em> could see events, but also that any events I put in my calendar will block my work calendar and be visible to coworkers so they know if I’m on a flight or traveling in another city. To do that, I need to copy these events to my work calendar.</p>
<p>This is a bit of an irony, because this whole exercise started when I was trying to <em>reduce</em> my dependency on Google Calendar. However, in fairness, Google Calendar is a choice of my workplace, and it’s not something <em>I</em> depend on outside of work. I’m not thrilled to give the data to Google, but at least I can walk away from them easily if I choose to.</p>
<p>To accomplish this, I’m using Google Script Engine and a modified version of <a href="https://github.com/derekantrican/GAS-ICS-Sync">this open source script</a>. In all honesty, I struggle with how this Javascript code is organized, but it gets the job done with minimal difficulty. I did modify this to read from the calendar <code>CATEGORIES</code> property and color code my calendar. The result means it’s really easy to parse my calendar at a glance—obviously I’m only sharing a small snippet of non-sensitive information.</p>
<p><img src="https://emilygorcenski.com/photo-gallery/writing/cal-colors.png" alt="Color coded blocks on a calendar showing a conference in green, a meeting in blue, and a flight in lavender"/></p>
<p>I have this Google Script running on 30 minute intervals.</p>

<p>I’ve been hacking around with this system for the last 6 months or so and making small tweaks and additions here or there in the meanwhile. I have to say, it works really great. The lastest update I made was integrating Airtrail via API. Now, when I book a flight, I enter the data into my flight tracker and within 15 minutes it’s added to my calendar, and within the hour it’s automatically copied to my work calendar. This is a huge quality of life improvement that saves me a ton of time in logistics management with my complicated travel requirements.</p>
<p>The overall cost of this system is pretty minimal. I’d imagine you can set this up and run it easily from a NAS at home if you want, but I opt to keep my data safely protected in Switzerland, so I subscribe to about $100 monthly of server time to run my websites and all my integrations. That’s a bit overkill—I can definitely optimize these costs and will do so over time, but the ease of getting everything set up on a docker host in a VM instance on a hosting provider was worth the extra money. And I’m easily saving $100 monthly in time just for making managing my schedule easier.</p>
<p>It’s not a perfect solution, but damn if it’s better than anything else I’ve tried yet.</p>
<p>Let me know if you ever try something similar!</p>
</div></div>
  </body>
</html>
