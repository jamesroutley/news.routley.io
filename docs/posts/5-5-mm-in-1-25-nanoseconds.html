<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://randomascii.wordpress.com/2022/01/12/5-5-mm-in-1-25-nanoseconds/">Original</a>
    <h1>5.5 mm in 1.25 nanoseconds</h1>
    
    <div id="readability-page-1" class="page"><div>
						<p>In 2004 I was working for Microsoft in the Xbox group, and a new console was being created. I got a copy of the detailed descriptions of the <a href="https://en.wikipedia.org/wiki/Xenon_(processor)">Xbox 360 CPU</a> and I read it through multiple times and suddenly I’d learned enough to become the official CPU expert. That meant I started having regular meetings with the hardware engineers who were working with IBM on the CPU which gave me even more expertise on this CPU, which was critical in helping me discover a <a href="https://randomascii.wordpress.com/2018/01/07/finding-a-cpu-design-bug-in-the-xbox-360/">design flaw in one of its instructions</a>, and in helping game developers master this finicky beast.</p>

<p>It was a lot of fun, and the work was appreciated, so a few months before <a href="https://randomascii.files.wordpress.com/2022/01/pxl_20220111_000923865-copy.jpg"><img width="371" height="277" title="Rainbow-hued picture of the top-right corner of the CPU wafer" alt="Rainbow-hued picture of the top-right corner of the CPU wafer" src="https://randomascii.files.wordpress.com/2022/01/pxl_20220111_000923865-copy_thumb.jpg?w=371&amp;h=277"/></a>the console shipped I got a present from the leadership of the project – an entire silicon wafer of Xbox 360 CPUs! That 30 cm disk of dice (I’ve always preferred “dice” as the plural form of CPU “die”) has been hanging on my home-office wall ever since. At its largest extent it has 23 complete CPUs horizontally and 20 vertically, but much fewer than 460 CPUs total due to the <a href="https://www.reddit.com/r/askscience/comments/9knl70/why_are_cpu_chip_wafers_circular_instead_of_a/">circular shape</a> of the wafer. A lot of CPUs are partially or totally omitted because of that – I counted 356 complete CPUs on the wafer.</p>
<p>It looks cool, it creates beautiful rainbow diffraction effects, and the individual chips are big enough that you can see the key features of the CPU that occupied my career for five years.</p>
<p><a href="https://randomascii.files.wordpress.com/2022/01/pxl_20220112_034711428-copy.jpg"><img width="324" height="229" title="Close-up of a single CPU with ruler beside it" alt="Close-up of a single CPU with ruler beside it" src="https://randomascii.files.wordpress.com/2022/01/pxl_20220112_034711428-copy_thumb.jpg?w=324&amp;h=229"/></a>The Xbox 360 CPU had three PowerPC cores and a 1 MB L2 cache and these features are clearly visible on the wafer.</p>
<p>In the die picture to the right (which looks to be about 14 mm by 12 mm) you can see the regular pattern of small black rectangles in the bottom right corner – that’s the L2 cache. To the left of that is one of the CPU cores. Above that but flipped vertically is another CPU core, and to the right of that one and flipped horizontally is the third CPU core. I used to know what the visible elements of the CPU cores were (L1 caches? register files? arithmetic units?) but I’ve long since forgotten. However they are still distinctive enough to make the reflective copying obvious.</p>
<p><a href="https://randomascii.files.wordpress.com/2022/01/image-7.png"><img width="267" height="308" title="Super-closeup of CPU die with labels for CPU cores, interconect, and I/O stuff" alt="Super-closeup of CPU die with labels for CPU cores, interconect, and I/O stuff" src="https://randomascii.files.wordpress.com/2022/01/image_thumb-7.png?w=267&amp;h=308"/></a>In addition to the three CPU cores and the L2 cache there is a horizontal bar going across the middle of the chip, and some more space to the right of the top-right CPU. I think that the horizontal bar is the bus that connects the CPUs to each other and to the L2 cache, and the top-right stuff is presumably for off-chip I/O.</p>
<p>The picture to the right – beautifully annotated by yours truly – is literally just a cell-phone picture of the wafer hanging on my wall. I may be biased – or traumatized by my time dealing with this ornery CPU – but I think that being able to see the features of this chip so clearly is wonderful.</p>
<p>So, this is all very pretty, and I know that you all wish you had one of these on your wall, but there is more to tell. Back in the day I wrote a lot of benchmarks in order to look for places where the actual performance of the CPU didn’t match what we expected. I remember doing that for our customized memcpy routine and discovering that prefetch instructions that missed in the TLB (<a href="https://en.wikipedia.org/wiki/Translation_lookaside_buffer">Translation Lookaside Buffer</a>, also known as the <a href="https://randomascii.files.wordpress.com/2022/01/pxl_20220112_222806496.jpg"><img width="229" height="304" title="Self-portrait of author, reflected in CPU wafer" alt="Self-portrait of author, reflected in CPU wafer" src="https://randomascii.files.wordpress.com/2022/01/pxl_20220112_222806496_thumb.jpg?w=229&amp;h=304"/></a>page-table cache) were discarded. Since we typically prefetched about 1 KiB (eight 128-byte cache lines) ahead this meant that when copying large amounts of memory (where every 4 KiB page would give a TLB miss) roughly 25% of prefetches would be discarded. Those cache-line reads would then be handled serially, instead of having eight happening in parallel, causing large memory copies to take almost three times as long. These discarded prefetches were particularly bad because the Xbox 360 CPU was an in-order processor so no work would be done while waiting on the non-prefetched reads. This lead to me rewriting the heap so that it would use 64-KiB pages, thus avoiding most of the TLB misses and restoring the expected performance.</p>
<p>So, anyway. I wrote a lot of benchmarks.</p>
<p>One benchmark I wrote measured the L2 cache latency. This is done by setting up a linked list, following the links, and seeing how many cycles it takes to walk a long list. With fixed hardware it’s easy to construct a linked list that will stay in L1, or will always require a trip to L2, or will always require a trip to main memory. Standard stuff.</p>
<p>I don’t remember what the L2 cache latency was but do remember that the latency <em>varied</em> depending on which CPU core I ran it on. The L2 latency from CPU core 0 was pretty reliably four cycles lower than the L2 latency from CPU core 1 or 2. So that’s interesting.</p>
<p><a href="https://randomascii.files.wordpress.com/2022/01/image-8.png"><img width="348" height="335" title="CPU die with L2-cache to core arrows shown" alt="CPU die with L2-cache to core arrows shown" src="https://randomascii.files.wordpress.com/2022/01/image_thumb-8.png?w=348&amp;h=335"/></a>As I mentioned earlier, all communication between the CPU cores and the L2 cache was done through that horizontal strip across the middle of the chip. That means, necessarily, that all of the L2 traffic came out through the top of the L2 cache and then made its way to the three different CPUs. I’ve zoomed in on the earlier CPU die picture and added some arrows showing the flow of information from the L2 cache to the three different CPU cores. The crucial thing is that the path to the top-right CPU is quite short, whereas the path to the two CPUs on the left is noticeably longer – the signals have to travel horizontally across the interconnect.</p>
<p>The horizontal black lines on the very left are the <a href="https://en.wikipedia.org/wiki/Millimetre">millimeter</a> markers (ask a Canadian friend if you’re not familiar with these units) on a ruler that I held against the wafer when I took the picture. I rotated that ruler image and used it to measure the length of my horizontal red line and it came in at 5.5 mm. Since the Xbox 360 CPU ran at 3.2 GHz and since CPU cores 1 and 2 had an extra four cycles of L2 latency we can conclude that it took 1.25 nanoseconds for the signals to propagate that 5.5 mm distance!</p>
<p>Light can travel roughly 30 cm in one nanosecond so you may be wondering why this signal is traveling <em>so slow</em>. I will try to answer this but I must warn that I am a software developer with no formal training in hardware, so I might be misleading or wrong.</p>
<p>One reason is simply that electrical signals in wires, especially very thin wires, do not <a href="https://en.wikipedia.org/wiki/Velocity_factor">travel at the speed of light</a>. Another reason is that the signal is not traveling continuously. Instead the signal travels a short distance and then is latched by some gates and then on the next clock cycle it travels a bit farther, so the poor signal never even has a chance to get up to full speed. Finally, the Xbox 360 was designed to run at a higher clock speed, but then shipped at 3.2 GHz because otherwise it would have melted. The 5.5 mm in four clock cycles was probably an artifact of the design goal of having the clock cycles be much shorter.</p>
<p>That said, 5.5 mm in 1.25 nanoseconds is still about 4,400 kilometers per second, so it’s not exactly slow. But mostly I just inordinately geekily <em>love</em> that I can see that 1.25 nanosecond delay, with my naked eye, hanging on my wall. Thanks Xbox leadership!</p>
<h2>Aside</h2>
<p><a href="https://randomascii.files.wordpress.com/2022/01/pxl_20211226_224154522-1.jpg"><img width="340" height="256" title="Unicycle lying in the snow, &#39;cause why not? It&#39;s the only snow tire we had" alt="Unicycle lying in the snow, &#39;cause why not? It&#39;s the only snow tire we had" src="https://randomascii.files.wordpress.com/2022/01/pxl_20211226_224154522-1_thumb.jpg?w=340&amp;h=256"/></a>The origin story above for how I became the Xbox 360 CPU expert is reasonably accurate. I was never assigned the task of becoming CPU expert, I was just given access to the reading material and I studied it to a slightly fanatical degree. I remembering lying on our living room floor during a snowpocalypse-triggered power outage reading it by flashlight until all the pipeline quirks made sense. This same learning pattern has been true for many areas of expertise that I have grabbed, from crash analysis to floating point to compiler bugs to CPU bugs. It’s worked for me.</p>
											</div><div id="entry-author-info">
						<p><img alt="" src="https://1.gravatar.com/avatar/d69d2780728dfc033fcc8123f31ef8fa?s=60&amp;d=identicon&amp;r=G" height="60" width="60"/>						</p><!-- #author-avatar -->
						<div id="author-description">
							<h2>
							About brucedawson							</h2><p>
							I&#39;m a programmer, working for Google, focusing on optimization and reliability. Nothing&#39;s more fun than making code run 10x as fast. Unless it&#39;s eliminating large numbers of bugs.

I also unicycle. And play (ice) hockey. And sled hockey. And juggle. And worry about whether this blog should have been called randomutf-8.

2010s in review tells more: https://twitter.com/BruceDawson0xB/status/1212101533015298048							</p><!-- #author-link	-->
						</div><!-- #author-description -->
					</div></div>
  </body>
</html>
