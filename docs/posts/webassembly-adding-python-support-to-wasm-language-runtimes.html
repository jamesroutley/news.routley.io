<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wasmlabs.dev/articles/python-wasm32-wasi/">Original</a>
    <h1>WebAssembly: Adding Python support to WASM language runtimes</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>We recently added Python support to <a href="https://github.com/vmware-labs/webassembly-language-runtimes/">Wasm Language Runtimes</a>. This article provides an overview of how Python works in WebAssembly environments and provides a step by step guide on how to use it.</p>
<p>At VMware OCTO WasmLabs we want to grow the WebAssembly ecosystem by <a href="https://wasmlabs.dev/articles/hello-wasm/">helping developers adopt this new and exciting technology</a>. Our <a href="https://github.com/vmware-labs/webassembly-language-runtimes/">Wasm Language Runtimes</a> project aims to provide up-to-date, ready-to-run WebAssembly builds for the most popular language runtimes.</p>
<p><strong>We are happy to announce that we have a first build of Python for the <code>wasm32-wasi</code> target!</strong> It is based on the WASI support that is already available in CPython (the mainstream, C-based implementation of Python), augmented with additional libraries and usage examples to make it as easy to use as possible. Python joins PHP and Ruby in the list of supported languages.</p>

<p>To build <code>python.wasm</code> we rely on the <a href="https://pythondev.readthedocs.io/wasm.html">WASI build support</a> that is already available in CPython. We are reusing <code>zlib</code> and <code>libuuid</code> from the <a href="https://github.com/singlestore-labs/python-wasi/tree/main/docker">singlestore-labs/python-wasi</a> repository but are building <code>libsqlite</code> in-house to also enable support for the <code>sqlite3</code> module. You can find the <a href="https://github.com/vmware-labs/webassembly-language-runtimes/tree/main/libs/sqlite">source code here</a>.</p>
<p>We will build and release new binaries of Python for Wasm whenever a new upstream release is available. To find the latest release look for &#34;python&#34; releases in <a href="https://github.com/vmware-labs/webassembly-language-runtimes/releases?q=python">webassembly-language-runtimes on github</a>.</p>
<p>Also, Docker+Wasm fans, we are providing a <a href="https://github.com/orgs/vmware-labs/packages/container/package/python-wasm">python-wasm</a> container image.</p>
<p>The rest of this article will deal with examples of how to run <code>python.wasm</code> and leverage it to run your Python apps on WASI.</p>

<p>All of the examples below include a short explanation along with sample output, where relevant, so it is easier to read them through.</p>
<h2 id="prerequisites" tabindex="-1">Prerequisites</h2>
<p>To give it a try, you will need to have a few tools installed in advance.</p>
<p>Most notably, a shell that has enough Unicode support to show emojis. Yep, this is what we use as part of our examples ðŸ˜„</p>
<h3 id="python3-on-your-machine" tabindex="-1"><code>python3</code> on your machine</h3>
<p>Implementing pip for <code>python.wasm</code> is not universally possible, because WASI still does not offer full socket support. Downloading a package from the internet may not even work on some runtimes.</p>
<p>But that is OK for most scenarios we are interested in, as <code>python.wasm</code> is likely to be used as a runtime in Cloud or Edge environments rather than a generic development platform. We will start by using a native python3.11 installation to setup a sample applications. And then we will show how you can run it on <code>python.wasm</code>.</p>
<h3 id="wget-and-zip" tabindex="-1"><code>wget</code> and <code>zip</code></h3>
<p>These tools are required to download and extract the released binary.</p>
<h3 id="a-wasi-compatible-runtime" tabindex="-1">A WASI-compatible runtime</h3>
<p>As <code>python.wasm</code> is built for WASI you will need to get a compatible WebAssembly runtime, such as <a href="https://wasmtime.dev/">Wasmtime</a>. We also provide an additional binary that will run on <a href="https://wasmedge.org/">WasmEdge</a>, which offers extended socket support on top of a modified WASI API. Since Docker+Wasm uses WasmEdge, this is the binary you will need if you want to build a WASM container image to use with Docker, as explained later in the article.</p>
<h3 id="docker%2Bwasm" tabindex="-1">Docker+Wasm</h3>
<p>To try the examples with Docker you will need &#34;Docker Desktop&#34; + Wasm <a href="https://docs.docker.com/desktop/release-notes/#4150">version 4.15</a> or later.</p>
<h2 id="setup" tabindex="-1">Setup</h2>
<p>All of the examples below assume you are using the same working directory. Some of them build on top of each other. Where this is the case we have tried referencing the previous one that we step on.</p>
<p>First, prepare a temporary folder and download the <code>python.wasm</code> binary</p>
<pre><code><span>mkdir /tmp/try-python-wasm</span></code></pre>
<p>Taking a look at the unzipped files we see two versions of <code>python.wasm</code> - one that&#39;s WASI compliant and one that can run on WasmEdge with its slightly non-standard and extended socket API. Also, the <code>usr/local/lib</code> folder includes a zip of the standard libraries, a placeholder <code>Lib/lib-dynload</code> and a <code>Lib/os.py</code>. The last two are not strictly necessary but if omitted will cause dependency warnings whenever python runs.</p>
<pre><code><span>tree</span></code></pre>
<p>Now, let&#39;s get the sample script and the data it will work on</p>
<pre><code><span>wget https://raw.githubusercontent.com/vmware-labs/webassembly-language-runtimes/main/python/examples/emojize_text.py</span></code></pre>
<h2 id="first-time-running-python.wasm" tabindex="-1">First time running python.wasm</h2>
<p>The Python standard libraries are packed into <code>usr/local/lib</code> and the <code>python.wasm</code> binary is compiled to look for this path in <code>/</code></p>
<p>So, in order to run Python properly we need to pre-open the current folder as root within the sandboxed WASM environment, where <code>python.wasm</code> will be running. For Wasmtime this is done via <code>--mapdir</code>.</p>
<pre><code><span>wasmtime run \</span></code></pre>
<p>We could do the same with the WasmEdge-compliant binary (note the slight differences in the CLI arguments).</p>
<pre><code><span>wasmedge \</span></code></pre>
<h2 id="running-the-repl" tabindex="-1">Running the repl</h2>
<p>If you want, you can play with the Python repl.</p>
<pre><code><span>wasmtime run --mapdir /::$PWD bin/python-3.11.1.wasm</span></code></pre>
<h2 id="running-an-app-with-dependencies" tabindex="-1">Running an app with dependencies</h2>
<p>Next, let&#39;s assume we have a Python app that has additional dependencies. For example <a href="https://github.com/vmware-labs/webassembly-language-runtimes/blob/main/python/examples/emojize_text.py">emojize_text.py</a>, which we downloaded as part of the <a href="#setup">setup</a>.</p>
<h3 id="installing-dependencies-to-the-pre-compiled-path" tabindex="-1">Installing dependencies to the pre-compiled path</h3>
<p>To set up the dependencies we will need <code>pip3</code> (or <code>python3 -m pip</code>) on the development machine, to download and install the necessary dependencies. The most straightforward way of doing this is by running pip with <code>--target</code> pointing the path that is already pre-compiled into the <code>python.wasm</code> binary. Namely, <code>usr/local/lib/python3.11/</code></p>
<pre><code><span>pip3 install emoji -t usr/local/lib/python3.11/</span></code></pre>
<p>Now we can run our text <em>emojizer</em>. Taking a look at the sample source text.</p>
<pre><code><span>cat source_text.txt</span></code></pre>
<p>We get this result from <code>emojize_text.py</code></p>
<pre><code><span>wasmtime run \</span></code></pre>
<h3 id="using-a-virtual-environment" tabindex="-1">Using a virtual environment</h3>
<p>Any more complex python application is likely to be using virtual environments. In that case, you will have a <code>venv</code> folder with all requirements pre-installed. All you need to leverage them is to:</p>
<ul>
<li>Make sure this folder is pre-opened when running <code>python.wasm</code></li>
<li>Add it to the <code>PYTHONPATH</code> environment variable</li>
</ul>
<p>Let&#39;s take a look at how to do this.</p>
<p>We will start by creating a virtual environment within the same folder and installing &#39;emoji&#39; in it.</p>
<pre><code><span>python3 -m venv venv-emoji</span></code></pre>
<p>With what we did so far we were mapping the current folder as root anyway (for the sake of <code>usr</code> becoming <code>/usr</code>) so we only need to set the <code>PYTHONPATH</code> variable accordingly.</p>
<pre><code><span>wasmtime \</span></code></pre>
<p>Passing an environment variable with WasmEdge is similar</p>
<pre><code><span>wasmedge \</span></code></pre>
<h2 id="running-the-docker-container" tabindex="-1">Running the Docker container</h2>
<p>Docker+WASM uses the WasmEdge runtime internally. To leverage it we have packaged the python-3.11.1-wasmedge.wasm binary in a container image available as <code>ghcr.io/vmware-labs/python-wasm:3.11.1-latest</code>.</p>
<p>Here is an example of running the Python repl from this container image. As you can see from the output of the interactive session, the container includes only <code>python.wasm</code> and the standard libraries from <code>usr</code>. No base OS images, no extra environment variables, or any other clutter. The Dockerfile for this image is available at <a href="https://raw.githubusercontent.com/vmware-labs/webassembly-language-runtimes/c8036b435ea22fa554a77576eeb2d94626dddc2b/images/python/Dockerfile">webassembly-language-runtimes/images/python/Dockerfile</a>.</p>
<pre><code><span>docker run --rm \</span></code></pre>
<p>You can also run the Docker container to execute a one-liner like this.</p>
<pre><code><span>docker run --rm \</span></code></pre>
<h2 id="running-the-docker-container-with-dependencies" tabindex="-1">Running the Docker container with dependencies</h2>
<p>The <code>python-wasm</code> container image comes by default just with the Python standard library, so if your project has extra dependencies you will need to take care of them. Let&#39;s reuse the <code>venv-emoji</code> environment in which we installed <code>emoji</code> in <a href="#using-a-virtual-environment">the example above</a>.</p>
<p>We need to do three things</p>
<ol>
<li>Ensure that the <code>emoji</code> module installed in the <code>venv-emoji</code> folder is mounted in the running <code>python-wasm</code> container</li>
<li>Ensure that it is also on the <code>PYTHONPATH</code> within the running <code>python-wasm</code> container</li>
<li>Ensure that the python program and its data (in this case <code>emojize_text.py</code> and <code>source_text.txt</code>) are also mounted in the container</li>
</ol>
<p>A vital piece of knowledge here is that whatever you mount in the running container gets automatically pre-opened by the WasmEdge runtime. Same goes for all environment variables that you pass to the container when you run it.</p>
<p>One way of doing what we want is to just mount <code>site-packages</code> from <code>venv-emoji</code> over the <code>site-packages</code> folder of the pre-compiled path in <code>/usr/local</code>. This is what this could look like:</p>
<pre><code><span>docker run --rm \</span></code></pre>
<p>An alternative would be to map the current folder as <code>/opt</code> and use <code>PYTHONPATH</code> like this:</p>
<pre><code><span>docker run --rm \</span></code></pre>
<h2 id="wrapping-it-all-in-a-new-container-image" tabindex="-1">Wrapping it all in a new container image</h2>
<p>This way of running your python application with the <code>python-wasm</code> container is too cumbersome. Luckily OCI and Docker already offer a way to package everything nicely.</p>
<p>Let&#39;s first create a Dockerfile that steps on <code>python-wasm</code> to package our emojize_text.py app and its <code>venv</code> into a single image.</p>
<pre><code><span>cat &gt; Dockerfile.emojize &lt;&lt;EOF</span></code></pre>
<p>Building the container is straightforward</p>
<pre><code><span>docker build -f Dockerfile.emojize -t emojize.py-wasm .</span></code></pre>
<p>And to run it we only have to mount and provide the data file.</p>
<pre><code><span>docker run --rm \</span></code></pre>

<p>We have seen how to use <code>python.wasm</code> with pre-existing applications either directly, or as part of the <code>python-wasm</code> container image.</p>
<p>If your Python application has only pure Python dependencies now you know how to run it on any Cloud or Edge WASI-compatible platform, including Docker+WASM.</p>
<p>As we work on extending what <code>python.wasm</code> has to offer, we are happy to get your feedback and suggestions. Give us a star at <a href="https://github.com/vmware-labs/webassembly-language-runtimes/">WebAssembly Language Runtimes</a>, drop us a comment in Github at <a href="https://github.com/vmware-labs/webassembly-language-runtimes/issues/46">Python.wasm roadmap #46</a> or follow us on Twitter at <a href="https://twitter.com/vmwwasm">@vmwwasm</a>.</p>
</div></div>
  </body>
</html>
