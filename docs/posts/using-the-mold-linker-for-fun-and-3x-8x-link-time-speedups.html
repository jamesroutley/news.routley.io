<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.productive-cpp.com/using-the-mold-linker-for-fun-and-3x-8x-link-time-speedups/">Original</a>
    <h1>Using the mold linker for fun and 3x-8x link time speedups</h1>
    
    <div id="readability-page-1" class="page"><article id="post-446">
	<!-- Page/Post Single Image Disabled or No Image set in Post Thumbnail -->
	<div>
		<!-- .entry-header -->

		<div>
			
<h2>Introduction</h2>



<p>Scripting languages provide immediate feedback: They are usually interpreted or compiled to code just-in-time, enabling a rapid edit-test-cycle. On the other hand, languages like C++ and Rust generate all code upfront before anything gets executed. While this can make for some very efficient code, it slows down development: For any change you make, there is a certain time you have to wait before you can test it. For C++ specifically this is exacerbated¬†by these traits:</p>



<ul><li>It is a complicated language with lots of baggage ‚Äì hard, and therefore slow, to parse.</li><li>Modules still haven‚Äôt ‚Äúarrived‚Äù ‚Äì preprocessor inclusion of a large amount of header code is still necessary and can lead to very large translation units that must be processed.</li><li>Template instantiation that can take long and runs single-threaded in all major compilers.</li><li>Templates produce large binaries and debug info, both during compilation and linking. More bytes = more time needed!</li><li>There are two steps to building an executable: Compiling and linking.</li></ul>



<p>Depending on the size of the codebase and the hardware building it, there can be substantial turnaround time forcing developers to switch to other tasks, and losing flow and context.</p>



<p>Best practices for writing C++ code and a distributed build system can go a long way in reducing <em>compile </em>times. The clang compiler has also focused on fast compilation speeds and beats gcc in most cases. But in this post we want to focus on speeding up the <em>linking </em>step, which comes after building the object files of a library or executable.</p>



<p><strong>Linking</strong></p>



<p>In the typical edit-build-test cycle, one or a few source files will be built, and afterwards linked into an executable or shared library. Linking can easily take up a majority of the time: Even if only one file changed, <em>the entire binary is recreated</em> (there have been attempts at <a href="https://gcc.gnu.org/wiki/GoldIncrementalLinking">incremental linking</a>, but in practice they are brittle and hardly used, at least on Unix).</p>



<h2>Overview of Unix Linkers</h2>



<p>Here‚Äôs a brief overview of the major linkers I have used on Linux the past years, in chronological order of release:</p>



<ul><li><a href="https://sourceware.org/binutils/docs/ld/">ld</a>: The GNU linker (sometimes called bfd linker or  <code>ld.bfd</code>  since it uses the BFD libraries for accessing the object files). Part of <a href="https://www.gnu.org/software/binutils/">binutils</a>. </li><li><a href="https://en.wikipedia.org/wiki/Gold_(linker)">gold</a>: A linker developed at Google to reduce link times of large applications. Also part of binutils.</li><li><a href="https://lld.llvm.org/">lld</a>: The linker of the LLVM project. It is usually faster than gold.</li></ul>



<p>At work we have a large C++ codebase that <a href="https://github.com/AlDanial/cloc">clocs </a>in at nearly 12 million lines. It contains lots of templated code to effortlessly generate fast code across distinct data types and for special cases. Binaries can get quite large, especially with full debug info. To deal with this huge beast and keep developers productive we made these adjustments over the years:</p>



<ul><li>June 2012: Port to clang. In addition to quicker compilation, this also enabled better tooling (e.g. sanitizers that weren‚Äôt on par in gcc at that time). Developers can use either gcc or clang. For testing and production gcc remains king.</li><li>August 2013: Integrate gold. This provided a noticeable reduction of link times.</li><li>December 2017: Enable <code>-gsplit-dwarf</code>. This outsources the debug info from the object file into an adjacent file and therefore reduces the work the linker has to perform (<a href="https://www.productive-cpp.com/improving-cpp-builds-with-split-dwarf/" data-type="post" data-id="266">more details</a>).</li><li>March 2017: Integrate lld, which was faster than gold, but caused some issues in conjunction with <code>-gsplit-dwarf</code> so in the end we didn‚Äôt use it.</li></ul>



<p>Then in May 2021 a new linker was released: <a href="https://github.com/rui314/mold">mold</a>. Its main goal was to be a faster (<em>much faster</em>) replacement for all the existing linkers. To be honest, with all the development that had been going on with lld and gold and the speedups they provided I wasn‚Äôt expecting any major breakthroughs on the linker front anymore. But benchmarks looked promising. So I moved to the fun part ‚Äì integrating a new tool into our build, analyzing the resulting bugs and, finally, benchmarking!</p>







<h2>Using mold</h2>



<p>Building mold is easy ‚Äì just <a href="https://github.com/rui314/mold#compile-mold">follow the instructions</a>. You will end up with the <code>mold</code> executable and an <code>ld</code> symlink pointing to it. But how do we make gcc or clang use it? When the compiler generates a shared library or an executable, it searches for the <code>ld</code> command in some predefined locations, which can be overridden by <code>-B/path/to/mold/install/dir</code> (<a href="https://gcc.gnu.org/onlinedocs/gcc/Directory-Options.html#index-B">see the gcc docs</a>):</p>



<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div id="crayon-629a173636c99875224135" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span># Uses ld from standard location</span></p><p><span>$</span><span> </span><span>gcc </span><span>f1</span><span>.</span><span>cpp</span><span>.</span><span>o</span><span> </span><span>f2</span><span>.</span><span>cpp</span><span>.</span><span>o</span><span> </span>-<span>shared</span><span> </span>-<span>o</span><span> </span><span>lib1</span><span>.</span><span>so</span></p><p><span># Uses ld from -B override</span></p><p><span>$</span><span> </span><span>gcc</span><span> </span>-<span>B</span>/<span>path</span>/<span>to</span>/<span>mold</span>/<span>install</span>/<span>dir </span><span>f1</span><span>.</span><span>cpp</span><span>.</span><span>o</span><span> </span><span>f2</span><span>.</span><span>cpp</span><span>.</span><span>o</span><span> </span>-<span>shared</span><span> </span>-<span>o</span><span> </span><span>lib1</span><span>.</span><span>so</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0010 seconds] -->




<p>That‚Äôs it, next up is a scratch make and analyzing the errors üòâ</p>



<h2>Issues encountered</h2>



<ul><li><a href="https://github.com/rui314/mold/issues/271">Linking exits with error</a></li></ul>



<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div id="crayon-629a173636cae502655004" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>mold</span><span>:</span><span> </span><span>warning</span><span>:</span><span> </span><span>libsse_icc</span><span>.</span><span>a</span><span>(</span><span>searchbv</span><span>.</span><span>cpp</span><span>.</span><span>o</span><span>)</span><span>:</span><span>(</span><span>.</span><span>gnu</span><span>.</span><span>linkonce</span><span>.</span><span>d</span><span>.</span><span>DW</span><span>.</span><span>ref</span><span>.</span><span>__gxx_personality_v0</span><span>)</span><span>:</span><span> </span><span>R_X86_64_64 </span><span>relocation </span><span>against </span><span>symbol</span><span> </span><span>`</span><span>__gxx_personality_v0</span>&#39;<span> </span><span>can </span><span>not</span><span> </span><span>be </span><span>used</span><span>;</span><span> </span><span>recompile </span><span>with</span><span> </span>-<span>fPIC</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->




<p>Some of our object files are built by Intel‚Äôs<a href="https://en.wikipedia.org/wiki/Intel_C%2B%2B_Compiler"> ICC compiler</a> for better optimization. This triggered an error during linking. Apparently ICC emits a legacy <code>.gnu.linkonce</code> section, which can be ignored. This was <a href="https://github.com/rui314/mold/commit/be6ae07ac181eb783f2d7428572a5e0aab879efa">workarounded quickly</a> in mold.</p>



<ul><li><a href="https://github.com/rui314/mold/issues/283">Linking archives with <code>-l</code> and absolute name does not work</a></li></ul>



<p>We had something like this in our codebase:</p>



<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div id="crayon-629a173636cb1948897674" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>$</span><span> </span><span>mold </span><span>main</span><span>.</span><span>cpp</span><span>.</span><span>o</span><span> </span>-<span>l</span>/<span>path</span>/<span>to</span>/<span>lib1</span><span>.</span><span>a</span><span> </span>-<span>o</span><span> </span><span>exe</span></p><p><span>mold</span><span>:</span><span> </span><span>library </span><span>not</span><span> </span><span>found</span><span>:</span><span> </span>/<span>path</span>/<span>to</span>/<span>lib1</span><span>.</span><span>a</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->




<p>This worked in gold, but does not in ld nor lld. It was trivial to fix this in our codebase by including the archive without <code>-l</code>: </p>



<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div id="crayon-629a173636cb2101466957" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>$</span><span> </span><span>mold </span><span>main</span><span>.</span><span>cpp</span><span>.</span><span>o</span><span> </span>/<span>path</span>/<span>to</span>/<span>lib1</span><span>.</span><span>a</span><span> </span>-<span>o</span><span> </span><span>exe</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->




<ul><li><a href="https://github.com/rui314/mold/issues/366">Crash and hanging debugger for gcc-built binaries</a></li></ul>



<p>This issue turned out to be two distinct ones. First, we had a crash in a binary linked by mold. This was fixed by a later version, though it‚Äôs unknown to me what exactly fixed it, and I did not have time to investigate. The second issue was <em>very slow debugging</em>: It took ages to attach to or start mold-linked binaries ‚Äì which is a tough sell if you want to speed up developer workflows. Analysis of the binaries showed that there was no <a href="https://sourceware.org/gdb/onlinedocs/gdb/Index-Files.html">gdb index</a> section in the binaries since mold did not support this yet (the gdb index is optionally constructed at link time when passing <code>-Wl,--gdb-index</code> and allows the debugger to look up symbols quickly). For our very large binaries it was essential. Eventually the feature <a href="https://github.com/rui314/mold/issues/396">was implemented</a> (very quickly!) and this problem was solved. To construct the index, the object files need to be built with <code>-ggnu-pubnames</code>.</p>



<ul><li><a href="https://github.com/rui314/mold/issues/472">Linker crash during gdb index construction</a></li></ul>



<p>When taking the new gdb index feature for a test drive, mold crashed during linking of some binaries. After providing a reproducer the issue was again fixed quickly!</p>



<ul><li><strong>Executables failing to link with undefined symbols</strong></li></ul>



<p>There were a handful of targets that failed to link with undefined symbols. All these linker invocations featured static archives. The reason here was that mold has a slightly different archive handling than gold and ld, but identical to lld. That handling is <a href="https://rui314.github.io/mold.html#Archive_symbol_resolution">described here</a>. In practice that means mold can use different object files to resolve symbols, and these different object files in turn have dependencies themselves which need to be fulfilled.</p>



<p>Here‚Äôs an example:</p>



<ul><li><code>main.cpp.o</code> references function <code>f1</code></li><li>Both <code>a.cpp.o</code> and <code>b.cpp.o</code> define function <code>f1</code> (e.g. it‚Äôs an inline function so it is not an ODR violation)</li><li><code>a.cpp.o</code> is part of a static library <code>tools.a</code> and references lots of other symbols from another library, let‚Äôs call it <code>libext.a</code></li><li><code>b.cpp.o</code> has no external references</li><li>The link command is <code>gcc -o exe tools.a main.cpp.o b.cpp.o</code></li></ul>



<p>The ‚Äústandard‚Äù linker semantics of ld and gold use objects from an archive only to resolve undefined symbols from objects previously encountered on the command line. They would look at <code>main.cpp.o</code>, see the reference to <code>f1</code>, and look for it in all objects that come after, <code>b.cpp.o</code> in our case, and pull that in. In contrast, mold and lld <em>remember the contents of the archive</em> and the definition of <code>f1</code> in <code>a.cpp.o</code>, and pull that in. When you consider that <code>a.cpp.o</code> references symbols from <code>libext.a</code> which is <em>not</em> linked here, it becomes clear that this will lead to linker errors with mold or lld only.</p>



<p>While it‚Äôs possible to refactor the targets so that they do link with mold, we still need to retain gold compatibility. So for such targets we just fall back to linking with gold.</p>



<p><strong>Conclusion</strong></p>



<p>While looking at these issues please keep in mind:</p>



<ul><li>mold is still in development and barely one year old! Yet there were only two bugs.</li><li>Our codebase is large and definitely has some edge cases. It‚Äôs likely even easier to get this running for smaller projects.</li><li><a href="https://github.com/rui314">Rui, the creator of mold</a>, is incredibly responsive and helpful, fixing bugs quickly and implementing features with amazing quality and speed! Thanks Rui!</li></ul>



<h2>Benchmarks</h2>



<p>So what have we gained by integrating mold? Let‚Äôs take a look! The charts below compare several predefined build profiles on the y-axis that can be used by our developers. Some explanations:</p>



<ul><li>gcc still is our default compiler and gold the default linker. So when there is neither clang nor mold in the profile name, it‚Äôs a gcc+gold build.</li><li>ASan refers to <a href="https://github.com/google/sanitizers/wiki/AddressSanitizer">AddressSanitizer</a>. The <code>ClangASanOptimized</code> profile is just for comparison, and there is no corresponding mold profile.</li><li><code>-gsplit-dwarf</code> is enabled in all profiles.</li><li>Measurements were performed three times and the minimum was used.</li><li>The bars represent the percentage of the maximum value of each chart.<br/></li></ul>



<p><strong>Scratch make</strong></p>



<div><figure><a href="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image.png?ssl=1"><img data-attachment-id="495" data-permalink="https://www.productive-cpp.com/using-the-mold-linker-for-fun-and-3x-8x-link-time-speedups/image/#main" data-orig-file="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image.png?fit=634%2C442&amp;ssl=1" data-orig-size="634,442" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image.png?fit=300%2C209&amp;ssl=1" data-large-file="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image.png?fit=634%2C442&amp;ssl=1" width="634" height="442" src="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image.png?resize=634%2C442&amp;ssl=1" alt="" srcset="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image.png?w=634&amp;ssl=1 634w, https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image.png?resize=300%2C209&amp;ssl=1 300w" sizes="(max-width: 634px) 100vw, 634px" data-recalc-dims="1"/></a></figure></div>



<p>These numbers should be taken with a grain of salt since a compile cluster was used, which can lead to fluctuations. Although the scratch make is heavily dominated by compilation (not linking), and therefore not the target of our improvements, there is still a visible speedup. Note that <code>OptimizedMold</code> takes longer than <code>Optimized</code>, while all others are faster with mold. This was not analyzed further but the incremental link times below indicate this might have been such a fluctuation.</p>







<p><strong>Build size</strong></p>



<div><figure><a href="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image-1.png?ssl=1"><img data-attachment-id="496" data-permalink="https://www.productive-cpp.com/using-the-mold-linker-for-fun-and-3x-8x-link-time-speedups/image-1/#main" data-orig-file="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image-1.png?fit=637%2C444&amp;ssl=1" data-orig-size="637,444" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-1" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image-1.png?fit=300%2C209&amp;ssl=1" data-large-file="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image-1.png?fit=637%2C444&amp;ssl=1" loading="lazy" width="637" height="444" src="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image-1.png?resize=637%2C444&amp;ssl=1" alt="" srcset="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image-1.png?w=637&amp;ssl=1 637w, https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image-1.png?resize=300%2C209&amp;ssl=1 300w" sizes="(max-width: 637px) 100vw, 637px" data-recalc-dims="1"/></a></figure></div>



<p>As expected, mold does not make much difference here. On the compiler side, clang generates noticeably smaller artifacts which I believe is due to smaller debug info.</p>







<p><strong>Linking large shared libraries</strong></p>



<p>lib1.so</p>



<div><figure><a href="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image-2.png?ssl=1"><img data-attachment-id="497" data-permalink="https://www.productive-cpp.com/using-the-mold-linker-for-fun-and-3x-8x-link-time-speedups/image-2/#main" data-orig-file="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image-2.png?fit=638%2C435&amp;ssl=1" data-orig-size="638,435" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-2" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image-2.png?fit=300%2C205&amp;ssl=1" data-large-file="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image-2.png?fit=638%2C435&amp;ssl=1" loading="lazy" width="638" height="435" src="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image-2.png?resize=638%2C435&amp;ssl=1" alt="" srcset="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image-2.png?w=638&amp;ssl=1 638w, https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image-2.png?resize=300%2C205&amp;ssl=1 300w" sizes="(max-width: 638px) 100vw, 638px" data-recalc-dims="1"/></a></figure></div>



<p>lib2.so</p>



<div><figure><a href="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image-3.png?ssl=1"><img data-attachment-id="498" data-permalink="https://www.productive-cpp.com/using-the-mold-linker-for-fun-and-3x-8x-link-time-speedups/image-3/#main" data-orig-file="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image-3.png?fit=636%2C441&amp;ssl=1" data-orig-size="636,441" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-3" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image-3.png?fit=300%2C208&amp;ssl=1" data-large-file="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image-3.png?fit=636%2C441&amp;ssl=1" loading="lazy" width="636" height="441" src="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image-3.png?resize=636%2C441&amp;ssl=1" alt="" srcset="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image-3.png?w=636&amp;ssl=1 636w, https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image-3.png?resize=300%2C208&amp;ssl=1 300w" sizes="(max-width: 636px) 100vw, 636px" data-recalc-dims="1"/></a></figure></div>



<p>Here we are measuring the link time of the two largest shared libraries in our system. This is a major bottleneck in the edit-build-test cycle and as you can see, mold performs very well here (speedup as measured over corresponding gold profiles).</p>



<figure><table><thead><tr><th data-align="left">Build Profile</th><th data-align="center">Link Speedup lib1.so</th><th data-align="center">Link Speedup lib2.so</th></tr></thead><tbody><tr><td data-align="left"><code>DebugMold</code></td><td data-align="center">6.4x</td><td data-align="center">3.7x</td></tr><tr><td data-align="left"><code>ClangDebugMold</code></td><td data-align="center">6.5x</td><td data-align="center">5.7x</td></tr><tr><td data-align="left"><code>OptimizedMold</code></td><td data-align="center">8.4x</td><td data-align="center">4.5x</td></tr></tbody></table></figure>







<p><strong>Attaching gdb to a running process and setting breakpoints</strong></p>



<div><figure><a href="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image-4.png?ssl=1"><img data-attachment-id="499" data-permalink="https://www.productive-cpp.com/using-the-mold-linker-for-fun-and-3x-8x-link-time-speedups/image-4/#main" data-orig-file="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image-4.png?fit=639%2C430&amp;ssl=1" data-orig-size="639,430" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-4" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image-4.png?fit=300%2C202&amp;ssl=1" data-large-file="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image-4.png?fit=639%2C430&amp;ssl=1" loading="lazy" width="639" height="430" src="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image-4.png?resize=639%2C430&amp;ssl=1" alt="" srcset="https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image-4.png?w=639&amp;ssl=1 639w, https://i0.wp.com/www.productive-cpp.com/wp-content/uploads/2022/06/image-4.png?resize=300%2C202&amp;ssl=1 300w" sizes="(max-width: 639px) 100vw, 639px" data-recalc-dims="1"/></a></figure></div>



<p>In this benchmark mold-linked binaries perform just as quickly as those from gold, which shows that the gdb index works. Interestingly clang shines again here with much faster gdb attach times.</p>



<p><strong>Other observations</strong></p>



<p>As expected, mold-linked binaries had the same runtime performance.</p>



<p>On another positive note, the peak memory consumption of mold is roughly half of gold‚Äôs, I‚Äôve also seen 30% for some libraries. This can be very helpful when linking many libraries in parallel.</p>







<p>Integrating mold into a Rust build is also quite simple and showed similar improvements on an internal project. Scratch make times didn‚Äôt improve dramatically but the more important incremental builds did.</p>







<h2>Takeaways</h2>



<ul><li>There is still innovation in linkers. <strong>Thanks Rui for developing this great tool!</strong></li></ul>



<ul><li>If you are a C++ developer, I recommend integrating mold into your projects. It is straightforward and the benefits are huge!<br/></li></ul>



<h2>Further Reading</h2>



<ul><li><a href="https://github.com/rui314/mold#why-is-mold-so-fast">Why is mold so fast?</a></li></ul>



<ul><li><a href="https://github.com/rui314/mold/blob/main/docs/design.md">Design and implementation of mold</a></li></ul>



<ul><li><a href="https://rui314.github.io/mold.html">mold help page</a></li></ul>


            <!-- Share buttons by mashshare.net - Version: 3.7.6--><!-- AI CONTENT END 1 -->
					</div><!-- .entry-content -->

		<!-- .entry-footer -->
	</div><!-- .entry-container -->
</article></div>
  </body>
</html>
