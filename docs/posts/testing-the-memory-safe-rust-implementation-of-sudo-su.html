<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ferrous-systems.com/blog/testing-sudo-rs/">Original</a>
    <h1>Testing the memory safe Rust implementation of Sudo/Su</h1>
    
    <div id="readability-page-1" class="page"><div>
        <blockquote>
  <p><em><a href="https://github.com/memorysafety/sudo-rs">sudo-rs</a> is a project by <a href="https://www.memorysafety.org/">Prossimo</a> jointly implemented by <a href="https://tweedegolf.nl/en">Tweede golf</a> and <a href="https://tweedegolf.nl/en/blog/91/reimplementing-sudo-in-rust">Ferrous Systems</a>.</em></p>
</blockquote>

<p>As our friends at Tweede golf announced in <a href="https://tweedegolf.nl/en/blog/91/reimplementing-sudo-in-rust">a previous blog post</a>, Ferrous Systems and Tweede golf have been working together on a re-implementation of sudo in the Rust programming language.</p>

<p>In this blog post, I&#39;ll talk about the approach we are using to test sudo-rs and ensure sudo-rs is &#34;compliant&#34; with the original sudo. Let&#39;s dive in!</p>

<blockquote>
  <p>NOTE The first half of this post covers technical details and the second half is more high-level. If you are not super interested in the low-level details, feel free to skim the first half until you reach the <a href="#the-big-picture">the big picture</a> section.</p>
</blockquote>



<p>Faced with the task of re-implementing sudo, one of the questions that came up early on was:
how do we verify that sudo-rs behaves just like the original sudo (&#34;ogsudo&#34;)?</p>

<p>The obvious answer was: given a particular scenario, I should get the same results regardless of whether I use ogsudo or sudo-rs.
So, for example, a command invocation like this:</p>

<div><pre><code><span>$</span> whoami 
<span>ferris

</span><span>$</span> <span>sudo </span>whoami
<span>root
</span></code></pre></div>
<p>should return the same output with either sudo implementation.</p>

<p>In particular, this single command verifies a few things about a sudo implementation:</p>

<ul>
  <li>the command, <code>whoami</code>, is executed as the target user.</li>
  <li>the default target user is the superuser, <code>root</code>.</li>
</ul>

<p>These end-to-end (E2E) tests at the command line interface felt like the right approach to verify our implementation.</p>



<p>To scale this approach, we wanted to be able to run these tests automatically as part of our CI pipeline, so
we wrote a test library to be able to write the E2E tests as regular Rust <code>#[test]</code> functions.</p>

<p>Each test often requires a different set of settings:</p>

<ul>
  <li>a custom <code>/etc/sudoers</code> file; this file defines sudo&#39;s security policy and other sudo configuration</li>
  <li>users with certain group memberships, login shells, passwords, etc.</li>
  <li>other custom <code>/etc</code> files to, for example, configure PAM or the syslog daemon and test how sudo interoperates with them</li>
</ul>

<p>Making these changes in the system that runs the tests would not only be cumbersome but could potentially compromise its security, even if just temporarily.
Instead of doing that, we made it so that each test runs in an ephemeral test environment isolated from the rest of the system.</p>

<p>With that requirement in mind, we came up with the following test API.
Below is the <code>sudo whoami</code> E2E test written in Rust using <a href="https://github.com/memorysafety/sudo-rs/tree/v0.1.0-dev.20230620/test-framework">our <code>sudo_test</code> library</a>.</p>

<div><pre><code><span>use</span> <span>sudo_test</span><span>::{</span><span>Command</span><span>,</span> <span>Env</span><span>};</span>

<span>#[test]</span>
<span>fn</span> <span>default_target_user_is_root</span><span>()</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>()</span><span>&gt;</span> <span>{</span>
    <span>let</span> <span>username</span> <span>=</span> <span>&#34;ferris&#34;</span><span>;</span>
    <span>let</span> <span>sudoers</span> <span>=</span> <span>&#34;ALL ALL=(ALL:ALL) NOPASSWD: ALL&#34;</span><span>;</span>
    <span>let</span> <span>test_environment</span> <span>=</span> <span>Env</span><span>(</span><span>sudoers</span><span>)</span>
        <span>.user</span><span>(</span><span>username</span><span>)</span>
        <span>.build</span><span>()</span><span>?</span><span>;</span>

    <span>let</span> <span>actual</span> <span>=</span> <span>Command</span><span>::</span><span>new</span><span>(</span><span>&#34;sudo&#34;</span><span>)</span>
        <span>.arg</span><span>(</span><span>&#34;whoami&#34;</span><span>)</span>
        <span>.as_user</span><span>(</span><span>username</span><span>)</span>
        <span>.output</span><span>(</span><span>&amp;</span><span>test_environment</span><span>)</span><span>?</span>
        <span>.stdout</span><span>()</span><span>?</span><span>;</span>

    <span>let</span> <span>expected</span> <span>=</span> <span>&#34;root&#34;</span><span>;</span>
    <span>assert_eq!</span><span>(</span><span>expected</span><span>,</span> <span>actual</span><span>);</span>
    <span>Ok</span><span>(())</span>
<span>}</span>
</code></pre></div>
<p>Let&#39;s break down that a bit.</p>

<p>The chain of <code>sudo_test::Command</code> methods should look familiar because that API is based on the <a href="https://doc.rust-lang.org/std/process/struct.Command.html"><code>std::process::Command</code></a> API.
It has a few deviations, though: the extra <code>as_user</code> method lets you run the command as a specific user;
and the <code>output</code> method takes a <code>test_environment</code> argument because the command is executed there, and <em>not on the system that&#39;s running the test</em>.
Other than that, that statement should be quite readable: the <code>actual</code> variable contains the stdout output of running <code>sudo whoami</code> as the user <code>ferris</code>.</p>

<p>Now let&#39;s look at the <code>Env</code> statement.
The expression on the right hand side builds a test environment using the settings specified in the preceding method calls.
The test environment will include a user called ferris.
The argument of the <code>Env</code> function is the content of the test environment&#39;s <code>/etc/sudoers</code> file.
The sudoers file used in this test allows <em>everyone</em> to run <em>any</em> command with sudo <em>without</em> password authentication!
That policy is likely not something you want to use on a real system, but it&#39;s appropriate in this case, where we don&#39;t want to test nor deal with password authentication.</p>

<p>Finally, we have the assertion that verifies that the user ferris temporarily became root while running sudo.</p>

<p>Last thing worth mentioning here: when the test finishes, regardless of success or failure, the test environment gets disposed of automatically.</p>



<p>I said we want to run these tests using both ogsudo and sudo-rs to verify that they behave the same.
The previous test didn&#39;t specify <em>which</em> sudo implementation was being tested but
the code hints that there is <em>a</em> sudo implementation in the test environment.</p>

<p>The sudo implementation is chosen at runtime using the environment variable: <code>SUDO_UNDER_TEST</code> and is typically set prior to calling <code>cargo test</code>.</p>

<p>To run the entire test suite against the sudo-rs implementation you execute</p>

<div><pre><code><span>$</span> <span>SUDO_UNDER_TEST</span><span>=</span>ours cargo <span>test</span>
</code></pre></div>
<p>And to run the entire test suite against the original sudo implementation you execute</p>

<div><pre><code><span>$</span> <span>SUDO_UNDER_TEST</span><span>=</span>theirs cargo <span>test</span>
</code></pre></div>
<p>or simply omit setting <code>SUDO_UNDER_TEST</code> as the default is to use ogsudo.</p>

<p>At runtime, <code>sudo_test::Env</code> reads <code>SUDO_UNDER_TEST</code> and installs either a fresh build of sudo-rs in the test environment or some known version of ogsudo.</p>



<p>As we started writing these tests early on, we had to deal with the fact that a test would pass with ogsudo but fail with sudo-rs.
The way we deal with this scenario is to mark such tests with the <code>#[ignore]</code> attribute.
That way, <code>SUDO_UNDER_TEST=ours cargo test</code> runs only the un-<code>#[ignore]</code>-d tests that are known to work.</p>

<p><code>#[ignore]</code>-d tests should always pass when run against ogsudo so in CI we pass <code>--include-ignored</code> to a second <code>cargo test</code> invocation to run all tests, including the <code>#[ignore]</code>-d ones, against ogsudo.</p>

<p>There are two reasons why a test can fail with sudo-rs:</p>

<ul>
  <li>the feature is not yet implemented</li>
  <li>the feature is implemented but we got some detail wrong â€“ I like to think of these as &#34;gaps&#34; between our implementation and ogsudo</li>
</ul>

<p>In both cases we track the test failure in the project&#39;s issue tracker and,
in the latter case, we mark the issue with <a href="https://github.com/memorysafety/sudo-rs/issues?q=is%3Aissue+label%3Anon-compliant+sort%3Acreated-asc">the <code>non-compliant</code> label</a>.</p>

<p>As a way to check that all failing tests are linked to more visible issues,
we have a CI check that enforces that all <code>#[ignore]</code>-d tests include an issue number using the format shown below:</p>

<div><pre><code><span>#</span><span>[</span><span>ignore</span> <span>=</span> <span>&#34;gh1234&#34;</span><span>]</span>
<span>fn</span> <span>tests_some_unimplemented_sudo_rs_feature</span><span>()</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>()</span><span>&gt;</span> <span>{</span>
    <span>// ..</span>
<span>}</span>
</code></pre></div>
<p>Eventually, features get implemented and gaps get closed.
That&#39;s when we remove the <code>#[ignore]</code> attributes from the tests and the tests become regression tests for sudo-rs.</p>

<p>It would be bad if we forgot to un-<code>#[ignore]</code> the tests that a PR fixed, but as we are human, that can happen!
So, there is a CI check for that too: all <code>#[ignore]</code>-d tests are run against sudo-rs and if <em>any</em> of them <em>succeeds</em> then CI fails.
If an <code>#[ignore]</code>-d test succeeds, that means it should be un-<code>#[ignore]</code>-d and that&#39;s what the CI failure message instructs you to do.</p>



<p>So far I&#39;ve focused on the implementation and the Rust bits because as a programmer that&#39;s the easier and more fun thing to do when writing a blog post but,
let&#39;s take a step back from the <em>how</em> and change the focus to <em>what</em> we have accomplished.</p>

<p>The test suite we have built is effectively an executable specification of the <em>original</em> sudo.
Each test verifies a piece of sudo behavior described in sudo&#39;s user documentation, which is the closest thing we have to a written specification.
In other words, all this time we have not been writing sudo-rs tests, but rather ogsudo tests.
(â€¦ just don&#39;t tell the sudo-rs team; they haven&#39;t realized yet).</p>

<p>By running the test suite against our sudo implementation we are finding all the spots where it doesn&#39;t quite match ogsudo&#39;s behavior.
So, from the point of view of the sudo-rs project these are &#34;compliance&#34; tests that verify that our sudo implementation is compliant with the executable ogsudo specification.</p>

<p>Having these compliance tests, especially the failing ones, is great for a few reasons:</p>

<ul>
  <li>it&#39;s easier to fix bugs when you have a failing test case that reproduces the bug</li>
  <li>when you are going to implement a new feature, the existing ogsudo tests that exercise that feature can serve as your checklist or acceptance criteria. One could even view this aspect as test-driven development or behavior-driven development</li>
  <li>the number and percentage of failing tests let us track progress towards the goal of being a &#34;drop-in replacement&#34; for sudo</li>
</ul>

<p>And, at the end of the day, with this test suite we can confidently say that sudo-rs behaves the same as ogsudo in these hundreds of scenarios.</p>

<p>Another benefit of writing ogsudo tests that operate at the command line interface is that this process can happen independently of the work that happens on sudo-rs.
There is no problem committing tests that exercise a feature that has not yet been implemented in sudo-rs.
Because we run the tests against ogsudo and CI checks that all those pass, we can be confident in that each test in itself is correct even when sudo-rs fails the test.</p>



<p>As you may imagine, we derive test cases from our experience as sudo users as well as the sudo man pages.
We test that command-line flags and sudoers settings behave as described in the documentation and that illegal operations and invalid syntax are rejected.</p>

<p>Sometimes the documentation is not clear about how some features interact with each other.
In that case, the observable behaviors of those interactions become test cases.</p>

<p>For example, these are two features described in the manual:</p>

<ul>
  <li><code>sudo command</code> executes the <code>command</code> in an environment that contains only a handful of environment variables, like <code>SUDO_USER</code> and <code>SUDO_COMMAND</code>, that are set by sudo itself.</li>
  <li>The <code>env_keep</code> setting in the sudoers file lets you preserve some environment variables set in the invoking user&#39;s environment.</li>
</ul>

<p>The manual does not describe, however, what happens if you put a variable that sudo sets, like <code>SUDO_USER</code>, in the <code>env_keep</code> list.
In that case, is <code>SUDO_USER</code> preserved from the invoking user&#39;s environment or does it get set/overwritten by sudo?
(what happens in practice is the latter)</p>

<p>Another example: the manual says that some env vars like <code>PATH</code> and <code>TERM</code> are preserved if set in the invoking user&#39;s environment. Does that sound familiar?
At first, that may sound like <code>PATH</code> and <code>TERM</code> are special but the reality is that they are default members of the <code>env_keep</code> list.</p>

<p>The more surprising bit is that you can write <code>Defaults env_keep -= &#34;PATH TERM&#34;</code> or <code>Defaults !env_keep</code> in the sudoers file to avoid preserving said env vars â€“ that behavior is not mentioned in the sudo manual.</p>

<p>One of the most interesting findings about ogsudo&#39;s behavior was due to carelessness rather than paying attention to the details.</p>

<p>The <code>sudo_test::Env</code> API has a method to create files in the test environment.
The initial version of that API created files with very open permissions; basically it <code>chmod 0777</code>-ed the file (whoops, that was me ðŸ™‹).</p>

<p>To our initial surprise, <code>sudo</code> refuses to run when <code>/etc/sudoers</code> has world-write permissions and gives you a helpful error message.</p>

<p>That fact makes a lot of sense from a security point of view: if the sudoers file is world writable then a user that should not have sudo perms can simply grant themselves sudo permissions by modifying the sudoers file.
This detail is not mentioned in the sudo manual so if that had been our only specification we would have missed it, so I&#39;m glad for my carelessness back then.</p>

<p>All in all, writing tests has improved our collective understanding of sudo, which is a huge plus in my opinion:
the better you understand the problem you are trying to solve, the better the solution you&#39;ll come up with.</p>

<p>I should also mention here that the sudo-rs team is in contact with Todd Miller, the author of sudo,
and we often <a href="https://github.com/memorysafety/sudo-rs/issues/180">receive clarifications on corner cases where it&#39;s unclear what the intended sudo behavior should be</a>.</p>



<p>As I revealed earlier, we have been writing ogsudo tests all this time and those tests have eventually uncovered two bugs in the original sudo.
It did come as a surprise though; the test seemed to correctly check the behavior stated in the manual and sudo-rs passed it but ogsudo failed it.
That was a first because so far test failures had been exclusive to sudo-rs.</p>

<p>In any case, I&#39;m happy to report that both bugs have been reported upstream (<a href="https://github.com/memorysafety/sudo-rs/issues/427#issuecomment-1589619556">1</a>, <a href="https://github.com/memorysafety/sudo-rs/issues/427#issuecomment-1591838516">2</a>), promptly fixed (<a href="https://github.com/memorysafety/sudo-rs/issues/432#issuecomment-1589915702">1</a>, <a href="https://github.com/memorysafety/sudo-rs/issues/432#issuecomment-1591832031">2</a>) and already released in (og)sudo <a href="https://www.sudo.ws/releases/devel/#1.9.14b2">1.9.14b2</a> ðŸŽ‰.</p>



<p>To summarize this blog post: with our testing approach, we have:</p>

<ul>
  <li>built an executable sudo specification that serves as our sudo compliance test suite</li>
  <li>found and fixed gaps between our implementation and the original sudo</li>
  <li>improved our collective understanding of sudo</li>
  <li>uncovered two bugs in the original sudo implementation</li>
</ul>

<p>Now that you know about our testing approach, why not <a href="https://github.com/memorysafety/sudo-rs#quick-start">give sudo-rs a try</a>?
And if you find that it doesn&#39;t support a use case you care about or that it doesn&#39;t behave like ogsudo, we would greatly appreciate a pull request adding a new test case to our compliance test suite!</p>

      </div></div>
  </body>
</html>
