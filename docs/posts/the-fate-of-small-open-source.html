<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nolanlawson.com/2025/11/16/the-fate-of-small-open-source/">Original</a>
    <h1>The fate of &#34;small&#34; open source</h1>
    
    <div id="readability-page-1" class="page"><div>
				<p>By far the most popular npm package I’ve ever written is <a href="https://www.npmjs.com/package/blob-util"><code>blob-util</code></a>, which is ~10 years old and still gets 5+ million weekly downloads.</p>
<p>It’s a small collection of utilities for working with <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob"><code>Blob</code>s</a> in JavaScript. I wrote it because I found that PouchDB users were endlessly confused about how to work with <code>Blob</code>s and how to convert them to strings, <code>ArrayBuffer</code>s, etc.</p>
<p>Given that <a href="https://survey.stackoverflow.co/2025/ai#sentiment-and-usage">some 80% of developers</a> are now using AI in their regular work, <code>blob-util</code> is almost certainly the kind of thing that most developers would just happily have an LLM generate for them. Sure, you <em>could</em> use <code>blob-util</code>, but then you’d be taking on an extra dependency, with unknown performance, maintenance, and supply-chain risks.</p>
<p>And sure enough, Claude will happily spit out whatever <code>Blob</code> utilities you need when prompted:</p>
<p><em>&gt; Write me a utility function in TypeScript to convert a Blob to an ArrayBuffer. It should return a Promise.</em></p>
<pre title="">function blobToArrayBuffer(blob: Blob): Promise&lt;ArrayBuffer&gt; {
  return new Promise((resolve, reject) =&gt; {
    const reader = new FileReader();

    reader.onload = () =&gt; {
      if (reader.result instanceof ArrayBuffer) {
        resolve(reader.result);
      } else {
        reject(new Error(&#39;Failed to read Blob as ArrayBuffer&#39;));
      }
    };

    reader.onerror = () =&gt; {
      reject(reader.error);
    };

    reader.readAsArrayBuffer(blob);
  });
}
</pre>
<p>Claude’s version is pretty close to <a href="https://github.com/nolanlawson/blob-util/blob/99c06472d18329eda1421286692bd875d76d5c9c/src/blob-util.ts#L384-L394">the <code>blob-util</code> version</a> (unsurprising, since it was probably trained on it!). Although it’s much more verbose, unnecessarily checking if <code>readAsArrayBuffer</code> actually gives you an <code>ArrayBuffer</code> (although this does make TypeScript happy). To be fair, it also improves on my implementation by directly <code>reject</code>ing with an error rather than the more awkward <code>onerror</code> event.</p>
<p role="complementary"><strong>Note:</strong> for anyone wondering, yes Claude did suggest the new <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob/arrayBuffer"><code>Blob.arrayBuffer()</code></a> method, but it also generated the above for “older environments.”</p>
<p>I suppose some people would see this as progress: fewer dependencies, more robust code (even if it’s a bit more verbose), quicker turnaround time than the old “search npm, find a package, read the docs, install it” approach.</p>
<p>I don’t have any excessive pride in this library, and I don’t particularly care if the download numbers go up or down. But I do think something is lost with the AI approach. When I wrote <code>blob-util</code>, I took a teacher’s mentality: the README has <a href="https://www.npmjs.com/package/blob-util#tutorial">a cutesy and whimsical tutorial</a> featuring Kirby, in all his blobby glory. (I had a thing for putting Nintendo characters in all my stuff at the time.)</p>
<p>The goal wasn’t just to give you a utility to solve your problem (although it does that) – the goal was also to <em>teach</em> people how to use JavaScript effectively, so that you’d have an understanding of how to solve other problems in the future.</p>
<p>I don’t know which direction we’re going in with AI (well, ~80% of us; to the remaining holdouts, I salute you and wish you godspeed!), but I do think it’s a future where we prize instant answers over teaching and understanding. There’s less reason to use something like <code>blob-util</code>, which means there’s less reason to write it in the first place, and therefore less reason to educate people about the problem space.</p>
<p>Even now there’s a movement toward putting documentation in an <a href="https://llmstxt.org/"><code>llms.txt</code></a> file, so you can just point an agent at it and save your brain cells the effort of deciphering English prose. (Is this even documentation anymore? What <em>is</em> documentation?)</p>
<h2>Conclusion</h2>
<p>I still believe in open source, and I’m still doing it (in fits and starts). But one thing has become clear to me: the era of small, low-value libraries like <code>blob-util</code> is over. They were already on their way out thanks to Node.js and the browser taking on more and more of their functionality (see <code>node:glob</code>, <code>structuredClone</code>, etc.), but LLMs are the final nail in the coffin.</p>
<p>This does mean that there’s less opportunity to use these libraries as a springboard for user education (Underscore.js <a href="https://underscorejs.org/docs/underscore-esm.html">also had this philosophy</a>), but maybe that’s okay. If there’s no need to find a library to, say, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/groupBy">group the items in an array</a>, then maybe learning about the mechanics of such libraries is unnecessary. Many software developers will argue that asking a candidate to reverse a binary tree is pointless, since it never comes up in the day-to-day job, so maybe the same can be said for utility libraries.</p>
<p>I’m still trying to figure out what <em>kinds</em> of open source are worth writing in this new era (hint: ones that an LLM can’t just spit out on command), and where education is the most lacking. My current thinking is that the most value is in bigger projects, more inventive projects, or in more niche topics not covered in an LLM’s training data. For example, I look back on my work on <a href="https://github.com/nolanlawson/fuite"><code>fuite</code></a> and various <a href="https://nolanlawson.com/2022/01/05/memory-leaks-the-forgotten-side-of-web-performance/">memory-leak-hunting blog posts</a>, and I’m pretty satisfied that an LLM couldn’t reproduce this, because it requires novel research and creative techniques. (Although who knows: maybe someday an agent will be able to just bang its head against Chrome heap snapshots until it finds the leak. I’ll believe it when I see it.)</p>
<p>There’s been a lot of hand-wringing lately about where open source fits in in a world of LLMs, but I still see people pushing the boundaries. For example, a lot of naysayers think there’s no point in writing a new JavaScript framework, since LLMs are so heavily trained on React, but then there goes the indefatigable <a href="https://github.com/trueadm">Dominic Gannaway</a> writing <a href="https://www.ripplejs.com/">Ripple.js</a>, yet another JavaScript framework (and with <a href="https://podrocket.logrocket.com/ripple-js-dominic-gannaway-logrocket-podrocket">some new ideas</a>, to boot!). This is the kind of thing I like to see: humans laughing in the face of the machine, going on with their human thing.</p>
<p>So if there’s a conclusion to this meandering blog post (excuse my squishy human brain; I didn’t use an LLM to write this), it’s just that: yes, LLMs have made some kinds of open source obsolete, but there’s still plenty of open source left to write. I’m excited to see what kinds of novel and unexpected things you all come up with.</p>
							</div></div>
  </body>
</html>
