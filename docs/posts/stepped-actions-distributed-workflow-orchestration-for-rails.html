<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/envirobly/stepped">Original</a>
    <h1>Show HN: Stepped Actions – distributed workflow orchestration for Rails</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">Stepped is a Rails engine for orchestrating complex workflows as a tree of actions. Each action is persisted, runs through Active Job, and can fan out into more actions while keeping the parent action moving step-by-step as dependencies complete.</p>
<a target="_blank" rel="noopener noreferrer" href="https://private-user-images.githubusercontent.com/32981/526200809-32577a1e-1240-44ec-af0a-493a48ec70ef.png?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NjYxNzYwOTYsIm5iZiI6MTc2NjE3NTc5NiwicGF0aCI6Ii8zMjk4MS81MjYyMDA4MDktMzI1NzdhMWUtMTI0MC00NGVjLWFmMGEtNDkzYTQ4ZWM3MGVmLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTEyMTklMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUxMjE5VDIwMjMxNlomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTUyZDNjODQ1ODAxNDNmNWU1M2NkMzY2MDYzZGZkNzNlZTI1ODY3NGUxNGI0ZGYyNzhjZmUyMDMyNjJmZWYxYmEmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.GDaiRmQihHiir9eqkT8fhZi4W7rddf02J3PSiPL_XeA"><img width="1024" height="1024" alt="stepped-actions" src="https://private-user-images.githubusercontent.com/32981/526200809-32577a1e-1240-44ec-af0a-493a48ec70ef.png?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NjYxNzYwOTYsIm5iZiI6MTc2NjE3NTc5NiwicGF0aCI6Ii8zMjk4MS81MjYyMDA4MDktMzI1NzdhMWUtMTI0MC00NGVjLWFmMGEtNDkzYTQ4ZWM3MGVmLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTEyMTklMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUxMjE5VDIwMjMxNlomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTUyZDNjODQ1ODAxNDNmNWU1M2NkMzY2MDYzZGZkNzNlZTI1ODY3NGUxNGI0ZGYyNzhjZmUyMDMyNjJmZWYxYmEmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.GDaiRmQihHiir9eqkT8fhZi4W7rddf02J3PSiPL_XeA"/></a>
<p dir="auto">Stepped was extracted out of <a href="https://klevo.sk/projects/envirobly-efficient-application-hosting-platform/" rel="nofollow">Envirobly</a> where it powers tasks like application deployment, that involve complex, out-of-the-band tasks like DNS provisioning, retries, waiting for instances to boot, running health checks and all the fun of a highly distributed networked system.</p>

<ul dir="auto">
<li><strong>Action trees</strong>: define a root action with multiple steps; each step can enqueue more actions and the step completes only once all the actions within it complete.</li>
<li><strong>Models are the Actors</strong>: in Rails, your business logic usually centers around database-persisted models. Stepped takes advantage of this and allows you to define and run actions on all your models, out of the box.</li>
<li><strong>Concurrency lanes</strong>: actions with the same <code>concurrency_key</code> share a <code>Stepped::Performance</code>, so only one runs at a time while others queue up (with automatic superseding of older queued work).</li>
<li><strong>Reuse</strong>: optional <code>checksum</code> lets Stepped skip work that is already achieved, or share a currently-performing action with multiple parents. Imagine you need to launch multiple workflows with different outcomes, that all depend on the outcome of the same action, somewhere in the action tree. Stepped makes this easy and efficient.</li>
<li><strong>Outbound completion</strong>: actions can be marked outbound (or implemented as a job) and completed later by an external event.</li>
</ul>

<p dir="auto">Add Stepped to your application (Rails <code>&gt;= 8.1.1</code>):</p>

<p dir="auto">Then install and run the migrations:</p>
<div dir="auto" data-snippet-clipboard-copy-content="bundle install
bin/rails stepped:install
bin/rails db:migrate"><pre>bundle install
bin/rails stepped:install
bin/rails db:migrate</pre></div>

<p dir="auto">Stepped hooks into Active Record automatically, so any model can declare actions.</p>
<p dir="auto">If you define an action without steps, Stepped generates a single step that calls the instance method with the same name:</p>
<div dir="auto" data-snippet-clipboard-copy-content="class Car &lt; ApplicationRecord
  stepped_action :drive

  def drive(miles)
    update!(mileage: mileage + miles)
  end
end

car = Car.find(1)
car.drive_later(5) # enqueues Stepped::ActionJob
car.drive_now(5)   # runs synchronously (still uses the Stepped state machine)"><pre><span>class</span> <span>Car</span> &lt; <span>ApplicationRecord</span>
  <span>stepped_action</span> <span>:drive</span>

  <span>def</span> <span>drive</span><span>(</span><span>miles</span><span>)</span>
    <span>update!</span><span>(</span><span>mileage</span>: <span>mileage</span> + <span>miles</span><span>)</span>
  <span>end</span>
<span>end</span>

<span>car</span> <span>=</span> <span>Car</span><span>.</span><span>find</span><span>(</span><span>1</span><span>)</span>
<span>car</span><span>.</span><span>drive_later</span><span>(</span><span>5</span><span>)</span> <span># enqueues Stepped::ActionJob</span>
<span>car</span><span>.</span><span>drive_now</span><span>(</span><span>5</span><span>)</span>   <span># runs synchronously (still uses the Stepped state machine)</span></pre></div>
<p dir="auto">Calling <code>*_now</code>/<code>*_later</code> creates a <code>Stepped::Action</code> and a <code>Stepped::Step</code> record behind the scenes. If the action finishes immediately, the associated <code>Stepped::Performance</code> (the concurrency “lane”) is created and destroyed within the same run. If the action is short-circuited (for example, cancelled/completed in <code>before</code>, or skipped due to a matching achievement), Stepped returns an action instance but does not create any database rows.</p>

<p dir="auto">An action is represented by <code>Stepped::Action</code> (statuses include <code>pending</code>, <code>performing</code>, <code>succeeded</code>, <code>failed</code>, <code>cancelled</code>, <code>superseded</code>, <code>timed_out</code>, and <code>deadlocked</code>). Each action executes one step at a time; steps are stored in <code>Stepped::Step</code> and complete when all of their dependencies finish.</p>
<p dir="auto">Actions that share a <code>concurrency_key</code> are grouped under a <code>Stepped::Performance</code>. A performance behaves like a single-file queue: the current action performs, later actions wait as <code>pending</code>, and when the current action completes the performance advances to the next incomplete action.</p>
<p dir="auto">If you opt into reuse, successful actions write a <code>Stepped::Achievement</code> keyed by <code>checksum</code>. When an action is invoked again with the same <code>checksum</code>, Stepped can skip the work entirely.</p>

<p dir="auto">Define an action on an Active Record model with <code>stepped_action</code>. The block is a small DSL that lets you specify steps, hooks, and keys:</p>
<div dir="auto" data-snippet-clipboard-copy-content="class Car &lt; ApplicationRecord
  stepped_action :visit do
    step do |step, location|
      step.do :change_location, location
    end

    succeeded do
      update!(last_visited_at: Time.current)
    end
  end

  def change_location(location)
    update!(location:)
  end
end"><pre><span>class</span> <span>Car</span> &lt; <span>ApplicationRecord</span>
  <span>stepped_action</span> <span>:visit</span> <span>do</span>
    <span>step</span> <span>do</span> |<span>step</span><span>,</span> <span>location</span>|
      <span>step</span><span>.</span><span>do</span> <span>:change_location</span><span>,</span> <span>location</span>
    <span>end</span>

    <span>succeeded</span> <span>do</span>
      <span>update!</span><span>(</span><span>last_visited_at</span>: <span>Time</span><span>.</span><span>current</span><span>)</span>
    <span>end</span>
  <span>end</span>

  <span>def</span> <span>change_location</span><span>(</span><span>location</span><span>)</span>
    <span>update!</span><span>(</span><span>location</span>:<span>)</span>
  <span>end</span>
<span>end</span></pre></div>

<p dir="auto">Each <code>step</code> block runs in the actor’s context (<code>self</code> is the model instance) and receives <code>(step, *arguments)</code>. Inside a step you typically enqueue more actions:</p>
<div dir="auto" data-snippet-clipboard-copy-content="stepped_action :park do
  step do
    honk
  end

  step do |step, miles|
    step.do :honk
    step.on [self, nil], :drive, miles
  end
end"><pre><span>stepped_action</span> <span>:park</span> <span>do</span>
  <span>step</span> <span>do</span>
    <span>honk</span>
  <span>end</span>

  <span>step</span> <span>do</span> |<span>step</span><span>,</span> <span>miles</span>|
    <span>step</span><span>.</span><span>do</span> <span>:honk</span>
    <span>step</span><span>.</span><span>on</span> <span>[</span><span>self</span><span>,</span> <span>nil</span><span>]</span><span>,</span> <span>:drive</span><span>,</span> <span>miles</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto"><code>step.do</code> is shorthand for “run another action on the same actor”. <code>step.on</code> accepts a single actor or an array of actors; <code>nil</code> values are ignored. If a step enqueues work, the parent action will remain <code>performing</code> until those child actions finish and report back.</p>
<p dir="auto">To deliberately fail a step without raising, set <code>step.status = :failed</code> inside the step body.</p>
<p dir="auto">The code within the <code>step</code> block runs within the model instance context. Therefore you have flexibility to write any model code within this block, not just invoking actions.</p>

<p dir="auto">Steps can also enqueue a timed wait:</p>
<div dir="auto" data-snippet-clipboard-copy-content="stepped_action :stopover do
  step { |step| step.wait 5.seconds }
  step { honk }
end"><pre><span>stepped_action</span> <span>:stopover</span> <span>do</span>
  <span>step</span> <span>{</span> |<span>step</span>| <span>step</span><span>.</span><span>wait</span> <span>5</span><span>.</span><span>seconds</span> <span>}</span>
  <span>step</span> <span>{</span> <span>honk</span> <span>}</span>
<span>end</span></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Before hooks and argument mutation</h3><a id="user-content-before-hooks-and-argument-mutation" aria-label="Permalink: Before hooks and argument mutation" href="#before-hooks-and-argument-mutation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><code>before</code> runs once, before any steps are performed. It can mutate <code>action.arguments</code>, or cancel/complete the action early:</p>
<div dir="auto" data-snippet-clipboard-copy-content="stepped_action :multiplied_drive do
  before do |action, distance|
    action.arguments = [distance * 2]
  end

  step do |step, distance|
    step.do :drive, distance
  end
end"><pre><span>stepped_action</span> <span>:multiplied_drive</span> <span>do</span>
  <span>before</span> <span>do</span> |<span>action</span><span>,</span> <span>distance</span>|
    <span>action</span><span>.</span><span>arguments</span> <span>=</span> <span>[</span><span>distance</span> * <span>2</span><span>]</span>
  <span>end</span>

  <span>step</span> <span>do</span> |<span>step</span><span>,</span> <span>distance</span>|
    <span>step</span><span>.</span><span>do</span> <span>:drive</span><span>,</span> <span>distance</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">The checksum (if you define one) is computed after <code>before</code>, so it sees the updated arguments.</p>

<p dir="auto">After callbacks run when the action is completed. You can attach them inline (<code>succeeded</code>, <code>failed</code>, <code>cancelled</code>, <code>timed_out</code>) or later from elsewhere with <code>after_stepped_action</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="Car.stepped_action :drive, outbound: true do
  after :cancelled, :failed, :timed_out do
    honk
  end
end

Car.after_stepped_action :drive, :succeeded do |action, miles|
  Rails.logger.info(&#34;Drove #{miles} miles&#34;)
end"><pre><span>Car</span><span>.</span><span>stepped_action</span> <span>:drive</span><span>,</span> <span>outbound</span>: <span>true</span> <span>do</span>
  <span>after</span> <span>:cancelled</span><span>,</span> <span>:failed</span><span>,</span> <span>:timed_out</span> <span>do</span>
    <span>honk</span>
  <span>end</span>
<span>end</span>

<span>Car</span><span>.</span><span>after_stepped_action</span> <span>:drive</span><span>,</span> <span>:succeeded</span> <span>do</span> |<span>action</span><span>,</span> <span>miles</span>|
  <span>Rails</span><span>.</span><span>logger</span><span>.</span><span>info</span><span>(</span><span>&#34;Drove <span><span>#{</span><span>miles</span><span>}</span></span> miles&#34;</span><span>)</span>
<span>end</span></pre></div>
<p dir="auto">If an after callback raises and you’ve configured Stepped to handle that exception class, the action status is preserved but the callback is counted as failed and the action will not grant an achievement.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Concurrency, queueing, and superseding</h2><a id="user-content-concurrency-queueing-and-superseding" aria-label="Permalink: Concurrency, queueing, and superseding" href="#concurrency-queueing-and-superseding"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Every action runs under a <code>concurrency_key</code>. Actions with the same key share a performance and therefore run one-at-a-time, in order.</p>
<p dir="auto">By default, the key is scoped to the actor and action name (for example <code>Car/123/visit</code>). You can override it with <code>concurrency_key</code> to coordinate across records or across different actions:</p>
<div dir="auto" data-snippet-clipboard-copy-content="stepped_action :recycle, outbound: true do
  concurrency_key { &#34;Car/maintenance&#34; }
end

stepped_action :paint, outbound: true do
  concurrency_key { &#34;Car/maintenance&#34; }
end"><pre><span>stepped_action</span> <span>:recycle</span><span>,</span> <span>outbound</span>: <span>true</span> <span>do</span>
  <span>concurrency_key</span> <span>{</span> <span>&#34;Car/maintenance&#34;</span> <span>}</span>
<span>end</span>

<span>stepped_action</span> <span>:paint</span><span>,</span> <span>outbound</span>: <span>true</span> <span>do</span>
  <span>concurrency_key</span> <span>{</span> <span>&#34;Car/maintenance&#34;</span> <span>}</span>
<span>end</span></pre></div>
<p dir="auto">While one action is <code>performing</code>, later actions with the same key are queued as <code>pending</code>. If multiple pending actions build up, Stepped supersedes older pending actions in favor of the newest one, and transfers any parent-step dependencies to the newest action so waiting steps don’t get stuck.</p>
<p dir="auto">Stepped also protects you from deadlocks: if a descendant action tries to join the same <code>concurrency_key</code> as one of its ancestors, it is marked <code>deadlocked</code> and its parent step will fail.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Checksums and reuse (Achievements)</h2><a id="user-content-checksums-and-reuse-achievements" aria-label="Permalink: Checksums and reuse (Achievements)" href="#checksums-and-reuse-achievements"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Reuse is opt-in per action via <code>checksum</code>. When a checksum is present, Stepped stores the last successful checksum in <code>Stepped::Achievement</code> under <code>checksum_key</code> (which defaults to the action’s tenancy key).</p>
<div dir="auto" data-snippet-clipboard-copy-content="stepped_action :visit do
  checksum { |location| location }

  step do |step, location|
    step.do :change_location, location
  end
end"><pre><span>stepped_action</span> <span>:visit</span> <span>do</span>
  <span>checksum</span> <span>{</span> |<span>location</span>| <span>location</span> <span>}</span>

  <span>step</span> <span>do</span> |<span>step</span><span>,</span> <span>location</span>|
    <span>step</span><span>.</span><span>do</span> <span>:change_location</span><span>,</span> <span>location</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">With a checksum in place:</p>
<ol dir="auto">
<li>If you invoke an action while an identical checksum is already performing under the same concurrency lane, Stepped returns the existing performing action and attaches the new parent step to it.</li>
<li>If an identical checksum has already succeeded (an achievement exists), Stepped returns a <code>succeeded</code> action immediately without creating new records.</li>
<li>If the checksum changes, Stepped performs the action and updates the stored achievement to the new checksum.</li>
</ol>
<p dir="auto">Use <code>checksum_key</code> to control the scope of reuse. Returning an array joins parts with <code>/</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="checksum_key { [&#34;Car&#34;, &#34;visit&#34;] } # shared across all cars"><pre><span>checksum_key</span> <span>{</span> <span>[</span><span>&#34;Car&#34;</span><span>,</span> <span>&#34;visit&#34;</span><span>]</span> <span>}</span> <span># shared across all cars</span></pre></div>
<div dir="auto"><h2 tabindex="-1" dir="auto">Outbound actions and external completion</h2><a id="user-content-outbound-actions-and-external-completion" aria-label="Permalink: Outbound actions and external completion" href="#outbound-actions-and-external-completion"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">An outbound action runs its steps but does not complete automatically when the final step finishes. It stays <code>performing</code> until you explicitly complete it (for example, from a webhook handler or another system):</p>
<div dir="auto" data-snippet-clipboard-copy-content="stepped_action :charge_card, outbound: true do
  step do |step, amount_cents|
    # enqueue calls to external systems here
  end
end

user.charge_card_later(1500)
user.complete_stepped_action_later(:charge_card, :succeeded)"><pre><span>stepped_action</span> <span>:charge_card</span><span>,</span> <span>outbound</span>: <span>true</span> <span>do</span>
  <span>step</span> <span>do</span> |<span>step</span><span>,</span> <span>amount_cents</span>|
    <span># enqueue calls to external systems here</span>
  <span>end</span>
<span>end</span>

<span>user</span><span>.</span><span>charge_card_later</span><span>(</span><span>1500</span><span>)</span>
<span>user</span><span>.</span><span>complete_stepped_action_later</span><span>(</span><span>:charge_card</span><span>,</span> <span>:succeeded</span><span>)</span></pre></div>
<p dir="auto">Under the hood, completion forwards to the current outbound action for that actor+name and advances its performance queue.</p>

<p dir="auto">This is especially useful if you&#39;d like to have (delayed) retries on certain errors, that ActiveJob supports out of the box.</p>
<p dir="auto">You can declare it with <code>job:</code>. Job-backed actions are treated as outbound and are expected to call <code>action.complete!</code> when finished. The action instance is passed as the first and only argument. To work with the action arguments, use the familiar <code>action.arguments</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="class TowJob &lt; ActiveJob::Base
  def perform(action)
    car = action.actor
    location = action.arguments.first
    car.update!(location:)

    action.complete!
  end
end

class Car &lt; ApplicationRecord
  stepped_action :tow, job: TowJob
end"><pre><span>class</span> <span>TowJob</span> &lt; <span>ActiveJob</span>::<span>Base</span>
  <span>def</span> <span>perform</span><span>(</span><span>action</span><span>)</span>
    <span>car</span> <span>=</span> <span>action</span><span>.</span><span>actor</span>
    <span>location</span> <span>=</span> <span>action</span><span>.</span><span>arguments</span><span>.</span><span>first</span>
    <span>car</span><span>.</span><span>update!</span><span>(</span><span>location</span>:<span>)</span>

    <span>action</span><span>.</span><span>complete!</span>
  <span>end</span>
<span>end</span>

<span>class</span> <span>Car</span> &lt; <span>ApplicationRecord</span>
  <span>stepped_action</span> <span>:tow</span><span>,</span> <span>job</span>: <span>TowJob</span>
<span>end</span></pre></div>
<p dir="auto">You can extend existing actions (including job-backed ones) by prepending steps:</p>
<div dir="auto" data-snippet-clipboard-copy-content="Car.prepend_stepped_action_step :tow do
  honk
end"><pre><span>Car</span><span>.</span><span>prepend_stepped_action_step</span> <span>:tow</span> <span>do</span>
  <span>honk</span>
<span>end</span></pre></div>

<p dir="auto">Set <code>timeout:</code> to enqueue a <code>Stepped::TimeoutJob</code> when the action starts. If the action is still <code>performing</code> after the timeout elapses, it completes as <code>timed_out</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="stepped_action :change_location, outbound: true, timeout: 5.seconds"><pre><span>stepped_action</span> <span>:change_location</span><span>,</span> <span>outbound</span>: <span>true</span><span>,</span> <span>timeout</span>: <span>5</span><span>.</span><span>seconds</span></pre></div>
<p dir="auto">Timeouts propagate through the tree: a timed-out nested action fails its parent step, which fails the parent action.</p>

<p dir="auto">Stepped can either raise exceptions (letting your job backend retry) or treat specific exception classes as handled and turn them into action failure.</p>
<p dir="auto">Configure the handled exception classes in your application:</p>
<div dir="auto" data-snippet-clipboard-copy-content="# config/initializers/stepped.rb (or an environment file)
Stepped::Engine.config.stepped_actions.handle_exceptions = [StandardError]"><pre><span># config/initializers/stepped.rb (or an environment file)</span>
<span>Stepped</span>::<span>Engine</span><span>.</span><span>config</span><span>.</span><span>stepped_actions</span><span>.</span><span>handle_exceptions</span> <span>=</span> <span>[</span><span>StandardError</span><span>]</span></pre></div>
<p dir="auto">When an exception is handled, Stepped reports it via <code>Rails.error.report</code> and marks the action/step as <code>failed</code> instead of raising.</p>

<p dir="auto">Stepped ships with <code>Stepped::TestHelper</code> (require <code>&#34;stepped/test_helper&#34;</code>) which builds on Active Job’s test helpers to make it easy to drain the full action tree.</p>
<div dir="auto" data-snippet-clipboard-copy-content="# test/test_helper.rb
require &#34;stepped/test_helper&#34;

class ActiveSupport::TestCase
  include ActiveJob::TestHelper
  include Stepped::TestHelper

  # If your workflows include outbound actions, complete them here so
  # `perform_stepped_actions` can fully drain the tree.
  def complete_stepped_outbound_performances
    Stepped::Performance.outbounds.includes(:action).find_each do |performance|
      action = performance.action
      Stepped::Performance.outbound_complete(action.actor, action.name, :succeeded)
    end
  end
end"><pre><span># test/test_helper.rb</span>
<span>require</span> <span>&#34;stepped/test_helper&#34;</span>

<span>class</span> <span>ActiveSupport</span>::<span>TestCase</span>
  <span>include</span> <span>ActiveJob</span>::<span>TestHelper</span>
  <span>include</span> <span>Stepped</span>::<span>TestHelper</span>

  <span># If your workflows include outbound actions, complete them here so</span>
  <span># `perform_stepped_actions` can fully drain the tree.</span>
  <span>def</span> <span>complete_stepped_outbound_performances</span>
    <span>Stepped</span>::<span>Performance</span><span>.</span><span>outbounds</span><span>.</span><span>includes</span><span>(</span><span>:action</span><span>)</span><span>.</span><span>find_each</span> <span>do</span> |<span>performance</span>|
      <span>action</span> <span>=</span> <span>performance</span><span>.</span><span>action</span>
      <span>Stepped</span>::<span>Performance</span><span>.</span><span>outbound_complete</span><span>(</span><span>action</span><span>.</span><span>actor</span><span>,</span> <span>action</span><span>.</span><span>name</span><span>,</span> <span>:succeeded</span><span>)</span>
    <span>end</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">In a test, you can perform Stepped jobs recursively:</p>
<div dir="auto" data-snippet-clipboard-copy-content="car.visit_later(&#34;London&#34;)
perform_stepped_actions"><pre><span>car</span><span>.</span><span>visit_later</span><span>(</span><span>&#34;London&#34;</span><span>)</span>
<span>perform_stepped_actions</span></pre></div>
<p dir="auto">To test failure behavior without bubbling exceptions, you can temporarily mark exception classes as handled:</p>
<div dir="auto" data-snippet-clipboard-copy-content="handle_stepped_action_exceptions(only: [StandardError]) do
  car.visit_now(&#34;London&#34;)
end"><pre><span>handle_stepped_action_exceptions</span><span>(</span><span>only</span>: <span>[</span><span>StandardError</span><span>]</span><span>)</span> <span>do</span>
  <span>car</span><span>.</span><span>visit_now</span><span>(</span><span>&#34;London&#34;</span><span>)</span>
<span>end</span></pre></div>

<p dir="auto">Run the test suite:</p>
<div dir="auto" data-snippet-clipboard-copy-content="bin/rails db:test:prepare
bin/rails test"><pre>bin/rails db:test:prepare
bin/rails <span>test</span></pre></div>

<p dir="auto">The gem is available as open source under the terms of the <a href="https://opensource.org/licenses/MIT" rel="nofollow">MIT License</a>.</p>
</article></div></div>
  </body>
</html>
