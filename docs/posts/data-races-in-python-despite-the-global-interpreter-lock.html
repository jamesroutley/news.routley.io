<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://verdagon.dev/blog/python-data-races">Original</a>
    <h1>Data races in Python, despite the Global Interpreter Lock</h1>
    
    <div id="readability-page-1" class="page"><div>
  
<section>
<h2 id="the-intrigue">
 The Intrigue</h2>

</section>
<section>
<p>
This was actually pretty hard to discover. The first few experiments failed, because Python is pretty smart about when it runs each thread.
</p>

</section>
<section>
<p>
Python will only interrupt a thread if it&#39;s taking too long. From <a href="https://stackoverflow.com/a/49573860">anekix&#39;s StackOverflow answer</a>:
</p>
<p>
In new versions, instead of using instruction count as a metric to switch threads, a configurable time interval is used. The default switch interval is 5 milliseconds.
</p>

</section>
<section>
<p>
So, it seems a thread needs to last longer than 5 milliseconds to possibly trigger a data race. This explains why we had to do 100,000 iterations in each thread.
</p>

</section>
<section>
<p>
This policy makes it difficult to identify when one has data races. However, it probably also reduces their frequency in production, which is a nice benefit.
</p>

</section>
<section>
<h2 id="thoughts-on-detecting-races">
 Thoughts on Detecting Races</h2>

</section>
<section>
<p>
As a language designer, I wonder if there was a missed opportunity in here.
</p>

</section>
<section>
<p>
<a href="https://news.ycombinator.com/item?id=7655948">Go&#39;s map iteration order is random</a>, in part because it prevents us from accidentally relying on iteration order. We could take some inspiration from that.
</p>

</section>
<section>
<p>
I wonder if, in development mode, Python could use a shorter interval so that we notice any data races hiding in our code, and in release mode, could use this longer (5ms) interval. <a href="#note4" data-noteid="4">4</a>
</p>

</section>
<section>
<p>
This also relates to one&#39;s philosophy on determinism. We know that:
</p>
<ul>
<li>
Determinism helps a lot for reproducing bugs. Nobody likes heisenbugs. <a href="#note5" data-noteid="5">5</a>
</li>
<li>
Relying on non-guaranteed determinism can cause some bugs. For example, if we accidentally depend on a hash map&#39;s ordering in 100 places, and then change our hash map&#39;s algorithm, we suddenly have 100 bugs.
</li>
</ul>

</section>
<section>
<p>
These would seem to be incompatible, but a core goal of <a href="https://vale.dev/">Vale</a> is to make races more obvious, and reproduce them easily.
</p>

</section>
<section>
<p>
We could do this with <b>universal deterministic replayability</b>, where in development mode we record all non-deterministic inputs, such as command line arguments, stdin, sockets, files, etc. <a href="#note6" data-noteid="6">6</a> <a href="#note7" data-noteid="7">7</a>, plus the scheduling of all inter-thread messages and mutex lockings. This might seem difficult, but it&#39;s possible for a language to guarantee determinism, for example if it uses a <a href="https://verdagon.dev/blog/seamless-fearless-structured-concurrency">region-based borrow checker</a>, and eliminates <span>unsafe</span> blocks and undefined behavior.
</p>

</section>
<section>
<p>
With that, every run would be <b>random but recorded</b>, and when we do encounter a race, we could reproduce the race trivially by replaying the recording.
</p>

</section>
<section>
<p>
Someday, perhaps problems like these will be a thing of the past!
</p>

</section>

      </div></div>
  </body>
</html>
