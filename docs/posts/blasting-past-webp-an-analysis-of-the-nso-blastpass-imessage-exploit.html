<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://googleprojectzero.blogspot.com/2025/03/blasting-past-webp.html">Original</a>
    <h1>Blasting Past WebP - An analysis of the NSO BLASTPASS iMessage exploit</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-4442255878341841259" itemprop="description articleBody">

 <p id="h.7totxo172g4m"><span>An analysis of the NSO BLASTPASS iMessage exploit</span></p>
 <p><span>Posted by Ian Beer, Google Project Zero</span></p>
 
 <p><span>On September 7, 2023 Apple </span><span><a href="https://support.apple.com/en-us/106361">issued</a></span><span> an out-of-band security update for iOS:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhpVzqhKSxPZc0TxpxC_Ka4_MVC3fJD4u9HbPMnh5jE4_tLYK08va_RroD4K3PkzOHV5SLJa8ovjXtUpF5FJRaA2SBW-SFv4fELlDeF8kEznmeBu4Zzi-kV_AMIlQLXBZTgUj9s6WQvkpE041lbp2XmSqGkj4u49X9EQOdNCeum_m1acT1HAul-xsuToi0/s1748/image8.png"><img alt="Release notes for iOS 16.6.1 and iPadOS 16.6.1, including CVE-2023-41064 for ImageIO and CVE-2023-41061 for Wallet, detailing security updates and potential exploitation." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhpVzqhKSxPZc0TxpxC_Ka4_MVC3fJD4u9HbPMnh5jE4_tLYK08va_RroD4K3PkzOHV5SLJa8ovjXtUpF5FJRaA2SBW-SFv4fELlDeF8kEznmeBu4Zzi-kV_AMIlQLXBZTgUj9s6WQvkpE041lbp2XmSqGkj4u49X9EQOdNCeum_m1acT1HAul-xsuToi0/s1200/image8.png" title="Release notes for iOS 16.6.1 and iPadOS 16.6.1, including CVE-2023-41064 for ImageIO and CVE-2023-41061 for Wallet, detailing security updates and potential exploitation."/></a></span></p>
 
 <p><span>Around the same time on September 7th 2023, </span><span><a href="https://citizenlab.ca/2023/09/blastpass-nso-group-iphone-zero-click-zero-day-exploit-captured-in-the-wild/">Citizen Lab published a blog post</a></span><span> linking the two CVEs fixed in iOS 16.6.1 to an &#34;NSO Group Zero-Click, Zero-Day exploit captured in the wild&#34;:</span></p>
 
 <p><span>&#34;</span><span>[The target was] an individual employed by a Washington DC-based civil society organization with international offices...</span></p>
 
 <p><span>The exploit chain was capable of compromising iPhones running the latest version of iOS (16.6) without any interaction from the victim.</span></p>
 
 <p><span>The exploit involved PassKit attachments containing malicious images sent from an attacker iMessage account to the victim.&#34;</span></p>
 
 <p><span>The day before, on September 6th 2023, Apple </span><span><a href="https://issues.chromium.org/issues/40071416">reported a vulnerability to the WebP project</a></span><span>, indicating in the report that they planned to ship a custom fix for Apple customers the next day.</span></p>
 
 <p><span>The WebP team posted their first </span><span><a href="https://chromium.googlesource.com/webm/libwebp/%2B/902bc9190331343b2017211debcec8d2ab87e17a">proposed fix</a></span><span> in the public git repo the next day, and five days after that on September 12th Google released a </span><span><a href="https://chromereleases.googleblog.com/2023/09/stable-channel-update-for-desktop_12.html">new Chrome stable release</a></span><span> containing the WebP fix. Both Apple and Google marked the issue as exploited in the wild, alerting other integrators of WebP that they should rapidly integrate the fix as well as causing the security research community to take a closer look...</span></p>
 
 <p><span>A couple of weeks later on September 21st 2023, former Project Zero team lead Ben Hawkes (in collaboration with </span><span><a href="https://x.com/mistymntncop">@mistymntncop</a></span><span>) published the </span><span><a href="https://blog.isosceles.com/the-webp-0day/">first detailed writeup</a></span><span> of the root cause of the vulnerability on the </span><span>Isosceles</span><span> Blog. A couple of months later, on November 3rd, a group called </span><span><a href="https://www.darknavy.org/">Dark Navy</a></span><span> published their first blog post: a two-part analysis (</span><span><a href="https://www.darknavy.org/blog/exploiting_the_libwebp_vulnerability_part_1/">Part 1</a></span><span> - </span><span><a href="https://www.darknavy.org/blog/exploiting_the_libwebp_vulnerability_part_2/">Part 2</a></span><span>) of the WebP vulnerability and a </span><span><a href="https://github.com/DarkNavySecurity/PoC/tree/main/CVE-2023-4863">proof-of-concept exploit</a></span><span> targeting Chrome (CVE-2023-4863).</span></p>
 
 
 <p><span>Whilst the Isosceles and Dark Navy posts explained the underlying memory corruption vulnerability in great detail, they were unable to solve another fascinating part of the puzzle: just how exactly do you land an exploit for this vulnerability in a one-shot, zero-click setup? As we&#39;ll soon see, the corruption primitive is very limited. Without access to the samples it was almost impossible to know.</span></p>
 
 <p><span>In mid-November, in collaboration with </span><span><a href="https://securitylab.amnesty.org/">Amnesty International Security Lab</a></span><span>, I was able to obtain a number of BLASTPASS </span><span><a href="https://en.wikipedia.org/wiki/PKPASS">PKPass</a></span><span> sample files as well as crash logs from failed exploit attempts.</span></p>
 
 <p><span>This blog post covers my analysis of those samples and the journey to figure out how one of NSO&#39;s recent zero-click iOS exploits really worked. For me that journey began by immediately taking three months of paternity leave, and resumed in March 2024 where this story begins:</span></p><h3 id="h.l3phtwrgqdig"><span>Setting the scene</span></h3>
 <p><span>For a detailed analysis of the root-cause of the WebP vulnerability and the primitive it yields, I recommend first reading the three blog posts I mentioned earlier (</span><span><a href="https://blog.isosceles.com/the-webp-0day/">Isosceles</a></span><span>, </span><span><a href="https://www.darknavy.org/blog/exploiting_the_libwebp_vulnerability_part_1/">Dark Navy 1</a></span><span>, </span><span><a href="https://www.darknavy.org/blog/exploiting_the_libwebp_vulnerability_part_2/">Dark Navy 2</a></span><span>.) I won&#39;t restate their analyses here (both because you should read their original work, and because it&#39;s quite complicated!) Instead I&#39;ll briefly discuss WebP and the corruption </span><span>primitive the vulnerability</span><span> yields.</span></p><h3 id="h.115gmx6di0dd"><span>WebP</span></h3>
 <p><span><a href="https://developers.google.com/speed/webp">WebP</a></span><span> is a relatively modern image file format, first released in 2010. In reality WebP is actually two completely distinct image formats: </span><span><a href="https://developers.google.com/speed/webp/docs/compression%23lossy_webp">a lossy format</a></span><span> based on the VP8 video codec and a separate </span><span><a href="https://developers.google.com/speed/webp/docs/compression%23lossless_webp">lossless format</a></span><span>. The two formats share nothing apart from both using a </span><span><a href="https://en.wikipedia.org/wiki/Resource_Interchange_File_Format">RIFF</a></span><span> container and the string </span><span>WEBP</span><span> for the first chunk name. From that point on (12 bytes into the file) they are completely different. The vulnerability is in the lossless format, with the RIFF chunk name </span><span>VP8L</span><span>.</span></p>
 
 <p><span>Lossless WebP makes extensive use of </span><span><a href="https://en.wikipedia.org/wiki/Huffman_coding">Huffman coding</a></span><span>; there are at least 10 huffman trees present in the BLASTPASS sample. In the file they&#39;re stored as </span><span><a href="https://en.wikipedia.org/wiki/Canonical_Huffman_code">canonical huffman trees</a></span><span>, meaning that only the code lengths are retained. At decompression time those lengths are converted directly into a two-level huffman decoding table, with the five largest tables all getting squeezed together into the same pre-allocated buffer. The (it turns out not quite) maximum size of these tables is pre-computed based on the number of symbols they encode. If you&#39;re up to this part and you&#39;re slightly lost, the other three blogposts referenced above explain this in detail.</span></p>
 
 <p><span>With control over the symbol lengths it&#39;s possible to define all sorts of strange trees, many of which aren&#39;t valid. The fundamental issue was that the WebP code only checked the validity of the tree </span><span>after</span><span> building the decoding table. But the pre-computed size of the decoding table was only correct for </span><span>valid</span><span> trees.</span></p>
 
 <p><span>As the Isosceles blog post points out, this means that a fundamental part of the vulnerability is that triggering the bug </span><span>is</span><span> detected, though after memory has been corrupted, and image parsing stops only a few lines of code later</span><span>. This presents another exploitation mystery: in a zero-click context, how do you exploit a bug where every time the issue is triggered it also stops parsing any attacker-controlled data?</span></p>
 
 <p><span>The second mystery involves the actual corruption primitive. The vulnerability will write a </span><span>HuffmanCode</span><span> structure at a known offset past the end of the huffman tables buffer:</span></p>
 
 <p><span>// Huffman lookup table entry</span></p>
 <p><span>typedef struct {</span></p>
 <p><span>  uint8_t bits;</span></p>
 <p><span>  uint16_t value;</span></p>
 <p><span>} HuffmanCode;</span></p>
 
 <p><span><a href="https://www.darknavy.org/blog/exploiting_the_libwebp_vulnerability_part_1/%23how-to-control-the-data-to-write">As DarkNavy point out</a></span><span>, whilst the </span><span>bits</span><span> and </span><span>value</span><span> fields are nominally attacker-controlled, in reality there isn&#39;t that much flexibility. The fifth huffman table (the one at the end of the preallocated buffer, part of which can get written </span><span>out-of-bounds</span><span>) only has </span><span>40</span><span> symbols, limiting </span><span>value</span><span> to a maximum value of </span><span>39</span><span> (</span><span>0x27</span><span>) and </span><span>bits</span><span> will be between </span><span>1</span><span> and </span><span>7</span><span> (for a second-level table entry). There&#39;s a padding byte between </span><span>bits</span><span> and </span><span>value</span><span> which makes the largest value that could be written out-of-bounds </span><span>0x00270007</span><span>. And it just so happens that that&#39;s exactly the value which the exploit does write — and they likely didn&#39;t have that much choice about it.</span></p>
 
 <p><span>There&#39;s also not much flexibility in the huffman table allocation size. The table allocation in the exploit is </span><span>12072</span><span> (</span><span>0x2F28</span><span>) bytes, which will get rounded up to fit within a </span><span>0x3000</span><span> byte libmalloc </span><span>small</span><span> region. The code lengths are chosen such that the overflow occurs like this:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgDhw37v8HaNAcUY9lTzT-ePEPn_stvb57BbFv0ktM5_XCGEvQD2Mego6iMH3bBO8EZgWOfhFhg-e5R1YoUquDFdVwBWX6QRHIcccAWJnWQXlxwSU44nDYIQF_MCldcENnaef5JPaCR1Nmam7NrnZD2yng0BPEfrIDnIfww-efdAECA5F4UaSDfGi1dSJY/s766/image10.png"><img alt="Memory layout diagram showing Huffman tables at offset 0x3000 and the structure of a Huffman lookup table entry at offset 0x3058." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgDhw37v8HaNAcUY9lTzT-ePEPn_stvb57BbFv0ktM5_XCGEvQD2Mego6iMH3bBO8EZgWOfhFhg-e5R1YoUquDFdVwBWX6QRHIcccAWJnWQXlxwSU44nDYIQF_MCldcENnaef5JPaCR1Nmam7NrnZD2yng0BPEfrIDnIfww-efdAECA5F4UaSDfGi1dSJY/s766/image10.png" title="Memory layout diagram showing Huffman tables at offset 0x3000 and the structure of a Huffman lookup table entry at offset 0x3058."/></a></span></p>
 
 <p><span>To summarize: The 32-bit value </span><span>0x270007</span><span> will be written </span><span>0x58</span><span> bytes past the end of a </span><span>0x3000</span><span> byte huffman table allocation. And then WebP parsing will fail, and the decoder will bail out.</span></p><h3 id="h.ow3137rwwm6g"><span>Déjà vu?</span></h3>
 <p><span>Long-term readers of the Project Zero blog might be experiencing a sense of déjà vu at this point... haven&#39;t I already written a blog post about an NSO zero-click iPhone zero day exploiting a vulnerability in a slightly obscure lossless compression format used in an image parsed from an iMessage attachment?</span></p>
 
 <p><span><a href="https://googleprojectzero.blogspot.com/2021/12/a-deep-dive-into-nso-zero-click.html">Indeed</a></span><span>.</span></p>
 
 <p><span>BLASTPASS has many similarities with </span><span><a href="https://en.wikipedia.org/wiki/FORCEDENTRY">FORCEDENTRY</a></span><span>, and my initial hunch (which turned out to be completely wrong) was that this exploit might take a similar approach to build a weird machine using some fancier WebP features. To that end I started out by writing a WebP parser to see what features were actually used.</span></p><h3 id="h.2q4vz1fpty3b"><span>Transformation</span></h3>
 <p><span>In a very similar fashion to </span><span><a href="https://en.wikipedia.org/wiki/JBIG2">JBIG2</a></span><span>, WebP also </span><span><a href="https://developers.google.com/speed/webp/docs/webp_lossless_bitstream_specification">supports</a></span><span> invertible transformations on the input pixel data:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEisPMddn7TKdOEgMlAvECAc_0pAKivdDJ6Zs0O-FmBK8MOiTFlpnf5SUTXiaHcK0EYE733CtDTMboqnyHpUNw-2FTMA606fQvta_MUm0TPwoY6GeZHctPb-MKo4U73mbXbF0XGAZG4UtB3iqTCW_sUFYvY7VAKxIQJQRc8ZsmE678can0zHE445bOnVVG8/s1964/image12.png"><img alt="Screenshot of WebP documentation explaining &#39;4 Transforms&#39; and their role in image compression." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEisPMddn7TKdOEgMlAvECAc_0pAKivdDJ6Zs0O-FmBK8MOiTFlpnf5SUTXiaHcK0EYE733CtDTMboqnyHpUNw-2FTMA606fQvta_MUm0TPwoY6GeZHctPb-MKo4U73mbXbF0XGAZG4UtB3iqTCW_sUFYvY7VAKxIQJQRc8ZsmE678can0zHE445bOnVVG8/s1200/image12.png" title="Screenshot of WebP documentation explaining &#39;4 Transforms&#39; and their role in image compression."/></a></span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjOaeJ5e_hL-BxqWZFAVyDb38AlNiW53Uf_67I9jiMTNvSRP8sJbF6GOZtxM587_jVZPDvL84Lu2P7D4HshHEwN5Ui3KBUMa7zmv8hh5bMvThElMj7-5k1lefL5siOGS1M2uu8lW-FjV-0ZQSUstBbbkETa10kFbWFE-65ZAb_S5Qpw-fuZvnQ2GusU33I/s1356/image3.png"><img alt="Screenshot of a table listing pixel prediction modes with corresponding formulas for calculating predicted values." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjOaeJ5e_hL-BxqWZFAVyDb38AlNiW53Uf_67I9jiMTNvSRP8sJbF6GOZtxM587_jVZPDvL84Lu2P7D4HshHEwN5Ui3KBUMa7zmv8hh5bMvThElMj7-5k1lefL5siOGS1M2uu8lW-FjV-0ZQSUstBbbkETa10kFbWFE-65ZAb_S5Qpw-fuZvnQ2GusU33I/s1200/image3.png" title="Screenshot of a table listing pixel prediction modes with corresponding formulas for calculating predicted values."/></a></span></p>
 
 <p><span>My initial theory was that the exploit might operate in a similar fashion to FORCEDENTRY and apply sequences of these transformations outside of the bounds of the image buffer to build a weird machine. But after implementing enough of the WebP format in python to parse every bit of the </span><span>VP8L</span><span> chunk it became pretty clear that it was only triggering the Huffman table overflow and nothing more. The VP8L chunk was only </span><span>1052</span><span> bytes, and pretty much all of it was the 10 Huffman tables needed to trigger the overflow.</span></p><h3 id="h.jkdp8pyrc6re"><span>What&#39;s in a pass?</span></h3>
 <p><span>Although BLASTPASS is often referred to as an exploit for &#34;the WebP vulnerability&#34;, the attackers don&#39;t actually just send a WebP file (even though that is supported in iMessage). They send a </span><span><a href="https://developer.apple.com/documentation/passkit_apple_pay_and_wallet">PassKit</a></span><span> PKPass file, which contains a WebP. There must be a reason for this. So let&#39;s step back and actually take a look at one of the sample files I received:</span></p>
 
 <p><span>171K sample.pkpass</span></p>
 
 <p><span>$ file sample.pkpass </span></p>
 <p><span>sample.pkpass: Zip archive data, at least v2.0 to extract, compression method=deflate</span></p>
 
 <p><span>There are five files inside the PKPass zip archive:</span></p>
 
 <p><span>60K  background.png</span></p>
 <p><span>5.5M logo.png</span></p>
 <p><span>175B manifest.json</span></p>
 <p><span>18B  pass.json</span></p>
 <p><span>3.3K signature</span></p>
 
 <p><span>The 5.5MB </span><span>logo.png</span><span> is the WebP image, just with a </span><span>.png</span><span> extension instead of </span><span>.webp</span><span>:</span></p>
 
 <p><span>$ file logo.png:</span></p>
 <p><span>logo.png:         RIFF (little-endian) data, Web/P image</span></p>
 
 <p><span>The closest thing to a specification for the PKPass format appears to be the </span><span><a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/PassKit_PG/Creating.html">Wallet Developer Guide</a></span><span>, and whilst it doesn&#39;t explicitly state that the </span><span>.png</span><span> files should actually be Portable Network Graphics images, that&#39;s presumably the intention. This is yet another parallel with FORCEDENTRY, where a similar trick was used to reach the PDF parser when attempting to parse a GIF.</span></p>
 
 <p><span>PKPass files require a valid signature which is contained in </span><span>manifest.json</span><span> and </span><span>signature</span><span>. The signature has a presumably fake name and more timestamps indicating that the PKPass is very likely being generated and signed on the fly for each exploit attempt.</span></p>
 
 <p><span>pass.json</span><span> is just this:</span></p>
 
 <p><span>{&#34;pass&#34;: &#34;PKpass&#34;}</span></p>
 
 <p><span>Finally </span><span>background.png</span><span>:</span></p>
 
 <p><span>$ file background.png </span></p>
 <p><span>background.png: TIFF image data, big-endian, direntries=15, height=16, bps=0, compression=deflate, PhotometricIntepretation=RGB, orientation=upper-left, width=48</span></p>
 
 <p><span>Curious. Another file with a misleading extension; this time a </span><span>TIFF</span><span> file with a </span><span>.png</span><span> extension. </span></p>
 
 <p><span>We&#39;ll return to this TIFF later in the analysis as it plays a critical role in the exploit flow, but for now we&#39;ll focus on the WebP, with one short diversion:</span></p><h3 id="h.cf35pgn7ecq3"><span>Blastdoor</span></h3>
 <p><span>So far I&#39;ve only mentioned the WebP vulnerability, but the Apple advisory I linked at the start of this post mentions two separate CVEs:</span></p>
 
 <p><span>The first, CVE-2023-41064 in ImageIO, is the WebP bug (though just to keep things confusing with a different CVE from the upstream WebP fix which is CVE-2023-4863 - they&#39;re the same vulnerability though).</span></p>
 
 <p><span>The second, CVE-2023-41061 in &#34;Wallet&#34;, is described in the Apple advisory as: &#34;</span><span>A maliciously crafted attachment may result in arbitrary code execution</span><span>&#34;.</span></p>
 
 <p><span>The </span><span><a href="https://blog.isosceles.com/the-webp-0day/">Isosceles blog post</a></span><span> hypothesises:</span></p>
 
 <p><span>&#34;</span><span>Citizen Lab called this attack &#34;BLASTPASS&#34;, since the attackers found a clever way to bypass the &#34;BlastDoor&#34; iMessage sandbox. We don&#39;t have the full technical details, but it looks like by bundling an image exploit in a PassKit attachment, the malicious image would be processed in a different, unsandboxed process. This corresponds to the first CVE that Apple released, CVE-2023-41061.</span><span>&#34;</span></p>
 
 <p><span>This theory makes sense — FORCEDENTRY had a similar trick where the </span><span><a href="https://googleprojectzero.blogspot.com/2022/03/forcedentry-sandbox-escape.html">JBIG2 bug was actually exploited inside </a></span><span><a href="https://googleprojectzero.blogspot.com/2022/03/forcedentry-sandbox-escape.html">IMTranscoderAgent</a></span><span> instead of the more restrictive sandbox of BlastDoor. But in all my experimentation, as well as all the in-the-wild crash logs I&#39;ve seen, this hypothesis doesn&#39;t seem to hold.</span></p>
 
 <p><span>The PKPass file and the images enclosed within </span><span>do</span><span> get parsed inside the BlastDoor sandbox and that&#39;s where the crashes occur or the payload executes — later on we&#39;ll also see evidence that the </span><span>NSExpression</span><span> payload which eventually gets evaluated expects to be running </span><span>inside</span><span> BlastDoor.</span></p>
 
 <p><span>My guess is that CVE-2023-41061 is more likely referring to the lax parsing of PKPasses which didn&#39;t reject images which weren&#39;t </span><span>png&#39;</span><span>s.</span></p>
 
 <p><span>In late 2024</span><span>, I received another set of in-the-wild crash logs including two which do in fact strongly indicate that there was also a path to hit the WebP vulnerability in the MobileSMS process, outside the BlastDoor sandbox! Interestingly, the timestamps indicate that these devices were targeted in November 2023, two months after the vulnerability was patched.</span></p>
 
 <p><span>In those cases the WebP code was reached inside the MobileSMS process via a </span><span>ChatKit</span><span> </span><span>CKPassPreviewMediaObject</span><span> created by a </span><span>CKAttachmentMessagePartChatItem</span><span>.</span></p><h3 id="h.le24xell6lgv"><span>What&#39;s in a WebP?</span></h3>
 <p><span>I mentioned that the </span><span>VP8L</span><span> chunk in the WebP file is only around 1KB. Yet in the file listing above the WebP file is 5.5MB! So what&#39;s in the rest of it? Expanding out my WebP parser we see that there&#39;s one more RIFF chunk:</span></p>
 
 <p><span>EXIF : 0x586bb8</span></p>
 <p><span>exif is Intel byte alignment</span></p>
 <p><span>EXIF has n_entries=1</span></p>
 <p><span>tag=8769 fmt=4 n_components=1 data=1a</span></p>
 <p><span>subIFD has n_entries=1</span></p>
 <p><span>tag=927c fmt=7 n_components=586b8c data=2c</span></p>
 
 <p><span>It&#39;s a (really really huge) </span><span><a href="https://en.wikipedia.org/wiki/Exif">EXIF</a></span><span> - the standard format which cameras use to store image metadata — stuff like the camera model, exposure time, f-stop etc.</span></p>
 
 <p><span>It&#39;s a tag-based format and pretty much all 5.5MB is inside one tag with the id </span><span>0x927c</span><span>. So what&#39;s that?</span></p>
 
 <p><span>Looking through an </span><span><a href="https://www.awaresystems.be/imaging/tiff/tifftags/privateifd/exif.html">online list of EXIF tags</a></span><span> just below the lens FocalLength tag and above the UserComment tag we spot </span><span>0x927c</span><span>:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi4qMYlckEAJZhphzfIDHw4kQg6htOmpV99VYzwChysKpCA9l6gNZriWUdWxws3xcVGIq7Hl3WNtBmNdXLQC6ezsQ6lPjdRHhv2z9LHCXhWPwTuSnxJGURaDEhBz_ZjjPLviIO3Y87lo3VHmTFyLhONCSE_RAWzZ6-iVm-Yub5AQ5Q5wo2K31SZBdvL83s/s1999/image4.png"><img alt="Screenshot of a table listing EXIF tag definitions. The table includes columns for tag number, tag name, and description. The row for tag number 0x927C with the tag name &#39;MakerNote&#39; is highlighted in red, with the description &#39;Manufacturer specific information&#39;." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi4qMYlckEAJZhphzfIDHw4kQg6htOmpV99VYzwChysKpCA9l6gNZriWUdWxws3xcVGIq7Hl3WNtBmNdXLQC6ezsQ6lPjdRHhv2z9LHCXhWPwTuSnxJGURaDEhBz_ZjjPLviIO3Y87lo3VHmTFyLhONCSE_RAWzZ6-iVm-Yub5AQ5Q5wo2K31SZBdvL83s/s1200/image4.png" title="Screenshot of a table listing EXIF tag definitions. The table includes columns for tag number, tag name, and description. The row for tag number 0x927C with the tag name &#39;MakerNote&#39; is highlighted in red, with the description &#39;Manufacturer specific information&#39;."/></a></span></p>
 
 <p><span>It&#39;s the very-vague-yet-fascinating sounding: &#34;</span><span>MakerNote - Manufacturer specific information.</span><span>&#34;</span></p>
 
 <p><span>Looking to </span><span><a href="https://en.wikipedia.org/wiki/Exif">Wikipedia for some clarification</a></span><span> on what that actually is, we learn that </span></p>
 
 <p><span>&#34;the &#34;MakerNote&#34; tag contains information normally in a proprietary binary format.&#34;</span></p>
 
 <p><span>Modifying the webp parser to now dump out the MakerNote tag we see:</span></p>
 
 <p><span>$ file sample.makernote </span></p>
 <p><span>sample.makernote: Apple binary property list</span></p>
 
 <p><span>Apple&#39;s chosen format for the &#34;proprietary binary format&#34; is binary plist!</span></p>
 
 <p><span>And indeed: looking through the ImageIO library in IDA there&#39;s a clear path between the WebP parser, the EXIF parser, the MakerNote parser and the binary plist parser.</span></p><h3 id="h.9tu54e9o1ow0"><span>unbplisting</span></h3>
 <p><span>I covered the binary plist format in </span><span><a href="https://googleprojectzero.blogspot.com/2023/10/an-analysis-of-an-in-the-wild-ios-safari-sandbox-escape.html">a previous blog post</a></span><span>. That was the second time I&#39;d had to analyse a large bplist. The first time (for the FORCEDENTRY sandbox escape) it was possible mostly by hand, just using the human-readable output of </span><span>plutil</span><span>. Last year, for the Safari sandbox escape analysis, the bplist was 437KB and I had to write a custom bplist parser to figure out what was going on. Keeping the exponential curve going this year the bplist was 10x larger again.</span></p>
 
 <p><span>In this case it&#39;s fairly clear that the bplist must be a heap groom - and at 5.5MB, presumably a fairly complicated one. So what&#39;s it doing?</span></p><h3 id="h.dwp3fpvl5otv"><span>Switching Views</span></h3>
 <p><span>I had a hunch that the bplist would use duplicate dictionary keys as a fundamental building block for the heap groom, but running my parser it didn&#39;t output any... until I realised that my tool stored the parsed dictionaries directly as python dictionaries before dumping them. Fixing the tools to instead keep lists of keys and values it became clear that there were duplicate keys. Lots of them:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhi8ixELdnlgPEAlry1qJUaZAL0gu_lmlCy2OFHIpWIe3Jdmc89ST1jaPfEyInzGSxxUEbtX5L0dk5d5Z9L1RPSpDS0FDG_PJtCfy-HLcQBMYHZNokkE1XEgizDmBr_5Sww7JxA7joYE7zI0fMbuUt-34d5pXHAHSplO9t7lhzRMk7NObBmdIaPGkEe4eY/s1999/image6.png"><img alt="Screenshot of code showing a series of nested dictionary creations / duplicate keys" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhi8ixELdnlgPEAlry1qJUaZAL0gu_lmlCy2OFHIpWIe3Jdmc89ST1jaPfEyInzGSxxUEbtX5L0dk5d5Z9L1RPSpDS0FDG_PJtCfy-HLcQBMYHZNokkE1XEgizDmBr_5Sww7JxA7joYE7zI0fMbuUt-34d5pXHAHSplO9t7lhzRMk7NObBmdIaPGkEe4eY/s1200/image6.png" title="Screenshot of code showing a series of nested dictionary creations / duplicate keys"/></a></span></p>
 
 <p><span>In the Safari exploit writeup I described how I used different visualisation techniques to try to explore the structure of the objects, looking for patterns I could use to simplify what was going on. In this case, modifying the parser to emit well-formed curly brackets and indentation then relying on </span><span><a href="https://code.visualstudio.com/">VS Code</a></span><span>&#39;s automatic code-folding proved to work well enough for browsing around and getting a feel for the structure of the groom object.</span></p>
 
 <p><span>Sometimes the right visualisation technique is sufficient to figure out what the exploit is trying to do. In this case, where the primitive is a heap-based buffer overflow, the groom will inevitably try to put two things next to each other in memory and I want to know &#34;what two things?&#34;</span></p>
 
 <p><span>But no matter how long I stared and scrolled, I couldn&#39;t figure anything out. Time to try something different.</span></p><h3 id="h.qsa5rb3wbgxp"><span>Instrumentation</span></h3>
 <p><span>I wrote a small helper to load the bplist using the same API as the </span><span>MakerNote</span><span> parser and ran it using the Mac Instruments app:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEioXK-ctrJxcKGIj-UEWZpLrFDR6z8L4jtEne1cJrcBpAEM_jYaHWn1NaQ_-DEAf7kZ8PSgrk1pzy11pe9TGfurgmHfFwW3MezoSrdZ_KQJzMUEIjkiL7mWt-gE-3XOiK1ooX7AibTNufcXkAjlWqS-x87ld2xLNm7sDygVVgduf_npeudyoA0645BDRuw/s1999/image1.png"><img alt="Screenshot of Instruments app showing memory allocation with detailed information for the top three categories: &#39;All Heap &amp; Anonymous...&#39;, &#39;CFString (store)&#39;, and &#39;Malloc 16.00 KiB&#39;" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEioXK-ctrJxcKGIj-UEWZpLrFDR6z8L4jtEne1cJrcBpAEM_jYaHWn1NaQ_-DEAf7kZ8PSgrk1pzy11pe9TGfurgmHfFwW3MezoSrdZ_KQJzMUEIjkiL7mWt-gE-3XOiK1ooX7AibTNufcXkAjlWqS-x87ld2xLNm7sDygVVgduf_npeudyoA0645BDRuw/s1200/image1.png" title="Screenshot of Instruments app showing memory allocation with detailed information for the top three categories: &#39;All Heap &amp; Anonymous...&#39;, &#39;CFString (store)&#39;, and &#39;Malloc 16.00 KiB&#39;"/></a></span></p>
 
 <p><span>Parsing the single 5.5MB bplist causes nearly half a million allocations, churning through nearly a gigabyte of memory. Just looking through this allocation summary it&#39;s clear there&#39;s lots of </span><span>CFString</span><span> and </span><span>CFData</span><span> objects, likely used for heap shaping. Looking further down the list there are other interesting numbers:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhTNContQj1sCDNIzAplyRVfRMR6y1vgjkGkRBbKXdlIrmiVV90kTNmxSvWwcv4iQ7Ju6W_bbrmqoh7k7UoTvytds40F1p7WUWhGmMtk8a5LfZuVNt7P1VjwZJ980-Xee42x_rNEK_HTmGSkPy8xucdhd0eyHj5XCcH3PwPfN5ZmzbNXR0hu_T6UNwZlbE/s1428/image11.png"><img alt="Memory allocation table showing &#39;All Heap &amp; Anonymous...&#39; using 990.66 MiB of total bytes, with 660.77 MiB being persistent." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhTNContQj1sCDNIzAplyRVfRMR6y1vgjkGkRBbKXdlIrmiVV90kTNmxSvWwcv4iQ7Ju6W_bbrmqoh7k7UoTvytds40F1p7WUWhGmMtk8a5LfZuVNt7P1VjwZJ980-Xee42x_rNEK_HTmGSkPy8xucdhd0eyHj5XCcH3PwPfN5ZmzbNXR0hu_T6UNwZlbE/s1200/image11.png" title="Memory allocation table showing &#39;All Heap &amp; Anonymous...&#39; using 990.66 MiB of total bytes, with 660.77 MiB being persistent."/></a></span></p>
 
 <p><span>The </span><span>20&#39;000</span><span> in the last line is far too round a number to be a coincidence. This number matches up with the number of </span><span>__NSDictionaryM</span><span> objects allocated:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgFVqxOaJc8pyHBEa74GIoOpG-Y7TbNOvBcaslTYe3e-sFEe7nW2GjN4YA0xlKhmd0FT8c1vCkY5OwWtGdsO_tGDic8CZC3jHHe9HKy33YMGRrdp_yyPUvdtOQkaL3kVTV1p8eZT_LzWsKoCSOZIFVd_t3zszVFhlQhYARImnbr7sKHO7n56fDyEKmQmGA/s1510/image7.png"><img alt="Table displaying memory usage broken down by allocation size, showing the number of allocations, the size of each allocation, and the total memory used for each size. In the middle of the image, there are 20000 __NSDictionaryM objects allocated." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgFVqxOaJc8pyHBEa74GIoOpG-Y7TbNOvBcaslTYe3e-sFEe7nW2GjN4YA0xlKhmd0FT8c1vCkY5OwWtGdsO_tGDic8CZC3jHHe9HKy33YMGRrdp_yyPUvdtOQkaL3kVTV1p8eZT_LzWsKoCSOZIFVd_t3zszVFhlQhYARImnbr7sKHO7n56fDyEKmQmGA/s1200/image7.png" title="Table displaying memory usage broken down by allocation size, showing the number of allocations, the size of each allocation, and the total memory used for each size. In the middle of the image, there are 20000 __NSDictionaryM objects allocated."/></a></span></p>
 
 <p><span>Finally, at the very bottom of the list there are two more allocation patterns which stand out:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiqhUsJFzltLPjA4xT4zUvWvbkRNrboNac_h7srw04M3PhAisiqgVw5EmdczdjaCP7sDwUwfqU1TR6d27MY0EzAEHOwGfWz6mNx2GJJmRyKEmY_JeV8Mvtzx41up9VSGRV3d9kYbKB4DZ8bNXkwQc0wCUR7BFU445qNnY2-euwBgJIu2p_-re5PXC7hEx8/s1622/image9.png"><img alt="Screenshot of a table listing memory allocations with details like size, count, and total bytes, highlighting two sets of very large allocations: eighty 1MB allocations and 44 4MB ones." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiqhUsJFzltLPjA4xT4zUvWvbkRNrboNac_h7srw04M3PhAisiqgVw5EmdczdjaCP7sDwUwfqU1TR6d27MY0EzAEHOwGfWz6mNx2GJJmRyKEmY_JeV8Mvtzx41up9VSGRV3d9kYbKB4DZ8bNXkwQc0wCUR7BFU445qNnY2-euwBgJIu2p_-re5PXC7hEx8/s1200/image9.png" title="Screenshot of a table listing memory allocations with details like size, count, and total bytes, highlighting two sets of very large allocations: eighty 1MB allocations and 44 4MB ones."/></a></span></p>
 
 <p><span>There are two sets of very large allocations: eighty 1MB allocations and 44 4MB ones.</span></p>
 
 <p><span>I modified my bplist tool again to dump out each unique string or data buffer, along with a count of how many times it was seen and its hash. Looking through the file listing there&#39;s a clear pattern:</span></p>
 <table><tbody><tr><td colspan="1" rowspan="1">
 <p><span>Object Size</span></p></td><td colspan="1" rowspan="1">
 <p><span>Count</span></p></td></tr><tr><td colspan="1" rowspan="1">
 <p><span>0x3FFFFF</span></p></td><td colspan="1" rowspan="1">
 <p><span>44</span></p></td></tr><tr><td colspan="1" rowspan="1">
 <p><span>0xFFFFF</span></p></td><td colspan="1" rowspan="1">
 <p><span>80</span></p></td></tr><tr><td colspan="1" rowspan="1">
 <p><span>0x3FFF</span></p></td><td colspan="1" rowspan="1">
 <p><span>20</span></p></td></tr><tr><td colspan="1" rowspan="1">
 <p><span>0x26A9</span></p></td><td colspan="1" rowspan="1">
 <p><span>24978</span></p></td></tr><tr><td colspan="1" rowspan="1">
 <p><span>0x2554</span></p></td><td colspan="1" rowspan="1">
 <p><span>44</span></p></td></tr><tr><td colspan="1" rowspan="1">
 <p><span>0x23FF</span></p></td><td colspan="1" rowspan="1">
 <p><span>5822</span></p></td></tr><tr><td colspan="1" rowspan="1">
 <p><span>0x22A9</span></p></td><td colspan="1" rowspan="1">
 <p><span>4</span></p></td></tr><tr><td colspan="1" rowspan="1">
 <p><span>0x1FFF</span></p></td><td colspan="1" rowspan="1">
 <p><span>2</span></p></td></tr><tr><td colspan="1" rowspan="1">
 <p><span>0x1EA9</span></p></td><td colspan="1" rowspan="1">
 <p><span>26</span></p></td></tr><tr><td colspan="1" rowspan="1">
 <p><span>0x1D54</span></p></td><td colspan="1" rowspan="1">
 <p><span>40</span></p></td></tr><tr><td colspan="1" rowspan="1">
 <p><span>0x17FF</span></p></td><td colspan="1" rowspan="1">
 <p><span>66</span></p></td></tr><tr><td colspan="1" rowspan="1">
 <p><span>0x13FF</span></p></td><td colspan="1" rowspan="1">
 <p><span>66</span></p></td></tr><tr><td colspan="1" rowspan="1">
 <p><span>0x3FF</span></p></td><td colspan="1" rowspan="1">
 <p><span>322</span></p></td></tr><tr><td colspan="1" rowspan="1">
 <p><span>0x3D7</span></p></td><td colspan="1" rowspan="1">
 <p><span>404</span></p></td></tr><tr><td colspan="1" rowspan="1">
 <p><span>0xF</span></p></td><td colspan="1" rowspan="1">
 <p><span>112882</span></p></td></tr><tr><td colspan="1" rowspan="1">
 <p><span>0x8</span></p></td><td colspan="1" rowspan="1">
 <p><span>3</span></p></td></tr></tbody></table>
 
 
 <p><span>There are a large number of allocations which fall just below a &#34;round&#34; number in hexadecimal: </span><span>0x3ff</span><span>, </span><span>0x13ff</span><span>, </span><span>0x17ff</span><span>, </span><span>0x1fff</span><span>, </span><span>0x23ff</span><span>, </span><span>0x3fff</span><span>... That heavily hints that they are sized to fall exactly within certain allocator size buckets.</span></p>
 
 <p><span>Almost all of the allocations are just filled with zeros or &#39;</span><span>A</span><span>&#39;s. But the 1MB one is quite different:</span></p>
 
 <p><span>$ hexdump -C 170ae757_80.bin | head -n 20</span></p>
 
 <p><span>00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span></p>
 <p><span>00000010  00 00 00 00 00 00 00 00  80 26 00 00 01 00 00 00  |.........&amp;......|</span></p>
 <p><span>00000020  1f 00 00 00 00 00 00 00  10 00 8b 56 02 00 00 00  |...........V....|</span></p>
 <p><span>00000030  b0 c3 31 16 02 00 00 00  60 e3 01 00 00 00 00 00  |..1.....`.......|</span></p>
 <p><span>00000040  20 ec 46 58 02 00 00 00  00 00 00 00 00 00 00 00  | .FX............|</span></p>
 <p><span>00000050  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span></p>
 <p><span>00000060  00 00 00 00 00 00 00 00  60 bf 31 16 02 00 00 00  |........`.1.....|</span></p>
 <p><span>00000070  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span></p>
 <p><span>*</span></p>
 <p><span>000004b0  00 00 00 00 00 00 00 00  10 c4 31 16 02 00 00 00  |..........1.....|</span></p>
 <p><span>000004c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span></p>
 <p><span>*</span></p>
 <p><span>000004e0  02 1c 00 00 01 00 00 00  00 00 00 00 00 00 00 00  |................|</span></p>
 <p><span>000004f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span></p>
 <p><span>00000500  00 00 00 00 00 00 00 00  70 80 33 16 02 00 00 00  |........p.3.....|</span></p>
 <p><span>00000510  b8 b5 e5 57 02 00 00 00  ff ff ff ff ff ff ff ff  |...W............|</span></p>
 <p><span>00000520  58 c4 31 16 02 00 00 00  00 00 00 00 00 00 00 00  |X.1.............|</span></p>
 <p><span>00000530  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span></p>
 <p><span>*</span></p>
 <p><span>00000550  50 75 2c 18 02 00 00 00  01 00 00 00 00 00 00 00  |Pu,.............|</span></p>
 
 
 <p><span>Further on in the hexdump of the 1MB object there&#39;s clearly an </span><span>NSExpression</span><span> payload - this payload is also visible just running </span><span>strings</span><span> on the WebP file. Matthias Frielingsdorf from iVerify gave a </span><span><a href="https://i.blackhat.com/Asia-24/Asia-24-Frielingsdorf-YouShallNotPassAnalysing.pdf">talk at BlackHat Asia with an initial analysis of this NSExpression payload</a></span><span>, we&#39;ll return to that at the end of this blog post.</span></p>
 
 <p><span>Equally striking (and visible in the hexdump above): there are clearly pointers in there. It&#39;s too early in the analysis to know whether this is a payload which gets rebased somehow, or whether there&#39;s a separate ASLR disclosure step.</span></p>
 
 <p><span>On a slightly higher level this hexdump looks a little bit like an Objective-C or C++ object, though some things are strange. Why are the first 24 bytes all zero? Why isn&#39;t there an isa pointer or vtable? It looks a bit like there are a number of integer fields before the pointers, but what are they? At this stage of the analysis, I had no idea.</span></p><h3 id="h.m4inyehexyvr"><span>Thinking dynamically</span></h3>
 <p><span>I had tried a </span><span>lot</span><span> to reproduce the exploit primitives on a real device; I built tooling to dynamically generate and sign legitimate PKPass files that I could send via iMessage to test devices and I could crash a lot, but I never seemed to get very far into the exploit - the iOS version range where the heap grooming works seems to be pretty small, and I didn&#39;t have an exact device and iOS version match to test on.</span></p>
 
 <p><span>Regardless of what I tried: sending the original exploits via iMessage, sending custom PKPasses with the trigger and groom, rendering the WebP directly in a test app or trying to use the PassKit APIs to render the PKPass file the best I could manage dynamically was to trigger a heap metadata integrity check failure, which I assumed was indicative of the exploit failing.</span></p>
 
 <p><span>(Amusingly, using the legitimate APIs to render the PKPass inside an app failed with an error that the PKPass file was malformed. And indeed, the exploit sample PKPass is malformed: it&#39;s missing multiple required files. But the &#34;secure&#34; PKPass BlastDoor parser entrypoint (</span><span>PKPassSecurePreviewContextCreateMessagesPreview</span><span>) is, in this regard at least, less strict and will attempt to render an incomplete and invalid PKPass).</span></p>
 
 <p><span>Though getting the whole PKPass parsed was proving tricky, with a bit of reversing it was possible to call the correct underlying CoreGraphics APIs to render the WebP and also get the EXIF/MakerNote parsed. By then setting a breakpoint when the huffman tables were allocated I had hoped it would be obvious what the overflow target was. But it was actually totally unclear what the following object was: (Here </span><span>X</span><span>3</span><span> points to the start of the huffman tables which are </span><span>0x3000</span><span> bytes large)</span></p>
 
 <p><span>(lldb) x/6xg $x3+0x3000</span></p>
 <p><span>0x112000000: 0x0000000111800000 0x0000000000000000</span></p>
 <p><span>0x112000010: 0x00000000001a1600 0x0000000000000004</span></p>
 <p><span>0x112000020: 0x0000000000000001 0x0000000000000019</span></p>
 
 <p><span>The first qword (</span><span>0x111800000</span><span>) is a valid pointer, but this is clearly not an Objective-C object, nor did it seem to look like any other recognizable object or have much to do with either the bplist or WebP. But running the tests a few times, there was a curious pattern:</span></p>
 
 <p><span>(lldb) x/6xg $x3+0x3000</span></p>
 <p><span>0x148000000: 0x0000000147800000 0x0000000000000000</span></p>
 <p><span>0x148000010: 0x000000000019c800 0x0000000000000004</span></p>
 <p><span>0x148000020: 0x0000000000000001 0x0000000000000019</span></p>
 
 <p><span>The huffman table is </span><span>0x2F28</span><span> bytes, which the allocator rounds up to </span><span>0x3000</span><span>. And in both of those test runs, adding the allocation size to the huffman table pointer yielded a suspiciously round number. There&#39;s no way that&#39;s a coincidence. Running a few more tests the </span><span>table+0x3000</span><span> pointer is always 8MB aligned. I remembered from some presentations on the iOS userspace allocator I&#39;d read that 8MB is a meaningful number. Here&#39;s </span><span><a href="https://www.synacktiv.com/ressources/Sthack_2018_Heapple_Pie.pdf">one from Synaktiv</a></span><span>:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgTLmTlzJ81OUix0D0YbwLxJHqxvWz9FoODHNMMlc2YXu7zIsXlnDlN3rLeYeZS89uMuNXWVyT21f6WweYNhi7T9rjYNI48bdaMdwu99QNv5W04XPk2zciSMmvnPr5WeixDG9UqD5feWIVoP8nx9Sq4_CJeASquS0cD3gvJvT992qTLTh7Ggp7CjaVC41k/s1999/image13.png"><img alt="Presentation slide from SynAckTiv explaining scalable zone memory allocation using Tiny, Small, and Large racks" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgTLmTlzJ81OUix0D0YbwLxJHqxvWz9FoODHNMMlc2YXu7zIsXlnDlN3rLeYeZS89uMuNXWVyT21f6WweYNhi7T9rjYNI48bdaMdwu99QNv5W04XPk2zciSMmvnPr5WeixDG9UqD5feWIVoP8nx9Sq4_CJeASquS0cD3gvJvT992qTLTh7Ggp7CjaVC41k/s1200/image13.png" title="Presentation slide from SynAckTiv explaining scalable zone memory allocation using Tiny, Small, and Large racks"/></a></span></p>
 
 <p><span>Or </span><span><a href="https://www.slideshare.net/AngelBoy1/macos-memory-allocator-libmalloc-exploitation%2352">this one from Angelboy</a></span><span>:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi93g-2hZd6CFI7vQ8H7FcV3FCyUlIQJ94eWD85k_8UmrLJHqjLF4tWkKjzQmQA2g3LdKts1IY9zovIt0c1Fhc40ZkqbMTmdV7IwHkkKK0AkVpzTML52EstSqcu4SLB9RcAoDl15qgGLucFzYpVjlM8v1LgoChwrrfiDBA6nxGgDgOy-S5nNpuKrSb46ak/s1670/image5.png"><img alt="Slide from Angelboy explaining the &#39;Small&#39; memory region in libmalloc, noting its size of 0x800000 and 16319 blocks, and showing a diagram of its memory layout and linked list structure." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi93g-2hZd6CFI7vQ8H7FcV3FCyUlIQJ94eWD85k_8UmrLJHqjLF4tWkKjzQmQA2g3LdKts1IY9zovIt0c1Fhc40ZkqbMTmdV7IwHkkKK0AkVpzTML52EstSqcu4SLB9RcAoDl15qgGLucFzYpVjlM8v1LgoChwrrfiDBA6nxGgDgOy-S5nNpuKrSb46ak/s1200/image5.png" title="Slide from Angelboy explaining the &#39;Small&#39; memory region in libmalloc, noting its size of 0x800000 and 16319 blocks, and showing a diagram of its memory layout and linked list structure."/></a></span></p>
 
 <p><span>8MB is the size of the iOS userspace default allocator&#39;s small rack regions. It looks like they might be trying to groom the allocator not to target application-specific data but allocator metadata. Time to dive into some libmalloc internals!</span></p><h3 id="h.ghgbtq9u1wm2"><span>libmalloc</span></h3>
 <p><span>I&#39;d suggest reading the two presentations linked above for a good overview of the iOS default userspace malloc implementation</span><span>. Libmalloc manages memory on four levels of abstraction. From largest to smallest those are: rack, magazine, region and block. The size split between the tiny, small and large racks depends on the platform. Almost all the relevant allocations for this exploit come from the small rack, so that&#39;s the one I&#39;ll focus on.</span></p>
 
 <p><span>Reading through the libmalloc source I noticed that the region trailer, whilst still called a trailer, has been now moved to the start of the region object. The small region manages memory in chunks of 8MB. That 8MB gets split up in to (for our purposes) three relevant parts: a header, an array of metadata words, then blocks of 512 bytes which form the allocations:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgCMp-bRPTYK_XPZAy21JujY_GaDKo20e3Jov0_Z4CD8xpL7AZpmYoH6BgC-m4bamxMvpIxz-mXXnKarp-HelkUvP_BSxEfrYGtI2ABj8x9k_C_X7sMG-H0kMXuWiGI7azIvlzyb7v4l3MnyE071j5pfoTktL0c4wg7L3ODkaZecnY29TdOPoDwAdE1T_A/s899/image2.png"><img alt="Diagram showing a memory layout with a small pink block on the left labeled with &#39;free flag bit&#39; and &#39;15 count bits&#39;, and dimensions &#39;0x28 bytes&#39;. Below it is a larger white block labeled &#39;512 bytes&#39;. On the right is a larger structure composed of three stacked blocks, colored green, red, and blue, with the entire structure labeled &#39;0x8200 bytes&#39; and &#39;8MB&#39;." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgCMp-bRPTYK_XPZAy21JujY_GaDKo20e3Jov0_Z4CD8xpL7AZpmYoH6BgC-m4bamxMvpIxz-mXXnKarp-HelkUvP_BSxEfrYGtI2ABj8x9k_C_X7sMG-H0kMXuWiGI7azIvlzyb7v4l3MnyE071j5pfoTktL0c4wg7L3ODkaZecnY29TdOPoDwAdE1T_A/s899/image2.png" title="Diagram showing a memory layout with a small pink block on the left labeled with &#39;free flag bit&#39; and &#39;15 count bits&#39;, and dimensions &#39;0x28 bytes&#39;. Below it is a larger white block labeled &#39;512 bytes&#39;. On the right is a larger structure composed of three stacked blocks, colored green, red, and blue, with the entire structure labeled &#39;0x8200 bytes&#39; and &#39;8MB&#39;."/></a></span></p>
 
 <p><span>The first 0x28 bytes are a header where the first two fields form a linked-list of small regions:</span></p>
 
 <p><span>typedef</span><span> </span><span>struct</span><span> </span><span>region_trailer</span><span> </span><span>{</span></p>
 <p><span>        </span><span>struct</span><span> </span><span>region_trailer</span><span> </span><span>*prev;</span></p>
 <p><span>        </span><span>struct</span><span> </span><span>region_trailer</span><span> </span><span>*next;</span></p>
 <p><span>        </span><span>unsigned</span><span> </span><span>bytes_used;</span></p>
 <p><span>        </span><span>unsigned</span><span> </span><span>objects_in_use;</span></p>
 <p><span>        </span><span>mag_index_t</span><span> </span><span>mag_index;</span></p>
 <p><span>        </span><span>volatile</span><span> </span><span>int32_t</span><span> </span><span>pinned_to_depot;</span></p>
 <p><span>        </span><span>bool</span><span> </span><span>recirc_suitable;</span></p>
 <p><span>        </span><span>rack_dispose_flags_t</span><span> </span><span>dispose_flags;</span></p>
 <p><span>}</span><span> </span><span>region_trailer_t;</span></p>
 
 <p><span>The small region manages memory in units of 512 bytes called blocks. On iOS allocations from the small region consist of contiguous runs of up to 31 blocks. Each block has an associated 16-bit metadata word called a small meta word, which itself is subdivided into a &#34;free&#34; flag in the most-significant bit, and a 15-bit count.</span></p>
 
 <p><span>To mark a contiguous run of blocks as in-use (belonging to an allocation) the first meta word has its free flags cleared and the count set to the number of blocks in the run. On </span><span>free</span><span>, </span><span>an allocation is first placed on a lookaside list for rapid reuse without freeing. But once an allocation really gets freed the allocator will attempt to greedily coalesce neighbouring chunks. While in-use runs can never exceed 31 blocks, free runs can grow to encompass the entire region.</span></p><h3 id="h.r67dy0s0nxnn"><span>The groom</span></h3>
 <p><span>Below you can see the state of the meta words array for the small region directly following the one containing the huffman table as its last allocation: </span></p>
 
 <p><span>(lldb) x/200wh 0x148000028</span></p>
 <p><span>0x148000028: </span><span>0x0019</span><span> 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000</span></p>
 <p><span>0x148000038: </span><span>0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000</span></p>
 <p><span>0x148000048: </span><span>0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000</span></p>
 <p><span>0x148000058: </span><span>0x0000</span><span> </span><span>0x0003 0x0000 0x0000</span><span> </span><span>0x0018 0x0000 0x0000 0x0000</span></p>
 <p><span>0x148000068: </span><span>0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000</span></p>
 <p><span>0x148000078: </span><span>0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000</span></p>
 <p><span>0x148000088: </span><span>0x0000 0x0000 0x0000 0x0000</span><span> </span><span>0x0003 0x0000 0x0000</span><span> </span><span>0x001c</span></p>
 <p><span>0x148000098: </span><span>0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000</span></p>
 <p><span>0x1480000a8: </span><span>0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000</span></p>
 <p><span>0x1480000b8: </span><span>0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000</span></p>
 <p><span>0x1480000c8: </span><span>0x0000 0x0000 0x0000</span><span> </span><span>0x001d 0x0000 0x0000 0x0000 0x0000</span></p>
 
 <p><span>With some simple maths we can convert indexes in the meta words array into their corresponding heap pointers. Doing that it&#39;s possible to dump the memory associated with the allocations shown above. The larger </span><span>0x19</span><span>, </span><span>0x18</span><span> and </span><span>0x1c</span><span> allocations all seem to be generic groom allocations, but the two </span><span>0x3</span><span> block allocations appear more interesting. The first one (with the first metadata word at </span><span>0x14800005a</span><span>, shown in yellow) is the </span><span>code_lengths</span><span> array which gets freed directly after the huffman table building fails. The blue </span><span>0x3</span><span> block run (with the first metadata word at </span><span>0x148000090</span><span>) is the backing buffer for a </span><span>CFSet</span><span> object from the MakerNote and contains object pointers.</span></p>
 
 <p><span>Recall that the corruption primitive will write the dword </span><span>0x270007</span><span> </span><span>0x58</span><span> bytes off the end of the </span><span>0x3000</span><span> allocation (and that allocation happens to sit directly in front of this small region). That corruption has the following effect (shown in bold):</span></p>
 
 <p><span>(lldb) x/200wh 0x148000028</span></p>
 <p><span>0x148000028: </span><span>0x0019 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000</span></p>
 <p><span>0x148000038: </span><span>0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000</span></p>
 <p><span>0x148000048: </span><span>0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000</span></p>
 <p><span>0x148000058: </span><span>0x0007</span><span> </span><span>0x0027</span><span> 0x0000 0x0000</span><span> </span><span>0x0018 0x0000 0x0000 0x0000</span></p>
 <p><span>0x148000068: </span><span>0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000</span></p>
 <p><span>0x148000078: </span><span>0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000</span></p>
 <p><span>0x148000088: </span><span>0x0000 0x0000 0x0000 0x0000</span><span> </span><span>0x0003 0x0000 0x0000</span><span> </span><span>0x001c</span></p>
 <p><span>0x148000098: </span><span>0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000</span></p>
 <p><span>0x1480000a8: </span><span>0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000</span></p>
 <p><span>0x1480000b8: </span><span>0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000</span></p>
 <p><span>0x1480000c8: </span><span>0x0000 0x0000 0x0000</span><span> </span><span>0x001d 0x0000 0x0000 0x0000 0x0000</span></p>
 
 <p><span>It&#39;s changed the size of an in-use allocation from </span><span>3</span><span> blocks to </span><span>39</span><span> (or from </span><span>1536</span><span> to </span><span>19968</span><span> bytes). I mentioned before that the maximum size of an in-use allocation is meant to be 31 blocks, but this doesn&#39;t seem to be checked in every single free path. If things don&#39;t quite work out, you&#39;ll hit a runtime check. But if things do work out you end up with a situation like this:</span></p>
 
 <p><span>(lldb) x/200wh 0x148000028</span></p>
 <p><span>0x148000028: </span><span>0x0019 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000</span></p>
 <p><span>0x148000038: </span><span>0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000</span></p>
 <p><span>0x148000048: </span><span>0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000</span></p>
 <p><span>0x148000058: </span><span>0x0007</span><span> </span><span>0x8027</span><span> 0x0000 0x0000</span><span> </span><span>0x0018 0x0000 0x0000 0x0000</span></p>
 <p><span>0x148000068: </span><span>0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000</span></p>
 <p><span>0x148000078: </span><span>0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000</span></p>
 <p><span>0x148000088: </span><span>0x0000 0x0000 0x0000 0x0000</span><span> </span><span>0x0003 0x0000 0x0000</span><span> </span><span>0x001c</span></p>
 <p><span>0x148000098: </span><span>0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 </span><span>0x8027</span></p>
 <p><span>0x1480000a8: </span><span>0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000</span></p>
 <p><span>0x1480000b8: </span><span>0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000</span></p>
 <p><span>0x1480000c8: </span><span>0x0000 0x0000 0x0000</span><span> </span><span>0x001d 0x0000 0x0000 0x0000 0x0000</span></p>
 
 <p><span>The yellow (</span><span>0x8027</span><span>) allocation now extends beyond its original three blocks and completely overlaps the following green (</span><span>0x18</span><span>) and blue (</span><span>0x3</span><span>) as well as the start of the purple (</span><span>0x1c</span><span>) allocation.</span></p>
 
 <p><span>But as soon as this corruption occurs WebP parsing fails and it&#39;s not going to make any other allocations. So what are they doing? How are they able to leverage these overlapping allocations? I was pretty stumped.</span></p>
 
 <p><span>One theory was that perhaps it was some internal ImageIO or BlastDoor specific object which reallocated the overlapping memory. Another theory was that perhaps the exploit had two parts; this first part which puts overlapping entries on the allocator freelist, then another file which is sent to exploit that? And maybe I was lacking that file? But then, why would there be that huge 1MB payload with NSExpressions in it? That didn&#39;t add up.</span></p><h3 id="h.swwxr4jh7qvs"><span>Puzzling pieces</span></h3>
 <p><span>As is so often the case, stepping back and not thinking about the problem for a while I realised that I&#39;d completely overlooked and forgotten something critical. Right at the very start of the analysis I had run </span><span>file</span><span> on all the files inside the PKPass and noted that </span><span>background.png</span><span> was actually not a </span><span>png</span><span> but a </span><span>TIFF</span><span>. I had then completely forgotten that. But now the solution seemed obvious: the reason to use a PKPass versus just a WebP is that the PKPass parser will render multiple images in sequence, and there must be something in the TIFF which reallocates the overlapping allocation with something useful.</span></p>
 
 <p><span><a href="http://www.libtiff.org/">Libtiff</a></span><span> comes with a suite of tools for parsing tiff files. </span><span>tiffdump</span><span> displays the headers and </span><span>EXIF</span><span> tags:</span></p>
 
 <p><span>$ tiffdump background-15.tiff </span></p>
 <p><span>background-15.tiff:</span></p>
 <p><span>Magic: 0x4d4d &lt;big-endian&gt; Version: 0x2a &lt;ClassicTIFF&gt;</span></p>
 <p><span>Directory 0: offset 68 (0x44) next 0 (0)</span></p>
 <p><span>ImageWidth (256) SHORT (3) 1&lt;48&gt;</span></p>
 <p><span>ImageLength (257) SHORT (3) 1&lt;16&gt;</span></p>
 <p><span>BitsPerSample (258) SHORT (3) 4&lt;8 8 8 8&gt;</span></p>
 <p><span>Compression (259) SHORT (3) 1&lt;8&gt;</span></p>
 <p><span>Photometric (262) SHORT (3) 1&lt;2&gt;</span></p>
 <p><span>StripOffsets (273) LONG (4) 1&lt;8&gt;</span></p>
 <p><span>Orientation (274) SHORT (3) 1&lt;1&gt;</span></p>
 <p><span>SamplesPerPixel (277) SHORT (3) 1&lt;4&gt;</span></p>
 <p><span>StripByteCounts (279) LONG (4) 1&lt;59&gt;</span></p>
 <p><span>PlanarConfig (284) SHORT (3) 1&lt;1&gt;</span></p>
 <p><span>ExtraSamples (338) SHORT (3) 1&lt;2&gt;</span></p>
 <p><span>700 (0x2bc) BYTE (1) 15347&lt;00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ...&gt;</span></p>
 <p><span>33723 (0x83bb) UNDEFINED (7) 15347&lt;00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ...&gt;</span></p>
 <p><span>34377 (0x8649) BYTE (1) 15347&lt;00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ...&gt;</span></p>
 <p><span>ICC Profile (34675) UNDEFINED (7) 15347&lt;00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ...&gt;</span></p>
 
 <p><span>The presence of the four 15KB buffers is notable, but they seemed to mostly just be zeros. Here&#39;s the output from </span><span>tiffinfo</span><span>:</span></p>
 
 <p><span>$ tiffinfo -c -j -d -s -z background-15.tiff </span></p>
 <p><span>=== TIFF directory 0 ===</span></p>
 <p><span>TIFF Directory at offset 0x44 (68)</span></p>
 <p><span>  Image Width: 48 Image Length: 16</span></p>
 <p><span>  Bits/Sample: 8</span></p>
 <p><span>  Compression Scheme: AdobeDeflate</span></p>
 <p><span>  Photometric Interpretation: RGB color</span></p>
 <p><span>  Extra Samples: 1&lt;unassoc-alpha&gt;</span></p>
 <p><span>  Orientation: row 0 top, col 0 lhs</span></p>
 <p><span>  Samples/Pixel: 4</span></p>
 <p><span>  Planar Configuration: single image plane</span></p>
 <p><span>  XMLPacket (XMP Metadata):</span></p>
 
 <p><span>  RichTIFFIPTC Data: &lt;present&gt;, 15347 bytes</span></p>
 <p><span>  Photoshop Data: &lt;present&gt;, 15347 bytes</span></p>
 <p><span>  ICC Profile: &lt;present&gt;, 15347 bytes</span></p>
 <p><span>  1 Strips:</span></p>
 <p><span>      0: [       8,       59]</span></p>
 <p><span>Strip 0:</span></p>
 <p><span> 00 00 00 00 00 00 00 00 84 13 00 00 01 00 00 00 01 00 00 00 00 00 00 00</span></p>
 <p><span> 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></p>
 <p><span> cd ab 34 12 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></p>
 <p><span> 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></p>
 <p><span> 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></p>
 <p><span> 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></p>
 <p><span> 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></p>
 <p><span> 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></p>
 <p><span>...</span></p>
 
 <p><span>This dumps the uncompressed TIFF strip buffer and this looks much more interesting! There&#39;s clearly some structure, though not a lot of it. Is this really enough to do something useful? It looks like there could be some sort of object, but I didn&#39;t recognise the structure, and had no idea how replacing an object with this would be useful. I explored two possibilities:</span></p><h4 id="h.w1yajpmi02ag"><span>1) Alpha blending:</span></h4>
 <p><span>This is actually the raw TIFF strip after decompression but before the rendering step which applies the </span><span><a href="https://en.wikipedia.org/wiki/Alpha_compositing">alpha</a></span><span>, so it was possible that this got rendered &#34;on top&#34; of another object. That seemed like a reasonable explanation for why the object seemed so sparse; perhaps the idea was to just &#34;move&#34; a pointer value. The first 16 bytes of the strip look like this:</span></p>
 
 <p><span>00 00 00 00 00 00 00 00 84 13 00 00 01 00 00 00</span></p>
 
 <p><span>which when viewed as two 64-bit values look like this:</span></p>
 
 <p><span>0x0000000000000000 0x0000000100001384</span></p>
 
 <p><span>It seemed sort-of plausible that rendering the </span><span>0x100001384</span><span> on top of another pointer might be a neat primitive, but there was something that didn&#39;t quite add up. This pointer-</span><span>ish</span><span> value is at the </span><span>start</span><span> of the strip buffer, so if the overlapping allocation got reallocated with this strip buffer </span><span>directly,</span><span> nothing interesting would happen, as the </span><span>overlapping</span><span> parts are </span><span>further</span><span> along. Maybe the overlapping buffer gets split up multiple times, but this was seeming less and less likely, and I couldn&#39;t reproduce this part of the exploit to actually observe what happened.</span></p><h4 id="h.xf2e3zlng30e"><span>2) This is an object:</span></h4>
 <p><span>The other theory I had was that this actually was an object. The 8 zero bytes at the start were certainly strange… </span><span>so then</span><span> what&#39;s the significance of the next 8 bytes?</span></p>
 
 <p><span>84 13 00 00 01 00 00 00</span></p>
 
 <p><span>I tried using </span><span>lldb</span><span>&#39;s </span><span>memory find</span><span> command to see if there were other instances of that exact byte sequence occurring in a test iOS app rendering the WebP then the TIFF using the CoreGraphics APIs:</span></p>
 
 <p><span>(lldb) memory find -e 0x100001384 -- 0x100000000 0x200000000</span></p>
 <p><span>data not found within the range.</span></p>
 
 <p><span>Nope, plus it was very, very slow.</span></p>
 
 <p><span>One thing I had noticed was that this byte sequence was similar to one near the start of the 1MB groom object:</span></p>
 
 <p><span>00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span></p>
 <p><span>00000010  00 00 00 00 00 00 00 00  </span><span>80 26 00 00 01 00 00 00</span><span>  |.........&amp;......|</span></p>
 <p><span>00000020  1f 00 00 00 00 00 00 00  10 00 8b 56 02 00 00 00  |...........V....|</span></p>
 <p><span>00000030  b0 c3 31 16 02 00 00 00  60 e3 01 00 00 00 00 00  |..1.....`.......|</span></p>
 
 <p><span>They&#39;re not identical, but it seemed a strange coincidence.</span></p>
 
 <p><span>I took a bunch of test app core dumps using </span><span>lldb</span><span>&#39;s </span><span>process save-core</span><span> command and wrote some simple code to search for similar-ish byte patterns. After some experimentation I managed to find something:</span></p>
 
 <p><span>1c7b2600  49 d2 e4 29 02 00 00 01  </span><span>84 13 00 00 02 00 00 00</span><span>  |I..)............|</span></p>
 <p><span>1c7b2610  42 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |B...............|</span></p>
 <p><span>1c7b2620  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span></p>
 <p><span>1c7b2630  c0 92 d6 83 02 00 00 00  00 93 d6 83 02 00 00 00  |................|</span></p>
 
 <p><span>Converting those coredump offsets into VM address and looking them up revealed:</span></p>
 
 <p><span>(lldb) x/10xg 0x121E47600</span></p>
 <p><span>0x121e47600: </span><span>0x0100000229e4d249</span><span> 0x0000000200001384 </span></p>
 <p><span>0x121e47610: 0x0000000000000042 0x0000000000000000</span></p>
 <p><span>0x121e47620: 0x0000000000000000 0x0000000000000000</span></p>
 
 <p><span>(lldb) image lookup --address </span><span>0x229e4d248</span></p>
 <p><span>      Address: CoreFoundation[0x00000001dceed248] (CoreFoundation.__DATA_DIRTY.__objc_data + 7800)</span></p>
 <p><span>      Summary: (void *)0x0000000229e4d0e0: __NSCFArray</span></p>
 
 <p><span>It&#39;s an </span><span>NSCFArray</span><span>, which is the Foundation (Objective-C) &#34;</span><span><a href="https://ridiculousfish.com/blog/posts/bridge.html">toll-free bridged</a></span><span>&#34; version of the Core Foundation (C) CFArray type! This was the hint that I was looking for to identify the significance of the TIFF and that 1MB groom object, which also contains a similar byte sequence. </span></p><h3 id="h.udq8imwbq2pa"><span>Cores and Foundations</span></h3>
 <p><span>Even though Apple hasn&#39;t updated the open-source version of CoreFoundation for almost a decade, the old source is still helpful. Here&#39;s what a CoreFoundation object looks like:</span></p>
 
 <p><span>/*</span><span> </span><span>All</span><span> </span><span>CF</span><span> </span><span>&#34;instances&#34;</span><span> </span><span>start</span><span> </span><span>with</span><span> </span><span>this</span><span> </span><span>structure.</span><span>  </span><span>Never</span><span> </span><span>refer</span><span> </span><span>to</span></p>
 <p><span> </span><span>*</span><span> </span><span>these</span><span> </span><span>fields</span><span> </span><span>directly</span><span> </span><span>--</span><span> </span><span>they</span><span> </span><span>are</span><span> </span><span>for</span><span> </span><span>CF&#39;s</span><span> </span><span>use</span><span> </span><span>and</span><span> </span><span>may</span><span> </span><span>be</span><span> </span><span>added</span></p>
 <p><span> </span><span>*</span><span> </span><span>to</span><span> </span><span>or</span><span> </span><span>removed</span><span> </span><span>or</span><span> </span><span>change</span><span> </span><span>format</span><span> </span><span>without</span><span> </span><span>warning.</span><span>  </span><span>Binary</span></p>
 <p><span> </span><span>*</span><span> </span><span>compatibility</span><span> </span><span>for</span><span> </span><span>uses</span><span> </span><span>of</span><span> </span><span>this</span><span> </span><span>struct</span><span> </span><span>is</span><span> </span><span>not</span><span> </span><span>guaranteed</span><span> </span><span>from</span></p>
 <p><span> </span><span>*</span><span> </span><span>release</span><span> </span><span>to</span><span> </span><span>release.</span></p>
 <p><span> </span><span>*/</span></p>
 <p><span>typedef</span><span> </span><span>struct</span><span> </span><span>__CFRuntimeBase</span><span> </span><span>{</span></p>
 <p><span>    </span><span>uintptr_t</span><span> </span><span>_cfisa;</span></p>
 <p><span>    </span><span>uint8_t</span><span> </span><span>_cfinfo[4];</span></p>
 <p><span>#if</span><span> </span><span>__LP64__</span></p>
 <p><span>    </span><span>uint32_t</span><span> </span><span>_rc;</span></p>
 <p><span>#endif</span></p>
 <p><span>}</span><span> </span><span>CFRuntimeBase;</span></p>
 
 <p><span>So the header is an Objective-C </span><span><a href="https://alwaysprocessing.blog/2023/01/19/objc-class-isa">isa</a></span><span> pointer followed by four bytes of </span><span>_cfinfo</span><span>, </span><span>followed by a reference count. Taking a closer look at the uses of </span><span>__cfinfo</span><span>:</span></p>
 
 <p><span>CF_INLINE</span><span> </span><span>CFTypeID</span><span> </span><span>__CFGenericTypeID_inline(const</span><span> </span><span>void</span><span> </span><span>*cf)</span><span> </span><span>{</span></p>
 <p><span>  </span><span>//</span><span> </span><span>yes,</span><span> </span><span>10</span><span> </span><span>bits</span><span> </span><span>masked</span><span> </span><span>off,</span><span> </span><span>though</span><span> </span><span>12</span><span> </span><span>bits</span><span> </span><span>are</span></p>
 <p><span>  </span><span>//</span><span> </span><span>there</span><span> </span><span>for</span><span> </span><span>the</span><span> </span><span>type</span><span> </span><span>field;</span><span> </span><span>__CFRuntimeClassTableSize</span><span> </span><span>is</span><span> </span><span>1024</span></p>
 <p><span>  </span><span>uint32_t</span><span> </span><span>*cfinfop</span><span> </span><span>=</span><span> </span><span>(uint32_t</span><span> </span><span>*)&amp;(((CFRuntimeBase</span><span> </span><span>*)cf)-&gt;_cfinfo);</span></p>
 <p><span>  </span><span>CFTypeID</span><span> </span><span>typeID</span><span> </span><span>=</span><span> </span><span>(*cfinfop</span><span> </span><span>&gt;&gt;</span><span> </span><span>8)</span><span> </span><span>&amp;</span><span> </span><span>0x03FF;</span><span> </span><span>//</span><span> </span><span>mask</span><span> </span><span>up</span><span> </span><span>to</span><span> </span><span>0x0FFF</span></p>
 <p><span>  </span><span>return</span><span> </span><span>typeID;</span></p>
 <p><span>}</span></p>
 
 <p><span>It seems that the second byte in </span><span>__cfinfo</span><span> is a type identifier. And indeed, running </span><span>expr (int) CFArrayGetTypeID()</span><span> in </span><span>lldb</span><span> prints: </span><span>19</span><span> (</span><span>0x13</span><span>) which matches up with both the object found in the coredump as well as the strange (or now not so strange) object in the TIFF strip buffer.</span></p><h3 id="h.rn1kanz6est3"><span>X steps forwards, Y steps back</span></h3>
 <p><span>Looking through more of the CoreFoundation code it seems that the object in the TIFF strip buffer is a </span><span>CFArray</span><span> with inline storage containing one element with the value </span><span>0x1234abcd</span><span>. It also seems that it&#39;s possible for CF objects to have NULL isa pointers, which explains why the first 8 bytes of the fake object are zero.</span></p>
 
 <p><span>This is interesting, but it still doesn&#39;t actually get us any closer to figuring out what the next step of the exploit actually is. If the </span><span>CFArray</span><span> is meant to overlap with something, then what? And what interesting side-effects could having an </span><span>CFArray</span><span> with only a single element with the value </span><span>0x1234abcd</span><span> possibly have?</span></p>
 
 <p><span>This seems like one step forward and two steps back, but there&#39;s something else which we can now figure out: what that 1MB groom object actually is. Let&#39;s take a look at the start of it again:</span></p>
 
 <p><span>00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span></p>
 <p><span>00000010  00 00 00 00 00 00 00 00  80 26 00 00 01 00 00 00  |.........&amp;......|</span></p>
 <p><span>00000020  1f 00 00 00 00 00 00 00  10 00 8b 56 02 00 00 00  |...........V....|</span></p>
 <p><span>00000030  b0 c3 31 16 02 00 00 00  48 e3 01 00 00 00 00 00  |..1.....H.......|</span></p>
 <p><span>00000040  20 ec 46 58 02 00 00 00  00 00 00 00 00 00 00 00  | .FX............|</span></p>
 <p><span>00000050  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span></p>
 <p><span>00000060  00 00 00 00 00 00 00 00  60 bf 31 16 02 00 00 00  |........`.1.....|</span></p>
 <p><span>00000070  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span></p>
 
 <p><span>It looks like another CF object, starting at </span><span>+0x10</span><span> in the buffer with the same NULL isa pointer, a reference count of </span><span>1</span><span> and a </span><span>__cfinfo</span><span> of </span><span>{0x80, 0x26, 0, 0}</span><span>. The type identifiers aren&#39;t actually fixed, they&#39;re allocated dynamically via calls to </span><span>_CFRuntimeRegisterClass</span><span> like this:</span></p>
 
 <p><span>CFTypeID</span><span> </span><span>CFArrayGetTypeID(void)</span><span> </span><span>{</span></p>
 <p><span>    </span><span>static</span><span> </span><span>dispatch_once_t</span><span> </span><span>initOnce;</span></p>
 <p><span>    </span><span>dispatch_once(&amp;initOnce,</span><span> </span><span>^{</span><span> </span><span>__kCFArrayTypeID</span><span> </span><span>=</span><span> </span><span>_CFRuntimeRegisterClass(&amp;__CFArrayClass);</span><span> </span><span>});</span></p>
 <p><span>    </span><span>return</span><span> </span><span>__kCFArrayTypeID;</span></p>
 <p><span>}</span></p>
 
 <p><span>The </span><span>CFTypeID</span><span>s</span><span> are really just indexes into the </span><span>__CFRuntimeClassTable</span><span> array, and even though the types are allocated dynamically the ordering seems sufficiently stable that the hardcoded type values in the exploit work. </span><span>0x26</span><span> is the </span><span>CFTypeID</span><span> for </span><span>CFReadStream</span><span>:</span></p>
 
 <p><span>struct</span><span> </span><span>_CFStream</span><span> </span><span>{</span></p>
 <p><span>    </span><span>CFRuntimeBase</span><span> </span><span>_cfBase;</span></p>
 <p><span>    </span><span>CFOptionFlags</span><span> </span><span>flags;</span></p>
 <p><span>    </span><span>CFErrorRef</span><span> </span><span>error;</span></p>
 <p><span>    </span><span>struct</span><span> </span><span>_CFStreamClient</span><span> </span><span>*client;</span></p>
 <p><span>    </span><span>void</span><span> </span><span>*info;</span></p>
 <p><span>    </span><span>const</span><span> </span><span>struct</span><span> </span><span>_CFStreamCallBacks</span><span> </span><span>*callBacks;</span></p>
 <p><span>    </span><span>CFLock_t</span><span> </span><span>streamLock;</span></p>
 <p><span>    </span><span>CFArrayRef</span><span> </span><span>previousRunloopsAndModes;</span></p>
 <p><span>    </span><span>dispatch_queue_t</span><span> </span><span>queue;</span></p>
 <p><span>};</span></p>
 
 <p><span>Looking through the </span><span>CFStream</span><span> code it seems to call various callback functions during object destruction — that seems like a very likely path towards code execution, though with some significant caveats:</span></p>
 
 <p><span>Caveat I: It&#39;s still unclear how an overlapping allocation in the small malloc region could lead to a </span><span>CFRelease</span><span> being called on this 1MB allocation.</span></p>
 
 <p><span>Caveat II: What about ASLR? There have been some tricks in the past targeting &#34;universal gadgets&#34; which work across multiple slides. Nemo also had </span><span><a href="http://www.phrack.org/issues/69/9.html">a neat objective-c trick</a></span><span> for defeating ASLR in the past, so it&#39;s plausible that there&#39;s something like that here.</span></p>
 
 <p><span>Caveat III: What about PAC? If it&#39;s a data-only attack then maybe PAC isn&#39;t an issue, but if they are trying to JOP they&#39;d need a trick beyond just an ASLR leak, as all forward control flow edges should be protected by PAC.</span></p><h3 id="h.w6e9d5pn9dq0"><span>Special Delivery</span></h3>
 <p><span>Around this time in my analysis </span><span><a href="https://x.com/helthydriver">Matthias Frielingsdorf</a></span><span> </span><span>offered me the use of an iPhone running 16.6, the same version as the targeted ITW victim. With Matthias&#39; vulnerable iPhone, I was able to use the </span><span><a href="https://ellekit.space/dopamine/">Dopamine</a></span><span> jailbreak to attach </span><span>lldb</span><span> to </span><span>MessagesBlastDoorService</span><span> and a</span><span>fter a few tries was able to reproduce the exploit right up to the </span><span>CFRelease</span><span> call on the fake </span><span>CFReadStream</span><span>, confirming that that part of my analysis was correct! </span></p>
 
 <p><span>Collecting a few crashes led, yet again, to even more questions...</span></p><h3 id="h.ie8yjj3vyb3y"><span>Caveat I:</span><span> </span><span>Mysterious Pointers</span></h3>
 
 <p><span>Similar to the analysis of the huffman tables, there was a clear pattern in the fake object pointers, which this time were even stranger than the huffman tables. The crash site was here:</span></p>
 
 <p><span>LDR</span><span>    </span><span>X8,</span><span> </span><span>[X19,#0x30]</span></p>
 <p><span>LDR</span><span>    </span><span>X8,</span><span> </span><span>[X8,#0x58]</span></p>
 
 <p><span>At this point </span><span>X19</span><span> points to the fake </span><span>CFReadStream</span><span> object, and collecting a few </span><span>X19</span><span> values there&#39;s a pretty clear pattern:</span></p>
 
 <p><span>0x000000075f000010</span></p>
 <p><span>0x0000000d4f000010</span></p>
 
 <p><span>The fake object is inside a 1MB heap allocation, but all those fake object addresses are always 16 bytes above a 16MB-aligned address. It seemed really strange to me to end up with a pointer 0x10 bytes past such a round number. What kind of construct would lead to the creation of such a pointer? Even though I did have a debugger attached to </span><span>MessagesBlastDoorService</span><span>, it wasn&#39;t a time-travel debugger, so figuring out the history of such a pointer was non-trivial. Using the same core dump analysis techniques I could see that the pointer which would end up in </span><span>X19</span><span> was also present in the backing buffer of the </span><span>CFSet</span><span> described earlier. But how did it get there?</span></p>
 
 <p><span>Having found the strange </span><span>CFArray</span><span> inside the TIFF I was heavily biased towards believing that this must have something to do with it, so I wrote some tooling to modify the fake </span><span>CFArray</span><span>&#39;s in the TIFF in the exploit. The theory was that by messing with that </span><span>CFArray</span><span>, I could cause a crash when it was used and figure out what was going on. But making minor changes to the strip buffer didn&#39;t seem to have any effect — the exploit still worked! Even replacing the entire strip buffer with </span><span>A</span><span>&#39;s didn&#39;t stop the exploit working... What&#39;s going on?</span></p><h3 id="h.du8xlqhnw8z7"><span>Stepping back</span></h3>
 <p><span>I had made a list of the primitives I thought might lead to the creation of such a strange looking pointer — first on the list was a partial pointer overwrite. But then why the </span><span>CFArray</span><span>? But now having shown that the </span><span>CFArray</span><span> can&#39;t be involved, it was time to go back to the list. And step back even further and make sure I&#39;d really looked at all of that TIFF...</span></p>
 
 <p><span>There were still those four other metadata buffers in the </span><span>tiffdump</span><span> output I&#39;d shown earlier:</span></p>
 
 <p><span>700 (0x2bc) BYTE (1) 15347&lt;00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ...&gt;</span></p>
 <p><span>33723 (0x83bb) UNDEFINED (7) 15347&lt;00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ...&gt;</span></p>
 <p><span>34377 (0x8649) BYTE (1) 15347&lt;00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ...&gt;</span></p>
 <p><span>ICC Profile (34675) UNDEFINED (7) 15347&lt;00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ...&gt;</span></p>
 
 <p><span>I&#39;d just dismissed them, but, maybe I shouldn&#39;t have done that? I had actually already dumped the full contents of each of those buffers and checked that there wasn&#39;t something else apart from the zeros. They were all zeros, except the third-to-last bytes which were 0x10, which I&#39;d considered completely uninteresting. Uninteresting, unless you wanted to partially overwrite the three least-significant bytes of a little-endian pointer value with 0x000010 that is!</span></p>
 
 <p><span>Let&#39;s look back at the SMALL metadata:</span></p>
 
 <p><span>0x148000058: </span><span>0x0007</span><span> </span><span>0x8027</span><span> 0x0000 0x0000</span><span> </span><span>0x0018 0x0000 0x0000 0x0000</span></p>
 <p><span>0x148000068: </span><span>0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000</span></p>
 <p><span>0x148000078: </span><span>0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000</span></p>
 <p><span>0x148000088: </span><span>0x0000 0x0000 0x0000 0x0000</span><span> </span><span>0x0003 0x0000 0x0000</span><span> </span><span>0x001c</span></p>
 <p><span>0x148000098: </span><span>0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 </span><span>0x8027</span></p>
 
 <p><span>Each of those four metadata buffers in the TIFF is </span><span>15347</span><span> bytes, which is </span><span>0x3bf3</span><span> — looked at another way that&#39;s </span><span>0x3c00</span><span> (the size rounded up to the next </span><span>0x200</span><span> block size), minus </span><span>5</span><span>, minus </span><span>8</span><span>.</span></p>
 
 <p><span>0x3c00</span><span> is exactly 30 </span><span>0x200</span><span> byte blocks. Each 16-bit word in the metadata array shown above corresponds to one </span><span>0x200</span><span> block, where the overlapping chunk in yellow starts at </span><span>0x14800005a</span><span>. Counting forwards 30 chunks means that the end of a </span><span>0x3c00</span><span> allocation overlaps perfectly with the end of the original blue three-chunk allocation:</span></p>
 
 <p><span>0x148000058: </span><span>0x0007</span><span> </span><span>0x8027</span><span> 0x0000 0x0000</span><span> </span><span>0x0018 0x0000 0x0000 0x0000</span></p>
 <p><span>0x148000068: </span><span>0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000</span></p>
 <p><span>0x148000078: </span><span>0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000</span></p>
 <p><span>0x148000088: </span><span>0x0000 0x0000 0x0000 0x0000</span><span> </span><span>0x0003 0x0000 0x0000</span><span> </span><span>0x001c</span></p>
 <p><span>0x148000098: </span><span>0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 </span><span>0x8027</span></p>
 
 <p><span>This has the effect of overwriting all but the last 16 bytes of the blue allocation with zeros, then overwriting the three least-significant bytes of the second-to-last pointer-sized value with </span><span>0x10 00 00</span><span>; which, if that memory happened to contain a pointer, has the effect of &#34;shifting&#34; that pointer down to the nearest 16MB boundary, then adding </span><span>0x10</span><span> bytes! (For those who saw my </span><span><a href="https://www.youtube.com/watch?v%3DZawX9I9MM6Y">2024 Offensivecon talk</a></span><span>, this was the missing link between the overlapping allocations and code execution I mentioned.)</span></p>
 
 
 <p><span>As mentioned earlier, that</span><span> blue allocation</span><span> starting with </span><span>0x0003</span><span> is the backing buffer of a </span><span>CFSet</span><span> object from the bplist inside the WebP MakerNote. The set is constructed in a very precise fashion such that the target pointer (the one to be rounded down) ends up as the second-to-last pointer in the backing buffer. The 1MB object is then also groomed such that it falls on a 16MB boundary below the object which the CFSet entry originally points to. Then when that </span><span>CFSet</span><span> is destructed it calls </span><span>CFRelease</span><span> on each object, causing the fake </span><span>CFReadStream</span><span> destructor to run.</span></p><h3 id="h.vdkjpva8e9lq"><span>Caveat II: ASLR</span></h3>
 <p><span>We&#39;ve looked at the whole flow from huffman table overflow to </span><span>CFRelease</span><span> being invoked on a fake </span><span>CFReadStream</span><span> — but there&#39;s still stuff missing. The second open question I discussed earlier was ASLR. I had theorised that maybe it used a trick like a universal gadget, but is that the case?</span></p>
 
 <p><span>In addition to the samples, I was also able to obtain a number of crash logs from failed exploit attempts where those samples were thrown, which meant I could figure out the ASLR slide of the </span><span>MessagesBlastDoorService</span><span> when the exploit failed. In combination with the target device and exact OS build (also contained in the crash log) I could then obtain the matching </span><span>dyld_shared_cache</span><span>, subtract the runtime ASLR slide from a bunch of the pointer-looking things in the 1MB object and take a look at them. </span></p>
 
 <p><span>The simple answer is:</span><span> the 1MB object contains a large number of hardcoded, pre-slid, valid pointers. There&#39;s no weird machine, tricks or universal gadget here. By the time the PKPass is built and sent by the attackers they already know both the target device type and build as well as the runtime ASLR slide of the </span><span>MessagesBlastDoorService</span><span>...</span></p>
 
 <p><span>Based on </span><span><a href="https://iverify.io/post/clipping-wings-our-analysis-of-a-pegasus-spyware-sample">analysis by iVerify</a></span><span>,</span><span> as well as analysis of </span><span><a href="https://citizenlab.ca/2023/04/nso-groups-pegasus-spyware-returns-in-2022/">earlier exploit chains published by Citizen Lab</a></span><span>, my current working theory is that the large amount of HomeKit traffic seen in those cases is likely a separate ASLR/memory disclosure exploit.</span></p><h3 id="h.pybpzzcf990c"><span>Caveat III: Pointer Authentication</span></h3>
 <p><span>In the years since PAC was introduced we&#39;ve seen a whole spectrum of interesting ways to either defeat, or just avoid, PAC. So what did these attackers do? To understand that let&#39;s follow the </span><span>CFReadStream</span><span> destruction code closely. (All these code snippets are from the most recently available version of CF from 2015, but the code doesn&#39;t seem to have changed much.)</span></p>
 
 <p><span>Here&#39;s the definition of the </span><span>CFReadStream</span><span>:</span></p>
 
 <p><span>static</span><span> </span><span>const</span><span> </span><span>CFRuntimeClass</span><span> </span><span>__CFReadStreamClass</span><span> </span><span>=</span><span> </span><span>{</span></p>
 <p><span>    </span><span>0</span><span>,</span></p>
 <p><span>    </span><span>&#34;CFReadStream&#34;</span><span>,</span></p>
 <p><span>    </span><span>NULL</span><span>,</span><span>      </span><span>// init</span></p>
 <p><span>    </span><span>NULL</span><span>,</span><span>      </span><span>// copy</span></p>
 <p><span>    </span><span>__CFStreamDeallocate,</span></p>
 <p><span>    </span><span>NULL</span><span>,</span></p>
 <p><span>    </span><span>NULL</span><span>,</span></p>
 <p><span>    </span><span>NULL</span><span>,</span><span>      </span><span>// copyHumanDesc</span></p>
 <p><span>    </span><span>__CFStreamCopyDescription</span></p>
 <p><span>};</span></p>
 
 <p><span>When a </span><span>CFReadStream</span><span> is passed to </span><span>CFRelease</span><span>, it will call </span><span>__CFStreamDeallocate</span><span>:</span></p>
 
 <p><span>static</span><span> </span><span>void</span><span> </span><span>__CFStreamDeallocate(CFTypeRef</span><span> </span><span>cf)</span><span> </span><span>{</span></p>
 <p><span>  </span><span>struct</span><span> </span><span>_CFStream</span><span> </span><span>*stream</span><span> </span><span>=</span><span> </span><span>(</span><span>struct</span><span> </span><span>_CFStream</span><span> </span><span>*)cf;</span></p>
 <p><span>  </span><span>const</span><span> </span><span>struct</span><span> </span><span>_CFStreamCallBacks</span><span> </span><span>*cb</span><span> </span><span>=</span></p>
 <p><span>    </span><span>_CFStreamGetCallBackPtr(stream);</span></p>
 <p><span>  </span><span>CFAllocatorRef</span><span> </span><span>alloc</span><span> </span><span>=</span><span> </span><span>CFGetAllocator(stream);</span></p>
 <p><span>  </span><span>_CFStreamClose(stream);</span></p>
 
 <p><span>_CFStreamGetCallBackPtr</span><span> just returns the </span><span>CFStream</span><span>&#39;s </span><span>callBacks</span><span> field:</span></p>
 
 <p><span>CF_INLINE</span><span> </span><span>const</span><span> </span><span>struct</span><span> </span><span>_CFStreamCallBacks</span><span> </span><span>*_CFStreamGetCallBackPtr(</span><span>struct</span><span> </span><span>_CFStream</span><span> </span><span>*stream)</span><span> </span><span>{</span></p>
 <p><span>    </span><span>return</span><span> </span><span>stream-&gt;callBacks;</span></p>
 <p><span>}</span></p>
 
 <p><span>Here&#39;s </span><span>_CFStreamClose</span><span>:</span></p>
 
 <p><span>CF_PRIVATE</span><span> </span><span>void</span><span> </span><span>_CFStreamClose(</span><span>struct</span><span> </span><span>_CFStream</span><span> </span><span>*stream)</span><span> </span><span>{</span></p>
 <p><span>  </span><span>CFStreamStatus</span><span> </span><span>status</span><span> </span><span>=</span><span> </span><span>_CFStreamGetStatus(stream);</span></p>
 <p><span>  </span><span>const</span><span> </span><span>struct</span><span> </span><span>_CFStreamCallBacks</span><span> </span><span>*cb</span><span> </span><span>=</span></p>
 <p><span>    </span><span>_CFStreamGetCallBackPtr(stream);</span></p>
 <p><span>  </span><span>if</span><span> </span><span>(status</span><span> </span><span>==</span><span> </span><span>kCFStreamStatusNotOpen</span><span> </span><span>||</span><span> </span></p>
 <p><span>      </span><span>status</span><span> </span><span>==</span><span> </span><span>kCFStreamStatusClosed</span><span> </span><span>||</span></p>
 <p><span>       </span><span>(status</span><span> </span><span>==</span><span> </span><span>kCFStreamStatusError</span><span> </span><span>&amp;&amp;</span></p>
 <p><span>        </span><span>__CFBitIsSet(stream-&gt;flags,</span><span> </span><span>HAVE_CLOSED)</span></p>
 <p><span>      </span><span>))</span></p>
 <p><span>  </span><span>{</span></p>
 <p><span>    </span><span>// Stream is not open from the client&#39;s perspective;</span></p>
 <p><span>    </span><span>// do not callout and do not update our status to &#34;closed&#34;</span></p>
 <p><span>    </span><span>return</span><span>;</span></p>
 <p><span>  </span><span>}</span></p>
 <p><span>  </span><span>if</span><span> </span><span>(!</span><span> </span><span>__CFBitIsSet(stream-&gt;flags,</span><span> </span><span>HAVE_CLOSED))</span><span> </span><span>{</span></p>
 <p><span>        </span><span>__CFBitSet(stream-&gt;flags,</span><span> </span><span>HAVE_CLOSED);</span></p>
 <p><span>        </span><span>__CFBitSet(stream-&gt;flags,</span><span> </span><span>CALLING_CLIENT);</span></p>
 <p><span>    </span><span>if</span><span> </span><span>(cb-&gt;close)</span><span> </span><span>{</span></p>
 <p><span>      </span><span>cb-&gt;close(stream,</span><span> </span><span>_CFStreamGetInfoPointer(stream));</span></p>
 <p><span>    </span><span>}</span></p>
 
 
 
 <p><span>_CFStreamGetStatus</span><span> extracts the </span><span>status</span><span> bitfield from the </span><span>flags</span><span> field:</span></p>
 
 <p><span>#define</span><span> </span><span>__CFStreamGetStatus(x)</span><span> </span><span>__CFBitfieldGetValue((x)-&gt;flags,</span><span> </span><span>MAX_STATUS_CODE_BIT,</span><span> </span><span>MIN_STATUS_CODE_BIT)</span></p>
 
 <p><span>Looking at the 1MB object again the flags field is the first non-base field:</span></p>
 
 <p><span>00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span></p>
 <p><span>00000010  00 00 00 00 00 00 00 00  80 26 00 00 01 00 00 00  |.........&amp;......|</span></p>
 <p><span>00000020  </span><span>1f 00 00 00</span><span> 00 00 00 00  10 00 8b 56 02 00 00 00  |...........V....|</span></p>
 <p><span>00000030  b0 c3 31 16 02 00 00 00  48 e3 01 00 00 00 00 00  |..1.....H.......|</span></p>
 <p><span>00000040  20 ec 46 58 02 00 00 00  00 00 00 00 00 00 00 00  | .FX............|</span></p>
 <p><span>00000050  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span></p>
 <p><span>00000060  00 00 00 00 00 00 00 00  60 bf 31 16 02 00 00 00  |........`.1.....|</span></p>
 <p><span>00000070  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span></p>
 
 <p><span>That gives a status code of </span><span>0x1f</span><span> with all the other flags bits clear. This gets through the two conditional branches to reach this close callback call:</span></p>
 
 
 <p><span>  </span><span>if</span><span> </span><span>(cb-&gt;close)</span><span> </span><span>{</span></p>
 <p><span>    </span><span>cb-&gt;close(stream,</span><span> </span><span>_CFStreamGetInfoPointer(stream));</span></p>
 <p><span>  </span><span>}</span></p>
 
 
 <p><span>At this point we need to switch to looking at the assembly to see what&#39;s really happening:</span></p>
 
 <p><span>__CFStreamClose</span></p>
 
 <p><span>var_30=</span><span> </span><span>-0x30</span></p>
 <p><span>var_20=</span><span> </span><span>-0x20</span></p>
 <p><span>var_10=</span><span> </span><span>-0x10</span></p>
 <p><span>var_s0=</span><span>  </span><span>0</span></p>
 
 <p><span>PACIBSP</span></p>
 <p><span>STP</span><span>             </span><span>X24,</span><span> </span><span>X23,</span><span> </span><span>[SP,#-0x10+var_30]!</span></p>
 <p><span>STP</span><span>             </span><span>X22,</span><span> </span><span>X21,</span><span> </span><span>[SP,#0x30+var_20]</span></p>
 <p><span>STP</span><span>             </span><span>X20,</span><span> </span><span>X19,</span><span> </span><span>[SP,#0x30+var_10]</span></p>
 <p><span>STP</span><span>             </span><span>X29,</span><span> </span><span>X30,</span><span> </span><span>[SP,#0x30+var_s0]</span></p>
 <p><span>ADD</span><span>             </span><span>X29,</span><span> </span><span>SP,</span><span> </span><span>#0x30</span></p>
 <p><span>MOV</span><span>             </span><span>X19,</span><span> </span><span>X0</span></p>
 <p><span>BL</span><span>              </span><span>__CFStreamGetStatus</span></p>
 <p><span>CBZ</span><span>             </span><span>X0,</span><span> </span><span>loc_187076958</span></p>
 
 <p><span>The fake </span><span>CFReadStream</span><span> is the first argument to this function, so passed in the </span><span>X0</span><span> register. It&#39;s then stored into </span><span>X19</span><span> so it survives the call to </span><span>__CFStreamGetStatus</span><span>.</span></p>
 
 <p><span>Skipping ahead past the flag checks we reach the callback callsite (this is also the crash site seen earlier):</span></p>
 
 <p><span>LDR</span><span>             </span><span>X8,</span><span> </span><span>[X19,#0x30]</span></p>
 <p><span>...</span></p>
 <p><span>LDR</span><span>             </span><span>X8,</span><span> </span><span>[X8,#0x58]</span></p>
 <p><span>CBZ</span><span>             </span><span>X8,</span><span> </span><span>loc_187076758</span></p>
 <p><span>LDR</span><span>             </span><span>X1,</span><span> </span><span>[X19,#0x28]</span></p>
 <p><span>MOV</span><span>             </span><span>X0,</span><span> </span><span>X19</span></p>
 <p><span>BLRAAZ</span><span>          </span><span>X8</span></p>
 
 <p><span>Let&#39;s walk through each instruction in turn there:</span></p>
 
 <p><span>First it loads the 64-bit value from </span><span>X19+0x30</span><span> into </span><span>X8</span><span>:</span></p>
 
 <p><span>LDR</span><span>             </span><span>X8,</span><span> </span><span>[X19,#0x30]</span></p>
 
 <p><span>Looking at the hexdump of the 1MB object above this will load the value </span><span>0x25846ec20</span><span>.</span></p>
 
 <p><span>From the crash reports we know the runtime ASLR slide of the </span><span>MessagesBlastDoorService</span><span> when this exploit was thrown was </span><span>0x3A8D0000</span><span>, so subtracting that we can figure out where in the shared cache this pointer should point:</span></p>
 
 <p><span>0x25846ec20-0x3A8D0000=0x21DB9EC20</span></p>
 
 <p><span>It points into the </span><span>__const</span><span> segment of the </span><span>TextToSpeechMauiSupport</span><span> library in the shared cache:</span></p>
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEisVBydDqsc93nYCwXZuJdCfA16RTdCOLAgDG0jBVQ1_qAmFpkdYPTzqHv4W69SbzLVBkNd9lgBoy8m3EWOfwDpS9EKDxwWt35m1eJnpER6E2UxaG3e8tBYdBwxA7bHvMuvUzH2zRNYj-C1HfRQHrOAI5qWHBVm9E4XYMWV8q-Wu0qk0j4-hEyYMEGxuWc/s1999/image14.png"><img alt="Assembly code snippet with the memory address 000000021DB9EC20 highlighted, followed by DataSectionWriter function definitions." src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEisVBydDqsc93nYCwXZuJdCfA16RTdCOLAgDG0jBVQ1_qAmFpkdYPTzqHv4W69SbzLVBkNd9lgBoy8m3EWOfwDpS9EKDxwWt35m1eJnpER6E2UxaG3e8tBYdBwxA7bHvMuvUzH2zRNYj-C1HfRQHrOAI5qWHBVm9E4XYMWV8q-Wu0qk0j4-hEyYMEGxuWc/s1200/image14.png" title="Assembly code snippet with the memory address 000000021DB9EC20 highlighted, followed by DataSectionWriter function definitions."/></a></span></p>
 
 <p><span>The next instruction adds </span><span>0x58</span><span> to that TextToSpeechMauiSupport pointer and reads a 64-bit value from there:</span></p>
 
 <p><span>LDR</span><span>             </span><span>X8,</span><span> </span><span>[X8,#0x58]</span><span> </span><span>//</span><span> </span><span>x8</span><span> </span><span>:=</span><span> </span><span>[0x21DB9EC20+0x58]</span></p>
 
 <p><span>This loads the pointer to the function </span><span>_DataSectionWriter_CommitDataBlock</span><span> from </span><span>0x21DB9EC78</span><span>.</span></p>
 
 <p><span>IDA is simplifying something for us here: the function pointer loaded there is actually signed with the </span><span><a href="https://googleprojectzero.blogspot.com/2019/02/examining-pointer-authentication-on.html">A-family instruction key</a></span><span><a href="https://googleprojectzero.blogspot.com/2019/02/examining-pointer-authentication-on.html"> with a zero context</a></span><span>. This signing happens transparently (either during load or when the page is faulted in).</span></p>
 
 <p><span>The remaining four instructions then check that the pointer wasn&#39;t </span><span>NULL</span><span>, load </span><span>X1</span><span> from offset </span><span>+0x28</span><span> in the fake 1MB object, move the pointer to the fake object back into </span><span>X0</span><span> and call the PAC&#39;ed </span><span>_DataSectionWriter_CommitDataBlock</span><span> function pointer via </span><span>BLRAAZ</span><span>:</span></p>
 
 <p><span>CBZ</span><span>             </span><span>X8,</span><span> </span><span>loc_187076758</span></p>
 <p><span>LDR</span><span>             </span><span>X1,</span><span> </span><span>[X19,#0x28]</span></p>
 <p><span>MOV</span><span>             </span><span>X0,</span><span> </span><span>X19</span></p>
 <p><span>BLRAAZ</span><span>          </span><span>X8</span></p>
 <h3 id="h.85z2ks5ykaev"><span>Callback-Oriented Programming</span></h3>
 <p><span>A well-known attack against PAC is to swap two valid, PAC&#39;ed pointers which are signed in the same way but point to different places (e.g. swapping two function pointers with different semantics, allowing you to exploit those semantic differences).</span></p>
 
 <p><span>Since a large number of PAC-protected pointers are signed with the A-family instruction key with a zero-context value, there are a large number of pointers to choose from. &#34;Just&#34; having an ASLR defeat shouldn&#39;t be enough to achieve this though; surely you&#39;d need to disclose the actual PAC&#39;ed pointer value? But that&#39;s not what happened above.</span></p>
 
 <p><span>Notice that the </span><span>CFStream</span><span> objects don&#39;t directly contain the callback function pointers — there&#39;s an extra level of indirection. The </span><span>CFStream</span><span> object contains a pointer </span><span>to</span><span> a callback structure, and </span><span>that</span><span> structure has the PAC&#39;d function pointers. And crucially: that first pointer, the one </span><span>to</span><span> the callbacks structure, isn&#39;t protected by PAC. This means that the attackers can freely swap pointers to callback structures, operating one-level removed from the function pointers.</span></p>
 
 <p><span>This might seem like a severe constraint, but the dyld_shared_cache is vast and there are easily enough pre-existing callback structures to build a &#34;callback-oriented JOP&#34; chain, chaining together unsigned pointers to signed function pointers.</span></p>
 
 <p><span>The initial portion of the payload is a large callback-oriented JOP chain which is used to bootstrap the evaluation of the next payload stage, a large NSExpression.</span></p><h3 id="h.x0b2urrhmfz4"><span>Similarities</span></h3>
 <p><span>There are a number of similarities between this exploit chain and PWNYOURHOME, an earlier exploit also attributed by CitizenLab to NSO, </span><span><a href="https://citizenlab.ca/2023/04/nso-groups-pegasus-spyware-returns-in-2022/">described in this blog post in April 2023</a></span><span>.</span></p>
 
 <p><span>That chain also had an initial stage targeting HomeKit, followed by a stage targeting </span><span>MessagesBlastDoorService</span><span> and also involving a </span><span>MakerNote</span><span> object — the Citizen Lab post claims that at the time the </span><span>MakerNote</span><span> was inside a PNG file. My guess would be that that PNG was being used as the delivery mechanism for the </span><span>MakerNote</span><span> bplist heap grooming primitives discussed in this post.</span></p>
 
 <p><span>Based on Citizen Lab&#39;s description it also seems like PWNYOURHOME was leveraging a similar callback-oriented JOP technique, and it seems likely that there was also a HomeKit-based ASLR disclosure. The PWNYOURHOME post has a couple of extra details around a minor fix which Apple made, preventing parsing of &#34;</span><span>certain HomeKit messages unless they arrive from a plausible source.</span><span>&#34; But there still aren&#39;t enough details to figure out the underlying vulnerability or primitive. It seems likely to me that the same issue, or a variant thereof was still in use in BLASTPASS.</span></p><h3 id="h.x3s02rsriugj"><span>Key material</span></h3>
 <p><span>Matthias from iVerify presented an </span><span><a href="https://i.blackhat.com/Asia-24/Asia-24-Frielingsdorf-YouShallNotPassAnalysing.pdf">initial analysis of the NSExpression payload at BlackHat Asia</a></span><span> in April 2024. In early July 2024, Matthias and I took a closer look at the final stages of the NSExpression payload which decrypts an AES-encrypted NSExpression and executes it.</span></p>
 
 <p><span>It seems very likely that the encrypted payload contains a BlastDoor sandbox escape. Although the BlastDoor sandbox profile is fairly restrictive it still allows access to a number of system services like </span><span>notifyd</span><span>, </span><span>logd</span><span> and </span><span>mobilegestalt</span><span>. In addition to the syscall attack surface there&#39;s also a non-trivial IOKit driver attack surface:</span></p>
 
 <p><span>...</span></p>
 <p><span>(allow</span><span> </span><span>iokit-open-user-client</span></p>
 <p><span>        </span><span>(iokit-user-client-class</span><span> </span><span>&#34;IOSurfaceRootUserClient&#34;)</span></p>
 <p><span>        </span><span>(iokit-user-client-class</span><span> </span><span>&#34;IOSurfaceAcceleratorClient&#34;)</span></p>
 <p><span>        </span><span>(iokit-user-client-class</span><span> </span><span>&#34;AGXDevice&#34;))</span></p>
 <p><span>(allow</span><span> </span><span>iokit-open-service)</span></p>
 <p><span>(allow</span><span> </span><span>mach-derive-port)</span></p>
 <p><span>(allow</span><span> </span><span>mach-kernel-endpoint)</span></p>
 <p><span>(allow</span><span> </span><span>mach-lookup</span></p>
 <p><span>        </span><span>(require-all</span></p>
 <p><span>                </span><span>(require-not</span><span> </span><span>(global-name</span><span> </span><span>&#34;com.apple.diagnosticd&#34;))</span></p>
 <p><span>                </span><span>(require-any</span></p>
 <p><span>                        </span><span>(global-name</span><span> </span><span>&#34;com.apple.logd&#34;)</span></p>
 <p><span>                        </span><span>(global-name</span><span> </span><span>&#34;com.apple.system.notification_center&#34;)</span></p>
 <p><span>                        </span><span>(global-name</span><span> </span><span>&#34;com.apple.mobilegestalt.xpc&#34;))))</span></p>
 <p><span>...</span></p>
 
 <p><span>(This profile snippet was generated using the </span><span><a href="https://github.com/cellebrite-labs/sandblaster">Cellebrite labs&#39; fork of SandBlaster</a></span><span>)</span></p>
 
 <p><span>In FORCEDENTRY the sandbox escape was contained directly in the NSExpression payload (though that was an escape from the less-restrictive IMTranscoderAgent sandbox). This time around it seems extra care has been taken to prevent analysis of the sandbox escape.</span></p>
 
 <p><span>The question is: where does the key come from? We had a few theories:</span></p>
 <ul><li><span>Perhaps the key is just obfuscated, and by completely reversing the </span><span>NSExpression</span><span> payload we can find it?</span></li><li><span>Perhaps the key is derived from some target-specific information?</span></li><li><span>Perhaps the key was somehow delivered in some other way and can be read from inside BlastDoor?</span></li></ul>
 
 <p><span>We spent a day analysing the NSExpression payload and concluded that the third theory appeared to be the correct one. The NSExpression walks up the native stack looking for the communication ports back to </span><span>imagent</span><span>. It then hijacks that communication, effectively taking over responsibility for parsing all subsequent incoming requests from </span><span>imagent</span><span> for &#34;defusing&#34; of iMessage payloads. The NSExpression loops 100 times, parsing incoming requests as XPC messages, reading the </span><span>request</span><span> xpc dictionary then the </span><span>data</span><span> </span><span>xpc data</span><span> object to get access to the raw, binary iMessage format. It waits until the device receives another iMessage with a specific format, and from that message extracts an AES key which is then used to decrypt the next NSExpression stage and evaluate it.</span></p>
 
 <p><span>We were unable to recover any messages with the matching format and therefore unable to analyse the next stage of the exploit.</span></p><h3 id="h.kwbzpb78bv4k"><span>Conclusion</span></h3>
 <p><span>In contrast to FORCEDENTRY, BLASTPASS&#39;s separation of the ASLR disclosure and RCE phases mitigated the need for a novel weird machine. Whilst the heap groom was impressively complicated and precise, the exploit still relied on well-known exploitation techniques. Furthermore, the MakerNote bplist groom and callback-JOP PAC defeat techniques appear to have been in use for multiple years, based on similarities with </span><span><a href="https://citizenlab.ca/2023/04/nso-groups-pegasus-spyware-returns-in-2022/">Citizenlab&#39;s blogpost in 2023</a></span><span>, which looked at devices compromised in 2022. </span></p>
 
 <p><span>Enforcing much stricter requirements on the format of the bplist inside the MakerNote (for example: a size limit or a strict-parser mode which rejects duplicate keys) would seem prudent. The callback-JOP issue is likely harder to mitigate.</span></p>
 
 <p><span>The HomeKit aspect of the exploit chain remains mostly a mystery, but it seems very likely that it was somehow involved in the ASLR disclosure. </span><span><a href="https://googleprojectzero.blogspot.com/2021/01/a-look-at-imessage-in-ios-14.html">Samuel Groß&#39;s post &#34;A Look at iMessage in iOS 14&#34;</a></span><span> in 2021,</span><span> mentioned that Apple added support for re-randomizing the shared cache slide of certain services. Ensuring that BlastDoor has a unique ASLR slide could be a way to mitigate this.</span></p>
 
 <p><span>This is the second in-the-wild NSO exploit which relied on simply renaming a file extension to access a parser in an unexpected context which shouldn&#39;t have been allowed. </span></p>
 
 <p><span>FORCEDENTRY had a .gif which was really a .pdf. </span></p>
 
 <p><span>BLASTPASS had a .png which was really a .webp. </span></p>
 
 <p><span>A basic principle of sandboxing is treating all incoming attacker-controlled data as untrusted, and not simply trusting a file extension.</span></p>
 
 <p><span>This speaks to a broader challenge in sandboxing: that current approaches based on process isolation can only take you so far. They increase the length of an exploit chain, but don&#39;t necessarily reduce the size of the initial remote attack surface. Accurately mapping, then truly reducing the scope of that initial remote attack surface should be a top priority.</span></p>
 
 


</div></div>
  </body>
</html>
