<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wadetregaskis.com/swifts-native-clocks-are-very-inefficient/">Original</a>
    <h1>Swift&#39;s native Clocks are inefficient</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="text">
			

<p>By which I mean, things like <code><a href="https://developer.apple.com/documentation/swift/continuousclock" data-wpel-link="external" target="_blank" rel="external noopener">ContinuousClock</a></code> and <code><a href="https://developer.apple.com/documentation/swift/suspendingclock" data-wpel-link="external" target="_blank" rel="external noopener">SuspendingClock</a></code>.</p>



<p>In absolute terms they don‚Äôt have much overhead ‚Äì think sub-microsecond for most uses.  Which makes them perfectly acceptable when they‚Äôre used sporadically (e.g. only a few times per second).</p>



<p>However, if you need to deal with time and timing more frequently, their inefficiency can become a serious bottleneck.</p>



<p>I stumbled into this because of a fairly common and otherwise uninteresting pattern ‚Äì throttling UI updates on an I/O operation‚Äôs progress.  This might look something like:</p>



<div data-code-block-pro-font-family=""><pre tabindex="0"><code><span><span>struct</span><span> </span><span>Example</span><span>: View {</span></span>
<span><span>    </span><span>let</span><span> bytes: AsyncSequence&lt;</span><span>UInt8</span><span>&gt;</span></span>
<span></span>
<span><span>    </span><span>@State</span><span> </span><span>var</span><span> byteCount = </span><span>0</span></span>
<span><span>    </span></span>
<span><span>    </span><span>var</span><span> body: some View {</span></span>
<span><span>        </span><span>Text</span><span>(</span><span>&#34;Bytes so far: </span><span>\(</span><span>byteCount.</span><span>formatted</span><span>(.</span><span>byteCount</span><span>(</span><span>style</span><span>: .</span><span>binary</span><span>))</span><span>)</span><span>&#34;</span><span>)</span></span>
<span><span>            .</span><span>task</span><span> {</span></span>
<span><span>                </span><span>var</span><span> unpostedByteCount = </span><span>0</span></span>
<span><span>                </span><span>let</span><span> clock = </span><span>ContinuousClock</span><span>()</span></span>
<span><span>                </span><span>var</span><span> lastUpdate = clock.</span><span>now</span></span>
<span></span>
<span><span>                </span><span>for</span><span> </span><span>try</span><span> </span><span>await</span><span> byte </span><span>in</span><span> bytes {</span></span>
<span><span>                    ‚Ä¶ </span><span>// Do something with the byte.</span></span>
<span><span>                    </span></span>
<span><span>                    unpostedByteCount += </span><span>1</span></span>
<span></span>
<span><span>                    </span><span>let</span><span> now = clock.</span><span>now</span></span>
<span><span>                    </span><span>let</span><span> delta = now - lastUpdate</span></span>
<span></span>
<span><span>                    </span><span>if</span><span> (    delta &gt; .</span><span>seconds</span><span>(</span><span>1</span><span>)</span></span>
<span><span>                         || (    (delta &gt; .</span><span>milliseconds</span><span>(</span><span>100</span><span>)</span></span>
<span><span>                              &amp;&amp; </span><span>1_000_000</span><span> &lt;= unpostedByteCount))) {</span></span>
<span><span>                        byteCount += unpostedByteCount</span></span>
<span><span>                        unpostedByteCount = </span><span>0</span></span>
<span><span>                        lastUpdate = now</span></span>
<span><span>                    }</span></span>
<span><span>                }</span></span>
<span><span>            }</span></span>
<span><span>    }</span></span>
<span><span>}</span></span></code></pre></div>



<div><div>
<p>‚òùÔ∏è This isn‚Äôt a complete implementation, as it won‚Äôt update the byte count if the download stalls (since the lack of incoming bytes will mean no iteration on the loop, and therefore no updates even if a full second passes). But it‚Äôs sufficient for demonstration purposes here.</p>



<p>üñêÔ∏è Why didn‚Äôt I just use <code><a href="https://github.com/apple/swift-async-algorithms/blob/main/Sources/AsyncAlgorithms/AsyncAlgorithms.docc/Guides/Throttle.md" data-wpel-link="external" target="_blank" rel="external noopener">throttle</a></code> from <a href="https://github.com/apple/swift-async-algorithms" data-wpel-link="external" target="_blank" rel="external noopener">swift-async-algorithms</a>?  I did, at first, and quickly discovered that its performance is <em>horrible</em>.  While I do suspect I can ‚Äòoptimise‚Äô it to not be atrocious, I haven‚Äôt pursued that as it was easier to just write my own throttling system.</p>
</div></div>



<p>The above seems fairly straightforward, but if you run it and have any non-trivial I/O rate ‚Äì even just a few hundred kilobytes per second ‚Äì you‚Äôll find that it saturates an entire CPU core, not just wasting CPU time but limiting the I/O rate severely.</p>



<p>Using a <code>SuspendingClock</code> makes no difference.</p>



<p>In a nutshell, the problem is that Swift‚Äôs <code><a href="https://developer.apple.com/documentation/swift/clock" data-wpel-link="external" target="_blank" rel="external noopener">Clock</a></code> protocol has significant overheads by design.  If you look at a time profile of code like this, you‚Äôll see things like:</p>


<div>
<figure><img fetchpriority="high" decoding="async" width="900" height="716" src="https://wadetregaskis.com/wp-content/uploads/2024/05/ContinuousClock-overhead.webp" alt="Screenshot of Instruments showing the outline view for a Time Profile, expanded to show dozens of spurious, overhead functions taking up the vast majority of the runtime." srcset="https://wadetregaskis.com/wp-content/uploads/2024/05/ContinuousClock-overhead.webp 900w, https://wadetregaskis.com/wp-content/uploads/2024/05/ContinuousClock-overhead-256x204.webp 256w, https://wadetregaskis.com/wp-content/uploads/2024/05/ContinuousClock-overhead-768x611.webp 768w, https://wadetregaskis.com/wp-content/uploads/2024/05/ContinuousClock-overhead@2x.webp 1800w, https://wadetregaskis.com/wp-content/uploads/2024/05/ContinuousClock-overhead-256x204@2x.webp 512w" sizes="(max-width: 900px) 100vw, 900px"/></figure></div>


<p>That‚Äôs a lot of time wasted in function calls and struct initialisation and type conversion and protocol witnesses and all that guff.  The only part that‚Äôs <em>actually</em> retrieving the time is the <code><a href="https://github.com/apple/swift/blob/625436af05b1cf8f1904096530235489daec9dac/stdlib/public/Concurrency/Clock.cpp#L30" data-wpel-link="external" target="_blank" rel="external noopener">swift_get_time</a></code> call (which is just a wrapper over <code><a href="https://www.manpagez.com/man/3/clock_gettime/" data-wpel-link="external" target="_blank" rel="external noopener">clock_gettime</a></code>, which is just a wrapper over <code><a href="https://www.manpagez.com/man/3/clock_gettime_nsec_np/" data-wpel-link="external" target="_blank" rel="external noopener">clock_gettime_nsec_np</a>(CLOCK_UPTIME_RAW)</code>, which is just a wrapper over <code><a href="https://developer.apple.com/documentation/kernel/1462446-mach_absolute_time" data-wpel-link="external" target="_blank" rel="external noopener">mach_absolute_time</a></code>).</p>



<p>I wrote <a href="https://github.com/wadetregaskis/Swift-Benchmarks/blob/main/Benchmarks/Clocks/Clocks.swift" data-wpel-link="external" target="_blank" rel="external noopener">some simple benchmarks of various alternative time-tracking methods</a>, with these results with Swift 5.10 (showing the median runtime of the benchmark, which is a million iterations of checking the time):</p>



<figure><table><thead><tr><th data-align="right">Method</th><th data-align="center">10-core iMac Pro</th><th data-align="center">M2 MacBook Air</th></tr></thead><tbody><tr><td data-align="right"><code>ContinuousClock</code></td><td data-align="center">429 ms</td><td data-align="center">258 ms</td></tr><tr><td data-align="right"><code>SuspendingClock</code></td><td data-align="center">430 ms</td><td data-align="center">247 ms</td></tr><tr><td data-align="right"><code>Date</code> / <code>NSDate</code></td><td data-align="center">30 ms</td><td data-align="center">19 ms</td></tr><tr><td data-align="right"><code>clock_gettime_nsec_np(CLOCK_MONOTONIC_RAW)</code></td><td data-align="center">32 ms</td><td data-align="center">10 ms</td></tr><tr><td data-align="right"><code>clock_gettime_nsec_np(CLOCK_UPTIME_RAW)</code></td><td data-align="center">27 ms</td><td data-align="center">10 ms</td></tr><tr><td data-align="right"><code>gettimeofday</code></td><td data-align="center">24 ms</td><td data-align="center">12 ms</td></tr><tr><td data-align="right"><code>mach_absolute_time</code></td><td data-align="center">15 ms</td><td data-align="center">6 ms</td></tr></tbody></table></figure>



<p>All these alternative methods are <em>well</em> over an order of magnitude faster than Swift‚Äôs native clock APIs, showing just how dreadfully inefficient the Swift <code>Clock</code> API is.</p>



<h3><span id="mach_absolute_time_for_the_win">mach_absolute_time for the win</span></h3>



<p>Unsurprisingly, <code>mach_absolute_time</code> is the fastest.  It is what all these other APIs are actually based on; it is the lowest level of the time stack.</p>



<p>The downside to calling <code>mach_absolute_time</code> <em>directly</em>, though, is that <a href="https://developer.apple.com/documentation/kernel/1462446-mach_absolute_time#discussion" data-wpel-link="external" target="_blank" rel="external noopener">it‚Äôs on Apple‚Äôs ‚Äúnaughty‚Äù list</a> ‚Äì apparently it‚Äôs been abused for device fingerprinting, so Apple require you to beg for special permission if you want to use it (even though it‚Äôs used by all these other APIs anyway, as the basis for their implementations, and there‚Äôs nothing you can get from <code>mach_absolute_time</code> that you can‚Äôt get from them too ü§®).</p>



<h3><span id="Date_NSDate_surprisingly_not_bad"><code>Date</code> / <code>NSDate</code> surprisingly not bad</span></h3>



<p>I was quite surprised to see good ol‚Äô <code><a href="https://developer.apple.com/documentation/foundation/date" data-wpel-link="external" target="_blank" rel="external noopener">Date</a></code> (a.k.a. <code>NSDate</code>) performing competitively with the traditional C-level APIs, at least on x86-64. Even on arm64 it‚Äôs not bad, at still a third to half the speed of the C APIs. This surprised me because <s>it has the overhead of at least one Objective-C message send (for <code><a href="https://developer.apple.com/documentation/foundation/date/1780473-timeintervalsincenow" data-wpel-link="external" target="_blank" rel="external noopener">timeIntervalSinceNow</a></code>), unless somehow the Swift compiler is optimising that into a static function call, or inlining it entirely‚Ä¶?</s></p>



<div><div>
<p><strong>Update</strong>: I later looked at the disassembly, and found no message sends, only a plain function call to <code>Foundation.Date.timeIntervalSinceNow.getter</code> (which is only 40 instructions, on arm64, over <code>clock_gettime</code> and <code>__stack_chk_fail</code> ‚Äì and the former is hundreds of instructions, so it‚Äôs adding relatively little overhead to the C API).</p>



<p>This isn‚Äôt being done by the compiler, it‚Äôs because <a href="https://github.com/apple/swift-foundation/blob/main/Sources/FoundationEssentials/Date.swift" data-wpel-link="external" target="_blank" rel="external noopener">that‚Äôs <em>actually</em> how it‚Äôs implemented in Foundation</a>. I keep forgetting that Foundation from Swift is no longer just the old Objective-C Foundation, but rather mostly the <em>new</em> Foundation that‚Äôs written in native Swift. So these performance results likely don‚Äôt apply once you go back far enough in Apple OS releases (to when Swift really was calling into the Objective-C code for <code>NSDate</code>) ‚Äì but it‚Äôs safe to rely on good <code>Date</code> performance now and in future.</p>
</div></div>



<p>I certainly wouldn‚Äôt be afraid to use <code>Date</code> broadly, going down to lower APIs only when truly necessary ‚Äì which is pretty rarely, I‚Äôd wager; we‚Äôre talking a mere 19 to 30 <em>nanoseconds</em> to get the time elapsed since a reference date <em>and</em> compare it to a threshold. If that‚Äôs too slow, it might be an indication that there‚Äôs a bigger problem (like transferring data a single byte at a time, as in the example that started this post ‚Äì but more on that in <a href="https://wadetregaskis.com/urlsession-performance-for-reading-a-byte-stream/" data-wpel-link="internal">the next post</a>).</p>
		</div></div>
  </body>
</html>
