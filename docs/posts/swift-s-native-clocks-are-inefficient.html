<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wadetregaskis.com/swifts-native-clocks-are-very-inefficient/">Original</a>
    <h1>Swift&#39;s native Clocks are inefficient</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="text">
			

<p>By which I mean, things like <code><a href="https://developer.apple.com/documentation/swift/continuousclock" data-wpel-link="external" target="_blank" rel="external noopener">ContinuousClock</a></code> and <code><a href="https://developer.apple.com/documentation/swift/suspendingclock" data-wpel-link="external" target="_blank" rel="external noopener">SuspendingClock</a></code>.</p>



<p>In absolute terms they don‚Äôt have much overhead ‚Äì think sub-microsecond for most uses.  Which makes them perfectly acceptable when they‚Äôre used sporadically (e.g. only a few times per second).</p>



<p>However, if you need to deal with time and timing more frequently, their inefficiency can become a serious bottleneck.</p>



<p>I stumbled into this because of a fairly common and otherwise uninteresting pattern ‚Äì throttling UI updates on an I/O operation‚Äôs progress.  This might look something like:</p>



<div data-code-block-pro-font-family=""><pre tabindex="0"><code><span><span>struct</span><span> </span><span>Example</span><span>: View {</span></span>
<span><span>    </span><span>let</span><span> bytes: AsyncSequence&lt;</span><span>UInt8</span><span>&gt;</span></span>
<span></span>
<span><span>    </span><span>@State</span><span> </span><span>var</span><span> byteCount = </span><span>0</span></span>
<span><span>    </span></span>
<span><span>    </span><span>var</span><span> body: some View {</span></span>
<span><span>        </span><span>Text</span><span>(</span><span>&#34;Bytes so far: </span><span>\(</span><span>byteCount.</span><span>formatted</span><span>(.</span><span>byteCount</span><span>(</span><span>style</span><span>: .</span><span>binary</span><span>))</span><span>)</span><span>&#34;</span><span>)</span></span>
<span><span>            .</span><span>task</span><span> {</span></span>
<span><span>                </span><span>var</span><span> unpostedByteCount = </span><span>0</span></span>
<span><span>                </span><span>let</span><span> clock = </span><span>ContinuousClock</span><span>()</span></span>
<span><span>                </span><span>var</span><span> lastUpdate = clock.</span><span>now</span></span>
<span></span>
<span><span>                </span><span>for</span><span> </span><span>try</span><span> </span><span>await</span><span> byte </span><span>in</span><span> bytes {</span></span>
<span><span>                    ‚Ä¶ </span><span>// Do something with the byte.</span></span>
<span><span>                    </span></span>
<span><span>                    unpostedByteCount += </span><span>1</span></span>
<span></span>
<span><span>                    </span><span>let</span><span> now = clock.</span><span>now</span></span>
<span><span>                    </span><span>let</span><span> delta = now - lastUpdate</span></span>
<span></span>
<span><span>                    </span><span>if</span><span> (    delta &gt; .</span><span>seconds</span><span>(</span><span>1</span><span>)</span></span>
<span><span>                         || (    (delta &gt; .</span><span>milliseconds</span><span>(</span><span>100</span><span>)</span></span>
<span><span>                              &amp;&amp; </span><span>1_000_000</span><span> &lt;= unpostedByteCount))) {</span></span>
<span><span>                        byteCount += unpostedByteCount</span></span>
<span><span>                        unpostedByteCount = </span><span>0</span></span>
<span><span>                        lastUpdate = now</span></span>
<span><span>                    }</span></span>
<span><span>                }</span></span>
<span><span>            }</span></span>
<span><span>    }</span></span>
<span><span>}</span></span></code></pre></div>



<div><div>
<p>‚òùÔ∏è This isn‚Äôt a complete implementation, as it won‚Äôt update the byte count if the download stalls (since the lack of incoming bytes will mean no iteration on the loop, and therefore no updates even if a full second passes). But it‚Äôs sufficient for demonstration purposes here.</p>



<p>üñêÔ∏è Why didn‚Äôt I just use <code><a href="https://github.com/apple/swift-async-algorithms/blob/main/Sources/AsyncAlgorithms/AsyncAlgorithms.docc/Guides/Throttle.md" data-wpel-link="external" target="_blank" rel="external noopener">throttle</a></code> from <a href="https://github.com/apple/swift-async-algorithms" data-wpel-link="external" target="_blank" rel="external noopener">swift-async-algorithms</a>?  I did, at first, and quickly discovered that its performance is <em>horrible</em>.  While I do suspect I can ‚Äòoptimise‚Äô it to not be atrocious, I haven‚Äôt pursued that as it was easier to just write my own throttling system.</p>
</div></div>



<p>The above seems fairly straightforward, but if you run it and have any non-trivial I/O rate ‚Äì even just a few hundred kilobytes per second ‚Äì you‚Äôll find that it saturates an entire CPU core, not just wasting CPU time but limiting the I/O rate severely.</p>



<p>Using a <code>SuspendingClock</code> makes no difference.</p>



<p>In a nutshell, the problem is that Swift‚Äôs <code><a href="https://developer.apple.com/documentation/swift/clock" data-wpel-link="external" target="_blank" rel="external noopener">Clock</a></code> protocol has significant overheads by design.  If you look at a time profile of code like this, you‚Äôll see things like:</p>


<div>
<figure><img fetchpriority="high" decoding="async" width="900" height="716" src="https://wadetregaskis.com/wp-content/uploads/2024/05/ContinuousClock-overhead.webp" alt="Screenshot of Instruments showing the outline view for a Time Profile, expanded to show dozens of spurious, overhead functions taking up the vast majority of the runtime." srcset="https://wadetregaskis.com/wp-content/uploads/2024/05/ContinuousClock-overhead.webp 900w, https://wadetregaskis.com/wp-content/uploads/2024/05/ContinuousClock-overhead-256x204.webp 256w, https://wadetregaskis.com/wp-content/uploads/2024/05/ContinuousClock-overhead-768x611.webp 768w, https://wadetregaskis.com/wp-content/uploads/2024/05/ContinuousClock-overhead@2x.webp 1800w, https://wadetregaskis.com/wp-content/uploads/2024/05/ContinuousClock-overhead-256x204@2x.webp 512w" sizes="(max-width: 900px) 100vw, 900px"/></figure></div>


<p>That‚Äôs a lot of time wasted in function calls and struct initialisation and type conversion and protocol witnesses and all that guff.  The only part that‚Äôs <em>actually</em> retrieving the time is the <code><a href="https://github.com/apple/swift/blob/625436af05b1cf8f1904096530235489daec9dac/stdlib/public/Concurrency/Clock.cpp#L30" data-wpel-link="external" target="_blank" rel="external noopener">swift_get_time</a></code> call (which is just a wrapper over <code><a href="https://www.manpagez.com/man/3/clock_gettime/" data-wpel-link="external" target="_blank" rel="external noopener">clock_gettime</a></code>, which is just a wrapper over <code><a href="https://www.manpagez.com/man/3/clock_gettime_nsec_np/" data-wpel-link="external" target="_blank" rel="external noopener">clock_gettime_nsec_np</a>(CLOCK_UPTIME_RAW)</code>, which is just a wrapper over <code><a href="https://developer.apple.com/documentation/kernel/1462446-mach_absolute_time" data-wpel-link="external" target="_blank" rel="external noopener">mach_absolute_time</a></code>).</p>



<p>I wrote <a href="https://github.com/wadetregaskis/Swift-Benchmarks/blob/main/Benchmarks/Clocks/Clocks.swift" data-wpel-link="external" target="_blank" rel="external noopener">some simple benchmarks of various alternative time-tracking methods</a>, with these results with Swift 5.10 (showing the median runtime of the benchmark, which is a million iterations of checking the time):</p>



<figure><table><thead><tr><th data-align="right">Method</th><th data-align="center">10-core iMac Pro</th><th data-align="center">M2 MacBook Air</th></tr></thead><tbody><tr><td data-align="right"><code><a href="https://developer.apple.com/documentation/swift/continuousclock" data-wpel-link="external" target="_blank" rel="external noopener">ContinuousClock</a></code></td><td data-align="center">429 ms</td><td data-align="center">258 ms</td></tr><tr><td data-align="right"><code><a href="https://developer.apple.com/documentation/swift/suspendingclock" data-wpel-link="external" target="_blank" rel="external noopener">SuspendingClock</a></code></td><td data-align="center">430 ms</td><td data-align="center">247 ms</td></tr><tr><td data-align="right"><code><a href="https://developer.apple.com/documentation/foundation/date" data-wpel-link="external" target="_blank" rel="external noopener">Date</a></code></td><td data-align="center">30 ms</td><td data-align="center">19 ms</td></tr><tr><td data-align="right"><code><a href="https://www.manpagez.com/man/3/clock_gettime_nsec_np/" data-wpel-link="external" target="_blank" rel="external noopener">clock_gettime_nsec_np(CLOCK_MONOTONIC_RAW)</a></code></td><td data-align="center">32 ms</td><td data-align="center">10 ms</td></tr><tr><td data-align="right"><code><a href="https://www.manpagez.com/man/3/clock_gettime_nsec_np/" data-wpel-link="external" target="_blank" rel="external noopener">clock_gettime_nsec_np(CLOCK_UPTIME_RAW)</a></code></td><td data-align="center">27 ms</td><td data-align="center">10 ms</td></tr><tr><td data-align="right"><code><a href="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man2/gettimeofday.2.html" data-wpel-link="external" target="_blank" rel="external noopener">gettimeofday</a></code></td><td data-align="center">24 ms</td><td data-align="center">12 ms</td></tr><tr><td data-align="right"><code><a href="https://developer.apple.com/documentation/kernel/1462446-mach_absolute_time" data-wpel-link="external" target="_blank" rel="external noopener">mach_absolute_time</a></code></td><td data-align="center">15 ms</td><td data-align="center">6 ms</td></tr></tbody></table></figure>



<p>All these alternative methods are <em>well</em> over an order of magnitude faster than Swift‚Äôs native clock APIs, showing just how dreadfully inefficient the Swift <code>Clock</code> API is.</p>



<h3><span id="mach_absolute_time_for_the_win">mach_absolute_time for the win</span></h3>



<p>Unsurprisingly, <code>mach_absolute_time</code> is the fastest.  It is what all these other APIs are actually based on; it is the lowest level of the time stack.</p>



<p>The downside to calling <code>mach_absolute_time</code> <em>directly</em>, though, is that <a href="https://developer.apple.com/documentation/kernel/1462446-mach_absolute_time#discussion" data-wpel-link="external" target="_blank" rel="external noopener">it‚Äôs on Apple‚Äôs ‚Äúnaughty‚Äù list</a> ‚Äì apparently it‚Äôs been abused for device fingerprinting, so Apple require you to beg for special permission if you want to use it (even though it‚Äôs used by all these other APIs anyway, as the basis for their implementations, and there‚Äôs nothing you can get from <code>mach_absolute_time</code> that you can‚Äôt get from them too ü§®).</p>



<h3><span id="Date_surprisingly_not_bad"><code>Date</code> surprisingly not bad</span></h3>



<p>I was quite surprised to see good ol‚Äô <code><a href="https://developer.apple.com/documentation/foundation/date" data-wpel-link="external" target="_blank" rel="external noopener">Date</a></code> performing competitively with the traditional C-level APIs, at least on x86-64. Even on arm64 it‚Äôs not bad, at still a third to half the speed of the C APIs. This surprised me because <s>it has the overhead of at least one Objective-C message send (for <code><a href="https://developer.apple.com/documentation/foundation/date/1780473-timeintervalsincenow" data-wpel-link="external" target="_blank" rel="external noopener">timeIntervalSinceNow</a></code>), unless somehow the Swift compiler is optimising that into a static function call, or inlining it entirely‚Ä¶?</s></p>



<div><div>
<p><strong>Update</strong>: I later looked at the disassembly, and found no message sends, only a plain function call to <code>Foundation.Date.timeIntervalSinceNow.getter</code> (which is only 40 instructions, on arm64, over <code>clock_gettime</code> and <code>__stack_chk_fail</code> ‚Äì and the former is hundreds of instructions, so it‚Äôs adding relatively little overhead to the C API).</p>



<p>This isn‚Äôt being done by the compiler, it‚Äôs because <a href="https://github.com/apple/swift-foundation/blob/main/Sources/FoundationEssentials/Date.swift" data-wpel-link="external" target="_blank" rel="external noopener">that‚Äôs <em>actually</em> how it‚Äôs implemented in Foundation</a>. I keep forgetting that Foundation from Swift is no longer just the old Objective-C Foundation, but rather mostly the <em>new</em> Foundation that‚Äôs written in native Swift. So these performance results likely don‚Äôt apply once you go back far enough in Apple OS releases (to when Swift really was calling into the Objective-C code for <code>NSDate</code>) ‚Äì but it‚Äôs safe to rely on good <code>Date</code> performance now and in future.</p>
</div></div>



<p>I certainly wouldn‚Äôt be afraid to use <code>Date</code> broadly, going down to lower APIs only when truly necessary ‚Äì which is pretty rarely, I‚Äôd wager; we‚Äôre talking a mere 19 to 30 <em>nanoseconds</em> to get the time elapsed since a reference date <em>and</em> compare it to a threshold. If that‚Äôs too slow, it might be an indication that there‚Äôs a bigger problem (like transferring data a single byte at a time, as in the example that started this post ‚Äì but more on that in <a href="https://wadetregaskis.com/urlsession-performance-for-reading-a-byte-stream/" data-wpel-link="internal">the next post</a>).</p>



<hr/>



<h3><span id="Follow-up">Follow-up</span></h3>



<p>This post <a href="https://news.ycombinator.com/item?id=40262897" data-wpel-link="external" target="_blank" rel="external noopener">got some attention on HackerNews</a>. Pleasingly, the comments there were almost all well-intentioned and interesting. It‚Äôs a bit beyond me to try to address all of them, but a few in particular raised good points that I would like to answer / clarify:</p>



<ul>
<li>A lot of folks were curious about <code>mach_absolute_time</code> being on Apple‚Äôs naughty list. I don‚Äôt know for sure why it is either, but I think it‚Äôs very likely that it‚Äôs <em>primarily</em> because it essentially provides a reference time point, that‚Äôs very precise and pretty unique between computers. It‚Äôs not the boot time necessarily ‚Äì because the timer pauses whenever the system is put to sleep ‚Äì but even so it provides a simple way to nearly if not exactly identify an individual machine session (between boots &amp; sleeps). It probably wouldn‚Äôt take many other fingerprinting data points to reliably pin-point a specific machine.</li>



<li>Admittedly my phrasing regarding Apple‚Äôs policies on <code>mach_absolute_time</code> ‚Äì ‚Äúbeg for permission to use it‚Äù ‚Äì is a little melodramatic.  It‚Äôs revealing something of my personal opinions on certain Apple ‚Äúsecurity‚Äù practices.  I love that Apple genuinely care about protecting everyone‚Äôs privacy, but sometimes I chaff at what feels like capricious or impractical specific policies.</li>



<li>A few folks looked at the example case, of iterating a single byte at a time, and were suspicious of how performant that could possibly be anyway. This is a very fair reaction ‚Äì it‚Äôs my ingrained instinct as well, from years of C/C++/Objective-C ‚Äì <em>but</em> it‚Äôs relying on a few outdated assumptions. <a href="https://wadetregaskis.com/urlsession-performance-for-reading-a-byte-stream/" data-wpel-link="internal">My next post</a> already covered this for the most part, but in short here:</li>



<li>Some folks noted that are a <em>lot</em> of other clock APIs from Apple‚Äôs frameworks, like <code><a href="https://developer.apple.com/documentation/dispatch/dispatchtime" data-wpel-link="external" target="_blank" rel="external noopener">DispatchTime</a></code> and <code><a href="https://developer.apple.com/documentation/quartzcore/1395996-cacurrentmediatime" data-wpel-link="external" target="_blank" rel="external noopener">CACurrentMediaTime</a></code>.  I didn‚Äôt include those in the benchmark because I just didn‚Äôt think of them at the time.  If anyone wants to send me a pull request adding them to <a href="https://github.com/wadetregaskis/Swift-Benchmarks/blob/main/Benchmarks/Clocks/Clocks.swift" data-wpel-link="external" target="_blank" rel="external noopener">the code</a>, I‚Äôd be very happy to accept it.</li>



<li><a href="https://news.ycombinator.com/user?id=Kallikrates" data-wpel-link="external" target="_blank" rel="external noopener">Kallikrates</a> quietly pointed to a very interesting recent change in Apple‚Äôs Swift standard library code, <a href="https://github.com/apple/swift/pull/73429" data-wpel-link="external" target="_blank" rel="external noopener">Make static [milli/micro/nano]seconds members on Duration inlinable</a>. It‚Äôs paired with <a href="https://github.com/apple/swift/pull/73419" data-wpel-link="external" target="_blank" rel="external noopener">another patch</a> that together seem very specifically aimed at eliminating some of the absurd overhead in Swift‚Äôs <code>ContinuousClock</code> &amp; <code>SuspendingClock</code> implementations. The timing is a bit interesting ‚Äì I don‚Äôt know if they were prompted by this post, but it‚Äôd be an unlikely coincidence otherwise.</li>
</ul>
		</div></div>
  </body>
</html>
