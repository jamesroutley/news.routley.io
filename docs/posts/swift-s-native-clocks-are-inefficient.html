<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wadetregaskis.com/swifts-native-clocks-are-very-inefficient/">Original</a>
    <h1>Swift&#39;s native Clocks are inefficient</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="text">
			

<p>By which I mean, things like <code><a href="https://developer.apple.com/documentation/swift/continuousclock" data-wpel-link="external" target="_blank" rel="external noopener">ContinuousClock</a></code> and <code><a href="https://developer.apple.com/documentation/swift/suspendingclock" data-wpel-link="external" target="_blank" rel="external noopener">SuspendingClock</a></code>.</p>



<p>In absolute terms they donâ€™t have much overhead â€“ think sub-microsecond for most uses.  Which makes them perfectly acceptable when theyâ€™re used sporadically (e.g. only a few times per second).</p>



<p>However, if you need to deal with time and timing more frequently, their inefficiency can become a serious bottleneck.</p>



<p>I stumbled into this because of a fairly common and otherwise uninteresting pattern â€“ throttling UI updates on an I/O operationâ€™s progress.  This might look something like:</p>



<div data-code-block-pro-font-family=""><pre tabindex="0"><code><span><span>struct</span><span> </span><span>Example</span><span>: View {</span></span>
<span><span>    </span><span>let</span><span> bytes: AsyncSequence&lt;</span><span>UInt8</span><span>&gt;</span></span>
<span></span>
<span><span>    </span><span>@State</span><span> </span><span>var</span><span> byteCount = </span><span>0</span></span>
<span><span>    </span></span>
<span><span>    </span><span>var</span><span> body: some View {</span></span>
<span><span>        </span><span>Text</span><span>(</span><span>&#34;Bytes so far: </span><span>\(</span><span>byteCount.</span><span>formatted</span><span>(.</span><span>byteCount</span><span>(</span><span>style</span><span>: .</span><span>binary</span><span>))</span><span>)</span><span>&#34;</span><span>)</span></span>
<span><span>            .</span><span>task</span><span> {</span></span>
<span><span>                </span><span>var</span><span> unpostedByteCount = </span><span>0</span></span>
<span><span>                </span><span>let</span><span> clock = </span><span>ContinuousClock</span><span>()</span></span>
<span><span>                </span><span>var</span><span> lastUpdate = clock.</span><span>now</span></span>
<span></span>
<span><span>                </span><span>for</span><span> </span><span>try</span><span> </span><span>await</span><span> byte </span><span>in</span><span> bytes {</span></span>
<span><span>                    â€¦ </span><span>// Do something with the byte.</span></span>
<span><span>                    </span></span>
<span><span>                    unpostedByteCount += </span><span>1</span></span>
<span></span>
<span><span>                    </span><span>let</span><span> now = clock.</span><span>now</span></span>
<span><span>                    </span><span>let</span><span> delta = now - lastUpdate</span></span>
<span></span>
<span><span>                    </span><span>if</span><span> (    delta &gt; .</span><span>seconds</span><span>(</span><span>1</span><span>)</span></span>
<span><span>                         || (    (delta &gt; .</span><span>milliseconds</span><span>(</span><span>100</span><span>)</span></span>
<span><span>                              &amp;&amp; </span><span>1_000_000</span><span> &lt;= unpostedByteCount))) {</span></span>
<span><span>                        byteCount += unpostedByteCount</span></span>
<span><span>                        unpostedByteCount = </span><span>0</span></span>
<span><span>                        lastUpdate = now</span></span>
<span><span>                    }</span></span>
<span><span>                }</span></span>
<span><span>            }</span></span>
<span><span>    }</span></span>
<span><span>}</span></span></code></pre></div>



<div><div>
<p>â˜ï¸ This isnâ€™t a complete implementation, as it wonâ€™t update the byte count if the download stalls (since the lack of incoming bytes will mean no iteration on the loop, and therefore no updates even if a full second passes). But itâ€™s sufficient for demonstration purposes here.</p>



<p>ğŸ–ï¸ Why didnâ€™t I just use <code><a href="https://github.com/apple/swift-async-algorithms/blob/main/Sources/AsyncAlgorithms/AsyncAlgorithms.docc/Guides/Throttle.md" data-wpel-link="external" target="_blank" rel="external noopener">throttle</a></code> from <a href="https://github.com/apple/swift-async-algorithms" data-wpel-link="external" target="_blank" rel="external noopener">swift-async-algorithms</a>?  I did, at first, and quickly discovered that its performance is <em>horrible</em>.  While I do suspect I can â€˜optimiseâ€™ it to not be atrocious, I havenâ€™t pursued that as it was easier to just write my own throttling system.</p>
</div></div>



<p>The above seems fairly straightforward, but if you run it and have any non-trivial I/O rate â€“ even just a few hundred kilobytes per second â€“ youâ€™ll find that it saturates an entire CPU core, not just wasting CPU time but limiting the I/O rate severely.</p>



<p>Using a <code>SuspendingClock</code> makes no difference.</p>



<p>In a nutshell, the problem is that Swiftâ€™s <code><a href="https://developer.apple.com/documentation/swift/clock" data-wpel-link="external" target="_blank" rel="external noopener">Clock</a></code> protocol has significant overheads by design.  If you look at a time profile of code like this, youâ€™ll see things like:</p>


<div>
<figure><img fetchpriority="high" decoding="async" width="900" height="716" src="https://wadetregaskis.com/wp-content/uploads/2024/05/ContinuousClock-overhead.webp" alt="Screenshot of Instruments showing the outline view for a Time Profile, expanded to show dozens of spurious, overhead functions taking up the vast majority of the runtime." srcset="https://wadetregaskis.com/wp-content/uploads/2024/05/ContinuousClock-overhead.webp 900w, https://wadetregaskis.com/wp-content/uploads/2024/05/ContinuousClock-overhead-256x204.webp 256w, https://wadetregaskis.com/wp-content/uploads/2024/05/ContinuousClock-overhead-768x611.webp 768w, https://wadetregaskis.com/wp-content/uploads/2024/05/ContinuousClock-overhead@2x.webp 1800w, https://wadetregaskis.com/wp-content/uploads/2024/05/ContinuousClock-overhead-256x204@2x.webp 512w" sizes="(max-width: 900px) 100vw, 900px"/></figure></div>


<p>Thatâ€™s a lot of time wasted in function calls and struct initialisation and type conversion and protocol witnesses and all that guff.  The only part thatâ€™s <em>actually</em> retrieving the time is the <code><a href="https://github.com/apple/swift/blob/625436af05b1cf8f1904096530235489daec9dac/stdlib/public/Concurrency/Clock.cpp#L30" data-wpel-link="external" target="_blank" rel="external noopener">swift_get_time</a></code> call (which is just a wrapper over <code><a href="https://www.manpagez.com/man/3/clock_gettime/" data-wpel-link="external" target="_blank" rel="external noopener">clock_gettime</a></code>, which is just a wrapper over <code><a href="https://www.manpagez.com/man/3/clock_gettime_nsec_np/" data-wpel-link="external" target="_blank" rel="external noopener">clock_gettime_nsec_np</a>(CLOCK_UPTIME_RAW)</code>, which is just a wrapper over <code><a href="https://developer.apple.com/documentation/kernel/1462446-mach_absolute_time" data-wpel-link="external" target="_blank" rel="external noopener">mach_absolute_time</a></code>).</p>



<p>I wrote <a href="https://github.com/wadetregaskis/Swift-Benchmarks/blob/main/Benchmarks/Clocks/Clocks.swift" data-wpel-link="external" target="_blank" rel="external noopener">some simple benchmarks of various alternative time-tracking methods</a>, with these results with Swift 5.10 (showing the median runtime of the benchmark, which is a million iterations of checking the time):</p>



<figure><table><thead><tr><th data-align="right">Method</th><th data-align="center">10-core iMac Pro</th><th data-align="center">M2 MacBook Air</th></tr></thead><tbody><tr><td data-align="right"><code><a href="https://developer.apple.com/documentation/swift/continuousclock" data-wpel-link="external" target="_blank" rel="external noopener">ContinuousClock</a></code></td><td data-align="center">429 ms</td><td data-align="center">258 ms</td></tr><tr><td data-align="right"><code><a href="https://developer.apple.com/documentation/swift/suspendingclock" data-wpel-link="external" target="_blank" rel="external noopener">SuspendingClock</a></code></td><td data-align="center">430 ms</td><td data-align="center">247 ms</td></tr><tr><td data-align="right"><code><a href="https://developer.apple.com/documentation/foundation/date" data-wpel-link="external" target="_blank" rel="external noopener">Date</a></code></td><td data-align="center">30 ms</td><td data-align="center">19 ms</td></tr><tr><td data-align="right"><code><a href="https://www.manpagez.com/man/3/clock_gettime_nsec_np/" data-wpel-link="external" target="_blank" rel="external noopener">clock_gettime_nsec_np(CLOCK_MONOTONIC_RAW)</a></code></td><td data-align="center">32 ms</td><td data-align="center">10 ms</td></tr><tr><td data-align="right"><code><a href="https://www.manpagez.com/man/3/clock_gettime_nsec_np/" data-wpel-link="external" target="_blank" rel="external noopener">clock_gettime_nsec_np(CLOCK_UPTIME_RAW)</a></code></td><td data-align="center">27 ms</td><td data-align="center">10 ms</td></tr><tr><td data-align="right"><code><a href="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man2/gettimeofday.2.html" data-wpel-link="external" target="_blank" rel="external noopener">gettimeofday</a></code></td><td data-align="center">24 ms</td><td data-align="center">12 ms</td></tr><tr><td data-align="right"><code><a href="https://developer.apple.com/documentation/kernel/1462446-mach_absolute_time" data-wpel-link="external" target="_blank" rel="external noopener">mach_absolute_time</a></code></td><td data-align="center">15 ms</td><td data-align="center">6 ms</td></tr></tbody></table></figure>



<p>All these alternative methods are <em>well</em> over an order of magnitude faster than Swiftâ€™s native clock APIs, showing just how dreadfully inefficient the Swift <code>Clock</code> API is.</p>



<h3><span id="mach_absolute_time_for_the_win">mach_absolute_time for the win</span></h3>



<p>Unsurprisingly, <code>mach_absolute_time</code> is the fastest.  It is what all these other APIs are actually based on; it is the lowest level of the time stack.</p>



<p>The downside to calling <code>mach_absolute_time</code> <em>directly</em>, though, is that <a href="https://developer.apple.com/documentation/kernel/1462446-mach_absolute_time#discussion" data-wpel-link="external" target="_blank" rel="external noopener">itâ€™s on Appleâ€™s â€œnaughtyâ€ list</a> â€“ apparently itâ€™s been abused for device fingerprinting, so Apple require you to beg for special permission if you want to use it (even though itâ€™s used by all these other APIs anyway, as the basis for their implementations, and thereâ€™s nothing you can get from <code>mach_absolute_time</code> that you canâ€™t get from them too ğŸ¤¨).</p>



<h3><span id="Date_surprisingly_not_bad"><code>Date</code> surprisingly not bad</span></h3>



<p>I was quite surprised to see good olâ€™ <code><a href="https://developer.apple.com/documentation/foundation/date" data-wpel-link="external" target="_blank" rel="external noopener">Date</a></code> performing competitively with the traditional C-level APIs, at least on x86-64. Even on arm64 itâ€™s not bad, at still a third to half the speed of the C APIs. This surprised me because <s>it has the overhead of at least one Objective-C message send (for <code><a href="https://developer.apple.com/documentation/foundation/date/1780473-timeintervalsincenow" data-wpel-link="external" target="_blank" rel="external noopener">timeIntervalSinceNow</a></code>), unless somehow the Swift compiler is optimising that into a static function call, or inlining it entirelyâ€¦?</s></p>



<div><div>
<p><strong>Update</strong>: I later looked at the disassembly, and found no message sends, only a plain function call to <code>Foundation.Date.timeIntervalSinceNow.getter</code> (which is only 40 instructions, on arm64, over <code>clock_gettime</code> and <code>__stack_chk_fail</code> â€“ and the former is hundreds of instructions, so itâ€™s adding relatively little overhead to the C API).</p>



<p>This isnâ€™t being done by the compiler, itâ€™s because <a href="https://github.com/apple/swift-foundation/blob/main/Sources/FoundationEssentials/Date.swift" data-wpel-link="external" target="_blank" rel="external noopener">thatâ€™s <em>actually</em> how itâ€™s implemented in Foundation</a>. I keep forgetting that Foundation from Swift is no longer just the old Objective-C Foundation, but rather mostly the <em>new</em> Foundation thatâ€™s written in native Swift. So these performance results likely donâ€™t apply once you go back far enough in Apple OS releases (to when Swift really was calling into the Objective-C code for <code>NSDate</code>) â€“ but itâ€™s safe to rely on good <code>Date</code> performance now and in future.</p>
</div></div>



<p>I certainly wouldnâ€™t be afraid to use <code>Date</code> broadly, going down to lower APIs only when truly necessary â€“ which is pretty rarely, Iâ€™d wager; weâ€™re talking a mere 19 to 30 <em>nanoseconds</em> to get the time elapsed since a reference date <em>and</em> compare it to a threshold. If thatâ€™s too slow, it might be an indication that thereâ€™s a bigger problem (like transferring data a single byte at a time, as in the example that started this post â€“ but more on that in <a href="https://wadetregaskis.com/urlsession-performance-for-reading-a-byte-stream/" data-wpel-link="internal">the next post</a>).</p>



<hr/>



<h3><span id="Follow-up">Follow-up</span></h3>



<p>This post <a href="https://news.ycombinator.com/item?id=40262897" data-wpel-link="external" target="_blank" rel="external noopener">got some attention on HackerNews</a>. Pleasingly, the comments there were almost all well-intentioned and interesting. Itâ€™s a bit beyond me to try to address all of them, but a few in particular raised good points that I would like to answer / clarify:</p>



<ul>
<li>A lot of folks were curious about <code>mach_absolute_time</code> being on Appleâ€™s naughty list. I donâ€™t know for sure why it is either, but I think itâ€™s very likely that itâ€™s <em>primarily</em> because it essentially provides a reference time point, thatâ€™s very precise and pretty unique between computers. Itâ€™s not the boot time necessarily â€“ because the timer pauses whenever the system is put to sleep â€“ but even so it provides a simple way to nearly if not exactly identify an individual machine session (between boots &amp; sleeps). It probably wouldnâ€™t take many other fingerprinting data points to reliably pin-point a specific machine.</li>



<li>Admittedly my phrasing regarding Appleâ€™s policies on <code>mach_absolute_time</code> â€“ â€œbeg for permission to use itâ€ â€“ is a little melodramatic.  Itâ€™s revealing something of my personal opinions on certain Apple â€œsecurityâ€ practices.  I love that Apple genuinely care about protecting everyoneâ€™s privacy, but sometimes I chaff at what feels like capricious or impractical specific policies.</li>



<li>A few folks looked at the example case, of iterating a single byte at a time, and were suspicious of how performant that could possibly be anyway. This is a very fair reaction â€“ itâ€™s my ingrained instinct as well, from years of C/C++/Objective-C â€“ <em>but</em> itâ€™s relying on a few outdated assumptions. <a href="https://wadetregaskis.com/urlsession-performance-for-reading-a-byte-stream/" data-wpel-link="internal">My next post</a> already covered this for the most part, but in short here:</li>



<li>Some folks noted that are a <em>lot</em> of other clock APIs from Appleâ€™s frameworks, like <code><a href="https://developer.apple.com/documentation/dispatch/dispatchtime" data-wpel-link="external" target="_blank" rel="external noopener">DispatchTime</a></code> and <code><a href="https://developer.apple.com/documentation/quartzcore/1395996-cacurrentmediatime" data-wpel-link="external" target="_blank" rel="external noopener">CACurrentMediaTime</a></code>.  I didnâ€™t include those in the benchmark because I just didnâ€™t think of them at the time.  If anyone wants to send me a pull request adding them to <a href="https://github.com/wadetregaskis/Swift-Benchmarks/blob/main/Benchmarks/Clocks/Clocks.swift" data-wpel-link="external" target="_blank" rel="external noopener">the code</a>, Iâ€™d be very happy to accept it.</li>



<li><a href="https://news.ycombinator.com/user?id=Kallikrates" data-wpel-link="external" target="_blank" rel="external noopener">Kallikrates</a> quietly pointed to a very interesting recent change in Appleâ€™s Swift standard library code, <a href="https://github.com/apple/swift/pull/73429" data-wpel-link="external" target="_blank" rel="external noopener">Make static [milli/micro/nano]seconds members on Duration inlinable</a>. Itâ€™s paired with <a href="https://github.com/apple/swift/pull/73419" data-wpel-link="external" target="_blank" rel="external noopener">another patch</a> that together seem very specifically aimed at eliminating some of the absurd overhead in Swiftâ€™s <code>ContinuousClock</code> &amp; <code>SuspendingClock</code> implementations. The timing is a bit interesting â€“ I donâ€™t know if they were prompted by this post, but itâ€™d be an unlikely coincidence otherwise.</li>
</ul>
		</div></div>
  </body>
</html>
