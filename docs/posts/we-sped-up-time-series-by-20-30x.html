<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.rerun.io/blog/primary-query-caching">Original</a>
    <h1>We sped up time series by 20-30x</h1>
    
    <div id="readability-page-1" class="page"><div id="__next"><div><div><div><p>This is a follow up post to the post <a href="https://www.rerun.io/blog/fast-plots">Real-time kHz time series in a multimodal visualizer</a> that dives into how we managed to achieve such huge performance gains for time series (among other things), and why it was so hard in the first place.</p>
<p><img src="https://www.rerun.io/blog/1M_series_before_v_after.png" alt="Before and after graph of time taken to draw a 1M point time series in Rerun"/></p>
<p><em>Comparison of time taken to draw a time series plot in Rerun with 1M points between version 0.12 and 0.13. The numbers come from profiling on a 2021 M1 MacBook Pro.</em></p>
<h2 id="flexible-multimodal-data-is-hard-to-combine-with-fast-plots">Flexible multimodal data is hard to combine with fast plots<!-- --> <a href="#flexible-multimodal-data-is-hard-to-combine-with-fast-plots"></a></h2>
<p>Ever since the first release of Rerun, plotting larger time series has been painfully slow.
<a href="https://github.com/rerun-io/rerun/releases/tag/0.13.0">0.13</a> is the first release where we think they&#39;re actually usable.
It’s worth taking a step back to explain why making plots fast in Rerun was hard, before getting into what we did about it.
To do that, we need some more background on how Rerun, the in-memory database, works.</p>
<h3 id="rerun-as-a-multimodal-time-series-database">Rerun as a multimodal time series database<!-- --> <a href="#rerun-as-a-multimodal-time-series-database"></a></h3>
<p>One way of looking at Rerun is as an in-memory multimodal time series database with visualization on top.</p>
<ul>
<li>You can throw many kinds of data at it, from simple metrics to big multi dimensional tensors, point clouds, and text documents.</li>
<li>Data is indexed along multiple user defined timelines, and can come in out of order.</li>
<li>The Rerun data model is a temporal Entity Component System (ECS) that allows updating single components at a time.</li>
</ul>
<p>Let&#39;s look at a small example of updating a colored point cloud in parts and out of order:</p>
<p><img src="https://www.rerun.io/blog/data-model-example.png" alt="Overview of Rerun&#39;s ECS updated out of order"/></p>
<p>For any given time point, the datastore needs to be able to collect the latest components of any entity, and join them against the primary component (3D positions in this case). Queries run every time Rerun renders a frame, which should be 60 times per second.</p>
<p>Getting all this to be both correct and fast took considerable effort during the first year of Rerun. The combination of all these features is what makes Rerun so versatile and easy to use.</p>
<p><iframe src="https://player.vimeo.com/video/910960113?autoplay=1&amp;loop=1&amp;autopause=0&amp;background=1&amp;muted=1&amp;ratio=1920:1080&amp;transparent=false&amp;dnt=1" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen=""></iframe></p>
<h3 id="overhead-from-flexibility-make-simple-time-series-the-worst-case">Overhead from flexibility make simple time series the worst case<!-- --> <a href="#overhead-from-flexibility-make-simple-time-series-the-worst-case"></a></h3>
<p>Flexibility comes at the cost of added overhead. That matters less for larger data, but dominates performance for small data like scalars. In Rerun, time series are created by querying the datastore for all scalars on an entity for a range of time.
Before 0.13, the worst case was therefore simple time series plots, since you&#39;d have to pay all that overhead many times for very little data.</p>
<h2 id="speeding-up-time-series-by-a-factor-of-2030">Speeding up time series by a factor of 20-30<!-- --> <a href="#speeding-up-time-series-by-a-factor-of-2030"></a></h2>
<p>On Rerun 0.12, rendering a single frame of a 1M point time series plot takes ~600ms on a 2021 M1 MacBook Pro. On 0.13 it takes ~20ms, a 30x speedup. For smaller series the speedup tends to come closer to 20x, which is still huge. How did we get there?</p>
<h3 id="sources-of-overhead-in-time-series-plots">Sources of overhead in time series plots<!-- --> <a href="#sources-of-overhead-in-time-series-plots"></a></h3>
<p>Let’s sum up the main sources of overhead in producing data for and rendering a time series plot:</p>
<ol>
<li><strong>Bookkeeping</strong>: Keeping track of which components exist at each timestamp is relatively costly for small data.</li>
<li><strong>Data locality</strong>: For small data, the flexible data model (both in time and data type) bottoms out in a lack of data locality, which is bad for CPU cache efficiency.</li>
<li><strong>Redundant work</strong>: When plotting a moving time window, data is usually only changing at the edges of the window. Repeatedly running the full range query creates lots of redundant work.</li>
<li><strong>Rendering</strong>: For large time series, there may be more points than pixels to draw them on along the time dimension (x-axis). This leads to redundant tessellation and overdraw in the rendering pipeline.</li>
</ol>
<h3 id="why-we-didnt-just-special-case-metrics">Why we didn&#39;t just special case metrics<!-- --> <a href="#why-we-didnt-just-special-case-metrics"></a></h3>
<p>The easiest solution for speeding up time series plots would be to special case the path for metrics. A specialized code path for simple metrics would make huge gains relatively easy.</p>
<p>Unfortunately this isn’t good enough because our users need good performance for more kinds of range queries. Here is an example using time ranges to show an aggregate point cloud in a structure from motion setting:</p>
<p><iframe src="https://player.vimeo.com/video/910977084?autoplay=1&amp;loop=1&amp;autopause=0&amp;background=1&amp;muted=1&amp;ratio=1920:1080&amp;transparent=false&amp;dnt=1" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen=""></iframe></p>
<p>In addition, our motivating example for kHz plots was <a href="https://en.wikipedia.org/wiki/Inertial_measurement_unit">IMU</a> samples, which usually come as messages containing multiple values to plot. That makes special casing the single metrics less useful. For example:</p>
<pre><p><code><span>typedef</span> <span>struct</span> <span>{</span>
    <span>float</span> acc<span>[</span><span>3</span><span>]</span><span>;</span>

    <span>float</span> gyro<span>[</span><span>3</span><span>]</span><span>;</span>  
    
    <span>unsigned</span> <span>long</span> timestamp<span>;</span>
<span>}</span> IMUSample<span>;</span>
</code></p></pre>
<p>Rerun doesn’t yet support visualizing time series from single fields of larger structs directly, but we will soon and our approach needs to support this as a first class use-case.</p>
<h3 id="caching-is-difficult-but-necessary">Caching is difficult but necessary<!-- --> <a href="#caching-is-difficult-but-necessary"></a></h3>
<blockquote>
<p>There are only two hard things in Computer Science: cache invalidation and naming things.</p>
<p>Phil Karlton</p>
</blockquote>
<p>The non-rendering sources of overhead just scream caching, but as usual the devil is in the details, in particular the details of cache invalidation. In our case, out of order insertions combined with composing multiple components over time make invalidation particularly gnarly.</p>
<h3 id="datastore-changelogs-make-invalidation-manageable">Datastore changelogs make invalidation manageable<!-- --> <a href="#datastore-changelogs-make-invalidation-manageable"></a></h3>
<p>Except for garbage collection (dropping old data to free up memory), the Rerun datastore is immutable. Data is always dropped through snapshotting so that query semantics are left unchanged. Every single change results in adding or removing rows to the store.</p>
<p>The first step we took after deciding it was time for caching was a refactor that turned every system that maintains a derived dataset in Rerun (timeline widget, view heuristics engine, etc) into a store subscriber, which listens to changelogs of added or removed rows in the datastore.</p>
<p>Cache invalidation is yet another store subscriber, and having this protocol in place is what made it manageable to deal with all the complexity.</p>
<h3 id="caches-are-built-lazily-at-query-time">Caches are built lazily at query time<!-- --> <a href="#caches-are-built-lazily-at-query-time"></a></h3>
<p>Cache invalidation only sets a dirty flag. Actually building the cache happens lazily at query time. Since Rerun uses an end to end immediate mode architecture, we query the datastore on every frame, ideally 60 times per second.</p>
<p>This acts as a natural micro-batching mechanism where we first accumulate changes while we render the current frame and then handle all these changes at the start of the next frame. Batching updates like this is great for performance.</p>
<p>Visible views query the datastore right before rendering. Building caches lazily therefore means we never spend time updating a cache that isn’t used.</p>
<h3 id="multitenancy-requires-fine-grained-locking">Multi-tenancy requires fine grained locking<!-- --> <a href="#multitenancy-requires-fine-grained-locking"></a></h3>
<p>When not on the web, each space view (draggable visualization panel) runs and queries the datastore in parallel. Many of these queries might overlap so we need to make sure to share data and cache resources appropriately.</p>
<p>Supporting this multi-tenancy requires fine grained locking on the combination of store (there are multiple), entity, set of components, and the component “point of view” (the component we join against).</p>
<h3 id="aggregating-subpixel-points-speeds-up-rendering">Aggregating sub-pixel points speeds up rendering<!-- --> <a href="#aggregating-subpixel-points-speeds-up-rendering"></a></h3>
<p>There are only so many pixels available to draw on along the x-axis. For large time series, that means you need to aggregate points that would show up on the same x-axis tick to avoid overdraw and redundant tessellation in the render pipeline.</p>
<p><iframe src="https://player.vimeo.com/video/910983296?autoplay=1&amp;loop=1&amp;autopause=0&amp;background=1&amp;muted=1&amp;ratio=1920:1080&amp;transparent=false&amp;dnt=1" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen=""></iframe></p>
<p>We compute these aggregations on every frame and let users choose between a set of basic options.</p>
<h3 id="a-caveat-on-performance-for-out-of-order-logs">A caveat on performance for out of order logs<!-- --> <a href="#a-caveat-on-performance-for-out-of-order-logs"></a></h3>
<p>The speedups added in 0.13 slow down ingestion speed for out of order logs.
In practice this only matters for scalars logged out of order at high frequency,
but it does mean that live time series plots are slow in this case.
An update that fixes this is planned for 0.13.1.
Follow the progress <a href="https://github.com/rerun-io/rerun/issues/4810">here</a>.</p>
<h2 id="huge-wins-already-but-there-is-more-to-be-had">Huge wins already but there is more to be had<!-- --> <a href="#huge-wins-already-but-there-is-more-to-be-had"></a></h2>
<p>Adding a caching layer to the Rerun datastore has taken lots of effort over the last months, but the performance gains are clearly worth the added complexity.</p>
<p>There are still lots of gains to be had by adding secondary caches on top, for scalars and other data. For example, slowly changing 3D geometry could be cached on the GPU to avoid redundant CPU -&gt; GPU transfers, which are currently the performance bottleneck for point clouds.</p>
<p>Join us on <a href="https://github.com/rerun-io/rerun">Github</a> or <a href="https://discord.gg/PXtCgFBSmH">Discord</a>
and let us know what if these performance improvement made a difference for you,
and what areas you&#39;d love to see us speed up next.</p></div></div></div></div></div>
  </body>
</html>
