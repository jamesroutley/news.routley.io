<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/908026/6284e31d9060a6ec/">Original</a>
    <h1>The road to Zettalinux</h1>
    
    <div id="readability-page-1" class="page"><p>

<h2>[LWN subscriber-only content]</h2>
</p><div>
<!-- $Id: slink-none,v 1.2 2005-11-04 22:11:18 corbet Exp $ -->
<blockquote>
<div>
<h3>Welcome to LWN.net</h3>
<p>
The following subscription-only content has been made available to you 
by an LWN subscriber.  Thousands of subscribers depend on LWN for the 
best news from the Linux and free software communities.  If you enjoy this 
article, please consider <a href="https://lwn.net/subscribe/">subscribing to LWN</a>.  Thank you
for visiting LWN.net!
</p></div>
</blockquote>
<p>
Nobody should need more memory than a 64-bit pointer can address — or so
developers tend to think.  The range covered by a pointer of that size
seems to be nearly infinite.  During the Kernel Summit track at the <a href="https://lpc.events/">2022 Linux Plumbers Conference</a>, Matthew
Wilcox took the stage to make the point that 64 bits may turn out to
be too few — and sooner than we think.  It is not too early to start
planning for 128-bit Linux systems, which he termed &#34;ZettaLinux&#34;, and we
don&#39;t want to find ourselves wishing we&#39;d started sooner.
</p><p>
The old-timers in the audience, he said, are likely to have painful
memories of the 32-bit to 64-bit transition, which happened in the
mid-1990s.  The driving factor at the time was file sizes, which were
growing beyond the 2GB that could be represented with signed, 32-bit
numbers.  The Large File
Summit in 1995 worked out <a href="https://www.opengroup.org/platform/lfs.html">the mechanisms</a>
(&#34;lots of dreadful things&#34;) for 
handling larger files.  Developers had to add the new <tt>lloff_t</tt> size
for 64-bit file sizes and the <a href="https://man7.org/linux/man-pages/man2/llseek.2.html"><tt>llseek()</tt>
system call</a> to move around 
in large files.  Wilcox said that he would really prefer not to see an
<tt>lllseek()</tt> for 128-bit offsets.
</p><p>
<a href="https://lwn.net/Articles/908089/"><img src="https://static.lwn.net/images/conf/2022/lpc/MatthewWilcox-sm.png" alt="[Matthew Wilcox]" title="Matthew Wilcox"/></a>

Similarly, he does not want to see the equivalent of
<tt>CONFIG_HIGHMEM</tt> on 128-bit systems.  The <a href="https://lwn.net/Articles/813201/">&#34;high memory&#34; concept</a> was
created to support (relatively) large amounts of memory on 32-bit systems.
The inability to address all of physical memory with a 32-bit address means
that the kernel had to explicitly map memory before accessing it and unmap it
afterward.  
Vendors are still shipping a few systems that need high memory, but it only
represents
a cost for 64-bit machines.  Linux should transition to 128-bits before
the 64-bit limitation falls behind
memory sizes and forces us to recreate high memory.
</p><p>
The solution, he said, is to move to CPUs with 128-bit registers.
Processors back to the Pentium series have supported registers of that
size, but they are special-purpose registers, not the general-purpose registers
we will need.  Looking at industry projections, Wilcox estimated that we
would need 128-bit file-size values around 2040; he would like to see
operating-system support for that in place by 2035.  Address spaces are
likely to grow beyond 64 bits around 2035 as well, so everything seems
to be converging on that date.
</p><p>
That said, he has talked with security-oriented developers who say that
2035 is far too late; 128-bit pointers are needed now.  Address-space
layout randomization, by changing the placement of objects in the virtual
address space, is essentially using address-space bits for security; the
more bits it has, the more effective that security is.  When huge pages are
in use, the number of available bits is low; 128-bit pointers would be
helpful here.  Similarly, technologies like <a href="https://lwn.net/Articles/902094/">linear address masking</a> and <a href="https://lwn.net/Articles/834289/">memory tagging</a> need more address bits to be
truly effective.  The experimental <a href="https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/">CHERI
architecture</a> is using 12<b>9</b>-bit pointers now.
</p><p>
How would this look in the kernel?  Wilcox had originally thought that, on
a 128-bit system, an <tt>int</tt> should be 32 bits, <tt>long</tt>
would be 64 bits, and both <tt>long long</tt> and pointer types would
be 128 bits.  But that runs afoul of deeply rooted assumptions in the
kernel that <tt>long</tt> has the same size as the CPU&#39;s registers, and
that <tt>long</tt> can also hold a pointer value.  The conclusion is that
<tt>long</tt> must be a 128-bit type.
</p><p>
The problem now is that there is no 64-bit type in the mix.  One solution
might be to &#34;ask the compiler folks&#34; to provide a <tt>__int64_t</tt> type.
But a better solution might just be to switch to Rust types, where
<tt>i32</tt> is a 32-bit, signed integer, while <tt>u128</tt> would be
unsigned and 128 bits.  This convention is close to what the kernel
uses already internally, though a switch from &#34;<tt>s</tt>&#34; to &#34;<tt>i</tt>&#34; for
signed types would be necessary.  Rust has all the types we need, he said,
it would be best to just switch to them.
</p><p>
The system-call ABI is going to need thought as well.  There are a lot of
64-bit pointer values passed between the kernel and user space in the
current ABI.  Wilcox

suggested defining a new <tt>__ptr_t</tt> type to hold pointers at the
user-space boundary; he said it should be sized at 256 bits.  That&#39;s
more than the 128 bits needed now, but gives room for any surprising future
needs, and &#34;it&#39;s only memory&#34; in the end.
</p><p>
Another problem is that, currently, the kernel only supports one
compatibility personality, which is 
most often used to run 32-bit binaries on 64-bit systems.  That will need
to be fixed to be able to support both 32-bit and 64-bit applications on a
128-bit kernel.  There are also many places in the kernel that are
explicitly checking whether integers are 64-bits wide; those will all need
to be tracked down and fixed to handle the 128-bit case too.
</p><p>
All this sounds like a lot of work, he said, but in the end it&#39;s just
porting Linux to a new architecture, and that has been done many times
before.
</p><p>
Ben Herrenschmidt said that, if he were in Wilcox&#39;s shoes, he would
automate the generation of the compatibility definitions to minimize
potential problems going forward.  Wilcox answered:
&#34;In <i>my</i> shoes?&#34;.  His next slide, labeled &#34;next steps&#34;, started with
the need to find somebody to lead this effort.  He said he would do it if
he had to, but would rather somebody else did it.  His hope was that Arnd
Bergmann would step up to the task, &#34;not that I don&#39;t like Arnd&#34;.  Other
steps include actually getting a 128-bit system to develop on; there is
currently the beginning of a 128-bit extension defined for RISC-V that
could be a starting point, probably via QEMU emulation initially.
</p><p>
Bergmann appeared briefly on the remote feed to point out that the problem
can be broken into two parts: running the kernel with 128-bit pointers,
and supporting a 128-bit user space.  He suggested starting by just
supporting the user-space side while keeping the kernel at 64 bits as
a way to simplify the problem.  Wilcox said he hadn&#39;t thought of that, but
that it could be an interesting approach.  Whichever approach is taken, he
concluded, the community should get started to avoid repeating the most
painful parts of the 64-bit transition.  There is, he said, still time to
get the job done.
</p><p>
[Thanks to LWN subscribers for supporting my travel to this event.]</p>
               </div></div>
  </body>
</html>
