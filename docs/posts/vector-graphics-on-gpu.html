<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gasiulis.name/vector-graphics-on-gpu/">Original</a>
    <h1>Vector graphics on GPU</h1>
    
    <div id="readability-page-1" class="page"><article>
			
			<p>Despite vector graphics being used in every computer with a screen connected to it, rendering of vector shapes and text is still mostly a task for the CPU. This is wrong and needs to be changed. Here I describe a general approach to rasterization and how we can ask for help from GPU when rendering vector paths.</p>
			<h2>Basic rasterization operation.</h2>
			<p>First, let&#39;s overview a general principle of rasterization of vector shapes. Here is an image with a clockwise circle in it and I&#39;ll demonstrate a very rudimentary algorithm for drawing one row of pixels of that image. For simplicity reasons, anti-aliasing will not be included at this time.</p>
			<img src="https://gasiulis.name/vector-graphics-on-gpu/demo-shape.svg"/>
			<p>For each pixel in this row we only need to know if its center is inside of this shape or outside. Outside pixels are left untouched while inside pixels are filled with color of that shape.</p>
			<p>We start with a <i>winding number</i> set to zero. Winding number is an integer which indicates whether the pixel center is inside or outside of shape.</p>
			<p>Next imagine a horizontal ray being cast through centers of all pixels in this pixel row. Ray goes from infinity on the left side to infinity on the right side. Every time an intersection with an upward segment is found, the winding number is increased by 1. When an intersection is found with a downward segment, the winding number is decreased by 1. As we go from one pixel to another, left to right, if the current winding number at the center of each pixel is zero, the pixel is not visible. If it is something else, the pixel is filled according to the fill rule. For example, for the non-zero fill rule, all pixels with a winding number other than zero are filled with color.</p>
			<img src="https://gasiulis.name/vector-graphics-on-gpu/winding-numbers.svg"/>
			<p>In this picture the circle is drawn clockwise, but if it was drawn counterclockwise, the intersection on the left would result in the winding number decreasing by 1 instead of increasing it.</p>
			<img src="https://gasiulis.name/vector-graphics-on-gpu/winding-numbers-ccw.svg"/>
			<p>Now, pixel centers between both intersections have winding numbers of -1, but according to the non-zero winding rule, they are filled the same way as for a clockwise circle.</p>
			<p>Note that intersections are found while ray travels from left to right so they are automatically sorted by X position of each intersection.</p>
			<p>Repeat the same operation for each row of pixels of the output image and in the end the image will be complete.</p>
			<p>Of course, state of the art rasterizers have a lot of optimisations and actual algorithms may look very different from this, but the basic idea is the same and it works for Bézier paths of any complexity.</p>
			<h2>Now do this on GPU.</h2>
			<p>Unfortunately, GPUs work a bit differently from CPUs. CPU is like one person reading a book. You start at page 1 and read all the pages one by one, in order. But if you read books like me, it may take up to 6 years to finish one book. So you come up with a faster way. You hire 14.000 people to read that book, each reading a single line from it in parallel. They finish in about 8 seconds, but there are new challenges. You need to find a way to quickly assign which line to read to which person and when they finish, they somehow need to tell you the whole story in order. They cannot all speak at the same time randomly. This is the kind of challenges you face when programming for GPUs.</p>
			<p>GPUs are extremely parallel. They can run thousands of threads at the same time. For example, the original Apple M1 GPU can execute 24.576 threads in parallel. Ideally, data should be prepared for the GPU in such a way all these threads can work with small amounts of information and produce even smaller output of fixed size. This is not a requirement, especially for more modern GPUs, but I like to keep it simple because of my deep distrust in graphics drivers.</p>
			<h2>Rasterize one pixel at a time.</h2>
			<p>An intuitive way to do rasterization on GPU is one pixel at a time. Screens contain a lot of pixels and GPUs can run a lot of threads. So it looks like each pixel can be processed in parallel.</p>
			<p>To do this, we need to modify the algorithm to work on each pixel separately instead of processing each shape and each segment of it in order in a single thread.</p>
			<p>Now, for each pixel, go over all segments of a shape and if a segment intersects with this imaginary horizontal line going through the center of that pixel, the winding number is modified. Only intersections on the left side of the pixel center need to be considered. Intersections on the right side of the pixel center can be completely ignored. The order in which segments are processed does not matter.</p>
			<img src="https://gasiulis.name/vector-graphics-on-gpu/pixel-rendering.svg"/>
			<p>In this example there is only one intersection to the left of the highlighted pixel center. So if we were rendering it, this intersection would be contributing to the final winding number of this pixel by increasing it by one.</p>
			<p>After processing all intersections on the left side of the pixel center, the final winding number is used to determine if a pixel needs to be filled according to the fill rule of that shape.</p>
			<h2>Add anti-aliasing.</h2>
		    <p>Up to this point anti-aliasing was not introduced to rasterizer for simplicity reasons. But having sharp edges of shapes has a 1995 vibe to it. People demand smooth pixels in 2022. Fortunately there are methods that can be used to achieve smooth edges without heavily modifying the entire rasterizer.</p>
		    <h2>Supersampling.</h2>
		    <p>One of the simplest methods for anti-aliasing is <a href="https://en.wikipedia.org/wiki/Supersampling">Supersampling</a>. It does not require modifying the rasterizer at all. The idea is to draw the image at a bigger resolution first, then scale the result back to desired size. While scaling down, an average of a few pixels will produce a single output pixel, making it look smooth. Supersampling, however, has a few problems. The biggest problem is that it is extremely expensive. If we wanted to achieve somewhat decent quality, we would have to render at size 4 times the original size in both directions. This means rendering 16 times larger image and taking an average of 16 pixels to produce one pixel in the final image. This means 16 times more memory and at least 16 times longer to render image. And in the end, 16 levels is not that good. A lot of people will quickly notice the low quality of anti-aliasing at the edges of shapes with only 16 samples per pixel.</p>
		    <h2>Analytic anti-aliasing.</h2>
		    <p>Much better approach for vector graphics is analytic anti-aliasing. And it turns out, it is not just almost as fast as a rasterizer with no anti-aliasing, but also has much better quality than what can be practically achieved with supersampling. It requires small changes to the rasterization algorithm, but nothing fundamental.</p>
		    <p>I introduced the concept of winding number for deciding if a pixel is inside the shape or not. This concept can be extended to also include information about how much pixel is covered by shape, not just binary covered or not covered.</p>
		    <p>The value indicating how shape is contributing to the coverage of a pixel will be called <i>alpha</i> from now on. Just like winding number, alpha is not the same as pixel <i>opacity</i>. It will need to be converted to opacity according to the fill rule.</p>
		    <p>From here I will assume floating point arithmetic will be used and pixel size is 1.0 × 1.0. 100% of something is equal to 1.0, 50% is equal to 0.5.</p>
		    <p>To calculate alpha for any given pixel, there are two values that need to be calculated for each segment of a shape. First value is <i>cover</i> and another is called <i>area</i>. If a segment is on the right edge of a pixel, none of these values need calculation. Obviously, if the segment is below or above the pixel, computation is not needed either. The remaining situation is when the segment is in the pixel, on the left of the pixel or both. Area value is calculated for a part of the segment which intersects with the pixel being rendered. Cover value is calculated for a part of the segment which is to the left of the pixel. Once both of these values are calculated for a segment, they are added to the final alpha value. Once all segments in a shape are considered, the final alpha value is converted to pixel opacity according to the fill rule of that shape.</p>
		    <h2>Calculating area and cover values.</h2>
		    <p>Here is an example of how to calculate area and cover values for the highlighted pixel. The shape being drawn is the same clockwise circle, but now we are drawing a pixel which is located somewhere at the top left side of this shape.</p>
		    <img src="https://gasiulis.name/vector-graphics-on-gpu/aa-1.svg"/>
		    <p>First step is to find the part of the ellipse which will be contributing to the alpha value of this pixel. We are only interested in the segment which is one the left from the right edge of our pixel.</p>
		    <img src="https://gasiulis.name/vector-graphics-on-gpu/aa-2.svg"/>
		    <p>Now calculate the area. Find a segment which is within our pixel only. Cut off any parts of the segment that are outside of the pixel. And calculate the area that is to the right of the segment. For segments that go down instead of going up, area value is negated.</p>
		    <img src="https://gasiulis.name/vector-graphics-on-gpu/aa-3.svg"/>
		    <p>To calculate cover, isolate the part of the segment which is to the left of our pixel, but is still in between the top and bottom edges of the pixel row. Then multiply <i>a</i> value is calculated by subtracting the minimum Y value of the isolated segment from maximum Y value of the isolated segment. Like with area, if a segment goes down instead of up, cover value is negated. In this particular case, <i>a</i> is around 0.45 and pixel size is 1.0. So the cover value is 0.45.</p>
		    <img src="https://gasiulis.name/vector-graphics-on-gpu/aa-4.svg"/>
		    <p>Note that cover needs to be calculated for all segments which are to the left of the pixel and between top and bottom edges of the pixel, even if they do not intersect with the pixel at all.</p>
		    <p>Once both area and cover values are calculated, they are added to alpha value. Here is an illustration of both area and cover values combined for this case.</p>
		    <img src="https://gasiulis.name/vector-graphics-on-gpu/aa-5.svg"/>
		    <p>Then repeat the process for all segments of a shape, continuously accumulating their area and cover values. In the end we will have a final alpha value. Now alpha value must be converted to opacity according to the fill rule of a shape. If the fill rule is non-zero, alpha is calculated by using formula <i>min(abs(alpha), 1.0)</i>. If the fill rule is even-odd, the formula is <i>abs(alpha - 2.0 × round(0.5 × alpha))</i>. Resulting opacity value is in the range from 0.0 to 1.0.</p>
		    <p>I first discovered this algorithm in <a href="https://gitlab.freedesktop.org/freetype/freetype/-/blob/master/src/smooth/ftgrays.c">FreeType</a> which cites <a href="https://www.levien.com/libart">LibArt</a> as inspiration. Some form of the same algorithm with various modifications is used pretty much on every computer now.</p>
		    <h2>Summary.</h2>
		    <p>At this point we can rasterize shapes on GPU with very good quality anti-aliasing.</p>
		    <p>The following algorithm is run in parallel for every pixel on screen -</p>
		    <ul>
		    	<li>Initialize pixel color to transparent black.</li>
		    	<li>For each shape in shape list do the following -</li>
		    	<ul>
		    		<li>Initialize floating point value alpha to zero.</li>
		    		<li>Go over all segments in shape and compute area and cover values continuously adding them to alpha value.</li>
		    		<li>Convert alpha value to opacity.</li>
		    		<li>Multiply color of a shape by opacity.</li>
		    		<li>Blend resulting color with current pixel color.</li>
		    	</ul>
		    	<li>Write current pixel value to destination image.</li>
		    </ul>
		    <p>For small amounts of small shapes this approach will be extremely fast. However, it will become slower when more shapes are added due to the increasing amount of segments that need to be processed at each pixel. To make this renderer usable in the real world, some fundamental changes need to be made. We have to reduce the amount of segments that require processing for each pixel. The simplest way is to divide the screen into smaller lists of segments and process only this reduced list of segments for each pixel.</p>
			<h2>Divide input into smaller chunks.</h2>
			<p>Let&#39;s split the entire destination area to virtual fixed size blocks. The size of these blocks do not depend on threadgroup size or SIMD group size. Since the renderer will be splitting segments at block boundaries, larger blocks will require less CPU processing power to cut segments, but will require more processing power on GPU to rasterize segments within a block. It is always best to choose some nice round number. I chose <span>32 × 32</span> pixels.</p>
			<img src="https://gasiulis.name/vector-graphics-on-gpu/block-origin.svg"/>
			<p>The origin of the first block is always at 0, 0 relative to the destination image. If the destination image is not multiple of 32, the last block is still <span>32 × 32</span> pixels size and extends a little beyond the image.</p>
			<h2>What is in the block.</h2>
			<p>Each block contains two main things. First, there is a list of shapes that intersect with a block. Each shape comes with a list of segments that make that shape. Second, there is a cover table. This is all that is needed to draw a pixel.</p>
			<img src="https://gasiulis.name/vector-graphics-on-gpu/block-anatomy.svg"/>
			<ul>
				<li>Cover table. Each shape that intersects with a block gets it. It is one 32 bit value for each pixel row of a block. If the block is 32 pixels high, the cover table is 32 values. Cover table keeps information about how pixel coverage is affected by the same path in all blocks to the left of this one.</li>
				<li>An array of shapes that intersect this block along with all segments that fall into this block. This is a two dimensional array. It is an array of shapes that intersect with a block. And for each shape there is a list of segments from that shape that intersect with a block. In the case demonstrated by the picture above, the block only has one shape.</li>
			</ul>
			<h2>Cover table.</h2>
			<p>Previously I mentioned cover value and how it is calculated when implementing anti-aliasing. This is the same. We only have a list of segments which intersect with a block our pixel is in. Cover table carries cover information from previous blocks on the left side of a block our random pixel is in.</p>
			<p>Cover table is needed because we do not know anything about shapes or segments outside of any given block, but segments outside of the block can still contribute to coverage of pixels within the block.</p>
			<h2>Final algorithm.</h2>
			<p>At this point, most of the things we need are there. Let&#39;s overview the full process.</p>
			<h2>Prepare blocks on CPU.</h2>
			<p>For each shape in composition do the following -</p>
			<ul>
				<li>Find all blocks which intersect with shape. If no intersecting blocks are found, this shape is ignored.</li>
				<li>For each block which intersects with shape, do the following -</li>
				<ul>
					<li>Add a new shape element to the shape list of that block. This new shape now becomes the current shape.</li>
					<li>Find shape segments which intersect with that block.</li>
					<li>Clip each shape segment to fit entirely within the block.</li>
					<li>Discard all segments which are completely horizontal.</li>
					<li>Add the resulting segment to the segment array of current shape.</li>
				</ul>
			</ul>
			<p>Lastly, calculate cover table values for each shape in each block by examining contents of blocks to the left.</p>
			<p>Now the work on the CPU is done. Data can be uploaded to the GPU now.</p>
			<h2>Dispatch one thread for each pixel to run on GPU.</h2>
			<p>The following algorithm is run in parallel for every pixel on screen -</p>
			<ul>
				<li>Initialize pixel color to transparent black.</li>
				<li>Find block for destination pixel. Given the screen position of a pixel, find a block that intersects with that pixel. If block size is <span>32 × 32</span>, this is simply two integer shifts to the right by 5. And you have row and column indices to a block.</li>
				<li>For each shape in shape list of the block do the following -</li>
				<ul>
					<li>Initialize floating point value alpha to corresponding value from cover table. Value is found by using Y position relative to block as table index.</li>
					<li>Go over all segments in shape and compute area and cover values continuously adding them to alpha value.</li>
					<li>Convert alpha value to opacity.</li>
					<li>Multiply color of a shape by opacity.</li>
					<li>Blend resulting color with current pixel color.</li>
				</ul>
				<li>Write current pixel value to destination image.</li>
		    </ul>
		    <p>This is it.</p>
		    <p>Now I&#39;ll write some thoughts about certain parts of the pipeline and what I discovered so far.</p>
		    <h2>What is a segment?</h2>
		    <p>In this article I talk about shapes being made of segments. But what exactly is this segment? The answer is that it does not matter much. The simplest to handle are simple line segments. Hardest are cubic curves. And there can be everything in-between like quadratic curves or monotonic cubic curves.</p>
		    <p>In my implementation I use simple lines encoded as <span>8.8</span> fixed point numbers. Since block size is <span>32 × 32</span> pixels, <span>8.8</span> fixed point numbers are enough to describe lines with <span>1/256th</span> of a pixel precision. Using this encoding, one line segment can be described using only 64 bits. It also makes shader which then processes these lines simpler. It can operate on 16 bit integers quite far in the algorithm until it needs higher precision.</p>
		    <p>Monotonic quadratic curves are also tempting thing to try. You would need to find up to 2 roots of a quadratic curve to get a line which then can be used to calculate cover and area values. For input which is mostly curves, not lines, having segments encoded as curves may save some space and iteration over the list of segments in the shader will be shorter. However, if input is mostly lines, it will add cost to processing and memory requirements. So far, I&#39;m sticking with simple line segments.</p>
		    <h2>SIMD group configuration is important.</h2>
		    <p>Once you ask the GPU to dispatch a list of threads, it divides them into thread groups. Each thread group has a list of threads to run. And threads within thread groups are further divided into SIMD groups. The last one is significant because every time the code path is diverging within the SIMD group, the shader will run longer because it will have to execute both sides of a branch.</p>
		    <p>Given that, a very good performance optimization is not to try to reject segments on the X axis in the shader. Rejecting segments which are below or above current pixel boundaries is fine. Rejecting segments which are to the right of the current pixel will most likely increase shader execution time.</p>
		    <p>Another point is to choose thread group size which has width equal to SIMD group on that hardware to make sure that within the thread group, SIMD group is only 1 row of pixels.</p>
		    <h2>Calculate vertical bounds of shapes.</h2>
		    <p>It is good to skip entire shapes in the shader and avoid processing of segments within. Again, since block size is <span>32 × 32</span> pixels, the bounding box can be only two 8 bit values. Only vertical minimum and maximum values are enough. As I said before, I do not attempt to reject shapes by X pixel position to avoid diverging branches within SIMD groups, but rejecting them by Y position gives a good performance boost.</p>
		    <h2>Why not prepare blocks on the GPU too?</h2>
		    <p>This certainly can be achieved as demonstrated by brilliant <a href="https://github.com/linebender/piet-gpu">piet-gpu</a>. However, it requires more advanced features of GPU compute than I&#39;d like. In the simple approach where blocks are prepared on CPU, there is only one GPU kernel dispatch. The simplest kernel which renders shapes with solid color is about 80 lines of code. Easy to fix and extend. I managed to optimize block preparation on CPU quite well and this preparation step is predictable while allocating memory. I think it is quite well balanced.</p>
		    <h2>Other work.</h2>
		    <p>Primary inspiration for me to try rendering vector graphics on GPU was <a href="https://github.com/linebender/piet-metal">piet-metal</a>. The next generation of concept is <a href="https://github.com/linebender/piet-gpu">piet-gpu</a>. It seems like it went to the opposite direction than my implementation and now it attempts to do everything on GPU, including flattening of shapes to individual segments. The method presented in <a href="http://kunzhou.net/zjugaps/pathrendering/">Efficient GPU Path Rendering Using Scanline Rasterization</a> is very interesting. Although a bit too complex for my taste since it relies on prefix sum calculation and sorting, both of which are not particularly trivial to do on GPU. <a href="https://github.com/servo/pathfinder">Pathfinder</a> is quite interesting as well and I suspect it is very similar to what I described here, but I have not attempted to figure out how it works exactly. Then there is <a href="https://sluglibrary.com">Slug</a> which is popular library for rendering scalable text for games. Algorithm seems to be patented.</p>
		    <h2>Conclusion.</h2>
		    <p>Overall I really like this approach of giving the GPU to perform some of the steps of rasterization. The most expensive elements of vector graphics rendering are blending, finding which pixels to fill and calculating fill colors. Calculating fill colors can become really expensive if shapes are filled with images using a bilinear filter. Radial gradients can become not so cheap as well for the CPU to process. So the most expensive parts are run on GPU already.</p>
		    <p>Trying to come up with an exact number of milliseconds spent in an attempt to compare approaches is a more or less pointless task in my opinion. However, compared to rendering exactly the same input with heavily optimized software renderer, GPU-assisted version is 10-15 times faster. Image fills is the place with the biggest performance boost. I think this is a good start.</p>
		</article></div>
  </body>
</html>
