<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.mattkeeter.com/blog/2022-08-11-udp/">Original</a>
    <h1>From Oscilloscope to Wireshark: A UDP Story</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
<!-- End header -->








<h2>From Oscilloscope to Wireshark: A UDP Story</h2>
<p><a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>
is a transport-level protocol for sending messages through an IP network.</p>
<p>It sits at level 4 in the <a href="https://en.wikipedia.org/wiki/OSI_model">OSI model</a>:</p>
<table>
<tbody><tr><td>7</td><td>Application
</td></tr><tr><td>6</td><td>Presentation
</td></tr><tr><td>5</td><td>Session
</td></tr><tr><td><b>4</b></td><td><b>Transport
</b></td></tr><tr><td>3</td><td>Network
</td></tr><tr><td>2</td><td>Data link
</td></tr><tr><td>1</td><td>Physical
</td></tr></tbody></table>
<p>Like many of you, I&#39;ve got hardware on my desk that&#39;s sending UDP packets, and
the time has come to take a closer look at them.</p>
<p>Most &#34;low-level&#34; networking tutorials
will bottom out somewhere at &#34;use <a href="https://www.tcpdump.org/"><code>tcpdump</code></a> to see
raw packets&#34;.
We&#39;ll be starting a bit lower in the stack; specifically, <em>here</em>:</p>
<div>
<p><a href="https://humanprogramming.substack.com/p/probes_full.jpg"><img alt="Probes soldered to a circuit board" src="https://humanprogramming.substack.com/p/probes.jpg"/></a></p></div>
<p>This is a <a href="https://www.tek.com/en/datasheet/trimode(tm)-probe-family-1">high-speed active differential probe</a>
soldered to an <a href="https://oxide.computer">Oxide Computer Company</a> rack switch.
We&#39;re going <strong>all the way down</strong> to the metal.</p>
<p>(Huge thanks to <a href="https://twitter.com/random_enginerd">Eric</a> for the careful
soldering that made this possible!)</p>
<p>Looking at the signals on an oscilloscope, we see data zooming down the wires:</p>
<p><a href="https://humanprogramming.substack.com/p/scope_full.jpg"><img alt="Oscilloscope showing bits at 5 GHz" src="https://humanprogramming.substack.com/p/scope.jpg"/></a></p>
<p>The rest of this post will take us from these raw voltage waveforms all the
way to decoded UDP packets.  Hold on tight, we&#39;re going from L1 all the way to
L4.</p>
<hr/>
<h3>First, a bit of context</h3>
<p>I work at Oxide Computer Company, writing
<a href="https://github.com/oxidecomputer/hubris">embedded software</a>
for the
<a href="https://oxide.computer/product">rack-scale computer</a>.</p>
<p>Over the past few months, I&#39;ve been focused on the <strong>management network</strong>,
which is a low-speed network between each server&#39;s Service Processor.
The service processor is roughly equivalent to a
<a href="https://en.wikipedia.org/wiki/Intelligent_Platform_Management_Interface#Baseboard_management_controller">baseboard management controller</a>;
it allows for lights-out management of the rack.</p>
<p>The heart of the management network is the
<a href="https://www.microchip.com/en-us/product/VSC7448">VSC7448</a>,
a 52-port, 80G ethernet switch chip.  This is the <em>slower</em> switch, and it&#39;s
still a beast; here&#39;s the dev kit:</p>
<div>
<p><img alt="Very large 48-port ethernet switch dev kit" src="https://humanprogramming.substack.com/p/switch.jpg"/></p></div>
<p>This decoding work was part of tracking down a nasty bug which caused a
subset of links to only work <em>some</em> of the time.  The root cause turned out to
be a
<a href="https://github.com/oxidecomputer/hubris/blob/7cace18d40bbea96d1ccd7a5e65e8ed740d62021/task/monorail-server/src/bsp/sidecar_1.rs#L209-L228">misconfiguration of the switch IC</a>,
but the hunt was an interesting dive into the physical layer of modern
networking.</p>
<hr/>
<h3>Loading the waveforms</h3>
<p>That&#39;s enough context, back to work!</p>
<p>The oscilloscope doesn&#39;t have a built-in QSGMII analyzer (and we&#39;ll want to do
fairly sophisticated processing of the data), so I wanted to export waveform
data to my computer.</p>
<p>How much data should I capture?
Analog waveforms can easily add up to multiple gigabytes,
so I&#39;d like to capture a small amount while still catching a packet or two.</p>
<p>I knew that a device on the network was emitting about 30K UDP packets per
second, or one packet every 33 µs.  I configured the oscilloscope to collect
100M samples at 1 TSPS (tera-sample per second, 10<sup>12</sup>), which
multiplies out to 100 µs of data; this means we should catch 1-3 UDP packets.</p>
<p>After hunting down a USB key, I ended up with a 191M <code>.wfm</code> file to process.</p>
<p>Fortunately, the <code>.wfm</code> file format is
<a href="https://download.tek.com/manual/Waveform-File-Format-Manual-077022011.pdf">documented by Tektronix</a>.</p>
<p>In about 400 lines of code, I implemented
<a href="https://github.com/oxidecomputer/wfm-to-qsgmii/blob/main/src/wfm.rs">a simple parser</a>
using
<a href="https://github.com/Geal/nom"><code>nom</code></a>
(which has great support for this kind of binary format).
The parser is overkill: it decodes the entire file based on the specification.
In practice, we only care about two things:</p>
<ul>
<li>The sample waveform (which is an array of <code>i16</code>)</li>
<li>The sample rate (in seconds per sample)</li>
</ul>
<p>It&#39;s also possible to write a decoder in three lines of Python,
once you know where the data stream starts in the file:</p>
<pre><code>import numpy as np
data = open(&#39;udp-spam.wfm&#39;, &#39;rb&#39;).read()
pts = np.frombuffer(data[904:-1], dtype=np.int16)
</code></pre>
<p>Plotting a chunk of this data,
it looks like what I was seeing on the oscilloscope:</p>
<p><img src="https://humanprogramming.substack.com/p/raw_data.svg" alt="A chunk of raw data from an oscilloscope"/></p>
<p>Now, we have to figure out what it means.</p>
<h3>QSGMII for dummies</h3>
<p>Thinking back to the probes soldered to our PCB,
we are probing the link between the main VSC7448 switch and a
<a href="https://www.microchip.com/en-us/product/VSC8504">VSC8504 PHY</a>.
The PHY is acting as a port expander: it&#39;s taking four ports from the switch
(combined into a single Tx/Rx channel), and splitting them into four separate
channels.</p>
<p><img src="https://humanprogramming.substack.com/p/diagram.png" alt="Network diagram"/><br/>
</p>
<p>(This is only necessary because the VSC7448 does not have enough pins to drive
all 52 of its ports directly)</p>
<p>The link between the switch and the PHY is using <strong>QSGMII</strong>,
which stands for
<a href="https://en.wikipedia.org/wiki/Media-independent_interface#Serial_gigabit_media-independent_interface">quad serial gigabit media-independent interface</a>.
QSGMII is a protocol for communication between a Media Access Control (MAC)
block and an ethernet PHY.</p>
<p>Specifically, QSGMII is a way to pack four SGMII channels into a single Tx/Rx
pair (hence the &#34;quad&#34;), running 4× as fast (5 GBPS instead of 1.25 GBPS)</p>
<p>The <a href="https://archive.org/details/sgmii">SGMII</a> and
<a href="https://community.nxp.com/pwmxy87654/attachments/pwmxy87654/powerquicc/3546/1/qsgmii%20specification.pdf">QSGMII standards</a>
are both freely available,
and are both quite readable (especially compared to
<a href="https://en.wikipedia.org/wiki/IEEE_802.3">IEEE 802.3-2015</a>).</p>
<p>Let&#39;s start with the encoding.</p>
<h3>8b/10b decoding</h3>
<p>Both SGMII and QSGMII use <a href="https://en.wikipedia.org/wiki/8b/10b_encoding">8b/10b encoding</a>,
which is a way to pack a stream of (8-bit) bytes into 10-bit &#34;code-groups&#34;
(sometimes called &#34;symbols&#34;) with various desirable properties:</p>
<ul>
<li>On average, there are the same number of 0s and 1s in the stream</li>
<li>There are enough bit transitions to recover the clock</li>
</ul>
<p>The code-groups are all smushed together, so when you look at the raw data,
it&#39;s not obvious where code-groups begin or end.</p>
<p>To recover the code-group framing, we need to look for <strong>comma characters</strong>,
which are characters of the form <code>1100000</code> or <code>0011111</code>.  These are (almost) the
only characters which have five 0s or 1s in a row.</p>
<p>First, let&#39;s convert the <code>i16</code> values to binary:</p>
<pre><code>let pts: Vec&lt;bool&gt; = t.pts.iter().map(|p| *p &lt; 0).collect();
</code></pre>
<p>Next, we&#39;ll start by picking out places where the signal changes from 0 to 1 or
vice versa:</p>
<pre><code>let crossings = pts.iter()
    .zip(&amp;pts[1..])
    .enumerate()
    .filter(|(_, (a, b))| a != b)
    .map(|(i, _)| i)
    .collect()
</code></pre>
<p>We know our sample rate (1 TPSP) and the nominal QSGMII bit rate (5 GHz);
this means that a single-bit pulse (e.g. <code>010</code>) should be a 200-sample
pulse.  In turn, we expect a comma character to be roughly 1000 samples long
(200 × 5).</p>
<p>Here&#39;s a chunk of data (normalized to 0-1); can you spot the comma character?</p>
<p><img src="https://humanprogramming.substack.com/p/comma_where.svg" alt="A QSGMII waveform"/></p>
<p>We can detect comma characters by picking out places where the signal doesn&#39;t
change for &gt; 900 samples, i.e. 4.5 bit lengths:</p>
<pre><code>// We detect a potential comma if there are &gt;= 4.5 bit lengths between
// transitions, since a comma has 5 identical bits in a row.
let comma_length = samples_per_clock * 9 / 2;
let commas = crossings
    .iter()
    .zip(&amp;crossings[1..])
    .filter(|&amp;(a, b)| b - a &gt;= comma_length)
    .map(|(a, _b)| *a - samples_per_clock * 2)
    .filter(|a| {
        // A comma is either 0011111 or 1100000.  We detected the crossing
        // at the beginning of the 11111 or 00000 run, so we backed up by
        // two clock periods (in the `map` above).  Now, we advance by by
        // 1/2 clock period to land in the middle of the bit.
        let i = a + samples_per_clock / 2;
        let mut value = 0;
        for j in 0..7 {
            value = (value &lt;&lt; 1) | (pts[i + j * samples_per_clock] as u16);
        }
        value == 0b1100000 || value == 0b0011111
    })
    .collect();
</code></pre>
<p>(Notice that we check for <code>0011111</code>/<code>1100000</code>, not just <code>11111</code>/<code>00000</code>; certain
other data patterns can produce a run of 5 identical bits, but lack the leading
<code>00</code>/<code>11</code>)</p>
<p>The comma character is right here in our data:</p>
<p><img src="https://humanprogramming.substack.com/p/comma_there.svg" alt="QSGMII trace with comma highlighted"/></p>
<p>(I&#39;m going to stop showing the analog trace now, to keep the graphs readable)</p>
<p>Once synchronized with the comma character, we know that bits are spaced at
the bit sample rate, so we can read the 10-bit code-group.  In this case, it&#39;s
<code>1100000101</code>:</p>
<p><img src="https://humanprogramming.substack.com/p/comma_cg.svg" alt="QSGMII trace with comma and bits shown"/></p>
<p>However, it&#39;s not <em>quite</em> that easy!</p>
<p>The oscilloscope and switch may not have <em>exactly</em> the same clock rate.
If we go a long time between comma characters, we may end up sampling at the
wrong position in the waveform!</p>
<p>It turns out that we need to synchronize in two places:</p>
<ul>
<li>Comma characters tell us when a new code-group starts</li>
<li>Bit transitions help us keep the clock in sync</li>
</ul>
<p>Here&#39;s what that looks like:</p>
<pre><code>// The comma iterator points to the bit transition at the beginning of the
// comma codegroup, i.e. 0011111 or 1100000
let mut iter_comma = commas.iter().cloned().peekable();

// Index at which to sample the data.  We start at a half-cycle offset from
// the bit transition at the beginning of the comma character.
let mut i = iter_comma.next().unwrap() + samples_per_clock / 2;

// The zero-crossing iterator points to bit transitions, so we can stay in
// sync even if it&#39;s been a long time since the last comma character.
let mut iter_cross =
    crossings.iter().cloned().filter(move |c| *c &gt; i).peekable();

let mut bit = 0;
let mut value: u16 = 0;
let mut cgs = vec![];
while i &lt; pts.len() {
    // Resynchronize based on bit transitions
    if let Some(&amp;j) = iter_cross.peek() {
        if i &gt; j {
            i = j + samples_per_clock / 2;
            iter_cross.next();
        }
    }
    // Resynchronize and reset on comma characters
    if let Some(&amp;j) = iter_comma.peek() {
        if i &gt; j {
            i = j + samples_per_clock / 2;
            if bit != 0 {
                warn!(&#34;Off-sync comma character at {j} ({})&#34;, cgs.len());
            }
            bit = 0;
            value = 0;
            iter_comma.next();
        }
    }

    value = (value &lt;&lt; 1) | (pts[i] as u16);
    bit += 1;
    i += samples_per_clock;
    if bit == 10 {
        cgs.push(value);
        bit = 0;
        value = 0;
    }
}
</code></pre>
<p>This gives us a <code>Vec&lt;u16&gt;</code>, with each item storing a 10-bit code-group.
To convert to actual code-groups, we just need a <strong>huge</strong> look-up table:</p>
<pre><code>#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum Codegroup {
    D0_0,
    D1_0,
    D2_0,
    D3_0,
    D4_0,
    // etc...
    K23_7,
    K27_7,
    K29_7,
    K30_7,
}

impl TryFrom&lt;u16&gt; for Codegroup {
    type Error = ();
    fn try_from(value: u16) -&gt; Result&lt;Self, Self::Error&gt; {
        use Codegroup::*;
        let out = match value {
            0b100111_0100 | 0b011000_1011 =&gt; D0_0,
            0b011101_0100 | 0b100010_1011 =&gt; D1_0,
            0b101101_0100 | 0b010010_1011 =&gt; D2_0,
            // etc...
            0b110110_1000 | 0b001001_0111 =&gt; K27_7,
            0b101110_1000 | 0b010001_0111 =&gt; K29_7,
            0b011110_1000 | 0b100001_0111 =&gt; K30_7,
            _ =&gt; return Err(()),
        };
        Ok(out)
    }
}
</code></pre>
<p>At this point, we&#39;ve gone from raw voltage readings to a stream of codegroups.
Here&#39;s a few dozen samples from the stream:</p>
<pre><code><span>K28.5</span>
<span>D24.2</span>
<span>K23.7</span>
<span>D24.2</span>
<span>D16.2</span>
<span>D24.2</span>
<span>K28.1</span>
<span>D24.2</span>
<span>K28.5</span>
<span>D24.2</span>
<span>D16.2</span>
<span>D24.2</span>
<span>D16.2</span>
<span>K29.7</span>
<span>K28.1</span>
<span>K29.7</span>
<span>K28.5</span>
<span>K23.7</span>
<span>D16.2</span>
<span>K23.7</span>
<span>D16.2</span>
<span>K28.5</span>
<span>K28.1</span>
<span>K28.5</span>
</code>
</pre>
<p>If you&#39;ve done any low-level networking, some of this may be starting to look
familiar!</p>
<h3>Separating the streams</h3>
<p>Remember that QSGMII combines four separate SGMII streams into a single physical
link.  How does this work, and how do we distinguish them?</p>
<p>Let&#39;s go to the QSGMII standard:</p>
<p><img src="https://humanprogramming.substack.com/p/qsgmii_swap.png" alt="QSGMII PCS diagram"/></p>
<p>Code-groups from the individual ports are interleaved in order by the
demultiplexer in the center of the diagram, so we&#39;d expect to see</p>
<pre><code>port0, port1, port2, port3, port0, port1, port2, port3, ...
</code></pre>
<p>To uniquely identify Port 0, QSGMII uses the &#34;K28.5 swapper&#34;, shown in the
diagram right before the demultiplexer: <code>K28.5</code> is replaced with <code>K28.1</code> for
Port 0.</p>
<p>This works because <code>K28.5</code> appears frequently in SGMII traffic: it&#39;s part of the
idle pattern and also used for start / end of packet delimiters.</p>
<p>By detecting this code-group, we can split the data into four streams:</p>
<pre><code>// Split the codegroups into separate streams for each channel
let mut channel: Option&lt;usize&gt; = None;
let mut streams: [Vec&lt;Codegroup&gt;; 4] = Default::default();
for (i, mut cg) in cgs.iter().cloned().enumerate() {
    // Detect the K28.1 sync character
    if cg == Codegroup::K28_1 {
        if channel.map(|c| c != 0).unwrap_or(false) {
            warn!(&#34;Out of sync K28.1 at codegroup {}&#34;, i);
        }
        channel = Some(0);
        cg = Codegroup::K28_5; // Unswap K28.1 -&gt; K28.5
    }
    // Only record codegroups after we&#39;ve found Port 0
    if let Some(c) = channel.as_mut() {
        streams[*c].push(cg);
        *c = (*c + 1) % 4;
    }
}
</code></pre>
<p>Starting at the first <code>K28.1</code>, we now have four per-port streams:</p>
<pre><code>Port 0 | Port 1 | Port 2 | Port 3
-------|--------|--------|-------
<span>K28.1</span>  | <span>D24.2</span>  | <span>K28.5</span>  | <span>D24.2</span>
<span>D16.2</span>  | <span>D24.2</span>  | <span>D16.2</span>  | <span>K29.7</span>
<span>K28.1</span>  | <span>K29.7</span>  | <span>K28.5</span>  | <span |="">K23.7</span>
<span>D16.2</span>  | <span>K23.7</span>  | <span>D16.2</span>  | <span>K28.5</span>
<span>K28.1</span>  | <span>K28.5</span>  | <span>K28.5</span>  | <span>D16.2</span>
<span>D16.2</span>  | <span>D16.2</span>  | <span>D16.2</span>  | <span>K28.5</span>
<span>K28.1</span>  | <span>K28.5</span>  | <span>K28.5</span>  | <span>D16.2</span>
<span>D16.2</span>  | <span>D16.2</span>  | <span>D16.2</span>  | <span>K28.5</span>
<span>K28.1</span>  | <span>K28.5</span>  | <span>K28.5</span>  | <span>D16.2</span>
<span>D16.2</span>  | <span>D16.2</span>  | <span>D16.2</span>  | <span>K28.5</span>
</code></pre>
<h3>From code-groups to packets</h3>
<p>We&#39;re getting closer!  The next step is turning this stream of code-groups into
packets.  To understand how this works, we&#39;ll consult IEEE 802.3-2015, the
IEEE Standard for Ethernet:</p>
<p><img src="https://humanprogramming.substack.com/p/table.png" alt="Table showing codegroups and how they map to ordered sets"/></p>
<p>This table defines a mapping from code-groups to &#34;ordered sets&#34;.  We can create
a few more types, then write a decoder:</p>
<pre><code>#[derive(Copy, Clone, Debug, Eq, PartialEq)]
enum OrderedSet {
    Configuration(Codegroup, Codegroup),
    Idle,
    CarrierExtend,
    StartOfPacket,
    EndOfPacket,
    ErrorPropagation,
    LinkPartnerIdle,
}

enum Pcs {
    OrderedSet(OrderedSet),
    Data(u8),
}

/// Decodes a set of codegroups into PCS-level control and data
fn decode(cgs: &amp;[Codegroup]) -&gt; Vec&lt;Pcs&gt; {
    let mut cg_iter = cgs.iter().cloned();
    let mut pcs = vec![];
    while let Some(cg) = cg_iter.next() {
        // Table 36–3
        let s = match cg {
            Codegroup::K28_5 =&gt; match read_k28_5(&amp;mut cg_iter) {
                Some(c) =&gt; Pcs::OrderedSet(c),
                None =&gt; break,
            },
            Codegroup::K23_7 =&gt; Pcs::OrderedSet(OrderedSet::CarrierExtend),
            Codegroup::K27_7 =&gt; Pcs::OrderedSet(OrderedSet::StartOfPacket),
            Codegroup::K29_7 =&gt; Pcs::OrderedSet(OrderedSet::EndOfPacket),
            Codegroup::K30_7 =&gt; Pcs::OrderedSet(OrderedSet::ErrorPropagation),
            d =&gt; {
                if !d.is_data() {
                    warn!(&#34;Unexpected special codegroup: {:?}&#34;, d);
                    continue;
                }
                Pcs::Data(u8::from(d))
            }
        };
        pcs.push(s);
    }
    pcs
}

/// Reads the data that follows a K28.5 codegroup, forming an ordered set
///
/// Returns `None` if the stream terminates.
fn read_k28_5(
    mut iter: impl Iterator&lt;Item = Codegroup&gt;
) -&gt; Option&lt;OrderedSet&gt; {
    let out = match iter.next()? {
        Codegroup::D21_5 | Codegroup::D2_2 =&gt; {
            let d1 = iter.next()?;
            let d2 = iter.next()?;
            if !d1.is_data() {
                warn!(&#34;Unexpected special codegroup: {:?}&#34;, d1);
            }
            if !d2.is_data() {
                warn!(&#34;Unexpected special codegroup: {:?}&#34;, d2);
            }
            OrderedSet::Configuration(d1, d2)
        }

        Codegroup::D5_6 | Codegroup::D16_2 =&gt; OrderedSet::Idle,
        Codegroup::D6_5 | Codegroup::D26_4 =&gt; OrderedSet::LinkPartnerIdle,
        c =&gt; {
            // &#34;A received ordered set that consists of two
            //  code-groups, the first of which is /K28.5/ and the
            //  second of which is a data code-group other than
            //  /D21.5/ or /D2.2/ (or /D6.5/ or /D26.4/ to support
            //  EEE capability), is treated as an /I/ ordered set.&#34;
            //  [36.2.4.12]
            warn!(&#34;Unexpected codegroup after K28.5: {:?}&#34;, c);
            OrderedSet::Idle
        }
    };
    Some(out)
}
</code></pre>
<p>Printing the decoded results for port 0, we&#39;re <strong>almost there</strong>:</p>
<pre><code><span>/I/</span> 
<span>/S/</span>
55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 d5 d5 d5 d5 d5 d5 d5 d5 d5 d5 33 33 33 33 33 33 33 33 33 33 33 33 33 33 33 33 33 33 33 33 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 01 01 01 01 01 01 01 01 01 0e 0e 0e 0e 0e 0e 0e 0e 0e 0e 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d f3 f3 f3 f3 f3 f3 f3 f3 f3 f3 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 9d 9d 9d 9d 9d 9d 9d 9d 9d 9d 24 24 24 24 24 24 24 24 24 24 86 86 86 86 86 86 86 86 86 86 dd dd dd dd dd dd dd dd dd dd 60 60 60 60 60 60 60 60 60 60 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 10 10 10 10 10 10 10 10 10 10 11 11 11 11 11 11 11 11 11 11 40 40 40 40 40 40 40 40 40 40 fe fe fe fe fe fe fe fe fe fe 80 80 80 80 80 80 80 80 80 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d f3 f3 f3 f3 f3 f3 f3 f3 f3 f3 ff ff ff ff ff ff ff ff ff ff fe fe fe fe fe fe fe fe fe fe 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 9d 9d 9d 9d 9d 9d 9d 9d 9d 9d 24 24 24 24 24 24 24 24 24 24 ff ff ff ff ff ff ff ff ff ff 02 02 02 02 02 02 02 02 02 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 01 01 01 01 01 01 01 01 01 03 03 03 03 03 03 03 03 03 03 e5 e5 e5 e5 e5 e5 e5 e5 e5 e5 00 00 00 00 00 00 00 00 00 00 08 08 08 08 08 08 08 08 08 08 00 00 00 00 00 00 00 00 00 00 10 10 10 10 10 10 10 10 10 10 52 52 52 52 52 52 52 52 52 52 aa aa aa aa aa aa aa aa aa aa 01 01 01 01 01 01 01 01 01 01 02 02 02 02 02 02 02 02 02 02 03 03 03 03 03 03 03 03 03 03 04 04 04 04 04 04 04 04 04 04 05 05 05 05 05 05 05 05 05 05 06 06 06 06 06 06 06 06 06 06 07 07 07 07 07 07 07 07 07 07 08 08 08 08 08 08 08 08 08 08 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 30 30 30 30 30 30 30 30 30 30 02 02 02 02 02 02 02 02 02 02 58 58 58 58 58 58 58 58 58 58
<span>/T/</span>
<span>/R/</span>
<span>/I/</span> 
<span>/S/</span>
55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 d5 d5 d5 d5 d5 d5 d5 d5 d5 d5 33 33 33 33 33 33 33 33 33 33 33 33 33 33 33 33 33 33 33 33 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 01 01 01 01 01 01 01 01 01 0e 0e 0e 0e 0e 0e 0e 0e 0e 0e 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d f3 f3 f3 f3 f3 f3 f3 f3 f3 f3 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 9d 9d 9d 9d 9d 9d 9d 9d 9d 9d 24 24 24 24 24 24 24 24 24 24 86 86 86 86 86 86 86 86 86 86 dd dd dd dd dd dd dd dd dd dd 60 60 60 60 60 60 60 60 60 60 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 10 10 10 10 10 10 10 10 10 10 11 11 11 11 11 11 11 11 11 11 40 40 40 40 40 40 40 40 40 40 fe fe fe fe fe fe fe fe fe fe 80 80 80 80 80 80 80 80 80 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0c 0c 0c 0c 0c 0c 0c 0c 0c 0c 1d 1d 1d 1d 1d 1d 1d 1d 1d 1d f3 f3 f3 f3 f3 f3 f3 f3 f3 f3 ff ff ff ff ff ff ff ff ff ff fe fe fe fe fe fe fe fe fe fe 5c 5c 5c 5c 5c 5c 5c 5c 5c 5c 9d 9d 9d 9d 9d 9d 9d 9d 9d 9d 24 24 24 24 24 24 24 24 24 24 ff ff ff ff ff ff ff ff ff ff 02 02 02 02 02 02 02 02 02 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 01 01 01 01 01 01 01 01 01 03 03 03 03 03 03 03 03 03 03 e5 e5 e5 e5 e5 e5 e5 e5 e5 e5 00 00 00 00 00 00 00 00 00 00 08 08 08 08 08 08 08 08 08 08 00 00 00 00 00 00 00 00 00 00 10 10 10 10 10 10 10 10 10 10 52 52 52 52 52 52 52 52 52 52 aa aa aa aa aa aa aa aa aa aa 01 01 01 01 01 01 01 01 01 01 02 02 02 02 02 02 02 02 02 02 03 03 03 03 03 03 03 03 03 03 04 04 04 04 04 04 04 04 04 04 05 05 05 05 05 05 05 05 05 05 06 06 06 06 06 06 06 06 06 06 07 07 07 07 07 07 07 07 07 07 08 08 08 08 08 08 08 08 08 08 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e 30 30 30 30 30 30 30 30 30 30 02 02 02 02 02 02 02 02 02 02 58 58 58 58 58 58 58 58 58 58
<span>/T/</span>
<span>/R/</span>
<span>/I/</span> 
</code></pre>
<p>There&#39;s a repeating pattern here:</p>
<ul>
<li>Repeated idle characters (<code>/I/</code>)</li>
<li>Start of packet (<code>/S/</code>)</li>
<li>Packet data (beginning with <code>55 55 55...</code>)</li>
<li>End of packet (<code>/T/</code>)</li>
<li>Carrier extend (<code>/R/</code>)</li>
</ul>
<p>The packet data is a bit curious, though.  <code>0x55</code> is part of the ethernet frame
<a href="https://en.wikipedia.org/wiki/Ethernet_frame#Preamble_and_start_frame_delimiter">preamble</a>,
but it should only appear 7 times, not... 69.</p>
<p>It turns out there&#39;s a simple explanation: this link is running at 100M mode,
but (Q)SGMII only runs at gigabit speeds.  Rate adaption is a simple matter
of repeating each byte 10x, with the first <code>/S/</code> replacing one instance of
<code>D0</code>:</p>
<p><img src="https://humanprogramming.substack.com/p/100m.png" alt="Diagram from QSGMII Specification showing 100 Mbit mode"/></p>
<p>Taking every 10th byte from the packet data, we see something very promising:</p>
<pre><code><span>/I/</span> 
<span>/S/</span>
55 55 55 55 55 55 55 d5 33 33 00 00 00 01 0e 1d f3 5c 9d 24 86 dd 60 00 00 00 00 10 11 40 fe 80 00 00 00 00 00 00 0c 1d f3 ff fe 5c 9d 24 ff 02 00 00 00 00 00 00 00 00 00 00 00 00 00 01 03 e5 00 08 00 10 52 aa 01 02 03 04 05 06 07 08 1e 30 02 58
<span>/T/</span>
<span>/R/</span>
<span>/I/</span> 
<span>/S/</span>
55 55 55 55 55 55 55 d5 33 33 00 00 00 01 0e 1d f3 5c 9d 24 86 dd 60 00 00 00 00 10 11 40 fe 80 00 00 00 00 00 00 0c 1d f3 ff fe 5c 9d 24 ff 02 00 00 00 00 00 00 00 00 00 00 00 00 00 01 03 e5 00 08 00 10 52 aa 01 02 03 04 05 06 07 08 1e 30 02 58
<span>/T/</span>
<span>/R/</span>
<span>/I/</span> 
</code></pre>
<p>Delimited by start and end markers, we see data beginning with</p>
<pre><code>55 55 55 55 55 55 55 d5
</code></pre>
<p>which is the ethernet frame preamble!</p>
<p>Continuing to decode the ethernet frame with our eyes:</p>
<ul>
<li>The destination MAC address is <code>33:33:00:00:00:01</code>, an IPv6 <a href="https://www.ietf.org/proceedings/65/slides/16ng-3/sld5.htm">&#34;all-nodes&#34; multicast address</a></li>
<li>The source MAC address is <code>0e:1d:f3:5c:9d:24</code></li>
<li>The ethertype is <code>0x86DD</code>, which indicates IPv6</li>
</ul>
<p>We&#39;ve finally made it to the ethernet frame level!</p>
<h3>Storing and analyzing packets</h3>
<p>Decoding ethernet frames with our eyes gets old fast.</p>
<p>Luckily, there are lots of good tools for working with frame data.  Using
the <a href="https://crates.io/crates/pcap"><code>pcap</code> library</a>,
we can write out a <code>.pcap</code> file to be analyzed with
<a href="https://www.wireshark.org/">Wireshark</a>.</p>
<p>Here&#39;s our full analyzer, going from <code>.wfm</code> to four <code>.pcap</code> files:</p>
<pre><code>$ cargo run --release -- udp-spam.wfm
[2022-08-08T13:22:35Z <span>INFO</span>  qsgmii] Opening udp-spam.wfm
[2022-08-08T13:22:36Z <span>INFO</span>  qsgmii] Loaded 100000000 samples
[2022-08-08T13:22:36Z <span>INFO</span>  qsgmii] Found 290319 crossings
[2022-08-08T13:22:36Z <span>INFO</span>  qsgmii] Using 200 samples per QSGMII clock
[2022-08-08T13:22:36Z <span>INFO</span>  qsgmii] Found 21596 commas
[2022-08-08T13:22:36Z <span>INFO</span>  qsgmii] Found 49776 code-groups
[2022-08-08T13:22:36Z <span>WARN</span>  qsgmii] Skipping short packet []
[2022-08-08T13:22:36Z <span>WARN</span>  qsgmii] Skipping short packet []
[2022-08-08T13:22:36Z <span>INFO</span>  qsgmii] Wrote 2 packets from port 0 to out.pcap.0
[2022-08-08T13:22:36Z <span>WARN</span>  qsgmii] Skipping short packet []
[2022-08-08T13:22:36Z <span>WARN</span>  qsgmii] Skipping short packet []
[2022-08-08T13:22:36Z <span>INFO</span>  qsgmii] Wrote 2 packets from port 1 to out.pcap.1
[2022-08-08T13:22:36Z <span>WARN</span>  qsgmii] Skipping short packet []
[2022-08-08T13:22:36Z <span>WARN</span>  qsgmii] Skipping short packet []
[2022-08-08T13:22:36Z <span>INFO</span>  qsgmii] Wrote 2 packets from port 2 to out.pcap.2
[2022-08-08T13:22:36Z <span>WARN</span>  qsgmii] Skipping short packet []
[2022-08-08T13:22:36Z <span>WARN</span>  qsgmii] Skipping short packet []
[2022-08-08T13:22:36Z <span>INFO</span>  qsgmii] Wrote 2 packets from port 3 to out.pcap.3
</code></pre>
<p>The whole pipeline – from loading the <code>.wfm</code> to writing the <code>.pcap</code> file –
runs in about 410 milliseconds on my computer.  Considering I put no effort
into optimization, this isn&#39;t too bad!</p>
<p>Using <code>tshark</code>, we can confirm that these are UDP packets:</p>
<pre><code>$ tshark -r out.pcap.0
    1   0.000000 fe80::c1d:f3ff:fe5c:9d24 → ff02::1      UDP 82 997 → 8 Len=8
    2   0.000000 fe80::c1d:f3ff:fe5c:9d24 → ff02::1      UDP 82 997 → 8 Len=8
</code></pre>
<p>At this point, we&#39;ve entered the realm of conventional packet-handling
tools.  For example, using <code>tshark -V</code>, we can get a (very) verbose explanation
of the packets:</p>
<pre><code>$ tshark -V -r out.pcap.0
Frame 1: 82 bytes on wire (656 bits), 82 bytes captured (656 bits)
    Encapsulation type: Ethernet (1)
    Arrival Time: Aug  8, 2022 09:22:36.372717000 EDT
    [Time shift for this packet: 0.000000000 seconds]
    Epoch Time: 1659964956.372717000 seconds
    [Time delta from previous captured frame: 0.000000000 seconds]
    [Time delta from previous displayed frame: 0.000000000 seconds]
    [Time since reference or first frame: 0.000000000 seconds]
    Frame Number: 1
    Frame Length: 82 bytes (656 bits)
    Capture Length: 82 bytes (656 bits)
    [Frame is marked: False]
    [Frame is ignored: False]
    [Protocols in frame: eth:ethertype:ipv6:udp:data]
Ethernet II, Src: 0e:1d:f3:5c:9d:24 (0e:1d:f3:5c:9d:24), Dst: IPv6mcast_01 (33:33:00:00:00:01)
    Destination: IPv6mcast_01 (33:33:00:00:00:01)
        Address: IPv6mcast_01 (33:33:00:00:00:01)
        .... ..1. .... .... .... .... = LG bit: Locally administered address (this is NOT the factory default)
        .... ...1 .... .... .... .... = IG bit: Group address (multicast/broadcast)
    Source: 0e:1d:f3:5c:9d:24 (0e:1d:f3:5c:9d:24)
        Address: 0e:1d:f3:5c:9d:24 (0e:1d:f3:5c:9d:24)
        .... ..1. .... .... .... .... = LG bit: Locally administered address (this is NOT the factory default)
        .... ...0 .... .... .... .... = IG bit: Individual address (unicast)
    Type: IPv6 (0x86dd)
    Trailer: 1e3002580c01009b
    Frame check sequence: 0x00000c01 [unverified]
    [FCS Status: Unverified]
Internet Protocol Version 6, Src: fe80::c1d:f3ff:fe5c:9d24, Dst: ff02::1
    0110 .... = Version: 6
    .... 0000 0000 .... .... .... .... .... = Traffic Class: 0x00 (DSCP: CS0, ECN: Not-ECT)
        .... 0000 00.. .... .... .... .... .... = Differentiated Services Codepoint: Default (0)
        .... .... ..00 .... .... .... .... .... = Explicit Congestion Notification: Not ECN-Capable Transport (0)
    .... 0000 0000 0000 0000 0000 = Flow Label: 0x00000
    Payload Length: 16
    Next Header: UDP (17)
    Hop Limit: 64
    Source Address: fe80::c1d:f3ff:fe5c:9d24
    Destination Address: ff02::1
User Datagram Protocol, Src Port: 997, Dst Port: 8
    Source Port: 997
    Destination Port: 8
    Length: 16
    Checksum: 0x52aa [unverified]
    [Checksum Status: Unverified]
    [Stream index: 0]
    [Timestamps]
        [Time since first frame: 0.000000000 seconds]
        [Time since previous frame: 0.000000000 seconds]
    UDP payload (8 bytes)
Data (8 bytes)

0000  01 02 03 04 05 06 07 08                           ........
    Data: 0102030405060708
    [Length: 8]
</code></pre>
<p>These are the UDP packets I was looking for!</p>
<p><strong>Misson accomplished.</strong></p>
<hr/>
<p>Thanks to <a href="https://twitter.com/random_enginerd">Eric</a>,
<a href="https://twitter.com/arjenroodselaar">Arjen</a>,
<a href="https://github.com/refugeesus">RFK</a>,
and everyone else at Oxide that helped with this investigation!</p>
<p>As further reading,
<a href="https://www.liveaction.com/resources/glossary/gigabit-ethernet-and-fibre-channel-technology/">&#34;Gigabit Ethernet and Fibre Channel Technology&#34;</a>
describes the physical and data link layers in great detail.</p>
<p>For a less home-brew workflow, check out
<a href="https://twitter.com/azonenberg/">Andrew Zonenberg</a>&#39;s
excellent work on
<a href="https://github.com/glscopeclient/scopehal-apps"><code>glscopeclient</code></a>,
which can now do this kind of
<a href="https://twitter.com/azonenberg/status/1556060569345486848">QSGMII decoding</a>.</p>

<!-- Begin footer -->
</div></div>
  </body>
</html>
