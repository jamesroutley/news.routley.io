<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.brixit.nl/moving-to-a-rtos-on-the-rp2040/">Original</a>
    <h1>Moving to a RTOS on the RP2040</h1>
    
    <div id="readability-page-1" class="page"><section>
                <div>
                    <p>I&#39;ve been working on a bunch of small projects involving microcontrollers. Currently a lot of them are based around the Raspberry Pi Pico boards because I like the development experience of those a lot. They have a decent SDK and cheap hardware to get started and the debugger works with gdb/openocd so it just integrates in all IDEs that support that.</p>

<p>One of my current projects is making a fancy hardware controller for a bunch of video equipment I use. The main things that will be controlled are two PTZ cameras (those are cameras that have motors to move them). One stationary camera and the video switching equipment that that&#39;s hooked up to.</p>

<p>Currently the control of the control of the PTZ cameras is done with an unbranded panel that looks suspiciously like the Marshall VS-PTC-200:</p>

<figure><img src="https://vaibhavsagar.com/image/w1000//static/files/blog.brixit.nl/1715003106/VS-PTC-200-Keyboard-PTZ-Compact-Controller.jpg"/><figcaption>(Image from marshall-usa.com)</figcaption></figure>

<p>The performance of this controller is simply not very great, especially for the price. It was a €650 device several years ago and for that money it has very annoying squishy buttons and the cheapest analog joystick you could find. Most of the buttons are also not functional with the cameras in use since this seems to be optimized for security cameras. This connects to the cameras over an RS-485 bus.</p>

<p>The second thing I want my panel to do is very basic ATEM video switcher control. Currently that&#39;s fully done using the software panel on the computer because the panels from Blackmagic Design are very expensive.</p>

<figure><img src="https://vaibhavsagar.com/image/w1000//static/files/blog.brixit.nl/1715003565/image.png"/><figcaption>There&#39;s a tiny cheaper one now though. (from blackmagicdesign.com)</figcaption></figure>

<p>After a bit of designing I figured the most minimal design I can get away with is 9 buttons, the joystick and a display for the user interface. The hardware design has gone through several iterations over the last year but I now have some PCBs with the 9 RGB buttons on it, the $10 joystick that was also in the Marshall-clone panel and to interface with the outside world it has the TP8485E to communicate with the cameras over RS-485 and a Wiznet W5500 module to communicate with the video switcher over ethernet.</p>

<figure><img src="https://vaibhavsagar.com/image/w1000//static/files/blog.brixit.nl/1715003933/IMG_20240429_184436.jpg"/><figcaption>This includes a bunch of &#34;oops-the-wrong-pinout&#34; fixes...</figcaption></figure>

<p>After a lot of fixing of the board I had made I now have all the hardware parts functional, but the difficult part of this project is the software.</p>

<h2>Initial software</h2>

<p>I first started creating the software like I do all the RP2040 based projects. A cmake project that pulls in the pico-sdk. To make anything work at all I dedicated the second core of the pico to dealing with the Wiznet module and the first core then handles all the user interface I/O. This worked fine to blink some leds and I did implement a DHCP client that ran on the second core. It did make implementing the rest of the system a lot more complicated. There&#39;s simply a lot of things that need to happen at once:</p>

<ul><li>Draw an user interface on the display that&#39;s somewhat smooth</li>
<li>Send out VISCA commands over the RS-485 interface</li>
<li>Respond to button presses</li>
<li>Keep the entire network stack alive with multiple connections</li>
</ul>

<p>There&#39;s a bunch of things that need to happen on the network, the first of which is some actually standards complicant DHCP support. This would require keeping track of the expire times and occasionally talk to the DHCP server to keep the lease active. The second background task is making mDNS work. The ATEM video switcher IP can be autodiscovered using DNS-SD and it would be great to also announce the existence of the control panel.</p>

<p>The ATEM protocol itself is also one of the harder parts to get right, the protocol itself is pretty simple but it does involve sometimes receiving a lot of data that exceeds the buffer size of the Wiznet module and the protocol has a very low timeout for disconnection for when you stop sending UDP datagrams to the ATEM.</p>

<p>This all made me decide that it&#39;s probably better to switch to an RTOS for this project.</p>

<h2>FreeRTOS</h2>

<p>The first project I&#39;ve looked into is FreeRTOS. This is technically already bundled inside the pico-sdk but all tutorials I&#39;ve found for this download a fresh copy anyway so that&#39;s what I did. FreeRTOS seems to be the simplest RTOS I&#39;ve looked at from this list, the main thing it provides is the RTOS scheduler and some communication between tasks. The simplest way I can show it is with some code:</p>

<div><pre><span></span><span>#include</span><span> </span><span>&#34;FreeRTOS.h&#34;</span><span></span>

<span>TaskHandle_t</span><span> </span><span>button_task</span><span> </span><span>=</span><span> </span><span>NULL</span><span>;</span><span></span>
<span>TaskHandle_t</span><span> </span><span>led_task</span><span> </span><span>=</span><span> </span><span>NULL</span><span>;</span><span></span>
<span>QueueHandle_t</span><span> </span><span>led_queue</span><span> </span><span>=</span><span> </span><span>NULL</span><span>;</span><span></span>

<span>void</span><span> </span><span>buttonTask</span><span>(</span><span>void</span><span> </span><span>*</span><span>param</span><span>)</span><span> </span><span>{</span><span></span>
<span>    </span><span>while</span><span> </span><span>(</span><span>1</span><span>)</span><span> </span><span>{</span><span></span>
<span>      </span><span>bool</span><span> </span><span>state</span><span> </span><span>=</span><span> </span><span>get_button_pressed</span><span>();</span><span></span>
<span>      </span><span>xQueueSend</span><span>(</span><span>led_queue</span><span>,</span><span> </span><span>&amp;</span><span>state</span><span>,</span><span> </span><span>0</span><span>);</span><span></span>
<span>    </span><span>}</span><span></span>
<span>}</span><span></span>

<span>void</span><span> </span><span>ledTask</span><span>(</span><span>void</span><span> </span><span>*</span><span>param</span><span>)</span><span> </span><span>{</span><span></span>
<span>    </span><span>while</span><span> </span><span>(</span><span>1</span><span>)</span><span> </span><span>{</span><span></span>
<span>        </span><span>bool</span><span> </span><span>state</span><span>;</span><span></span>
<span>        </span><span>if</span><span>(</span><span>xQueueReceive</span><span>(</span><span>led_queue</span><span>,</span><span> </span><span>&amp;</span><span>state</span><span>,</span><span> </span><span>portMAX_DELAY</span><span>))</span><span> </span><span>{</span><span></span>
<span>            </span><span>gpio_put</span><span>(</span><span>LED_PIN</span><span>,</span><span> </span><span>state</span><span>);</span><span></span>
<span>        </span><span>}</span><span></span>
<span>    </span><span>}</span><span></span>
<span>}</span><span></span>

<span>int</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span><span></span>
<span>    </span><span>xTaskCreate</span><span>(</span><span>buttonTask</span><span>,</span><span> </span><span>&#34;Button&#34;</span><span>,</span><span> </span><span>128</span><span>,</span><span> </span><span>NULL</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>&amp;</span><span>button_task</span><span>);</span><span></span>
<span>    </span><span>xTaskCreate</span><span>(</span><span>ledTask</span><span>,</span><span> </span><span>&#34;Led&#34;</span><span>,</span><span> </span><span>128</span><span>,</span><span> </span><span>NULL</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>&amp;</span><span>led_task</span><span>);</span><span></span>
<span>    </span><span>vTaskStartScheduler</span><span>();</span><span></span>
<span>    </span><span>// Code will never reach here</span>
<span>    </span><span>return</span><span> </span><span>0</span><span>;</span><span></span>
<span>}</span><span></span>
</pre></div>


<p>Both the buttonTask and the ledTask function will seem to run in parallel and there&#39;s a few IPC systems to move data between the various tasks. The code above is not functional but I stripped it down to get the general usage across.</p>

<p>I&#39;ve used this for a few days to make an enormous mess of my codebase. I have created several tasks in my test project:</p>

<ul><li>The buttonsTask that polls the i2c gpio expander to check if buttons have been pressed and then put a message on the button queue.</li>
<li>The ledTask that sets  the right RGB color on the right button by putting a message on the ledQueue;</li>
<li>The mainTask that runs the main loop of the project that updates the state based on the button presses.</li>
<li>The networkTask that communicates with the Wiznet module.</li>
<li>The dhcpTask that is spawned by the networkTask when a network cable is plugged in.</li>
<li>The mdnsTask that is spawned by the dhcpTask once an ip address is aquired.</li>
<li>the atemTask that is spawned by the mdnsTask when it gets a response from an ATEM device.</li>
<li>the viscaTask that does nothing but should send data out the RS-485 port.</li>
</ul>

<p>This is a lot of tasks and the hardware doesn&#39;t even do anything yet except appear on the network.</p>

<p>I ran into a few issues with FreeRTOS. The main annoying one is that printf simply caused things to hang every single time which makes debugging very hard. Sure the gdb debugger works but it&#39;s not neat for dumping out DHCP traffic for example.</p>

<p>The FreeRTOS also doesn&#39;t seem to provide any hardware abstraction at all which means all the code I wrote to communicate with the various chips is not easily re-used.</p>

<p>After a few days I created a new clean FreeRTOS project and started porting the various functionalities from the previous version over to try to get a cleaner and more manageable codebase but ended up giving up because blind debugging because there&#39;s no serial output is quite annoying. I decided to look what the alternatives have to offer.</p>

<h2>Apache NuttX</h2>

<p>Another seemingly popular RTOS is NuttX. This project seems a lot closer to what you&#39;d expect from a regular operating system. It makes your microcontroller look like an unix system.</p>

<p>First thing the tutorial tells me to do is fetching the pico-sdk and set the environment variable. No problem, I already have the sdk in /usr/share and that environment variable already exists on my system. Suprisingly this made the build fail because NuttX decides that it really needs to overwrite the version.h file in my pico-sdk for which it doesn&#39;t have permissions... why...</p>

<p>After doing the initial setup of building a minimal NuttX firmware for my board I connected to the serial port and was greeted by an actual shell.</p>

<pre><code>nsh&gt; uptime
00:01:34 up  0:01, load average: 0.00, 0.00, 0.00
nsh&gt; uname
NuttX
nsh&gt; uname -a
NuttX 12.5.1 9d6e2b97fb May  6 2024 15:18:54 arm raspberrypi-pico</code></pre>

<p>It looks like I&#39;d just be able to write an app for this operating system and have it auto-launch on boot. Since this tries to do the Unix thing it also has a filesystem of course so the hardware has FS abstractions like <code>/dev/i2c0</code> and <code>/dev/adc0</code>. </p>

<p>One thing I liked a lot was that it&#39;s build around menuconfig/Kconfig which I&#39;m already used to for Linux development. This also means there&#39;s an actual hardware driver system and the GPIO expander chip I&#39;ve used for the buttons already had a driver. The menuconfig system also allows me to configure the pin muxing of the rp2040 chip so I don&#39;t have to keep constants around with pin numbers and do a bunch of hardware setup to make my i2c bus work. I can just go into the menuconfig and tell it that i2c0 of the pico is used and that it&#39;s on two specific pins. I&#39;ve also enabled the i2c testing utility as one of the apps that will be build into the firmware.</p>

<pre><code>nsh&gt; i2c dev 0 79
     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
00: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
70: -- -- -- -- -- -- -- -- -- --                   
nsh&gt; </code></pre>

<p>Well uuuuh... yup the basics aren&#39;t working. I&#39;ve spend a bit of time going through the rp2040 setup code and the various i2c related menuconfig options but it seems like this just doesn&#39;t really work...</p>

<p>I also have not figured out yet how I can tell NuttX that my gpio buttons are behind the gpio extender, or how to actually link the gpio extender to my non-functional i2c bus.</p>

<p>Another thing that annoyed me is that I had to re-clone the nuttx repository multiple times simply because sometimes one of the configure.sh commands would fail which would leave the repository in an inconsistent state and the distclean command wouldn&#39;t work because the repository was in an inconsistent state. Really the classic &#34;configure.sh: you are already configured; distclean: you are not configured yet&#34;</p>

<p>Unix-like seems great at first glance, but I don&#39;t really want to deal with filesystem paths on a microcontroller for a pretend filesystem. I also don&#39;t need a shell in my production system, it should just run my code.</p>

<h2>Zephyr</h2>

<p>So next on the list is Zephyr. This provides a python utility to set up a project which should make things a bit easier, or it&#39;s a sign something is terribly overcomplicated.</p>

<p>The very first thing this project does is pull in 5GB of git repositories which includes the entire HAL library for every chip under the sun. The second thing it does is for some reason mess with my user-wide cmake stuff on my system.</p>

<p>After that the tutorial told me to install the Zephyr SDK:</p>

<blockquote>The <a href="https://docs.zephyrproject.org/latest/develop/toolchains/zephyr_sdk.html#toolchain-zephyr-sdk">Zephyr Software Development Kit (SDK)</a> contains toolchains for each of Zephyr’s supported architectures, which include a compiler, assembler, linker and other programs required to build Zephyr applications.</blockquote>

<p>Yeah no thanks, I have already several perfectly fine ARM toolchains and I don&#39;t really want to either build or fetch precompiled compilers for every architecture Zephyr supports, lets see if I can get away with not installing this.</p>

<p>After some messing around I figured out how to get away with it. There need to be two command line options set for cross compiling:</p>

<div><pre><span></span><span>$ </span><span>export</span> <span>ZEPHYR_TOOLCHAIN_VARIANT</span><span>=</span>cross-compile
<span>$ </span><span>export</span> <span>CROSS_COMPILE</span><span>=</span>/usr/bin/arm-none-eabi- 
<span>$ </span>west build -p always -b sparkfun_pro_micro_rp2040 samples/basic/blinky
</pre></div>


<p>One thing I also found out is that the Raspberry Pi Pico is not actually supported, only other boards that have the same SoC. No worries, these boards are practically the same. The very second issue I hit is that the blinky demo doesn&#39;t build because it requires <code>led0</code> to be defined to have something to blink.</p>

<p>It turns out the Sparkfun pro Micro RP2040 does not actually have a simple gpio led to blink but a ws2812B adressable led. </p>

<p>So I started following the custom board manual which told me to copy a random other board because that&#39;s how it always goes. Maybe if you already have a meta tool to set-up a project make it create this scaffolding.</p>

<p>In the end I did not manage to build for my board because it simply wouldn&#39;t start to exist after fixing all the errors and warnings in the build.</p>

<h2>Conclusion</h2>

<p>Well at least with FreeRTOS I managed to building some of my own application. I guess I have to follow the online instructions of replacing printf with another printf implementation and make sure to call the different function everywhere.</p>

<p>I&#39;ll probably continue on trying to get FreeRTOS to do the things I want since it&#39;s the only one that can be simply integrated in your own environment instead of the other way around.</p>


                </div>
            </section></div>
  </body>
</html>
