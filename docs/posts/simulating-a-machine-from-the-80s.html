<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rmazur.io/blog/fahivets.html">Original</a>
    <h1>Simulating a Machine from the 80s</h1>
    
    <div id="readability-page-1" class="page"><div>


<p>
  <i>2025-08-10</i>
</p>


  <h2>The book</h2>
  <p>I recently read a book on the history of computing in Ukraine: <a href="https://www.innovation-in-isolation.com/" target="_blank" rel="noopener">Innovation in Isolation</a>.
It has the story of <a href="https://en.wikipedia.org/wiki/Specialist_(computer)" target="_blank" rel="noopener">Fahivets-85</a> - my first computer I got as a birthday gift when I was 6.
The urge to try this machine again was so big I decided to simulate it and run some programs (and games) I remember from the childhood.
Even though there are several existing emulators of this and similar machines, I wanted to take the implementation path myself.</p>


  <h2>The code</h2>
  <p>At the moment of writing I have <a href="https://github.com/roman-mazur/fahivets" target="_blank" rel="noopener">an emulator</a> that compiles into Web Assembly
and is good enough to <a href="https://rmazur.io/fahivets-sim" target="_blank" rel="noopener">run the game called &#34;Rain&#34;</a>.
The game is quite simple: press any key to go past the main screen, then use the arrow keys (left and right) to control
a up and catch the rain drops. Is you miss a drop once, a cactus starts growing. If you miss twice on the same place,
the cactus get bigger and you will die if you touch it. If you miss for the 3rd time, the cactus will transform into
a demon that will move randomly.</p>
<p>There are some issues with how the keyboard is handled, and I don&#39;t yet have the sound. But the game is quite playable.</p>
<p>It took me 43 commits to get to this state. Here are the main ones.</p>
<ul>
<li><em><a href="https://github.com/roman-mazur/fahivets/commit/c9f2c0c97903d737a04d2e3bc67b60e0b962c5bd" target="_blank" rel="noopener">Add first implementation</a></em>
Reviewing the specs for Intel 8085, I&#39;m building the ops.txt file with a short spec of different CPU commands.
It looks like this: each line has info about how the command is encoded in the binary code, its duration; semantics
can be interpreted as micro-assembler code, and an example can be used as an illustration and a test.</li>
</ul>
<pre><code>  cmd  encoding   flags   size  cycles     time  semantics            example
  ACI  11001110   ZSCPA      2       2        7  A = A + data + fC   |A=2, data=1, fC=1 =&gt; A=4
  ADC  10001r/m   ZSCPA      1     1/2      4/7  A = A + r/m + fC    |A=2, B=1, r/m=b000, fC=1 =&gt; A=4
</code></pre>
<p>My original idea was that I can write a generator of Go code from this table. Instead of implementing my own generator,
I take the path of asking AI assistant to generate implementation and tests for me looking at those specs.
It took some time to get implementation and tests in the style I liked, but once I prepared first examples myself, AI
was quite good in following the existing pattern and adding other implementations.</p>
<ul>
<li>
<p><em><a href="https://github.com/roman-mazur/fahivets/commit/63865ff62a7eada73ca8e0e2451a51cfb234b18d" target="_blank" rel="noopener">arch: Add first decoding logic</a></em>
I wanted to get to trying real binary codes I could find for Фахівець as fast as possible, so even though I haven&#39;t yet
had full commands implementation, I started adding their decoding logic too.</p>
</li>
<li>
<p><em><a href="https://github.com/roman-mazur/fahivets/commit/c6b1161d22c7e0c8a9f781da308d692a18e9d629" target="_blank" rel="noopener">Add go.mod</a></em>
Not much to say. Feels like it&#39;s time.</p>
</li>
<li>
<p><em><a href="https://github.com/roman-mazur/fahivets/commit/69696651dd4bc7ad8d73d1f363b76f4448a1e982" target="_blank" rel="noopener">arch: Support decoding of more instructions</a></em>
Continue with adding the decoding logic for the instructions I already have.</p>
</li>
<li>
<p><em><a href="https://github.com/roman-mazur/fahivets/commit/0484bbee57cca6c01c0a668ee154efed6bb0bec0" target="_blank" rel="noopener">Add more instructions support including load</a></em>
Extend the coverage of the CPU commands, keep using AI help. Instructions that load data from memory are now supported.</p>
</li>
<li>
<p><em><a href="https://github.com/roman-mazur/fahivets/commit/73404bea0096ffd87c0d2184460fa0b88f24506f" target="_blank" rel="noopener">Add move codes</a></em>
Support coping data between registers and memory. Why did people call it <code>MOV</code>, and not <code>COPY</code>?</p>
</li>
<li>
<p><em><a href="https://github.com/roman-mazur/fahivets/commit/986a0afa6fb6878b4788fbb04791beabe08e76e7" target="_blank" rel="noopener">Complete instruction set</a></em></p>
</li>
<li>
<p><em><a href="https://github.com/roman-mazur/fahivets/commit/3ea47641e4285debf82b919f5e9c563ff10aa3bb" target="_blank" rel="noopener">arch: Debug first ROM code</a></em>
Now we have the full coverage of instructions, and we can try running the bootloader code, see what happens.
I&#39;m adding the code of the bootloader and monitor (BIOS-like programs that were in the ROM of the computer) and add tests
that load them. This leads to adjusting some code and fixing some obvious bugs. Dumping the registers state and some</p>
</li>
<li>
<p><em><a href="https://github.com/roman-mazur/fahivets/commit/e29d91119307dc766d22c468f9c822b2ea805f54" target="_blank" rel="noopener">arch: Implement simple 8255 simulator</a></em>
Integration between the CPU is the keyboard is done via a dedicated device: an IO controller. So we need to emulate it too.</p>
</li>
<li>
<p><em><a href="https://github.com/roman-mazur/fahivets/commit/861960041c6d275dbc076be747343d767d5eaef2" target="_blank" rel="noopener">.github: Add first workflow</a></em>
The code is ont GitHub by this moment. Why not to benefit from the test reports there.</p>
</li>
<li>
<p><em><a href="https://github.com/roman-mazur/fahivets/commit/f748605b831f68442526f49505be87a14a3f27d7" target="_blank" rel="noopener">devices: Draft keyboard implementation</a></em>
Continue the work on the keyboard. Now we need an emulator for the keyboard behaviour that will integrate with
the keyboard controller.</p>
</li>
<li>
<p><em><a href="https://github.com/roman-mazur/fahivets/commit/506317af353cd466e590b529ae2414efbd82d2cd" target="_blank" rel="noopener">Test first keyboard scan program</a></em>
Compose my own program that scans what key is pressed to test is the emulator works according to my expectations.
Hope that real programs for Fahivets are similar...</p>
</li>
<li>
<p><em><a href="https://github.com/roman-mazur/fahivets/commit/177bafc57c8daf618f8b36ffc861928230a1f29d" target="_blank" rel="noopener">Fix IO controller mapping and expectations</a></em>
Debugging the bootloader and looking at my own program I realize that I used the wrong memory range to address the IO controller.</p>
</li>
<li>
<p><em><a href="https://github.com/roman-mazur/fahivets/commit/40f7c1895e09e710934b6ccbbd45a2b5d62d0565" target="_blank" rel="noopener">devices: Add monochrome display</a></em>
After getting tired of the keyboard story, I wanted some satisfaction. What is better than getting some graphics?
So now we can render what is the display buffer into PNG to understand if anything really works.
Capture the image <a href="https://github.com/roman-mazur/fahivets/commit/40f7c1895e09e710934b6ccbbd45a2b5d62d0565#diff-f185f33aad27f0d686a12ce2c306b5a7869854169e419fc2648265190209b313" target="_blank" rel="noopener">and add it to the test</a>
to avoid regressions when we run the bootloader code after changing the emulator.</p>
</li>
</ul>

    <p><img src="https://rmazur.io/blog/images/fahivets/display-sample.png"/>
    </p>
<ul>
<li>
<p><em><a href="https://github.com/roman-mazur/fahivets/commit/c36759ee9ef9235c5084f1340d64412826295cb5" target="_blank" rel="noopener">cmd/sim: Add web interface</a></em>
We can render and inject keyboard events. Let&#39;s try exposing it on a web page via Web Assembly.</p>
</li>
<li>
<p><em><a href="https://github.com/roman-mazur/fahivets/commit/a6718841d022935a53d30ffc0aa1574cac6520d9" target="_blank" rel="noopener">Start analyzing bootloader code</a></em>
I have problems making the bootloader do something after I inject keyboard events. So digging deeper into its logic.
Committing the disassembled code and add some annotations on how I understand it.</p>
</li>
<li>
<p><em><a href="https://github.com/roman-mazur/fahivets/commit/3818b059dab3f74546d7167b3f10b6a43a0500d9" target="_blank" rel="noopener">fahivets: Add RKS reader logic</a></em></p>
</li>
<li>
<p><em><a href="https://github.com/roman-mazur/fahivets/commit/fdc440878d1e06313a94c71d5eef7ec6ffea1467" target="_blank" rel="noopener">fahivets: Add some test rks files</a></em>
But why to be stuck with the bootloader/monitor? Why not to try loading other programs?
Most of the programs for Fahivets that can found on the Internet are in some <code>.rks</code> format. I found how to interpret it om some forums.</p>
</li>
<li>
<p><em><a href="https://github.com/roman-mazur/fahivets/commit/8193a9c068b6be1a5c5e479c51f467d92742a44a" target="_blank" rel="noopener">cmd/sim: Load rain game for a test</a></em>
Now we can get the game running and it kinda works.</p>
</li>
<li>
<p><em><a href="https://github.com/roman-mazur/fahivets/commit/ad04d1af8e7c2f9b9d5a2ef28a3ffb7fd2558dfa" target="_blank" rel="noopener">cmd/sim: Scale the rendered frame</a></em>
The display buffer is just 384x256, so the output image is quite small on a modern monitor.
Let&#39;s scale it up before rendering.</p>
</li>
<li>
<p><em><a href="https://github.com/roman-mazur/fahivets/commit/7ac41de66e0cbdbee0fe1643b368e70744ecc7d6" target="_blank" rel="noopener">cmd/sim: Use JS animation frames</a></em>
Experiment a bit how to organize routines to run the simulation, capture user input, display the frames.</p>
</li>
<li>
<p><em><a href="https://github.com/roman-mazur/fahivets/commit/7f771256bcf2b65f343d805468584e0f36c2d8a2" target="_blank" rel="noopener">arch: Fix parity bit</a></em>
The rain game had an obvious bug: the drops were falling at the same location.
It was pointing to the fact I had some issue with the CPU commands implementation.
It turned out to be a problem with how I was calculating the parity bit: somehow I decided to check
if the number is even instead of checking how many bits are set in the register.</p>
</li>
</ul>
<p>Now the game is playable. Most likely, I have more problems with the CPU emulation.
I&#39;m not confident in my decimal addition implementation and handing the decimal carry flag (<code>A</code>).
Other games are not working yet.</p>
<p>But it&#39;s such a joy to see the first result and share it with friends...
Let&#39;s see when I get energy to continue.</p>

    <p><img src="https://rmazur.io/blog/images/fahivets/rain.jpeg?1"/>
    </p>



</div></div>
  </body>
</html>
