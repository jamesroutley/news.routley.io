<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blogs.windows.com/msedgedev/2023/01/17/the-truth-about-css-selector-performance/">Original</a>
    <h1>The truth about CSS selector performance</h1>
    
    <div id="readability-page-1" class="page"><section data-js="panel-article-header">
			


		
</section><div data-modular-content-collection="">
	
		

			<section data-index="0" data-js="panel" data-type="wysiwyg-with-aside" data-modular-content="">

	
	
	
	
	<div>
		<div>
			
<div>
<p>If you’re a web developer, you may have already heard that some CSS selectors are faster than others. And you’re probably hoping to find a list of the better selectors to use in this article.</p>
<p>Well, not quite. But bear with me, I promise that by the end, you’ll have learnt something new about CSS selector performance.</p>
<h2>A quick look behind the scenes</h2>
<p>The way you write CSS selectors does play a role in how browsers render your web pages.</p>
<p>Whenever a part of your page changes, the browser engine that’s running it needs to take a look at the new DOM tree, and figure how to style it based on the available CSS stylesheets. This operation of matching styles to DOM nodes is called a style recalculation.</p>
<p>Without getting into a lot of details, the browser engine needs to look at all your rules and make decisions as to which ones apply to a given element. To do this, the engine needs to look at the rule selector, and this happens from right to left.</p>
<p>For example, when the engine sees a selector like <code data-enlighter-language="css">`.wrapper .section .title .link`</code> it will try to match the <code data-enlighter-language="css">`link`</code> class with the element first, and if that matches, then go up the chain from right to left to find an ancestor element with class <code data-enlighter-language="css">`title`</code>, then one with class <code data-enlighter-language="css">`section`</code>, and finally one with class <code data-enlighter-language="css">`wrapper`</code>.</p>
<p>This example illustrates that it’s likely faster for the browser engine to match just <code data-enlighter-language="css">`.link`</code> than it is to match this longer <code data-enlighter-language="css">`.wrapper .section .title .link`</code> selector. There are just fewer things to check.</p>
<p>Classes aren’t the only type of identifiers you can use in your CSS selectors of course. One interesting example is using attribute selectors and do substring matching like <code data-enlighter-language="css">`[class*=&#34;icon-&#34;]`</code>.</p>
<p>This type of selector requires the browser engine to not only check if the element has a class attribute but also whether the value of this attribute contains the substring <code data-enlighter-language="css">`icon-`</code>. That’s another example of how different ways of writing selectors may require more or less work for the engine to apply CSS rules.</p>
<h2>In practice, does it matter?</h2>
<p><strong>Maybe</strong>. This heavily depends on the web page, the size of the DOM tree, the amount of CSS rules, and whether the DOM changes often. There’s unfortunately no rule around this.</p>
<p>In fact, talking about rules, as an industry, we like inventing rules for what’s good and what’s bad. Rules help us make quick decisions and guide us when writing code and designing software. But they can also blind us from what’s really happening in our specific case.</p>
<p>When it comes to writing CSS selectors, strictly applying rules, or using a linter to do it automatically, may actually be counter-productive in some cases.</p>
<p>Overly complex CSS selectors, coupled with a huge DOM tree that changes a lot could very well lead to bad performance. But there’s a balance. Over-indexing on theoretical rules and changing selectors just to please your linter and hope for better performance may just be making your CSS harder to read and maintain, for not much actual gains.</p>
<p>So, write the code in a way that makes sense for your app, and is easy to read and maintain, and then measure the actual performance of your important user scenarios.</p>
<h2>Measure!</h2>
<p>Prefer measuring your key app scenarios over blindly applying a set of rules for how to write fast code. Know the tools at your disposal, and use them.</p>
<p>Microsoft Edge DevTools has a <strong>Performance</strong> tool that can be a real eye opener when your app starts feeling slow.</p>
<p>I want to emphasize the word <em>feeling</em> here. Build empathy for your users and use the devices they actually use if you can. Your development machine is likely much more powerful than your users’ devices.</p>
<p>In fact, one nice thing you can do with DevTools is <a href="https://learn.microsoft.com/en-us/microsoft-edge/devtools-guide-chromium/evaluate-performance/reference#throttle-the-network-while-recording">slow down your CPU and network connection</a> from within the tools directly.</p>
<p>The Performance tool can look quite complicated, but we have <a href="https://learn.microsoft.com/microsoft-edge/devtools-guide-chromium/evaluate-performance/">documentation</a> that should help. Also, everything happens in your browser only, so you can try things out without breaking anything, and you can always just reload the page and re-open DevTools if you get into trouble.</p>
<p>Learn to use the tools available to measure your key scenarios, and learn to identify the biggest blocks that are making things slow.</p>
<figure><p><a href="https://blogs.windows.com/wp-content/uploads/prod/sites/33/2023/01/Picture1.png"><img src="https://blogs.windows.com/wp-content/uploads/prod/sites/33/2023/01/Picture1.png" alt="The Performance tool in Edge DevTools. The &#34;Main&#34; panel is expanded to show a flame chart in &#34;Bottom-Up&#34; sorting." width="922" height="703"/></a></p></figure>
<p>If style recalculation is, indeed, one of the things that is making your app slow, then we’ve got good news for you. When it comes to investigating a performance issue you’ve zeroed in on, nothing beats having a tool that just gives you the root cause for it immediately.</p>
<h2>Selector stats to the rescue</h2>
<p>Starting with Microsoft Edge 109 the Performance tool in DevTools can list the most costly selectors in any style recalculation. Here’s how to get it:</p>
<ol>
<li>Open the <strong>Performance</strong> tool.</li>
<li>Open the tool’s settings by clicking the cog icon in the top-right corner.</li>
<li>Check the <strong>Enable advanced rendering instrumentation (slow)</strong> option.</li>
<li>Click <strong>Record</strong>, execute the scenario on the webpage that you want to improve, and then click <strong>Stop</strong>.</li>
<li>In the recorded profile, identify a long style recalculation that you want to improve and select it.</li>
<li>In the bottom tab bar, click <strong>Selector Stats</strong>.</li>
</ol>
<p>DevTools now gives you the list of all the CSS selectors that got calculated by the browser engine during this recalculation operation. You can sort the selectors by the time they took to process or the number of times they matched.</p>
<figure><p><a href="https://blogs.windows.com/wp-content/uploads/prod/sites/33/2023/01/Picture2.png"><img loading="lazy" src="https://blogs.windows.com/wp-content/uploads/prod/sites/33/2023/01/Picture2.png" alt="The Performance tool with the &#34;Selector Stats&#34; tab expanded, displaying a list of CSS selectors and time elapsed to calculate them." width="936" height="714"/></a></p></figure>
<p>If you find a selector that required a long time to process, and was matched many times, that might be a good candidate to try and improve. Could the selector be simplified? Could it be made more specific to the elements it should match?</p>
<p>This new feature makes it instant to go from a suspicious-looking style recalculation to the individual CSS selectors that are causing it to be that long. You can then go back to your source code, improve those particular selectors, and measure again.</p>
<h2>Case study</h2>
<p>To make things more practical, let’s try to improve an actual webpage. We will use a photo gallery page built as a demo just for this.</p>
<figure><p><a href="https://blogs.windows.com/wp-content/uploads/prod/sites/33/2023/01/Picture3.png"><img loading="lazy" src="https://blogs.windows.com/wp-content/uploads/prod/sites/33/2023/01/Picture3-1024x901.png" alt="A sample gallery page showing a set of photos with descriptions and metadata for each photos, and a row of filter options at the top." width="1024" height="901"/></a></p></figure>
<p>This page has a toolbar at the top to filter photos by camera model, aperture, exposure time, etc. and switching between camera models feels a bit slow right now.</p>
<p>Although this demo page was built just for this, it does show a case that’s similar to what we encountered in our own products at Microsoft. The Edge team and other product teams at Microsoft who rely on the web platform collaborate closely in this area in order to create the best user experience. In certain specific scenarios, we were seeing unusually long style recalculations in apps that have a lot of DOM elements (like the demo page we’ll use here, which has around 5000 elements). Having access to the CSS selector stats tool helped us a lot.</p>
<p>The scenario we’ll be focusing on is the following:</p>
<ul>
<li>Load the demo page, and wait for the filters to be ready.</li>
<li>Switch the camera model filter to another value and start the performance recording.</li>
<li>Switch back to all camera models and stop the recording.</li>
</ul>
<p>Switching back to all photos is slow so we’re measuring only that part. We’ll also slow down the CPU four times to have more realistic results than we’d normally get on a powerful development machine.</p>
<p>Once the recording is ready, we can easily see a long style recalculation block in the profile, amounting to more than 900 milliseconds of work in my case. Let’s click on this block, open the <strong>Selector Stats</strong> pane, and then sort by elapsed time:</p>
<figure><p><a href="https://blogs.windows.com/wp-content/uploads/prod/sites/33/2023/01/Picture4.png"><img loading="lazy" src="https://blogs.windows.com/wp-content/uploads/prod/sites/33/2023/01/Picture4.png" alt="The DevTools selector stats pane with results sorted by elapsed time" width="936" height="696"/></a></p></figure>
<p>The more work a selector requires to match, and the more times it’s matched, the more potential wins we can get by improving this selector. In the list above, the following selectors seem interesting to look at:</p>
<ul>
<li><code data-enlighter-language="css">`.gallery .photo .meta ::selection`</code></li>
<li><code data-enlighter-language="css">`.gallery .photo .meta li strong:empty`</code></li>
<li><code data-enlighter-language="css">`[class*=&#34; gallery-icon--&#34;]::before`</code></li>
<li><code data-enlighter-language="css">`.gallery .photo .meta li`</code></li>
<li><code data-enlighter-language="css">`*`</code></li>
<li><code data-enlighter-language="css">`html[dir=&#34;rtl&#34;] .gallery .photo .meta li button`</code></li>
</ul>
<h3>Improving the <code>::selection</code> selector</h3>
<p>We use <code data-enlighter-language="css">`.gallery .photo .meta ::selection`</code> in the demo web page to style the background and text colors of user selections inside the photo metadata part of the page. When users select the text below a photo, custom colors are used instead of the browser default ones.</p>
<p>This particular case is actually problematic because of a bug in the code. The selector should really be <code data-enlighter-language="css">`.gallery .photo .meta::selection`</code> instead, with no extra space between <code data-enlighter-language="css">`.meta`</code> and <code data-enlighter-language="css">`::selection`</code>.</p>
<p>Because there’s an extra space there, our selector is actually interpreted by the engine as: <code data-enlighter-language="css">`.gallery .photo .meta *::selection`</code> which makes it a lot slower to match during a style recalculation because the engine needs to check all DOM elements, and then verify if they’re nested inside the right ancestors.</p>
<p>Without the extra space, the engine only needs to check if the element has a class of <code data-enlighter-language="css">`.meta`</code> before going further.</p>
<h3>Improving the <code>:empty</code> selectors</h3>
<p>The selector <code data-enlighter-language="css">`.gallery .photo .meta li strong:empty`</code> looks suspicious at first sight. The <code data-enlighter-language="css">`:empty`</code> pseudo means that the selector only matches when the <code data-enlighter-language="html">`strong`</code> element doesn’t have any contents.</p>
<p>This might require the engine to do a bit more work than just checking the element’s tag name but is very useful.</p>
<p>However, looking at other CSS rules close to this one, we can see the following:</p>
<pre data-enlighter-language="css">.gallery .photo .meta li strong:empty {
  padding: .125rem 2rem;
  margin-left: .125rem;
  background: var(--dim-bg-color);
}

html[dir=&#34;rtl&#34;] .gallery .photo .meta li strong:empty {
  margin-left: unset;
  margin-right: .125rem;
}</pre>
<p>The same selector is repeated twice, but the second instance is prefixed with <code data-enlighter-language="css">`html[dir=rtl]`</code> which is useful to override the first rule when the text direction on the page is right to left. In this case, the <code data-enlighter-language="generic">rtl</code> direction rule overrides the left margin and replaces it with a right margin.</p>
<p>To improve this, we can use <a href="https://developer.mozilla.org/docs/Web/CSS/CSS_Logical_Properties">CSS logical properties</a>. Instead of specifying a physical margin direction, we can use a logical one that will adapt to any text direction, as shown below:</p>
<pre data-enlighter-language="css">.gallery .photo .meta li strong:empty {
  padding: .125rem 2rem;
  margin-inline-start: .125rem;
  background: var(--dim-bg-color);
}</pre>
<p>While we’re doing this, there are other places in the CSS code that use the same attribute selector which can be improved by using logical CSS properties. For example, we can get rid of the <code data-enlighter-language="css">`html[dir=&#34;rtl&#34;] .gallery .photo .meta li button`</code> selector we found earlier.</p>
<h3>Improving the <code>[class*=&#34; gallery-icon--&#34;]</code> selector</h3>
<p>Our next selector is this complicated-looking attribute selector: <code data-enlighter-language="css">`[class*=&#34; gallery-icon--&#34;]::before`</code>.</p>
<p>Attribute selectors can be very useful, so before removing them, check whether they’re really having a negative impact. In our case, this selector does seem to play a role.</p>
<p>Here are the CSS rules we use this selector for:</p>
<pre data-enlighter-language="css">[class*=&#34; gallery-icon--&#34;]::before {
  content: &#39;&#39;;
  display: block;
  width: 1rem;
  height: 1rem;
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  filter: contrast(0);
}

.gallery-icon--camera::before { background-image: url(...); }
.gallery-icon--aperture::before { background-image: url(...); }
.gallery-icon--exposure::before { background-image: url(...); }
...</pre>
<p>The idea here is that we can assign any of these icon classes to an element and it’ll get the corresponding icon.</p>
<p>While this is a handy feature, we’re asking the engine to read the class value and do a substring search on it. Here is one way we can help the engine do less work:</p>
<pre data-enlighter-language="css">.gallery-icon::before {
  content: &#39;&#39;;
  display: block;
  width: 1rem;
  height: 1rem;
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  filter: contrast(0);
}

.gallery-icon.camera::before { background-image: url(...); }
.gallery-icon.aperture::before { background-image: url(...); }
.gallery-icon.exposure::before { background-image: url(...); }</pre>
<p>Now instead of using just one class, we’ll need to add two classes to elements: <code data-enlighter-language="html">`&lt;div class=&#34;gallery-icon camera&#34;&gt;`</code> instead of <code data-enlighter-language="html">`&lt;div class=&#34;gallery-icon--camera&#34;&gt;`</code>. But, overall, the feature is still very easy to use and causes less work for the engine when there are many DOM nodes to re-style like in our demo page.</p>
<h3>Improving the <code>.gallery .photo .meta li</code> selector</h3>
<p>This selector looks really inoffensive. But, as described earlier, it still forces the browser to go and check multiple levels in the list of ancestors to the <code data-enlighter-language="html">`li`</code> element. Knowing that our web page has a lot of <code data-enlighter-language="html">`li`</code> elements, this can amount to a lot of work.</p>
<p>We can simplify this by giving our <code data-enlighter-language="html">`li`</code> elements a specific class, and removing the unnecessary nesting. For example:</p>
<pre data-enlighter-language="css">.photo-meta {
  display: flex;
  align-items: center;
  gap: .5rem;
  height: 1.5rem;
}</pre>
<h3>Improving the <code>*</code> selector</h3>
<p>The <code data-enlighter-language="css">`*`</code> symbol is used as a universal selector in CSS that matches any element. This ability to match anything means that the engine needs to apply the associated rule to all elements.</p>
<p>As we can see in our performance recording, this selector is indeed being matched many times. It’s worth looking into what the CSS rule actually does.</p>
<p>In our case, it applies a specific <code data-enlighter-language="css">`box-sizing`</code> value:</p>
<pre data-enlighter-language="css">* {
  box-sizing: border-box;
}
</pre>
<p>This is very common in CSS, but in our case, it actually makes sense to remove it, apply the <code data-enlighter-language="css">`box-sizing`</code> only where needed, and then see the gains.</p>
<h3>Results</h3>
<p>With all of these improvements done, it’s time to check the performance of our scenario again.</p>
<figure><p><a href="https://blogs.windows.com/wp-content/uploads/prod/sites/33/2023/01/Picture5.png"><img loading="lazy" src="https://blogs.windows.com/wp-content/uploads/prod/sites/33/2023/01/Picture5.png" alt="The Performance tool showing a significant improvement in elapsed time on the Recalculate Style block addressed above" width="936" height="696"/></a></p></figure>
<p>In the above performance recording, the same Recalculate Style block that was taking almost a second to run, is now taking around 300ms to run which a really big win!</p>
<h2>Conclusion</h2>
<p>The case study showed that improving certain CSS selectors can lead to important performance gains. It’s key to remember, however, that this will depend on your particular use case. Test the performance of your web page using the Performance tool, and if you find that style recalculations are making your scenarios slow, use the new <strong>Selector Stats</strong> pane in Microsoft Edge.</p>
<p>As always, if you have any feedback for the DevTools team, please reach out to us by opening a new issue on our <a href="https://github.com/MicrosoftEdge/DevTools/issues">GitHub repository</a>.</p>

</div>


					</div>
	</div>


				
	
			</section>
	

</div></div>
  </body>
</html>
