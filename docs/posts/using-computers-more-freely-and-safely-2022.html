<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://akkartik.name/freewheeling">Original</a>
    <h1>Using computers more freely and safely (2022)</h1>
    
    <div id="readability-page-1" class="page"><div>
  <tbody><tr>
    <td>
      <a href="https://en.wikipedia.org/wiki/Home_computer#/media/File%3ACpc464.computer.750pix.jpg" target="_blank">
        <img src="http://akkartik.name/freewheeling/computer.jpg" alt="2 kids at a computer"/>
      </a>
    </td>
    <td>
      How can we use computers more freely and safely?

    </td>
  </tr>

  <tr>
    <td>
      <p>
        the punchline
      </p>
      Prefer software:
      <ul>
        <li> with thousands rather than millions of users
        </li><li> that seldom requires updates
        </li><li> that spawns lots of forks
        </li><li> that is easy to modify
        </li><li> that <em>you</em> can modify
      </li></ul>
    </td>
    <td>
      These are my suggestions.

      <ul>
        <li> Prefer software with thousands rather than millions of users,
        </li><li> that doesn&#39;t change often,
        </li><li> that seems to get forked a lot,
        </li><li> that can be modified without specialized tools, and, ideally
        </li><li> that you can make small changes to. Yourself. In a single
        afternoon.
      </li></ul>

      You don&#39;t have to do all this. Their benefits are additive, but acting
      on even one of these suggestions is better than nothing. The suggestions
      are arranged roughly in order of increasing effort and skill required.
      Trying to follow one suggestion will pave the way for the others, should
      you choose later to continue down this path. Software without constant
      updates is easier for forks to keep up with. Forks are signs of
      easily-modified software, and testimonials from nearby programmers can
      be promising signs that, hey, maybe making a change yourself won&#39;t be
      very hard.

      <p>
      The most important step is the first one. Humanity didn&#39;t get good at
      building houses by building the same house a million times. We built
      lots of different houses and learned from each other&#39;s failures.
      Gravitating away from monopolies is a way everyone can help improve
      software, regardless of our abilities or needs.

    </p></td>
  </tr>

  <tr>
    <td>
      <p>
      outline
      </p>
      <ul>
        <li> Problems
        </li><li> Suggestions ↔ Examples
      </li></ul>
    </td>
    <td>
      That&#39;s the whole argument in a nutshell. In the rest of this talk I want
      to show how to apply these principles in small ways in your day-to-day
      decision-making, making the world a little better in the process. I&#39;ll
      show this by drawing on my own journey over the past year for examples.
      I&#39;ll first back up to some problems I was responding to at the start,
      then show how I responded fairly directly to these problems and ended up
      with the above suggestions.

    </td>
  </tr>

  <tr>
    <td>
      <p>
        expensive
      </p>
    </td>

    <td>
      So, problems. The first problem is: software is expensive. We like to
      think the incremental cost of software is 0. You build it once, lots of
      people use it. The additional cost for any new user is negligible. This
      is just not borne out by multiple decades of experience. Apps and
      services require constant maintenance. And they grow complex over time,
      so their costs grow over time.

    </td>
  </tr>

  <tr>
    <td>
      <p>
        untrustworthy
      </p>
    </td>
    <td>
      Also, software today is just not very trustworthy.
    </td>
  </tr>

  <tr>
    <td>
      <p>
        incompetence
      </p>
      <a href="http://akkartik.name/freewheeling/incompetence.png" target="_blank">
        <img src="http://akkartik.name/freewheeling/incompetence.png" alt="some data on data breaches"/>
      </a>
    </td>
    <td>
      Data breaches <a href="https://privacyrights.org/data-breaches">impact millions of people every year</a>.

      <p>
      If you manage data for others it&#39;s extremely difficult to secure.
      Efforts to secure it add to your costs.
    </p></td>
  </tr>

  <tr>
    <td>
      <p>
        malice
      </p>
      <a href="https://www.telegraph.co.uk/technology/2020/03/30/popular-apps-can-read-phones-clipboard-without-permission" target="_blank">
        <img src="http://akkartik.name/freewheeling/malice.png" alt="headline: how popular apps can read your phone&#39;s clipboard without permission"/>
      </a>
    </td>
    <td>
      Beyond incompetence, services engage in rampant misbehavior.
      <a href="https://www.telegraph.co.uk/technology/2020/03/30/popular-apps-can-read-phones-clipboard-without-permission">This is a headline</a>
      from a couple of years ago. Just about every single major phone app was
      snooping on your clipboard. And this was going on for years before these
      researchers noticed.

      <p>
      Since they noticed, Apple plugged this loophole. But what else are apps
      up to, and what current misbehavior will we find out about this year or
      the next?
    </p></td>
  </tr>

  <tr>
    <td>
      <p>
        slow
      </p>
      <a href="https://idlewords.com/talks/website_obesity.htm" target="_blank">
        <img src="http://akkartik.name/freewheeling/obesity-crisis.png" alt="headline: the website obesity crisis by Maciej Cegłowski"/>
      </a>
    </td>
    <td>
      Ok, so software providers fail to keep us secure and also do shady
      stuff. What do we get for this? Are they at least effective at providing
      the service they advertise? <a href="https://idlewords.com/talks/website_obesity.htm">Here is a talk</a>
      about how inefficient just about every single mainstream website is. Our
      computers pay a tax on every page we read.
    </td>
  </tr>

  <tr>
    <td>
      <p>
        slow
      </p>
      <a href="https://danluu.com/input-lag" target="_blank">
        <img src="http://akkartik.name/freewheeling/input-lag.png" alt="screenshot: computer latency by Dan Luu"/>
      </a>
    </td>
    <td>
      But maybe that&#39;s just websites that have to go out over the internet.
      What about native apps? <a href="https://danluu.com/input-lag">Here is a study</a>
      showing that a computer from 2015 is 2-5 times slower than an Apple 2e
      from 1986 just at reading a keystroke and displaying it on screen.
    </td>
  </tr>

  <tr>
    <td>
      <p>
        all is not well with computers
      </p>
      <ul>
        <li> they grow increasingly complex and expensive
        </li><li> they grow untrustworthy as they grow complex
        </li><li> they slow down as they grow complex
      </li></ul>
    </td>
    <td>
      These are the fairly fundamental problems I see. They&#39;re not new or
      insightful, lots of people have said all this. What do we do about it?

    </td>
  </tr>

  <tr>
    <td>
      <p>
        depend less on software
      </p>
    </td>
    <td>
      My first resolution is just to bring less software into my life. It is
      still early days, we don&#39;t really understand computers yet. It&#39;s
      important to be clear-eyed about the risks they bring with them, and to
      think about computers primarily as a <em>liability</em> rather than an
      asset.

    </td>
  </tr>

  <tr>
    <td>
      <p>
        depend on services with dozens of users
      </p>
      <a href="https://gwern.net/doc/technology/2004-03-30-shirky-situatedsoftware.html" target="_blank">
        <img src="http://akkartik.name/freewheeling/situated-software.png" alt="Situated Software by Clay Shirky"/>
      </a>
    </td>
    <td>
      But, unfortunately, I came to this realization too late. Computers have
      already eaten the world. Today I need to use computers to conduct
      commerce, interact with my government, and to talk to my family and
      friends. What to do about this?

      <p>
      One coping mechanism is an idea from almost 20 years ago called
      <a href="https://gwern.net/doc/technology/2004-03-30-shirky-situatedsoftware.html">situated software</a>.
      This is software with a few users who know each other and share a social
      context or <em>situation</em>. The idea is analogous to local
      government: services with few stakeholders are often better able to meet
      the needs of their stakeholders, particularly when everyone knows
      everyone and there&#39;s a certain level of social accountability.

      </p><p>
      This isn&#39;t always possible. Sometimes we have to use software with
      millions of users. But I think it helps to rely on small-scale tools as
      much as possible, and to question tools for large crowds of people at
      every opportunity.

    </p></td>
  </tr>

  <tr>
    <td>
      <p>
        depend on the right tools
      </p>
      <p><a href="https://xkcd.com/2347" target="_blank">
          <img src="http://akkartik.name/freewheeling/dependency_2x.png" alt="Dependency by Randall Munroe"/>
        </a>
      </p>
    </td>
    <td>
      The idea of situated software has been seeing a renaissance recently,
      and there is growing awareness of the value it brings. However, I think
      we don&#39;t yet appreciate the implications of this idea at all levels of
      activity around computers.

      <p>
      As a programmer, I&#39;ve tried multiple times in the past decade to create
      services just for myself and a few friends. Each of them has fallen away
      after a year or two. And a big reason for that was the burden of keeping
      up with updates for all the tools they depend on.

      </p><p>
      It took me a while to realize the underlying issue: I was using tools
      that themselves are catering to non-situated software. They assume that
      it&#39;s worth someone&#39;s time to keep up with updates every month or two.
      But situated software doesn&#39;t have those kinds of surpluses. It requires
      programs to just work once built, with little maintenance.

    </p></td>
  </tr>

  <tr>
    <td>
      <a href="https://www.lua.org" target="_blank">
        <img src="http://akkartik.name/freewheeling/lua.png" alt="screenshot: lua.org"/>
      </a>
    </td>
    <td>
      Last year I switched to something new. <a href="https://www.lua.org">This is the Lua programming language.</a>
      It&#39;s implemented in just 12k LoC, it&#39;s extremely easy to build from
      source and it&#39;s quite fast. It&#39;s not as popular as Javascript or
      Python. As a result, it doesn&#39;t tend to get used in products of conquest
      that try to be all things to all people.
    </td>
  </tr>

  <tr>
    <td>
      <a href="https://www.lua.org/versions.html" target="_blank">
        <img src="http://akkartik.name/freewheeling/lua-versions.png" alt="screenshot: lua.org versions page"/>
      </a>
    </td>
    <td>
      Another thing I love about it: there&#39;s a widespread culture of using old
      versions. Lua is often embedded in games. Games are a hits-driven
      business like movies. Hits are short-lived. As a result, its less common
      for released games to receive updates. Old games running old versions of
      Lua are common.

      <p>
      I use version 5.1 which came out in 2006.

    </p></td>
  </tr>

  <tr>
    <td>
      <a href="https://love2d.org" target="_blank">
        <img src="http://akkartik.name/freewheeling/love2d.png" alt="screenshot: love2d.org"/>
      </a>
    </td>
    <td>
      This is <a href="https://love2d.org">the LÖVE game engine</a>. It&#39;s
      based on Lua, it&#39;s easy to build, it changes infrequently, and it&#39;s
      surprisingly versatile while providing a tiny set of APIs.

      <p>
      LÖVE allows me to send a zip file with inspectable source code to my
      friends. All they need to run it is a single, reputable 5MB binary.

    </p></td>
  </tr>

  <tr>
    <td>
      <p>
        alternatives
      </p>
    </td>
    <td>
      Now, you don&#39;t <em>have</em> to use Lua and LÖVE. I have friends who use
      Python or Rails or Javascript and are able to manage the overheads of
      upgrading. They do so by being extremely selective about what libraries
      they depend on. This can work, but I think it&#39;s not ideal. These
      languages foster a culture of depending on lots of libraries, and those
      libraries put out frequent updates. If you use these languages, you have
      to spend some energy espousing your values to collaborators and users,
      so they are parsimonious with libraries and depend on the right
      libraries. It requires constant discipline. With Lua and LÖVE the
      community shares these values and this discipline.

    </td>
  </tr>

  <tr>
    <td>
      <p>
        forks/examples
      </p>
      <a href="http://akkartik.name/freewheeling/forks.png" target="_blank">
        <img src="http://akkartik.name/freewheeling/forks.png" alt="a map of my forks"/>
      </a>
    </td>
    <td>
      What can I do with this platform? A language that doesn&#39;t try to be all
      things to all people and tends to leave copies of itself embedded in
      older games is fertile soil for <em>forking</em>. Every new game is an
      opportunity to rethink old ideas, to shed some complexity. This culture
      has had an effect on me even though I don&#39;t build games. I build little
      apps for my own life, and when I need something new, some of the time I
      now copy an existing program and permit the two copies to diverge.

      <p>
      This picture shows a family tree of sorts for the apps I built over the
      past year. I organized the tree roughly by complexity from left to
      right. And the lines trace heredity from top to bottom. Look for this
      image over the rest of the talk as I focus on individual apps to
      illustrate values I care about and concerns I can jettison entirely.

    </p></td>
  </tr>

  <tr>
    <td>
      <a href="http://akkartik.name/freewheeling/gravity.png" target="_blank">
        <img src="http://akkartik.name/freewheeling/gravity.png" alt="screenshot: editing a file with a drawing using lines.love"/>
      </a>
      <a href="http://akkartik.name/freewheeling/forks-lines.png" target="_blank">
        <img src="http://akkartik.name/freewheeling/forks-lines.t.png" alt="lines.love on the map of forks"/>
      </a>
    </td>
    <td>
      The app that started it all was
      <a href="http://akkartik.name/lines.html">a plain-text editor that lets
      me draw little line drawings in the middle of text</a>. I find it very
      useful. Definitely talk to me if it or any of my other programs sounds
      interesting. I want to support anyone interested in using it or hacking
      on it.

      <p>
      When I show it to other programmers, often the first question I get is
      about what the file format for drawings is, and how to get other editors
      to support that file format. But does it make sense to so privilege
      interoperability? You have a tool to draw pictures as you write. There
      are situations where it can be useful, even if nobody else can read it.
      Trying to stay close to other people and tools makes things more complex
      and less supple. A tiny, open-source tool that is easy to run and works
      with a simple file format allows me (and you) to focus on the writing
      experience without precluding others from taking on additional concerns.

    </p></td>
  </tr>

  <tr>
    <td>
      <p>
        values
      </p>
      <ul>
        <li> no requirements
      </li></ul>
    </td>
    <td>

      <p>
      This is an example of keeping requirements negotiable. We programmers
      have a tendency to start with a germ of a neat idea and, in a
      <em>microsecond</em>, often so fast we&#39;re not even conscious of the
      transition, pile on a bunch of requirements to it, just because other
      things like it satisfy those requirements.

    </p></td>
  </tr>

  <tr>
    <td>
      <p>
        values
      </p>
      <ul>
        <li> no requirements
        </li><li> <b>wabi-sabi</b>
      </li></ul>
    </td>
    <td>

      Requirements often stem from unconscious acculturation, so it&#39;s worth
      coming up with strategies to question assumptions. One hack I&#39;ve found
      useful is to stop trying to seem “professional”.

      <p>
      I remember when I started out programming, I wanted my programs to look
      “professional,” like the programs other “real”
      programmers made. This desire is the devil. It&#39;s taken me 20 years as a
      professional programmer to realize what matters is what it
      <em>does</em>, for your specific situation. In practice, seeming
      professional is often a way to end up with a pile of stuff you don&#39;t
      need. All it does is slow you down.

    </p></td>
  </tr>

  <tr>
    <td>
      <p>
        values
      </p>
      <ul>
        <li> no requirements
        </li><li> wabi-sabi
        </li><li> <b>no compatibility</b>
      </li></ul>
    </td>
    <td>

      One particularly egregious requirement we unthinkingly take on is
      backwards compatibility. Backwards compatibility is of huge strategic
      importance if you&#39;re Intel and trying to sell a lot of chips. But it&#39;s
      also easy to end up depending on a million lines of code just to avoid
      writing a thousand.

      <p>
      Deciding when and how an organization should break compatibility is a
      thorny problem. But fortunately we&#39;re not concerned with organizations
      here. When we&#39;re just individuals creating for other individuals, asking
      each other to make small changes just isn&#39;t that big a deal.

    </p></td>
  </tr>

  <tr>
    <td>
        <video controls="">
          <source src="/freewheeling/broadsheet.webm" type="video/webm"/>
          Your browser does not support the video tag.
        </video>
        <a href="http://akkartik.name/freewheeling/forks-broadsheet.png" target="_blank">
          <img src="http://akkartik.name/freewheeling/forks-broadsheet.t.png" alt="broadsheet.love on the map of forks"/>
        </a>
    </td>
    <td>
      <a href="http://akkartik.name/freewheeling/https://git.sr.ht/~akkartik/broadsheet.love">Here&#39;s another
      of my forks.</a> This one&#39;s not an editor, just a viewer. Its only
      reason for existence is to use all available width to display text in a
      readable way. That&#39;s it. It&#39;s a very simple thing to build, just 100
      lines once you have an editor, and yet it&#39;s something I&#39;ve never seen
      other programs do. I&#39;m sick of overly wide lines of text and oceans of
      wasted whitespace. Now I can have dense but readable text on screen.

    </td>
  </tr>

  <tr>
    <td>
      <p>
        values
      </p>
      <ul>
        <li> no requirements
        </li><li> wabi-sabi
        </li><li> no compatibility
        </li><li> <b>avoid disagreements by forking</b>
      </li></ul>
    </td>
    <td>

      We programmers have long had an ideal of building programs that do one
      thing and do it well. But we have a really hard time keeping such
      programs from accreting features and complexity over time. I think one
      essential requirement for programs that do a single thing well is to not
      tie yourself too tightly with what other people want. It&#39;s easy for two
      people to want slightly different things, and a program that tries to
      cover both is no longer doing one thing. Rinse and repeat, and you end
      up with <a href="http://harmful.cat-v.org/cat-v">programs
      with hundreds of commandline flags</a> or preferences. Or worse,
      <a href="https://arstechnica.com/information-technology/2011/04/ars-reviews-gnome-30-a-shiny-new-ornament-for-your-linux-lawn/2/">someone
      deciding for everyone, whose preferred settings should get taken
      out</a>. Just say no. Build simple things, and if others want to do
      something slightly different, well we already have a solution: fork!

    </td>
  </tr>

  <tr>
    <td>
      <video controls="">
        <source src="/freewheeling/drawing.webm" type="video/webm"/>
        Your browser does not support the video tag.
      </video>
      <a href="http://akkartik.name/freewheeling/forks-lines.png" target="_blank">
        <img src="http://akkartik.name/freewheeling/forks-lines.t.png" alt="lines.love on the map of forks"/>
      </a>
    </td>
    <td>

      Here&#39;s how I draw pictures in my text editor. One thing to notice is
      that there are no menus, dialogs or conventional UI elements. I&#39;ve been
      trying to mimic the feel of paper and pen. I want to be able to draw at
      a moment&#39;s notice, but I don&#39;t want any <em>reminders</em> that I could
      draw. I don&#39;t want any widgets constantly on screen just for the moment
      when I might start drawing.

    </td>
  </tr>

  <tr>
    <td>
      <p>
        values
      </p>
      <ul>
        <li> no requirements
        </li><li> wabi-sabi
        </li><li> no compatibility
        </li><li> avoid disagreements by forking
        </li><li> <b>limit features per fork</b>
      </li></ul>
    </td>
    <td>

      Now, I likely don&#39;t know what I&#39;m doing. I&#39;ve only been drawing pixels
      for a year now, I&#39;m not a UX designer. But I notice that menus grow over
      time, and the trend doesn&#39;t often come with great UX.

      <p>
      Our conventional UI idioms were created in the context of organizations.
      Menus and toolbars are at least partly scalable ways to pack lots of
      features in, to be all things to all people. Situated software doesn&#39;t
      need menus and toolbars.

    </p></td>
  </tr>

  <tr>
    <td>
      <a href="http://akkartik.name/freewheeling/set-up-dev-environment.png" target="_blank">
        <img src="http://akkartik.name/freewheeling/set-up-dev-environment.png" alt="meme: setup my dev environment"/>
      </a>
    </td>
    <td>
      Let&#39;s set aside app features and look at how we might make changes to
      these apps. It&#39;s distressingly common to need complicated tools to
      modify an app. We&#39;d like to avoid requiring any such setup.
    </td>
  </tr>

  <tr>
    <td>
      <video controls="">
        <source src="/freewheeling/driver.webm" type="video/webm"/>
        Your browser does not support the video tag.
      </video>
      <a href="http://akkartik.name/freewheeling/forks-driver.png" target="_blank">
        <img src="http://akkartik.name/freewheeling/forks-driver.t.png" alt="driver.love on the map of forks"/>
      </a>
    </td>
    <td>

      To modify any of my LÖVE apps you need just a second LÖVE app. Run the
      same 5MB LÖVE binary, just on a different 5k lines of Lua, mostly the
      same as my editor, just tweaked in a few ways, and now you can make
      changes to any of my apps as they run, without having to restart them.

      <p>
      Teaching a new LÖVE app to listen for commands from the editor takes 250
      LoC.

    </p></td>
  </tr>

  <tr>
    <td>
      <p>
        values
      </p>
      <ul>
        <li> no requirements
        </li><li> wabi-sabi
        </li><li> no compatibility
        </li><li> avoid disagreements by forking
        </li><li> limit features per fork
        </li><li> <b>reward curiosity</b>
      </li></ul>
    </td>
    <td>

      It&#39;s not enough that the sources are available. “Open” is a
      spectrum, and most open software today is too hard to build, so we leave
      the build process to a priest class, and the priests accumulate power
      over time. What if there was zero accidental complexity to modifying a
      app, and all you had to focus on was understanding how it worked?

    </td>
  </tr>


  <tr>
    <td>
      <p>
        values
      </p>
      <ul>
        <li> no requirements
        </li><li> wabi-sabi
        </li><li> no compatibility
        </li><li> avoid disagreements by forking
        </li><li> limit features per fork
        </li><li> reward curiosity
        </li><li> <b>just small apps (for now)</b>
      </li></ul>
    </td>
    <td>

      My editing environment doesn&#39;t have find-and-replace yet. I haven&#39;t felt
      much need for it, which is surprising because I used to use it all the
      time. I recently realized why: small programs just tend to need less
      bulk replacement.

      <p>
      There are many features like this that my environment lacks at the
      moment. Some of them I&#39;ll get to, some I may never add.

      </p><p>
      There will absolutely be programs that are difficult to create this way,
      but that&#39;s ok.

    </p></td>
  </tr>

  <tr>
    <td>
      <video controls="">
        <source src="/freewheeling/luaML.webm" type="video/webm"/>
        Your browser does not support the video tag.
      </video>
      <a href="http://akkartik.name/freewheeling/forks-luaML.png" target="_blank">
        <img src="http://akkartik.name/freewheeling/forks-luaML.t.png" alt="luaML.love on the map of forks"/>
      </a>
    </td>
    <td>

      I&#39;ve surprised myself a couple of times when a seemingly complex
      program turns out to have a simple core.
      <a href="https://git.sr.ht/~akkartik/luaML.love">This</a> is a simple
      DOM model I wrote in 50 lines of code. It doesn&#39;t support 99.9% of CSS.
      It&#39;s just a simple way to specify grid layouts. Throw in an infinite 2D
      surface with support for panning and zooming, and it requires 350 LoC.

    </td>
  </tr>

  <tr>
    <td>
      <video controls="">
        <source src="/freewheeling/driver2.webm" type="video/webm"/>
        Your browser does not support the video tag.
      </video>
      <a href="http://akkartik.name/freewheeling/forks-driver.png" target="_blank">
        <img src="http://akkartik.name/freewheeling/forks-driver.t.png" alt="driver.love on the map of forks"/>
      </a>
    </td>
    <td>

      Once I built it, it was easy to include in <a href="https://git.sr.ht/~akkartik/driver.love">my editing app</a>.
      Here you can see my programming environment with the ability to view
      multiple definitions at once. This is something I&#39;ve wanted for a long
      time, to view not just arbitrary files but arbitrary
      <em>definitions</em> side by side.

    </td>
  </tr>

  <tr>
    <td>
      <video controls="">
        <source src="/freewheeling/codemap.webm" type="video/webm"/>
        Your browser does not support the video tag.
      </video>
      <a href="http://akkartik.name/freewheeling/forks-driver.png" target="_blank">
        <img src="http://akkartik.name/freewheeling/forks-driver.t.png" alt="driver.love on the map of forks"/>
      </a>
    </td>
    <td>

      When I first started working on this environment I had a hazy desire for
      multiple views. However, I found myself gravitating towards a style
      where I positioned definitions once and never moved them thereafter. It
      was valuable to give all the code for my apps a <em>place</em>, so I
      always have a sense of space when I make changes to it. The computer
      contains my memory palace.

    </td>
  </tr>

  <tr>
    <td>
      <video controls="">
        <source src="/freewheeling/montage.webm" type="video/webm"/>
        Your browser does not support the video tag.
      </video>
    </td>
    <td>

      I&#39;m a little surprised at this point, by how far I&#39;ve been able to take
      what I initially considered just a coping strategy. My initial plan had
      been to create clones of apps for myself and take out lots of features.
      It felt like eating my vegetables. I didn&#39;t expect to find myself
      wondering what a web browser for memory palaces might look like. Small
      apps leave more headroom for design exploration. What new types of
      experience might <em>you</em> create if you undertook such a journey?
      Focus on keeping software easy to try out, easy to modify and easy to
      share.

    </td>
  </tr>

  <tr>
    <td>
      <p>
        avoid crowds
      </p>
      Prefer software:
      <ul>
        <li> with thousands rather than millions of users
        </li><li> that seldom requires updates
        </li><li> that spawns lots of forks
        </li><li> that is easy to modify
        </li><li> that <em>you</em> can modify
      </li></ul>

      <a href="https://git.sr.ht/~akkartik/driver.love">https://git.sr.ht/~akkartik/driver.love</a>
    </td>
    <td>
      The final message I want to leave you with is: avoid crowds. We can each
      have huge quantities of freedom inside our own devices on this crowded
      planet. Our freedoms only run into frictions when we leave our devices.
      The less often we need to do that, the happier we&#39;ll be. It doesn&#39;t
      solve everything, but it helps. A lot.

      <p>
      There isn&#39;t a whole lot of software out there that follows these
      principles. I expect I have a lot more to learn on this journey. If
      you&#39;re interested in joining me, I&#39;d love to help ease your way along
      however you need. My <em>freewheeling apps</em> are freely available and
      designed for the long term, and I&#39;m always looking for ways to make them
      useful to others.

    </p></td>
  </tr>

</tbody></div><p>
Links to all the apps/forks I showed above. Click on any node in this image to
see its repo and Readme. (Unfortunately HTML doesn&#39;t support resizing such an
image.)

</p></div>
  </body>
</html>
