<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ratfactor.com/cards/asm-data-in-text">Original</a>
    <h1>i386 Assembly Language trick for storing data in .text</h1>
    
    <div id="readability-page-1" class="page"><p>Don’t want a big old bloated multi-kilobyte executable with a data segment, but you do need to store some data?</p><p>One of my biggest challenges has been storing strings in a position-independent
way. I’ve considered a Global Offset Table (GOT), but it seems like <strong>way</strong> more
machinery than I need. And though I went well
<a href="https://ratfactor.com/repos/mez/">out of my way</a>
to figure out how to make multi-segment ELF executables, I just couldn’t bear
to export a &#34;huge&#34; 2kb+ padded file with the proper alignment.</p><p>So I was determined to store strings in a Forth-style manner - embedding them with the executable code and jumping over them.</p><p>To do this was going to be a lot of painful trial-and-error to get the exact right opcodes compiled in place to push the address of the string on the stack followed by a <code>jmp</code> instruction to hop over the string (gotta know the length first, then come back and write the instruction).</p><p>The thing that makes this <em>extra</em> hard is that 32-bit i386 doesn’t have an instruction for getting the value of the instruction pointer (EIP) directly. (x86_64 added this later.)</p><p>But I realized something: there <em>is</em> an instruction that pushes the following address on the stack and then jumps to a location. It’s <code>call</code>.</p><p>So I made a little stand-alone NASM assembly &#34;Hello world&#34; test as a proof of concept. I realized I can even get the length of the string by subtracting the offset of my call’d label from the return address:</p><div>
<div>
<pre>global _start
_start:

    ; call pushes the next address on the stack
    ; so we could &#34;return&#34; there
    call print

    ; this gets jumped over, but we&#39;ve got the address!
    db `Hello World!\n`

print:
    ; Print with Linux SYS_WRITE
    ; pop the address from the stack to ecx
    pop ecx        ; string address
    mov edx, print ; label address
    sub edx, ecx   ; length of string!
    mov     ebx, 1 ; STDOUT
    mov     eax, 4 ; SYS_WRITE
    int     80h

    ; Exit with Linux SYS_EXIT
    mov ebx, 0 ; return status
    mov eax, 1 ; SYS_EXIT
    int 80h    ; kernel syscall</pre>
</div>
</div><p>Without a data segment, this executable is truly tiny, just 532 bytes.</p><p>Of course. :-)</p><p>I’m sure this trick is well-known and has a name and everything, but it’s new
to me.</p><p>I was really pleased with how nice and neat it turned out and it’s definitely
going straight into Meow5, which should allow me to finally finish that
project.</p></div>
  </body>
</html>
