<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://avestura.dev/blog/creating-a-git-commit-the-hard-way">Original</a>
    <h1>Creating a Git Commit: The Hard Way</h1>
    
    <div id="readability-page-1" class="page"><div><p>Many of us create a few Git commits daily, either through GUI tools or
the command line. It can be as simple as following these steps:</p>

<p>Here, we&#39;ve used Git high-level commands (also known as Porcelain commands) like
<code>git add</code>, and <code>git commit</code>.
However, there is another group of Git commands, known as
<a target="_blank" rel="noopener noreferrer" href="https://git-scm.com/book/en/v2/Git-Internals-Plumbing-and-Porcelain">Plumbing commands</a>,
that handle the low-level operations.</p>
<p>In this blog post, we want to create a Git commit using these low-level operations, and
not the <code>git commit</code> command.</p>
<p>Before diving into low-level commands and crafting a Git commit, we need to understand
a few Git basics. Let&#39;s start with the states of a file in Git.</p>
<h2 id="the-basics"><a href="#the-basics" aria-hidden="true" tabindex="-1"><span></span></a>The Basics</h2>
<p>Files in Git can be in one of these three states:</p>
<ol>
<li><strong>Modified</strong>: The file has changed but has not been committed to the Git database.</li>
<li><strong>Staged</strong>: The current version of the modified file is staged to be included in the next commit.</li>
<li><strong>Committed</strong>: Data is safely stored in the Git database.</li>
</ol>
<p>Similarly, A Git project has three sections:</p>
<ol>
<li><strong>Working Directory</strong>: These are the files that are pulled out of the Git database so you can easily modify them.
<strong>Modified</strong> files reside here.</li>
<li><strong>Staging Area (Index)</strong>: A file inside the <code>.git</code> directory that holds the information about what will go into your next commit.
<strong>Staged</strong> files reside here.</li>
<li><strong>Git directory</strong>: It&#39;s where Git stores all the objects and metadata of your repository. This
directory is essentially what you copy when you clone a git project. <strong>Committed</strong> files reside here.</li>
</ol>
<p><img src="https://ntietz.com/static/images/posts/git/git-sections.svg" alt="Git Sections"/></p><p>Now that we understand the different sections of a Git project, we
need to know what exactly a Git commit is.</p>
<h2 id="git-objects-commits-trees-and-blobs"><a href="#git-objects-commits-trees-and-blobs" aria-hidden="true" tabindex="-1"><span></span></a>Git Objects: Commits, Trees, and Blobs</h2>
<p>A git <code>commit</code> is a git <code>object</code>. There are several types of objects in git,
including <code>blob</code>, <code>tree</code>, and <code>commit</code> objects.
These objects can be found inside the <code>.git/objects</code> folder.</p>
<p>If you look inside that folder, you&#39;ll see that everything is stored using a
SHA-1 hash of the object&#39;s content rather than file names. This approach helps Git
track all changes to the content of a file or directory and makes it impossible to
alter the content without Git detecting it.</p>
<h3 id="blob-objects"><a href="#blob-objects" aria-hidden="true" tabindex="-1"><span></span></a>Blob Objects</h3>
<p>We can store any blob (binary file) inside Git&#39;s database, making it a powerful
content-addressable file system with a version-control system built on top of it.
This can easily be done using one of Git&#39;s plumbing commands called <code>git hash-object</code>:</p>

<p>The <code>-w</code> flag tells Git not only to return the hash of the content passed to it via
standard input (<code>--stdin</code>) but also to store that content inside the <code>.git/objects</code>
folder as a blob. Essentially, Git writes a binary file with this content:</p>

<p>In the &#34;hello world&#34; case, the content of the blob file becomes: <code>blob 11\0hello world</code>.
Git then calculates the SHA-1 hash of this content and stores the file using the hash
as the filename.</p>
<h3 id="tree-objects"><a href="#tree-objects" aria-hidden="true" tabindex="-1"><span></span></a>Tree Objects</h3>
<p>Tree objects allow us to store file names for one or more files. You can think of <code>tree</code>
objects as representing directories, while <code>blob</code> objects represent file contents.
Essentially, a <code>tree</code> is a collection of references to blobs along with their file names,
or other trees.</p>
<p><img src="https://ntietz.com/static/images/posts/git/git-tree.svg" alt="Git Tree"/></p><p>This is the content of the tree object shown in the image above:</p>

<h3 id="commit-objects"><a href="#commit-objects" aria-hidden="true" tabindex="-1"><span></span></a>Commit Objects</h3>
<p>A Git commit is essentially an object that contains a reference to a Git tree, along
with information such as who made the changes (author), when they were made, and why
they were made (commit message). A commit can also have zero parents (initial commit),
one parent (normal commits), or multiple parents (merge commits).</p>
<p>This is the content of an example commit object:</p>

<p>Now that we understand <code>blob</code>, <code>tree</code>, and <code>commit</code> objects, we can visualize
their relationships. Consider a simple scenario like this:</p>

<p>In this case, a total of four objects are created in Git:</p>
<ul>
<li>1 README <code>blob</code> object</li>
<li>1 LICENSE <code>blob</code> object</li>
<li>1 <code>tree</code> object that contains references to the previous blobs and their names</li>
<li>1 <code>commit</code> object that references the <code>tree</code> and includes the author information</li>
</ul>
<p>If we add another commit, the new commit will have a <code>parent</code> metadata, pointing to the
inital commit:</p>
<p><img src="https://ntietz.com/static/images/posts/git/git-commit.svg" alt="Git Commit"/></p><h2 id="craft-a-commit-the-hard-way"><a href="#craft-a-commit-the-hard-way" aria-hidden="true" tabindex="-1"><span></span></a>Craft a Commit, the hard way</h2>
<p>Now that we understand the Git objects related to a commit and their relationships, we
can easily create a commit using low-level Git plumbing commands.</p>
<p>First of all, we need to initalize a new repository:</p>

<p>Now we have to create a <code>blob</code> object. As we already know, we can do this using the <code>hash-object</code> command:</p>

<p>We have stored our <code>blob</code> object and know its hash. Now we need to create a <code>tree</code> object.
Git normally uses the staging area (index) to create tree objects. We can create an index with
a single entry (our previously created blob) using the <code>git update-index</code> command:</p>

<p>Explanation of the above command:</p>
<ul>
<li><code>--add</code> adds the file to the index, as it isnâ€™t already there.</li>
<li><code>--cacheinfo &lt;mode&gt; &lt;object&gt; &lt;path&gt;</code> is used because the file is not in our directory, but inside the git&#39;s database<!-- -->
<ul>
<li>The number represents the file mode. <code>100644</code> means it&#39;s a normal file. Other modes include executable files and symbolic links.</li>
<li><code>6b59acb69a04903bfa9189e3c482fb57f77393f9</code> is the hash of the <code>blob</code></li>
<li><code>myfile.txt</code> is the name of the file</li>
</ul>
</li>
</ul>
<p>Now that we have the index file ready, we can create a <code>tree</code> object from it using <code>write-tree</code>:</p>

<p>Git now outputs the hash of the <code>tree</code> object.
You can check its content using the <code>cat-file</code> command:</p>

<p>Now that our <code>tree</code> object is ready and connected to the underlying <code>blob</code>, we can
simply create the <code>commit</code> object using the <code>git commit-tree</code> command:</p>


<p>Finally, we have created a commit without using any of the high-level git commands (e.g. <code>git commit</code>).
You can view the content of the newly created commit:</p>

<p>You can also view the log of the commit using <code>git log</code>:</p>

<p>If you want to see the files in your working directory, you can reset your
current branch to point to the newly created commit using <code>git reset</code>:</p>

<p>ðŸ¥³ Hooray! We have crafted our commit and seen it in our working directory!</p>
<h2 id="conclusion"><a href="#conclusion" aria-hidden="true" tabindex="-1"><span></span></a>Conclusion</h2>
<p>Git has two sets of commands: Porcelain (high-level commands) such as <code>git add</code>,
<code>git commit</code>, <code>git remote</code>, etc., and low-level Plumbing commands, which are used by
higher-level commands to manipulate Git objects and references.
We used these low-level commands to craft a commit by creating its underlying <code>tree</code> and <code>blob</code>
objects.</p>
<h2 id="references"><a href="#references" aria-hidden="true" tabindex="-1"><span></span></a>References</h2>
<p>Resources I&#39;ve used to write this blog post:</p>
<ul>
<li>Chacon, S., &amp; Straub, B. (2014). Pro Git (2nd ed.). Apress.</li>
</ul></div></div>
  </body>
</html>
