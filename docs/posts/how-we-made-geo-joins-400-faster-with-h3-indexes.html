<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://floedb.ai/blog/how-we-made-geo-joins-400-faster-with-h3-indexes">Original</a>
    <h1>How we made geo joins 400× faster with H3 indexes</h1>
    
    <div id="readability-page-1" class="page"><div id="hs_cos_wrapper_post_body" data-hs-cos-general-type="meta_field" data-hs-cos-type="rich_text"><p>Geo joins look innocent:</p>
<!--more-->
<pre><code>SELECT *
FROM A
JOIN B
  ON ST_Intersects(A.geo, B.geo);
</code></pre>
<p>…but at scale they can become the query that ruins your day.</p>
<p>Geospatial functions are expensive, and they often force a loop join that starts to <em>feel</em> quadratic as your tables grow.</p>
<p>The core idea in this post is simple: we’ll see how Floe automatically rewrites this kind of query and takes advantage of H3 indexes for dramatic speedup.</p>
<h2>What’s a geo join</h2>
<p>A <strong>geo join</strong> is any join whose <code>ON</code> clause is a spatial predicate:</p>
<ul>
<li><code>ST_Intersects</code></li>
<li><code>ST_Covers</code></li>
<li><code>ST_DWithin</code></li>
<li>...</li>
</ul>
<p>A canonical example:</p>
<pre><code>SELECT *
FROM A
JOIN B
  ON ST_Intersects(A.geo, B.geo);
</code></pre>
<h3>Why it hurts at scale</h3>
<p>Modern databases make joins fast by turning them into <strong>hash joins over keys</strong>. If you can hash-partition both inputs on the join key, each worker compares only its share instead of comparing everything to everything. If the data is nicely distributed, this decreases the complexity from quadratic to linear.</p>
<p>Spatial predicates don’t give you a clean join key. So you end up in a terrible situation:</p>
<ul>
<li>you have to compare every value with each other (the quadratic complexity)</li>
<li>plus an expensive predicate on each candidate pair</li>
</ul>
<p>That’s the situation we want to escape.</p>
<hr/>
<h2>Meet H3</h2>
<p><a href="https://h3geo.org/">H3</a> (originally from Uber) partitions the Earth into a hierarchy of mostly hexagonal cells.</p>
<p><img src="https://floedb.ai/hs-fs/hubfs/AI-Generated%20Media/Images/geo_france_to_cell.png?width=896&amp;height=681&amp;name=geo_france_to_cell.png" width="896" height="681" loading="lazy" alt="geo_france_to_cell" srcset="https://floedb.ai/hs-fs/hubfs/AI-Generated%20Media/Images/geo_france_to_cell.png?width=448&amp;height=341&amp;name=geo_france_to_cell.png 448w, https://floedb.ai/hs-fs/hubfs/AI-Generated%20Media/Images/geo_france_to_cell.png?width=896&amp;height=681&amp;name=geo_france_to_cell.png 896w, https://floedb.ai/hs-fs/hubfs/AI-Generated%20Media/Images/geo_france_to_cell.png?width=1344&amp;height=1022&amp;name=geo_france_to_cell.png 1344w, https://floedb.ai/hs-fs/hubfs/AI-Generated%20Media/Images/geo_france_to_cell.png?width=1792&amp;height=1362&amp;name=geo_france_to_cell.png 1792w, https://floedb.ai/hs-fs/hubfs/AI-Generated%20Media/Images/geo_france_to_cell.png?width=2240&amp;height=1703&amp;name=geo_france_to_cell.png 2240w, https://floedb.ai/hs-fs/hubfs/AI-Generated%20Media/Images/geo_france_to_cell.png?width=2688&amp;height=2043&amp;name=geo_france_to_cell.png 2688w" sizes="(max-width: 896px) 100vw, 896px"/></p>
<p>Two properties matter for us:</p>
<ul>
<li><strong>Hierarchical resolution:</strong> you choose a resolution from coarse to fine.</li>
<li><strong>Compact keys:</strong> each cell is a <code>BIGINT</code>, so it behaves like a normal join key: hashable, sortable, distributable.</li>
</ul>
<p>Most importantly, it lets us represent a geography as a <strong>set of cell IDs</strong> that covers it.</p>
<blockquote>
<p>If two shapes intersect, then their H3 cover sets share at least one cell.</p>
</blockquote>
<p>That gives us a path to rewrite <em>“do these shapes intersect?”</em> into <em>“do these two sets overlap?”</em> which a database can execute as a plain equi-join.</p>
<p><img src="https://floedb.ai/hs-fs/hubfs/AI-Generated%20Media/Images/geo_set_ops.png?width=767&amp;height=745&amp;name=geo_set_ops.png" width="767" height="745" loading="lazy" alt="geo_set_ops" srcset="https://floedb.ai/hs-fs/hubfs/AI-Generated%20Media/Images/geo_set_ops.png?width=384&amp;height=373&amp;name=geo_set_ops.png 384w, https://floedb.ai/hs-fs/hubfs/AI-Generated%20Media/Images/geo_set_ops.png?width=767&amp;height=745&amp;name=geo_set_ops.png 767w, https://floedb.ai/hs-fs/hubfs/AI-Generated%20Media/Images/geo_set_ops.png?width=1151&amp;height=1118&amp;name=geo_set_ops.png 1151w, https://floedb.ai/hs-fs/hubfs/AI-Generated%20Media/Images/geo_set_ops.png?width=1534&amp;height=1490&amp;name=geo_set_ops.png 1534w, https://floedb.ai/hs-fs/hubfs/AI-Generated%20Media/Images/geo_set_ops.png?width=1918&amp;height=1863&amp;name=geo_set_ops.png 1918w, https://floedb.ai/hs-fs/hubfs/AI-Generated%20Media/Images/geo_set_ops.png?width=2301&amp;height=2235&amp;name=geo_set_ops.png 2301w" sizes="(max-width: 767px) 100vw, 767px"/></p>
<h3>Conservative approximation (false positives only)</h3>
<p>Cell coverage is an <strong>approximation</strong> of the exact geometry:</p>
<ul>
<li>It’s OK to keep extra candidates (<strong>false positives</strong>): they’ll be removed by the exact predicate.</li>
<li>It’s not OK to miss true matches (<strong>false negatives</strong>): if we drop them in the pre-filter, no later step can recover them.</li>
</ul>
<p>So we generate coverage so it over-approximates the shape (the coverage <em>contains</em> the shape).</p>
<hr/>
<h2>From geography predicate to set-ops</h2>
<h3>The rewrite: exact join → fast filter + exact recheck</h3>
<p>Baseline:</p>
<pre><code>SELECT *
FROM A
JOIN B
  ON ST_Intersects(A.geo, B.geo);
</code></pre>
<p>With H3, the planner inserts a filtering phase:</p>
<ol>
<li>Generate H3 coverage for <code>A</code></li>
<li>Generate H3 coverage for <code>B</code></li>
<li>Join on <code>cell</code> (fast integer equi-join)</li>
<li>Deduplicate candidates (the same pair can match on multiple cells)</li>
<li>Run the exact predicate on candidates only</li>
</ol>
<p>A concrete template:</p>
<pre><code>WITH
  a_cells AS (
    SELECT
      a.id,
      a.geo,
      c.cell
    FROM A a
    JOIN h3_coverage(a.geo, /* resolution */ 3, /* full cover */ true) c
      ON TRUE
  ),
  b_cells AS (
    SELECT
      b.id,
      b.geo,
      c.cell
    FROM B b
    JOIN h3_coverage(b.geo, 3, true) c
      ON TRUE
  ),
  candidates AS (
    SELECT DISTINCT
      a_cells.id  AS a_id,
      a_cells.geo AS a_geo,
      b_cells.id  AS b_id,
      b_cells.geo AS b_geo
    FROM a_cells
    JOIN b_cells USING (cell)
  )
SELECT *
FROM candidates
WHERE ST_Intersects(a_geo, b_geo);
</code></pre>
<h3>What the database gets “for free”</h3>
<p>With this rewrite, the heavy work becomes an equi-join on <code>(cell)</code>:</p>
<ul>
<li>It’s an <strong>integer join</strong> → hashing is cheap.</li>
<li>It’s <strong>naturally distributable</strong> → you can hash-partition on <code>cell</code> across workers.</li>
<li>The expensive predicate becomes a <strong>cleanup step</strong> instead of the main event.</li>
</ul>
<h3>Three questions readers always ask</h3>
<p><strong>“Isn’t that approximate?”</strong> Yes — the H3 step is an approximation used as a pre-filter. Correctness is preserved by the final exact predicate recheck.</p>
<p><strong>“Won’t that create false positives?”</strong> Yes, and that’s expected. The goal is to reduce the candidate set enough that exact checks become cheap.</p>
<p><strong>“How do I pick a resolution?”</strong> Resolution is the tradeoff knob: higher resolution usually reduces false positives but increases the number of cells generated per shape. (We’ll cover how to measure and choose this in the Numbers section later.)</p>
<h3>See the effect</h3>
<p>When a user enters a simple query to join countries with the cities they contain, the planner automatically applies the rewrite:</p>
<!-- markdownlint-disable MD013 -->
<pre><code>EXPLAIN ANALYZE SELECT * FROM world_cities JOIN countries ON ST_Intersects(world_cities.geo, countries.geo);
&gt;&gt;&gt;
Planning time: 2.291 ms
rows_actual    node
     142141    SELECT
     142141    FILTER WHERE ST_INTERSECTS(MAX(MAX(world_cities.geo)), MAX(MAX(countries.geo)))
                 geojoin filtered rows ratio: 99.62%
     199848    GROUP BY (countries.rowunique, world_cities.rowunique)
     199848    DISTRIBUTE ON HASH(world_cities.rowunique),HASH(countries.rowunique))
     199848    GROUP BY PARTIAL (countries.rowunique, world_cities.rowunique)
     224075    INNER HASH JOIN ON (COALESCE(h3_coverage_geodesic.h3_coverage_geodesic , $1 , const )  = COALESCE(h3_coverage_geodesic.h3_coverage_geodesic , $0 , const ) )
     147043    |-DISTRIBUTE ON HASH(COALESCE(h3_coverage_geodesic.h3_coverage_geodesic , $0 , const ) )
     147043    | LEFT OUTER FUNCTION JOIN H3_COVERAGE_GEODESIC(world_cities.geo, 3, t, t) ON true
     147043    | SCAN world_cities
      17223    |-BUILD HASH
      17223      DISTRIBUTE ON HASH(COALESCE(h3_coverage_geodesic.h3_coverage_geodesic , $1 , const ) )
      17223      LEFT OUTER FUNCTION JOIN H3_COVERAGE_GEODESIC(countries.geo, 3, t, t) ON true
        256      SCAN countries

142141 rows returned
Read: 16.92MiB, Distributed: 5.85GiB, Network: 8.00GiB
Database: yellowbrick_test_utf8
Execution time: 1220.118 ms, End time: 2025-12-16 14:00:50
</code></pre>
<!-- markdownlint-enable MD013 -->
<p>Without the rewrite, the join would face ~`256 * 147043 = 37.6 million` country×city pairs.</p>
<p>Instead, we’re doing <code>199848</code> calls to <code>ST_Intersects</code>, of which we keep <code>142141</code> pairs, a 99.6% reduction.</p>
<h2>On-the-fly indexing</h2>
<p>A possible approach is to materialize an index table (<code>row_id → list of H3 cells</code>) and maintain it. This avoids the somewhat expensive step of computing H3 indexes.</p>
<p>We chose a different route: <strong>compute coverage at query time as part of the rewrite</strong></p>
<p>Why it’s practical:</p>
<ul>
<li>Works over <strong>views, CTEs and subqueries</strong>, not just base tables.</li>
<li>Avoids <strong>extra storage</strong> and index maintenance.</li>
<li>Keeps experimentation easy (resolution, coverage mode, predicate type).</li>
</ul>
<p>This makes it easy to play with data cleaning directly in the query:</p>
<pre><code>with cleaned_cities as
    (select distinct st_reduceprecision(geo, 100) geo from world_cities) -- Dedup cities that are less than 100 meters apart
select count(*) from countries join cleaned_cities on st_intersects(countries.geo, cleaned_cities.geo);
</code></pre>
<h2>Numbers</h2>
<p>Let’s look at some numbers.</p>
<p>We’ll use a join between <strong>256 polygons</strong> representing countries and <strong>points</strong> representing world cities:</p>
<pre><code>SELECT *
FROM world_cities
JOIN countries
  ON ST_Intersects(world_cities.geo, countries.geo);
</code></pre>
<p>In this dataset, <code>countries.geo</code> is a polygon or multipolygon with <strong>418 vertices on average</strong>.</p>
<p>We ran these tests on a cluster with <strong>15 workers</strong>, each with a <strong>Xeon E5-2695</strong> (16 cores @ 2.10GHz) and <strong>1 TB of memory</strong>.</p>
<p>First, let’s look at the effect of <strong>H3 resolution</strong>.</p>
<p>Each time we increase the resolution by 1, the average size of a cell decreases by <strong>~6×</strong>.</p>
<ul>
<li><strong>Baseline</strong> is the time the query takes <em>without</em> H3 indexing. (<strong>459 seconds</strong>)</li>
<li><strong>GeoJoin</strong> is the time the query takes with the rewrite.</li>
</ul>
<p>The GeoJoin time follows a <strong>U-shape</strong>:</p>
<ul>
<li>Increasing the resolution improves row rejection.</li>
<li>Increasing it too much makes indexing and the <code>(cell)</code> join too expensive.</li>
</ul>
<p>At best, at <strong>resolution 3</strong>, the geo join takes <strong>1.17 seconds</strong> — a <strong>400×</strong> improvement.</p>
<p>We can also see where the time goes:</p>
<ul>
<li>At low resolution it’s really fast to index both tables — <strong>less than 10% of the time at resolution 2</strong>.</li>
<li>But it increases rapidly after <strong>resolution 4</strong>.</li>
</ul>
<p>And even when we eliminate indexing time, at high resolution there are so many rows in the join that the geo join time starts to increase.</p>
<!-- markdownlint-disable MD013 -->
<table>
<thead>
<tr>
<th>Resolution</th>
<th>Baseline query Time (s)</th>
<th>GeoJoin Time (s)</th>
<th>Speedup</th>
<th>Index countries Time (s)</th>
<th>Index cities Time (s)</th>
<th>Total indexing Time (s)</th>
<th>GeoJoin - Index Time (s)</th>
<th>Index Time / GeoJoin Time</th>
<th>Average Hexagon Area (km2)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>459.7</td>
<td>16.2</td>
<td>28.3</td>
<td>0.2</td>
<td>0.03</td>
<td>0.2</td>
<td>16.0</td>
<td>0.0</td>
<td>4,357,449</td>
</tr>
<tr>
<td>1</td>
<td>459.7</td>
<td>3.0</td>
<td>152.7</td>
<td>0.1</td>
<td>0.0</td>
<td>0.1</td>
<td>2.9</td>
<td>0.0</td>
<td>609,788</td>
</tr>
<tr>
<td>2</td>
<td>459.7</td>
<td>1.4</td>
<td>338.8</td>
<td>0.1</td>
<td>0.0</td>
<td>0.1</td>
<td>1.2</td>
<td>0.1</td>
<td>86,801</td>
</tr>
<tr>
<td>3</td>
<td>459.7</td>
<td>1.1</td>
<td><strong>392.5</strong></td>
<td>0.3</td>
<td>0.0</td>
<td>0.3</td>
<td>0.9</td>
<td><strong>0.3</strong></td>
<td>12,393</td>
</tr>
<tr>
<td>4</td>
<td>459.7</td>
<td>2.2</td>
<td>205.0</td>
<td>1.4</td>
<td>0.0</td>
<td>1.4</td>
<td>0.9</td>
<td>0.6</td>
<td>1,770</td>
</tr>
<tr>
<td>5</td>
<td>459.7</td>
<td>13.2</td>
<td>34.8</td>
<td>8.2</td>
<td>0.0</td>
<td>8.3</td>
<td>4.9</td>
<td>0.6</td>
<td>252</td>
</tr>
</tbody>
</table>
<!-- markdownlint-enable MD013 -->
<p><img src="https://floedb.ai/hs-fs/hubfs/AI-Generated%20Media/Images/geo_bench_res.png?width=857&amp;height=589&amp;name=geo_bench_res.png" width="857" height="589" loading="lazy" alt="geo_bench_res" srcset="https://floedb.ai/hs-fs/hubfs/AI-Generated%20Media/Images/geo_bench_res.png?width=429&amp;height=295&amp;name=geo_bench_res.png 429w, https://floedb.ai/hs-fs/hubfs/AI-Generated%20Media/Images/geo_bench_res.png?width=857&amp;height=589&amp;name=geo_bench_res.png 857w, https://floedb.ai/hs-fs/hubfs/AI-Generated%20Media/Images/geo_bench_res.png?width=1286&amp;height=884&amp;name=geo_bench_res.png 1286w, https://floedb.ai/hs-fs/hubfs/AI-Generated%20Media/Images/geo_bench_res.png?width=1714&amp;height=1178&amp;name=geo_bench_res.png 1714w, https://floedb.ai/hs-fs/hubfs/AI-Generated%20Media/Images/geo_bench_res.png?width=2143&amp;height=1473&amp;name=geo_bench_res.png 2143w, https://floedb.ai/hs-fs/hubfs/AI-Generated%20Media/Images/geo_bench_res.png?width=2571&amp;height=1767&amp;name=geo_bench_res.png 2571w" sizes="(max-width: 857px) 100vw, 857px"/></p>
<h2>Conclusion</h2>
<p>By rewriting spatial predicates into set operations on H3 cells, we let the database do what it’s best at: parallel hash joins on compact keys. This leads to a dramatic speedup of geography operations.</p>
<p>We could improve these results even more by avoiding calls to the geography predicate in trivial-true cases. For instance, when a point lies well inside a large polygon.</p></div></div>
  </body>
</html>
